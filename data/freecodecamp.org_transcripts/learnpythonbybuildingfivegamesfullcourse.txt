00:00 - Welcome to this learn Python through game
development course. In this course, we've
00:05 - compiled the five great game programming tutorials,
all in Python. To help you learn Python. through
00:12 - creating games, you will learn how to create
Pong snake Connect for Tetris. And finally,
00:20 - a simple multiplayer game. This course is
all about learning through doing. If you want
00:26 - to learn Python syntax directly, check out
our other big Python course though there's
00:31 - a link up here or down in the description.
The some people learn best by just jumping
00:35 - around to projects, especially people who
may already have a little bit of experience
00:40 - with another programming language. But whatever
your experiences, you may learn best by just
00:46 - jumping into these game development projects,
a few of the tutorials use PI game, you don't
00:52 - have to know about pi game already. But you
can always check out our pygame course, the
00:58 - links right up there down in the description
again, you should be able to follow along,
01:02 - even if you don't really know that much about
pygame. So check the description if you want
01:07 - links to the code. Or if you just want to
learn more information about the people who
01:12 - created these great tutorials. So let's jump
right into it.
01:18 - Let's take a look at what we're going to be
building today. Classic Pong game. So we got
01:24 - a paddle on the right, we got a paddle on
the left. And we've got a ball in the center.
01:33 - Okay, the ball goes off the screen.
01:38 - And
01:41 - the opposite player gets a point and the ball
continues. Okay, so that is what we're gonna
01:46 - be working on. So let's get started. Today,
we're gonna be doing this by using Python.
01:51 - Of course, this is written in Python three.
But it should work in Python two as well,
01:55 - I don't think there's any Python three specific
code in this particular tutorial. So we're
02:01 - going to be building this on top of the turtle
module. On turtle module, it was a nice little
02:06 - module, it lets you do some basic graphics,
it's great for getting started with games,
02:10 - a lot, a lot of tutorials use pygame, which
is amazing. It's got a lot of great features.
02:16 - But for beginners, this is a lot simpler.
And it's built in, you don't have to install
02:20 - it like you do with pygame. So now that I've
got my turtle imported the module, I need
02:27 - to create a window. So I'm going to call it
w n, you got wind w i n or wherever you want
02:32 - to call it. And but I use w n and it's turtle
dot screen, notice the S is capitalized, it's
02:40 - very important. And I'm going to give it a
title. And I'm going to call that poem by
02:46 - at Tokyo edtech. That's my Twitter handle.
And do feel free to leave comments I do take
02:53 - keep close eye on things. And if you having
trouble, let me know. And I want to change
02:58 - the background color of the window to black
classic Pong. And I want to change the size
03:04 - of the window. And I want the width to be
800. And I want the height to be 600 pixels.
03:12 - I'm gonna do something called wind tracer.
And this one's a little bit hard to explain.
03:18 - But basically what that does is it actually
stops the window from updating. And so we
03:23 - have to manually update it, what this lets
us do is basically speed up our games quite
03:28 - a bit. If we didn't do that, things would
run much, much slower. So every game meet
03:33 - needs something called a main game loop. And
this is where basically all the meat and potatoes
03:38 - of your your game goes to. So we're gonna
make a loop wild true. Not gonna put four
03:46 - spaces there. Um, you can use tabs, but spaces
are recommended. But whatever you use, make
03:51 - sure that you are consistent. You can't make
spaces and tabs, and then we'll do Windows
03:57 - Update. And what that does is every time the
loop runs, it updates the screen. Okay, just
04:03 - a quick note this this program is written
for beginners, so I'm not really using object
04:07 - oriented programming, I'm not really using
classes, except as it relates to the turtle
04:12 - module. This is basically a really straightforward,
old school style of programming methodology.
04:19 - So let's run that and see how it goes. And
what we should have is we have our title,
04:26 - black background. It is 800 wide by 600 tall.
00 is at the center. So plus 300 minus 300
04:36 - plus 400 minus 400. Remember those numbers
because they'll come in handy in our next
04:41 - few tutorials. So that's all for this particular
lesson. I just want to get you started. We
04:45 - move on to lesson two, we'll add our paddle
on the left, paddle on the right and our ball
04:51 - in the center. In this part of the tutorial,
we're going to add our paddles to the screen
04:56 - and we're going to add the ball to the screen
as well. So let's get started with that. So
05:02 - basically what we have in Pong is we have
Pat, I'm gonna call it paddle a, we have paddle
05:08 - B. And we have a ball. So those are the three
items that we need to add to the screen. Now,
05:16 - as I mentioned earlier, in the previous video,
we are using the turtle module to, you know,
05:22 - add our graphics and to open our windows and
things like that. It's very, very convenient,
05:26 - it works great for basic games, a lot of people
use PI game, which is great. But for simple
05:31 - games, this is probably an easier way to get
started. So everything in our game needs a
05:36 - name, so I'm going to call it paddle ng very
original. And it is actually going to be a
05:41 - turtle, what's known as a turtle object. So
to do that, it's turtle dot capital turtle.
05:48 - Notice the capitalization small t, because
that is our module name, capital T, because
05:53 - that is the class name. Now, as this tutorial
is aimed at beginners, I'm not going to talk
05:57 - about classes, I'm not writing in object oriented
style, I'm just writing it in, you know, functional
06:03 - style. Although there are some objects kind
of patterns here, you'll you'll see. But for
06:09 - beginners, don't worry about that stuff for
now. So then what I want to do is paddle a,
06:14 - I need to set the speed. Now this is not the
speed that the paddle moves on the screen.
06:21 - This is the speed of animation, this is just
something we need to do for the turtle module.
06:25 - And what this does is it sets the speed to
the maximum possible speed, otherwise, things
06:30 - would be really slow. We want to give our
paddle a shape.
06:34 - And there are a few built in shapes. And we're
going to use square in this case. Okay, there's
06:42 - Circle Square, circle, Square Triangle, a
few others, we're gonna give our paddle a
06:49 - color. And we're gonna call it white, because
that's what Pong looks like. And we're going
06:58 - to basically do something called pin up. Turtles,
by definition, what they do is they draw a
07:09 - line as they're moving, we don't need to draw
lines, because that's not what this program
07:12 - does. So we do the pet up, and I want my paddle
a to start at minus 350. That's an X coordinate,
07:22 - and zero and vertically centered in the screen.
So in our game, 00 is in the middle, minus
07:28 - 350 plus 350. So I'm gonna go ahead and run
that and see what it looks like so far. Okay,
07:37 - so this is our left pattern. Now, you know,
you've played Pong, you've seen the demo from
07:44 - the first video. Clearly, it's not the right
size. So what we can do in our program is
07:52 - this. Now just just for your information,
by default, that shape is 20 pixels by 20
07:58 - pixels, so it's 20 pixels wide by 20 pixels
high. So what we're going to do is we're going
08:03 - to stretch the shape. So we use the shape
size method, you can see I'm using Visual
08:10 - Studio codes, very good program, you don't
want a Mac, and it tells you you know, what
08:14 - you can do stretch with stretch length, etc,
etc. So what I want to do is I want to stretch
08:21 - the width by five sets to be five times 20.
So that'll make it 100 tall. And then by 20,
08:34 - wide, and stretch limb is going to be one
we're gonna keep it at the default. So let's
08:40 - save that and run it. Okay, so you see now
we've got a paddle over here, 20 pixels wide
08:49 - by 20 pixels high. Okay, now. So that's paddle
a. Now I'm kind of lazy guy. So I'm just going
08:57 - to copy this. So what I always recommend if
something's similar, similar styles are similar,
09:02 - you know, functions, you know, get it working
right once and copy it, paste and just make
09:09 - the necessary changes. So now that we've done
that, we just need to change that to be. So
09:14 - if you keep consistent names, it will really
help your programming. And in this case, we
09:17 - want it to go on the right side of the screen.
So that's gonna be plus 350. So I'm gonna
09:23 - run that and test it. And testing your program
is very, very important. At each stage, a
09:29 - lot of beginners I don't know why they insist
on typing the whole program in and then trying
09:33 - to test it and you'll never be able to figure
out where the problems are, especially as
09:37 - a beginner unless you do it step by step like
this. So we got our left paddle, we got our
09:42 - right paddle, so I just call it a said paddle
a paddle B. And then the last thing we need
09:48 - is going to be our ball. So I'm gonna just
go ahead and copy this because it's basically
09:53 - the same thing. I don't need it stretched.
I want to keep it the original size and I
09:59 - Want to start in the middle of the screen,
and I'm going to call it ball instead of paddle.
10:04 - So you see once, if you do it like this method,
if you get everything working correctly, there's
10:11 - no errors and you tested it, you just copy
and paste, it really speeds up your programming.
10:15 - So I'm going to run that one more time. Okay,
you can see we've got our left paddle, paddle
10:22 - a, our right paddle, paddle B, and we've got
our ball, which is starting in the center,
10:26 - so we're off to a good start. Okay, so we've
got our pond window, we've got our paddle
10:31 - a on the left, paddle B, on the right, we've
got our ball in the middle. So in this lesson,
10:35 - we're gonna learn how to move the paddles
using the keyboard. Okay, so what we need
10:41 - to do is to basically, we're going to create
some functions, okay. And if you haven't ever
10:48 - used functions before, a function is basically
kind of a piece of a program that does a,
10:56 - something that's been defined for it. So.
So in this case, we want to move paddle a
11:01 - up, we want to move paddle a down, we move
paddle B up when we paddle B down. So to use
11:08 - functions, you first need to define your function.
And I'm going to call this first function
11:12 - paddle a up.
11:13 - If you recall, in the last video, we talked
about doing one function at a time or one
11:19 - piece at a time, getting that working perfectly,
and then you can copy and just make the necessary
11:24 - changes. So that's what we're gonna do here.
Okay, so paddle a up. So to move the paddle,
11:31 - what I need to do is I need to know the current
y coordinate. So what I'm gonna do is I'm
11:36 - gonna say y equals paddle, a dot y core. Okay?
Now this part here, paddle A is the name of
11:44 - the object we created here, we call it paddle
a. And the dot y core method is from the turtle
11:52 - module. Okay, what that does is it returns
the y coordinate. And so we're just assigning
11:56 - that value to a variable called y, which makes
sense. Okay, so we've defined the function
12:02 - using the def keyword, you notice we have
a, I guess, the tab, in this case, whammies
12:09 - space, we'll see might get an error there.
And I'll explain that a second if we do. And
12:14 - it's supposed to be set to automatically change
the spaces, but I think it's not set that
12:19 - way. So I'll leave it the way it is. So then
what I'm gonna do is I'm going to go up on
12:22 - the screen, it's this way, so up. So why increases
as we go up, it decreases as we go down. So
12:32 - we're going to do is I'm going to add 20 to
why this is the way you do that. You say y
12:38 - plus equals 20. So that will add 20 pixels
to the y coordinates. Okay, so now notice,
12:45 - we've just calculated the y's, then what we
actually have to do is paddle a set y to the
12:53 - new y. So now having a function doesn't actually
do anything until we call the function. So
13:04 - the function has just been defined, but we're
not using it. So what would you do is you
13:08 - do something called a keyboard binding. Okay,
so in the turtle module, we need to do w n.
13:16 - So that was our window. And listen, this tells
it to listen for keyboard input. And we're
13:25 - going to use the on key press method. Okay,
and watch what I do here, paddle a up. W.
13:34 - Okay, so let me explain what that does. So,
this line here, it tells the program to listen
13:43 - for keyboard input. This line here says, when
the user presses W, notice that's a lowercase
13:50 - W. So if you have caps lock on, it won't work.
Call the function, paddle a up, here's our
13:57 - function, paddle a up, paddle a up, says get
the y coordinate, add 20 to the y coordinate,
14:05 - and then actually set the y of the paddle
to the new y coordinate. Okay, so let's test
14:12 - that and see what happens. Okay, so I'm going
to hit the W key. Okay, so you can see how
14:22 - it is moving up. Okay, we actually moved off
the screen. So now that we've gotten that
14:28 - working, okay, what I can do is I can copy
that and I'm gonna change this to paddle a
14:39 - down. So instead of adding 20, I'm going to
subtract 20. And then I need to do a key binding
14:47 - for that as well. So I'm going to copy and
paste that. So it's gonna be paddle a down
14:54 - and in this case, I'm gonna use the AES key.
You can use whatever key you want, but I just
14:58 - chosen those as usually swa SD on the left,
and the arrow keys on the right. So again,
15:04 - I've done one thing, I've changed it, now
I'm going to test it. Okay, so w s, okay,
15:13 - so everything's working exactly as expected.
So then what I'm gonna do is, now I've got
15:20 - both of those working, I'm gonna copy it,
and I'm gonna do paddle B. That'll be, that'll
15:29 - be. So if you keep your naming consistent,
it makes it very, very easy to do what I'm
15:35 - doing, which is to be lazy. And just use copy
and paste. And then here. Now for paddle B,
15:45 - I'm going to use the arrow keys. And then
for the up arrow, it's it's a little bit different
15:51 - use up this capitalize and down is the down
arrow. So again, I made a couple changes,
15:58 - I'm going to test my code.
16:00 - Okay, so w s on the left, up and down on the
right. And voila, there you have it, moving
16:09 - the ball. This is really kind of the meat
and the central kind of part of the program.
16:14 - This is where we actually get the ball to
move. So we need to get to move, we need to
16:20 - get to bounce off the top and the bottom.
And we need to get it to bounce off of the
16:24 - paddles. And so I'm going to show you how
that's going to work. Because we have our
16:28 - paddles can move. And but the ball does not
yet. So let's get started with that. And so
16:35 - what I want to do is with the ball is I want
to separate the balls movement into two parts,
16:44 - an X movement and a y movement. So we're going
to call that I'm going to say ball dot d x
16:50 - d means delta or change. You can even call
it XP or whatever you want to, but dx works
16:57 - very, very well. Now on my computer, I found
that two number two works very, very well,
17:03 - my computer at home, actually, it was like
0.1, it's much, much faster, I don't know
17:08 - quite know why. So you might have to play
with the numbers here to get it to where you
17:13 - feel the game should be. So So dx and dy y
equals two. So what that means is every time
17:23 - our ball moves, it moves by two pixels. So
since x is positive, it's going to move to
17:28 - the right to and since y is positive, it's
going to move up to so it'd be kind of moving
17:32 - up and diagonally. Okay, so to get that to
actually happen, we have to go inside the
17:38 - main game loop. Okay, and in here, I'm gonna
say move the ball. So what we need to do is
17:48 - ball dot set x. And what we want is the current
x coordinate. So I'm just basically kind of
17:57 - combining what I did up here into one line,
plus ball.dx. Okay, so the ball starts at
18:06 - 00. So 0x. So the first time through this
loop, it's going to go to an x times the loop
18:13 - is gonna go to two, so depending on your computer
speed, it could just fly off the screen, or
18:18 - it could, it can go a little bit slower. So
again, you have to play around with that a
18:22 - little bit. So that when I say ball dot set
y and basically the same thing I could have
18:30 - copied and pasted, but I should have done
and ball dot d y. So I'm gonna say that and
18:39 - I'm gonna test and see what happens. You see
some red lines here. I think there's gonna
18:44 - be maybe we problem. Yeah. So I'm gonna run
that and explain why it's not gonna work.
18:49 - Okay, so you see here, I've got an error.
And this is something again, beginners, I
18:53 - don't know why do not want to read error messages.
The error messages basically tell you what's
18:59 - wrong. CCR says tab error, inconsistent use
of tabs and spaces. Okay, so I mentioned this
19:05 - in an earlier video. So here, I use four spaces.
But here, it's a tab. Okay, you got to use
19:12 - the same thing each time. So I'm gonna go
with four spaces, that's actually the preferred
19:15 - method. Now I can set my editor up. So when
I hit a tab, it changes the four spaces automatically,
19:20 - but I'll do that another time. Hey, so I'm
going to run that. And hopefully we'll see
19:25 - the ball move. Okay, so plus, plus and right
off the screen. All right, which is what we
19:34 - expected. Okay, so that's, that's good. So
now what we need to do is we need to do some
19:39 - border checking. So what do we want to happen
when the ball hits the border? Okay, so since
19:47 - it's moving up into the right, we'll do the
top border first. Once you get the top border
19:51 - working, then it's easy to get the bottom
we're working. So all we have to do is we
19:56 - have to compare the balls y coordinate Okay,
so once it gets to a certain point, we want
20:03 - it to bounce. So if you recall earlier in
the program, we set the height of the window
20:09 - to be 600. So so that means that the, the
top y coordinate is plus 300, and the bottom
20:18 - is minus 300. Okay, but the ball itself is
2020, high by 20 wide. Okay, so what we'll
20:27 - do, then is what kind of split the difference,
so we're gonna say if the ball dot y core,
20:33 - so if the current y coordinate is greater
than 290. colon, and I gotta use spaces, it's
20:50 - telling me if it's greater than 290, what
we do is we we set it back to 90.
20:59 - This avoids certain types of problems. And
then what we need to do is we say ball dot
21:06 - d y times equals negative one. And what that
does is it reverses the direction. Okay? So
21:20 - if d Y is two, so d y minus negative one is
negative two. Okay, and that should reverse
21:28 - the direction of the ball. Let's run that.
Let's watch it and we're good. That's exactly
21:38 - what we wanted to happen. Okay, now, since
this is working, correct, exactly as we want
21:47 - it, I'm going to copy and paste that and just
make some changes. So on the other end, it's
21:54 - less than negative 290. We set it to negative
290. And that is that so let's test that.
22:02 - To test that we'll need to start the ball
off with a negative DUI for now. And again,
22:09 - notice how I'm making a change testing making
a change testing. Okay, it's working. That's
22:15 - about what we wanted it a little bit off screen,
bear. But we'll we'll let that go. So that's
22:20 - the borders. That's the top and bottom borders.
Now, the next thing we need to do is the left
22:28 - and right border. So this is where it gets
not more tricky or anything, but you got to
22:38 - think about what we want to happen. So in
this case, because we're looking at left and
22:41 - right. Okay, we're not looking at the y coordinate,
we're looking at the export. And now what
22:48 - we want to do is if the x coordinate, basically,
if it goes off the right side, so if you remember,
22:57 - we said the width was 800. So that means it's
plus 400 on the left minus 400. On the right.
23:02 - So let's say if it's greater than, we'll say
290. Or sorry, 390. That tells us basically,
23:09 - it's gone past the paddle and it is off the
screen. Okay. Okay, so, if that's the case,
23:22 - basically, we're gonna put the ball back to
the center, zero. And then what I can do is
23:32 - I can, maybe ball.dx may have it reversed
direction. Okay, so let's take a look at that.
23:43 - Again, I'm testing to make sure it works.
And if it does that, I can copy and paste
23:48 - and do the other side.
23:53 - Okay, so we got an error. Okay, so it says
we got a lot of weird stuff here. That was
24:05 - a really long one. And
24:07 - say here, if you see it says line 87. So here's
the line where it thinks the error is. And
24:18 - there's a lot of different weird stuff. But
basically, what I forgot to do was zero comma
24:22 - zero. So let's test that again. So it shouldn't
go off the screen and went back to the center
24:35 - and reverse direction. Okay, so we know it
works. So let's copy that
24:45 - and paste it. And again, we're just gonna
reverse it. So if it's less than negative
24:49 - 390, and that's all we got to do. So, again,
let's test it. Hopefully it will come back.
25:00 - Okay, so that's basically, that's exactly
what we wanted to happen. Okay. So in this
25:12 - lesson, we're gonna learn how to get the ball
to collide with the paddles. So let's see
25:16 - what we have so far. So we've got our ball,
it's bouncing off the top of the screen, and
25:21 - it's at the edge of the screen, it goes back
to the center, which is what we want. So what
25:24 - we got to do is we got to make it so that
when it touches the paddles, it will reverse.
25:29 - And how we're going to do that is basically,
what we're going to do is we're compare the
25:34 - x and y coordinates of the paddle and the
ball. So if we look at our code, we put paddle
25:41 - B at 350. So the x coordinate of the center
is 350. If you recall, the center, it's Sorry,
25:51 - it's 20 pixels wide, by 100 pixels tall. So
we need to basically look at, we need to make
25:58 - sure that the ball is basically between here
and here. And that it's basically between
26:05 - here and here. If it is, then we'll call that
a bounce. Okay, so let me kind of play the
26:10 - math a little bit on that and give that a
shot. So let's, let's again, as I mentioned
26:14 - before, we're just gonna try and get the right
paddle working. If we get the right paddle
26:18 - working, then it's easy to get the left paddle
working. Okay, so I'm going to say so paddle
26:26 - and ball collisions. Okay, so if the ball
dot x core, so if the balls x coordinate is
26:36 - greater than. So we said 350, it's 10 wide.
So it's greater than c 340. And the ball?
26:46 - Well, should I leave it at that? I'll leave
that No, we'll come back and fix it in a bit.
26:51 - So that's one condition. And the balls, y
coordinate is less than paddle b dot y core,
27:11 - plus 50. There's a lot of stuff in here. And
there's a lot of different things here. Ball
27:21 - dot y core is greater than paddle. b dot y
Cor. Minus 50. Isn't glad that scrolling over
27:46 - from explain that real quick. So if that's
the case, either.
27:58 - If that is the case, basically, we just want
the DX, same thing we did at the top times
28:04 - equals one of those is x naught y, sorry,
negative one. So if it's going this way, the
28:10 - dx is positive. It's gonna balance and go
back this way. So what we want to see is the
28:16 - ball x coordinate greater than 340. That means
the edges are basically touching. And is it
28:22 - between the top of the paddle and the bottom
of the paddle actually used to be 50 is probably
28:27 - 40. Because of the size of the ball. Let's
Let's play with that. Let's test out see what
28:33 - happens. So I'm gonna run that. Okay, so do
you see what happened there? Which is not
28:49 - only one. Okay, see it bounce there. Watch
what happens. If I miss it. See, there's like
29:01 - a little bit of a glitch there. It's because
even though it's behind the x coordinate is
29:07 - greater than 340. And it's between here. Okay,
so you see how that's kind of acting weird.
29:13 - So we need to do is I want to add this condition.
29:21 - And ball that x score is less than we'll say
350. So that gives it basically to the middle
29:30 - of the paddle.
29:32 - So we'll say ball dot set x to 340. So that
moves it back to the left a little bit. And
29:41 - then it reverses the direction,
29:44 - which is what we wanted. Okay, so let me test
that one more time. Make sure it's working.
29:55 - So bounces Which is good. Hopefully to get
past and see. Okay, so you see how it did
30:11 - not get stuck that time. So that's basically
what we wanted to happen. Let's just test
30:15 - it one more time. Yep. So that's, that's where
we wanted it. Hey, so I'm just gonna basically
30:20 - take this, I'm going to copy it, paste it.
And we're gonna do the same thing on the other
30:29 - side. So minus 340. greater than minus 350.
And the top and bottom doesn't matter. But
30:37 - in this case, it's gonna be paddle a, not
paddle B.
30:42 - That will give you some definitely some weird
glitches. And then same thing, we're gonna
30:48 - reverse the ball. So let's test it again.
30:51 - Okay, so over here, he's the up and down arrows,
he bounced. Over here, we're going to use
30:59 - the W and s keys. That's it. Okay, so something
went wrong there. So I know what I did wrong.
31:10 - So I had set x here to 340, it should be negative
340. So again, notice, because I'm testing
31:17 - it, you know, after every little bit of code,
I knew that the problem had to be in here
31:21 - somewhere, because that's the only thing I
changed. I just I can't emphasize that enough.
31:25 - Because my students, like I said, they always
want to type the whole thing in and then debug,
31:30 - which is never a good idea. Okay, so let's
test it one more time. So you see this process,
31:37 - we're iterating, we're testing and just making
sure everything is working as expected before
31:43 - we move on, okay, so that is that for that
section. So now we've got collided with the
31:49 - paddles, it's going off the screen, the next
thing we need to do is to add some sort of
31:54 - scoring mechanism. So here's what we have.
So far, we've actually got a functioning Pong
31:58 - game. The paddle on the right is moving using
the up and down arrows. paddle on the left
32:03 - is moving using W and s, the balls bouncing
is doing everything and he's due. Next we
32:09 - want to add a scoring system. So let's go
and take a look at that. So basically, what
32:15 - we do is we want to draw the score on the
screen. And here's how we're going to do that.
32:19 - In Python using the turtle module, so we're
gonna do is we're actually going to create
32:25 - a pen, okay, it's called a pen, but it's actually
just a turtle, just like the ball like the
32:30 - paddle. But the turtle module gives these
turtles objects a lot of different abilities.
32:36 - So I'm gonna make a pen. And it like the other
is a turtle dot turtle. And I always spell
32:44 - that wrong. And keep an eye on the capitalization.
So small t for the module name, capital T
32:50 - for the class name, which we it's happening
in the background. Same thing as before, so
32:57 - pin dot speed. And again, this is the animation
speed, not the movement speed that we're going
33:02 - to move, but we're going to give it a color
pen color, the shape doesn't matter because
33:07 - we're not going to see it. If we want to print
in white on a screen, like classic Pong style,
33:13 - and pen dot pan up. This is because we don't
want to draw a line. When the pen moves, every
33:19 - turtle actually starts out at the dead center
of the screen, then we move it somewhere.
33:23 - And if we don't do pen up, you'll see a line
moving between those two points. And then
33:29 - here we want to hide the turtle because we
don't need to see it. Now with the ball and
33:37 - the paddle paddles, we didn't hide it because
we want to see those on the screen. But the
33:41 - pen we don't want to see, we just want to
see the text that's going to write. So pen.go
33:46 - two, and zero comma, I think 260 I think and
I played around with the numbers, that's why
33:51 - no 260 is number one. If you remember, again,
the screen height is 600. So that means zero
33:58 - to 300 here, so we want the score to be right
around this part of the screen. And then it
34:04 - gets pretty easy at this point is we use the
right method. So we want to write and when
34:10 - the right player a. And now when the game
starts the score, of course is 02 spaces,
34:15 - Player B, zero, comma, anywhere align equals
center that will center the text force around
34:25 - that point. And then we want to choose a font.
You know, watch here, I've got an extra set
34:31 - of parentheses here. Okay, don't forget that.
And I want the font courier that's kind of
34:36 - old school techie. choose a font size of 24.
And normal I think normal I think you choose
34:43 - bold and italics I'm 100% sure on that one.
So be very careful. Again, we've got a set
34:48 - of parentheses here. I've got an extra set
of parentheses here for the font. So because
34:52 - there's three arguments we got to send there,
okay, so now, test your code. Make sure This
35:00 - is working. So I run that. Okay, so that's
what we wanted to see if red little space
35:07 - after Player B. Hey, but yeah, that's that's
basically what we wanted. Okay, so that's
35:12 - how we get the default score on the screen.
So what we got to do is we need to keep track
35:17 - of the score. And so what I'm going to do,
and I'm going to put this up here, and score,
35:26 - so I need to create a couple variables, I'm
going to call it score a, and we start the
35:32 - game with a zero and score. B
35:37 - is going to be zero. Now, down, down here,
okay, so we get a score when the ball goes
35:49 - off the screen. So here's the right sides
of the ball goes off the right side, think
35:54 - to yourself who gets a score, of course, that
is going to be Player A. So what I can do
36:00 - is score a plus equals one that adds one to
player A's score. And by the same token, on
36:12 - this on the other side, if the ball goes off
the left side of the screen, Player B, gets
36:22 - Okay, so let's run that.
36:25 - Oops. Okay, so nothing, we don't see any change.
Can you guess why? Okay. Now, if you said,
36:39 - Well, we didn't update the score on the screen,
you'd be 100%. Correct. Okay, so what I'm
36:44 - just going to do is I'm going to copy this
line here. And I'm going to put that into
36:53 - here. And you'll see, what I got to do is
instead of the zeros, this is just print,
37:02 - you know, basic printing, you know, one on
one, if you're not sure how to do that, I
37:07 - do have a video on that somewhere. I'll try
to remember to link that below. But how printing
37:12 - works. So we use the format method on our
string, and we want score a and score B is
37:19 - what that does is put score a here and score
B there. So I'm going to make sure I'm using
37:28 - spaces. I'm gonna copy that. And I'm pretty
sure this is correct. So basically, every
37:37 - time I update the score, I need to update
the actual printed score on the screen or
37:41 - the show's displayed spruce score, I should
say. So run that. Now, watch what happens
37:49 - here. Okay, so you can see it did update.
Okay. But clearly something is wrong. Because
37:59 - basically what it's doing is it's just printing
on top of itself. Okay. So what we have to
38:03 - do is, before we do that call the right method,
we say pen clear. Now actually clear what's
38:11 - on the screen. You know, it happens so fast
that you don't see it. But it actually it
38:20 - does. So take my word for that one. Again,
if you're using pygame, or some other, you
38:26 - know, framework or method, you might not have
to do this type of steps. But for the turtle
38:31 - module, this is what you need to do. Okay,
so I'm going to run that. And let's watch
38:38 - what happens. Okay, so Player A just got to
a point where we just got to a point, and
38:45 - so on, and so forth. So, yeah, so basically,
we've got a pretty well working game here.
38:51 - Again, the game never ends, you just go until,
you know until you give up and get bored,
38:56 - which is pretty easy with Pong. So I've got
Yeah, I got another tutorial coming up on
39:02 - this series, I'm gonna show you how to add
a little bit of sound, which is interesting,
39:07 - especially depending on the operating system
that you are using, I'm going to show you
39:11 - how to add a little bit of sound to your game.
So just basically, you know, what you need
39:16 - to do to get started with that is you need
to have a sound, you need to have a sound
39:19 - file. And what I've done is I have downloaded
this file from I forget the site now, but
39:29 - it is balanced dot WAV and it's like kind
of a classic old school. Bouncing sound. You'll
39:34 - hear it in a minute. Now, Python is generally
pretty cross platform. Basically everything
39:42 - that we've done so far, it doesn't matter
which operating system you're using Linux,
39:47 - Mac or Windows, everything works, the same.
Sound is one of those things where it doesn't
39:54 - work the same. So right now I'm on a Mac,
and I'm going to show you how to do it on
39:58 - a Mac and then I'll talk about how you would
do it then on Linux or Windows? Okay, so it's
40:04 - a bit different. Okay. So the first thing
I had to point out is that the sound that
40:09 - I found bounce dot WAV, and WAV files generally
are more compatible cross platform compatibility
40:15 - isn't the exact same folder as my Python file.
So right now, I'm on Pong, seven, and Pong
40:23 - sevens in there. So they are in the same folder.
That's a really important point. Now that
40:29 - you can you work around that if you know what
you're doing. But for beginners, this is probably
40:33 - the easiest way to do things. And so basically,
it's really simple. When do I want to play
40:38 - a sound. And so I'm going to play a sound
when I having to put when I when the ball
40:46 - either touches one of the borders, or bounces
off of the paddle. Okay, so in Mac, okay,
40:56 - so I'm going to use something called the O
S. Module. And what that lets us do is basically
41:03 - interact with the operating system through
text commands. And so I've imported o s, so
41:09 - I can use that module. And then down here,
so what I can do is I can say, oh s that system,
41:17 - that will do a system function call for us.
Now on Mac, it's a play
41:22 - bounce.mp bounce dot w Av. So this is it.
This will play the sound when it hits the
41:36 - border. Now there's, there's a problem here
and I'm gonna show you that in a second. But
41:39 - again, let's test it. See what happens. Oops,
one throw away. The wait till it's the top.
41:47 - I'll turn my volume up. Oops, sorry, my bad.
A play is for Linux, a f play is for Mac.
41:57 - Let's try that again. Got that backwards.
I had a 5050 chance and I blew it. Okay, let's
42:07 - listen. Now, did you notice that everything
stopped while that sound played? So watch
42:12 - it again. Okay, that is not what we want to
happen. Okay. So to get around that, at the
42:19 - end of this command, we need to add an ampersand.
That's the end symbol. Okay, so let's test
42:32 - it.
42:33 - And watch it will not delay. It says a little
bit, it's a little bit off. But that's you
42:39 - know, neither here nor there, I suppose what
to do with that. Okay, I think actually, what
42:45 - I would probably have to do is edit this,
this WAV sound is probably a little bit of
42:48 - a blank space at the beginning of it. So that's
that's it on Mac. Okay, so let me copy that.
42:56 - And let's say we want to play it when it bounces
the top, bottom and when it touches the paddles.
43:03 - So we need to put, do that. Okay, so let's
test it. So again, I got it working once now
43:14 - I just copy and paste. So it should bounce
here.
43:21 - I'm terrible at Pong, apparently. Okay, now
you can choose different sounds, you have
43:29 - one sound for when it bounces off the walls,
one sound for when it bounces off the paddle,
43:34 - et cetera, et cetera. Okay? Now, if you are
a Linux user, the the system is very, very
43:41 - similar. Instead of AF play, it's a play.
That's all you have to change. Okay, and for
43:47 - Windows is a little bit different. Now, I
can't test it for you, but I can explain how
43:51 - it works. And I do have a video that explains
this. And I'll try to remember to link that
43:56 - down below. And basically, in Windows, instead
of importing o s, you import wind sound, which
44:04 - is a little module that only exists on Windows.
And then when you want to play your sound,
44:10 - instead of this oh s dot system stuff, you
would type win sound. dot play sound. Again,
44:19 - pay attention to the capitalization, okay?
Small W, capital P, capital S, then in parentheses.
44:26 - So don't need the ampersand here. But you
do need a comma, and then when sound not SMD
44:39 - async. So what that does is that same thing
as adding the ampersand. that'll stop you
44:45 - if it's asynchronous, it will play the sound
in the background. If it's not a synchronous
44:48 - program, we'll stop. Again, I can't show it
to you because this is Mac but that should
44:55 - should do it. So I'm gonna undo that and get
back to my system. Oops, somebody wanted to
45:00 - Oh yeah. Keep going, Yeah, a play and it's
AF play, let's leave that. I'm gonna test
45:05 - it one more time. And that is our Pong program.
Not the most exciting thing in the world.
45:15 - But you know, you learn a lot of different
concepts, you know how to put objects on the
45:19 - screen, how to move them with a keyboard,
how to detect collisions, update the score
45:24 - on the screen, gaming loops, sounds. So basically
all the basic elements that you need to make
45:30 - a game are included in Pong. That's why it's
one of the classics. And I remember playing
45:35 - this as a child, it brings back some memories.
45:42 - So let's just go ahead and get a look at what
this final product is going to look like.
45:46 - So on like an x by x grid, so whatever you
want it to be, you have little snake moving
45:51 - around, there's a snack is what I want to
call it that shows up and as you collect it,
45:56 - it increases the length of the tail. And then
obviously, if you run into yourself, and I
46:00 - just did that by clicking the back us going
forward, it gives you a little error message
46:04 - here says, You ran into your tail, your length
was nine dot, whatever. And then you can continue
46:11 - and play as long as you want. Anyways, what
I'm gonna be doing in here is I'm going to
46:16 - be coding everything object oriented, I know
that there's a much faster and easier way
46:20 - to do this doesn't really teach you that much.
This way, you're gonna learn a bit about objects,
46:25 - but classes, how we can kind of work with
them. And you'll see like how the flow of
46:29 - my program goes, and you should learn quite
a bit, especially if you're someone a beginner
46:34 - programmer, what we're going to be using to
make this is module called pi game, if you
46:39 - don't know about pi game, and you want to
learn about it, before you do this, I would
46:42 - recommend that. Alright, so let's start coding.
So pretty much what I've done is I've just
46:47 - set up the flow of the program, all the classes
and the function just to remind myself what
46:51 - I need to write. And while I'm talking here,
it's probably good ideas, if you guys copy
46:55 - this down, so we're gonna have, you're gonna
have two main objects, we're gonna have a
46:59 - cube object and a snake object, and our snake
object is going to contain cube objects, if
47:04 - that makes sense. So each one of those little
red squares it was moving around is a cube
47:09 - object, and the whole thing is our snake object.
We're gonna have a few functions here, draw
47:14 - grid, redraw window, random snack, messagebox,
and main. So let's get started with our main
47:21 - function here. And this is what's going to
be our main loop. So essentially, what I need
47:24 - for the main loop to start is we need to make
a surface so in pygame, to do this, we do
47:29 - when equals pi game, dot display, dot set
underscore mode, and then I'm going to set
47:36 - it. Let's see here, what do I want the height
to be? I say, width, and height like this.
47:44 - Oops, that's fine. And I'm just gonna make
a variable here called width equals, height
47:49 - equals, and we'll just set this to 500 by
500, like so. Now we need another variable,
47:57 - I'm going to set this as rows can delete this
down here, it's gonna do something, we'll
48:01 - do that later. And this is how many rows you're
gonna have what rows or columns, whatever,
48:06 - you can set this to whatever you want, just
make sure it divides 500 evenly, otherwise,
48:10 - you're gonna have like weird looking rows,
if you know what I mean. So I'm just gonna
48:13 - set mine to 20. That's what I'm using the
other one. But if you want to make it harder,
48:16 - set it to something like 10, and there won't
be as much room for the snake to move around,
48:20 - and the games will go faster, pretty well.
Okay, next, what we need to do is we need
48:25 - to set up a snake object. So I know that we
haven't even created like anything in the
48:29 - snake class yet, but I'm gonna do s equals
snake. And I'm just gonna give it a position.
48:35 - So in this case, we want to use a color Sorry,
just gonna be red, because red, green, blue,
48:42 - 255 for red, and then I'm gonna give the position
we're gonna start in the middle. So I'm going
48:45 - to start at 1010. Now let's move into our
main loop. So I'm just gonna say, well, flag,
48:52 - create my variable here, flag equals true.
And then we're just gonna start by doing a
48:59 - pygame tic, so pi game dot time dot delay.
50, like so. And that's just gonna delay us,
49:07 - I want to say, like point five or 50 milliseconds,
every time so that our program doesn't run
49:13 - too fast. I'm also going to create this clock,
tick on to put that at 10. And what I'm gonna
49:20 - do is I'm gonna create a clock object up here.
And this is a built in thing in PI game. And
49:25 - what this is going to do is I'll explain in
just one second once I finish typing it pi
49:31 - game, clock, I believe it is, oops, time clock,
like so. So what this clock tick is actually
49:38 - going to do is it's going to make sure that
our game doesn't run more than 10 frames per
49:42 - second. So that would mean essentially that
our snake would be able to move like 10 blocks
49:49 - in one second. And again, we don't want it
to be that fast. So that's why we're also
49:53 - delaying by like a few milliseconds here.
If you put this too low. Then again, it's
49:58 - going to move to Oh, you can play Round with
the speed, this is kind of what I found was
50:02 - the best speed. And it may vary depending
on what machine you're on, it shouldn't, it
50:06 - might. So you might want to just change these
numbers. Again, the lower this goes is, the
50:11 - faster it's going to be. And the lower this
one goes is, the slower it's going to be.
50:15 - So they're kind of inversely proportional
like that. Alright, next, what are we going
50:21 - to do here, I'm just going to call redraw
window.
50:28 - And I butchered that so bad, oops, redraw
window like so I'm just going to give it a
50:33 - surface, which is in this case going to be
when that we've created up here. And for now,
50:38 - that's all I'm going to put in my main loop
here. And we'll move more into that once I
50:42 - start coding some other stuff. Okay, so now
that we have our redraw window being called
50:47 - here, I'm going to go and I'm going to start
coding our redraw window. So what this is
50:52 - essentially going to do is we first need to
update the display. So pygame display dot
50:57 - update, like so. And we also need to draw
the grid. So we're going to do draw grid,
51:05 - we're going to pass it out same surface that
we were given, and move on from that, we're
51:10 - also going to fill the screen. So when Phil,
in this case, I'm just gonna use block 6000.
51:18 - And there we are, that's all we need to do
right now. But essentially, we're also going
51:21 - to need to draw the snake, we're gonna need
to draw a few other things on the screen.
51:26 - That will we'll get to later. Okay, so draw
grid, let's move into this one. Now, what
51:30 - we need to do here is draw a grid, which is
pretty easy to do. So what we do is we were
51:37 - given rows and surface. So it's probably a
good idea, if I actually passed in the rows
51:41 - and the surface. So I'm just going to global
them here so that I can reference them, I
51:46 - think this is going to work well the global
rows and width, like that. And here, we also
51:53 - need to make these global just because I don't
want to pass them. And every time I draw a
51:57 - grid, we're just gonna say width. And rows,
and this height variable is actually not necessary,
52:04 - because we are just gonna draw a square, like
a square surface every time. So we can just
52:11 - make this the same, we don't need two variables
for width and height width are going to contain
52:14 - the same number anyway, so global width and
rows, I go here, draw a grid, given with rows
52:20 - and surface. So now we're gonna put in, well,
first we're gonna put our rows are oops, width,
52:28 - row, and surface like that. Okay, so that
should be working. Now, in here, what we first
52:34 - need to do when we're drawing a grid, is we
want to figure out how big each square in
52:41 - the grid is going to be. Because what we're
going to do is we're going to just draw lines
52:45 - going down and across, but we need to figure
out where to draw those lines. So we have
52:49 - to figure out kind of like the gap between
each of the lines. So the way we do that,
52:53 - I'm just gonna create a variable here size
between is equal to our width, integer divided
52:58 - by our rows. This is just so that we don't
get like large decimal numbers, because that
53:04 - we cannot pass into our draw line method in,
in Python. Okay, so now I'm just gonna create
53:10 - X variable, and Y variable. And I'm going
to set these to zero, let's say for L, in
53:18 - range. And this just standing for line pretty
well, in rows, like that. Now, what I'm gonna
53:23 - do is I'm gonna increment my x by the size
between, I'm going to increment my y by the
53:29 - same, so y equals y plus size between can
get rid of one of the spaces here. Okay, there
53:40 - we go. And now we're simply just going to
draw two lines. So to draw a line in pygame,
53:44 - all we have to do is pygame dot draw dot line.
And the argument that takes is a surface,
53:52 - we need a color in this case is going to be
white. So you 250 by 255 255 foot white, we're
53:58 - going to draw x zero comma x w, and I'll go
through this in just one second. What this
54:06 - does, and I'm just gonna copy this and draw
one more and then explain how this is going
54:10 - to work pretty well. Okay, so now we need
zero, y, and
54:16 - w, y. Okay? So what this is going to do is
this is going to draw two lines for us every
54:23 - loop of this for loop. And these arguments
here is the start position of the line and
54:28 - the end position of the line. So the first
line that we want to draw is going horizontal,
54:32 - which means we don't want to change the y
value at all. So what we need to do is we
54:37 - need to find the x and then we're going to
put y at zero, because we're going to be at
54:42 - the top. I think that's right at least Oh
sorry, this this line is being drawn down
54:46 - not being drawn to the right, I was getting
confused. Okay, so we're going to change the
54:49 - x, but we're going to keep the Y at zero.
And then we're going to stay at that same
54:54 - x and we're going to keep the Y at the width
of the screen so that we're going far enough
54:59 - down then same thing here, this one is going
horizontal, excuse me, I messed that up before.
55:03 - So our x is always going to stay at zero.
And our y is going to be what's changing as
55:08 - we draw a horizontal line across the screen.
I hope that makes sense to everyone how that
55:12 - works. Anyways, I'm going to move on from
that. And that's all we need for the drug
55:15 - grid function. So just go ahead, I probably
made a mistake here, but we'll run the program
55:20 - to see if everything's working. Good now named
when is not the find window fill. So I've
55:25 - called this when one really needs to be surface
like that. So let's try now. And there we
55:32 - go, we get a nice little grid on our screen
like so 20 by 20. grid. There we are. So now,
55:39 - let's move into another function, or actually,
let's start coding on the classes here. So
55:44 - like I was talking about before, we're gonna
have a snake object, which is going to contain
55:48 - a bunch of cube objects. So essentially, what
we're gonna do is we're gonna have a list
55:51 - of cubes. And that's going to be known as
the snake body. So let's go ahead and write
55:55 - that in. Now, what I want to do for that is
just create a list. So we're just gonna say
56:01 - body is equal to and then a blank list. I'm
also just while we're already up here, in
56:05 - creating a class variable, I'm going to create
turns, is equal to, and it's just gonna be
56:10 - the set of squiggly brackets here that we'll
we'll get into in a bit. Okay, so now that
56:16 - we're already in the snake function, what
we need to do is we just need to define our
56:21 - parameters here that were passed. So we're
just gonna say self dot color, equals color,
56:27 - self dot equals cube, which I'll get into
in a second, given the position, say self
56:35 - dot, body, dot, append our head, self dot
head, like this. So what we're doing here
56:42 - now is we're saying Okay, so the head of our
snake, which is going to be important, because
56:45 - we need to know where that is at all time.
So we can move accordingly, is equal to a
56:50 - cube at the given position. And the given
position is what we pass in here, as like
56:54 - the starting position of our snake. Or we
create a new snake, like we'd have multiple
56:58 - snakes moving around. And anyways, that's
the position. Now we're saying we're going
57:02 - to append to the body, this head. So now this
is in our list here. And then we can go through
57:09 - that list. And we can draw things, we can
move it, we can check things, we want all
57:12 - of our cubes to be ordered within this list.
So that's why I'm putting that in first. Now,
57:17 - I'm just going to give this one which is called
turn x is equal to zero, and turn y, which
57:24 - is equal to one. So what this is going to
do is we have a direction for x and a direction
57:29 - for y for moving our snakes, obviously, these
are going to be a value like negative one,
57:36 - one, or zero, and that's going to be the same
for y and x. If y or x is equal to one, negative
57:42 - one, then the other one is going to be equal
to zero because you can only be moving in
57:44 - one direction at the same time. And this is
just going to keep track of what direction
57:49 - we're moving in. And we'll use this in the
next function that we're going to code, which
57:53 - is our move function. So moving is pretty
straightforward, at least in terms of just
57:58 - if you have one object moving around the screen,
getting it to go left straight, right, but
58:02 - when you have the snake object, it has to
turn at certain points. So when I click left,
58:08 - the rest of the snake is still moving forward,
once it reaches the point where the head turned
58:12 - left, then it has to turn left. So that's
where things can get a bit complicated. Anyways,
58:16 - to start, what I'm going to do is say for
event in PI game, by the end of my typing
58:24 - here, pi game, dot event dot gets like so.
58:29 - And that we're just gonna say if events dot
type equals equals pi game, dot quit this,
58:38 - and this is the first one we always want to
code in. Because we want to make sure that
58:41 - if they click that little red arrow, it actually
works. And we can quit going to pi game dot
58:45 - quit like that. And I'm just gonna say if,
actually, we don't even need another F, because
58:50 - the way I'm going to do this is this other
way you might have seen in PI game before
58:54 - to move things around use, like if event dot
type equals key down, and then you just check
58:59 - which key was pressed and move to the left.
This is a similar thing, but it works smoother.
59:03 - I've used both of them a lot. And this is
what I prefer. So I'm just going to use this.
59:07 - So pygame dot key dot get underscore press.
So this is going to do is it's going to get
59:11 - a list. Actually, I think it's like a dictionary
or something like that, that has all the key
59:16 - values. And then if they were pressed or not.
So that way, if you press more than one key
59:21 - at once, when you're looping through, it'll
adjust to that. Whereas the other one, you
59:25 - can only click one at a time and you couldn't
move like per se diagonally if you're moving
59:29 - like a character at the screen. Doesn't matter
too much for this, but this is the way I like
59:31 - to do it. So now I'm gonna say four key in
keys. Because remember, this is going to give
59:37 - us all of the keys and then like one or zero
value if they were clicked or not. So we need
59:42 - to loop through all of them and check if keys
and then pygame dot key or uhq stuff dot k
59:50 - underscore left. Thought it was key there.
And then we say keys by game dot k underscore
59:59 - rights Like that, and we can continue down
here with up and down. And then we'll get
60:05 - into exactly what is going to happen when
we click these keys. So last one here.
60:13 - Alright, and there we go. Okay. So now what
we're going to do is we're going to change
60:21 - the direction according to what key we click.
So for going left, that means that our x has
60:26 - to be negative because the way again coordinates
work in pygame is in the top left hand corner
60:31 - of your screen is 00. So if we want to be
moving left, we should be making our x negative
60:36 - to move more towards zero, right? If we want
to move right, though, you make our x positive,
60:42 - which would be one in this case, because we're
just gonna move one cube at a time to go further
60:46 - to the right. Same thing with the Y, it's
kind of weird in pygame, how the Y works,
60:50 - because the more y you add, the further down
you go. So what do we say for x, we're gonna
60:57 - say self love journey, x equals negative one,
again, because we left and we're gonna set
61:01 - our journ y equal to zero. And this is because
again, we don't want to be moving in two directions
61:07 - at once and be going diagonal. Now, this is
what I was talking about, it's we need to
61:12 - remember where we actually turned. Because
if you just have one cube in the ground, that's
61:17 - fine. But when you have multiple cubes, we
need to be to turn left, right, we need to
61:20 - remember where we turned, so at the tail of
our cube can turn at that point. So that's
61:25 - why we have that self dot turns list up, you're
just as turns, I want to say, dictionary or
61:30 - set, whatever. So we're gonna add to that,
itself that turns, and we're gonna give it
61:37 - a new key. I'll go through how this works
in a second self dot pause here, is equal
61:44 - to, and then we're gonna give just a list
of self dot exe, and self dot dir and why.
61:51 - Okay, so you might be kind of confused on
what's going on here. So I've created a new
61:56 - dictionary up here, that's what I'm going
to call it officially, you could think of
61:58 - it as a set as well. And pretty much, we're
going to add a key, which is the current position
62:05 - of the head of our snake. And then it's going
to be set equal to what direction we turned.
62:11 - So we're saying we have a new turn at this
position, and our character where our snake
62:16 - moved left, so it's gonna say we have self
doctrine y, which is right here is negative
62:20 - one self.or surf, don't turn x or then turn
y is equal to zero, so we know what way we
62:25 - actually turned. And I hope that makes sense.
That's, that's how we're gonna do that. Now,
62:30 - I'm just gonna copy and paste these and then
change these values. So when we're going right,
62:34 - this is going to be one. Oops, same thing
here. So put that in, this is going to be
62:40 - zero, and turn y we're going off is going
to be negative one. Now when we're going down,
62:47 - we need to change this to one and this to
zero, and I'm just gonna get rid of that.
62:52 - And there we go. Okay, so that is pretty much
how we go about doing this. And I can also
62:59 - just put LS here as well, because we don't
want to be able to move in more than one direction.
63:04 - So we're going to prioritize the left arrow
key. If they're not clicking the left arrow
63:08 - key, then we'll check they're doing the right
otherwise up otherwise down, because we don't
63:11 - want them to be able to click More than one
key at once. Okay, so next, we need to actually
63:16 - move our cube. And this is where it gets a
little bit more tricky in terms of looking
63:21 - where our cube is. And if it's at that turn,
then we're going to turn it. So I'm just gonna
63:26 - start coding and I'm kind of going to go through
exactly what I do. So before I see in a numerate,
63:33 - oops. And I spelt that wrong. Like that, and
the version, say self dot body, because we're
63:41 - going to look through the list of positions
that we have in on stake and then say, P equals
63:48 - seat up position. And I'm just going to copy
this. By the way, that's what this little
63:53 - arrow does here, it just makes a copy so that
we're not changing the position of our snake.
63:59 - When we do things, it's just just follow along
with it's not super important. Okay, so we're
64:04 - gonna say if p is in self dot turns, like
this, because remember, what we did is we
64:10 - added the position of our head, two turns.
So now we're going to say, Well, if this position
64:17 - is in the turns, then we're going to move
or we're going to turn right, so let's say
64:23 - here, when say, turn, oops, equals self dot
turns. Like that. So now we've seen that it's
64:34 - in there. So now it's in there, we can find
the index of it and we can grab the direction
64:38 - value so we know what way we're gonna be moving.
And average can say C dot move, like this,
64:44 - and turn zero, turn, one, like so. Okay, now
Next, I'm going to say if i equals equals
64:55 - the length of self dot body, minus one
65:00 - Oops, then I'm gonna do self run away, that's
capital stuff, but turned dot pop. Okay, so
65:09 - I know I just did a lot of coding here. And
this probably doesn't make a lot of sense
65:13 - to you guys. So I'm going to kind of run through
exactly what I just did. It's, it's pretty,
65:17 - it's a little bit difficult to explain. So
anyways, what we start off by doing is we're
65:21 - gonna say, we're gonna get the index, and
we're going to get the cube object in our
65:25 - self dot body, because remember, our self
dot body is made up of cube objects right
65:29 - here, that have these properties, right, they're
gonna have a direction y direction, x, a start
65:36 - color, so on, and we're gonna get, we're gonna
get to coding cube in just a second. So there
65:41 - are cube objects. Now all of these cube objects
have a position. So I'm saying for each object
65:47 - here, I'm going to grab their position. And
I'm going to see if that position is in our
65:51 - turn list. And we create the term list and
add to the turn list. When we turn right,
65:58 - when we click left, center, right, so on,
and then we're gonna say, Okay, so the actual
66:03 - turn, so where we're actually going to be
moving is equal to that all the turns list
66:09 - at that index, right, so we grab the turn
direction, x and direction y, which we stored
66:15 - there. And now we're gonna just gonna say,
our cube dot move, which is another method
66:19 - that we're going to code, and we're giving
it that direction, x and that direction y,
66:22 - so it knows what weight it needs to move pretty
well. And then I say, if i is equal to the
66:28 - length of self dot body minus one, so that
means if we are on the last cube, we're going
66:33 - to remove that turn. So once that last cube
hits that turn, we're going to remove it,
66:39 - because if we were just to leave that turn
in the list, that would mean any time you
66:42 - hit that position on the screen, regardless
of if the snake was turning there or not,
66:46 - you'd automatically change directions, if
you don't remove it from the list. hope that
66:52 - makes sense. Okay. Now, also after this, if
you were gonna say if the, what do you call
66:59 - it if it's not in the list. So if our position
is not in the list, we still need to move
67:03 - the snake, because it's constantly moving.
So what do we do to this? Well, we write an
67:08 - else. And I'm just gonna copy this in, because
it's going to take a second to type because
67:11 - I have another file open. And I'll go through
what happened, how this works, okay? No, it
67:15 - looks like a lot. But pretty much. What this
is doing for us is we're checking whether
67:21 - or not we've reached the edge of the screen
for saying, if we're moving left, and the
67:27 - position, so the exposition of our cube is
less than or equal to zero, then we're going
67:34 - to change that position so that it goes to
the right side of the screen. So the way that
67:38 - we can do that is by saying c dot rows minus
one, because again, if you start counting
67:42 - at zero, and computers, so if our rows is
like 20, then the last cube would be 19 in
67:49 - a list, right? They see that rows minus one,
and we're gonna be at the same y value. So
67:52 - we'll leave that there. Okay, and then we
say, otherwise, we're gonna check if we're
67:58 - going right for moving right. And same thing,
if we're at the edge of the screen, move back
68:03 - to the left side by putting zero here. And
the next one, if we're going down, what we're
68:08 - going to be doing is, again, checking, are
we less than rows minus one or greater than
68:13 - rows minus one? No, we're not. Or if we are,
then let's move us back up to the top of the
68:17 - screen by changing our y value. And then same
thing here, if you're moving upwards. Now,
68:23 - if none of that's true, so we're not at the
edge of the screen, we're not moving up left
68:27 - down to whatever I just said, then we're just
simply going to move our cube at the direction
68:33 - x and the direction y of that cube already.
So if that cube is moving upwards, and it's
68:38 - not turning, and it's not going to the edge
of the screen, it doesn't need to be changed.
68:42 - Just keep moving it in whatever direction
it's going. And that's why I'm simply referencing
68:45 - the cubes already existing direction, x and
direction, why we're not changing anything,
68:49 - we're simply just saying, Okay, let's move
you forward one, like that. I hope that makes
68:54 - sense. That was a lot and that's probably
one of the hardest things in this program
68:57 - is figuring out the movement of the steak.
So if you guys understand that, then that
69:01 - is the hard part kind of over with and we're
gonna get into this cube objects, you're gonna
69:05 - understand what all this means and how our
rows and columns kind of work and stuff. Okay,
69:11 - so I'm just gonna forget about resetting od
q for now because we'll worry about those
69:15 - later. But let's get into the draw method
because want to see if there's actually working
69:19 - and put this on the screen. So simply for
I see a numerate plug in outselling numerate
69:26 - today, like that. Same thing, self dot body,
like that. We're gonna say if i equals equals
69:33 - zero, c dot draw, and you'll see why it is
in a second. True.
69:41 - Else c dot draw surface. So the reason I'm
doing this little check here, rather than
69:49 - just drawing every object is because when
we draw the first snake object onto if you
69:55 - remember my other program, it had eyes. So
what I would simply want to do is make sure
70:00 - That when we draw that first object, we add
eyes onto it just so we know where the head
70:03 - of the snake is. We don't get confused, like
what directions are having. And although you
70:07 - shouldn't we, I want to add a little is maybe
just for aesthetic as well. So what this true
70:10 - does optional parameter simply says draw eyes
if it's the first one in our list like that,
70:17 - if it's the head, and then in this draw method,
you can see I have is equals to false. But
70:22 - when you make it equal to true, we're going
to do a special thing in here that's going
70:24 - to draw eyes for us. Okay, so now that we've
coded this, this whole mess of stuff in the
70:30 - snake class, let's just run the program quickly
and see if anything's happening. So currently,
70:34 - we just have the grid, we don't have any errors
or anything. That's because we haven't drawn
70:38 - the snake object onto the screen yet. So what
we need to do is we just need to do simply
70:44 - do s dot draw it within our redraw window
here. So I'm just going to type I'm going
70:48 - to global s here on global it down there as
well. Because say s dot draw, like that. And
70:53 - we need to give a surface. So let's give it
a surface, and I'm going to global s so that
70:58 - we can reference it there. And is there a
reason why we aren't being drawn to the screen?
71:03 - Let's just have a look quickly. Start draw.
Start draw Oh, it's because yes, we are indeed
71:12 - trying Yes, but we haven't drawn any of the
cube objects yet. And it is calling the draw
71:17 - method on all of our cube objects, which we
haven't yet created. Hopefully, that makes
71:22 - sense. But we'll go ahead and do that now.
So we have to code a little bit more before
71:25 - we can see everything. So let's just go ahead
and get into the cube object. And let's just
71:29 - say self dot start, people start, except I'm
actually just gonna change this to position
71:35 - because I believe this is what it's supposed
to be. And we're gonna say self, during x
71:44 - equals one, self dot y is equal to zero, and
self color, is equal to color. And the reason
71:54 - we have this is because we're going to be
drawing later what I want to call it a snack
71:58 - for the, for the cube to collect for the snake
to collect on. So we want to change the color
72:03 - with that. And I've spelled it wrong, like
three times during extender and why the reason
72:08 - I have done x your set to one initially, is
because I want to make sure that we start
72:15 - moving in a direction. If I had this at zero,
you'd have to click a key before the snake
72:20 - starts moving, but I want right when we run
the program for the snake to just start moving,
72:23 - so I'm setting it already with a direction
x. And the reason these are optional, again,
72:27 - is so that when we create a new cue object,
we don't have to implicitly say direction
72:33 - x is one direction y zero, because it's assumed
that it's always going to be like that, unless
72:36 - otherwise stated. Okay, let's have a look.
What else do we need to do here, we need to
72:42 - now code this new function, which actually
really easy I'm gonna do is we're gonna say,
72:47 - since we're changing the direction x in the
direction y in our snake class, we need to
72:51 - do that in here so that it stays with the
object, let's say during x equals
72:55 - x.
72:59 - And then same thing, so thought, during y
equals getting y, like that. And then we'll
73:07 - go down here, and all we're going to do is
going to change our position. So self dot
73:10 - position, is equal to self dot pose zero,
which is our already existing position plus
73:17 - self dot, drag x. And they're saying self
dot, part one, which is our already existing
73:24 - y value, plus equals self dot journey one
like that. And just in case, I haven't mentioned
73:31 - it here, right, we're working with a grid
system of 20 rows in this instance. So when
73:36 - I say something like, if our self deposition
is like one, three, or 1010, I'm saying we're
73:42 - in the 10th row and the 10th call, I'm not
saying the x value is equal to 10. And the
73:46 - y value is equal to 10. Because it's not in
the case of drawing on the screen, because
73:51 - our screen is actually a width of 500 pixels.
But just where we are in the grid, which is
73:55 - most important to us right now, is equal to
like that values like 1435. So on that just
74:02 - just to make that clear for anyone who might
have been confused. Okay, so now for drawing.
74:07 - So a little bit harder, just because of what
I mentioned as well, is the fact that we need
74:11 - to figure out the distance between each x
value and each y value. So when we're drawing
74:16 - something in pygame, it draws in the top left
hand corner of the object. So if we draw a
74:20 - cube, we're drawing that in the top left.
So we need to figure out what that x and y
74:25 - value is going to be for each cube when we're
drawing to the screen. So I'm just gonna call
74:30 - this gap here that is gonna be our distance.
And then we have same thing self dot w, y
74:36 - self dot rows. And we're gonna change W and
rows down in our program later, but we can
74:41 - actually just type it in now. Like this 502
100 just so we have that set. Okay, so self
74:47 - dot w, answer divided by self dot rows. Again,
that's the same thing we did when we were
74:51 - drawing the grid to figure out the distance
between our x and y values. Okay, we're gonna
74:56 - say i is equal to self dot pause. Yeah, I
was gonna say is a bit of typing in our function
75:01 - here, or in our method, just say j dot self
dot paws one. So we're just saying I, which
75:07 - stands for row j stands for column, like a
classically convention for it, so that we
75:13 - don't have to keep typing pause zero plus
one when we move. Okay, so the next one, next
75:17 - thing we need to do is no draw rectangle,
you're gonna say pygame dot draw dot rect,
75:22 - like this. And then we need a surface, we
need to cover so self color, and then we need
75:28 - a rect. And here is a little bit of math.
I'm just gonna type it and I'll go through
75:32 - exactly what what it goes j multiplied by
this plus one, dispose to this question. Okay,
75:43 - so the reason I have these little plus ones,
and these minus twos here is just so you can
75:47 - still see the grid when we draw the rectangle.
Because if we were to draw with exactly the
75:52 - dimensions of this distance, then what would
end up happening is we'd cover the white lines
75:58 - of the grid, and it just looks kind of weird
if you can't see the white lines. So that's
76:02 - why I have plus one, added here and minus
two just so we're drawn inside of the circle,
76:07 - or inside of the square a little bit. And
you'll see that in a second. So what I'm simply
76:10 - doing is I'm multiplying my I value, which
is going to be my current like row column
76:15 - by the distance that we need to get to the
next one. And then same thing for J. And then
76:20 - this will add ones minus twos, it's just to
make sure that we stay inside. So a quick
76:24 - quick example, if you don't understand is
say we're in a position 00. so r is zero and
76:29 - r j zero. We're going to say, I multiplied
by distance, let's say distances, like 40.
76:34 - Okay, so zero multiplied by 40 00, multiplied
by 40, zero, so our position is 00. And that's
76:41 - correct. Because if we're drawing in the top
left hand corner here, and we're in position
76:44 - 00, then that's where we should draw again,
if you go something like zero 10, and you
76:48 - are you move down, I guess so 10, you moving
wide down, you're gonna say zero miles distance
76:54 - zero, and you're gonna say 10, multiplied
by distance, let's say it's 40, then we move
76:58 - to that correct position down the screen.
So this is rectangle x, y, width, height.
77:04 - Okay, make sense. Now, the next thing we need
to do is when to draw the eyes. Now you can
77:08 - skip this part, if you want, I'm just going
to copy it in because it's a little bit of
77:10 - math to make it them like perfectly aligned
on the square.
77:14 - But yeah, so we say, if eyes are saying our
center is equal to distance modulates two,
77:21 - because that's going to be the center, obviously,
or much. So we're saying divided by two is
77:25 - gonna be the middle of our cube. And we're
saying the radius, that's how big the eye
77:29 - radius is going to be. And then we go through
a little bit of math here. So circle middle
77:33 - is going to be high multiplied by distance
plus center minus radius. And then we're finding
77:39 - out the x. And this is just like a random
x that I'm setting by just putting it eight
77:43 - pixels up, like every time because I don't
want to calculate the X. I don't feel like
77:47 - doing that. And then I'm drawing two circles,
based on circle, middle one, circle, middle
77:51 - two, and then the radius and a color of black,
or color of white, actually, sir, or no, that's
77:57 - black. I'm confused. Alright. Anyways, with
all that being said and done, and you guys
78:04 - probably pretty confused, right? Now, let's
just run and see if anything's actually happening.
78:08 - And you can see we have a cube in the middle
of the screen. Yeah, so that's all we've done
78:13 - with all this coding. so far is drawn a cube.
So actually, not quite, because we still,
78:20 - all we have to do now simply to start having
that queue move and seeing our key presses
78:24 - work is just do a little bit in the main loop.
So let's move down to the main loop now, and
78:29 - have a look here what we need to do. Okay,
so what I'm going to do is I'm simply just
78:33 - going to call a stop move, which is our snake
object every time this main loop runs. And
78:39 - what this will allow us to do is I want to
call this before I read your window is it's
78:43 - going to go up to that method and snake, it's
going to check every time that we run the
78:47 - loop, if a key has been pressed, if it has,
we're going to move accordingly. And remember
78:51 - that in this move loop here, it moves all
of the objects for us. So it moves all those
78:55 - cube objects. And then we're just drawing
the grid redrawing everything in this redraw
79:00 - function, so it'll just display that and update
that to the screen. So let's see here. And
79:05 - we get an error tuple object is not callable.
self dot pose. 0% that there next. Alright,
79:11 - one second guys. Oh, it's because I used curl.
Okay, so apparently, I'm an idiot. And I forgot
79:19 - to add an equal sign here. So the issue was
simply that this looked something like this,
79:25 - that I changed it to square brackets, when
all I needed to do was put an equal sign like
79:29 - this. And now we should be up and running.
So to reiterate, the line here is that the
79:34 - issue is, you guys probably saw this when
I coded it, to be honest, is in move in cube,
79:40 - it's near the top of the program, all you
have to do is change this add an equal sign
79:44 - between this like the bracket and the pause.
So now that we run it, we can see that we
79:50 - have a moving object, and that we can move
up, down, left, right, etc. so on and so forth,
79:57 - like that. Okay. So play around with that
for a second. And now we'll get into adding
80:02 - cubes. And we're actually almost done, we
just need to add that add cube function messagebox
80:08 - little bit in the main loop, and that will
be finished. Okay, so what we need to do now
80:12 - is, that's all great, we're moving around,
but we need to add stuff to our cube, right?
80:16 - Like we need to progress the game. So to do
this, we are going to generate what I want
80:21 - to call a random snack that we're going to
place on the screen that our snake can eat.
80:25 - So the way that we do this, I'm just gonna
say, positions equals item, dot body. And
80:33 - this item, oops, shouldn't be items should
be item is just going to be a snake object.
80:38 - I don't know why I'm calling an item, but
that's what I'm calling it. And we're simply
80:42 - just going to set like a new list equal to
that list. So okay, so now we're gonna say,
80:50 - well, tree,
80:51 - capital T,
80:53 - we're gonna do x equals random dot random
range. If you haven't imported random yet,
80:58 - make sure you do that. And y equals random
dot Rand range. rows. And rows, again, should
81:07 - be global. So let's make sure that this works
global rows. And after this, we're gonna say
81:16 - if I don't know how I just typed that, but
the length of and I'm doing something fancy
81:23 - here, and I'll explain what this does in a
second.
81:33 - Okay, so I know I just typed this stuff that
probably makes absolutely no sense, you guys,
81:46 - if you haven't been using Python for a little
bit, but pretty much what this is going to
81:49 - do is we're going to get a list of a filtered
list. And we're going to see if any of the
81:57 - positions are the same as like the current
position of the snake pretty well. So what
82:04 - we're doing is we're saying that, we want
to make sure that we're not going to put a
82:08 - snack on top of the snake. Because if we have
a really long snake, the chance of that happens
82:12 - is actually somewhat high. And I didn't do
this when I first coded the game. So what
82:16 - happened is, when you have your snake moving
around the screen, all of a sudden the snake
82:18 - could pop up, but it's like on the tail of
the snake, which you don't want. So what this
82:23 - is doing, and just type it out, you don't
really have to understand it is we're saying
82:27 - this, this means a function, Zed, and we're
just checking if this Zed dot position is
82:34 - equal to x, y. So if it's equal to x, y, which
is the position we just generated, here, by
82:39 - getting two random numbers, x and y, then
we're gonna have to do this again. So we say,
82:48 - continue. And else we break like that, and
then I'm just gonna simply gonna return in
82:56 - the tupple, or to go where you want to call
it x, y. Okay, so this is confusing. But um,
83:02 - you can do this in like a much longer way
with a for loop, where you pretty much loop
83:05 - through every position in this list, you check
it against x and y, you see if it's the same,
83:11 - if it's the same, then do this loop again.
Otherwise, you break and you return x, y,
83:16 - that's all we're doing in there to generate
a random set. And it messagebox you gonna
83:20 - leave that and in here, now, what we're good.
Okay, so now that I've created this, this
83:25 - random snack function, what I need to do is
I need to use it. So I'm just going to create
83:29 - a new object, and we're going to call this
snack. And it's going to be equal to another
83:33 - cube, right, because we want to have the same
functionality want to build, draw it, possibly
83:38 - move it around, right, so we're just going
to create a new cube object, we're going to
83:40 - give it a position of a random stock, which
is going to select this random stack. And
83:46 - the random stack, I believe, oh, it takes
a row in an item. So what we're gonna do is
83:51 - we're gonna give it row rows, and we'll just
give it our item, which is gonna be s. And
83:56 - then after that, what else do we need for
cube, I don't think we actually need anything
84:00 - else, I think that's all we need, oh, I'm
gonna change the color. That's what I want
84:04 - to do. But I changed the color equal to green.
So red, green, blue, 255 for green. So that
84:09 - shows up and is visible on the screen. And
now what I'm going to do down here in this
84:12 - while loop is I'm going to say, snack, I'm
going to check if our the head of our snake
84:18 - has hit the stack. And if it has, we're going
to add another part to the body of the snake.
84:24 - Otherwise, we're not going to do that right,
and then we're going to generate a new snack
84:27 - and so on, we're going to just gonna say if
s dot body zero dot pause, and this is going
84:35 - to be the head, right, because we haven't
ordered I don't need those brackets is equal
84:39 - to snack dot pause. And remember, these are
both cube objects, that's works fine because
84:43 - we're going to be tuples. Then what we're
going to do is we're simply going to say s
84:48 - dot add cube, which is a method that we have
there that we haven't actually written yet.
84:52 - And we're gonna say snack is now equal to
well, a new cube. So I'm just gonna copy this
84:58 - and paste it here. So All we're doing is now
generating a new cube for snack, I'm sure
85:03 - I could put something in that, like change
it, but this is just the way that works. Okay,
85:08 - so now that we've done that, we should be
able to move around the screen and get the
85:11 - snack. But we need to code in the Add snack
method here, which I believe I have here or
85:16 - add cube. So the odd cube is pretty straightforward,
we just have to figure out where we're adding
85:22 - that snack, or wherever adding that cube,
I don't know why I keep calling it snack to
85:26 - the list. So what we're gonna do is we're
gonna figure out where the tail is. And we
85:31 - want to add it after that tail. So tail is
equal to self dot body, negative one, the
85:37 - last element in that list, we're gonna say
dx d y, which again, is going to be a direction
85:42 - extraction, I'm just shorting it, shortening
it here, it's gonna be tailed during x, and
85:45 - tail dot during y, like this. Now, again,
you could do this in two lines, I'm just doing
85:53 - it like this because it's faster. And now
I'm going to copy something in and we're just
85:57 - go through exactly what this does. Okay, so
pretty much this looks complicated. But all
86:05 - it's going to be doing is checking what direction
that we're currently moving in, like the head
86:09 - of the keyboard or the tail actually, of the
cube is moving in. So that we can then make
86:14 - sure that when we add that cube, we know where
to add it. So for adding it like to the right
86:19 - of the cube to the left of the cube above
it below it, and we can give it the correct
86:23 - direction to be moving. So pretty much
86:28 - what we do here is we just say we're going
to append a new cube to our body. And its
86:34 - position if we're moving to the right, which
and here we are, because the x equals one
86:39 - is one less than the x position of that tail.
So whatever the last cube is one less than
86:45 - that. And that's so that we don't add a cube
per se to the right when we're moving to the
86:49 - right. And then we're just going to have overlapping
cubes and you're not getting to see them right.
86:54 - Same thing down here, for moving down. That
means are not down sorry, for moving left,
86:59 - that means we need to add the cube to the
right side. So one plus the tail of the expedition
87:05 - of the tail of the cube or of the snake sorry,
so that we can have it in the proper position,
87:11 - right and same thing here with x and y, or
with y so that we're moving up or moving down
87:17 - when we add it above. Otherwise, we move we
put it below. So I just stumbled through that,
87:23 - because there was a lot of different words
are very similar. Anyways, what we need to
87:26 - do now is simply set the direction for that
cube so that we added it in, if we just left
87:32 - it like that, you wouldn't be moving any words,
we just need to change that to the current
87:36 - direction of that tail. So whatever the tail
is moving, that's where this new cube is going
87:40 - to be moving in that direction. So we're going
to say self dot body, negative one dot x equals
87:48 - dx. And then same thing down here, except
we're just gonna change this to y, then y
87:55 - equals d y, and not again, it's just the where
our tail is moving at the current moment.
88:01 - Okay, so now that we've got all that done,
it's time to see what syntax error we get.
88:05 - Next name, Rose is parameter and global. One
second. So I've actually never even ran into
88:12 - that error, oh, global rows as, okay, so let's
just make this our, and let's change this
88:18 - to be one second, we can just get rid of this.
And this should work. There we go. So now
88:27 - move around like this, the only issue is our
snack is not being generated on the screen.
88:31 - And I don't know why that is exactly happening.
Oh, it's because we're not drawing the snack.
88:36 - That's what so now, global snack up here believe
that's what I called it. And I'm simply just
88:42 - gonna say snack dot drop, like that. And I
gotta give it a surface. So let's give a surface
88:49 - Let's run. And air named snack is not fine,
because I didn't global down here. So let's
88:57 - go with that.
88:58 - Okay, so now we have the slack on the screen.
And you can see that when we collect it, we
89:04 - have that cube added to the end of our snake.
And that pretty much is almost the game done.
89:10 - So all we need to do now is right, that reset
method. And then we need to just simply check
89:16 - like when we lose a great another snake can
go through each other through itself. And
89:19 - you can see we have a huge error when the
snake can cook through itself. So we need
89:23 - to make sure that when we hit ourselves, we
like end the game and we need to write that
89:28 - message with this method as well. So to do
this, again, I'm just gonna copy in this for
89:34 - loop, and then we'll kind of go through go
from there. So let's move in here. Okay, so
89:41 - for x and range, the length of s dot body,
we're gonna say s dot body x, which is going
89:46 - to be we're looping through every cube in
our snake body. We're checking if the position
89:52 - is in a list of all the positions. After that
works. That's how we're checking the collision.
89:59 - If you want to do it. Your Own Way, go ahead.
But this is the way that I like to do. Okay,
90:03 - so now what I'm going to do is I just want
to print to the console, like their score,
90:07 - just so that I would just say score. Oops.
And that will say plus is the length of s
90:16 - dot body. But this is going to have to be
converted to a string unless I put a comma
90:21 - like that. So let's just do it like that.
And then I'm going to simply display a message
90:26 - box will say, message box, like this message
underscore box, we have a subject and we have
90:32 - content. And we'll, we'll do that in just
a second because I haven't yet actually coded
90:36 - that. And then we're going to reset our snake
by just doing str reset, and this is going
90:39 - to take a position, which is going to be our
starting position again, 1010. And then we're
90:43 - going to break out of this for loop. Because
if we collided once, we don't really care
90:47 - if we collide it again, and go back, and we
continue the game with a snake that has length
90:53 - one. Okay, so our reset on this is pretty
straightforward. All I'm doing in this reset,
90:59 - is I'm just gonna get rid of our terms, I'm
gonna get rid of our body. And I'm just gonna
91:06 - change like the direction x and the direction
y. So maybe it's faster by just copy down,
91:09 - and you guys can just copy this out. So pretty
much all I'm doing is I'm setting a new head,
91:15 - which is going to be equal to, again, like
whatever position we given because we can
91:19 - move it at a different position if we wanted
to. I'm clearing self dot body, which is again,
91:24 - a class variable here. And then I'm adding
head, I'm setting turns equal to blank direction
91:31 - x zero direction, y is set to one against
that we start moving. And you can see, it's
91:35 - pretty much exactly what I have typed out
here, except I'm just resetting the turns
91:39 - list. Okay, so now that we've done that, all
we need to do code is messagebox. So this
91:44 - one's pretty easy. Um, you can see up here,
just in case you haven't looked yet, I import
91:49 - t kinter, st K, and then from G kintra. Import
message box. Now this is how you create a
91:54 - message box in pygame. And this is how you
create one that actually shows up on top of
91:58 - the screen. And that doesn't like float kind
of below it or doesn't show up right away
92:03 - if you want to see that. So just watch this
is extremely useful to use in other programs
92:08 - too, if you if you copy up this function,
and then you just drag it into other
92:16 - attributes.
92:18 - topmost column true, what this simply does
is we're creating a root oops, which is not
92:24 - root dot t gates route equal to tk.tk, which
is going to be a new TK enter window, we're
92:29 - making sure that this window is going to be
on top of anything. So if we have like a bunch
92:33 - of different windows open, it just comes up
on top, which is what we want. I'm just going
92:37 - to simply make this window now invisible.
And I'll explain how this works in a second.
92:42 - And then from this message box, what do you
call it method, class, whatever. It's gonna
92:47 - say message box dot show info. And then we're
gonna do subject and content. And this just
92:53 - takes it takes a few more parameters as well
if you want, but pretty much this just shows
92:57 - info, given whatever subject we type in and
whatever content we have. And now I'm going
93:01 - to say try
93:02 - group dot
93:05 - destroy like that. Except groups. And don't
ask me what this does, because honestly, I
93:14 - don't know. But it just works. So pretty much
it shows his message books. And I'm actually
93:19 - pretty sure the way that this works is it
constantly keeps trying to destroy the message
93:24 - box until eventually you click the X button
and then it actually can, I think it's like
93:28 - something like that. So anyways, that's how
you create a message box. And with that we
93:32 - all we need to do is add a subject and contents
on inside you lost. And our message will be
93:41 - play again. Let's run the program for the
last time and make sure everything's working.
93:48 - So there we go. I just need to get my snake
to a length that is large enough to the point
93:52 - where I can actually hit myself. Okay, and
there we go. So pretty much we ran into an
94:00 - error. What is the error I spelt attributes
wrong? That is lovely error to run into. Let's
94:05 - run back up here. Attributes attributes attributes.
Where'd I even make this function? I must
94:12 - have scrolled path it there we go. And I believe
that's correct. Let's try this go so I'm actually
94:21 - just gonna go see if I can There we go. Okay,
so we get a message says you lost plugin and
94:27 - the reason I died there by the way is because
while I was moving right, I moved left So
94:30 - technically, the head of my snake actually
ran into another part of it so it says you
94:35 - last play again. And you can make that say
exactly what you want and then we can see
94:40 - that our guy just continues to move so on.
So anyways, if you guys want to see more content
94:46 - like this, go check out my channel it is named
tech with Tim and I'd have a bunch of videos
94:50 - teaching stuff like pygame and doing a bunch
of Python tutorials you guys will definitely
94:54 - learn a lot falling through some my videos
and I would be very grateful if you guys went
94:59 - over there and like some My videos and subscribe.
95:07 - What's up guys, in this set of videos I'm
going to show you how to program Connect for
95:12 - in Python. By the end of these videos, we'll
build something that looks like this. It's
95:19 - a simple two player Connect for game with
graphics, I think this is a really good exercise
95:26 - for your beginner to intermediate level Python
programmers who want to build their skills.
95:32 - I'll just finish up a game real quick, just
so you can see how this fully works. As you
95:38 - can see out of the diagonal, and it says player
one wind school. Alright, so more specifically,
95:43 - In this first video, we're going to do something
a little bit simpler, and then build up to
95:46 - that graphic based Connect for game. So by
the end of this specific video, you'll have
95:51 - something that looks like this. It's a command
line Connect for game where you actually manually
95:57 - type in numbers to drop your pieces, you see
the one there, two, etc. Alright, so let's
96:02 - start building that. Just quickly, I want
to mention that I'll be programming in Python
96:06 - three. And then using Sublime Text two as
my editor, I posted a link to a video on how
96:12 - to set up these things in the description.
So one of the first questions I asked myself
96:17 - when I was writing this game is what is the
best way to represent the board. So if I drag
96:21 - in a Connect for board real quick, you can
see that it is six rows by seven columns.
96:26 - And to me, this looks like the perfect structure
to represent as a matrix in Python. So that's
96:31 - what we'll do. So we'll define a function
called create board. And that's going to accept
96:36 - any inputs. And then we're going to make a,
a matrix of all zeros with the dimension six
96:42 - by seven. And to help us do this, we're going
to import a package called NumPy. And if you
96:48 - haven't already installed this, you can open
up a terminal window and just type in pip
96:52 - install NumPy. And as you can see, I already
have it. So we're going to use this as follows
97:00 - we're gonna say board equals NumPy dot zeros.
And that's gonna make a matrix of all zeros,
97:06 - which is good for initial state and then the
dimension six rows by seven columns. Cool.
97:11 - And then we just need to return that board.
And we can test to make sure that worked by
97:16 - doing the following create board, and then
print board. And as you can see, if I run
97:24 - Oh, no what happened. As you can see, if I
run that, we, we do in fact have this six
97:30 - by seven matrix of all zeros. So that looks
good, we're going to begin writing the main
97:34 - game loop now. So we're going to write a loop
that says while not game over. And so our
97:43 - loop is going to be running as long as this
game over variable is false. And the only
97:49 - way it becomes true is if someone has a foreign
row. So we need to initialize the game over
97:54 - to be false to begin with, equals false. And
the only way that's going to switch to true
97:59 - is if someone got a four in a row. So now
we're going to need to we're also going to
98:04 - want to real quick make our board initialize
before we start the game, just so we have
98:09 - something to put pieces into. So we have our
board, we have our game over variable. And
98:14 - now we're going to want to be able to ask
98:16 - for player one input. And then we're also
going to want to eventually be able to ask
98:28 - ask for player two input. So this kind of
leads us to the problem of Oh, how do we differentiate
98:35 - between whether it's player one or player
two's turn, so we're always going to define
98:39 - another variable here called turn, that's
just going to initialize to zero. So what
98:43 - we're going to say is, if turn equals equals
zero, then we're going to want to ask for
98:49 - player one input. Alright, so in Python, there's
a function a built in function called input.
98:56 - As you can see, it highlights blue for me.
So we're gonna say, selection equals input.
99:05 - And then we're gonna say, player one, make
your selection. So this is what the player
99:13 - was going to say. And then the way we're going
to initialize this game is we're going to
99:17 - just say they can type in between zero and
six. So this is what the player one should
99:23 - see. So if I build this, you see we run into
this error. So this is because Sublime Text
99:30 - doesn't accept this input function. So my
workaround for this was I installed a package
99:36 - in sublime called sublime RPL. I'll put a
link in the description of how to install
99:41 - this. And I can run the input function through
that. So now you can see player one, make
99:46 - your selection three, and doesn't do anything
with that input right now, but you can see
99:52 - that it's asking me that and I can type in
enter. Alright, cool. So we also just want
99:57 - to make sure that it saves our selection properly.
So we're going to print selection. And I also
100:05 - just want to see, you know, if I type in a
number, does it actually give me the number?
100:09 - Or does it give me a string that represents
the number. So I'm going to also printing
100:13 - type of selection, I just want to see what
we're getting. So I'm going to run that again.
100:17 - And as you can see ever again, but we're going
to go to splice mrpl. And the link is in the
100:22 - description, as I just said, run current file.
So to and as you can see, it gets to, but
100:29 - it says it's a string, so we're gonna want
to make sure that it's actually a integer.
100:35 - So we can just surround this with an input.
And this should work. So let's see, run that
100:41 - again. And you can also run this through the
command line. So if you run this in your terminal,
100:47 - go to the directory that the file is in and
type in Python, and then file name, it will
100:53 - also run it just as I'm running it in this
sublime RPL. Player One, make your selection
100:59 - three, cool analysis says three, and it says
the class of that is an int. So that looks
101:05 - good to me. So now you can save some sort
of selection from the user. And you can also
101:11 - edit this so that it requires you to make
a specific number type in a specific number,
101:18 - but we'll just leave it as like, we'll imagine
our players are following the directions right
101:23 - now. Alright, cool, we have that. And then
we're always going to want to be able to ask
101:27 - for player two's input. So that's going to
happen else otherwise have The turn is not
101:32 - equal to zero. Then we want to ask our player
to input so selection equals, and we'll just
101:41 - copy this from above. And we'll just have
to change this to say player to make your
101:48 - selection. All right. Cool. And now at the
end of the turn, no matter whose turn it is,
101:56 - we're gonna want to increase our turn by one,
so turn plus or plus equals one. So I'll make
102:04 - it incremented by one. And then we'll also
what we're going to also want to do is we're
102:09 - gonna just make this odd even. So we're going
to use mod division, so it's going to be turn
102:14 - mod to turn equals turn mod two. And this
is just basically making it go take the remainder
102:25 - of whatever our turn is divided by two. So
this is just gonna alternate between zero
102:30 - and one. So it will alternate between player
ones turn and player two's turn. So let's
102:35 - just see if this works properly. So we're
gonna run this build Python current file,
102:44 - player will make your selection to player
to make your selection for player one, make
102:48 - your selection to Oh, that looks good. It's
alternating between our player one or player
102:51 - two. Cool. Okay, and now we're going to want
to start building our actual functionality,
102:57 - we're going to want to be able to make this
selection right here, actually drop a piece
103:01 - into our board. So I'm going to define another
function up here called definition drop piece.
103:09 - And we might define a couple functions. So
maybe have dropped piece and I will just do
103:15 - pass for now, maybe we'll also have like,
is valid location. So that will check whatever
103:21 - number that the player typed in, we'll check
to see if that's a valid location.
103:29 - We'll also define a function called get next
open row, and how all these functions are
103:36 - going to work together as as follows. So it
all begins with the player making a selection.
103:41 - The zero to six here represents the column
that they want to drop their piece in. So
103:46 - maybe a more appropriate title for this would
be co l representing column C. Well, next,
103:53 - we're going to take this column and the current
board we have and pass it into this is now
104:00 - location functions aboard comm individualize
how we can check to see if the column they
104:06 - selected is a valid location, we will print
out the board real quick.
104:17 - So as you can see, imagine this is the zero
throws the first row, second row all the way
104:25 - up to the fifth row here. And then this is
the zeroeth column, first column, second column,
104:30 - etc. We're starting at zero as our first index.
So if we wanted to check if the column that
104:38 - the user selected, let's just assume that
the user always typed in a valid number zero
104:42 - to six, we wanted to check to see if it's
valid, all we need to do is make sure that
104:47 - this top row for that specific column is not
been filled. So let's imagine that we're putting
104:55 - ones in for player one going in twos and for
player two guys. So if this top row is still
105:01 - zero for the specific column we selected,
then we know that it's okay for us to drop
105:06 - a piece in that row, or in that column, it
hasn't been filled all the way to the top.
105:12 - So do that. So this is the fifth row. So all
I'm going to do is just check to see whether
105:16 - or not the position at the fifth row. And
let's say, you know, whatever column we select,
105:24 - is zero. And if it is, that means a column
is still free, if it's not, then that's not
105:30 - an allocation, we'll have to have the user
try something else. So to do that, let's just
105:35 - do board. So we're going to return board.
And then the, the row is five. And the column
105:44 - is whatever the user selected. So here, so
and we're going to make sure that's equal
105:51 - equals zero. So if that's true, then we're
good to work good to let them drop the piece
105:58 - there. If that's not true, that means a column
has been filled up all the way. And one thing
106:04 - I'll note that will probably change in a future
video is that it's kind of getting messy my
106:08 - code a little bit with just throwing these
random numbers here all the way all over the
106:12 - place in programming, this is a called magic
numbers, you kind of don't know where they
106:15 - come from. So I'll clean those up in some
of the future videos in the series. So return
106:22 - board five, column equals equals zero. And
that is just checking to make sure that that
106:26 - column has an empty slot. Okay, so now that
we've gotten the valid location, let's get
106:31 - the next open row in that column. So if we
think back to our board, that's just checking
106:38 - to see when we drop it in that say, the zero
column here on the left, checking to see which
106:46 - row of these, the piece will fall on. So to
do this, we're going to write a quick little
106:52 - loop. So we're going to do
106:53 - four.
107:00 - And we're going to set the past in the board
and the column into this one. So the loop
107:06 - we're going to write here is for our end range.
And I'm actually going to start getting rid
107:12 - of some of these magic numbers. So I'm going
to initialize a global variable called row
107:20 - count. And often Global's are capitalized
just to show that are static variables that
107:27 - don't change or capitalized just to show that
they're non changing variable. So the number
107:31 - of rows we have is six, and the number of
columns we have is seven. So I'm going to
107:37 - do for our so for row in range, so the number
of rows we have, so row count. And we're going
107:46 - to check the board position, we're going to
see, if board our position, or so the column
108:00 - equals zero, then we want to return that row.
So basically, if the row is equal to zero,
108:08 - so imagine we're filling this whole board
up with ones and twos. If the slot is still
108:13 - zero, that means it's empty still. So we're
going to return the first instance that it's
108:18 - empty. So this R is going to count from zero
to row count minus one. And we're going to
108:26 - return that first case where it equals zero.
Okay, so now we got the next open row. And
108:33 - then finally, what we're going to want to
do is drop the piece. So this is going to
108:36 - take in the board, the row and the column.
And then we'll also add something, we'll just
108:42 - call it the piece. So whether it's player
one or two going, so all this is going to
108:49 - do is go board, row, column equals equals
piece. So we're going to make it fill in the
109:00 - board with whatever piece that the player
just dropped. So let's put this all together
109:04 - in our loop. So first, we got the column.
And now we're going to check if is valid location
109:12 - of the board in the column. And then we can
start getting the next empty row. So row equals
109:19 - get next open row. And that takes in the board
and column as well. So get next input in row
109:26 - board column. And then we're gonna finally
drop piece. And we're going to take in the
109:33 - board, the row, the column, and then for player
one, the pieces just a one. And we're going
109:40 - to copy this in to player two as well because
player one and player two, the functionality
109:48 - of what they're doing is the same, but we'll
just have to change the piece here to two.
109:54 - So now and then finally, after the player
goes, we'll probably want to To print out
110:02 - the board, so we'll print the board here.
And let's see what happens now. So, tools
110:10 - build sheet, sorry, supply more IPL Python
run card file. So player one selection, we're
110:18 - gonna drop our piece right in the middle.
So at 0123 is the third column. So three.
110:24 - What happened? Why did it not fill in? Let's
figure out what exactly went wrong there.
110:31 - So should have updated the board, but for
some reason it did not. So let's see. Okay,
110:40 - I see what I did wrong here. So I accidentally
put in two equal sign here. And what we're
110:49 - really trying to do is an assignment, we're
not trying to set C of the board row column
110:53 - position is equal to that. So I didn't assign
it. So now it should work. So we'll rerun
110:59 - this. So tools, primary PL,
111:03 - Python, on current file, player one, make
your selection will say go to the middle three,
111:11 - player to make your selection, we'll do three
as well. Play one, make your selection. And
111:15 - as you can see, one issue we're having right
now is that the pieces are starting at the
111:19 - top and going downwards. And so the reason
for this is, our convention was to say that
111:24 - this was the 00 index, but in the actual lumpy,
they represent this right here as the 00 index.
111:34 - So I'm just going to add an additional function
real quick called print board. And all that's
111:40 - going to do is change the orientation. So
that what we're seeing is actually the day
111:47 - flipped over the way we're expecting to see
a Connect Four board kind of be building from
111:52 - bottom up. So print board, and we just need
to pass in the board. And all we're going
111:56 - to do is there's a command in dumpee. So the
command is I mean, just remember it, it is
112:06 - NP dot flip. And when to do board, and then
you have to flip it over, you have to specify
112:15 - the axis of the zero the axis, we're going
to flip the board over the x axis. So that
112:23 - should get it upside the right side up again.
So instead of doing print board here, we're
112:29 - going to now call our new print function.
So print board, and board. And we can also
112:36 - do that down here if we want to print doesn't
matter, I guess to start with print, or whatever.
112:45 - Okay, now let's run it again. Tools, primary
PL Python, on current file, player will make
112:53 - your selection 333. And as you can see, now
it's building up from with ones and twos.
113:00 - Just how we expect. Okay, that's all I'm going
to do for this video. In the next video, I'm
113:05 - going to kind of build in the functionality
of actually checking for wins with these ones
113:09 - and twos. And then in the next video, probably
after that, we're gonna actually add the graphics,
113:13 - so make sure you stick tuned for those videos.
Thanks for watching this one guy's seen a
113:19 - bit. What's up guys, and welcome to the second
video in the programming Connect foreign Python
113:26 - series. At the end of last video, we had something
that looked like this. It's just a simple
113:32 - command line based Connect for game. And the
one problem with this is that if I actually
113:40 - won this game, so as you can see, I just won
with player one down the bottom. The game
113:44 - doesn't let me know at all that I won. So
we need to implement that functionality. So
113:49 - we're going to define a function called
113:52 - winning move.
113:56 - And we're going to have that taken the board
and then the last piece that was dropped.
114:04 - So winning move, there's a bunch of different
ways to implement this. And the way we're
114:08 - going to do is not the most efficient method,
but it's probably the easiest describe in
114:13 - a video. So that's kind of why I'm selecting
it. But we're going to manually check all
114:17 - the different possible places you could win
and connect for. So all the horizontals all
114:23 - the verticals and all the diagonals, and check
to see if there is a winning combination on
114:30 - the board. And because we're doing this after
every turn, we're going to pick up the first
114:34 - instance of that winning combination, so we'll
know who won. Probably the more practical
114:40 - way would be to just check around the spaces
where the last piece was dropped. But that
114:46 - code got a little bit messier when I was doing
it before so I'm going to just do it this
114:50 - way. So we're going to first check all the
horizontal locations and To do that, we'll
115:01 - have a loop that iterates over the columns.
So for see in color range, column count. And
115:09 - so we defined a column count up here. And
that's seven. And one thing, I think would
115:14 - be a cool challenge for you guys to try that
I don't think my game is going to be able
115:18 - to do at this point in time is a very well
designed like Kinect for game, you'd be able
115:24 - to change these numbers. So like I could change
it to say, like 12 or something. And this
115:29 - to like eight in the game would still be able
to work, you still have like a Kinect for
115:34 - game, but just a bigger board. So that's a
kind of a cool way to make sure like you've
115:39 - designed things in a smart way, where you
don't have just these random like magic numbers
115:44 - popping up all over the place, I'm actually
going to change this real quick to row count,
115:49 - and column count, just because I'm going to
try to eliminate the magic numbers where I
115:54 - can and will clean this up to row count, minus
one. So this is the last row, the left index
116:03 - of the last row. Okay, getting back to winning
move. So we want to check horizontal locations
116:09 - for the win. So we're going to first loop
over all of the columns. And then we're also
116:13 - going to have a loop over all of the rows.
And what this loop is going to be over is
116:20 - not every single position but over all the
possible starting positions for a horizontal
116:27 - when. So if we think about our board a horizontal
when can start this spot, this spot, this
116:34 - button this spot, it can't start here, because
you can't go for over from this location.
116:41 - So this is our last column, the third column
in terms of indices, and then upwards, we
116:47 - can go all the way to the top vertically,
because it can so this half sorry, you can't
116:54 - really see, but we're making a box around
that half is where our starting locations
116:59 - can be for this first. This first check, so
we're iterating over the columns. So it can
117:07 - only be the number of columns, and then we
have to subtract three, because three of those
117:11 - columns couldn't actually work. So we're subtracting
three off of that one, and then all the rows
117:18 - could work. So that's totally fine. So now
we're going to check all the foreign row locations.
117:24 - So this is gonna look like something like
that. So if board row, column, so this is
117:35 - just indexing the matrix equals equals piece
and board, row, c plus one. So this is taking
117:48 - the next one to the right, so we're checking
horizontally, so we're only changing the columns
117:53 - equals equals piece and board, our C plus
two equals equals piece. And then finally,
118:04 - and board, this is the fourth piece in row
board, c plus three equals equals piece, then
118:18 - we're going to return true. So we want to
return true the first time this happens, we're
118:25 - not going to return this expression, because
that would return that would break out of
118:30 - this loop before we wanted it to. Okay, and
so what read it right again, this is not the
118:35 - best way probably to write it, you know, we
have these magic numbers popping up. But it's
118:40 - just a very simple way to check for all those
horizontal locations. Right. So let's do the
118:44 - same thing with vertical locations.
118:46 - locations for when. And actually before I
do that, let's just check to see if we can
118:56 - get some functionality on this. So if falsification
and we're gonna also write a if statement
119:02 - that says if winning move. And so we're gonna
say, Ford and then the pieces one. So if it's
119:17 - winning move, we're gonna just print out.
player one wins. Congrats, yay. Okay, let's
119:31 - just see if that works with the horizontal
real quick. And then we're also going to want
119:35 - to set this game over variable to true, because
the game is in fact over if the move is winning,
119:43 - so let's just run that real quick. Python
on current file. Okay, everyone make your
119:53 - selection three.
119:55 - Yay. It says player one wins. And we I guess
I accidentally printed the board at one extra
120:02 - time. But you know, we did get that functionality,
it did check that horizontal line. So I think
120:06 - that looks good. Obviously, you'd want to
test these like very thoroughly. But for the
120:14 - sake of the time of this video, I'm going
to just start going to the horizontal, the
120:19 - vertical location. So think about where vertical
locations can start. can start, you we need
120:26 - four up so it can start, it's pretty much
the opposite of the horizontal. So vertical
120:31 - could start all this bottom section, because
we need four up, but it can be in any column,
120:38 - so it's gonna be pretty similar to the last
loop, but we're gonna have to change the row.
120:46 - So we'll see in a sec, Shift Tab, we're gonna
have to change instead of the column count
120:54 - doing for C and column count minus three,
we're gonna have to do row count, minus three,
120:59 - because we can't start at the top row. And
then we're gonna have that add these pluses
121:05 - to the rows actually, row plus one, row plus
two. And the last one is rho plus three, and
121:19 - then write it once again, like, see if you
could figure out how to manipulate this, these
121:25 - equations to work for any length of a board.
And also, let's say maybe we want to make
121:32 - a game that was like Connect six, like, it'd
be a cool challenge for you guys to try to
121:36 - build these functions so that they could be
any number of columns, any number of rows
121:41 - and any number of pieces for the winning length.
Okay, so let's check to see if the vertical
121:47 - locations now we're gonna run this again,
real quick. So tools, Python, and current
121:56 - file, three. Cool, it works again. So we see
have the foreign row with a one right here,
122:07 - and it says player one wins, congrats. So
that looks good. Now we have to get to the
122:12 - little bit of the trickier
122:13 - things run out the check for the first we'll
check for the positively, slopes, diagonals.
122:23 - And we're also going to make a separate method
to check for the negatively sloped.
122:36 - And you'll see why we need to do this in a
sec diagonals. Alright, so let's think about
122:43 - it. We're gonna think about it the same way,
where are our possible starting locations
122:48 - that we could have a positively sloped diagonal?
Well, we can start here and go up, we start
122:54 - here and go up here and go up. So I think
the last piece, we can start here and go up.
123:01 - So this is going to be the top row. And we
can't go any farther than this piece right
123:07 - here. So that looks like we're doing row count
minus three and column count minus three.
123:12 - So
123:14 - right, so we're going to, we'll just copy
this code, see, oh, no, what happened? See,
123:24 - and I'll paste that in right here. Alright,
so we're going to have to subtract three from
123:29 - column count and from row count, and then
how this is going to increment as you start
123:33 - with that initial starting location. And then
we need to plus one to both things because
123:39 - it's a slope. It's not just a horizontal or
vertical now, so with do the addition step
123:47 - for both of these. Okay, cool. And as we've
been doing, let's just check to see if we
123:52 - can get a diagonal when here. So player one,
make your selection. I'll just start in the
124:04 - right, we're almost there. So close. Don't
screw this up. Now, Keith. Okay, and we'll
124:22 - check here. Cool, the diagonal there worked.
So that looks like it's working too. And then
124:28 - finally, we need to do the negatively sloped
diagonals. And so if we think about negatively
124:37 - sloped diagonals, they can start at the top
and go downwards. But they couldn't start
124:41 - any lower than this right here. This is the
last one they could start at, because they
124:47 - have to go down four. So that looks like it
would be the top rows and then also the columns
124:58 - minus three. So we're going to Start the rows
at three. And we're going to have to start
125:03 - the columns in the normal, normal location.
So this is going to start from three to the
125:12 - row count. And so it's three, because if you
think about it, z, this is the zeroeth row
125:18 - is the first row, second row, third row. So
even though it's actually the fourth up, it's
125:25 - third index. So that's why we're starting
at three. And that's going to go all the way
125:29 - to the top, and the column counts actually
good as it is. And so this is going to have
125:33 - to now go, it's going to go positively over
in the column direction, but it's going to
125:39 - go down a row, so negative one here, native
to here, and this is just a negative slope,
125:47 - you you know, you have one direction, positive
one direction negative, and this will be negative
125:53 - three. So let's test to see if this works.
Come on. or have your Python file. Okay, just
126:05 - build up the left side first.
126:11 - Okay, to
126:15 - okay.
126:16 - Okay, okay. Okay, we're almost into the negative
diagonal there. So player one, you can go
126:26 - three, and then player two, to then do cool
the native diagnose work now to Okay, so that
126:34 - looks like we have all the possible winning
directions, you should more thoroughly test
126:37 - to make sure the all the edge cases work.
But to me, that looks pretty good. So we're
126:43 - also going to implement the functionality
for player two in this main game loop. Okay,
126:51 - so this is player two, Player Two Wins from
grads Game Over true. Okay. And if you wanted
127:01 - to, you could just break out of the loop,
if you didn't want to see this board, and
127:07 - the turns changing at the end. Okay, so that's,
we've now finished the command line version
127:14 - of the game. So we'll start building out,
probably in the next video, we might clean
127:18 - up the code a little bit, and then we'll build
out the graphics. Okay, see you in a bit.
127:25 - What's up guys, and welcome to the third video
in my programming Connect Four in Python series.
127:31 - In this video, we're actually going to implement
the graphics for our game. So at the end of
127:36 - the last video, we had something that looked
like this, it was a fully functional command
127:42 - line base Connect for game. So we're going
to take this game, and we're going to expand
127:48 - on it to actually make it look nice. So the
first thing we're going to do to do that is
127:52 - import a library called pi game. And just
like the NumPy library, if you don't have
127:57 - pi game installed, just open up a new terminal
window and type in pip install pi game. As
128:03 - you can see, I already have it. Cool. Alright,
and now what we're going to do is we're not
128:08 - to start out by initializing pot pi game.
So there's you have to do in any pi game project.
128:14 - So before our game loop starts, we're gonna
do pi game.net.
128:20 - Okay, and then what we're going to have to
do is define our screen size, how big do we
128:27 - want our game to be. So if I real quick, just
build the finished version I have, you can
128:34 - see that, you know, it's pretty, you know,
you can kind of break this game down into
128:40 - squares, I would say you have squares that
represent each column in each row. And then
128:46 - I had this one extra row at the top. So we're
gonna define each one of those squares as
128:52 - 100 pixels. So the sizes we're going to talk
about right now are all in pixels. So the
128:58 - square size is going to be 100 pixels. And
then our width for our screen is going to
129:04 - be the number of columns, so the column count
times the square size. Cool. And the height
129:13 - is going to be the row count times the square
size. And actually, if you saw my, the game
129:21 - I just dragged in, I'll drag it in over time.
I actually added one additional row because
129:27 - I wanted this spot where I could display this
circle that I'm dropping. So we'll actually
129:32 - make this row count plus one times square
size for the height. And that will be packaged
129:40 - together nicely in a variable called size
which will be a tuple of width, comma height.
129:46 - And then to get pygame to actually read that,
we need to type in the following screen equals
129:53 - pi game dot display, dot set mode and then
We'll have it read in the size. And if you're
130:04 - wondering where I'm kind of just magically
getting these functions from, I'm looking
130:08 - at the documentation on the PI game site.
So if you go to pi game.org, slash docs, you
130:15 - can find all the kinds of functions that I'm
using, I'll post a link to that in the description.
130:26 - I'm going to real quick test to see our screen
is actually working. So you can just run Ctrl
130:31 - B. And as you can see, the window popped up,
and then it disappeared. We'll handle why
130:36 - it's disappearing in a second. So it looks
like though is reading in that screen. Cool.
130:42 - So let's now create a function called Where
do a couple things. So I think first we'll
130:49 - define a function called draw board. And this
will just be like print board that we defined
130:55 - up here. But now we're actually going to draw
it with the PI game graphics. So draw board
131:01 - is going to have to take in the board, and
that's about it. And I'll actually pass this
131:05 - for now, because we're going to make some
changes to our loop before we do this job
131:10 - board. So the first major change we're going
to do to our loop is pygame is an event based
131:17 - game library. So pi game kind of works and
allows you to function in the game. By just
131:23 - reading all of your movements of your you
know, the keys, you press the mouse buttons,
131:27 - you click the mouse, like how you move your
mouse, it reads those all in as individual
131:32 - events. So that looks like something like
that. So for event in PI game, dot event dot
131:38 - get. And as I just said, events are like mouse
motion, mouse button down, key down, etc.
131:47 - So we're going to read in, we're going to
drop a piece by clicking down. So that's one
131:51 - of the important events we'll have to get.
So we're going to first do just kind of follow
131:57 - me on this one, event type, event type equals
equals pi game dot quit. So this is just something
132:05 - you want to handle in all of your games that
you make, just allowing your game to properly
132:10 - exit out, if you click the button here in
the top right that x out, x is out of it.
132:15 - So if that happens, we have to do a system
exit just so it properly shuts down. And to
132:22 - get this sits right here, we're gonna have
to import that into our project goes well
132:25 - that means system. And that comes to fall
in any Python installation. Okay, system makes
132:33 - it now to get to the more interesting stuff.
The event that we really are going to care
132:38 - about to start is mouse button down. So if
event dot type equals equals pi game, dot
132:47 - mouse button down and all the different events,
you can also find on the PI game website under
132:54 - the docs. The game is going to run by us clicking
down on a specific spot in the screen where
133:02 - we want to drop the piece. So instead of reading
in the column, we want to drop it in as we
133:08 - did previously. Now this column is going to
be populated by where we click. So I'm going
133:13 - to real quick, put all of this all of this
behavior into this mouse button down event
133:20 - type because now the events of us dropping
the piece always happen when we click the
133:25 - mouse button down. So we don't want to tap
in otherwise we don't want it to be asking
133:28 - for this input. Alright, so column equals,
and this is going to be where we click on
133:33 - the screen. So just for now, I'm going to
just kind of comment out this stuff, just
133:42 - so it doesn't run on us while we're testing.
And let's just real quick, see if this fixed
133:49 - our error of the screen disappearing right
when it pops up. What happened? Prince as
134:10 - you can see, now we have this screen and it's
not, you know, it's staying here. So that's
134:16 - because we actually added in this event loop
here. And knows kind of continue while these
134:21 - events are happening. And the exit out will
be handled properly by this this system exit
134:26 - cool. Alright, so we have our screen looking
pretty good but doesn't have any graphics
134:33 - obviously.
134:39 - So we're going to implement the draw board
function now. So we think about it. I'll drag
134:45 - in the finished one I have again, we're gonna
draw some sort of rectangle for each of these
134:52 - slots, and then a black circle inside those
rectangles. And then we'll have to draw this
134:58 - afterwards. This piece So we drop and then
whenever we do drop a piece, the the one or
135:03 - two that's in our command line based game
on to become like a red circle or a yellow
135:07 - circle based on what we're doing. So let's
implement this. So first, we're going to iterate
135:20 - through kind of every spot in our board. So
for our refer, we'll say see in range, column
135:31 - count. And then we'll do the same thing for
our in range row count, just as we did above
135:42 - here, and when we're iterating through all
the spots, well, we need to initially just
135:48 - draw it as like an open, you know, a blue
blue rectangle, and then in that blue rectangle,
135:56 - we want a black circle. So we're going to
do a pygame dot draw function. So first, we're
136:01 - going to draw a blue rectangle. So that looks
like kind of our game board, and then the
136:08 - black circle inside of that will be the open
slot. So we're going to draw that on the screen.
136:14 - And I'm going to drag in again, the light
the library, so I can see exactly what I'm
136:20 - doing. So as you can see here, pygame dot
draw rect, we need to take in the surface,
136:25 - the color, the rectangle we want to draw,
and then the width. So the screen is the surface,
136:33 - we're gonna draw it on the color is we want
a blue color. So I'm going to define blue
136:37 - as a global variable, global static variable
up above, this is going to be an RGB value.
136:44 - So we're gonna say it's 00, comma 200. And
that means are 255 or so. So that's gonna
136:50 - be a very blue RGB value, because this means
red, this means green. And this means blue.
136:57 - And the only color that's actually has some
value is the blue here. So the color we're
137:02 - going to say, is blue, we just defined that
that's the RGB value. Now we need to find
137:07 - our rectangle. So our rectangle is going to
be there, you need to have four different
137:15 - things to define your rectangle, you need
to have the size of the width and height,
137:20 - and then also the position. So the position
is going to be this might be take a little
137:26 - playing around with to get this, but it's
going to be school see time. So these are
137:31 - numbers zero to, you know, the column count
and zero to the row count, there's gonna be
137:36 - see Times Square size, because we want the
actual is the top left corner of it. And that's
137:46 - going to the
137:57 - and then our position on the y axis is going
to be our times the square size. And our height
138:08 - and width, are going to be the other two parameters
of this, what they make up a rectangle object,
138:14 - and that's just going to be it's gonna be
a square, so it's square size, square size,
138:18 - height and width are the same. And the width
argument that I showed was in the documentation,
138:25 - as you can see it defined as zero. So that's
optional. And think that's just the outline
138:30 - like the line that surrounds the square, so
we don't need to implement that. Alright,
138:35 - let's test to see if just these rectangles
draw properly. So down here, we'll just do
138:40 - a draw board, taking the board as we did here,
and then what we have to do whenever we want
138:49 - to update our display is do pygame dot display
dot update. And I'll make sure that we actually
138:55 - see what we're supposed to see. So we'll build
that real quick. Oh, and as you can see, we
138:59 - have this giant mound of blue. And the one
problem I see right now is it's not actually
139:04 - opening up the I wanted the top to be open,
so we could have a piece that swings around
139:09 - it. So it shows us where we're dropping it.
So I think the problem with that is because
139:13 - our axis starts at 00, we actually need to
shift down by one square size to kind of account
139:21 - for that offset that we left for that space.
So we're gonna have to add a square size here.
139:29 - Now I build this again, as you can see, it
looks proper. Now we'll need to fill in some
139:34 - circles to represent the, the slots. So we'll
do that by drawing a circle in PI game and
139:41 - that's also in the documentation. So pi game
dot draw dot circle, and that's going to take
139:48 - in the surface of a screen, and now we need
a color. So I think a good color would be
139:54 - just black. So we'll define black up above
two, and black in RGB is just Zero everything
140:00 - 000. Okay, so this is black. And then let's
drag in the documentation real quick to see
140:13 - how we're gonna finish off this circle. So
Circle Circle Circle,
140:17 - okay position
140:18 - and then radius. So this is going to be the
position of the center of the circle, as you
140:22 - see in the documentation, and the radius will
probably want to be a little bit smaller than
140:25 - our square size, just so there's, the circles
aren't touching. So let's define a radius
140:33 - too. So our radius is going to be fun to find
that under the width and height and whatnot.
140:42 - So our radius is going to be a little bit
less than the square size. So we'll do I'm
140:48 - going to make this also they have to be integer
values, I believe. So once we start getting
140:52 - into division, it might get a little bit messy.
So to me n square size divided by two, because
141:00 - it needs to be the radiuses half the diameter
and the diameter would be the full square
141:04 - size, and then we'll just minus an arbitrary
like, integer value off of that. So now we
141:12 - can draw our circle with that radius, we'll
have to do the position first. So the position
141:19 - where is it, I forget, oh, it's in job board,
the position is going to be so if this the
141:24 - top left of the rectangle, our position for
the center of the circle is going to have
141:30 - to be that then with some offset, so square
size, then are Times Square size, plus square
141:41 - size. And the offset is going to have to be
like half of it because we're talking about
141:46 - the radius. So half of the rectangle is going
to be adding an additional square size divided
141:53 - by two. Adding a square size divided by two.
All right, let's see what happens now. Oh,
142:05 - and then I'm actually going to do the actually
specify the radius. So the radius is what
142:10 - we defined just a second ago.
142:12 - Build
142:14 - What happened? Yeah, integer argument expected.
Okay, so it looks like this division causes
142:20 - us to have some floats in our code. So we're
gonna have to actually make this and pygame
142:24 - it seems like only accepts integers. So make
sure that everything you every position and
142:30 - radius value, you make a integer. Come on,
baby, let's go. Cool. Yay, we got a board.
142:41 - All right, I think that's where we're gonna
end this video will actually animate the dropping
142:46 - of the pieces and then the kind of the pieces
hovering over here and the text saying you
142:50 - won in the next video. Alright, see in a bit.
What's up guys, and welcome to the fourth
142:58 - video in my programming Connect for in Python
series. In the last video, we implemented
143:03 - the background graphics for our game. But
if I click around on this screen, nothing
143:08 - actually happens. So in this video, we'll
finish implementing this graphics will implement
143:13 - the piece dropping and then a nice little
piece follow up here. Just a few quick notes.
143:19 - Before I begin, if there's a feature you wanted
to know how to implement, but that I didn't
143:23 - actually cover myself in these videos, feel
free to leave a comment down below, and I'll
143:27 - try my best to get back to you as quickly
as possible. Also, if you enjoyed this series,
143:34 - please please, please leave me some suggestions
for future programs that I can write make
143:38 - tutorials on, we're always looking for new
content. Alright, let's get started. So to
143:44 - start this video, navigate down to the main
game loop. before when we are selecting which
143:51 - column we wanted to drop a piece in, we manually
typed in a number between zero and six to
143:57 - specify this. Now that we have a graphic,
we want the column that we dropped the piece
144:03 - in to be dependent on where we click. So if
I click on the left side of the screen, we
144:08 - want it to drop a piece in the left column
if I click the middle, the middle column,
144:12 - etc. So where we dropped the piece depends
on the x position of our mouse pointer. So
144:20 - luckily for us pygame makes using the getting
the exposition of your mouse, super easy.
144:28 - So if you go to the PI game documentations
under the events, it lists all of these events,
144:34 - and then it lists the properties you can get
on these events. So for us, we care about
144:38 - mouse button down and we care about the position
so position gives us an x comma y tuple of
144:46 - where we clicked. And I can use that as follows.
So I can do print event dot position. And
144:56 - then I can rerun our game. And so as I click
on the screen You'll be able to see in the
145:00 - bottom left, he positions where I'm clicking.
So I click in the top left of the screen,
145:06 - it's about zero comma zero, that's where our
axes starts. If I click in the bottom right
145:11 - of the screen, that's the, the full dimension
of our game. And we specified that to be 700
145:17 - 700. So these are the pixel values of where
we're clicking. To develop a kind of way to
145:26 - select the column based on where we click,
we need to try to find a pattern on clicking
145:31 - in these different columns. So I'm going to
do that real quick. And if we will look at
145:36 - all these clicks I just made, we can see the
first click is between zero and 100. Second
145:42 - click is between 102 100 200 300 cetera. So
the last column is between 607 100. So we
145:50 - can somehow round these numbers down to just
give us zero to six, or back at where we were
145:56 - when we mainly typed in those numbers. So
we're going to do that real quick. So let's,
146:02 - we can go ahead and uncomment all of this
code. And actually, this is supposed to be
146:07 - a comment. So we can uncomment this code right
here, and we can just comment this out for
146:13 - now. So column, so we want that to be we'll
say that the exposition, so this is a tuple
146:22 - on the x values first, so the position of
x is equal to event dot position, and then
146:28 - it's the zeroeth element of that the column
now is going to be so this is between zero
146:37 - and 700. So the column we can get using, we're
gonna also just to make this our lives easier,
146:44 - we're going to import a library called math,
this comes default in any Python installation.
146:50 - So we are going to get what we want to drop
it by doing
147:01 - position x, then we're going to divide everything
by 100. Because this would give us a range
147:07 - between zero and seven instead of zero in
700. So the first thing we're going to do
147:12 - is divide it by 100. And 100, remember, is
what we define our square sizes. So to make
147:18 - our code a little bit more robust to changes,
we're going to do position x divided by square
147:23 - size. And then we want this to be a whole
number, an integer value, so we're gonna have
147:29 - to take the floor of this division so that
we'll round it down to the nearest integer.
147:35 - So we're going to do math dot floor. And then
the final change we're gonna have to make
147:42 - is we just need to make sure that the column
is an integer. Because we don't, we can't
147:47 - take the index of float value of decimal value.
So we'll just ensure that it's an injury by
147:53 - just surrounding it with an int. And now we
should be able to see when we click on the
148:00 - screen, we should see our board building up
and we can copy the same thing for player
148:05 - two. And we'll uncomment this.
148:10 - Comment that
148:12 - uncomment all of this. And then we'll make
player to be able to select the piece in the
148:17 - same way. So we'll say position x equals a
bench that vendor position zero, and then
148:25 - the column now, my god messy. Okay, we'll
delete this line. Cool. So let's see what
148:38 - happens when we build game. So now we have
this, where's the actual game window, what
148:44 - happened? Oh, like didn't pop up for some
reason. clicked down the middle. If you can
148:50 - see over here in the bottom right, our game
did pick up that click. So I click on the
148:54 - middle again, keep clicking on the middle.
And it keeps reading that I'm dropping the
148:59 - pieces. And so that looks really good. Now
we actually have to just represent that on
149:02 - the screen. So to do this, we'll just make
a small change to our draw board function
149:10 - that draws the graphics. So navigate to draw
board. And we'll just do a if statement here.
149:18 - Just say so the rectangles always drawn the
blue rectangles that make up the board. The
149:25 - black circle represents the empty square.
So if
149:30 - board
149:31 - right now, board row, column equals equals
zero, then we want it to be a black, we want
149:40 - it to be empty.
149:42 - If
149:45 - elsif board our row column, so this is just
indexing our matrix equals equals one. So
149:53 - that's what we see here. Player One dropped
it in the middle. Then we want to draw a circle.
149:59 - So we Just copy this line because we know
that this is in the right position, where
150:04 - we're just gonna have to change the color
up. So we don't want it to be black, we'll
150:10 - just use red and yellow, player one will be
red. So this is going to be red. And this
150:15 - is not a built in thing, we're gonna have
to define red. So we'll define red right below
150:21 - black. These are RGB values, so our needs
to be have a value and the other two can be
150:27 - zeros. So this will give us a nice bright
red. And then while I'm up here doing this,
150:32 - I'm also going to define yellow. Yellow is
both red and green is combination of both
150:38 - red and green in RGB. So 255 255, zero. So
now we have red and yellow for player one
150:45 - and player two.
150:47 - Ch,
150:49 - Where was that? Okay, yeah, it's red. And
then one last line, which will be the else
151:00 - condition lbf. Board our common our C is two.
So that's going to be pi game, or actually,
151:08 - I'll just paste this in, again, pi game, and
then instead of black, we'll make this one
151:14 - yellow. And then one thing that might not
be intuitive is that whenever we make changes
151:25 - to our game board, after this is all done,
this loop has been iterated through, we're
151:31 - going to want to call pi game dot display
dot update that will rerender the screen with
151:36 - the new changes. So let us let us and also
we're going to have to add the drop board
151:43 - resort, we are printing board on every turn,
but we're going to draw a board here as well.
151:49 - Okay, moment of truth, clicking right here,
know what happened. So it looks like it's
151:58 - populating, it's just populating it in the
wrong spot. And the reason for this is because
152:03 - of how our axes is set up. So as you recall,
when I clicked down on the top left, this
152:11 - is the 00. And this is the 700 700 space.
So in our game, though, this is the 00 piece,
152:24 - but it just kind of flipped. So when we printed
the board, we call that NP dot flip function.
152:28 - So we're just gonna have to figure out a way
to offset this to actually be in the bottom
152:33 - of the screen as opposed to the top. So to
do that, we can just use our height smartly.
152:41 - So what we really need to do is, we're starting
at the bottom, so we need to subtract whatever
152:46 - we're actually trying to build up from the
bottom from our height. So height minus this
152:52 - height minus this, let's try running this.
What is happening, alright, so we still are
153:05 - having an issue. And the reason we're now
having an issue is because this piece right
153:10 - here is still filling in the old fashioned
way. So they're kind of like filling in black
153:14 - and red and yellow tiles, all on different
axes. So what we're going to do to make our
153:19 - lives easier, is we're going to take out these
two lines into a another loop. So I'm going
153:29 - to delete those real quick. And we're just
going to do a whole nother loop of, so just
153:36 - try to bear with me here, I'm going to copy
this stuff, we're going to iterate through
153:40 - everything. Again, this might not be the smartest
way, but it's just going to be very clean
153:45 - for us to deal with. Because we're always
going to build our we're always going to build
153:53 - our background and then fill in the piece
afterwards, as opposed to like try to fill
153:57 - in our pieces as we're building the pack round.
So I'm thinking this will work well. This
154:04 - spacing is just messing me up. And these lines
are so long. Here we go. Okay, so if board
154:10 - RC is one, we're gonna fill it with that,
and then we can just delete this line.
154:17 - bring us back.
154:20 - Okay, so now we have two loops running but
this will kind of fix our problem of them,
154:28 - building our board out on different accesses.
So let's try running it again. What the heck.
154:36 - If board RC equals one, we're gonna have to
have make this an elsif. Otherwise, it's gonna
154:40 - fill out the board for all the empty spaces
at the start of the game equals two. Right?
154:50 - Cool. Let's see what happens now. It looks
like it's working properly, but it's just
154:56 - offset by one square. sighs and that's because
of this, right here we are initially account
155:03 - when we're building downwards, we're initially
accounting for this. But now that we're building
155:07 - upwards, we can delete that from it from the
height. So we're gonna delete this square
155:12 - size here. We're gonna delete this square
size here. And we should now fully have it
155:19 - working.
155:20 - Build.
155:21 - Yay, looks pretty good, huh? All right, cool.
So now that we've pretty much fully implemented
155:29 - a game with graphics, we're going to add a
couple additional features. So the first feature
155:34 - we're going to add is add this little scroll
wheel so that before we drop a piece, we can
155:38 - see what color the pieces in where we're going
to drop it. So to do that, we're going to
155:44 - add a new event, we're going to track a new
event. And that's going to be the event type
155:49 - equal to pi game dot mouse motion. And once
again, all the different events you can use
155:55 - are listed in the the pygame documentation.
And just like mouse button down, the mouse
156:03 - motion also has a position property. So I
can do position x equals event dot position
156:14 - zero. So this is gonna get me a lot more events,
though, because it's always tracking whenever
156:19 - making any motion. So this is going to be
constantly updating. So now we're going to
156:24 - use this position and draw some circles based
on where that position is. So if the turn
156:31 - equals equals zero, that's a player one's
going, then we're going to do pygame dot draw
156:38 - dot circle screen, the surface color is red,
because it's player one. The next thing we
156:47 - need to put in the circle is the position.
So the exposition This is the center of the
156:51 - circle, it's going to be at position x wherever
our mouse is, then we just want it to be offset
156:57 - enough so that the full circle can draw, so
we'll just make this square size divided by
157:02 - two. And then finally, we need to specify
the height of or the radius of the circle.
157:09 - And that's just the radius we've been using
for all the tiles. Else is means it's turned
157:14 - equals equals one, it's player two's turn.
And we'll just copy this and draw it. And
157:22 - now it's going to be actually yellow. So let's
look what that looks like if we build that.
157:28 - Alright, build.
157:31 - Okay, I forgot to get the display update,
just like we did in the draw function. So
157:40 - pygame dot display dot update, build. It looks
good. It's just not ever deleting the circles.
157:49 - So what we're going to do to fix this is right,
before we actually draw the circle, we'll
157:56 - just draw a rectangle that's black, that will
black out any previous circles that we have
158:01 - drawn. So pygame dot draw dot rectangle, surfaces,
the screen, color is black. position is going
158:09 - to start at the top left. So that's 00. It's
going to have with the hole with the screen,
158:16 - and then the height will be a square size,
because that's how big that buffer bar kind
158:21 - of at the top is. And that should be good.
I think I might have one extra. No. Yeah,
158:28 - I have one extra parentheses there. Yeah,
it looks good. So now we have this game over,
158:36 - Drop. Drop, drop, drop, drop. That looks good.
Cool. And so one thing that you also might
158:46 - want to change is that if I win the game,
so I'll win the game real quick with red,
158:52 - it automatically closes right away. So one
thing we can do is we can add a weight pygame
158:58 - has a built in weight function. So what we
can do is if the game over condition is true,
159:05 - so if Game Over, we'll call pi game dot time
dot weight. And this is the milliseconds you
159:11 - want to wait. So 3000 would equal three seconds.
So if I run this again 123 and I'll shut down
159:21 - automatically. Cool. And then right before
it shuts down, we want some notification that
159:27 - the player actually won. So initially, we
were printing it, but now we'll actually render
159:32 - the print function on our screen. So that
will look something like as follows. So we're
159:39 - going to delete the line this is player one
wins. And we're initialize a font up top so
159:49 - that will look like we'll do it right below
the the first update. So we'll do my font
159:56 - equals pi game dot font dot system. font.
This is all in the documentation, just copying
160:02 - some previous code I wrote. And the last time
I wrote this, I use a font called monospace.
160:07 - But there's other options, you can look at
the documentation for all the details. And
160:12 - we'll do font size 75. That's just an arbitrary
number that I found worked. And then if we
160:18 - go down below, to actually render that on
the screen horizontally, I can type the following.
160:24 - I can say, label equals my font dot render,
player one wins, explanation. And then I believe
160:37 - this one right here that I just put in, specifies
the axes that it's on, I'm not actually sure
160:42 - I might play around with that to check. And
then we want the color to be red, because
160:48 - it's rendering that text red, because player
one one, and then what we have to do to get
160:52 - that on the screen, do it quickly, we can
also use the PI game display dot update function,
160:58 - but I'm going to do something a little different
here. I'm going to do a screen dot blit. And
161:02 - that just updates that specific part of the
screen. And I toyed around with these values
161:08 - before I found that the XY pay or where this
will start at the top left hand corner of
161:13 - this text starting at 40, comma 10. worked
pretty well. So let's see what happens when
161:17 - I run that we're going to have read when
161:22 - player one wins. And one thing is that tile
gets in the way. Well, we could potentially
161:36 - do, we could potentially draw another black
rectangle if we wanted to.
161:40 - I don't know I'm not too bothered by it, we'll
fix it in one sec. We're gonna copy this for
161:46 - player two. And also Player Two Wins in the
colors gonna be yellow now. Build. So what
161:58 - happens if yellow wins. Making this so hard
on myself. 32 wins, yay. All right. And maybe
162:15 - what we'll do is at the start of the mouse
button down, we will draw that black rectangle
162:21 - as well. So we don't have that annoying. Annoying
tile getting in our way. So right wondering
162:26 - when we click the mouse button down, that
will make the thing disappear on it one more
162:34 - time.
162:35 - Ah,
162:36 - player one wins, it looks good. And you can
mess around with that as you see fit. Okay,
162:40 - I mean, that's like a pretty good game. I'm
pretty happy with it.
162:49 - So this is going to be Tetris in Python with
PI game. Now this is a pretty advanced tutorial.
162:55 - A lot of the stuff I do in here assumes that
you already have a basic knowledge of Python,
162:59 - you kind of know some of the syntax, and you're
not a complete beginner. That being said,
163:03 - if you are a complete beginner, feel free
to watch through, see what you might understand,
163:06 - you're probably going to learn something along
the way. It just might be a little bit confusing,
163:10 - because I'm kind of going to speed through
a few things that are I would consider like
163:14 - trivial right now. Okay. So first step for
this tutorial series is you guys have to download
163:19 - and install pi game because that's the module
we're going to be using. Okay, so let's give
163:22 - a quick preview of what our game is going
to look like. So this is Tetris, I didn't
163:28 - go too fancy with the graphics, I pretty much
just want to make sure that we get everything
163:32 - functional here. And then you guys can play
around and change stuff later on, if you want
163:36 - to. But yeah, this is a fully functioning
game. You can see it just like standard Tetris,
163:40 - we have different colors, shapes are falling
down the screen shows us our neck shape. And
163:44 - there we go, the road just cleared. So that's
all I'm going to show you right now. Because
163:48 - I want to get into actually coding, okay.
So, pretty much what we're going to be doing
163:55 - in this first tutorial, is we're going to
be working a bit in the main function, we're
163:59 - going to be creating the grid, we're gonna
be talking about formatting shapes, all the
164:04 - basics of just setting up for the rest of
the tutorials. So the first step, and what
164:08 - I need you guys to do is you're going to download
kind of like a starter file, okay. And that's
164:12 - just because if you see here, I scroll through
my file, I got a lot of lists, I got a few
164:15 - things set up here. And you know what I could
go through and type them all out. But that's
164:19 - just a waste of video, because it takes a
long time. So to save yourself time, and to
164:24 - save me some time, what I'm going to do is
just put a link in the description as a paste
164:27 - bin link, click that link and download this
code. It's just going to be all this it just
164:32 - has all the functions that we're going to
need for this. And then it has these shape
164:37 - formats, which I'm going to talk about in
just a minute. So go do that if for some reason
164:40 - Paceman is not working, let me know in the
comments. And I'll find another way to give
164:44 - it to you but I'm also going to put it in
the pinned comment, so that you can just copy
164:48 - and paste it from there as well. I do recommend
you check the indentation on it though because
164:52 - sometimes it messes up on paste bin and in
the comments. Okay. So now that you've got
164:58 - that downloaded, we're working on that I'm
gonna be working in PI charm. If you don't
165:03 - know about pi charm, don't worry about it,
you can just use it ideally, but it's just
165:06 - going to save me a bit of time because it
autocompletes variables, and it does some
165:10 - cool stuff. So that's what I'm going to be
working in, feel free to work in PI charm,
165:13 - feel free to work in whatever text editor
you want, just know that that's what I'm using
165:17 - doesn't make a difference. But some of the
stuff I do in here you might not be able to
165:21 - do And ideally, or Sublime Text or whatever
you guys are going to use. So we've got that
165:24 - all the way. We've got everything set up.
And now we're ready to actually start coding
165:27 - and understanding what's going to be going
on. So Tetris is a fairly complex game, you
165:32 - have shapes moving down the screen, they're
rotating around, they're moving left and right.
165:36 - When they hit the bottom, they freeze in whatever
position they're in. And then if you have
165:40 - a full row complete, like cubes, that not
row clears, and you keep going. And obviously
165:45 - you lose the game, if you stack up too many
blocks, and it goes up or above the top of
165:51 - the screen. Okay. So this first variables
we need to set up is our screen width and
165:56 - our screen height. So we got 800 700 here,
the next ones are play with and play heights.
166:01 - Now this is the actual red box that you guys
saw. That's what these are representing. So
166:08 - since in Tetris, we have a 10 by 20 grid,
we need to make sure that our play with is
166:12 - exactly half of our play height, so that we
have perfect squares, right. So doing the
166:16 - math here that makes it 30 width and 30 height
per block. So that's our block size of 30.
166:21 - Okay, so now this top left and top left x
and top left y, this represents the top left
166:28 - position of our actual play area. That's so
when we start drawing blocks, and we start
166:33 - checking for like collusion and stuff like
that, we just have these already set up, and
166:37 - we don't have to deal with that. So the math
is pretty straightforward. You guys could
166:41 - probably figure that out. You don't need me
to explain that. Okay, shape format. So these,
166:46 - and this is the longest part is why I got
you guys to copy everything is this is what's
166:49 - going to represent our shapes in Tetris. Now
you see that I have multiple lists inside
166:54 - of lists, in most cases, this is because each
shape has possibly more than one rotation,
167:01 - right. So this is the standard rotation of
the S shape. And that's actually what they're
167:05 - called in Tetris, like s said, I, oh, whatever.
And this is the second rotation. And these
167:10 - are the only two rotations or whatever that
s can have. So that's why we have them in
167:15 - here we have a five by five grid of periods,
and then whatever, there's a zero that represents
167:20 - where the block actually exists, okay. So
that you can scroll through, you can kind
167:24 - of look at them. And you can see for some
of them, for example, the square, well, it
167:27 - doesn't have any rotation, if you flip it,
it's gonna look the same. So we only have
167:30 - one list here, for J. However, though, we
have four, right, because we can rotate in
167:35 - different ways L, we also afford T, we have
four as well, okay? After this, I create a
167:41 - list. And it just holds all of my shapes.
So as I said, I just saw that That way, I
167:46 - can really easily select shapes, just by indexing
them in the list like zero through six. And
167:52 - shape colors here is the same thing. It just
corresponds to like for example, if I did
167:56 - shape zero, and I did shape color zero, then
that's going to be the color of shape zero,
168:00 - okay? Same thing with like, six. So shape
six, well, color list, or shape, color six
168:06 - is the color of that shape. So just makes
it really easy. We don't have to deal with
168:10 - dictionaries or anything like that. Okay.
All right. So now, we've kind of gone through
168:15 - the like starter file, I'd say. And you can
scroll down here, you can look at the function
168:21 - names, I'm not going to explain them, because
most of them are pretty straightforward. And
168:23 - I'll talk about them when we start coding
them anyways. But we do have a class here.
168:27 - Now this class is going to be the main kind
of data structure, if you want to call it
168:32 - for our game, and this is going to represent
or this class is going to represent different
168:37 - pieces. So the reason we have the class is
because we're going to call this a bunch of
168:40 - times, and it's pretty much just going to
hold the information like x y width height
168:44 - for our piece. So let's actually start coding
this now. So I'm just going to create my initialization
168:48 - function or method. And this is actually the
only method that I'm going to have. So I need
168:53 - another underscore, just butchered that. And
pretty much, what this is gonna have is gonna
168:57 - have an x, a y, and then it's going to have
a shake. Okay. And that's the only information
169:03 - we need for this. And I'll show you why. So
we'll say self dot x equals x, self dot y
169:10 - is equal to y, self dot shape is equal to
shape. And then what we're gonna do here now
169:16 - is want the color, and we want the rotation.
So self dot color. Well, I was already talking
169:22 - about this self dot color is just equal to
whatever the index of this shape is, in this
169:27 - color list. So what we can do is we can do
shape under short colors, square brackets,
169:33 - and then shapes dot index, and whatever shape
we were given. So if we're given the shape
169:39 - s, well, let's just find it in the shapeless,
whatever index that is, well, that's the color
169:43 - of our shape, pretty straightforward. And
then we're going to do a rotation. So rotation,
169:48 - this is going to set default to zero. And
this is so that whenever we click the up arrow
169:52 - key, we can just add one to this rotation,
and that will represent what shape we're actually
169:58 - going to be showing because again, remember
the shape list is a multi dimensional list
170:01 - it has, you can see here, in this case four
lists within it. Okay. Alright, create grid.
170:09 - I don't know if we want to do this one yet,
you know what, actually, let's go. Let's go
170:12 - ahead and do this one. It's not too complicated.
So the way that I'm going to represent the
170:16 - grid in Tetris, so that 10 by 20 grid, is
just by creating a list full of colors. Okay,
170:23 - so we're going to have a two dimensional list.
And within that second dimension, it's going
170:27 - to represent a bunch of colors. Okay, so I'll
show you just by coding and kind of talking
170:31 - about after, say, grid is equal to, and then
another square bracket here, for x, and range
170:38 - 20. And don't worry, I'll explain this in
one second. And it will say for x in range
170:47 - 10. Okay. Except here, we're just gonna use
000. Okay, so what I've just done here, this
170:54 - is pretty this is like, the Python way to
create lists k list comprehension, we're going
171:00 - to create one list for every row in our grid.
So since we have 20 rows, we want to create
171:06 - 20 sub lists, and each of these like sub lists,
or whatever two dimensional list is going
171:12 - to have a bunch of colors in it, how many
colors is gonna have? Well, it's going to
171:15 - have 10 colors, because we have 10 squares
in each row, we have 20 rows. So that's the
171:21 - way it works. These X's you could replace
with underscores, because we don't really
171:26 - care about the actual variable, we just need
to do this that many times. Now. 0000, or
171:31 - 000. Like that's right. Anyways, that's just
block stands for block. And the way we're
171:36 - going to draw the grid is simply by looping
through this grid, which we're going to return
171:41 - and just draw on each color. So it makes it
pretty straightforward. Okay. Now, the only
171:45 - thing that we have to do here, though, is
we have this locked position. argument now,
171:51 - locked position will right now we've created
a blank grid. What if there's already blocks
171:56 - that have been placed in our grid, so like
they've already fallen, they're static, now
171:59 - they're not moving? Well, we need to also
draw those. So to draw those, we're going
172:04 - to check if any of the positions in locked
position are not like or whatever positions
172:10 - are in locked position, we're going to get
that color and we're going to change the corresponding
172:13 - value in the grid. I'll show that just by
kind of coding here. So for I, in range, I'm
172:20 - going to do the length of grid. And again,
this is going to give us 20. Because the length
172:25 - of grid will that it's 20 of these, right?
Okay, so for i in range, one of grid for j
172:31 - in range, and then we'll say the Len of grid
I, because now we're in this list. So now
172:39 - we're going to do whatever the length of that
list is, okay? Alright, say if this if j comma
172:46 - i, because j is our x value, I is our y value,
because rows are represented by I and the
172:52 - columns represented by J in a locked position,
and just you know, locked pause stands for
172:59 - locked position, it's also a dictionary. So
you can see that it's a blank dictionary here
173:03 - and each position. So like, for example, if
we had like one one, is going to be set equal
173:07 - to a color, and the color could be something
like 255 00. Okay, and we're going to talk
173:11 - about that and create that later. But that's
just something he needs to know for now. Okay,
173:14 - so j is in locked position. So if that key
exists, let's figure out what that key is.
173:19 - So that key is going to be equal to well lock
position, or what the value is sorry, associated
173:25 - with that key J. Now we're going to change
whatever the current grid position is here.
173:30 - So for grid, i, j, is equal to C. Okay? I
know this might seem kind of complicated,
173:39 - but pretty much we're just looking through
this grid, and we're gonna find the corresponding
173:42 - position to the locked position, and just
change the color in the grid so that later
173:46 - when we draw it, we get an accurate grid.
Okay. And you guys will see how this all is
173:50 - kind of plays out later if it seems a bit
confusing, okay. And we're going to return
173:55 - that grid to wherever we're calling. Okay,
so that's one part done. Now we can move down
174:01 - and we can go into draw window, which is the
actually let's do get shaped. This one's really
174:05 - easy. Okay. So this is literally a one liner,
return random dot x, actually, what is it
174:15 - called here, I got to have a look, I think
it's random dot choose random dot choice.
174:19 - That's what is random dot choice. And then
we're going to be given a shape list. So say,
174:25 - shape. Actually, let's just, we'll call it
up here. Sorry guys shape.
174:32 - random choice shapes. All this is going to
do is it's going to pick one of these shapes,
174:36 - and it's just going to give it to us. So that
when we need to create like a new shape falling
174:41 - down the screen or whatever, that's all we
have to do. Okay, so good shape. random choice
174:46 - down really easy. Okay. Next one drug raid.
Alright, so what we're gonna do is we're gonna
174:51 - be past a surface, and the surface is obviously
what we're going to be drawing on. So we're
174:55 - gonna start by just changing the surface surface
that when surface dot fill with color this
175:00 - case the code is going to be blocked. Okay,
surface dot fill 002. Alright, next thing
175:04 - we're going to do is we're just going to draw
like a title on things. So the way we have
175:08 - to do this, we first have to start by initializing
font objects when we do pygame.font.net. Okay,
175:16 - this just means we're setting up font, and
we're getting ready to draw to the screen.
175:19 - We're going to create a font, a font is equal
to pi game, dot font dot, s, y s capital,
175:27 - as well as font. And then we need the font
name on the Comic Sans guy. So I'm gonna use
175:33 - Comic Sans size of the font, I believe. Yeah,
so the fight Randy's 60. Okay. So the way
175:39 - you want to set up your fight, you want to
change this, just change this to any font,
175:43 - you can look up fonts on the pygame website,
and then just give it a size, if you know
175:47 - the name of the font, type it in here, it
probably exists in, in PI game. All right.
175:51 - So now we're gonna need to set up a label.
So I say label is equal to font dot render.
175:56 - And then in here, we need the text that we're
going to render, in this case, I'm gonna call
176:01 - Tetris, need our anti aliasing of one, and
I believe we need a color. In this case, I'm
176:06 - going to make it white. Okay. So text, anti
aliasing, just set this one, I don't know
176:12 - why you need to set this one. But just so
that one, and then whatever color you want
176:16 - your label to be, okay, now that we've got
the label, we need to draw this label on the
176:19 - screen. So let's pull it it's not when I'm
used to typing when surface dot Blitz. And
176:24 - then in this case, we're going to put the
label, where do we want to put it? Well, now
176:29 - we want to figure out where the middle of
the screen is. So we could just hard code
176:33 - this in. But if we ever want to change the
dimensions of our screen, we want this just
176:36 - automatically kind of adapt to that. So we're
gonna do top left, x plus play width, over
176:46 - two, okay, and that's going to give us the
middle of the screen. If you don't understand
176:50 - that, let me know and I can explain it to
you in the comments down below. Okay, now
176:54 - we're going to subtract this sorry, this isn't
actually done yet, by the width of the label,
176:58 - because this is gonna matter. Depending on
how long the label is, we're gonna determine
177:03 - where we place it on the screen. So we're
gonna get the width of the label, and we're
177:07 - going to divide that by two. Okay, so now
we need to do the Y. While the Y is pretty
177:12 - easy, we can just statically type this in
because it's from the top of the screen. So
177:16 - I'm just going to give it unclick 50 is what
I typed in 30. Okay, and that should put it
177:22 - in the middle of the screen. And I can explain
that to any of you guys that might not understand
177:25 - it, you just leave a comment, because I don't
want to waste too much time because I think
177:28 - a lot of people might understand that. So
for i in range, now, the length of grid, because
177:34 - now we're gonna start drawing all the grid
objects onto the screen. So we created a grid,
177:38 - we know how that kind of format works, we're
gonna say, for J. and range, the lun of grid
177:46 - is same as before. And we're going to pygame
177:52 - dot draw dot rectangle, and then this guy
is gonna draw on the surface. And then we're
177:59 - gonna go grid, i, j, okay, and then top underscore
left, I need to put this in. What do you call
178:09 - it, brackets, your top underscore left search
need to scroll over top left, underscore x
178:15 - plus j multiplied by 30. And I'll talk about
this one in just a second how this works.
178:20 - And then top left, why Plus, I multiplied
by 30, another bracket, and there we go. Now
178:29 - we just got to deal with this grid thing.
So that means that we just now need to pass
178:32 - grid as well into our drop grid. Okay, way
this works, we're a loop through every color
178:39 - within our grid. So this is the color grid
ij. Alright, this is the surface we're drawing
178:44 - it onto. And this is the position in which
it's being drawn. Now, we also just need to
178:48 - add two things here that I realized I forgot,
because we need the x, y, we need a width,
178:54 - and we need height. And so for width and height,
well, that's go to the block size, and block
178:59 - size once again. And you know, we can even
multiply this instead of by 30. By block size
179:03 - in case we ever decide to change that. So
let's do that just to keep this nice and dynamic.
179:09 - And then if we keep going over here, the last
thing we need is a fill. So we're just gonna
179:13 - put comma zero to make sure that we fill in
the shape, we don't just draw like a border
179:17 - for it. Okay, we this works, we get our top
left x, and we're gonna figure out wherever
179:22 - we are. So which column we're in, multiply
that by block size, and that's our exposition.
179:29 - Same thing works for the Y with the starting
y position plus, whatever row we're in, multiplied
179:35 - by the block size will give us the correct
position to draw our cube in. Okay. After
179:40 - we've done all that, we just need to update
the screen. So pi game dot display to update.
179:47 - And there we go. So there's actually one last
thing we want to draw. And it's a red rectangle
179:51 - that you guys saw in that kind of represented
like the play area. So to draw it out, we
179:56 - do pygame dot draw, dot rect and then surface.
And then in this case, we're just gonna actually,
180:04 - let's see here, do we want do I want to dynamically
type this in? Or do I want to just statically
180:07 - draw it. So let's give it a color first of
all, of red series 00. Okay, and we're actually
180:12 - going to type it in dynamic, just in case
we decide to change anything later. So top
180:17 - left, x, and topless, why. And then the width,
we actually already have all these variables.
180:22 - So we have the play underscore width, and
the play underscore height. And in this case,
180:27 - we're going to give it a border size of four.
Okay. And that's all for drawing the grid,
180:33 - we might come back to this later, but for
now, that's it. Okay, so this just draws the
180:37 - actual grid, draw grid, and I've added this,
okay, we're just gonna copy this part of you
180:44 - guys that says draw grid. So surface, I'll
put this label and I'm just gonna move this
180:48 - in, because I realized I have another function
called draw window. So in draw window, what
180:52 - I'm going to do is surface stop, fill, whatever.
Okay, so, um, take surface and a grid. So
180:58 - I've just copied some of it from there. And
then instead of updating the screen here,
181:03 - we're gonna update the screen over here. And
we're just going to call our draw grid. What
181:09 - do you call it? function like this. Okay,
so now what if we want to draw the grid and
181:14 - we want to use this in another program, we
could just copy and paste this function, we
181:17 - wouldn't have to kind of take it out of here.
We wouldn't have to like dissect it. Alright.
181:21 - Okay, so draw grid. Again, this takes surface
and this takes grid. And there we go. I believe
181:28 - that's working well. Okay. Now that we've
done that, we're going to start coding in
181:33 - the main and in main menu, and this is what
we're going to finish off with this tutorial,
181:37 - because I know we're almost at the 20 minute
mark. Right. So what we're gonna do in main
181:40 - now is we're going to set up a few variables.
So the first variable we need is this locked
181:45 - position. locked position, okay. And again,
this is what we're passing up here into create
181:51 - grid, it's equal to a blank dictionary just
to set in case we don't pass it then we don't
181:58 - need it. Okay. So lock positions equals blank,
we're going to say grid is now equal to well
182:03 - create grid because we already created that
function with lock positions passed to it
182:07 - and create a variable called change underscored
piece, it's gonna be equal to false, we're
182:12 - gonna make run equal to true, this is just
for our while loop that we're gonna use, we're
182:16 - gonna say current piece is equal to get underscore
shape. Okay, we're gonna say, next piece is
182:27 - equal to get shaped as well, we're gonna set
up a clock object and clock is equal to pi
182:33 - game, dot time dot clock. And we're gonna
set a variable called full time equal to zero.
182:39 - And those are all the variables that we need
in our main function already coded for us.
182:43 - Okay, so now we're gonna set up our while
loop is our main game loop here, say well
182:48 - run. First thing we need to do in our loop,
sorry, for event
182:50 - in PI game, dot event dot get, let me say
if event dot type equals equals pi game dot
183:00 - quit. Well, that means we need to quit the
program. So the way that we can do that is
183:05 - just simply hitting run equals false. It's
going to break us out of our while loop, and
183:08 - then we can deal with that afterwards. We're
also going to add another event. This is a
183:12 - key down event. So if event dot type equals
equals pi game dot key down like that, then
183:19 - we're going to check what specific key is
actually hit. So let's go ahead and do this
183:23 - now. Kind of get it over with so I'm just
going to type all the different keys. And
183:28 - then we'll go in and code that after. So we'll
say if what do you call it pi game dot key
183:34 - equals equals, I believe, that's what it is,
or event key not plugging key my bad guys,
183:40 - event dot key equals equals pi game dot k
underscore, capital K. K underscore left.
183:49 - We say if event dot key equals equals pi game,
dot k underscore, right, like that. And then
183:58 - same thing up and down. So event dot key equals
equals game dot k underscore down. And last
184:07 - one,
184:09 - up. Okay, I don't know why that keeps happening.
Okay, okay, underscore up like that. Okay,
184:20 - so painfully after typing that left, right
down, up. Now we can go in here and we can
184:24 - kind of code what each of these is going to
do. So for hitting left, we want to move our
184:28 - block left. If we're coding, right, if we're
hitting rate one, move our block, right, and
184:34 - we're going down, we're gonna move down if
we're going up, we want to rotate our shape.
184:37 - That's what the main things are going to do
in here. So if we want to move our piece left,
184:42 - well, we should change the Y the x value left
wise, okay. So the way that we can do that
184:48 - it is a current piece, dot x minus equals
one. Now I know you guys are looking at this
184:54 - right now you're saying okay, well what the
heck man, so current piece is equal to get
184:58 - shape. And that's all equal Get shape, well,
what is good shape, and it's just returning
185:04 - random choice shapes. Now, this actually just
made me realize the fact that our get shaped
185:09 - thing needs to change. But that's because
we need to actually create a piece in here.
185:14 - So we set up this lovely class up here and
we weren't even using it. So Pease random
185:20 - choice shapes as the last argument takes,
it also takes an x and a y value, right? So
185:25 - for the x and the y, well, the Y is pretty
straightforward. It's just gonna be zero,
185:30 - the x has to be the middle of the screen,
so we're gonna give me five for y, we're gonna
185:34 - give it to you. Okay? And actually, for why
we'll leave it zero for now. But we might
185:39 - want to make it negative so that it kind of
starts above the screen and then starts falling
185:42 - down. Okay, so we have, let's make sure this
works. looks right, x, y shape. Yep. Okay,
185:48 - great. Okay, so that makes sense. Now on how
we can change this x value, same thing for
185:52 - rights. We'll do current piece, dot y, or
dot x plus equals one. That's a for down,
186:01 - we're actually just going to type this in
for now. But this is not exactly what's going
186:05 - to work. Y plus equals one to move downwards.
And for up, well, we need to rotate the shape.
186:11 - So to rotate the shape, this actually pretty
easy over into Steve, his current piece dot
186:15 - rotation, plus equals one, okay? Because when
we change that rotation, well, that changes
186:21 - the actual image of the shape. Okay? Now,
this is all great. But the thing is, what
186:26 - if we're moving off the screen? Or what if
this is not a valid position? Well, that's
186:30 - why we have a function called valid space.
Now, valid space, we haven't yet coded but
186:37 - I do have it in here somewhere valid space,
and well valid space is going to do is it's
186:40 - simply going to return if the current position
that we're in is a valid space. So the way
186:44 - that I do so this is gonna just make life
a lot easier. If we're moving left, let's
186:48 - simply just change the pieces x, move it left
one, and then check if that's a valid position.
186:53 - And if it's not, well, then we can just add
one, and move it back to where it was. So
186:57 - we're gonna say if not, and then valid space
and valid space. Again, take two arguments,
187:02 - gonna take the current piece and it's going
to take the grid, okay? Then let's just simply
187:08 - subtract or add one to our piece. So all this
is saying is we're gonna move left, but if
187:14 - for some reason moving left, results in not
a valid space, well, let's just add one and
187:18 - pretend like we didn't even move there. So
we're not drawing it, we're not changing anything.
187:21 - So this is perfectly fine. And it's actually
a really easy way to check things that haven't
187:26 - been checking if if it's below this or above
this or whatever. Okay, so now next, next
187:30 - one here, we're gonna say if not valid space.
And same thing current piece. With grid. Well,
187:38 - now in here, instead of adding one, we're
just gonna subtract one because we were trying
187:42 - to move right. And there we go. Same thing
with moving down. Okay, so we're literally
187:46 - just gonna take the exact same thing, if not,
valid space, current piece and grid. Well,
187:57 - now let, instead of adding one, we're just
gonna subtract one and this is from the y
188:00 - value this time she said current piece. dot
y minus equals one. Okay, so now for up. So
188:08 - when we change the rotation, we are changing
the shape. Okay? So it doesn't show this yet
188:15 - right now, like how we change the shape, but
we're going to do that later. So we can actually
188:18 - just call the exact same thing on rotation.
Because think about it. If we're fully on
188:22 - the right side with like the straight piece,
and we try to rotate, well, that could result
188:27 - in our piece being moved to the left or to
the right. Or like, there could be positions
188:32 - where it's on the left, or it's on the right,
and it's not in the grid. So we do have to
188:36 - check for rotation. If it is about spacemouse.
We'll say current piece. And then what else
188:42 - are we doing? Great here. Okay, and then this
case, we get it, we'll just we'll just subtract
188:47 - one from rotation. So minus equals one. And
that should all work pretty well. Okay, so
188:53 - after we do that, we're gonna make sure that
we remember to draw the grid. So in this wallet,
188:58 - put such say, actually draw window. I'm gonna
give it surface.
189:03 - And we're going to give it grid. Now, this
reminds me that I haven't yet created a pie
189:08 - game surface. That's great. So let's do that.
So here, I'm going to say when equals pi game,
189:15 - dot display dot set underscore mode. In this
case, I'm going to give it what is their screen
189:21 - width and screen height. So s, width, and
s underscore height. And that's it for display.
189:27 - We want to give this a caption though. So
we'll say a pygame dot display dot set underscore
189:35 - caption. Yep. So let's call this Tetris. Like
that. And now we're going to just pass when
189:42 - into our main menu. We'll put one in here.
And then in main menu, we're going to call
189:47 - me, okay, and we'll deal with Main Menu later.
I don't feel like coding it right now. And
189:51 - it's not really important to like the main
functionality of the game so we can simply
189:54 - just do this. Okay. Main win. Like this, and
If I put win here, then everything should
190:04 - work out the surface. change this to say,
when? In locusts Okay, so now we've effectively
190:13 - done draw grid or draw window, draw grid,
get shape, create grid, we've created a piece,
190:19 - we've gone through what all this stuff in
the starter file does. And we are now at 27
190:23 - minutes. Hey guys, and welcome back to part
two of coding Tetris in Python with PI game.
190:29 - So let's get right into it. In this video,
we're gonna be finishing a few other functions,
190:34 - we're going to be doing valid space, convert
shape format, we're gonna be coding but in
190:38 - the main, and we're also gonna be fixing a
small mistake I made in the last video. So
190:43 - this code right here in drug grid, yes, this
does draw our grid, but this is not what I
190:48 - intended this function to do. And I kind of
just realized this, when I was looking over
190:52 - the video and looking over the codes, we're
just gonna copy this code from draw grid,
190:55 - okay, deleted out of there. And we're just
going to paste it down here at the bottom
191:00 - of draw wind. Okay, so now we just have this
after we're putting the label, we have whatever
191:04 - code we had within draw grid, okay, because
draw grid would this actually was supposed
191:10 - to do is draw the lines for the grid. So I
kind of got this mixed up while I was going
191:16 - through the tutorial. So we're going to finish
draw grid now. And what this is going to do,
191:19 - and it's going to draw those gray lines over
top of all of our different colors that can
191:24 - kind of see where each block is, and we can
see the actual grid structure. So let's get
191:28 - started with this. Say sx, which stands for
start x is equal to
191:31 - what do you call it? Top left x. Okay, and
then as far as equal to top left y, like that,
191:40 - all right. And this is just so I don't have
to keep typing top left x, top left, y just
191:45 - makes it a little bit shorter for us. Okay.
Now, I'm just gonna say I'm going to set up
191:49 - a for loop and I say, for i in range, and
this is going to be the length of the grid.
191:54 - So how many rows we have, let's say for j,
in range, and this one is going to be the
192:01 - length of grid i. So how many columns in each
row. And then here, we're going to be drawing
192:07 - lines, okay. So for every row, we're going
to draw a line. So pygame dot draw dot line,
192:13 - we need a surface, give it a surface, we need
to cover this case gonna be gray. So gray
192:17 - color code standard is 128 128 128. And then
we need two positions, okay. So the start
192:24 - position is going to be equal to sx. Alright.
And then S y plus, what do you call it, I
192:33 - believe multiplied by block size. And I think
that is actually correct. Okay. Now, for the
192:40 - end position, well, it's gonna be the same
x value because we're destroying, or actually,
192:44 - it's gonna be, let me just check you, yeah,
it's gonna be a x value that is just equal
192:49 - to the width. So s x plus whatever the play
with this, and then the y value is going to
192:54 - be the same here. Because if you think about
it, we're gonna be at the same y value each
192:59 - time we're doing like, we're drawing a horizontal
line, every horizontal line is gonna have
193:04 - the same two y values and the x values just
gonna be changed. Okay? So I'm just gonna
193:08 - copy this and paste it in here now. Okay.
All right. I don't know why that did that.
193:14 - But we'll just go back like that. Okay. So
now what we're gonna do is we're just gonna
193:18 - do this case with x s x plus j multiplied
by block size, okay? s, y can actually just
193:26 - stay like this, okay. And then for sx, same
thing, as x plus j, multiplied by block size.
193:34 - And j is, again, is our current column. And
then this one s, y plus play, underscore,
193:39 - oops, we need a plus sign here, plus play
underscore height like that. Okay. And that
193:46 - should be drawing us. What do you call it
20 vertical lines, and then 10 horizontal
193:52 - lines down the screen, giving us a grid, and
kind of the way that works is every time we
193:57 - loop through a new row, we're simply changing
the y value of what line we're drawing, and
194:02 - then these x values are gonna stay static,
just at the left side and the right side of
194:07 - the screen. And then the way that we do it
here is we have the x values that constantly
194:11 - are changing every column and the y values
are staying static, being the top of the screen
194:16 - and the bottom of the screen to draw the vertical
lines. And that's what I wanted to do within
194:20 - this draw grid function. So now, that's all
kind of sorted out. And we fixed like a small
194:24 - mistake, don't get me wrong, can still have
that other code up here. Like it still works
194:28 - fine. But just in terms of what I actually
wanted to do with these functions. That's
194:31 - the way we need to fix it. Okay. So now that
we've done that, what I want to start doing
194:36 - is getting into this convert shape format,
okay? Now, this is probably the most complicated
194:41 - function I want to say within our program.
And what this is going to take as an argument
194:45 - or a parameter is just the shape. Now this
is what I was talking about before. So when
194:49 - we have a shape, it looks something like this,
right? So we have zeros and we have periods.
194:55 - Now this looks nice to us. Like we can tell
what kind of shape this is, but the computer
194:59 - has no idea. So how can we get this into a
form that the computer can read. And ideally
195:04 - you want to give it, we want it to give us
positions within the grid of where blocks
195:08 - exist. And then we're not going to give position
if the block doesn't exist. So if there's
195:12 - a period like this, okay, and you'll see what
I mean, as we start coding this function,
195:16 - and that's what the goal of this function
is to do to take that information and put
195:19 - it into something that's actually useful to
us. So we want a bunch of positions, that's
195:24 - the goal. From these, like lists, we want
to generate a list of positions. And then
195:30 - based on those positions, we can do things
we can check them, we can draw them, and so
195:34 - on, I'm just gonna create a list called format.
Don't worry if it's a keyword, it'll just
195:38 - override it. We're gonna say when we're given
a shape, we're actually given a piece object.
195:42 - So I don't know why I'm calling the shape,
but whatever. So shape dot shape, and then
195:46 - we can just do is equal to, and I'll talk
about this in a second shape, dot rotation,
195:51 - modulus, youth length of shape, dot shape.
Okay, so what this does is actually gives
195:57 - us the sub list that we need. So this needs
to be spelt correctly. I
196:04 - don't know how I butchered that. So bad. Okay,
shape dot shape. So if we look again, here,
196:09 - whenever we're past a shape, we're actually
past something like this, right, so we're
196:12 - past the shape object and its shape property.
So right here, is looks something like this
196:16 - looks like the variable t, which would have
a list full of lists. So we want to get the
196:21 - actual sub list. So which one this list right,
that's what we want. So the way we do that,
196:28 - is by getting the shape rotation modulates
the length of the shape. So for example, if
196:33 - our current rotation is zero, like we haven't
rotated yet, then what's gonna happen is we're
196:39 - gonna have zero modulates the length of shape,
in this case, the length would be four, so
196:43 - we get zero. So we're given this first shape.
Now if we have one, we're given this if we
196:47 - have two, we're given this, if we have three,
we're given this. And if we have four, then
196:51 - we go back, and we get this one, okay? And
it just keeps going and keeps going. Because
196:56 - modules simply just gives us the remainder.
So that's how we can tell what the actual
197:00 - current shape is within that main list. Okay,
hope that makes sense. So now we've done that,
197:06 - well, we want to do is want to set up a loop.
And because we want to look through every
197:11 - row and every column, and then based on if
there's a zero or a period, we're going to
197:14 - do something. So we're going to say for i
comma, and because we want the line as well
197:20 - in a numerate, right, and then format, okay,
because format is the list that contains,
197:27 - like the actual zeros and ones, okay, we're
just gonna say row is equal to list of line.
197:34 - This just gives us a nice list format that
we can deal with making it easier for us,
197:38 - I'm going to say for j in or j, comma column,
sorry, in a numerate and now row. So now every
197:48 - row we're getting the current line, and then
we're gonna loop through the line and look
197:51 - for either zero or a period. We're gonna say
if column, which is going to be, for example,
197:56 - if we have some, like this gonna look like
00. Okay, so this is what our row is gonna
198:03 - look like. So when we start looping, J will
be zero and column will be a period. Okay?
198:08 - Just Just in case you can't confuse that.
Okay, so for if column equals equals, and
198:13 - it's gonna be string zero, then we know that
we've hit like a position like this cube exists
198:18 - here. So what we want to do is we want to
add the position to our positions list. Now,
198:22 - it's not so simple as just add current IMG
value, we actually have to add something else
198:28 - what I'll show you right now, I'm just gonna
type it out and kind of talk about Okay, so
198:32 - shape dot x plus j, and then shape dot y,
plus i, okay, so this is our x value, it's
198:43 - the current value of the shape, because if
the shape is already moving down the screen,
198:46 - it's moving left and right, well, we need
to add that to whatever the J value is, whatever
198:51 - column we're in within this list, okay? And
then same thing with the y value. So whatever
198:57 - the current y value is of our shape, we're
going to add whatever column or whatever row
199:01 - sorry, we're now in as for the y value, okay?
And that is the positions that we need in
199:07 - these positions list. Okay, so now that we've
done that, we just have to modify these positions
199:12 - slightly, we've got to give them an offset.
Okay. And I'll talk about why this why we
199:15 - have to do this. So for I pause in a numerate
199:19 - positions, okay, then we're gonna say, positions,
i is equal to, and then this is going to be
199:31 - the current position, okay? So we just need
to put this into Tableau because that's where
199:35 - we're gonna give it. Pause zero minus two,
and pause one, minus four. Okay, so now let's
199:42 - break this down and kind of talk about exactly
what's going on. So we started off blank list
199:46 - positions. We're just getting the actual shape
within this list. So for example, we get something
199:52 - like this, okay. And then we're looping through
it. And where am I sorry, and we're pretty
199:56 - much just checking if zero exists in each
Position have that shape, okay? If that exists,
200:04 - then we're gonna add that position into our
list. And the way we do that is simply by
200:07 - getting the x plus whatever the current column
is that we're looping through, and whatever
200:13 - the current row is plus y, okay? Now we've
got that, the issue is that if we look here,
200:21 - we're going to get something like for a position
list here, we'll get something like three,
200:26 - one, and then we'll get three, two, we'll
get three, three, and we'll get three, four.
200:31 - Okay. Now the issue with that is we're adding
the current x value, plus these two periods,
200:37 - and the Oh, so we need to remove these kind
of trailing periods, right? Because that's
200:43 - going to result in our positions being offset
to the right by too much. Same thing with
200:48 - these y values, okay? Because when we're counting
this row, we're saying, well, this is one
200:53 - lower than this row, so our current y value,
say zero, and we're adding to it, now instead
200:59 - of just adding one, we're gonna be adding
two, so it's gonna, everything's gonna be
201:02 - offset down. So the way that we can kind of
fix this is just by offsetting by constant
201:06 - and by offsetting, I'm just gonna take every
x value that we've added and subtract two
201:09 - from it. And every y value that we've added
in subtract four from it. Now this is going
201:14 - to do is simply just move everything to the
left and up so that when we are displaying
201:18 - it, it's just more accurate to the screen.
Okay, you guys can see what's going to happen
201:23 - if you don't offset this. And you'll notice
that you kind of run into a few errors. So
201:26 - just run with me on the screen and just kind
of you should see how this works later on.
201:31 - Okay. Okay, so now that we've converted the
shape format, I want to go and code valid
201:36 - space now. Okay, so valid space is going to
take two parameters, shape and grid. Alright.
201:43 - And we're going to check the grid to see if
we're moving into a valid space. So what I'm
201:49 - going to do here is I'm going to create two
lists, I'm gonna say accepted. How do you
201:54 - spell accepted, accepted underscore pause.
So these are just gonna be the positions that
201:58 - are actually valid, okay, is equal to and
just flow with me on this, we'll talk about
202:03 - in a second for j, i, in then within this
list for j in range, 10. So similar to what
202:10 - we did to did in the last tutorial, and then
for i in range 20. Okay, so this is really
202:17 - similar to the way that we created the grid,
we're just getting every single possible position
202:21 - for a 10 by 20. grid, okay, and we're just
adding in a tupple and accepted positions
202:25 - gate. That's great. But the thing is, I want
to convert this into a one dimensional list.
202:30 - So this is the way that we can do this and
make all the positions. But now how do we
202:34 - flatten this list. So this is actually how
you do this. Okay, so excepted pause, is going
202:38 - to be equal to and this is one way, there's
many j for sub in accepted positions. And
202:46 - then one more for j in sub, okay. So what
this is actually doing now is it's pretty
202:53 - much taking all the positions in our list
and just adding it into a one dimensional
202:57 - list. And then we're just overriding this
list with that. So see if you guys can understand
203:03 - that. If not, don't worry about it, just know
that all this does is simply flatten this
203:06 - list. So we go from looking something like
this. wouldn't call it like 01. And then having
203:11 - another list.
203:12 - bedded stretched out example here, two, three.
So we go from that to something that kind
203:19 - of looks like this. And we just held the positions
in it now. So we don't have those sub lists.
203:23 - And this just makes it a lot easier to loop
through. Okay, so now we just have 0123, rather
203:28 - than having these embedded lists full of other
temples, okay, that's all we're doing with
203:32 - this line. Okay. So after we do that, what
we want to do is we want to get all these
203:37 - positions, and we're going to get the shape,
and we're going to convert it into our positions,
203:42 - right, because remember, whenever we get a
shape that looks something like this, it means
203:45 - nothing to us, we need to first convert it
into positions before we can compare it against
203:48 - other positions in our grid. So we're going
to use this convert shape format grid, our
203:53 - convert shape format, we're gonna pass it
the shape, and we're just gonna store this
203:57 - in a variable, and I guess we're gonna call
it, what should we call it? format, okay,
204:03 - because I guess that makes sense. We formatted
our shapes. So now we can use this and kind
204:08 - of compare it against accepted positions.
So here, we're gonna have a list that looks
204:12 - like something with a bunch of positions in
it. And then this one, we're gonna have a
204:16 - list that has a bunch of positions in it.
So you might see where we're going here in
204:19 - terms of how to compare these things. Okay.
Okay, so now that we've done that, we've kind
204:23 - of got all the data ready to check. This is
the really easy part is we're just gonna say
204:27 - for position, informatics, and all we're gonna
do now is just check if this position exists
204:33 - within accepted positions, because accepted
position is every position that we're allowed
204:38 - to have, right? So we're gonna say, if paws
not in accepted position. And this is an important
204:47 - part, pause. One is greater than negative
one, return false, and then otherwise, so
204:55 - if we make it through that loop, that means
we had all our positions accepted, we can
204:58 - return true Okay, so let's talk about this
really quickly. The reason I have this if
205:03 - paws once the y value is greater than negative
one is because when we give this offset of
205:07 - four, what ends up happening is we get some,
when we spawn in our shapes, they're going
205:12 - to spawn above the screen. Now we actually
want this, because we don't want our shape
205:17 - to show up on the screen wants to start falling
before it's actually seen. So typically, this
205:22 - means y position is going to start at like
negative one or negative two. So the thing
205:27 - is, while it's falling, we're checking if
it's in a valid position, right? But the thing
205:31 - is, it's not going to be in a valid position
if it's negative. So we just want to make
205:36 - sure that we're only asking if it's an invalid
position if the y value is greater than negative
205:40 - one, so greater than or equal to zero, okay?
And this is a really easy way to tell us well,
205:45 - are we on the grid or not? So let's give an
example. Say we're trying to move left, and
205:50 - we're already at the edge of the screen. So
that means we're gonna have an x value of
205:52 - negative one. Well, that position of negative
one, whatever y value is not going to be in
205:57 - this accepted position. What do you list?
So when we try this, we're going to return
206:01 - false, and it's not going to allow us to move
left? And that is the whole point of that.
206:07 - And now, okay. What am I doing here? Okay,
so I also just want to modify this part up
206:15 - here. So I have true j, i in range for j in
range. If i in range 20. I want to just change
206:21 - something here. Okay, so what I'm going to
do actually the mistake if grid,
206:24 - i j equals equals, and then the colored users
Yeah, okay. So this is an important part,
206:34 - I was kind of waiting, I was kind of thinking
about this. So pretty much, we're only going
206:39 - to add this position into our accepted position
if it's empty, which actually makes a lot
206:46 - of sense. Because think about it, if we already
have a color in that position, then that's
206:49 - not a valid position, we can't move into where
piece already exists. So this conduct condition
206:54 - does it says, Okay, we're only adding this
position. Now, if this is true, so if i j
207:00 - is true, then we're good, we can add the position.
If it's not 000, that means something exists
207:05 - in there. So that's why we're not going to
add it into our accepted positions. Okay,
207:10 - so I know this looks kind of confusing. So
I'm doing like a bunch of embedded for loops.
207:13 - This just saves us a few lines. It's kind
of a cool way to create a list in one liner.
207:17 - It's like the Python anyway, so I figured
I'd do that for most of the stuff in here.
207:21 - Okay. So now that we've done that, what else
can we code? Well, you know what, while we're
207:26 - here, we can code check last. All right, this
one's a really easy function, this is just
207:31 - simply going to check if any of the positions
are, what do you call it above the screen.
207:37 - So if we hit y value zero, then we know that
we're above the screen that we've actually
207:42 - lost. So the way to do is we're gonna say
four paws in positions, because what this
207:48 - is going to do is we're going to pass a list
of positions. So we're going to get every
207:53 - pause now in the position, we're going to
say x, y is equal to pause, which simply you're
207:57 - splitting up the tupple, because we know we're
gonna get something that looks in the form
208:00 - of like, three, four, okay, and we're gonna
say, if y is less than one, so equal to zero
208:07 - or greater than return true. Else, or we don't
even need an else return false down here.
208:16 - So if every position is less than or greater
than y, or whatever, one, then we will return
208:22 - false because we haven't lost yet. Otherwise,
we're returning true. Okay, so we're almost
208:28 - getting there. Now I want to go down to the
main, and I want to finish coding up some
208:32 - stuff in here. So last time, we kind of just
left it at this, like moving pieces around,
208:36 - whatever. But we have these variables. Okay,
so change piece, next piece clock full time
208:41 - that we're not using. So what I'm going to
do now is I'm going to show you guys how we
208:44 - can actually move our shape down our screen
at like a regular time interval. So I'm going
208:50 - to create a variable here actually called
false speed. And this is how long it's going
208:54 - to take before each shape starts falling.
Okay, so we'll talk about how to do this,
209:00 - I shouldn't gonna start coding it now. So
pretty much we're gonna say, up here. And
209:04 - I didn't do this before, but follow along.
Grid equals create grid based on locked positions.
209:10 - The reason we're doing this, I know we already
created grid up here is because every time
209:15 - that we move, we have a chance to be adding
something to locked positions. We're going
209:19 - to do that later. Because for example, if
we hit the bottom of the screen will now locked
209:22 - position is going to be equal to something
else because it's going to have a new shape
209:25 - and it shouldn't we need to constantly update
the grid, so that when we're drawing it to
209:29 - the screen, we get like an updated version.
So that's why I'm doing that up here. Okay.
209:34 - I also need to actually, I don't think I need
to do that here. We need to add to full time,
209:40 - okay, so the way we're gonna add to full time
because this is going to track what do you
209:45 - call it? How long since like the last loop
ran is by using this clock object that I set
209:51 - up here. Okay, so before I add to that, after
here, I'm going to do clock dot tick and then
209:57 - I'm going to add this and I'll talk about
After I do at some clock dot get underscore
210:02 - raw time like that. Okay. So the way that
this works is this raw time actually gets
210:10 - the amount of time since this last clock dot
tick. So when I first add, it's going to be
210:15 - zero because we haven't yet ticked the clock
and the next iteration, it's going to see
210:19 - how long it took this while loop to run. And
then it's going to simply add that amount,
210:24 - okay, so it's actually going to give us real
time. This means that this should technically
210:28 - run at the exact same speed on everyone's
computer at every one machine. Because I know
210:32 - when I use FPS, FPS is dependent on kind of
the speed of what you call it. Your actual
210:39 - computer, sometimes like the way I did it
in other games, so this is a better way to
210:42 - do it. So now what I'm going to do is, since
I've now incremented, the full time, and this
210:46 - is going to be given to us in milliseconds.
So like one second would be 1000. That number
210:51 - and our full speed is in well 0.27. So what
I need to do is I have to say if fall time,
210:56 - divided by 1000 is greater than full speed,
then what we're gonna do is we're gonna reset
211:03 - full time equal to zero, and we're going to
add one to the current y value, which means
211:08 - we're scrapped we're moving down the piece
one, so this is going to automatically Now
211:12 - move our piece down. Another thing is what
if our piece will hit the bottom of the screen,
211:15 - and what if it's moving into position we can't
move into. So this is the same thing we've
211:19 - kind of done in here, what we're gonna do
is we're gonna say again, if not valid position
211:25 - or valid space, whatever, given the current
piece, and our grid,
211:32 - I believe at least grid, okay, then, and actually,
we're gonna check one other condition. And
211:39 - our current PCE dot y is greater than zero.
So this means that we're not at like the top
211:45 - of the screen, because the same thing with
negative values, alright, is greater than
211:49 - zero, then what we're gonna do is we're going
to subtract one from the current piece. So
211:51 - why once equal one, because that means we
moved into an invalid position. So let's move
211:56 - back up one and pretend like that never happened.
And we're just going to say, change piece
212:01 - is equal to true. Now, the reason I'm setting
change piece equal to true, because think
212:07 - about it, right, if we're moving down, and
we move into position, that's not valid, well,
212:11 - we know we didn't move left right off the
screen, because we were moving down, that
212:15 - means we must have either hit the bottom of
the screen, or hit another piece. So in that
212:20 - instance, we need to stop moving this piece,
and we need to change it. And what changing
212:24 - pieces going to do, we're going to do that
later, is simply going to lock all the positions
212:27 - what they're currently in, and then it's going
to make this next piece generate down the
212:31 - screen. And I'll show you that in a second.
But this is kind of the way to check it. It's
212:36 - easier way then you don't have to check like
the y values and, and all that stuff. Okay.
212:40 - Alright, so now that we've done that, let's
move down here to the bottom of main. And
212:44 - let's start adding a few things. Okay, so
what I want to do down here, I want to say
212:50 - shape positions. So shape underscore pause,
is equal to convert shape format, current
212:56 - piece, because what we're going to do now
is we're going to check all the positions
213:00 - of the piece moving down to see if we've hit
the ground or see if we need to lock it, okay.
213:07 - So, and we're going to add all that color
to the grid so that when we're drawing it,
213:10 - we actually see the piece because right now
we have the piece, but we don't add its color
213:14 - into the grid, so we're not actually going
to see it show up. So we first need to add
213:17 - it to the grid so that we can draw it and
we can see it moving. So to do that, we're
213:20 - gonna say for i in range, the Len of shape
positions, okay. We're going to here to say
213:31 - x, y equals shape positions of i x, that's
the current iteration, the current one we're
213:37 - looking through, we're gonna say if y is greater
than negative one. So this means that we're
213:43 - not above the screen, let me say grid, y,
x equals current piece dot cutting, okay?
213:54 - Because remember, the grid stores a bunch
of different colors. So all we're doing the
213:57 - greatest giving different colors, and based
on that position in the grid, so y x, which
214:01 - is going to be this shape, the all the shape
positions, we're going to draw that color.
214:05 - Now the reason we're going to have this negative
one is because imagine that we're at the top
214:08 - of the screen, and we try to draw it or we're
above the screen, we have a position with
214:12 - a negative y value. So if we throw negative,
we're not actually going to get an error in
214:16 - grade here. But it's going to end up looking
like it's at the bottom of the screen and
214:19 - then moving to the top and it's just gonna
look weird. If you guys want to see what it
214:22 - looks like without this, just remove this
condition. You'll see that why have it added
214:26 - in. Okay, so now what we're gonna do is we're
going to check this change piece variable.
214:33 - So I put it up here, change piece, this means
that we've hit the bottom or we've hit something.
214:38 - What we're going to do now is we're gonna
update lock positions and this one, I'm gonna
214:43 - start talking about lock positions. Okay,
so for pause actually in shape positions.
214:49 - Alright, we're gonna say p is equal to pause,
zero. Pause one. All right. I don't know why.
214:59 - Do this, but I think there's a reason for
it. So let's just run with it. And we're gonna
215:03 - say locked positions p is equal to current
piece, dot code. Okay, so what is this? Well
215:13 - locked positions is going to be a dictionary,
in a form like this, right? It's gonna have
215:17 - a tough one here, that's gonna have a position
like one, two, colon, and then we're gonna
215:21 - have a color and the color is going to be
another tupple. But RGB values, okay, so for
215:27 - example, 255 00. The reason we have this is
so that when we passed locked positions into
215:32 - our grid like this, right, we can get each
of those positions in the grid, and then update
215:37 - the color of grid. So every time that we have
like a locked position in a locked position,
215:43 - as simply means our piece is no longer moving,
it hit the bottom of the screen, and we're
215:46 - on to a new piece, we can get the position
and we can get the color, and then we can
215:50 - update the grid based on that, and we can
keep that in there. Okay. And that's the way
215:55 - that locked position works. So it's a dictionary
with the key of a position and the value of
215:59 - a color. Alright, that's kind of like the
data structure for now what we're gonna do
216:03 - after this, after we update our locked positions,
and we add positions to it, we're gonna say
216:07 - current piece equals next piece. Okay, so
we're just gonna change that. And now since
216:12 - we've said, current piece now equal next piece,
will we need to update next piece. So let's
216:17 - get a new shape, because we're just moving
forward with the game. And now, of course,
216:21 - we got to say change piece equals false, because
we're on to a new piece that's going to spawn
216:24 - at the top of the screen. Okay. And I think
that is about it. What we also want to do
216:31 - actually, is we're going to check if we lost
the game, and I think I do this after draw
216:37 - window. I don't think it really matters. But
we're gonna say if check last, based on what
216:41 - do you call it locked positions? Okay, so
these are all the positions of the shapes,
216:46 - then we're going to say run is equal to false.
And that's going to break us out of this wall
216:52 - up. And you know what, while we're here, let's
indent out and uninstall pygame. dot. What
216:58 - is it, I think it's display dot quit or something.
Yeah, display dot quit. So we're actually
217:03 - just exiting out of our game. Now, up until
this point, I actually have not tested my
217:07 - code. Now I know some of you probably think
I'm insane. Because we've already written
217:10 - like 300 lines of code, we haven't tested
any of it. The reason I haven't done this
217:14 - is because I wanted to test this in between
videos, figure out what the errors were so
217:19 - that I didn't waste too much time fixing all
of them. So I'm going to go through a few
217:24 - errors that we have now and show you what
happens when I run the code. So I'm just going
217:28 - to delete that because that was the fix that
I made. And pretty much you can see a big
217:32 - crash right away. And we actually get a four
Iron Range, none type has no length. Now the
217:38 - reason we get this, and this happens down
in the main is because in convert shape format,
217:43 - somehow I managed to forget to return positions.
So this is really important because the whole
217:47 - goal of this function well was to generate
this list of positions. And we did that fine,
217:52 - but we forgot to return them. So pretty easy
error to fix or return positions. Now, again,
217:58 - we run this like okay, everything looks good.
Now, there's another issue, right? So just
218:02 - watch. If I try to go off the screen, you
can see that we get a unsupported operand
218:06 - for current piece, because I forgot to put
a y or an x here. So let's go down to main,
218:12 - let's fix this. What line are we on? 262 262
current piece dot x. Yeah, that would be important.
218:19 - Okay. Now I know there's a few other errors.
So this one current piece minus equals, let's
218:24 - change this to an X. Current piece minus equals,
wow, I really messed up on this a lot. Okay.
218:32 - dot rotation, minus equal one. Okay, so this
is rotation. And let's see anything else?
218:39 - Let's run the program. See, okay, we're getting
another issue here. So if we have valid space,
218:44 - okay, so I just messed up and a bracket here.
So let's go line 265.
218:49 - Here, so we're gonna take this quotation mark,
or one of the same condition Mark bracket,
218:53 - and just put it there. And all should be good.
Now, let's see, we go down to the bottom of
219:01 - the screen. Okay, we get another. And let's
just play this for one sec, see if we can
219:05 - run into any errors. Okay, so we're rotating
fine. We can't move off the screen. And all
219:12 - looks to be doing okay. Alright, so that's
a good sign for now. Let's leave that. So
219:19 - it doesn't look like there's any issues. If
you find any, I probably end up fixing them
219:23 - in future videos. So don't stress about it.
Okay. So now that we've done all this, what
219:28 - we need to do next is a few things. Alright.
So we need to deal with this draw next shape,
219:35 - clear rows, draw text, middle, what are their
functions, so I think that's about it. And
219:39 - we're also going to deal with Main Menu, kind
of starting the game, finishing the game,
219:44 - and all that stuff. So what I first want to
do actually, is I want to deal with draw neck
219:50 - shape. And then I'm going to do clear rows
just because clear rows is kind of complicated.
219:53 - So draw next shape. What this is going to
do is it's just going to draw the next shape
219:56 - kind of off the screen and show us what it
is because in Tetris It shows you like the
220:00 - next shape the next few shapes. So yeah, now
this seems pretty straightforward, like just
220:06 - draw the shape. It's actually kind of long
because we have to, once again, get this list,
220:12 - turn it into positions that we can use. And
yeah, it just it gets a bit complicated. So
220:18 - what we're gonna do is we're also gonna set
up a font in here, we're gonna say font equals
220:22 - pi game dot fonts dot s, why is font. Here,
we're gonna do Comic Sans again, because you
220:28 - guys know I love Comic Sans. Comic Sans sighs
stick 30. And let's render this font. Okay,
220:36 - so label equals font dot render, text for
this is going to be next shape. Okay, feel
220:43 - free to add a colon or something if you guys
want anti aliasing, one, text color white
220:49 - to fit fatty food factory gate, basically
already been through that. Okay. Now we need
220:54 - to figure out where we're going to draw this,
this label. Okay, so let's do the same thing
220:59 - we've done before we say s x is equal to top
left x plus the play width. And then we're
221:08 - gonna say s y is equal to top left y plus
the play underscore heights actually won't
221:18 - play 100 we're gonna say play height, divided
by two. Okay, now what we're gonna do is this
221:23 - is going to give us like, to the right, maybe
I can just run this and show you guys, it's
221:29 - gonna give us where my mouse is right here,
like a position kind of similar to here. So
221:33 - we are actually here. So what we want to do
is we want to add a constant to this, so we
221:36 - move to the right of it. So this constant,
we're just gonna hard code in. And we can
221:41 - change this and play with it, if we want it
to be like move more to the right or more
221:44 - to the left. So to move more to the right,
we're gonna add 50. And then to kind of make
221:49 - this look a little bit better, which can actually
subtract the 100 from the site. So we can
221:53 - move a bit higher up on the screen playing
with these constants if you guys want it to
221:56 - look a bit different. Okay, so now we've got
that, what we're going to do is, we're going
222:02 - to once again, we're going to format written
say format is equal to shape, dot shape. And
222:09 - same thing, we need the actual shape. So not
just like that main list, its shape dot rotation,
222:15 - modulus, the length of shape, dot shape like
that. Okay, so this is the exact same thing
222:22 - that we did in format, whatever it goes out,
yes. Know what function I'm talking about.
222:28 - And I've lost myself here, okay, just to get
the actual like, sublist that we need. Okay,
222:34 - so now, you might say, Well, what are you?
What are you doing here, we already have like
222:38 - a function that does this for us. Don't worry
about it, just follow along. Because this
222:41 - is a bit different. The way that I'm going
to do in case I'm gonna say four, I call them
222:45 - a line in a numerate. All right, and then
row
222:50 - four, actually, format, sorry, I'm gonna do
the same thing here, we're gonna convert row
222:56 - ID into list is really similar to the other
function, except we're gonna do one major
223:00 - change. And you'll see that for row equals
list line, we're gonna say for j, comma, what
223:04 - do you want to call it calm in a numerate
row this time, and exact same condition, if
223:14 - column equals equals zero, what we're going
to do here, instead of adding some position
223:19 - to list, we're gonna draw something. And this
is why I didn't want to use the other function
223:23 - that gives us list of positions because I
don't care about the position within the grid,
223:26 - I just care when we should draw something
or not, because this doesn't matter, it's
223:30 - not going to be moving, we just want to draw
like a constant image on the right side of
223:34 - this static image on the right side of the
screen that we can just look at. Okay. So
223:38 - what we do here is we're going to say pygame
dot draw dot rect. So dot draw dot rect. And
223:43 - each surface we pass the surface in, in each
color, that's going to be the shape color.
223:49 - Okay, and then we need our position to draw
sx. And then in this case, we're gonna have
223:56 - to do since we're drawing each cube, great,
we're not just drawing the whole shape, plus
224:00 - j multiplied by 30. And then we're gonna do
same thing with y. So s y, plus i multiplied
224:05 - by 30. And we actually just change this to
let's change the block size to be a bit more
224:12 - dynamic. Okay, so it's a 30 block size, just
in case we decide to change the dimensions
224:15 - of our screen later on. And then we new width
and height, and that is going to be block
224:19 - size and block size and we want this filled
in so comma, zero. Okay, so what we've done
224:24 - here is really similar to what we've already
done. We're just going to be drawing these
224:28 - blocks according to where they show up like
in this list, based on initial exposition
224:35 - plus, like a changed kind of position or whatever.
Okay. Anyways, I think that's about it for
224:43 - this. Oh, we need to actually complete the
label now. So we created this labeled we have
224:48 - actually drawn on the screen. Yep. So let's
do this. As we say surface dot, Blitz. Label
224:56 - changes to period. Okay. Then we need to position
what's their position going to be? Well, we're
225:04 - actually just gonna do sx plus 10 and s y
minus 30. Okay? Again, play around with these
225:09 - constants, guys, if you want your thing to
look a bit different, be more centered, whatever.
225:13 - I again, I don't go like too crazy on cosmetics
here. I just want everything to work and look
225:18 - decent. I assume you guys can mess around
with it. All right. Okay, so now we've done
225:22 - that we've drawn the next shape, well, we
actually need to call this function. So within
225:26 - draw window, we're going to call draw next
shape, as well. So where should we call this?
225:33 - Let's see what's called before we draw a grid,
draw next shape, or actually can't call them
225:39 - here, where we need to call this as in the
main because we only have next shape within
225:43 - the main symbol. Right? When we're drawing
draw window, we're actually just going to
225:47 - call draw next shape. Because we need to give
it the next shape. So it's going to be next
225:52 - piece. And then the grid does, it takes it
takes a surface surface. Okay, so let me just
225:59 - go check this to make sure our surface is
not cold surface. It's called wind. Okay,
226:05 - so in draw neck shape, you have a shape and
surface case. So that that should work fine.
226:12 - You know what, let's actually test this now
and see this working. And we're not showing
226:16 - up, we're not drawing this surface. I believe
it is because Joe, when adrenix. Okay, so
226:23 - we need to do actually, this draw next shape,
we're gonna draw after Joe and no, and we're
226:28 - just gonna update the display in here. So
pygame dot display dot update. And then if
226:33 - we go to draw window, just remove this display
update, and this should work. There we go.
226:40 - So now we're getting neck shape. On the side,
the reason I wasn't working is because we're
226:44 - pretty much drawn overtop of the next shape,
every time that we drew the window. So now
226:50 - that's working fine. We have our next shape
showing up. And what else do we need to do?
226:55 - I'm really delaying trying to go to this clear
rows function, because it's really complicated,
226:59 - but I think we're gonna have to do this next.
Okay. So clear rows in Tetris. Obviously,
227:04 - if we create a full row, we need to clear
that row. And then so that's the only way
227:07 - the user can win, obviously, yeah. So way
to do this
227:12 - is probably a lot easier than the way I'm
going to do it, but try to follow along, because
227:17 - this is the only way I could kind of get to
work. And this is probably the hardest part
227:19 - of the actual game. Okay, so we're going to
take grid, and we're going to take locked
227:25 - positions. And what we're gonna do is we're
gonna set up a few things here, just follow
227:29 - along with me, I'll try to explain as I go,
so when I say Inc, which is an increment zero,
227:33 - for I, in range, the length of grid, negative
one, negative one, okay, and we're actually
227:43 - just going to subtract one from this to, what
this is going to do is go loop through our
227:47 - grid backwards, so it's gonna start at the
20th row, and it's gonna move up to the 19
227:51 - through, Okay, I'm gonna say the current row
is equal to grid I. Alright, and we're gonna
227:56 - say, if the color 000 is not in our row, let's
clear. Okay, so we're gonna add one to Inc.
228:05 - Don't worry, I'm gonna explain this after
I just fall on, say ID equals I am going to
228:12 - say, for j in range, the length of row, what
we're gonna do is we're gonna try to delete,
228:21 - locked, square brackets, current position,
which can be JDI. And then if this doesn't
228:32 - work, then accept. And continue. Okay. Okay,
so let's just talk about what I just did here,
228:39 - because I kind of went fast. And there's another
part of this function door. So the way this
228:44 - is gonna work, is we're gonna say, we're gonna
loop through the grid backwards, we're gonna
228:49 - set row equal to every walbro in our grid.
So we're looping through. And the way that
228:56 - we know if the row should be cleared is if
000 doesn't exist, because if 000 doesn't
229:01 - exist, that means there's no plaque squares
in our row, which means it's completely filled
229:05 - with shapes are completely filled with cube
objects or whatever. Okay, so we know we can
229:10 - clear it. So the way to clear it now. And
don't worry about these variables, we'll talk
229:15 - about that in a second is to get every position
in that room. To do that mean to loop through
229:20 - j in the row. And we're already at the current
row. So we know that I just gonna stay static
229:26 - change j and try to delete this from locked
positions, because now what we're doing is
229:32 - the lock positions need to be removed. So
when we dealt with these, since locked position
229:36 - is a dictionary, it's mutable, we can actually
just change it within here. And that's how
229:40 - we delete those keys and those colors from
the grid. Okay, so after we've delete that,
229:45 - all we need to do is we need to shift every
row. So what's happening now and I think I'm
229:51 - actually just going to pull out a little,
I have a drawing tablet and just start using
229:54 - this to kind of explain some things because
it's pretty complex. So just give me one second
229:58 - Alright, so what we need to do is we need
to shift every row. So if we delete, like,
230:04 - the bottom row in every row above that row
needs to move down by one. So if I go to,
230:10 - let's see this, and delete this, okay, so
you can see if I have a grid. Alright, and
230:16 - it looks something like this, we're just gonna
do like a very basic like three by three grid.
230:20 - Okay, just to save us some time. Let's say
that we want to clear this row down here.
230:24 - So these are full of colors, right? So if
we clear this row, and then what happens is
230:28 - we get rid of all these and that any positions
that were above it, so let's draw something
230:32 - like this. Now, this is here. Well, currently,
this is floating, right? Because if we've
230:36 - cleared all these positions down here, so
we got rid of those, this is floating. So
230:41 - this needs to move down one. So how can we
go about doing that. And the thing is, every
230:46 - other row needs to shift down by one as well.
But now let's talk about like a potential
230:50 - issue we might run into. So if I delete all
that, and let's say we have a grid that looks
230:54 - like this, okay. And there's a color here.
If we delete this row, the grid actually now
231:00 - in our memory, only looks like this. Alright,
it's only this top portion.
231:08 - Because we've deleted an entire row out of
the grid. So yeah, we can shift everything
231:12 - down by one. But now we're left with the grid,
that's one less than the other one. So what
231:16 - we want to do is we need to add another row
at the top here, so that our grid stays the
231:21 - same size. Because if you delete an entire
row, well, you're deleting row, right? So
231:26 - you need to add back the other positions at
the top, because everything's shifting down
231:30 - by one. So really, the way it works is you
delete this, and then this whole thing moves
231:34 - down, and then you add a row up top like this.
Okay, so that you're back to your continual
231:39 - grid. I hope that makes sense. That's kind
of the only way I can really explain it to
231:44 - you guys, in terms of how we shift things,
and I'm going to do it in code, right? Okay.
231:49 - So leave a comment if you guys are confused
about that, because I'll try to explain it
231:51 - in a better way. But it's just kind of like
a confusing topic in general. Okay, so now
231:56 - what we're gonna do when I say if IMC is greater
than zero, okay, we're going to say, so this
232:01 - means that we've shifted, and we've removed
at least one row, and I'll talk about the
232:05 - case in which we move to Rosa one second,
okay, let's say for key in and just follow
232:12 - it this is, this is gonna be kind of confusing.
List of locked positions. So locked, because
232:20 - we just, we just pass in locked there, okay.
And then you say key equals lambda lamda.
232:26 - I'll explain what this does in a second. x,
x one. And I think that's about it. And we're
232:32 - actually just gonna reverse this negative
one. Okay. So, for every key in our sorted
232:42 - list of locked positions, based on the y value,
is what this does. So given a list that looks
232:51 - like this, if you have like 0100. Okay, given
this a very basic list, this could be an example
233:00 - of locked positions list, okay? What we're
gonna do is we're gonna sort this list, and
233:04 - the way we sorted is based on this number
here, this y value, and this is what this
233:08 - key equals lambda x x one does. Don't have
to understand that this is just really kind
233:14 - of complex way to sort of list. What we're
gonna do is we're gonna now make it looked
233:18 - like this 0001. And the way we do that is
that we get all the positions that have the
233:26 - same y value in like the correct order. Okay?
And you'll see why we need that when we start
233:34 - coding, okay, so I'm gonna say x, y equals
key because again, remember, key is a tupple.
233:40 - And we're gonna say, if y is less than ind,
we're gonna say, new key is equal to x comma
233:50 - y plus IMC and then locked. New key equals
locked dot pop key. Okay, let's, let's dissect
234:05 - this now, right? Because this is, I told you
guys, this was kind of confusing. So what
234:10 - we're doing now, if we want to shift every
single position in the grid down, because
234:16 - when we delete a row, everything above that
needs to move down. So the first part is pretty
234:21 - straightforward. Okay, so x, y equals keys,
we're simply getting the x&y position of each
234:25 - key in locked positions. And remember, lock
positions has a key and then corresponding
234:29 - with that is, okay, straightforward. Now,
what we're gonna do is we're gonna say, if
234:35 - y is less than IMT, what that means is if
y is if the y value of our key is above the
234:43 - current index of the row that we removed.
So if we remove for example, row 17, then
234:50 - only things that are above that are gonna
move down. We don't need to move anything
234:53 - below row 17 down because we didn't remove
anything after row 17. Right. I mean, shows
234:57 - us an intro in just a second. Okay, so with
that happen,
234:59 - In this, what we're gonna do is we're gonna
change a key, we're going to get a new key,
235:02 - let's say it equals current x value, but we're
going to increment this by a certain value,
235:07 - so we're going to add a head to the y value
to shift it down. And then we're going to
235:12 - do is we're going to rewrite, we're going
to create a new key in locked position, which
235:18 - can have the same color value as the last
key, B, and this will, this gives us the last
235:22 - current color value, but it's equal to this
position, right? So I'll explain why this
235:28 - works now kind of withdrawing, and why I needed
to look at this backwards, okay? Because when
235:33 - we're looking at from bottom to top, there's,
there's a reason for that. Alright, and I
235:38 - might butcher the explanation, but just kind
of bear with me here for a second because
235:41 - this is important understand why this works.
And this is the most complex thing. And this
235:46 - is actually very useful, you might want to
use this a lot like shifting positions in
235:49 - a dictionary or in a list. Okay, so if I go
back to my little drawing thing here, I go
235:55 - like this. Okay, so let's create a grid over
here. Let's make it a few more rows this time
236:01 - just for a better explanation. So 1234, okay,
make it a four by four. And you guys can see
236:11 - my fancy drawing skills. Let's make this a
row. So let's say we have a row like this
236:17 - guy, so it's green, make orange. Orange didn't
work. So green can say they're orange, like
236:26 - this, like this. And like this, and then we'll
add some more colors. Let's do like blue.
236:31 - Up here, and up here. Okay. So obviously,
this is the row that needs to be cleared that
236:36 - my mouse is going over right now. Okay, so
this is the row that needs to be cleared.
236:41 - What happens when we clear this row? Okay,
so we've looked from the bottom of the list
236:45 - up, and we found if we're looking at row like
four, now looking at row three, we say row
236:51 - three needs to be clear. Okay, so it's cleared.
So we delete everything out of row three,
236:55 - right? This row is now gone. So our grid in
memory just looks like this. And this. So
237:00 - what we need to do now seem to shift these
positions down. But we don't want to shift
237:04 - these positions. So that's why we're getting
that ind. So we know which position positions
237:10 - in our grid to shift. So we delete that row.
And then what we're doing is we're adding
237:15 - one and shifting all these positions down.
Okay, that's a straightforward example. Let's
237:19 - get rid of this. And let's do this. Okay,
so let's say when we add our, I don't know
237:25 - shape, whatever to our grid, we end up getting
something that looks like this. Okay, two
237:32 - rows that need to be shifted down. Now what
we have to do is we have to delete this row
237:37 - and this row. Now here's the thing, we delete
this row, we delete this row, how many rows
237:43 - is this now needs to move down? Well, this
needs to move down to rows. So how do we know
237:49 - how many rows to move this down? How many
rows and everything else above it down? Well,
237:53 - that is based on our What do you call it increment
here. And that's why whenever we delete a
238:00 - row, we add one to increment, because we know
that we have to now shifted down another row.
238:07 - Okay. And that's kind of the way that this
works, if that makes sense. Now, the reason
238:13 - that we go through and we look at things backwards
is we don't overwrite existing rows. Now,
238:18 - this is another complex thing, okay. You probably
don't have to really understand this that
238:21 - much. But anyway, okay, so let's just say
it's not going to let me undo. Okay, that's
238:26 - fine. So we have this right. Now, here's the
thing, we started looking at it from the top
238:31 - down to the bottom, what would happen is,
we would so let's actually have to add another
238:37 - row for this example. That makes sense. So
if I add another row, and I say, Well, okay,
238:43 - let's add a color. Let's pick yellow, right?
Let's say we have a position here. And we
238:49 - have a position here, right? So that means
this position, this position, and this position
238:53 - only to move down. So here's the thing, if
I move this one down by two, alright, or if
239:00 - I move it down by one, or whatever, it could
possibly overwrite this existing position.
239:05 - And we don't want that to happen. So what
why we have to start looking at it from the
239:09 - bottom is that when we start moving everything
down, we move the lowest most things down
239:13 - first, so that way, when we then change this,
there's no possible way we're gonna overwrite
239:18 - this right here. Okay? Because remember, if
you in a dictionary, if you change a key and
239:24 - the key already exists, will you're just gonna
overwrite that key. So that's what we start
239:27 - looking at it from the bottom. If that doesn't
make sense, don't worry, just, that's for
239:31 - any of you. That's why okay, because I want
to make sure I explain everything and you
239:34 - guys understand, at least on some level, why
I'm doing what I'm doing. Okay. So that's
239:39 - it for the explanation of clear rows. Now,
let's call it function. So when are we going
239:45 - to call clear rows. Now this is actually an
interesting call. We could call this function,
239:50 - every loop. But we're only going to call this
when our change piece hits the ground. Now
239:57 - the reason for this is because you could possibly
be moving On the screen, and at some point,
240:04 - the grid would have a full row before your
shape actually hit the ground. Now we obviously
240:09 - know the way in Tetris, when you're moving
down the grid until you like land or you stay
240:14 - static, we're not clearing anything. So that's
why we're only going to call this if we are
240:19 - about to change the piece. So clear rows,
what is clear rows take again, I would say
240:24 - it probably takes grid in locked positions,
maybe, yeah, grid and locked positions. Okay,
240:28 - so passive, the grid will pass it block positions.
Okay. So then we're checking whenever we're
240:34 - changing the piece, if we should clear a row,
and this can clear multiple rows at once.
240:38 - Okay, I'm going to be showing you guys a few
different things. So in the last video, I
240:42 - mentioned, I was going to be doing more cosmetic
stuff. So that is true. In this video, I'm
240:45 - going to be showing you how to do the main
menu screen how to draw text in the middle
240:49 - the screen, how to make things look a little
bit better. And I'm also gonna be adding a
240:52 - little bit of functionality to the game, in
terms of making the piece fall faster as it
240:58 - moves, or as time moves forward. So obviously,
you want the game to get more difficult as
241:03 - time goes on. So what we're going to do to
do that is increase the speed at which the
241:08 - piece falls on the screen, it's pretty easy,
I'll show you how to do that, I'm going to
241:10 - be adding score, and we're going to be displaying
that score. And that's probably about it for
241:15 - this game. So the first thing I want to show
you is how to add the piece falling faster.
241:24 - So to do this, we need to create a variable
in our main here. And I'm just gonna make
241:28 - this equal to what do you want to say, fall
or let's say level, underscore time, okay.
241:36 - And this is gonna just represent how much
time has passed. And it's gonna be similar
241:40 - to full time and levels, just because as we
increase speed, like the level is going up,
241:45 - kind of whatever, okay, so say level time
plus equals clock dot get underscore raw time,
241:50 - and we're gonna do exactly what we did with
making the piece move down the screen, except
241:56 - we're just gonna change the speed at which
it moves down the screen. So what I'm going
241:59 - to do here is when I'm making the if statement,
I'm simply gonna say if level underscore time
242:05 - divided by 1000 is greater than, and then
you can put in whatever time you want here.
242:09 - Now I'm going to do five seconds. So every
five seconds, we increase the speed, okay.
242:14 - And then we can decide what we want to increase
the speed by. So I'm going to say level underscore
242:19 - time, we need to first reset this back to
zero so that we continue to do this. And then
242:23 - what I'm going to actually do here is going
to say, if level,
242:29 - underscore time is greater than, and we want
to put like a terminal velocity here. So at
242:34 - what speed do we stop increasing the time
because we obviously we can't get to a negative
242:39 - false speed, otherwise, you're just going
to instantly fall. And we don't want it to
242:42 - get too fast that the game is unplayable.
So we need to pick a speed. Now a good speed
242:46 - that I kind of found was 0.12. Because anything
faster than that is like pretty fast. But
242:51 - I mean, you guys can play with that and change
that around, it's really easy number just
242:55 - fix right. And then if we're greater than
that, we're just simply going to subtract
242:59 - a value from level underscore time. Now this
value, the magnitude to the size of this value
243:06 - that you're subtracting is going to determine
like how quickly you increase the speed as
243:10 - well as obviously the time. So I put originally
0.01. And I mean, depending on how long it
243:17 - takes you to play a Tetris game, this is pretty
fast, because that means after 50 seconds,
243:22 - you're already going to be down to 0.17, which
is very quick and almost a terminal velocity.
243:27 - So I recommend you do 0.005. That means it'll
take about a minute and 40 seconds before,
243:33 - you're going to be close to reaching this
terminal velocity, which might be good if
243:37 - you're playing Tetris for a decent time. Okay,
so you guys can play with those numbers. But
243:40 - that is he is going to move it down faster,
I would show you but it's going to take like
243:44 - a decent amount of time for it to continue
moving faster to just play with that. Okay,
243:49 - just trust me. All right, the next thing we
want to do is add score. So we need to first
243:54 - create a score variable and as a score is
equal to zero like that. an incorrect score
243:59 - is pretty simple, I'm going to say and you
guys can make this whatever you want. Whenever
244:03 - we clear a row, I'm going to add 10 to our
score, because you had 10 pieces or 10 cubes
244:08 - or whatever that you cleared. Okay, so actually,
the way that we need to do this is we're gonna
244:13 - return a value from clear rows, which is going
to be equal to score. Now I'm going to go
244:18 - to clear rows, and in here, I'm simply just
going to return I NC, okay. And I NC is the
244:26 - increments, so how many rows that we actually
ended up clearing. So if we clear the one
244:32 - row, we're going to get a value of two, we
can multiply that by whatever our score increments
244:35 - going to be. And then yeah, we can just add
that to the score. So this is pretty straightforward.
244:42 - If we go to clear rows, we're gonna say score
is equal to clear rows, multiplied by 10.
244:49 - All right, we're actually not equal to we're
gonna have to say plus equal to clearos plus
244:55 - 10. Now what we need to do is we need to display
this score on the screen, somehow. The user
245:00 - can see that we're actually going to save
the score as well when we lose the game. Okay,
245:05 - so the way that we can display this is we're
gonna have to do the intro window, but we're
245:09 - gonna have to pass the score to draw into.
So after our grid object, we're going to pass
245:12 - score like that. And we're going to go to
draw window. And we're simply going to add
245:18 - another parameter here score like that. Now
I'm just gonna set it equal to zero as a default
245:23 - parameter. So in case we call it somewhere
else, and we forget to add that score, that's
245:27 - fine, we don't need that. So what I'm going
to do now is I'm actually going to go to draw
245:31 - next shape and draw next shape. You can see
if I run the program quickly here, it shows
245:36 - us a little text object, okay? Now I want
to get this similar text object. So I'm just
245:41 - going to copy this font, the label sx s, y.
And I'm just going to bring it down here into
245:46 - draw window. Now it doesn't really matter
where you draw it, I'm going to plop it in
245:49 - the middle here. And obviously, I'm going
to change this from next shape to be
245:53 - score.
245:55 - Now we need to obviously display what the
actual score is. So we can just say plus STr
246:00 - score, like that, and that should be displaying
for us. Okay, so now we have s x and s y,
246:06 - which is giving us the play area, I believe
we're no this is actually the position in
246:11 - which we want it to draw it. Okay, so what
I'm going to do is I'm going to say now when
246:16 - dot Blitz, or is it surface surface,
246:19 - Blitz,
246:20 - our text object, which is the label, and then
where do we want to draw it to draw sx s y.
246:25 - Now, I'm just going to have a look up here
to see where I did it here. So that's x plus
246:28 - 10, s y minus 30. So what I might want to
do is, we can add plus time to this, so it's
246:35 - aligned, but then we're gonna subtract, or
actually add to the y, so it's lower. So I'm
246:40 - going to add, let's say like 80. Like that.
So let's test this out and see if it's working.
246:45 - Score, so it's not low enough. So we'll add
this and do 120. And see where we're getting
246:52 - enough score. Again, not low enough. Let's
go 160. And again, you guys can play with
246:57 - these, our score equals zero, perfect. And
then maybe we'll just add 10 more pixels here.
247:01 - So it's more in the center. And you know,
whatever, that's good enough for me. Okay.
247:06 - Good. So that is working well. So we've got
the score, and we're moving down faster. Now,
247:11 - what else do we need to do? What we need to
do now is work in main menu and figure out
247:15 - what happens when we actually lose the game.
So we have this check last, and all this simply
247:19 - does is just quit the game for us when that
happens. But we want to do something else
247:23 - when we lose, and we want to display something
to the screen. So actually, before I go on
247:27 - Main Menu, I'm going to go up here to a function
that I told you guys, I need to get rid of
247:32 - that, that I was going to finish, which is
draw text in middle. Now this is going to
247:36 - take a surface
247:37 - text.
247:39 - And what else do we want, say size and color.
Okay, so surface text size color, this way,
247:46 - you can use this in another function or sorry,
in another program, and you can use them multiple
247:50 - times with whatever text size and color you
want. So we're going to set up a font and
247:53 - say font equals pi game, dot font dot s, y
s followed by now you probably know this,
248:01 - I'm just gonna pick Comic Sans, we're gonna
make it equal to size and bold is going to
248:07 - be equal to true. Now, you can make this false
if you want, or just omit it completely, and
248:12 - then it won't make it bold, pretty straightforward.
Make a label label is equal to again, font
248:18 - dot render. And then we're gonna say text,
one for anti aliasing and color, like this.
248:26 - Okay, now we'll just simply draw this in the
middle of the screen. So to do this, we'll
248:31 - say surface uplit. label, comma, and now we're
just gonna do a little bit of math here. So
248:37 - top underscore, left, underscore x plus play
underscore width divided by two, not three
248:45 - minus, and we're gonna get the label width.
And the way we do this, I don't believe I've
248:49 - actually done this yet, is get underscore
width, I think I'm just gonna check Yeah,
248:53 - get width. And then the reason I have this
in brackets, because I'm going to divide this
248:56 - by two as well. And this will essentially
give us the middle position where we should
249:01 - be drawing in terms of x squared, okay, so
now I'm going to give top underscore left
249:05 - y plus play underscore height divided by two.
Okay, and now same thing minus label dot get
249:17 - underscore height in brackets and divided
by two. I don't know why kids tab over here,
249:26 - okay. divided by two. And that should hopefully
be working for us. Okay, so we can test that
249:32 - in just a second. So we've got this, it's
bleeding now, whatever text we want to the
249:35 - screen. So this makes it really easy for us
to draw anything to the middle of the screen.
249:39 - So the first thing I want to draw to the middle
of the screen is like a you lost message.
249:44 - So when it says you've lost, what I want to
do is draw obviously, you lost and tell them
249:48 - so let's say draw, text, the middle. And then
what do we want to draw? Well, let's simply
249:55 - draw what surface first actually that we need.
So we'll say when And then we're going to
250:02 - pass it text. And in this case, we're gonna
say you lost exclamation point, size. Let's
250:08 - go for AV, and color. Let's go white. And
obviously, you guys can play around with that.
250:16 - Now after I draw that, and I display the screen,
or update the screen, pi game dot display
250:21 - dot update, just because we haven't called
the window yet, draw window when we do this,
250:27 - then what we're going to do is we're just
going to delay, so we're gonna say pi game
250:29 - dot time dot delay. And I'm just gonna delay
one and a half seconds, just so once this
250:35 - comes up, the user has a second to look at
it, because then we're gonna move back into
250:39 - our main menu screen, which you'll see. Okay,
so I'm just gonna fast forward this until
250:45 - I lose, and then you guys can see that it's
working. And there we go. So we got you lost,
250:53 - and then it delayed, and then just quit because
I have this pygame dot display dot quit here.
250:57 - Okay. So now what we're going to move to his
main menu, everything else is working. I told
251:01 - you guys snot, like super difficult. While
this stuff in main menu, what we're going
251:05 - to do now is we're just going to make it pop
up whenever you start the game. And whenever
251:08 - you lose, it's just going to say hit any key
to, like, move forward to continue. Okay,
251:14 - so once you set another game loop in here,
so we're gonna say run equals true. Well run,
251:20 - and this is gonna be really similar to the
loop we've done above, it's just step just
251:23 - a lot shorter, we're, and we're going to just
draw in here, without using a different function,
251:28 - just because we're not drawing very much.
So it's not important that we would call it
251:32 - like, update the screen with a defined function.
So I'm just gonna fill it with blocks, we
251:35 - cover getting rid of everything, we're gonna
draw text middle. And what I'm going to do
251:39 - here is I'm gonna say press any key to play,
okay. And then we'll give this a size of 60,
251:47 - and a color of white once again. Okay, so
that's being drawn in the middle, we'll update
251:54 - the display, so pygame dot display dot update,
like that. And then we're gonna say, for event
252:01 - in PI game, dot event tickets are similar
to what we've already typed up top, we're
252:06 - going to say, if event dot type equals equals
pi, game dot quit, we always want one of these,
252:13 - not quit Q, then we're simply going to say
run.
252:18 - Oops, run is equal to false. And then we can
tab out here, and we can just make sure that
252:24 - we are actually quitting the display. So dot
quit. And we'll get rid of this pygame dot
252:29 - display dot quit. And then we're gonna add
one more event, and this event is going to
252:34 - be a key down. So whenever they press any
key on the keyboard, then that is going to
252:38 - move this forward. And we're simply going
to call this main function where we'll play
252:43 - and I'll explain how this kind of flows in
just a second because it's really nice. Okay,
252:47 - so if event dot type equals equals pi, game
dot, all capitals, key down, so if they hit
252:54 - any key, then what we're gonna do is we're
gonna say main, like that. Okay? And I believe
253:00 - that is about it. Okay, yeah. So let's see
here. pygame dot display quit, looks correct.
253:07 - Okay. So the way this is gonna work pretty
much is when we run the game, we start by
253:12 - running main menu. So we run main menu, and
then we go into this main loop, where all
253:17 - its gonna do is just say press any key to
play, and that's going to be drawn in the
253:20 - middle of the screen. Once that happens, we're
going to check if they're hitting any key,
253:24 - if they hit any key, we're going to call mate,
in which case, or let me close this, so it's
253:27 - easier to see. If we hit main, then we go
into the main game loop, and we go in, we
253:32 - do this loop until eventually we lose. Once
we lose, it displays you lost on the screen,
253:39 - makes this loop equal to false, which means
it brings us back into this main menu loop.
253:42 - And we can play again by hitting any key.
Pretty straightforward. Okay, so let's test
253:47 - this out to make sure this is working. Draw
text missing one potential argument color.
253:52 - Because I didn't give a surface My bad. So
let's just do win. And there we go. Okay,
253:57 - so press any key to play. Press space missing
one, mate. Sorry, guys. So this is why we
254:04 - tested Perfect. Okay, when. And now let's
try. There we go. And now we're playing shows
254:08 - the score, and you guys can mess around, I
haven't actually tested the score. So I'll
254:11 - just do this really quickly and see if I can
clear row without having to fast forward.
254:17 - Which we may be able to do
254:18 - not using that one.
254:21 - Okay, let's see. There we go. And score is
equal to 10. So the score system is working
254:26 - as well. And that's relief, because I hadn't
even tested that before I put this in the
254:29 - video. Okay, perfect. Oh, when you press the
X brings you to press any key to play. If
254:35 - you press it again, you can do that. So if
we wanted to change it, so when you hit the
254:38 - X key in the main thing, and you want to close
the game, then in the main loop here, sorry,
254:44 - what are you going to do instead of saying
runnicles false just to high game. Display
254:49 - dot quit. So you can do both the and say run
equals false and then you can quit the display
254:53 - as well. Okay, so what's next? So I said we
were going to save the score and potentially
254:59 - display that So if we want to save the score,
we're gonna have to do something when we lose,
255:04 - so we're gonna have to update, like the current
score. And we're gonna use a text file to
255:07 - do this so that you can play multiple times.
So what I'm gonna do, I'm gonna say new file,
255:10 - to create a new text file, I'm just gonna
call this scores dot txt. Okay, and here,
255:16 - I'm just gonna put zero as a default value,
it's really important you put a default value
255:20 - to start, otherwise, you might run into some
issues. So just create a new text file, make
255:23 - sure it's in your directory with the mean,
with the script, okay? Now, what I'm gonna
255:28 - do is I'm going to create another function
doesn't really matter where it goes from,
255:32 - say, define, update underscore score, and
we're going to give it score. Okay? Now and
255:39 - here, what I'm going to do is I'm going to
say, with open, and this is how we're going
255:44 - to open our text file and like update and
display with open scores dot txt, in our so
255:49 - in read mode, and this action needs to be
in quotation marks as well, we're going to
255:53 - say,
255:54 - F,
255:55 - F, do this as f sorry, say F dot read lines
like this, okay. And that'll be equal to lines,
256:08 - is equal to F dot read lines. So that means
our score is going to be, well, the first
256:11 - line, so score is equal to lines, zero. And
we're gonna add this dot strip, so that we
256:19 - remove any like backslash ends, because if
you don't know, in a text file, when you hit
256:24 - the next line, the way that it actually tracks
that you have another line is it puts a character
256:28 - that looks like this, on the line, it's invisible
to you in the text file when you're viewing
256:32 - it. But when you read it in with code, you're
actually reading this character. So we just
256:34 - want to make sure we strip that off, in case
it is there. We're gonna say score equals
256:39 - this, and then we'll just set Okay, so we've
done that. And since we're tabbing out now,
256:43 - it'll, it's going to automatically close our
file, what we're going to do now is we're
256:47 - going to open the file again, except in this
time, we're gonna open it right mode, which
256:50 - means we're going to overwrite whatever is
in the file. And we're simply gonna say, if
256:56 - score is, I guess I'm gonna change this to
and score standing for new score, if score
257:03 - is greater than n score, then we'll say F
dot, and we'll say write lines, actually,
257:11 - right, I think, and we'll simply put in str
of score, which is this update score, otherwise,
257:19 - so if that's not true, we just have to write
back the other score, because we're clearing
257:23 - it when we open this with w mode. Okay, so
we're gonna say F dot write, and then we're
257:27 - sorry, this is gonna be limiting, and n square.
Yeah, sorry. So I kind of messed up in this
257:36 - way, it should be the other way around. But
whatever. We're just checking if the original
257:40 - score is greater than the new score, if it
is, we'll write the original score, otherwise,
257:43 - we'll write the new score. So this works still,
it just not the way that I was thinking about
257:47 - it when I was kind of talking about that.
Okay, so update score
257:49 - should work.
257:52 - And then you can actually return, let's just
return actually, now we don't need to return
257:56 - anything. So I haven't pre written this yet.
So I'm kind of still just going through how
258:00 - I want it to work. Okay. All we'll do here,
after we start running equal to false, we'll
258:04 - say update score, and we'll give it whatever
the current score is. And then it should be
258:09 - working in the scores dot txt file. So let's
run this. I'll fast forward through and make
258:14 - sure everything's working. Okay, so we go
they're not supported between insists of string
258:27 - and int, okay, so if score greater than sports,
which means we have to convert the student.
258:31 - So if we go back up to score, and where did
I make this, okay? Score is going to be int
258:40 - score, like that. Okay. And that should hopefully
work because n score comes in as an int. And
258:47 - we'll run a one time one more fast forward.
Sorry about that, guys.
258:54 - Okay, and another issue lines, zero, Linda,
list index out of range. Okay, I'm gonna have
259:02 - a look at this and come back. Okay, so this
code is actually working just fine. The issue
259:06 - was that since last time, when it crashed,
we didn't end up writing anything into the
259:11 - file. So we had a blank file, and then we
were going lines zero, where is it here, and
259:16 - obviously, there was no line zero, so that
crashed. But if you just add any numbers like
259:20 - that, add zero back in here, two squares dot
txt and save it, then this works fine. Okay,
259:24 - so that's it for saving scores. Now we need
to display those same scores. So I'm coming
259:29 - in to leave this up to you guys where you
want to display it, I don't really know where
259:33 - I want to put my same score, like high score,
maybe on the left side of the screen. Doesn't
259:38 - really matter. So if I want to draw it on
the left side of the screen, then I can do
259:42 - something like, we're gonna have to first
get this max score, right? So I'm gonna have
259:47 - to make a new function called define, Max
score, or last score, whatever you want to
259:53 - call it. And if you call max score, what we're
gonna do is we're just gonna do the exact
259:58 - same thing we did here. So we can say with
open source text, source zero slot zero dot
260:02 - strip, except in this time, we're going to
return a
260:06 - score
260:07 - like that. Okay? Now, we actually do here
too is we can just simply replace this whole
260:13 - line with Max score and just say, score equals
max score. really efficient way to do it.
260:20 - And I mean, feel free to do that if you want
or leave it the other way. Okay, so now we
260:24 - have something that's getting us back score.
So how are we going to use this? Well, when
260:27 - we call mean, I guess when we call me or we
can call Main Menu does it like you guys,
260:32 - if you want to draw it on the main menu, you
can do that otherwise, straw didn't mean to
260:35 - draw it in the main, all you're gonna do is
gonna say like last
260:39 - score is equal to max score, which is going
to be whatever it is stored in that text file.
260:45 - And then to draw this old, we're gonna have
to pass this again, into when we're redrawn
260:50 - window. So in draw window, I'm just gonna
say, last score, we can go up to draw window
260:56 - again, say, last underscore score equals zero.
And you're pretty much gonna copy exactly
261:04 - what we have here, with this font, and the
split. So let me just call it out this and
261:09 - say, This is correct score. So I remember,
you had a comment, say, last score, high score,
261:18 - whatever you want to say here. And then we
can just say score. And we can actually get
261:23 - rid of this font, because we already defined
it will say, high score equals, and in this
261:30 - case, last underscore score, okay? Draw that
to the screen, this is probably not where
261:36 - you want to draw it, you probably want to
draw it, top left x, minus, like some value
261:42 - minus 30, top left y, maybe Plus, I don't
know, like 300, or something. So now we can
261:50 - see where this is actually going to draw if
we check this out. So let's run this, press
261:55 - any key. So it's not obviously showing up
where we want to, we're gonna have to subtract
261:58 - more from this. So let's subtract like,
262:02 - I don't know
262:03 - 100.
262:04 - And then this was plus too much c plus 200.
And high score. So again, like you got to
262:11 - move it over more. So we'll move over 200
this time, and hopefully this works. Okay,
262:15 - so high score zero score zero. And that's
obviously because at the current moment, we
262:20 - have no, or our score is just zero in that
text file. Okay, so I think that is pretty
262:25 - much it for this video. So essentially, this
is online game development with Python, which
262:34 - means we're going to be using sockets and
networking to connect what's known as a client
262:38 - and a server or multiple clients to a server,
where they can send and share information.
262:43 - And therefore we can create an online game.
So we're going to start off with just the
262:47 - absolute basics and just get shapes. For example,
like if I move a shape on my computer, it
262:52 - moves a shape on your computer, like if you're
the other client, and then we'll start getting
262:56 - into some more advanced stuff where we create
a legitimate game and start sending massive
263:01 - amounts of information to the server, and
back to the client. So we'll start really
263:05 - simply by just getting everything working
on our local network. And then once it's working
263:08 - on our local network, we'll deploy that to
an external server, which will allow us to
263:12 - play from anywhere in the world, not just
against people on our local network. Okay,
263:18 - so what I'm showing you right now is actually
an online game that I created with Python
263:25 - pi game and networking. And this is similar,
something we're gonna make obviously not as
263:29 - advanced, but it works on the same principles.
So essentially, I have what is known as two
263:34 - clients. Now if you don't know, the way that
any online game works is we have multiple
263:39 - clients connecting to one main location, which
is known as a server. Now right here on my
263:45 - screen, we have two clients. So this client
on the left that my mouse is kind of going
263:48 - over that has this red highlight the way the
rook is, or where I just didn't vote to move
263:52 - this night is client one, and then this block
one over here. So like your block, where I
263:57 - just moved this pawn is client two. Now you
can see in the background, I have this command
264:03 - line thing going and it's sending and receiving
information. And this is essentially how a
264:08 - online game works. And you might see, whatever
you guys playing online game, it says waiting
264:12 - for server we're connecting to server. And
that's because it's doing exactly that. It's
264:16 - waiting to get a connection to the server
and then grab information from that. So that's
264:20 - the way that we're going to be doing things
is using the client and server. Now I'm not
264:24 - going to be using any frameworks that are
pre created, like, I know there's like twisted
264:29 - and some other frameworks for Python, the
only module we're going to be using the external
264:33 - is pi game and that's just to create some
very basic graphics. Okay, so let's close
264:37 - this, I just want to give you guys an example
of what an online game looks like. And you
264:40 - could see when I was moving something on one
client, it would move it on the other. So
264:44 - let's close that up. And let's actually get
started with the tutorial did not mean to
264:49 - open up. So I'm going to be working with PI
charm for this tutorial. Now if you don't
264:54 - know what pi charm is, it's an ID. To download
it. All you have to do is just go to the internet.
265:01 - Type pi charm. And you can go here and click
Download whenever it loads up. Now, if you
265:08 - guys don't want to use PI charm, that's absolutely
fine. You can do everything using the standard
265:12 - editor like ideally you can use atom, Muse,
whatever you want. But if you want to follow
265:17 - exactly what the tutorial I'm going to be
using pi charm. Now the next thing we're going
265:21 - to need other than it, I guess you don't need
pi charm is we're going to have to install
265:26 - pi game. Now for 90% of you, the way that
you're going to be able to install pi game
265:30 - is just by going to command prompt, loading
it up like this and just typing pip install
265:36 - pi game, and then hitting Enter. Now, if this
doesn't work for you, I'll put a card in the
265:43 - top right hand corner of the screen right
now, which tells you where you can go to install
265:47 - pi game. And I have a video explaining you
exactly how to do this. And if this command
265:51 - doesn't work for you can follow that video,
and I'll explain to you how to do that. So
265:55 - once we have pygame, then we're ready to actually
start writing a bit of code. So while I launch
266:00 - up pi charm right here and create a new project,
let me just tell you about, I don't know some
266:05 - of the things we'll be going through in this
tutorial series. So obviously, we're going
266:08 - to be working on coding both a client and
a server. And I'm going to explain obviously,
266:11 - exactly how those things work, and how we
can create them. And then what we're going
266:17 - to be doing is we're going to be dealing with
a bit of server like administration, if you
266:21 - want to say that. So actually deploying things
to an external server, stalling in pen, installing
266:28 - dependencies, working with like a Linux server
to deploy our game to and that will be at
266:33 - the end of the series that we do that right
now we're just gonna be working with what's
266:36 - known as local host, which means that we're
just gonna be doing it on our own network.
266:40 - So right now, the games that we create are
only going to work on our, what do you call
266:44 - it against people that are on our Wi Fi or
on the same network as us, and then later,
266:49 - it'll work against anyone in the world that
has that client downloaded? Okay, so let's
266:54 - just create a new project here, my new project,
I'm just gonna say is tutorial, let's say
266:59 - network tutorial waters.
267:01 - And just as a, what do you call it here, just
letting you guys know, I did actually mess
267:08 - up my thumb a little bit. It's kind of swan.
So if my typing is not the best, that is actually
267:14 - my excuse for that. So now that I've got a
new project opened, I'm just gonna create
267:17 - a new Python file. Let's call this tutorial.
One, actually, let's call this client, okay.
267:22 - And just save that as okay, because that's
all we're going to be coding in this video
267:26 - is just a very basic client. Okay, so now
we've got client. So what I'm going to start
267:31 - off by doing is creating a configuration for
my client. And keep in mind, if you guys are
267:34 - using something else, you don't have to worry
about what I'm doing with this pie chart specifics.
267:39 - This just the way you have to set up a project
in PI charm. So I'm just gonna set a client,
267:44 - I'm going to go to script path network game
client. Okay, apply. Okay. Now, quick side
267:51 - note, all the code that I'm about to write
is available on my website tech with Tim dotnet.
267:55 - Usually I have as well as that a text based
tutorial version. I'm not sure if I'm gonna
267:59 - be able to write the text based tutorial.
Well, this first tutorial is out. But you
268:04 - will see it on there at some point input tutorial
import pi game. But yeah, all the code will
268:08 - be available on there in case you guys missed
something or something's not working. So we're
268:11 - going to start by importing pi game and make
sure that that's working. Once that's working,
268:15 - we're going to create a window. So to do that,
we'll just say, when equals pi game, dot display
268:22 - dot update, or what am I saying pi game dot
display dot set underscore cap set underscore
268:30 - mode. Wow, bit tired today guys. And then
in here, which can type width, and height,
268:35 - and then we're going to create these variables.
So say width equals 500. Height equals 500.
268:43 - Okay, so there we go with height when and
now we're just gonna set up a few global variables
268:48 - we're gonna have to use after we create a
caption, so let's just say
268:50 - login,
268:52 - dot display, dot set underscore caption. And
then in here, we'll just go to caption, let's
269:00 - just say,
269:01 - client. Okay? Alright, so
269:03 - now let's set up a global variable that we're
gonna use. And what we're gonna do for this
269:06 - global variables, it's gonna hold the current
like clients, we're gonna say, like client
269:11 - number. I want to start by making that zero,
but we're going to increment that based on
269:17 - like, once we connect to the server, which
we'll do later. Okay, so now that we've done
269:21 - that, there's a few basic things. This is
what we always do for like a PI game project
269:25 - or whatnot. I'm just gonna define redraw window.
Okay, and in here, all we're going to do is
269:30 - just pi game dot display dot update, like
that. And we'll also fill the display before
269:37 - we do that, oops, didn't mean to do that.
With when dot fill, and it will just pick
269:43 - a color. In this case, I want to do whites
which is 255-250-5255. Okay, now Yeah, I just
269:50 - realized this is actually gonna be a lot harder
to type than I thought because my thumb so
269:53 - just excuse me guys, if I'm making a few mistakes
here. Okay, so we got our redraw window now
269:58 - and what we can do next is We can code our
main loop. So I'm going to say define main.
270:04 - And then here I'm just going to create a game
loop. And this is going to run continuously
270:08 - while I program is going and it's just gonna
be what's checking for collision checking
270:12 - for events can constantly asking the server
for information, and you guys will see how
270:16 - this works in later videos more. So we're
gonna say run equals true. And then here,
270:20 - we'll say well run. And we'll just set up
some very basic things that we always do for
270:24 - pygame. So for event in PI game dot, event,
dot get, okay. And then we're gonna do say,
270:32 - if event dot type equals equals pi game dot
quit with all capitals, then we'll simply
270:40 - do pi game dot quit like that. Don't need
a semicolon, I guess we can say run equals
270:46 - false as well.
270:48 - Okay, for events, that looks good. And then
what else we'll do in here is we'll just call
270:53 - that redraw window function. So redraw window
like that. Now, what I'm thinking we should
270:58 - do next is probably set up a class for our
character, okay, now our character is going
271:04 - to be just the only object we're working with
right now. And it's just going to represent
271:07 - like a rectangle that moves like left out
up right around our screen. And I guess we'll
271:12 - do that all in this video moving that character
around, and that will connect it to the server,
271:16 - the next one. So let's create a class. And
we'll do that up here. And we'll say, class
271:20 - player like that. Okay, so we'll give it a
knit function. If you guys don't know much
271:25 - about object oriented programming, and programming,
and you want to learn, I do have a tutorial
271:29 - series on my channel that I would recommend
you go through if you don't understand a lot
271:33 - of the stuff that I'm doing right now. Okay.
So x, y width heights will be what we get
271:37 - in here, this is just going to represent,
actually, let's give it a color as well, because
271:41 - it'll be good to have X, Y, width, height,
color. And yeah, this will just represent
271:47 - kind of our player and what variables they're
gonna have. So we'll pass these values in
271:51 - when we create an Eclair. So self dot y equals
y. This is very straightforward. self dot
271:56 - width equals width, and self dot height, equals
height. And finally, self dot color, equals
272:04 - color. So these are just our initialization
here, this is what we're going to use when
272:08 - we're drawing the character when we're checking
for collision or stuff like that. And what
272:12 - I'm also going to do to save us a bit of time
in the future, I'm gonna say self dot rect
272:16 - equals and then in here, let's do this, okay,
so x,
272:21 - y,
272:22 - width, height like that, okay. And this will
just make it a bit faster when we're trying
272:25 - to draw our character. So the next thing we're
gonna need is define draw. Now, in the draw
272:31 - method, here, we're going to take a window,
so we'll call that when, and all we're going
272:35 - to do is just draw a rectangle that represents
our character onto the screen, and obviously
272:41 - be the appropriate color. So to do that, all
we have to do is just say, when.oh. No, we
272:46 - don't see that we have to pygame dot draw
dot rect. standing for rectangle, we have
272:53 - to first give the window so we'll give when
we need the color. So we'll do self dot color.
272:57 - And then we need a rect, which will be self
dot rect. Okay, and that's actually all we
273:01 - need to do to draw the rectangle to the screen.
Now we need one more method we're going to
273:07 - use and it's going to be called move. And
move Actually, I believe, yeah, we don't need
273:12 - to do anything else in there. Right now as
the argument sorry. So for move, what this
273:17 - is going to do, is it essentially just gonna
check. What do you call it? If they press
273:21 - like left key, right key whatnot? How can
we move them around the screen? So the way
273:25 - that we can do this really, basically, essentially
is just do pygame.
273:29 - Dot,
273:30 - what do you call it dot keys, dot get underscore,
pressed, I believe that's it might be key
273:39 - might be keys, we'll see. We'll see which
one works. So this is essentially going to
273:42 - give us a list of all of the keys, actually
a dictionary of all the keys. And essentially,
273:47 - each key is going to have a value of either
zero or one. Now, if one is true, that means
273:52 - we're currently pressing the key, if zero
is there, that means we're not pressing the
273:57 - key. So the way that this is useful, as opposed
to doing what we could sometimes do, which
274:01 - is just check for events. And here is if you're
pressing more than one key at once, it'll
274:05 - allow you to move like diagonally or whatnot.
Okay, so what we can do in here now is we
274:09 - can just check if certain keys are pressed,
and then change the x and y values accordingly.
274:14 - So we'll say if, what do you call it? Oh,
I guess we should probably put this in a variable.
274:17 - Let's say keys equals pi game dot. Maybe I
feel like it's key, we're gonna go key for
274:22 - pi game dot key, don't get on a script. So
say if keys and then pi game, dot k underscore
274:29 - left standing for our left arrow key. And
that's all we need to do for that one. And
274:32 - then we'll say if keys and then pi game dot
k, underscore is this should this be all capitals,
274:42 - I think it should be k underscore, right.
And then the next one, if keys, pi game dot
274:51 - k underscore up, and then our last one obviously
is down. And then we'll change our values
274:57 - accordingly inside of these if statements,
so pygame dot k underscore. Okay, so left
275:04 - right up, down. So if we press the left arrow
key, obviously, we have to do a subtract from
275:08 - our x value. So to do that, we'll just say
self dot x minus equals self dot Val. Now,
275:12 - Val is something we need to define. So let's
do that up here, self dot Val equals, and
275:18 - let's do a value of like three for right now.
Okay, so if we're going to write we need to
275:23 - add to our x, so we'll do this very similar.
So self dot x plus plus equals self dot Val.
275:32 - Okay, if I could type that correctly, and
then to go up, we're going to subtract from
275:36 - our y value, so self dot y minus equals self
dot Val. And to go down, we'll do self dot
275:42 - y plus equals self dot Val. And that's the
way the coordinate system works in pygame,
275:47 - our coordinates actually at the top left hand
of our player or a screen, so if we want to
275:51 - go down, we have to add to it and then left
and right is the same in terms of subtracting
275:55 - and adding, okay, so that should successfully
move our player, we could add like a jump
276:00 - and stuff in here at another time. But for
right now, that's all we need. I'm trying
276:03 - to think of anything else that we could do
right? Now, we should probably create a player
276:07 - object and draw that to the screen just to
make sure everything's working. So to do that,
276:12 - let's create a player. Should we do it up
here, let's do it right above our main loop
276:16 - here. Okay. So we're just gonna say, actually,
we'll do it inside the main that this will
276:21 - work better. We'll say p saying for player
just equals player, and then we'll give it
276:26 - some values in x, y with high color. So for
x, y, we'll just start them out like 5050.
276:32 - And then for width, let's just do 100 by 100.
So he's nice and big, and we can see him and
276:36 - then we'll do a color of green. So that would
be red, green, blue, like that. So 255, for
276:43 - green. And then what we're going to do actually,
is we're gonna type in here, insert in redraw
276:51 - window, we're just going to pass p to our
redraw window so that we can draw him. And
276:56 - before we do that, we'll call p dot move.
And what this will do is move our character
277:00 - based on what keys we're pressing. So inside
redraw window, let's add a player. What do
277:07 - you call it? argument attribute, whatever
you want to call that. Sorry, parameter. That's
277:12 - the correct name. And then we'll just say
player dot draw, like that. And we'll pass
277:17 - winning here, which probably should be passed
in here as well, because we do use wind quite
277:22 - a bit. So let's do P. Let's do when and then.
Okay, so let's run this now and see if I made
277:31 - any mistakes I likely did. Process finished,
oh, we never calling the main function. So
277:37 - let's call this main function from down here.
So we're actually executing that code that
277:41 - we wrote. And there we go. So now we have
a little green square. And you can see, Hmm,
277:46 - interesting, it's not working for me to move
this around. So let's check this one more
277:52 - time. P dot move, what is move doing get pressed.
Let's just add, I want to add something here
277:58 - and make sure this is working. So let's, we're
gonna say clock
278:01 - equals pi game.
278:04 - dot time, dot clock. Okay. And then in here,
we're just gonna do clock,
278:10 - dot tick. And we'll do 60 FPS, I just want
to see if this is working. If not, I do know
278:14 - how to fix this. Okay, so we're not able to
actually move this. Oh, I know why. So very
278:21 - interesting. We are not updating this rect.
But we are updating. What do you call it like,
278:27 - up, down, left, right. So at the bottom here,
all we're gonna do is just redefine our rect
278:31 - by doing self dot x, self dot y, self dot
width, and self dot height. Now I'll really
278:39 - quickly explain why this error was happening.
Essentially, we're defining rect up here based
278:43 - on the input parameters when we're creating
our player. So that means we're always just
278:48 - constantly drawing our rectangle in the same
position, because we're never updating this
278:52 - rect variable, we're only updating like x,
y, width, height, right. So we just have to
278:57 - redefine our rect variable every single time
that we're moving, which is fine. And we can
279:00 - do that. So now let's see. And we can move
our green square around the screen, I actually
279:05 - quite like the speed this movement. So yeah,
so essentially, in the next video, we'll we're
279:09 - going to be doing it so I'm wrapping it up
here is we'll add a little bit more to this
279:14 - client. And then we'll start working with
sockets. So we can connect this up to a server.
279:18 - And we'll start talking about all the networking
aspects. And then so in this tutorial, we're
279:25 - going to be working on coding the server.
And then in the next video, we're going to
279:29 - be connecting this client that we made in
the last one to that server and then sending
279:33 - information to and from the server. So let's
get started. And let's create a new file that
279:38 - is going to be our server file. So I'll just
call this one server.pi. And then in here,
279:45 - we're just gonna have to import a few things.
I'll talk about exactly what they're gonna
279:49 - do for us once we start using them. So let's
start by importing sockets, our socket, then
279:55 - we can import underscore thread and We'll
also import OS. Okay, so actually not sorry.
280:06 - That's why Yes, that's all we need for that.
So what we're going to be doing, like I've
280:10 - talked about is we're going to be using sockets
and threading, to handle connections to our
280:15 - server. And essentially, what that means is
we're going to set up a socket, and it's going
280:19 - to allow for connections to come into our
server on a certain port. So we're gonna start
280:24 - by just defining server, which is going to
be a string, and port, which is going to be
280:30 - a number. Now for port, you guys probably
know what ports are, you might have heard
280:37 - of them before, for example, like a common
port you would use on or common port that
280:42 - is used on your on your router would be Port
80. And that is for HTTP connections. There's
280:47 - also a port like 443, there's there's tons
of other ports that have distinct uses. But
280:54 - there's also a ton of ports that don't have
any uses and that are just left open for programs
280:58 - like this, or for different things to be used
for. So what port I'm going to use, which
281:02 - is typically open, it depends on like what
router you're using and your internet connection.
281:06 - But typically a port that's open is 5555.
So we're going to use this port to connect
281:12 - to and from and it's just a safe port to use,
as opposed to trying to use another number
281:16 - that we might not know if it's being used
for something else or not. Okay, so once we've
281:20 - done that we've created a server and create
a port we're going to do is we're going to
281:24 - set up what's known as a socket, okay, and
we'll talk about exactly how this works in
281:27 - a second. But we're just gonna say s equals
socket, dot socket. And then here, we're going
281:34 - to type something that's probably gonna mean
nothing to you, but I'll talk about what it
281:37 - means. So we'll say, socket equals AF, underscore,
eye net, okay. And then socket dot sock stream
281:44 - like that. All right. Now, these are just
the types of connection. So since we're going
281:48 - to be connecting to a ipv4 address, which,
again, we're gonna keep talking about all
281:53 - this stuff, as we go through in case you guys
are unfamiliar with networks, this is the
281:57 - type we're gonna have to use and sock stream
just I believe, represents, like how the server
282:02 - string comes in. I could be wrong on that.
But this is the type we're gonna use. And
282:07 - for any kind of applications like this, this
will be what you use for your socket. Okay,
282:12 - so we're just initializing that. And now the
next thing to do is to bind our server and
282:16 - our port to the socket. So to do this, we
need to do a try and accept. And the reason
282:21 - we do this is because like I talked about,
we don't know if this is actually going to
282:24 - work on initially doing it, there could be
in some instance, this port is already being
282:29 - used for something. And if that's happening,
that means that this is going to fail. So
282:32 - we need to try and accept this. So it will
accept, what do you call it? error as he said,
282:39 - when we say socket dot error, as he will just
print that out to the screen, just so we know
282:45 - why we're not working there. Otherwise, what
we'll do is we'll say s dot bind, and then
282:51 - in here, we're going to put server comma ports.
Okay, so we'll bind to whatever IP address
282:57 - we'll put in here, to this given port. Okay,
so I hope everything's making sense so far.
283:02 - Essentially, what we're doing when we do sockets,
is we're setting up a connection or we're
283:07 - using a port on our server on our network,
it's going to look for certain connections.
283:14 - And then we'll be doing this on the client
side as well will be binding or not enough
283:18 - will be binding, we'll just be connecting
to a certain server at a port. And then since
283:23 - we're connecting to that this server script
that we're gonna have running will see that
283:27 - connection and handle it in some way. Okay,
so now that we've done that, I'm trying to
283:31 - think what else we have to do. Okay, so what
we're gonna start by doing is we're gonna
283:34 - start listening for connections. So we're
gonna do s dot Listen, now. So listen, essentially
283:40 - just opened up the port. So now we can start
connecting to it and having multiple clients
283:44 - connecting and whatnot. So in here, this actually
takes one argument. Now it's optional. And
283:50 - if you leave it blank, it means it'll allow
for unlimited connections to happen. Now,
283:56 - depending on what kind of program you're writing,
is, what you're going to do for this now for
284:00 - me, I only want two people to be able to connect
to my, what do you call it? Yeah, to my server.
284:06 - So we're just going to do s dot listen to
Now this might actually be one because it
284:10 - might be like 01, but I think to maybe the
correct thing, so do s dot listen for now.
284:15 - And then what we're gonna do is we're going
to print after we've listened, we'll just
284:18 - say waiting for connection. And we'll say,
server started or something like that. Because
284:25 - once we get to this point, we are running
the server and everything actually is working
284:31 - like we're listening for connection, we're
ready to go. Okay, so the next thing we're
284:34 - going to do is, we're going to define something
known as a threaded function. Okay. And we'll,
284:40 - I'll talk about again what this means. But
let's just do threaded threaded underscore
284:46 - client for now. And I'm just putting, you
don't actually have to name it this you can
284:50 - name it whatever you want. I'm just putting
threaded here just so we know. This is threaded,
284:53 - and then it's going to take one argument which
is going to be co nn, which stands for action
284:57 - and let's just pass in there for right now.
So the way that threading works, actually,
285:03 - let's, let's do the threading. And then we'll
talk about how it works. So they'll probably
285:07 - make a bit more sense. So let's do a while
true down here. Okay, so once we set up our
285:12 - server, our port we bind it doing here, we're
starting to listen waiting for connections
285:16 - starting the server, then we're going to do
is we'll be get put into this while loop.
285:20 - And what this while loop will do is will continuously
look for connections, okay? Because right
285:24 - here, we're just listening, like once right
to see if anything's on that server port.
285:28 - But down here, we want to continually try
to grab connection to see if somebody's connected.
285:33 - And if it does, then we want to print something
to the screen are we gonna send information
285:37 - are we gonna start a new thread, which we'll
talk about in a second. So in here, what we're
285:41 - gonna do is gonna say connection, which co
nn and then ADR equals and then s dot, and
285:48 - then we'll say accept. And what s dot accept
is going to do is it's going to well accept
285:53 - any incoming connections. And then it's going
to store the connection and the address. And
285:59 - the connection is, by the way, an object representing
like, what's connected, the address is going
286:02 - to be an IP address in these variables. So
if we get a connection, what we'll do is we'll
286:10 - say, print
286:11 - connected to Okay, and then ATR. And this
is going to show us what IP address is actually
286:19 - connecting. So we can have a look at that.
And then what we're gonna do is we're gonna
286:22 - do start underscore new underscore thread.
And then in here, we're going to do, what
286:29 - was that name of the function that we had
was threading clients. Okay, and I believe
286:37 - we do, comma, and that in brackets here, we
do see, like that. Okay, so start new thread.
286:43 - Is there a reason that's not working? Give
me a second, I want to see why
286:47 - oh,
286:48 - that's why. So up here, instead of saying
import thread, we're gonna say from underscore
286:53 - thread, import star. Okay, and that's just
gonna make it so we can just do start new
286:58 - thread thing. And you know, what, I don't
know if we're gonna need this S y s, but let's
287:02 - just leave it there for now. Okay, so let's
talk about what reading is gonna do. So essentially,
287:07 - the way that you guys are used to programs
working, I'm assuming, unless you have some
287:11 - familiarity with threading is that say, we're
in this while loop, right, and we were to
287:15 - call the function thread client.
287:18 - Well,
287:19 - before we continue going with this while loop,
we would have to wait until this function
287:23 - was done running. In other words, we return
back from this function, some value, or, for
287:28 - example, like he does, like x equals five,
we would have to wait for this x equals five
287:32 - to execute, and then it would come back in
this while loop and keep going. Now, we don't
287:37 - want that to happen, because we're going to
be having multiple connections going at once.
287:43 - So what we want to do is we want to start
what's called a thread and the thread is just
287:47 - another process that's running in the background.
So that just means when we do start new thread,
287:51 - and we do threaded client, it's going to run
this function, but it's not going to need
287:57 - this function to finish executing before it
continues the while loop. So this is going
288:00 - to be running in the background as like process
two, while process one is still running and
288:06 - still going. So that means say we connect
to 100 different things, we're going to have
288:11 - 100 different functions running. So 100 different
threaded clients on the stock or like keep
288:15 - going. And then what we're going to have is
this while loop still continuing to go, what
288:20 - did I just do, still continuing to run to
look for another possible connection, you
288:25 - guys will see more how this works, but essentially
just means this will run in the background.
288:30 - And we don't have to wait for it to finish
executing before we can accept another connection.
288:35 - That's the basic kind of a way to that works.
So now let's start working with threaded client.
288:40 - And then we will test the server out and see
if it's working. And then obviously in next
288:44 - video, we're going to connect to it and do
all the connection stuff. Okay. So in here,
288:49 - threaded client. So what should happen when
we connect to a client? Well, we're going
288:55 - to have to do a while up in here. So we're
gonna say well, true. Because we want this
288:59 - to continually run well, our client is still
connected, okay? Now, what we're also going
289:05 - to do is, we're just going to say reply equals
blank like that. I'm just copying from my
289:09 - other screen, because this one is a bit finicky.
I don't want to mess it up. We're going to
289:13 - put a try in here. And then we're going to
say is we're going to try to receive some
289:17 - kind of data from our connection. Okay, from
whoever's connected, we want to receive some
289:22 - kind of data. So what we'll do is we'll say,
I believe it's s con dot receive. That might
289:29 - be right. Yeah, I think that's right. And
then here, we're gonna put the amount of bits,
289:33 - okay. Now, if you guys know anything about
computing, you know, like how what bits represents,
289:38 - but essentially, this is the amount of information
we're trying to receive. Now, if you're getting
289:44 - an error, when say you'd like do this and
you connect up and you get some error that
289:48 - says,
289:49 - What do you call it?
289:52 - Like object was true answer like you're getting
any errors just increase this size, okay?
289:57 - And you can just do that by like putting this
like time Ate or something, just note that
290:01 - the larger the size is, the longer it's going
to take to receive information. And that's
290:06 - obviously because the more information you're
getting, the longer it takes to send that
290:10 - over the server. So 2048 bits is not a lot,
it doesn't take very long, it happens almost
290:15 - instantly. But if you bump this number up
to a ton, then it will take longer to do that.
290:20 - Okay, so data, then we're gonna say reply
equals, and then we say data
290:25 - dot,
290:26 - I think it's actually string dot d coach.
Let's see this data dot decode, because it
290:31 - will be in that kind of objects for that data
decode. And then here, we're going to do UTF,
290:37 - eight, comma, eight. Now, the reason we have
to do this is because whenever we're sending
290:41 - information over a like client server system,
we have to encode the information. And you'll
290:46 - see that in the next step that we're going
to encode information before we send it back
290:50 - to the client. But that means that we're receiving
encoded information. So to actually be able
290:56 - to read it like a human readable string, we
need to decode it first. So it's really easy
291:00 - to do that we just do dot decode, and we're
just giving the format which is UTF, eight,
291:04 - okay? So reply equals that. And then we're
going to say address, if not data, we're going
291:09 - to print disconnected, okay, and then we're
going to break. And this just means if we
291:17 - try to get some information from the, what
do you call it, the client, but we're not
291:22 - getting anything, we're gonna disconnect and
we're gonna break. And that likely means that
291:27 - we've will disconnected from the client or
the clients left or something like that. So
291:31 - instead of continuing to run this, while we've
been trying to get information from a client
291:35 - that's disconnected, we're going to break
this just kind of a failsafe to make sure
291:38 - we don't get into any infinite loops. And
it's also going to show us if we're running
291:43 - into any issues with like receiving the data
and decoding it, which we'll talk about later.
291:47 - Okay, so otherwise, so if we are getting information,
all we're going to do is we're going to print
291:52 - received, is that how you spell received,
maybe? And then we're going to put? What do
292:00 - you call it? reply, okay. I didn't mean to
that. Let me see if I'm spelling this, right,
292:05 - I have not received reply. So this just means
we received from the client, this reply, let's
292:09 - print to the screen, see what it looks like.
And then we're gonna print sending a colon?
292:18 - And we'll just print reply. Okay. And then
we'll talk about this again, in a second.
292:21 - Why does this keep happening? Okay, reply.
Next. Now, after this, if not data breakout,
292:28 - what we'll do down here is we're gonna say
con dot send all and we're going to send str
292:35 - dot encode, reply. Now, again, remember that
since we're sending information over the server,
292:42 - we have to encode our information. So all
this is going to do is just encode our string
292:46 - reply into a bytes object. So that means when
we read it in from the client side, again,
292:51 - we'll have to decode that information. It's
kind of annoying, but I mean, it's a security
292:55 - thing, right? So now we're just going to accept,
I guess, what, what kind of error would even
293:00 - be, I don't even know if there's gonna be
any errors. If we run into anything, let's
293:03 - just break just to make sure that we're not
you know, getting in that infinite loop, or
293:07 - we're not gonna ruin the program by doing
that. Okay, so this is actually about it for
293:13 - our server. Let's see how much time We're
at 30 minutes. Okay, so now what we need to
293:17 - do is figure out what the server number is,
and then we can actually test it and see if
293:20 - this is working. So what
293:22 - we're gonna do now, is we're gonna find the
server number. Now, to do this, we're gonna
293:26 - be doing this over localhost. Okay, that means
that our, we're only gonna be able to connect
293:31 - over our local network, meaning that like
anything on our Wi Fi network, that can see
293:37 - each other, that'll work fine. But as soon
as you're outside that network, it won't work.
293:42 - So we're going to be using what's known as
local IP addresses. So to find the local IP
293:46 - address of the machine you're currently on,
you're going to go to command prompt in the
293:51 - bottom left. And then we're just going to
type IP config. Okay. Now, some of you guys
293:55 - are probably freaking out, because you can
see my IP address right now, this is a local
294:00 - IP address. And that means that it is locally
assigned to my network, no one outside of
294:06 - my network can see this IP address or can
ping it or can DDoS it or anything like that.
294:10 - Okay. So it's perfectly fine if you guys see
this address, if other people know what this
294:13 - local addresses, okay, just as a note, so
we're going to do is we're going to take this
294:18 - ipv4 address, so just copy that. And we're
going to paste that inside of the string here.
294:23 - Okay. So 10 to 11.2 52. Seven is mine. Now,
yours likely is like 192 dot 168 dot something,
294:31 - okay. But since I'm on like a massive network,
usually they use 10 dot 10, like as the default
294:36 - gateway, which is what they're using. So my
IP address starts with the 10. Yours likely
294:40 - starts with 192 dot 168 dot one, or dot like
five or something like that, and then the
294:46 - rest of it, okay, so that's the address we're
going to use. And this is going to be our
294:50 - server address. So whatever machine that you're
going to be running the server script on,
294:55 - that's the address you want. So say you want
to run this server on your laptop and you
294:58 - want to run clients on Like your PC, and your
Mac or something like that, then you want
295:03 - to make sure you get the IP address from your
laptop, and you're putting it in that script.
295:08 - Okay, and we'll talk about more of this in
the next video when we actually connect to
295:11 - it. Okay, so now that we've done this, I probably
made a mistake. But let's actually just create
295:15 - a configuration quickly for server and run
this and just see if we're getting any errors
295:20 - as of now. But now, it is worth noting that
we're not gonna build to connect anything
295:24 - yet. So there's not really going to be much
we can see or really do. But for now, let's
295:30 - just test this out. So let's have server let's
run this. And you can see waiting for connection
295:35 - server started. So that's actually good. If
you're getting this string of text, everything
295:40 - is currently working. In the next video, we'll
probably have to debug a little bit once we
295:44 - start connecting to this. But for now, that
is the main server script. Now briefly, just
295:49 - talk about before I end this video, how it's
going to work in terms of running the server
295:53 - script and running the client script. The
server script always has to be running, okay,
295:57 - so whatever you're trying to connect, you
have to have first run the server script.
296:01 - And then you can run multiple client scripts
from wherever on the network you want. Now,
296:06 - the server script has to be running on the
machine that the IP addresses like this little
296:10 - string here, okay has to be running on that
machine. And you can run a client script on
296:17 - the same machine that the server scripts running,
and you can run multiple client scripts on
296:21 - the same machine. So like, for example, what
I'm going to do To test this in the next video
296:24 - is I'm going to run the server and then I'm
going to run two clients on this machine.
296:29 - And we'll see that it like is moving back
and forth for them. So what we're gonna be
296:35 - doing in this video is we're gonna be coding
the kind of client side of this. So connecting
296:40 - to the server, I know, we already coded a
client, but we're gonna code like the network
296:45 - aspect of the client so that it can connect
to the server, it's not as much code it's
296:49 - a bit more straightforward. And then we're
just going to test out sending very basic
296:53 - information to the server, and hopefully getting
some back, see if that's working. Okay, and
296:58 - then in the next video, we're going to be
connecting this. So like the little user interface
297:02 - we created with moving that block around in
the first video, we're gonna be connecting
297:06 - that. So that we can have multiple clients
running and we can see like different blocks
297:10 - moving on each screen. Okay, so that will
involve a bit more work. Hopefully, by video
297:15 - five, we'll have like a fully working kind
of game that's working over the network. Okay,
297:19 - that's the goal. So with this video, I just
want to start by saying on the server class
297:23 - here, or sorry, server file, I did actually
forget two lines of code in the last video.
297:28 - So after this, except break in threaded client,
just need to add this print last connection.
297:33 - And then connection close. All this is doing
is once we break out of this threaded client,
297:38 - we're just letting the we're just going to
print this to the console so we can see what
297:41 - it looks like. And then we're going to close
that connection, so that we can possibly reopen
297:46 - it in the future. Okay. really straightforward.
That's all you got to add. So just make sure
297:49 - you add that before moving on. Okay, so next,
what we're gonna do is we're gonna create
297:53 - a new file, and I'm going to call this network,
okay, now you don't have to put what I'm going
297:58 - to in the new file, it's just a lot easier.
So that's why I'm going to do that. So let's
298:02 - do network. And in here, we're going to import
socket.
298:04 - Now what I'm going to do is I'm just going
to code a class that is going to be responsible
298:07 - for connecting to our server. And this just
makes it like so I can reuse this class in
298:11 - the future. And you guys could reuse this
class in the future. It's just a bit cleaner
298:16 - and nicer. In this way. I like to do things.
So when I say class network, again, call us
298:21 - whatever you want. And in here, we're just
going to send an initialization function will
298:25 - take actually as network, do we need anything
in network? No, I think we'll just leave like
298:30 - that. So we're gonna say self dot clients
equals socket, dot socket. It's gonna be the
298:36 - exact same arguments as last time. So say
socket dot i f. NET Anka, is that what it
298:41 - is if underscore net, AF underscore eye net?
Okay, and then we'll do socket dot sock stream
298:50 - like that. Okay, now we're going to define
the server and the port again. So self dot
298:54 - server equals self dot port equals 5555. Now
for the server, this again, this number has
299:02 - to be the same as the one you used in the
server. What do you call it? The server file
299:07 - here. So no matter what, like no matter where
you actually are, like, what client you're
299:13 - using, this number is gonna stay the same,
because this is the server you're connecting
299:16 - to. It's not the clients address. We don't
actually have to define the client address
299:20 - anywhere. It'll automatically get that for
us. Okay, so what we're gonna do now, we have
299:26 - client server port, we need to do this self
dot addr equals and we're gonna say, server
299:33 - so self dot server, and then self dot port
here. Okay? And then self dot. What do you
299:43 - call it? self.id is going to be equal to self
dot Connect. Okay? Now, you guys, actually
299:51 - let's just do self connects right now and
we'll talk about why I was going to add this
299:54 - ID later. Once we add that functionality,
the server, okay. Essentially, I wanted to
299:59 - have an ID There was returned here, or like
it was stored in this network object, just
300:03 - because we are going to have to like be sending
an ID to each of our clients. So they know
300:08 - if they're like player one or player two,
but we'll do that later. Because we don't
300:11 - really, we can't really do that yet. Okay,
so we've called this Connect method. So we
300:15 - need to write that now. So let's say define
Connect. OK, and in here, I believe we should
300:21 - probably be given Actually, it's probably
fine. Just yourself, right? Now, what we can
300:25 - do is use your self dot clients dot Connect,
okay, and then here, we do self dot addr.
300:30 - Now we're going to throw this in a try and
accept just in case you know, this isn't working.
300:36 - So say try, say, accept, and renew socket,
air,
300:40 - um,
300:41 - let's say accept. And we'll just pass right
there. Okay, just in case this doesn't work.
300:48 - So we'll try this, we'll try to connect, accept
pass. Now, once we actually connect, what
300:54 - we're gonna do is we're going to return, I'm
just looking at the screen right now self
300:58 - dot client dot receive. And then we'll do
2048
301:02 - dot decode.
301:05 - Guess what this is going to do? I'll talk
about this because it might be a little bit
301:08 - confusing is when we connect, we want to actually
send some kind of information immediately
301:14 - back to the object that connected to us. So
like, for example, it's going to give me to
301:18 - close that. Let's go into server here. And
you can see, when we initially Connect, we're
301:25 - not sending any information until we receive
something, now, that's fine. But when we connect,
301:31 - we should really send some kind of like validation
token, or like, Id back to our network object
301:38 - or back to our client. So what I'm going to
do in here, let's say con, dot send, okay?
301:44 - And then in here, what we're going to type
is, let's see, what should we really type
301:49 - here, um, str dot encode, then he was connected
like that. Okay? Just so we know that we did
301:58 - indeed, connect. So that means if we set this
equal to a value, so self dot, I don't know,
302:04 - let's say ID equals self dot Connect, what'll
happen is, when we connect, we'll return that
302:11 - string connected. So this will get connected.
And since it's in Kota, we need to decode
302:16 - it, obviously. So if we want to print actually
in here, self.id, it should say like, connected,
302:24 - okay, let's see if that works. Okay, so now
that we actually have that, um, let's see
302:30 - if we can connect to the server, and then
we'll deal with sending information from the
302:34 - client to the server, as opposed to just getting
it from the server. Okay. And that's a bit
302:38 - confusing, right now, I'm just trying to figure
out the best way to do this. So let's try
302:40 - this case. So we're gonna say n equals network,
I will just type this in the bottom of the
302:46 - script. We won't do this after we'll delete
this just for testing purposes. And then we're
302:51 - just going to say, actually, that's probably
all we need to do, because it'll just print
302:54 - our ID. Okay, so let's create a configuration
for network. So new configuration, type network
303:05 - and here and then select that path. And then
let's test if this is working. So remember
303:10 - what I said, when we're going to connect right
to our server, what we have to do is first
303:15 - run that server script. So let's run the server
script here. Waiting for connection server
303:19 - started. Okay, let's run this network script
now. invalid argument with supplied s dot
303:24 - listen to. Okay, so I had a quick look here,
I realized the mistake was I was actually
303:30 - running this server two times. So obviously,
that's not going to work for us. So we can
303:33 - put two back in this. Listen, I'm not sure
if you guys will see if I left that in the
303:38 - video or not. But let's go to network. And
we also need to change this to AF instead
303:43 - of if I don't know why I typed if I literally
said AF when I was typing it, but that's fine.
303:48 - And we have server, I'm actually running it
right now. So make sure you guys run that.
303:51 - And then those run now we can see if this
works. Okay, sweet. So I know it doesn't seem
303:56 - like much. But you can check here if we go
to server says connected to and then it gives
304:01 - us that address. And it's also printing out
some other thing that I honestly don't know
304:05 - what that means. And then saying disconnected
and lost connection. Sweet, that's actually
304:09 - really good. And that means that we're everything's
working. And you can also see that we have
304:14 - connected being printed here. slot means when
we connect to the server, we're actually getting
304:19 - the value that descending so we're getting
this connected, and we're printing it out,
304:25 - decoding and all fine. So that's really awesome.
So now the only next step is to actually send
304:29 - information to the server and keep like a
loop going like sending receiving, sending,
304:33 - receiving, sending, receiving. Now let's actually
just test. If I run this again, you can see
304:39 - again, obviously it's working again. So this
is the server just continually is running,
304:44 - I don't actually have to stop this unless
you want to make modifications to it. So let's
304:47 - just keep that running for now. And let's
add something to our network class. So in
304:53 - our network class, we're going to define a
method that is going to be sent. Now this
304:56 - method is gonna be very useful later on, because
it's gonna save us a lot of time. So in sandbridge,
305:01 - can take a string, which is going to be data,
okay. And all we're gonna do here is we're
305:06 - gonna try to self dot client dot send. And
we'll say data, str actually dot ENCODE data.
305:17 - And then we're gonna get a reply from that
service, we're going to say return. So exact
305:20 - same thing that we're doing here, self client
receive 20 48.2 code, and we'll accept. And
305:28 - I believe this is a socket, err, yet, it's
socket dot air as he and just print E. So
305:34 - if we get into some error where, you know,
either we're sending or we're receiving, it's
305:39 - not working, let's just print that arrow to
the screen. So we have a look at what that
305:42 - really means. So now let's do a test and try
to send information to the server and then
305:49 - get something back. Okay, now the information
that we're getting back should just be the
305:53 - same information because that's what we have
in server, we're just going to send exactly
305:57 - what we got right back,
305:59 - right. So it doesn't really make sense right
now to do that, but we'll talk about like,
306:03 - what we can, what valid information we can
send, how to send receive information in the
306:07 - next video when we connect up the client to
the thing, okay, so what we're gonna do is
306:12 - we're gonna say n dot send, and we'll print
n dot send, okay. And we'll print and send
306:19 - again, and let's just send like a few bits
of information and see if everything is indeed
306:23 - working. Okay, so n dot send. And then in
here, let's just type Hello. And we'll type
306:30 - working Ok, and see if this works. So we have
actually, we should have Yes, server is working,
306:36 - let's run our client. And you can see we get
connected, hello, working. And if we come
306:41 - here, it says, received Hello, sending Hello
received working, sending working. So that's
306:46 - awesome. That means our network class is working,
sending information receiving information
306:51 - is working, servers working. And now the only
thing that's left to do essentially, is to
306:57 - connect that up to this. So use this network
class in some meaningful way here, and then
307:03 - to actually store information on the server,
and then send that information to multiple
307:08 - clients, which we'll be doing in future videos,
what we're going to be doing is we're going
307:14 - to be hooking up our graphical client to our
server, so we can send information back and
307:19 - forth. And ideally, at the end of this video,
what we're gonna have is we're gonna have
307:24 - two rectangles on each client. So I have like
two clients running. And when you move the
307:28 - rectangle on one client, it moves on the other,
and vice versa. Okay, so you guys will get
307:32 - the idea when we go through, but there's a
little bit of work we have to do. And we're
307:36 - gonna be modifying a few things within a lot
of the files you've already created. So just
307:39 - make sure you guys are paying attention. And
again, if anything is going wrong, feel free
307:43 - to download all the code off of tech with
Tim dotnet. It'll be available there. And
307:47 - it'll be exactly the same code that I'm writing
right now. Okay. So first thing we're going
307:51 - to do is in this network class, we're just
going to delete a few things. So this testing
307:56 - stuff, we don't need any more, this print
statement for the self, that ID, we don't
307:59 - need that.
308:00 - And we're actually going to change this self.id
to be self dot pause, okay, and you guys will
308:05 - see why we're doing that in a second. And
we're gonna add one quick method in here.
308:10 - And then we're just gonna say define, get
pause, okay. And what we're gonna do here
308:13 - is just return self dot pause. Alright, and
again, we'll, you'll see why we're doing that.
308:18 - But I don't want to have to come back to this
network class. So we'll do that right now.
308:22 - Okay, so from inside our client, now, what
we're going to do is we're going to import
308:26 - this network class, because we're going to
use it in here. So we're gonna say from network,
308:31 - import network. And then in our main function
down here, what we're going to do is actually
308:39 - above player, we're going to say, and equals
network, okay, like that. And then what we're
308:46 - gonna do is we're gonna say, start, pause,
equals and dot get pause. So essentially,
308:53 - why I'm doing this is because when we first
connect to our server, what I want to happen
308:58 - is I want it to return to each of our clients,
the starting position of their character,
309:03 - right or of their cube, okay, because it's
going to depend where they're starting based
309:07 - on if they're player one, or if they're player
two. So then on the client side, what we're
309:11 - going to do is when we initially connect to
the server, which is what we're doing, when
309:14 - we create this network object, we're connecting
to the server, we're going to get that starting
309:19 - position. And then for creating our own player,
we're going to use that starting position
309:23 - to determine like where we're starting. So
the position is going to come in as a tupple.
309:27 - Alright, and we'll be coding all this on the
server side in a second, but it's easier just
309:30 - to go through each file, rather than going
back and forth. It's going to come through
309:34 - as a tupple. That looks something like this.
So it'll be like 50 100. Okay. So what we're
309:38 - going to do is you're going to read this tupple.
And because it's actually going to come in
309:42 - as a string, like, you'll see how it comes
in. We're going to get the two aspects of
309:46 - it like the x value and the y value. And then
we're going to use that inside of this player
309:51 - initialization to like set the initial position.
So that reminds me what we're going to be
309:57 - doing when we're sending information to the
server is we're Send it using string data,
310:01 - right. And that's what we're doing in the
last video is we were sending everything with
310:04 - strings we were sending, like Hello, and then
we were decoding and encoding it. Now, this
310:09 - is not the only way we can send information,
we can actually send information with objects.
310:13 - And I'm going to show you the advantage of
doing that in the next video. But for now,
310:17 - we're just going to send strings. So since
we're going to be sending strings, the strings
310:21 - that I want to send our positions, okay, I
want to for each client, send the current
310:26 - clients position to the server, the server
is going to get that position updated on the
310:31 - server side, and then send the other clients
position back to the client, you guys will
310:37 - see how it works in a second. Actually, let's
see if I can do a quick drawing to illustrate
310:41 - this because I'll make things a bit easier.
Okay, let's, I don't know why I had this.
310:45 - Let's delete that. Okay, so let's do a quick
drawing. So we're gonna have, we're gonna
310:49 - have client one, and excusing some drawing
this with the mouse and client two, okay,
310:53 - so it's gonna be one, and this is going to
be too, alright, this will do it as a red
310:57 - box is going to be our server. And on the
server, what we're going to do is we're going
311:01 - to store positions, so psych one has positioned
like, one, two, okay, sorry, this is hard
311:07 - with the most guys. And then client two will
have position like three, and one, OK. So
311:13 - it can store these positions. So what's going
to happen is when we initially Connect, client
311:18 - one is going to go to the server, it's going
to connect to it, and then it's going to be
311:21 - sent back the starting position for the client.
Okay, so it's going to be set. Okay, so your
311:26 - client one, so that means you're going to
start at position one to client two, it's
311:30 - going to connect, it's going to say, okay,
we're client two, so I need to send client
311:34 - twos position. So let's send that back. All
right. Now, let's say we've already connected
311:38 - client ones, their clients twos there, and
we've set their starting positions, what we're
311:41 - going to do next is now we're going to continually
call to the client and update the position.
311:47 - So what we're going to do is say, let's say
we're working with client one, okay? What
311:51 - it's going to do is it's going to send its
position to the server. So it's going to say,
311:55 - let's just say pause, okay, it's sending its
current position, let's say that position
311:59 - is like four, five, so this is really hard
with the mouse, get four or five, what's gonna
312:05 - happen here is we're gonna say, okay, so you're
updating your position. So then it's going
312:09 - to go in here, it's going to say, okay, client,
one will update your position to be four,
312:14 - five, like that, okay. And then what it's
going to do is, instead of sending back the
312:18 - same position, because we already know what
the position is, it's going to send back the
312:21 - position of client two. So it's going to send
three one. And then on here, we can draw that
312:27 - client so that it looks like it's moving,
right? So we're getting we're sending our
312:31 - information, and then in return receiving
the other clients information. Now the same
312:35 - thing works here with client two. So client
twos connects, right, and it's sending information,
312:39 - it's gonna send its position. Let's say it
sends the position one, three, okay, that's
312:44 - its updated position. So this is going to
change to be one and three. And then what's
312:49 - going to happen is, it's going to say, Okay,
well, we don't need clients twos position,
312:52 - we need clients one. So what's client one
position? Well, that is four, five, so let's
312:58 - send four or five, over to client two. And
then on client two, we can draw four, or five.
313:02 - So you'll see those simultaneously be moving.
I hope that makes sense. I just want to draw
313:07 - it out for you. So you guys know what I'm
about to do in this video.
313:10 - Okay,
313:11 - perfect. Now, the only thing is we need to
send these positions as strings. So we're
313:16 - actually going to have to implement two helper
methods so that we can convert those positions
313:20 - which are going to be topos Industries. And
then we can also read the string into a tupple.
313:25 - So what we're going to do is we're gonna say
define, and I'd want to remember what I call
313:29 - this one, we'll say this one is read underscore
position, which means we're going to take
313:32 - a string value, and we're just going to read
the string and we'll say str equals str dot
313:37 - split. And we'll split it at a comma. Okay,
and you guys will see how this works in a
313:42 - second. And then we're going to do is we're
simply going to return the end of string zero.
313:48 - So str, zero, okay, comma, int, str. One.
So what we're going to do is we're going to
313:56 - take a string that looks something like this
would be 45, comma 67. Okay, in in string
314:02 - value, 4567, we're going to split it, which
means we're going to get a list that has the
314:06 - string 45, and the string 67. And then we're
just going to convert those two ends, and
314:12 - return them as a tupple. So now we get that
converted something that looks like this,
314:16 - which is useful information that we can actually
use. Okay, so that's what read pause is gonna
314:20 - do, but we need to make one more which is
going to convert that position into a string.
314:24 - So we're gonna say, Make underscore position.
And in here, what we're gonna have is we're
314:30 - going to take a tupple. So the shape top standard
for tupple. And what we'll do here is we'll
314:34 - say, let's see here, return, tuck, actually
str of top zero. And then we're going to add
314:47 - that comma in so sorry, I'm butchering my
typing right now, comma, plus STr of top one.
314:55 - And I hope that makes sense how we do that.
So that's returning the string value. So we're
314:59 - reading pause And making pawns. And that's
all we need to do for those helper functions.
315:04 - Okay, so that means though, that when we get
the position initially from our server, it's
315:09 - going to come in in that string value, right,
it's going to look like 4567. So we need to
315:13 - convert that. So what we'll do is we'll say,
read pause, we'll just put that around and
315:19 - get pods because get returned us that string
position. So we'll read it in. And now what
315:23 - we're going to do is for our player, we're
going to say start, pause, zero, and start
315:30 - pause, one, okay. And what this is going to
do is just set it to the initial start position,
315:35 - we're going to code all the server stuff after
it will start making a lot more sense. Okay.
315:38 - Now, what we also need to do is we need to
create a second player, because we're gonna
315:43 - have to draw the first player and the second
player on the screen, right, so we're gonna
315:47 - say p two equals, and we're literally just
going to copy this, except for start position,
315:53 - we'll just gonna put it as 00 for right now.
And we'll update that in a second. Okay. So
315:57 - we have P, P, two M. And for now, that's what
we'll do, actually, let's we can continue
316:05 - working in here. So that we don't have to
do anything else in here, after we'll just
316:07 - code the server side. So what we'll do now
is we're going to send our current position
316:12 - to the server, right, that's like the algorithm
we've developed, essentially, we are, when
316:15 - we connect, we're going to get the starting
position, we're going to set that starting
316:19 - position. And then every time after that,
so like every time the frame updates, we're
316:23 - going to send our position and then get the
other person's position. So we're going to
316:27 - say is, we're going to say, P to pause is
going to be equal to n dot send, okay? And
316:34 - we're going to send make position of, and
then we're gonna have to do in here is, it's
316:38 - a little sketchy, but we're gonna do p dot
x, p dot y. Now, right, because that's the
316:46 - position of our player, the x and y coordinate,
we're putting it in tabular form, we're sending
316:50 - it to the function make position, which is
going to turn it into a string, and then we're
316:52 - sending it to the server, right? Okay, awesome.
So I think that makes sense. And then we're
316:57 - going to do simply is for p two, we're going
to update is its position. So we'll say p
317:03 - two dot x is going to be equal to, actually,
and to not sad, but we'll we're gonna have
317:08 - to put around to your story is make pause,
read pause, because right, it's coming in
317:12 - as a string, so we need to convert this into
our actual position. So P to pause is going
317:17 - to be P to position zero, and then P two dot
y is going to be equal to P two, P to pause
317:24 - one. Okay, now the only thing that's left
to do here is what he called draw p two and
317:31 - update p twos rectangle. So what we're going
to do now is in the redraw window down here
317:35 - and put p two, we're going to go to redraw
window, we're going to say player two here.
317:40 - And then we're going to do
317:41 - player two dot
317:43 - draw window, because again, it's going to
be a player object, so that'll be fine. And
317:48 - then last thing to do is just update the rectangle.
So what I'm going to do is I'm gonna say p
317:52 - two dot update, and we're going to go to player
object now we're just going to add this one
317:56 - function, that is define, update. And then,
so you see, I just made the x self dot rect
318:04 - equals x, y, width, height. And then in here,
I'm just gonna say self
318:07 - dot
318:09 - updates, like this. Okay. So I know this might
be getting a bit confusing, but we're almost
318:14 - finished. Let's go do the server side. And
then we'll recap through everything, what
318:17 - we've done, explain things, I kind of have
to get this content out. Okay, so define update.
318:22 - So what we're doing again, here is before,
we just had this line of code here, so we're
318:26 - just replacing that with an update method.
That's pretty straightforward. I hope that
318:29 - makes sense to you guys. And that's just again,
so when we change the x, and we change the
318:33 - y value of p to directly, then we are updating
the rectangles. So when we draw it to the
318:37 - screen, it's in the correct position. Okay,
so I believe that's all I have to do for the
318:42 - client side. So now it's time to go to the
server side and server sides pretty straightforward.
318:47 - Now what the server needs to keep track of
the positions, right, it needs to hold player
318:51 - ones position and players to position consistently.
So we can decide if we want to store that,
318:56 - let's say like on a hard drive, or if we want
to store that in memory. Now in our case,
319:00 - it's not a lot of information. So we're just
going to store it in the memory of the server,
319:04 - right. So what we'll do for that is we're
going to create a list. And we're going to
319:07 - say pause equals and just a blank list. And
this list is going to hold the positions of
319:12 - our players. Now actually, that reminds me,
we're going to put two titles in here. And
319:16 - these are going to represent sort of the starting
positions of our players. So we'll start with
319:20 - 00. And like 100 100, so player one will start
at 00. Player Two will start at 100 100. Okay,
319:27 - and that's all we're going to do for that
little list there. And then what we're going
319:30 - to do down here, while this while loop is
we're going to keep track of how many players
319:35 - have connected. In our case, we only want
to to connect right. And then we need to keep
319:40 - track of well those players, so we're going
to say there is a current player equals zero.
319:46 - Now, this is because when we connect, we're
going to add one to this so that when we go
319:51 - back into this function, it'll be you guys
will see how it works. But essentially, every
319:56 - time we create a new connection, so every
time this, we accept a new connection, we're
320:00 - going to add one to our current player. So
we'll actually do it at the bottom of the
320:03 - while loop, we'll say current player plus
equals one. This is just to keep track of
320:07 - which player we're using, so that we know
what position to update what position to send
320:12 - to that player based on the connection, right?
Okay, so keep track of current player. And
320:17 - now what we're going to do is when we start
this new thread, so this threaded client,
320:21 - we're also going to pass another argument,
which is going to be the current player. So
320:26 - instead of just passing connection, we're
also going to pass player in here, okay? Current
320:31 - player like that, okay? Because that's gonna
be important information to know. Alright,
320:37 - so we're actually almost finished, we just
got to update a few things. So let's actually
320:40 - grab these two methods from our client class
or client file, and throw them onto server
320:48 - here. So we're just going to put them right
above position, because we're going to need
320:51 - to use them read pause and make pause. So
now when we initially connect to our player,
320:57 - right, this is what happens when we initially
Connect, the first thing that sent is this
321:01 - encoded message that is connected. Now in
our case, what we want to send is we want
321:06 - to send the starting position. So how do we
do that? Well, we know what player we are,
321:11 - we're either player zero, or either player
one, right? Because we only have two players.
321:15 - When we start with player zero after player
zero connects, then we do player one, right?
321:20 - So what we'll do is we're going to send pause,
player. Now, that won't work, because it's
321:27 - just a tupple, right, we need to first convert
that to a string, and then encode that string
321:32 - and send it. So let's actually go back here,
I want to keep the string dot encode. So string
321:36 - dot encode, and we'll say make underscore,
oh, a pause. And then we'll just put pause
321:43 - player in here. And what that'll do is it'll
convert it into a string for us, and then
321:47 - it will send that to the player for us, right.
And then they'll read that string in Kibera
321:52 - to position and update the position accordingly.
Okay, making sense. I hope so. Okay, so that's
321:57 - how that works for player. Now, the only thing
we need to change now is what information
322:03 - we are sending, every time this loop is running,
right, every time we receive something from
322:08 - the player, we want to send back the other
players position. So to do that, what we're
322:12 - going to do is we're going to say conduct
receive D code. So we'll get rid of this for
322:17 - now. And then we're going to say is we're
going to turn this data into, like readable
322:23 - a readable tupple, right. So to do that, we
are going to use the read position method
322:29 - that we've already created or function. So
say read pause, conduct receive. And we'll
322:34 - turn that into from that string like this
right? or whatever it was, like 4567, we'll
322:40 - turn that into something that looks like this.
So that we can actually use it. Okay, so now
322:44 - that we have that, it's turned into that,
what we're gonna do is we're going to update
322:48 - our current players position. So we're gonna
say pause,
322:51 - player equals data, right? Because this is
the position they sent to us. So let's update
322:56 - it on the server. So yeah, so it's updated
information. Okay, sweet. So we've done that.
323:01 - Now, all that's left to do is send the other
players position back to our client. So to
323:07 - do that, what we can do is simply say, reply,
equals, and we're just going to say, pause,
323:14 - or actually, let's not do it up here. Let's
do it down here. Okay, we're gonna say, if
323:21 - player equals equals one, so if we're player
one, we're gonna send player zero position,
323:25 - right? So as a reply, equals, and then pause,
player or not, pause, not not player zero,
323:34 - sorry. And then else we're gonna send. So
say reply equals pause one. Okay? So if we're
323:41 - player one, we send player zero position.
If we're players here, we send players one
323:44 - position, right, like I was talking about
with that little algorithm we're going to
323:47 - use, okay, and then instead of saying received,
and sending, actually, yeah, we can say received
323:53 - reply sending reply, or real estate received
data sending reply, that should work fine.
323:58 - Okay. Now, what we'll do is we're going to
send all the reply, but the thing is our reply,
324:04 - we need to first convert into a string. So
to do that, we're going to say make underscore,
324:08 - pause,
324:09 - write that
324:10 - function we've already created. And then that
should actually be about it. Now, I'm probably
324:16 - made a mistake or two here, but let's just
test this out and see if everything's working.
324:19 - So let's start by running the server. And
then let's run to clients and see if we can
324:24 - connect if there's any errors. Okay, so we've
connected with client one, let's run client
324:30 - two. And let's see what happens. So I'm on
client one, right now, you can see that when
324:35 - I move my green square, it moves on the other
client,
324:38 - kids go to the other one.
324:39 - And when you look at this, when I move it
on here, it moves on the other client. So
324:43 - we have successfully set up and connected
our two clients together. Now the only thing
324:48 - I want to change quickly, it's just the color
of these so that we know who is who like which
324:52 - square am I. So to do this, we're just simply
going to go will actually close the server
324:57 - class otherwise you're gonna run into an issue
or sir instance, whatever it is, we would
325:02 - have clients. And instead of having the same
color here, we're just gonna change this to
325:05 - be 255 for player two. And now I want to show
you what happens, because some of you are
325:10 - probably gonna be confused with what's about
to happen here. But it's kind of interesting.
325:13 - So let's run server. Let's run client one,
let's run client two. Now notice that these
325:19 - colors are inverted. Now Can anyone think
of why that might be? So green, right is going
325:25 - to be your current player. So right now I'm
on here, I'm on this where my mouse is, and
325:30 - I'm moving the green square that's near the
middle of the screen, okay. But notice on
325:34 - the other screen, it's moving the Red Square.
That's because on your client, it's unique
325:39 - to you. So on your client, you are green,
and red is the other person. Meanwhile, if
325:44 - I go to this client, and I start moving, see
green is me. And red is the other guy, right,
325:49 - and he's not currently moving. Now, if I wanted
to move these at the same time, I would just
325:53 - have to be running these on different computers,
or I would have to change like the arrow keys
325:57 - to move them. And that's just because obviously,
right, like, if I'm pressing the arrow keys
326:01 - on here, it's not going to work on this client.
But if I were to load up my laptop and try
326:04 - doing it on there, this would work fine as
well. There's a quite a few issues that we
326:12 - may run into when we're doing this. So I've
set this up essentially, to be kind of like
326:17 - an example program or like an example problem.
To give you guys an idea of the way we go
326:22 - about doing things in terms of server and
network. But it's really not ideal, the way
326:27 - that we've coded things so far. Now, I did
plan this for to do what we're about to do.
326:32 - But essentially, I'm going to redo what we've
just done in a much more elegant and nicer
326:38 - way that's going to allow for better scalability
of this program. Okay. So what we're going
326:44 - to do is I'm going to redo it here, I'm going
to show you how we can actually send physical,
326:48 - not physical, but like send objects to the
server and from the server back to the client
326:53 - rather than just string data. And then in
the next videos, we're actually going to scrap
326:58 - all this code that we've written, and we're
going to start fresh and code, like a networking
327:03 - game, there's going to be a lot more complex
than just a few squares moving around the
327:06 - screen. So that's my plan for this series,
let me know what you guys think of that. I
327:09 - know, it might be a little bit frustrating
to get rid of this code. But now that we understand
327:12 - a lot of this works, it's gonna be really
fast to rewrite it in a much more elegant
327:17 - way. So what I need to first start by doing
is just taking this player class, okay, and
327:23 - I'm just gonna copy it into its own file.
So really straightforward, I'm just gonna
327:26 - go to a new Python file, I'm going to call
this player with lowercase. And then just
327:31 - copy that player class in there. And just
import pi game up here. Okay, import pi game.
327:38 - Now I'm just going to go back into client,
we can delete this player class. Now, what
327:42 - I'm going to do really basically is just from
player import player like that, okay. And
327:49 - that's the first step. Now, remember, I said,
we're going to send objects. So that actually
327:55 - means that we're not going to need this read,
pause and make pause thing. And it's kind
327:58 - of annoying how we've had to, we'll take that
Tableau object, decompose it, turn it into
328:04 - integers, and then change Object Properties.
And then when we want to send something, we
328:08 - got to put it into a string, and we got to
send it in just a pain. And we don't want
328:11 - to have to do that, especially when we're
sending tons of different bits of information,
328:15 - not just that same positional data, right.
So we're actually going to delete this, I'm
328:19 - going to delete this client number, I don't
know why I have that there. And we're going
328:23 - to start just making some modifications in
terms of sending data and receiving data.
328:27 - So we'll start on the client side, and then
we'll go over the network, the server side
328:31 - and fix some of that. So wherever we see like
read pause and make pause, we can just get
328:35 - rid of that for right now. We don't actually
need any of that, we're not going to need
328:39 - this P two dot x stuff, we don't need p two
dot update, we'll get rid of all this for
328:45 - right now. You know, actually, let's get rid
of star position. Let's get rid of P and let's
328:50 - get rid of P two, and we're going to recode
all this. Okay.
328:53 - So, actually, um, p2p, I can stay there, Peter
move is fun. Okay, so we got rid of all that.
329:00 - And you can see we've just cleaned up this
file, but and we'll start working with some
329:02 - more stuff in a second. Now, what I want to
do actually is go to this network file that
329:07 - we have. And we're gonna start making some
modifications in here as well. So what we're
329:11 - going to be doing is we're gonna be sending
objects, so that means we're going to send
329:14 - like an instance of the player class. And
that's actually what we're gonna be sending
329:18 - instance of a player class to our server,
as opposed to sending like string data and
329:23 - then updating the object on or then updating
the string data on the server and then sending
329:28 - it back and then updating the object, it's
just a lot of work, it's a lot easier just
329:31 - to send the actual object. So we can do that
using something called pickle, okay. Now,
329:36 - it's a weird module name, but it comes default
with Python. And this allows us to do something
329:41 - that's called serialized objects. And that
just means we turn it into byte information,
329:45 - which is like all the zeros and ones, send
it over the, what do you call it, send it
329:50 - over the network, and then we can decompose
that, turn it back into an object and use
329:55 - it and it's really easy to do that. So what
we're gonna do here is we're going to modify
329:59 - a few things. In this in our network class,
so first thing, instead of having self dot
330:04 - pause, we're gonna say self dot P, okay? Let's
give equal to self dot Connect. And so saying
330:10 - get position will this do get P, and then
we'll return self dot P, okay. And that's
330:15 - all we need to modify for that. But now in
the connect in the Send, we're going to change
330:20 - a few things as well. So since we're going
to be getting object data, what we have to
330:26 - do in the Connect is we have to decompose
that object data. So to do that you do pickle
330:31 - dot loves,
330:32 - okay? Now what this stands for is it stands
for load byte data. Okay. And we'll we'll
330:37 - talk more about this as we keep going through,
but that's essentially what it means. And
330:41 - same thing here in send, instead of encoding
this data, what we're going to do, and I guess
330:46 - decoding as well, is we're going to dump it
into a pickle object and unsend it. So to
330:53 - do that, we're going to save pickle, pickle,
yep, dot, dot dumps, like that. And we'll
331:00 - just put data in there. Okay. And then when
we receive, we'll do the same thing as before,
331:05 - we'll say pickle dot loads, and that will
load that in. So now essentially, what we're
331:12 - doing is we're going to be receiving an object,
decomposing that object, getting the actual
331:17 - object, not the bytes form of it, and then
we're sending it, we're going to first like,
331:22 - what do you call it, encrypt it, like send
it into that byte information, and then on
331:26 - the server side will decompose that as well.
Okay, so we'll, we'll go through that. But
331:29 - that's all we need for the network side. So
now let's go to server and start making some
331:33 - modifications. So same thing here, we no longer
need this read, pause and make pause functions,
331:38 - we're not going to be using those. And we
don't need this pause list, either, we're
331:41 - going to change this actually to be players.
And it's going to be equal to two new players.
331:48 - So notice that we're going to actually store
the player object on the server, as opposed
331:54 - to on the client side. And this is not only
like safer, because it means that the player
331:59 - technically can't really mess with the player
objects, they can only like, do commands to
332:03 - update them. But it's also just like, it's
gonna be a lot easier. And you guys will see
332:07 - how it works. We're gonna say player, and
we'll do another instance of player. And in
332:11 - here, what we're gonna do is we're just going
to create two new players. So you say 00 5050,
332:17 - and we'll give it a color. In this case, the
first color will be red. So we'll say, red,
332:21 - green, blue, like that. And for the other
player, we'll start them at 100 100, like
332:25 - before will be 5050. And then we'll make his
color blue. Why not do that? Okay. So now
332:33 - you notice that we're getting an error for
player here, just because we forgot to import
332:37 - it just say from player, import player like
that. And that's why I made this new file,
332:44 - by the way, just so that we'd be able to see
it from the server side and the client side
332:47 - as well. And then wherever we're doing this,
like send encoding stuff, we're going to change
332:52 - this. So let's do that. Now, actually. So
instead of conduct send, instead of encoding
332:57 - some string information, we're just going
to send the player object. So what we'll do
333:01 - is we'll say, players, like this, and then
player, right, so exact same kind of concept
333:10 - as before, in that we're going to send the
initial like starting position of the player,
333:15 - or like the, but in this case, we're just
setting the initial player object, which means
333:19 - any information that's stored in that player
will be given to the client as opposed to
333:23 - just the position. Okay. So next, what we'll
do is instead of saying data equals read,
333:28 - pause and decoding, we're going to get rid
of this dot decode and we're going to put
333:34 - pickle dot loads, okay? And actually, when
I'm sending this player object, my bad here,
333:41 - guys, we got to do pickle. dot dumps, okay?
And then we're gonna have to import pickle
333:48 - up here. So import, pickle, alright, sweet.
So pickle that loads pickle dot dumps, and
333:54 - then obviously, instead of pause, player equals
data, we're gonna say,
333:58 - player,
333:59 - players,
334:00 - player equals data. And again, same concept
as before, what's gonna happen is the, what
334:05 - he called the client is going to send us a
player object, we're going to replace the
334:10 - existing player object with that new player
object. And then we're going to send back
334:14 - the other player objects like the other clients.
Okay. So now what we're going to do is just
334:19 - change these pause to be player or players
like that. Okay? Same thing here, players.
334:28 - And then when we send it back, what we'll
do is we'll just turn it into a object, right?
334:34 - So we'll just do that pickle dot dumps and
send it back. So say,
334:38 - pickle dot
334:39 - dumps, reply, like that.
334:41 - And that
334:42 - should actually be about it. So let's go back
or sorry, there's something we need to do
334:46 - in client. So now what we're going to do is
essentially, we've set up our network class
334:51 - so that we're going to be able to send that
object data. We've set up the server so we're
334:56 - gonna be able to receive that object data.
We're gonna Modify the objects we're storing
335:01 - in the list here, and then we're going to
send back the other ones to the other client.
335:05 - So in clients, all we have to do now is set
up player one and player two and then send
335:10 - that data. So really straightforward, it's
very similar to before, what we're going to
335:14 - do, first of all, just say p one, we're actually
just p i guess is equal to n dot get P. Okay?
335:21 - Because in the network class, remember, what
we're doing is when we initially Connect,
335:26 - so let's go back to server, we're just going
to send the initial player object, which is
335:30 - going to be whatever player it is. So zero
or one. So let's just say that this clients
335:34 - player object is going to be n duck MP. Okay?
And then we'll say, actually, I think that's
335:41 - all we have to do for Yeah, that is all we
have to do for that. Inside this while loop.
335:44 - Now, what we're going to do is every frame,
we're going to send this player object, which
335:49 - will be updating with P dot move. And we'll
just get the reply and say that that's p two.
335:54 - So we're going to do is I say p two equals.
And then in this case, we'll just say p.or,
336:00 - not n dot send, P. And that's all we have
to do. And notice here that we don't have
336:07 - to do with all this like make, what do you
call it, make pause, read, pause all that
336:12 - stuff. And I believe this should be working.
If I didn't make any mistakes, let's cross
336:16 - the fingers. And let's try this out, waiting
for connection. Let's go to client one, run
336:21 - that, okay, and client two, running that.
And now notice that these rectangles are the
336:27 - same color. And watch what happens if I move
this red one, see how it's red on the other
336:32 - screen as well. Now that already shows us
one of the advantages of doing it this way,
336:37 - is that we can store information like color
as well not just position. And if we wanted
336:41 - to store maybe like there was a text attribute
on each of these players, we could store that
336:45 - as well. But we wanted to store more information
in the player like a health or something like
336:49 - that, it'd be a lot easier to do that by just
sending the actual player object that has
336:54 - like an unlimited amount of attributes, rather
than just sending a little tupple that has
336:58 - like five, six, right, which is the position.
So the reason I went through the trouble of
337:02 - showing you the other way is to show you the
massive advantage of doing it this way. And
337:07 - just to give you kind of perspective, if you're
making something really simple, and you don't
337:10 - use any objects, that's you can do it with
string data. But I think this way is a lot
337:14 - easier. And we've just cleaned up quite a
bit of code, we've gotten rid of a bunch of
337:18 - functions. And moving forward, this is going
to make things a lot easier for us. I'm pretty
337:24 - much going to be gutting everything we already
did, we'll keep a little bit of it, but we're
337:28 - just going to really add to a bunch of that.
And just yeah, we're going to be gutting most
337:33 - of it. And we're actually gonna be working
to create online Rock paper scissors. Now
337:37 - I know this sounds like kind of a lame game,
but let me show you because it's actually
337:41 - pretty complex. And if you can understand
how to make this game, then you're going to
337:45 - be able to understand how to make any other
kind of online game because the principles
337:49 - are the same in terms of sending information
waiting for players to go. And there's a lot
337:53 - of different things that you might not think
about that we actually have to do to code
337:57 - something like online Rock Paper, scissors.
Okay, so let's This is client number one,
338:02 - I'm just running another pi game window, or
pi charm window with the server running on
338:06 - it. And you can see obviously, it's been oversized,
but it says waiting for player. Okay, so I'm
338:10 - going to launch another client. And then excuse
me, you can see when I launched that it loads
338:15 - both of them up into the game, and it says
your move opponents, your move opponents,
338:19 - and currently it's waiting. So I believe this
one's player two, and this one's player one.
338:23 - So if I make a move here on, let's say rock,
it'll lock in my move and says your move is
338:28 - rock. And then over here it says, obviously
the opponent's move is locked in because it's
338:34 - like looking for this guy's move. And now
if he makes a move, like let's say scissors,
338:38 - then it says you when you last, and then it
just resets and you can keep playing games.
338:43 - Now I'm also going to be adding more to this,
this is just like the beta version, I'm going
338:46 - to have wins, ties and losses, keeping track
and top hand corner. And when you load in,
338:51 - you're going to be brought to a menu screen,
which will allow you to like start a new game
338:55 - or to leave or we'll we'll add that later
as we go. But this is the main functioning
339:00 - game. And you can see obviously, it's working
well tie game. And it restarts. This also
339:05 - allows for unlimited amount of clients to
play. So for example, if I launch another
339:09 - two windows, you can see these guys now have
their own game going. It's kind of difficult,
339:13 - because I can't really get four on the screen.
But anyways, if I go like Scissors, paper
339:19 - that works independently of these games, and
these games can kind of play at their own
339:22 - time, which is really interesting and really
cool. And if you disconnect one of them, it
339:27 - automatically disconnects the pair. And that's
just because obviously you can't play against
339:32 - no one right? So yeah.
339:34 - Okay, sweet. So that's that. Let's start getting
into the code. Okay, so first thing we're
339:39 - going to do is we're actually going to code
a game class, okay? And this is just going
339:44 - to be responsible for holding all the information
for our game that we need. So for example,
339:47 - did player one go yet to player to go yet?
What move did player one make one move to
339:52 - player to make are both of them connected
to the server information like that, and you
339:56 - guys will see how much information we actually
need. It's also going to or things like keeping
340:00 - track of who won or who lost, how many times
how many wins. So that's what we're going
340:05 - to do with this game class. So let's start
making it. So class game, I'm doing this in
340:10 - its own file, by the way, just called game,
you are going to need the end zone file, because
340:15 - it's going to have to be accessed by both
the client and the server. Okay, we're going
340:18 - to define our initialization. In here, we're
going to take ID, I'm going to say self dot
340:24 - p one went equals false. self dot p two went
equals false. And obviously, you guys know
340:33 - what this is going to do, it's just going
to stand for if player one has made a move
340:36 - or not, if player two has made a move, we're
gonna do self dot ready, equals false. If
340:41 - I could type that correctly, we're also going
to add self.id. So self, that ID equals ID,
340:46 - and this is just going to stand for the current
games ID. So each game we create is going
340:50 - to have its own unique numeric ID so that
we can determine who is like what clients
340:55 - are a part of what game and whatnot, we're
gonna do self dot moves, equals, and then
341:00 - we'll just do none. And none in here, because
currently, the moves are none. But we'll just
341:05 - store two positions, so we can change that
will say self dot wins, equals and then 00.
341:11 - Obviously, this one is going to stand for
player one, this one's gonna stand for player
341:14 - two will say self dot ties equals zero. That's
all we need for the net. So the next one is
341:20 - going to say get underscore player underscore
move. Now what this is going to do is exactly
341:27 - what it says is just going to get I don't
know how I added that there, it just going
341:30 - to get the player move that we asked for.
So we're going to take p, which is going to
341:33 - be either zero or one. And we're going to
do simply return self dot moves, and P and
341:42 - just remind ourselves, we'll say that P is
in the range of zero, and one. So we're only
341:48 - going to take value zero or one and then we're
going to return a move, move here. And let's
341:54 - just remind ourselves that we have to pass
your one, obviously, zero is going to represent
341:58 - player one, and one is going to represent
player two. Okay, next one play. So this one's
342:03 - a bit more complicated, not crazy, we're gonna
take play, we're going to take a player, and
342:06 - we're gonna take a move. And what this is
going to do is it's simply going to update
342:11 - our moves list with that players move. Pretty
straightforward. So what we're going to do
342:16 - here is we're just going to say, if player
equals equals zero, then what we'll do is
342:22 - we'll say self dot moves, zero equals move.
Oh, actually, you know, let's do this. Sorry,
342:31 - I'm just looking at my other screen right
now we'll say self dot moves, player equals
342:36 - move. But now what we have to do is based
on the player, we have to update if p one
342:40 - went or P two went, Okay, so what we'll do
in here is, if it's player one, obviously,
342:44 - we'll do p one went equals true, get any to
self before that, and then we'll call it,
342:52 - we'll just do a little LS here, because it's
not player zero must be player one will say
342:56 - self.pg. Want, if I could spell once, equals
true. So that'll just keep track of if we've
343:02 - gone or not. Sweet. Next method, this one's
really easy, it's going to be called connected.
343:07 - And it's just going to tell us if the two
players are currently connected to the game.
343:13 - If they are, it will allow us to load in.
And that's how we can determine whether we
343:16 - should show waiting for player or not on the
screen. Right. So we'll say return self dot
343:22 - ready. And that's just going to tell us obviously,
if we're ready, and that'll be updated from
343:26 - the server side, which we'll do later. Next
method define both went, this is just simply
343:33 - going to return if both of our players left.
So to do that, we're just gonna say self dot
343:38 - p one once and Why can I not spell that word,
and self dot p two went like that. Okay. Next
343:47 - one is winner. This one is a bit more complicated,
but it's just gonna keep track of where it's
343:51 - actually going to tell us who's won the game.
So if we call this method, we're assuming
343:56 - that both players have gone, we're going to
check their moves, excuse me against one another,
344:02 - and see if they want. So we're actually going
to have to check nine possible cases, because
344:05 - there's three moves, each player could do
three times three, nine. So what we'll start
344:10 - by doing is we'll just say p one equals self
dot moves, zero, dot upper. And then to the
344:21 - reason we're doing this is because we just
want to get the first letter of the move,
344:25 - because the move is going to be stored as
Rock paper or scissors, the string, and it's
344:29 - just gonna be easier for us to type out, for
example, R or s, or what do you call it, or
344:34 - P to check the moves, as opposed to having
to check the entire word. So we're just going
344:39 - to get that first letter by doing move zero,
we're going to upper it and then we're going
344:42 - to take that first letter, we're gonna do
the exact same thing for p two, except obviously,
344:46 - we're going to need Oh, I don't know what
I did there. We're going to need moves one
344:52 - dot upper. And now we can start checking to
see who's won. So we're going to stay to start
344:57 - winner is equal to negative one. Now that's
because There could be no winner that could
345:01 - be a tie. So if it's tied, we're gonna say
negative one. If player one is the winner
345:06 - it's gonna be zero. If player two is the winner,
it's gonna be one. Okay? So we're gonna do
345:11 - is we're gonna say if p one equals equals
345:13 - R, and P two equals equals scissors, what
we'll do is we'll say winner equals zero because
345:22 - player one one that will say lF p one equals
equals s, and P two equals equals R, then
345:31 - we'll say winner equals one believe, do another
lF, and I know this is tedious, but this is
345:39 - the way you have to check for rock paper scissors.
I don't think there's an easier way to do
345:42 - it. If you know an easier way let me know.
And p two equals equals R. And if you guys
345:47 - don't want to type this, you can always copy
it from my website, tech with Tim net. Okay,
345:51 - so say winner equals paper beats rock solid
B winner equals one or zero sorry, we'll say
345:57 - lF p one equals equals R, and P two equals
equals p, then winner equals one. And we've
346:08 - just got two last ones to check here. So we'll
say lF p one equals equals s, and P two equals
346:16 - equals R. And then P two is the winner. So
winner equals one. believe that's Oh, sorry,
346:24 - I'm gonna mess this up. This should be P.
Thanks. So P rock, rock, paper, scissors,
346:30 - paper. Yeah, when r equals zero. Okay, well,
if p one equals equals paper, and P two equals
346:38 - equals scissors, then when r equals one, and
I believe that should be correct, 123456.
346:46 - Okay, sweet. And then the other cases, or
if it's a tie, so if none of this is the case,
346:51 - then they must have tied, and then all we're
going to do is simply return winner like that.
346:56 - Okay, and one very last method, then we're
actually done with this class, we can move
347:00 - to something else is the fine, reset, went.
And all this is going to do is say self dot
347:06 - p one went equals false. And self dot P to
one
347:12 - equals false.
347:13 - Pretty straightforward. And this is the game
class. I know it kind of sped through this,
347:17 - but it's pretty trivial how this works. We
just need to get this out of the way so we
347:20 - can start coding some other stuff. Okay, sweets,
we've done this class. Next thing I think
347:26 - we want to work on is network. So network,
actually, you guys are gonna have to modify
347:30 - yours to look like mine. Now get P. And what
do you call it? So this first half, so a net
347:38 - and get p are gonna be the same as what we
had previously, the only thing that's changed
347:41 - is connect and this send. So in Connect, instead
of, what do you call it, like unpicking an
347:48 - object. So like pickle dot loads, what we're
simply doing is we're going to just connect
347:53 - to the client like we did before, but instead
of unpicking it, we're just going to decode
347:57 - it. So we're gonna say self dot client dot
receive 2048 D code would return that value.
348:04 - And that's because when we initially connect
to the server, what we're going to get from
348:07 - the server is our player number, which means
we're either player zero, or we're player
348:11 - one. Now, that's important, because that's
going to determine where on the screen we're
348:14 - drawing certain things, and how we're sending
information back to the server and updating
348:19 - player one or player two, right? Because technically,
each player thinks that they're player one,
348:24 - but each one needs to be assigned either zero
or one by the computer. So we know where to
348:28 - store information, right? Okay, so that's
how we modify that to decode instead of pickling.
348:34 - Sending, I believe is the same except what
we're going to do is, instead of picking an
348:39 - object to send, we're simply going to send
a string, and we're going to load an object.
348:44 - So that means we're going to send a string
data to the server, and we're going to receive
348:48 - back object data. So when we receive something,
we have to pick it out, loads it in, but when
348:52 - we're sending it, we just have to encode the
string. Okay, so just make sure it looks like
348:56 - this, I don't think I need to go through this.
We've already done this for the past two,
349:00 - three videos. And that's the network class.
So game and network are done. The next thing
349:05 - is to do our server and client. Now server
and client are a bit more complicated. So
349:11 - inside of server, I guess we could do this
first because it doesn't really depend on
349:15 - the client to work or the client kind of depends
on the server. We're gonna change a bunch
349:21 - of things. So this is what mine looks like.
Now I've kind of gutted the entire threaded
349:24 - client, I got rid of most of the stuff like
most of the other stuff, just left this beginning
349:29 - thing so that the server IP, the port, the
socket, connecting, listening, waiting for
349:36 - connection. So by the way, some of you were
saying you're having issues with F s dot Listen,
349:40 - you can just make this zero doesn't really
matter. What's in here. And some of you are
349:44 - saying like you're having issues just you
can just delete it and type it in again. And
349:48 - apparently that works. That's when someone
said so. I don't know. Don't ask me about
349:52 - that. But if you're running into issues, do
that. Okay, so what we're going to do now,
349:57 - is we want to make it so you can have unlimited
connections at once. Now that means we're
350:01 - going to have to have unlimited games running
at the same time. So before what we were doing,
350:06 - when we had those players moving around the
screen, we were just storing, like player
350:09 - one, player two, and we just had a list that
had two entries. That's what we were doing
350:13 - that, what we're gonna do now, is we're gonna
have a list that contains a bunch of different
350:18 - games. And those games actually, you're sorry,
it's gonna be a dictionary, those games will
350:22 - be accessed by their ID, and use, we'll see
how this works. It's a bit complicated, but
350:27 - just follow along. And yeah, so I got to just
open up my other file, so don't make any mistakes
350:32 - here. Guess what we're gonna do is we're gonna
do connected equals set, we're going to define
350:39 - some variables, we'll talk about these do
games equals a blank dictionary, and Id count
350:45 - equals zero. So the reason we're adding these
is games, this dictionary is going to store
350:50 - our games. So it's gonna have an ID as a key,
and the game as like a game object like this,
350:56 - okay, as the value, this connected is just
going to store the IP addresses of the connected
351:02 - clients, we're struggling to set just so it's
easier to access later. I don't actually know
351:06 - if we use this, we might. But we'll see. Id
count, obviously, it's just gonna keep track
351:13 - of our current ID. So that means what game
we should recreate. So we don't override games
351:18 - and say like two games have the same ID because
obviously, we can't have that happening. Okay,
351:22 - so that's fine. for that. We're not going
to deal with anything threaded client right,
351:26 - now, we're going to go down to our while loop.
And this is where we're going to create new
351:30 - games based on new people joining or possibly
delete games, actually will delete games from
351:35 - threaded client.
351:36 - So we're going to do right now is when someone
connects this, this runs, right, and we run
351:40 - a new so like, once we accept a connection,
everything after this runs, so what we're
351:44 - gonna do is we're gonna say ID count, plus
equals one, if you noticed me looking away,
351:49 - I'm just looking at my other screen to make
sure don't make any mistakes on this. Now,
351:52 - what Id count plus equals one is going to
do obviously, it's going to keep track of
351:56 - how many people are connected to the, the
server at once. Because obviously, right like,
352:01 - once this happened, we can accept, then we
go down the while loop, we start a new thread,
352:05 - and then we wait for another connection. So
we're just gonna keep track of that, what
352:09 - we're gonna do is we're gonna say P equals
zero, just standing for the current player,
352:13 - we're gonna say game ID, equals, and this
is gonna be weird, but just follow along with
352:17 - me. We call it ID count, minus one, integer
division two. Now, what this is going to do
352:25 - is essentially, every two people that connect
to the server, we're going to increment game
352:30 - ID by one, and what game ID is going to be,
or we will say, it's, yeah, we'll add it by
352:36 - one, what game ID is going to do is keep track
of what Id or game is going to be. So like,
352:41 - for example, if we have 10 people connected
to the server, we're gonna have five games,
352:45 - right? So that's what this line of code is
doing. For us, it's keeping track of how many
352:49 - games or if we need to add a new game, because
obviously, if we have like six people connected,
352:54 - all of them are gonna be playing each other
a seventh person connects, well, it doesn't
352:58 - have a game to join, we have to create a new
game for it to join. Hopefully, that makes
353:02 - sense. Okay, so what we'll do next and say
if Id count, modulus two, equals equals one.
353:09 - And what this is going to stand for, is if
you're going to be player one, or player two,
353:14 - and if this happens is actually we need to
create a new game, because this means that
353:17 - we don't have a pair for our new player. So
for example, like, say this numbers three,
353:23 - that means two people already playing. So
that's one person just connected. So we need
353:27 - to create a new game. That's what this module
is to is getting. Okay, so to do that, we're
353:31 - going to say games. Game ID equals game. Game
ID. Okay. And I believe it's actually speed
353:42 - capital. So obviously, start at the beginning
of this, I forgot to mention I import a game.
353:47 - So from game import game, that is important.
And yeah, essentially, what we're doing is
353:53 - we're just going to say that game ID, which
is that key in our dictionary is now equal
354:00 - to a new game, so we can access that and add
players to it and whatnot. Sweet. So that
354:04 - works, let's actually print out a message
here and just say, creating a new game, dot
354:10 - dot dot, just so that in our server, we get
some kind of output, and we can have a look
354:14 - at that if something's going wrong. So otherwise,
if there, we don't need to create a new game,
354:19 - meaning we have, let's say, three people are
connected. So that second game already exists,
354:25 - and another person connects, well, that person
has to be a part of this new game. So what
354:29 - we're gonna do then is we're gonna say games,
game ID dot ready, equals true. Now, what
354:36 - this means is that the second player connected,
so there's two players now connected to our
354:40 - game. So now we can say that that game is
ready to start playing because both the players
354:45 - are connected. So that means that they can
will obviously play against each other, right?
354:48 - So that's what we'll do, we'll set that dot
ready equal to true. And obviously, we're
354:52 - storing all the games on the server side,
as opposed to on the client side. And then
354:56 - what we're going to say is we're gonna say
P equals one and what this means is putting
355:00 - Error equals one. And you'll see why we need
to do this in a second. Okay, so now we're
355:04 - going to do start new thread. Now notice insert
new thread, I added two new parameters, P
355:09 - and game ID. So this means the current player,
so it's either player zero or player one.
355:14 - And the game ID and game ID is going to stand
for which game in this games dictionary, are
355:20 - we playing in this thread client, like, which
one of our clients that's connected here is
355:26 - playing which game, that's why we need that.
So let's pass that information. So we're gonna
355:30 - pass p, which is either going to be zero or
one like we have there. And we're going to
355:34 - pass game ID. And then we'll have that up
here. And just remember that threaded client,
355:40 - one of these functions is continuously running
for every single one of our clients. So if
355:45 - we have 100 clients, we have 100 different
functions of this running in the background
355:50 - at the same time. Okay. Awesome. So that's
how that's working inside our threaded client
355:55 - now.
355:56 - Excuse me shut to take a break there. inside
of our threaded client, we now need to add
356:04 - some things. So the first thing we're going
to add is ID count we're going to global ID
356:08 - count, because if someone leaves our game
or disconnects, we're gonna need to subtract
356:13 - from that. So we can keep track of accordingly,
like, how many people are connected, how many
356:18 - games are running, and all that stuff. Okay?
Now, the first thing we're going to do, when
356:24 - someone connects to our, what do you call
it, our server is we're going to send them
356:28 - what player there. Remember what I was saying
in the scheme class, or in this network class,
356:32 - sorry, then when we connect, we're initially
just going to decode a string, that's either
356:36 - going to be zero or one to tell us what player
we are. Okay, so what we're going to do is
356:41 - we're going to send con dot send str dot encode
P. And I believe it should be actually string
356:49 - P. Like that, so that we know for player zero
or for player one, that's the first step.
356:56 - Next, we're gonna say reply equals a blank
string, want to say while true. And this is
357:01 - where we're going to start doing some more
serious stuff in here. So the way that it's
357:04 - going to work in terms of sending string data
from a client to our server, is we're going
357:09 - to send one of three different options we're
going to send yet we're going to send reset,
357:17 - or we are going to send a move, and the move
is going to be like rock paper or scissors.
357:22 - So if we send get what that means is we want
to get the game from the server. So we're
357:28 - going to send that every frame, we're going
to send get a string get, and then the server
357:32 - is going to look, it's going to say okay,
what are you sending you're sending get, Alright,
357:35 - we'll send you back the game. That's how that's
gonna work. Or another option is reset. Reset
357:41 - means reset the game, the game is finished,
both players played, reset, and that's going
357:47 - to be sent from the client side, because the
client knows when we want to reset, right.
357:52 - The last one is a move, same thing when the
client makes a move. So like rock, paper,
357:57 - scissors, if they are allowed to make that
move, which will check on the client side,
358:02 - we'll send that move to the server, the server
will update the game accordingly. And then
358:06 - it will send back the game to the client.
And that's how that's gonna work. Sweet. So
358:11 - what we'll do now is say, well, true, let's
say data equals con, dot receive. And then
358:18 - we're gonna say 4096. And here instead of
2048, which you're using for D code, reason
358:24 - we're doing this is just in case, we're sending
too much information that is more than 2048
358:30 - bits, we want to just double this number so
we can get more if you run into any issues
358:35 - that say like pickle data was true onst or
like ran out a input, just increase this number,
358:40 - okay, you can literally just do multiply by
two in here. And that should hopefully fix
358:44 - the error. If it doesn't work, you can like
multiply by four, multiply by eight. And that
358:49 - should hopefully fix your air for you. Okay,
so now what we're going to say is gonna say
358:52 - if game ID in games. Now I'll talk about why
we're doing this in a second, we're gonna
358:59 - say they're gonna say game equals games. Game
ID. So essentially, every time we run this
359:06 - while loop, we're gonna check if the game
still exists. And that's what we're doing
359:11 - right? So in this games dictionary, we're
seeing if this game ID, which is the key to
359:16 - access, the game is still there. Now, why
would we check that? Well, if one of our clients
359:21 - disconnects from the game, we're actually
going to delete that game from the we call
359:26 - it the games thing. Now, what that's doing
for us, excuse me is not only like keeping
359:34 - track of our memory, which means that we're
not going to just continually keep creating
359:38 - games. So like Sarah server ran for weeks,
and we never deleted any games, then we probably
359:43 - run run out of memory on our computer, right?
If we're playing a lot of games, but it's
359:47 - also going to tell the other client that was
connected to that game that, hey, this game
359:52 - no longer exists. That means the other person
must have disconnected from it. So we have
359:56 - to do something accordingly. Go back to the
menu screen right. Do something like that.
360:00 - Okay, so let's we'll do there. And then we're
going to say, in here, as I say, if not
360:05 - data,
360:06 - we're gonna break this similar to before.
So I'll go through it a bit quicker. We're
360:10 - gonna say else. And now we're gonna check
the three different things that could have
360:13 - been set. Right? So we've received the data.
So we're going to check if we got reset and
360:17 - get or if we got a move, first thing we'll
check, we'll save data equals equals reset.
360:22 - Okay, then we're gonna say if data does not
equal, get, and then else. Sorry, this should
360:32 - be an lF Alec data does not equal get else
we'll do something else. actually do anything
360:37 - else? No, we don't. Okay, so if data equals
reset, what we're gonna do is we're gonna
360:44 - say game, dot reset, right, because we already
have the game. And if we look in here, what
360:49 - resets doing is essentially it's resetting
both players one so we can play another game.
360:54 - really straightforward for that. Next one,
if data equals get, what we're going to do
360:59 - is say, gain. Or if data does not equal get
sorry. So if it didn't equal read, reset,
361:05 - and it does not equal get, well, then it must
be a move. So it means we're either getting
361:09 - Rock Paper, scissors, so we're going to send
that move to the game to update it. So to
361:14 - do that, we're gonna say game dot play. And
then we're gonna do with the current player
361:18 - number, which is P, and then the move, and
the move is going to be whatever this data
361:22 - is, right? So it'll be data. Okay, and then
otherwise, so I guess after that, what should
361:29 - we do here? We'll say, reply equals game.
And that what we're going to do is we're gonna
361:35 - do con dot send all we're gonna say pickle
dot dumps,
361:41 - and not
361:42 - reply. Okay. And what this is going to do,
let me just make sure I didn't run into any
361:47 - errors here is simply going to package up
our game into that nice sendible form, we're
361:53 - going to send it over to our clients, clients
going to receive it on Piglet, and then use
361:57 - it to obviously make moves and do different
things and draw to the screen and all that.
362:02 - Okay. Alright, so I think that makes sense.
We can go through it really quickly. What
362:07 - time we got 25 minutes. All right. So we'll
go through really quickly, essentially, what's
362:11 - happening. When you connect, we're going to
check if we have an even amount of players
362:15 - or an automatic players, if it's an automatic
players, when you connect, that means we need
362:19 - to create a new game. So we create a new game.
If it's not, that means we need to assign
362:24 - you to a game. So what we're going to do is
make the current game that only has one player
362:28 - in it ready, we're going to assign you to
that and start a new thread. When we start
362:32 - the new thread, what's going to happen is
we're going to send to the client what player
362:36 - they are either player zero or player one.
And then what we're going to do is we're going
362:41 - to constantly receive string data from the
client. If the game still exists, then what
362:46 - we'll do is we'll check if they're sending
us reset, get or remove, they're sending us
362:50 - a move, we'll make that move the sending us
reset, we'll apply that reset to the game.
362:54 - And then we're just going to constantly send
back to them the game object. And now what
362:58 - we need to do is just really quickly add some
statements in here. So that if some of this
363:02 - stuff doesn't happen, we have like a catch
for it. Okay. So what we'll do here is we're
363:07 - just going to simply say else break. Okay,
that should be lined up here. And we're just
363:12 - gonna add a try and accept up here. So we're
gonna say try, and we're gonna indent all
363:17 - this by just highlighting and pressing tab,
let's say accept, and then pass. I think that
363:24 - Yeah, no, not pass or accept and then break,
just in case you know, something goes wrong
363:28 - with this data dot receive, we want to make
sure the server keeps running. So we have
363:31 - that try and accept. And then underneath this
accept, in line with the main function indentation,
363:38 - what we'll do is if we break out of this while
loop, we need to close the game and delete
363:42 - it. So to do that, is actually we're going
to print some on my ROM file here. We're going
363:49 - to print last connection. And then we're going
to print What do you call it? closing game.
363:59 - Okay, actually, we can print that game ID
to see what game ID we're closing. So say
364:04 - last connection, closing game game ID, okay.
And then we're gonna try to
364:10 - delete games.
364:13 - Game ID. Otherwise, we will accept
364:20 - and pass.
364:21 - Okay, and then underneath here, last thing
we're gonna do is gonna say ID count minus
364:26 - equals one. And we're going to say connection
dot close. Now that actually think about it,
364:32 - we should probably put this closing game only
in this try after we delete, just so that
364:37 - we don't we only close the game once we don't
say we're closing the game twice. Okay, so
364:42 - what we're doing down here essentially, is
if we break out of this while loop so for
364:45 - example, if the game no longer exists, we're
going to break if something goes wrong with
364:50 - this getting data so like the player disconnected,
we're gonna break we're gonna say lost connection.
364:55 - We're gonna try to delete that game. The reason
we have this try here is because if both players
364:59 - just can At the same time, one player will
delete the game before the other. So if we
365:03 - try to delete a key that doesn't exist, we're
gonna run into an issue. So we try that. If
365:08 - that works, we will say print closing game,
and then we'll say that game ID, otherwise
365:12 - we're gonna pass, we're gonna subtract from
the ID count, and we're gonna close the connection.
365:17 - Sweet. So we're rolling, we're going pretty
fast here. Now all we got to do is code the
365:21 - client. Now, this is probably the most amount
of code, I think it's about 100. lines, it
365:25 - just is a lot of drawing stuff. Okay. So I'm
into your break, we'll be back in one second,
365:29 - and then we're going to code the client. Alright,
so I'm back out and we've got about 150 lines
365:37 - to write for this file. It's pretty tedious,
because a lot of the stuff has to do with
365:41 - the drawing, like we need those buttons to
be working. We need, like all that text to
365:46 - be showing up. So that's like 90%, or not
90%. But like 70% of the code are about to
365:50 - write is just going to be cosmetic stuff.
But I mean, what do want me to tell you, that's
365:55 - what we need to do if we're going to make
an online graphical game, right? So let's
365:59 - start by just coding a class. And this is
going to be a button class, just that when
366:04 - we have those three buttons, you know, it
just makes things easier. So we're gonna do
366:09 - our net. What do we need the niche, we're
gonna go for
366:14 - text.
366:15 - Sorry, coding in the wrong file, text x, y,
and color. And we're just gonna say that the
366:20 - width and the height will be uniform in here.
And we'll just make it the same for all of
366:24 - our buttons. So we're gonna say self dot,
text equals text. self dot x equals x. self
366:31 - dot y equals y. And self dot color equals
color. Okay, sweet. We'll also add a width
366:40 - and a height here. So we'll say self dot width
equals 150,
366:42 - self dot
366:44 - height equals 100. And feel free to play with
these numbers. That's just what I decided.
366:48 - By the way, guys, I just really want to say
this. I'm not focusing on how good this game
366:52 - looks. I know it looks like crap. But you
guys I know can go through and tweak the colors
366:56 - and tweak the positions and all that. I still
want to focus on that because I want to get
367:00 - the hard stuff out of the way in the tutorial.
Okay, so let's do a draw method in here. Pretty
367:05 - straightforward. We're just gonna do pygame
dot draw, dot rect. And then for the rectangle,
367:11 - we're gonna take window, which is a parameter
for the draw, and then we're gonna do, what
367:16 - should we do color, so self dot, self dot
color, and then we're gonna need that rectangle
367:22 - position, which is going to be self dot x,
self dot y, self dot width, and self dot height
367:30 - like that. Okay, and then I guess, let's see
if there's anything else we need to add to
367:34 - that, no, that's fine. We're going to find
a font. So we actually need to make sure you
367:38 - just add this to the top pygame.font.net.
Okay, make sure you get on that. And we're
367:42 - gonna do font equals pi game,
367:47 - dot font
367:48 - dot s, s y s fonts should help you spell font
correctly. And then here, you're gonna pick
367:55 - your favorite fonts. I like Comic Sans. I'm
gonna make this. How big should this be? Let's
368:01 - make it 40. And then what we're gonna do is
we're gonna render some fonts, we're gonna
368:05 - say text equals plot dot render. And we're
gonna put self dot text, we're gonna do one,
368:11 - and we're gonna do the color, which will be
I guess, in this case, black or white. 255-250-5255.
368:18 - Okay, next, we're going to draw this on the
screen. Now we want this to be centered on
368:22 - the button. So I'm going to do some like,
decently complicated math. It's not really
368:27 - that crazy, but we're gonna say window, Blitz
text, and then we're gonna say, self dot x
368:33 - minus is it minus notes plus self dot x plus
in brackets, and we're gonna round in these
368:41 - brackets. I know this is confusing, or any
self doubt with over two, minus round. And
368:47 - we're gonna say txt dot get underscore width,
over two. Now what this is doing essentially,
368:54 - is we're starting at our exposition, but obviously,
we want our text to be centered. So to center
369:00 - our text, we need to know not only the width
of the container of the button, but the width
369:05 - of our text. So we're going to get the width
of our text or our button, we're going to
369:09 - subtract that from the width of what do you
call it our text. So that way, it should add
369:17 - like 20 or 30 pixels from the left side to
our text center. Okay, for the why we'll do
369:22 - a similar thing. So inside makes you don't
mess up these brackets inside here. We're
369:27 - just gonna actually copy this. And we're gonna
paste it right after comma. And we're simply
369:32 - gonna say self dot y, plus round self dot
height.
369:36 - Okay, plus text dot get underscore heights,
or minus txa. gunners get height over two,
369:44 - and that should center our button. Yeah. Okay,
next, we're gonna say define,
369:49 - click,
369:50 - we're going to add a position here. This is
just going to tell us if we clicked on the
369:54 - button or not. So it's a really basic if statement
here, so we're just gonna say x one equals
369:59 - pa zero and y one
370:03 - equals paused one.
370:04 - Now we're gonna say we're gonna say if self
dot x is less than or equal to x one less
370:10 - than or equal to self dot x plus self dot
width. And self dot y is less than or equal
370:19 - to y one less than or equal to self dot y
plus self dot height. I believe that's correct.
370:28 - Let me just check this. Yep, that's correct,
then what we'll simply do is we'll return
370:33 - true, indicating that we did press the button,
otherwise, we will return false. Now, I know
370:39 - I'm speeding through this, but it just because
it's really basic pygame stuff, and we're
370:42 - doing online games. So make sure I change
that. So I don't want to focus too much on
370:48 - the cosmetics. But essentially, what this
is doing is it's checking if the coordinate
370:51 - which we're going to pass in here, which is
going to be a tupple of x, and why of our
370:54 - mouse position is actually in the button.
And the way we're doing that is we're saying,
370:58 - well, we go on the x, right, we check if it's
greater than the x, we check if it's less
371:03 - than the x plus the width. So like if it's
in between the little box, and then for the
371:08 - y value, we do the same thing. But we're checking
vertically to see if it's in that box. If
371:12 - you don't understand that I have pygame tutorials
where I go through like collusion and how
371:15 - all that works. I'm not really going to talk
about that right now. Okay, sweet. So we got
371:20 - that working. Now what we're going to do is
actually, let's see what I want to code now.
371:28 - Let's code the main function, and then we'll
get into Redrow window. So the first thing
371:31 - we're going to do is we're gonna define those
three buttons that we're gonna have at the
371:34 - bottom of our screen. So Rock, paper, scissors,
do that we're gonna say buttons equals, and
371:38 - we're just gonna make three buttons. First
button will be rock, and say rock, we're gonna
371:43 - start it at 5500. And then we're just going
to go and give it a color of 000. Okay, we're
371:50 - gonna create another button. Let's say button.
And then we'll say, scissors. We'll give it
371:58 - a, me just check here. 250 as next 250 as
an X 500 as a why, and for the color. For
372:07 - that, I gotta check what color I made this.
I believe that I made that red. Okay, so the
372:16 - 255 00. And then one more button. Can anyone
guess what this one is going to be? It's going
372:22 - to be paper, we're going to put this out of
position of 457 go here for 5500. And we will
372:34 - simply make it blue, or green. Sorry, 02 55
zero, so red, green, blue. Okay, sweet. So
372:41 - that should be at for our buttons. And now
we'll get into the main function and start
372:47 - coding some stuff, the first thing we're going
to need to do is we're gonna need to say run
372:51 - is equal to false or equal to true, I'll just
do that. We're gonna say clock equals pi game
372:58 - dot time, dot clock. Capital, see here, my
bad. Okay, next, we're gonna say n equals
373:06 - network. Right, because we're importing network
up here, we're gonna do a very similar thing
373:12 - to what we did before in the previous tutorials
where we just connect initially by doing that
373:17 - initialization, and then we're going to say,
P equals, actually player equals and dot get
373:24 - P, right? And you should already have that
method. It's just returning that, like, connect
373:30 - what we connected to, right, so when we connect,
we get the player number, which is either
373:34 - zero or one. So we need that. Now it reminds
me, it's going to be number, so we got to
373:38 - put an inch around this so that we can compare
it with other integers. Okay, and last, we're
373:43 - going to just print just so we have this you
our Player, Player. Now this just indicates
373:51 - to us like when we initially run, if we know
where zero or one just to make sure everything's
373:55 - working fine. Now we're gonna make a while
loop running, say, sir main game loop, we're
373:59 - gonna say well run. And then in here, we're
gonna do clock dot tick 60. Very similar to
374:05 - what we've done before, guys, I'm gonna start
adding some new stuff in a second. Okay, so
374:08 - now that we've done this, it's time to start
actually connecting and asking the server
374:15 - for information. So what we should be doing
here is every frame, we should be asking the
374:19 - server to send us the game, especially at
the beginning of this loop, because right
374:23 - now, we haven't actually created a game class,
right? We need to get that from the server.
374:28 - So we're connected now, we know what player
we are. So now what we can do is we can try
374:32 - to get that from the server. So to do that,
we're gonna say game equals n dot send. Get
374:40 - and that's literally as easy as it is. We
just need to do an accept. And then we'll
374:44 - just when you call it will say run equals
false, and also print
374:51 - couldn't get game. Okay? And the reason we're
doing this and we're gonna break as well,
374:57 - is because when we if we Send this and we
don't get a response from the server, that
375:03 - means the game doesn't exist. And what what
if that happens? Well, then what we should
375:08 - do is we should exit out of this game, we
should print saying we couldn't get the game.
375:13 - And then we should try to reconnect or start
a new game with someone else. So this main
375:17 - function is going to be like the actual game
running. But once we exit of this main function,
375:22 - we're going to go to a main menu. And the
main menu will allow us to choose like we
375:27 - want to play against, and a bunch of other
stuff as well. Okay, you guys will see that
375:30 - later. Okay, so let's do that. Next, what
we're gonna do is we're gonna say, if game
375:37 - dot both went. Now, what we're going to do
here is if both players went, well, we're
375:44 - not waiting for anything. Now, we need to
see which one one. So what we're going to
375:48 - do here is going to check which player one
and we're going to display that message accordingly
375:51 - on the screen. So what we're going to do,
initially, we're going to redraw the window.
375:56 - The reason we do this right away, is because
we want to make sure that if both players
376:00 - went, we're updating the window and on the
window, it'll check like if both players have
376:05 - gone like in this redraw window, and it'll
draw the player moves for us. So you guys
376:09 - will see how that works in a second, we're
going to do a delay when we pygame dot time
376:13 - dot delay 200. And now what we're gonna do
is we're gonna try game, sorry, game equals
376:21 - n dot send, reset. Now, why we're doing this,
obviously, is because, well, if both players
376:28 - went, we need to tell the server to reset
those player moves. Right. So inside of game,
376:35 - if we call reset went, we're just gonna reset
it so that we were able to play the next round
376:39 - after,
376:40 - okay, we're going to accept
376:41 - except, of course, I can't spell that. We're
gonna say run equals false, we're gonna do
376:49 - the same thing as before, we're gonna print
couldn't get game. Couldn't get game, and
376:56 - we're gonna break. Okay? Now under this, so
after we send that reset, now what we want
377:03 - to do is want to display a message on the
screen indicating whether player one one or
377:07 - player two one or like if you want, or if
the other player one. So the way we're gonna
377:11 - do this, and it's actually a decent amount
of lines is we have to like render font and
377:15 - then we get to determine where we're gonna
draw the font and what's going to be on the
377:18 - font. So we're first just gonna start by defining
thoughts. We'll say font equals pi game, dot
377:25 - font dot s, why is font Okay, in here, we'll
say, Comic Sans, font size, let's go 90 for
377:33 - this one. Now we're going to say if game dot
winner, and remember if we go to game winner
377:40 - is going to respond to us with either a zero,
a one or negative one. So you have to check
377:45 - if winner is one and player. So whenever our
current player is one, then we're gonna say
377:50 - you won. If winner is one, but the current
player is zero, we're gonna say you lost,
377:54 - right? So that's how we can check this. So
to do that, we're gonna say if game dot winner
377:59 - equals equals one, and Claire eagles, Eagles
one, and remember, we got that player from
378:04 - the server. So we know if we're either player
zero or player one on the client side.
378:09 - And
378:11 - is actually doing an end. Oh, sorry, or that's
what we need to do. Or game dot winner equals
378:20 - equals zero, and player equals equals zero.
So essentially, what we're going to do here
378:24 - is going to check if this player one, so we
know what player we are. And we know what
378:29 - player one so if that coincide, like what
player we are and the player that one, then
378:35 - we'll print out and we'll say, or we'll put
on the screen you want, right telling that
378:38 - client they want. So we'll say text equals
font dot render. And then here we simply say,
378:46 - you one exclamation point, and then we can
just do one, and then a color and obviously
378:52 - color we just do like red like that. Okay,
on the screen. Okay, so else, actually, l
378:59 - if, and now we're gonna check if they last
washy, I think we can do this easier. We're
379:04 - gonna say l if game dot winner equals equals
negative one. So if we type, what we'll do
379:12 - here, is we'll say text equals font dot render.
And we'll just say tie game. exclamation point
379:20 - one. Again, we'll put that in red. Okay, and
now else, so if we didn't win, and we didn't
379:27 - tie we must have lost so we can literally
just copy this and it will just say you lost
379:32 - as the text. Okay, so you lost that. Sweet.
And now what we're going to do is just render
379:40 - that font, put it on the screen, so or not
render it just put on the screen so say wind
379:45 - up lit text. And now we're gonna do the exact
same thing that we did before. To get it in
379:51 - the middle of the screen just be a little
bit easier. So we're just gonna say, I believe
379:55 - to any another bracket, so I don't think so
we'll say width over two and that's the width
379:58 - of the actual screen. Minus text dot get underscore
380:02 - width,
380:05 - we need those brackets over to do comma. And
now we'll just do the same thing with height.
380:09 - So we'll say height over two minus text dot
get underscore height over two. Okay, so that's
380:18 - going to put it in the middle of screen, we're
going to update the display, game dot display,
380:22 - dot update, and we're going to delay, so pi
game dot time dot delay, and I'm going to
380:30 - put 2000 for two seconds, you guys can put
whatever you want in here. Okay, so let's
380:34 - break this down really quickly. If both players
went, that means now we're going to check
380:39 - who won. So we're going to do is we're going
to redraw the window, we're going to what
380:43 - do you call it, apply a small delay of 0.2
seconds, just so that we can see what both
380:49 - players did before it immediately pops up
who won and who lost. So actually, let's make
380:53 - this delay half a second, we're going to send
to the server reset, we're going to reset
380:58 - both players once the next time that we start
playing we can both players are allowed to
381:02 - move, we're gonna say run equals false. If
this doesn't happen, if this doesn't work,
381:06 - we're gonna print couldn't get a game we're
gonna break. Now otherwise. So like, if this
381:12 - worked, we set the game, we're going to create
a font, we're going to check who won. So either
381:15 - we won, we tied it, we lost, we then display
that to the screen, ran delay for two seconds,
381:20 - and then we're going to play the game again
after. Okay, awesome. So we're almost done.
381:25 - We're just gonna add this pretty actually
complex for loop in here. So we're gonna do
381:30 - now we're going to say for event in PI games
dot event, dot gets very standard for pagi
381:38 - probably seen this before, we're gonna say
if event dot type equals equals pi game dot
381:45 - quit, then what we're gonna do is gonna say,
run equals false. And we're gonna say pi game
381:52 - dot quit. So this just means that they hit
the little X button on top of this corner.
381:56 - Now we're going to check if they actually
pressed their mouse button down. So this is
382:00 - how we're going to check if they pressed a
button. That's where we're gonna do now, let's
382:02 - say if event dot type equals pi game, dot
mouse button.
382:11 - down,
382:13 - then what we'll do is we'll get the mouse
position to do the hovering so if we're gonna
382:17 - say pi game dot pause, pi game dot mouse,
dot get underscore pause. So what we're doing
382:24 - here is we're checking if they press right
mineral or left mouse button, if they do,
382:28 - let's get the most position. Now, for every
single button, we're going to check if we
382:33 - click that button. If we did, we're gonna
do something accordingly. Okay, so we're gonna
382:37 - do now I'm gonna say for button in btn. Remember,
we defined buttons up here, then what we're
382:44 - gonna say is, if btn dot click, pause. Now,
if they did click the position, there's a
382:54 - few things we need to check. Oh, and also,
we can check this sir. And game dot connected.
382:59 - Sorry. So what this game connections doing
is just making sure that it's not going to
383:03 - let us press like Rock Paper, scissors, unless
we both players are on. So just so that we
383:08 - don't run into an issue where we can make
a move before the other player connects. Okay,
383:12 - so just add this end game connected. What
we'll do now is we're gonna check what our
383:17 - current player is, because this is gonna determine
how we send a move. So we're gonna do now
383:22 - is gonna say if Claire equals equals zero,
if not, game dot, what do you call it P one
383:30 - went, then we'll do something otherwise, so
we'll just put Alice here. And we'll check
383:38 - if not, p two game.pt one. Okay, so what we're
doing now, and I haven't coded the rest of
383:47 - it yet, is we're just going to check if we
press one of the buttons. So remember, we
383:51 - have that click method in our button that
tells us if we clicked on it. So if we do
383:56 - click on it, and we're connected to the game,
what we're going to do is we're going to check
384:00 - if our current player is your one. Now, what
we're doing is if we're player zero, we're
384:05 - going to check if players here has gone yet,
if they've gone, obviously, we're not going
384:08 - to let them make a move, right, because they've
already made that move, they can't change
384:11 - their move once they made it. Same thing with
player two. So if we're not player zero, we're
384:16 - player one clearly. So that means we're gonna
check if player two has gone yet. And if they
384:20 - haven't gone, we'll allow them to move. Okay,
so all we're doing here now is we're going
384:24 - to make a move. Now to make a move, remember,
we just need to send to the network our move.
384:27 - So we're just gonna say n dot send origin
server, sorry. And all we're gonna do is we're
384:31 - just gonna send the text of the button. Now
the text of the button will be Rock paper
384:36 - or scissors, right? And that's precisely the
move that we're gonna make, depending on what
384:40 - button we're clicking. So it's a really nice
dynamic way to do that. Now, once we've done
384:46 - that, right, so if we go to server, what happens
here is if we send that we're going to play
384:51 - that move, and we're going to update it on
the game, so that the other client when it
384:55 - gets that game board again, we'll have the
updated move. You guys will see how this works
384:59 - out. Okay, so that's working well, now all
we need to do is just add in line with this,
385:07 - right here is a redraw window, we're gonna
give it when we're gonna give it, what else
385:12 - do I need to give it a game, and p, which
stands for current player. And that's actually
385:18 - it for and make sure you just call our calling
main down here at the end of climb. That's
385:23 - actually it for this main function. So now
all we need to do is do redraw window. And
385:27 - we're really close to done. So we got another
like 20 lines. And then once we do that, we're
385:32 - actually finished this game. And then we can
start testing it out and talking about some
385:36 - more things we can add to it. Okay. So what
we're going to do now is, it's actually quite
385:41 - a bit of work is we're going to draw all the
stuff on the screen now. So we've done all
385:45 - the logic aspect of it down here in this main
function. Now we need to draw everything so
385:50 - it's more tedious and it is difficult. Or
we're just going to first start by checking
385:54 - if not gamed connected. Now, this just means
if we have not yet had the other player Connect,
386:00 - then all we're going to do is we're just gonna
print on the screen waiting for player and
386:03 - we're not going to show anything else. So
to do that, we're gonna say font equals pi
386:07 - game, dot font dot s y as Font Name, obviously,
it's Comic Sans. And then the, how big should
386:18 - it be? Let's make it 80. Okay, and then we're
gonna say text equals font, dot render in
386:24 - here, we're gonna say, waiting for player,
dot dot dot, one color, let's do a nice red.
386:31 - And let's actually add true here for bold,
okay? Okay, so we're going to put this on
386:36 - the screen. So to do this, we'll say wind
dot lit. And we're going to do again, that
386:42 - same I know a tedious thing to get in the
middle of the screen. So we're just gonna
386:46 - say with over two minus Tex dot get underscore
width. And then we're gonna say height over
386:54 - two minus text dot get underscore height.
And actually, we need to make sure we're dividing
387:01 - both the width and the height by two. So let's
do that.
387:04 - Okay, that's it for that. Now else. So this
means if we actually are connected, both players
387:10 - are in now it's time to start drawing the
real stuff on the screen. So we need to draw
387:14 - that. What was it? So actually, let me pop
up client for you guys. So you can see what
387:18 - it looks like. Let's run the server. Right
and client client. Great. So if we want to
387:24 - see the client, what we should do is we need
to draw this, this, this, this and then the
387:30 - three buttons. Okay, so we're gonna have to
do these four texts. And the thing is, these
387:34 - text needs to change on like, they're gonna
be different depending on what player is looking
387:39 - at it, right. So for example, here, it's showing
us what our move is. But notice, it just says
387:43 - locked in for opponents. It doesn't tell us
what our move is, or what the other players
387:48 - move is, right? So we need to do that as well.
Okay, so to do that, let's start. We're gonna
387:53 - make another font, I'm gonna say font equals
pi game, dot font dot s, why is font, Comic
388:05 - Sans size of this font, let's make it 60.
And then what we're going to do is I say text
388:11 - equals font dot render. And we're going to
do your move. So we're going to start by just
388:18 - doing your move and like opponent move, because
those aren't going to change, they're going
388:22 - to stay the same no matter what. And for that,
we're gonna do one and the color I had there
388:25 - was a nice cyan, I think, right? So we'll
do this, to feel free to change the color.
388:30 - I know, it probably doesn't look the best.
And let's just put this at a static position
388:34 - on the screen. So we'll say text. And let's
go at 200. Okay. All right, next. So actually
388:42 - still in this else statement, we're going
to copy this. Just sorry, what am I doing?
388:48 - Just this text and this wind part. And we're
going to put it down here. And so your move,
388:53 - we're going to say, opponent opponents move.
Is that a spell that? Let's change that to
389:00 - opponents. And actually, let's just get rid
of moves and be too big opponents. And same
389:04 - color, except we're just going to change the
x value, so that we draw it at Will you call
389:09 - it 380. Like that, okay. So that's it for
your moving opponents. Next, what we need
389:15 - to do is a bit more complicated, because now
we have to draw what the actual moves are.
389:20 - So remember, we're obviously we don't want
to show the other player what one of the players
389:25 - moves is, unless both of them have gone like
we want to know what our move is, but we can't
389:29 - know what the other players movers until we
both made a move. So to do this, we're gonna
389:34 - do, we're gonna start by just getting ballplayer
moves, we're gonna say game, dot get underscore
389:39 - player underscore move, we're gonna get move
zero. And we'll actually we'll copy this and
389:47 - just do move to and change this to one. So
let's start by getting the moves. And then
389:53 - now we're going to check if we should show
those moves, if we should show waiting or
389:56 - if we should show locked in. Okay, so to do
this, we're gonna say if Game dot both went,
390:02 - Okay, like that we're gonna say is gonna say
text one equals font dot render. And we're
390:09 - just gonna use the same font as before. And
what is going to be is move one, comma, one,
390:16 - comma, and we'll make this black. So 000.
Okay, and we'll copy this. And we'll do the
390:22 - same thing except text two, is going to be
equal to move two. So essentially, this is
390:27 - saying, If both of the players have gone,
well, we can show their moves, because they
390:30 - both made them. So let's do that. And it's
just rendering that font, and we'll display
390:34 - the font after, you'll see how that works.
So now, otherwise, if both players have not
390:38 - gone, what we need to do is we need to actually,
let me just check something for a second is
390:43 - we need to determine if we're going to show
locked in meaning the other player actually
390:47 - has gone but we're not going to show their
move, or if we're going to show waiting, which
390:50 - means the other player hasn't gone. So to
do this, we're gonna say if game dot p one
390:55 - went, and P equals equals zero. So this is
saying, if we have gone, and that's our current,
391:05 - like, we are the player, we're player one.
So player one's gone, and we are player one,
391:09 - what we're going to do is we say text one
equals font, dot render, move on, which is
391:15 - the move we've done, which is fine if we see
that, and then we're gonna say one, and color
391:20 - 000. Okay, lF game dot p two went, and is
this one, it is actually sorry, game dot p
391:32 - one went, you guys will see how this works
in a second. We're gonna say this a text two
391:37 - equals the same thing. Now, this might be
confusing, but essentially what this is doing
391:42 - is it's saying if player one is gone, and
we are player one, we're gonna say,
391:47 - if I spell render correctly, render, like
that. Render, sorry, I got interrupted there.
391:55 - Okay, so if player one is gone, and we are
player one, then we want to show underneath
391:59 - like your move what our move is. Otherwise,
what we want to show is we want to show that,
392:06 - like locked in, so we're gonna change this
to locked in, underneath opponents move because
392:10 - it means player one went, but it's not us.
So it's not our move. So that means we want
392:14 - to show it under opponent's moves, you'll
see how this works. We're gonna say, locked
392:19 - in like that. Okay? All right, now we're just
gonna do else. So this actually just stands
392:25 - for, if game dot p one hasn't, like if they
haven't moved yet. We're gonna it's gonna
392:30 - say txt two equals waiting. So we'll say waiting.
I believe that's correct. I'm actually sorry,
392:44 - these all need to be text one by one. Okay?
All right, IOC is confusing, but we'll go
392:49 - through it after. All right, so we're gonna
actually copy this, and we're just gonna change
392:53 - everything to two. So this is going to be
P two, this is going to be one, this is going
392:58 - to be two, it's going to be two, and it's
going to be two, and this is going to be two
393:02 - as well. And we just make sure that I did
that correctly. I believe I did. Okay, sweet.
393:08 - And now we're going to actually show these,
we're going to split these on the screen,
393:12 - and we're actually really close to French
guys. So to do this, we're gonna say if P
393:17 - equals equals one, so if we're clear one,
we'll do is say wind up lit. And we'll say
393:22 - text two, and then we're going to show it,
we're gonna show it at 103 50. Okay, now we'll
393:30 - copy this, so Ctrl D, and we'll blit one,
except instead of at 100, we're gonna change
393:35 - this to 400. Now we're just going to put an
else so if we're not player one, clearly,
393:39 - we must be player zero. So we're just going
to reverse these player one, player two. Now,
393:45 - the reason we're doing this is because this
is going to be where like player one and player
393:50 - two's moves are shown on the screen. So we
want it to make so that for each of our clients,
393:55 - rather than saying like player one, player
two, and having one of the clients have their
393:59 - move on the right side, and one of them have
it on the left side, we want it to be the
394:02 - same for each client. You guys will see how
this works when we actually run the thing.
394:06 - So let's actually just, let's add in drawing
the buttons. So to draw the buttons, we could
394:12 - we could draw them in this L statement. Actually,
I might be better. Yeah, let's do it inside
394:16 - of this, this else, okay, we're gonna say
for btn. In buttons, we're just gonna say
394:23 - btn dot draw, and give it a win. And I think
that's actually all we need to do. And lastly,
394:29 - we're just going to update the display. So
probably game dot display dot update. Now,
394:35 - assuming I didn't make any critical errors,
this should actually be working. So I know
394:40 - this has been a lot of code and a lot of writing
but I think I've kept it to just about an
394:43 - hour now actually. And that's actually pretty
decent time for creating a game like this.
394:48 - So you guys will see how this works out. Okay,
so let's try running our server and see if
394:53 - we got any errors First of all, okay, server
waiting for connection server started. Good
394:57 - sign so far. Okay, clients, let's try running
it. Client client. Oh name P is not defined
395:04 - when game P. Okay, so what we're gonna do
for client, this is a really easy fix just
395:08 - change this to player.
395:10 - And I might have to change. Oh yeah, up here
but I do redraw game window as well we got
395:16 - to do win.
395:17 - Game and player. Okay, so fix that. Alright
client run waiting for player. all right good
395:23 - sign. Let's run another one. And what do you
look at that okay they both launching now
395:28 - so you saw that waiting for player showed
up but as soon as we are ready, now both of
395:32 - them are showing up. Okay, so this should
be player one, this should be player zero
395:37 - or Player, Player One player two, right? Okay,
so let's try this now. Rock ran out input
395:43 - self client received 2048. Okay, so let's
have a quick look at why this might be. So
395:50 - I think I might have finally found the issue.
I'm actually I don't know if this is the issue
395:54 - Exactly. But we do need to fix this, where
I do game dot reset inside of server here
395:59 - it actually needs to be reset went cuz that's
what I called it inside here. Reset went so
396:03 - we should make sure we do that. Okay guys,
so really silly error here actually on the
396:08 - issue was on the server side here. I'm calling
play, right, like game dot play. And so actually,
396:14 - to get rid of six, I was just printing out
the exception so I can see what it was. But
396:18 - essentially, play doesn't actually exist because
I misspelled something on game, I misspelled
396:23 - it, and misspelled player should be play.
So that was the issue I was running into.
396:28 - It just was very difficult to see because
it was just accepting it and not like not
396:33 - printing any Oh, just continuing to run the
server. So I couldn't find it. But essentially,
396:37 - if we run the server and run the two clients
now we should have everything working. I haven't
396:42 - actually tested it. So let's pray. I go paper.
Sweet. So it goes paper here. We're not getting
396:47 - locked in over here. So that might be an issue.
But let's see if we make something here. That
396:52 - is since you lost and you won. Because we
have a slight issue, but it's pretty easy
396:56 - fix. Let's just go up to client, just look
through, we're just probably messing something
397:01 - up in the drawing code here. So Oh, that would
make sense. Well, we're not actually end up
397:06 - drawing. Yeah. So this, if P equals equals
one, this just needs to top back one, one
397:12 - indentation level. And now we should everything
actually working fine. So let's try this now
397:18 - client client. And let's go rock. Okay, so
that works. But it's not doing the locked
397:26 - in for some reason. So let's check this this
locked in portion, close that server and make
397:32 - sure that this is actually working. So that
needs to be P two went. And oh, if this one
397:39 - should be working, that was what's confusing.
Okay, so actually, so that would just need
397:44 - to be P two went game dot p two went. Let's
try this server. And let's go client. And
397:52 - let's run it again. And we'll scissors locked
in sweet. So that's actually working and the
397:58 - game is pretty well finished. All we got to
do is out of menu screen and we're gonna be
398:01 - done. So let's go scissors. This is a scissors,
scissors. That's not correct. We got to fix
398:08 - that as well. Okay. I thought I had everything
working guys. I really thought so. Okay, so
398:14 - actually I do I do know the issue it was it's
pretty straightforward. So in main here when
398:19 - we check the let's see here the winners where
do we check winners? If it equals equals one,
398:25 - because it goes negative one? Ah, okay. So
again, no winner needs brackets? Of course
398:33 - it does. So we add that so obviously just
subsidiaries guys. So servers running right
398:38 - now, let's run these clients see if everything
is indeed working as as it's supposed to be
398:43 - now. Okay, so let's try this paper blocked
in scissors. You lost you won. Yeah. Okay,
398:50 - everything's working. Okay, paper, paper,
die games. Sweet. Okay, so you guys can really
398:55 - mess around with the timing, you can see how
this is working. So the only last thing to
398:59 - do now is watch this. If I disconnect, disconnect
both of them. So what we're going to want
399:04 - to do now, if that happens is instead of just
completely like exiting the game, we're going
399:09 - to want to bring them to a menu screen where
they can just click to reconnect. And this
399:13 - is a really, it's actually really easy to
do. So what we're going to do is we're just
399:17 - gonna define another function. I'm gonna call
this menu underscore screen. Okay, and in
399:23 - here, all we're going to do is have a really
basic while loop that just checks if you click
399:26 - something, and all it's going to do there
is click the Run that mean functions we're
399:30 - gonna do is gonna say run equals true. Or
say well run. Okay, and then in here, we're
399:36 - gonna say for event in PI game, dot event
dot get, and then obviously, we're gonna check
399:45 - if they click Exit. So if event dot type equals
equals pi game dot quit, then we will do is
399:50 - just do pi game dot quit, Ron equals false.
Otherwise, if they click any key, so we'll
399:57 - say if event dot type e Calls equals pi game
dot, I will just say, most button down, so
400:04 - I should just get it, click the mouse button,
400:07 - then what we'll do is we'll simply say, run
equals false. And at the bottom of run equals
400:13 - false, what we're going to do is we're just
going to call main. So all this is going to
400:16 - do and we'll call menu underscore screen here.
Say while true. Comma, menu screen. Okay,
400:24 - I'll go through this in a second. We say while
true menu screen, okay, so what we're going
400:31 - to do is in menu screen, if they click something,
we're going to call the main function, which
400:37 - is simply going to what do you call it do
all of this stuff in here. And then if they
400:44 - exit out of the main function, so if you say
like run equals false, because they disconnected,
400:49 - it'll just rerun the menu screen, which means
that there'll be prompted to reconnect to
400:53 - new game. Awesome. Well, we'll do it here.
It's one o'clock as well. So say clock equals
401:00 - pygame dot time dot clock, give it a tick.
So clock dot tick 60. We'll do we'll just
401:10 - draw something in here. We don't need to use
the redraw window function will just do font
401:15 - equals pygame dot font. dot. That's why as
font in here, we'll go Comic Sans will go
401:26 - 60. And then we're going to render some texts,
we'll say text
401:29 - equals font dot render.
401:31 - In here, we'll simply say click to connect,
our click to play, exclamation point, one,
401:40 - some nice red text. And we can just continually
Actually, we can just window fill. So wind
401:46 - fill, and we'll just fill it with white 00.
Or what I say gray, actually 128 128. And
401:55 - we should just Where's when do I define it
up here somewhere? Yes, I do. So that's sweet
401:59 - winds up there. So what we could do is just
fill the window, run into this while loop,
402:05 - put some text on the screen. We may actually
have to fill this every frame. Let's get rid
402:12 - of one of those brackets I created. So let's
fill this every frame actually. Okay, so we'll
402:16 - fill it. We will blit this font. So let's
say when dot Blitz
402:22 - text,
402:23 - and you don't for right now, I don't want
to do it. We'll just do it. statically let's
402:26 - do like 150. So tonight at the top of the
screen, actually, let's go 100 200 Okay, pygame
402:34 - dot display dot update. Like that. Then if
they click something, what should happen is
402:41 - that you break this loop, they should be brought
to the main thing. And yeah, that should hopefully
402:47 - be working for us. So let's try this. Client.
Click to play. Okay, little little sketchy
402:53 - on the click to play but let's see if we click
the play. Okay, waiting for player. So this
402:56 - is what actually what I wanted. So it says
waiting for player. We're gonna wait for someone
402:59 - else to connect. Okay, boom, connected. Sweet.
So now we're ready. So let's just run a game.
403:04 - Let's go rock scissors. Now let's just see
what happens if we click x. This one goes
403:10 - to the menu screen where it says click to
play. And it can be what do you call it play
403:14 - against someone else, right and that's exactly
what we want it. We may also want to have
403:17 - like a back button to go back. But I'll leave
that to you guys. So guys, I'm gonna leave
403:21 - the tutorial here. If you guys have any questions
or run into any bugs or anything, please let
403:25 - me know this is by no means like a full complete
game. There's still obviously a lot of things
403:30 - that could be added to this. I hope that you
guys learned how to make an online game. I
403:34 - find this stuff really freakin cool and really
interesting how you can have like a ton of
403:38 - different clients connecting together. And
that being said, I'll see you guys in another
403:41 - video.