00:02 - So I wanted to start out with an introduction
to the go language itself. Now I know that
00:06 - this is much storied territory, but I have
to start somewhere. And this is going to serve
00:10 - as a stepping off point for us to go through
a survey of the entire go language, as well
00:15 - as hitting some of the key libraries along
the way. So the first thing that we need to
00:19 - know is that go is created by a small team
within Google. And that team was made up of
00:23 - Robert griesemer, Rob Pike, and Ken Thompson.
Now these guys have been around the software
00:28 - industry for a little while, for example,
Ken designed and implemented the first Unix
00:32 - operating system, as well as had a key role
in the development of Unicode. So when these
00:36 - guys got together and decided that they wanted
to create a language, we had a lot of talent
00:40 - in the room as soon as these guys got together.
But one of the questions that we need to understand
00:45 - is, why create a new language at all? Well,
to understand that, we have to look at the
00:49 - languages that are common inside of Google.
And that's the time that go is being designed,
00:54 - there were really three languages that were
key. The first is Python, then Java, and then
00:59 - C and c++. Now, each of these languages in
and of itself is very powerful. However, the
01:06 - go designers started to recognize that there
were some limitations that Google was running
01:10 - into, that might not be able to be fixed,
given the history and the designs of the existing
01:15 - languages. So for example, when we look at
Python, Python is very easy to use, but it's
01:20 - an interpreted language. And so it can be
a little bit difficult to run applications
01:24 - at Google scale that are based on Python,
it can certainly happen. But that is one of
01:29 - the challenges that you can run into in very
large Python implementations. Java is very
01:34 - quick, but its type system has become increasingly
complex over time. Now, this is a natural
01:39 - trend that a lot of languages go through.
They start out very simple, but it has additional
01:44 - use cases and additional features are layered
into the language, it becomes increasingly
01:48 - more difficult to navigate things C and c++
is quick as well. However, it suffers from
01:54 - a complex type system. And additionally, its
compile times are notoriously slow. Now, the
01:59 - type system has been receiving a lot of attention
lately in the C and c++ communities. However,
02:04 - they still have the burden of needing to manage
all that legacy code. And so similar to Java,
02:09 - it's very difficult for them to move past
the history that they have, because c++ applications
02:16 - written 10 years ago still need to compile
today. And the slow compile times are another
02:20 - legacy issue that C and c++ have inherited
as well. When C and c++ were designed computers
02:26 - had nowhere near as much memory as they do
today. So the decision was made to optimize
02:32 - the compilers to use a minimum amount of memory.
And one of the compromises that that brought
02:36 - about was the compile times can be a little
bit sluggish. In addition, all three of these
02:41 - languages were created in a time where multi
threaded applications were extremely rare.
02:46 - Almost every application that was created
really had to focus on a single thread at
02:49 - a time. So concurrency patterns built into
these languages are patched in at best. And
02:54 - so working in highly parallel, highly concurrent
applications like Google often runs into can
02:59 - be a little bit challenging when working in
these three languages. So enter go, What does
03:04 - go bring to the party in order to address
some of these concerns? Well, the first thing
03:09 - that we need to understand is gozi, strong
and statically typed language, so it inherits
03:13 - that same feature set from Java and c++. So
what do we mean by strong and statically typed
03:19 - with strong typing means that the type of
a variable cannot change over time. So when
03:24 - you declare a variable a to hold an integer,
it's always going to hold an integer, you
03:29 - can't put a Boolean in it, you can't put a
string in it. And static typing means that
03:33 - all of those variables have to be defined
at compile time. Now, are there ways around
03:37 - that? Yes, go does have features that allow
you to get around its type system, but 99%
03:43 - of the time, you're going to be living in
a world that's strong and statically typed.
03:46 - And getting all the benefits that come with
that. Now, if you come from languages such
03:49 - as Java, then you might be a little concerned
that strong and statically typed languages
03:53 - tend to be a little bit verbose. Well, we'll
see as we get into some go syntax, how there's
03:58 - been a lot of effort taken to make the compiler
do as much work to understand what you're
04:02 - talking about with a variable. So you don't
have to explain to the compiler every time
04:06 - what your variable types and things like that
are.
04:10 - In addition, go like a lot of recent languages
has a strong focus on the community that supporting
04:15 - it. Just because go is an excellent language
does not guarantee success. Because there
04:20 - are so many languages out there, that it can
become difficult for a new developer to ramp
04:25 - up in any one. As a result, there's a strong
community built up around go that's really
04:31 - focused on making sure that the go language
keeps moving forward, and that new developers
04:35 - have an easier time as possible ramping up
onto the language. So what are some of the
04:40 - key features of the language itself? One of
the first and I would argue most important
04:45 - features that go has is a recognition that
simplicity is a feature. So as we go through
04:51 - and start learning about the go language,
you're going to run into some features and
04:54 - you're going to ask yourself, Well, why doesn't
this exist? Or why don't we have that feature?
04:58 - And a lot of the reasons Come back to this
feature. There's a recognition that if the
05:03 - go language recognizes simplicity is important,
then that means that we're going to have to
05:09 - decide to leave out some other features that
might be very useful, but would add complexity
05:14 - to the language. Additionally, go focuses
on extremely fast compile times a lot of modern
05:19 - development environments to write code fast
to build it fast and to test it fast and get
05:24 - feedback back to the developer as quick as
possible. Well, if you've got a 45 minute
05:28 - compile time, it breaks that cycle. And developers
have a very hard time staying in that design
05:34 - build test loop. And so go focuses on keeping
those compile times down, even though it's
05:40 - going to yield us fully compiled binaries
at the end, go as a garbage collected language,
05:44 - which means that you're not going to have
to manage your own memory. Now you can manage
05:48 - your own memory. But by and large, the go
runtime is going to manage that for you. And
05:52 - the reason for that gets back to this simplicity
argument, there is a recognition that a garbage
05:57 - collected language does have challenges when
dealing with certain use cases. For example,
06:01 - real time trading systems for stock market
systems have a very hard time when you're
06:05 - dealing with garbage collection. However,
the advantages on the developer of not having
06:09 - to manage their own memory all the time, were
deemed to be more important. Now, that doesn't
06:13 - mean that the delays that a garbage collector
incurs haven't been paid attention to, if
06:18 - you go back through the history of the go
language, you'll actually see the past few
06:21 - versions have had a huge emphasis on reducing
the amount of time that the application has
06:26 - to pause during a garbage collection cycle.
And at this point, they're actually really
06:30 - fast, almost to the point that you don't know
that a garbage collection happened, in order
06:34 - to address that concern of concurrency go
does have concurrency primitives built right
06:39 - into the language. And we'll talk about that
as we go through some of these videos. But
06:42 - instead of having a library that we're going
to have to import, in order to work with concurrency,
06:47 - we're going to be able to do concurrent development
right there in the base language. Finally,
06:51 - go compiles down to a standalone library,
which means when you compile your go application,
06:57 - everything is going to be bundled into that
single binary that's related to the go application
07:01 - itself. So the go runtime is going to be bundled
in there, any libraries that you're depending
07:06 - on, they're going to be compiled in there.
So you don't have to worry about reaching
07:09 - out to external libraries and DLLs, and things
like that in order to make your application
07:14 - work. And what that gives you is version management
at runtime becomes trivial. Because you simply
07:20 - have one binary, you deploy that binary, you
run it, and all of its dependencies are there.
07:25 - Now keep in mind, when I say dependencies,
I mean to go dependencies, if you're going
07:28 - to build a web application that has HTML,
resources, and CSS, those have to be bundled
07:33 - along with the binary, but the binary itself
is standalone and self contained. Okay, the
07:38 - next thing that I'd like to do is show you
some of the resources that are available to
07:41 - you, as you start to explore the go language.
07:45 - One of the most useful resources that you're
going to be able to take advantage of as you're
07:48 - ramping up on go, is goes website here@golang.org.
Now, why is it go lang.org? Well, if you take
07:55 - a minute to think about a language called
go, that doesn't really lend itself to unique
07:59 - search results in Google or Bing. So go lang.org
it is, as a matter of fact, a lot of places
08:03 - that you see go mentioned, you're gonna see
it actually described as go Lang, because
08:08 - that makes it a little bit more unique when
you're looking for search results. So the
08:11 - first thing that you might notice, as we go
into the homepage here is this isn't really
08:15 - laid out like a lot of traditional home pages.
This, in my opinion, is very much an engineering
08:19 - homepage. So instead of a lot of design aesthetic,
this gets right into the engineering aspects
08:23 - and shows you how to start working with the
language. So this yellow box over here is
08:28 - going to be your entry point for your first
go application. So if we go ahead and click
08:32 - this run button, you see that we almost instantly
get an application sent back to the server,
08:37 - it gets compiled, and it gets run for us.
So we can start playing around with go code
08:41 - without installing anything on our local machines.
And we're actually going to take advantage
08:45 - of that through this first few videos. As
a matter of fact, if I make a small change
08:49 - here, so maybe if I will say, Hello, YouTube
peoples and run that again, then I'm saying
08:56 - hello to y'all, so Hi. So it's as simple as
that in order to get started with the go program.
09:01 - Beside that window, we see this download GO
button. And that's going to take you to resources
09:05 - that you're going to be able to use in order
to download the latest go binaries, as well
09:09 - as download older versions of the runtime.
And if there's an unpublished version, for
09:13 - example, at the time I'm recording this go
1.8 is at RC two, you can go ahead and download
09:18 - that install that and check that for bugs
and play around with new features in the language.
09:22 - If we come across at the top, we see this
documents link here. And this is going to
09:25 - be another critical resource as you're starting
out with the language. As a matter of fact,
09:29 - you're going to refer back to this page quite
often. But if you really want to walk through
09:33 - on the website, a tour of the go languages,
and I would recommend you go to this Getting
09:37 - Started link. This is going to get you started
downloading and installing the go compilers
09:41 - and tools and things like that. And you can
see as we navigate there, it's going to show
09:45 - you the different architectures that you're
going to be able to use with go and there's
09:48 - quite a few and how to get started on each
one of those. If we keep continuing down the
09:52 - tour of go is kind of an introduction to the
go language that takes you through a gradual
09:57 - introduction. So it's going to start out with
some very simple Apple And then build up more
10:01 - and more and more and help you understand
what's going on with go concurrency and things
10:05 - like that. Effective go is a very useful article,
especially as you start to mature in your
10:11 - understanding of the language, and really
understand how the go language is used. So
10:15 - I would encourage you to go into that it's
a pretty lengthy
10:18 - read. But you should consider this required
reading if you're actually going to start
10:21 - building non trivial go applications. But
we're not going to worry about that right
10:24 - now. We got plenty ways to go before we need
to get through all of this stuff. And then
10:28 - down here at the bottom is some reference
information. This is more advanced documentation
10:32 - that you're probably not going to need right
away. But for example, the command documentation
10:36 - gives you a lot of information about the go
tool itself that you're going to use for local
10:40 - development with go, there's a lot of things
that the go program does. And this is going
10:44 - to help you understand how to navigate that.
The packages link is perhaps where I spend
10:49 - the most time on gos website. And this gives
you documentation for all of the libraries
10:53 - that are built into go. So when you install
go and you install the go binaries and tools,
10:57 - you're going to get all of these libraries
available to you. So just scanning down, you
11:01 - can see that we've got different libraries
that are targeted at working with archives,
11:05 - we've got some cryptography libraries, database
drivers, continuing to go down, we've got
11:09 - some things for working with HTML, and network
traffic. Now, some things that you might find
11:14 - missing here are we don't have any GUI libraries.
That's because at this point go really isn't
11:19 - focused on the use case of client application
development. So go is really targeted at building
11:24 - servers and web applications. And so that's
where a lot of the libraries are going to
11:28 - be focused on. There are some projects that
are working on mobile applications using go
11:33 - as well as client side applications using
go but they're not officially supported at
11:37 - this point. If we come over to the project
link, we're going to find some information
11:40 - about history of the project, what releases
have come out and when, as well as some links
11:46 - to mailing lists and resources that you can
take advantage of. If you want to keep track
11:51 - of the development of go as a language as
well as if you find an issue in the go language,
11:56 - you can see some information here on how to
report that issue. And then we've got the
11:59 - Help link here. And this is going to be one
of your more important links as you get started
12:03 - here because this is going to be your on ramp
into the community. Now the two most active
12:07 - in my experience are the go forum, which is
a nice discussion forum that allows you to
12:11 - post your questions and get people to answer
back. But if you want something a little bit
12:15 - more real time then the gopher slack is a
Slack channel specifically targeted at NGO
12:20 - development. And there's multiple sub channels
in there for new developers for library developers.
12:25 - Even a lot of the NGO meetup groups have their
own sub channels on the gopher slack. So if
12:30 - you want to get on the gopher slack that I
would encourage you to come over here to another
12:33 - website called go Lang bridge. And this is
what I consider the on ramp to the NGO community.
12:39 - Because NGO Lang bridge is specifically there
to advocate for the go language, and to make
12:43 - sure that the community is healthy and strong.
As I said, one of the key aspects of the go
12:47 - language is a focus on having an excellent
community. And really, it's go Lang bridge
12:52 - and the awesome people that support it, that
are making that happen. So if you scroll down
12:57 - a little bit, you can see some links to the
online communities. If you want to join the
13:00 - Slack channel, you do have to receive an invite.
So this link here is going to take you to
13:04 - the forum that's going to allow you to get
that invitation. And there's no problem getting
13:08 - the invitation, the only thing that they asked
you is to read the community guidelines, there
13:12 - is a code of conduct that just make sure that
everybody is going to be treated respectfully
13:15 - in the community, just to make sure that we're
all here trying to help each other out. And
13:19 - the last thing that I want to show you on
the website is this play link here. Now this
13:23 - link just flies out an editor. And this is
really nice, because this is available throughout
13:27 - the site. So if I come to the packages, and
let's just say I dive into the network package,
13:34 - and I'm learning about some network function,
then I can go ahead and pop into the play,
13:37 - I can create a real quick proof of concept
go application in order to make sure that
13:41 - I understand how that's working. And again,
just like we saw on that homepage, if I click
13:45 - run that I can go ahead and execute that.
Now there are some limitations, obviously,
13:50 - this application is sent to the back end.
And there are some limitations, you're not
13:54 - gonna be able to read the file system at the
back end, for example.
13:56 - But a lot of the things that you want to play
around with, you can play around with in this
13:59 - online environment. Now another place to get
at this playground is over here at play that
14:05 - golang.org. And this is the last thing I want
to show you in this introductory video. So
14:10 - this is going to be the environment that we're
going to focus on. And actually, let me make
14:13 - that a little bit bigger. So maybe it's a
little easier for you to see. But this is
14:16 - going to be the environment that we're going
to focus on as we start to learn the go language.
14:20 - So we're going to learn the basics of go application
here, we're going to start playing around
14:23 - with how we're going to work with variables
and logic and looping and things like that.
14:27 - Now, eventually, we'll get to installing a
local environment. And you can certainly take
14:31 - advantage of the other resources on go Lang
website, if you want to get there before I
14:34 - create a video on it. But I think that there's
a lot that we can talk about without making
14:39 - a commitment to setting up a local development
environment by just going through this playground
14:43 - here. So if we take a second look at this
application, we see some of the key aspects
14:47 - of any go program. And the first thing that
you see at the top is this statement package
14:51 - main. Every go application is structured into
packages. So every go file that you're going
14:56 - to have is going to have to declare what package
it's a part of nain is a special package,
15:02 - because main is going to be the entry point
of any one of your applications. Down below
15:07 - that we have an import statement. And this
is the statement that we're going to use in
15:11 - order to import additional libraries. So this
library is called thumped, which Yeah, you
15:16 - actually say that in the NGO community, I
can't bring myself to say that. So if I call
15:19 - that FMT, I hope that you'll forgive me. But
in the NGO community, you will often hear
15:23 - this called thumped. And this is the package
is going to allow us to format strings. So
15:28 - you see down below here and our main function,
which is the entry point of our application,
15:33 - so the main function in the main package is
always going to be our application entry point.
15:37 - And this is going to be where we're going
to contain our first code that's going to
15:40 - run in go. So we're going to call into the
FMT library. And we're going to pull out its
15:45 - print ln function, and that print ln function
takes one argument, and that argument in this
15:50 - case is a string. So we're going to print
out Hello playground. Now if I go ahead and
15:54 - run this, then down below at the bottom of
the screen, here, you see Hello, playground
15:58 - gets printed out. And then it says program
exited. If we have an error in the application,
16:03 - say if I delete this quotation mark and run,
then you're going to get a compiler error
16:07 - printed out at the bottom, that's going to
help you debug your application. So this online
16:11 - environments going to be very good for you
to get started, because it's going to help
16:15 - you through understanding what's going on.
So for example, we see here in line eight,
16:19 - it got an unexpected semi colon or new line,
when instead it was expecting a comma or a
16:24 - parenthesis. And the reason for that is because
this closing parenthesis actually became part
16:28 - of the string. So the line terminated early,
and it didn't have an end to the function
16:32 - call. So if we go ahead and re add the quotation
mark, and run, we're good to go. And we've
16:37 - got our first start in a go application. So
I hope that this was helpful for you a little
16:42 - bit of background in a language that you're
going to be learning I always find is a little
16:45 - bit valuable, it helps to understand the motivations
for the creation of the language and the major
16:50 - features, in order to understand what problems
that language is going to try and solve and
16:54 - how it's going to go about trying to solve
them. What I want to show you is how to get
17:01 - started setting up your own local development
environment to program with go. Now I know
17:07 - in the last video, I showed you this website
here, and I said that this is what I want
17:11 - to use. That is the website it played@golang.org.
And I said that this is the website that I
17:16 - want to use in order to show you a lot of
concepts that you're going to need to be familiar
17:20 - with with the go language. And that's still
my plan. But as I thought about it, I decided
17:24 - that it doesn't really make sense to force
you to use the playground, just because it's
17:28 - a really good place for me to demonstrate
concepts. So I want you to have all the tools
17:33 - available to you to set up your own local
NGO development environment. So you can play
17:37 - around with creating your own applications
as you learn about this wonderful language.
17:41 - So the first thing that we're going to need
to do is we're going to need to download and
17:44 - install the go language in the go tools itself.
And so in order to get started with that,
17:49 - we're going to start over here@golang.org.
And we're going to click on this download
17:52 - go link here.
17:54 - Now this link is going to take you to all
sorts of different versions of go. But in
17:58 - general, if you're getting started, just pick
the latest stable version that's available
18:01 - for you, and it's not going to steer you wrong.
Now, if you're a Windows user, then I would
18:05 - encourage you to click this MSI link, it's
going to download an installer and go is going
18:09 - to be put on your system automatically. However,
if you're using os 10, or Linux, then I would
18:14 - recommend that you go to this installation
instructions link here and follow the instructions
18:19 - here. Now, you're still going to need to download
the go binaries. But if you scroll down just
18:23 - a little bit, you're going to see this command
here. And this is going to give you the tar
18:26 - command that you're going to need to use in
order to unpack the go binary and install
18:30 - it onto your system. So I've already done
that. And I can show you that by opening up
18:35 - a terminal here. And the default location
to put go is in the user directory underneath
18:40 - local and then in a folder called go. So if
we look at there, and they look at the contents
18:46 - there, I see that I have all the go tools
installed. So with the Windows Installer,
18:50 - all it's going to do is it's going to place
these into C colon backslash go. And I would
18:54 - strongly encourage you if you can accept these
default locations that you go ahead and do
18:58 - that because it's going to make setting up
your environment just a little bit simpler.
19:02 - Now after we get go installed, we have a little
bit of configuration in our environment in
19:06 - order to be able to use go effectively. So
I'm going to come back to my home directory
19:10 - here. And I'm going to make a change to my
bash RC file. Now I'm on Ubuntu. So it's going
19:15 - to be in my bash RC file. If you're an LS
10, it's going to be your bash profile. If
19:20 - you're in Windows, basically what we're doing
is we're setting environment variables. So
19:24 - if I open that up and come down to the bottom,
then I see that I've got the pre generated
19:28 - bash script. I'm not going to really worry
about that. But there's a couple of variables
19:31 - that we're going to need to set. Hello, everybody,
I need to pause the video here for a second
19:38 - and make an important announcement. So as
soon as I originally released this video,
19:42 - Dave cainy came in within a couple of minutes
and he expressed a concern about one of the
19:46 - things that I'm about to talk about. Now I'm
about to talk about setting a couple of environment
19:50 - variables here and showing you how they work.
Now one of those variables is called go route.
19:55 - And setting go route has been shown to cause
problems as you move through different versions.
20:00 - Go, especially if you've got multiple versions
of the language on your system. So if you
20:05 - want more information about that Dave has
a really good blog post here that you can
20:08 - go to to learn more information about it.
But for now, please keep in mind, if you're
20:13 - able to install go at its default locations,
which on Unix or Mac is going to be slash
20:18 - user slash local slash go in on Windows is
going to be C colon, backslash go. If you're
20:23 - able to do that, please do that. And then
go ahead and avoid setting go route. Now you
20:28 - will need to set the PATH variable to go roots
bin directory in order to access the go executable.
20:34 - And you will need to set go path which we're
going to talk about after that. But if you
20:38 - can avoid setting the go route environment
variable, it's going to save you a lot of
20:41 - heartache. So well, I'm going to show you
how to do that in case you do need to set
20:44 - it please avoid that if at all possible. Okay,
at this point, I'm going to resume the video
20:49 - and continue talking about the environment
setup. Now the first variable that you're
20:53 - going to need to know about is called go route.
Now, if you've installed go to its default
20:58 - location, you're not going to need to worry
about this. But if you've decided to install
21:01 - go somewhere else, for example, maybe you've
installed it in your home directory, then
21:05 - you can go ahead and set go route. And that'll
tell the environment where to go to find the
21:09 - go binaries. Now the next thing that we want
to do is we actually want to set a PATH variable
21:14 - to the go binaries themselves. So I'm going
to go ahead and export a PATH variable. And
21:20 - that'll Of course, start with my existing
path. And then I'm going to add on to that
21:25 - go route. And then I'm going to whack on the
path slash bin. So there's quite a few binaries
21:30 - that we're going to be using on a regular
basis. And those are in go route slash bin,
21:34 - so you're going to want to make sure that
that's part of your path. Now once I do that,
21:37 - let me go ahead and save this. And then I
will use the source command in order to get
21:43 - my shell to reread the bash RC file. And then
I should be able to test to make sure it goes
21:48 - available by typing go and version. And you
can see here I'm running go version 1.8 release
21:54 - candidate three.
21:55 - Okay, now there's one more thing that we need
to do in order to get our environment fully
21:59 - set up. And I'm going to go back into my bash
RC file in order to do that. And that is the
22:04 - setting of a second environment variable.
So we have go route. And that's going to tell
22:08 - the environment where goes installed. But
we're also going to be downloading a lot of
22:12 - packages as we work with go, because we're
going to be taking advantage of libraries
22:17 - that other people have published in order
to build our own applications out. So those
22:21 - applications as well as our own source code
are not going to be located with the go binaries,
22:25 - they're going to be located in a path that
we're going to specify with a another variable
22:29 - called go path. Now go path is either one
of the most awesome or one of the most horrible
22:34 - things about go because it gives you this
really nice way to specify where you go projects
22:39 - are located. However, it does kind of push
you towards having this monolithic repository
22:44 - of all these binaries and your applications
tied together. So I'll show you a little bit
22:48 - of a hint on how to work with that. But for
now, let's go ahead and set a go PATH variable
22:53 - in my home directory. And then I will call
this go lib. Now just like with go route,
22:58 - we might have some executable binaries that
are going to be stored in our gopath. So I'm
23:02 - going to go ahead and export on our path again.
And we'll start with our existing path. And
23:07 - then I want to add on go path slash bin. That
way if we install any libraries that have
23:13 - executables, and we will be installing libraries
that have executables, then we're going to
23:17 - be able to track that. Now just to show you
real quick what that's going to do. Let me
23:20 - go ahead and save this out resource, my bash
RC file. And then I've actually already created
23:27 - this folder here called go live. Now if I
go into go lib, and I look at the contents
23:31 - of that it's currently empty. But I can change
that by using a tool called go get. So if
23:37 - I get a library that's at github.com slash
NSF slash go code. This is historically the
23:43 - library that people use to provide autocomplete
functionality in their go applications. So
23:48 - if I go ahead and hit Enter, and wait a second,
then go back into my go lib folder. And look,
23:56 - now I've got some content here. So if I look
in the bin directory, I've got this go code
24:00 - executable. And if I come back to the source
directory, then I see that I've got this GitHub
24:06 - comm folder. And inside of that is NSF. And
inside of that is go code. So if I come in
24:12 - here, here's all of the source code for the
go code library. So when I'm working with
24:17 - go code, it actually downloads the source
code and compiles it into the go code library
24:21 - for me. And that's what that go path is going
to do for you. The problem that you might
24:25 - run into is that this use of gopath tends
to drive towards monolithic repository. So
24:30 - you're going to have go code, you're going
to have your own code, you're going to have
24:33 - all sorts of other libraries, all put into
this one location. Now when I create my courses,
24:38 - that creates a lot of visual clutter. And
so that isn't exactly the form of gopath that
24:42 - I use. What I do is coming back into my bash
RC file is I actually use a capability of
24:48 - gopath to create a compound gopath. So instead
of a single path here, I'm actually going
24:54 - to re export go path and I'm going to add
on an additional path to this and I'm going
24:59 - to add Home mic and code. Now a lot of times
when I'm teaching courses, I only need to
25:04 - go pants. And so I've got go live. And that's
going to be where all my third party libraries
25:08 - go. And then I'm going to have another folder,
that's going to be what's called by workspace
25:12 - location. So let's go ahead and write this
out. We'll source this again. And now I've
25:18 - got the full gopath. So if I come into my
NGO lib, and I remove everything from it,
25:23 - now it's empty again. So if I go ahead and
go get that repository, again@github.com slash
25:30 - NSF slash go code. And now you see that it
actually goes into my go lib folder. If I
25:35 - come into my code folder, which I also created
earlier, that's still empty. So the first
25:40 - segment of your go path is going to be used
by go get in order to store your files, but
25:45 - all of the segments of your go path are going
to be searched for source code. So that's
25:49 - going to really help us as we're setting up
our workspace. So speaking of which, that's
25:55 - the next thing that I want to do. So a workspace
in go isn't anything special, the only thing
26:00 - that you need in order to create a workspace
is to have a single directory called SRC in
26:05 - it. So if I add a directory called SRC into
my code folder, then I've got to go workspace.
26:11 - Now SRC, as you might expect, is where you're
going to keep your source code. So when I
26:15 - set go path to slash home slash Mike slash
code, it's going to look for an SRC directory
26:21 - in order to find my source code. Now, there
are two other directories that you might find
26:25 - in a workspace that are interesting. And we
found one already when we installed that go
26:29 - code library. And that's been. So anytime
we're working with a project and a binary
26:34 - is created, it's going to be put into that
bin directory. And that's also why we added
26:38 - that bin segment to our path,
26:40 - the last directory that you might find in
your workspace is a pkg directory. So for
26:45 - compiling something, and it's going to generate
an intermediate binary, which means it's not
26:49 - going to be a fully compiled application,
it's going to be an intermediate step. So
26:53 - for example, if we're taking a third party
library, and we're integrating that into our
26:57 - application, then the pkg directory is where
those intermediate binaries are going to be
27:01 - stored. And the reason those are created is
so that they don't have to be recompiled every
27:05 - time. So when you compile your go application,
go is going to check to see if any of the
27:10 - source files in that directory have changed
since the last time it compiled them. If it
27:15 - hasn't, then it's not going to recompile that
package, it's just going to go ahead and link
27:18 - them into the binary that it's creating for
you. Okay, so let's go ahead and clear this
27:22 - out. Because that's getting a little bit cluttered.
And now let's set up an editor to work with
27:27 - go code. Now, there's a lot of editors that
are out there. And so what I'm going to show
27:31 - you is just one, but feel free to explore
the option for your favorite editor, because
27:36 - there's probably a go plugin for it. And all
of these plugins are really good right now.
27:40 - So I'm going to show you the one that I've
been using lately, which is Visual Studio
27:44 - code, now might be a little bit surprising
Microsoft, oh my goodness, they're doing all
27:47 - this really awesome stuff for the open source
community. But it's really true, one of the
27:51 - best development experiences that you're likely
to come across with go is in this Microsoft
27:55 - product
27:56 - running on Linux. So I've already installed
it. But if you do need to install it, you
28:00 - can come here to code Visual Studio Comm.
28:03 - It's going to give you the binaries. In this
case, I'm running Ubuntu. So I would download
28:07 - this.db file and install that onto my system.
And then I'm going to be able to run that
28:12 - by simply typing code in my application launcher,
or I've already set up a shortcut over here
28:18 - in my taskbar. So as soon as I run that, I'm
going to be presented with this. Now you can
28:22 - see I've already opened up a folder here,
you can open up a folder to your workspace
28:26 - by simply file open, and then pick your folder
that you want to be working with. So we're
28:32 - going to be working with code. But there is
one setup step that I need to go through before
28:36 - Visual Studio code is quite ready to go. And
that is I need to install the plugin that's
28:40 - going to allow us to work with go code. And
so if I click this button down here called
28:44 - extensions, then I have a list of all sorts
of extensions that I can add in for Visual
28:48 - Studio code. Now, right here is the go extension
by Lu COVID. Now there's a couple of go extensions,
28:54 - but I would strongly recommend you use this
one here by Luke, because it is really amazing.
28:58 - It offers a lot of capability, it really makes
Visual Studio Code of first class environment
29:03 - for developing go, okay, and as fast as that
that's been installed. And it was that fast,
29:07 - because it's been cashed from earlier. And
then I'm all set and ready to build my first
29:11 - go application. So let me go ahead into this
source directory. And I'm going to create
29:16 - a folder that's going to contain my source
code. Now your first temptation might be to
29:20 - just plug in your source code right here in
your src folder. But I wouldn't recommend
29:24 - that the standard structure that you're going
to use in a go application is to mirror where
29:30 - your application is going to be in source
control. And that makes it go gettable. So
29:34 - in this case, if I was going to keep this
file on GitHub, I would create a folder called
29:39 - github.com. And then underneath that, my GitHub
account is vi n si Mk II don't ask long story
29:47 - about why I called it that. And then I would
have an application name. So I would call
29:51 - this maybe first app, and that's the folder
that I'm going to store my application in.
29:55 - And the reason for that is if you think about
if I check this into GitHub, and observatory
30:00 - called first app, when I go get that, it's
going to recreate this structure. And so you
30:05 - want to create your applications following
that structure. So now I'm ready to create
30:09 - my first file, and I will call that main go.
And then I can start adding in my source code.
30:15 - So the first thing that I'm going to add is
package main. And then when I save this, oh,
30:20 - it looks like I expected something to happen
here. And it's not happening. I think it's
30:24 - because yeah, he told me that I needed to
reload the environment. Good. So I'm going
30:28 - to go ahead and do that. So I'm going to exit
out of Visual Studio code, and it should kick
30:32 - right back off, but it has to initialize the
plugin. So now I see what I was expecting
30:36 - to see. And that is that the NGO plugin has
recognized that they don't have all the tools
30:41 - that it needs in order to provide me all the
support that it can, because the NGO plugin
30:45 - for Visual Studio code is actually like a
lot of the plugins and other languages, it
30:50 - takes advantage of these language services,
for example, it's talking to me about go land,
30:54 - go lint isn't available on my system. And
so it's not going to be able to provide linting
30:59 - capabilities. So basically, the go plugin,
cause up to all these language services. The
31:03 - nice thing about that is if you decide to
flip between different editors, your experience
31:07 - is pretty much the same, because they're all
relying on the same language services in order
31:10 - to provide you the capabilities that you have
31:12 - something go ahead and install all. And you
can see there's a pretty long list of
31:19 - libraries that it's installing for me. Okay,
and now they're all installed. So that took
31:23 - about a minute to install all those dependencies.
So I expect that you'd probably have a similar
31:28 - experience in your own environment. Now, before
we start adding anything else, I actually
31:33 - put some quotation marks around this package,
that's not going to be correct. And now I'm
31:37 - ready to start actually building out my program.
So let me go ahead and put in an import statement
31:41 - here. And we haven't talked too much about
imports. But we have mentioned a little bit
31:44 - about packages, packages, or how code is organized
into sub libraries inside of NGO. So for example,
31:50 - if I want to build a web application, then
I might pull in the net HTTP package that
31:54 - you see here, in order to set up my web request
handlers. But for now, I just want to do a
31:58 - simple Hello, go example. And so I'm just
going to import the FMT package. But you notice
32:04 - that the NGO plugin for Visual Studio Code
gives me autocomplete, so any library that's
32:08 - available on my go path is going to be found
here. So now I'm going to create a simple
32:13 - function called main. And inside of that,
I'm going to access the FMT package. And notice
32:18 - that I get autocomplete functionality here.
So I can go ahead and say I want to call the
32:23 - print ln function, and it gives me the signature
for that function. So I can go ahead and add
32:28 - that in here. And the I just want to say hello,
go. Okay, so in order to run this, inside
32:34 - of Visual Studio code, you do have the ability
by pressing Ctrl backtick, you can open up
32:38 - a terminal right here inside of the editor.
And there's a couple of different options
32:42 - that I have in order to run my application.
So the first thing that I can do is I can
32:46 - use gos run command, as you see here, and
I can give the path all the way through to
32:50 - my source code. So if I come and I just keep
tapping through, then I'm going to get source
32:56 - slash github.com, slash vianne, si MKE slash
first app slash main.go. So if I run that,
33:02 - then it will compile that temporarily, and
run that for me. And it also compile in any
33:07 - third party libraries. So the FMT package
was compiled in as well. Now, that's a really
33:11 - good way to get a really quick run. Another
way that you have available to you is to use
33:15 - go build and go build takes the actual package
path. So all we're going to do here, is compile
33:21 - the first app package. Now, if it finds a
main package with a main function, then it's
33:27 - going to compile that as an executable, like
you see right here in my home directory. So
33:31 - I can go ahead and run that. Now the last
build tool that I have available is go install,
33:37 - go install is actually expecting to be pointed
to a package that has an entry point. And
33:42 - it's going to install that into your bin folder.
So let's go ahead and see that work. So we'll
33:46 - go to github.com, my username for GitHub,
and then first app again. So notice I'm using
33:53 - the package address, I'm not using the folder
path. If I run that, notice, I don't get anything
33:59 - in my main directory. But if I come into this
bin folder here, now I've got first app over
34:04 - here. So if I come back to my terminal, bin
slash first app, run that I get Hello, go
34:09 - printed out again. Okay, so the last thing
that I want to show you if I come back over
34:12 - to the terminal, so you see how we have all
the packages that we're working with locally
34:16 - over here in this code directory. If I come
to the first element of my go path, which
34:20 - is go lib, and look at that, you'll see that
this is starting to become a pretty busy place
34:25 - here. Because now I've got three source folders.
And if I come into GitHub comm, you'll see
34:30 - that I've got quite a few packages. So now
all of these third party dependencies aren't
34:35 - cluttering up my main workspace. They're all
in this go lib folder, and then I can focus
34:39 - on my development in my code folder. Now the
last place that you're going to see packages
34:45 - is over in the NGO installation directory.
So if I look in that folder, you see here
34:50 - that I have this directory called source.
So the ghost source code itself is in fact
34:55 - a valid go workspace. So if I come in here
look If the folders in here, you see, these
35:02 - are exactly the go standard library. So here's
FMT. Here. You see if I scroll down a little
35:07 - bit the net package, if I go into the net
package, you'll see that that contains the
35:13 - HTTP package. If I come into the HTTP package,
and list those contents, you see all of the
35:18 - source codes for all of the modules that you
can see over here at go. Lang Comm. So if
35:23 - I follow that through, over here, scroll down
to net, and HTTP, you see all of the capabilities
35:34 - that are available in here? Well, all of those
are provided by this source code here. So
35:39 - if you have any questions about how any one
of those libraries work, or how something's
35:43 - configured, you can jump right into the source
code and see how it's all put together. Over
35:47 - the last couple of videos, we've laid some
foundation by talking about the history and
35:51 - the features of go and working through setting
up the local development environment. What
35:55 - today is the day that we're going to start
a discussion about the go language itself
35:58 - by discussing how to work with variables.
So in order to fully cover how to work with
36:03 - variables, there's several topics that we're
going to need to cover. We're going to start
36:07 - by learning how to declare variables. Then
we'll move into a discussion about how go
36:11 - considers read declaration variables. And
this concept of shadowing. After that, we'll
36:16 - talk about visibility, where we're going
36:18 - to learn how we can control what aspects of
our program can see a variable that we create,
36:23 - then we'll talk about naming conventions.
And finally, we'll wrap up with a brief discussion
36:27 - about how to convert variables from one type
to another. Okay, so let's go ahead and get
36:32 - started. So I'm going to be using the playground
in order to host our conversation. That way,
36:37 - you can follow along whether you've set up
a local development environment, or just want
36:41 - to follow along online. So as you can see,
when we first load up the playground, we've
36:45 - got this one statement program, which is just
printing out the string hello playground to
36:49 - the bottom of the screen, when I click this
run button here. Now this statement can only
36:53 - ever do one thing because we're passing in
a string literal. And similarly, if I pass
36:57 - in the number, say 42, and run it, then we
print 42 out. Now no matter what we send to
37:03 - this print ln function, it's only going to
ever do that one thing. So in order to provide
37:07 - a little bit more flexibility to our application,
we're going to introduce variables. So there's
37:12 - actually three different ways to declare variables
and go and we're going to go through each
37:15 - one of those. And then we'll talk a little
bit about where you might use each format.
37:20 - So the first thing that we can do is actually
declare the variable itself. And that'll be
37:24 - done using this kind of a statement. So we're
going to start with the var keyword, then
37:27 - we're going to have the name of the variable
and the type of the variable. Now if you come
37:31 - from another strongly typed language, this
might look a little bit backwards, because
37:34 - you might be expecting to see something like
int i. Well, that's not actually how go works.
37:39 - And if you think about it, the way gos structures,
things actually looks more like how you read
37:43 - it. So I'm going to declare a variable called
I that's going to be of type integer. So the
37:48 - way you declare variables and go, it's pretty
much the same way that you speak. And so it
37:52 - might look a little bit odd when you first
start working with it. But it very quickly
37:55 - becomes intuitive. Now that we have our variable
declared, we can go ahead and assign a value
37:59 - to it. And we'll do that simply with the equals
operator. So once we have that set, we can
38:03 - go ahead and replace this with an AI, run
it and we print the value 42 out. And since
38:09 - variables in go can vary, we can go ahead
and change the value of that to say 27. When
38:14 - we run again, we get the value 27 printed
out. So now even though the statement can
38:19 - only ever do one thing at a time, the program
that runs up above this FORMAT statement can
38:24 - actually influence the value that's printed
out to the console. Okay, so let's go ahead
38:29 - and get rid of this, and then explore another
way to initialize this variable. Because one
38:33 - of the things that we trying to do and go
is we want to keep things simple. So if we
38:37 - need multiple lines, then we'll go ahead and
do that. But we don't want anything to be
38:41 - more verbose than we have to. So we can actually
combine these two lines in one like this.
38:47 - So we can initialize the variable i as an
integer and assign the value 42 in the same
38:52 - line. So if we go ahead and run this, then
no big surprise, we get the value 42 printed
38:56 - out. Now, this is actually still making us
work a little bit harder than we need to.
39:01 - Because since we're assigning the value 42
to this, the go compiler can actually figure
39:06 - out what data type it needs to have. So we
can go ahead and tell it to figure this out
39:11 - for us by replacing all this text with this
text here. So if we just say I and then use
39:17 - this colon equal operator and the value 42,
and run this, then we get this really nice
39:23 - concise way of setting things up. Now, where
are you going to need each one of these? Well,
39:29 - let me go ahead and add them back in so we
can talk about them. So we'll set var I integer
39:34 - i equals 42. And then we'll use var j integer
equals 27. And then we'll set up K and that's
39:43 - going to be equal to
39:44 - 99.
39:46 - So we have these three different formats.
So when are you gonna want to use each one
39:49 - of these? Well, the nice thing about this
first format is there are going to be times
39:54 - when you want to declare a variable but you're
not ready to initialize it yet. So for example,
39:58 - if you want to declare variable in the scope
of this main function, and then you have a
40:02 - loop or something like that, that sets up
a local variable scope. And that's where the
40:06 - variable is actually going to be assigned,
then you can go ahead and use this first syntax.
40:10 - The second syntax is valuable, if go doesn't
have enough information to actually assign
40:15 - the type that you really want assign to it.
So to show that, let me go ahead and add another
40:20 - print statement here. And I'm going to need
to come up these other lines out in order
40:24 - to make things happy for us. So let me go
ahead and change this print ln to a print
40:29 - F. And what this is going to do is it's going
to allow us to provide a formatting string
40:32 - and print things out that way. So we'll print
out the value, and then I'll print out the
40:37 - type of the variable, and then I'll pass in
j twice. And so if I run this, then we get
40:42 - the value 27. And no big surprise, it's an
integer. But what if we want this to be, for
40:48 - example, a floating point number? Well, with
this syntax, it's as simple as just changing
40:52 - this to float 32. When we run this, then go
understand that we want to use 27 as a floating
40:58 - point number. Now, if we tried that with K,
down here, so let me uncomment the K, switch
41:06 - this over to use K and run, then you see that
the number 99 is inferred to be of type integer.
41:12 - And we can influence that a little bit by
adding a decimal point. And that's going to
41:16 - give a hint, making that a float 64. But there's
no way to use this colon equals syntax to
41:22 - initialize a float 32. For example, go is
either going to decide it's an integer type,
41:26 - or it's a float 64 type. So if you need a
little bit more control than the second declaration,
41:31 - syntax is going to be valuable for you. Now
the next thing that I want to show you is
41:35 - how we can declare variables. Now we've been
declaring variables one at a time and inside
41:39 - of a function. Well, another way that you
can declare variables is up here at the package
41:44 - level. Now when you're doing it at the package
level, you cannot use this colon equals syntax,
41:48 - you actually have to use the full declaration
syntax. So we can declare a variable is an
41:54 - integer set equal to 42. So that works, come
down, wipe out this code, and then replace
42:01 - this with I. And you see that we have the
value 42. And it's of type integer. So just
42:08 - like we have before, we can go ahead and tell
it to declare that as a float 32. And the
42:13 - compiler recognizes, well, I can make 42 a
floating point number, that's not going to
42:16 - be a problem at all. Now, of course, if you
try something like this, the compiler has
42:21 - no idea how to convert the string food to
a floating point number, and so it's going
42:25 - to fail on you. Another thing that we can
do at the package level is we can actually
42:29 - create a block of variables that are declared
together. And to show you why that's valuable.
42:34 - Let me just drop in some variables that we
can play around with. Okay, so as you can
42:38 - see, I've got a little bit of Doctor Who has
a brain here, and say I'm writing a program
42:42 - that's going to print out some information
about the doctor's companions. So here we
42:45 - got a variable actor name, that's going to
be Elisabeth Sladen, then we got her companion
42:50 - name, which doctor she worked with, and what
season she was on. So by declaring these variables
42:54 - like this, things are actually a little bit
cluttered. Because again, we want things in
42:58 - go to be as clear and concise as possible.
So all these var keywords are actually cluttering
43:03 - things up a little bit. So what we can do
instead of this is actually wrap this whole
43:08 - section with a VAR block. And then we can
actually get rid of the use of this var keyword.
43:17 - And now all of these variables are going to
be declared because they're inside of this
43:21 - var block. And we can actually show that they're
related somehow. Now they don't have to be
43:25 - related. That's a design decision. But we
can do that. So if we had another set of variables
43:30 - that were related to a different context.
So say, for example, we had a counter, and
43:34 - that was going to be an integer initialized
to zero, then we can have multiple variable
43:38 - blocks at the package level. And that's just
going to allow you to organize your application
43:42 - a little better, and keep your code a little
bit cleaner. Now the next thing that I want
43:46 - to show you and let me just drop in some code
here is how variables work when you're trying
43:51 - to read Eclair them.
43:52 - So you can see in this application, we're
declaring the variable i up here in the package
43:56 - scope, then I'm declaring it here inside of
the main function, and then I'm re declaring
44:01 - it here on line 11. Now, if I try and run
this, I'm actually going to get an error.
44:07 - And the error comes on line 11 here, because
there's no new variables here. So I can reassign
44:12 - the value of i 13. But I can't declare a new
variable here. And that's because the variables
44:19 - already declared on line 10. And you can't
declare the variable twice in the same scope.
44:24 - However, if I get rid of this line, notice
that the application runs just fine, and uses
44:29 - the value 42. So even though I is declared
twice in my application, once at the package
44:34 - level, and once inside of the main function,
that's okay. And what happens is that the
44:40 - variable with the innermost scope actually
takes precedence. So this is called shadowing.
44:44 - So the package level is still available,
44:47 - but it's being hidden by the declaration in
the main function. And I can actually show
44:50 - that by copying this line up here
44:54 - and running this. And now you see I get 27,
which is the package level scope. Then I create
44:59 - the shadow Variable setting equal to 42. And
when I print out I again, then I get the new
45:04 - value of i. Now another interesting thing
about variables in go is that they always
45:09 - have to be used. So let me just drop in this
example here. And let's walk through it. So
45:14 - I'm declaring a variable, I'm setting it equal
to 42, then I'm instantiating, a variable
45:18 - j, setting it equal to 13. But I'm only using
i. So what happens when I run this? Well,
45:24 - if I do, I actually get yelled at, because
j is declared and not used. And this is one
45:29 - of the things that's going to keep your go
applications nice and clean. If you have a
45:33 - local variable that's declared and not used,
then that's actually a compile time error.
45:39 - And the reason that's really valuable is as
your application grows and evolves, and new
45:43 - features are added and old features are deprecated,
you're very likely to end up with some old
45:48 - code hanging around inside of your functions.
Well, if any of your old code or variables
45:53 - and those variables are no longer used, then
the compiler is going to detect that for you
45:57 - see that you can make sure that you can clean
those out. Now another important thing to
46:00 - know about when you're working with variables
is how to name them. And there's actually
46:04 - two sets of rules that you're going to need
to keep track of. One is how naming controls
46:09 - visibility of the variable and go. And the
other is the naming conventions themselves.
46:14 - So notice that I've been creating lowercase
variables. Well, that actually isn't always
46:18 - the case in NGO, because if I'm declaring
a variable, and let's just declare it at the
46:23 - package level, and I declared as an integer,
with the name I, and I go ahead and work with
46:29 - that, then that lowercase variable name actually
means that this variable is scoped to this
46:35 - package. Now, this is a main package. And
so this doesn't really matter so much. But
46:39 - when we get into working with packages, this
becomes extremely important. So lowercase
46:44 - variables are scoped to the package, which
means anything that consumes the package,
46:48 - can't see it and can't work with it. But if
I switch to an uppercase letter, then that's
46:55 - what's going to trigger the go compiler to
expose this variable to the outside world.
47:00 - So it's a very simple naming convention. And
there's really only three levels of visibility
47:03 - for variables in go. If you have it at the
package level, and as lowercase is scoped
47:08 - to the package, so any file in the same package
can access that variable. If it's uppercase
47:14 - at the package level, then it's export at
the front of package and it's globally visible.
47:19 - And the third scope is block scope. So when
we have this main function here, it's actually
47:23 - establishing a block scope. So when we declare
this variable I write here on line 10, that
47:29 - variable is scoped to the block. And so that's
never visible outside of the block itself.
47:35 - Now beyond that, it's important to understand
the naming conventions in go, and there's
47:38 - a couple rules that we need to follow. The
first is that the length of the variable name
47:43 - should reflect the life of the variable. So
for example, in this example, we're declaring
47:48 - a variable i, and we're using it right away.
So having a very simple variable name is perfectly
47:54 - acceptable. And this is going to be especially
true if you're declaring counters and for
47:58 - loops and things like that, it's very common
have single letter or very, very concise variable
48:03 - names, because the lifespan of that variable
is very small. And the amount of time that
48:08 - you have to keep the meaning of that variable
in your head is very small as well. However,
48:13 - if you're declaring a variable that you use
for a very long time, then it's best practice
48:17 - to use a longer name. So for example, if this
was going to represent the season number that
48:23 - our companion was on, so say, season 11. And
we use that throughout this entire main function,
48:29 - then we'd want to use a name something like
season number. Now, if you're working with
48:34 - a package level variable, and that package
level variable is going to be used in quite
48:38 - a few other places, then that's where you're
going to want to use the most verbose variable
48:42 - name. Now, you still shouldn't get crazy,
you shouldn't have 50 character long variable
48:46 - names if you can avoid it. So keep your names
as short as you can. But make sure that the
48:50 - names of those exported or package level variables
are clear enough so that somebody who's outside
48:56 - of that source file understands the meaning
of it. The other thing I'd like to talk about
49:00 - is how to work with acronyms, because in other
languages, you might see variables like the
49:04 - URL, and then maybe this is http google.com.
49:11 - You might see a variables name like this.
Well, the best practice and go is actually
49:15 - to keep these acronyms as all uppercase. So
if you're working with a variable called the
49:20 - URL, the URL should be all uppercase. Similarly,
HTTP and any variables like that. So anytime
49:27 - you see an acronym, make sure that that's
all uppercase. And the reason is for readability,
49:31 - it's very clear, we're used to seeing URL
and HTTP all put together. So when you read
49:36 - this variable, it's very clear that you're
talking about an HTTP. Maybe you're talking
49:41 - about an HTTP request that reads a little
bit cleaner than if you go ahead and make
49:47 - those lowercase. So just some rules to keep
in mind as you're creating variables. Now
49:52 - the next example that I want to show you is
how we can actually convert from one variable
49:56 - type to another. So notice that I have two
variables here. I've got variable i on line
50:01 - eight, and then I'm declaring as an integer
with the value 42. And then I've got this
50:06 - variable j, that's going to be a floating
point number. Now what I want to do is I want
50:10 - to actually treat it as a floating point number
and assign that value to J. So the way that
50:16 - I do that is using this conversion operator.
So if you look on line 12, it looks like float
50:22 - is being used as a function. And in fact,
it is. And this is a conversion function.
50:26 - So when I run this program, you see that the
first print statement on line nine, prints
50:31 - 42, as an integer, the second print statement
still prints the same value 42. But now it's
50:36 - been coerced into being a floating point number,
they have to be a little careful with this.
50:41 - Because if you go the other way, so for example,
if we go from a float 32 to an integer, and
50:49 - then I convert that and run it, it looks like
everything's okay. But keep in mind, a floating
50:56 - point number can have a decimal on it. So
now I've actually lost information to the
51:01 - conversion. So the important thing about this
is I have to explicitly convert, because if
51:06 - I just tried to do this, then I'm actually
going to get a compile time error, because
51:12 - go is not going to risk the possibility of
losing information through that conversion.
51:16 - So you have to do an explicit conversion,
when you're changing types. That way, it's
51:20 - your responsibility to understand if you're
losing information or not. Now, the other
51:24 - thing that's important to know is if I decide
to work with strings, it's a very common use
51:30 - case, to try and convert an integer into a
string, say, for example, you want to print
51:34 - it out to a log file. Well, if I run this,
I get a pretty odd result. The first line
51:40 - prints out Okay, 42. And that's an integer,
that's okay. But then I get an asterisk. That's
51:45 - of type string, what the heck happened there?
Well, in order to understand that, you have
51:49 - to understand how strings work with go, a
string is just an alias for a stream of bytes.
51:54 - So what happens when we asked the application
to convert the number 42 into a string is
52:00 - it looks for what Unicode character is set
at the value 42. And that happens to be an
52:04 - asterisk. So if you want to convert back and
forth between strings and numbers, then you're
52:07 - actually going to need to pull in the string
conversion package, which you can find on
52:13 - go Lang under packages. If you scroll down
a little bit, you see string conversion here.
52:18 - And this is going to expose all sorts of functions
that are going to make it a lot easier to
52:21 - convert back and forth between strings and
other data types. So in this case, what we'd
52:26 - want to do is use the string conversion packages
I to a function, which converts an integer,
52:34 - that's the I two, that's the two and then
to an ASCII string. So if we go ahead and
52:38 - run that, now you see that it properly converts
the integer 42 into the string 42, and prints
52:44 - it out for us. So if you need to work with
converting between numbers and strings, then
52:49 - go ahead and use that string conversion package.
But if you're converting between numeric types,
52:53 - just keep in mind, you can't implicitly do
that conversion, you have to explicitly do
52:57 - it. And if you need to do that, then you can
go ahead and use the type as a function. Okay,
53:03 - so we just covered quite a bit of ground.
So let's go through a summary of what we've
53:06 - talked about throughout this video.
53:09 - Okay, there's quite a few things to keep in
mind as we're working with variables. So let's
53:14 - go through and review what we talked about.
The first thing that we talked about is the
53:18 - three different ways to declare variables.
So we saw that we could declare a variable,
53:22 - and then initialize it later, we saw that
we can declare it and initialize it at the
53:26 - same time. And then we also saw that we can
use this colon equals syntax as a shorthand
53:30 - version of declaring and initializing a variable.
And then we let the compiler decide what type
53:35 - to assign to that. Now normally, you're going
to use this third version, the only time you're
53:39 - really going to use the second version is
when the compiler is going to guess wrong.
53:43 - And then the first version is sometimes useful.
If you need to declare the variable in a different
53:47 - scope than you're actually going to initialize
it. We then talked about how we can't read
53:51 - declare a variable. So within the same scope,
we can't initialize that variable twice, but
53:55 - we can continue to reassign values to it,
but we can shadow them. So if we declare a
54:00 - variable in a package scope, for example,
we can read declare that in a function scope,
54:06 - and that's going to shadow the variable at
the higher level of scope. All variables must
54:09 - be used in a go application. So if you declare
a local variable, and that variable isn't
54:14 - used in the scope that it's declared or one
of its inner scopes, then that's going to
54:18 - trigger a compiler error. And you're going
to have to go back and clean that up before
54:22 - your application is going to run. And again,
the reason that that's really nice is as code
54:25 - evolves, and it continues to be refactored
and improved over time, and features get retired,
54:30 - you don't have all these old variables hanging
around and requiring allocations of memory
54:35 - when they're not being used for anything anymore.
We also talked about the visibility rules.
54:39 - The first thing that you need to know is when
you're working with package level variables,
54:42 - a lowercase first letter means that it's scoped
to the package, which means all of the source
54:47 - files that are in the same package have access
to that variable. If you have an uppercase
54:52 - first letter, then it's going to be exported
globally, and so anything can work with that
54:55 - variable at that point. There is no private
scope. So you can't scope it. variable to
55:00 - the source code itself. However, you can scope
a variable to a block by declaring it within
55:05 - the block instead of declaring it at the package
level. We also talked about the naming conventions.
55:10 - And there are really two naming conventions
that are used Pascal case, which basically
55:14 - means you uppercase, the first letter, and
camelcase. So when you're naming variables,
55:18 - you don't want to separate the words in the
variables with underscores. You don't want
55:22 - to have them all in lowercase, you don't want
to do anything like that. Just use standard
55:26 - Pascal or camel casing rules. The only exception
to that is if you're working with acronyms,
55:31 - all of the letters in the acronym should be
uppercase. The names of the variables should
55:35 - be as short as you reasonably can get them.
So you've got a very short lifespan of the
55:40 - variable, say, for example, a counter in a
for loop, then having a one letter variable
55:44 - name is perfectly acceptable. However, if
you've got a variable that's got a longer
55:48 - lifespan, say, for example, it's used in a
fairly long function, or if it's exported
55:52 - from the package, then having a longer more
descriptive variable name is certainly something
55:56 - that you should consider. However, please
don't go crazy. Keep those names as brief
56:00 - and concise as possible. And the last thing
we talked about are the type conversions and
56:05 - how these work a little bit differently than
other languages, a lot of other languages,
56:09 - you would have to put the type in params,
and then what you want to convert, in NGO,
56:13 - it acts more like a function. If we want to
convert an integer to a floating point 32
56:17 - number, then we use float 32 as a function,
and we pass the integer into it, and it's
56:21 - going to do the type conversion for us, we
also learned that go does not do implicit
56:26 - type conversion. So if you try and take a
floating point number and assign it to an
56:29 - integer, goes going to throw a compile time
error for that. And that's because of the
56:33 - possibility of losing information through
that conversion. So every time you're going
56:36 - to do a type conversion that might lose information,
you're going to have to do that yourself so
56:41 - that you're making the decision. And then
you can write whatever tests are required
56:44 - in order to make sure that information hasn't
lost. The final thing that we learned is when
56:49 - we're working with strings, then type conversions
can start to get a little bit weird. So in
56:53 - order to handle the conversion between integers
and strings, and other data types in strings,
56:58 - we can use that string conversion package
that offers a series of functions that make
57:02 - sure that the conversions happen the way that
we expect them to. In today's video, what
57:06 - I want to do is introduce the primitive types
that we have available in the go language.
57:09 - Now, we're not going to be talking about every
basic type that you can create. There are
57:13 - certainly collections and some more complicated
types. And we'll introduce those a little
57:17 - bit later. Today, I want to focus on three
categories of information that we can store
57:21 - and go. We'll start by talking about the Boolean
type, then we'll move on to the numeric types.
57:26 - And in that category, we have integers, floating
point numbers and complex numbers. And then
57:31 - we'll move on to the text types. Okay, so
fairly simple agenda, but we've got a lot
57:35 - to cover. So let's go ahead and get started
by talking about how we can work with boolean
57:38 - data in go. boolean data is probably the simplest
type of data that we can work with and go.
57:44 - And it represents two states, you either have
true or you have false. So in order to show
57:49 - you a simple example of working with Boolean
variables, we can create a variable here and
57:54 - make it of type bool. So that's the data type
that you're going to use when you're declaring
57:58 - a Boolean. And we can set it equal to A values.
So for example, we can set it equal to true,
58:03 - and then we can go ahead and print out using
our
58:05 - fancy printf statement here, we can print
out the value and type of this Boolean. And
58:10 - if we run that, we see that the Boolean true
is in fact got the value true. And its data
58:14 - type is Boolean. So we can also initialize
this to false, and run that. And now we see
58:21 - false is also a Boolean. Now there's a couple
of uses for Boolean variables in our applications,
58:26 - perhaps one of the most common is to use them
as state flags. So for example, say you're
58:31 - creating an application and you want to store
whether a user is signed up for notifications
58:35 - when a report is generated. Well, you can
use a boolean variable in order to store true
58:39 - if they want that report or false if they
don't. The other case. And perhaps the more
58:44 - common case for using Boolean and go is as
a result of logical tests. Now, we're not
58:49 - ready to talk about logical tests quite yet.
But I can show you how Boolean 's are used
58:54 - in those tests. So if we create a simple variable
here, and we use the equals operator to test
59:01 - if one equals one, and then create another
variable, and then I want to test if one equals
59:05 - two. Now, the double equals operator is called
the equals operator. And that's basically
59:09 - checking to see if the item on the left is
equivalent to the item on the right, so one
59:13 - obviously equals the number one, and one,
just as obviously doesn't equal the number
59:17 - two. So if we print out the value of those
using these two printf statements, then we
59:22 - see that a Boolean is actually generated as
a result of this equivalency test. Now when
59:28 - we get into talking about logical tests, we'll
see that there are actually quite a few other
59:31 - logical tests that we can use. But this is
a very common use case that we have. So we
59:35 - see looks like I need to add a new line operator
here, we see that the first operation does
59:41 - in fact, generate the Boolean true and the
second operation generates the Boolean false.
59:46 - Now the other thing that's important to know
about the primitives is that every time you
59:50 - initialize a variable, Ingo, it actually has
a zero value. So we're assigning the value
59:56 - of n and m in this example here, but what
happens is If I just do this and print out
60:02 - the value of that, well, in some languages,
that would be uninitialized memory, and we
60:07 - would have no control over what printed out,
when go, every time you initialize a variable,
60:12 - it has a zero value in the zero value for
Boolean is the value false. So you don't have
60:17 - to worry about initializing variables every
time. If the zero value is acceptable to you,
60:21 - you can certainly leave it like that. So Boolean
is a pretty simple. The next type that I want
60:26 - to get into are the numeric types. And these
are a little bit more complicated, because
60:30 - of all of the different types of numbers that
we can work with in our applications. Go has
60:35 - a rich array of numeric types to choose from.
Now, the first thing that we need to know
60:39 - about is the zero value. And the zero value
for all numeric types is going to be zero,
60:45 - or the equivalent of zero for that numeric
type. So let's start talking about the integer
60:49 - types. So the first type of integers that
we can work with are the signed integers.
60:54 - And those have several different data types.
So we have the general int, which is an integer
60:58 - of unspecified size. And I say unspecified
because every platform can choose to implement
61:03 - it as a different size. Now, the one thing
that you're guaranteed is regardless of your
61:08 - environment, and it will be at least 32 bits,
but it could be 64, or even 128 bits depending
61:14 - on the system that you're running on. And
this is going to be the default integer type.
61:18 - So if we do something like n equals 42, and
then we print out the type of n, then you
61:23 - see that we get the value 42. And it's of
type integer. Now, there are other types.
61:28 - So we can have eight bit integers, which can
range from negative 128 to 127. We can have
61:33 - 16 bit integers, which can go from negative
32,007 68, up to 32,007 67, then 32 bit integers,
61:40 - which can go from approximately negative to
positive 2 billion. And then if you need a
61:45 - really big number, you can go with 64 bit
integers. And those go somewhere between plus
61:50 - and minus nine quintillion. So if you need
bigger numbers than that, then you've got
61:54 - a very large application that you're working
with. And in that case, you're going to need
61:57 - to look into the big package from the math
library, which can handle arbitrarily large
62:01 - numbers. So you can't get a number big enough
for the big package to not be able to handle.
62:05 - Although working with numbers at large, you're
going to take a bit of a performance hit and
62:09 - the numbers aren't going to be quite as easy
to work with is using the primitive types
62:12 - that we're talking about here. Now related
to the signed integers are the unsigned integers.
62:18 - So we have the value 42 here, and just so
you can see, we can create an unsigned integer.
62:24 - And I'll just pick at you and 16 and assign
that the value of 42. And then let's go ahead
62:31 - and run that. And you see that now we have
a un 16. So there's an equivalent type of
62:36 - unsigned integer for every signed integer,
we have you int eight, which is an unsigned
62:41 - eight bit integer which can go from zero to
255. We have a 16 bit unsigned integer and
62:45 - a 32 bit unsigned integer. Now, what we don't
have is we don't have a 64 bit unsigned integer.
62:51 - But we do have a type byte. And a byte is
an alias for an eight bit unsigned integer.
62:57 - And the reason we have that is because the
unsigned eight bit integer is very common,
63:01 - because that's what a lot of data streams
are used to encode their data. Now with
63:04 - these integer types, and again, unsigned unsigned
integers are basically the same type, we've
63:08 - got several different arithmetic operations
that we can do. And these are built into the
63:13 - language. So if I just dropped in this example,
here, you see that we've got an integer, a
63:17 - set equal to 10. And we've got another integer
be set equal to three. And we're doing the
63:21 - basic arithmetic operations that are available
to
63:23 - us.
63:24 - So we can add, we can subtract, we can multiply,
we can divide, and then this percent sign
63:28 - here is actually used for the remainder. So
if I run this, you see that we get 10, plus
63:33 - three is 1310, minus three is seven, and so
on. So we get the numbers that we expect,
63:38 - then the one that you might not expect is
this a divided by b. So 10 divided by three
63:42 - is three, remainder one. And so we get the
result three out, because when you divide
63:46 - an integer by an integer, you have to get
an integer result. So the type cannot change
63:51 - during the operation. So when we do this,
we're doing what's called integer division,
63:55 - and we dropped the remainder. Now, if the
remainder is interesting, that's what this
63:58 - remainder operator is for. And then we can
pick up that remainder one out of it. Now,
64:02 - just like when we're doing division, we can't
change the type. So dividing an integer by
64:07 - an integer can't give us a floating point
number, for example, we're also not allowed
64:10 - to add to two integers of different types.
So if we take this as an example, we've got
64:15 - the integer, a set equal to 10, and an eight
bit integer set equal to three. And if we
64:21 - try and add those together, we're actually
going to get an error. So even though go might
64:25 - be able to do that, theoretically, it's very,
very insistent that it's not going to work
64:30 - across types without your consent. So in order
to make this work, we would actually have
64:34 - to do a type conversion on one of the variables
to convert it into the type of the other.
64:40 - So just like we talked about in the last video,
where go is very, very hesitant about implicit
64:45 - data conversion. This is another example.
Even though these integers are almost equivalent,
64:50 - go is not going to make that assumption for
you, you're going to have to do the type conversion.
64:54 - Now a couple of other operations that we have
are called the bit operators. So if I drop
64:58 - in this example, we see the full Bit operators
that we have, we've got the AND operator,
65:03 - we've got the OR operator, we've got the exclusive
OR operator, and we've got the and NOT operator.
65:08 - Now what's going to happen when we run this?
Well, let me just run this first and get these
65:13 - results. So you see that if we take a and
b, then we get two, if we take a or b, we
65:17 - get 11. And these might not make a lot of
sense. So in order to clear things up a little
65:21 - bit, let me put in the binary representation
of these. And then we can walk through what
65:25 - these are doing. So 10 is 1010, in binary
three is 0011. Now when we run into an end
65:32 - operation, that's going to look for what bits
are set in the first number and the second
65:37 - number. So as we can see, we've got four bits
in each one of these numbers that are allocated.
65:42 - Actually, these are 32, or 64 bits long, but
I'm ignoring all the zeros at the beginning
65:46 - of these numbers. So let's look at the four
digits that matter. So if we look at these,
65:50 - then we see actually, if we add these together,
we're going to get 0010. And in binary, that
65:57 - is two, so 10, and three equals two. Now if
we do the or, or means if one or the other
66:05 - is set, so we get one, because a has the first
bit set, neither one has the second bit set,
66:11 - both have the third bits set, so we're going
to include that, and then B has the last bit
66:15 - set. So we'll have that. So now we end up
with 1011, which is one plus two plus eight,
66:22 - which equals 11. Exclusive OR means either
one has the bit set, or the other does, but
66:28 - not both. So in that case, we're going to
do 1001. The only difference between this
66:33 - and the OR operation is that third bit where
they're both set to true. And therefore we're
66:39 - not going to include that. Now in the end
not that's kind of the opposite of or because
66:43 - within not, it's going to be set true only
if neither one of the numbers have the bit
66:48 - set. So since the first bit is set in a, we're
not gonna include that, neither one has the
66:54 - second bit set, so we're going to include
that both have the third bit set, so we're
66:57 - not going to include that. And B has the fourth
bit set. So we're not gonna include that.
67:02 - So we get 0100, which is equivalent to the
number eight. And that's how these bit operations
67:07 - work. The last example that I have to show
you with integers is what's called bit shifting.
67:12 - So when we have this example here, the first
print statement is going to bit shift a left
67:17 - three places. And the second is going a bit
shift a right three places. So let's run this
67:22 - and see what that's going to do. And so we
get to number 64, and one, so in order to
67:28 - understand that, let me go ahead and put in
these values, so we can understand what's
67:33 - going on. So eight is really two to the third
power. And when we do bit shifting, we're
67:39 - basically adding to that exponent, as long
as we're dealing with the power of two, because
67:42 - really, what we're going to do is we're going
to take this to to the third and multiply
67:49 - it by two to the third, which is equivalent
to two to the sixth, and two to the six is
67:57 - 248 1632 64. So that's how we get the 64.
Now, when we bit shift to the right, we're
68:05 - going to take our original number, and we're
going to divide it by two to however hard
68:10 - we're shifting, so we're going to divide it
by two to the third. And in that case, we're
68:13 - going to get two raised to the zero power.
And any number greater than zero raised to
68:17 - the zero power is one.
68:19 - And so that's how those operations work. The
next data type that I want to talk about are
68:23 - the floating point types. So we have a lot
of different integer types. So we can store
68:27 - a lot of different size numbers. But with
integer types, we can only store integers,
68:31 - so they can be positive or negative integers
or zero, but we can't store decimal numbers.
68:36 - So in order to store decimal numbers in go,
we're going to use the floating point numbers.
68:41 - Now the floating point numbers in go follow
I triple E 754. Standard. And in that standard,
68:46 - we're going to pull out two of the types.
So we've got 32 bit floating point numbers
68:50 - and 64 bit floating point numbers. So if you're
working with a 32 bit floating point number,
68:54 - you can store numbers between plus or minus
1.18 times 10 to the negative 38, all the
68:59 - way up to 3.4 times 10 to the 38. So from
very small numbers to very large numbers.
69:04 - If you need even more precision than that,
then you can use a float 64. And that can
69:08 - go from plus or minus 2.23 times 10 to the
negative 308th, all the way through 1.8 times
69:14 - 10 to the 308. So how do we create floating
point numbers? Well, here's some examples
69:18 - of how we can do that. So line eight here
shows you how you're going to define your
69:22 - flooding point literals almost all the time.
So we're going to declare a variable and set
69:27 - it equal to 3.14. And away we go. This next
line here shows that we can use exponential
69:33 - notation. So we can use 13.7 times 10 to the
72nd. And that's going to be able to use the
69:38 - short form iE 72nd to stand for that 10 to
the 72nd. So if I run this, we're actually
69:43 - going to get the final result here, of 2.1
times 10 to the 14th as a floating point 64.
69:50 - But notice we didn't get any errors. So all
three of those declarations, syntaxes are
69:54 - okay, so that's how we can work with floating
point numbers and show you how you can explicitly
69:58 - declare these We can use, let me just do var
and float 32, for example, and initialize
70:06 - that. And that's how you're going to declare
a floating point number. Now unfortunately,
70:10 - this number is a little big, because we can
only go times 10 to the 38th power. So if
70:15 - I comment that line out, things are going
to run properly. If I come back in and make
70:20 - this a floating point 64, then we can restore
this number. And that's another thing that's
70:25 - important. If you're going to use the initializer
syntax on a decimal, it's always going to
70:29 - be initialized to a float 64. So keep in mind,
you can't do arithmetic operations between
70:34 - float 64 and float 30 twos. So if you're just
using the initializer syntax, you're going
70:40 - to want to make sure that everything's working
as float 64. And if you forget, don't worry
70:43 - about it, the compiler will complain at you,
and you can quickly go in there and make sure
70:47 - that everything's working properly. Okay.
Now, speaking of arithmetic operations, let
70:51 - me jump in a couple of those. And you can
see the arithmetic operations that are available
70:55 - with floating point numbers. So if I run this,
we get the expected answers of adding, subtracting,
71:00 - multiplying dividing two numbers together.
Now, a couple things to notice here, when
71:04 - we divided A by B, we did in fact get a decimal
result, because as long as we're working with
71:09 - floating point numbers on both sides, we can
get a floating point result. As a matter of
71:13 - fact, we have to get a floating point result.
The other thing to notice, we don't have the
71:17 - remainder operator available that is only
available on the integer types. Further, we
71:22 - don't have the bitwise operators or the bit
shifting operators. So if you need to work
71:26 - with those, you're going to have to work with
the integer types. The last type of numeric
71:30 - primitive that we have available in go is
the complex type. And this is really kind
71:34 - of exciting because this is fairly rare in
the languages that I've worked with, where
71:38 - complex numbers are actually treated as a
first class citizen, and it opens up go to
71:42 - be used as a very powerful language for data
science. So if we come in and paste an example,
71:47 - you can see a very basic declaration of a
complex number. Now there are two types of
71:51 - complex numbers. There's complex 64, and complex
128. And the reason we have that is we're
71:57 - basically taking a float 64 plus a float 64,
or a float 32 plus a float 32 for the real
72:03 - and imaginary parts. Now here, I've got a
very simple complex number, that's one plus
72:07 - two I, if I go ahead and run that, you see
that in fact, it prints out as one plus two
72:11 - I and that's complex 64. So goes parser understands
the I literal as an imaginary number, and
72:19 - it uses that when you're creating your variable.
Now we can actually go even simpler than that,
72:24 - because AI is considered special. And we can
run this with just two AI and we get zero
72:28 - plus two I down here and the result. Now what
operations that we have available. Well, we
72:33 - can do addition, subtraction, multiplication,
and division again. So I've got two complex
72:37 - numbers defined here. If I run this, then
I get the expected result, where the real
72:42 - parts are added together, and the imaginary
parts are added together, or subtracted, multiplied,
72:47 - divide whatever operation we're applying.
Now, what happens if you need to decompose
72:51 - this down. So if I come back to our first
example, here, where we have one plus two
72:55 - I, not every operation that I'm going to do
with these numbers is going to need this to
72:59 - work as a complex number. So what happens
if I need to get at the real part or the imaginary
73:04 - part? Well, in order to do that, we actually
have two built in functions in the language.
73:09 - So let me wrap this in here with a call to
the real function. And then I can
73:15 - follow that up with its partner, which is
the image function. And what those are going
73:19 - to do is those are going to look at the complex
number that you provide. And they're going
73:22 - to pull out the real part or the imaginary
part. And these functions work with complex
73:27 - 64 and complex 128. So if you run this on
the complex 64, then the real and the image
73:33 - function are going to give you float 30 twos
out, if you run this on complex 128, it's
73:37 - going to give you float 64 is out because
those are the data types used for the components.
73:41 - So if we run this, we see that we get float
32 is out. If we convert this to a 128 and
73:49 - run this again, then we're going to get float
64 is out. And it's going to break apart that
73:52 - complex number into the real and imaginary
part. So we can work with those however, we
73:56 - need to know the complement of these two functions
is the complex function. So if you're working
74:01 - along in your program, and all of a sudden
you need to make a complex number. How do
74:05 - you do that, because you can't use this literal
syntax. So in order to do that, we do have
74:10 - another function. And that's the complex function.
And this takes two numbers. The first number
74:15 - is the real part. And the second number is
the imaginary part. So let me go ahead and
74:19 - wipe out this line. Get rid of these real
calls here, and then run. And now that we
74:25 - see that we can take two floating point numbers.
In this case, they're considered to be floating
74:29 - point 60 fours because we're making a complex
128. And it creates five plus 12 I for us,
74:35 - the last data type that I want to talk about
is the text type. And texting go falls into
74:40 - two basic categories. One, I can talk a lot
about the other we're just going to touch
74:45 - on. So the first text type that we have available
is a string, and a string. Ingo stands for
74:50 - any UTF eight character, so that makes it
very powerful. But that means that strings
74:55 - cannot encode every type of character that's
available. For that we need the other text
74:59 - type which we'll talk about in a second. But
let's just start by introducing a basic example
75:04 - here. So here I've got a string literal, this
is a string, I'm going to print out its value
75:08 - and its type. So if I go ahead and run this,
you see that this is a string print out. And
75:12 - it's of type string. No big surprise here.
Now one of the interesting aspects of a string
75:17 - is I can actually treat it sort of like an
array. Now, we haven't talked about arrays
75:21 - yet. But I can actually treat this string
of text as a collection of letters. So if
75:27 - I do something like this, I'm actually going
to ask it for the third letter, because arrays
75:32 - and go are zero based. So I'm going to look
for the 012. That's the third letter in the
75:36 - string, which is the letter II. So if I run
this, I get an interesting result, I get the
75:41 - value 105. And that's a un eight. So what
the heck happened there? Well, what's happening
75:46 - is that strings and go are actually aliases
for bytes. So we can go ahead and convert
75:51 - this guy back, since a byte is just an alias
for a string, and we can get our letter I
75:57 - back. Now, strings are generally immutable.
So while I can inspect the second character,
76:03 - I can't do something like this, if I tried
to run this program, let me just print out
76:08 - the full string here and run this, then I
get an error. And there's actually quite a
76:12 - few things wrong with this. The first thing
is I can't assign a string to a byte because
76:16 - I'd have to do a conversion. The second thing
is I can't manipulate the value of the string.
76:21 - Now with the numeric types, I should do that
there were quite a few operations that we
76:24 - can perform with it, there is one arithmetic
or pseudo arithmetic operation that we can
76:29 - do with strings, and that is string concatenation.
Or in simpler terms, we can add strings together.
76:34 - So in this example, I've got the string s
and the string s two. And as you can see down
76:38 - in the printf statement, I'm adding s&s two
together, and then we're going to print out
76:41 - the value in the type. So if I run this, you
see that it just merges all the strings together,
76:46 - and it gives us the result. Now another thing
that I can do with strings is I can actually
76:50 - convert them to collections of bytes, which
in go is called a slice of bytes. So in this
76:55 - example, I'm starting with a string, this
is a string, and then I'm going to do a conversion
77:00 - to this collection of bytes. And I'm going
to pass the string into that. So if we run
77:05 - that, we actually get this as a string comes
out as the ASCII values, or the UTF values
77:11 - for each character in that string. And then
you see that the result is a collection of
77:15 - UN eights, which is a type alias for bytes.
Now, why would you use this one? It's a very
77:20 - good question. A lot of the functions that
we're going to use in go actually work with
77:25 - byte slices. And that makes them much more
generic and much more flexible than if we
77:30 - work with hard coded strings. So for example,
if you want to send as a response to a web
77:35 - service call, if you want to send a string
back, you can easily convert it to a collection
77:39 - of bytes. But if you want to send a file back,
well, a file on your hard disk is just a collection
77:45 - of bytes, too. So you can work with those
transparently and not have to worry about
77:49 - line endings and things like that. So while
in your go programs, you're going to work
77:53 - with strings a lot as strings. When you're
going to start sending them around to other
77:57 - applications or to other services, you're
very often going to take advantage of this
78:01 - ability to just convert it to a byte slice.
Okay, the last primitive data type that we
78:05 - have to work with is called a rune. Now a
rune is a little bit different than a string
78:10 - type in go. Because we're a string type represent
any UTF eight character, a rune represents
78:16 - any UTF 32 character. Now, UTF 32 is a little
bit of a weird animal, because while any character
78:23 - in UTF, 32, can be up to 32 bits long, it
doesn't have to be 32 bits long. For example,
78:29 - any UTF eight character, which is eight bits
long, is a valid UTF 32 character. So there's
78:35 - all sorts of tricks that they have to do in
the encoding of the characters in order to
78:39 - know whether the character is one, two or
four bytes long. So that makes things a little
78:45 - bit tricky to work with and go. Now we're
not going to get too deep into this subject,
78:49 - we're just going to talk a little bit about
what runes are. And then I'm going to point
78:53 - you to some things that you can refer to if
you actually need to work with rooms in your
78:57 - application. So if we look at this example,
here, we're declaring the room a. Now notice
79:03 - the difference here, if we were declaring
a string, we would have double quotes. When
79:07 - we're declaring a single room, we use single
quotes. But if I run this, I'm going to get
79:11 - an interesting result. Notice I get the value
97. And it's an int 32. Now that might seem
79:16 - a little weird. And the reason for this is
because runes are just a type alias for int
79:23 - 30. twos. So we're strings can be converted
back and forth between collections of bytes.
79:29 - Rooms are a true type alias. So when you talk
about a rune and go it is the same thing as
79:34 - talking about an integer 32 name, I think,
well, that's just because we're doing some
79:39 - implicit initialization here, we're using
that colon equals syntax. So let's specifically
79:44 - and explicitly declare this as a rune and
try this again. And we get the same result.
79:49 - And again, that's because a rune is an integer
32. Now, you might be feeling a little lost
79:55 - here. So if I've got a UTF 32 characters at
how do I work with that. Well, the Answer
80:00 - comes from the go API's. So if I jump out
to go lang.org, come into the packages. And
80:06 - let me just jump to the strings package. And
then I'll show you this. Notice this function
80:10 - here, read rune. So if you're working with
a data stream that's encoded in UTF 32, then
80:17 - you have special functions that you're going
to be able to take advantage of, that's going
80:20 - to return those values out. So if we do read
byte, which is going to read a single character,
80:25 - then we're going to get a bite out and a potential
error. But with read rune go is going to look
80:30 - at the byte stream, it's going to pull off
the next room that's available to you the
80:34 - size of that room, and then a potential error.
So you're going to have all the information
80:37 - you need in order to re encode that integer
32 that you're going to have back into its
80:43 - UTF 32 character. So things are a little bit
more tricky when you're working with runes.
80:47 - And you're going to have to read into the
API's for the go package that you're working
80:51 - with, in order to understand how to work with
them in your application. Okay, so that covers
80:57 - the primitive data types that you have to
work with and go, let's go into a summary
81:00 - and review what we've talked about in this
video.
81:04 - We covered a lot of ground in this video,
and I understand that it might take a little
81:07 - bit of time to process this and really understand
all the different options that you have for
81:12 - primitive data types and go. Now before we
get into the summary, I do want to let you
81:16 - know that a lot of times the default data
types that you're given are going to be perfectly
81:20 - fine. So if you're working with Boolean, you're
going to get a Boolean type, if you're working
81:22 - with integers, you're going to get that signed
integer type floating point, it's going to
81:26 - give you a floating point, 64, and so on.
So you don't have to memorize every single
81:30 - data type. If you need a specific data type,
then you can certainly refer to the NGO documentation
81:35 - in order to find out what's available for
you. So let's go through and review what we
81:39 - talked about. The first thing that we talked
about was the Boolean type of data, we found
81:43 - out that it can take two values true or false.
And it's not an alias for other types. So
81:48 - in some languages, a Boolean is actually an
alias for an integer. So you might use like
81:51 - negative one for true and zero for false when
go Boolean is its own type. So you can't convert
81:56 - back and forth between integers and things
like that, you're going to have to work with
82:00 - Boolean as their own type. We also talked
about the zero value for a Boolean is the
82:04 - value of false. And so if you initialize a
Boolean and don't set a value for it, it's
82:08 - going to receive the value false. Then we
talked about the numeric types. And the first
82:13 - type that we talked about were the integer
types. And that broke down into two different
82:16 - types with the signed integers. And there
are two classes, I guess you could say within
82:21 - the sign integer type. There's the INT type,
which has varying size, but a minimum of 32
82:25 - bits. And this is going to be the most common
type of integer you're going to deal with
82:28 - in your applications. But if you need a little
bit more granularity, or a little bit more
82:33 - resolution, or control over how much memory
is assigned to the integer, then you can go
82:36 - all the way from int eight, which is an eight
bit integer all the way up to 64 bit integer,
82:41 - we also have the unsigned integers where the
signed integers have a plus or minus and so
82:45 - they can't store numbers quite so large because
they have to store a plus or minus bit. The
82:51 - unsigned integers can store larger numbers,
but they can only ever be positive. And we
82:55 - have all the way through an eight bit which
we can use the byte or the UN eight, type
82:59 - four, all the way through 32 bit unsigned
integers with the un 32. We have various arithmetic
83:06 - operations that we can perform on both integer
types. So we can do addition, subtraction,
83:10 - multiplication, division, and that remainder
operation. So remember, division with integers
83:14 - is going to give you an integer result. So
you're going to lose that remainder portion.
83:19 - So if you need that, you can use that remainder
operator to get it. We also have the bitwise
83:24 - operators. So we can do and or Exclusive OR,
and the and not operations. And the zero value
83:30 - for any integer type is going to be the literal
value zero. So when you initialize an integer
83:35 - type, and don't assign a value to it, that's
going to be equivalent to the value zero,
83:38 - you're not just going to get whatever was
in memory when that variable is initialized,
83:42 - and you cannot mix types in the same family.
Now, this is going to be true throughout all
83:46 - of the numeric types. If you have a un 16,
for example, and a un 32. And you cannot add
83:50 - those together, you're going to get a compile
time error. The next numeric type that we
83:54 - talked about where the floating point
83:56 - numbers,
83:57 - so they follow the I triple E 754. Standard,
there's zero value is similar to the integer
84:01 - types, the value is zero. And we have two
different versions, we got 32 bit versions
84:05 - and 64 bit versions that we can work with.
And we have several different literal styles
84:10 - that we can use to initialize them. So we
can use a pure decimal like 3.14, we can use
84:14 - exponential notation, for example, 13 e 18,
or two e 10. And it doesn't matter if that
84:19 - e is upper or lowercase, or you can do mixed.
So for example, 13.7 e 12 is a perfectly acceptable
84:25 - way to initialize that. We do have addition,
subtraction, multiplication and division that
84:29 - we can do with floating point numbers. Now
we don't have the remainder operation, but
84:34 - the division operation is going to give us
a true floating point result. So we're not
84:37 - going to lose our decimal portion. The final
numeric type that we talked about were the
84:41 - complex numbers. The zero value of a complex
number is zero plus zero I and they come in
84:46 - 64 and 28 bit versions and the reason for
that is the two components, the real and the
84:51 - imaginary component are either going to be
floating point 32 or floating point 64. So
84:56 - when you add those together, that's where
you get the 64 and 128 bit versions. We have
84:59 - Some built in functions that we can work with.
So we can use the complex function in order
85:04 - to create a complex number, we can use the
real function in order to get the real component.
85:08 - And we can use the match function in order
to get the imaginary component of a complex
85:12 - number. Now what the data type that comes
out of that depends on the size of the complex
85:16 - number going in. So complex 64 is going to
give you a float 32 out from the real in the
85:22 - match function and a complex 128 is going
to give you a float 64 out of the real in
85:26 - the match function, we have the same arithmetic
operations as we do for floating point numbers,
85:30 - we can do addition, subtraction, multiplication
and division. The final category of primitive
85:35 - data that we talked about, or the text types,
and in go, there are really two different
85:39 - text types. The most common one that you're
probably going to deal with are strings. No
85:43 - Strings are represented as a collection of
UTF eight characters, they're immutable, you
85:48 - cannot change the value of a string after
it's been initialized. You can concatenate
85:52 - strings together with the plus operator. And
then you can convert them back and forth between
85:57 - a collection of bytes with this square bracket
byte syntax and passing in the string that'll
86:02 - convert it to a collection of bytes. And you
can convert a collection of bytes back to
86:06 - a string by using the string conversion. The
other type we talked about is a rune and a
86:11 - rune represents any UTF 32 character. Now
runes are a little bit more complicated to
86:16 - work with because of the multi step process
that it takes in order to encode a character
86:20 - into the UTF 32 character set. So when we're
working with runes as a primitive type, really
86:25 - all we're working with is an alias for an
integer 32. Today, I want to talk about constants
86:30 - and how you can use them in your NGO applications.
Now, there are several things that we need
86:34 - to talk about with constants. So like we've
been doing, I want to break this down into
86:38 - several categories. The first thing that I
want to talk about is how we're going to name
86:42 - constants in our NGO applications. Then we'll
talk about type constants, followed by a discussion
86:48 - about untyped constants. And we'll talk about
the differences between those two, and the
86:52 - options that each one gives us. And then we'll
talk about a method of generating constants
86:56 - that are called enumerated constants. And
finally, we'll end our discussion by talking
87:00 - about enumeration expressions, which are going
to build upon the concepts that we're going
87:04 - to talk about in that first enumeration discussion.
The first thing that I want to talk about
87:09 - is how we're going to name our constants.
So all constants are going to be preceded
87:13 - with the const keyword, that's going to let
the compiler know that that's what we're trying
87:17 - to work with. Now, if you've come from other
languages, you might be expecting that we're
87:21 - going to name our constants, something like
this, where we're going to have all uppercase
87:24 - letters and separate the words with underscores.
The problem with that is if we do that and
87:30 - go, then the first letter is going to be uppercase.
And as you remember, from our discussion on
87:35 - variables, if we've got an uppercase first
letter, that's going to mean that the constant
87:39 - is going to be exported. And we don't always
want that. So instead of this, we're actually
87:43 - going to name our constants the same way that
we named variables.
87:46 - So if we had a variable that we wanted to
call my const, and we didn't want to export
87:50 - it, then we would start with a lowercase first
letter, or in other words, we would use camel
87:54 - casing. And if we did want to export this
symbol, then we would simply change that first
87:58 - character to uppercase. Now assuming that
we're going to be working with an internal
88:02 - constant, then we're going to switch this
back to a lowercase first letter. And then
88:06 - let's talk about how we can create what's
called a typed constant. Now a typed constant
88:10 - is created very similarly to a typed variable.
So we can start with the const keyword, then
88:15 - the name of our constant, and then we're going
to list the type of the content, and then
88:19 - we can set it equal to a value, then if we
want to prove that that worked out the way
88:24 - we expected it to, then we can go ahead and
print out the value in the type of the constant.
88:28 - And we will do that by using this printf statement
here. And then when we run this, we see that
88:35 - the constant is in fact created. It's got
the value 42 that we assigned, and it's got
88:39 - the type that we assigned to it. Now the reason
it's a constant and not a variable is it has
88:43 - to remain constant. So if we tried to do something
like this, change this to the value 27, then
88:48 - the compiler throws an error, because we're
not allowed to change the value of a constant.
88:52 - Another characteristic of a constant is that
it has to be assignable at compile time. So
88:57 - for example, if I wanted to have a constant
that represented the sine of pi over two,
89:01 - then I might be tempted to do something like
this. I'll create a float 64 constant. And
89:06 - I'll set it equal to the result of the sine
function from the math library. And I'll pass
89:11 - in 1.57, which is approximately pi over two.
And then I can run this right? Well, the problem
89:16 - with that is in order to determine the sine
of that value, that actually requires the
89:21 - function to execute, which is not allowable
at compile time. And so you can't set your
89:25 - constants equal to something that has to be
determined at runtime. And that includes things
89:30 - like setting it equal to flags that you pass
into your application, when you run, if you're
89:34 - going to do that you can't use a constant
to store that value. Now constants can be
89:38 - made up of any of the primitive types that
we talked about in the last video. So if we
89:42 - have this example, here, we've got an integer
constant, we've got a string constant, a floating
89:45 - point constant and a Boolean constant. And
if we run this, we see that all of those printout
89:51 - exactly the way that we expect. We've got
the integer the string, the floating point
89:54 - value and the boolean value. Now in an upcoming
video, we're going to talk about the collection
89:58 - types and the collection types. are inherently
mutable. So for example, you couldn't create
90:02 - an array and declare that to be a constant
type. Arrays are always going to be variable
90:07 - types. Now another characteristic that constants
have in common with variables is they can
90:12 - be shadowed. So if we create a constant at
the package level, and let's just make this
90:16 - an integer 16, and set it equal to the value
27, then we'll delete these guys. And also
90:22 - these guys. Now we've got a constant called
a declared at the package level, that's an
90:27 - integer 16. And then we got a constant in
the main function, that's also called a and
90:31 - it's an integer type. So if we update This
printf statement to print the type of variable,
90:37 - we see that the looks like I need to print
my variable twice, we see that the inner declaration
90:44 - of the constant wins. So not only can we change
the value of the constant, but we can also
90:48 - change the type because the inner constant
shadows that outer constant. And we can prove
90:53 - that by commenting this line out, running
again. And we see that the package level constant
91:00 - wins. So you want to be a little careful here,
because if you're going to reuse constant,
91:03 - it's going to feel like those values are changing.
So I wouldn't recommend that you take advantage
91:07 - of this. But if you do get into a situation
where constants aren't evaluating the way
91:11 - that you expect them to, this is one possible
reason. Now when we're working with constants,
91:15 - they work very similar to variables when we're
using them in operations. So if we bring this
91:20 - line back, and set it equal to 42, and then
what I want to do is declare a variable. So
91:28 - we'll declare a variable b as an integer,
and set that equal to the value 27. And then
91:33 - we can do a plus b. And let's see what happens
when we do that. So if we run that, we in
91:39 - fact, get the ability to add a constant to
a variable, and the result is going to be
91:44 - a variable. And so since the constant and
the variable are of the same type, we can
91:48 - perform the addition operation on there. Now,
our constant is of a different type. For example,
91:52 - if we made variable b in 16, and run this,
then we get exactly the same failure that
91:57 - we get when we try and add two variables of
different types together. Now, so far, all
92:02 - we've been talking about are these type constants,
we're after the constant name, we list the
92:06 - type. But we don't have to do that, we can
use the compilers ability to infer the type
92:12 - for us. So let's just go ahead and do that
with this example here. When we run this,
92:17 - we see that the constant a is inferred to
be an integer with the value 42. Now given
92:23 - that, given that the compiler is inferring
the value, what do you think is going to
92:27 - happen? If we do something like this, if we
restore that previous example, where we're
92:33 - going to add this constant to an integer 16?
Well, in fact, in this case, the operation
92:39 - succeeds, which might be a little bit confusing.
But the reason that works is because what
92:43 - the compiler is actually doing, when it sees
this constant is it's basically replacing
92:49 - every instance. So the way the compiler sees
this program is it sees it like this. So since
92:56 - we're taking a literal 42, and adding an int
16 to it, that 42 is interpreted as being
93:02 - an integer 16. So the compiler doesn't say,
oh, constant, a equals 42, that's an integer
93:08 - and always an integer. Instead, the compiler
is going to look for every time that we use
93:13 - the symbol a, and it's going to replace that
with the value of the constant. And so we
93:18 - can do these implicit conversions when we're
working with constants, which is something
93:23 - that we can't really do when we're working
with variables. The next thing that I want
93:27 - to talk about are what are called enumerated
constants. So let me go ahead and start that
93:32 - conversation out by wiping out what we have
here, clean up our code just a little bit.
93:36 - And then I'm going to do this at the package
level. Because this is where I've seen these
93:39 - most commonly applied, you could do these
in a function level, if that made sense in
93:43 - your application. So I'm going to declare
a constant a, and I'm going to have that as
93:48 - an untyped constant. And I'm going to set
it equal to this special symbol called Iota.
93:52 - So when I run this, you see that a is evaluated
to have the value zero, and it's inferred
93:57 - to have the type integer. So what is Iota?
Well, Iota is a counter that we can use when
94:04 - we're creating what are called enumerated
constants. So in this example, having an enumerated
94:09 - constant isn't terribly valuable. But one
of the things that I can do with constants
94:13 - is I can actually work with them in a constant
block like this. So when I'm doing this, I
94:18 - can create another constant set that equal
to Iota and another constant and set that
94:22 - equal to it, let's go ahead and clean up this
because we already know what the type is going
94:29 - to be. So we don't need to be printing that
out. And then let's print this command out
94:32 - two more times, switching to B, and C. So
now we're using Iota three times and when
94:39 - we get the result we actually see Iota is
changing its value as the constants are being
94:45 - evaluated. So the first constant that's assigned
has the value of zero than one and then to
94:51 - know another special feature that we can take
advantage of with Iota is that if we don't
94:56 - assign the value of a constant after the first
one, then the Pilar is going to try and infer
95:01 - the pattern of assignments. So in this example,
we would expect to have an error because B
95:06 - and C don't have a value assigned. But since
we've established a pattern for how to name
95:11 - the constants in this block, when we run,
we actually get the same result. And that's
95:16 - because the compiler is going to apply the
same formula. So it's going to apply b equals
95:20 - Iota and C equals Iota for us. Now that value
of Iota is scoped to that constant block.
95:27 - So we create another constant block. And in
this case, we create a constant called a two
95:33 - and set that equal to Iota, copy this line,
bring it down, and print out the value of
95:39 - a two, then what we're gonna find is Iota
resets to zero. So Iota is scoped to a constant
95:45 - block. And what that lets you do is you can
actually create related constants together,
95:50 - ensure that they have different values. And
then if you have another set of related constants,
95:55 - you can start another constant block and ensure
that they have unique values, but allow duplication
96:01 - between the values in one constant block in
another. So what's an example where you might
96:05 - use this? Well, let me just drop in this simple
application. And what we're doing here is
96:11 - we're setting up a constant block, where maybe
we're trying to store the specialty of veterinarians
96:17 - in a veterinarian clinic so that our narine
could be a cat specialist or a dog specialist,
96:22 - or maybe we can take his neck specialist to.
Now as you can see, inside the cost box, I'm
96:27 - setting the cat specialist equal to Iota.
And then in the main block, I'm creating a
96:33 - variable and setting its value equal to cat
specialist. So if I check to see if the specialist
96:38 - type is a cat specialist, then I in fact,
get the value true. Now, that works just fine.
96:44 - And this also works if I, for example, use
a dog specialist, assign that specialist type
96:50 - to be a dog specialist run that, then that's
going to work out just fine. So everything
96:54 - looks really good here, right? And this is
a very common use for enumerated constants.
97:00 - However, one thing
97:01 - that I would warn you about is what happens
if I declare this variable and don't initialize
97:05 - it to a type? Well, if I check to see if it's
dog specialist, I get false, which makes sense.
97:11 - But remember, what is the initial value of
Iota? Well, the initial value of Iota equals
97:17 - the zero value for an integer. And so in fact,
even though we haven't specified a specialist
97:21 - type, it does show up as the value can't specialist.
So what do we do about this, so there's a
97:27 - couple of approaches that we can take here.
The first is to use the zero value of the
97:34 - constant as an error value. So we can set
this equal to error, then we don't need this
97:40 - statement anymore. And now when we check to
see if the specialist type is a cat specialist,
97:45 - we get the value false because cat specialists
is equivalent to the integer value one, which
97:50 - is no longer the zero value of the integer.
This is a very valuable approach, if you want
97:55 - to check to see if a value hasn't been assigned
to a constant yet, so you can specify an error
98:01 - specialist. And then you can check to see
if that value is set equal to the zero value
98:04 - of that constant. And if it is, you can handle
that error,
98:07 - because
98:08 - presumably, you expect that to be initialized
in some way. Now, if your application guards
98:13 - against that, and there's no reasonable way
for this to happen, then you can take advantage
98:16 - of this underscore symbol, which is goes one
and only write only variable. Now what's the
98:22 - value of a write only variable? Well, with
Iota, we have to have a zero value, we always
98:28 - have to start with zero. But if we don't care
about zero, then we don't have any reason
98:32 - to assign the memory to it. So we can use
this underscore symbol. And we'll see this
98:36 - in quite a few places in our go applications.
And basically, what that tells the compiler
98:40 - is yes, I know you're going to generate a
value here, but I don't care what it is go
98:44 - ahead and throw that away. So if we run our
application, again, everything works just
98:49 - fine. But in this case, we can't actually
get at the zero value of this constant block.
98:54 - Now the ability to create it lists of enumerated
constants with a Oda is very valuable. But
98:59 - things don't actually stop there. And the
reason is, remember, the value of a constant
99:03 - has to be able to be determined at compile
time, but there are some operations that go
99:08 - is going to allow us to do for example, we
can do addition. So if we do this and run,
99:15 - then we get false again. But what happens
if we print out the value of kept specialist
99:22 - if we do that, and we're going to have to
remove this line, then in fact, that expression
99:28 - got evaluated. So the first line line eight
is evaluated to Iota plus five, which is zero
99:34 - plus five, the next line cat specialist, Iota
increments, and the formula repeats. So cat
99:40 - specialist is equal to the value six, dog
specialist is seven, and snake specialist
99:44 - is eight. So this can be valuable if you need
some kind of a fixed offset. Now a common
99:49 - use case for this is to use the bit shifting
operators because anything that we can apply
99:54 - to our primitive type, we can apply here as
long as it's not a function expression. So
99:59 - we can do addition, subtraction, multiplication
and division, we can do remainder operations,
100:04 - we can do the bitwise operations. And we can
do bit shifting, which is one of the more
100:08 - interesting use cases that we can take advantage
of. And the reason is because we don't have
100:13 - the ability to raise two powers because raising
two powers and go is a function in the math
100:18 - package. So we can't do that in our constant
evaluations. But by bit shifting, we can raise
100:25 - things to the power of two, because every
time you shift the number one level, you're
100:29 - actually multiplying it by two. So we have
this example here. And I actually stole this
100:34 - from the effect of go article on golang.org.
So what we have here is we have an example
100:39 - of a constant block that's giving you constants
that are equivalent to kilobyte, megabyte,
100:44 - gigabyte, terabyte, petabyte, and so on. So
down here, in our main program, what I've
100:49 - done is initialize the file size to some arbitrary
value. And then I've got this printf statement.
100:54 - And this is basically going to format a result
to print two decimal places, and then the
100:58 - literal string GB afterward. So this string
here is basically saying I'm expecting to
101:03 - format a floating point number, and I'm going
to give it two decimal places, this GB is
101:07 - a literal GB, that's going to be printed in
the result. And then we've got the value that's
101:11 - going to be used to fill this in. And that's
going to be file size divided by the GB constant.
101:17 - Now you notice this constant block is set
equal to one, and then we're going to bit
101:21 - shift that value 10 times Iota. So the first
time we're going to bit shift 10 times one,
101:26 - so we're basically going to multiply this
by two to the 10th. And then we're going to
101:30 - multiply by two to the hundreds for the megabyte,
and then two to the 1004, gigabyte, and so
101:35 - on. So when we run this, we get a really convenient
way to format an arbitrary file size into
101:41 - a human readable format. And in the effective
go article, it actually shows you how to put
101:46 - a switch block, which we haven't talked about.
So you can make a decision about which constant
101:50 - you're going to use based on the size of the
incoming value. So here, we get this nice
101:54 - way to format this relatively difficult number
to read to be the very easily read 3.73 gigabytes.
102:02 - Now another thing that can be very valuable
to do is using bit shifting in order to set
102:06 - Boolean flags inside of a single byte. So
if I paste this example in, we can see an
102:13 - example of that. So let's just say that we've
got an application and that application has
102:16 - users and those users have certain roles.
So inside of this constant block, here, I'm
102:21 - defining various roles that we can have. So
for example, you might be an admin, you might
102:25 - be at the headquarters or out in the field
somewhere, you might be able to see the financials
102:30 - or see the monetary values. And then there
may be some regional roles. So can you see
102:34 - properties in Africa, can you see properties
in Asia, Europe, North America, or South America.
102:39 - So in order to define these constants, what
I'm doing is I'm setting the value to one
102:44 - bit shifted biota. So the first constant is
admin is one bit shifted zero places, so it's
102:51 - a literal one, the second one is one bit shifted
one place, that's two, and then four, and
102:57 - then eight, and then 16, and so on.
103:00 - So what I have is each one of these constants
is going to occupy one location in a byte.
103:05 - So down here in the main program, I'm defining
the roles in a single byte. And I'm oaring
103:10 - together is admin can see financials and can
see Europe now if you remember, oaring, is
103:16 - going to be set to true if one of the values
is true, or the other one. So his admin has
103:21 - the binary representation of 0000001. I think
that's enough zeros, seven zeros, followed
103:27 - by one can see financials is going to end
up with 100, can see Europe is going to end
103:34 - up with the value 100000. And so when we order
those all together, we're going to get this
103:40 - byte that has these three flags set to true.
So when we run this, we see that we've encoded
103:47 - eight access roles for user into a single
byte of data. So we're able to store this
103:53 - information extremely efficiently. So if I
want to see for example, if this user is an
103:57 - admin, I can go ahead and print his admin,
and then print out the value. And then in
104:05 - order to determine if that's valid or not,
then I can do a little bit of bitwise mathematics
104:09 - here. So I can take the constant is admin,
and that with the roles, and what that's going
104:15 - to do is that's going to apply what's called
a bit mask. So only the bits that are set
104:20 - in the is admin constant, and our roles are
going to be left as true, which means if we're
104:24 - an admin, we're going to have the value one
set at that first bit. And then I can compare
104:29 - that to the is admin constant. So when I run
this, if we have the admin role, then we're
104:35 - going to get the value true. Now, if I check
something that I don't have the role, so let
104:39 - me go ahead and copy this down. And then let's
just see if they're at the headquarters, so
104:46 - we'll put that in here. And it's exactly the
same bitwise operations, we're just changing
104:52 - our mask. If we run this, we see that is headquarters
equals false Actually, let me put in my Line
105:00 - return here, and then run this again. And
you see that is headquarters equals false.
105:05 - So we can very quickly and very efficiently
store a lot of different information about
105:09 - what roles and access rights a user might
have, and a simple byte. And having this constant
105:14 - defined with a numeration expression makes
it really fast and really efficient and really
105:19 - clear in our application. Okay, so let's go
into a summary and review what we've talked
105:23 - about in this video. constants are another
one of those foundational elements, that is
105:28 - going to be a part of almost every application
you're going to write. Now, the first thing
105:32 - that we learned about with constants is that
they're immutable, but they can be shadowed.
105:37 - So we can create a constant, we cannot assign
a new value to it. But if we create a constant
105:42 - on an inner scope from an existing constant,
then not only can we change the value, but
105:47 - we can even change the type, because that
inner scope is going to shadow the outer scope
105:51 - constant, they have to be replaceable by the
compiler at compile time, so the value must
105:56 - be calculable. So we're not gonna be able
to access functions or command line arguments
106:01 - in order to determine the value of the constants
in our application. But we are going to be
106:05 - able to do simple expressions like we talked
about in the enumeration section. They're
106:10 - named like variables. So if you want to export
the value of the constant outside of your
106:14 - package, then you're going to use Pascal casing.
And if you want to leave it as an internal
106:18 - value to the package, then you're going to
use camel casing to name that constant. Type
106:24 - constants work just like immutable variables.
So you can use them in arithmetic operations,
106:28 - you can pass them into functions, but they
can only interoperate with the same type untyped
106:34 - constants have a little bit more flexibility.
So they work just like the literals. So if
106:39 - you replace that constant throughout your
application with the literal value of that
106:43 - constant, that's how it's going to work. So
that's going to allow us to interoperate with
106:46 - similar types. So we had the value 42 defined
as an untyped constant. And we could add that
106:51 - to an integer 16, we could add that to an
integer, we can add that to a un 16. Any of
106:56 - those would work, because the literal 42 will
work in all of those cases. Then we talk about
107:02 - the enumeration types that we can work with.
And we learned about the special symbol Iota.
107:07 - That allows us to start with as values zero
and increments one time every time we use
107:12 - it inside the same const block. Now the one
thing that we have to watch out for is that
107:16 - constant values that match the zero values
of variables can cause subtle bugs in your
107:21 - application, because you might have logic
that you expect it to initialize the value
107:24 - of the constant. And if something happens
and then initialization doesn't occur, then
107:29 - you're going to be working with zero value,
which might give you a false match to a constant
107:32 - that you're evaluating
107:33 - against. Using that Iota operator, we can
actually create what are called enumeration
107:38 - expressions. So we can define the value of
the constant dynamically by combining Iota
107:44 - with any arithmetic bitwise operation, or
bit shifting operation that's allowable with
107:50 - the primitive type that the constant and representing,
I want to talk about the first two collection
107:54 - types that we have available and go arrays
and slices. Now, arrays form the basis of
108:00 - slices. So I want to start a discussion with
those. And when we talk about arrays, we're
108:04 - going to talk about how to create them the
built in functions that go offers us to understand
108:09 - what's going on with our arrays. And then
we'll do some exercises working with arrays
108:12 - and see how we can use those in our applications,
then we're going to follow the same pattern,
108:17 - but we're going to switch over to slices.
So we'll learn the various ways that we can
108:20 - create slices, we'll learn the built in functions
that we can use to understand what's going
108:24 - on with our slices. And then we'll do some
exercises working with those. Okay, so let's
108:29 - go ahead and get started by learning how to
create an array. So the first thing that I
108:34 - want to discuss about arrays is the use case
for them. Why do we need them and what are
108:38 - they used for? So let me just drop in an example,
let's just say that we're building an application
108:43 - that's going to work with the grades of students
in a class. So with that arrays, we're going
108:48 - to end up with an application something like
this, we're going to have maybe grade one,
108:51 - grade two, grade three, and then we can print
out those grades. So we can go ahead and run
108:55 - this. And we see that we get the scores 9785
and 93 printed out. Now this works sort of.
109:02 - But we got a lot of problems here, because
our application needs to know exactly how
109:06 - many grades we have to work with, at the time
that we're designing the application. And
109:11 - working with these grades as a collection
becomes very cumbersome. So enter the array,
109:15 - and that's going to solve all of our problems.
So in order to see what an array looks like,
109:20 - let's go ahead and delete this code here.
And then we'll create an array, that's going
109:24 - to hold the grades for us. Now the way we
declare an array is we're going to start with
109:29 - the size of the array. So we're going to use
square brackets and then we're going to have
109:32 - an index that's going to be the number of
elements that are array can hold, and then
109:36 - the type of data that the array is going to
be designed to store. So an array can only
109:41 - store one type of data. So in this case, we're
declaring an array of integers that can hold
109:45 - up to three elements. If we wanted to hold
a different type, say we want them to have
109:49 - an array of strings, then we would type this
to a string, and so on. So you have to specify
109:53 - at the time that you're declaring the array,
what type of data you're going to store. And
109:58 - then we can use this initializer syntax To
put in the values for our array, so we can
110:03 - put in the same scores that we had before
9785, and 93. And then, if we come into our
110:10 - print statement here, and add our grades as
what we're going to print, then we see that
110:15 - we have all of the grades printed out together
in this collection called an array. Right
110:21 - now, that's a convenient collector. As we
start getting into looping constructs and
110:25 - things like that, we're going to really find
that having things grouped into arrays and
110:29 - slices and the other collection types is a
very powerful way for us to work with our
110:33 - data. Now, another advantage that we have
with working with arrays is the way that they're
110:38 - laid out in memory. So if you declare three
different variables and specify their values,
110:43 - it's impossible to know how they're going
to be laid out by the go runtime with arrays.
110:47 - However, we know by the design of the language
that these elements are contiguous in memory,
110:53 - which means accessing the various elements
of the array is very, very fast. So by collecting
110:58 - our data together in arrays, not only is it
easier to work with, but it also makes our
111:02 - applications generally a little bit faster.
Now one problem that we have in this example
111:06 - here is if you look at it, we're actually
declaring the size of the array twice, because
111:12 - we have this syntax here, where we're saying
that we're creating a three element integer
111:15 - array, but then we're adding three elements
to it. And that's not really required. If
111:20 - you're going to be initializing an array literal
like we're doing here, then you can actually
111:24 - replace the size with these three dots here.
Basically, what that says is create an array
111:30 - that's just large enough to hold the data
that I'm going to pass to you in the literal
111:33 - syntax. So in this case, we're going to get
an array that has three elements in it. And
111:37 - that's implied by the fact that in this literal
syntax, we've passed three integers to it,
111:42 - we can also declare an array that has a certain
size, but has its values zeroed out, by doing
111:48 - something like this, if we declare an array
called students, and let's make that a three
111:53 - element array that's going to hold strings.
And then let's print out what we have in that
111:57 - array. So if we print out, students, make
sure I'm spelling everything correctly and
112:01 - run this, then we see that we have an array
that's empty. So we have declared a three
112:06 - element array that can hold strings. But obviously,
there's no elements in there right now. So
112:10 - in order to specify a value in the array,
we're going to use this syntax, so we're going
112:15 - to call upon the array, and then we're going
to tell it which index we want to work with
112:19 - within the array. So in this case, we're working
with the zeroeth index of the students array.
112:25 - And then let's just assign the name Lisa to
it,
112:28 - then we can go ahead and print out our array
again, and run it. And now we see that we
112:33 - have, I always forget to add this line return
here, then we see initially we have an array
112:37 - of students that's full of empty strings.
In the second instance, we've actually specified
112:42 - that first element. Now you may be wondering
why we're starting with the value zero. And
112:46 - the reason is related to how arrays are made
up of contiguous blocks of memory. So when
112:51 - we talk about students as the name of the
array, what go is going to do is it's going
112:56 - to have a pointer or it's going to remember
the location of the beginning of that array.
113:00 - And then the index that we pass in this case
zero, is going to tell it how many strings
113:06 - to walk forward. So it knows that when it
has a string, a string has a certain length.
113:12 - And so it's going to walk that many strings.
So when we pass zero, it's going to be the
113:17 - head of the students array moved forward zero
string elements. And so that's going to be
113:22 - the first element of our array. So we can
finish this example out, if I drop some code
113:28 - in here, we can see what it would take to
fill out this array. So in this case, we got
113:33 - the zeroeth element to Lisa, the first element
is Ahmed. And the second element is Arnold.
113:38 - So if we print that out, we see the expected
result, where we have Lisa, Ahmed and Arnold.
113:43 - And it doesn't matter what order we work with
these, if we flip these around, then we find
113:49 - that they do flip around in the array, we
can assign them in any order that we want.
113:52 - Now if we want to get add a specific element
in the array, then we can use this square
113:57 - bracket syntax again, and dereference the
element from the array. So if we do this,
114:02 - and then change our label again. So we're
going to get the second element of the array,
114:07 - which is index one, then we can go ahead and
run this. And then we see that the second
114:12 - element has the value of Arnold. So we can
use this square bracket syntax in order to
114:16 - assign values to the array, as well as to
pull out the values that have been assigned.
114:20 - Now another thing that we can do is we can
determine how big the array is. Now, obviously,
114:24 - we created the array up on line eight. So
we remember at design time that we created
114:29 - this, but there may be a situation where you
need to go back and review the size of the
114:32 - array that you're working with. And the way
that we can do that is using the built in
114:36 - length function. So if I drop in another print
statement here, and format that, you see that
114:43 - we can get the number of students in array
using this built in alien function and passing
114:48 - in the array. So if we run this, then we see
that we get the number of students equals
114:52 - three and that's going to print out the size
of the array. So if we change the size of
114:56 - the array to say five then the results of
printing The array isn't going to change,
115:01 - but the size of the array does. Now one thing
that's important to remember is that an array
115:06 - can be made up of any type, it just always
has to be the same type for a given array.
115:11 - So we've been working with arrays of integers
and arrays of strings. So we've been working
115:14 - with primitives. But this example here shows
that we can actually make up arrays have anything
115:19 - else. So in this case, we've got an array
of arrays. So let's just say that we're working
115:23 - with some linear algebra. And we need the
identity matrix, which is a concept that's
115:27 - used pretty often in linear algebra. So this
array here stores a three by three identity
115:32 - matrix. So the first row is going to hold
the values 100, the second row is going to
115:37 - hold 010. And the third row is going to hold
001. So if we go ahead and print this out,
115:43 - then we see that we do in fact, get those
values. Another way to look at this, and maybe
115:47 - a little bit easier to see is using this way
here. So we're just going to declare the array
115:52 - of arrays, and then we're going to initialize
each one of those rows individually. So this
115:56 - reads a little bit cleaner, and might be a
little bit easier for you to understand what's
116:00 - going on. And if we run this, we get the exact
same result. Now the last thing that I want
116:04 - to talk about with arrays is something that's
a little bit different with arrays and go
116:08 - than in other languages. And that is that
arrays are actually considered values. So
116:14 - in a lot of languages, when you create an
array, it's actually pointing to the values
116:18 - in that array. So if you pass things around,
you're actually passing around the same underlying
116:21 - data. But in go, that's not true. When you
copy an array, as we're doing on line nine,
116:27 - here, you're actually creating a literal copy.
So it's not pointing to the same underlying
116:31 - data is pointing to a different set of data,
which means it's got to reassign that entire
116:36 - length of the array. So if I run this, you'll
see what I'm talking about here. So on line
116:41 - eight, I assigned an array on line nine, I
created another variable b and assign that
116:46 - to a, and then on line 10, I changed the second
element of the array to the value five. And
116:51 - what you see is that when I print out the
array, it has the original values 123. But
116:57 - B has the new values of 153. So when you're
working with these, you have to be a little
117:01 - careful, because copying arrays, especially
when we get into functions, if you're passing
117:06 - arrays into a function, go is going to copy
that entire array over. So if you're dealing
117:11 - with a three element array, that's not a big
deal, if you've got a million elements in
117:14 - your array that could slow your program down
a little bit. So what do you do if you don't
117:19 - want to have this behavior? Well, we haven't
talked about it yet. But I want to give you
117:23 - a hint right now in order to cover this completely.
117:26 - And that is this idea of pointers. So the
way that our program is working right now
117:31 - is that the value B is assigned to a copy
of the array. But if we do the address of
117:38 - operation, which is this character here, then
what we're saying is B is going to point to
117:42 - the same data that he has. Now we'll get into
more detail about what this means later. But
117:47 - the long and the short of it is if I run this,
now, A and B are pointing to the same data.
117:52 - So A is the array itself, and B is pointing
to a. So when we change the value in line
118:00 - 10, we're actually changing the same underlying
data for both. So when we print them out,
118:05 - we see that the array has changed, as well
as the array that B is pointing to, because
118:10 - they happen to be exactly the same array.
Now arrays are very powerful. And there's
118:14 - a lot of use cases where you can use arrays
very efficiently. However, the fact that they
118:19 - have a fixed size that has to be known at
compile time definitely limits their usefulness.
118:25 - So in go, the most common use case for using
arrays is to back something called a slice.
118:30 - So let's take a look at a slice. So the first
thing that I want to do is comment out a couple
118:34 - more items in this example here. So we'll
comment on this one, this one and this one.
118:39 - And then we'll change this over to slice syntax.
So the way we're going to do that is simply
118:43 - by eliminating these three dots here. So a
slice is initialized as a literal by just
118:48 - using the square brackets, the type of data
we want to store. And then in the curly braces,
118:53 - we can pass in the initialized data. So we
go ahead and run this, we see that we get
118:57 - the values 123, it looks exactly like an array.
And as a matter of fact, everything we can
119:02 - do with an array we can do with a slice as
well, with one or two exceptions. So in order
119:06 - to illustrate that, we have the length function
that we talked about with an array, well,
119:11 - we have the length function with a slice as
well. So if I run this, we see that we do
119:15 - get the length of three. So we initialize
the slice with values 123. So with three elements,
119:20 - so the length function gives us a value of
three. Now there's an additional function
119:24 - that we have available with slices, and that
is the capacity. And that's because the number
119:28 - of elements in the slice doesn't necessarily
match the size of the backing array, because
119:34 - the slice is really a projection of that underlying
array. So we can have a very large array and
119:40 - only be looking at a small piece of it. Now
if we run this example, we see that the capacity
119:45 - function returns the value three. So the underlying
array is exactly the same size as the slice.
119:52 - But as we go along here, we'll see how we
can get into situations where the length and
119:56 - capacity are different, and why that's a very
good thing.
119:59 - Now unlike Like
120:00 - arrays, where we have this syntax here, and
we have to use this address of operation in
120:05 - order to point to the same data slices are
naturally what are called reference types.
120:10 - So they refer to the same underlying data.
So if we run this example, again, remember
120:15 - when we ran this with an array, we saw that
B store different data than a when we were
120:20 - done. So if we run this, we see that A and
B are actually pointing to the same underlying
120:25 - array. And so when we change the value in
B, we get a change in the value in a. So this
120:30 - is one thing that you're going to have to
keep in mind when you're working with slices.
120:33 - If you got multiple slices pointing to the
same underlying data, you have to keep in
120:37 - mind, if one of those slices changes the underlying
data, it could have an impact somewhere else
120:41 - in your application. Now, so far, we've only
looked at the literal syntax for creating
120:46 - a slice. And that's what we're seeing here
on line eight, there's actually several other
120:50 - ways that we can create slices. And that is
illustrated with this example here. So you
120:55 - see on line eight, we're creating a slice
that has the values one through 10. And then
120:59 - on line nine, we're creating a slice B, and
that's using this bracket with the colon in
121:04 - between. And what that's going to do is, it's
basically going to create a slice of all the
121:08 - elements of what it's referring to. So it's
going to create a slice of all of the elements
121:12 - of a online 10, we're creating a slight C,
and that's going to start with a third element
121:16 - of the parent, and copy all the values after
that. So that's going to start with the element
121:21 - with index three, which is, of course, the
fourth element and every element after that,
121:26 - so this is going to copy four through 10,
into the slice at sea, then on line 11, we're
121:32 - going to do the other syntax, and that's going
to copy everything up to
121:35 - the sixth
121:36 - element. And that's the literal sixth element,
that's not element number seven, that's actually
121:41 - the sixth element, which is going to have
the index five. And then on line 12, we actually
121:46 - see an inner slice. So we're going to copy
the fourth element through the sixth element
121:50 - into our new slice. So let's go ahead and
run this and see what prints out. So we see
121:54 - the first line printed out is the original
slice that we have. The second line is the
121:58 - copy of that slice that's copying all of the
elements. The third line is going to copy
122:04 - the fourth element on so we see the number
four through 10. The fourth line copies everything
122:09 - up to the sixth element, so we get the values
one through six. And then the last line printed
122:13 - out is a slice from three to six. And so we're
gonna get the elements four, five, and six
122:17 - printed out. So that can be a little bit confusing,
because the first number has a slightly different
122:21 - meaning than the second number. So basically,
the first number is inclusive, and the second
122:25 - number is XClusive. So for example, if we
look at line 12, again, we're going to copy
122:29 - from index three, up to but not including
index six. So that's another way that you
122:35 - can look at it. Now one thing to keep in mind,
remember what I said that all of these operations
122:40 - point at the same underlying data. So if we
take element five, and change that value in
122:46 - the a slice and run this again, notice all
of them teams value, because they're all pointing
122:51 - to the same underlying array. So each one
of these operations includes the fifth index
122:56 - in their results. And each one of those gets
updated to the value of 42. Now another thing
123:01 - to know about these slicing operations is
they can work with slices like we're doing
123:04 - here, but they can also work with arrays.
So if you remember, if I put these three dots
123:09 - in here, it's actually going to turn a into
an array. And if I run this, we get the same
123:14 - result. And that's because slicing operations
can have as their source, an array or a slice.
123:19 - So whatever type of data you're working with,
as long as it's one of those two, you can
123:23 - use these slicing operations. Now the last
way that we have available to us to create
123:27 - a slice is using what's called the make function.
And that's a built in function that we have
123:32 - to work with. So if I delete all this, and
drop this guy out, we're going to use the
123:38 - built in make function. And this takes two
or three arguments. So let's start with two
123:42 - arguments. So the first thing we're going
to say is the type of object that we want
123:46 - to create. So you can use make for several
different operations. In this case, we're
123:51 - going to be talking about making slices. So
in this example, here, we're going to make
123:54 - a slice of integers. The second argument is
going to be the length of the slice. So in
124:00 - this case, I want to start with three elements.
So now let's just get some information about
124:04 - the slice that we created here. And we'll
do that by dropping in a couple of print statements.
124:09 - So we'll print out the values of the slice,
the length of the slice and the capacity of
124:12 - the slice. So they run this, no big surprise
it zeroed out. So when I create a slice, everything
124:18 - gets set to the zero value, which is what
we always expect in go to happen every time
124:22 - we initialize a variable, we expect it to
be initialized to zero values. And that's
124:26 - true for slices just like it's true for primitives.
When we asked for the length, we get a length
124:31 - three, when we ask for the capacity, that's
also set to three. Now we can also pass a
124:36 - third argument to the make function, and that's
going to set the capacity. So keep in mind,
124:40 - the slice has an underlying array, and they
don't have to be equivalent. So if we run
124:45 - this, we see that we've created a slice of
length three, it's got three elements in it,
124:50 - but the underlying array has 100 elements
in it. So why would we do that? Well, the
124:54 - reason is because unlike arrays, slices don't
have to have a fixed size over there and Life,
125:01 - we can actually add elements and remove elements
from them. So in order to show you an example
125:06 - of that, let me drop in another example here.
And this is going to start with a slice of
125:10 - integers that starts with no elements in it.
So if we go ahead and run this, we see what
125:13 - we expect, we see an empty slice length of
zero capacity of zero. Now, if I want to add
125:18 - an element to this slice, I can use the built
in append function. So this takes two or more
125:23 - arguments, the first is going to be the source
slice that we're going to be working with.
125:28 - So I'm going to start with a and I'm going
to add an element to it. And in this case,
125:32 - all I want to do is add the number one to
it. And then let's go ahead and print out
125:37 - the value of the slice the length of the slice
and the capacity of the slice again. So if
125:42 - I go ahead and run this, we see that in the
second operation, we have a value one stored
125:46 - in there, we have the length of one, and notice
the capacity is two. So that's kind of interesting.
125:53 - What happened here is when we initialize a
slice to the value a go assigned a memory
125:58 - location for the slice. And since it didn't
have to store anything, it basically created
126:03 - an underlying array of zero elements for us.
As soon as we added an element, obviously,
126:09 - it couldn't fit in a zero element array. So
it had to assign an array for us. So what
126:13 - go does is it copies all of the existing elements,
in this case, nothing to a new array that's
126:18 - got a larger size. So when we reassigned,
it actually did create a new array, this one
126:24 - has a capacity of
126:25 - two, and then it put the value one into that
array. Now, when we're dealing with small
126:30 - slices like this, things are pretty cheap
and pretty easy, even if you're resizing the
126:34 - array quite a few times. However, as things
get very large, these copy operations become
126:39 - very expensive. And that's why we have that
three parameter make function. That way, if
126:44 - we know the capacity is going to be somewhere
around 100 elements, you can go ahead and
126:48 - start there. And that way, as you're appending
elements and building up the slicer, you're
126:52 - not constantly copying the underlying array
around. Now, if you remember, when I said
126:56 - the append function can take two or more arguments.
The reason for that is this is what's called
127:01 - a variadic function. So everything after the
first argument is going to be interpreted
127:06 - as a value to append to the slice passed in
the first argument. So if we have this example,
127:12 - here, we're actually going to append the values
234 and five to the slice returned by A. So
127:18 - if we run this guy, we see that we get the
elements one through five created there, and
127:23 - the length is five, like we might expect.
But now the capacity is eight knots not fixed
127:28 - in stone, how go resize of the arrays. But
generally, what I've seen it does is once
127:33 - it fills up the underlying array with a slice,
when you add the next element, it's going
127:38 - to create a new array, and it's actually going
to double the size from the previous array.
127:42 - So if we start with an empty slice, we see
that the array would initially be of size
127:45 - zero, then we'll go to 248 1632, and 64 elements.
So that's something else to be aware of, if
127:52 - you're just over one of those powers of two,
you can actually end up with a lot of memory
127:56 - consumed that you're never going to be using.
So again, if you have the ability to come
127:59 - up with a decent first estimate, then that's
going to be beneficial to you. Now one common
128:04 - situation that you're going to run into is
if you have a slice of elements, and another
128:08 - slice of elements, and you want to concatenate
them together, so you want to have another
128:12 - slice created that has all of the elements
of the first slice, and all of the elements
128:16 - of the second slice. So you might want to
do something like this, if I convert this
128:20 - over to a literal slice, you might want to
run a command something like this. Well, this
128:26 - unfortunately, is not going to work. If I
go ahead and run this, you'll see that we're
128:29 - going to get go complaining to us. And that's
because the second argument to the append
128:34 - function has to have the type of the slice.
So go can only accept integers here. It can't
128:39 - accept a slice of integers. But we do have
a way around this. So I don't know what it's
128:45 - called an NGO in JavaScript, they would call
this the spread operator, where if you have
128:49 - three dots after the slice, it's actually
going to spread that slice out into individual
128:55 - arguments. So if we run this, this is going
to work. And it works exactly the same as
129:00 - if this weren't a slice at all, it's basically
going to take this slice and decompose it
129:03 - into looking something like this. So these
work exactly the same way. But it's a convenient
129:09 - feature to know about if you have slices and
you want to concatenate them together. Now,
129:13 - some other common operations that you might
do with slices are stack operations. So let's
129:17 - just say that we're treating our slices a
stack, and we want to be able to push elements
129:20 - onto the stack and pop elements off of the
stack. And things like that, with the append
129:25 - function is going to allow us to push elements
onto the stack. But how do we pop elements
129:29 - off? Well, we have a couple of different ways
that we want to do this. If we want to do
129:33 - what's called a shift operation, which means
we want to remove the first element from the
129:37 - slice, then we can do this operation here.
And what this is going to do is it's going
129:41 - to create a new slice that starts at index
one, which has the value two in this example,
129:45 - and takes everything else from that. So if
we go ahead and print out the value of b,
129:50 - we'll see that that has the elements two through
five. Now if you want to trim an element off
129:53 - of the end, then you're going to have to use
a different syntax here. So we want all of
129:58 - the initial elements. So we're going to start
with a colon, and then we'll use that length
130:02 - operation, figure out the length of the slice.
But remember, that's going to return the number
130:06 - that's too large, we actually want to remove
an element off. So let's go ahead and do length
130:10 - minus one. And this will have the values one
through four in it. So it's pretty easy to
130:14 - remove an element from the beginning of the
slice or the end of the slice. But what happens
130:17 - if you want to remove an element from the
middle?
130:19 - Well, here, things get a little bit hairy.
Because what we have to do is we actually
130:23 - have to concatenate two slices together, the
first slice is going to be all the elements
130:28 - up to where we want to remove the element.
So in this case, we can take the first two
130:32 - elements, by doing a slice of a, and passing
in colon two for this slice that we want to
130:37 - create, then we have to concatenate to that
all of the element after the index we want
130:42 - to remove. So in this case, we're removing
that middle element. So we'll take from three
130:46 - on and then we have to use this spread operation
in order to spread things out so that the
130:51 - append function is happy. So let's go ahead
and run this and then get my syntax correct
130:56 - here. And now we see that we've got the elements
124, and five. So we've successfully removed
131:01 - an element from the slice, they have to be
a little bit careful here. because keep in
131:06 - mind, we're working with references to the
same underlying array. Because these are all
131:10 - slicing operations, there's one underlying
array and everything is being done on that
131:14 - underlying array. So just to show you the
havoc that we've created here, let me go ahead
131:19 - and print the value of a out here, and then
print the value of a out afterwards and go
131:23 - ahead and run that. And you see we start out
with the elements 12345. Like we might expect,
131:29 - we do our slicing operation, removing the
elements from the middle, we get 1245, which
131:33 - was what we might expect. But then when we
print a out, things look a little weird, because
131:38 - we have that slice that V represents which
is 1245, our three is completely gone, and
131:44 - five is duplicated. So this is something to
be very sensitive about. If you're going to
131:49 - be removing elements from the inside of a
slice using a command like we have on line
131:53 - 10, make sure that you don't have any other
references to that underlying array. Otherwise,
131:58 - you're going to get some unexpected behavior.
So what do you do if you have a situation
132:02 - like this, and you really, really need a to
stay the same, and you really, really need
132:05 - B to change? Well, unfortunately, we don't
have the tools to work with this right now.
132:09 - Because what we're going to need to do is
to use a loop to create a copy of that slice
132:13 - that doesn't point to the same underlying
array, and then you can make the manipulation.
132:17 - So when we get to the looping section, we'll
show you how to do loops. And then you'll
132:20 - have all the tools that you need in order
to handle that situation. For now, the only
132:24 - thing I can say is be aware of this behavior.
And if you get into a situation like this,
132:29 - understand that you're going to have to do
a little bit of research in order to make
132:31 - sure that your application responds correctly.
Okay, so that covers what I want to talk about
132:37 - with the raising of slices. Let's head into
a summary and review what we've talked about.
132:42 - arrays and slices are very common in NGO applications.
And I think you're going to see them all over
132:47 - the place as you start to work more and more
with the language. So I hope that this conversation
132:51 - has really helped you understand what arrays
and slices are and some basics about how you
132:55 - can work with them. We started our discussion
by talking about arrays. And we learned how
133:00 - there are collections of items with the same
type. So you can't create an array that has
133:04 - strings and integers and things like that
all of the types have to be the same, but
133:08 - does collect them all together. And as we
start to get into conversations about looping
133:12 - and things like that, we're going to find
how we get some very powerful tools that we
133:16 - can work with, when we're basing our data
on arrays and slices. They are fixed size.
133:22 - So when you create an array, you have to specify
at compile time how big that array is. And
133:27 - it can never change. So you can't make them
smaller, and you can't make them larger. There
133:32 - are three different ways that we can declare
an array, we can do the literal style, like
133:36 - you see on this first line, where we're going
to specify the number of elements and then
133:39 - we use a literal that's going to initialize
those elements. However, we do have a shorthand
133:44 - notation that uses three dots instead of that
first size. And that's going to be a little
133:48 - bit more robust in your application design.
Because if you run into a situation where
133:52 - you need to add another literal, you don't
have to remember to update the size of the
133:55 - array, it's going to update automatically.
We also have this third syntax where we can
134:00 - declare a zero data array. In this case, we're
going to declare an array of three integers,
134:04 - each one of those integers is going to start
with the value zero. We also talked about
134:08 - how arrays are zero based. So we're going
to be counting from the head of the array.
134:12 - So the first element in the array has the
index zero, the second element has the index
134:17 - one, and so on. So in this example, if we
asked for the index one of array, we're going
134:23 - to get the value three out, we have the Len
function that's going to return the size of
134:27 - the array in case you need to know that some
other place in your application. And you want
134:32 - to have a way to be able to handle that robustly.
That's not relying on the fact that you know,
134:36 - at design time how big that array is, you
can use the Le n function to interrogate the
134:40 - size of the array. Anytime you're moving the
array around, it's going to copy the underlying
134:45 - data. So if you have a three element array,
and you assign that to another variable, all
134:50 - three elements are going to be copied to a
new location in memory and you're going to
134:53 - be working with an independent copy. So that
can cause some unexpected behaviors because
134:58 - if you change that copied array unexpected
changes to be reflected back in the initial
135:02 - array, that won't happen. And it can be very
expensive because all that memory has to be
135:06 - allocated a second time.
135:08 - Then we moved on to discuss slices and how
they're very similar to arrays. As a matter
135:11 - of fact, they're backed by an array. So every
slice that you see, under the covers, go has
135:16 - an array that's holding all of that data for
you. There are several creation styles, we
135:21 - saw that we can create a slice by slicing
an existing array or another slice, we have
135:25 - the literal style that we can use, which is
very similar to the array literal, except
135:29 - for we just leave those three dots out, because
the size of the slice is dynamic. And so it
135:34 - can be determined at runtime, we also saw
how we can use the make function. So if we
135:39 - pass two arguments to the make function, the
first is going to be the type of slice that
135:42 - we want to create. So in this example, we're
going to create a slice of integers. And the
135:46 - second parameter is going to determine the
length and the initial capacity of the slice.
135:50 - If we need a capacity that's different than
the initial length, then we can pass a third
135:55 - parameter into the make function. And that's
going to allow us to specify a capacity independent
135:59 - of that initial length, the Len function returns
the length of the slice itself, whereas the
136:04 - capacity function returns the length of the
underlying array. So if for some example,
136:09 - you want to control the resizing of the slice,
you can go ahead and do that. And use that
136:13 - capacity to function to understand when you're
starting to get to your limits, you can also
136:17 - use the append function to add an element
to the slice. And what that's going to do
136:21 - is it's going to take in a parent slice, and
it's going to take in one or more elements
136:25 - to add to that slice. Now through the course
of that append operation, you can add elements
136:29 - that exceeds the capacity of the underlying
array. If that happens, then you are going
136:33 - to trigger a copy operation. And all of those
elements are going to have to be copied to
136:37 - a new location. So be aware of that. If you're
dealing with large slices of data, and you
136:42 - end up resizing, a lot of times your application
performance can suffer, you might want to
136:46 - think about using that three parameter make
function, in order to set the capacity of
136:51 - the slice close to where you need it to be.
When you're passing slices around in your
136:55 - application. Keep in mind that assigning a
new value to an existing slice actually points
137:00 - to the same underlying array. So if you manipulate
the slice in one location, it's actually going
137:05 - to affect all the other slices that are pointing
to that same underlying data. So we talked
137:10 - about an example where we created a slice
and removed the middle element out of it.
137:14 - And we saw how that actually affected the
initial slice, and could cause some behavior
137:18 - that we weren't expecting. I want to complete
the discussion, I started in the last video
137:22 - by talking about the two remaining collection
types that are available and go. And those
137:26 - types are mapped in structs. So we'll start
our discussion by talking about maps, we'll
137:32 - talk about what they are, how we can create
them, and then how we can manipulate the data
137:36 - within the maps, then we'll move on to the
struct data type, we'll talk about what they
137:40 - are, how we can create them, then we'll move
on to the naming conventions that we're going
137:44 - to have to be aware of as we're working with
structs, then we'll talk about a concept called
137:48 - embedding, and how we can use that to have
a struct that we're creating inherit a lot
137:53 - of functionality from a base struct, then
we'll finish our discussion of structs by
137:57 - talking about a concept called tags, and how
we can use tags to provide some additional
138:02 - information about the fields within our structs
to help the consumers of objects created from
138:07 - the struct get additional information about
how that field is intended to be used. Okay,
138:11 - so let's begin our discussion by talking about
what maps are and how we can use them. So
138:16 - the first thing that we're going to need to
get our heads around when we're talking about
138:19 - maps is what exactly a map is. And I think
the easiest way to show you what a map is,
138:23 - is by showing you a map. So we have an example
here of a variable called state populations.
138:28 - And this represents a map of US state names
over to the population within those states.
138:34 - So what we see here is a map is going to take
some kind of a key, in this case, the state
138:40 - names, and it's going to map that over to
some kind of a value, in this case, the population
138:44 - of that state. So what this provides us is
a very flexible data type. When we're trying
138:49 - to map one key type over to one value type.
138:53 - Now there's a couple of constraints we're
going to have to keep in mind. As you can
138:55 - see up in the Declaration on line eight, we're
going to map one key type to one value type.
139:02 - So all of the keys in this map have to be
of type string, and all of the values have
139:06 - to be of type integer. Now we can use a lot
of different types for the keys. And we can
139:10 - use any type for the value. But when we declare
a map, that type has to be consistent for
139:15 - every key value pair within the map. So if
we run this, we can see an example of what
139:20 - a map looks like when we print it. And it's
not the best output in the world, but we can
139:23 - get an idea of what's going on. So we see
that we get the key value pairs printed out.
139:27 - So we get California, Texas, Florida, New
York, Pennsylvania, Illinois, and Ohio. So
139:32 - one thing that I just alluded to is that we
have a lot of options with the key type, but
139:36 - we don't have an infinite number of options.
So the basic constraint on the keys when you're
139:40 - creating a map is they have to be able to
be tested for equality. Now most of the types
139:46 - that we're working with can do that. So Boolean
can be tested for equality, all of the numeric
139:50 - types, strings, pointers, interfaces, structs
arrays, and this thing we haven't talked about
139:55 - called channels. All of those can be tested
to see if one instance of for example For
140:00 - a string variable is equivalent to another
one. However, there are some data types that
140:04 - cannot be used for equivalency checking. And
those are slices, maps and other functions.
140:10 - So for example, if we create a map called
m, and we'll make that a map of, say we want
140:15 - to map slices of integers over two strings.
And we'll use the literal syntax for that,
140:22 - and then we print that out, then you would
expect a map to print out. But in fact, we
140:27 - get an error because we've got an invalid
key type because a slice cannot be a key to
140:30 - a map. However, if we had an index here, then
it turns it into an array. And now we do get
140:36 - a successful printout, of course, the map
is empty. So we don't see anything, we just
140:40 - see this empty map right here. But we were
successfully able to create the map, because
140:45 - an array is a valid key type, but a slice
is not. So what are the different ways that
140:49 - we can create a map? Well, you see, the first
way here, this is the literal syntax, and
140:53 - this is going to probably be the most common
way you're going to see maps created. So we
140:58 - just need to declare the type of map. And
we're going to do that using this syntax that
141:01 - we see here on line eight, where we're going
to start with the map keyword in square brackets,
141:06 - we're going to list the type of the key, and
then after the square brackets, we're going
141:09 - to list the type of the value. Another way
that we can do this is we can use the built
141:14 - in make function again. Now we first saw the
make function when we were talking about slices.
141:18 - But we can use that once again here. So if
I copy this variable up here, and I set this
141:23 - equal to the result of calling the make function,
and we're going to tell it what type of map
141:27 - we want to make. So we're going to use the
map keyword again, the key is type string,
141:32 - the value is type integer. And now we can
go ahead and remove this colon. And if we
141:37 - run this, we have to remove our m again from
our print statement. Now if we run it, we
141:42 - get the same value printed out. So this is
a common way that you can work with maps,
141:47 - if you don't have at the time that you're
declaring the variable, the entries that you're
141:51 - going to want to put in it. So for example,
if you're populating the map within a loop,
141:54 - you might use this syntax. Now another option
that you have with the make is it will take
141:59 - a second parameter. So if I run that like
this, then that works. However, I wasn't able
142:04 - to find the intention for this. So this is
available. But it doesn't seem to affect the
142:08 - length of the map that's created, the map
is always going to be the length of the number
142:12 - of elements in it, but it might have some
effect under the covers. If you find that
142:16 - what that's for, please leave a comment down
below. So that I can learn along with you
142:20 - know, let me go ahead and remove this because
I don't know what it's there for. And I haven't
142:24 - seen that very commonly used and run this
again. And we can see that we're back to where
142:28 - our map used to be. Now how are we going to
manipulate the values in our map? Well, the
142:33 - first thing that we can do is we can pull
out one single value from the map by using
142:37 - the square brackets and typing in the value
of the key. So the key can be provided either
142:43 - as a variable or as I'm doing here as a literal.
So if I go ahead and run this, we see that
142:48 - we get the population of Ohio is 11 point
6 million people. So we can interrogate the
142:52 - values of our map. Using this syntax here.
We can also add a value to our map using a
142:57 - very similar syntax. So we call on the state
populations variable. And I add a key. In
143:03 - this case, let me add the next largest state,
which is Georgia. And it as of 2016, had a
143:09 - population of 10,310,371. Now I can pull that
value back out, run this. And we see that
143:18 - we get that value printed out of our map.
If we print the entire map out, we see right
143:23 - here, Georgia gets added in here. Now, something
you might have noticed, let me do this, I'm
143:28 - going to copy this print line here, put it
above where we added the Georgia key. And
143:33 - notice the ordering is different. And this
is going to be a very important thing to keep
143:37 - in mind as you're iterating through maps later
on,
143:39 - the return order of a map is not guaranteed.
So even though we declared California, Texas,
143:45 - Florida, New York, Pennsylvania, Illinois,
Ohio, and then added Georgia, this is not
143:50 - like a slice, a slice or an array would return
those elements in exactly the same order we
143:54 - provided them. In a map, everything is stored
in a way that cannot guarantee the order upon
144:00 - returning. So even though we just added one
entry here, it completely changed how everything
144:05 - was organized within the map, and we get it
a little bit different output. Now another
144:08 - thing that I want to show you is that we can
delete entries from the map. So we can do
144:12 - that using the built in delete function. The
first is the map that we want to delete from,
144:17 - and then we need to provide the key that we
want to delete. So if we go ahead and delete
144:21 - Georgia back out, it wasn't there very long.
But if we run it looks like I need to add
144:27 - my s here. Now if we run it, we see that ga
is no longer part of our map. So we can add
144:34 - by just calling on the map providing a new
key and value. We can delete using the built
144:39 - in delete function, and we can interrogate
a value from the map using those square brackets.
144:44 - Now, an interesting thing about deleting is
if I asked for the value of that key again,
144:50 - what do you think I'm going to get? So we
see here in the output, Georgia is no longer
144:55 - part of the map. So you might expect some
sort of error to be raised. Well, in fact,
144:59 - if I run this We get the value zero out. Now
that should cause you some concern, because
145:04 - does Georgia have a population of zero? Or
is it missing from our map? Did I just misspell
145:09 - the key? What's going on? So for example,
if I fat finger, Ohio, and I forget the I
145:17 - and run this, I get a value zero. Well, did
everybody move out of Ohio? What happened?
145:22 - What with what we know right now, there's
no way for us to really now. So there's another
145:26 - way that we can interrogate our map. And that
is using what's called the comma. Okay, syntax.
145:32 - So with doing what we know, right now, we're
basically doing this, we're calling state
145:36 - populations. And we're asking for the key,
Ohio, and I'll continue that misspelling.
145:42 - And then we're printing out the value of that
population variable, and we get the value
145:45 - zero. Well, we can also add an optional comma,
okay, here. And when we do this, let's go
145:52 - ahead and add that okay, variable to the output
and see what that's going to do. So notice
145:56 - that this prints out the value false. So the
okay is false if the key was not found within
146:02 - our map, but if we add the eye back in and
correct our spelling, we see that we get the
146:06 - value true out. So if you're in a situation
where you're not sure if the key is in the
146:10 - map or not, then you can use this comma, okay,
syntax. As a matter of fact, if you just want
146:15 - to check for presence, then we can use that
right on the operator again, in order to throw
146:20 - away the actual value. And then we just get
the okay variable printed back out. Now, there's
146:24 - nothing magic about the variable name, okay.
But it is conventional to use, okay, and you
146:29 - go programs when you're using it for this
kind of a test. The next thing that I want
146:33 - to show you about maps is we can in fact,
find out how many elements are in them. So
146:37 - we can do that using the built in Le n function.
So if I go ahead and run that, we see that
146:42 - we get the value seven, and we have let's
see 12345 yet we have got seven states declared
146:47 - in our map right now. So if we added another
state back in, then the length function would
146:51 - return eight. The other thing that's interesting
to know is that just like slices, when you
146:57 - have multiple assignments to a map, which
is especially important when you're passing
147:01 - maps into functions, the underlying data is
passed by reference, which means manipulating
147:07 - one variable that points to a map is going
to have an impact on the other one, so I can
147:12 - demonstrate that by creating another variable
called SP, and set that equal to state populations.
147:18 - And then let's go ahead and delete poor Ohio
out of SP, it always seems to get left out.
147:23 - And then we can print out SP and print out
state populations. So if I run this, we see
147:30 - that in our first result, we don't have the
entry Ohio anymore. And then our second
147:35 - print statement, which is the original map,
Ohio has been removed from there as well.
147:39 - So if you start passing maps around and you
start manipulating the data within that map,
147:43 - keep in mind, you can have side effects on
the calling functions or any other place where
147:48 - that map is referred to. Because manipulating
the map in one place is going to have impacts
147:53 - on every other place to use. So the final
collection type that I want to talk about
147:57 - today is called a struct. Now at first, you
might not think of a struct as a collection
148:02 - type. But go with me on this, if I drop in
an example, we see here an example of a struct.
148:07 - Now I'm in kind of a doctor who frame of mind
today. So we're going to run with an example
148:10 - that's talking about some information about
one of the doctors from Doctor Who. So if
148:14 - I go ahead and run this, we can see that we're
getting information on the third doctor, the
148:18 - actor's name is john Pertwee, we see some
of his companions listed out here. So the
148:23 - reason I call this a collection type is look
at the declaration or the struck on line seven
148:27 - through 11. What we have here is a list of
field names. So we've got number, actor name
148:33 - and companions as field names, and then a
type associated with that field. So the doctor
148:39 - number is an integer, the actor name is a
string, and the companions is a slice of strings.
148:44 - So what the struct type does is it gathers
information together that are related to one
148:51 - concept, in this case, a doctor. And it does
it in a very flexible way. Because we don't
148:55 - have to have any constraints on the types
of data that's contained within our struct,
148:59 - we can mix any type of data together. And
that is the true power of a struct. Because
149:04 - all of the other collection types we've talked
about have had to have consistent types. So
149:09 - arrays always have to store the same type
of data slices have the same constraint. And
149:14 - we just talked about maps and how their keys
always have to have the same type. And their
149:18 - values always have to have the same type within
the same map. When a struct we can have our
149:22 - fields describe any type of data that we want.
So we can have structs that contain other
149:26 - structs, anything that we want. So while in
a lot of ways, structs are the simplest type
149:31 - of collection that we're going to be talking
about. They're also one of the most powerful.
149:35 - So we see down here in the main function,
how we can create a struct and I'm using the
149:39 - declaration syntax, where I'm using named
fields. So we're going to create a variable
149:43 - called a doctor. And we're going to use this
literal syntax. So we list the type of the
149:47 - struct doctor, we use the curly braces like
we do with every other literal definition.
149:52 - And then I have a list of the field names
colon and the value. So number colon three
149:57 - after name colon, john Pertwee, and then campaign
To set equal to this slice of strings now
150:02 - notice that when I'm setting something equal
to a slice, I do actually have to tell go,
150:06 - what kind of collection type, I'm initializing
for that, and then down here on line 23, I
150:11 - go ahead and print the entire value of the
struct out. And you see that I get the values
150:15 - printed out, I see three, john Pertwee, and
then the three companions that john Pertwee
150:19 - had, in his time as the doctor. Now if we
want to interrogate one value from a struct,
150:24 - then we're going to use what's called the
dot syntax. So if we ask for the actor name
150:29 - of this struct, then we're going to put a
dot after the variable name, put in the field
150:33 - name. And when we run this, we see that we
get john Pertwee out. So we can work with
150:38 - the struct as a whole, or we can start drilling
down. As a matter of fact, we can drill down
150:42 - through the structure. So if we ask for the
companions, we can get that out, certainly.
150:49 - But this is a slice like any other slice.
So if I just want the second item in the collection,
150:54 - I can get Joe grant out by interrogating the
slice that gets returned by asking for the
150:59 - companions field. Now another way that we
can instantiate our struct is using what's
151:03 - called a positional syntax. So here, I'm listing
the field names, but it don't have to. So
151:08 - if I go ahead and take these out, and take
this out, so I print the entire struct out,
151:14 - then I get exactly the same result as I got
the first time. Now, this is valid go syntax,
151:19 - I would encourage you not to use it, though.
And the reason for that is it can become a
151:23 - maintenance problem. So for example, let's
just say that this is our struct, and this
151:27 - is checked into source control, and everybody's
happy with it. But then let's say we have
151:31 - a change request Comm. And we're going to
add a list of the episodes that each doctor
151:36 - appeared in. So that's going to be another
slice of strings. And that gets added right
151:39 - here.
151:40 - Well, if we use the positional syntax and
try and run this, we've got a problem. Because
151:44 - go doesn't know how to map the fields that
we provided into the initializer. Because
151:49 - there's three values provided in the initializer.
And there's four values in the struct. So
151:53 - we have to find every place that we have one
of these declared with the positional syntax.
151:57 - And we have to add, for example, a placeholder
or populated or something. So we go ahead
152:02 - and run this and everything's working again.
But now, what happens if another change comes
152:07 - along, and somebody does this? Now they've
changed the order of the fields. When we run
152:13 - this, everything looks fine. But when I asked
for the doctor's companions, again, I get
152:21 - an empty slice, because the positional syntax
requires the fields to be declared in the
152:26 - correct order, much better for us to go ahead
and add in the field names. So let me drop
152:30 - those in real fast here. Now when I run this,
I get the expected results out. And notice
152:36 - what the field names syntax, I don't even
have to have it in the same order as they're
152:39 - declared in the struct go is going to figure
out how to map the data from the initializer
152:44 - over into the object that's created by using
those field names. The other advantage that
152:49 - I have is, if I don't have any information
about the episodes at this point in my program,
152:53 - I actually can ignore the fact that that field
exists. And what this means is I changed the
152:59 - underlying struct without changing the usage
at all, which makes my application a little
153:04 - bit more robust and change proof. So while
it is possible for you to use the positional
153:10 - syntax, I would strongly recommend you do
not use it unless you've got a very short
153:14 - lived struct. We'll talk about anonymous structs
here in a second. And in those situations,
153:19 - positional declaration might make sense because
that struct is not going to live for very
153:22 - long. However, I would strongly recommend
anytime you're taking the time to declare
153:27 - a type, like we're doing here on line seven,
then you're generally going to be better served
153:31 - by using field names explicitly instead of
the positional syntax. Okay, the next thing
153:35 - I want to talk about are naming conventions.
So as you can see, here, I've got my type
153:39 - declared as Doctor with a capital D, and the
fields declared as lowercase. So the rules
153:43 - in this situation, follow the rules for any
other variable and go, if we start with a
153:47 - capital letter, it's going to be exported
from the package. If we start with a lowercase
153:52 - letter, it's going to be internal to the package.
So in this case, I can work with all of the
153:56 - fields, because I'm declaring the doctor type
in my main package. And so my main function,
154:01 - which is also in the main package has access
to it. However, nothing in any other package
154:06 - would have access to this. So it would be
able to see that there is a doctor struct,
154:10 - but it wouldn't see any field names. So if
I did want to publish these out, so anything
154:14 - can use them, I would have to go ahead and
capitalize these field names, of course, or
154:19 - have to capitalize them in my declaration
as well. And then when I run I get the exact
154:24 - same result that I got before. So I forgot
to change this variable as well go ahead and
154:29 - run that, and I get the expected result out.
So generally, we're going to follow the same
154:33 - convention as we do with any other variable.
uppercase is going to export lowercase is
154:38 - going to import, you should use Pascal casing
and camel casing, you shouldn't have underscores
154:43 - and things like that in your field names or
in your struct names. Now if you notice here
154:47 - on line seven, I have explicitly created a
type called a struct. And that's going to
154:52 - be a very common way that you're going to
see struct to use. You see you're going to
154:55 - define a type and then everywhere you need
to use that struct, you can just refer to
154:59 - it by its type. But we don't have to do that.
And there are some situations where you might
155:04 - see a program like this. So on line eight,
we're declaring what's called an anonymous
155:08 - struct. So instead of setting up a type, and
saying, doctor, and that's going to be a struct,
155:14 - and that's going to have a single field called
name, that's going to take a string. We're
155:17 - condensing all of that into this single declaration
right here. Now, I can't use this anywhere
155:23 - else, because it's anonymous. And so it doesn't
have an independent name that I can refer
155:26 - to it. But I can certainly use this just fine.
So let me go ahead and delete this. And then
155:32 - notice I'm using the initializer syntax right
here. So we got two sets of curly braces,
155:37 - it's very important to remember what each
one is doing. So the first set of curly braces
155:41 - is paired to the struct keyword. And it's
defining the structure of the struct. The
155:46 - second is the initializer. And it's what's
going to provide data into the struct. So
155:50 - if we run this application, we see that we
do get the struct with the value john Pertwee
155:54 - printed out and everything's gonna work just
fine. Now, when are you going to use this,
155:59 - this is going to be used in relatively few
situations, basically, you're going to use
156:03 - this in situations where you need to structure
some data in a way that you don't have in
156:07 - a formal type. But it's normally only going
to be very short lived. So you can think about
156:11 - if you have a data model that's coming back
in a web application, and you need to send
156:16 - a projection or a subset of that data down
to the client, you could create an anonymous
156:21 - struct in order to organize that information.
156:23 - So you don't have to create a formal type
that's going to be available throughout your
156:26 - package for something that might be used only
one time.
156:29 - Now, unlike maps, structs are value types.
So if I take this example here, and let's
156:35 - just use the same basic manipulation that
we've been doing with all of these collections,
156:40 - so I'm going to create another struct, and
I'm going to assign it to the value of my
156:44 - current struct, and then I'm going to manipulate
the value of that name field. So I'm going
156:48 - to create another doctor called Tom Baker.
And then let's see what happens when we print
156:53 - both of these doctors out. So as you can see,
even though I copied another doctor from a
156:58 - doctor, and change the value, the values remain
independent. So a doctor still has the name
157:03 - john Pertwee, another doctor has the name
Tom Baker. So unlike maps, and slices, these
157:08 - are referring to independent datasets. So
when you pass a struct around in your application,
157:13 - you're actually passing copies of the same
data around. So if you've got structs, that
157:17 - are very, very large, keep in mind, you're
creating a copy every time you're manipulating
157:21 - this. Now, just like with arrays, if we do
want to point to the same underlying data,
157:26 - we can use that address of operator. And when
we run this, we have in fact, both variables
157:31 - pointing to the same underlying data. A doctor
is the struct itself. Another doctor is a
157:37 - pointer to the struct. So when we manipulate
its name field, we're actually manipulating
157:42 - the Name field of the a doctor struct. The
next thing that I want to talk to you about
157:47 - in go is a concept called embedding. Now,
you may have heard in your research on the
157:52 - go language that go doesn't support traditional
object oriented principles. So for example,
157:56 - we don't have inheritance, and oh, my goodness,
how am I going to create my program if I don't
158:00 - have inheritance available? Well, let me show
you what go has, instead of an inheritance
158:04 - model. It uses a model that's similar to inheritance
called composition. So where inheritance is
158:10 - trying to establish the is a relationship.
So if we take this example here, if we were
158:16 - in a traditional object oriented language,
we wouldn't want to say that a bird is an
158:20 - animal, and therefore a bird has a name a
bird has an origin, a bird has also bird things
158:26 - like its speed, and if it can fly or not,
go doesn't support that model. But instead,
158:31 - it supports composition through what's called
embedding. So right now we see that animal
158:36 - and bird are definitely independent structs,
there's no relationship between them. However,
158:40 - I can say that a bird has animal like characteristics
by embedding an animal struct in here like
158:47 - this. So I've just embedded the struct itself,
I haven't provided a name. Now, if I did something
158:53 - like this, then how to have a named field
in the bird called animal. But I'm not doing
158:59 - that I'm doing this. So I'm just saying embed
the animal struct right into the bird struct.
159:04 - Now how can I use this? Well, let me drop
in a new main function here. And then you
159:10 - can see, so I'm creating an instance of a
bird. And then I'm initializing the variables.
159:14 - So name is going to be E mu origin is going
to be Australia, the speed is 48 kilometers
159:19 - an hour, and it cannot fly. So if I print
this out, I see that other than a little bit
159:24 - of a strange syntax with that inner type,
I see that I have all of my fields defined,
159:28 - it's a matter of fact, I can come in here
and dig into any one of those animal fields.
159:34 - And everything worked exactly like I would
expect them to so it kind of looks like bird
159:39 - is inheriting the properties of animal. But
really what's happening here is there's some
159:43 - syntactic sugar go is handling the delegation
of the request for the Name field automatically
159:50 - to the embedded animal type for you. So if
you try and pass these around and look to
159:55 - see if the bird is a type of animal, it is
not bird is still an issue. Independent struct
160:01 - that has no relationship to an animal other
than the fact that it embeds it. So it's not
160:05 - a traditional inheritance relationship where
a bird is an animal. Instead, it's a composition
160:10 - relationship, which is answering the question
has a, so a bird has an animal, or has animal
160:17 - like characteristics is how we would say it
in this example. But it is not the same thing
160:22 - as an animal, they cannot be used interchangeably.
In order to use data interchangeably, we're
160:27 - going to have to use something called interfaces,
which we'll talk about a little bit later.
160:31 - Now we can see in this example, that if we
declare the type, and we initialize the variables
160:35 - afterward, everything's pretty clear, we can
just treat all of the fields as if they're
160:39 - owned by the bird struct. And we don't have
to worry about the internal structure of the
160:43 - struct. And that's very intentional. However,
if we're going to use the literal syntax,
160:48 - we do have to know a little bit about the
birds internal structure. So let me drop in
160:51 - this code here, clean up our formatting a
little bit, and then remove these lines here.
160:56 - So this is declaring exactly the same object,
we're going to have an E mu from Australia,
161:02 - the speed is actually going to be 48 kilometers
an hour, and can fly is going to be false.
161:08 - But notice what I have to do here, I have
to explicitly talk about the internal animal
161:12 - struct. So when I'm working with the literal
syntax, I have to be aware that I'm using
161:18 - embedding. But if I just declare the object
and manipulate it from the outside, I don't
161:22 - have to be aware of it at all. Now, when should
you use embedding? Well, I will say Generally,
161:28 - if you're talking about modeling behavior,
embedding is not the right choice for you
161:32 - to use. When we get into methods, we will
see that embedding will allow behaviors or
161:37 - methods to carry through into the type that
has the embedding. However, the fact that
161:42 - we can't use them interchangeably, is a very
severe limitation. Generally, it's much better
161:47 - to use interfaces when you want to describe
common behavior. So when is embedding a good
161:53 - idea? Well, if you're offering a library,
for example, and let's just say you're making
161:57 - a web framework, and you've got a very sophisticated
base controller, in that case, you might want
162:03 - to use consumers of your library to embed
that base controller into their custom controllers,
162:08 - so that they can get useful functionality
out of it. In that case, you're not talking
162:11 - about polymorphism. And the ability to interchangeably
use objects, you're just trying to get some
162:16 - base behavior into a custom type. And in that
case, embedding makes sense. The last thing
162:21 - that I want to talk about with structs is
a concept called tags. So let me just drop
162:26 - in another example program here that we can
work with. This is a simpler version of what
162:30 - we had before, because we don't need to structs
for this conversation. So we're just going
162:33 - to have a simple animal struct with the name
of the origin fields. And then what I want
162:37 - to do is I want to add what's called a tag
in order to describe some specific information
162:43 - about this name field. So let's say for example,
that I'm working with some validation framework.
162:47 - So let's just say that I'm working within
a web application, and the user is filling
162:51 - out a form and two of the fields are providing
the name and the origin. And I want to make
162:55 - sure that the name is required and doesn't
exceed a maximum length. So I can do that
162:59 - with a tag that looks something like this.
So the format of a tag is to have backticks
163:04 - as the delimiters of the tag, and then we
have these space delimited key value pairs.
163:09 - So my first field is going to be required.
So I'm going to say that the Name field is
163:13 - required. And then I've got a max length argument,
which in this case, is set to 100 characters.
163:19 - So the value of the tag is arbitrary, you
could actually put any string that you want
163:22 - in here, but this is the conventional use
within go, we're going to use space delimited
163:26 - sub tags. And then if you do need a key value
relationship, then you're going to use a colon
163:31 - to separate the key and the value. And then
the value is typically put in quotation marks.
163:35 - So now that we have this, how do we get at
it? Well, the way that we're going to get
163:39 - at it is using gos reflection package. So
there's no straightforward way from an object
163:44 - to get at the tags of a field, you have to
use reflection in order to get that, unfortunately,
163:48 - go makes this pretty easy. So the first thing
that I need to do is I need to get the type
163:53 - of an object that I'm working with. So I get
that using the reflect packages type of function.
163:59 - And I have to pass in an object to this. So
I will just initialize an empty animal to
164:03 - get them that and then I can grab a field
from that type, using the types field by name
164:09 - method, and then passing in the name. In this
case, I want the name name. And now I can
164:12 - get at the tag by asking for the tag property
of the field. So if I run this, we see that
164:20 - I do in fact, get that tag out. Now, what
do I do with that? Well, that's really up
164:24 - to my validation framework to figure out all
tags do is provide a string of text and something
164:29 - else has to figure out what to do with that.
So this tags value is meaningless to go itself,
164:34 - we're then going to have to have some sort
of a validation library that's going to have
164:38 - to parse this figure out that yes, required
is part of the tag. And then it's going to
164:42 - have to decide well, if required is there
and then I'm going to apply this logic making
164:46 - sure the string is non empty or whatever makes
sense in our use case. Okay, so that finishes
164:51 - up what I have to talk about with maps and
structs. Let's go into a summary and review
164:55 - what we've talked about. In this video we
talked about the two remaining collections
165:00 - types that are available and go, we talked
about maps, and we talked about structs. And
165:03 - when we talked about maps, we learned that
they are collections of value types that can
165:07 - be accessed by keys, they can be created as
literals, or via the make function, and members
165:12 - are accessed via the square bracket key syntax,
we can check for the presence of an element
165:17 - within a map using this comma, okay syntax.
So we can ask for the value at a comma, okay,
165:24 - and what the map is going to return is the
value type as well as a Boolean, that's going
165:29 - to indicate if the value was found or not.
Now, if the value wasn't found, your value
165:33 - variable is going to be the zero value of
the value type in that map. So for example,
165:38 - if you've got a map of strings to strings,
and the element isn't found, you're going
165:42 - to get an empty string returned out, if you've
got a map of string to integers, for example,
165:46 - you're going to get the value zero. If you
have multiple assignments to the same map,
165:50 - they all point to the same underlying data.
So they're what are called reference types,
165:54 - which means that if you manipulate the data
in a map in one location, any other variables
165:59 - that are pointing to that same map are going
to see that change as well. We then went on
166:03 - to talk about the struct type, and how they're
a collection of disparate data types. So whereas
166:09 - arrays and slices and maps are all collecting
the same data type together, a struct is unique
166:14 - in that it collects any type of data together.
So you've got a common field name. But those
166:20 - fields can point to any valid data structure
within go. They're keyed by name fields, which
166:26 - generally follow the syntax of any valid variable,
including whether they export it or not. So
166:31 - if you capitalize the name of the field, then
that's going to be exported from the package.
166:35 - If you leave it lowercase, then that's going
to be kept internal to the package. They're
166:39 - normally created as types. But we can create
anonymous structs if we need to. And again,
166:44 - common use cases for this are very short lived
structs, such as generating a JSON response
166:49 - to a web service call, that's only used one
time. structs are value types. So if I assign
166:54 - a variable to an existing struct, then all
of the struct values are going to be copied
166:59 - over to create a brand new struct. So if I
manipulate a struct in one location, it's
167:03 - not going to affect any other variables in
your application. We don't have an inheritance
167:08 - system within go. But we can use composition
using what's called embedding. So when we
167:13 - want to embed one struct within another, we
just list the type of the struct, and we don't
167:17 - give it a field name. Go is then going to
automatically interpret that for us and delegate
167:22 - any calls for fields or methods in the containing
struct down to the embedded struct. If that
167:27 - top level struct doesn't contain a member
with that name, we
167:31 - also learned a little bit about tags and how
they can be added to struct fields to describe
167:35 - that field in some way. So there's a lot of
different use cases. For this. The JSON package
167:39 - uses this to provide ways to map field names
from NGO field names, which are typically
167:44 - uppercase to follow JSON conventions, which
are typically lowercase. We also saw that
167:49 - we can use this, for example, to pass information
into a validation framework. And that framework
167:54 - could generate errors. If we need fields to
be required, or have rules about their length
167:58 - or things like that, I want to start a discussion
about the tools that go makes available to
168:03 - control the flow of execution in our applications.
In today's video, we're going to focus on
168:08 - two of these tools, the if statement and the
switch statement. We'll start a discussion
168:13 - by talking about if statements. And we'll
talk about all of the different ways that
168:17 - we can use them in our applications. And we're
going to specifically focus on the various
168:21 - operators that are often associated with working
with if statements. And we'll go through what
168:25 - those are and how you can use them. And then
we'll talk about the relatives of the if statement.
168:30 - And those are the if else statement. And the
if else if statement. We'll then move on to
168:35 - talk about switch statements. And we'll start
that conversation with some simple use cases
168:39 - for switch statements. We'll then talk about
cases with multiple tests, how we can follow
168:44 - through from one case to another in our switch
statements. And then we'll talk about this
168:48 - special version of a switch called a type
switch. So let's go ahead and jump in and
168:52 - start learning about if statements. In order
to start our discussion about if statements,
168:57 - I want to start as simply as we can. So if
you look at this application here, it's got
169:01 - just about the simplest if statement that
I could come up with. So we're going to start
169:05 - with the if keyword as you see here on line
eight. And then we're going to have an expression
169:09 - that generates some kind of a Boolean result.
And that's actually where we're gonna spend
169:13 - a lot of time when we're talking about if
statements is how to generate these Boolean
169:16 - results. In this case, I'm just using the
literal true, which is the simplest Boolean
169:21 - result that we can come up with. And then
inside of these curly braces here, I've got
169:26 - the code that's going to execute if that Boolean
test returns true. So in this case, since
169:31 - we're using a literal true, then the test
is always going to pass. And when I run this
169:35 - application, I see that I get this test is
true printed out in the results here, if I
169:39 - change this to a literal false, and we see
that we don't get any output from the application
169:43 - because the code inside of the curly braces
is not executed. Now, one thing to keep in
169:47 - mind if you're coming to go from another language,
is you may be expecting this to be valid syntax.
169:53 - Well, if we try and run this, we actually
are going to get a syntax error because one
169:57 - of the design decisions that was made with
go is that You're never allowed to have a
170:01 - single line block evaluated as the result
of an if statement. So you always have to
170:05 - use curly braces, even if you only have one
line to execute. Now, this style of this statement
170:10 - has the Boolean test right here. And that's
the only thing after the if clause. There's
170:14 - actually another style that's very commonly
used in the go language. And that's what I
170:19 - would call the initializer syntax. So as you
see here on line 17, we've got a call into
170:25 - a map that's pulling out the value from a
map, and it's pulling out the okay variable.
170:29 - And then notice I've got this semi colon,
and then the Boolean result listed here. So
170:35 - this part here, this first part of the if
statement, is the initializer. So the initializer
170:40 - allows us to run a statement and generate
some information that's going to set us up
170:45 - to work within the F block. So in this case,
I'm generating a Boolean result by interrogating
170:49 - the map. And then I'm using that as the test
to see if the code inside the if block should
170:53 - execute or not, I also have access to the
pop variable that I'm creating right here
170:59 - inside of the F test, and that variable is
going to be scoped to the block. So if I execute
171:04 - this, you see that I get the population of
Florida printed out, no problem there. If
171:09 - I try and work with that variable outside
of here, and printed out again, I'm going
171:15 - to get an undefined error, because the pop
of variables is only defined within the scope
171:19 - of that if statement. The next thing that
I want to talk about with if statements are
171:24 - the comparison operators that we have. I mean,
obviously, as long as we can generate pure
171:28 - Boolean values, things are going to be pretty
simple. But that's a pretty limited benefit,
171:33 - because in a lot of applications, we need
to do some kind of a comparison in order to
171:36 - determine if the branch should execute or
not. So let me drop in this example here.
171:41 - And let's just say that we're building some
kind of a number guessing game. Now to keep
171:44 - things as simple as possible. This is going
to be a pretty simple number guessing game,
171:48 - because we're going to hard code the value
that we're going to guess. And we're going
171:50 - to hard code our guests. So we're not going
to have a user interface involved here at
171:53 - all. And we're not going to randomly generate
the number that way, it's very clear what
171:57 - the application is doing. So right now what
we have is we've got the number that we're
172:01 - going to try and guess we've got our guests
here on line nine. And then we've got a couple
172:05 - of tests. So in line 10, we're checking to
see if the guess is less than the numbers.
172:10 - So this is the first comparison operator that
we're looking at. This is the less than operator,
172:15 - we also have the greater than operator and
the equality operator. So if we run this with
172:20 - the guests of 30, and a number of 50, we're
going to get the value to low printed out
172:24 - because this first test evaluates to true.
And the second and third test evaluate to
172:28 - false. If I change my guest to 70, and run,
then the second test evaluates to true and
172:34 - the first and third evaluate to false. And
as you might expect, if I put in a guess of
172:38 - 50, and run this, then I finally got it. So
this is the basics of a number guessing game,
172:43 - all you need to do is wrap this in loops,
which we'll talk about in a future video and
172:47 - add a little bit of a user interface and you've
got your first game written in the go language.
172:51 - Now there's some other operators that we have
available. And it's a little hard to justify
172:54 - getting them into this example. So I'm just
going to go ahead and dump them here. And
172:58 - then we can take a look at them. So this first
test is called the less than or equal operator.
173:02 - So it's going to check to see if number is
less than or equal to guess the second is
173:06 - the greater than or equal to operator. And
the third is the not equal operator. So if
173:10 - I go ahead and run this, you see that we are
less than or equal to because we're exactly
173:14 - on the number we are also greater than or
equal to, and we fail the non equal t test.
173:19 - So we get true true false printed here, if
we go with 30. Again, we're going to get false
173:25 - true true. And if we go with 70, we're going
to get true false true. So these are the six
173:33 - different comparison operators that you're
typically going to use in your applications.
173:37 - And these work with all numeric types. They
don't however, work with things like string
173:41 - types. So if you're going to work with string
types, typically what you're going to work
173:44 - with is the equality operator or the non equality
operator. And that goes for any kind of reference
173:49 - type as well. Now the next thing that I want
to do in this example is add in some kind
173:53 - of simple validation. So if you imagine that
we've got some kind of a simple user interface
173:57 - where the user is asked to enter a number
on the keyboard, and then we're going to use
174:01 - that as our guests, then we're going to need
some way to validate that number to make sure
174:06 - that for example, they don't enter negative
five. So to do that, we can add another logical
174:09 - test. But we can also combine multiple tests
together using what are called logical operators.
174:16 - So let me drop this code in here. And you
can see our first logical operator. So this
174:21 - code here is conducting two tests, it's checking
to see if the guest is less than one. Or if
174:26 - the guest is greater than 100. And if it is,
then we're going to print out a message here,
174:31 - we can also put a guard around our actual
game code, checking to see if the guess is
174:37 - greater than or equal to one. And this is
the AND operator less than or equal to 100.
174:43 - So this first test case is going to execute
if the guess is out of range. So if we enter
174:47 - negative five, for example, then we're going
to run this and we see that the guests must
174:52 - be within one and 100. If we enter a number
that's within range, then everything executes
174:57 - like we expect it to and this code on line
11,000 execute. So this first operator here
175:03 - is called the OR operator. And this is checking
to see if the test on the left is true, or
175:07 - the test on the right is true. So obviously,
we can't have the guest less than one and
175:11 - greater than 100 at the same time, but one
or the other could be true. And if one of
175:16 - those is true, then we're going to have an
invalid guess. And it makes sense to print
175:20 - out a message to the user saying that this
other operator that we see here is called
175:24 - the AND operator. And it evaluates to true
if both the test on the left and the test
175:29 - on the right evaluate to true. So if we had
a guest, for example of 105, then this code
175:34 - is gonna evaluate to true because it is greater
than or equal to one. But this code is not
175:39 - because 105 is not less than or equal to 100.
So with an and test, both cases have to be
175:45 - true, unlike an or test, we're only one of
the two has to be true. So a guess of 105
175:51 - is going to print out our error message. And
it is not going to execute the code within
175:55 - this if statement here. The other logical
operator that we have is called the NOT operator.
176:00 - And what that's going to do is it's going
to take a Boolean, and it's going to flip
176:02 - it to the other side. So if I take and just
as a simple example, if I take and print the
176:08 - value true out, then we're going to get the
value true printed out here at the end of
176:12 - our program. If I put the NOT operator, which
is just an exclamation point, and run that,
176:18 - then the true becomes false. Similarly, if
I put this in front of a false, the false
176:22 - becomes true. And I can just prove that false
is really false
176:26 - by taking that away, and false is false. So
those are the three logical operators that
176:31 - we have. We've got the OR operator, which
is the double pipe that you see here on line
176:34 - 10. We've got the and operation which is the
double ampersand, which you see here on line
176:38 - 13. And then we have the knot operation, which
reverses a Boolean result. And that's done
176:43 - simply using the exclamation point. The other
interesting thing to know about working with
176:48 - logical operators, is a concept called short
circuiting. So in order to show you that,
176:52 - I'm actually going to have to jump ahead and
add a custom function here. And we haven't
176:56 - talked about this. So let me just give you
a simple of an explanation as possible. So
177:01 - I've got a function down here between line
27 and 30, called return true, that's gonna
177:06 - return a Boolean result. Now in order to make
sure that we know that it executed, I'm printing
177:10 - out returning true here, and then I am returning
the true value. So what happens when we call
177:15 - this function is it's just going to be replaced
with the Boolean true in our application code.
177:20 - Now, up here in line 10, I've changed our
or test to include this return true. And this
177:25 - doesn't make sense in our demo example. But
I'm doing this just to show you how this works.
177:30 - So in this case, we're ordering three tests
together. So what's going to happen is go
177:35 - is going to evaluate these guys, it's going
to generate a result. And it's going to take
177:39 - that result, and it's going to order it against
this guy. So basically, it's going to evaluate
177:43 - all of them. And only one of those has to
be true in order to generate a validation
177:47 - message. So as you might expect, if we run
this like this, we're going to get returning
177:51 - true because the guest is not less than one.
So we're going to check this value, this returns
177:56 - true. And so we're going to evaluate if it's
greater than 100. None of those are truths
178:00 - or or statement fails. And then we're going
to drop down and we're going to execute this
178:04 - code down here. Like we might expect, if we
generate an invalid value. So if we put a
178:09 - negative five, then well, let's just run it
and we'll see what happens. So if we run this,
178:14 - we get the validation message. The guests
must be within one and 100. Well, that's okay.
178:19 - But what happened to our return true? If you
remember, this function is supposed to print
178:23 - returning true out, and it didn't. So what
happened? Well, what happened is a concept
178:28 - called short circuiting. So as soon as one
part of an or test returns true, then go doesn't
178:34 - need to execute any more code, it already
knows that the old test is going to pass.
178:38 - So it does what's called short circuiting,
which basically means it's not going to evaluate
178:43 - any other part of the or test, it's just going
to move on and say, well, the or test passed,
178:47 - and therefore everything works. So in this
case, since guess is less than one, there's
178:52 - no reason for go to evaluate these two tests
here. So since this test is a function call,
178:59 - it doesn't even execute that function. Now,
if we go the other way, and we go out of range
179:04 - high, then this is going to return false.
This is actually going to return true because
179:09 - it's hard coded. And actually go isn't even
going to evaluate this because this is going
179:12 - to return true. However, this value is going
to fail this test here. So if we run this,
179:17 - we see that now we get returning true printed
out. So this is a concept called short circuiting.
179:22 - Go is going to lazily evaluate the logical
tests that we put in here. So when we give
179:26 - it negative five, since it doesn't need to
evaluate anything after this first test, it
179:31 - doesn't. So any function executions are not
going to be evaluated. The same thing happens
179:35 - for an and test. If one of the parameters
returns false, then we're going to get a short
179:41 - circuiting here. So if we get into a situation
where this is false, go will not even evaluate
179:45 - this test here. So for example, with the negative
five, when Google evaluates this, it sees
179:49 - that the guest is not greater than or equal
to one. So the ant test has to fail because
179:54 - both sides of an ant test have to return true
in order to work and so go is going to exit
179:59 - early It's not going to execute this code.
So for the next thing that I want to talk
180:03 - about, I want to actually drop back into our
baseline for our test here. And I want to
180:07 - talk a little bit about these two if tests.
Now this code obviously works, but it's a
180:12 - little bit ugly, right? Because we have this
logic here, guess is less than one or guess
180:17 - is greater than 100. And then we have this
expression here. And this is exactly the opposite.
180:22 - So this is basically saying, Well, if it's
not less than one or greater than 100, then
180:27 - do this other thing. So while this code is
perfectly fine, it becomes a little bit of
180:32 - a maintenance nightmare, because really, our
intent is that we want to execute either this
180:37 - code or this code. So the way we can do that
a little bit more elegantly and go is by taking
180:43 - out all of this and just putting in the keyword
else. So what's going to happen in this situation
180:48 - is it's going to evaluate the logical tests.
If these tests return a Boolean true, then
180:54 - we're going to print this. Otherwise, we're
going to execute this block here. So in this
180:59 - case, if we run this, we see that we get the
value too low. And our logical tests down
181:04 - here in line 21. Execute. If we put in the
value negative five, however, then we get
181:11 - the same behavior that we had before. But
our code is a lot cleaner, and a lot more
181:14 - clear as to our intent. Now related to that
is the situation where we have multiple
181:20 - tests that we want to chain together. And
so let me paste in another permutation of
181:23 - our little game. And in this case, I've actually
split out the validation logic. So I want
181:29 - to check if it's less than one, I want to
print out one message, if it's greater than
181:32 - 100, I want to print out another message.
Otherwise, I've got a valid value. And to
181:37 - do that, I'm using this else if clause. So
basically, what this is doing is it's taking
181:42 - an IF test, and then it's chaining on another
if test if this fails. And so what goes is
181:47 - going to do is the first logical test that
passes is going to be executed, otherwise,
181:52 - it's going to drop down to the else clause.
So with the guests of 30, we would expect
181:56 - our else clause to fire. So if we run, we
see that in fact it does. If we put in a value
182:01 - of negative five, then we would expect this
first statement to run and it does. And if
182:06 - we put in a value that's too high, then we
see that we get the second validation message
182:10 - printed out. And those are the three different
ways that we have to create if statements.
182:15 - So we've got the simple if statement, that's
just if and if that evaluates to true, then
182:19 - the statements inside of the curly braces
are going to execute. We've got if else. So
182:23 - we're either going to execute the first set
of code or the second set of code. And then
182:27 - we have the if elsif, which we can chain together
with else in order to have very complicated
182:32 - branching, so that we can have multiple code
paths execute, depending on how our logical
182:36 - tests execute. Now one thing to keep in mind
is through these examples, we've never been
182:41 - able to have more than one code path execute.
So even if we did something like this, if
182:47 - we did elsif guess is less than one or the
notice both the first test and the second
182:53 - test will pass with a value of negative five,
however, goes on and go to execute the first
182:59 - branch that has a succeeding test. So we get
the result, the guests must be greater than
183:03 - one because this test passed. And so this
test wasn't even evaluated, go immediately
183:07 - went in and executed this branch of code and
ignored all of the rest of our if statements.
183:12 - Now another thing to keep in mind when you're
working with equality operators, and this
183:16 - isn't specific to if checks, but it is something
that's easy to demonstrate with an F check.
183:21 - So if I take a look at this example, here,
I've got a floating point number of 0.1. And
183:25 - I'm going to check to see if that number is
equal to the number squared, and then I'm
183:29 - going to take the square root of it. So if
you get out of pencil and paper, you're going
183:34 - to take point one squared, which is going
to be point one, and then you're going to
183:37 - take the square root of that, which is going
to be back to point one, right? So this should
183:40 - evaluate to true. If we run this, we see that
in fact they are however, if I add in a couple
183:48 - of decimal places here and run this, now go
says the results are different. Well, the
183:54 - fact is that if you square a number and take
the square root of it, it is the same number.
183:58 - So what's going on here? Well, the thing is
go is working with floating point numbers
184:02 - and floating point numbers are approximations
of decimal values. They're not exact representations
184:07 - of decimal values. And so we have to be very
careful with them. When we're doing comparison
184:12 - operations with decimal values, this is generally
not a good idea, the better approach is to
184:17 - generate some kind of an error value and then
check to see if that error value is less than
184:21 - a certain threshold. So in this case, since
we're taking a floating point number and comparing
184:26 - it to a floating point number, what we can
actually do is divided two numbers and subtract
184:31 - one. And now what we have is a value that's
close to zero. So if we take the absolute
184:36 - value of that, so we'll use the ABS function,
which does that from the math package. And
184:43 - then check that to see if it's less than,
for example, point 001. What this is doing
184:48 - is saying divide these two numbers, and if
they're within a 10th of a percentage of each
184:53 - other, then we're going to consider them to
be the same. So if we run this, then you see
184:58 - that the results are the same and we We can
add as many decimal places as we want right
185:02 - now. And the errors that are associated with
floating point numbers aren't going to get
185:06 - in our way. Now, this isn't a perfect solution,
because you could get two numbers that aren't
185:10 - truly the same, and get them to pass this
test. So the key to that is tuning this error
185:15 - parameter here, making sure that it's sufficiently
small to catch those cases, but sufficiently
185:20 - large, so that the errors introduced with
floating point operations don't affect your
185:24 - results. Okay, so the next thing that I want
to talk about are switch statements. So let
185:28 - me start that conversation by dropping in
an example. And we'll see a basic switch statement.
185:33 - So a switch statement is a kind of special
purpose if statement. So where if statement
185:39 - has a logical test and runs a block of code
if that test is true, and then you can add
185:43 - an elsif to run a second test and another
elsif. And as many else ifs as you want. A
185:48 - lot of times in application development, we
run into a set of comparison operations that
185:51 - are very similar to one another. So a lot
of times it's more efficient to use a switch
185:55 - instead of an if statement. So we have a simple
example here, we're going to use this switch
185:59 - keyword as you might expect. And in this example,
we're going to start with this value here.
186:04 - And that's called a tag when we're working
with switch statements. So this is what we're
186:08 - going to compare everything against, then
we're going to have a series of cases. And
186:12 - you can see here we got case one, and we got
case two. So what's going
186:16 - to happen is the value here is going to be
compared to the tag. And if it's true, then
186:22 - the statements after the case are going to
execute. If not, then they're not going to
186:26 - execute. And just like with if statements,
the first case that passes is going to be
186:30 - the one that executes, we also have this default
case down here. And that's going to execute
186:35 - if none of our other test cases passed. So
if we go ahead and run this, we see that we
186:39 - get to print it out. If we add the value one
here, we get the value one printed out. And
186:44 - if we have three, then we get the default
case printed out. So it's a very simple way
186:49 - to compare one variable to multiple possible
values for that variable. Now in a lot of
186:54 - languages, if you want to compare against
a range, then you'd have to do something like
186:58 - this, you'd have case two, you'd have case
three. And then we use what's called falling
187:03 - through in order to compare multiple cases
together, well, we don't actually have falling
187:07 - through as a default behavior and go, but
what we do have to make up for that is the
187:13 - ability to have multiple tests in a single
case. So if I extend this example out here,
187:18 - and I say this is going to test one, five,
and 10. And this is going to test two, four,
187:22 - and six, then I'm going to say this is going
to print out one, five, or 10. And this will
187:28 - print two, four, or six, and then I put in
the value five, and let's just change this
187:34 - message to this is going to say another number.
Okay, so if I run this, then I get the first
187:43 - case is going to pass because I matched this
second test. So this is going to execute if
187:48 - I have the value one, five, or 10. So I can
also get into that same case by passing in
187:53 - the value of one, if I pass in the value of
four, then like you might expect, I'm gonna
187:58 - have the second case, evaluate. And naturally,
if I pass in an unknown number, then I'm going
188:02 - to have the default case execute, just like
I had before with a single test. Now one thing
188:07 - we have to be aware of is the test cases do
have to be unique. So if I try and run this,
188:12 - where I'm going to have five in the first
case, and in the second case, that's actually
188:16 - a syntax error, because you can't have overlapping
cases when you're using this syntax. Now,
188:21 - just like with if statements, we don't have
to have a simple tag here, in our switch,
188:26 - we can use an initializer, just like you're
seeing here. Now, in this case, the initializer
188:31 - doesn't have to generate a Boolean result,
because we're not doing a Boolean test in
188:35 - our switch statement up here, the Boolean
test is comparing the second parameter in
188:39 - the switch statement to our cases. So in this
case, we're just going to initialize that
188:43 - value. So I'm doing some simple math here,
I have set equal to two plus three. So obviously,
188:47 - that's going to be five, then I've got the
semi colon and the tag that we're going to
188:50 - be testing against. So as you might expect,
when I run this, the first case executes because
188:55 - two plus three is five, five is matched by
the first case. And so we get this statement
189:00 - printed out. Now another syntax that we have
available to us in switch statements is a
189:05 - tankless syntax. So both of the styles that
we've been talking about, we've always had
189:09 - a value that we're comparing to our test cases,
where there's actually another syntax, this
189:14 - tag list syntax. And this is arguably more
powerful than the tag syntax, although it
189:19 - is a little bit more verbose. So in this case,
on line eight, I'm establishing a variable
189:23 - which is going to come from some other logic
in my application. And then I've got the switch
189:27 - statement that standing all alone and immediately
opening a curly brace. So notice, I don't
189:32 - have a tag here. However, my case statements
now I've got full comparison operations. And
189:38 - I can use the comparison operators, I can
use the logical operators. So in this case,
189:42 - the cases are standing in for the logical
tests that we have in our if statements, they're
189:47 - doing exactly the same job. So in our first
case, I'm checking if i is less than or equal
189:51 - to 10. And if it is, I'm going to print that
out. And then in our second case, I'm going
189:55 - to check if i is less than or equal to 20.
And then of course, we've got the default
189:58 - case. If The value falls through. So if I
run this, I see that I do get the code executing,
190:04 - which is an interesting thing. And it executes
the first case. Now, why is this interesting?
190:09 - Well, if you notice the first case, in the
second case overlap, because 10 is less than
190:15 - or equal to 10. It's also less than or equal
to 20. So unlike the tag syntax, we've got
190:20 - multiple test cases. And I said they cannot
overlap. When we're using this tag list syntax,
190:25 - they are allowed to overlap. And if they do,
then the first case that evaluates to true
190:29 - is going to execute. Now another thing that
I should have pointed out earlier is notice
190:33 - that we don't have curly braces around this,
any statements that after this case, and before
190:38 - the next case is going to be part of the block
that's going to execute, so I can have as
190:41 - many statements as I want here. The delimiters,
in this case, are the actual case keywords,
190:47 - the default keyword, or the closing brace,
so any of those delimit the end of a block
190:52 - in a case statement. Now again, if you're
coming from another language, then this syntax
190:56 - might be looking a little weird, because you
might be looking for this word coming in here.
191:00 - And we'll have to add this word here. And
we'll have to have this word here.
191:04 - So you might be wondering where the heck are
my break keywords, one go, the break keyword
191:08 - is actually implied, because so many use cases
for switches have breaks in there. And forgetting
191:14 - a break is the cause of innumerable errors
when working with switch statements, the design
191:19 - decision was made to have an implicit break
between our cases, instead of an implicit
191:24 - fall through which most other c based languages
have. So what happens if you do in fact want
191:30 - your case to fall through. So in this example,
let's just say that we do want to print out
191:35 - that we're less than or equal to 10, and that
we're less than or equal to 20. And we know
191:39 - that if we pass this first case, we're going
to pass the second case to, in that case,
191:44 - we can actually use the keyword fall through.
So if I run this, you see that both messages
191:50 - print out. So I'm going to get less than or
equal to 10 and less than or equal to 20.
191:54 - Now one thing to keep in mind here is fall
through is logic less. So when we say fall
192:00 - through to the next case, it will do that.
So if I, for example, change this to be greater
192:05 - than or equal to, then we know that I fails
the second case, but if I run, it still executes,
192:12 - because fall through means that you are taking
the responsibility with the control flow.
192:17 - And you intentionally want the statements
in the next case to execute. Now and go you
192:20 - don't use follow through very often, because
we have that tag syntax that can take multiple
192:25 - tests per case. And so a lot of the use cases
for falling through are taking care of that.
192:31 - However, if you do have a use case where you
need follow through, then it is available
192:34 - to you. The next thing that I want to talk
about was switch statements are a special
192:38 - use of a switch statement called a type switch.
So I'm going to drop in this example here.
192:42 - And this should be pretty familiar except
for what we're switching on. So notice that
192:47 - we are switching on a tag. But the tag variable
is typed to type interface, which can take
192:52 - any type of data that we have in a go application.
So the interface type can be assigned to an
192:57 - integer like we're seeing here, we can assign
it to a string to a Boolean, to a function
193:02 - to a struct to a collection, anything we want
to assign to an interface is going to be permissible.
193:08 - So then in go, we can use this syntax here.
So we can put in the dot operator. And after
193:13 - that, put in params with the word type in
the middle. And what that's going to do is
193:17 - tell go to pull the actual underlying type
of that interface and use that for whatever
193:23 - we're doing next. Now, you don't just use
that for type switching. But this is a common
193:27 - use case for it. So in this case, I'm going
to assign the variable i the value one, which
193:32 - as we know is going to type I to be an integer.
And then I can actually use go types as the
193:39 - cases, because this is going to return a type,
then I can use those type keywords here as
193:43 - my cases. So if I run this, knowing that one
is an integer, I should not be surprised when
193:49 - I see the first case passes, and the other
two are ignored. If I had a decimal point
193:53 - zero here, then that's going to turn this
into a floating point 64. And we see that
193:58 - go recognizes that. Similarly, if I put one
in a string here, then we're going to see
194:03 - that go understand that. And I can even make,
for example, an array. And we don't need to
194:09 - initialize any values here. But if we see
that, then go recognizes that as another type.
194:15 - And if I want to have a case to catch that,
then I can actually have a case for a raise
194:21 - of three integers. And then I can print that
out. Now if I run, we see that it recognize
194:28 - that and this is different than two. So if
I use a two element array, please be aware
194:34 - that those are different types. Arrays are
not equivalent to every other array, you have
194:38 - to have the same data type and the same array
size in order for them to be evaluated as
194:42 - the same type. Okay, the last thing that I
want to talk about I can illustrate with this
194:45 - example here. Now in this example we're extending
on the previous one was type switches. And
194:50 - notice that I've got these two print statements
here on line 11 and line 12. So if I run this,
194:56 - I see that I is an integer and this will print
to it. In some situations, you might need
195:01 - to leave a case early. So maybe inside of
the case, you're executing some kind of a
195:06 - logical test, and you find out that there
is some logic in the case that you don't want
195:11 - to execute in certain situations. Well, if
you want to do that, you can actually exit
195:15 - out of the switch statement early by using
the break keyword. So if I add that and run,
195:19 - then I have a way to break out of the switch
early. And I'm not going to execute any code
195:24 - below that break statement. So you can wrap
this in a logical test to determine if you've
195:29 - got a validation error. For example, on some
incoming data, you might not want to save
195:33 - that data to the database. And then you can
use this break keyword in order to short circuit
195:37 - that save operation. Okay, so that pretty
much wraps up what I have to talk about with
195:41 - if and switch statements. Let's go into a
summary and review what we've talked about.
195:45 - In this video, we started our discussion about
the different control flow tools that we have
195:50 - available
195:51 - to us in our NGO applications. And we started
out by talking about the very basic if statements
195:55 - and how we can use a boolean variable to determine
if a block of statements will execute or not.
196:00 - We then talked about the initializer syntax,
and how that allows us to execute a statement,
196:05 - that's going to set up variables that we can
use to run our test against as well as use
196:10 - within the statements of our if tests. We
then talked about the comparison operators,
196:14 - and we talked about how there are six of them,
we've got less than, greater than, less than
196:18 - or equal to and greater than or equal to,
to work with primarily the numeric types,
196:23 - as well as the double equals operator and
the non equals operator that are available
196:27 - to be used more generally, we talked about
the logical operators, the AND operator, the
196:31 - OR operator and the non operator that allows
to chain together Boolean operations, as well
196:36 - as reverse the result of a Boolean operation.
In the case of that knot operator, we talked
196:41 - about short circuiting and how when you're
chaining together tests with an OR operation,
196:46 - for example, if any one of those logical tests
evaluates to true, then the remaining tests
196:51 - are not executed. So any side effects or any
functional operations that might occur with
196:56 - those are not going to be executed. Similarly,
with an an test, the first part of an ad test
197:02 - to return a false result is going to halt
the execution of that and test. So any side
197:06 - effects you might be relying on afterward
are not going to occur. We then talked about
197:11 - the two different variants of if tests, we
talked about the FL statement, and how we
197:16 - can use that to execute one of two branches
of code. So if the if test succeeds, then
197:22 - we're going to execute the first block of
statements. Otherwise, we're going to execute
197:26 - the second block of statements. Related to
that is the if else if statement. And in this
197:30 - case, instead of determining between one of
two paths, and forcing your code to execute
197:35 - one of those, you can add additional logical
tests. So at most one block is going to execute.
197:41 - But if all of your F tests fail, then you
might not get any blocks executing. And finally,
197:46 - I took a minute to talk about equality operations,
especially when working with floating point
197:51 - numbers. And how equality and floats don't
really get along that well. So if you do need
197:56 - to do some kind of inequality operation with
floating point numbers, then you're going
198:00 - to want to turn that into some kind of a comparison
operation against an error function. So for
198:05 - example, we were checking to see if two floats
were equal, instead of checking to see if
198:09 - they're actually equal, and we divided them
subtracted one from that result, and check
198:14 - that against an error parameter. So we decided,
if they were within a 10th of a percent, they
198:19 - were going to be considered the same, you
can use a similar type of error function with
198:22 - your operations. But in general, you should
not test to see if two floating point numbers
198:27 - are equivalent to one another. We then moved
on to talk about switch statements, and the
198:31 - various ways that we can use those in our
applications. We started by talking about
198:35 - how to switch on a tag or tag is just another
name for a variable. But that variable has
198:40 - a special significance in a switch statement,
because all of your test cases are going to
198:45 - be compared back to that tag. We talked about
how with go we can have multiple tests with
198:50 - our case statements. And by doing that, we
can actually eliminate a lot of situations
198:54 - in other languages where we need to fall through
and chain multiple cases together. Well in
198:59 - go, we can just add those multiple tests in
the same case, and eliminate the need to do
199:03 - that following through. We also do have initializers
available with switch statements. But instead
199:08 - of the initializer, generally generating a
Boolean as we do with an if statement, the
199:13 - initializer is going to generate the tag that's
going to be used for the comparisons. In our
199:17 - cases, we talked about switches with no tags
and how it adds a lot of flexibility to the
199:21 - switch statement. But it is a little bit more
verbose syntax. So instead of the cases being
199:26 - compared for equivalency with the tag, we're
going to actually put in the comparison operation
199:31 - ourselves. So we can use more than just equivalency
testing we can check less than or equal to,
199:36 - or any other comparison function, including
chaining comparisons together by using logical
199:41 - operators. We talked about how we have the
fall through keyword available in switches,
199:45 - and how that replaces the break keyword in
many languages. So where many languages have
199:50 - implicit fall through an explicit breaking
in go we flip it around so we have implicit
199:56 - breaks. But if you do need one case to fall
through to the next Then you can use this
200:00 - fall through keyword. Now one thing to keep
in mind when you're doing that is when you're
200:05 - falling through, any additional case logic
is not executed, the fall through will override
200:10 - any case logic that you have. And so the next
statement will execute regardless of if that
200:15 - case would normally pass or not. We also talked
about type switches, and how we can use that
200:21 - special syntax by adding a dot perenne type
perenne on an empty interface in order to
200:27 - get the underlying type of that empty interface.
So for example, if we've got an empty interface
200:32 - that's holding an integer, then we can use
that syntax in order to get that underlying
200:35 - integer value. Then in our switches, we can
switch against those types. And then we can
200:41 - make a decision based on the data that we
got in. And finally, we talked about breaking
200:45 - out early, when we've passed into a case in
our switch statement. There are times when,
200:50 - in the middle of the case, we need to exit
out early, because we've done some additional
200:54 - analysis. And we've decided that we should
not proceed executing this case. So for example,
200:59 - we've got a switch statement. And inside of
that case, we're doing some validation on
201:03 - the data before we save it to the database,
we might decide that data is invalid, and
201:07 - we should not proceed to save it to the database.
So in that case, you can use the break keyword
201:12 - break out of the case and continue execution
after the switch statement, I want to continue
201:17 - our discussion of the control flow structures
that we have available in the go language
201:21 - by talking about looping. Now in the last
video, we talked about the two ways that we
201:26 - have to introduce branching logic into our
application if statements and switch statements.
201:31 - Well, when we talk about looping and go, things
are actually going to be a little bit simpler,
201:34 - because we only have one type of statement
that we're going to have to learn. And that
201:38 - statement is the for statement. Now we're
basically going to break this conversation
201:42 - down into three different parts, we're going
to talk about simple loops, we're going to
201:46 - talk about how we can exit a loop early. And
then we're going to talk about how we can
201:49 - loop through collections. Okay, so let's go
ahead and get started by learning how to do
201:54 - some simple loops in go.
201:56 - So in order to start our discussion about
looping and go, I want to start with this
202:00 - perhaps the most basic for loop that we can
create. So we're going to start with the for
202:05 - keyword as you might expect. And then we're
going to follow the for keyword with three
202:09 - statements, the first statement is going to
be an initializer. Now this is the same as
202:13 - an initializer. And if statements and switch
statements. So we can add any kind of statement
202:18 - that we want here. And normally, we're going
to use that in order to set up a counter,
202:22 - when we're using a for loop like this, the
next statement that we have here is going
202:26 - to be some kind of a statement that generates
a Boolean result. And that's going to be used
202:30 - by the for loop to determine if it's done
looping or not. And then the last statement
202:35 - is going to be the incrementer. And normally,
we're going to use that in a situation like
202:38 - this to increment a counter variable. So if
we run this, we see that we get the numbers
202:43 - zero through four printed out, we could also
increment i by two. And there, you see that
202:49 - we only get three iterations of the loop,
because I has the value zero, then it has
202:53 - the value two, and then it has the value four,
when it comes to the next time it has the
202:57 - value of six, well, six is not less than five.
Therefore the comparison operation results
203:02 - to false and we exit out of the loop. So this
is certainly possible to do and you will occasionally
203:07 - see this. But the most standard way that you
see these loops created is like this using
203:11 - an increment statement. Now if you're coming
from another language, you might be expecting
203:15 - to be able to do something like this. So maybe
we want to variables, increment in our for
203:20 - loop. And so we're going to initialize j there.
And then we're going to increment j with each
203:25 - loop. So if we go ahead and try and run this,
we see that that's actually not allowed, because
203:30 - we have no comma operator in the go language.
So you can't separate two statements like
203:34 - this using the comma. So this is an error,
and this is an error. So if we want to do
203:40 - that, though, we can use gos ability to initialize
multiple values at the same time by adding
203:45 - a comma here getting rid of this part here,
adding the comma there. And then we can't
203:50 - treat these as individual statements, because
you can only have one statement here. And
203:54 - in go the increment operation is a statement,
it's not an expression. So we need to figure
203:59 - out a way to do both of these at one time.
So we will simply come in and said I n j equal
204:05 - to i plus one and j plus one. And go ahead
and run that. And now we have I printing out
204:12 - if we have j here we see that j printout as
well, we can actually increment j by two here.
204:18 - And we see that i and j are incrementing independently.
And we have no problems here. Now just to
204:22 - come back and revisit that increment comment
that I made earlier, you might be tempted
204:27 - to do something like this, if you just want
to increment them by one. If we run that,
204:31 - we're actually going to get an error because
again, in go unlike a lot of languages, the
204:36 - increment operation is not an expression.
So we can't use that as part of a statement.
204:40 - It is a statement on its own. So when you're
just incrementing one variable, you can certainly
204:45 - do this because i plus plus is a statement,
but we can't use that in combination with
204:49 - anything else. We can't use it as an expression.
Something else that's interesting. Let me
204:54 - go back to our initial example here. So we
can play around with this a little bit. So
205:00 - at first blush, if you just come into programming,
this AI variable might seem like it's something
205:04 - special because it's used up in the for loop.
And the fact is, it's a variable just like
205:08 - anything else. So we can do whatever we want
with it. As a matter of fact, just to show
205:12 - you that, let me drop in this cool little
bit of code. As you can see, what we're going
205:17 - to do here is we're going to take the modulus
of i n two, and we're going to see if that
205:21 - zero, so basically, we're checking to see
if it has an even number or an odd number.
205:25 - If I is an odd number, then we're going to
divide it by two. If I is an even number,
205:30 - then we're going to multiply it by two and
add one to it, it's just a couple things to
205:33 - play around with the incrementer. So let's
run this and see if this actually goes to
205:36 - completion. And in fact, it does. And you
see that the variables going all over the
205:40 - place. So we start with zero zeros on so divide
that by two, which stays zero, the next iteration
205:47 - is going to be one because we're incrementing
by one, so it's actually going to be multiplied
205:51 - by two and one added to it. So we print the
one here. But then by the time we're done
205:56 - here, two times one plus one is three, and
so is three, that gets incremented to four,
206:03 - so we're printing for four out here, four
is even to divide that by two, two gets incremented
206:08 - again, so we print out the value three, three
is odd. So three times two is six plus one
206:14 - is seven, seven is greater than five. And
so we leave the comparison operation, so we
206:19 - can do whatever we want with the counter.
Now, just because you can play with the counter
206:23 - doesn't mean it's a good idea. As a matter
of fact, normally, it's very bad practice
206:27 - to manipulate the counter within the for loop.
So maybe the best reason to show you that
206:30 - you can do this is to make sure that you avoid
doing this because there can be times when
206:34 - you're inadvertently changing the counter
variable within a loop. And your loops might
206:38 - start to act really strange, like we're seeing
in this example here. Okay, so let's go ahead
206:42 - and restore our original example, make sure
that that's running again, and it is we're
206:46 - printing out the values zero through four
again. Now the next thing that I want to show
206:49 - you is that we don't actually need all three
statements here. So one thing that we could
206:54 - do, let's just say that I is initialized somewhere
else in our application, so we don't need
206:59 - it to be set up here. And we can run with
this first statement being empty. Now you
207:05 - can't leave this for a semi colon out, because
if you leave that out, then everything's in
207:09 - the wrong place. And it thinks that this is
going to be the initializer. And this is going
207:12 - to be the comparison operator. So if we try
and run this way, we're going to get an error.
207:17 - But if we leave the semicolon in, then go
recognizes that we simply don't have an initializer
207:21 - in this for loop. And it executes everything
the way that we expect it to. And of course
207:25 - I've variable ri is taken in just like we
would expect. Now the difference between this
207:30 - format and the previous one is in this i is
scoped to the main function. But when we have
207:37 - this syntax here, I is scoped to the for loop.
So if I tried to print the value of i out
207:44 - here, we're not going to get a valid value
because I is not defined. But in this other
207:49 - form, when we're putting it out here, then
I is scoped to the main function. And we are
207:54 - actually going to get the final value of I
printed out which is the value five, because
207:58 - five is the first value that fails this test.
So this is actually coming from this statement
208:03 - right here. Okay, the next thing that we can
do, let me go ahead and wipe this out, we
208:08 - also don't need the incrementer value, so
we can eliminate that. Now if I run this right,
208:12 - now, we're actually going to get an error,
because what this is going to do is it's going
208:16 - to generate an infinite loop. And in the go
playground, they don't let us do infinite
208:20 - loops. And so after it runs for a little bit
of time, it's going to shut the process down
208:24 - on us. If we were actually running this in
a local environment, all you'd see is the
208:27 - value zero printed out over and over and over
and over again, until eventually you got bored
208:32 - and shut the application down. Now we can
of course, since I is a variable just like
208:37 - any other, we can put the incrementer in here,
and everything works just fine. So once again,
208:43 - we have to remember to put the semicolon here,
if we remove the semi colon, then go doesn't
208:47 - know what the heck we're asking it to do,
because this is invalid syntax. So if you
208:51 - have the first semicolon, you need the second
semi colon. Now this case does happen actually
208:56 - quite a bit where we need a for loop and just
a comparison operation. And this is how go
209:00 - does do while loops. So in a lot of languages,
you have two more keywords, you've got the
209:04 - do keyword and the wild keyword. And normally
those work with simply a logical test. And
209:09 - then you have some other increment operations.
So you either have an increment or inside
209:13 - of the loop, or you're pulling the next value
off the stack. And comparing that on each
209:17 - iteration, or something like that, we'll go
has the same problems to solve, but didn't
209:22 - make sense for the designers of the language
to introduce a new keyword just for what is
209:26 - basically a special case of a for loop. So
what they allow us to do is we of course can
209:31 - use this double semi colon syntax here. But
you can also leave them both off. So if I
209:37 - run this way, we see that this works. And
this is going to work exactly the same way
209:41 - as if we have both of these semicolons here.
So this is a little bit of syntactic sugar.
209:46 - It's exactly the same construct. It's just
you don't need to have the additional semi-colons
209:51 - and it reads a little bit cleaner. So in this
case, our for loop is just doing a comparison
209:56 - operation. Go is going to assume that we're
taking care of where those variables for the
210:00 - comparison are coming from somewhere else.
Now the third form of a for loop that we have
210:05 - available when we're working with counters
like this is the infinite for loop. Because
210:09 - we also have a situation with do while loops
in other languages, where we need the application
210:14 - to run through the loop and undetermined number
of times. And by undetermined means, we don't
210:20 - actually know when to stop by an obvious logical
test, we need some complex logic within the
210:25 - loop in order to determine when to leave.
So in go, the way that we do that is we simply
210:29 - leave off the logical test, and we run like
this. So if I run this, again, as you might
210:33 - expect, the playground is going to crash out
on us because there's no way for the program
210:37 - to exit. And so it's just going to run forever.
So we need some way to tell our infinite loop
210:42 - when it's done processing and when to leave.
And the way we're going to do that is using
210:46 - the break keyword. And then Normally, the
way that you do this is you'll put some kind
210:50 - of logical tests inside of the loop. So we
can say, if I equals five, then we're going
210:56 - to use that break keyword. And we saw the
break keyword, the first time when we were
210:59 - talking about switch statements, or the break
keyword is actually more commonly used inside
211:03 - of for loops, especially this kind of infinite
for loop here. So what we're doing here is
211:08 - if i is equal to five, so we're going to print
out the values, zero through four, then when
211:13 - I was fine, we're gonna break out. So if we
go ahead and run this, we get exactly the
211:16 - same values that we had before. Now when we
do this, we actually leave the entire for
211:21 - loop. So execution of the loop stops, and
we're done processing. Now another thing that
211:26 - we can do is use what's called a continue
statement. So let me drop in an example that
211:31 - shows you that. So in this case, we're looping
from zero to nine, because we're going to
211:35 - keep incrementing as long as i is less than
10. And then we're checking to see if the
211:39 - value is even if it is even, then we're going
to use this continuous statement here. And
211:43 - what this does is it basically says, exit
this iteration of the loop and start back
211:48 - over. So what's going to happen when we have
00 modulates to is zero, so we're going to
211:54 - continue, which means we're not going to hit
this print statement, when we have one, one
211:59 - minus two is one, so we're not going to hit
this continue, and we're going to print out
212:03 - one, and then two is going to hit the continue
and three is not. So what we should see is
212:07 - we'll only print the odd numbers out. If we
run this, we see that that is in fact what
212:11 - happens. So continuous statements aren't used
very often. But they can be very, very useful.
212:16 - If you're looping through a large set of numbers,
and you need to determine within the loop
212:20 - whether you want to process a record or not.
Now, to show you the next thing, I'm actually
212:24 - going to do this, this is actually going to
print out a nested loop. So what we're doing
212:28 - here is a pretty simple example, we're starting
with the variable, I initializing it to one,
212:33 - and we're going to run as long as i is less
than or equal to three, and then we're doing
212:37 - the same thing with J on the inside. So basically
is going to be one, then it's going to loop
212:41 - through days from one to three, then is going
to be two, it's going to loop through j 4123.
212:46 - Again, and then inside this inner loop, we're
just multiplying the two numbers together.
212:50 - So if we run this, we see that we get all
of the permutations of i times j, where i
212:54 - and j go from the values 123. So we get all
of these values printed out, and everything
212:59 - works the way that we expect. Now what happens
if we want to leave the loop, as soon as we
213:05 - get the first value that's greater than three.
So what we want to do is something like this,
213:08 - so we're going to multiply it times j, we're
going to repeat our logic here. And we're
213:12 - going to see if that's greater than or equal
to three, if it is, then we're going to break
213:16 - out of the loop. Now if I run this, we don't
exactly get the expected result. And the reason
213:21 - for that is as soon as i times j is greater
than three, it breaks out of the loop, but
213:27 - the loop that is going to break out of is
the closest loop that it can find. So it's
213:31 - actually breaking out of this loop here. And
this loop just restarts because there's nothing
213:36 - to tell it to stop. So you might ask the question,
Well, how do we break out in the outer loop?
213:39 - Do we have to have more logic here and check
to see if i times j is greater than three
213:44 - again, and then break out? Well, the answer
is, of course, now, we do have a concept called
213:48 - a label that we can add. So a label is put
together something like this, we're going
213:52 - to start with a word and follow it with a
colon. And we're going to left justify that
213:56 - in our code blocks. So once I have a label
defined, I can actually add the label after
214:01 - the break keyword. And it basically describes
where we want to break out to. So since this
214:06 - labels just before this for loop, we're going
to break out of the outer for loop. So if
214:10 - I run now, I get to the value three, three
is greater than or equal to three. And so
214:15 - I break out of both the inner and the outer
loop. The last thing that I want to talk about
214:20 - in this video is how we can work with collections
with for loops. So we've seen this before
214:25 - we have a slice of integers. In this case,
we're containing the values one, two, and
214:28 - three. And we've seen how we can work with
this as a slice so we can print this out.
214:33 - We run this we get no big surprise, we get
the slice printed out with the values 123.
214:38 - But what happens if I wanted to work with
each individual value? Well, we've seen how
214:42 - we can do this, we can pull out one value
from the slice, and we get the value two.
214:47 - But how do we work with an arbitrarily sized
slice. So I don't know how big this slice
214:52 - is going to be at runtime. I want to be able
to loop through all the items within the slice.
214:56 - So the way that I'm going to loop through
a collection is using a special format The
215:00 - for loop called a four range loop. So I'm
going to start that with the four keyword
215:04 - as you might expect. And then what I'm going
to get is both the key and the value for the
215:09 - current item in the collection. So I'm going
to have two variables that I can set there.
215:14 - And then I'm going to set that equal to this
special range keyword and then provide the
215:19 - collection that I'm going to range over. So
what this is going to do is it's going to
215:23 - look at the collection here. And it's going
to take each value one at a time, give us
215:28 - the key and the value, and then we're going
to be able to work with those values independently.
215:31 - So inside of this, let's go ahead and just
print out the value of the key and the value
215:37 - and run that. And you see that we get the
indexes for the items in the slice, and we
215:41 - get their values. So the indexes are coming
first, those are the keys. And then the values
215:46 - are the actual values in the slice. And this
is the only syntax, you have to remember when
215:51 - using the range keyword, you're always going
to get this key comma value result coming
215:56 - out. So this syntax is going to work for slices
and for arrays. So if we make this an array
216:01 - by just adding a size, here, we see that we
get the exact same output, we can loop over
216:06 - maps. So if I pull back the state populations
map that we use for a couple of videos now,
216:10 - and loop over that, once again, pulling up
the key and the value and ranging over the
216:14 - map this time, then if I print the key and
the value, I'm going to be able to split that
216:18 - out and then get the state in their population
printed out separately. And I can even use
216:22 - a string as a source for a four range loop.
Because what we're going to be able to do
216:26 - here is pull each letter out of this string
as a character and look at that. And we see
216:31 - that we do get each position. And now we get
this numeric value, which if you've been paying
216:36 - attention over the last few videos, you're
going to remember that this is actually the
216:40 - Unicode representation for that digit. So
we can cast it back to a string by just using
216:44 - a simple conversion operation. And we see
that we get each letter printed back out as
216:48 - we would expect. The other type of data that
we can arrange over in go is what's called
216:53 - a channel. Now channels are used for concurrent
programming and go and that's a topic for
216:57 - a future video. So I'm going to leave that
topic right now, I promise when we talk about
217:02 - parallelism and concurrency and go, I'll revisit
the for loop and show you how you can use
217:06 - for loops with channels, because there are
some special behaviors that you have to be
217:10 - aware of when you're ranging over channels.
Now, if I come back to this example, and print
217:14 - this out, you see that we have access to both
the key and the value every time. Now, this
217:19 - is not always true, you don't always need
access to the value. And this can lead to
217:23 - some problems. Because if I only want to print
the keys out and run this, this is actually
217:27 - an error, because in go, you have to use every
variable that's declared. And so we got this
217:32 - situation where we've got this variable v,
but we're not using it. And so that's going
217:36 - to cause us a problem with our application.
Now and go what you can do, if you only want
217:40 - to get the keys out, you can actually skipped
the comma value. And when you run that, it's
217:45 - going to ignore the value. But what happens
if you get into a situation where you only
217:49 - want to print the value out. So if I restore
this, and I want to want to print the value,
217:53 - of course, I get the same error. But I can't
just say this, because go who's going to assign
217:58 - the keys to that. So what do I do? Well, in
this situation, when you only want the values,
218:03 - then you can use that underscore operator
that write only variable that we've seen a
218:07 - couple of times. And basically, that's going
to give a hint to the compiler that we don't
218:11 - actually care about the key. But we need this
in this first position in order to get the
218:15 - value. So when we run this, we do see that
we get those populations printed out. Okay,
218:20 - so that covers what I want to talk about with
four statements and go, let's go into summary
218:24 - and review what we've talked about. In this
video, we talked about the second major control
218:29 - flow construct that we have in the go language,
the looping construct, and we talked about
218:34 - how we're going to use the for statement for
all of the loops that we need to do and go.
218:37 - So we don't have to remember I do keyword
and while keyword and a for keyword, when
218:41 - we use the for keyword that's going to allow
us to loop over every collection that we have.
218:47 - We started by talking about simple loops and
how there are three basic forms for the simple
218:51 - loop, we've got this first syntax, which is
the most basic, that's the initializer test
218:56 - incrementer syntax, and we're going to use
that initializer
218:59 - to set us up in our loop. Normally, by initializing
a counter variable, then we're going to follow
219:03 - that with our test, our test is normally going
to look at the incrementer to see if it's
219:07 - at a certain value that's out of range for
our for loop. And then we've got an incrementer
219:12 - and that incrementer. His job is to move the
incrementer along at every iteration of the
219:17 - loop in order to move to the next case that
we want to loop through. Now we also learned
219:20 - in this first syntax, we actually can leave
the first and last statements on that out.
219:25 - But if we're going to use any of this syntax,
we have to leave the semi colons in place.
219:29 - So leaving a semi colon out confuses the compiler,
it starts to assign things to the wrong places.
219:34 - And so you're going to get an error in your
application. So if you need an initializer
219:37 - or an incrementer, then you're going to have
to use this full syntax. Now the second syntax
219:42 - eliminates the need for the initializing the
incrementer. And it assumes that the test
219:47 - conditions are being managed somewhere else.
So in this construct, you only have the for
219:52 - test. And as soon as that test is false, you're
going to exit the loop. The last construct
219:56 - that we have is the for loop on its own and
that will run indefinitely. Until somewhere
220:00 - within your four loop, the break statement
is called. That leads us to how we can exit
220:05 - early from a for loop. And we have three concepts
that we talked about with that, we've got
220:09 - the break keyword that will break out of the
immediate loop that's executing and continue
220:14 - the application execution after that loop.
The continue statement is similar to the break
220:19 - statement, except for eight doesn't break
out of the loop, it just breaks out of the
220:23 - current iteration goes back to the incrementer,
and continues execution of the for loop at
220:28 - the next increment. Now we can also use labels
in our application and combine those with
220:32 - break statements in order to break out of
an inner loop. And that's typically how they're
220:36 - used in go. So for example, if you have a
nested loop where you're iterating over two
220:41 - collections, and you need to break out of
the outer loop, then you need to set up a
220:44 - label and then follow the break keyword with
the name of that label so that Google knows
220:48 - where to break out to. And finally, we talked
about how to loop over collections, and how
220:53 - the collections that we have available, there's
quite a few we've got arrays, slices, maps,
220:57 - strings and panels that we can loop over.
But they all have this similar syntax, we're
221:02 - going to use that for keyword, we're going
to get a key and a value. And then we're going
221:05 - to set that equal to the range keyword followed
by the collection that we're looping over.
221:10 - So the keys when working with arrays, slices
and strings are going to be the index within
221:14 - that collection. So you're going to have that
zero based index. With maps, we're going to
221:18 - get the key from that map. And the values
are what you expect them to be. They're the
221:22 - value for that current index. Now when we're
talking about channels, it's going to follow
221:26 - very similar syntax, but channels have a little
bit of a special interpretation for these.
221:30 - And we'll talk about those in a future module,
I'd like to finish our discussion of control
221:35 - flow constructs that we haven't go by talking
about defer panic and recovery. We'll start
221:40 - that discussion by talking about deferred
functions, and how we can actually invoke
221:44 - a function, but delay its execution to some
future point in time. Then we'll talk about
221:50 - how an application can panic. So in this conversation,
we'll talk about how go application can enter
221:55 - a state where it can no longer continue to
run and how the go runtime can trigger that
221:59 - as well as how we can trigger that on our
own. And then related to panicking, we'll
222:03 - talk about recovery. Now when your application
starts to panic, ideally, you'd have some
222:07 - way to save the program so that it doesn't
bail out completely. So we'll talk about if
222:12 - your application can be saved, how you can
use the recover function in order to signal
222:16 - that to the rest of your application. Okay,
so let's go ahead and get started. In a normal
222:22 - go, application control flows from the top
to the bottom of any function that we call.
222:27 - Now, of course, we can alter that a little
bit by introducing branching logic so that
222:31 - we can skip some statements. And we can use
looping that we talked about in the last video
222:36 - to repeat certain blocks of statements multiple
times. But generally, a function is going
222:40 - to start at the first line and execute through
until it gets to the last one. So if we run
222:44 - this program right here, we see that it's
no big surprise that we print start, then
222:49 - we print middle, and then we print end. And
what we can do if we want to defer the execution
222:53 - one of these statements is proceeded with
the defer keyword. So if I put that in front
222:58 - of this print line here, then run that, you
notice that middle is actually printed after
223:04 - end. So the way the defer keyword works in
go, is that it actually executes any functions
223:10 - that are passed into it after the function
finishes its final statement, but before it
223:14 - actually returns. So the way this main function
is executing is its calling line eight and
223:20 - it's printing out start, then it recognizes
that it has a deferred function to call and
223:24 - then it prints out end. And then the main
function exits now when go recognizes that
223:29 - that function exits, it looks to see if there
are any deferred functions to call. And since
223:33 - we have one, and then goes ahead and calls
that, so deferring doesn't move it to the
223:37 - end of the main function, and actually moves
it after the main function. But before the
223:42 - main function returned. Now, if we put the
deferred keyword in front of all of these
223:46 - statements, then we'll actually see an interesting
behavior. Because the deferred functions are
223:52 - actually executed in what's called lifepo
order or last in first out. So the last function
223:58 - that gets deferred is actually going to be
the first one that gets called. And this makes
224:02 - sense, because often we're going to use the
deferred keyword to close out resources. And
224:07 - it makes sense that we close resources out
in the opposite order that we open them, because
224:11 - one resource might actually be dependent on
another one. So if we run this like this,
224:15 - we actually see that we've reversed the order
of printing this. So we're now printing and
224:19 - middle and start. And just to remind you,
these aren't executing in the context of the
224:23 - main function they're executing after the
main function is done, but before it returns
224:27 - any results to the calling function. Now,
these are good theoretical examples. But in
224:31 - this situation, I felt it makes sense to get
a little bit more practical example for you
224:35 - to look at. So for this, we're actually going
to need to go into Visual Studio code, because
224:39 - we're going to need to run a program that's
going to make some resource requests through
224:43 - the HTTP package. And you can't do that in
a playground. So if we look at this program,
224:47 - here, we're importing a couple of packages.
Then we're using the get function from the
224:51 - HTTP package in order to request the robots
dot txt file from google.com. Now this example
224:57 - you can actually find in gos documentation.
I basically stole this as an example for how
225:02 - you can use the deferred function. Now, as
you can see, with this request, we're going
225:05 - to get a response and an optional error. And
we're going to check to see if that error
225:09 - is nil. And if it's not, then we're going
to log that out and exit our application.
225:13 - If it is not nailed, and we got a good response.
So then we're going to use the read all function
225:17 - from the IO util package, what that'll do
is that'll take in a stream, and that'll parse
225:22 - that out to a string of bytes for you to work
with. So if we look at the robots variable,
225:26 - here, we see that that is a string of bytes.
And then we close the body of the response
225:30 - to let the web request know that we're done
working with it, so it can free up those resources.
225:34 - Of course, the read operation can fail, so
we're checking for that error. And then we're
225:37 - finally going to print out the value of the
robots variable here. So if we run this application,
225:43 - by invoking it with the go run command, we
see in fact that we do get the robots printed
225:48 - out, and everything worked out just fine.
So we got this entire response printed out
225:52 - to the console here. Now, one thing that we're
doing here, and that the defer keyword can
225:56 - help with is handling this body close. Now,
in this application, we only have one statement
226:02 - that's really being worked with between the
request being made, and the body being closed.
226:06 - However, in many applications, you might have
quite a bit of logic that's involved, that
226:11 - needs that body to be open and continue to
work with it, maybe you're reading this stream
226:14 - one character at a time, and you're doing
some pattern matching or something like that.
226:19 - So you can actually end up with quite a few
statements in here. So what can happen here
226:23 - is that you might make this request and open
up this resource up here. And then it might
226:27 - be dozens of lines later that you actually
get around to closing in. Well, that introduces
226:31 - the possibility that you forget to close it.
Now, it's going to be hard to find that it's
226:36 - going to be hard to remember to close the
resource. And so you're introducing the possibility
226:40 - of bugs coming into your application. So what
we can do is add the defer keyword here. And
226:45 - then we can go ahead and move this up a line.
So if we run this, then it looks like we're
226:49 - closing the resource, and then we're trying
to read it. But if we run the application,
226:53 - we see that it works just fine. Everything
comes out the same way it did before. Now
226:57 - if we leave the defer keyword off,
227:00 - then we do get an error because we closed
the response body before we were done reading
227:04 - it. So what this allows you to do, and this
is the most common use case that I've seen
227:08 - for using defer is it allows you to associate
the opening of a resource and the closing
227:14 - of the resource right next to each other.
So you see this pattern a lot where we're
227:17 - going to open resource, we're going to check
for an error. And then we're going to close
227:21 - the resource. And you want to check for the
error first. Because if there's error generated
227:24 - here, then you actually never got this resource.
And so trying to close, it will cause your
227:28 - application to fail. But as long as you know
that you have the resource there, then it
227:32 - makes sense to do a deferred call to close
it. Now, one thing I would warn you about
227:35 - is this is a pretty common pattern. And you're
going to see this all the time. But if you're
227:39 - making a lot of requests and opening a lot
of resources within a loop, then using the
227:44 - defer keyword to close, it might not be your
best choice. Because remember, the deferred
227:49 - statements don't execute until the function
itself executes. So if you've got a loop that's
227:53 - going to loop over a million resources, you're
gonna have a million resources open before
227:57 - all of those get closed at the same time when
the function finally executes. So if you're
228:01 - working with resources in the loop, then you
might not actually want to use the defer keyword,
228:05 - you might want to explicitly close those resources
when you're done with them. Or another option
228:09 - would be to delegate the processing of those
resources out to another function and have
228:13 - that function, close the resource. That way,
you're not keeping a bunch of resources open
228:17 - at one time and wasting memory. Now the next
thing that I want to show you we can do back
228:21 - in the playground. So I want to do that, because
I think that's the most accessible environment
228:25 - that we have is this program here. So when
I run this program here, what do you think
228:30 - is going to print out when I run this, now
there's two lines of thought that you might
228:35 - have, the first line of thought is, well,
I'm defining a is the string start. And so
228:39 - I'm going to print start out. But you might
also realize the defer statement is going
228:44 - to cause this statement to print after the
main function is done. And before main is
228:48 - done, we've already changed the value to end.
So you could make an argument that this is
228:52 - going to bring start or end with the fact
is that we're going to get the values start
228:57 - printed out. And the reason for that is when
you defer a function like this, it actually
229:02 - takes the argument at the time, the defer
is called not at the time the called function
229:06 - is executed. So even though the value of a
is changed, before we leave the main function,
229:11 - we are going to actually eagerly evaluate
this variable. And so the value start is going
229:16 - to be put in here, we're not going to pay
attention to this value as it changes. Now
229:20 - the next thing that I want to talk to you
about in this video, is what's called panicking.
229:25 - Now in go, we don't have exceptions, like
a lot of applications have, because a lot
229:29 - of cases that are considered exceptional and
a lot of languages are considered normal in
229:33 - a go application. For example, if you try
and open a file, and that file doesn't exist,
229:38 - that's actually a pretty normal response.
It is reasonable to assume that you might
229:42 - try and open a file that doesn't exist. And
so we return error values. We don't throw
229:47 - exceptions because that's not considered exceptional
and go. However, there are some things that
229:52 - get a go application into a situation where
it cannot continue and that is considered
229:56 - exceptional. But instead of using the word
exception, which you has a lot of connotations
230:00 - because of its use and other languages, we're
going to use another word and that word is
230:04 - going to be panic. And that's because our
application can't continue to function. And
230:08 - so it's really starting to panic because it
can't figure out what to do. So if we take
230:12 - this example, here, I'm declaring two variables
a and b, and setting a equals one and B equal
230:16 - to zero. Now, obviously, the answer of one
divided by zero is invalid, we can't do that
230:22 - in a go application. So if I run this, we're
actually going to see that the runtime itself
230:27 - will generate a panic for us. And the runtime
errors printed out integer divide by zero.
230:32 - And then we get a stack trace letting us know
where that error occurred. Now, if you're
230:36 - going along and writing your own program,
and you get to a situation where your program
230:39 - cannot continue to execute, because of a certain
state that gets thrown, then it makes sense
230:43 - for you to panic as well. So to do that, you're
going to use the built in panic function like
230:48 - we see here. So we're printing out start,
then we're using the built in panic function
230:52 - passing in a string, and then we're going
to print out. And what's going to happen when
230:56 - we run this is very similar behavior to when
we had that divide by zero error a few seconds
231:01 - ago, but the error message that's printed
out is actually going to be the string that
231:04 - we passed into the panic function. And then
notice we get the same stack trace out, we
231:09 - do get start printing out. But of course,
we don't get the string end printed out.
231:13 - Now more practical example. Now this will
not run in the playground. But that's okay,
231:17 - because it probably wouldn't fail on the playground
anyway, is this one here. So this is a very
231:22 - simple web application where you're going
to use the handle function. So we're registering
231:25 - a function listener, that's going to listen
on every URL in our application. And then
231:30 - this is a callback that gets called every
time a URL comes in that matches this route.
231:35 - And all this is going to do is print out the
string hello, go. As a matter of fact, why
231:38 - don't I go ahead and do this over in Visual
Studio code, that way, you can see what this
231:41 - program is going to do. So we'll go ahead
and save this and we'll get it up and running.
231:45 - Now there's no errors and went ahead and started,
okay. So if I come in, and hit that URL, which
231:52 - is localhost 8080, that you see that we get
the string hello, go printed out. There you
231:57 - go an entire web development course in one
video. So we've got a very basic web handler
232:02 - that's printing out the string, hello, go.
And that's coming from this line right here,
232:06 - where we're writing to this response writer,
this response writer is basically giving us
232:10 - access to the response to this web request.
And we're printing out the string hello, go.
232:16 - Now, what's interesting here is this error
handler right here. So the listening serve
232:20 - function returns an optional error object.
So when might that happen? Well, one situation
232:25 - that can happen all the time, when you're
firing up a web server is the port can be
232:29 - blocked. So if I open up another terminal
here, and go ahead and try and run this, again,
232:34 - you see that we get our application panicking.
And the reason for that is we're trying to
232:38 - access a TCP port that's already been blocked.
And it's been blocked by the fact that we're
232:42 - running the application over here. So this
is a situation that happens all the time.
232:46 - Now, the listening serve function doesn't
have an opinion on if that's a panicking situation
232:51 - or not, because he just tried to execute something.
And it's going to return an error value saying,
232:55 - Well, that didn't work, it's reasonable to
assume that listening serve can fail. And
232:59 - so it's not going to panic is going to return
an error. Now, we're the ones writing the
233:03 - web application. And we know that if that
doesn't work, the entire application gets
233:08 - brought down, and nothing happens. So in that
situation, we decide that we're going to panic
233:13 - passing out that error that comes from the
listening serve method, letting whoever's
233:16 - trying to start this up, know that something
very bad just happen. And so this is a common
233:20 - pattern that you're going to see and go go
is rarely going to set an opinion about whether
233:25 - an error is something that should be panicked
over or not. all it's going to do is tell
233:28 - you, hey, this didn't work the way that you
expected it to work. It's up to you, as a
233:32 - developer to decide whether that's a problem
or not. So in this case, we say, yeah, that
233:36 - is a problem, we fail to start our application.
And so we do want to generate a panic. So
233:41 - what are we going to do in the situation that
our application is panicking. And we can get
233:46 - ourselves to a situation where we can recover
the application. So panics don't have to be
233:50 - fatal. They just are, if we panic all the
way up to the go runtime, and the go runtime
233:56 - realizes wait doesn't know what to do with
a panicking application. And so it's going
233:59 - to kill it. So we come back to this application
here, and run, we see that once again, we're
234:04 - getting this panic. But something I want to
show you related to our deferred discussion
234:09 - is this modification here. So I've added this
line, a deferred print statement that says
234:14 - this was deferred. So if we run this application,
something interesting is going to happen.
234:19 - We get stopped printed out. That's not a big
surprise. But then we get this was deferred
234:23 - printing out and then the panic happens. And
this is really important, because panics happen
234:28 - after deferred statements are executed. So
the order of execution is we're going to execute
234:34 - our main function, then we're going to execute
any deferred statements, then we're going
234:38 - to handle any panics that occur. And then
we're going to handle the return value. So
234:42 - there's actually quite a bit that happens
in a function after it exits this closing
234:46 - curly brace here. So why is this important?
Well, the first thing that's important is
234:50 - that the first statements that are going to
close resources are going to succeed even
234:54 - if the application panics. So if somewhere
up the call stack, you recover from the panic,
234:59 - you don't have to worry about
235:00 - resources being left out there and left open.
So any deferred calls to close resources are
235:05 - still going to work even if a function panics.
But the other thing that's really important
235:10 - is if I change my deferred function here to
something like this, now, this is a custom
235:17 - function. And we're not going to talk about
this for a couple of videos yet. But this
235:20 - is important in order to talk about this.
So I need to jump this ahead in the queue
235:23 - a little bit.
235:24 - So what we're creating here is what's called
an anonymous function. And an anonymous function
235:28 - is simply a function that doesn't have a name.
So nothing else can call this, this is defined
235:32 - at one point, and we can call it exactly one
time, these parenthesis here are making that
235:38 - function execute. And this is an important
thing to know about the defer statement, the
235:42 - first statement doesn't take a function itself,
it actually takes a function call. So you
235:46 - want to invoke that function, otherwise, things
aren't going to work properly. Now, inside
235:51 - of this custom function, notice that we're
using this recover function here. So what
235:55 - the recover function is going to do is it
will return nil if the application isn't panicking.
236:01 - But if it isn't nil, then it's going to return
the error that actually is causing the application
236:05 - to panic. So in this logical test, we're checking
to see if it's not nil. So if it's not nil,
236:10 - that means our application is panicking. and
in this situation, we're simply going to log
236:14 - that error out. Now, what happens in this
situation is the execution still stops at
236:18 - the panic. And let me import this log package
before we run this. And we see that the application
236:25 - still execute. So we got the string start
printed out, then we printed out the error
236:29 - using the long package. But we didn't get
this end function printed out. So it looks
236:34 - like our application is still dead. But recovered
does have some important impacts if we have
236:39 - a deeper call stack than what we're dealing
with right here. So let me drop in this example
236:43 - in order to show you. So in this case, we've
got the main function, that's going to be
236:46 - our application entry point, of course. And
then we've got this other function called
236:50 - panikkar. And all this thing does is it's
going to print on the line that says it's
236:53 - about the panic, and then it's going to panic.
And it's going to go ahead and recover from
236:57 - that panic using that deferred function that
we saw just a moment ago, then we're gonna
237:01 - have this line here, done panicking. And then
up in our main function, we're going to print
237:05 - start, we're going to call the panacur. And
then we're going to print and so let's see
237:09 - what happens when we run this. So as you see,
we get the start line printed out, like you
237:15 - would expect, we see the about the panic string
print out, then we panic, something bad happened,
237:21 - we go into our recover loop, because we're
not going to execute this because our application
237:25 - panic. And so our panikkar function is going
to stop execution right there and execute
237:29 - any deferred functions. And inside of that
deferred function, we call recover. So in
237:34 - that recover, we're going to log out the fact
that we have that error, and we're going to
237:38 - log that error message out that we see here.
But then in the main function execution continues.
237:43 - So in the event that you're recovering from
a panic, the function that actually recovers,
237:47 - still stops execution, because it's in a state
where it can no longer reliably continue to
237:52 - function. And so it makes sense for it to
stop doing whatever it was trying to do. However,
237:58 - functions higher up the call stack, those
functions that call the function that recovered
238:01 - from the panic, they are still presumably
in a situation where they can continue, because
238:06 - you recover function said that your application
is in a state working to continue to execute.
238:11 - Now, this is a little bit limiting as well,
because in order to determine what that error
238:15 - is, you actually have to call the recover
function, which basically means that you're
238:19 - saying that you're going to deal with it.
So what happens if you get that error, and
238:23 - you realize that this isn't something that
you can deal with? Well, in that case, what
238:26 - you're going to do is repainting the application.
So all we need to do in order to do that is
238:31 - just read through the error, or you can come
up with another error string, whatever makes
238:35 - sense for you. But in this case, inside of
the handler, we're throwing a panic again,
238:40 - then we actually see that we don't get that
end statement printed out our main function
238:45 - panics because we read through that panic.
So we get the full stack trace of when the
238:49 - panic actually happened. And we see that we're
inside a func one function, one is actually
238:53 - this anonymous function right here. And we
see that we do get that stack trace printed
238:58 - out and we don't get the string and printed
out. So if you're in a situation where you're
239:02 - trying to recover from a panic, and you realize
you can't handle it, you can feel free to
239:06 - re throw that panic, and the further management
of that panic, higher up the call stack. Okay,
239:11 - so let's go into a summary and review what
we've talked about in this video. In this
239:15 - video, we talked about the final two control
flow concepts that we have to be aware of
239:19 - in go programming. Now, one could argue that
differs and panics aren't really control flow
239:24 - constructs, because they're not the traditional
branching or looping logic that we consider.
239:29 - But they definitely do alter the flow of execution
of our program. And so I'm going to lump them
239:33 - together in this category. The first thing
that we talked about was the use of the defer
239:37 - function in order to delay the execution of
a statement until the end of a function. Now,
239:43 - these are useful to group open and close functions
together. So if your open function is going
239:47 - to open up a resource, and you need to make
sure that you close that, then you can defer
239:51 - the call to close that resource to make sure
that you're freeing up the memory and not
239:55 - holding on to that resource any longer than
you need to. The one thing I would warn you
239:59 - though, is be careful loops. If you're opening
and closing a bunch of resources inside of
240:03 - a loop, then you probably want to explicitly
handle that close without the deferred keyword.
240:08 - Because when you're using deferred keyword,
all of those resources are going to stay open
240:12 - until the function finishes execution. And
that can cause you some memory issues, especially
240:16 - if you're dealing with a very large number
of resources. If you've got multiple different
240:21 - statements inside of a function, then they
run in life order or lastin. First out, so
240:25 - the last deferred statement that you call
is going to be the first one that actually
240:30 - executes. And again, this makes sense, because
if you're opening a bunch of resources, and
240:34 - those resources are dependent upon one another,
then you're going to close them in the reverse
240:38 - order that you open them, which is typically
the right way to go. arguments in a deferred
240:42 - call are evaluated at the time the defer is
executed, not at the time the called function
240:47 - is executed. And that's important to keep
in mind because you could pass in variables
240:52 - into a deferred function call. And it can
be a little bit confusing if you change the
240:56 - value of those variables further on. And those
aren't reflected in your deferred statement.
241:00 - So just keep in mind, when you call defer,
the value of those variables are going to
241:04 - be captured at the time that that defer is
executed, not at the time the function actually
241:08 - executes. Now, something unplanned happens
in our application, then we've got two ways
241:13 - that a go application can go it can return
an error value, which is the normal case,
241:17 - or it can panic. Now, what you generally want
to do is you want to return an error value,
241:23 - because in go programming, we typically don't
consider a lot of things that go wrong in
241:28 - an application to be exceptional events, or
to be events that should cause the application
241:31 - to shut down. For example, a classic example
of that is making an HTTP request, and you
241:36 - make the request and you don't get a response
from that server. Well, that's something that
241:41 - happens all the time, no response is a valid
response, it just happens to be an error,
241:45 - because you're looking for that resource,
and you got a 404 return back. So in that
241:50 - case, you're going to return an error value,
you're not going to panic, the application
241:54 - panics are used when an application gets into
a state that it cannot recover from, for example,
241:59 - you hand the runtime a divide by zero problem,
there's no way for you to figure out how to
242:03 - divide a number by zero, and so has no way
to manage that. And that's a situation where
242:08 - the application is going to panic. So just
to summarize, then, they occur when an application
242:13 - can't continue at all, don't use them when
a file can't be opened. Unless it's a critical
242:17 - file. For example, if you're opening a template
that's used in a web application to generate
242:22 - your view layer, then that might be something
that's worth panicking over. But if you're
242:25 - trying to open up a log file, and you can't
get there, well, there's no reason to panic
242:29 - for that necessarily, you just need to return
an error value and then inform somebody that
242:33 - the logs aren't available.
242:34 - Now a situation where you might want to panic
is unrecoverable events. So if you're starting
242:37 - up a web server, and it can't get ahold of
the TCP port that it's supposed to be listening
242:41 - on, then that's probably a situation where
panic makes sense, the function will stop
242:45 - executing immediately at the point of the
panic, but the third functions will still
242:50 - fire. If nothing handles that panic, then
eventually the panic is going to go up the
242:53 - call stack, it's going to hit the go runtime,
the go runtime has no built in handling for
242:57 - panicking situations. And so the program will
then exit. If you do have a panicking situation
243:03 - that you feel that you can recover from, then
you can recover using the built in recover
243:07 - function. Now that function is used to recover
from panics, it's only useful inside of deferred
243:13 - functions. And the reason for that is because
of the behavior of panic. Remember, when an
243:17 - application starts to panic, it no longer
executes the rest of that function, but it
243:21 - will execute deferred functions. So the proper
place to use the recover keyword is inside
243:26 - of a deferred function, that's going to look
for a panicking situation. And if the application
243:30 - is panicking, then it can go ahead and decide
what to do with it, the current function will
243:34 - not attempt to continue. But if you do recover,
then higher functions in the call stack will
243:39 - continue as if nothing went wrong. Now, if
that's not the behavior that you want, if
243:43 - you call that recover function, you look at
the error that's returned from the recover
243:47 - function and you can't handle it. Remember
that you can go ahead and rethrow that panic
243:51 - by calling the panic function again. And then
the panic will continue to propagate up the
243:56 - call stack, I want to talk about pointers
and how we can use them in the go language.
244:01 - We'll start that discussion off by learning
how to create pointers. And then we'll talk
244:04 - about something called dereferencing. a pointer,
which is basically using a pointer to get
244:09 - at some underlying data. Then we'll talk about
the new function. And then we'll talk about
244:13 - a special type in NGO called nil. And then
we'll wrap up our discussion by talking about
244:18 - built in types and go that use internal pointers.
And so their behaviors a little bit different
244:23 - than other types that you'll work with in
your applications. Okay, so let's dive right
244:28 - in and learn how to create some pointers.
To start our discussion, I want to start as
244:33 - simply as I can. So I'm going to use this
example here. As you can see him declaring
244:37 - a variable a and assigning it the value 42.
And then I'm going to go ahead and print that
244:41 - out. So it should be no big surprise that
when I run this, the value 42 gets printed
244:46 - out. Now, if I extend this application a little
bit, and I create a variable b and assign
244:51 - it to the value of a and print both of those
out, then again, it's no big surprise that
244:56 - 42 prints out two times. Now since a and b
are value types. When I put in this line here,
245:02 - what go is going to do is it's actually going
to copy whatever data is stored in a and assign
245:06 - it to be. So we're not actually pointing to
the same memory. And we can prove that by
245:11 - changing the value of a to, for example, 27,
and then printing out everything again. And
245:17 - if we run this, we see that the value of a
changes to 27, but the value of b stays at
245:22 - 42. Now we can change this behavior a little
bit by having B point to a using something
245:27 - called a pointer. Now in order to demonstrate
that, I'm going to actually change our declaration
245:32 - syntax a little bit and go to more of a long
form syntax. And the reason for that is to
245:37 - make things a little bit more clear about
how the pointer notation works. So I hope
245:42 - you'll agree with me that this line eight
is exactly the same as the previous one that
245:45 - we had, it's just a little bit more verbose.
Now, if I want to change B into a pointer,
245:50 - and use that same long form syntax, what I
can do is declare the variable b. And then
245:55 - I'm going to declare it as a pointer to an
integer. And the way I declare it as a pointer
245:59 - is by preceding the type that I'm pointing
to with this asterisk here. So then if I want
246:04 - B to point to a, then I'm going to use a special
operator called the address of operator that
246:10 - you see here. So at line nine is now saying
is that B is a pointer to an integer. And
246:15 - I want to point it to a
246:18 - now what is a pointer exactly? Well, let me
remove these lines here and run this and see
246:21 - what we get as output. So as you see here,
a is still holding the value 42, like we expect,
246:27 - but B is holding this strange data here. So
what is that? Well, this is actually the numerical
246:32 - representation for the memory address that
is holding the location of a. So at this location
246:39 - in memory, we actually have assigned the integer
42. So be isn't holding the value 42, it's
246:46 - holding the memory location that's holding
his data. And we can prove that by using the
246:51 - address of operator down here. And when we
run this, again, we should see, in fact, we
246:56 - do see that the values are exactly the same.
So the address of A in memory is this value
247:02 - here, and B is holding that exact value. And
as a matter of fact, we can even go the other
247:07 - way. Because while the address of operator
is going to give us the address of a variable
247:12 - in memory, we can use a different operator
in order to figure out what value is actually
247:17 - being stored at a memory location. And that's
called the dereferencing operator. So if I
247:21 - go ahead and remove this, and then I'm going
to put a dereferencing operator right here
247:25 - in front of this pointer. Now you notice we're
using the same asterisk. But these have a
247:29 - little bit different meaning here. So up here
on line nine, this asterisk before type is
247:34 - declaring a pointer to data of that type.
So this is a pointer to an integer. Now when
247:39 - I put the asterisk in front of a pointer,
then that's going to dereference, which basically
247:44 - means it's going to ask the go runtime, to
drill through the pointer, find the memory
247:48 - location that that pointer is pointing to,
and then pull the value back out. So if we
247:53 - run this, we see that we get the value 42
printed out both times once again. Now what's
247:58 - the point of all of this, what the point is,
since B is pointing at the same value of a,
248:03 - Now both of these variables are actually tied
together. So if we change the value of a once
248:08 - again, and then print out their data, now
we see that both A and dereferencing, b both
248:16 - give the value of 27. Because they're both
actually pointing at the same underlying data.
248:21 - As a matter of fact, we can even dereference
the pointer and use that to change the value.
248:25 - So if I use the dereference, B, and assign
the value 42 to it, and then print it out
248:31 - again, then we see that once again, both values
are changing a and the value that B is pointing
248:36 - to our both teams, because it's in fact the
same data. Now, if you come from a background
248:41 - in languages that allow you to work with pointers
as variables, then you might be expecting
248:46 - to do something called pointer arithmetic.
So if I drop this example in here, we're going
248:50 - to start to play around with something that's
going to lead us to see how go treats pointer
248:54 - arithmetic. So I'm going to start with a variable
a, and that's going to hold an array of three
248:58 - values, one, two, and three. And then I'm
declared B as a pointer to the first element
249:04 - in the array to this value right here. And
then C is pointing to this second element
249:08 - right here. Now if I use this print statement,
here, it's going to print the value of the
249:11 - array and then this percent p syntax is actually
going to print the value of the pointer for
249:17 - BNC. So if we run this, we see that we do
in fact, get the array and then we get these
249:22 - two memory locations printed out that B and
C are holding. Now notice that C is holding
249:26 - a value that's for higher than B. And the
reason for that is how go lays out arrays
249:31 - in memory. Since this is an array of integers
and integers in this version of the runtime
249:36 - are four bytes long each element of an array
are four bytes apart. So this memory address
249:41 - ending with 124 is holding the first element
in the array, and then four bytes later, we're
249:47 - going to hold the next element of the array
c you might be tempted to do something like
249:50 - this if you come from another language, if
I take the address of C and subtract four,
249:56 - then that actually should give me the address
of B and then I can dereference that and Both
250:00 - of these should be pointing to the head of
the array. Well, if I run this, I in fact,
250:04 - see that I get an error. And the reason for
that is go does not allow math like this to
250:09 - be done on pointers. Now, once again, if you've
come from C or c++, you're probably aware
250:14 - of the tremendous performance advantages that
you can get if you're allowed to do pointer
250:19 - arithmetic, because you can jump around mapped
memory very, very quickly, and gain some pretty
250:24 - substantial benefits in the performance of
certain applications. However, whenever you
250:29 - get into pointer arithmetic, you're typically
getting into some fairly complicated code.
250:34 - And since go has as one of its core design
concerns simplicity, the decision was made
250:39 - to leave pointer arithmetic out of the go
language. Now, if you absolutely need to have
250:44 - something like this in your application, then
what I would suggest is you can come into
250:48 - the go packages and come down here to the
unsafe package. And this is going to give
250:54 - you operations that the go runtime is not
going to check for you. So if you really need
250:58 - to do pointer arithmetic and things like that,
then the unsafe package, which has a very
251:02 - appropriate name is available for you for
those very advanced scenarios. Now, those
251:07 - scenarios are advanced enough that what I'm
going to suggest is if you need to know it,
251:11 - you're going to learn it. But generally, you're
not going to need to know how this stuff works.
251:15 - Now the next thing that I want to show you
is how we can actually create pointer types.
251:19 - So we've seen this address of operator and
that's allowing us to instantiate a pointer
251:24 - to a certain variable. So if we look at the
type of B, it's actually a pointer to an integer
251:28 - because we're pointing to one element in the
array. But so far, we've had to declare the
251:32 - underlying type first. Well, that's actually
not necessary and go because often, you only
251:37 - want to work with the pointers, and you don't
really care where the underlying data is stored,
251:42 - you just need the ability to point to it wherever
it's at. So in this example, we see how we
251:47 - can do that. Now we've seen almost exactly
the same syntax before, because when we were
251:52 - talking about structs, we had an example that
looks something like this. So we were declaring
251:56 - my struct object, we were instantiating it
using the object initialization syntax. And
252:02 - when we print everything out, we print the
value 42 out. Now if I make this MSX variable,
252:07 - a pointer to a my struct, and then use the
address of operator in this object initializer,
252:12 - then I actually get almost the same behavior,
except for notice that when I print out the
252:17 - value of MS, I end up with this ampersand
here, which is basically saying that ns is
252:22 - holding the address of an object that has
a field with a value 42 in it. Now the advantage
252:28 - of being able to do this, it's going to come
to light in a future video. But for now, just
252:32 - be aware that you can do this. Now this isn't
the only way that we have available to us
252:37 - to initialize a variable to a pointer to an
object, we can also use the built in new function.
252:43 - Now unfortunately, with the new function,
we can't use the object initialization syntax,
252:48 - we're just going to be able to initialize
an empty object. So if I go ahead and run
252:51 - this, we see that we do get an initialized
object. But all of its fields are initialized
252:56 - to their zero values, we can't initialize
them using the object initialization syntax.
253:01 - Now, since I mentioned zero values, it's important
to understand the zero value for a pointer.
253:06 - Because as we talked about, in a very early
video, every variable that you declare in
253:10 - go has an initialization value. So right here
after line eight, ns is holding something.
253:17 - So the question is, what is that thing? So
if I go ahead and copy this print statement
253:21 - up here, we will be able to answer that question.
So let me format this and run it. And then
253:25 - we see that we get the special value nil out.
So a pointer that you don't initialize is
253:30 - actually going to be an initialized for you.
And it's going to hold this value nil. So
253:34 - this is very important to check in your applications.
Because if you're accepting pointers as arguments,
253:39 - it is best practice to see if that pointer
is a nil pointer. Because if it is, then you're
253:44 - going to have to handle that in a different
way. So for example, if we try and drill through
253:47 - and get to this foo field, but and this is
actually nil, then we're going to get a runtime
253:53 - exception, and our program is going to crash
on us. Now that actually leads us to an interesting
253:57 - point, how do we actually get at this underlying
field and work with it? Well, the obvious
254:01 - way that we're going to need to do that is
we're going to have to dereference the ns
254:04 - pointer in order to get it that struct, and
then we can get it that field. So we're going
254:08 - to have to use something like this. Now, you
might be asking why the prints are there?
254:12 - Well, it turns out that the dereferencing
operator actually has a lower precedence than
254:16 - the dot operator. So we need to print in order
to make sure that we're dereferencing, the
254:21 - MS variable instead of dereferencing, Ms dot
foo. So now we can go ahead and set this to
254:26 - the value 42. Now in order to get at the value
of foo, to print it out, then we're going
254:30 - to have to repeat the same exercise. So we're
going to add some brands here. I'm going to
254:34 - wrap this ms variable, and then we'll print
out the value of foods. So if I go ahead and
254:38 - run this, we in fact, do set and get the value
42, which is the value of that field. Now
254:44 - I hope you'll agree with me at this point
that this syntax is really ugly, because we
254:48 - use this syntax every time we dereference
a pointer, we're going to have to use match
254:52 - that a params and have this dereference operator.
Well it turns out because of the limitations
254:58 - that are put on point Here's the compiler
is actually able to help us out a little bit.
255:03 - So in fact, we don't need this syntax at all.
If we go ahead and remove this and remove
255:08 - this from the print statement as well, and
run this, we actually get exactly the same
255:13 - behavior. Now again, if you're coming from
a language, which makes extensive use of pointers,
255:17 - this is probably freaking you out. Because
the pointer and s
255:21 - doesn't actually have a field foo on it. The
pointer MS is pointing to a structure that
255:26 - has a field foo. So how is this working? Well,
again, this is just syntactic sugar. This
255:31 - is just the compiler helping us out because
it understands or not actually trying to access
255:36 - the Foo field on the pointer, we're implying
that we want the underlying object. And so
255:41 - go is going to go ahead and interpret that
properly for us, and dereference, the pointer.
255:46 - So the compiler really sees this statement
the same as this statement, they're exactly
255:50 - the same to the compiler, it's just one reads
a little bit more cleanly. Now, the last thing
255:54 - that I want to talk about today is how go
handles variables when they're assigned one
255:59 - to another. So let me go ahead and paste this
example in here. As you can see, on line eight,
256:03 - we're initializing an array. On line nine,
we're initializing another variable and pointing
256:08 - it in the same array as a, then I'm going
to print out both A and B. And then I'm going
256:12 - to change index one of the A array to 42,
and print them out again. Now, we've already
256:17 - done this example in the past, and hopefully
you remember that a is going to change but
256:21 - B is not because b is a copy of the array
that we stored in a and so they update independently
256:27 - of each other. However, if I remove this index,
and turn this into a slice, the behavior changes
256:33 - a little bit. If we run this, now we see that
both A and B are changed together. So what
256:40 - happened there? Well, the slice is copied
just like the array, but the effect of the
256:45 - copying is a little bit different. Because
in the version with an array, the values of
256:49 - the array are actually considered intrinsic
to the variable. So A is holding the values
256:54 - of the array, as well as the size of the array
and that size is held that way we can do bounds
256:58 - checking. So for example, if we asked for
index three, which is beyond the bounds of
257:01 - this array, and run, we can do bounds checking
in the go language. And that's a very good
257:06 - thing. However, with slices, remember, a slice
is actually a projection of an underlying
257:12 - array. And so the slice doesn't contain the
data itself, the slice contains a pointer
257:20 - to the first element that the slice is pointing
to on the underlying array. So what that means
257:25 - is that when we work with slices, the internal
representation of a slice actually has a pointer
257:31 - to an array. So while line nine is still copying
the slice a into the slice B, part of the
257:38 - data that gets copied is a pointer, not the
underlying data itself. What that basically
257:43 - means is, when you're sharing slices in your
application, you're actually always going
257:47 - to be pointing at that same underlying data.
Now, the other built in type that has this
257:51 - behavior is a map. Because maps, once again,
have a pointer to the underlying data, they
257:57 - don't actually contain the underlying data
in themselves. So if I take this example,
258:02 - where I'm initializing a map of strings to
strings and assigning that to a, and then
258:06 - B is assigned to a, then I print them both
out, then I change one of the values in a
258:11 - and print them out again, if I run this, we
see that both maps start out the same. And
258:16 - then when I change the key foo in the map,
a we actually change that in the map B as
258:21 - well. So what does that mean? Well, what it
means is, when you're working with slices
258:25 - and maps in a go application, you have to
be very, very careful to keep in mind at all
258:29 - times who's got access to that underlying
data. Because passing slices and maps around
258:35 - in your application can get you into situations
where data is changing in unexpected ways.
258:40 - However, if you're working with the other
data types, specifically primitives, arrays,
258:44 - or structs, then this generally isn't going
to happen to you because when you copy a struct,
258:49 - it's actually going to copy the entire structure
unless you're using pointers. Okay, so that
258:54 - wraps up what I have to talk about with pointers.
Let's head into a summary and review what
258:58 - we've talked about in this video. In this
video, we talked about pointers and how to
259:02 - use them in the go language. Now, we haven't
seen a lot of practical application for pointers
259:07 - yet. But we need to understand what pointers
are. Before we get into that. So over the
259:11 - next couple of videos, we'll get into why
you would want to use pointers and the benefits
259:15 - of them. But for now, we're just trying to
introduce the basic subject. So we started
259:19 - by learning how to create pointers. And we
learned that if we prefix a type with an asterisk,
259:25 - that's actually going to declare that type
to be a pointer to that underlying data type.
259:29 - So for example, we have this asterisk int,
which is going to be a pointer to an integer.
259:34 - We also learned how we can create pointers
using the address of operator to get the address
259:38 - of an existing variable in memory. Then we
learned about dereferencing pointers and how
259:43 - we can use that asterisk operator again, but
this time in front of a pointer instead of
259:48 - in front of a type and use that to drill through
the pointer to get at the value that the pointer
259:53 - is pointing to. We also learned that when
you're working with complex types, such as
259:58 - pointers to structs those pointers are automatically
going to be dereferenced for us. So our syntax
260:03 - doesn't get cluttered up by a whole bunch
of dereference, operations and parenthesis,
260:08 - then we moved on to learn how to create pointers
to objects. And we learned that there's a
260:12 - couple of different ways. So the first thing
that we can do is use that address of operator
260:17 - to get access to a pointer to an object that
we've already created. So in this example,
260:21 - we've got an instance of a my struct object
called Ms. And then we can use that address
260:25 - of operator to create a pointer p to that
struct. But we can also do that directly.
260:31 - So if we proceed an object initializer, with
that address of operator, then we can actually
260:36 - directly create a pointer. And we don't have
to have an intermediate variable that's holding
260:40 - that value, we can also use the new keyword
to initialize an object, but we can't initialize
260:45 - the fields at the same time. So the behavior
is a little bit different, because we're going
260:49 - to have to use the new keyword that's going
to zero out all the fields in a struct, for
260:53 - example. And then we're going to have to come
in later and initialize all the values. The
260:56 - last thing that we talked about was types
with internal pointers. And we saw how while
261:01 - they're treated exactly as any other variable
type, when we do an assignment, their behavior
261:06 - is a little bit different. So all assignment
operations and go are copy operations. So
261:11 - whenever you have a variable a and you create
a variable b and set it equal to a, all the
261:17 - data in a is going to be copied in order to
create B. However, slices and maps contain
261:21 - internal pointers. And so even though they're
copying, they're copying pointers, and so
261:26 - they're pointing to the same underlying data,
we're going to take a deep dive into functions
261:31 - and how you can use them in the go language.
Now, we've been talking about functions throughout
261:35 - this entire video series. But we've never
really taken the time to focus on them, because
261:40 - there's a lot of groundwork that we've had
to go through building up to the point where
261:43 - we can understand what a function is, and
how we can use those in our applications.
261:47 - So in today's video, like all of our videos
in this series, I'm going to break the discussion
261:50 - down into multiple parts. We'll start by talking
about the basic syntax of a function. Then
261:55 - we'll talk about the parameters that you can
pass into a function to influence how it works.
262:00 - Then we'll talk about the return values that
you can get back out of the function. We'll
262:03 - talk about something called an anonymous function.
We'll talk about how functions in the go language
262:08 - are first class citizens and can be passed
around in your application like any other
262:12 - variable, and then we'll wrap up our discussion
by talking about a special kind of function
262:16 - called a method. Okay, so let's get started
by learning the basic syntax of a function.
262:22 - To start our discussion of functions, we don't
have to go any farther than the basic application
262:27 - that the NGO playground gives us. So as soon
as you come into the playground, you're presented
262:31 - with this very simple application. And right
here, we have our first function. Now, the
262:36 - way that a go application is structured, is
you always have to have an entry point in
262:40 - the application. And the entry point of go
application is always in package main. And
262:44 - within that main package, you have to have
a function called main that takes no parameters
262:48 - and returns no values. So we can see that
right here. And so when we run the application,
262:53 - the application actually starts right here.
And so we print out the string, hello playground.
262:58 - And that's all that our application has to
do. So every NGO application starts this way.
263:02 - And we see here the most basic function that
we can create in the go language. So there
263:07 - are several major parts that we need to understand
about a function. First of all, they start
263:11 - with the func keyword. So as you can see here,
we're not going to start with function or
263:14 - anything else, we start with the func keyword,
and that's going to describe a function that
263:18 - we're going to create. Then we have the name
of the function that we're going to create.
263:22 - And this follows the same naming convention
as any other variable and go see you're going
263:26 - to use Pascal case or camel case for the names
of your functions. And depending on if you
263:31 - have an uppercase or lowercase determines
the visibility of that function. So just like
263:35 - with variables, and uppercase first letter
is going to be published from the package,
263:39 - so anything else can use it, and a lowercase
function name is going to be kept internal
263:43 - to the package. Now after the name of the
function, we have these match params here
263:47 - now we'll see as we get into parameters, what
these are for, but this is required syntax
263:51 - after the main function. So even if you don't
take any parameters in your function, you
263:55 - have to have these match params. And then
the actual body of the function is contained
264:00 - within these curly braces here. Now there
are a lot of holy wars and a lot of languages
264:04 - about where these curly braces should go.
So some languages put them here, some languages
264:08 - put them down here, some languages like to
indent them, there's all sorts of different
264:12 - conventions about where to put these curly
braces. Well, in the go language, there aren't
264:16 - any arguments because this is the convention
that is enforced by the compiler itself. So
264:21 - you have to put the opening curly brace on
the same line as the func keyword. And then
264:26 - the closing curly brace generally has to be
on its own. Now there are a couple of situations
264:30 - where you can have that closing curly brace
combined with a couple of other params. And
264:34 - we'll talk about that a little bit later in
this video. But generally speaking, when you're
264:38 - defining a function, the closing curly brace
has to be on its own line. Now, with functions
264:43 - defined like this, the execution path is static,
we can't actually influence what our functions
264:48 - doing from the outside, because we're not
passing any information into it. So if we
264:52 - do want to pass information into it, then
we're going to provide what are called parameters
264:56 - into the function. So let me just drop an
example that uses parameters. And you see
265:01 - here a main function is now calling into another
function called say message. And that same
265:06 - message function takes in this parameter MSG,
that's of type string. So when you're defining
265:12 - a function that takes parameters, the parameters
go between these two parenthesis here. And
265:16 - they're described like any other variable
declaration, except for you don't need the
265:19 - var keyword. So you're going to have the name
of the parameter, and you're going to have
265:22 - the type of the parameter. So then when we
want to call that function, we have to pass
265:26 - in the value for that parameter. And that's
called an argument. So we're going to pass
265:30 - in the argument Hello, go. And then inside
of our function, we're printing out the message
265:34 - that gets passed in. And so when we run this,
we see that Hello go prints out as a result.
265:40 - Now this MSG parameter isn't special in any
other way than the fact that it's passed into
265:44 - the function, it's treated as a local variable,
just like any other local variable that we
265:48 - might create. So if we created another variable
here, and we said, Hello, go, that's treated
265:54 - exactly the same way as our mystery variable.
So the only difference between the two is
265:59 - the MSG variable can be passed in from the
outside. And of course, that greeting variable
266:03 - was created locally. Now, you aren't constrained
to just pass a single parameter in, you can
266:07 - actually pass multiple parameters in. So if
I drop in this example, we can see that in
266:12 - action. So here, I've extended the same message
function to take two parameters. So I've still
266:17 - got the message parameter that's of type string.
And then I've put this comma here, and I've
266:21 - added another parameter, and that's going
to be an index. And that's going to be of
266:24 - type integer here. So as you can see, we can
pass as many parameters as we want, we're
266:29 - just going to provide a comma delimited list
of those parameter names and their types.
266:33 - So then when we call the function, we're going
to pass in one value for each one of those
266:38 - parameters. And they have to be in the same
order that they're declared. So the first
266:41 - argument that we're going to be passing is
the string hello, go, which is going to match
266:45 - this MSG variable. And then we're going to
pass in the I that's going to be the loop
266:49 - counter here. And that's going to be passed
into this ID x parameter. So then, in this
266:54 - function, we're just going to print out the
value of the message and then we're going
266:57 - to say what index we receive. So when we run
this, we see that the message prints out five
267:01 - times. And we get the same message, but the
index variable changes because we're passing
267:05 - in a different value every time we call the
function. Now, often, when you're defining
267:10 - a function, you're going to pass in multiple
parameters of the same type. So you're going
267:13 - to be tempted to have syntax like this. So
in this example, we've got a slightly different
267:18 - function. So instead of a generic, say, Hello,
we're going to have a say greeting function.
267:22 - And we're going to provide the greeting that
we're going to have and the name of whoever
267:25 - it is we're going to greet. So in this case,
we're passing in the string hello, and the
267:29 - string Stacy. So when we run this, we're gonna
say hello to Stacey. Now, since these types
267:34 - are the same, the go compiler actually provides
us a little bit more syntactic sugar, because
267:38 - this is a little bit more verbose than is
strictly necessary. So instead of specifying
267:43 - the type every time, we can actually just
specify a comma delimited list of variables,
267:47 - and then the type at the end. And what the
compiler is going to do is, it's going to
267:50 - infer that every variable that's in that comma
delimited, list has the same type. So when
267:55 - we run this, we actually get exactly the same
execution. But we just have a little bit more
268:00 - terse syntax. Now, so far, we've been passing
parameters in as value types. If you remember
268:06 - from our last discussion, we were talking
about pointers. And notice that I don't have
268:10 - any pointers in our function signatures right
now. So let me drop in this example here.
268:14 - And then we can start playing around with
the difference between passing in values and
268:17 - passing in pointers. So when I have this example
here, and I run it, we get exactly the same
268:22 - output that we had before. But I've got some
variables that I'm using to pass in as arguments
268:26 - to this function. Now, what do you think is
going to happen if I change the value of one
268:30 - of these variables inside the function, so
for example, if I change the name variable
268:34 - to Ted, and let's go ahead and print that
out, just to verify that it printed. And then
268:40 - what do you think is going to happen if I
print the same variable out, again, right
268:44 - here. So I'm passing in the name variable
by value. So that means that the go runtime
268:51 - is going to copy the data that's in this name
variable and provided to here. So what we
268:56 - would expect is when we change the value of
the name variable right here, it should have
269:00 - an effect. And we should print 10 out here.
But since this is a copy of the name variable,
269:05 - we actually shouldn't have any effect out
here. So if we run this, we see that in fact,
269:08 - that is true. So this is a safe way to pass
data into a function, you can be assured by
269:13 - passing by value, that the data is not going
to be changed when you pass it in. Now, if
269:18 - I change this to passing in pointers, by adding
a pointer here, and then passing in the address
269:24 - of these variables right here, and then dereferencing,
the pointers right here, then let's see what's
269:29 - going to happen. Actually, I need to add another
dereference right here. And now we're passing
269:34 - pointers to our variables around in our application.
So now, instead of working with a copy of
269:40 - the name variable, we're working with a pointer
to the name variable. And so when we run this,
269:46 - we actually see looks like I missed a dereference
operation right here. And now we see that
269:51 - we have in fact, change the variable not only
in the scope of the function, but in the calling
269:56 - scope as well. So by passing in a pointer,
we have in fact manipulated that parameter
270:01 - that we passed in. Now, why would you want
to do this? Well, there's a couple of reasons.
270:05 - First of all, a lot of times our functions
do need to act on the parameters that are
270:09 - passed into them. And so passing in pointers
is really the only way to do that. The other
270:14 - reason is passing in a pointer is often much,
much more efficient than passing in a whole
270:19 - value. Because right now we're passing in
simple strings, and strings aren't that large
270:22 - and ghost, so passing in copies versus passing
in pointers is pretty much going to be the
270:26 - same in terms of performance. However, if
you're passing in a large data structure,
270:31 - then passing in the value of that data structure
is going to cause that entire data structure
270:35 - to be copied every single time. So in that
case, you might decide to pass in a pointer
270:40 - simply for a performance benefit. Now, you
do have to be a little careful when you're
270:44 - passing in pointers, because of course, you
can inadvertently change that value. And so
270:48 - you can cause some issues for yourself. Now,
just to remind you of something else that
270:52 - we talked about in the pointer discussion,
if you're working with maps or slices, then
270:57 - you don't really have this option, because
since those two types have internal pointers
271:00 - to their underlying data, then they're always
going to act like you're passing pointers
271:04 - in. So just be careful when you're using those
data structures. Because you can inadvertently
271:09 - change the data in your calling function,
when you're manipulating them within the calling
271:14 - function.
271:15 - The last thing that I want to talk about when
we're working with parameters are what are
271:18 - called variadic parameters. So if I drop in
this example, here, we can see an example
271:22 - of a variadic parameter. So in this case,
I've got a generic some function that I'm
271:26 - creating here, and I'm passing in the numbers
one through five. Now, I'm not receiving five
271:31 - variables here, instead, I've got one variable
here, and I've preceded its type with these
271:36 - three dots here. So what that's done is that's
told the go runtime to take in all of the
271:41 - last arguments that are passed in, and wrap
them up into a slice that has the name of
271:46 - the variable that we have here. So then inside
of the sum function, we're going to print
271:50 - out what that values object is just so we
can see that and then we're going to go ahead
271:54 - and add up all the values in there. So since
it's going to act like a slice, we can use
271:58 - a for loop and range over those values. And
then we're going to print out the result of
272:02 - that. So when we run this, we see that we
do in fact, have a slice is printed out, the
272:07 - sum is 15. So we got that result printed out
properly. And there's no problem at all. Now,
272:12 - when you're using a variadic parameter, you
can only have one and it has to be the last
272:17 - one. So if I, for example, want to have a
custom message string, I can pass that in,
272:22 - and then pass that in here and then replace
this. And this still works just fine. However,
272:28 - I couldn't, for example, put the message parameter
as the last parameter, because the runtime
272:34 - doesn't have the ability to understand where
the variadic parameters and and where additional
272:38 - parameters would begin. So if you're using
variadic parameters, you can only have one
272:42 - and a half to be at the end. Okay, now, it's
nice to be able to pass data into our function,
272:47 - because now depending on the different data
that I pass in, I can change the behavior
272:51 - of the function. But it's also very useful
to be able to use our functions to do some
272:56 - work, and then return a result back to the
calling function. So in order to do that,
273:00 - we're going to use what are called return
values. So if I dropped in this example, we
273:04 - see it's basically the same as our last example.
But instead of printing the message in the
273:08 - sum function, we're returning the result out.
And then the main function is actually working
273:13 - with that. So there's a change we had to make
in our function signature. So right here after
273:17 - the parameter list, and before the opening
curly brace, I've listed the return values
273:22 - type. So in this case, I'm expecting to return
an integer. So I just put it right here, inside
273:27 - of my function, I'm going to use the return
keyword. And then I'm going to return the
273:31 - value of the variable that I've been building
up throughout the course of the function.
273:35 - So in this case, I declare the result variable
here, I populated in this loop. And then I
273:39 - return that result back now up here in the
main function, I can catch that return value
273:44 - by declaring a variable and setting it equal
to the result of this function. So S is actually
273:49 - going to be an integer type, because that's
what was returned out of this function. And
273:53 - then I can work with that integer. So if I
run this, I get exactly the same behavior
273:57 - that I had before. But now the sum function
is more of a pure function, it doesn't care
274:01 - what I do with that result, it's just going
to generate the result and return it back
274:05 - to the caller. Now another feature that go
has that's actually pretty rare in a lot of
274:09 - languages, is the ability to return a local
variable as a pointer. So in our previous
274:14 - example, when we return that result, go actually
copied that result to another variable, and
274:20 - that's what got assigned. But we can also
do this. So if you look here, I'm returning
274:25 - a pointer to an integer now. And instead of
returning the result, I'm returning the address
274:29 - of the result. And so S is now a pointer.
So I change to a dereference operation. So
274:34 - if I run this, it works exactly the same way.
Now again, if you're coming from another language
274:39 - that uses pointers a lot and doesn't abstract
away the differences between working on the
274:44 - stack and working on the heap, then this might
freak you out a little bit, because when we
274:48 - declare the result variable, it's actually
declared on the execution stack of this function,
274:53 - which is just a special section of memory
that's set aside for all of the operations
274:57 - that this function is going to be working
with. So in this funk Exit, then execution
275:01 - stack is destroyed, that memory is freed up.
And so in a lot of languages, this is not
275:06 - a safe operation, because now you're returning
a pointer to a location in memory that just
275:10 - got freed. And so you've got no idea what
value is going to be there.
275:14 - Well, in the go language, when it recognizes
that you're returning a value that's generated
275:20 - on the local stack, it's automatically going
to promote this variable for you to be on
275:25 - the shared memory in the computer, what's
also called the heap memory. So you don't
275:29 - have to worry about this value being cleared,
the runtime is going to recognize that you're
275:32 - returning a pointer from the local stack,
and everything is going to work for you just
275:36 - fine. And that makes a lot of things more
convenient. Because within the function, we
275:40 - can work with this as a true value. So we
don't have to worry about dereferencing pointers,
275:44 - and then just right at the end, we can return
the address of the result. And the runtime
275:48 - makes it all work for us. Another thing that
we can do in the go language, and this isn't
275:52 - done very often, but there are cases where
it is valuable is using named return values.
275:57 - So if I drop in this example here, notice
that I've changed my return value. Now I've
276:02 - got a set of parenthesis here. And then I've
got a name for the return value and a type
276:07 - for it. So when you do this, this is basically
syntactic sugar for declaring a result variable.
276:12 - So this variable is going to be available
in the scope of our sum function. And then
276:16 - that value is going to be implicitly returned.
So we can work with that result variable right
276:20 - here within our function. And then we don't
have to specify the name of the return variable
276:24 - down here in line 17, we just have to tell
it to return. So when we run this, we see
276:29 - that once again, we get exactly the same behavior.
But the body of our sum function is actually
276:33 - quite a bit cleaner, because we don't have
to do the maintenance of instantiating, this
276:37 - result variable. Now, this is actually not
done very often in the go language. And my
276:42 - suspicion is because it can be a little bit
confusing to read, because your return variables
276:46 - are declared way up here at the top of the
function, and your actual return is down here
276:51 - at the bottom. So if you're reading this code,
and you're trying to figure out what this
276:54 - function is actually going to return, you
have to come all the way back up to the function
276:58 - signature. So this can be a very valuable
technique to use. But I would be very careful
277:03 - with it. Because if you've got long functions,
the named result parameters can actually be
277:07 - more confusing instead of less confusing.
So you have the option there, pick whichever
277:11 - one makes the most sense for your application.
The last thing that I want to talk about with
277:15 - return values is the fact that we can do multiple
return values from a function. So in order
277:20 - to show you why this is valuable, let's take
this example here. So I've created a simple
277:23 - divide function that takes in two parameters
A and B, that are float 64, it's going to
277:28 - divide them and it's going to return that
result back. So if I run this, I get 1.6 666.
277:33 - Like you might expect, and everything's fine.
But what happens if I pass in a zero here.
277:39 - Now when I run this, I get an unknown result,
I get a positive infinity result. And I can't
277:44 - work with that in my application. So I'm going
to probably cause some sort of a failure down
277:48 - the line. So in a lot of languages, the only
thing we could do is throw an exception or
277:52 - panic the application and go when we detect
that there's this invalid value for the parameter
277:57 - B. So I guess we could do that we could add
some kind of logic here. If b equals equals
278:02 - 0.0, then we're going to panic and we're going
to say, cannot provide zero as second value.
278:11 - And that would work. But keep in mind when
we talk about control flow and go, we don't
278:15 - want to panic our application as a general
course of action, because panicking means
278:19 - the application cannot continue. Now, in fact,
this application cannot continue if somebody
278:24 - provides the value of beat. But it's reasonable
to assume that we might pass zero in for this
278:29 - be parameter occasionally. So instead of doing
this, what we actually want to do is return
278:34 - an error back letting the calling function
know something that they asked it to do wasn't
278:40 - able to be done properly. So instead of doing
this, we're actually going to add a second
278:44 - return variable. So to do that, we're going
to add a print here. And we're going to return
278:48 - an object of type error, and then close that
parenthesis off. So we can return as many
278:52 - values as we want from a function. But this
is a very idiomatic way of using the go language.
278:57 - So we're going to return the intention of
the function as the first return value. And
279:01 - then we're going to return an error object
in case something went wrong. So in that case,
279:05 - what we're going to do is, we're going to
remove this panic, because we really don't
279:09 - want to be doing that. And we're going to
return the first value, we're just going to
279:14 - zero it out, because we can't do this operation,
so we can't return anything meaningful. And
279:18 - then we're going to return an error object.
Now you can generate one of those by using
279:22 - the air f function. And we can say cannot
divide by zero. So we're going to provide
279:28 - a value for that error. And then that's all
we need to do here. So since we've returned
279:32 - to this function in the error case, then if
we get past it, we can continue as if our
279:36 - parameters are okay. And so in that case,
we can actually do our operation. And then
279:43 - for the error value, we're going to pass nil
because no error was present. And again, this
279:47 - is very idiomatic go, we're going to return
an error value if something went wrong, and
279:51 - then we're going to explicitly return nil
if nothing went wrong. And then if you've
279:55 - read any amount of go code, you've seen this
quite a few times. We're going to check to
279:58 - see if that error also Got our standard if
error is not equal to nil, and then we're
280:03 - going to put our error handling logic in here.
So in this case, all we're going to do is
280:06 - print out the error and return from our main
function. So we're going to exit our application.
280:16 - If we don't have that, then we're going to
just print out the result of our calculation.
280:17 - So again, this is a very common pattern and
go inside of your functions that can generate
280:20 - errors, you're going to return the expected
value and then an error as the second parameter,
280:25 - then you're going to have a guard that's going
to check for those error conditions, you're
280:29 - going to return as soon as possible from your
function with the error value if an error
280:34 - is present. And the reason for that is we're
going to try and left justify our code as
280:38 - much as possible. So we don't end up with
these pyramids of doom, where we're going
280:41 - to have else checks. And we do all of our
error checking at the bottom, we're going
280:45 - to do our error checking at the beginning
and then return out as soon as possible. So
280:49 - if we do get past that, then we're going to
be on our happy path. And we're going to return
280:53 - out the result of a calculation and then a
nil error up in the calling function, we're
280:58 - going to have the standard test to see if
error is not equal to nil. If it isn't equal
281:02 - to nil, then we're going to process that error,
because now we've got something we're going
281:05 - to have to deal with. And then again, we don't
have an else block here, we just continue
281:10 - moving on, we're going to make sure our error
handling logic either recovers from the error
281:15 - or exits onto the function. And that way,
we can keep our main thread of execution left
281:19 - justified. So our main thread of execution
here is we're going to call this divide function,
281:23 - and then we're going to print out the result.
So any error handling should not force the
281:27 - main line of execution to be indented. So
now if we run this, we see that I forgot to
281:32 - initialize my error parameter. So let's go
ahead and add that. And this is something
281:36 - else I should talk about. When we're receiving
multiple values out of a function call, we
281:41 - actually have a common delimited list of those
return values. So this D parameter is going
281:46 - to match up to this float 64. And this eerr
parameter is going to match up to this error
281:50 - parameter here. So now if I run, everything
should work. And we see that we now get an
281:54 - error cannot divide by zero. So our main function
doesn't explode on us, we actually have something
281:59 - that we can work with. But if we put in a
valid value, then we're on that other path
282:03 - of execution, and we get the return value
back out. Now, so far, we've been treating
282:08 - functions as this special thing, because we're
always using this func keyword, we're declaring
282:13 - these at the top level of our application,
we're working with them. But functions and
282:17 - go are actually more powerful than that. Because
functions themselves can be treated as types,
282:22 - they can be passed around as variables, they
can be passed as arguments into functions,
282:26 - you can get them as return values, pretty
much anything you can do with any other type
282:29 - you can do with functions. So let's take a
look at that a little bit. So in this example,
282:33 - I'm actually declaring a function on the fly.
And this is called an anonymous function.
282:38 - Now we're going to continue to explore this
over the next couple of minutes. But this
282:40 - is the simplest example I can come up with.
So notice that I'm starting with the func
282:44 - keyword, I've got the params. For the parameters,
I've got the opening and closing curly brace,
282:49 - but I don't have the function name here. So
when you're doing this, this is what's called
282:52 - an anonymous function. And this is the basic
structure of a function when you're not working
282:57 - with functions in this traditional scope.
But instead you're working with functions
283:00 - as types. So inside of my function body, I'm
printing out the message Hello, go. And then
283:05 - I've got accompanying my closing curly brace,
these params here. Now these params here are
283:10 - basically going to invoke this function. So
this is an immediately invoked function, I'm
283:14 - defining it and executing it at exactly the
same time. So when I run this, and actually
283:19 - does execute that function, and we get the
value Hello, go printed out. If I don't have
283:24 - these friends, then the compiler is a little
confused. It doesn't know what to do with
283:28 - this function. It's just defined, but it's
never used anywhere. So fails a compilation
283:33 - check. But if I do invoke that function immediately,
then I get this behavior here. Now why would
283:38 - you use an anonymous function like this, I
actually have no idea why you would use an
283:42 - anonymous function like this. I mean, there
can be situations where you can declare variables
283:46 - inside of here. So if I declare a message
variable here, and I set that equal to this
283:52 - string, and then print that out, that can
be valuable because you're actually generating
283:56 - an isolated scope. So this message variable
is not going to be available in the main function
284:00 - is only going to be inside of this anonymous
function here. Now another place that you
284:05 - might use this is if we've got a for loop.
So if I start up a simple for loop, and I'll
284:09 - just count up to five, and increment by one,
let's see if I can do this on the fly here.
284:15 - And then I come in here and I actually print
the value of i out, I'll get rid of this message
284:20 - here and I'll print out I, you're going to
get a little bit of strange behavior. If I
284:23 - run this, this works, okay. But as we start
getting into asynchronous code, things are
284:27 - going to start behaving a little bit oddly.
So we do have access to this AI variable,
284:32 - because we're in the scope and the main function.
And so inner functions can actually take advantage
284:36 - of variables that are in the outer scope.
But the problem is, if this function is actually
284:41 - executing asynchronously, then this counter
variable is going to keep going. And we may
284:46 - actually have odd behavior here. So the best
practice is actually to provide a variable
284:51 - inside of here and actually pass that AI variable.
And what that's going to do is we're not going
284:55 - to be reading from the outer scope anymore.
We're going to be passing that into the function
285:00 - execute And that way, even if this is running
asynchronously, we're going to print out the
285:04 - value correctly. Now, this works correctly
in the playground, the way that we have this
285:08 - right now, because we actually aren't doing
anything asynchronously. This is all synchronous
285:12 - execution. And so we are safe to use this
outer counter. But it's not good practice
285:16 - to do that. Instead, it is best practice to
pass in that kind of variable. If you need
285:20 - that in your inner function. That way, changes
in the outer scope aren't reflected on the
285:24 - inner scope. Now taking this a little bit
farther, we can work with functions as variables,
285:29 - like I said before, so in this case, I've
declared an anonymous function, and I've assigned
285:34 - it to this variable F. And then I can execute
f by just invoking it like any other function.
285:38 - So if I call that, we see that we do print
hello, go out. So now that I've got this function
285:42 - defined as a variable, it's free to pass around
my application. Now, you might ask yourself,
285:47 - what is the signature for this function. So
let's go ahead and go through that. So if
285:51 - I get rid of the short syntax and extend this
out a little bit, then I'm going to start
285:55 - with the var keyword. And since this is a
very simple function, the type is just like
285:59 - this, we have the func keyword, and then an
open and close parenthesis. So the parameter
286:03 - is normally going here, I don't have any parameters
here, I don't have any return types. So the
286:07 - type signature for this variable is simply
func with two params. There. So if I run this,
286:12 - that works just fine. Now we can go a little
bit more complicated. And I'll drop an example
286:17 - of that in just to show you how that's going
to look. So in this case, I'm declaring a
286:21 - function signature for a divide function,
that's going to take in two floats, and it's
286:25 - going to return a float and an error. And
you see, this is the syntax for that. So we
286:29 - pass our parameter types in here. And then
we have the return types in params. As well,
286:34 - if you have just a single return type, then
you don't need these params, we could just
286:38 - put the type there like that. But we do have
that error type this coming back. So we do
286:42 - need to include that. And then when I initialize
that variable, I'm going to set it equal to
286:46 - an anonymous function that takes a and d.
And this is exactly the same divide function
286:50 - that we had before. And I can call that exactly
like we had before. So when I run this, it
286:55 - has exactly the same behavior as the last
example we did with the divide function. But
287:00 - now we have the divide function declared as
a variable. And we're working with it exactly
287:04 - the same way as when we declared it as a function.
Now, the difference between this and when
287:08 - we had the divide function declared globally,
is if I try and call it up here and run the
287:15 - application, notice that I get an error because
in this case, the function divide hasn't been
287:19 - declared yet, because it's declared as a variable.
And so I can't work with it yet. So that's
287:24 - just something to be aware of. If you're going
to be working with functions as variables
287:27 - like this, make sure that they're defined
before you actually try and execute them.
287:31 - Okay, the last thing that I want to talk about
with functions today is working with what
287:34 - are called methods. And there's a couple of
things to talk about with those. So let me
287:37 - just drop in an example that shows that. And
we can walk through this and then see what
287:41 - it's going to do. So in this example, I've
got a struct called greeter that greeter struct
287:46 - has two fields greeting and name. And then
I've got this method on it. And we'll come
287:50 - back to this in a second. So in my main function,
I'm declaring a greeter struct, and then I'm
287:55 - calling this function preceding it with the
struct that I have here. And this is how we're
288:00 - going to do method invocation. So we call
the method just like we were accessing a field,
288:04 - except for we have the params here where we
can pass some arguments in. Now my method
288:08 - declaration down here looks a lot like a function
except for it's got this odd bit right here.
288:14 - And this is what makes this function into
a method. So a method is basically just a
288:18 - function that's executing in unknown context,
and unknown context. And go is any type. Now
288:24 - it's very common that we can use structs.
But you can use any type. So we can make a
288:28 - type for an integer. So maybe we have a type
for an integer called counter. And then we
288:33 - can add methods on to that counter type, and
work with those. So when we declare that method,
288:39 - we're actually going to get access to that
type right here in this part. So what's going
288:42 - to happen when we call the greet method is
the greet method is going to get a copy of
288:46 - the greeter object. And that's going to be
given the name g in the context of this method.
288:51 - So then when we print out, we can access the
fields on that greeter object. So we can print
288:56 - out the greeting and the name. So when we
go ahead and run this, we see that we get
288:59 - Hello go printed out. And that's the basics
of a method. So methods are basically the
289:03 - same as functions, they just have this little
bit of syntactic sugar, that's providing a
289:07 - context that that function is executing in.
And when we do that, we call that a method.
289:12 - Now when we use this syntax right here, notice
that we're specifying greeter as a value type,
289:17 - we don't have a pointer here. So this is what's
called a value receiver. The received object
289:22 - in this greet method is the value greeter.
So what that means is just like any other
289:26 - time that we're working with values, we are
getting a copy of the struct, we're not actually
289:31 - going to get the struct itself. So if I change
the value of the Name field here, and then
289:35 - I print the Name field out of here, so I say
the new name is and then I print the Name
289:40 - field out, then it's no big surprise that
even though I assigned an empty string to
289:44 - the Name field here, up here in the main function,
it didn't have any effect. Because down here
289:47 - in this method, we're operating on a copy
of the greeter object. We're not operating
289:51 - on the greeter object itself. So again, that's
very valuable if you want your methods to
289:55 - be able to access the data of their parent
type without being able to manipulate Just
290:00 - keep in mind there is a cost with that. So
if there's greeter object was a very large
290:04 - struck, then we would be creating a copy of
that struct every time we invoke this method.
290:08 - Now, as you might expect, there's another
option that we have here. And that is to pass
290:12 - in what's called a pointer receiver. So if
we make this a pointer, and run the application,
290:17 - again, now we're actually able to manipulate
that underlying data. So we're going to print
290:22 - out Hello ghosts. So the method operates in
exactly the same way. And we don't have to
290:27 - change the format here, because we do have
that implicit dereferencing of pointers that's
290:31 - working for us. But now when I change the
value of the Name field, and print the Name
290:35 - field out up here, we do in fact, see that
we've been able to reassign the value of that
290:39 - field. Okay, so that covers working with functions
in the go language. Let's go into a summary
290:44 - and review what we've talked about. In this
video, we talked about functions and how to
290:48 - use them in the go language. And we started
out by talking about the basic syntax of a
290:52 - function, and we saw that this is about as
simple of a function as we can get. So we
290:56 - start with the func keyword, we have a name
for that function. And again, if that first
291:00 - letter is uppercase, then that function is
going to be published and allowed to be executed
291:03 - from outside of the package. But with a lowercase
first letter, it's going to be kept internal
291:08 - to the package, then we follow with a match
set of parenthesis, and then we have an open
291:12 - and closed curly brace. Now the open curly
brace has to be on the same line as the func
291:16 - keyword. And the closed curly brace has to
be on its own line after the final statement
291:20 - of the function, then we moved on to talk
about parameters and parameters allow us to
291:24 - pass data into the function to influence how
that function executes, basically providing
291:29 - some variables for the function that are passed
in from the outside. So we talked about how
291:34 - parameters are passed in as a common delimited
list of the name of the parameter and the
291:39 - type of the parameter. So we see here we're
passing into the Foo function, two parameters,
291:43 - the bar parameter that says type string, and
the bass parameter that's of type integer
291:48 - parameters of the same type can be comma delimited.
And the type can be listed at the end there.
291:52 - So in this case, we're passing in bar and
Babs as parameters. And both of those are
291:56 - going to be of type integer.
291:59 - When pointers are passed in the function contains
the value in the caller. So by default, we're
292:03 - going to be passing in the values themselves.
And so the go runtime is going to be copying
292:07 - that data and passing it into the function.
So any changes that are made inside of the
292:11 - function aren't going to be reflected in the
color scope. However, if you pass in a pointer,
292:16 - then you are going to be able to manipulate
the value inside of your function. And that
292:20 - will have an effect in the calling scope.
So the only exception to this rule is when
292:24 - you're working with slices and maps, since
they work with internal pointers, any changes
292:28 - inside of the function to the underlying data
is always going to be reflected inside of
292:32 - the calling scope. We also talked about how
you can use variadic parameters to send a
292:36 - list of the same types in, so it must be the
last parameter in the parameter list. It's
292:41 - received inside of the function as a slice.
And you see an example of the syntax right
292:46 - here. So we've got the function foo. It has
one parameter bar that's of type string, and
292:50 - then a parameter Baz, that's a very attic
parameter of integers. So inside of this food
292:56 - function, we're going to have a slice called
Baz. And that's going to contain all of the
292:59 - integers that have been passed in. Once your
function finishes doing its work, a lot of
293:04 - times we want it to return a value back out.
And in order to get that information back
293:07 - out, we're going to use return values. So
if you have a single return value, all you
293:12 - need to do is list the type. So in this case,
our foo function needs to return an integer,
293:16 - we can also specify multiple return values.
So if we're going to do that, we need to put
293:20 - parentheses around the types that we're going
to be returning. So in this example, we're
293:24 - going to be returning an integer and an error.
And this is a very common pattern that you're
293:28 - going to see in NGO applications where we're
going to have our functions return the intended
293:32 - value, and then an error value that's going
to let the caller know if anything went wrong.
293:37 - That way, the function itself doesn't have
to determine whether the application needs
293:41 - to panic, or execution can't continue. It
just knows it wasn't able to do what it was
293:45 - asked to do. And then it can delegate what
that error means to the application to the
293:50 - calling function, you can also use named return
values. So when you do that, instead of just
293:55 - providing the types in the return last, you're
going to provide the name of that return value.
293:59 - So when you do that, the runtime is going
to initialize that value for you to the zero
294:04 - value for that variable. And when you use
the return keyword, all you need to do is
294:08 - enter return on its own go is going to find
the current value of those returned variables.
294:13 - And that's what's going to be returned out
of your function. Another special behavior
294:17 - of go is you can actually return the addresses
and local variables as return values, and
294:22 - those are going to be treated properly. So
when you do that those variables are automatically
294:25 - promoted from local memory or stack memory
up into shared memory or heap memory. So you
294:30 - don't have to worry about those values being
cleared out as the function stack memory is
294:35 - reclaimed. We then started talking about anonymous
functions. And we talked about a couple of
294:40 - different uses for those. So we have this
immediately invoked function, which really
294:44 - isn't used too often in the go language, but
it's as simple of an anonymous function as
294:47 - I could get. The only potential advantage
that you have here is you can create an inner
294:51 - scope. So local variables that are created
inside of this anonymous function aren't going
294:55 - to be available outside, but I haven't seen
that very often. It's not going to be very
294:59 - often that you're going need to use this kind
of a function, then we also talked about how
295:03 - we can take that anonymous function and actually
assign that to a variable. So in this example,
295:07 - we've got the variable a assigned to the value
of that function. And then we can invoke the
295:12 - a function just like any other function. The
only difference between this and the normal
295:17 - declaration of a function is that the a function
can only be invoked after it's been declared.
295:23 - So when you declare a function using the traditional
syntax, it's actually declared at the time
295:28 - that the package is initialized. And so it's
always available to you. When you're using
295:32 - this syntax, you have to make sure that a
is initialized before you can call it extending
295:37 - on that discussion about the ability to assign
functions to variables, functions, or types,
295:41 - just like any other type in go language, anytime
you can use a primitive or a slice or an array
295:46 - or a map, you can use a function. So you can
assign them to variables, you can use them
295:50 - as arguments, they can even be returned values
from functions, then we also talked about
295:54 - how since a function is a type, we have to
have the ability to create a type signature.
295:58 - So if you're declaring anonymous functions,
it's often most convenient just to use that
296:02 - colon equals syntax and declare your anonymous
function and the type is going to be inferred.
296:06 - However, if you're using a function as a parameter
to another function, or the return value from
296:11 - a function, then you're going to need to specify
that type signature. So we see an example
296:15 - here. In this case, we've got the definition
of a function f. And that function is going
296:19 - to take three parameters, two strings, and
an integer. And then it's going to return
296:23 - an integer and an error type. So it's basically
the same as when you're declaring a function
296:27 - normally, the only difference is we don't
have the names for those variables. Because
296:32 - those names will be provided when we actually
implement the function, we just need to know
296:35 - the types that are coming in, and the types
that are coming out at this point. The last
296:39 - thing we talked about were methods, and how
method is a special type of function that
296:43 - executes in the context of a type. Now a type
doesn't have to be a struct. Although that
296:48 - definitely is a very common use case for methods,
you can actually attach a method to any custom
296:53 - type. So you can create a type of an integer,
and then you can add methods on to that integer.
296:58 - When we create a method, we're going to use
a modified version of the basic function syntax.
297:03 - So before the name of the function, and after
the func keyword, we're going to provide another
297:07 - set of parentheses, we're going to provide
a local name for the type that's going to
297:10 - receive that method. And then we're going
to follow that with that method type. Now,
297:14 - that variable is what's called the receiver
for the method. So in this case, our G variable
297:20 - is what's called a value receiver, which means
we're going to get a copy of that greeter
297:24 - object. And that's going to be passed into
the greet method. However, we can also use
297:28 - what are called pointer receivers. So by adding
an asterisk in front of that greeter type,
297:33 - the method is going to change. So instead
of passing a copy of the greeter, we're going
297:36 - to get a pointer to the greeter object in
there. And then any manipulations we make
297:40 - to the greeter object in the greet method
are going to be reflected throughout your
297:44 - application. Now, that's very powerful if
you need the method to be able to manipulate
297:47 - the state of the object. It's also much more
efficient if you're dealing with large structures,
297:53 - because instead of copying the entire structure,
it only has to copy a pointer. And that's
297:56 - normally a much more efficient operation,
I want to talk about one of the coolest features
298:00 - of the go language. And that is interfaces.
Now I know that interfaces are normally considered
298:05 - pretty humble features, and they sit in the
background. It's much more fun to talk about
298:09 - go routines and channels, especially when
you're learning to go language. But I would
298:14 - argue that the way interfaces are implemented
in the go language are potentially one of
298:19 - the reasons why go applications tend to be
as maintainable and scalable as they have
298:23 - proven to be. So we're going to start this
conversation like we start every conversation
298:28 - by introducing the basics. So we'll learn
what an interface is and how to use them in
298:32 - the language itself. Then we'll move on to
discuss how to compose interfaces together.
298:37 - Now, just like in other high level languages,
such as Java, or C sharp, we can actually
298:42 - make interfaces of interfaces. And we'll talk
about how to do that, and why that's a very
298:46 - good thing to do when you're writing your
applications. Then we'll talk about type conversion.
298:51 - Now, we've touched on this a little bit before
in a previous video. But when we talk about
298:55 - interfaces, things changed a little bit, and
it's worth revisiting the topic. Along the
299:00 - way, we're going to talk about the empty interface,
which is a very useful general construct that
299:04 - we're going to deal with in our programming.
We'll also revisit type switches, which we've
299:08 - talked about before, and we'll revisit them
in the context of our interface discussion.
299:13 - Then we'll talk about how to implement interfaces.
And there's actually two different ways that
299:17 - you can do that. One is by implementing with
value type, and one is by implementing with
299:22 - a pointer. And we'll talk about some of the
subtle differences that you're going to run
299:25 - into as you implement interfaces with these
two different types. And then finally, we're
299:30 - going to talk about some best practices that
have been discovered over the last few years
299:34 - of working with the go language about how
to use interfaces in your actual production
299:39 - applications. Okay, so let's get started by
learning the basics of using interfaces in
299:44 - go. So to start our discussion about interfaces,
I'm going to actually build our first application
299:49 - up a piece at a time now often I just drop
in code and talk about it. But I want to take
299:53 - this one step at a time so that we're working
together and understanding what's going on.
299:58 - So the first thing that we're going to do
is we're going to introduce our first interface.
300:02 - So interfaces are a type, just like structs
or type aliases. So we're going to start with
300:08 - the type keyword, then we're going to enter
the name of our interface. And then the type
300:12 - that we're creating is a type interface. And
then we're going to surround the definition
300:16 - of this interface with curly braces, just
like we do when we're defining a struct. Now
300:20 - with a struct, we would add in here, the data
that we want that struct to hold on to because
300:25 - structs are ultimately data containers. And
so that's how we work with them. interfaces
300:30 - don't describe data, interfaces describe behaviors.
So instead of entering a bunch of data types
300:37 - that we're going to be storing inside of a
writer interface here, we're actually going
300:40 - to be storing method definitions. So I want
to create a write method here. And this is
300:45 - actually an interface from the IO package,
we're just going to be working with it here
300:49 - as if we created it. But this is exactly the
same interface that you would find in the
300:54 - IO package under the writer interface. So
this method is going to accept a slice of
300:58 - bytes. And then it's going to return an integer
and an error. Now on the writer interface,
301:04 - the way this works is anything that implements
this interface is going to take in that slice
301:08 - of bytes, write it to something that something
might be the console, it might be a TCP connection,
301:14 - it might be the file system, we don't know,
we just know that we're writing a slice of
301:18 - bytes to something. And then the integer and
error that get returned, of course, the error
301:22 - is there in case something goes wrong with
the write operation. And the integer is normally
301:26 - the number of bytes written. So now that we
have the interface defined, let's go ahead
301:30 - and implement it. So we're going to implement
this with a console writer implementation,
301:34 - and that'll be a struct. And that's all we
need to do with the struct definition. Now,
301:39 - if you come from another language, you might
be looking for an implements keyword or something
301:44 - like that. Well, in go, we don't actually
explicitly implement interfaces, we're going
301:49 - to implicitly implement the interface. And
we're going to do that by actually creating
301:54 - a method on our console writer that has the
signature of a writer interface. So let me
302:00 - just drop that in. Because if I try and type
all this out, I will screw it up, and then
302:04 - I'll have bugs that I have to go through.
So it's much easier just to drop it in. But
302:08 - notice what I've done here, I've got a method
on my console writer called write. So it's
302:11 - got the same name as my writer interface,
it's accepting a slice of bytes, and it's
302:16 - returning an integer and an error. Now the
implementation is whatever I want it to be.
302:20 - Now, in this case, all I'm going to do is
convert that byte slice into a string and
302:24 - printed onto the console to keep things easy
in the playground. But I can have my writer
302:29 - do whatever I want.
302:31 - So what's the value of doing this? Well, the
value of doing this is up in my main method,
302:36 - I can actually create a variable that's of
type writer. And let me just drop that code
302:42 - in and format it and set that equal to a console
writer instance. So the W variable here is
302:49 - holding a writer, which is something that
implements the writer interface. I don't actually
302:53 - know the concrete type, though. So when I
call the write method down here on line nine,
302:58 - I know how to call that because that's defined
by the interface. But I don't actually know
303:03 - in my main function, what's being written
to, that's the responsibility of the actual
303:08 - implementation. So I could replace this with
a TCP writer, I could replace it with a file
303:14 - writer, I could replace it with any other
kind of writer. And so I get what's called
303:18 - a polymorphic behavior. Why nine doesn't care
what it's writing to, I specify that behavior
303:25 - before that. But then anything that's going
to use this w object just knows that it can
303:30 - write to it. And so it can take advantage
of that behavior. So if I go ahead and run
303:34 - this application, you see that I do get a
logo printed out to the console, just like
303:39 - I would expect. So the key takeaway here as
we're learning the basics of interfaces, is
303:44 - this concept of implicit implementation. And
so what that means, for example, is if you
303:50 - need to wrap a concrete type, and somebody
hasn't published an interface, you can actually
303:55 - create an interface that their type implements.
So we did it the other way, we created an
304:00 - interface, and then we created a concrete
type that implemented it. But there's nothing
304:04 - to say we can't go the other way around. We
could, for example, go to if I travel to go
304:10 - lang.org, and go into packages, this is actually
something that I just ran into, in order to
304:16 - test SQL database connections. So if I come
down to the database package, and go into
304:22 - the SQL package, if we look at this, notice
that the DB type is a struct. So we don't
304:27 - have an interface here. So if our go application
is talking to a SQL database, we've got concrete
304:33 - types all over the place. So for our transactions,
we're interacting with this DB object. everything
304:38 - that we're doing sending SQL statements making
queries are all through this concrete DB object.
304:43 - So how do I test that without a database?
Well, the way that you test that without a
304:48 - database is you actually create an interface
that replicates this method signature, and
304:53 - the DB object from the SQL package will automatically
implement it, so I don't have to worry about
304:59 - creating inner phases at design time if I
don't need them myself, because consumers
305:04 - of my library or whatever I'm creating can
always create interfaces later. And their
305:09 - interfaces can be shaped to exactly what they
need for their application. Now another thing
305:14 - that I want to talk about before I move on
here is a naming convention. Now obviously,
305:18 - the name of the interface should represent
what that interface is going to be doing for
305:22 - you. And there is one special case, if you've
got single method interfaces, which are very
305:27 - common in the go language, then the convention
is to name the interface with the method name
305:32 - plus er. So if we're defining an interface,
like we have here with the right method, then
305:37 - the interface name should be writer, if we're
going to create an interface with a read method
305:41 - on it, then the interface name should be a
reader. Now if you got more than one method
305:45 - in the interface, things can get a little
bit more challenging. But at the end of the
305:49 - day, you should name your interface by what
it does. And in the case of a single method
305:53 - interface, just add er onto the end of the
method name. Okay, now, in this example, we
305:58 - use the struct, which is probably one of the
most common ways to implement interfaces,
306:02 - but you don't need to any type that can have
a method associated with it can implement
306:06 - an interface. And as we've talked about before,
any type can have methods associated with
306:11 - it. So in order to demonstrate that, let me
just drop in this example here. Now in line
306:16 - 16, through 18, I've defined a new interface
called incrementer. And that increment is
306:20 - going to be a method that only returns an
integer, so it's going to increment something.
306:25 - So whatever we're going to implement this
thing with, is going to increment values.
306:30 - So down here on line 20, I defined the type
alias for an integer called an int counter.
306:36 - And then I added a method to that custom type
on lines 22 through 25. And that's going to
306:41 - be my implementation for the incrementer interface.
So the method name is called increment, and
306:47 - it's going to return an integer. Now, in this
case, look at what I'm doing, I'm actually
306:51 - incrementing. The type itself, since I've
got a type alias for an integer, it's a number,
306:56 - so I can go ahead and increment that. And
then I'm going to return it as the result
307:00 - of this method call.
307:01 - So I've actually got a type defined on an
integer, and the integer itself is storing
307:06 - the data that the method is using. So up here
in my main function, I'm going to go ahead
307:11 - and create that integer counter. And I have
to cast an integer to an encounter. In order
307:15 - to do that. That's what I'm doing here on
line eight. And then I create my incrementer
307:20 - and assign that to a pointer of the my ns
object. And we'll talk about why that has
307:24 - to be a pointer toward the end of this video.
And then I'm just going to loop from zero
307:28 - to nine. And I'm going to print out the value
of the increment method every time I call
307:31 - it. So if I go ahead and run this, I see no
big surprise, I get the values one through
307:36 - 10 printed out. So what's the takeaway here?
Well, you don't have to use structs. To implement
307:41 - interfaces, you can use any kind of custom
type. Now I couldn't add a method directly
307:45 - to the entity type. Because the event type
isn't under my control that's defined in another
307:50 - package. It's a matter of fact, that's a primitive
type, and you can't modify it. But any type
307:54 - that I do have control over that I can create,
I can add methods to it. And if I can add
307:59 - methods to it, I can implement interfaces
with it. Now the next thing that I want to
308:03 - talk about is how to compose interfaces together.
Because this is another very powerful concept
308:08 - in the go language, and is one of the keys
to scalability, because if you remember I
308:12 - mentioned a little while ago, single method
interfaces are very common and very powerful
308:17 - in the language, because they define a very
specific behavior. But by having a single
308:22 - method, they don't have a lot of opinions.
And so they can be implemented in a lot of
308:26 - ways. So for example, the IO dot writer interface
is one of the most common interfaces in the
308:32 - entire go language, because all it does is
talk about how to write two things. And we
308:37 - write two things all the time. So by taking
as little opinion as possible, we actually
308:42 - make the interface very, very powerful and
very, very useful. So let me go ahead and
308:46 - paste this example here. Because what happens
if we need more than one method, but we can
308:51 - decompose the interfaces down. So in this
case, I've created an interface that's composed
308:56 - of other interfaces. So I've got my writer
interface that we started the video with.
309:01 - And then I've added this closer interface
that just has
309:04 - a closed method on it, and returns an error
just in case something happened when we tried
309:08 - to call this method. Now the writer closer
interface is actually composed of the writer
309:14 - interface and the closer interface. And this
is done exactly the same way that you do embedding
309:19 - with structs. We're just embedding interfaces
within other interfaces. So the writer closer
309:25 - is going to be implemented. If an object has
this method on it, and this method on it,
309:31 - then we can treat that as a writer closer.
So as an example, I've created this struct
309:36 - here, a buffered writer closer. Now, I'm not
saying that this is an efficient way of doing
309:41 - things. This is just an example of how you
might use this writer closer interface in
309:45 - a way that runs in the playground easily.
So in this case, I've got my write method
309:49 - that I'm going to be implementing. And what
I decided to do is I'm going to write out
309:53 - whatever gets sent into the buffered writer
closer. I'm going to print that out to the
309:58 - console in eight increments. So that's what
all this code is doing, when you pass data
310:04 - into the write method, it's going to store
that in this internal buffer that the structure
310:09 - defines. And then as long as the buffer has
more than eight characters, it's going to
310:14 - go ahead and write that out. But it won't
write anything out if it's got less than eight
310:18 - characters. So we're basically buffering the
data that we're sending in. And then down
310:22 - here in the close method, I've got to implement
that too. And so what we're gonna do there
310:26 - is we're going to flush the rest of the buffer.
So I'm pulling the next eight characters out.
310:30 - And I'm going to write that out to the console.
And keep doing that until the buffer is empty.
310:35 - Okay, up here in the main method, I simply
create a writer closer variable, and define
310:40 - that using the new buffered writer closer
function. And just to show you that I didn't
310:45 - talk about it, that's down here at the bottom,
that's just a constructor function that's
310:49 - returning a pointer to a buffered writer closer.
And I need to do that because I need to initialize
310:54 - this internal buffer to a new buffer. So I
have a constructor method there just to make
310:59 - sure that everything has been initialized
properly. So if I come back up to the main
311:02 - function, and look at that, then I'm going
to call the right method. And I'm converting
311:07 - the string hello youtube listeners, this is
a test over to a byte slice, because that's
311:11 - what the right method expects. And then I'm
going to call the close method. So if I go
311:15 - ahead and run this, you see that I get the
message printed out to the console in eight
311:19 - character chunks. And eventually I get all
this printed out. But if I comment out this
311:25 - last method, call here, you see that I don't
get the a test part of the string, because
311:31 - that's actually a partial. And so we didn't
get that full eight characters that's required
311:35 - for the right method to print it out. And
so I didn't actually flush the buffer. Okay.
311:40 - So I know that maybe a little bit of a complicated
example, to show a fairly simple thing. But
311:45 - I just wanted to show you this is how you
can compose interfaces together. And as long
311:49 - as you implement all of the methods on the
embedded interfaces, then you actually implement
311:53 - the composed interface as well. The next example
that I want to talk about is how we can do
311:58 - type conversion. So I'm going to go ahead
and replace my main function here with this
312:02 - code here, get rid of the extra curly brace,
actually, I'm going to get rid of this too,
312:06 - I guess I pulled in the whole function signature.
And then I made a little bit of a change down
312:11 - here in line 13. So lines nine through 11
are our original implementation, where we're
312:17 - creating the new buffered writer closer or
writing a string out, and then we're calling
312:21 - the close method on it. But on line 13, I'm
actually doing a type conversion. So using
312:27 - this syntax here, where I've got an object,
dot, and then in parentheses, I've got a type
312:32 - that I'm going to try and convert this variable
to. And then I can assign that to a variable
312:36 - such as this PwC variable right here. Now,
if that succeeds, then everything's fine.
312:42 - And I can go ahead and work with it. Now,
there's nothing useful I can do with this.
312:45 - But I'm just printing out the variable, because
I have to use the variables and go. So I'm
312:49 - just going to go ahead and print that out.
So if I run this, I see I get exactly the
312:52 - same output I had before. But now I get the
memory address of this buffered writer closer,
312:57 - so that tape conversion succeeded. And therefore
I can work with this no longer as a writer
313:02 - closer, but as a buffered writer closer. So
for example, if I needed to access the buffer
313:06 - directly, then I would be able to do that
now. Whereas with the writer closer, it's
313:10 - not aware of the internal fields of a specific
implementation. And so I wouldn't have access
313:15 - to that data. Now there is a problem. However,
if I import the IO package, and try and convert
313:21 - this to a type that it doesn't implement.
So for example, if I try and convert this
313:24 - over to an IO reader, which is another interface,
and that IO reader interface requires a read
313:30 - method on it. So if I try that now, let's
go ahead and run that. And we see here we
313:34 - put the application into a state that it can't
manage. And so what it does is whatever good
313:39 - go program does, when it can't figure out
what to do it panics. And the panic messages
313:43 - interface conversion, it can't figure out
how to cast a buffered writer closer into
313:47 - an IO reader. And so it's going to fail on
us. Now, it does give us some useful information
313:52 - about why it couldn't do that. It says it's
missing a method read. And then it's gonna
313:56 - give us a stack trace letting us know where
that error occurred. Now, this isn't really
314:00 - great, because sometimes we need to try and
convert an interface into something else.
314:05 - And we're not sure if it's going to work or
not. So it's not going to be good for our
314:08 - application to be panicking all the time,
because then we're going to have recovers
314:11 - and we're going to be using that as a primary
control flow concept. And we want to avoid
314:15 - that in the go language, because panicking
is pretty expensive. So we need another way
314:19 - around it. Well, we just so happen have another
way around it. And so I'm going to show you
314:24 - that. All we need to do let me rename this
variable, because PwC doesn't make sense for
314:28 - a reader anymore. I'm going to paste this
code in. So I'm going to now try and cast
314:33 - it to a variable called R. I'm going to do
the same type conversion, but now I'm using
314:37 - this comma, okay, syntax. So we've seen this
before, when we were trying to pull a value
314:41 - out of a map and we weren't sure if it was
there or not. Well, we have the same ability
314:45 - with type conversion. If we add a comma, okay,
this is going to be a Boolean result. And
314:50 - then we can test against that to see if we
can work with it. So if the conversion succeeds,
314:55 - then we're going to get an okay value back
out. If the conversion fails, then we're Going
315:00 - to get the zero value of whatever type we
were trying to convert to. So an IO reader
315:04 - is an interface. And so it's zero value is
going to be nil. So if we go ahead and run
315:08 - this now, we see that our conversion failed,
but our application didn't crash. If we switch
315:14 - this back to a pointer to a buffered writer
closer, let me go ahead and drop that in.
315:20 - And we run that we got to drop out our package
here that we're no longer using. And then
315:25 - we see that we're back to having things successfully
converted. And we could work with that however
315:29 - we needed to. So this is really important
to be aware of, especially if you're not sure
315:34 - if you're going to get a pointer or a value
type. So for example, it would be really easy
315:38 - to write this and have a problem because we
implemented the interface with a pointer,
315:43 - not with the value itself. And so we can't
actually do the conversion to the underlying
315:47 - value type. So let's go ahead and run this
again, we see that that all works. And one
315:51 - more thing I want to show you let me just
pull this error back up again, you'll notice
315:55 - that the reason this type assertion failed
is because buffered writer closer does not
316:00 - implement writer closer now that might seem
a little strange to you, because our buffered
316:04 - writer closer has a write method, and it has
a closed method, and they have the right signature.
316:09 - So for some reason this works when I asked
it to convert it to a pointer, but it doesn't
316:14 - work when I asked it to convert it to the
underlying value. Now we'll come back in just
316:18 - a second and talk about why that happens.
But I want to finish our discussion of type
316:22 - conversions first. So stay tuned, and we'll
talk about why that works the way it does.
316:26 - So the next thing that I want to talk about
is something called the empty interface. Now
316:30 - the empty interface is exactly that. It's
an interface that has no methods on it. And
316:35 - we describe that using this syntax here. Now,
this isn't a special symbol, this is just
316:39 - an interface that we're defining on the fly,
and we don't have any methods on it. So it's
316:43 - called the empty interface. But there's nothing
special about it, we could create this as
316:47 - the empty interface exactly the same way by
just deleting the method out. And that's an
316:51 - empty interface now, so you see it like this
all the time. Just be aware, there's nothing
316:55 - special about this, it's just an interface
to find on the fly that has no methods on
316:59 - it. Now the nice thing about the empty interface
is everything can be cast into an object that
317:05 - has no methods on it even primitives because,
well, an integer has no methods. And so it
317:10 - can be cast to the empty interface. And so
this can be very useful in situations where
317:15 - you've got multiple things that you need to
be working with. But they aren't tight compatible
317:20 - with one another. And you need to apply some
logic later to figure out exactly what you
317:24 - received. But we do have a problem with the
empty interface. Because we now have this
317:28 - my object variable that's defined as an empty
interface, we can't actually do anything with
317:34 - it, because my object has no methods that
it exposes because it's an empty interface.
317:39 - So in order to do anything useful with a variable
that has the type of an empty interface, you're
317:43 - going to need to do either type conversion,
or you're going to need to start using the
317:47 - reflect package in order to figure out what
kind of an object you're dealing with. So
317:52 - in this case, on line 10, I'm actually trying
to type cast into a writer closer, and I'm
317:56 - using the comma okay syntax to see if that
worked. If it does, then go ahead and call
318:00 - the write and close methods like I saw before.
And then I've got this other type conversion
318:04 - that I've done that before just to keep things
consistent. So if I run this, we see that
318:09 - I forgot to re import the IO package, let
me go ahead and pull that back in.
318:15 - And we see that everything works as normal.
So the empty interface is very common. But
318:19 - just keep in mind, it's almost always going
to be an intermediate step. And you're going
318:23 - to define a variable of the type empty interface.
And then you're gonna have to figure out exactly
318:28 - what you receive before you can do anything
useful with it. The last thing that I want
318:32 - to talk about in the context of type conversions
are type switches. So I want to revisit that
318:37 - conversation from a few videos ago. And just
to show you, we can do something like this.
318:42 - So in line eight, I've got a variable i that's
defined as the empty interface, and I'm setting
318:46 - it equal to the integer zero. And then I'm
going to use this switch block here, and I'm
318:50 - going to use this syntax. So I've got my variable
name I, and then I'm going to use this dot
318:56 - and inside of prims, I'm going to put type.
And so what this is called is this is called
319:01 - a type switch. So each of the cases in this
type of switch are actually going to be a
319:06 - data type. So in this case, I'm looking to
see if I've got an integer or a string, or
319:11 - I've got a default case, which is going to
be handled by our application, just saying
319:14 - it doesn't know what AI is. So let's go ahead
and run this, I properly identify as an integer.
319:21 - So we execute this case here. If I put params
around this, then of course, I is now going
319:26 - to contain a string. And so if I run that,
again, it identifies it as a string. And if
319:31 - I change this, once again, maybe we can make
this a Boolean, gotta spell true correctly,
319:36 - and run that then it has no idea what it is.
So this is commonly paired with the empty
319:41 - interface in order to list out the types that
you're expecting to receive. And then you
319:46 - would add in the logic of how to process those
different types. Now, I promised you that
319:51 - we would come back and talk about that weird
type conversion behavior, where we could convert
319:56 - our writer closer into a pointer to a buffered
writer closer but Couldn't convert it into
320:01 - the value itself. So now I want to go through
and have that conversation about why that
320:05 - happened. So let me just drop this code in.
This is a much simpler implementation than
320:09 - what we had before. I've actually not really
implemented these methods anymore, in order
320:13 - to keep things as clean as possible for you
to see. So all I'm doing is I'm going to create
320:17 - a my writer closer, and that's down here as
my writer closer struct with nil implementations
320:22 - for the methods. But I do have the methods
implemented. So I can create this object as
320:27 - a writer closer, and then I'm just printing
out the value of the variable just so we have
320:32 - some use for that variable. So the go runtime
will actually compile and run this, and the
320:37 - interface for the writer closers to find exactly
the way we had before. So if I run this, everything
320:41 - works out just fine. However, what happens
if I change the receiver of one of these methods
320:46 - to a pointer? Well, if I run this, now, I
get an error. And the reason that I get that
320:51 - error is it can no longer convert my writer
closer into a writer closer interface. And
320:58 - it gives us an interesting message here, it
says my writer closer does not implement writer
321:02 - closer, the right method has a pointer receiver.
And this is the key to understand what happened
321:09 - with this. So when we define types, and we
assign methods to them, each one of those
321:14 - types has what's called a method set. Now
when you're working with the types directly,
321:18 - the method set is all of the methods regardless
of the receiver types associated with that
321:24 - type. With interfaces, however, things change
a little bit when I implement an interface
321:30 - with the concrete value. So notice here I'm
creating my writer closer, I'm not taking
321:34 - the address of my writer closer, I'm using
my writer closer directly. So WC is defined
321:41 - as holding the value my writer closer. So
the method set for a value when we're talking
321:47 - in the context of an interface is any method
that has a value as the receiver. So the reason
321:53 - we're not implementing writer closer is because
a write method no longer has a value receiver,
321:59 - it's going to point a receiver. And so its
method set is incomplete. And now we can fix
322:03 - this by using the address of operator and
running again. And notice now everything works.
322:09 - And the reason for that is the method set
for a pointer is the sum of all of the value
322:15 - receiver methods, and all of the pointer receiver
methods. So let's go through that. Again,
322:20 - when I'm implementing an interface, if I use
a value type, the methods that implement the
322:26 - interface have to all have value receivers.
If I'm implementing the interface with a pointer,
322:33 - then I just have to have the methods there,
regardless of the receiver type. So the method
322:37 - set for a value type is the set of all methods
that have value receivers. But the method
322:42 - set for a pointer type is all of the methods
with value receivers, as well as all of the
322:47 - methods with pointer receivers. So there's
a couple of ways that we could fix this. Now
322:51 - in this case, we don't need access to the
underlying data. So we could just go back
322:55 - to a value receiver. And then this is going
to work just fine. This is actually the initial
322:59 - example we had. If we have one method that's
going to appoint a receiver, however, we're
323:04 - going to need to switch that over to a pointer
type. And notice I can actually remove this.
323:09 - And it continues to work. Or I can make both
of these pointer receivers. And this continues
323:15 - to work as well. So this is an important concept
when you're implementing your own interfaces.
323:20 - If any of the methods require a pointer receiver,
you're going to have to implement that interface
323:24 - with a pointer. If not, though, if all of
the methods except value types, then you can
323:30 - go ahead and use a value type if that's what
you want. But you could also use a pointer.
323:34 - Okay, the last thing that I want to talk about
are some best practices when using interfaces
323:39 - in your own go applications. So let's take
a look at those. Okay, when we're working
323:44 - with interfaces, there's a couple of rules
and guidelines that I'd like you to keep in
323:47 - mind. And these have been developed over the
last few years by the NGO community, and are
323:53 - generally accepted as some of the best ways
to use interfaces, if it's practical in your
323:57 - applications. The first is prefer many small
interfaces versus large monolithic ones. Now,
324:04 - if you need large, monolithic ones, that's
fine, go ahead and compose smaller interfaces
324:08 - together to make those but the smaller you
can make your interfaces, the more useful
324:12 - and powerful they're going to be. And that's
not actually unique to go. No matter what
324:16 - language you're working in interfaces there.
They're generally having many smaller interfaces
324:22 - is preferable in the long run to having a
few monolithic ones. Now, some examples that
324:27 - are in the go standard library are the IO
dot writer interface, the IO dot reader interface
324:32 - in the empty interface. Now these are arguably
three of the most powerful interfaces in the
324:37 - entire language. And if you think about it,
writer has one method reader has one method
324:42 - and the empty interface has zero methods.
So it's interesting support to the argument
324:46 - that smaller interfaces are better that some
of the most powerful interfaces in the language
324:51 - contain one or zero methods on them. Now when
you're working with interfaces, if you're
324:56 - coming from a language that has explicitly
implemented interfaces, You're going to be
325:00 - very tempted to create interfaces and export
those. So here's the guidance for that if
325:07 - you don't need to export the interface yourself,
so if you don't have any particular reason
325:12 - to do it, go ahead and don't. So there are
some good examples of why you would want to
325:16 - do that. But often, it's perfectly acceptable
to export the concrete type.
325:22 - I'll take as an example, the database slash
SQL package that we looked at earlier in the
325:26 - video, where we saw that the DB object was
exported as a concrete struct. And it had
325:32 - all sorts of methods that pointed to other
concrete structs. So you can't directly mock
325:37 - that out for testing right out of the box.
However, by not exporting an interface, it
325:44 - allows you as the consumer of that struct
to define your own interface that you can
325:49 - use for testing. And the beauty of that is,
if you don't use every method on the DB object,
325:54 - your interface doesn't have to have every
method on it, you can just expose the methods
325:59 - that you need, however, do export interfaces
for types that you will be using. So if you're
326:04 - going to pull a value in, go ahead and accept
an interface instead of a concrete type, if
326:10 - at all possible. So this is going to be almost
exactly backwards from how other languages
326:15 - consider interfaces. And the reason is that
whole idea about implicitly implementing interfaces
326:21 - instead of explicitly doing it. So if you
were working in Java or C sharp, you could
326:26 - not do this, because you have to define the
interface before you implement the interface,
326:31 - because they're explicitly implemented. But
since go has implicit implementation, you
326:36 - can go ahead and defer the creation of the
interfaces until exactly when you need them.
326:40 - So if you're creating a library that other
people are going to consume, you can define
326:44 - the interfaces that you accept. And then they
can provide whatever implementations that
326:49 - they want. Now, if your library has reasonable
defaults, then you could export those concrete
326:54 - types as well. But make sure that you're accepting
interfaces whenever possible. And that's what
326:59 - this third point is talking about. design
your functions and methods to receive interfaces
327:04 - whenever possible. Now, that's not always
possible. If you need access to the underlying
327:08 - data fields, then certainly taking the concrete
types. But if you're accepting behavior providers,
327:14 - then go ahead and try and accept those as
interface types instead of the concrete types.
327:19 - Okay, so that covers what I want to talk about
with interfaces. today. Let's go into a summary
327:25 - and review what we've talked about. In this
video, we've talked about interfaces and how
327:30 - to use them in the go language, we started
with a discussion of the basics of interfaces,
327:34 - so how to create them and how to implement
them. And we ended up with code that looks
327:37 - something like this. So we're defining an
interface as a type. So we're going to start
327:41 - with the type keyword, the name of the interface,
and then the keyword interface. And then inside
327:45 - of curly braces, things are going to be a
little bit different than if we were defining
327:49 - a struct. For example, if we were defining
a struct, we would put data fields inside
327:52 - of the curly braces, because we're defining
the data that that structure is holding. With
327:57 - interfaces. we're defining behaviors, however,
so instead of adding data fields, we're gonna
328:02 - add method signatures. So we see here on this
example, we're going to define a write method
328:06 - that accepts a slice of bytes, and returns
an integer and an error. And then we implement
328:12 - that interface by creating a method on our
type that has the same signature. So we don't
328:18 - have to explicitly state that we're implementing
the interface, we implement the interface
328:22 - by implementing the interface by having the
methods there that match the type signature
328:27 - for the interfaces methods, then we talked
about how to compose interfaces together,
328:32 - and how this is a preferable approach versus
creating a single monolithic interface, if
328:37 - you can break that interface down into smaller
types, and then compose them together. And
328:43 - we did that something like this. So we're
going to create multiple interfaces. So we
328:47 - have a writer interface and a closer interface.
And then when we compose them together, just
328:51 - like when we compose structs, by embedding,
we can embed interfaces into one another.
328:57 - So we can create a writer closer interface
that embeds the writer interface and the closer
329:01 - interface. So to implement that writer closer
interface, you have to implement the right
329:06 - method, because it's defined by the writer
interface. And you have to implement the closed
329:10 - method as as defined by the closer interface.
So by doing this, you can actually pass smaller
329:14 - chunks of your interface around your application.
So for example, if a method only needs a writer,
329:20 - it doesn't need a closer, then you can actually
pass this writer closer as a writer, and it
329:25 - worked just fine versus passing the entire
writer closer along, and potentially exposing
329:30 - methods to the consumer that aren't really
necessary. Then we talked about type conversion
329:36 - and how we can drill through the interface
to get at the underlying types in case we
329:40 - need to work with those directly. So we had
an example here, where we created a writer
329:45 - closure instance, and the underlying type
was a pointer to a buffered writer closer,
329:50 - and how we could cast that back to a pointer
to a buffered writer closer by using this
329:54 - syntax here, where we have a dot after the
object and then inside of print, we put the
329:59 - type We want to cast to
330:01 - know, we learned
330:02 - that when we did this, if the type assertion
failed, then we're actually going to panic
330:05 - or application. So remember to use that comma,
okay syntax, if you want to get a boolean
330:11 - variable out that you can run tests against
to see if that type conversion succeeded.
330:17 - And then we talked about the empty interface
and type switches. The empty interface is
330:20 - nothing magic, it's just an interface to find
on the fly that has no methods on it. Now,
330:25 - it's special in that every type in go implements
the empty interface. So you can store anything
330:31 - you want in a variable of type empty interface.
And then very often, we're going to pair that
330:37 - with what's called a type switch. And we see
an example of that here, where we're going
330:41 - to use the switch keyword, we're going to
have the object and then dot and params, like
330:45 - we do with a type assertion. But instead of
having a concrete type that we're asserting
330:49 - against, we put the keyword type in there.
And then in our case statements, we're actually
330:54 - going to put in the data type that we're asserting
against. So in this case, we're looking for
330:58 - integers or strings, or we have a default
case, in case the value stored in i is neither
331:03 - an integer nor a string. After that, we talked
about implementing with values versus pointers.
331:08 - And we learned about a concept called method
sets. Now, when you're working with types
331:12 - directly, you never have to think about this
because the methods are always all of the
331:16 - methods assigned to that type. But with interfaces,
the rules change a little bit. The method
331:21 - set of a value is all of the methods with
value receivers. So if you're going to try
331:25 - and implement an interface with a value type,
than all of the methods that implement that
331:31 - interface, have to have value receivers. With
pointers, things are a little bit more flexible,
331:37 - because pointers always have access to the
underlying tape as well. The method sets for
331:41 - a pointer is all of the methods regardless
of the receiver type, so all of the value
331:46 - receivers, as well as all of the pointer receivers.
So pointer types are definitely more flexible
331:51 - when you're implementing interfaces. Just
keep in mind, you don't want to assign pointer
331:55 - receivers everywhere without thinking about
the idea that that gives access to the underlying
332:00 - data of that type. And so that can allow methods
to alter that underlying data, even if you
332:05 - don't want them to. So be careful when you
make that choice about using pointer receivers
332:09 - or value receivers. The last thing that we
talked about were some best practices that
332:14 - have evolved over the last few years about
using interfaces in the go language. And we
332:19 - talked about use many smaller interfaces whenever
possible. And then if you need larger interfaces,
332:24 - go ahead and compose those together with interface
composition. Don't export interfaces for types
332:29 - that will be consumed. So if you're creating
a library, and somebody else is going to be
332:34 - consuming a type, go ahead and publish that
concrete type out there don't create an interface,
332:39 - assuming you know how people are going to
use it, allow them to create the interfaces
332:43 - that your type will implement. That way, they
don't have to implement a whole bunch of methods
332:47 - in their test suite that they never even use.
Do export interfaces for types that you will
332:53 - be consuming however. So again, these two
points are exactly opposite of how you're
332:57 - going to think about interfaces, if you're
coming from another language, such as C sharp
333:02 - or Java, that have explicit implementation
of interfaces. So when you're defining a type
333:07 - that you're going to be consuming in your
package, then go ahead and export interfaces.
333:11 - That way whoever's using your package can
create their own concrete types, and implement
333:17 - the interfaces that you need. So you don't
need to worry about the implementation, you
333:21 - just need to worry about the behaviors that
they're exposing to you. And then, if possible,
333:25 - define your functions and methods to receive
interfaces. Don't get too crazy with this.
333:30 - So don't go over the top. Use common sense
with this. But if you have the option of receiving
333:35 - interfaces, for example, if you don't need
access to the underlying data, then go ahead
333:39 - and define an interface that you're going
to be receiving. That way it makes your methods
333:44 - and functions more flexible. Since you can
have multiple implementations that you never
333:48 - thought about at design time. And your functions
and methods will continue to work. Even when
333:53 - those new concepts are thrown at your application,
I want to have a conversation about the tools
333:58 - that we have available to implement concurrent
and parallel programming in the go language.
334:03 - Now,
334:04 - if you come this far in the series, or you've
done any research and go at all, concurrent
334:08 - programming is one of the hottest topics that
is talked about, especially among people who
334:12 - are learning to go language for the first
time. So we're going to talk about this concept
334:17 - of a go routine, and how that enables us to
create efficient and highly concurrent applications.
334:23 - We'll start our conversation by learning how
to create go routines themselves. So this
334:27 - is going to be the basics of how we create
go routines and how we can work with them
334:31 - a little bit. Then we'll move into a conversation
about synchronization. And we'll talk about
334:35 - two concepts, weight groups and mutexes. And
how we can use those to get multiple go routines
334:41 - to work together. Because one of the challenges
that we're going to have with go routines
334:45 - is also one of the greatest advantages. Go
routines are going to allow our application
334:49 - to work on multiple things at the same time.
However, you're often going to run into situations
334:54 - where you need a certain bit of functionality
in your application to weight into one or
334:59 - more of those concurrent calculations is complete.
So we'll talk about how to use synchronization
335:03 - primitives in order to do that. Then we'll
move into a discussion of parallelism. Now
335:08 - up to this point, our conversation is going
to be about concurrency in the go language.
335:13 - And concurrency is just the ability of the
application to work on multiple things at
335:17 - the same time, it doesn't mean it can work
on them at the same time, it just means it
335:22 - has multiple things that it can be doing.
When we talk about parallelism, we'll talk
335:26 - about how we can take our NGO applications
and enable them to work on those concurrent
335:31 - calculations in parallel, or in other words,
introduce parallelism into our applications.
335:37 - And finally, we're gonna wrap this video up
again, with a little section on best practices,
335:41 - just to talk about some of the gotchas that
you can run into with concurrent and parallel
335:45 - programming, and some of the tools that are
available to help keep your application safe
335:49 - and away from those minefields. Okay, so let's
get started by talking about how to create
335:54 - go routines. Okay, so the first thing that
you're going to notice is that we're in Visual
335:58 - Studio code right now. Now, the reason for
that is while we can certainly play with go
336:02 - routines in the playground, when we start
to get into parallelism, that's going to be
336:06 - limited by the playground, because the playground
only enables us to use one core at a time.
336:11 - So when we're running locally, we can use
as many cores as we want. So we can truly
336:14 - run our applications in parallel. So some
of the things that I want to show you are
336:17 - going to be easier to illustrate in this environment.
So the first thing that I want to show you
336:21 - is how we can create our very first go routine.
So the first thing that we're going to need
336:25 - to do is we're going to need to have a function
here. So I will create a function called Say
336:29 - hello. And this is going to be a very simple
function, all it's going to do is well say
336:32 - hello. So we'll start with that. And that's
going to be just enough for us to get started
336:37 - seeing what's going to happen with our application.
So we can of course, call the say hello function
336:42 - and call that from the main function. So we
can run this application by just using go
336:48 - run and pointing it to that file. And of course,
it says hello, so no big surprises there.
336:53 - Now, to turn this into a go routine, all we
have to do is in front of the function invocation,
336:59 - just type the keyword go. Now what that's
going to do is that's going to tell go to
337:04 - spin off what's called a green thread, and
run the say hello function in that green thread.
337:10 - Now I need to take a little bit of a moment
here to talk about threads. most programming
337:15 - languages that you've probably heard of and
worked with us, oh s threads are used operating
337:19 - system threads. And what that means is that
they've got an individual function call stack
337:25 - dedicated to the execution of whatever code
is handed to that thread. Now, traditionally,
337:30 - these tend to be very, very large. They have,
for example, about one megabyte of RAM, they
337:35 - take quite a bit of time for the application
to set up. And so you want to be very conservative
337:39 - about how you use your threads. And that's
where you get into concepts of thread pooling
337:43 - and things like that, because the creation
and destruction of threads is very expensive.
337:47 - And so we want to avoid that in most programming
languages, such as Java, or C sharp. Now,
337:53 - in go, it follows a little bit of a different
model. And as a matter of fact, the first
337:58 - place I saw this model was used by the Erlang
language. And this is using what's called
338:02 - Green threads. So instead of creating these
very massive heavy overhead threads, we're
338:08 - going to create an abstraction of a thread
that we're going to call a go routine. Now,
338:13 - inside of the go runtime, we've got a scheduler
that's going to map these go routines onto
338:18 - these operating system threads for periods
of time, and the scheduler will then take
338:23 - turns with every CPU thread that's available
and assign the different go routines, a certain
338:28 - amount of processing time on those threads.
But we don't have to interact with those low
338:32 - level threads directly. we're interacting
with these high level go routines. Now the
338:37 - advantage of that is since we have this abstraction
go routines can start with very, very small
338:42 - stack spaces, because they can be reallocated
very, very quickly. And so they're very cheap
338:47 - to create and to destroy. So it's not uncommon
in a go application to see 1000s or 10s of
338:53 - 1000s of go routines running at the same time.
And the application is no problem with that
338:57 - at all.
338:58 - Now, if you compare that to other languages
that rely on operating system threads that
339:02 - have one megabyte of overhead, there's no
way you're going to run 10,000 threads in
339:06 - an environment like that. So by using go routines,
we get this nice lightweight abstraction over
339:11 - a thread, and we no longer have to be afraid
of creating and destroying them. So anyway,
339:16 - let's go ahead and run this and see what happens.
And it's going to be a little disappointing
339:19 - because you notice that our message doesn't
print out. And the reason for that is our
339:23 - main function is actually executing in a go
routine itself. So what we did here in line
339:28 - six was we told the main function to spawn
another go routine, but the application exits
339:33 - as soon as the main function is done. So as
soon as it spawn that go routine, it finished,
339:37 - it didn't have any more work to do. So the
say hello function never actually had any
339:42 - time available to it to print out its message.
So we can get around that a little bit by
339:48 - using a horrible practice, but it's good enough
to get us started in understanding this. So
339:54 - we'll just put an arbitrary sleep calling
here in order to get the main function to
339:58 - delay a little bit Now when we run the application,
we see that we do get our Hello message printed
340:03 - out. Now, as opposed to our first run of this,
it's not actually the main function that's
340:08 - executing this code. It's a go routine that
we're spawning off from the main function.
340:13 - And that's what's responsible for printing
out the message. Okay, now, this is a pretty
340:17 - typical use case of go routine where we're
using the go routine to invoke a function.
340:21 - But we don't have to do that. As a matter
of fact, let me just drop in this example
340:25 - here, which is basically the same, except
for instead of using a named function, I'm
340:32 - using this anonymous function here. So notice
that I've got this anonymously declared function,
340:37 - and I'm invoking it immediately. And I'm launching
it with go routine. Now, what's interesting
340:42 - about it is I'm printing out the message variable
that I've defined up here on line nine, down
340:47 - here inside of the go routine. So if I run
this, we do in fact, see that it works. Now
340:53 - the reason that it works is go has the concept
of closures, which means that this anonymous
340:58 - function actually does have access to the
variables in the outer scope. So it can take
341:04 - advantage of this MSG variable that we declared
up here on line nine, and use it inside of
341:09 - the go routine. Even though the go routine
is running with a completely different execution
341:13 - stack. The go runtime understands where to
get that MSG variable, and it takes care of
341:18 - it for us. Now, the problem with this is that
we've actually created a dependency between
341:23 - the variable in the main function and the
variable in the go routine. So to illustrate
341:27 - how that can be a problem. Let me modify the
example just a little bit. So I'm declaring
341:32 - the variable message and setting it equal
to Hello, and then printing it out in the
341:36 - go routine. And then right after I launched
the go routine, right here on line 13, I'm
341:40 - reassigning the variable to goodbye. So if
I go ahead and run this, you'll see that we
341:45 - in fact, get goodbye printed out in the go
routine, not Hello, like you might expect
341:50 - based on how the program is written. And the
reason for that. And it's not always going
341:55 - to be guaranteed to execute this way. But
most of the time, the ghost scheduler is not
342:00 - going to interrupt the main thread until it
hits this sleep call on line 14. Which means
342:06 - even though it launches another go routine
on line 10, it doesn't actually give
342:10 - it any love yet, it's still executing the
main function. And so it actually gets to
342:14 - line 13 and reassigns, the value of the message
variable before the go routine has a chance
342:20 - to print it out. And this is actually creating
what's called a race condition. And we'll
342:24 - come back and talk about race conditions at
the end of this video. But this is a bad thing.
342:28 - And generally, it's something that you want
to avoid, so that you can access variables
342:32 - via the closure, it's generally not a good
idea to do that. So if that's not a good idea,
342:37 - what are your other options? Well, notice
that we have a function here. And this is
342:42 - just a function invocation, there's nothing
special about it, just because we put the
342:46 - go keyword in front of it, it's just a function.
So functions can take arguments. So what happens
342:51 - if we add a message argument here, and then
down in the prints, where we're actually invoking
342:57 - the function? What if we pass in the message
parameter? Well, since we're passing this
343:02 - in by value, so we're actually going to copy
the string hello into the function, then we've
343:07 - actually decoupled the message variable in
the main function from the go routine, because
343:13 - now, this message that's going to print out
is actually a copy that we're passing in when
343:19 - we're invoking the function for the go routine.
So now if we run this, we see that we get
343:24 - Hello printed out. So this is generally the
way that you're going to want to pass data
343:27 - into your go routines, use arguments to do
that, and really intend for the variables
343:32 - to be coupled together. Now, this example
so far is working. But it's really not best
343:38 - practice. And the reason it's not best practice
is because we're using this sleep call. So
343:42 - we're actually binding the applications performance
and the applications clock cycles to the real
343:47 - world clock. And that's very unreliable. So
in order to get your applications to work,
343:52 - you're typically going to have to sleep for
a very long time relative to the average performance
343:56 - time in order to get the performance to be
reliable. So we don't want to use sleep calls
344:00 - in production, at least not for something
like this. So what are the other alternatives?
344:05 - Well, one of the other alternatives that we
have is to use what's called a weight group.
344:10 - So let's go ahead and add one in. And then
while we're doing that, we'll talk about what
344:13 - they are. So I'm going to create another variable.
And it looks like my auto formatting just
344:18 - helped me here. And we'll pull that from the
sync package. And we'll create an object of
344:21 - type weight group. So I just need to put my
curly braces here to initialize it. Now what
344:27 - a weight group does is it's designed to synchronize
multiple go routines together. So in this
344:33 - application, we've got two go routines that
we care about, we've got the go routine that's
344:36 - executing the main function. And we've got
this go routine that we're spawning off here
344:40 - on line 13. So what we want to do is we want
to synchronize the main function to this anonymous
344:46 - go routine. So we're going to do that by telling
the weight group that we've got another go
344:51 - routine that we wanted to synchronize to it
starts off synchronizing to zero. And so we're
344:56 - going to add one because we want to tell it
that we're going to synchronize to this go
345:00 - Right here. Now once it's done, we don't need
this line anymore. Once it's done, we're going
345:06 - to go ahead and exit the application. And
we will do that by just waiting on the weight
345:09 - group. And we do that by using the weight
method right here. Now when the go routine
345:14 - is done, then it can tell the weight group
that it's actually completed its execution.
345:20 - And we do that by using the done method. So
if we execute that, basically, what that's
345:25 - going to do is it's going to decrement, the
number of groups that the weight group is
345:28 - waiting on. And since we added one, and it's
going to decrement by one to be down to zero,
345:33 - and then the weight method will say, Okay,
it's time for us to go ahead and finish up
345:36 - our application run. So if I save this off,
and I go ahead and run it, we see in fact
345:41 - that our application is performing as it did
before. But now it's taking just enough time
345:45 - to complete the execution. We're not relying
on the rolling clock anymore, and having to
345:50 - Jimmy run with variables and hope that everything
stays consistent. Now, in this example, we're
345:55 - just synchronizing to go routines together.
But only one of the go routines is really
345:59 - doing any work. The main function in this
example is just storing data, and spawning
346:03 - other go routines. But we can have multiple
go routines that are working on the same data.
346:08 - And we might need to synchronize those together.
And that can be a little bit tricky. So let
346:12 - me drop in this example here, and we'll talk
about it. So I'm creating weight group again,
346:16 - up here on line eight. And then I'm initializing
a counter variable. inside of my main function,
346:21 - I'm actually spawning 20 go routines, because
inside of this for loop, each time I run through,
346:26 - I add two to the weight group to let it know
there are two more go routines that are running.
346:31 - And then I spawn a say hello, and then I spawn
an increment here. And then I just have a
346:35 - wait method call here on line 17, just to
make sure that the main function doesn't exit
346:39 - out too early now and say hello, all I'm going
to do is I'm going to print out Hello, and
346:43 - I'm going to print out the counter value.
And then in the increment function down here,
346:48 - I'm just going to increment the counter by
one. Now after each one of those is done,
346:51 - I'm going to call the done method on the weight
group. And everything should be just fine.
346:55 - Now notice that I've broken my own rule here,
the weight group is actually being accessed
347:00 - globally in this application. And that makes
sense, because I actually do want to share
347:04 - this object, and the weight group
347:06 - is safe to use concurrently like this. It's
designed to be using this way. So let's go
347:11 - ahead and run this application and see what's
going to happen. So our intuition says that
347:16 - we're going to print say, Hello. So it should
print say hello, zero, because the counters
347:20 - value is zero right here. And then it's going
to increment it. And then it's going to say
347:24 - hello, again, it's going to increment it.
So should say hello, number zero, hello, number
347:27 - one, hello, number two, and so on. So let's
go ahead and run this and see what happens.
347:32 - And we see that we get a mess, we in fact,
don't have any kind of reliable behavior going
347:37 - on here, we printed one twice, and then 2345.
So that seemed to work consistently. And then
347:43 - we jumped all the way to nine, we printed
10 out twice, and then we went back to nine
347:46 - for some reason. And if we run this again,
we'll get a completely different result. So
347:50 - what's happening here is our go routines are
actually racing against each other. So we
347:54 - have no synchronization between the go routines,
they're just going hell bent for leather,
347:59 - and going as fast as they can to accomplish
the work that we've asked them to do, regardless
348:03 - of what else is going on in the application.
So in order to correct this, we need to find
348:09 - a way to synchronize these guys together.
Now, we could probably find a way to use a
348:13 - weight group on this. But we've already talked
about weight groups. So I want to talk about
348:17 - another way to do this. So we're going to
introduce this concept of a mutex. So with
348:21 - a mutex. let me paste this example in here,
and then we'll talk about what it does. But
348:27 - a mutex is basically a lock that the application
is going to honor.
348:31 - Now in this case, you see on line 11, I'm
creating what's called an rW mutex, which
348:35 - is a read write mutex. Now a simple mutex
is simply locked or unlocked. So if the mutex
348:41 - is locked, and something tries to manipulate
that value, it has to wait until the mutex
348:46 - is unlocked. And they can obtain the mutex
lock itself. So what we can do with that is
348:50 - we can actually protect parts of our code
so that only one entity can be manipulating
348:55 - that code at a time. And typically what we're
going to use that for is to protect data to
348:59 - ensure that only one thing can access the
data at a single time. With an rW mutex, we've
349:05 - changed things a little bit. We've basically
said as many things as want to can read this
349:09 - data, but only one can write it at a time.
And if anything is reading, then we can't
349:15 - write to it at all. So we can have an infinite
number of readers, but only one writer. And
349:20 - so when something comes in and makes a write
request, it's going to wait till all the readers
349:23 - are done. And then the writer is going to
lock the mutex. So nothing can read it or
349:27 - write it until the writer is done. So in this
modification, actually, I don't want to talk
349:32 - about that line yet. We'll come back and revisit
that. So in this modification, what I've done
349:37 - here is I'm attempting to use a mutex to synchronize
things together. So the modification is down
349:43 - here in my say, Hello, I'm just reading the
value of the counter variable. And that's
349:47 - what I'm trying to protect. I'm trying to
protect the counter variable from concurrent
349:51 - reading and writing because that's what was
getting us into trouble. So on line 22, I
349:56 - obtained a read lock on the mutex and then
I print out my message and And then I released
350:00 - that lock using the R unlock method. Now in
the increment, that's where I'm actually mutating
350:05 - the data. So I need to write lock. And so
I'm going to call the lock method on the mutex,
350:09 - increment the value. And then I'm going to
call unlock. Now, if I run this application,
350:14 - I actually haven't gotten quite where I want
to be. So I don't get the weird random behavior
350:20 - that I was seeing before. But you notice that
something seems to be out of sync still, because
350:25 - I get Hello, one, hello, two, and then it
stays at two. And if I keep running, this
350:30 - actually can get different behaviors. But
notice that I'm always going in the proper
350:35 - order. So I fixed part of my problem, but
I haven't fixed all of it yet. So I can keep
350:39 - running. Actually, that one got pretty close.
But there's obviously something else going
350:42 - on here. With the reason that we have an issue
here is we're still working within the go
350:48 - routines. So if this say hello, function gets
executed twice by its go routines, and the
350:54 - increment function doesn't get called in between.
That's where we get this behavior here, where
350:58 - we actually get the same message printing
out twice, because we don't have a chance
351:01 - to lock this mutex before we try and read
it that second time. So the way to address
351:06 - this is we actually have to lock the mutex
outside of the context of the go routine.
351:11 - So we have a reliable execution model. So
let's go ahead and paste in a small modification
351:16 - here. Now all I've done is I've moved the
locks out here. So the locks are now executing
351:22 - before each go routine executes. And then
I unlock them when the go routine is done.
351:27 - So if I run this, we actually see that I now
get the behavior that I expect, I see zero
351:33 - through nine printed out. And if I run it
again, and I run it again, and run it again,
351:39 - everything is working great. So the reason
that this is working is I'm actually locking
351:44 - the mutex is in a single context. So the main
function is actually executing the locks.
351:50 - And then asynchronously, I'll unlock them
once I'm done with the asynchronous operation.
351:54 - Now the problem with this application is I
basically have completely destroyed concurrency
351:59 - and parallelism in this application. Because
all of these mutexes are forcing the data
352:04 - to be synchronized and run in a single threaded
way. So any potential benefits that I would
352:10 - get from the go routines are actually gone.
As a matter of fact, this application probably
352:14 - performs worse than one without go routines,
because I'm mucking around with this mutex.
352:18 - And I'm constantly locking it and unlocking
it. So this is an example where if this is
352:24 - all that this application needed to do, we
would actually be much better served by removing
352:28 - the go routines, and just running this with
a single execution path and removing any concurrency
352:33 - at all. However, there are often situations
where you can get a significant advantage
352:38 - by running things in parallel. And so you
can use weight groups, or mutex is in order
352:43 - to synchronize things together, and make sure
that your data is protected, and everything
352:47 - is playing well together. Now I have this
line in here, and I apologize for that I really
352:51 - shouldn't have had that in these earlier examples.
But I do want to talk about this function
352:56 - from the runtime package called go max procs.
So in modern versions of go, if you look at
353:02 - this go max procs variable, let's just go
ahead and execute this simple program, all
353:06 - it's going
353:07 - to do is it's going to tell me the number
of threads that are available. So it prints
353:10 - out that there are four threads available
in the application ends. Matter of fact, let
353:13 - me just add this carriage return in here and
run this again, that way things look a little
353:16 - better. And you see that I have four threads
available. So by default, what go is going
353:22 - to do is it's going to give you the number
of operating system threads equal to the number
353:27 - of cores that are available on the machine.
So in this virtual machine, I've exposed four
353:32 - cores to the VM.
353:33 - So I have by default four oh s threads that
I can work with. Now, I can change that value
353:38 - to anything I want. So for example, I can
change that to one. And now my application
353:45 - is running single threaded. So now I have
a truly concurrent application with no parallelism
353:50 - at all. So this can be useful in situations
where there's a lot of data synchronization
353:55 - going on. And you really need to be careful
to avoid any kind of race conditions that
354:00 - parallelism can incur. And maybe there's no
better way to do it. Now, I would say there's
354:04 - an architecture problem there. But it is possible
to run an application in a single threaded
354:09 - way, by setting go max procs equal to one.
Now if you're wondering what this negative
354:14 - one does, when you invoke the go max procs
function, it actually returns the number of
354:19 - threads that were previously set. And if you
pass a negative number, then it doesn't change
354:23 - the values. So this go max procs, negative
one, all that's doing is that's letting us
354:27 - interrogate how many threads we have available.
Now we can also set this to for example, 100.
354:32 - There's nothing stopping us from creating
a massive number of operating system threads.
354:37 - Now what I found in working with NGO is that
go max procs is a tuning variable for you
354:43 - to work with. So the general advice is one
operating system thread per core is a minimum.
354:50 - But a lot of times you'll actually find that
your application will get faster by increasing
354:56 - go max procs beyond that value. Now if you
get up too high Like, for example, 100, then
355:02 - you can run into other problems, because now
you've got additional memory overhead. Because
355:05 - you're maintaining 100 operating system threads,
your scheduler has to work harder because
355:09 - it's got all these different threads to manage.
And so eventually, the performance peaks and
355:14 - it starts to fall back off, because your application
is constantly rescheduling go routines on
355:19 - different threads. And so you're losing time
every time that occurs. So as you get your
355:25 - application closer to production, I would
encourage you definitely develop with go max
355:29 - procs greater than one because you want to
reveal those race conditions as early as possible.
355:34 - But just before you release to production,
you might want to run your application through
355:38 - a performance test suite with varying values
of go max procs, to see where it's going to
355:43 - perform the best. Now, the last thing that
I want to talk about are some best practices
355:48 - to keep in mind when you're working with go
routines in the go language. So let's take
355:52 - a look at those next. Go routines in the go
language are very powerful, and it can be
355:57 - easy to let them get a little bit out of hand.
So I want to go through and give you some
356:01 - advice on how to work with go routines in
your own applications. The first bit of advice
356:06 - is, if you're working in a library, be very,
very careful about creating go routines yourself,
356:11 - because generally, it's better to let the
consumer control the concurrency of the library,
356:16 - not the library itself. If you force your
library to work concurrently, then that can
356:20 - actually cause your consumers to have more
problems synchronizing data together. So in
356:24 - general, keep things simple, keep things single
threaded, and let the consumer of your library
356:29 - decide when to use a go routine and when not
to now, this advice can be softened a little
356:35 - bit, if you have a function called that's
going to return a channel that will return
356:38 - the result, then having the go routine in
there might not be such a bad thing, because
356:43 - your consumer never really has to worry about
how that unit of work is getting done. They
356:47 - don't really care if it's running concurrently
or not. Because they are just going to be
356:51 - listening for the result on a channel. But
we haven't talked about channels yet. So we'll
356:54 - revisit that topic in the next video. But
for now, if you're creating a library, trying
356:59 - to avoid go routines, at least go routines
that are going to be surface to the consumer
357:04 - and have them forced to work with them. When
you create a go routine, know how it's going
357:08 - to end. Now we're gonna see how to do this
a little bit more when we talk about channels.
357:14 - But it's really easy to have a go routine
launched as kind of a watch or go routine.
357:18 - So it's going to be just sitting out there
listening for messages to come in. And it's
357:22 - going to process those messages as they arrive.
However, if you don't have a way to stop that
357:26 - go routine, that go routine is going to continue
on for ever. And so it's constantly going
357:31 - to be a drain on the resources of your application.
And eventually, as the go routine ages, it
357:37 - could even cause other issues and cause your
application to crash. The other thing that
357:41 - I want to give you some advice about is check
for race conditions at compile time. So I
357:46 - want to jump back over to the editor and show
you how to do that. But it's very important
357:50 - and very simple to do in most environments
that go runs in. So let's jump over to the
357:54 - editor and take a look at that in order to
see if we don't have to go any further than
357:58 - this example. Now I know this is right from
the beginning of the video, and it's got sleeps
358:02 - in there. And it's got some bad practices.
But if you remember, if we run this application,
358:07 - then it prints goodbye instead of the Hello
message that we originally printed. So how
358:12 - could we have detected this without running
the application? Well, you might not think
358:17 - it's terribly important to be able to do that.
Because it's obvious, we've got some kind
358:21 - of a problem here. And all we have to do is
apply our debugging skills. But there are
358:24 - other cases where this is very, very subtle
and very, very hard to track down without
358:30 - a little bit of help. Well, fortunately, the
go compiler has quite a bit of help available
358:35 - to you. And it's as simple to invoke as just
adding a dash race flag to go run, go install,
358:42 - go build whatever you're using to get your
application up and running. So let's go ahead
358:45 - and try that and see what it says about our
little application here. And you notice it
358:50 - does run the application because we invoked
go run so we see goodbye printed here. But
358:55 - notice what we got up here we got this data
race message. So it's telling us it sees that
359:00 - the same area of data is being accessed by
two different executing go routines. So it
359:06 - says the first one that it found was in go
routine six which an internal identifier unless
359:10 - we're profiling, we've got no idea what goroutine
six is, but it does tell us it was invoked
359:15 - on line 11. So apparently in this run, go
routine six was this go routine right here.
359:20 - And it was accessing the MSG variable. It
also sees that we access the MSG variable
359:27 - on line 13, which is in our main function.
And so by adding the dash race flag, we get
359:32 - all of this additional information where the
go compiler itself, analyzes our application
359:38 - and tries to determine if we have any race
conditions. So I would strongly encourage
359:43 - you if you get any kind of concurrency at
all in your application, you're going to want
359:47 - to run this because it's very simple check
it runs very, very quickly. And it's going
359:52 - to help you prevent very subtle bugs from
getting into your production code.
359:57 - Okay, so that's what I have to talk about.
With go routines, maybe you are expecting
360:02 - more. But go routines are really quite simple.
Now when we get into our next conversation,
360:06 - which will be about channels, things get a
little bit more complicated, but go routines
360:10 - are relatively straightforward. So let's go
into a summary and review what we've talked
360:14 - about in this video. In this video, we learned
about go routines and how we can use them
360:20 - to create concurrent and parallel execution
paths in our applications. We started by learning
360:26 - how to create go routines themselves. And
we learned that by adding the go keyword in
360:31 - front of a function call, we've created a
go routine. And that's all that it takes.
360:34 - There's no special semantics, there's no special
things that need to be done. It's simply a
360:38 - function call with the keyword go in front
of it. Now when we're using anonymous functions,
360:44 - we in general want to pass data as local variables.
So you want to add a parameter into that anonymous
360:48 - function and pass data into the go routine,
instead of relying on the closures to prevent
360:54 - any kind of race conditions as you try and
manipulate that data. And that's not always
360:59 - true. We saw with weight groups that we access
that globally, because that was our intention,
361:03 - we truly did want that to be available in
multiple scopes. But even then we could pass
361:08 - a pointer in, in order to be very clear about
what information that go routine should have
361:12 - access to. Then we talked about the different
ways that we can synchronize multiple go routines
361:17 - together, one of the challenges that we have
with go routines is now we've got all sorts
361:21 - of things happening. And there's no way to
ensure without synchronization, how they're
361:26 - going to interact with one another. Now for
a lot of concurrent calculations, that's not
361:31 - a problem at all, because the two might not
be related to one another. But often you get
361:35 - into situations where you're relying on the
result of multiple calculations, or something
361:39 - needs to know the result of the work that's
been done, or you've got a shared memory issue.
361:45 - And you need to make sure that those go routines
aren't trying to manipulate the same data
361:49 - at the same time. So we can use weight groups
to wait for groups of go routines to complete.
361:54 - So we saw that we have three methods that
are interesting. There, we have the Add method
361:58 - to inform the weight group that there are
more go routines for it to wait on, we have
362:02 - the weight method that's going to block the
go routine that is called on until the weight
362:06 - group is completed. And then we have the done
method available on that weight group that
362:10 - lets the weight group know that one of the
go routines is completed with its work.
362:15 - We also talked about the mutex and the rW
mutex, and how those are generally used to
362:19 - protect data. So if you have a piece of data
that's going to be accessed in multiple locations
362:23 - in your application, then you can protect
that access by using a mutex or an rW mutex.
362:29 - To ensure that only one go routine is manipulating
that data at one time. We then talked about
362:34 - parallelism and how parallelism can introduce
some really tricky challenges into your go
362:39 - applications. We talked about how by default
go will use the number of CPU threads equal
362:45 - to the number of available cores on the computer
that is running on. We talked about how we
362:49 - can change that by using the go max procs
function from the runtime package. And we
362:54 - talked about how more threads will generally
increase performance. But too many can actually
362:59 - slow it down. So in general, if you're developing
an application, you want to start from day
363:04 - one with go max procs greater than one to
find any concurrency and any race conditions
363:09 - early on in your application development.
But don't settle on a final number until right
363:14 - as you get close to production and you have
a performance test suite that you can work
363:17 - with. To find out what the best value for
go max procs is for your application. Because
363:23 - while the starting number is a very good number
to start with, a lot of applications actually
363:27 - perform better with a value higher or lower
than that default value. And finally, we wrapped
363:33 - up with a discussion of some best practices
to keep in mind when you're working with go
363:36 - routines. We learned that if you're a library
developer, you should avoid the creation of
363:41 - go routines that are going to be exposed to
the consumer of your library. Let the consumer
363:45 - control the concurrency of your application
because they're the ones that are in the best
363:48 - place to know if something needs to be executed
single threaded, or if it can be executed
363:53 - concurrently. When creating a go routine,
know how it's going to end. It's very easy
363:57 - to get into situations where go routines start
leaking memory because they're never cleaned
364:02 - up because they never quite get done with
their work. Now normally a go routine is killed
364:06 - as soon as it finishes its execution. And
we saw that with the main function, the main
364:11 - function runs in a go routine. And that go
routine terminates as soon as the main function
364:15 - exits. We also saw in our say hello function,
as soon as it printed its message out and
364:20 - the function exited. That go routine was killed
and it was cleaned out. So it was very clear
364:25 - when those go routines life cycle is going
to be over. However, if you've got go routines
364:30 - that are listening for messages in a continuous
loop, then make sure that you code in a way
364:34 - to shut those go routines down so that once
you're done using them and clean up the memory
364:39 - that they're using. Also, as you're going
along with your application development, check
364:44 - for race conditions, it's not that hard to
do. You just have to add dash race onto the
364:49 - go command that's compiling your application.
And then the go compiler is going to analyze
364:54 - your application and try and locate places
in it that have the potential of access Seeing
365:00 - the same memory at the same time, or in an
unsynchronized way, causing very subtle and
365:05 - potentially very disastrous bugs where your
application when it gets to production. Over
365:10 - the course of this video series, we've talked
about a lot of structures and techniques and
365:15 - tools that are available. In order to get
started successfully programming with the
365:19 - go language. Well, I want to wrap up that
discussion in this video by talking about
365:23 - one of the features that makes go really stand
out when you're looking for different languages
365:27 - to work with. And that is this concept of
channels. Now most programming languages that
365:32 - are out there, were originally designed with
a single processing core in mind. And so when
365:37 - concurrency and parallelism came into play,
they were really kind of bolted on to the
365:42 - side. And so a lot of times, you're actually
going to be working with third party libraries
365:46 - and packages in order to help with data synchronization
and things like that. Well go was born in
365:52 - a multiprocessor world. So every computer
that was out there when go was invented, had
365:57 - more than one processing core. So it made
sense as the language was being designed to
366:02 - consider concurrency and parallelism from
the beginning. Now in the last video, we talked
366:07 - about go routines, and how go abstracts the
concept of a thread into this higher concept
366:14 - called a go routine to allow hundreds or 1000s
or even 10s of 1000s of things to be going
366:19 - on in your application at the same time. On
this video, we're going to be talking about
366:24 - channels, and how those can be used to pass
data between different go routines in a way
366:30 - that is safe, and prevents issues such as
race conditions, and memory sharing problems
366:35 - that can cause issues in your application
that are very difficult to debug.
366:41 - So we're going to start this talk by talking
about the basics of channels. So we'll talk
366:44 - about how to create them, how we can use them
how we can pass data through them, then we'll
366:49 - talk about how we can restrict data flow.
Now a basic channel is a two way street, we
366:53 - can send data in and we can get data out.
But that's not always what you want to be
366:57 - able to do with the channel. Sometimes you
want to send only channel or receive only
367:01 - channel. And we'll talk about how to do that
in the second section. Then we'll talk about
367:05 - buffered channels, and how we can actually
design channels to have an internal data store
367:11 - so that they can store several messages at
once just in case the sender and the receiver
367:15 - aren't processing data at the same rate. Then
we'll talk about how we can close channels
367:19 - once we're done with them. We'll then revisit
the topic of four range loops. And we'll learn
367:24 - how we can use channels with a four range
loop. And then we'll wrap up our discussion
367:28 - by talking about SELECT statements, which
is kind of like a switch statement, but specifically
367:33 - designed to work in the context of a channel.
Okay, so let's go ahead and dive in and learn
367:37 - the basics of working with channels.
367:40 - So when we're working with channels in the
go language, we're almost always going to
367:44 - be working with them in the context of go
routines. And the reason is because channels
367:48 - are really designed to synchronize data transmission
between multiple go routines. So let's go
367:54 - ahead and get started by creating some go
routines. Well, actually, the first thing
367:57 - that I need to do is I need to create a weight
group. Because as you remember from the last
368:00 - video, we use weight groups in order to synchronize
go routines together. So we're going to use
368:05 - the weight group to synchronize the go routines
to make sure that our main routine waits for
368:09 - all of our other go routines to finish. And
then we're going to use channels in order
368:14 - to synchronize the data flow between them.
So we got two different synchronization mechanisms
368:18 - going on in this little application. The next
thing we need to do is we need to create a
368:22 - channel. Now channels are created with the
built in make function. And there really is
368:26 - no shortcut around this. Now a lot of uses
of the make function, you can actually use
368:31 - other forms. When you're creating a channel,
there's enough internal mechanisms that need
368:35 - to fire that you have to use the make function
in order to allow the runtime to properly
368:39 - set up the channel for you. Now on the simplest
form of the make function with working with
368:44 - channels, we're going to use the channel keyword
to say that we want to create a channel. And
368:48 - then we're going to provide the data type
that's going to flow through the channel.
368:51 - Now you can pick any data type that you want,
we're just going to be using integers here.
368:55 - But keep in mind that this means that the
channel is strongly typed, you can only send
369:00 - integers through this channel that we're creating
here. Similarly, if we provided strings, we
369:04 - could only pass in strings. If you provided
pointers to integers, you can only send in
369:08 - pointers to integer, you get the general idea.
So when you create a channel, you're going
369:13 - to create that channel to accept messages
of a certain type. And it's only ever going
369:18 - to receive them send messages of that type.
Now in this initial example, we're going to
369:22 - have to go routines, I'm going to spawn so
I'm going to add two items to my wait group.
369:26 - And then we'll go ahead and create those go
routines, and then we'll talk about those.
369:30 - So let me just drop in the rest of the code
here. And you can see my first go routine
369:35 - is an anonymous function actually both of
the marm and this first one is going to be
369:39 - receiving data from the channel. So this go
routine is actually going to be my receiving
369:44 - go routine. And then this channel is actually
going to be my sending go routine. So the
369:49 - way that we send a message into a channel
is as you see here, we're going to use this
369:54 - arrow syntax, so we're going to use a less
than and a dash, and when we're putting data
369:58 - into the channel we list the channel first,
then we have this arrow and then the data
370:03 - that we want to pass in. So imagine that the
arrow is pointing in the direction that we
370:07 - want the data to flow. So we want the data
to flow into the channel, and so the arrow
370:11 - is pointing toward the channel. Similarly,
if we want to receive data from the channel,
370:15 - then we're going to put the arrow on the other
side. So we're going to use that same less
370:19 - than and dash, but it's going to be before
the channel. And so we're going to be pulling
370:24 - data from the channel. So in this line right
here, on line 14, we're going to be receiving
370:29 - data from the channel and assigning it to
the variable i. And then after we're done,
370:33 - we're going to call the done method on our
weight groups. And we're just going to print
370:37 - the value out. So all we're doing here is
this go routine is going to be sending the
370:41 - value 42, this go routine is going to be receiving
whatever value comes out of the channel, which
370:46 - in this case, of course, will be 42. And it's
going to print that out to the console. So
370:50 - let's go ahead and run that. And we see that
in fact, it does work. So the nice thing about
370:55 - doing this is since we're sending a copy of
the data to the channel, we could manipulate
371:01 - the variable assigned here. So for example,
we could actually start this off with I set
371:05 - equal to 42. And we can pass in I and then
afterwards, we can reassign I, and it doesn't
371:13 - matter because like with all other variable
operations and go, when we're passing data
371:18 - into the channel, we're actually going to
pass a copy of the data. So when we manipulate
371:21 - it afterwards, the receiving go routine doesn't
really care that we change the value of the
371:26 - variable, it's not affected by that at all.
Now another common use case for go routines
371:31 - is if you have data that's asynchronously
processed, so maybe you can generate the data
371:36 - very, very quickly, but it takes time to process
it. Or maybe it takes a long time to generate
371:41 - that data. So you've got multiple generators,
but it can be processed very quickly. So you
371:46 - might want to have a different number of go
routines that are sending data into a channel,
371:50 - then you have receiving. So let's take a look
at how we can do that. So it's a slight modification
371:55 - to the example that we just went through,
instead of just having the go routines fire
372:00 - once, I'm actually creating go routines inside
of this loop here. So I'm going to create
372:04 - five sets of go routines. So each one of the
groups is going to have a sender like we have
372:08 - here, which is exactly what we had before.
And then we're going to have a receiver, which
372:12 - is again, just like we had before. So by the
time the application is done, we're going
372:16 - to spawn 10 go routines here, five senders
and five receivers, and all of them are going
372:22 - to be using this single channel to communicate
their messages across. So if we go ahead and
372:26 - run this, we see that we do get five messages
received.
372:31 - Okay, so this works out really well, well,
but I will warn you, if you start playing
372:36 - around with this, and you decide to start
moving the senders and receivers to make them
372:40 - asymmetrical, things won't work very well.
So one of the things you might want to do
372:43 - to play with this example is take this go
routine, and move it outside of the for loop.
372:49 - So you're gonna have one receiver and multiple
senders at the end of this, well, that actually
372:54 - isn't going to work right now. Because if
you think about how this go routine is going
372:57 - to process, it's going to receive the message
coming in from the channel, it's going to
373:01 - print and then it's going to exit, but then
down here in the loop, we're actually going
373:04 - to spawn five messages into that channel.
So we can only receive one, but we're sending
373:09 - five. And if we run this, we're actually going
to run into a problem. And that is we see
373:13 - all routines are asleep, that we have a deadlock
condition. And the reason for that is because
373:18 - we have these go routines down here that are
trying to push messages into the channel.
373:22 - But there's nothing that can process them.
Now an important thing to keep in mind here
373:27 - is the reason that this is a deadlock. And
the reason for that is this line of code here
373:33 - is actually going to pause the execution of
this go routine right at this line until there's
373:39 - a space available in the channel. So by default,
we're working with unbuffered channels, which
373:44 - means only one message can be in the channel
at one time. So our first go routine in this
373:49 - loop gets happily spun up, it pushes a message
into the channel, and then it exits and then
373:54 - calls this done method on the weight group.
And then that message gets processed by this
373:58 - go routine here and everything's happy. However,
this go routine then exits. And then our next
374:03 - go routine comes along and tries to push another
message in. Well, it blocks right on this
374:08 - statement. And there's nothing in our application
that's going to receive that message. And
374:11 - that's why we see the go runtime. Notice that
and it's going to kill the application because
374:16 - it notices that we have a problem, and it
doesn't know how to resolve it. Now I want
374:20 - to go back to our previous example. And actually
I'm going to modify things slightly here.
374:25 - Because I want to show you that notice that
we're just working with the raw channel. So
374:29 - this is perfectly valid code for us to write.
As a matter of fact, if I go ahead and run
374:33 - this, we see that we get two messages printed
out but look at how that's happening. So this
374:39 - go routine is pushing a message into the channel.
That message is then being received up in
374:45 - this go routine and printed out this go routine
then the one that received this message is
374:50 - then putting a message back into the channel.
And that is then being received down here
374:55 - and this go routine, which is then printing
the message out. So both of these go routines
374:59 - are actually as readers and writers, now that
may be a situation that you want, but very
375:05 - often, you want to actually dedicate a go
routine to either reading from a channel or
375:10 - writing to a channel. So in order to do that,
what we're going to do is we're actually going
375:14 - to pass in the channel with a bias on the
direction that is going to be able to work
375:19 - with. So the way we're going to do that is
by accepting variables in our go routines.
375:23 - So we'll start with this first one here. And
we want this to be a receive only channel.
375:28 - So the way we're going to do that is we want
data to flow out of the channel. So you notice
375:33 - we're using that similar syntax, we're going
to list the type of the channel, and then
375:37 - we're going to have this arrow coming out
of it. So data is flowing out of the channel.
375:41 - And so this is going to be a receive only
channel. Similarly, if we want a send only
375:46 - channel, we're going to give it the variable
name, we're going to say that it's a channel,
375:51 - now we put the Send only operator right here,
and then we put the data type. So this is
375:57 - going to be sending data into the channel
only. And this is going to be receiving data
376:01 - from the channel. And then of course, we have
to pass the channel into the go routines as
376:06 - arguments. So when we run this, we're actually
going to get an error. And the reason we get
376:12 - an error is because we're trying to pass data
into this channel. But this is a receive only
376:16 - channel. So it's invalid to send data into
it. And then similarly, we have an error down
376:20 - here on line 21, because we're trying to receive
data from the Send only channel. So if we
376:25 - go ahead and wipe out these lines here, this
line, and this line, and run, then everything
376:32 - works as it did before. But now it's much
more clear what the data flow is in the go
376:39 - routine, we know that we're going to be receiving
data on one side, and we're going to be sending
376:42 - data on the other. Now something that's a
little unusual with this is notice that we're
376:47 - passing in a bi directional channel. So this
is just a normal channel, and we're receiving
376:52 - it a little bit differently. So this kind
of feels like a little bit of polymorphic
376:56 - behavior. And this is a special aspect of
channels, the runtime understands this syntax.
377:01 - And so it actually is going to, I'm going
to use the word cast here, it's going to cast
377:06 - this bi directional channel into a unidirectional
channel. But that's not something you can
377:11 - generally do in the go language. That is something
that is specific to channels. Now one of the
377:16 - problems we ran into on a previous example
is we had a situation where we tried to push
377:21 - five messages into a channel, but we only
had one receiver. And we noticed that the
377:26 - application deadlock, well, we can get around
that in a couple of different ways. Now I'm
377:30 - going to show you one way to get around that
that really is nice deal for solving that
377:35 - problem. But I will talk about the problem
that it is solving. And that is by using buffered
377:39 - channels. So if I go ahead and paste in this
example, here, we will see an example of the
377:44 - problem we might run into. I've simplified
it a little bit from the previous example
377:48 - we ran into. So we've got our initial example
where we've got a receive only go routine,
377:53 - we've got a send only go routine. But in our
send go routine, we're actually sending two
377:57 - messages. But since we're only receiving one,
we expect that we're going to run into a problem.
378:02 - So let's go ahead and run this. And we see
that we do in fact have a problem, we received
378:06 - the 42 out and printed it. But there's nothing
to deal with this message here that's in the
378:10 - channel. And so the application blows up,
because this go routine can never complete,
378:16 - because it's blocked on this line. So we need
a way to get around that. Now a simple way
378:21 - to get around that is by simply adding a buffer
here. So if we add a second parameter to the
378:28 - make function up here, and provide an integer,
that's actually going to tell go to create
378:33 - a channel that's got an internal data store
that can store in this case, 50 integers.
378:39 - Now what that's going to do is it's actually
going to allow our application to complete.
378:44 - But we do have a little bit of a problem here
because this message is lost. So it did eliminate
378:48 - the panic. And I guess in one way, you could
say it solved the problem. But it did create
378:52 - another problem in that we lost this message.
Now this isn't the problem that buffer channels
378:57 - are really intended to solve. But I do want
to show you that it does create that internal
379:02 - store, so we can receive multiple messages
back out. As a matter of fact, what we can
379:06 - do is we can just copy this line down here
and reformat this, and we don't need this
379:12 - column right here. And if we run this, we
see that we do get both messages printed back
379:17 - out. Now what a buffered channel is really
designed to do is if the sender or the receiver
379:23 - operate at a different frequency than the
other side. So you can imagine if we had a
379:30 - data acquisition system, and maybe we retrieve
data from our sensors, and a burst transmission,
379:36 - so maybe we're acquiring data from seismometers,
and we're monitoring earthquakes, well, maybe
379:41 - those seismometers in order to conserve power,
don't send their data continuously, they're
379:47 - going to send a burst transmission, maybe
once an hour. So every hour, we're going to
379:50 - get a burst transmission that maybe last five
or six seconds, that's going to contain the
379:55 - entire hours worth of data. So in that case,
our sender is going to be inundated with data
380:01 - when that burst happens. And it's going to
have to have a way to deal with it, one of
380:06 - the receivers might take a little while to
process that data. So in that case, what we
380:11 - might want to do is create a buffer here of
these signals that are coming in from our
380:16 - seismometer, that's going to be able to accept
that one hours worth of data. And then our
380:20 - receivers can pull that data off, as they're
able to process it, and keep things working
380:25 - smoothly, so that the channel that's receiving
the data from our sensors, doesn't get locked
380:31 - up, because it doesn't have a place to put
the next message. So that's really what buffered
380:35 - go routines are designed to work with, is
when your sender or your receiver needs a
380:39 - little bit more time to process. And so you
don't want to block the other side, because
380:44 - you have a little bit of a delay there. Now
if this isn't the right way to handle this
380:48 - situation, what is the right way? Well, the
way that we typically handle something that's
380:53 - going to happen multiple times, such as passing
a message into a channel, is by using some
380:57 - kind of a looping construct. And that's no
different with channels as is with anything
381:01 - else. So let's paste in this example, where
I instead of processing the message once and
381:07 - then having this first go routine exit, I'm
actually going to use a for range loop. But
381:12 - notice what I'm arranging over,
381:13 - instead of ranging over some kind of a collection,
such as an array, a slice or a map, I'm actually
381:18 - ranging over the channel. Now the syntax changes
just a little bit. Because if this were a
381:23 - slice, the first index that we pull back is
going to be the index in the slice. And then
381:29 - the second variable we pulled out, if we had,
for example, a second variable here would
381:33 - be the value. Well, when you're arranging
over a channel, things are a little bit different.
381:38 - When you pull a single value, you're actually
going to get the value that's coming out of
381:41 - the channel. And so if we run this, we see
that we do in fact get 42 and 27. But we still
381:48 - have a deadlock condition. So what's causing
that deadlock condition? Well, before we had
381:53 - this four range loop, we actually deadlocked
this go routine right here, and everything
381:58 - died. We're in our new application, we're
actually deadlocking in the four range loop.
382:03 - And the reason for that is because we're continuing
to monitor for additional messages, but we
382:08 - stopped sending messages. And so now this
four range loop doesn't know how to exit.
382:13 - And so this go routine is now causing the
deadlock condition. So we've improved the
382:18 - situation, we kind of move the needle where
we're no longer dead locking in our sender,
382:22 - but we are still dead locking in our receiver.
So how do we handle that? Well, the way that
382:26 - we're going to handle that is we have to understand
how the four range loop works. So if you're
382:32 - using a for range, loop over a slice, how
many times does that iterate? Well, it executes
382:37 - the loop once for every item in the slice.
So if you've got a slice with five elements
382:41 - in it, you're going to run through the four
range loop five times, well, how many elements
382:45 - are in a channel? Well, there can be an infinite
number of elements in a channel because you
382:50 - can constantly push a new message into it.
So what is the way to signal a four range
382:55 - loop with a channel that there are no more
messages coming? Well, the answer is we need
382:59 - to close the channel. So anything that has
access to the channel can do this, we're going
383:03 - to use the built in close function. And we're
going to pass in the channel like you see
383:08 - here. So what we're doing on our sending side
is we're passing in two messages, we're passing
383:12 - in 42, and 27. And then we're letting the
channel know we're done working with you.
383:18 - So we're going to go ahead and close the channel,
this four range loop is going to detect that.
383:23 - And when we run this, now everything runs
well, because we're passing in the message
383:27 - 42, that gets processed in the for loop, we're
passing in 27, that gets processed, then we
383:33 - close the channel, that gets processed by
the for range loop, which notices that the
383:37 - channel is closed, and it's going to exit
and it's going to terminate the loop. So when
383:42 - we terminate the loop, then we call the done
method on the weight group. And then we exit
383:46 - the go routine, all of our go routines exit
properly, and we have no more
383:50 - deadlocks.
383:51 - Now we do have to be a little bit careful
in closing channels, because when you close
383:54 - a channel, you really have to mean that you're
closing the channel down. So let's try closing
383:59 - the channel right here and then pushing another
message into it. So if we run this, we actually
384:04 - get a bad thing happening. So in this case,
the application panicked. And why did it panic,
384:09 - because we tried to send a message on a closed
channel. So the issue here is we close the
384:14 - channel right here on line 21. And then on
line 22, we tried to pass another message
384:19 - into it. So that is a no, no, you are not
allowed to pass a message into a closed channel
384:24 - because the channel is closed. So you might
ask, Well, how do I recover from this? How
384:28 - do I reopen the channel or undo that or whatever?
And the answer is, you can't. As a matter
384:34 - of fact, you can't even detect if a channel
is closed, except for by looking for the application
384:40 - panicking. So call that a limitation of the
go language or not, I don't know. But you
384:46 - do have to be very careful that when you close
a channel, nothing else is going to send a
384:49 - message into it. So if that is a possibility,
then the only option you really have is to
384:55 - have a deferred function and use a recover
in there to recover from the panic that gets
385:00 - thrown because in this situation, you will
have a panic and there is no way to avoid
385:04 - it. So if in your application, that's a situation
that's likely to happen, then again, you're
385:08 - going to have to use that recover function.
And you can review the video where I talked
385:12 - about using those. Now on the receiving side,
we do have a little bit of a different story
385:17 - here, because this issue is on the closing
side. So we cannot send the message into a
385:21 - closed channel. And we can't detect if a channel
is closed before we try and send a message
385:25 - into it. However, if we go on the receiving
side, then the story gets a little bit brighter.
385:31 - So you might ask the question, how does the
four range loop know that the channel is closed,
385:35 - it has to have some way of detecting it, what
turns out that there's more than one parameter
385:41 - that you can pull back from the channel. So
just like when we're querying maps, and we're
385:46 - trying to get a value out of a map, and we
can use that comma, okay, syntax, well, that
385:51 - syntax works for channels as well. So if I
change this example up a little bit, and this
385:56 - is going to do exactly the same thing as our
current example, here using a four range loop,
386:01 - but instead of using the four range loop,
and having go automatically processed the
386:04 - closed channel for us, we're going to process
this manually. So let me paste in this example
386:09 - and show you so notice that I'm in a for loop
in this go routine, and I don't have any conditions
386:14 - on it. So this is going to execute forever.
Down here, then I'm receiving a message from
386:19 - the channel, and I'm using the comma. Okay,
syntax. So I'm going to get the value from
386:24 - the channel and I and I'm going to get a Boolean
letting me know if the channels open or not
386:28 - in the okay variable. So if the channel is
open, then okay is going to be true. If the
386:33 - channel is closed, then Okay, it's going to
be false. So the happy path, if okay is true,
386:37 - then I'm going to go ahead and print out my
message. Otherwise, I'm going to break out
386:41 - of this for loop here, because the channels
closed, and I'm not going to be receiving
386:45 - any more messages from it. So this is functionally
exactly the same as the four range construct.
386:51 - But we're explicitly seeing this comma, okay,
syntax. So which one would you use?
386:56 - Well, in this situation, it would make more
sense to use the for range construct. But
387:00 - there may be situations where you're receiving
data from a channel, and you're not in a loop.
387:05 - So maybe you're spinning off a new go routine
for every time you're processing a message.
387:09 - And so the loop is going to contain the spinning
off of the go routines. And so you're going
387:14 - to need this comma, okay syntax, because it
might not make sense to use the for range
387:18 - loop. Now, the last thing that I want to talk
about in this video are what are called SELECT
387:22 - statements. So let me go ahead and paste in
this code here. So we talked about in the
387:28 - last video, how there can be situations where
you create go routines that don't have an
387:33 - obvious way to close. And that's what I want
to try and illustrate here. So if I go ahead
387:37 - and run this, we see that we do get these
messages printed out. So I'm just doing a
387:42 - simple logger implementation. So what you
see here is I've got some constants that are
387:47 - declaring my log level, I've got a struct
that I've declared the holding the timestamp
387:51 - for the login tree, the severity of the log
level, and then whatever message I'm trying
387:55 - to print out, then I'm creating a log channel.
And the way this application works, is the
388:00 - first thing the main function does is it spins
up this go routine, that's going to be my
388:03 - logger. And what it's going to do is it's
simply going to monitor that log channel for
388:09 - log entries that are coming from throughout
my application. So the idea is I've got a
388:13 - central logger, and anything that could do
logging in, my application just needs to know
388:17 - about this channel. And all of my logging
logic can be hidden within the processing
388:21 - of those log channel messages. So the logger
is down here, we've got a four range loop
388:26 - that's listening for messages from the log
channel. And all it's doing is it's printing
388:30 - out a formatted message that's got the timestamp,
it's got the log level, and it's got the message
388:35 - from the log. So no big deal here, nothing
terribly exciting. Then my main function goes
388:40 - on to exercise that a little bit, it sends
two messages into the log channel, one letting
388:45 - it know that the application is starting another
one letting the application note shutting
388:48 - down. And then I've got a sleep call here
just to make sure that the logger co routine
388:52 - has enough time to process that. Now you notice
my timestamps are a little funny here. That's
388:57 - because I'm working with the playground, I
promise you this code does work. If you shifted
389:01 - over to Visual Studio code, you will actually
get real timestamps. But for some reason,
389:05 - the playground doesn't give you the current
time when you call the now function. And so
389:10 - this is just something that we're going to
have to work with in this example. Now the
389:13 - problem I want you to consider is when does
the logger go routine closed down. So obviously,
389:20 - the logger go routine has to terminate sometime
because the program finishes execution, and
389:24 - we get the results back from the playground.
So what's happening here is remember, an application
389:30 - is shut down as soon as the last statement
of the main function finishes execution. So
389:37 - when we finish this sleep call here, the application
terminates and everything is torn down and
389:43 - all resources are reclaimed as the go runtime
returns all of the resources that it was using
389:49 - back to the operating system. So what that
means is that our logger go routine is being
389:54 - torn down forcibly. There's no graceful shutdown
for this go routine. It's just being ripped
389:59 - out because the main function has done. Now
in some situations like this one that may
390:03 - be acceptable. But there are many situations
where you want to have much more control over
390:07 - a go routine. Because remember what I said
in the go routine video, you should always
390:12 - have a strategy for how your go routine is
going to shut down when you create your go
390:16 - routine. Otherwise, it can be a subtle resource
leak, and eventually, it can leak enough resources
390:22 - that it can bring your application down. So
there's a couple of different things we could
390:25 - do here, right, we could of course, do a defer
call here, we can pass in an anonymous function.
390:31 - And inside of that, we could go ahead and
close the log channel. So what that's going
390:35 - to do is when the main function exits, it's
going to go ahead and close the channel, and
390:40 - then we are gracefully shutting down that
channel. And that works just fine. There's
390:43 - no issues with that we are intentionally closing
down the channel, we know how our go routine
390:48 - is going to close. And so this is perfectly
acceptable in this use case. But this isn't
390:54 - what I want to show you. So this is certainly
something you could use in this use case.
390:57 - But I want to show you another way that very
commonly used in these kinds of situations.
391:02 - So the way that I want to show you is using
what's called a select statement. So let me
391:06 - go ahead and paste in that code. And we'll
walk through that. So the application
391:10 - is basically the same, I've got the same constants
have here, I've got the same struct, I do
391:14 - have this additional channel here. And notice
the type signature for it. So it's strongly
391:19 - typed, but it's strongly typed to a struct
with no fields. Now struct with no fields
391:24 - in the go language is unique in that it requires
zero memory allocations. So a lot of times
391:29 - you will see a channel set up like this. And
the intention is it can send any data through
391:35 - except for the fact that a message was sent
or received. So this is what's called a signal
391:41 - only channel. There's zero memory allocations
required in sending the message. But we do
391:46 - have the ability to just let the receiving
side know that a message was sent. So this
391:52 - is pretty common, you might be tempted if
you're new to the language, like I first did
391:56 - you send a Boolean in here. But that does
actually require a variable to be allocated
392:01 - and copied. So it is actually better to use
an empty struct because it saves a couple
392:06 - of memory allocations. It's a little bit minor.
But it is something that if you are going
392:10 - to use a channel as a pure message, then you
might as well go with the conventions and
392:14 - use this approach. So our main function is
exactly the same as it was before. We've got
392:18 - our logger, we've got our log channel, sending
in a couple of messages. And then we got a
392:22 - sleep call here. And then inside of our logger
function, we've got an infinite loop now,
392:27 - and we're using this select block. So what
this SELECT statement does is the entire statement
392:33 - is going to block until a message is received
on one of the channels that it's listening
392:38 - for. So in this case, we've got a case listening
for messages from the log channel, and the
392:42 - case listening for messages from the done
channel. So if we get a message from the log
392:47 - channel, then we're going to print out our
log entry. If we get a message from the done
392:50 - channel, then we're going to go ahead and
break out of this for loop. So what this allows
392:55 - us to do is at the end of our application,
we can go ahead and pass in a message into
393:01 - our dumb channel. And that is going to be
an empty struct. And I'm just going to define
393:07 - that empty struct on the fly here. So this
is a little bit confusing syntax. But this
393:11 - is the type signature for my struct. So I'm
defining a struct with no fields. And then
393:16 - I'm initializing that struct using these curly
braces here. So if I go ahead and run this,
393:20 - you see that the application runs properly.
So I do process my log messages. And then
393:25 - I pass in this message into my done channel
when I wish the logger to shut down. So this
393:30 - is a common situation for you to use when
you're monitoring channels. And you need a
393:36 - way to have the go routine that's monitoring
those handles be able to terminate. So very
393:40 - often you're going to send in normally as
a parameter, you're going to send in this
393:44 - done channel. And then whatever's ready to
kill the go routine, will go ahead and send
393:48 - a message into that done channel. And it'll
go ahead and kill it. Now one more thing that
393:53 - I do want to talk about. And I'm not going
to actually run it because it's going to break
393:56 - our application here. But you can have a default
case here. And if you do, then this no longer
394:02 - becomes a blocking SELECT statement. So what
this is going to do is if there's a message
394:07 - ready on one of the channels that are being
monitored, then it's going to execute that
394:11 - code path. If not, it will execute a default
block. So this is useful. If you want to have
394:16 - a non blocking SELECT statement, then you
need to have that default case in there. If
394:20 - you don't have the default case, then the
select statement will block forever until
394:24 - a message does come in. Okay, so that's what
I have to talk about with channels. Let's
394:28 - go into a summary and review what we've talked
about. In this video, we talked about channels
394:33 - and how we can use them to synchronize data
transmission between go routines. We started
394:39 - out by talking about the basics of working
with channels. And we learned that we can
394:42 - make our channels using the built in make
function and how that's really the only way
394:46 - that we have available in the go routine to
make a channel. When we do make those channels,
394:51 - those channels are strongly typed. So we're
going to use the chain keyword to indicate
394:55 - that we wish to create a channel and then
we have to follow that with the data type
394:59 - that the channel is going to be Send and Receive.
Now that data type can be anything, it can
395:03 - be a primitive like we see here with an integer,
it can be a struct, it can be an interface.
395:07 - But it does have to be strongly typed, we
can send a message into the channel using
395:11 - this arrow syntax. And the position of the
arrow kind of indicates the direction that
395:16 - the data is going to flow. So in this case,
we list channel, we have the arrow and then
395:20 - the value that we wish to send into the channel.
So notice that the arrow is pointing into
395:24 - the channel. But when we went to receive messages
from the channel, then the arrow is leading
395:29 - out of the channel. And so we're going to
use the same arrow syntax, but the channel
395:33 - is going to be added after the arrow instead
of before. And we can have multiple senders
395:38 - and receivers. As a matter of fact, it's very
common. As a matter of fact, it's very common
395:42 - for one channel to be distributed among multiple
go routines. And that way, you can have multiple
395:47 - data generators that are sending messages
into the channel, as well as multiple data
395:52 - receivers. And that allows you to balance
the performance between senders and receivers.
395:57 - So if you can generate data 10 times as fast
as you can process it, then you can create
396:01 - 10 times as many receivers. And that way you
can balance the workload out between senders
396:06 - and receivers.
396:07 - We then talked about how to restrict data
flow. Buying default, channels are bi directional
396:12 - constructs, so you can send and receive data
into a channel. Now very often what we want,
396:17 - though, is our go routines to be designed
to handle channel data only in one direction.
396:23 - So we saw that we can do that by passing in
the channel. But then on the receiving side.
396:29 - So for example, in the argument list of the
function, we can actually specify the direction
396:33 - that we can work with by again adding that
arrow, and we either add it before or after
396:38 - the chain keyword. Depending on what kind
of channel that we want to make, we can make
396:41 - a send only channel by putting the arrow after
the chain keyword, and we can make a receive
396:46 - only channel by adding the arrow before it.
We then talk about buffered channels, and
396:50 - how buffered channels contain internal data
stores that allow us to get around this limitation
396:56 - of channels that by default, a channel will
block the sender side until a receiver is
397:01 - available, and the receiver side will be blocked
until a message is available to come out of
397:05 - the channel. So you can actually block a go
routine on the sending side or the receiving
397:09 - side of the channel. So if there's no position
available in the channel to add the message,
397:14 - then the sending side will be blocked until
a space does become available. And if there's
397:18 - no message in the channel, then the receiving
side is going to be blocked until a message
397:22 - becomes available for it to work with. So
in order to decouple that we can add an integer
397:28 - as a second argument to the main function.
And that's going to allow the channel to have
397:32 - an internal buffer to decouple your senders
and receivers, just in case there are situations
397:37 - where data is generated faster than it's received.
So just like it says here, we want to use
397:41 - buffered channels when sending and receiving
have asymmetric loading. So if we can generate
397:46 - messages faster than we can receive them,
then a lot of times a buffered channel is
397:50 - a really good way to go. We then moved on
to talk about four range loops, and specifically
397:54 - how to work with them with channels. And we
learned that they basically work the same
397:58 - way. But there are a couple of subtle differences.
The first thing is the first parameter that
398:03 - you're going to receive from the four range
loop when working with channels is the value
398:07 - itself, not the index, like we saw when we
were using for range loops over arrays, slices
398:12 - and maps. And we saw how we can use for range
loops to monitor channel and process messages
398:17 - as they arrive. So the four range loop is
just going to keep pulling messages as they
398:21 - come in off the channel. And it'll process
them as they come. Then when the channel gets
398:26 - closed, the four range loop is going to detect
that and it will go ahead and exit the loop.
398:30 - And finally, we talked about SELECT statements,
and how they work kinda like switch statements,
398:35 - but they work only in the context of channels,
and how they allow a go routine to monitor
398:39 - several channels at the same time. Now if
they block if all channels are blocked, so
398:44 - if there's no messages available on any channel,
then the select statement will block by default.
398:49 - And then when a message comes in, it will
go ahead and process that on the proper case.
398:53 - If multiple channels receive value simultaneously,
then the behavior is actually undefined. So
398:59 - because of the highly parallel nature of many
go applications, you can get into situations
399:03 - where messages arrive on two channels at virtually
the same time. So one of those cases will
399:08 - get the nod from the Select block, but you
can't be sure of which one's going to get
399:12 - it. So there is no rule like in switch block
where the first one that matches is going
399:16 - to get it, it could be anyone. So the ordering
of the cases in your SELECT statements really
399:21 - doesn't matter from the standpoint of how
those conflicts are going to get resolved.
399:25 - Now if you do want a non blocking SELECT statement,
remember that you can add that default case
399:30 - in there. So if there are no messages on any
of the monitored channels, then the default
399:35 - case will go ahead and fire and so the select
statement will process and execution of the
399:39 - go routine will continue from there.
399:41 - Okay,
399:42 - so that wraps up what I have to talk about
with channels. And really it brings us to
399:45 - the end of the discussion that I have for
this introduction to go series for now. This
399:51 - is Mike vansickle wishing you luck in all
of your gopher endeavors.
399:53 - Take care