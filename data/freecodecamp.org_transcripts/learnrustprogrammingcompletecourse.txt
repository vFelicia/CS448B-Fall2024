00:00 - welcome to this rust programming course
00:02 - for beginners this comprehensive course
00:04 - will guide you step by step through the
00:06 - fundamentals of rust enabling you to
00:09 - build robust and efficient applications
00:10 - from understanding basic syntax and data
00:13 - types to exploring more advanced topics
00:16 - like lifetimes and closures arfan zubi
00:19 - will provide clear explanations and
00:21 - Hands-On exercises to ensure you grasp
00:23 - every concept effectively get ready to
00:26 - unlock the power of rust and elevate
00:28 - your programming skills to new heights
00:30 - hi my name is Irfan and I will be your
00:33 - guide in this comprehensive for us
00:35 - course for beginners so if you're
00:38 - interested in learning rust then
00:40 - congratulations you have found the right
00:42 - course
00:43 - so I've designed this course to ensure
00:46 - that you will learn rust the proper way
00:48 - using slides and visuals to illustrate
00:51 - Concepts and providing exercises we will
00:55 - solve together this means you will have
00:57 - an appropriate mix of theory and
01:00 - practice that will help you step by step
01:02 - mastering this new awesome programming
01:05 - language
01:06 - and I strongly advise you to code along
01:09 - because you will learn so much more when
01:12 - actively participating rather than just
01:15 - watching the video
01:16 - so let's Dive In
01:20 - so what are the goals of this course
01:22 - first and foremost getting familiar with
01:25 - Core Concepts and syntax of the language
01:28 - we will take a look at data types and
01:31 - data structures as well as ownership and
01:35 - borrowing we will see how data is
01:37 - allocated in memory and how we access
01:39 - the data and we'll take a look at
01:42 - standard Library generics trades
01:45 - lifetimes and much much more basically
01:48 - everything you need to become a great
01:50 - rust developer
01:54 - so why would you want to learn rust now
01:58 - there would be I guess a thousand
02:00 - reasons but I have here put together
02:03 - some of the main ones now rust is a
02:07 - really fast language in terms of
02:09 - execution time it provides a rich type
02:12 - system it doesn't have a garbage
02:15 - collector which is part of the reason
02:17 - why it's so fast
02:19 - it provides useful compiler outputs and
02:23 - you will see that in the exercises we
02:25 - are solving it guarantees memory safety
02:29 - and it's the most beloved programming
02:31 - language since 2016 according to stack
02:35 - overflow meaning now seven years in a
02:38 - row and we are experiencing fast
02:41 - adoption in various branches
02:45 - foreign
02:46 - now over here you can see a table which
02:49 - shows various programming languages and
02:51 - their score in terms of Energy
02:53 - Efficiency and execution time and as you
02:58 - can see rust is one of the languages on
03:01 - the top of the list
03:04 - now over here are some resources that
03:07 - you can learn with now I guess the main
03:10 - resource would be the RAS programming
03:12 - language
03:13 - really fantastic book and I recommend
03:15 - you to read it then there is rustlings
03:18 - these are small exercises basically
03:21 - programs which you have to debug
03:24 - then there is Ross by example so if your
03:27 - style is more focusing code and less on
03:30 - text then this would be suitable for you
03:34 - and there is a website called rust by
03:37 - practice and that is what we will cover
03:40 - together
03:42 - and if you want to go more advanced
03:44 - there is a book called Russ forestations
03:46 - and it's also very much recommended to
03:50 - eat it
03:54 - so before we dive into the first topic I
03:57 - want to show you the website of lost by
04:00 - practice and you can access it by going
04:03 - to the URL practice dot RS
04:07 - and this is the website
04:11 - and over here as you can see these are
04:14 - all the topics we will cover together
04:17 - right now this will be the first one
04:21 - variables
04:23 - and as you can see over here we have
04:25 - small exercises that we will solve
04:28 - together
04:30 - now before we start I want to show you
04:33 - something else and of course we'll keep
04:36 - up with the tradition and write a hello
04:39 - world program
04:41 - so you can go to the
04:44 - rustlang.org website this is the
04:46 - official website of the rust foundation
04:50 - and you can click over here playground
04:55 - and as you can see over here you can
04:58 - write rascode and then execute it
05:02 - and it's really cool because you even
05:04 - have the Vim key bindings over here and
05:08 - you can even choose themes
05:11 - like that
05:16 - and let's write our first program so
05:22 - every program in Rust starts in the main
05:27 - function this is the starting point of
05:30 - execution of every rust program
05:34 - and we declare functions with the FN
05:37 - keyword
05:38 - so to print out to standard output we
05:41 - can use the print line macro
05:45 - as you can see we write print Ln
05:48 - exclamation mark and then we can provide
05:51 - here the string we want to Output
05:56 - like that
05:59 - and then you can hit run
06:05 - and as you can see we have executed our
06:09 - first program so congratulations I hope
06:13 - you coded along and now we start with
06:17 - the actual course
06:20 - so variables variables are assigned
06:24 - using the LED keyword so if you're
06:26 - coming from a JavaScript background this
06:28 - might seem familiar
06:30 - you can print to standard output by the
06:33 - print or print Ln macros
06:37 - so print and print Ln are basically very
06:41 - much the same but print Ln adds a new
06:44 - line at the end of the output
06:48 - and scope of a variable is defined by
06:52 - the block of code in which it is
06:54 - declared
06:55 - now a function is a named block of code
06:58 - that is reusable
07:01 - and shadowing allows a variable to be
07:03 - redeclared in the same scope with the
07:06 - same name
07:08 - so let's solve some exercises
07:12 - binding and mutability a variable can be
07:16 - used only if it has been initialized
07:20 - fix the arrow below with least amount of
07:23 - modification to the code
07:25 - so again we are starting always in the
07:29 - main function
07:30 - now over here we have two variables
07:34 - and again we declare variables with the
07:37 - let keyword then the name and over here
07:41 - we have a type annotation now don't
07:45 - worry too much for now we'll cover that
07:47 - in the next topic to come but for now
07:50 - think of i32 as an integer type
07:55 - right
07:57 - and then we have here the assert EQ
08:01 - macro which stands for assert equality
08:05 - so this macro takes two arguments and
08:08 - just basically asserts that these two
08:11 - are equal
08:13 - in case they are not equal the program
08:15 - will Panic meaning immediate exiting and
08:20 - returning an error message
08:24 - if there are in fact equal then the
08:27 - program will just continue executing
08:30 - so as you can see we want here that X is
08:33 - equal to a value of 5 so we can
08:37 - initialize X over here with with a value
08:40 - of 5 like that
08:45 - and to run this program you can either
08:48 - click here or you can press Ctrl enter
08:55 - and let's read that over here
08:57 - uninitialized but used error
09:00 - so when you use a variable it has to be
09:04 - initialized with a value which makes
09:06 - sense right you can't use something
09:09 - which isn't initialized yet
09:12 - now y over here is uninitialized but
09:15 - also unused this will only output a
09:19 - warning now over here you can see the
09:22 - warning actually
09:23 - but if I take this code and put it over
09:27 - here
09:30 - as you can see it gives us a warning
09:32 - unused variable y
09:36 - okay to fix that we can prepend it with
09:39 - an underscore
09:42 - like that
09:47 - all right
09:48 - use mute to Mark a variable as mutable
09:52 - so in Rust a variable in its nature is
09:57 - immutable and you have to explicitly
10:00 - state that you want a variable to be
10:02 - mutable
10:04 - so fill the blanks in the code to make
10:06 - it compile as you can see we are here
10:10 - using a variable X so we want over here
10:13 - to declare X and initialize it with a
10:18 - value of 1.
10:20 - now over here we are mutating X which
10:25 - means this variable X over here should
10:28 - be mutable and we do that using the mute
10:31 - keyword like that
10:34 - now this over here
10:37 - is shorthand Syntax for this
10:43 - all right so we take the value of one
10:46 - we add 2 to it and then we assign it
10:50 - back to X meaning X will then hold 3.
10:54 - right now
10:56 - just a quick note I will always try to
11:00 - annotate the type in this course most of
11:03 - the time it's not necessary so when you
11:06 - see me annotating types it's actually
11:09 - not because this is necessary but just
11:13 - because I want to make stuff as clear as
11:16 - possible so in this case this would hold
11:20 - an integer type and again we will cover
11:23 - that in the next topic
11:25 - let's see
11:30 - as you can see this is compiling X is
11:33 - equal to 3.
11:36 - scope a scope is the range within the
11:39 - program for which the item is valid
11:42 - fix the error below with least amount of
11:45 - modification
11:47 - so over here we are initializing the
11:50 - variable x with a value of 10.
11:53 - an integer type all right
11:58 - now
12:01 - now here we have another scope we also
12:04 - can call it the inner scope and this
12:06 - would be the outer scope right so in
12:10 - this scope over here we are declaring
12:12 - another variable y now
12:17 - we over here try to print out X and Y
12:20 - and we can do that by placing inside the
12:25 - print Ln macro these placeholders over
12:28 - here
12:29 - and then providing as additional
12:33 - arguments over here the variables we
12:36 - want to put the values inside here
12:39 - so for example if we provide X over here
12:42 - then this will get replaced by 10
12:46 - because X is holding a value of 10.
12:51 - and as you can see in the outer scope we
12:54 - are doing exactly the same
12:56 - now this program won't compile
13:00 - and the reason is because a variable is
13:05 - only valid inside the scope in which it
13:09 - was declared so for example the variable
13:12 - Y is declared inside the scope meaning
13:17 - T variable Y is only valid until this
13:21 - point
13:23 - all right that means we can't use y here
13:27 - so what would be the solution
13:30 - solution would be very simple we just
13:33 - initialize the variable y in the main
13:37 - scope in the outer scope over here
13:39 - meaning X and Y both of them are valid
13:43 - until this point over here
13:46 - right because this over here is the main
13:50 - scope
13:52 - let's see
13:55 - as you can see this is compiling
14:00 - fix the error with the use of Define X
14:04 - now we can have other functions besides
14:08 - main so over here we have the function
14:10 - define X
14:12 - and as you can see we are initializing a
14:17 - variable X which holds a string
14:20 - now this would be
14:22 - T-Type annotation for a string
14:26 - right don't worry too much about the
14:29 - annotations now because we will cover
14:31 - that but just to let you know now the
14:36 - problem here is that in main we are
14:40 - trying to access X now in this scope
14:43 - over here there is no variable with the
14:46 - name of X which means that this program
14:50 - won't compile because the compiler will
14:53 - tell you I can't find over here a
14:56 - variable with the name of X so what we
14:59 - can do over here is actually taking this
15:02 - line and putting it inside the function
15:05 - over here because as you can see in this
15:08 - scope of the function a variable X has
15:12 - been declared and initialized
15:16 - but if I run this program now
15:21 - nothing will happen
15:23 - and that's because as I've said the
15:26 - starting point of every Ras program is
15:28 - in the main function now
15:31 - when we run the code nothing will get
15:35 - executed
15:36 - and that's because we have to actually
15:39 - call this function for it to do
15:42 - something so in this case
15:45 - we can call a function like that
15:49 - just providing the name of the function
15:52 - and these parentheses
15:58 - and as you can see the output will be
16:01 - hello world right because over here we
16:05 - are
16:06 - providing x to the print line macro and
16:10 - we are appending to it comma world
16:14 - like that
16:17 - shadowing you can declare a new variable
16:20 - with the same name as a previous
16:22 - variable here we can say the first one
16:24 - is shadowed by the second one
16:28 - only modify a sort EQ to make print Line
16:31 - work print 42 in terminal as you can see
16:36 - over here we are initializing the
16:38 - variable X which holds an i32 type
16:42 - an integer type
16:45 - now in this scope over here we are
16:48 - initializing another variable with the
16:52 - same name X but over here we are
16:55 - initializing it with a value of 12
16:57 - instead of 5.
17:00 - and that means when we assert the value
17:04 - of x over here it should actually be 12
17:07 - right
17:09 - now what would be the value of x in this
17:14 - outer scope
17:18 - if you set 5 then you're right
17:21 - because
17:24 - this variable over here has been
17:26 - declared in the main scope in this scope
17:29 - over here that means X is holding a
17:32 - value of 5. now in this scope over here
17:36 - x holds a value of 12.
17:39 - and these are basically two different
17:43 - worlds right so the variable X declared
17:47 - in the main scope doesn't actually care
17:49 - about the variable X declared in this
17:52 - scope over here
17:54 - they are separate
17:56 - now over here we are shadowing X in the
18:01 - main scope meaning we re-declare and
18:04 - re-initialize the variable X again with
18:08 - an integer type
18:11 - now when we output X it should actually
18:14 - print out 42.
18:21 - as you can see this will be the output
18:25 - number six remove a line in the code to
18:28 - make it compile now over here we have a
18:32 - mutable variable X which holds one
18:37 - an integer type then we are assigning 7
18:42 - to X now X holds
18:45 - seven right
18:47 - then we are shadowing and rebinding so
18:50 - we are re-declaring X and
18:53 - re-initializing it and we initialize it
18:56 - with
18:58 - a value of x meaning with 7 right
19:04 - and then over here we are mutating X
19:09 - and that means we are here incrementing
19:13 - x by 3.
19:16 - again using this front end notation
19:18 - which would equate to that
19:22 - and
19:25 - this would actually fail and I want you
19:28 - to look at it and think about it what
19:32 - over here might cause an error
19:37 - so over here as you can see we are
19:40 - re-declaring X
19:42 - and over here we are mutating X now as
19:46 - I've said every variable in Rust is in
19:50 - its nature immutable meaning if we
19:53 - redeclare X like that X will be
19:56 - immutable even if it was mutable over
19:59 - here when we Shadow it then it will be
20:02 - immutable again so what we can do over
20:05 - here is just using
20:08 - the mute keyword again so X stays
20:12 - mutable
20:15 - now
20:18 - you might ask okay why even shadowing we
20:22 - can just assign a new value to X why is
20:25 - this even a thing
20:27 - and you can see that here very good so y
20:32 - over here holds an integer type right
20:36 - integer 4. now when shadowing we can
20:40 - assign to the variable a a value of
20:45 - another type in this case for example a
20:48 - string right so y will then hold a
20:52 - string type
20:56 - right let's run that
20:59 - and as you can see this compiles now
21:02 - this line over here is completely
21:04 - useless I hope you notice that because
21:07 - we are taking X and assign it again to X
21:10 - which basically is the exact same thing
21:13 - as we had over here so completely
21:16 - useless of course they are doing that to
21:19 - learn the concept
21:20 - but in real life you don't need this
21:23 - line all right you can just do it like
21:26 - that
21:27 - and as you can see this also compiles
21:32 - unused variables fix the warning below
21:34 - with only one solution two distinct
21:37 - Solutions so as you can see of course we
21:40 - want two stores so we will do with two
21:44 - solutions
21:45 - now the problem here is that this
21:48 - program won't actually output warnings
21:51 - right so I will again copy that
21:55 - and I will put it
21:59 - and I will put it inside the rust
22:02 - playground
22:04 - like that so if we run this program now
22:10 - as you can see we get a warning unused
22:13 - variable X now I have showed you that
22:16 - before the easiest method would be to
22:19 - prevent the variable name with an
22:21 - underscore
22:23 - as you can see we don't get the warning
22:26 - over here the second way would be to do
22:30 - it like that
22:32 - this is
22:34 - telling the compiler that it should
22:37 - allow
22:40 - unused variables
22:43 - so if you run it again
22:45 - as you can see no warning
22:50 - so we have solved that
22:53 - destructuring we can use pattern with
22:56 - lead to destructure a tuple to separate
22:59 - variables
23:01 - now tuples we will cover that in a later
23:04 - topic
23:05 - but for now just think of tuples as a
23:09 - data structure that can hold
23:13 - um various values even of different
23:16 - types
23:17 - so fix the arrow below with least amount
23:21 - of modification
23:24 - so as you can see over here we have a
23:27 - tuple right holding two integers one and
23:31 - two and this over here is called
23:34 - destructuring so we are using the let
23:37 - keyword and we use this syntax over here
23:41 - to this structure these values into
23:45 - variables X and Y so X will then hold a
23:50 - value of 1 and y will hold a value of 2.
23:53 - now over here we are mutating X
23:58 - now again
23:59 - this variable here would be immutable
24:02 - because in Rust every variable in its
24:05 - nature is immutable and we have to
24:08 - explicitly state that we want to have it
24:11 - mutable
24:12 - so what we can do over here like we did
24:15 - before we use the mute keyword
24:18 - like that and then this should actually
24:22 - compile so X holds one here and then we
24:26 - increment X by two so extrude in the
24:30 - nthole 3 and Y should stay the same as
24:34 - it was
24:39 - and as you can see this is compiling the
24:42 - structuring assignments introduced in
24:45 - Rust 1.59 you can now use Tuple slice
24:49 - and struct patterns as the left hand
24:51 - side of an assignment
24:54 - so this is very useful actually
24:58 - so we can declare two variables at once
25:02 - so here we declare X and Y and this
25:05 - would be the same like writing let X and
25:09 - let y
25:11 - right so you're writing one line of code
25:14 - instead of two lines here
25:21 - now again we declare here the variables
25:24 - and we can then
25:26 - destructure these data structures over
25:30 - here so we have here a tuple and we are
25:33 - destructuring it and notice over here we
25:36 - don't need to use the let keyword again
25:39 - because we have already declared these
25:42 - variables over here
25:44 - right
25:45 - so we assign 3 to X and this value over
25:51 - here we don't care about so we can use
25:54 - these double dots over here
25:57 - now this over here is an array and again
26:01 - we will cover that don't worry and this
26:05 - array holds two values now we don't care
26:08 - about the first one but we want to
26:11 - destructure the second one into a
26:13 - variable called y
26:16 - now fill the blank to make the code work
26:20 - in this case we have here an array right
26:24 - remember assert EQ takes two arguments
26:27 - and both of them have to be the same
26:30 - equate to the same output right so what
26:35 - would be the value of x
26:40 - it would be 3. because we have this
26:43 - structured here 3 into the variable X
26:46 - and the same goes for here we have this
26:49 - structured 2 into a variable Y which
26:54 - means y will then hold two
27:00 - all right and we are done with the first
27:03 - topic easy start and see you next time
27:08 - now let's look at numbers in Rust and
27:11 - we'll start with integer types
27:14 - now an integer is basically a whole
27:17 - number meaning it doesn't have a
27:20 - fractional part
27:22 - and integers can come in two different
27:25 - forms they can either be signed or
27:28 - unsigned now a signed integer can
27:31 - represent both positive and negative
27:34 - numbers
27:35 - and I remember that because signed might
27:38 - stand for the minus sign that could be
27:41 - prepended to it
27:43 - and unsigned integers are always
27:46 - positive integers meaning they don't
27:49 - have a minus sign hence unsigned
27:53 - now integers can come in different
27:56 - lengths so there can be 8-bit integers
28:00 - 16-bit 32 up until
28:04 - 128 bits and each length over here has
28:10 - two distinct types one for signed and
28:15 - one for unsigned so for example if we
28:18 - have a variable which holds an unsigned
28:21 - 8-bit integer we would type annotate
28:24 - that with the type u8
28:27 - or for example we have a signed 64-bit
28:30 - integral we would annotate it as i64.
28:35 - now the last element in the table over
28:38 - here is Arc and Arc stands for
28:41 - architecture now that means that the
28:44 - size of these two types eye size and U
28:47 - size are dependent on the computer's
28:50 - architecture now I guess most of you
28:53 - guys today run computers with 64-bit
28:57 - architecture meaning Isis new size have
29:01 - a size of 64 bits or 8 bytes
29:07 - All Right Now the default types in Rust
29:12 - are for integers i32 and for floats f64
29:17 - so if we don't annotate anything the
29:20 - compiler will infer it to these types
29:26 - now my head is in the way
29:31 - now to make sense of all of this you
29:34 - will have to understand the binary
29:36 - number system
29:38 - now if you're familiar with binary just
29:40 - skip ahead because you don't learn
29:42 - anything new here but I just want to
29:45 - ensure that we are all on the same page
29:48 - so if we consider this decimal number
29:52 - over here 42
29:54 - and let's look at each distinct digit so
30:00 - we would have 4 and we would have two
30:02 - right
30:04 - now 2 would be in the ones place and
30:08 - four would be in the tenths place
30:11 - and if we would have more digits here
30:13 - here would be the hundreds place
30:15 - thousands place and so on
30:18 - now
30:20 - as you can see we are here using a base
30:22 - of 10. why is that because in the
30:26 - decimal system we have 10 distinct
30:29 - digits to represent numbers right 0 to
30:33 - 9. and as you can see we are here doing
30:37 - an exponentiation with an exponent of
30:41 - zero because this is actually a
30:44 - mathematical rule which states that
30:46 - anything with an exponent of 0 will
30:49 - always evaluate to one so it doesn't
30:53 - matter which base you use if you have an
30:56 - exponent of 0 the result will always be
30:59 - one right 10 to the power of 0 would be
31:02 - 1 4 to the power of 0 would be one and
31:05 - so on
31:07 - and over here we have 10 to the power of
31:09 - 1 which would be 10 right and then what
31:13 - we do is just we are multiplying the
31:17 - digits of our number with these
31:21 - exponentiations right so we would for
31:25 - example here 4 times 10 to the power of
31:27 - 1 plus 2 times 10 to the power of 0.
31:32 - now again 10 to the power of 1 would be
31:34 - 10 and 10 to the power of 0 would be one
31:38 - and then we would multiply these numbers
31:41 - together and then add this and we would
31:44 - have 42 right something which is very
31:48 - natural to you and you don't even think
31:50 - about it right because decimal numbers
31:54 - are everywhere now in computers things
31:58 - actually look a little bit different
32:01 - let's for example again consider the
32:03 - decimal number 42 now this would be the
32:07 - binary representation of this number
32:09 - zero zero one zero one zero one zero
32:14 - and as you can see we have here eight
32:18 - digits now a digit is called bit right
32:24 - and a bit is the smallest possible unit
32:27 - of information a computer can hold okay
32:34 - now we have eight bits over here and
32:37 - eight bits make up one byte
32:40 - and we over here have actually the same
32:43 - logic as we did over here but with a
32:46 - base of two because again we can only
32:50 - represent two digits in a computer and
32:54 - that's because a transistor can only be
32:56 - in one of two states either it's
32:59 - conducting electric current or it's
33:02 - non-conducting zero or one
33:06 - right so
33:09 - the logic stays the same here we have 2
33:13 - to the power of 0 which would be one
33:15 - because of the rule we have talked about
33:17 - 2 to the power of 1 would be two two to
33:20 - the power of 2 would be four two to the
33:23 - power of 3 would be eight and so on and
33:25 - as you notice the number here doubles
33:28 - one two four eight sixteen and so on
33:33 - now
33:35 - this over here is actually the
33:37 - fascinating part about computers to me
33:39 - personally because it's just crazy if
33:43 - you think that everything
33:45 - represented this video over here and
33:49 - graphical models and 3D games and
33:52 - everything is stored and represented
33:55 - with only two digits
33:58 - mind-blowing right
34:01 - so
34:02 - we actually here do the same thing we
34:05 - are just multiplying
34:07 - the bits over here with the
34:10 - exponentiations
34:12 - now we won't consider the zero bits
34:16 - because anything multiplied by zero will
34:19 - always be zero right so we are just
34:23 - caring about the one bits over here so
34:26 - we are multiplying one times two to the
34:28 - power of one which would be 2 right
34:32 - because 1 times 2 would be two then one
34:36 - times two to the power of 3 which would
34:38 - equate to 8 and 1 times 2 to the power
34:42 - of 5 which would be 32 as you can see
34:45 - over here and then we are basically just
34:49 - adding these numbers together and we
34:51 - have 42 and this is the way your
34:55 - computer stores all of your data
34:59 - all right
35:00 - now you might ask okay how far can we go
35:05 - with this what would be the largest
35:08 - possible number we can represent
35:11 - and let's for that see the range of
35:13 - 8-bit integers
35:16 - so the smallest possible unsigned 8-bit
35:19 - integer would be zero right I hope this
35:22 - makes sense because if we have a zero in
35:25 - every position over here the result will
35:28 - just be zero right now the largest
35:31 - possible unsigned 8-bit integer would be
35:35 - 255.
35:38 - and that's the case when every single
35:41 - position over here holds A1 right and
35:45 - again we are then just multiplying D1 by
35:49 - the exponentiations over here and add it
35:52 - together
35:54 - and you might now think okay 255 isn't a
35:59 - lot what if I want to represent bigger
36:02 - numbers and there is a simple solution
36:04 - to that
36:05 - you're just adding more bits over here
36:08 - right because the more bits we have the
36:11 - larger number we can represent
36:14 - so let's see for example a 16 bit
36:18 - integer again the smallest possible
36:22 - 16-bit integer unsigned would be zero
36:27 - and this is if every position over here
36:29 - holds zero
36:31 - now the largest possible 16-bit integer
36:34 - unsigned would be 65
36:39 - 535 okay and again this would just be if
36:44 - we had in every single position a one
36:49 - right again just adding the results of
36:53 - the exponentiations over here all
36:56 - together and we would have this result
37:00 - now as you can see the more bits we have
37:03 - the more we can represent
37:07 - now what about signed integers again
37:10 - sine integers can represent negative
37:13 - numbers
37:14 - so signed integers use a concept called
37:19 - tools complement
37:21 - where the processor will take a number
37:25 - over here
37:26 - for example 42 and this would be the
37:29 - binary representation of this number
37:32 - then it will invert this binary number
37:37 - meaning a 0 becomes a 1 and 1 becomes
37:42 - zero right just inverting
37:46 - and then after inverting the number we
37:49 - add one single bit okay so we add one
37:53 - here this would then equate to zero and
37:57 - we have a carry of one
37:59 - and then we add here one and we would
38:03 - have one and the rest says the same now
38:06 - this would then be the binary
38:08 - representation of minus 42.
38:13 - or negative 42. now the most significant
38:17 - bit over here is actually the sine bit
38:20 - if it is zero then it means the number
38:24 - is positive if it is 1 then the number
38:27 - is negative all right
38:30 - and that's why there are distinct types
38:35 - for
38:37 - signed and unsigned
38:40 - and the ranges for signed and unsigned
38:43 - integers vary right
38:52 - and over here we have an illustration
38:55 - just to see the ranges for example for
38:59 - I8 a signed integral of 8 Bits
39:04 - the range would be from
39:06 - -128 to 127.
39:10 - so the smallest possible number we can
39:13 - represent with a signed 8-bit integer
39:16 - would be
39:17 - -128 and the largest one would be 127.
39:23 - and as you can see again the more bits
39:26 - we have
39:27 - the larger and smaller the integer can
39:32 - go
39:33 - right
39:35 - and again unsigned integers never go
39:39 - below zero
39:44 - right then we have view size and eye
39:48 - size so these are as I've said
39:50 - architecture dependent so on a 32-bit
39:54 - architecture computer
39:57 - the size of these view size and eye size
40:00 - type would be 32 bits
40:03 - on a 64-bit architecture it would be 64
40:07 - bits
40:08 - and this is also called pointer sized
40:11 - integer type because it matches the size
40:14 - of a word in a given platform
40:18 - so what is a word you have to understand
40:21 - that the processor does not read one
40:24 - byte at a time from memory it reads one
40:27 - word at a time
40:29 - so in a 32-bit processor it can access
40:32 - four bytes or 32 bits at a time and in a
40:37 - 64-bit processor it can access 8 bytes
40:41 - or 64 bits at a time
40:46 - now if we look at this very simplified
40:49 - representation of computer memory where
40:53 - we have over here addresses and over
40:56 - here the data
40:58 - and
40:59 - each location over here holds data of
41:03 - one byte all right
41:07 - now in a 32-bit architecture the size of
41:11 - a word is four bytes right 32 bits which
41:16 - means that the processor can access 4
41:19 - bytes at a time so the processor will
41:23 - read
41:24 - this section over here as one word right
41:29 - it's basically unit of data and what you
41:34 - have to take from this is this statement
41:36 - over here
41:37 - you size gives you the guarantee to be
41:40 - always big enough to hold any pointer or
41:44 - any offset in a data structure
41:47 - so the U size type
41:50 - can hold memory addresses which can
41:54 - point to any location in computer memory
41:59 - that's very important
42:02 - so let's see floating point there are
42:05 - two types F32 which is of size 32 bits
42:09 - and f64 which is of type 64 bits now the
42:14 - representation of these floats are
42:16 - according to the IEEE 754 specification
42:21 - so let's look at some exercises
42:26 - tips if we don't explicitly assign a
42:28 - type to a variable then the compiler
42:30 - will infer one for us
42:34 - now remove something to make it work
42:40 - as you can see over here we have a
42:42 - variable X which holds an i32
42:46 - integer right
42:48 - now over here we have immutable variable
42:52 - Y which holds an unsigned 32-bit integer
42:57 - right so over here we are trying to
43:00 - assign X to Y now this would actually
43:04 - fail because we can't assign a variable
43:08 - of a type to a variable of another type
43:12 - it's not possible
43:15 - so what we can do over here to fix that
43:18 - is actually just omitting the type and
43:22 - this will then implicitly hold an i32
43:26 - type right because this is the default
43:29 - integer type in Rust
43:33 - now over here we are initializing in
43:36 - another variable set and what would be
43:39 - the type of Z
43:43 - right it would be I 32.
43:47 - all right
43:51 - thank you
43:52 - fill the blank so over here as you can
43:56 - see we have a value 38 which is of type
44:00 - u8 so we can also annotate a type
44:04 - directly on a value
44:07 - meaning this value over here 38 is of
44:11 - type u8 now the problem here is that the
44:15 - variable over here V expects a type of
44:19 - u16
44:21 - so we can't initialize a variable which
44:25 - expects a certain type with another type
44:28 - but what we can do over here is using
44:31 - the as keyword which basically can
44:34 - convert an integer type to another
44:36 - integer type so we can use here s and
44:41 - u16
44:43 - this will then compile
44:49 - tips if we don't explicitly assign a
44:52 - type to a variable then the compiler
44:54 - will infer one for us now we know that
44:57 - already
44:58 - modify a sort EQ to make it work so over
45:02 - here we are initializing the variable x
45:05 - with a value of 5. what would be the
45:08 - type annotation
45:11 - it would be i32 right it's the default
45:15 - integer typing rust now in this assert
45:18 - EQ macro we have here a string u32 we
45:23 - don't worry yet about this method I will
45:26 - explain that in a later episode
45:28 - and on the other side of the assert EQ
45:32 - macro we have a function call so we call
45:36 - type of with an argument of x
45:40 - actually a reference to X but again
45:42 - don't worry we'll cover that
45:45 - so
45:47 - when we call this function over here it
45:50 - basically just gives us back the name of
45:53 - the type
45:55 - so if we pass X over here we would get
45:58 - back
46:00 - i32 right
46:03 - because this variable over here holds a
46:06 - value of type i32 now this boot then
46:11 - actually fail right because we want here
46:14 - that
46:16 - type of X returns u32 so what we can do
46:21 - is just changing this type annotation
46:24 - over here
46:28 - all right fill the blanks to make it
46:31 - work now over here we have a data type
46:34 - for example I8 and the constant Max now
46:38 - Max just Returns the largest possible
46:43 - number that can be represented with the
46:48 - mentioned data type so for example I8
46:52 - Max would be
46:54 - 127. right this would be an assigned
46:58 - 8-bit integer and we have seen the
47:01 - ranges
47:02 - now the max for an unsigned 8-bit
47:04 - integral would be 255.
47:09 - all right
47:14 - fix arrows and panics to make it work
47:17 - now over here we have a value 251 which
47:22 - is of type u8 and we add 8 to it now in
47:28 - this case the compiler will infer the
47:31 - types so this would be 8
47:35 - and the variable itself will hold them
47:39 - u8
47:40 - now can you spot the problem over here
47:46 - the problem is we have seen that u8 can
47:50 - only represent up to
47:53 - 255 right so over here we would have
47:58 - 259 so this is not possible
48:03 - so what we can do over here is just
48:06 - changing that to the next
48:08 - bigger data type for example u16
48:14 - now then we have here a data type I8
48:18 - assigned 8-bit integer and we call the
48:22 - checked add method now this is actually
48:26 - the same as doing it like that but in a
48:29 - safer way because we have to handle the
48:32 - error
48:34 - and unwrap over here we will cover that
48:38 - so
48:40 - this
48:42 - is actually a little bit safer but it
48:45 - still will panic because again the I8
48:48 - cannot represent
48:50 - 259 it would be an overflow so again we
48:55 - can over here just say we want an i16
49:00 - because an i16 can without problems
49:02 - represent 259.
49:06 - so V1 will then hold u16
49:10 - and V2 will hold i16
49:14 - . again I'm just doing this for clarity
49:16 - you don't have to annotate the types
49:21 - alright modify assert to make it work
49:25 - now as you can see over here we have
49:28 - numbers
49:30 - in different representations or
49:34 - basically in different number systems so
49:36 - this is decimal this is hexadecimal this
49:40 - is octal and this is binary okay
49:43 - now
49:46 - the decimal over here has an underscore
49:48 - and this is just a delimiter so this is
49:52 - just for readability it doesn't affect
49:55 - the actual value
49:58 - now let me convert that over here we
50:01 - would have 2024
50:05 - this is already in decimal system then
50:09 - over here we would have 255
50:12 - then over here we would have 63 and then
50:15 - over here I hope you remember this would
50:18 - be
50:19 - 255. now if we calculate this
50:27 - as you can see the result would be this
50:30 - value over here
50:38 - like that and this basically proves that
50:42 - in Rusty you can
50:44 - perform mathematical operations on
50:48 - different
50:49 - number systems right
50:56 - now floating Point fill the blank to
50:58 - make it work as you can see over here we
51:01 - have a floating point value so what
51:04 - would be the type
51:07 - I will annotate it directly so it would
51:10 - be f64 this is the default floating
51:13 - Point type right
51:16 - now over here we have an F 32
51:21 - and over here we have an F 64.
51:25 - right
51:29 - like that again type annotations are not
51:32 - necessary now if we pass x to the type
51:37 - of function over here what would be the
51:41 - return value
51:44 - it would be f64 right
51:52 - make it work in two distinct ways so if
51:56 - we execute this program over here
52:01 - as you can see this would panic
52:05 - now the problem here is a floating Point
52:08 - precision
52:10 - the result won't be exactly 0.3 it would
52:16 - be something like
52:20 - that maybe right or something like that
52:23 - I don't know exactly but
52:27 - t
52:29 - floating point value is too precise
52:32 - because the default floating Point type
52:34 - is f64 so this is really precise and
52:40 - that's why you have these tiny fractions
52:45 - over here now we can solve this using
52:49 - an F 32 Which is less precise right
52:56 - like that
52:58 - and this succeeds now two distinct ways
53:02 - we can also use the as keyword
53:18 - like that
53:22 - so let me first move my head over here
53:25 - again
53:26 - so range two goals first modify Sr to
53:29 - make it work second make print line
53:32 - output 97 to 122.
53:37 - now over here as you can see we have
53:39 - immutable variable sum
53:43 - what would be the type annotation it
53:46 - would be i32 okay now
53:50 - over here we have a for Loop meaning we
53:54 - are iterating over some range and then
53:58 - we are executing an instruction inside
54:01 - this code block over here
54:04 - multiple times basically the times we
54:08 - are iterating over this range over here
54:12 - now in each iteration the variable I
54:15 - will hold
54:16 - a different value right so in the first
54:19 - iteration it would be -3 in the second
54:22 - iteration it would be -2 in the third
54:25 - minus 1 and so on until we reach 1.
54:31 - y1 because 2 over here is excluded and
54:36 - that's always the case when using this
54:38 - syntax the end point of the range is
54:41 - always excluded so we are iterating from
54:44 - -3 to 1 okay
54:49 - now let's actually do these iterations
54:52 - manually so
54:55 - we start with zero right now in the
54:59 - first iteration I would be -3 so
55:03 - 0 plus minus 3 will be
55:07 - minus 3 right
55:09 - so sum will then hold
55:11 - -3 now in the second iteration I will be
55:15 - minus two so minus three plus minus 2
55:19 - will be minus five
55:21 - third iteration minus one minus five
55:25 - plus minus one will be minus six
55:29 - then
55:30 - in the next iteration I will be zero so
55:34 - it doesn't have any impact and in the
55:37 - last iteration I will be one so minus
55:40 - six plus one will be minus five
55:44 - so the value of sum after this for Loop
55:48 - will be minus five
55:51 - now over here we again have a for Loop
55:54 - and this time we are iterating over a
55:57 - range of characters namely from A to Z
56:02 - now this time Z over here is included
56:05 - because we are using the equal sign over
56:08 - here which means we want a range from A
56:12 - to Z where the end point set is included
56:17 - and C over here will then hold in each
56:21 - iteration a character so in the first
56:24 - one it would be a then it would be B
56:27 - then C and so on and we just print out
56:31 - the characters
56:33 - let's see how that looks like as you can
56:37 - see just printing out each character
56:40 - from a to z
56:43 - now we want to have an output of 97 to
56:46 - 122.
56:49 - so let's look at the ASCII table
56:53 - as you can see in memory a character
56:56 - would be stored as a numerical value now
57:01 - of course in memory everything is stored
57:03 - as binary numbers but it would be stored
57:06 - as the binary representation of these
57:11 - decimal numbers right here
57:14 - so we want to go from 97 a to
57:19 - 122 Z right
57:24 - so it's actually pretty simple instead
57:28 - of
57:29 - outputting DC as character
57:33 - we want to Output it as an u8 for
57:37 - example
57:38 - right
57:40 - and then as you can see we have the
57:42 - ASCII code for the characters from A to
57:47 - Z lowercase
57:50 - right
57:52 - then over here exercise 10 fill the
57:55 - blanks so we are here importing from the
58:00 - standard Library the Ops module range
58:03 - and range inclusive
58:05 - now we have seen the shorthand syntax
58:09 - and this would actually be the more
58:11 - verbose way to write that but I think no
58:15 - one actually does it this way
58:17 - over here we have a range which starts
58:21 - at one and ends at five now again five
58:25 - would be excluded right
58:29 - like that now range inclusive means
58:32 - we range from 1 to 5 where 5 is included
58:38 - and we would write that short and syntax
58:41 - like this
58:42 - one two five and five is included
58:51 - right let's see the last exercise in
58:54 - this topic computations fill the blanks
58:56 - and fix the errors
58:58 - so as you can see over here we have
59:00 - integer additions so one plus two will
59:05 - be three
59:07 - and the compiler over here will infer
59:10 - these types so because we have over here
59:14 - an u32 an unsigned 32-bit integer it
59:19 - will infer these values over here to be
59:23 - of the same type
59:25 - all right
59:27 - now over here the same thing we have 1
59:30 - minus 2 would be -1
59:33 - and the compiler infers these types
59:40 - then over here we have 1 minus 2 which
59:43 - is equal minus one
59:45 - the problem over here is that we are
59:48 - dealing with an unsigned 8-bit integer
59:51 - now remember unsigned integers can never
59:54 - be negative
59:56 - so what we can do to fix that is just
59:58 - converting it to an I8 assigned 8-bit
60:02 - integer and signed integers can
60:06 - represent both positive and negative
60:09 - numbers
60:10 - now over here we would have 150
60:15 - and if there are no type annotations
60:18 - here the default integer type will be
60:21 - inferred which will be i32
60:25 - now over here again we have the problem
60:28 - of floating Point Precision so we can
60:31 - cast that to an F 32.
60:42 - like that
60:43 - over here we have the modulus operator
60:46 - and the modules operator basically gives
60:50 - back the remainder of a division so if
60:54 - we divide 24 by 5 we would have a
60:58 - remainder of 4.
61:02 - now as you can see here we have Boolean
61:05 - logic and bitwise operations and I want
61:08 - to show you some slides so we get the
61:11 - concept
61:13 - let's start with Boolean logic Boolean
61:16 - logic deals with values that are either
61:19 - true or false
61:21 - and there are three basic operations and
61:25 - or and not
61:27 - and over here you can see the truth
61:29 - tables of these operations
61:32 - so let's see the and operator now the
61:35 - end operator takes two inputs and
61:38 - produces one output
61:41 - now the only time it outputs true is
61:44 - when both of the inputs are true
61:47 - otherwise it will always return false
61:51 - in an or operation
61:53 - if either one of the inputs is true or
61:57 - both of the inputs are true then it will
62:00 - output true if both of the inputs are
62:04 - false then it will output faults
62:08 - and the not operator will just basically
62:11 - invert the Boolean value so over here we
62:15 - have not false and this would evaluate
62:17 - to true and not true will evaluate to
62:22 - false
62:24 - now let's see bitwise operations
62:27 - bitwise operations are operations that
62:30 - manipulate individual bits that make up
62:33 - a binary number treating each bit of a
62:37 - binary number as a separate unit and
62:39 - perform logical operations on them
62:43 - so it's very important that you get that
62:45 - in bitwise operations we are treating
62:49 - each bit as a separate unit and we are
62:52 - doing some manipulation on each
62:54 - individual bit and not the binary number
62:57 - as a whole
63:00 - and we'll cover here and or X or
63:04 - operations and bitwise shifting now
63:07 - there are a lot more but I will just
63:09 - cover the ones in the exercise
63:14 - let's start with the end operator this
63:17 - Ampersand symbol over here and returns
63:20 - one only when both of its inputs are one
63:24 - so similar to Boolean logic as you can
63:27 - see the end operator takes two inputs
63:30 - and produces one output
63:34 - now
63:36 - as you can see in the truth table if
63:40 - both of the inputs are one then the
63:43 - output will be 1. in any other case the
63:46 - output will be zero
63:50 - let's see the or operator this symbol
63:54 - over here
63:55 - all returns one if at least one of its
63:58 - inputs is one if both inputs are zero
64:02 - the output will also be zero
64:05 - so same thing as in Boolean logic if
64:08 - either one of the inputs or both of the
64:11 - inputs are one then it will output one
64:15 - so the only case it outputs 0 is when
64:19 - both of the inputs are zero
64:24 - and let's see xor xor or exclusive or
64:28 - returns one if the inputs are different
64:31 - and zero if the inputs are the same
64:35 - so it's basically similar to the or
64:39 - operator with the difference that if
64:42 - both of the inputs are one then it will
64:45 - output 0. so the inputs must be
64:49 - different so it will output one all
64:52 - right if they are the same it will
64:54 - output 0.
64:59 - and this is basically a building block
65:02 - of your computer so your computer is
65:06 - made up of logic gates and these logic
65:08 - gates perform these operations all the
65:12 - time
65:13 - millions of times in a second
65:18 - then let's see bitwise left shift so we
65:21 - have over here the decimal number one
65:24 - this would be the binary representation
65:27 - now we want to left shift
65:31 - by five positions
65:33 - so we take this bit over here and move
65:37 - it five positions to the left
65:40 - so the so this bit over here will be at
65:44 - this position after the DP twice left
65:46 - shift operation all right and that means
65:49 - we then have a value of 32 because this
65:54 - is the binary representation of decimal
65:58 - 32.
66:01 - and bitwise right shift is basically the
66:04 - same
66:04 - now over here we have a hexadecimal
66:07 - value and we want to right shift it to
66:10 - positions
66:11 - now this value over here would be 128 in
66:17 - decimal
66:19 - and this would be the binary
66:21 - representation of 128.
66:25 - now we want to right shift it to
66:28 - positions meaning we take this bit over
66:31 - here and shift it two positions to the
66:35 - right meaning the bit will then be in
66:37 - this place and again we would have 32
66:41 - because this over here is the binary
66:44 - representation of that number all right
66:47 - let's see
66:48 - so true
66:50 - and false
66:52 - would be
66:54 - false
66:56 - right because in an and operation both
66:59 - of the inputs must be true in order for
67:02 - it to Output true now true or false
67:07 - would be true
67:09 - because in an or operation only one of
67:12 - the inputs have to be true
67:15 - and not true would be equal to
67:21 - that's right false
67:23 - fight
67:25 - like that now let me run the program so
67:29 - we can see the result of these
67:32 - bitwise operations
67:35 - so as you can see over here zero zero
67:38 - one one and zero one zero one is zero
67:42 - zero zero one why is that because again
67:46 - we are here considering each individual
67:49 - bit as a unit and Performing
67:52 - manipulation on each
67:55 - a distinct bit now over here as you can
67:58 - see we are taking the rightmost bit over
68:01 - here and we are performing The End
68:03 - operation with the rightmost bit over
68:06 - here meaning one and one
68:10 - would be one right because and if both
68:15 - of the inputs are 1 then it will output
68:19 - one in any other case as you can see one
68:23 - and zero would be zero
68:26 - 0 and 1 would be zero zero and zero of
68:31 - course would be zero
68:33 - now let's see this or operation we have
68:37 - one or one this will output one
68:42 - we have one or zero which will output
68:46 - one again right because in or operation
68:51 - if either one of its input or both of
68:54 - them are one then it will output one
68:58 - zero or one is one and zero or zero of
69:03 - course is zero
69:06 - and then we have xor one X or one put B
69:10 - zero because remember X or the inputs
69:16 - must be different in order for it to
69:18 - Output one
69:21 - like over here for example 1 X or zero
69:24 - would be one right the inputs over here
69:28 - are different one and zero
69:31 - same over here 0 x or one would be one
69:36 - and zero X or zero of course will be
69:39 - zero and as you can see over here these
69:42 - are the bitwise shifting so I've covered
69:46 - that in the slides
69:48 - all right see you in the next topic so
69:51 - we will cover in our Char pool and unit
69:54 - let's start with characters
69:57 - so over here make it work now size of
70:01 - Val will just return this size in bytes
70:05 - of a specific value so over here we are
70:09 - initializing the variable C1 with a
70:12 - character so C1 holds a type of char
70:18 - then we pass to the size of valve
70:20 - function the variable C1 and this will
70:24 - return the size of this character in
70:27 - memory in bytes right and same thing
70:31 - over here we have C2 also holding HR
70:35 - and we call the size of L function with
70:38 - this variable
70:39 - so
70:41 - let me first print out the actual result
70:45 - of this function call
70:47 - so if I come over here
70:49 - and I will do a print line
70:52 - statement
71:00 - and just basically
71:02 - outputting the result of this function
71:05 - column so let's see
71:11 - as you can see the output would be 4
71:14 - meaning this character over here will
71:18 - take up four bytes in memory so the size
71:22 - of C1 is 4 bytes
71:27 - now in Rust the chart type is big enough
71:32 - to hold every single Unicode symbol
71:35 - meaning it is of size 4 bytes so it's
71:39 - able to hold any Unicode scalar value
71:42 - all right
71:44 - and the same thing over here the output
71:47 - would be four
71:49 - meaning if we call this function we will
71:52 - get back four
71:59 - all right
72:00 - make it work again initializing a
72:03 - variable with a Char then we are calling
72:06 - the printshar function with an argument
72:09 - of this variable
72:11 - as you can see this function over here
72:13 - this is the function signature this
72:16 - function takes as argument C which is of
72:21 - type Char and then we will and then we
72:24 - just print out C
72:30 - now the problem over here is that this
72:33 - isn't actually a Char this would be
72:36 - considered a string because in Rust
72:38 - there is a difference between double
72:40 - quotes and single quotes So double
72:43 - quotes are four strings and these single
72:45 - quotes are for characters
72:49 - foreign
72:54 - out the character
72:57 - let's see booleans make print Line work
73:01 - as you can see this variable underscore
73:03 - F holds a Boolean value of false
73:07 - and over here T also holds a Boolean
73:11 - value of true
73:13 - now in an if block this conditional over
73:17 - here will be checked if the result
73:20 - evaluates to true then this instruction
73:23 - inside the curly braces will be printed
73:26 - out if it evaluates to false then the
73:31 - program will just ignore this
73:34 - instruction over here
73:35 - now in this case we want to print that
73:38 - out
73:39 - but over here the result would evaluate
73:42 - to false because we are saying not
73:46 - true right because T holds a Boolean
73:49 - value of true
73:51 - so not true would be false that means
73:54 - this will never get printed out what we
73:57 - can do over here is just removing this
74:00 - not operator and then it will work
74:05 - make it work again we have some
74:08 - variables that hold Boolean types now
74:12 - again this variable over here T will
74:15 - also hold a Boolean type because this
74:17 - over here is an and operation and
74:20 - remember an end operation takes two
74:23 - inputs and produces one output so the
74:27 - output type will be of type pool now
74:31 - true and false would evaluate to false
74:37 - and then we are comparing T and F now F
74:43 - holds true and T holds false
74:46 - which is not what we want
74:48 - so what we can do over here is just
74:51 - making this false over here
74:58 - and then both of them hold a Boolean
75:01 - value of false
75:05 - unit type make it work don't modify
75:08 - implicitly red unit
75:11 - so the unit type is a type which doesn't
75:14 - hold any value
75:16 - its size is zero bytes and it's usually
75:21 - if a function doesn't return
75:24 - any value then a unit type will be
75:28 - returned and this happens implicitly so
75:30 - you don't have to annotate that
75:34 - let's see an example
75:37 - over here the underscore V variable
75:41 - holds a unit type
75:44 - as you can see a unit type is basically
75:46 - represented as an empty Tuple
75:50 - and this would be the type annotation
75:52 - right
75:54 - so over here we are holding a tuple with
75:58 - two i-32 values
76:03 - then as you can see we have here an
76:06 - assert EQ macro we are comparing V with
76:10 - the output of this function call let's
76:13 - see this function over here implicitly
76:15 - red unit so all this function does is it
76:20 - will print out something and then goes
76:23 - back to the color now this function over
76:26 - here doesn't return anything
76:29 - and if a function doesn't return
76:31 - anything the compiler will implicitly
76:34 - return a unit type right but you don't
76:39 - have to annotate that
76:42 - all right so the return value of this
76:46 - would be unit type now V over here holds
76:50 - a tuple meaning this would fail we have
76:53 - here to provide underscore V which holds
76:57 - a unit type so this holds a unit type
77:00 - and this function call over here will
77:03 - return a unit type
77:09 - all right what's the size of the unit
77:12 - type modify 4 in assert to make it work
77:17 - as you can see we are again having this
77:20 - size of L function and we are providing
77:22 - it this variable which holds a unit type
77:26 - now the output would be zero because
77:30 - unit types are of size 0.
77:34 - so to quickly recap HR is a single
77:37 - character of size 4 bytes
77:40 - a Boolean value of true or false is of
77:43 - size 1 byte and the unit is an empty
77:47 - Tuple of size 0 bytes used to return
77:50 - nothing in expressions or functions
77:54 - so this time I will first show you the
77:57 - slide
77:58 - and then we will solve exercises so a
78:02 - statement is an instruction that
78:04 - performs some action but does not
78:06 - produce a value
78:08 - function definitions for example are
78:11 - statements as well as code that ends
78:14 - with a semicolon usually
78:17 - and an expression will evaluate to a
78:21 - resultant value so let's see
78:25 - all right let's see this example over
78:27 - here we have X which holds an u32 all
78:31 - right now
78:35 - over here we are initializing the
78:37 - variable y with the resultant value of
78:42 - this whole expression so as you can see
78:45 - we can inside these curly brackets
78:50 - we can declare variables over here and
78:54 - then we do some operations and return
78:58 - the value as you notice I omit over here
79:02 - the semicolon that means that
79:04 - this result of this operation will get
79:09 - returned which means when this evaluates
79:13 - it will then be assigned to Y so y will
79:18 - then hold the result of this operation
79:21 - now all of the code inside these curly
79:24 - braces are considered as an expression
79:27 - because it produces a resultant value
79:31 - right it would be this value over here
79:35 - now this variable assignment over here
79:39 - would be considered a statement because
79:42 - first of all it ends in a semicolon and
79:46 - second it doesn't produce a new value
79:48 - right it just assigns a value to a
79:53 - variable
79:54 - now y in the end would hold an u32 right
79:59 - because we are here performing an
80:01 - operation with values of u32 types
80:07 - the semicolon suppresses this expression
80:10 - and unit type is assigned to Z
80:14 - so Z over here would hold a unit type
80:18 - why is that because we over here have a
80:21 - semicolon so this
80:25 - code over here doesn't return a value
80:29 - if we omit the semicolon then this would
80:32 - be the return value that then gets
80:35 - assigned to this variable meaning it
80:38 - will then hold a u32
80:44 - all right let's do exercise one make it
80:47 - work with two ways so
80:52 - as you can see over here we are
80:54 - initializing this variable over here
80:56 - with this expression inside the curly
81:00 - braces now we are here initializing the
81:04 - mutable variable x with a value of one
81:07 - so X will hold I 32.
81:11 - then we are mutating X incrementing it
81:14 - by two so X should then hold
81:18 - 3 right
81:20 - now over here this would actually hold
81:25 - a unit type
81:27 - because over here we have an assignment
81:30 - so we are adding 2 to the value of x and
81:34 - then we assign it to X now the problem
81:38 - is that
81:39 - variable assignments are actually
81:42 - statements so this should end in a
81:45 - semicolon because this would be the same
81:48 - as if I would write it like that
81:52 - right
81:54 - so we can't return over here a variable
81:58 - assignment but what we can do is
82:01 - we just return X because X over here
82:05 - will then hold 3 and then we return X
82:09 - meaning the value of x is then assigned
82:12 - to the variable V
82:16 - so variable V will then hold a type of I
82:20 - 32.
82:22 - let's see
82:28 - this compiling as you can see make it
82:30 - work in two ways now the second way to
82:33 - solve it is just in this assert EQ macro
82:37 - we compare V to a unit type
82:43 - because
82:45 - um no value will get assigned to V and
82:50 - that means the variable we will then
82:52 - hold a unit type like that
82:56 - over here as you can see we are
82:58 - initializing V with a variable
83:01 - assignment so this would not be allowed
83:04 - it's invalid syntax but what we can do
83:08 - is we use curly braces like that and
83:12 - then we
83:14 - initialize here a variable X and we
83:18 - return X
83:21 - this would be allowed
83:25 - so V then holds an i32
83:32 - let's see over here we have a function
83:34 - call with two values one and two so
83:38 - let's see the function over here it
83:41 - takes two arguments X and Y of type i32
83:46 - and it returns an i32 value now over
83:51 - here as you can see this function just
83:54 - adds X Plus y now the actual return type
84:00 - over here would be unit type
84:06 - because as you can see we are ending
84:10 - this operation with a semicolon meaning
84:13 - nothing will get returned so if we omit
84:17 - the semicolon over here then we would
84:19 - have a return type of I 32.
84:26 - meaning after the function call over
84:29 - here
84:30 - s will then hold the result of this
84:34 - operation 1 plus 2 would be 3 so s would
84:39 - hold three
84:42 - that would be a type of i32
84:50 - so let's now look at functions a
84:52 - function is a block of reusable code
84:54 - that performs specific tasks it can take
84:58 - arguments processes those inputs and
85:01 - then returns a result
85:03 - and a diverging function is a function
85:06 - that never returns to the caller
85:10 - and this would happen for example if the
85:13 - diversion function is panicking looping
85:16 - forever or quitting the program
85:21 - so let's see don't modify the following
85:25 - two lines as you can see we have here a
85:28 - tuple and we are destructuring it we
85:31 - have already seen how that works
85:33 - now over here we have a function called
85:37 - now this would be the color and this
85:41 - function would be the collie okay when
85:45 - we call the function the flow control
85:47 - will go to this function and the program
85:51 - will continue executing the instructions
85:54 - provided in this function now
85:58 - it's very important that you know that
86:00 - functions always have to annotate types
86:03 - for their arguments
86:07 - so over here
86:09 - we would Define that X should be of type
86:12 - i32 right because Y is I 32 and we are
86:17 - performing here a mathematical operation
86:19 - meaning they both have to be of the same
86:22 - type
86:24 - and
86:27 - as you can see like in the last exercise
86:29 - this function wouldn't return a value
86:32 - because over here we have a semicolon so
86:35 - if we omit that then this result of this
86:40 - operation will get returned which means
86:42 - the return type would be i32
86:47 - then when this Returns the flow control
86:51 - will go back over here and assign The
86:55 - Returned value from this function to
86:58 - variable s meaning the variable s will
87:01 - then hold
87:02 - a type of i32 and the value would be 3
87:07 - right because we are calling the
87:09 - function with arguments one and two or X
87:13 - and Y
87:14 - over here which hold one and two and
87:19 - then this function will just sum it up
87:21 - together and that means s will hold 3.
87:30 - over here we are calling the print
87:33 - function so we go to the function over
87:36 - here and as you can see
87:39 - the function just prints out something
87:41 - to standard output but it doesn't return
87:45 - a value now implicitly the compiler will
87:50 - return a unit type like that but we
87:54 - don't have to write it
87:56 - it's implicit
88:05 - solve it in two ways don't let print Ln
88:08 - work
88:10 - all right so we are here calling a
88:12 - function never return
88:15 - and this function should never return
88:18 - because as you can see the return type
88:20 - over here is defined as exclamation mark
88:24 - and that means this is a diverging
88:27 - function a function that should never
88:30 - return back to the caller
88:33 - now we can do this in various different
88:36 - ways but I will just use the most simple
88:39 - one which is panic
88:43 - and the Panic macro just
88:46 - causes the program to panic meaning the
88:50 - program will immediately exit and return
88:53 - an error
89:03 - as you can see unreachable statement so
89:06 - this line over here is never reached
89:11 - as you can see and that's what we want
89:13 - because over here don't let print Ln
89:16 - work so we never actually reach this
89:20 - point the program will exit before
89:24 - going back to the caller
89:29 - diverging functions diverging functions
89:31 - never return to the caller so they may
89:34 - be used in places where a value of any
89:37 - type is expected
89:40 - so in the main function we just print
89:44 - out something and over here we have a
89:47 - function get option
89:49 - it takes as argument a value of type u8
89:54 - and returns option i32 now we will cover
89:58 - options in a later episode
90:02 - now over here we are matching TP
90:06 - and matching if you're coming from
90:09 - another programming language is like is
90:13 - which
90:15 - block okay we are matching TP and then
90:22 - if for example TP would be one then this
90:26 - code block over here would get executed
90:29 - if it is anything else then this code
90:32 - block will be executed and we will cover
90:36 - match statements but match is just a
90:40 - much more powerful way of pattern
90:43 - matching than for example if else
90:45 - conditionals
90:48 - so after this match we are calling this
90:51 - never return FN and this should never
90:55 - return so there are some macros we can
91:00 - use here I've showed you one the Panic
91:03 - macro
91:04 - [Applause]
91:10 - like that
91:12 - or we can also use unimplemented
91:18 - and you use the unimplemented macro if
91:21 - you have a function that is not
91:23 - implemented yet
91:25 - and we can also use it to do macro
91:31 - like that
91:33 - and to do is basically very similar to
91:37 - and implemented and all of them will
91:42 - cause this function to not return to the
91:46 - caller in this case this would be the
91:48 - color over here
91:52 - fill in the blank so as you can see we
91:55 - have here a variable B which then gets
91:58 - matched over here so if B holds a value
92:01 - of true then 1 will be assigned to
92:05 - variable V
92:07 - if B holds a value of false then it will
92:11 - print out success and the program will
92:15 - then panic
92:17 - now
92:18 - we can here assign false because I guess
92:22 - we wanted to print out success right
92:26 - and
92:28 - yeah let's see
92:36 - as you can see this would be the
92:38 - compiler message if a program panics
92:41 - trade main panicked at we have no value
92:44 - for false but we can panic
92:49 - that would be this output over here
92:53 - so we will now cover ownership and
92:57 - ownership is a concept which is unique
93:00 - to rust meaning even experienced
93:03 - programmers can find it difficult to
93:06 - understand this concept
93:08 - but it's very logical and it all makes
93:12 - sense and I will use visuals and
93:14 - illustrations
93:16 - to make it easier to understand the
93:20 - concept so ownership is basically a set
93:23 - of rules that govern memory management
93:27 - these rules are enforced at compiled
93:30 - time
93:31 - if any of the rules are violated then
93:34 - the program won't compile
93:39 - now let's see the three rules of
93:41 - ownership in Rust first each value in
93:45 - Rust has an owner second there can only
93:49 - be one owner at a time
93:52 - third when the owner goes out of scope
93:55 - the value will be dropped
93:58 - now the owner of a value is the variable
94:01 - or data structure that holds it and is
94:04 - responsible for allocating and freeing
94:08 - the memory used to store that data
94:13 - foreign let's look at scope
94:16 - a scope is arranged within a program for
94:19 - which an item is valid we have two types
94:23 - of scope one is global scope and that
94:26 - means a variable that is declared in
94:29 - global scope is accessible throughout
94:32 - the entire program
94:34 - and local scope if a variable is
94:39 - declared locally it means it is
94:42 - accessible only within that particular
94:45 - function or code block
94:48 - which in turn means it's not accessible
94:51 - outside of that function or code block
94:56 - let's see an example of scope
94:59 - as you can see we are here initializing
95:02 - the variable s with a string that means
95:06 - s over here is the owner of this data of
95:11 - this string value okay
95:14 - now s is valid from this point forward
95:17 - so after initializing s it will be valid
95:23 - throughout this scope over here which is
95:27 - defined by these curly braces
95:30 - so inside of this scope we can do stuff
95:34 - with s
95:37 - when this scope is over s is no longer
95:41 - valid so as over here the owner of this
95:45 - data will deallocate the data that is
95:48 - stored in computer memory and that means
95:52 - in turn we can't use as after this point
95:57 - it gets dropped or removed
96:01 - from memory
96:03 - so when s comes into scope it is valid
96:06 - it remains valid until it goes out of
96:09 - scope and a general rule is the scope
96:13 - ends where the block of code ends so to
96:17 - understand ownership you have to
96:19 - understand computer memory now memory is
96:24 - a component in a computer to store data
96:27 - and instructions for the processor to
96:30 - execute
96:32 - there is a type of memory called random
96:35 - access memory or RAM and it is volatile
96:39 - meaning when you're turning off your
96:42 - computer all data stored inside Ram is
96:46 - lost
96:47 - and there are two types of regions in
96:50 - Ram which is used by your rust program
96:53 - it is stack memory and Heap memory
96:58 - so now let's look at stack memory and I
97:02 - want you to imagine a stack of plates
97:05 - now if you want to eat something you
97:08 - take from the top of this stack a plate
97:11 - put food on it eat and then you will
97:14 - clean up the plate right when you're
97:18 - done cleaning you put the plate back on
97:21 - the top of the stack
97:24 - and that's exactly what is happening in
97:27 - stack memory so this concept is called
97:30 - last in first out meaning the last thing
97:35 - that is pushed
97:37 - on top of the stack will be the first
97:40 - thing that will get popped from this
97:42 - deck meaning the first thing that will
97:44 - get executed
97:47 - now all data stored on this deck must
97:50 - have a known fixed size like integers
97:54 - floats Charles bulls and so on basically
97:58 - all the types we have seen so far are
98:02 - all of fixed known size at compile time
98:08 - now pushing to the stack is faster than
98:11 - allocating on the Heap because the
98:13 - location for new data is always at the
98:16 - top of the stack
98:18 - meaning the program can access
98:21 - a data and stack memory at constant time
98:24 - if you are familiar with time complexity
98:28 - and types of unknown size will get
98:31 - allocated to the Heap and a pointer to
98:34 - the value is pushed to this stack
98:36 - because a pointer is fixed size
98:40 - don't worry I will show you
98:42 - illustrations which will make you
98:45 - understand this concept better
98:49 - let's see for example
98:52 - this simple rust program so as you can
98:56 - see we are starting in main because main
99:00 - is the starting point of execution in
99:03 - every rust program
99:06 - so over here we declare some variables X
99:10 - Y and Z meaning these variables are
99:13 - local to the main scope to this code
99:18 - block over here
99:21 - and
99:22 - because they are local they can't be
99:25 - accessed outside of this scope
99:30 - now over here we have a function call
99:33 - and we pass it the value of x and of Y
99:38 - right so as you can see the add numbers
99:41 - function takes two arguments of type i32
99:46 - then over here we declare a new variable
99:50 - and assign and we assign the result of
99:55 - the operation a plus b meaning
99:58 - the past value is X Plus Y
100:01 - and we assign it to the variable C and
100:06 - then we just return C right so then
100:12 - Z over here will hold the returned value
100:17 - now
100:18 - when we start execution main alongside
100:23 - with all the local variables will get
100:25 - pushed to the stack
100:29 - then because we have over here a
100:31 - function call inside Main
100:34 - the add numbers function alongside with
100:38 - all the local variables to this function
100:41 - will get pushed to this stack if we
100:44 - would have other function calls over
100:45 - here or inside here then this will also
100:50 - get pushed on the stack and so on
100:54 - and then the program will just execute
100:58 - everything that is on the stack from top
101:01 - to bottom
101:04 - now let's look at Heap memory date of no
101:08 - known fixed size belongs on the Heap
101:11 - allocating data on the Heap will return
101:14 - a pointer an address to a location where
101:17 - the data has been allocated
101:20 - allocating on the Heap is slower than
101:23 - pushing to this stack and accessing data
101:26 - on the Heap is also slower as it has to
101:29 - be accessed using a pointer which points
101:33 - to an address
101:36 - so if we look at this abstract
101:39 - illustration of Heap memory as you can
101:42 - see we are allocating to Heap memory if
101:46 - the size of of the type we are
101:49 - allocating is not known at compile time
101:53 - and the types can then also be
101:57 - dynamically grown or shrinked right the
102:01 - size is not fixed
102:04 - and we will see examples of these types
102:08 - where this cat where this could be
102:11 - useful
102:12 - so when we allocate to Heap memory let's
102:15 - see for example the this packet over
102:19 - here we will get back a memory address
102:23 - and we need this address so we know
102:26 - where this specific data over here has
102:29 - been allocated so we then can access it
102:32 - in our program
102:36 - and an example of a heap allocator type
102:41 - would be the string type now as I've
102:44 - said all types we have covered so far
102:47 - were fixed size meaning their size was
102:51 - known at compiled time and they can't
102:54 - grow and Shrink
102:56 - so the difference is a string is mutable
103:00 - meaning its size can change at run time
103:04 - and a string is stored on the stack with
103:08 - a pointer to the Heap so when we
103:11 - initialize a string type then we will
103:14 - get back a pointer which then points to
103:17 - the actual data in the Heap
103:20 - and and the actual data of the string is
103:24 - stored on the Heap
103:26 - so let's see an example to understand
103:29 - this better as you can see we have here
103:32 - the variable S1 which we initialize with
103:36 - a string type over here
103:39 - and we initialize a string like this
103:42 - string
103:44 - double colon from and then these the
103:49 - actual string
103:51 - now
103:53 - you need to understand that the variable
103:56 - S1 doesn't hold the actual string in
104:00 - this case
104:02 - it holds a pointer which points to the
104:06 - data that was allocated on the Heap so
104:10 - if we look at S1 we can see that S1
104:14 - doesn't hold the actual data but it
104:17 - holds a pointer and a pointer is
104:20 - basically a variable that holds a memory
104:24 - address that's what we call pointer
104:28 - and we have here Len and this is the
104:32 - length of the string we have initialized
104:36 - and the capacity holds the information
104:39 - of how much space was reserved in Heap
104:43 - memory for this specific type in this
104:47 - case we have initialized a string with a
104:50 - length of 5 so the capacity will be 5 so
104:55 - 5 locations have been allocated in Heap
105:00 - memory so this place is reserved
105:04 - for this string type and we will go into
105:08 - a much greater detail about capacity
105:11 - but for now when we initialize a string
105:16 - with a length of 5 the capacity will be
105:19 - five it will be the same
105:22 - so the size of this S1 variable will be
105:26 - 24 bytes because each field over here is
105:31 - of Type U size
105:34 - right so the pointer is of Type U size
105:36 - the Lan anti-capacity all of them are U
105:40 - size and u-size assuming we are on a
105:44 - 64-bit computer will be 8 bytes so 3
105:48 - times 8 bytes will be 24 bytes meaning
105:53 - the size of the variable S1 is known at
105:57 - compile time because again
106:00 - the variable S1 will get pushed to this
106:05 - stack memory and everything that lives
106:09 - on the stack memory has to be of known
106:12 - fixed size at compile time in this case
106:15 - all of these fields over here are known
106:18 - fixed size but we are pointing over here
106:23 - to the actual data in Heap memory which
106:27 - can be dynamically sized right it can
106:30 - grow and shrink and we will see examples
106:33 - of that
106:34 - so that is actually the point
106:38 - important the S1 variable doesn't hold
106:42 - the actual data but it holds a pointer
106:46 - to the data in Heap memory
106:50 - okay basically a pointer to the location
106:54 - of the first element
106:57 - and by the way in Heap memory this data
107:01 - over here is allocated as a contiguous
107:04 - block meaning in Heap memory these are
107:09 - all in a contiguous sequence of memory
107:13 - addresses right that's why we only need
107:16 - the
107:18 - memory address of the first location and
107:22 - a length and then the compiler will know
107:26 - where to look at and how long the
107:30 - sequence of data is
107:36 - so copy versus move scalar values with
107:41 - fixed size all types we've covered at
107:43 - the beginning will automatically get
107:46 - copied in this stack copying here is
107:49 - cheap
107:50 - dynamically sized data won't get copied
107:53 - but moved copying would be too expensive
107:57 - let's see an example
108:00 - over here as you can see we have
108:03 - initialized a variable x with a value of
108:06 - 5. then we assign X to y
108:11 - now the type of this value would be i32
108:14 - right because it's the default integer
108:17 - type
108:19 - now because i32 is fixed size it means
108:24 - that it lives in this stack memory
108:28 - and everything that lives in stack
108:30 - memory will automatically get copied
108:34 - meaning we are here assigning a copy of
108:38 - x to y or basically a copy of the value
108:43 - 5. so we are not assigning the actual
108:46 - value but a copy of that meaning Y and X
108:52 - would point to different memory
108:54 - locations the value is the same but the
108:57 - location at which the value is stored is
109:02 - different because again when we assign a
109:06 - fixed size integer that lives in stack
109:10 - memory rust will automatically copy the
109:14 - value
109:16 - because copying on the stack memory is
109:19 - cheap now over here as you can see we
109:23 - initialize a string
109:26 - and then we assign S1 holding this
109:29 - string 2s2
109:32 - now as we've seen S1 doesn't actually
109:36 - hold the data over here but it holds a
109:41 - pointer which is returned when we are
109:44 - allocating this data over here this
109:47 - string on the Heap memory so the
109:52 - allocator that allocates this data on
109:55 - the Heap memory will return a pointer
109:58 - and that means if we assign S1 over here
110:01 - to S2 then S2 will only get a copy of
110:06 - the pointer and not the actual
110:10 - data
110:14 - so that is how that might look like as
110:18 - you can see we have S1 which is
110:21 - initialized to hold a string
110:24 - now S1 will then be assigned to S2
110:31 - and
110:32 - as you can see this is how this might
110:35 - then look like we have here the variable
110:38 - S1 and S2 now
110:43 - the actual data over here didn't get
110:46 - copied the one thing that got copied was
110:49 - the pointer alongside with the metadata
110:53 - meaning
110:55 - these two variables now point to the
110:58 - same location in memory
111:02 - right now this would violate the second
111:04 - rule which states that there can only be
111:08 - one owner at a time
111:11 - so we can't over here have two owners to
111:15 - the same
111:17 - data in Heap memory
111:20 - so what rust will do is it will drop S1
111:25 - it will delete S1 and that means
111:29 - S2 will then be the owner of the data so
111:34 - the first variable S1 will be dropped
111:37 - and cannot be used after assigning it to
111:39 - S2 to avoid dangling pointers
111:43 - so after assigning S1 to S2 we can't use
111:48 - S1 again
111:51 - and that's different like we saw over
111:53 - here with for example integers which are
111:57 - fixed size
111:58 - we can use after assigning X to Y we can
112:02 - use both of these variables X and Y
112:05 - without any problem because again here
112:08 - the value got copied
112:14 - so the compiler will drop the variable
112:17 - S1 meaning S2 will become the owner of
112:21 - this string and that means we can't use
112:26 - S1 after this point
112:29 - now what if you want to actually have a
112:33 - deep copy meaning you actually want to
112:35 - copy the data that is allocated in Heap
112:40 - memory we can do that but we have to
112:43 - explicitly state that we want to do that
112:46 - because as I've said this might be
112:49 - expensive if you have large data that is
112:52 - allocated on the Heap
112:54 - and if rust would implicitly copy
112:59 - all the data all the time you're
113:00 - assigning variables then this would be
113:03 - really expensive and that's why we have
113:05 - to explicitly call over here the Clone
113:09 - method so when we take S1 which holds a
113:13 - string and we call upon it the Clone
113:15 - method
113:17 - and assign this to S2 then that is what
113:21 - this might look like
113:23 - as you can see S1 again doesn't hold the
113:27 - actual data but a pointer to the data
113:30 - that is that has been allocated in Heap
113:34 - memory
113:36 - and when we now look at S2 S2 also holds
113:41 - a pointer to data that has been
113:43 - allocated in Heap memory the difference
113:47 - is that the actual data in Heap memory
113:51 - that S1 is pointing to has been copied
113:55 - in Heap memory
113:57 - so S1 and S2 point to different
114:01 - locations even if the data is the same
114:06 - right and that's different from what we
114:09 - saw here as you can see S1 and S2 point
114:13 - to the same location in Heap memory
114:19 - I hope you get the concept so let's now
114:22 - see how ownership Works in functions as
114:26 - you can see we have here a variable s
114:28 - which we initialized with a string type
114:32 - so over here s comes into scope
114:36 - and in this case s will be the owner of
114:41 - this data
114:44 - then over here we are calling the takes
114:47 - ownership function providing it an
114:50 - argument of s
114:52 - so s value moves into the function and
114:55 - so is no longer valid here meaning the
114:59 - function takes ownership is now the
115:01 - owner of s
115:04 - so as you can see this function over
115:06 - here takes an argument of string type
115:10 - and it just prints out the provided
115:13 - string
115:14 - so as you can see some string comes into
115:17 - scope and some string over here is the
115:21 - string we have provided as an argument
115:25 - then we print it out and over here
115:29 - some string goes out of scope and drop
115:32 - is called the backing memory is freed
115:35 - meaning
115:37 - when we reach the end of the scope
115:41 - some string will get deallocated in Heap
115:45 - memory
115:47 - so after this point over here s
115:51 - can't be used in this main function over
115:55 - here because again the ownership has
115:58 - been moved from variable s into the
116:02 - takes ownership function
116:05 - now over here we have another
116:07 - initialized variable x with a value of
116:10 - five now five would be of type I 32 the
116:14 - default integer type meaning 5 is a type
116:18 - that lives on this stack it's pushed to
116:21 - the stack and not allocated on the Heap
116:25 - and that means when we call this
116:28 - function makes copy and provided X over
116:31 - here
116:32 - then we provide this function a copy of
116:36 - the value and not the actual value
116:39 - itself
116:41 - so we provide here a copy of the value 5
116:45 - right and then over here we just print
116:49 - out this number then here are some
116:51 - integrals out of scope nothing special
116:54 - happens
116:56 - so the argument we are providing here
116:59 - goes out of scope but X over here is
117:03 - still valid because again we have just
117:06 - provided a copy because this is a type
117:10 - that is living on the stack memory
117:16 - so let's see this example over here we
117:19 - are calling the gifs ownership function
117:23 - now when we look at this function over
117:25 - here we are inside the function code
117:29 - block
117:30 - initializing a variable with a string
117:34 - value over here
117:36 - and then we are just returning this
117:38 - string
117:39 - and that means that S1 will then hold
117:43 - the returned string
117:47 - namely this yours string over here so S1
117:51 - will be the owner of The Returned string
117:55 - type
117:57 - over here we are initializing S2 with a
118:01 - string over here that means S2 is the
118:05 - owner of the string
118:08 - then we are calling here the function
118:10 - takes and gives back with an argument of
118:13 - S2 meaning takes and gives back will
118:17 - become the owner of this data
118:22 - and that also means that after calling
118:26 - this function we can't use the variable
118:29 - as 2 because it has been dropped
118:34 - now when we look at the function takes
118:36 - and gives back it takes an argument of
118:40 - type string which we are providing here
118:42 - and then it just again Returns the
118:46 - string right so S3 will then hold the
118:50 - return string basically S3 then became
118:53 - the owner of this data right so we have
118:58 - transferred ownership from S2 to this
119:01 - function takes and gives back and then
119:04 - from this function to S3
119:08 - and then at the end of the main scope S3
119:12 - goes out of scope and is dropped S2 was
119:15 - moved we've seen that we have moved it
119:17 - inside the function so nothing happens
119:21 - S1 goes out of scope and is dropped
119:25 - so
119:26 - the variable S1 also gets dropped
119:29 - because it is the owner of of this
119:32 - string type returned from this function
119:37 - so you are now asking why do I even care
119:40 - about all this stuff in other languages
119:43 - I don't have to worry about all of this
119:47 - and this seems rather complicating
119:51 - a simple issue right now the main point
119:56 - of all of this is that ownership
119:58 - prevents memory safety issues
120:02 - so by this concept of ownership you are
120:06 - preventing dangling pointers pointers
120:09 - that point to Nowhere or some garbage
120:12 - values
120:13 - double three which is trying to free
120:15 - memory that has already been freed or
120:19 - memory leaks not free memory that should
120:22 - have been freed and if you're coming
120:25 - from C or C plus plus you're you know
120:28 - exactly what I'm talking about here
120:33 - so before stepping into borrowing we
120:36 - will do some exercises concerning
120:39 - ownership
120:43 - so let's see number one use as many
120:45 - approaches as you can to make it work
120:49 - so
120:51 - as you can see the variable X over here
120:53 - has been initialized with a string
120:57 - then we are assigning X to Y so y also
121:01 - should hold a string
121:05 - the problem over here is that we try to
121:09 - access X over here after it has been
121:13 - assigned to y
121:15 - now we have seen in the example that X
121:18 - will get dropped after we assigning
121:21 - after we are assigning it to another
121:23 - variable
121:25 - right so we can't access X but what we
121:29 - can do is
121:31 - telling the compiler that we want a deep
121:34 - copy of the data that X is holding and
121:38 - we are using for that the Clone method
121:45 - and then we X and then we can access
121:49 - both of these variables because the data
121:52 - has been cloned and X still lives on
121:59 - number two don't modify code in main
122:01 - again S1 has been initialized with a
122:05 - string
122:07 - and then we are calling here take
122:09 - ownership and providing it an argument
122:12 - as two
122:13 - as you can see the function take
122:16 - ownership expects an argument of type
122:19 - string and it just prints out the
122:23 - provided argument
122:26 - now
122:27 - we are then assigning the return value
122:31 - of this function to this variable the
122:34 - problem here is that this function
122:37 - actually doesn't return anything so this
122:40 - would hold a unit
122:42 - type right
122:44 - now if we want to return the argument
122:47 - over here after Printing and using it
122:51 - we can just return it like that and if
122:55 - you return something from a function you
122:57 - have to annotate the return type and
123:01 - that would be string right
123:04 - because we are taking here in the string
123:07 - and then we are returning it back that
123:10 - means S2 will then hold the returned
123:13 - string
123:16 - and then we can print out S2
123:20 - and notice S1 can't be used after we
123:25 - have called this function with an
123:28 - argument of S1 because the ownership has
123:31 - been transferred to this function
123:35 - so meaning
123:37 - S1 is holding the data over here which
123:40 - means it's the owner then we call this
123:43 - function and provide it as one meaning
123:46 - this function over here becomes the
123:48 - owner and then we are assigning the
123:51 - return value to S2 so that means S2 over
123:54 - here will be the owner of the data
123:59 - in the end
124:01 - number three we are here calling the
124:03 - function GIF ownership
124:06 - and as you can see inside the function
124:08 - we are initializing a variable s which
124:11 - holds a string
124:14 - and we call here the into bytes method
124:17 - on S
124:18 - now let me show you that in the
124:21 - documentation
124:25 - so this is the in two bytes method
124:29 - now as you can see converts a string
124:32 - into a byte Vector so if we have a
124:35 - string over here and we call the into
124:38 - bytes method
124:39 - then we will get the string over here
124:43 - but represented as a vector of bytes
124:47 - okay
124:49 - and the important thing here is that
124:52 - this consumes the string meaning s over
124:56 - here will get consumed and that means s
125:01 - can't be used after this point
125:06 - now what we can do as an alternative we
125:09 - can use S bytes and S bytes just takes
125:13 - references and references will be our
125:16 - next topic so don't worry too much about
125:18 - it right now but when we call the S
125:22 - bytes method over here then the owner
125:27 - will remain
125:29 - the same right it doesn't consume the
125:33 - data
125:35 - so what we can do over here is calling
125:37 - the S bytes method and that means s
125:42 - Remains the owner of this data and we
125:46 - can return it then and that means s over
125:49 - here will be then the owner of The
125:52 - Returned value
125:57 - and then we just print out s
126:04 - fix the arrow without removing code line
126:07 - again we are initializing s with a
126:11 - string
126:13 - then we are calling the print store
126:15 - function with an argument s
126:19 - and all we do is we then print out the
126:23 - string
126:25 - but over here again we try to access S
126:32 - and that would be a compiler error
126:35 - because we are over here
126:38 - providing S as an argument to this
126:40 - function over here meaning this function
126:44 - will become the owner of the data s is
126:47 - holding and that means s is not
126:50 - accessible anymore
126:52 - what we can do over here is we can call
126:56 - the Clone method
127:03 - meaning we are providing this function
127:06 - over here a copy of this data so this
127:09 - data will get copied in Heap memory
127:13 - and that means s will still be valid
127:21 - don't use clone use copy instead
127:26 - so over here we have a tuple now this
127:30 - Tuple holds two integers a unit type and
127:34 - a string
127:36 - now let me annotate that
127:38 - we annotate tuples like that
127:41 - and we have to
127:43 - find each type of array value distribute
127:48 - so we have 2i32 integers
127:52 - One units type and one string
127:57 - now over here we are calling the Clone
128:00 - method and assign it to Y so y should
128:04 - actually hold the same
128:07 - uh values all right
128:11 - and because we have called the Clone
128:13 - method we can use both variables without
128:16 - the problem now it says don't use clones
128:20 - so we can't use clone over here
128:23 - now my solution to this would be if you
128:27 - take a look
128:28 - at the types this Tuple is holding then
128:32 - we see that most of the types over here
128:35 - are actually on the stack memory meaning
128:38 - they are of known fixed size right so
128:43 - inters and i32 would be of size 32 bits
128:47 - right a unit type would be of zero bits
128:51 - the only problem arises here because we
128:54 - have a string now a string is a heap
128:57 - allocated type meaning its size is not
129:01 - known at compile time now what we can do
129:05 - over here is we can use a string literal
129:13 - now
129:14 - we will cover the difference between
129:17 - strings and string literals but for now
129:20 - a string literal is a string that is
129:24 - hard coded into the binary
129:28 - itself into the program
129:31 - so it is immutable which means that this
129:35 - size is known at compile time so all T
129:40 - types the Tuple holes are known
129:45 - are of known fixed size at compile time
129:48 - so over here we can do the same
129:51 - and what's the reason we have been doing
129:54 - this because we know that a type that
129:56 - lives in stack memory meaning it's fixed
130:00 - size will get copied implicitly
130:04 - now this Tuple only holds fixed sized
130:09 - types meaning the Tuple itself is fixed
130:12 - size and that means X over here will get
130:16 - copied implicitly by the compiler all
130:20 - right
130:25 - mutability can be changed when ownership
130:28 - is transferred
130:30 - as you can see we are here initializing
130:32 - s with a string
130:36 - then modify this line only
130:39 - we are here assigning s to S1
130:45 - now over here as you can see we are
130:48 - modifying the string that S1 is holding
130:54 - and remember when we assign s to S1 S1
130:58 - will become the owner of this data
131:01 - meaning s will get dropped
131:05 - so we are then trying to mutate S1
131:09 - and we are pushing to it D string world
131:14 - now remember that a variable is
131:17 - immutable in its nature so we have to
131:20 - use the mute keyword over here to denote
131:24 - that S1 should be mutable
131:32 - and that means that
131:35 - if
131:36 - the ownership has been transferred to
131:39 - another variable we can change its
131:42 - mutability right even if s was immutable
131:46 - we can make S1 mutable without problem
131:50 - because S1 is now the owner of the data
131:57 - now over here as you can see we are
132:00 - initializing a variable x with a boxed
132:04 - integer type now box allows you to
132:08 - allocate directly on the Heap as you
132:11 - know this is an i32 and i32 is normally
132:15 - live in stack memory when we use this
132:19 - over here Box new and we box this i32 it
132:23 - means it gets allocated on the Heap
132:27 - and that means
132:29 - X will then hold a pointer
132:32 - to the data that was allocated in Heap
132:37 - memory so the type annotation here would
132:39 - be box and
132:42 - this box holds an i32
132:45 - and X then basically holds a pointer
132:52 - now over here implement this line don't
132:54 - change other lines
132:57 - now as you can see we have over here to
133:01 - declare y
133:03 - now y gets the referenced and that means
133:08 - we have
133:10 - over here to get back a pointer so we
133:14 - can do basically the same thing like we
133:17 - did before we can use Box new and let's
133:21 - do one for example
133:24 - so the variable one will hold a box
133:29 - with a type of i32
133:33 - and as I've said we allocate
133:36 - this integer
133:38 - on Heap memory meaning we get back a
133:42 - pointer and the pointer is a memory
133:46 - address to the location where this data
133:49 - has been allocated
133:52 - now because y holds a memory address
133:58 - we can't
134:00 - assign a value and integer value
134:04 - directly to Y because Y is just holding
134:08 - an address
134:11 - and not an i32 type because remember we
134:15 - can just assign a value to a variable if
134:19 - both of them are of same type
134:22 - now as you can see y holds the type of
134:25 - box i32 which is not the same type that
134:30 - means we have to de-reference and we are
134:33 - dereferencing using this star operator
134:36 - and and this star operator means
134:40 - we go to the location
134:44 - of Y because Y is holding a memory
134:47 - address and we want to access the value
134:50 - right so we want to access this interval
134:55 - that has been allocated on the Heap and
134:58 - that means we can assign a new value
135:02 - 2y but we have to use this store
135:05 - operator
135:07 - and again over here you can see it even
135:10 - better
135:12 - this would be equal right because X is
135:17 - pointing
135:18 - to a location in memory which holds an
135:22 - integral value of 5.
135:25 - now if we would omit the star operator
135:29 - this would not match because X would
135:32 - hold something like that
135:39 - right in memory address now this memory
135:42 - address and the integer 5 would not be
135:45 - equal but this star operator basically
135:49 - says go to this address and give me back
135:52 - the value that is stored at that address
135:56 - which would be 5.
136:05 - and of course we have to make this
136:08 - variable over here mutable
136:10 - right because we are here mutating y
136:17 - partial move within the destructuring of
136:20 - a single variable both by move and by
136:23 - reference pattern binding can be used at
136:26 - the same time doing this will result
136:28 - doing this will result in a partial move
136:31 - of the variable which means that parts
136:34 - of the variable will be moved while
136:36 - other parts stay in such a case the
136:39 - parent variable cannot be used
136:41 - afterwards as a whole however the parts
136:45 - that are only referenced and not moved
136:47 - can still be used
136:50 - so over here we have a lot of stuff we
136:54 - didn't cover yet and I will try my best
136:58 - to explain it but if you don't get it
137:00 - 100 it's no problem okay we will go into
137:04 - greater detail on each of these
137:07 - structures and types
137:10 - so as you can see over here we have a
137:13 - struct person now a struct is basically
137:16 - a custom type we can create our own
137:19 - types in Rust
137:21 - and
137:22 - a struct basically is a template we are
137:26 - saying here as you can see this truck
137:29 - holds two members
137:31 - one name which is of type string and one
137:34 - H which is of type boxed u8
137:38 - okay a heap allocated unsigned 8-bit
137:42 - integer
137:44 - then we have to instantiate
137:47 - and
137:49 - this person struct meaning we are using
137:53 - this template and create basically a
137:56 - concrete value of that so we are
137:59 - providing here for the name member a
138:03 - string like it's defined here and for
138:06 - the age we provide a boxed value of 20.
138:11 - now this person variable will then hold
138:14 - a type of person right this is now our
138:18 - own
138:20 - custom defined type
138:24 - now
138:26 - name is moved out of person but age is
138:29 - referenced
138:30 - so over here we are destructuring the
138:34 - person instance over here
138:37 - and we do that very similar to tuples we
138:42 - have seen we used to let keyword the
138:45 - name of destruct and then we the
138:49 - structure the fields so the person
138:54 - so the person instance over here will
138:58 - get the structure meaning person name
139:02 - will get put into the name variable and
139:07 - the H member here will get put inside
139:10 - this H variable now notice something we
139:14 - are here using the ref keyword meaning
139:19 - th variable will only take a reference
139:23 - of this data and not the actual data
139:27 - itself
139:29 - but name will get moved inside this
139:33 - variable so the name variable here will
139:36 - be the owner of this string
139:40 - right
139:42 - and that means that person is not the
139:45 - owner of this string anymore it has been
139:49 - when instantiating the struct but it is
139:53 - not anymore
139:55 - then as you can see we are printing out
139:58 - these variables
140:00 - but we then can't use the person
140:03 - instance right because the person
140:06 - instance is not the full owner of all
140:10 - team members inside it
140:13 - and also we can't access person.name
140:16 - this is how you would access normally a
140:19 - member in a struct person Dot and then
140:23 - they member in this case name but we can
140:26 - access
140:28 - person.h because the person instance
140:31 - over here is still the owner of age
140:34 - because again we have destructured it
140:37 - and the variable H only took a reference
140:41 - again
140:44 - if you don't understand a hundred
140:46 - percent it's fine okay we haven't
140:48 - covered a lot of this stuff going on
140:51 - here and I even think this is not a good
140:54 - example right now
140:57 - but yeah so exercise eight as you can
141:01 - see we have here a tuple holding two
141:04 - string types
141:09 - [Applause]
141:11 - now we are assigning the first element
141:16 - of the Tuple and by the way Cupids are
141:19 - also zero index like arrays and we can
141:22 - access the indexes like this
141:24 - the name of the variable and then Dot
141:28 - and the index we want to access in this
141:31 - case the first one
141:33 - that means that underscore s will hold a
141:38 - type of string right namely this over
141:40 - here
141:42 - and that means the ownership of this
141:45 - string data here got transferred to this
141:49 - variable so underscore s is now the
141:53 - owner of this data
141:57 - meaning we can't access T again because
142:02 - T is not the owner anymore of all the
142:06 - values it contains in the Tuple right so
142:10 - we can't use it again but we could still
142:12 - use T at index 1 because this over here
142:17 - is still owned by T because only the
142:21 - first element has been moved out
142:31 - and over here again a tuple with two
142:34 - strings
142:37 - [Applause]
142:39 - so fill the blanks
142:41 - as you can see what we want here is
142:44 - destructuring the Tuple and we want to
142:48 - initialize these two variables S1
142:53 - and S2
142:56 - and remember when we destructure it we
143:01 - have a syntax like that
143:04 - now over here as you can see when we are
143:07 - destructuring this Tuple
143:09 - both of the values
143:12 - it is holding will get transferred to
143:16 - these variables so S1 will be the owner
143:19 - of this stream and S2 will be the owner
143:22 - of this string meaning T doesn't own any
143:26 - values after this point
143:30 - but what we can do because we want to
143:33 - access T again over here we can call the
143:37 - Clone method as you've seen
143:41 - meaning S1 and S2 only hold copies of
143:45 - these strings and not the actual values
143:49 - and that means that t will still be
143:52 - accessible and T is still the owner of
143:56 - all the values inside the tuber
144:04 - alright see you in the next topic so
144:06 - let's look at borrowing borrowing is a
144:09 - way of temporarily access data without
144:12 - taking ownership of it
144:15 - when borrowing you're taking a reference
144:18 - a pointer to the data and not the data
144:22 - itself
144:23 - its goal is to prevent Dengue pointers
144:27 - and data races
144:30 - data can be borrowed immutably and
144:33 - mutably and there are certain rules when
144:35 - borrowing which we have to comply with
144:38 - otherwise the program won't compile
144:43 - let's look at these rules the first rule
144:46 - states that at any given time you can
144:49 - have either one mutable reference or any
144:53 - number of immutable references
144:56 - but you cannot have both you either have
145:00 - one mutable reference or any number of
145:03 - immutable references
145:05 - and the second is references must always
145:10 - be valid
145:11 - so let's see an example of a reference
145:14 - over here we are initializing S1 with a
145:18 - string then we call the calculate length
145:21 - function and as you can see we are here
145:24 - passing a reference to S1 and this is
145:28 - indicated by this Ampersand symbol over
145:31 - here so then let's see the calculate
145:34 - length function as you can see the
145:36 - argument should be of type reference to
145:40 - a string which we did provide right it's
145:44 - a reference this Ampersand to S1 which
145:48 - is of type string
145:50 - and then all this function does it will
145:53 - call the Len method which will return
145:57 - the length of the string
146:01 - and it returns it now notice that the
146:03 - return type will be of Type U size
146:08 - and then this Len variable over here
146:12 - will hold the length of this string
146:16 - and the type annotation would be use
146:20 - size right the return value of this
146:23 - function
146:24 - and then we just print out S1 and length
146:28 - and notice something over here we can
146:31 - use S1 because S1 over here stays the
146:36 - owner of the data we have just provided
146:40 - here a reference to S1 and not S1 itself
146:44 - so let's see how that looks
146:48 - as you can see we have S1 now again it's
146:52 - very important that you understand that
146:54 - the variable S1 over here doesn't hold
146:57 - the actual data but a pointer to the
147:01 - data which will get allocated to the
147:04 - Heap memory so when we allocate to the
147:07 - Heap we will get back a pointer which S1
147:11 - is holding alongside with other metadata
147:15 - now because over here we are providing
147:19 - S1 as a reference that means the
147:23 - variable s from this function
147:26 - will then
147:28 - be another pointer which points to the
147:31 - S1 variable so s points to S1 and S1
147:37 - points to the Heap allocated data
147:42 - and that means that S1 over here Remains
147:46 - the owner of
147:48 - the string
147:52 - let's see Mutual references as you can
147:55 - see we initialize a string and assign it
147:59 - to S now then we call the change
148:03 - function with a mutable reference and
148:07 - notice that you have to annotate that
148:09 - you want the reference to be mutable
148:11 - this is important and it has to be
148:15 - explicitly stated so that the rules are
148:20 - set in place because remember you can
148:23 - only have one single mutable reference
148:26 - at a time
148:27 - and then this change function over here
148:30 - as you can see in the function signature
148:32 - it takes an argument of type mutable
148:36 - reference to string which we are
148:39 - providing right we are providing a
148:41 - multiple reference to S which holds a
148:45 - string and then we can manipulate the
148:48 - string
148:49 - now again very important s Remains the
148:53 - owner of this data even though we are
148:57 - manipulating it in this function over
149:00 - here s Remains the owner because we are
149:03 - here dealing with references
149:07 - so let's look at some examples just to
149:13 - strengthen the knowledge of this concept
149:17 - as you can see we here initialize s with
149:20 - a string and then we have here two
149:24 - mutable references to S and we assign it
149:28 - to R1 and R2
149:31 - now this would fail this program doesn't
149:35 - compile now this would violate the first
149:38 - rule of borrowing which says that we can
149:41 - only have one mutable reference to the
149:44 - same data at a time
149:46 - but what we can actually do
149:49 - let's see this program as you can see
149:52 - again we have a variable s which holds a
149:55 - string
149:56 - and notice over here we have an inner
149:59 - scope
150:00 - so in this scope R1 will hold a mutable
150:04 - reference to s
150:06 - now because at the end of the scope R1
150:10 - we go out of scope meaning it will be
150:13 - dropped we can then again pass a mutable
150:17 - reference to R2
150:19 - so this program will compile
150:22 - so over here again initializing s with a
150:26 - string here we have two immutable
150:29 - references to S now up to this point no
150:33 - problem because the first rule states
150:35 - that we can have any number of immutable
150:38 - references
150:40 - the problem is over here because we are
150:44 - then assigning immutable reference to S
150:47 - to R3 this is a problem because this
150:52 - would violate the first rule of
150:54 - borrowing which says that we can either
150:56 - have any number of immutable references
150:59 - or one single mutable reference but we
151:02 - can't have both of them immutable and
151:05 - mutable references at the same time
151:09 - now over here as you can see we have the
151:12 - exactly same program but as you can see
151:15 - we are here having two immutable
151:18 - references assigned to R1 and R2 and
151:23 - then we just print it out now after this
151:27 - point over here
151:28 - the variables R1 and R2 won't be used in
151:33 - the entire program and that means that
151:36 - we can assign then a mutable reference
151:39 - to R3
151:41 - it's important to notice here that again
151:45 - we don't use R1 and R2 after this point
151:50 - so it's allowed to have a mutable
151:54 - reference over here
151:56 - while over here as you can see we are
151:58 - trying to access all of them at once
152:01 - this would cause a problem
152:04 - now I've showed you some of the reasons
152:06 - why the compiler is so strict and one of
152:09 - them was dangling references so let's
152:12 - see what a dangling reference is
152:15 - as you can see over here we are calling
152:19 - a function dangle now in tangle we are
152:23 - initializing a variable with a string
152:26 - type and then we are returning over here
152:30 - a reference to this string
152:35 - as you can see in the return type it is
152:37 - a reference to a string now the problem
152:41 - here is that when the function returns
152:45 - this variable over here will hold a
152:48 - reference to this string right
152:52 - and
152:53 - s over here will get out of scope at the
152:57 - end of this function scope here
153:01 - and that means
153:02 - this variable over here will point to
153:06 - something that has already been dropped
153:09 - or deleted so it points to a garbage
153:13 - value right
153:16 - and rust won't allow you to compile a
153:20 - program like that because this will
153:22 - violate the second rule which states
153:24 - that references must always be valid
153:28 - very important
153:31 - and to avoid that we can change this
153:33 - tangle function over here and just
153:35 - returning
153:37 - this string itself right so reference to
153:41 - nothing would then be the owner of the
153:44 - string
153:45 - but returning a reference to something
153:49 - that has been declared inside the
153:51 - function scope is a bad idea all right
153:55 - let's do some exercises
153:58 - as you can see we have here a variable
154:01 - holding an i32 value
154:04 - then over here fill the blank and we
154:07 - have to complete this
154:09 - P assignment over here now let me see
154:13 - over here the memory address of X is
154:17 - and we are providing P so we want to
154:20 - print out here the memory address and by
154:25 - the way this is denotation if we pass
154:27 - here a pointer that it actually outputs
154:32 - the address
154:34 - of the memory location that P is holding
154:38 - so over here what we want to do is we
154:40 - want a reference to X now as I've told
154:44 - you
154:46 - P will then be of type reference to an
154:49 - i32 right because X is holding an i32
154:53 - type
154:55 - now a reference to an i32 is basically a
155:00 - pointer to a location in memory that
155:03 - points to this
155:06 - data over here
155:08 - so P here holds a memory address we'll
155:12 - see that when we execute this program
155:17 - as you can see the memory address of X
155:19 - is
155:20 - this
155:22 - so
155:26 - this memory address is where
155:29 - the value 5 is stored in in memory
155:34 - and we are accessing that using a
155:37 - pointer over here
155:39 - again a pointer is just a normal
155:41 - variable which holds a memory address in
155:44 - this case the memory address of x
155:48 - right
155:50 - so this is a reference to X
155:55 - over here again we have variable X
155:58 - holding i32 type and a reference to X
156:02 - which is a reference to an i32 value
156:06 - modify this line again we compare here y
156:11 - with five now y doesn't actually hold
156:15 - the value 5 it holds a memory address
156:19 - now to access the data
156:22 - at which this y pointer here will point
156:26 - to we have to dereference and we do that
156:29 - with the reference operator
156:32 - like that that means go to the location
156:36 - of Y and give me the value right so when
156:41 - we go to the location where X is stored
156:47 - for example at this memory address we
156:49 - want to get the value that is stored at
156:53 - that address
156:54 - we are using
156:55 - here the star operator
156:58 - just to access the value
157:07 - so over here we initialize a variable
157:10 - holding a string type
157:13 - then we are calling the function borrow
157:15 - object
157:17 - and as you can see the borrow object
157:19 - function expects an argument of type
157:22 - reference to a string but what we are
157:26 - here providing is a string right we are
157:29 - providing s which is of type string now
157:33 - we want here to pass a reference to s
157:36 - meaning a reference to string in this
157:40 - case we are complying with the function
157:42 - signature
157:48 - over here again variable s holding a
157:51 - string then we call puster function over
157:55 - here now again we have to always take
157:57 - care of the function signature what is
158:01 - expected so as you can see the argument
158:04 - should be of type mutable reference to a
158:07 - string so we have to pass here a mutual
158:10 - reference to s
158:13 - where s is holding a string right
158:22 - number five again here having a string
158:29 - and
158:30 - as you can see over here we are mutating
158:34 - p
158:36 - so that means we want to have immutable
158:39 - reference
158:40 - to s
158:44 - as you can see p will then hold
158:51 - P will then hold immutable reference to
158:54 - a string type right
158:57 - and then we can mutate the string that P
159:01 - is holding and again because we are here
159:04 - having a reference S will remain the
159:09 - owner of the data meaning we still can
159:12 - use S even after this assignment over
159:16 - here
159:22 - ref can be used to take references to a
159:25 - value similar to ampersand
159:29 - as you can see we have here a variable
159:31 - holding HR
159:33 - and this over here would be a variable
159:36 - which holds a reference to a chart right
159:39 - a reference to C
159:42 - now fill the blank don't change order
159:45 - code now instead of here
159:49 - using the Ampersand symbol we can use
159:52 - the ref keyword and it's exactly the
159:55 - same actually they are very similar
159:57 - there are some minor differences in
160:00 - pattern matching
160:02 - um but we will come to that
160:05 - so when we dereference R1 and R2
160:11 - then this should hold the same
160:14 - data right
160:17 - and over here check the quality of the
160:19 - two address strings
160:22 - so we have here a function get address
160:25 - which gets called with R1
160:28 - and R2
160:31 - now all this function over here does is
160:34 - it takes a reference to HR as an
160:37 - argument and it will
160:41 - then put it inside this format macro now
160:45 - this format macro over here is the same
160:47 - as the print line macro with the
160:50 - difference that the print line will
160:52 - print to the standard output while
160:55 - format will return a string right so we
160:59 - take this argument
161:01 - and then we will
161:04 - return here the memory address of this
161:08 - reference
161:09 - now in this case R1 and R2 should hold
161:12 - actually the same memory address right
161:15 - because they are pointing to the same
161:19 - data this case C so R1 is pointing to C
161:24 - and R2 is pointing to C
161:28 - all right so let's see
161:34 - and this is compiling
161:37 - borrowing rules remove something to make
161:39 - it work don't remove a whole line again
161:42 - here having immutable variable s which
161:45 - holds a string then we have two mutable
161:50 - references to s
161:52 - and this actually would
161:56 - failed to compile because again we can
162:00 - only have one mutable reference at a
162:04 - time so to solve this as you can see
162:08 - over here we are just printing out R1
162:12 - and R2 so this reference over here don't
162:16 - need to be mutable right
162:20 - because it's sufficient that we have a
162:23 - read-only reference to S and again the
162:28 - rule states that we can have as many
162:30 - immutable references as we want
162:38 - so this is compiling and also just to
162:41 - show you
162:53 - when dealing with references over here
162:55 - as you can see s is still valid
162:59 - right
163:03 - error borrow an immutable object as
163:07 - mutable
163:08 - fix the error by modifying this line as
163:11 - you can see we have here a string
163:14 - and we call here borrow object with a
163:18 - mutual reference to S so the problem
163:21 - over here is that we can't pass a mutual
163:24 - reference to something which is
163:26 - immutable so we have to make this
163:29 - variable over here mutable and then we
163:32 - can
163:33 - uh
163:35 - then we can provide here a mutable
163:38 - reference to this variable
163:47 - but the other way around it's no problem
163:50 - okay borrow a mutual object as immutable
163:54 - so this code has no errors as you can
163:58 - see we have here a string
164:00 - and we are passing to the borrow object
164:03 - and immutable reference right
164:07 - now
164:08 - this would actually compile because as
164:12 - you can see the function signature
164:14 - States it should be an immutable
164:17 - reference even though s itself is
164:20 - mutable we can still pass it as an
164:23 - immutable reference this would compile
164:26 - without problems
164:31 - and then over here you can see we are
164:33 - even mutating s because it's mutable
164:40 - comment one line to make it work we have
164:43 - here a string
164:46 - and we have a mutable reference to S
164:49 - right
164:54 - so this would be the type annotation
164:56 - mutable reference to a string type
165:00 - now we are then mutating R1
165:04 - and over here we again have a mutable
165:08 - reference to s
165:16 - and then we are modifying R2 the problem
165:21 - here is that you know the rule that we
165:24 - can only have one mutable reference at a
165:28 - time
165:29 - but as you can see R1 over here gets
165:32 - used again so this should remain valid
165:36 - but we can't have two valid mutable
165:40 - references at the same time so if I
165:43 - comment this out
165:45 - then this program should compile because
165:48 - we are not using R1 after this point
165:51 - meaning we can have another mutable
165:54 - reference
165:56 - and even if I print out here R2
166:01 - this should also compile
166:03 - because over here the only valid mutable
166:07 - reference to S would be R2 because we
166:11 - are not using R1 after this point
166:18 - so over here again we have a string
166:22 - and we have two mutable references to S
166:27 - now if we would run that
166:30 - it would actually
166:32 - compile
166:37 - as you can see the program compiles
166:40 - even though we have two mutable
166:43 - references to S but we are not using any
166:46 - one of these in the program
166:49 - but over here it says add one line below
166:52 - to make a compiler error cannot borrow S
166:55 - as mutable more than once at a time
167:00 - you can't use R1 and R2 at the same time
167:03 - so let's use both of them over here
167:07 - to force this compiler error
167:20 - and as you can see this would be the
167:22 - compiler error we are expecting Canon to
167:25 - borrow S as mutable more than once at a
167:28 - time
167:30 - and over here you can see really the Rus
167:32 - compiler is one of the best compilers
167:35 - I've ever seen because it provides you
167:39 - with really useful compiler messages
167:43 - alright see you in the next topic so we
167:45 - have now reached the topic of compound
167:48 - types now a compound type is a type
167:51 - which is made up of other types for
167:55 - example a string is made up of
167:57 - characters so it's considered a compound
168:00 - type
168:02 - now we have in Rust two types of strings
168:06 - we have string with a capital S string
168:10 - like that and we have string slices now
168:15 - if I say string I will always refer to
168:18 - this type otherwise I will say string
168:21 - slice
168:23 - so a string is a heap allocated string
168:26 - type that owns its contents and is
168:29 - mutable we have seen that a string is
168:32 - allocated in Heap memory
168:36 - a string slice is an immutable sequence
168:39 - of utf-8 bytes in memory it does not own
168:43 - the underlying data and is immutable
168:48 - so think of string slice as a view on a
168:52 - sequence of characters stored as utf-8
168:55 - bytes in memory it's basically just read
169:00 - only
169:03 - so use string slice if you just want to
169:07 - view a string
169:09 - and string slice is more lightweight and
169:12 - efficient than string and U string if
169:16 - you need to own the data and be able to
169:18 - mutate it
169:22 - then we have string literals a string
169:25 - literal is a sequence of characters
169:28 - enclosed in double quotes
169:31 - its fixed size compile time known
169:34 - sequence of utf-8 bytes the type is
169:39 - reference to static string which
169:41 - indicates the data is stored in static
169:44 - storage meaning it is valid throughout
169:47 - the entire lifetime of the program
169:51 - the data is hard-coded into the
169:53 - executable and stored in read-only
169:56 - memory meaning they are immutable
169:59 - so let's now see an example of a string
170:02 - slice and I'm seeing my head is in the
170:04 - way here
170:06 - let's do it like that
170:08 - so let's see
170:10 - over here we are initializing s with a
170:13 - string now again I repeat myself I know
170:17 - but this is very important s doesn't
170:20 - hold the actual data it holds a pointer
170:23 - which points to the data that is that is
170:27 - allocated in Heap memory so s will have
170:31 - a pointer alongside other metadata that
170:35 - will point to the first
170:37 - character of the string
170:41 - and let's now consider this world
170:45 - variable here so we are taking a
170:48 - reference to s
170:50 - meaning s will remain the owner of the
170:54 - Heap allocated string
170:57 - so we are taking a reference to S and
171:00 - providing here an offset
171:02 - from 6 to 11. now I hope you remember in
171:07 - a Range this would be excluded so it
171:10 - would be from 6 to 10.
171:14 - so when we look at the world variable we
171:17 - see that it has a pointer and a length
171:21 - now this length over here is actually
171:23 - false I'm sorry for that this should be
171:26 - the length of the string slice in this
171:28 - case one two three four five so this
171:33 - pointer points to the offset of the
171:35 - string we have provided so it points to
171:38 - index six
171:40 - and it goes to 10 because again 11 is
171:45 - excluded so this world here will hold a
171:50 - string slice of
171:52 - this word
171:54 - right
171:57 - so the string slice World points to a
171:59 - sequence of characters stored on the
172:01 - Heap this is basically just a view into
172:05 - a heap allocated string and that's why
172:09 - it's immutable
172:12 - all right
172:13 - the type of string literal hello world
172:16 - is Ampersand stir for example let s
172:21 - string slice equals hello world now this
172:25 - would be a string literal right because
172:28 - we are
172:29 - hard coding it into the executable
172:34 - and a string literal is also considered
172:38 - a string slice because it's also
172:41 - immutable and it's basically just a
172:44 - reference to the static memory this
172:47 - string gets stored in
172:50 - so store and string slice we can't use
172:54 - Stir type in normal ways but we can use
172:57 - reference to stir
172:59 - fix error without adding new line as you
173:03 - can see this would over here be a string
173:05 - literal we are hard coding this string
173:09 - into the executable into the program
173:13 - itself
173:14 - so again we can't use Stir as a type but
173:18 - we can use a reference to a stir right
173:28 - we can only use Stir by boxing it
173:31 - Ampersand can be used to convert Boxster
173:34 - to string slice now fix the arrow with
173:38 - at least two solutions as you can see
173:41 - over here we have a string literal a
173:44 - string hard coded into the program
173:46 - itself
173:48 - then we call the into method we will
173:50 - cover that later but basically into will
173:54 - convert a type into the type we are
173:57 - annotating here so this string literal
174:00 - will be put into
174:02 - a box meaning it will be Heap allocated
174:06 - then we are calling this greetings
174:09 - function with an argument s
174:13 - and as you can see as this argument over
174:15 - here is has to be of string slice so
174:20 - what we can do over here to convert this
174:23 - box into a string slice is passing a
174:27 - reference to this box
174:36 - as you can see this is compiling but we
174:39 - even can just omit all of this
174:42 - right this photo would be string slice
174:47 - and we then just pass s notice that we
174:51 - don't have to pass a reference to S
174:54 - because s is already the type we need
175:03 - string type is defined in standard
175:06 - library and stored as a vector of bytes
175:09 - back but guaranteed to always be a valid
175:13 - utf-8 sequence string is Heap allocated
175:17 - growable and not null terminated
175:21 - so let's see we want to initialize here
175:24 - s with a string right
175:27 - then we are mutating
175:31 - this string over here and mutate it
175:35 - again now over here we are pushing to it
175:37 - a string literal and over here we are
175:42 - pushing to it a single chart now if you
175:46 - push a single chart you just use the
175:48 - push method not
175:50 - not the push stir method
175:53 - and in the end as should hold hello
175:57 - world now we can initialize here an
176:02 - empty string like that
176:08 - this is now an empty string type
176:14 - now why are we using this type over here
176:17 - and not string slice
176:20 - like so for example
176:26 - why aren't we use why aren't we doing it
176:29 - like that
176:31 - because remember a string slice and
176:33 - string literals are immutable
176:36 - they are just references to some string
176:40 - data in the memory so we have to use
176:43 - string here
176:50 - so we are here initiating an empty
176:53 - string and then we are mutating it and
176:57 - push to its held over and this
176:59 - exclamation mark
177:04 - this compiles let's output the string
177:14 - as you can see
177:16 - the string over here has been mutated
177:21 - and that's the whole point of using this
177:23 - string type over here it can be mutated
177:26 - they can grow and shrink and so on
177:32 - so let's see exercise four fix all
177:35 - arrows without adding new line as you
177:39 - can see over here we have initialized a
177:41 - variable with a string
177:44 - then we are mutating this string over
177:47 - here which means we have to make this
177:50 - variable s here mutable
177:53 - so we are pushing A Single Character
177:56 - this comma and then we are pushing
177:58 - another string like that and we can even
178:02 - push to the string by using this
178:05 - notation here even though I don't like
178:08 - it but it's also possible
178:12 - but over here
178:14 - we have two
178:17 - pass it a string literal because this is
178:20 - defined in this standard Library
178:24 - all right
178:27 - let's see
178:29 - and of course over here sorry we have to
178:32 - use the push stir
178:34 - method
178:40 - as you can see this is compiling so
178:43 - again we are pushing A Single Character
178:46 - then we are using here the push stir
178:48 - method pushing a string literal and we
178:52 - can also mutate strings like that
178:57 - we place can be used to replace
178:59 - substring
179:01 - again we have here a string
179:05 - and we then can replace
179:08 - some elements inside the string
179:11 - so we provide as first argument
179:14 - the element we want to replace in this
179:17 - case dogs
179:18 - and it should be replaced with cats
179:22 - so S1 should then hold I like cats now
179:26 - again replace will mutate the string
179:29 - meaning the S should be mutable
179:35 - foreign
179:39 - methods can be found under string module
179:42 - so number six you can only concat a
179:46 - stream with a string slice and strings
179:48 - ownership can be moved to another
179:51 - variable
179:52 - so we have here S1 holding a string
179:56 - and S2 also holding a string
180:00 - now as you can see we want to
180:02 - concatenate these two strings and we can
180:05 - use the plus operator for that
180:09 - now in the rust documentation it says
180:12 - that the first argument should be of
180:15 - type string while all other arguments
180:18 - must be string slices
180:21 - so we have to convert S2 over here to a
180:24 - string slice now there are two
180:27 - possibilities the first one is using the
180:30 - s store method like that so this over
180:34 - here will then be considered as a string
180:37 - slice
180:42 - so we have converted a string to a
180:46 - string slice
180:47 - right
180:49 - but the output
180:51 - but the result of this concatenation
180:53 - will be of type string it's important to
180:56 - remember that
180:58 - and S3 should then hold this
181:01 - concatenated strings
181:06 - now because S1 over here has been moved
181:11 - inside S3 we can't use S1 anymore
181:14 - because S3 has become the owner of this
181:19 - data
181:20 - so let's instead print out S3
181:27 - and as you can see this is compiling now
181:29 - there is an easier approach to that we
181:33 - can convert a string to a string slice
181:36 - by just
181:37 - by just
181:39 - providing a reference to a string so a
181:43 - reference to a string can be
181:46 - inferred to a string slice like that
181:55 - string slice and string opposite to the
181:59 - seldom using of stir string slice and
182:01 - string are used everywhere
182:04 - swing slice can be converted to string
182:07 - in two ways so we have covered that
182:09 - fixed arrow with at least two solutions
182:13 - so over here we have a string slice
182:17 - right
182:19 - now
182:21 - we call the greetings function over here
182:24 - with an argument of s now s should
182:27 - actually be of type string
182:29 - so we can convert that by calling this
182:33 - two string method like that
182:41 - so we have converted here
182:44 - a string slice to a string
182:48 - all right
182:49 - the second way would be
183:00 - doing it like that string from and then
183:05 - providing s
183:07 - as you as you can see this is compiling
183:11 - and
183:13 - there are other ways for example two
183:15 - ohms even though
183:17 - I think this is not used that much
183:23 - because it's more General but it's also
183:26 - possible
183:32 - right we can use string form or two
183:35 - string to convert a string slice to a
183:38 - string use two approaches to fix the
183:41 - arrow and without adding a new line
183:44 - as you can see we have here a string
183:46 - literal that has been put into a string
183:51 - so this variable over here will hold a
183:54 - type of string
183:56 - now to convert this s over here into a
184:00 - string slice because this is the type
184:02 - annotation of this variable we can as I
184:06 - did before we can pass as as a reference
184:10 - and again
184:15 - a reference to a string will be inferred
184:19 - to a string slice
184:21 - again we can use as stir for example
184:27 - would be the same
184:34 - string escapes you can use escapes to
184:37 - ride bytes by their hexadecimal values
184:40 - fill the blank below to show I'm writing
184:43 - rust
184:44 - so as you can see we can escape
184:48 - certain values and they will then be
184:51 - convert to ASCII characters for example
184:54 - this would be the hexadecimal
184:56 - representation
184:58 - of the ASCII value of s
185:03 - right so if we want to write rust here
185:07 - then the next
185:10 - character to S would be T so we would
185:13 - write
185:14 - X 74.
185:17 - like that
185:20 - and you can check this out over here
185:23 - there are a lot of examples
185:25 - where we can just Escape using the
185:28 - backslash Now using two backslashes here
185:32 - will print out this literal
185:36 - and these literal characters so the
185:40 - output will be backslash x3f okay
185:45 - because we are basically escaping this
185:49 - backslash
185:56 - all right and over here we have raw
185:59 - string and a raw string is a string in
186:02 - which there are no escapes so everything
186:06 - is printed literally as it is written so
186:11 - the output of this let me run that
186:15 - so the output of this would be
186:19 - backslash x3f it won't be converted to
186:23 - an ASCII character
186:26 - so let's see string index you can't use
186:29 - index to access HR in a string but you
186:32 - can use slice
186:34 - reference to a S1 for example and the
186:37 - offset
186:39 - so let's see we have here a string
186:45 - and now we want to access the first
186:47 - character
186:49 - now in most programming languages this
186:52 - would be possible but in Rust you have
186:55 - to use string slices meaning you take a
186:58 - reference to S1 and then provide the
187:02 - offset if we want to only access the
187:05 - first character we would provide an
187:07 - offset in form of a range from 0 to 1.
187:11 - now again in a Range this would be
187:13 - excluded meaning we only access this
187:17 - first element
187:19 - so the return type will then be a string
187:22 - slice notice something here when we
187:26 - assert age we would have a string of H
187:30 - and not a character even though we are
187:33 - here only accessing a character we are
187:36 - accessing it using these string slice
187:41 - this string slice notation over here
187:44 - so remember a string slice is just a
187:47 - view into a heap allocated string right
187:50 - so we are just looking what is at this
187:54 - location
187:55 - in this case we just want to access the
187:58 - first location over here
188:01 - right
188:03 - modify this line to fix the error tips
188:07 - this would take three bytes in utf-8
188:10 - format and that's right we have said
188:12 - that a character in Rust is of size 4
188:16 - bytes now a character in a string is a
188:20 - little bit different so if it is an
188:22 - ASCII a character then it will usually
188:26 - take one byte and DC Unicode characters
188:30 - can take three bytes or I guess some of
188:33 - them even four bytes
188:36 - all right so we want to have in H1 only
188:40 - this character
188:42 - so again we are taking a reference to S1
188:45 - and providing an offset oh
188:48 - 8 would be at index 0 I would be at
188:51 - index 1 this comma index 2 and then this
188:56 - will be index 3. now this takes up three
188:59 - bytes so we have to provide here an
189:02 - offset from three to six remember six is
189:06 - excluded so it goes from three to five
189:09 - three four five three bytes
189:17 - let me output that
189:25 - as you can see this would be the output
189:29 - and again this is just a view into a
189:34 - heap allocated string right
189:40 - operate on utf-8 string fill the blank
189:43 - to print each character in this string
189:46 - so over here there is a method called
189:50 - chores
189:53 - now chores will put this sequence of
189:56 - characters into an iterator meaning we
190:00 - can then iterate over it using a for
190:03 - Loop for example
190:04 - and that means
190:06 - c will then be in each iteration one of
190:10 - these characters and we will then just
190:13 - find out C
190:17 - as you can see in each iteration we are
190:20 - printing out a single character alright
190:24 - that's it see you in the next topic so
190:27 - we'll Now cover arrays now an array is a
190:31 - fixed size collection of elements of the
190:34 - same data types stored as contiguous
190:36 - Block in stack memory now it's stored in
190:40 - stack memory because its size is known
190:43 - at compiled time
190:45 - the signature of an array is like that
190:49 - you can see over here
190:50 - which indicates that the length is fixed
190:54 - at compile time arrays can neither grow
190:57 - nor shrink they must retain their size
191:01 - so let's see
191:03 - the type of array is like this as you
191:07 - can see erase length is part of their
191:10 - type signature so their length must be
191:13 - known at compiled time for example you
191:16 - can't initialize an array like below
191:19 - this would not be possible as you can
191:22 - see we have an init R function which
191:25 - takes an argument of type i32 and then
191:29 - we try over here to initialize an array
191:32 - with
191:35 - the length that is provided as an
191:38 - argument
191:39 - this would be and compiler error because
191:42 - as we've seen the size of an array must
191:45 - be known at compiled time if we do it
191:49 - like that the size of the array would
191:51 - only be known at runtime this will cause
191:54 - an error because the compiler has no
191:57 - idea of the exact size of the array at
192:00 - compile time let's see fill the blank
192:03 - with proper array type
192:05 - as you can see we have here an array
192:08 - with five elements now what would be the
192:12 - type of these elements it would be the
192:15 - default integer type which is i32
192:19 - so we annotate arrays like that in
192:23 - square brackets then we would have to
192:26 - type of the elements
192:28 - and the amount of elements inside of the
192:33 - array which is five
192:35 - modify the code below to make it work so
192:39 - we can call the Len method on an array
192:42 - and it will then provide the length of
192:45 - the array
192:47 - so in this case this would be 5 right
192:50 - because there are five elements inside
192:56 - number two we can ignore parts of the
192:59 - array type or even the whole type let
193:02 - the compiler infer it for us
193:05 - so we actually don't have to annotate
193:08 - the type or we can annotate the type but
193:11 - leave
193:12 - for example the type annotation here for
193:16 - the compiler to infer
193:19 - fill the blank arrays or stack allocated
193:22 - size of well returns to bytes which in
193:25 - Array occupies HR takes four bytes in
193:29 - Rust Unicode Char so we have seen that
193:32 - before the size of well we'll just take
193:34 - an argument and it will output the size
193:38 - in bytes
193:40 - the provided argument occupies in memory
193:44 - so if we provide the r over here then we
193:49 - should actually get back
193:51 - 3 times 4 bytes because because a
193:56 - character in Rust takes four bytes
193:58 - meaning
194:01 - this array over here would occupy 12
194:05 - bytes in memory
194:13 - all elements in an array can be
194:15 - initialized to the same value at once
194:19 - so as you can see we have here an array
194:22 - which should hold 100 elements
194:27 - and each element should hold the number
194:30 - one okay we are here accessing the first
194:34 - element
194:35 - and this is the notation for accessing
194:40 - elements in an array in this case we
194:42 - access the first element at index 0.
194:47 - until length would be 100 so instead
194:55 - of typing out 100 times 1 we have a
195:00 - short 10 Syntax for that
195:02 - so we can here first of all provide the
195:06 - element it should hold in this case one
195:09 - and we want it to hold 100 elements of
195:14 - this value over here
195:28 - number four all elements in an array
195:30 - must be of the same type
195:34 - so as you can see because when we
195:36 - annotate an array we actually have to
195:40 - define the type here
195:43 - in this case we want integer types and
195:46 - we have three of them now as you can see
195:48 - this is a torrent this is not possible
195:52 - all elements inside an array must be of
195:56 - the same type
196:03 - indexing starts at zero so over here we
196:07 - have an array of characters let's
196:10 - annotate that
196:14 - and there are three elements inside it
196:17 - and now we want to access the first
196:21 - element right
196:23 - we want this variable over here to hold
196:26 - the first element now again arrays our
196:29 - zero indexed meaning we access it using
196:33 - this notation here and provided a value
196:37 - of 0.
196:45 - out of bounds indexing causes panic so
196:49 - over here we have an array
196:51 - which holds two strings
196:56 - and we want to
196:58 - access the first element right
197:02 - now we can use this notation over here
197:05 - like we did before or we could use the
197:09 - get method the difference is that get
197:12 - will return an option type we'll cover
197:15 - that in a later episode but it's
197:18 - generally safer than using this notation
197:22 - and this is especially true if you're
197:27 - accessing elements at runtime okay
197:31 - so
197:33 - we can use this notation or we could use
197:36 - this notation now over here this would
197:39 - panic because this array has only two
197:43 - elements meaning indexes 0 and 1. so
197:47 - let's access here index one
197:55 - and this compiles
197:59 - so let's see slices a slice is a
198:02 - reference to a contiguous sequence of
198:05 - elements in a collection it provides a
198:08 - way to borrow part of a collection
198:10 - without taking ownership of the entire
198:14 - collection it can be created from arrays
198:17 - vectors strings and other collections
198:20 - implementing DT ref trade
198:25 - so let's see this example of a slice we
198:29 - have here an array and then we are over
198:33 - here taking a reference to a and
198:37 - providing an offset
198:39 - essentially the same thing we did with
198:43 - string slices right a slice is just a
198:47 - view into a collection
198:51 - and over here we try to access the
198:53 - elements at index 1 to index two right
198:58 - because 3 would be excluded
199:02 - so the variable slice will then hold a
199:04 - slice with the elements 2 and 3 in it
199:09 - all right let's see slices are similar
199:13 - to arrays but their length is not known
199:15 - at compiled time so you can't use slice
199:18 - directly
199:20 - here both this slice over here and store
199:24 - or slice types but directly using it
199:28 - will cause errors you have to use the
199:30 - reference of this slice instead so
199:33 - because these two slices over here
199:37 - their sizes are not known at compile
199:40 - time we have to use a pointer to that
199:43 - right
199:45 - and we have seen that in the example of
199:48 - string slices
199:49 - so we use this syntax over here
199:53 - fix the arrows don't add new lines
199:57 - as you can see we are holding here an
199:59 - array let's annotate the type
200:04 - like that
200:06 - this is an array of three i32 integers
200:10 - now we want here to get a slice with
200:15 - this offset meaning from 0 to 1 0 1.
200:21 - so again like we did with a string slice
200:23 - we want a reference to an array
200:27 - with this specific offset so we are
200:31 - trying to access 0 to 1 because 2 is X
200:34 - because 2 is excluded meaning we are
200:38 - accessing here index 0 and 1. the
200:42 - elements one and two so this slice over
200:45 - here
200:46 - will then hold one and two right
200:51 - now the type annotation here would be
200:54 - like that because we are holding a
200:56 - reference to this array right and this
201:01 - would be the type annotation of a slice
201:08 - now over here we have a string later on
201:11 - now
201:13 - string literals as we've seen always are
201:17 - annotated like that
201:20 - string literal is hard coded into the
201:23 - program's binary and that's why we can
201:27 - access it using a reference
201:30 - to this string literal over here which
201:33 - is in the binary itself
201:36 - all right
201:43 - a slice reference is a two word object
201:46 - for Simplicity Reasons from now on we
201:49 - will use slice instead of slice
201:51 - reference the first word is a pointer to
201:55 - the data and the second word is the
201:57 - length of this slice the word size is
202:01 - the same as U size determined by the
202:04 - processor architecture for example 64
202:07 - bits on an
202:09 - x8664 slices can be used to borrow a
202:13 - section of an array and have the type
202:16 - signature
202:18 - like this
202:20 - where T over here stands for the type
202:25 - as you can see we have here an array
202:27 - with three characters
202:30 - now we want to have a slice of this
202:34 - array with
202:36 - the first two elements these two
202:40 - elements
202:41 - and this is shorthand notation instead
202:45 - of writing it like that we can just omit
202:48 - the zero
202:49 - all right so we are accessing 0 1 and 2
202:54 - is excluded
203:04 - so the slice variable should hold a
203:07 - slice with these elements
203:10 - the type annotation over here would be
203:12 - reference
203:14 - to char
203:16 - okay
203:19 - modify 8 to make it work tips slice
203:23 - reference is not an array if it is an
203:26 - array then assert will be packed each of
203:29 - the two characters this and this
203:32 - occupies four bytes 2 times 4 8.
203:37 - now because this slice variable over
203:41 - here doesn't actually hold an array but
203:44 - a slice
203:45 - we are here actually holding a pointer
203:49 - right because this is a reference to
203:52 - this array
203:54 - and that means we have seen over here A
203:57 - Slice reference is a two word object
204:01 - meaning the pointer and the length field
204:06 - will both occupy sizes of Type U size
204:11 - and your size
204:13 - if you're on a 64-bit computer it means
204:17 - you size will be of size 8 bytes or 64
204:21 - bits
204:23 - and that's why a slice holds
204:27 - 16 bytes
204:30 - right
204:31 - if we would pass the array here we would
204:34 - have
204:39 - if this slice would have been an array
204:41 - then 8 would actually pass because we
204:44 - would have two characters each character
204:47 - is four bytes meaning eight bytes but
204:51 - because we have a slice which holds a
204:54 - pointer and a length both of Type U size
204:57 - we have 16.
205:02 - so over here we have an array of five
205:05 - integers of type i32
205:08 - fill the blanks to make the code work as
205:12 - you can see we want the slice variable
205:14 - to hold a slice of these elements
205:19 - so
205:20 - let's first
205:22 - annotate the type actually so this slice
205:25 - variable over here should hold a slice
205:29 - of I 32 elements right so we are taking
205:36 - a reference to the array and provided an
205:39 - offset we want to go from this to this
205:44 - meaning index 0 1 we are starting at 1
205:49 - and we go up to 0 1 2 3 4.
205:57 - and I choose 4 here because 4 is
206:00 - excluded so we will go from 0 1 2 3 to
206:06 - index 3.
206:13 - string slices
206:15 - and we've covered that already but let's
206:18 - do some exercises for repetition now
206:22 - over here we have a string and we take
206:25 - over here a string slice
206:29 - meaning we take only
206:32 - the first two characters
206:44 - like that
206:46 - or let me write
206:52 - like like that right we take the first
206:54 - two characters
206:56 - fill the blank to make the code work
206:59 - don't use 0 to 2 again
207:02 - so over here we have a second variable
207:06 - which should hold a string slice and
207:09 - they should actually hold the same
207:11 - elements as you can see over here we are
207:14 - we are here asserting that slice one and
207:17 - slice two are the same
207:20 - so instead of using this syntax over
207:23 - here as we've seen before we can use
207:25 - like that we can omit t0
207:30 - over here we have a string literal
207:34 - again a string literal is hardcoded in
207:37 - 2D binary and this would be the type
207:39 - annotation
207:41 - modify this line to make the code work
207:44 - as you can see we want slice over here
207:48 - to hold
207:50 - a string slice with only this character
207:56 - so let's annotate the type this would be
207:58 - a string slice and because this Unicode
208:02 - character over here takes three bytes we
208:05 - have to provide an offset here of three
208:08 - meaning
208:09 - zero one two right three bytes
208:19 - alright last one number six a reference
208:23 - to a string can be implicitly converted
208:26 - into a string slice
208:28 - now over here we initialize a variable s
208:31 - which holds a string
208:35 - here reference to S is reference to
208:38 - string type but first word needs aced
208:42 - but first word needs a string slice as
208:46 - you can see over here
208:48 - it works because reference to string can
208:51 - be implicitly converted to string slice
208:54 - so as you can see over here we are
208:57 - calling the first word function which
209:00 - takes us an argument a type of string
209:02 - slice
209:04 - and
209:05 - this would actually work because we are
209:09 - here providing a reference to S which
209:12 - means this over here is
209:15 - a reference to a string right
209:19 - and
209:20 - a reference to a string can be converted
209:23 - to a string slice implicitly by the
209:27 - compiler
209:29 - so then this function over here will
209:31 - take a reference
209:33 - of s
209:36 - and provides an offset from 0 to 1 where
209:40 - 1 is excluded so we just so we just take
209:44 - the first element
209:47 - and it returns this as a string slice
209:50 - that means that the return value of this
209:54 - function will be assigned to the word
209:56 - variable
209:59 - then over here we are calling the clear
210:01 - method on S which means this string will
210:06 - then be empty clear will just remove
210:08 - every content in the string the string
210:11 - itself will still remain in memory with
210:14 - the same capacity and S also is valid so
210:19 - it's different from drop but it will
210:22 - empty the string essentially
210:25 - so we will then have over here an empty
210:28 - string
210:30 - the problem over here is that clear
210:32 - takes immutable reference to self
210:37 - and
210:39 - that's a problem because over here we
210:41 - have a reference which is immutable to S
210:46 - and we have over here immutable
210:48 - reference to us
210:51 - now
210:52 - the problem arises because we are here
210:55 - using the immutable reference so if we
211:00 - would delete that and put it over here
211:04 - then
211:05 - after this point the word variable over
211:09 - here which holds an immutable reference
211:12 - is not used anymore and so we can use
211:17 - this clear method
211:24 - and this is compiling and as you can see
211:26 - we just get the first element
211:32 - alright see you in the next topic
211:35 - now we will cover tuples we have seen
211:38 - some tuples before and some exercises
211:40 - but now we will go into greater detail
211:44 - so a tuple is a way to store related
211:47 - pieces of information in a single
211:50 - variable and it's essentially a
211:52 - collection of values of different types
211:55 - grouped together as a single compound
211:58 - value again a compound value is a type
212:02 - composed of other types
212:05 - it's stored as a fixed size contiguous
212:08 - block of memory on this stack and the
212:11 - signature is parentheses and the types
212:16 - the Tuple is holding
212:20 - let's see
212:21 - elements in a couple can have different
212:24 - types pupils type signature is like that
212:28 - where T1 T2 are the types of tuples
212:33 - members
212:34 - so as you can see we can hold different
212:37 - types we have here an u8 and an i16
212:42 - together in a tuple
212:46 - tuples can be tuples members so we can
212:50 - even Nest tuples so this Tuple over here
212:55 - as you can see
212:57 - holds an u8 over here
213:01 - and another Tuple inside it which holds
213:06 - an i16 and a u32 integer
213:10 - all right
213:12 - fill the blanks to make the code work
213:16 - so over here we have to annotate the
213:19 - type now again the first element over
213:22 - here would be u8 the second one is u16
213:29 - the third one is an I64
213:33 - the fourth one would be a string literal
213:40 - and the last one is a string
213:49 - members can be extracted from the Tuple
213:52 - using indexing
213:55 - so as you can see we have here a tuple
213:58 - let's annotate the type
214:00 - this is how we would annotate a tuple
214:04 - and it holds
214:05 - three string literals
214:10 - then we are accessing here the second
214:14 - element tuples remember are zero indexed
214:18 - but in this case it would be M but we
214:22 - want it to equal sulfates so we have to
214:25 - access
214:27 - d
214:29 - index 2 right 0 1 2.
214:38 - long tuples cannot be printed so
214:42 - if a tuple exceeds a certain amount of
214:46 - elements it is too long to be printed
214:53 - as you can see this would be too long
214:57 - if I delete that over here
215:03 - so this would work so we can have up to
215:06 - 12 elements in a tuple to make it
215:09 - printable
215:11 - if it exceeds 12 elements you can still
215:14 - use it but it's not printable
215:17 - the structuring Tuple with pattern
215:22 - so let's first annotate the type of this
215:24 - Tuple here
215:26 - we have an i32
215:29 - the default integer type then we have a
215:31 - float
215:32 - which means f64 the default floating
215:35 - Point type and we have a string literal
215:40 - fill the blank to make the code work
215:43 - so over here we want to destructure this
215:47 - Tuple where X holds one y holds hello
215:52 - and that holds 6.4
215:56 - so let's see
216:00 - re-distructure tuples like this using
216:03 - the let keyword and the parentheses
216:07 - then
216:08 - the first element should be X right
216:13 - now the second element 6.4 should be put
216:16 - into Z
216:20 - and the last element should be
216:23 - destructured into variable y
216:31 - the structural assignments over here we
216:34 - are declaring some variables and then
216:37 - over here we destructure this Tuple and
216:40 - we want to put it inside these variables
216:44 - so we can so because we have already
216:47 - declared these variables we don't need
216:50 - to declare it once more so we can omit
216:53 - the LED keyword
216:55 - and then
216:57 - all we do is we destructure it so one
217:02 - should be put inside variable y
217:06 - 2 should be put inside variable Z
217:11 - and 3 should be put inside variable X
217:19 - tuples can be used as function arguments
217:23 - and return values
217:25 - fill the blank need a few computations
217:28 - here
217:30 - so
217:34 - so as you can see we are calling this
217:37 - function some multiply and this function
217:40 - over here expects an argument of type
217:43 - Tuple and the Tuple should hold two
217:47 - integer values what we do over here is
217:51 - we perform some operations and return it
217:54 - in a tuple right so
217:58 - so the first operation will be this one
218:01 - adding the first element of the provided
218:05 - Tuple with the second element of the
218:07 - provided Tuple
218:09 - and then we are multiplying the first
218:12 - element of the provided Tuple with this
218:15 - second element of the provided Tuple and
218:18 - we return that in a tuple again so the
218:23 - result of this operation over here will
218:25 - be the first element
218:27 - and the result of this operation will be
218:30 - the second element and as you can see we
218:32 - and as you can see we can return that in
218:36 - a tuple
218:37 - now after returning this Tuple we
218:41 - destructure it so the first element will
218:44 - be put in X and the second element will
218:48 - be the structured to the variable Y
218:50 - where X will hold 5 and Y will hold 6.
218:56 - so we have now to provide here two
218:59 - numbers when we add them together they
219:02 - will equal they will evaluate to five if
219:06 - we multiply the two numbers they will
219:09 - evaluate two six so this is a little
219:12 - riddle for you and try to solve it
219:17 - and the answer would be
219:20 - 2 3 right and don't forget to add here
219:25 - parentheses because we are passing it
219:28 - here a tuple right we are not passing
219:32 - two arguments we are passing one
219:35 - argument which is a tuple that holds two
219:38 - elements very important
219:42 - so if we add 2 and 3 we will get 5 and
219:46 - if we multiply two times three we will
219:49 - get six and this will be the return type
219:52 - of this Tuple over here
220:01 - all right see you in the next topic
220:03 - up until now we have been using types
220:06 - that are defined in this standard
220:08 - library but we can in fact create our
220:11 - own types
220:12 - and we can do that by using a struct now
220:17 - a struct is a compound type allowing to
220:19 - group together values of different types
220:22 - into a named data structure
220:25 - it's similar to tuples but each value
220:28 - has a name so the values can then be
220:31 - accessed through this name
220:33 - and a struct has to be instantiated with
220:36 - data think of it like destruct itself is
220:40 - the template for the instances you
220:42 - create from it
220:46 - now let's see how that works
220:49 - as you can see over here we have our
220:52 - template in this case a struct named
220:55 - user and the user struct holds various
220:59 - fields and we can define a field by
221:02 - giving it a name and a type that this
221:06 - field should hold so in this case the
221:08 - active field holds a type of Boolean
221:11 - username holds a type of string email
221:14 - string and sign in count u64 and then we
221:19 - can instantiate this struct and we do
221:22 - that by calling the name of destruct
221:24 - user in this case and providing for each
221:29 - field a concrete type
221:33 - and of course the types have to match
221:35 - the template
221:36 - then we are assigning this instance we
221:40 - have created over here to a variable so
221:43 - this variable will then hold an instance
221:46 - of the user struct
221:50 - and we can access and even mutate the
221:53 - fields of an instance so over here as
221:57 - you can see we have created an instance
221:59 - and assigned it to the user1 variable
222:03 - and then we can use this syntax over
222:05 - here to access a field
222:08 - so in this case we are even mutating the
222:13 - email field from the instance user 1. as
222:17 - you can see we do that exactly like we
222:20 - would mutate a variable
222:23 - just assigning it a new value
222:26 - now to mutate you have to make it
222:29 - explicitly mutable meaning you use the
222:33 - mute keyword here like you did with
222:35 - variables
222:37 - and functions can also create instances
222:41 - and return it so in this case we have
222:44 - the build user function which creates an
222:47 - instance of the user struct and as you
222:50 - can see again it's just providing
222:53 - concrete values for each of its fields
222:57 - and over here as you can see this
223:00 - function takes two arguments email of
223:03 - type string and username of type string
223:06 - and then it provides it 2D username
223:11 - field and to the email field
223:14 - now in this case we are repeating
223:16 - ourselves as you can see and we can
223:19 - avoid this by just using this shorthand
223:22 - syntax
223:23 - so if the name of a field and the name
223:27 - of a variable or argument matches then
223:30 - we can write it like that and this just
223:34 - makes it less verbose
223:37 - and there is also a concept called
223:40 - struct update syntax so over here we
223:43 - have an instance of the user struct now
223:47 - we want to create another instance but
223:50 - taking some of the values from the
223:53 - fields from user 1. as you can see for
223:56 - example in this instance we want the
223:59 - active field to hold
224:01 - the value of user 1's active field
224:06 - so we are accessing user 1 and the
224:09 - active field
224:10 - and as you can see we are taking
224:13 - everything from this user one instance
224:16 - except the email
224:19 - and
224:21 - as I've said there is a better way to
224:24 - write this and this would be
224:26 - instantiating a struct like we did
224:29 - before but just providing the fields
224:31 - that are different from the instance we
224:35 - we want to take from it
224:38 - so for example over here we say that the
224:42 - email field should hold this value
224:44 - and the remaining values should be taken
224:47 - from this user 1 instance so this will
224:51 - then create a user instance
224:55 - with all the same values from user 1
224:58 - except the email field
225:03 - then we also have Tuple structs and
225:07 - Tuple structs are like normal structs
225:10 - but using tuple-like Syntax for defining
225:13 - their fields it's basically a named
225:16 - Tuple and it's instantiated by
225:19 - parentheses instead of curly braces and
225:24 - its values are accessed using Point
225:27 - notation
225:29 - and then we have unit-like structs and
225:33 - these are structs without any Fields
225:35 - meaning they don't hold any values
225:38 - and it's mainly used when working with
225:42 - trades and this will be covered soon
225:44 - and that means they don't store any data
225:50 - let's solve some exercises the types of
225:53 - structs
225:54 - exercise one we must specify concrete
225:57 - values for each of the fields in
226:00 - destruct
226:01 - as you can see we have here a person
226:04 - struct holding various fields
226:08 - and then over here we have a variable H
226:12 - which holds a value of 30. now then we
226:16 - are instantiating this person's struct
226:20 - and assign it to the variable P meaning
226:23 - P will then be an instance of the
226:26 - person's struct
226:28 - now as you can see we have here the
226:30 - fields and the concrete values
226:34 - and this would be the shorthand Syntax
226:37 - for this because we have over here a
226:41 - variable matching the name of the field
226:45 - so we can write it like that
226:48 - but as you've noticed we didn't provide
226:51 - the hobby field a concrete value so when
226:55 - you are instantiating a struct you have
226:58 - to provide to each field a concrete
227:02 - value so let's do that
227:13 - and the variable P will then hold a type
227:16 - of person
227:18 - now h of course has to match with the
227:21 - templates so this would be an u8
227:25 - [Applause]
227:35 - and of course
227:37 - we use commas here and not say me colons
227:43 - all right
227:44 - unit struct doesn't have any field it
227:48 - can be useful when you need to implement
227:49 - a trade on some type but don't have any
227:53 - data that you want to store in the type
227:56 - itself
227:57 - so as you can see this example is using
228:01 - trades and we have and we have not yet
228:04 - covered that so I will skip that because
228:07 - this might just be confusing and we will
228:12 - cover that soon
228:16 - number three Tuple truck looks similar
228:19 - to tuples it has added meaning this
228:22 - track name provides but has no named
228:25 - fields
228:25 - it's useful when you want to give the
228:28 - whole Tuple a name but don't care about
228:31 - the fields names
228:35 - so as you can see over here we have two
228:38 - Tuple structs one color and one point
228:42 - and they are exactly like tuples but
228:45 - they are named okay so over here we have
228:49 - three integer values in the color Tuple
228:53 - struct and in the points rack the same
228:56 - thing now we want to instantiate the
229:00 - point struct over here
229:02 - and the variable V will then hold an
229:05 - instance
229:06 - of our custom type point
229:11 - then we are calling the check color
229:14 - function and provide an argument of B
229:18 - now as you can see
229:20 - the check color function
229:23 - takes an argument of type color but this
229:27 - is not what we want right because we are
229:29 - here passing a variable of type point so
229:33 - let's change that
229:37 - and over here we are then destructuring
229:40 - the instance
229:42 - that was passed so in this case as you
229:46 - can see X should hold zero so let's
229:49 - provide this value over here
229:52 - then the P1 field and as you can see we
229:56 - are accessing
229:58 - the fields in the Tuple struct like we
230:01 - would access elements in a normal Tuple
230:04 - using this syntax so over here we are
230:08 - accessing the second element and this
230:11 - should hold 127.
230:15 - so that means the last element should
230:17 - hold 255.
230:21 - and
230:24 - as you can see over here we are
230:26 - destructuring
230:28 - so the first element over here gets this
230:31 - structured into a variable X
230:34 - now the second one over here we don't
230:37 - need to destructure right because we are
230:40 - accessing it directly using the PE
230:43 - instance
230:46 - and the last one let's call this Z okay
230:52 - and by the way when destructuring and
230:55 - you don't need a value like for example
230:57 - this one you just provided an underscore
231:02 - let's see
231:08 - and of course when the structuring we
231:10 - have to provide the name of this truck
231:13 - in this case point
231:17 - and this is compiling
231:20 - operating on structs you can make a
231:23 - whole struct mutable when instantiating
231:26 - it but rust doesn't allow us to Mark
231:28 - only certain Fields as mutable
231:33 - fill the blank and fix the arrow without
231:36 - adding removing new line
231:39 - again we have the person struct we have
231:42 - here the age variable
231:45 - let's annotate that and we have the P
231:48 - instance
231:51 - so as you can see we want to mutate the
231:55 - age field of the P instance
231:58 - and this is right but the problem is the
232:02 - P instance is not mutable so let's make
232:05 - that mutable
232:07 - and then we can also mutate the name
232:11 - field like that
232:19 - using field initial shortened syntax to
232:22 - reduce repetitions
232:25 - so again we have the person struct and
232:29 - in main we are just printing out
232:31 - something and over here we have the
232:34 - build person function so as you can see
232:37 - this function takes two arguments name
232:40 - of type string and H of type u8
232:44 - and these arguments exactly match the
232:48 - types defined in the template
232:51 - so then we can over here instantiate a
232:55 - person struct
232:56 - meaning we can hear for the name field
233:00 - provide this argument
233:03 - [Applause]
233:04 - and we have seen we can use field image
233:07 - for 10 syntax meaning if the field name
233:10 - matches the name of a variable or an
233:13 - argument we can skip it like that
233:20 - let's see exercise 6 you can create an
233:23 - instance from another instance with
233:25 - struct update syntax so as you can see
233:28 - we have here the user struct and we have
233:31 - seen an example of that in these slides
233:34 - then over here we are creating an
233:37 - instance from the user struct
233:40 - that means the variable U1 will then
233:43 - hold an instance
233:45 - that means that the variable U1 will
233:47 - then be an instance of the user type and
233:51 - again we are just providing each field
233:53 - over here with a concrete value
233:56 - then over here
233:58 - we call the set email function with an
234:02 - argument of the U1 instance
234:06 - so let's see over here as you can see in
234:08 - the function signature the argument must
234:12 - be of type user
234:14 - and then we want to create over here a
234:17 - new instance
234:19 - and what we want to achieve here is that
234:22 - we take everything
234:24 - and what we want to achieve here is that
234:27 - we take every field from the U1 instance
234:30 - except for the email field we want to
234:34 - we want that to be different
234:37 - so what we can do is providing a
234:40 - concrete value for the email field and
234:44 - then just saying the rest we want to
234:46 - take from the argument provided
234:51 - and then we are just returning it
234:55 - so that means U2 will then hold a newly
234:59 - created instance
235:07 - Point distracts we can use derive debug
235:10 - to make a struct printable click fill
235:13 - the blanks to make the code work so you
235:16 - actually can't print out a struct using
235:20 - the normal print line syntax
235:23 - we have to
235:25 - so to be able to print a struct we have
235:28 - to derive a trade again we will cover
235:32 - trades but we have to derive that
235:37 - using an attribute all right that means
235:41 - that destruct rectangle here
235:45 - implements this debug trade and that
235:49 - means we can then use debug notation to
235:52 - print it out
235:53 - so over here as you can see we have a
235:57 - variable scale
235:59 - and then we are creating here a
236:01 - rectangle instance
236:03 - so we are providing a concrete value for
236:07 - the
236:08 - field with
236:10 - and this would be 30 times the scale
236:15 - and we provide a concrete value for
236:18 - height now as you can see print debug
236:21 - info to standard error and assign the
236:24 - value of 30 times scale to width
236:29 - now this debug macro over here will just
236:32 - print out debug information to the
236:35 - standard error output
236:39 - and
236:40 - that means over here rect one will then
236:44 - hold an instance of the type rectangle
236:48 - and the type annotation for the scale
236:51 - variable over here would be u32
236:55 - right because we are passing this scale
236:58 - variable over here meaning it should be
237:02 - of Type U 32.
237:04 - and then again we are here
237:07 - using the debug macro and printing out
237:10 - racked one and instead of doing that we
237:14 - can also use a normal print line
237:16 - statement
237:17 - like you're used to except that in the
237:21 - placeholder over here we have to use
237:23 - this notation and this is called debug
237:26 - notation
237:28 - meaning any type that implements the
237:30 - debug trade can then be printed
237:37 - and the difference between debug macro
237:40 - and printland macro as you can see print
237:43 - line will point to the standard output
237:45 - while debug will print to the standard
237:48 - error and that's why you don't see it
237:51 - over here you just see the print line
237:54 - output
237:55 - now to see that
237:58 - [Applause]
237:59 - I will go to the rust playground
238:09 - and we can just run this code
238:16 - and as you can see over here this would
238:19 - be
238:20 - the debug output
238:23 - so this debug macro over here prints out
238:27 - the exact thing we are passing to the
238:32 - width field in this case 60. and this
238:37 - debug macro over here points out
238:39 - the instance right we then have an
238:42 - rectangle with a width of 60 and a
238:46 - height of 50. basically the same thing
238:49 - that we print out with the print line
238:52 - statement here
238:55 - foreign
239:01 - move within the destructuring of a
239:04 - single variable both by move and by
239:06 - reference pattern bindings can be used
239:09 - at the same time doing this will result
239:12 - in a partial move of the variable which
239:15 - means that parts of the variable will be
239:17 - moved while other parts stay in such a
239:21 - case the parent variable cannot be used
239:24 - afterwards as a whole however the parts
239:27 - that are only referenced and not moved
239:30 - can still be used
239:32 - and I guess we have seen that before but
239:35 - let's do another exercise
239:38 - so as you can see
239:40 - right we have seen that
239:42 - alright so let's move to the exercises
239:45 - directly because I've already covered
239:48 - that
239:48 - and I think the exercises are better for
239:52 - understanding so as you can see fix the
239:55 - arrows to make it work over here we have
239:58 - a file struct holding two fields of type
240:02 - string
240:05 - then in main we are creating an instance
240:08 - of the filed struct providing it
240:10 - concrete values for each field meaning F
240:14 - will then hold an instance of the file
240:18 - struct
240:20 - and over here we are then assigning the
240:24 - name field of the F instance to the
240:27 - underscore name variable
240:30 - so what would be the type annotation
240:32 - here
240:34 - it would be string right because F name
240:38 - holds a string
240:41 - and that means the name variable here
240:44 - will become the owner of this string
240:49 - data
240:50 - and that is the reason that we then
240:53 - cannot use f as a whole and also not F
240:57 - dot name because a partial move happened
241:03 - so if a field gets moved out to another
241:07 - owner then you can't access this field
241:11 - and also not the data structure that is
241:14 - holding this field
241:16 - so this would fail over here and this
241:20 - would fail now to fix that we can
241:23 - actually access
241:26 - just the name variable here right
241:29 - because this is now the owner of this
241:32 - string
241:34 - but what we can't do is accessing the
241:38 - whole instance over here this is not
241:40 - possible
241:48 - as you can see this is working
241:52 - now
241:53 - if you actually want to keep f as the
241:57 - owner of all the fields
241:59 - and to print it out like that
242:08 - and by the way notice again when we are
242:11 - outputting
242:13 - a single field we used in normal
242:15 - notation if we output the whole instance
242:18 - then we have to use debug notation
242:21 - because these fields over here hold
242:23 - types that are defined in the standard
242:26 - Library while this is a custom type we
242:30 - have created
242:31 - so to make that work we can also use
242:35 - here the Clone method
242:42 - and as you can see this is working and
242:45 - we are here printing out the instance
242:49 - all right see you in the next topic
242:54 - we can also create custom types using
242:57 - enums now an enum is a way of defining a
243:00 - type with only one of a possible set of
243:04 - values we can only access one variant of
243:07 - an enum at a time
243:10 - and it can hold additional information
243:13 - using tuples
243:15 - and it's especially useful when using in
243:19 - match statements
243:22 - let's see an example of an enum so we
243:25 - have here the enum IP address
243:29 - and this enum holds two variance so in
243:33 - enums we call it variance and not Fields
243:36 - like instructs
243:37 - and each variant over here holds a type
243:43 - using tuple-like syntax all right so an
243:48 - IP address by the way can be in either
243:50 - one of two formats either it's V4 or B6
243:55 - and now we will see the difference
243:58 - between enums and structs so this is how
244:02 - we would instantiate this enum IP
244:05 - address
244:06 - we are accessing the name of the enum
244:10 - double colon and then the name of the
244:13 - variant in this case V4 then providing
244:17 - it a concrete value
244:20 - I hope you noticed the difference
244:23 - in a struct we would have
244:26 - provided concrete values for each field
244:30 - in an enum we instantiate the enum only
244:34 - with one single variant all right
244:39 - so this home variable will then hold an
244:42 - instance of the IP address enum
244:47 - and this loopback variable over here
244:50 - will also hold an instance of IP address
244:53 - but using the variant V6
244:58 - and by the way this is the old format of
245:01 - IP addresses ntcc new one
245:07 - so let's do some exercises enums can be
245:10 - created with an explicit discriminator
245:13 - so enums are enumerated right that's why
245:19 - they are called enum now if you don't
245:23 - provide here a value it will be
245:26 - implicitly starting from zero
245:30 - this would be one and this would be two
245:33 - and we can also enumerate them with an
245:37 - explicit discriminator okay so this will
245:41 - then hold zero this variant will be one
245:44 - and this will be two
245:47 - and over here you can see C like enum
245:51 - now you can't use as a discriminator a
245:55 - floating point value this is not allowed
246:00 - but like in C if you for example would
246:04 - do it like that
246:09 - we are here providing the discriminator
246:11 - 5. then
246:15 - 1 and 2 implicitly will be six
246:20 - and seven
246:22 - right or we could say
246:25 - this should be 9 for example
246:29 - right
246:30 - so you can manipulate the enumeration of
246:34 - an enum
246:35 - so let's see actually let me change that
246:39 - back
246:41 - and let me change that to integers
246:46 - an inner variant can be converted to an
246:49 - integer by the as keyword
246:52 - so when we take
246:55 - this enum over here and we create an
246:58 - instance
246:59 - as we've said as we've seen calling the
247:03 - name of the enum and the variant
247:06 - and then we can convert it to an u8 for
247:10 - example right
247:12 - and we can do the same thing here
247:15 - and over here should be the same thing
247:27 - and as you can see this is compiling
247:30 - let me print out
247:38 - [Applause]
247:47 - as you can see when we access from the
247:50 - number in on the variant one then A1
247:55 - will get outputted now let's see if I
247:58 - provided a value of 10 over here
248:03 - but for that I have to
248:07 - comment that out
248:11 - as you can see
248:12 - this foot would then be
248:14 - the discriminator for the one variant
248:20 - all right each enum variant can hold its
248:24 - own data
248:25 - so as you can see we have here an enum
248:27 - message
248:29 - now this enum has different variants so
248:33 - this variant quit doesn't hold any
248:36 - additional data but while this variant
248:39 - move here holds Fields it's very struct
248:44 - like
248:45 - and this variant right is tube alike so
248:49 - it holds a value in a tuple syntax and
248:54 - the same thing for change color
248:56 - so we can then instantiate the move
248:59 - variant from the message enum
249:01 - with these values over here X1 and Y 2.
249:07 - and as you can see because this is very
249:10 - struck like you instantiate it basically
249:13 - like a struct
249:15 - and over here instantiating with hello
249:18 - world as you can see this variant over
249:21 - here
249:22 - holds a string type
249:25 - so
249:26 - [Applause]
249:30 - like that
249:35 - and please notice over here that both of
249:38 - these variables here hold the same type
249:41 - message
249:47 - because this is also a custom type A
249:51 - type we have created
249:54 - we can get the data which an enum
249:57 - variant is holding by pattern matching
250:01 - so
250:02 - over here we have the same enum like we
250:05 - saw before
250:06 - and over here we have an instance
250:11 - of team move variant
250:14 - now we can here use E flat and we will
250:17 - cover that in the next section
250:20 - two
250:23 - get out the data inside
250:27 - this move variant so we are matching
250:30 - here the message variable holding an
250:33 - instance of the move variant
250:35 - and then over here we can basically
250:38 - destructure it so X should then be
250:41 - destructured into a variable a
250:45 - and Y should be restructured into a
250:48 - variable B and then as you can see we
250:51 - can use these two variables
250:54 - now we are here asserting A and B
250:59 - and a stands for this value and b stands
251:03 - for this value and as you notice they
251:05 - are not the same so this would fail
251:07 - actually
251:09 - so let me change that
251:11 - and now let's run the program
251:16 - fill in the blank and fix the errors
251:18 - again same enum and over here we have an
251:23 - array of
251:25 - different variants from this enum type
251:28 - right we have the quit variant the move
251:32 - variant and the change color variant now
251:36 - the neat thing here is that all of these
251:39 - instances are of the same type message
251:43 - right our custom type now I hope you
251:46 - remember how we annotate an array
251:49 - so first thing will be the type and then
251:52 - the number of elements
251:54 - Let's see we have over here three
251:57 - elements right
252:00 - and the type would be
252:03 - I hope you know it
252:05 - message right all of these variants
252:09 - or instances hold the same type
252:14 - and then over here we are looping over
252:17 - this array here
252:19 - meaning
252:20 - message this variable will hold in each
252:24 - iteration one of these instances
252:28 - and then passing it to the show message
252:31 - function and as you can see when we want
252:34 - to take
252:35 - an instance of this inner message we can
252:38 - just use the type message here because
252:42 - again all of them all
252:45 - because all of them have the same type
252:48 - and all we do then is just printing it
252:51 - out
252:58 - and again because this is a custom type
253:01 - we cannot print it out just like that so
253:04 - we have to use debug notation here
253:07 - and derive over here
253:10 - the debug trait
253:13 - [Applause]
253:17 - and as you can see
253:18 - in each iteration over here we call the
253:22 - show message function and it will print
253:25 - out
253:27 - the contents of this array
253:31 - so let's see exercise five since there
253:34 - is no null in Rust we have to use enum
253:37 - option to deal with the cases when the
253:39 - value is absent and I want to show you
253:43 - some slides for that
253:46 - so the option enum option is an enum
253:49 - that represents a value that may or may
253:52 - not be present it's known in other
253:55 - languages as null and it's referring to
253:57 - the absence of a value it's used to
254:01 - handle cases where a function or method
254:04 - might fail to return a value
254:07 - so this is how the enum option looks
254:11 - like as defined by the standard Library
254:13 - as you can see it's an enum holding two
254:17 - variants none and some now this over
254:21 - here is a generic meaning that sum can
254:26 - hold any type and we'll cover generics
254:30 - very soon
254:31 - but for now again think that this can
254:34 - hold any type provided so let's see an
254:38 - example over here
254:40 - we are here initializing the variable 5
254:43 - with
254:45 - D variant sum holding an integer value
254:50 - right
254:52 - and then over here we are calling the
254:54 - function plus 1 providing it five
254:58 - so let's see here as you can see the
255:01 - argument should be of type option
255:04 - and the type parameter here would be i32
255:10 - now we have to provide a concrete type
255:14 - for this generic type parameter now
255:18 - again we will cover that in much greater
255:21 - detail but as you can see this is
255:25 - exactly the type we are passing to the
255:27 - function sum is a variant of the option
255:31 - enum and it is holding an i32 value
255:38 - and it is holding an i32 type now then
255:42 - we are matching this argument over here
255:45 - if it is holding a non we will return
255:48 - none if it is holding a sum then over
255:53 - here we are destructuring the value
255:55 - wrapped inside this sum variant into the
255:59 - variable I and then over here we are
256:03 - incrementing I by 1 and wrapping it in a
256:07 - sum because as you can see the return
256:10 - type over here is defined as option i32
256:17 - and
256:19 - that means that this variable over here
256:23 - will then hold some 6 right because we
256:27 - have incremented 5 over here by one so
256:31 - this will hold an option type
256:34 - and the concrete value would be sum 6.
256:40 - the sum variant and a value of 6.
256:45 - now over here we are calling the plus
256:48 - one function with none meaning the
256:51 - argument will get matched and
256:53 - this will then get
256:56 - returned right a non
256:59 - and as you can see the non is also a
257:02 - variant of the option Ina
257:06 - and this i32 just stands for the sum
257:09 - variant if your turn if we are returning
257:13 - none then this type over here is still
257:16 - valid because the non-variant here
257:19 - doesn't hold any value of generic type t
257:25 - but again generics are a topic on its
257:28 - own
257:31 - and by the way this is exactly the same
257:34 - that we have over here so let's do that
257:37 - annotating the type so over here we have
257:40 - an option holding an i32
257:44 - type all right and as I've said
257:49 - this is not necessary you can omit that
257:53 - because again
257:55 - the option type is in the prelude
257:58 - then we are calling the plus one
258:01 - function
258:02 - again we are providing it sum 5 which is
258:06 - an option
258:08 - and then we are matching the argument so
258:12 - if the argument is none
258:14 - then we return none
258:18 - it is some
258:20 - then we destructure the value
258:23 - that was passed over here
258:26 - and we incremented by one and return it
258:31 - wrapped in some because
258:34 - the return type has to be of type option
258:38 - that means over here the type annotation
258:41 - would be option i32
258:45 - and in this case we are passing a non so
258:48 - a non will be returned
258:51 - and by the way
258:54 - [Applause]
258:55 - the Returns value here would be sum 6
258:58 - right because 5
259:01 - plus 1 will be 6.
259:05 - and over here we have non-anti-type
259:07 - annotation would still be
259:10 - option I 32.
259:14 - now we want actually to unwrap this
259:18 - value inside this sum variant and we can
259:22 - do that by using IF let
259:25 - so as you can see we are matching these
259:27 - six variables holding some six and then
259:31 - we can destructure it basically so
259:35 - we can then say sum
259:38 - and the variable n
259:41 - meaning we then can use n over here
259:47 - and I see right now never let this run
259:51 - so we have to pack that into an else
259:53 - block
259:58 - just to ensure that this doesn't run
260:01 - after we are running this conditional
260:03 - here
260:07 - and as you can see it will output
260:10 - the value inside sum now again we'll
260:15 - cover generics will cover a flat and
260:18 - match over here this will actually be
260:21 - the next topic so don't worry if this
260:24 - seems a little difficult to understand
260:26 - we will cover that in much greater
260:28 - detail
260:30 - Implement a linked list via enums now
260:34 - over here
260:36 - this linked list
260:37 - I won't cover because there are a lot of
260:42 - things we haven't seen so in here we
260:45 - have
260:47 - um
260:48 - methods and other things that we didn't
260:53 - really cover so I think this would be
260:56 - more confusing than it would be helpful
261:00 - what I suggest you is that you will come
261:04 - back after we have seen some more topics
261:07 - you come back to this exercise and try
261:10 - to solve it it's not that difficult and
261:13 - the solution will be on my GitHub
261:15 - account
261:15 - but I think this is just Overkill right
261:19 - now
261:22 - so see you in the next topic
261:26 - the normal flow of execution in a
261:29 - program would be from top to bottom line
261:31 - by line but we can actually manipulate
261:34 - the flow of a program
261:37 - and flow control is a concept that
261:40 - refers to the ability to control the
261:43 - order in which statements or
261:45 - instructions are executed in a program
261:49 - it allows to specify which instructions
261:52 - should be executed under which
261:55 - conditions and in what order
261:58 - so we have many ways to do that and some
262:01 - of them are for example using
262:03 - conditionals so we have the if else
262:05 - keywords and match for example
262:08 - and we can use Loops for Loops while
262:12 - Loops there is a special Loop in Rust
262:14 - called Loop we'll cover that
262:17 - and we can even manipulate the flow
262:20 - inside the loop by keywords such as
262:22 - continue and break so let's see
262:27 - so let's start with if else conditionals
262:30 - over here we are initializing n with a
262:33 - value of 5. then over here we have an if
262:37 - conditional checking if n is less than
262:40 - zero in this case this would evaluate to
262:43 - false meaning meaning this this
262:46 - instruction over here will get ignored
262:49 - and the program will continue executing
262:52 - on the next line now in the next line we
262:55 - have another conditional
262:58 - so we can use here the else if keyword
263:03 - and over here we are checking is n
263:05 - bigger than zero
263:07 - in this case this would evaluate to true
263:10 - meaning this line will get printed out
263:13 - now we can also match anything else
263:17 - using the else keyword
263:20 - meaning if this evaluates to false and
263:24 - this evaluates to false then this will
263:26 - get executed
263:28 - now in this case this evaluates to true
263:30 - so this will get executed meaning this
263:34 - over here will be ignored
263:41 - as you can see this was the line that
263:44 - has been printed out
263:47 - number two if else expression can be
263:51 - used in assignments again initializing n
263:56 - and over here we have a variable
263:58 - assignment
264:00 - now we can even use if else conditionals
264:04 - when assigning a value to a variable now
264:09 - remember in a variable assignment is a
264:12 - statement so we so we have to end that
264:14 - with a semicolon like that
264:17 - so let's see we have here an if
264:19 - conditional and this is a Boolean and
264:23 - operation do you remember we have two
264:27 - inputs and both of these inputs have to
264:31 - evaluate to true in order the end
264:34 - operation to return true
264:37 - so let's see we have here n should be
264:41 - less than 10 which would evaluate to
264:44 - True right because 5 is less than 10.
264:47 - and 5 is bigger than -10 so this end
264:52 - operation will return true meaning the
264:58 - meaning the code in this if conditional
265:00 - block will get executed and over here we
265:04 - are just printing out a line and then we
265:08 - are multiplying n by 10 and in fact we
265:12 - don't have a semicolon so this will be
265:15 - returned from this expression meaning it
265:18 - will then be assigned to the variable
265:20 - Big N so big n will then hold
265:24 - a type of i32
265:27 - now in case this would evaluate to false
265:30 - then this else block would get executed
265:34 - meaning again we are printing out a line
265:37 - and then dividing n by 2.0
265:41 - now as you can see we should omit this
265:45 - semicolon because this should
265:47 - because this result over here should
265:50 - then be assigned to this variable
265:53 - now
265:55 - we actually can't do this operation here
265:58 - because n is of type i32 and we are
266:02 - dividing it by a floating Point number
266:06 - so we can
266:09 - so we can Typecast that when I 32.
266:16 - and as you can see
266:18 - this would be
266:20 - the output
266:22 - and we are printing out big n meaning 50
266:26 - over here
266:27 - so n
266:30 - has been multiplied by 10.
266:35 - so let's see we have here a for Loop D4
266:38 - in construct can be used to iterate
266:40 - through an iterator for example a range
266:43 - A to B
266:45 - now as you can see we have a for Loop
266:48 - declaring a variable n and we provide a
266:52 - range
266:54 - now this range over here reaches from 1
266:57 - to 100 and 100 here included because we
267:02 - have here the equal sign
267:04 - then we are checking if n is equal to
267:09 - 100 this program will panic
267:14 - that's not what we want so what we can
267:18 - do over here is just removing this equal
267:21 - sign because that means 100 is excluded
267:26 - meaning n will never be equals to 100
267:31 - the largest it will get will be 99
267:34 - because let's see
267:39 - all right
267:41 - fix the arrows without adding or
267:44 - removing lines so over here we have a
267:48 - so over here we have an array
267:51 - holding two strings
267:55 - now we want then to iterate over this
267:58 - array meaning this name variable will
268:01 - hold
268:03 - in the first iteration this string and
268:06 - in the second iteration this string
268:10 - so what we can do over here is
268:13 - pointing out
268:17 - name right so this will iterate two
268:21 - times
268:22 - and it will output this and then this
268:28 - now as you can see we are trying to
268:32 - access names again over here and that
268:36 - would then violate the ownership rules
268:39 - because as you can see in a for Loop
268:42 - the for Loop actually will take
268:44 - ownership of the provided value
268:48 - and we can pass here a reference like we
268:52 - have seen before and that means we can
268:55 - use names then again
269:02 - so
269:04 - and by the way
269:06 - we don't have to dereference name over
269:09 - here because the print line statement
269:11 - will do that automatically
269:14 - now over here we have three i32 integers
269:21 - the elements in numbers are copies so
269:23 - there is no move here so we are
269:26 - iterating over each element in this
269:28 - array
269:29 - where n will then hold in each iteration
269:33 - one element from this array so let's see
269:41 - [Applause]
269:46 - so and this would be the output
269:50 - as you can see in the first iteration
269:53 - name will hold this string and in the
269:57 - second iteration it will hold this
269:59 - string and it prints it out in each
270:02 - iteration then we print out the whole
270:04 - array
270:06 - and over here the same thing but with
270:09 - the integers
270:13 - so again we have an array
270:19 - so iterate the indexing and value in a
270:24 - so there is a useful method called
270:26 - enumerate
270:30 - and this enumerate method takes a
270:34 - collection for example an array or a
270:37 - tube pillar or anything else
270:40 - and it will then return a tuple
270:44 - and this Tuple will then hold the index
270:47 - and T value meaning for example in the
270:51 - first iteration this Tuple will hold
270:55 - for i 0 and for V4 right because
271:00 - at index 0 we have a value of 4 and it
271:05 - will then just print out the index but
271:08 - we increment it by one
271:10 - and the actual value
271:22 - and of course we have to put a into an
271:26 - iterator
271:27 - so let's see
271:31 - like that so we have to first put a into
271:34 - an iterator and then we can call this
271:37 - enumerate method on it because the
271:40 - enumerate method is implemented in the
271:44 - iterator trade we'll take a look at that
271:46 - later
271:48 - so as you can see this will be the
271:51 - output and
271:53 - that was the reason we have incremented
271:56 - I by one because we don't want to start
271:59 - with the zeroest element is four right
272:03 - so we say here the first element is four
272:05 - second three and so on
272:09 - while the while keyword can be used to
272:12 - run a loop when a condition is true fill
272:15 - in the blanks to make the last print Ln
272:18 - work
272:19 - so as you can see we have here a mutual
272:22 - variable n
272:24 - Loop while the condition is true
272:27 - so as you can see this is a while loop
272:30 - and we provided a conditional meaning if
272:34 - this evaluates to true
272:37 - then this Loop will keep running until
272:41 - this conditional evaluates two folds
272:45 - so inside the while loop we have other
272:48 - conditionals as you can see we here
272:51 - check
272:53 - the condition and modulus 15 is 0. if
272:58 - that would evaluate to true then we
273:00 - print out that
273:03 - and by the way this was a question at
273:06 - coding interviews at Google
273:09 - so
273:11 - we are
273:13 - here having more conditionals and
273:17 - a
273:18 - an else conditional so meaning if
273:21 - anything of this fails then this will
273:25 - get printed out
273:26 - so what we can do over here checking if
273:30 - n is less than 10 then this Loop will
273:34 - keep running now when you're using while
273:37 - Loops then you have to ensure that
273:40 - the while loop eventually stops right
273:43 - that this conditioner over here will
273:46 - evaluate to false eventually because
273:49 - otherwise you would have an infinite
273:51 - Loop
273:52 - now to do that we can increment and over
273:56 - here
273:58 - so I increment at the end of this while
274:02 - loop
274:03 - n by 1.
274:06 - meaning at each meaning in each
274:09 - iteration in this while loop n gets
274:12 - incremented by one so n will eventually
274:15 - be bigger or equal to 10 meaning this
274:20 - would evaluate to false meaning we break
274:23 - out of this Loop
274:30 - continue and break use break to break
274:33 - the loop
274:35 - so we have here a for Loop looping from
274:39 - 0 to 100 and 100 included
274:44 - so if n is 66 then we want to break out
274:49 - of the loop
274:49 - [Applause]
274:51 - anti-break keyword
274:53 - will immediately exit out of this for
274:57 - Loop so when this conditional evaluates
275:00 - to true we immediately exit out meaning
275:04 - the program will continue execution
275:06 - after the for Loop in this case this
275:10 - line over here
275:12 - let's see
275:15 - so as you can see in the end n will be
275:19 - equal to 66.
275:21 - because when I is 66 then we stop
275:25 - iterating
275:27 - continue will skip over the remaining
275:29 - code in current iteration and go to the
275:32 - next iteration
275:34 - so as you can see we are here again
275:37 - iterating from 0 to 100
275:40 - and we have here an if conditional if n
275:43 - is not equal to 66 then we increment n
275:48 - by 1.
275:50 - and we want them to continue
275:56 - meaning
275:58 - that
276:01 - that the remaining code
276:04 - in this for Loop will get ignored so
276:07 - discontinue keyword the program will go
276:11 - back to the beginning of the for Loop
276:14 - now in case this evaluates to false
276:18 - right so if n is in fact 66 this would
276:22 - evaluate to false meaning we ignore this
276:26 - code block and we go over here where we
276:30 - want to break out of the loo because as
276:32 - you can see we want n to be 66 at the
276:36 - end
276:41 - Loop is usually used together with break
276:44 - or continue
276:46 - so Loop is a special Loop in Rust where
276:51 - this is basically an infinite Loop and
276:55 - you have to manually
276:57 - manipulate the flow of the loop and we
277:00 - will see soon so this is a u32 over here
277:04 - count
277:07 - so let's count until Infinity
277:10 - as you can see we are here using the
277:12 - loop keyword
277:14 - meaning this would keep looping to
277:16 - Infinity
277:18 - or we provide some keywords that will
277:22 - break out of the loop or continue
277:25 - so as you can see in each iteration we
277:28 - are incrementing the count variable by
277:31 - one
277:36 - now if count is equal to 3 then we print
277:40 - out 3 and we want to skip the rest of
277:43 - this iteration so we can use here the
277:46 - continue keyword
277:48 - meaning again the rest over here will be
277:53 - ignored
277:54 - the program will go back to the
277:57 - beginning of the loop
278:01 - so
278:02 - then over here if count is not equal to
278:06 - 3
278:07 - this will get printed out so we print
278:10 - out the count in every iteration except
278:14 - if count is equal to 3.
278:18 - and then over here if count is equal to
278:20 - 5 then we'll print out okay that's
278:22 - enough and we want to break out
278:26 - meaning count in the end should hold a
278:30 - value of 5.
278:35 - you can see we are iterating one two and
278:39 - then in the third iteration this if
278:42 - conditional evaluates to true meaning we
278:45 - print out three and we continue we are
278:49 - going back to the beginning so the
278:52 - actual value of count over here is not
278:55 - printed as you can see there is no digit
278:58 - 3 but will printed out three over here
279:01 - because that was defined in this code
279:04 - block here
279:07 - and then
279:09 - add iteration 5 we will stop and break
279:13 - out of the loop
279:16 - so Loop is an expression so we can use
279:18 - it with break to return a value
279:22 - and again we have here a counter
279:29 - so over here we have a loop and we are
279:32 - in each iteration
279:34 - incrementing counter by one
279:37 - then we check if counter is equal to 10
279:41 - then we want to break out
279:45 - but as you notice we want to assign a
279:48 - value to the result variable right this
279:52 - variable should then hold an i32 but we
279:56 - don't return anything here
279:58 - so you can Define after the break
280:01 - keyword a return value meaning for
280:05 - example we want to return counter
280:08 - but in this case result will hold 10
280:12 - right because counter when we break out
280:15 - will be 10 otherwise this conditional
280:18 - would not evaluate to true so if counter
280:21 - is 10 then we break out
280:24 - but as you can see we want result to be
280:27 - 20. so we can even pass here an
280:31 - operation so we can double the counter
280:35 - value
280:36 - let's see
280:39 - and
280:40 - this is compiling
280:45 - it's possible to break or continue outer
280:48 - Loops when dealing with nested Loops in
280:51 - these cases the loops must be annotated
280:53 - with some label and the label must be
280:56 - passed to the break continuous statement
281:00 - so
281:01 - as you can see we can even Nest
281:04 - different loops
281:06 - so when we do that we have to actually
281:09 - provide labels so we provide here outer
281:13 - for the Outer Loop and inner one for the
281:17 - inner loop and as you can see we have
281:19 - even two inner Loops so we have inner
281:23 - one and inner two
281:26 - alright so let's see in the first inner
281:30 - loop
281:31 - we are checking if count is bigger than
281:34 - or equal to 20.
281:38 - if this is the case we break out of this
281:42 - inner loop
281:45 - otherwise we increment the count by two
281:51 - all right
281:55 - and notice here this would break only
281:57 - the inner one Loop so when we break out
282:00 - of this Loop this outer loop will still
282:03 - continue looping okay
282:07 - so then over here in the outer loop we
282:11 - are incrementing count by five
282:15 - and in this inner two Loop we are then
282:18 - checking if count is bigger than or
282:21 - equal to 30 then we break out of the
282:25 - Outer Loop
282:28 - otherwise if count is smaller than 30
282:31 - then
282:33 - the outer loop will continue meaning
282:37 - the program will go back to the
282:39 - beginning of the outer loop and continue
282:41 - executing from here
282:44 - so let's go step by step
282:47 - and as you can see we have to find out
282:50 - here what the count value will be in the
282:53 - end
282:55 - okay let's go step by step we start at
282:58 - zero then over here we are checking is
283:01 - Count bigger than or equal to 20 no
283:05 - right
283:06 - so that means count will get incremented
283:11 - by two
283:13 - and this will continue because we are in
283:16 - this Loop remember and this will
283:18 - continue until
283:20 - this evaluates to true meaning when
283:23 - count is 20 then we break out of this
283:27 - inner loop meaning we continue
283:31 - executing here
283:33 - then
283:35 - count would be 20 and we increment it by
283:38 - 5.
283:41 - then we enter this inner two Loop
283:45 - so 25 is not bigger or not equal to 30
283:51 - meaning we don't break off outer but we
283:56 - will continue outer meaning we go back
283:59 - over here
284:01 - now we enter this Loop here and 25 is
284:08 - bigger than 20 so we break out of this
284:11 - Inner Loop and continue here
284:14 - then we add 5 to count meaning count is
284:17 - now 30.
284:19 - so we enter this inner two Loop and this
284:23 - will now evaluate to true because count
284:26 - is equal to 30 meaning we break out of
284:30 - the outer loop so in this case count
284:33 - will be 30 in the end
284:38 - and this succeeded and I will see you in
284:41 - the next topic
284:44 - pattern match is a powerful construct
284:47 - that allows you to compare a value
284:49 - against a set of patterns and then
284:53 - execute different code based on which
284:55 - pattern matches
284:57 - and these patterns can be made up of
285:00 - literal values variable names wild cards
285:04 - and so on and in a match statement all
285:08 - possible cases must be handled and this
285:11 - is enforced by the compiler
285:14 - and really this match keyword is
285:17 - something that I really miss when I'm
285:19 - coding in other languages so once you
285:22 - get used to it you will love it and you
285:25 - will see why
285:27 - so let's see an example over here we
285:30 - have in coin enum and this enum holds
285:34 - variance of different denominations of
285:38 - U.S currency
285:40 - or U.S coins
285:42 - and here we have a function value in
285:46 - sense
285:48 - this takes as an argument a variant of
285:51 - type coin
285:54 - then it matches the argument
285:57 - and as you can see it matches the
286:00 - variance of this coin enum meaning if we
286:04 - provide an instance of this coin enum
286:07 - which holds a penny variant for example
286:10 - then it will return one right and this
286:15 - will then be the return value of this
286:18 - function so for each denomination over
286:21 - here it will return its proper value
286:33 - then let's see if let so I've said that
286:37 - in a match statement all possible cases
286:40 - have to be handled and this could
286:43 - sometimes lead to annoying boiler play
286:45 - code that is not really that necessary
286:49 - so for example we have over here an
286:51 - option type right a value wrapped inside
286:55 - sum and then we match
286:58 - this variable over here that holds this
287:02 - option type and then we are matching as
287:05 - you can see if it is sum then we the
287:09 - structure
287:10 - the value inside this Max variable and
287:13 - then we just print it out
287:16 - now as you can see we also have to match
287:19 - any other case meaning if it is not some
287:23 - in that case none then nothing will get
287:27 - executed meaning it will return a unit
287:31 - type
287:32 - now this is sometimes two verbose
287:37 - especially for cases like this for
287:40 - example you just want to unwrap
287:42 - something from a sum variant
287:46 - now what we can do instead is just using
287:50 - using E flat
287:51 - so it's exactly the same as this match
287:54 - statement but we know that config Max
287:58 - holds a sum value right so we don't have
288:03 - to
288:06 - so we don't have to consider the case
288:08 - where it holds a non-value
288:12 - and as you can see this is how we would
288:15 - destructure this value into the variable
288:18 - Max we will see a flat keyword and then
288:23 - the pattern so if config Max holds a sum
288:27 - then the value will get
288:31 - the structured
288:32 - let's do exercises
288:35 - fill the blanks so over here we have a
288:38 - direction enum holding
288:41 - directions over here as variance
288:45 - then over here as you can see we are
288:47 - instantiating
288:49 - the direction enum with a variant of the
288:53 - South
288:54 - so the type over here would be Direction
288:57 - [Applause]
288:59 - then we match this variable here
289:03 - and if this variable over here holds
289:07 - Direction East then it will print out
289:10 - east
289:12 - now we want over here to match south or
289:16 - north
289:18 - so what we can do over here is pattern
289:20 - matching either south or north and we
289:24 - can do it like that
289:28 - [Applause]
289:36 - so we are here matching
289:39 - so we are here basically saying if this
289:43 - variable holds either a variant of south
289:47 - or north then it will print out south or
289:51 - north
289:53 - now
289:54 - in case it's not any of these variants
289:58 - then it must be West right so we can
290:02 - print out here West
290:06 - let's see
290:10 - and as you can see
290:13 - the variable holds South so this will
290:16 - get matched so this will get printed out
290:22 - match is an expression so we can use it
290:25 - in assignments
290:27 - over here we have a Boolean value
290:30 - [Applause]
290:31 - fill the blank with a match expression
290:34 - Boolean true binary one Boolean false
290:38 - binary zero
290:40 - so what we want to do is we want to
290:42 - match this variable over here
290:52 - and then we provided the cases so if it
290:55 - is true
290:56 - then we should return one
291:01 - otherwise we return zero so that means
291:05 - the return value over here will then be
291:08 - assigned to this binary variable let's
291:12 - store that as u8
291:16 - and that means binary should then hold
291:19 - one right because we are matching here
291:21 - true
291:23 - and then the return value should be 1.
291:31 - using match to get the data and enum
291:35 - variant holds
291:37 - again we have the message enum we have
291:39 - seen that before
291:41 - then over here we have an array of
291:44 - message variants
291:52 - over here we are iterating over this
291:55 - array and passing it
291:59 - to this function
292:01 - as you can see
292:03 - the argument should be of type message
292:06 - so we are then matching this provided
292:10 - argument
292:12 - so we want to match over here message
292:15 - move
292:17 - [Applause]
292:22 - now as you can see the message move has
292:25 - struck like syntax so we have to match
292:29 - it like that
292:31 - and
292:36 - and as you can see we want the variables
292:39 - A and B so let's do that
292:51 - as you can see it holds Fields X and Y
292:55 - and that means we will then destructure
292:58 - these values into the variables into the
293:02 - variables A and B so a should hold 1 and
293:07 - B should hold three
293:12 - then we match over here the message
293:15 - change color variant as you can see this
293:18 - is a tuple-like
293:20 - variant
293:24 - and this Tuple has three elements so we
293:29 - can
293:30 - provide it some variables and we use
293:33 - here RGB red green blue and this is for
293:38 - color representation
293:40 - so in that case
293:43 - G the second value should be 255.
293:47 - and the last value B should be
293:51 - in this case 0.
293:56 - and again because we have to match all
293:58 - the cases
294:00 - if
294:03 - there is anything else that doesn't
294:06 - match here we will print out no data in
294:09 - this parents
294:16 - like that
294:27 - matches matches looks like match but can
294:31 - do something different
294:34 - so the macro matches allows us to
294:38 - test for example this array if a pattern
294:42 - matches
294:44 - so as you can see we are iterating over
294:48 - the elements of this array
294:51 - so over here we have the assert macro
294:54 - and all this does is it asserts that the
294:58 - given
294:59 - argument evaluates to true
295:02 - so we can over here use team matches
295:05 - macro
295:07 - and we provide it a b meaning the
295:11 - character we are iterating over
295:14 - and then we can
295:16 - give it a pattern it should match
295:21 - so as we are iterating over each element
295:25 - over here it should match each of these
295:28 - characters
295:30 - and we can do that like this
295:33 - so we want to match characters from a
295:37 - to and including z
295:41 - or
295:43 - a to and including that lowercase
295:48 - or zero
295:53 - two nine
295:54 - and notice these are characters and not
295:57 - integers because we have here an array
296:00 - of characters
296:02 - let's see
296:06 - and this succeeds as you can see all we
296:10 - did is we iterated over each element and
296:14 - we checked
296:16 - over here for each element if it matches
296:19 - if it matches this pattern
296:23 - and in this case everything matched
296:26 - because assert
296:28 - didn't Panic right because if one of
296:33 - them would evaluate to false insert will
296:36 - cause the program to panic
296:38 - let's see exercise five so over here we
296:42 - have an enum with two variants full and
296:45 - Bar
296:47 - then here we have a count variable
296:50 - which is initialized with zero
296:55 - and over here we have a vector now we
296:58 - didn't cover vectors yet but they are
297:01 - very similar to arrays but their size
297:04 - can shrink and grow meaning during a
297:07 - vector is dynamic in its size
297:10 - so as you can see we are
297:13 - having a vector of my enum variance two
297:18 - of them fool
297:20 - and one bar
297:27 - so this is a vector holding types of my
297:31 - inner
297:32 - then over here we are iterating over the
297:36 - elements of this vector
297:38 - now we want to match my enum Foo
297:44 - and if conditionals don't allow to match
297:48 - for patterns so we can't use that here
297:51 - but we can do something else we can hear
297:55 - instead using matches
297:58 - macro
297:59 - meaning we take e the element in the
298:03 - vector we are iterating over
298:06 - and we match it for
298:10 - this pattern right
298:12 - so if the element we are currently
298:15 - iterating over matches my enum full
298:19 - variant
298:21 - then
298:23 - we want to increment count by one
298:28 - like that
298:34 - and that means count after this for Loop
298:37 - iterating over each element should be
298:40 - two right because
298:42 - matches matched two times because there
298:46 - are two my enum full variants in this
298:50 - vector
298:53 - if let for some cases when matching
298:56 - enums match is too heavy we can use if
299:00 - let instead
299:02 - so over here as you can see we have an
299:05 - option
299:07 - [Applause]
299:08 - of type i32
299:11 - we move the whole match block using IF
299:14 - let instead so as you can see match is
299:18 - really verbal so we can use E flat
299:21 - instead
299:22 - and we do that like this we use the E
299:25 - flat keyword and then the pattern we
299:28 - want to match in this case sum
299:31 - and the variable should be I so the
299:35 - inner value here will get the structured
299:38 - into this variable I
299:42 - and then we are matching on all
299:49 - and if
299:51 - this matches then we want to print out
299:54 - these two lines
300:03 - as you can see this is much cleaner
300:10 - and this will get printed out this is a
300:14 - really long string and seven as you can
300:17 - see
300:18 - we here provide I and I just holds the
300:23 - inner value of this sum variant
300:28 - fill in a blank we have here a full enum
300:32 - with a bar variant holding a type of u8
300:36 - then over here we have an instance of
300:38 - the bar variant holding a value of one
300:44 - now over here again we could do the same
300:46 - thing we can use E flat and
300:52 - then we match the pattern
300:57 - so if
300:59 - the pattern is full bar then we want to
301:02 - destructure the inner value
301:04 - to a variable I
301:06 - [Applause]
301:08 - and we are matching on a
301:14 - as you can see this compiles
301:19 - so we have a full Anum with three
301:22 - variants and only the last one holds a
301:26 - value
301:28 - so over here we instantiate the full
301:31 - enum with a variant of
301:34 - cues and a value of 10. I hope I
301:39 - pronounce it correctly
301:43 - so remove the codes below using match
301:46 - instead
301:48 - so if I run this code
301:53 - then this would actually work because we
301:56 - are using IF let here but we can
302:01 - do it in a match statement so we match
302:04 - on a right
302:08 - and then we can provide the pattern
302:12 - so in case of full bar
302:16 - then we would
302:18 - then we will print out this line
302:23 - in case of Foo Bass
302:28 - we want to Output this line
302:33 - and in case of anything else
302:37 - like that
302:39 - we print out this line
302:45 - now I can delete that
302:47 - [Applause]
302:49 - and as you can see much cleaner
302:52 - so in this case match others
302:57 - shadowing fix the arrows in place again
303:00 - we have here an option
303:04 - with an inner value of i32
303:10 - then we are here using E flat to
303:13 - destructure the inner value to H
303:17 - and that means we are actually shadowing
303:20 - H because as you can see this variable
303:24 - here has the name H and we are then
303:27 - destructuring into a variable h
303:31 - so that means
303:33 - H has been shadowed
303:37 - create a new variable with the same name
303:40 - as previous age
303:42 - now over here as you can see H would be
303:46 - sum 30 which is wrong because we are
303:48 - actually here
303:50 - destructuring it right
303:54 - so H doesn't hold some 30 anymore but it
303:58 - will hold 30 because we are here
304:01 - destructuring it
304:04 - the new variable H goes out of scope
304:07 - here
304:08 - right so this variable over here
304:11 - goes out of scope
304:17 - and image can also Shadow a variable so
304:21 - we can here essentially doing the
304:24 - exactly same thing like in the uh like
304:28 - in the E flat statement over here
304:35 - foreign
304:38 - this would be the output from this match
304:42 - here
304:44 - alright see in the next topic
304:47 - so let's see patterns we can use this
304:49 - sign to match several values and we can
304:53 - use this one to match an inclusive range
304:57 - so as you can see we have here a
304:59 - function match number which takes an
305:02 - integer as argument
305:05 - then we are matching this integer and if
305:08 - it is one then we will then we'll print
305:10 - out one
305:12 - and fill in a blank with this don't use
305:16 - ranges okay so we have to match here two
305:20 - to five
305:22 - so we can do it like that
305:29 - and this pattern is basically saying if
305:32 - n is either 2 or 3 or 4 or 5 then we
305:38 - will print this
305:40 - match an inclusive range so if the
305:45 - so if n is between 6 and 10 where 10 is
305:49 - included then it will print out that
305:53 - and for any other case because again
305:56 - because again in a match statement we
305:58 - have to match every case so in this case
306:01 - we will print out that
306:05 - the add operator lets us create a
306:08 - variable that holds a value at the same
306:10 - time we are testing that value to see
306:13 - whether it matches a pattern
306:17 - so let's see we have here the point
306:19 - struct that has two Fields with I 32
306:23 - types
306:24 - fill in the blank to let P match the
306:27 - second arm so we have to complete here
306:30 - something we have here an instance of
306:34 - the point type
306:38 - now let's see the match here so we match
306:40 - on P
306:42 - and as you can see this is how we would
306:46 - match a struct so we provide this track
306:49 - name and then the fields as you can see
306:53 - we are matching X and Y so
306:56 - so if Y is equal to 0 that means this
307:00 - arm here matches and this will get
307:03 - printed out
307:04 - and we then can use x over because this
307:10 - is actually a destructuring assignment
307:13 - so this would be the same as writing it
307:16 - like that
307:17 - but this is shorthand syntax so we are
307:20 - then using X here
307:23 - now in the second arm as you can see we
307:26 - are matching X and Y Fields so X should
307:31 - be between 0 and 5 5 included
307:36 - and Y should be either 10 20 or 30.
307:42 - now as you can see when we are matching
307:45 - here this pattern we can't use x we
307:49 - don't use x here but we can in fact use
307:52 - y because we are using here the add
307:56 - operator so this means we are
307:59 - destructuring the variable y
308:02 - of the field y so that means the value
308:06 - that Y is holding over here will gets
308:09 - we'll get this structured into the Y
308:12 - variable
308:14 - and at the same time we are testing why
308:18 - if it is matching this pattern
308:24 - and the last arm as you can see we don't
308:27 - match for any pattern
308:29 - other than this main pattern and then we
308:34 - can use X and Y because again this would
308:37 - be the same as writing it like that
308:41 - all right
308:45 - now we want to match the second arm that
308:50 - means we have to provide values that
308:52 - match these patterns so let's see
308:55 - X between 0 and 5 so let's do three
308:59 - [Applause]
309:00 - and Y 10 20 or 30 I will do 30.
309:08 - as you can see this second arm matched
309:14 - fix the arrows over here we have the
309:16 - message enum that's holding which is
309:19 - holding one variant with a struct like
309:22 - syntax as you can see this is one field
309:25 - ID of type i32 then over here we are
309:30 - instantiating this variant so this will
309:33 - be an instance of the message enum
309:37 - and then over here we are matching this
309:41 - instance so if it is hello
309:44 - then we match the ID field so is it
309:49 - between 3 and 7 then
309:52 - we want to output here the ID now the
309:58 - problem here is that we did not actually
310:01 - destructure this field here into its
310:06 - distinct
310:07 - variable right so we have to provide
310:09 - here each variable let's do ID because
310:12 - that's the one defined here and for that
310:15 - we have to use the add operator so we
310:18 - are destructuring and matching the
310:21 - pattern at the same time
310:25 - and over here
310:27 - this is already done as you can see we
310:30 - can also provide any a variable with
310:34 - another name as you can see so the value
310:38 - of the ID field then we'll get this
310:41 - structured into this
310:44 - new ID variable
310:47 - right it doesn't have to be the same
310:50 - variable name as the field we have
310:55 - [Applause]
310:57 - and again we are destructuring and at
311:00 - the same time
311:01 - pattern matching and that's
311:04 - and that is the reason we are using the
311:06 - add operator
311:09 - and as you can see when we are matching
311:12 - like that then this ID over here got
311:16 - this structured because this is
311:19 - the shorthand for this all right
311:43 - and
311:44 - when we have a pattern here we have to
311:47 - wrap it inside parentheses
311:51 - that's also important
311:53 - and as you can see in this case the
311:56 - first arm matched right because ID over
312:00 - here the value is between 3 and 7.
312:05 - in match card is an additional if
312:07 - condition specified after the pattern in
312:11 - a match arm that must also match along
312:14 - with the pattern matching for that arm
312:17 - to be chosen
312:19 - fill in the blank to make the code work
312:21 - split must be used
312:25 - alright as you can see we have here an
312:27 - option
312:28 - [Applause]
312:30 - with an i32 value
312:33 - then we have here split
312:39 - and we are here matching
312:43 - the num variable and we are doing that
312:46 - to basically restructure the inner value
312:49 - so we are putting the value of 4 into X
312:53 - right so we can then use x over here
312:57 - but we over here also want a match card
313:00 - to check if x
313:03 - in this case this value over here is
313:06 - less than split
313:08 - we can do that like this
313:15 - foreign
313:19 - so this basically is just for
313:22 - destructuring the this value into X and
313:26 - over here we have an additional
313:28 - conditional in match card to check for a
313:33 - more specific condition to be true
313:37 - so
313:38 - if num is a sum so if num is of some
313:44 - variant then we the structure X and
313:48 - check it again and if all of that
313:51 - matches then we
313:53 - execute this
313:55 - if it is a sum but yeah but the value
314:00 - over here is actually bigger than split
314:03 - then this will get executed and if num
314:07 - holds a none then we just return a unit
314:11 - type
314:13 - ignoring remaining parts of the value
314:16 - with with this
314:20 - so as you can see we have here a tuple I
314:24 - want annotate that so we are matching on
314:28 - numbers
314:29 - now we only care about the first as you
314:36 - can see and the last one
314:42 - so what we can do over here we are
314:44 - matching on a tuple right so this is a
314:47 - tuple and we want to destructure the
314:52 - first and the last values into the
314:55 - variables first and last we can do it
314:59 - like that
315:05 - right so we have the first
315:08 - then anything in between and then the
315:11 - last
315:13 - so first should all two and last should
315:16 - hold 2048.
315:21 - using pattern mutable reference to V to
315:25 - match a mutable reference needs you to
315:28 - be very careful due to B being a value
315:31 - after matching
315:35 - let's see fix the arrow with least
315:37 - changing don't remove any code lines so
315:40 - over here we have a mutable variable
315:43 - holding a string
315:45 - and this would be a variable that holds
315:49 - a mutable reference to a string
315:53 - now we match r
315:56 - and that means over here we can
315:59 - destructure it directly into a value
316:04 - like that so
316:08 - this string over here will then be
316:11 - destructured into the value directly we
316:15 - don't have to match
316:17 - mute the reference like that right
316:21 - and that means the value variable
316:24 - will hold immutable reference to a
316:28 - string
316:31 - and of course then we can modify
316:34 - this stream over here
316:39 - all right that's it see you in the next
316:41 - one
316:43 - a method is a function that is
316:45 - associated with a particular type or
316:48 - struct it takes parameters and returns a
316:52 - value like a function but it's defined
316:55 - as a member of a struct or an enum
316:59 - it's called using dot notation like
317:02 - accessing members of a struct and it's
317:05 - implemented through an implementation
317:07 - block
317:09 - let's see an example over here we have
317:12 - the struct rectangle with two fields
317:17 - and as you can see we can then Implement
317:20 - methods for this rectangle type using
317:24 - the input keyword and the name of the
317:28 - type we want to implement the methods
317:31 - for
317:33 - so then over here we can see that
317:36 - rectangle has a method called area it
317:41 - takes as an argument a reference to self
317:45 - and self stands for the name of the
317:48 - instance so
317:51 - inside the method we are multiplying
317:54 - self dot with this field by self dot
317:58 - height this field and then we return the
318:02 - result of this operation now again self
318:06 - over here will be replaced by the name
318:09 - of the instance
318:12 - so when we create an instance of
318:15 - rectangle with concrete values then as
318:18 - you can see we can call this method on
318:21 - the created instance right one
318:24 - meaning when this method is called like
318:28 - that then self over here will be
318:31 - replaced by rect one so here rect1 dot
318:35 - width times rect1 dot height meaning 30
318:39 - by 50 will be returned
318:46 - now let's see Associated functions an
318:50 - Associated function is a function that
318:52 - is associated with a struct or an enum
318:55 - but doesn't take an instance as its
318:58 - first parameter so you can recognize an
319:01 - Associated function if it doesn't take
319:04 - self as its first parameter
319:08 - it's called using the name of the type
319:10 - not an instance of it
319:13 - and it's often used as Constructors for
319:16 - a struct or an enum
319:18 - so let's see an Associated function as
319:22 - you can see we have again the rectangle
319:24 - type and we Implement over here again in
319:28 - an implementation block
319:30 - the new Associated function for the
319:34 - rectangle type
319:36 - and notice we don't have a self here and
319:39 - you will see in a minute why that is now
319:42 - the new Associated function takes two
319:45 - arguments with and height both of type
319:48 - u32 and it will then create an instance
319:53 - rectangle and returns it
319:56 - meaning when we want to call this
320:00 - Associated function we don't call it on
320:03 - an instance right because we don't have
320:05 - self here we call it directly on the
320:09 - type
320:09 - so in this case we take rectangle double
320:12 - colon and then the function new and we
320:16 - provide it two values 5 and 10 right
320:21 - that means Rec 1 will then hold an
320:25 - instance of the type rectangle
320:29 - okay let's do the exercises we will skip
320:32 - this example because I've showed you
320:34 - that
320:36 - before
320:38 - and we will do the exercises directly
320:42 - methods are similar to functions declare
320:45 - with FN have parameters and a return
320:49 - value unlike functions methods are
320:52 - defined within the context of a struct
320:55 - or an enum or a trade object and the
320:59 - first parameter is always self which
321:03 - represents the instance of destruct the
321:05 - method is being called upon so as you
321:08 - can see we have the rectangle struct
321:11 - again and over here we have the
321:13 - implementation block we can implement
321:16 - the methods for this type
321:19 - now as you can see we instantiate
321:22 - rectangle over here with concrete values
321:25 - and then assign it to right one select
321:28 - one holds an instance of type rectangle
321:33 - then over here we call this
321:36 - then over here we call the method area
321:39 - on rect one and we should get back
321:43 - 1500 so let's implement the area method
321:48 - so
321:51 - the first thing is we always start with
321:55 - cell so every method takes as first
321:58 - argument self okay
322:02 - then the return type will be
322:06 - Au 32 right because we are here doing
322:10 - operation with these two fields
322:15 - now what we want to do to get the area
322:18 - of the rectangle is multiplying the
322:21 - width by the height
322:24 - so we use self.width
322:27 - times self dot height
322:31 - and I omit here the semicolon so this
322:34 - will get returned
322:37 - let's see
322:41 - so when we so when we call the area
322:44 - method on the rect one instance then
322:48 - rect one dot width times rect1 dot
322:51 - height
322:52 - will result will result in
322:56 - 1500 meaning 30 times 50.
323:01 - self will take the ownership of current
323:05 - struct instance however reference to
323:08 - self will only borrow a reference from
323:11 - the instance
323:13 - Let's see we have again destruct traffic
323:15 - light with one field now over here there
323:18 - is the implementation block we can
323:21 - Implement methods for destruct
323:24 - Now using self to fill in the blank so
323:28 - we have been using self like this
323:31 - right meaning we take a reference to the
323:35 - instance
323:37 - now this is actually syntactic sugar for
323:40 - this
323:45 - and as you can see itself with an
323:48 - uppercase s refers to the type we are
323:52 - implementing the method on right so in
323:56 - this implementation block when we use
323:58 - self uppercase it refers to traffic
324:02 - light
324:04 - and you can use this syntax or you can
324:08 - use like we did before
324:11 - using just self right
324:17 - and here we want to take immutable
324:19 - reference because we are here mutating
324:22 - the
324:24 - color field
324:30 - and again
324:33 - and this
324:36 - and this and that are exactly the same
324:39 - but this is not mutable so
324:43 - if I would do it like that
324:46 - then as you can see these are actually
324:49 - exactly the same thing but I would
324:52 - suggest just stick with that it's more
324:55 - readable and it's clear what you mean
324:59 - Associated functions all functions
325:01 - Define within an input block are called
325:04 - Associated functions because they are
325:07 - associated with the type named after the
325:10 - impul
325:12 - we can Define Associated functions that
325:15 - don't have self as their first parameter
325:17 - and thus are not methods because they
325:21 - don't need an instance of the type to
325:24 - work with
325:26 - so as you can see we again use the
325:28 - traffic like struct
325:30 - and here we have the imple block
325:33 - so let's see first Implement an
325:36 - Associated function new it will return a
325:40 - traffic light contains color red must
325:43 - use self don't use traffic light in FN
325:46 - signatures or body
325:49 - let's first see in main what's going on
325:51 - so we call here the new Associated
325:55 - function
325:58 - and disassociated function is associated
326:01 - with the traffic light type
326:05 - and again notice the difference is we
326:07 - call this directly on the type and not
326:10 - on an instance otherwise it would be a
326:14 - method
326:15 - so we call new and then we want to have
326:19 - an instance of traffic light back
326:24 - write this new function should return an
326:27 - instance of traffic light meaning we can
326:31 - then call upon this instance light the
326:34 - get State method and return Red
326:39 - so let's see
326:42 - over here we are expecting no argument
326:47 - right
326:48 - so let's leave it like that and remember
326:51 - Associated functions don't take self
326:55 - now the return type would be traffic
326:57 - light instance
327:02 - and because we should use self in here
327:05 - we can do that and again self in an
327:09 - implementation block refers to the type
327:13 - in this case traffic light
327:16 - then in there we want to create an
327:20 - instance of traffic light so again we
327:22 - can use self instead of this name
327:28 - and then we like normally instantiating
327:31 - it providing it concrete values
327:36 - so in this case we want this self.color
327:39 - field to hold a string of red
327:48 - like that
327:49 - and as you can see then we should get
327:52 - and as you can see when we call this
327:56 - Associated function we'll get back an
327:59 - instance with this concrete value a
328:02 - string red then we call upon this
328:06 - instance light the get State method so
328:10 - again self here refers to light because
328:14 - we are calling the method on this
328:16 - instance
328:17 - and it takes just a reference to the
328:22 - instance meaning light is usable even
328:25 - after this method call and all it does
328:29 - it will return the value inside the
328:31 - color field of the instance in this case
328:34 - slide
328:35 - so light dot color will hold a string of
328:40 - red
328:46 - multiple input blocks each struct is
328:49 - allowed to have multiple input blocks
328:52 - again rectangle struct and using
328:56 - multiple input blocks to rewrite the
328:59 - code below so
329:01 - we can either put all of the functions
329:04 - and methods in the same input block or
329:08 - we can even reorganize it using various
329:12 - different input blocks
329:16 - so we can for example put that
329:19 - in its own implementation block like
329:23 - that
329:24 - and it will work exactly the same this
329:27 - is just for organizing and restructuring
329:36 - enums we can also Implement methods for
329:39 - enums so over here we have the enum
329:42 - traffic light color with three variants
329:46 - Implement traffic light color with a
329:49 - method
329:50 - so over here in main we are
329:52 - instantiating traffic light color with a
329:56 - variant of yellow
330:00 - this would be the type annotation and
330:03 - then when we call a method color on the
330:07 - C instance it should return yellow
330:11 - so let's see
330:23 - so we could Implement that using a match
330:26 - statement
330:30 - then we match a self and if match self
330:35 - would be this
330:40 - then we return the string yellow
330:44 - okay
330:45 - [Applause]
330:47 - and we can over here instead of writing
330:51 - the whole name of the type we can again
330:54 - use uppercase self referring to the type
330:59 - this method is implemented on in this
331:03 - case traffic light color
331:05 - and remember in a match statement we
331:08 - have to handle all the possible cases
331:10 - meaning we have to create an arm for
331:13 - right and for green two so let's do that
331:30 - let's see
331:34 - and as you can see because we have here
331:37 - an instance which holds the variant
331:39 - yellow we will get back yellow when we
331:42 - call the color method
331:46 - all right that's it until next time
331:50 - until now we have only been dealing with
331:53 - concrete types but we can also deal with
331:57 - generics and generics are placeholders
332:01 - for concrete types it enables writing
332:05 - more reusable and flexible code and it
332:09 - avoids having duplicate code for
332:11 - different types it's a zero cost
332:14 - abstraction meaning the rust compiler
332:17 - will add compile time fill out the
332:20 - generics with concrete types
332:25 - and there is also a concept called const
332:28 - generics I will just briefly touch upon
332:31 - it because this is more of an advanced
332:34 - topic but I will show you one exercise
332:36 - just so you get the idea from it
332:40 - so const generic is a type parameter
332:43 - that represents a compile time constant
332:46 - value it allows to write generic code
332:49 - that operates on values that are known
332:52 - at compiled time and it's mainly used
332:56 - for array sizes bitwits and other
332:59 - constants and you will see what I mean
333:03 - when you see the exercise
333:07 - let's start with generics
333:10 - so as you can see over here we have a
333:14 - struct a now this would be considered a
333:18 - concrete type
333:20 - because we don't deal with generic types
333:23 - in here
333:24 - now destruct s takes as an argument an
333:28 - instance of destruct a this is also
333:32 - considered a concrete type because again
333:35 - there are not
333:37 - generics used here
333:39 - now destruct s-gen is considered a
333:44 - generic type because we are dealing here
333:47 - with a generic type parameter and this
333:51 - would be denotation when you declare
333:55 - a type for example then after the name
333:59 - of the type you annotate
334:02 - a generic type parameter like that using
334:07 - these symbols over here and then
334:10 - providing a name and by convention this
334:14 - is usually T standing for type and that
334:18 - means this struct can hold any type
334:24 - now as you can see we have here some
334:27 - functions this function over here takes
334:30 - s which is a concrete type the Gen spec
334:35 - takes as an argument an instance of s
334:39 - gen with a type of a
334:44 - now again a would be a concrete type
334:48 - meaning the type parameter over here
334:53 - is specified to be a concrete type so we
334:57 - can only pass to this S10 struct
335:02 - an instance of destruct a
335:07 - then over here we have the genspec i32
335:11 - function which takes as an argument the
335:14 - S-10
335:16 - struct over here with a value that is of
335:20 - type i32
335:23 - and over here we have a generic function
335:27 - meaning we are declaring after the
335:30 - function name the the generic type
335:34 - parameter T and then we can use it on
335:37 - here meaning that we can provide
335:41 - as an argument over here an instance of
335:44 - S-10 with any type
335:49 - so let's see using the non-generic
335:52 - functions so these over here are all
335:56 - non-generic as you can see because we
335:59 - didn't Define a generic type parameter
336:02 - and all the values it is using are
336:05 - concrete right over here we have S over
336:10 - here we have S10 and this is taking as a
336:14 - value T over here the concrete Type A
336:20 - and over here it takes as concrete type
336:23 - i32 so all these are non-generic
336:27 - functions the only generic function over
336:30 - here would be this one
336:33 - so let's see
336:34 - so we want to call Direct F and function
336:37 - and as you can see in the function
336:39 - signature we are taking as an argument
336:44 - a type of s
336:46 - so let's provide that
336:53 - now we have to pass into s
336:57 - the concrete type a right because that
337:00 - is defined
337:02 - in this
337:04 - struct
337:07 - then gen spec t
337:10 - so this function over here takes
337:14 - an S10 struct with a type of a now again
337:20 - a would be a concrete type
337:23 - so we provide here S10
337:27 - and a right
337:30 - so we are passing to the S gen
337:33 - struct over here
337:35 - a value of type A
337:41 - and in this case we want it to be S10
337:44 - and let's say 7 because over here we
337:48 - Define that this function should take as
337:51 - an argument a type S10 which holds an
337:55 - i32 integer
337:59 - then explicitly specify type parameter
338:03 - chart to generic
338:05 - so over here we are calling the generic
338:08 - function meaning we can pass to it and
338:12 - S10 type holding any possible type now
338:17 - we can explicitly specify a type
338:20 - parameter for this T over here and we
338:24 - are here saying T should be a char
338:29 - meaning we are calling the generic
338:31 - function over here with the type S gen
338:36 - and passing as a value a type of char
338:40 - let's say a
338:45 - and implicitly specify type parameter
338:49 - chart to generic so we don't have to
338:52 - annotate the type here it will be
338:55 - automatically inferred by the compiler
338:58 - so if I do the same thing over here
339:03 - let's go with Z this time
339:07 - as you can see this is compiling now
339:10 - again because sgen is defined to be
339:14 - generic over its type
339:16 - pass any value so let's pass for example
339:20 - a floating point
339:25 - as you can see this is also compiling
339:28 - because
339:30 - T over here is a placeholder that stands
339:34 - for any type possible
339:37 - but again when we annotate the specific
339:40 - type then we can only pass a character
339:44 - in this example so if I try 7.7 here
339:49 - this would be in compiler error
339:55 - if I Define f64 as you can see then it's
339:59 - working
340:02 - all right a function call with
340:05 - explicitly specified type parameter
340:08 - looks like that
340:11 - and this is also called the turbo fish
340:14 - syntax
340:15 - so let's see implement the generic
340:18 - function below
340:21 - so as you can see we are calling here
340:24 - the sum function with different types
340:28 - and that's the whole point of generics
340:30 - so here we are calling sum with two I8
340:34 - integers over here we call this sum
340:38 - function with 2i32 integers remember if
340:43 - nothing is annotated then the default
340:46 - integer type is i32 and here the same
340:50 - thing but for floating Point f 64.
340:55 - so we have to use here generics
340:59 - otherwise this won't be possible over
341:02 - here we are creating our generic type
341:06 - parameter and again by convention this
341:09 - is called t
341:11 - then we take here the arguments
341:15 - so let's say a should be of type T and B
341:20 - should also be of type T and then we
341:23 - return a type of t
341:29 - meaning if we pass here to i8
341:33 - integers then T will get converted to an
341:38 - I8 right this is just a placeholder and
341:43 - because we operate then on two i8s the
341:46 - type the return type will also be I8 so
341:51 - what we do is just adding together the
341:54 - two arguments and return it
342:04 - and over here we have to implement a
342:07 - trade bound and we'll cover that in the
342:10 - next section so we have to Define here
342:16 - that t should implement the add trait
342:19 - otherwise we can't use this plus sign
342:22 - over here
342:25 - and again we will cover that in the next
342:28 - section when we look at trades
342:31 - and as you can see this is compiling so
342:34 - we can pass to sum
342:36 - two numbers
342:37 - of any type
342:42 - let's see number three Implement struct
342:45 - point to make it work as you can see we
342:48 - are instantiating two point structs but
342:52 - over here we are passing to the fields
342:55 - different types so in the first instance
342:58 - we would have i32 values
343:02 - in the second instance we are dealing
343:04 - with floats
343:13 - so to make that possible we have to use
343:16 - generic so let's implement the point
343:18 - struct
343:23 - and we are defining here the generic
343:27 - type parameter
343:29 - and then we can Define the fields
343:36 - and as you can see the fields hold the
343:40 - type
343:41 - t
343:42 - meaning if we pass it intervals then X
343:46 - and Y Must both be integers if we are
343:50 - passing it floats then both of these
343:53 - fields must be of type floats
343:57 - now because we are here defining a
344:00 - generic type parameter this parameter
344:04 - over here becomes part of the type
344:07 - annotation so over here we are providing
344:10 - to the fields of the point struct values
344:13 - of type i32 so we must annotate that
344:19 - and over here we are passing f64
344:27 - and as you can see this is compiling now
344:30 - again we don't have to do the type
344:32 - annotations actually I just want to make
344:35 - that clear as you can see the compiler
344:38 - is able to infer that for us
344:43 - modify the struct to make the code work
344:46 - don't modify this code so as you can see
344:49 - we are here instantiating a point but
344:53 - the fields over here hold different
344:55 - types so this is not working
344:59 - because
345:01 - T over here defines that both of these
345:05 - placeholders will be filled with the
345:08 - same concrete type
345:10 - so in this case if we are passing X
345:14 - over here with an i32 type then the
345:19 - compiler thinks that y should also hold
345:22 - an i32 now what we can do then is
345:25 - defining another generic type parameter
345:29 - and by convention you just go one letter
345:33 - further so T and U meaning we can then
345:38 - use here U right and this
345:42 - indicates that the fields over here hold
345:46 - different types or could potentially
345:49 - hold different types they can also hold
345:52 - the same types
345:54 - and then when we annotate that
345:58 - we have said that the generic type
346:00 - parameter becomes part of the type
346:02 - annotation so we would pass here for x
346:07 - so we would pass here for T and i32
346:12 - the value
346:14 - the type the X field is holding and over
346:18 - here a string
346:22 - so this would be the type annotation for
346:26 - this returned instance
346:33 - number five at generic for well to make
346:36 - the code work don't modify the code in
346:39 - Main
346:40 - so here we have the valve struct holding
346:42 - one field and we have an implementation
346:46 - block implementing one method for the
346:50 - well type now how do I know it's a
346:54 - method because it has as first parameter
346:57 - this self keyword
347:00 - and all this Value method does is just
347:04 - returning a reference to the Bell field
347:07 - value all right so when we instantiate
347:11 - the Bell
347:14 - struct over here we are providing a type
347:17 - of f64.
347:19 - but over here we are instantiating the
347:22 - valve field with a string so again we
347:25 - have different types so let's annotate
347:28 - here the generic type parameter
347:31 - then we can use T here meaning the Field
347:36 - Val can hold any type
347:40 - so let's annotate here
347:53 - now over here as you can see
347:56 - we are returning the value of the Val
347:59 - field and we Define here that it should
348:02 - be of type f64. now this would cause an
348:07 - error because when we call over here
348:10 - the Value method on the instance of Y
348:14 - then self.wall would hold a string right
348:18 - so it doesn't return an f64. now we have
348:23 - to use a generic type parameter also in
348:27 - this implementation block and we can do
348:29 - that like that
348:35 - so we have over here
348:38 - the generic type parameter for our type
348:41 - and as we've said this becomes part of
348:45 - the type annotation
348:47 - and over here we are also defining a
348:51 - generic type parameter T so we are then
348:54 - able to use it inside the implementation
348:57 - block so over here we can Define that it
349:01 - should be a reference to T right a
349:06 - reference to any type that the wall
349:09 - field holds
349:11 - so in the first call of value it would
349:15 - be an F 64 right
349:18 - that is the type of The Returned value
349:23 - that Val field is holding
349:26 - and in the second call over here it
349:29 - would be a string right so T then would
349:32 - be string
349:40 - number six we have here a point struct
349:43 - and we are here defining that the fields
349:46 - could potentially hold different types
349:49 - but they could also be the same
349:52 - and here we have the implementation
349:55 - block for our point struct
350:00 - now as you can see over here we are
350:03 - instantiating a point with I 32 values
350:13 - right so they can be the same even if we
350:17 - here have two generic type parameters it
350:20 - doesn't matter they can be the same but
350:24 - over here we are instantiating point
350:26 - with two different types right
350:35 - we are instantiating point with a string
350:38 - literal this here and HR that over here
350:43 - so they are different in its types
350:48 - then we call over here the mix up method
350:52 - on P1
350:55 - and provided an argument of P2
350:59 - and then over here as you can see we
351:02 - want then P3
351:04 - to look something like that
351:26 - so we want the newly created instance
351:30 - here P3 to hold the value of the first
351:34 - instance in this case P1
351:37 - as you can see we are taking X from P1
351:42 - and we want the Y field to hold the
351:46 - value of the P2 instance of the P2
351:50 - instance this character
351:53 - right so how would we do that with
351:57 - generic type parameters
351:59 - now let's first Implement here the mix
352:03 - up function
352:08 - and again the convention is just the
352:11 - more generic type parameters you are
352:13 - declaring you just go further in the
352:16 - alphabet so T U V W all right
352:21 - and as you can see as a first argument
352:24 - we are taking P1 now let's take
352:28 - ownership we don't care because we don't
352:30 - use P1 after this point meaning we can
352:34 - take ownership and we don't have to use
352:37 - a reference to self here
352:40 - and
352:42 - as an argument here we want P2 meaning a
352:47 - point
352:49 - with generic type parameters we are
352:52 - declaring here
353:00 - and the return type will be a point
353:04 - with
353:05 - a generic type parameter t
353:08 - and a generic type parameter of w and
353:13 - you will see why that is
353:16 - so then what we want to do is creating
353:20 - here a new instance
353:26 - and we provide here x which should be of
353:31 - self because self here refers to P1
353:34 - right so we want self and we want the x
353:38 - value
353:42 - and Y should take it from the second
353:45 - argument the P1 over here and we want
353:49 - the Y field
353:55 - so let me actually annotate that as
353:58 - order
354:00 - [Applause]
354:03 - right we take here another
354:06 - Point instance and this would refer to
354:10 - P2 because we are passing P2 over here
354:14 - to this mix up method so we take from P
354:19 - to d y field
354:22 - and then we are returning this instance
354:24 - meaning P3 will then look something like
354:28 - that right
354:30 - so let me annotate the type
354:33 - we would have a point with the x value
354:37 - of P1 and i32
354:41 - and a character type of P2 the Y field
354:50 - right and that is what we will get
354:54 - let's first see if this even compiles
355:00 - and this is compiling
355:02 - now
355:03 - as you can see we have here a lot of
355:06 - generic type parameters so
355:10 - when we take a look at the mix-up method
355:14 - as you can see we are here declaring new
355:18 - generic type parameters because we want
355:21 - to Define over here that the types self
355:26 - and self again refers to the instance
355:29 - over here P1 that these types are
355:34 - different from the types provided on the
355:38 - second argument the instance of P2 right
355:41 - if we compare it together then P1
355:44 - instance holds different types than the
355:47 - P2 instant so we need new generic type
355:51 - parameters
355:52 - because t and u
355:54 - are for this P1 instance and the other
356:00 - the argument we are here providing P2
356:03 - will hold different types right
356:07 - and as you can see we are then taking
356:10 - from P1 the X field and from P2 we take
356:15 - the Y field
356:16 - and this would be the return type a
356:21 - point
356:22 - with t this is from P1 X and W this
356:28 - would be the second type from DP to
356:32 - point
356:35 - all right
356:38 - fix the errors to make the code work as
356:41 - you can see we have here is tracked
356:43 - point which has two fields which are
356:46 - generic over its type
356:49 - and we Implement over here
356:53 - a method for the point struct over here
356:58 - now this method over here is in fact
357:01 - only implemented for a struct point that
357:06 - holds F 32 types of fields right so if
357:13 - we would pass floats then this method is
357:16 - not implemented for a point
357:19 - so this is only implemented for point
357:21 - with a concrete type of F32
357:26 - now
357:28 - then over here we are calling on the
357:31 - fields X
357:33 - the power integer method
357:37 - and let's see that in the rust
357:39 - documentation
357:44 - so as you can see
357:46 - the power integer
357:48 - method over here is actually implemented
357:52 - for f 64 types right so self in this
357:57 - case must be of type f 64.
358:02 - as you can see over here we have X which
358:05 - holds an F 64 type so we can we can call
358:09 - this method on X right again this is a
358:14 - method and not a function
358:21 - so the problem over here is that self in
358:24 - this case would be F32 which is not the
358:29 - right type so let's change that f64
358:33 - and that means self over here would be
358:36 - of type f64 the concrete type we are
358:40 - providing here
358:42 - and then of course the return type would
358:45 - be f64 right because we are here
358:49 - performing an operation on two f64 types
358:54 - now
358:57 - over here of course we have to provide
359:00 - floating Point values right because
359:03 - again this method is only implemented
359:07 - for a point that holds as Fields F 64
359:13 - types
359:15 - like that
359:19 - all right and then we can use this
359:21 - method as defined in the standard
359:24 - Library
359:32 - and of course over here
359:35 - we just have to annotate one type right
359:38 - because we only have one generic type
359:41 - parameter
359:43 - and as you can see this is compiling and
359:46 - I will see you next time
359:49 - so I've told you that we will take a
359:51 - brief look at const generics and I will
359:54 - just solve one exercise and leave it at
359:57 - that because constant generics is a more
360:00 - advanced topic and you don't need it
360:03 - that much in your everyday programming
360:06 - so they're useful at some situations but
360:10 - they are not that much used
360:13 - so let's see an example over here we
360:16 - have here a struct array
360:19 - so we have here destruct array which
360:22 - defines two generic type parameters t
360:27 - and n
360:28 - now T is a generic type parameter and
360:32 - n over here is a const generic type
360:35 - parameter
360:36 - and as you can see each array struct
360:39 - holds a data field with an array
360:43 - of type t and n elements
360:48 - all right
360:49 - so when we look over here we have an
360:52 - array and I will now annotate this type
360:55 - of type array
360:59 - right this struct
361:03 - distract we have defined over here we
361:06 - are holding three instances as you can
361:09 - see one two three three instances of
361:13 - this array struct right
361:18 - like that
361:20 - now I've told you that when
361:23 - we have generic type parameters it
361:27 - becomes part of its annotations we have
361:30 - to annotate it over here too
361:33 - in fact we don't have to do that because
361:35 - it's usually inferred by the compiler
361:38 - but I will do it right now so
361:42 - this over here cares about the types in
361:46 - the aerated data field holds so as you
361:49 - can see we have here integers we have
361:52 - here
361:53 - floats and over here we again have
361:56 - integers
361:57 - and what that means is that in this
362:00 - array over here these actually should
362:03 - all hold the same type because we have
362:07 - to provide here a concrete type right
362:10 - for T and that means
362:13 - this data field over here will then hold
362:16 - in its array this type so in this case
362:20 - we will do i32
362:22 - and we need to provide it a constant
362:26 - meaning for the length of the array in
362:29 - this case we Define three all right
362:34 - and what that means is that the arrays
362:37 - inside the data field of these instances
362:41 - must be of i32 type and they must have a
362:46 - length of 3. right so we can't use
362:50 - floats here we have to use i32
362:54 - and over here we need to add another
362:57 - element
362:58 - now they can't be different for example
363:02 - let's do it like that
363:05 - that is possible
363:07 - but all of them over here must have the
363:11 - same type and the same amount of
363:15 - elements because we are annotating that
363:17 - here
363:19 - so it complies with the generic type
363:23 - parameter annotations here
363:27 - now let's create another array
363:32 - with floats
363:35 - now I want this to hold array instances
363:40 - of type f64
363:44 - and let's do two elements
363:48 - and I will pass here
363:51 - let's say also three
363:57 - and that means
364:03 - inside here
364:05 - let's first look at the outside array at
364:08 - this array over here so we want three
364:11 - elements of
364:14 - type array this array struct right
364:18 - so let's define that
364:33 - like that as you can see we have here
364:35 - three
364:38 - elements of type array now we Define
364:42 - here for the generic type parameters
364:45 - that
364:46 - the data field
364:55 - the data field should hold an array
365:04 - right because this is defined over here
365:08 - in the array struct
365:10 - so each data field should hold an array
365:14 - of f64 right the T over here
365:20 - of two elements right
365:24 - this is the const generic parameter so
365:28 - we are passing here a constant and not a
365:31 - type
365:33 - so in this case
365:36 - we the data field would have concrete
365:39 - types of f64 and two elements right so
365:45 - let's fill that out
366:00 - like that
366:02 - as you can see this is compiling because
366:04 - we are here complying with the generic
366:09 - type parameters
366:10 - we have three
366:13 - array instances
366:15 - right and each array instance holds a
366:18 - data field with these types
366:22 - f64 and they have to be two elements
366:27 - inside the array
366:29 - all right see in the next topic
366:34 - we will now cover trades so a trade is a
366:37 - set of methods that can be implemented
366:40 - for multiple types in order to provide
366:43 - common functionality and behavior
366:46 - between them a trade consists only of
366:49 - method signatures which then have to be
366:53 - implemented by the Target type it's
366:56 - similar to classes in other languages
366:59 - but not quite the same and it defines
367:03 - shared behavior in an abstract way so
367:07 - let's see how that might look like
367:10 - as you can see over here we have two
367:13 - custom types sheep and Cal now we want
367:17 - to indicate that these are somewhat
367:19 - related so over here we have created a
367:23 - trade anime which defines one method
367:28 - then over here we are implementing the
367:31 - animal trade for sheep and for cow now
367:36 - when we Implement a trade for some type
367:39 - then we have to implement all the
367:42 - methods the trade
367:45 - defines so in this case as you can see
367:47 - in the trade animal we only provide it
367:51 - with a function signature and then the
367:55 - concrete types for example sheep and cow
367:58 - will implement the method and Its
368:01 - Behavior
368:03 - so as you can see both sheep and cow
368:07 - then implement the animal trait meaning
368:10 - they automatically implement the method
368:14 - right
368:17 - so both of them
368:19 - take a reference to its instance for
368:24 - example an a ship instance and then just
368:28 - return the string over here
368:31 - and the same thing for cow
368:35 - now there is also derivable traits and
368:38 - we have seen that before a trait can be
368:41 - automatically implemented for a struct
368:44 - or an enum by the rust compiler these
368:47 - are called derivable because they can
368:49 - beat derived automatically
368:52 - and the most common derivable traits are
368:55 - debug allowing to Output content via
368:58 - this debug notation we have seen that
369:01 - clone which enables a type to be
369:04 - duplicated with the Clone method
369:08 - copy enables a type to be copied
369:10 - implicitly without requiring explicit
369:14 - clone method and partially queue enables
369:18 - comparison
369:22 - now we can pass trades as parameters so
369:27 - the notify function over here takes as
369:29 - an argument any type that implements the
369:33 - summary trade
369:35 - meaning we can ensure that the item
369:39 - argument over here implements this
369:42 - summarize method right if we provide
369:46 - here A type that didn't implement this
369:50 - summary trait then it wouldn't have this
369:52 - summarize method
369:55 - trades can be used as parameters for
369:57 - functions the function notify takes as
370:01 - an argument any type that has
370:03 - implemented the summary trait
370:07 - now there is also a concept called trade
370:10 - bounce
370:11 - meaning if we declare over here a
370:15 - generic type parameter we can define
370:18 - that
370:20 - the type over here must implement the
370:24 - summary trade so the argument we pass to
370:27 - this notify function must implement this
370:31 - summary trait
370:34 - and this is similar to the example using
370:37 - the impulse summary but more verbose
370:40 - so as you can see this would actually be
370:43 - exactly the same like we did over here
370:47 - trade bounds are declared like generics
370:50 - after the name of the function and use
370:54 - trade bounds if you have lots of
370:56 - parameters to avoid this so if we would
371:00 - have here an argument which takes a
371:04 - typed Implement summary and another
371:07 - argument which
371:09 - again takes a type that implements
371:12 - summary we can do it like that so we
371:15 - Define here a trade bound meaning the
371:19 - generic type T must implement this
371:23 - summary trait so both argument 1 and
371:27 - argument 2 take a reference to a type
371:31 - that implements the summary trait
371:35 - and if you have big trade bounds like
371:38 - for example this we have here generic
371:41 - type parameter T and we say here that
371:44 - the type T has to implement the display
371:47 - and decline trades
371:49 - and the generic Type U has to implement
371:53 - the Clone anti-debug trait right and
371:57 - then over here as you can see the first
371:59 - argument must be of type T and the
372:03 - second one of Type U and we are taking
372:05 - references
372:08 - so we can write that in a more concise
372:11 - way using a verb Clause meaning after
372:15 - the return type in a function we can use
372:18 - the verb keyword and then over here
372:21 - Define our trade bounds and this over
372:25 - here is exactly the same as this but
372:29 - instead of
372:31 - defining the trade bounds directly on
372:34 - the generic type parameter we do it in a
372:37 - separate block
372:42 - foreign and we can also
372:45 - return from a function a type that
372:49 - implements a specific trait so as you
372:52 - can see the return dog function over
372:55 - here returns an instance of the dog
372:58 - struct
372:59 - and because the animal trade over here
373:03 - has been implemented for torque we can
373:06 - also Define the return type as follows
373:10 - we return here an instance of talk
373:13 - meaning we return here
373:16 - a type that implements the animal trade
373:19 - because as you can see animal is
373:22 - implemented for the dog struct
373:26 - let's see exercise one feeling the two
373:29 - input blocks to make the chord work
373:31 - don't modify the code in main now we
373:35 - have here a trade hello
373:38 - finding two methods now over here you
373:42 - can see that we didn't only provide the
373:45 - function signature but we implemented
373:48 - basically the whole method why is that
373:51 - because this is considered the default
373:54 - implementation meaning any type that
373:58 - implements the hello trade automatically
374:00 - gets this default implementation of this
374:04 - method so we don't have then to
374:09 - implement it manually it will
374:12 - automatically get implemented for the
374:15 - type that implements the hello trade
374:19 - but as you can see over here we have a
374:21 - method which is here just a function
374:25 - signature so we have to implement that
374:28 - manually
374:30 - then over here we have two structs
374:32 - student and teacher and we Implement
374:36 - over here the hello trade for student
374:39 - and for teacher
374:42 - so let's see we have here an instance of
374:45 - student
374:47 - and as you can see this is just a struct
374:51 - that doesn't hold any values right so we
374:55 - instantiate it like that
374:57 - but because
374:59 - we have here implemented hello for the
375:03 - student struct that means we can then
375:07 - call upon it
375:09 - this method over here as you can see we
375:13 - call this say hi method on the S
375:15 - instance and then it should return high
375:19 - now we don't have to implement this say
375:22 - hi method over here again like that
375:31 - we don't have to do that because it's
375:34 - already implemented by default right
375:38 - but what we have to implement is to say
375:41 - something method because as you can see
375:44 - we are calling the say something method
375:47 - on the instance of s and remember when
375:51 - we Implement a trade for a type in this
375:54 - case student we have to implement all
375:58 - the methods
375:59 - except the default implementation here
376:03 - so let's actually
376:05 - take this and copy it over
376:09 - because the function signature must be
376:12 - exactly the same like defined in the
376:16 - trade
376:17 - and then over here we want the return to
376:20 - be I'm a good student
376:24 - so let's return this string here
376:34 - like that
376:39 - so when we call
376:42 - on an instance of student this say
376:46 - something method then it will return I'm
376:50 - a good student
376:52 - now over here we are instantiating the
376:55 - teacher struct
376:59 - and as you can see we are calling the
377:01 - method on the T instance and this should
377:05 - be the returned string so as you can see
377:08 - this is different from what is
377:11 - implemented in the default
377:13 - implementation and that means we have to
377:16 - re-implement this say hi method for the
377:19 - teacher type
377:32 - and the return string should be hi I'm
377:35 - your new teacher
377:43 - so as you can see if a trade defines a
377:46 - default implementation we can also
377:50 - overwrite
377:51 - the default implementation and provide
377:55 - another return value
377:58 - and of course because we have to
378:01 - implement
378:02 - this over here I will copy that
378:06 - and I will implement it for the teacher
378:09 - type
378:12 - so as you can see when we call
378:14 - the say something method on an instance
378:17 - of teacher then we should get back this
378:20 - string
378:29 - so as you can see we have then
378:32 - implemented the hello trade for our
378:36 - custom types student and teacher let's
378:40 - see if that compiles
378:44 - and this is compiling
378:47 - derived the compiler is capable of
378:50 - providing basic implementations for some
378:53 - trades via ddrive attribute for more
378:57 - info please visit here
378:59 - let's see over here we have a tuple
379:02 - struct centimeters which holds a value
379:05 - of type f64 now as you can see this
379:10 - truck here derives to trades partially q
379:14 - and partial order meaning the compiler
379:18 - will automatically Implement these
379:21 - trades for our type centimeters
379:25 - now partially Q is for comparing
379:28 - equality and partial order is for
379:31 - ordering
379:32 - so over here we have inches and and
379:37 - inches is a tuple struct that holds an
379:40 - i32 type
379:43 - and it derives the debug trade meaning
379:46 - we can print it out using the debug
379:49 - notation
379:51 - and as you can see over here we
379:53 - Implement a method two centimeters for
379:57 - an instance of the inches type
380:00 - so when we call
380:02 - this
380:04 - method on an instance of inches then we
380:08 - will convert it to centimeters right so
380:12 - we hear the reference self meaning the
380:15 - instance
380:17 - of inches and then we destructure over
380:22 - here
380:23 - the inches basically the value
380:27 - that the Tuple struct inches holes so
380:31 - this variable then will hold the value
380:35 - of
380:37 - the instance provided here okay and then
380:42 - as you can see we are multiplying inches
380:44 - by 2.54 to convert it to centimeters and
380:49 - we are wrapping that
380:52 - and we are returning that as an instance
380:57 - of centimeters as you can see
381:05 - add some attributes to make the code
381:08 - work don't modify other code
381:11 - so as you can see over here we are
381:13 - instantiating this seconds struct
381:19 - [Applause]
381:23 - so then we are printing it out using
381:27 - debug notation so we have to derive over
381:30 - here the debug trade
381:36 - then we are here comparing for equality
381:40 - so we have to
381:42 - derive The partially Q trait
381:47 - and over here we are checking if one
381:50 - second is bigger than one second meaning
381:53 - we need to implement the partial order
381:58 - trade
381:59 - like that
382:03 - and as you can see we are here
382:05 - instantiating the inches struct
382:09 - providing it a value of 12 right this
382:14 - i32 type
382:18 - and then we print it out
382:21 - and let's check debug is implemented so
382:24 - we can print it using debug notation and
382:29 - over here we are instantiating the
382:31 - centimeter struct
382:34 - [Applause]
382:36 - as you can see centimeters takes a value
382:39 - of f64.
382:43 - and over here we are comparing
382:49 - as you can see over here this foot
382:52 - instance
382:54 - holding an instance of inches with 12.
382:58 - so in the U.S 12 inches equal one foot
383:04 - and then we call the two centimeters
383:06 - method on it mean meaning this will then
383:10 - return an instance of centimeters right
383:14 - so we are taking here inches 12.
383:19 - and that means
383:20 - 12 over here will get destructured right
383:24 - here we have
383:28 - here self would be inches 12 and we take
383:32 - it as an reference like that so
383:37 - we destructure it like that using the
383:40 - let keyword the reference because we
383:43 - want to take the value and not a
383:46 - reference and then 12 will be put inside
383:50 - the inches variable
383:53 - then we are multiplying by
383:56 - 2.54 and returning an instance of
384:01 - centimeters and that means
384:05 - we can then compare this over here
384:10 - with the meter because the meter holds
384:14 - also the same type namely the custom
384:18 - type centimeters over here
384:21 - right
384:23 - so both
384:25 - types would be here of type centimeters
384:33 - and if this is smaller than this then it
384:37 - will
384:39 - assigned to this variable
384:41 - a string smaller otherwise bigger and
384:46 - these are string literals by the way
384:49 - and over here we are outputting
384:52 - the result of this compare
385:00 - let's see
385:06 - and as you can see this is compiling
385:10 - so we are outputting here one second
385:12 - looks like seconds one as you can see we
385:16 - can
385:17 - output this
385:21 - type over here seconds because we have
385:24 - derived the debug trade meaning we can
385:29 - use debug notation
385:32 - then one foot equals inches 12.
385:36 - and over here this one foot is smaller
385:40 - than one meter
385:43 - operator in Rust many of The Operators
385:46 - can be overloaded via trades that is
385:49 - some operators can be used to accomplish
385:52 - different tasks based on their input
385:55 - arguments this is possible because
385:58 - operators are syntactic sugar for method
386:02 - called example the plus operator in a
386:05 - plus b calls the add method as in a at B
386:10 - over here this would be a method this
386:14 - add method is part of the add trade
386:17 - hence the plus operator can be used by
386:21 - any implementer of the add trade
386:27 - so Implement implement the function
386:31 - multiply to make the code work as
386:34 - mentioned above plus needs T to
386:37 - implement standard Ops add trait
386:41 - that's why we are here importing the Ops
386:44 - module from standard Library
386:48 - so let's implement the multiply function
386:51 - as you can see over here we are
386:54 - providing two u8 integers to the
386:58 - multiply function now in the second call
387:01 - over here we are providing flow means we
387:04 - need a generic type parameter like that
387:08 - so this function takes two arguments
387:17 - and it will return T basically the same
387:21 - type of the provided arguments
387:27 - and then over here we basically just
387:30 - want to multiply a by B now as you can
387:35 - see over here we are using the operator
387:37 - for multiplications
387:40 - and that means we have to ensure that
387:44 - the T over here
387:47 - the type of the arguments that the
387:51 - multiply function takes
387:54 - implements the Mal trait
387:57 - now the mall trade like the add trades
388:00 - over here
388:02 - then knows that if both of the types of
388:08 - A and B Implement The Malt rate it is
388:12 - possible to multiply these two together
388:15 - so we can use here a trade bound meaning
388:20 - the type T over here should implement
388:28 - should implement the standard of malt
388:32 - rate
388:32 - because again this is just overloading
388:37 - and syntactic sugar for this call
388:43 - right
388:45 - so this actually would translate to this
388:49 - and we are seen in the add over here
388:51 - that it would be a at B right
388:56 - these operators are just overloaded so
388:59 - it's easier to use
389:02 - and that's why we have to ensure that a
389:07 - this argument here of type T has
389:11 - actually implemented the Mal method
389:16 - and we make sure that this is the case
389:19 - when providing here a trade bound
389:22 - meaning T must Implement The Malt rate
389:26 - meaning then that t has implemented the
389:31 - Mal method let's see
389:57 - and we have here to also
390:02 - find that the output will be of type t
390:06 - because as you can see the mult rate
390:08 - over here
390:10 - has an Associated type of output so we
390:14 - have to Define and we will take a look
390:16 - at Associated types
390:19 - but we have here to Define that the
390:21 - output should of type t
390:24 - that the output should be of type T
390:27 - right
390:29 - let's see again
390:32 - and this is working
390:36 - fix the arrows don't modify the code in
390:39 - main so over here again we are using the
390:42 - Ops module from the standard Library
390:45 - then we have here two structs full and
390:47 - power and full bar and Powerful
390:52 - the standard Ops add trade is used to
390:56 - specify the functionality of the plus
390:58 - operator here we make add bar to trace
391:03 - for addition with a right hand side of
391:06 - type bar the following block implements
391:09 - the operation full plus bar should
391:13 - return powerful so if we
391:16 - USD plus operator with these two types
391:20 - over here we should return this type
391:22 - right full plus bar should return full
391:26 - bar
391:28 - now let's see the add
391:31 - tray
391:32 - now the add trade over here takes as
391:36 - default parameter
391:39 - rhs standing for right hand side
391:43 - if we don't provide anything to right
391:45 - hand side then it will be self meaning
391:48 - the type we implement the add trade on
391:53 - and as you can see we have an Associated
391:56 - type here for the output
392:00 - and over here as you can see it takes
392:04 - self and basically becomes the owner
392:07 - when called on an instance that
392:09 - implements the add trade
392:12 - and right hand side is off type right
392:16 - hand side which means by default it
392:20 - would be self
392:21 - and this looks confusing I know but you
392:25 - will get it when we Implement that over
392:28 - here
392:29 - so as you can see we are implementing
392:31 - from the Ops module the add trade so we
392:35 - can Implement from this standard Library
392:38 - trades for our custom types
392:43 - and
392:45 - let's see
392:47 - again
392:51 - when doing something like that
392:53 - [Applause]
392:56 - then
392:59 - then the compiler will actually do
393:02 - something like that
393:08 - right it will call the add method now
393:12 - this over here is the type here would be
393:15 - an instance of Foo but just so you get
393:19 - the concept
393:23 - and as you can see we have here to
393:26 - define the right hand side meaning the
393:29 - right hand side over here would be poor
393:32 - and we are implementing the add trade
393:35 - for Foo right
393:37 - because we want the instance to be of
393:40 - Type 4 so we implement it for Foo
393:46 - and we want the right hand side to be of
393:49 - type bar now if we wanted
393:53 - to add for example
394:02 - then we could omit that because you are
394:05 - seeing that the default
394:08 - itself right so the default right hand
394:11 - side would be
394:13 - self as you can see
394:16 - so we can omit that but
394:20 - the
394:22 - bow but that means both types must be
394:26 - the same in this case Foo and fool right
394:29 - because self over here refers to the
394:33 - type we are implement the trade four
394:37 - right but in this case it would be bar
394:40 - right because the right hand side is
394:43 - different from the left hand side
394:47 - and the output should be of type full
394:50 - bar so as and again Associated functions
394:54 - we will cover that very soon
394:57 - so over here we have to implement the
395:01 - add method right because the
395:04 - add trade over here defines an add
395:08 - method so we have to implement it
395:13 - and that means we take self and this is
395:17 - taking ownership of an instance of Foo
395:21 - right
395:23 - and right hand side would be of type bar
395:28 - again
395:30 - as you can see Foo would be the instance
395:32 - then we call the add method upon the
395:35 - instance and this argument should be of
395:39 - type par and then we return full bar
395:45 - so in Main
395:48 - when we call
395:51 - so in main when we perform this over
395:54 - here full plus bar we will get back full
395:57 - bar right
395:59 - so we have implemented the plus operator
396:03 - on our custom types
396:07 - now let's do the same for minus sign but
396:11 - in this case full minus bar would be
396:14 - powerful
396:15 - so let's see as you can see this would
396:18 - be distract we want to return powerful
396:23 - so
396:25 - minus sign
396:33 - is actually the same but implementing
396:35 - this sub trade
396:38 - so we will type full sub
396:41 - R right this would be the sub method
396:44 - defined in this sub trade as you can see
396:48 - we are here implementing
396:51 - the substrate from the Ops module
396:55 - for bar
396:57 - now again we want actually to implement
397:00 - it for Foo because here
397:04 - we
397:05 - call Foo support meaning we would
397:10 - implement it for the foo instance
397:17 - because cell 4 here refers to the
397:20 - instance the method is called upon right
397:24 - so the sub will be called upon self
397:27 - meaning we have to implement it for Foo
397:31 - and the right hand side would be bar
397:36 - now we want to return bar food that's
397:39 - true
397:40 - and
397:42 - over here as you can see
397:45 - the sub method is implemented but as
397:49 - right hand side the type should be bar
397:52 - right this is the right hand side of the
397:56 - operation
398:00 - and we are returning powerful so when we
398:04 - do this full minus 4 we will get back
398:07 - powerful so we have overloaded this
398:10 - operator
398:16 - and of course to do assert EQ here
398:19 - because this is a custom type we have to
398:23 - implement the partial EQ trade so let's
398:27 - do that
398:47 - and we also have to implement the debug
398:50 - trade
398:59 - as you can see this is compiling meaning
399:02 - when we use our custom types with these
399:05 - operators they will return a custom type
399:09 - and we can do that by implementing from
399:12 - the Ops module from the standard Library
399:15 - the appropriate trades
399:18 - for our custom types
399:22 - use trade as function parameters
399:25 - instead of a concrete type for the item
399:28 - parameter we specify the input keyword
399:31 - and the trade name this parameter
399:34 - accepts any type that implements the
399:37 - specified trade
399:41 - as you can see we have here a trade
399:44 - summary
399:45 - Implement function summary to make the
399:48 - code work fix the errors without
399:50 - removing any code line
399:53 - so over here we have a struct post with
399:56 - three fields of type string
399:59 - and we Implement over here this summary
400:03 - trade for the Post struct meaning we
400:07 - have to implement the defined method in
400:11 - the trade
400:12 - so we implement it for post like this as
400:16 - you can see we are accessing from the
400:19 - instance remember this is a method so it
400:23 - refers to an instance
400:25 - it is called upon right
400:28 - so we access the fields self.title and
400:32 - self dot author all right
400:38 - then over here we have a struct Weeble
400:41 - with two fields of type string then we
400:44 - implement the summary trait for Weeble
400:47 - and we then have to implement the method
400:51 - from the trade all right because again
400:54 - when we Implement a trade for a type we
400:59 - have to implement its methods
401:03 - so this over here accesses the username
401:06 - and contact field and prints it out
401:11 - now here we have an instant of post
401:14 - and here we have an instance of weibo
401:21 - so as you can see we are here calling
401:23 - this summary function with an argument
401:26 - of post and weibo so we have to
401:30 - implement this summary function below
401:32 - let's do that
401:37 - now
401:38 - as an argument
401:41 - it takes
401:44 - now as an argument it takes
401:47 - in the first call Post and in the second
401:50 - call Weeble right two different types
401:54 - but now think about it what do they
401:57 - share in common
401:59 - write they implement this summary trade
402:03 - right we have implemented it for post
402:06 - and for Weeble so we can Define over
402:09 - here that the argument provided must be
402:13 - a type that implements the summary trait
402:18 - and we do it like that
402:21 - and then inside the function body we
402:24 - want to take this argument
402:27 - and again a is an instance of a type
402:31 - that implements the summary trait so we
402:35 - are taking a and we call upon it the
402:37 - summarize method
402:43 - meaning
402:45 - the first one it will be post dot
402:48 - summarize
402:49 - now post over here is of type post
402:53 - meaning we go to post and as you can see
402:56 - this would be the summarize method as
402:59 - you can see self would refer to the
403:01 - instance in this case post
403:05 - this instance over here
403:09 - so then the summarize method will return
403:12 - a string
403:13 - so let's actually
403:15 - assign this to a variable
403:18 - [Applause]
403:22 - this would then hold this string and we
403:24 - can then output
403:32 - like that let's see
403:36 - and of course
403:38 - when we are calling the summary method
403:42 - with an instance then we can't use the
403:45 - instance again so let's define here that
403:48 - it should take a reference
403:51 - right
404:00 - and as you can see this is compiling
404:04 - now what we can do over here
404:06 - and this would be exactly the same we
404:10 - can Define here a generic type parameter
404:13 - T and here Define that it should
404:17 - Implement summary right so we Define
404:20 - here the type t
404:23 - and it should be a type that must
404:26 - Implement summary and then we can write
404:29 - it like that
404:31 - so a should then be a reference of type
404:34 - T which implements summary trait let's
404:37 - see
404:39 - as you can see exactly the same thing
404:45 - returning types that Implement rates we
404:48 - can also use the infiltrate syntax in
404:51 - the return position to return a value of
404:54 - some type that implements a trade
404:57 - however you can only use input trade if
405:00 - you're returning a single type use trade
405:03 - objects instead when you really need to
405:06 - return several types
405:09 - so over here we have two custom types
405:12 - sheep and Cal and we have one trade
405:15 - animal which has one method
405:19 - so over here we are then implementing
405:21 - the animal trades for both of these
405:24 - custom types
405:26 - and as you can see when we Implement a
405:29 - trade for a concrete type then we have
405:33 - to implement the given method
405:37 - so over here we have a function random
405:41 - animal it takes a random number and then
405:45 - and then looks if the random number is
405:48 - less than 0.5 it will return a sheep
405:52 - instance otherwise it will return a cow
405:56 - instance
405:58 - now over here the return type of the
406:01 - function would be a type that implements
406:05 - the animal trade which both of them do
406:10 - and as you can see in main we have here
406:12 - our random number
406:17 - and we call this random number on the
406:21 - random animal function so let's for now
406:24 - assume that this really is random okay
406:28 - so that means that when this is passed
406:32 - over here it could either be a sheep or
406:36 - a cow to be returned here
406:40 - but the problem here is that the return
406:44 - type in a function must be of known
406:48 - fixed size at compile time
406:51 - which in this case sheep might be bigger
406:54 - than cow or cow might be bigger than
406:57 - sheep so the exact size is not known at
407:02 - compile time so when we do that
407:05 - this doesn't work
407:08 - and to make that work we have to know
407:11 - about trade objects so let's see
407:16 - so trade objects using input traits
407:19 - doesn't work when returning multiple
407:22 - types different implementations of a
407:25 - trade probably with different amounts of
407:28 - memory but sizes of types must be known
407:32 - at compiled time in this case a trade
407:35 - object can be used a trait object is
407:39 - essentially a pointer to any type that
407:42 - implements the given trade where the
407:45 - precise type can only be known at
407:48 - runtime
407:51 - so
407:53 - over here for example we have a trade
407:56 - animal and two custom types token cat
407:59 - then we implement the trade animal for
408:03 - both of these types
408:05 - and as you can see we have a function
408:08 - return animal it takes a string and if
408:12 - this string is dark then it returns a
408:16 - dog instance now if it returns cat then
408:20 - it returns a cat instant but as you can
408:24 - see we are here providing a reference to
408:27 - the instance and not the incense itself
408:30 - because when we return a reference to a
408:34 - type that implements the animal trade it
408:38 - means that the size of this type is
408:41 - known at compile time because remember a
408:44 - reference is a pointer and the size of a
408:48 - power and the size of a pointer is known
408:52 - at compile time meaning it's of Type U
408:55 - size and U size is 8 bytes on a 64-bit
409:00 - computer
409:02 - so the size of the return type is known
409:07 - it's just a pointer sized type
409:11 - so the size of the return type is known
409:15 - at compile time it's of size U size
409:18 - right because we are here returning a
409:22 - pointer meaning it doesn't matter if dog
409:25 - is bigger than cat or otherwise
409:28 - it's always the same size because
409:32 - pointers have a fixed size at compile
409:35 - time
409:37 - and that is how we would
409:40 - solve this problem so again here we have
409:43 - a function which
409:45 - so here we have a function which returns
409:48 - a type that implements the animal trade
409:51 - this could be dog or cat as the trade
409:55 - object is behind the pointer the size is
409:58 - known at compile time which is U size
410:01 - the size of a pointer this allows for
410:05 - more flexible code as the exact return
410:07 - type doesn't have to be known at compile
410:11 - time as long as the size is fixed
410:14 - so we don't care anymore about the size
410:17 - of dog and cat because they're behind a
410:21 - pointer
410:23 - and to understand what's going on you
410:25 - have to know about static and dynamic
410:28 - dispatch so let's first look at static
410:31 - dispatch
410:33 - static dispatch resolves method calls at
410:36 - compile time the compiler will generate
410:40 - function code for each concrete type
410:43 - that implements the trade
410:45 - it calls the appropriate function based
410:48 - on concrete types it's faster and more
410:52 - efficient than Dynamic dispatch but it
410:55 - doesn't provide great flexibility
411:00 - so we have here the trade animal
411:04 - holding one method say hi then we have
411:08 - Talking Cat and we implement the animal
411:11 - trade for dog and for cat
411:15 - now as you can see when we create an
411:17 - instance from dog and from cat and call
411:20 - the say hi method on it because as you
411:25 - can see every
411:27 - every type that implements the animal
411:30 - trait must have this method
411:33 - and when we then run this program then
411:37 - the compiler will actually generate
411:40 - methods for each concrete type in this
411:43 - case stock or cat
411:45 - because then the say hi method we are
411:49 - calling here on the dog and cat instance
411:53 - is known at compile time
411:56 - so the compiler then knows when we call
411:59 - the method on the dog or cat instance
412:03 - which method has to be resolved for
412:07 - which type
412:10 - so let's see Dynamic dispatch
412:12 - in Dynamic dispatch the specific methods
412:16 - to be called is determined at runtime
412:20 - and not at compile time like static
412:22 - dispatch
412:23 - it works by creating a reference or
412:26 - smart pointer to a trade object using
412:30 - reference din or boxed in when trade
412:35 - object is created the compiler will
412:37 - build a v-table for that trade a v table
412:41 - is a table that contains a pointer to
412:44 - the implementation of each method in the
412:48 - trades for the specific type of the
412:50 - object that the reference points to
412:55 - the compiler will do a lookup in a V
412:58 - table to determine which method should
413:01 - be called for which type that implements
413:04 - the given trade
413:06 - and this lookup will cause overhead but
413:09 - allows for more flexible code
413:12 - so exactly because of this lookup
413:15 - static dispatch is faster than Dynamic
413:19 - dispatch but on the other hand Dynamic
413:22 - dispatch allows for more flexibility
413:26 - so let's see how that might look like as
413:30 - you remember with box we are able to
413:33 - allocate a type to Heap memory meaning
413:38 - the type will then get allocated for
413:41 - example a
413:42 - i32 integer like 7 will get allocated to
413:47 - the Heap and we will then get back a
413:50 - pointer this is what box is for and we
413:54 - have seen examples of that now when we
413:57 - use box with a trait object it means
414:00 - that the
414:03 - type that implements the specific trade
414:06 - will get allocated in Heap memory get
414:10 - back a pointer to the location where the
414:14 - type that implements this specific trait
414:16 - was allocated and we will get back a v
414:21 - pointer right this is happening when
414:24 - dynamically dispatching so the V pointer
414:28 - points to the V table
414:30 - and in the v table there are certain
414:34 - Fields now there is also a field called
414:37 - Methods and this is where all the
414:40 - methods for the concrete type over here
414:43 - are located meaning at runtime the
414:48 - compiler will check this V table and see
414:52 - in the methods over here which methods
414:55 - are implemented for the concrete type
414:58 - that was allocated in Heap memory
415:03 - so let's see an example
415:06 - so we have over here a trade animal and
415:10 - we have two custom types cat and talk
415:12 - and we implement this method defined in
415:16 - the trade for both of our types right
415:20 - because when we Implement a trade for a
415:23 - custom type we have to implement all of
415:27 - its defined methods
415:29 - so over here we have seen we have a
415:33 - random animal function which takes a
415:35 - random number and based on this
415:37 - conditional it will either output a cad
415:41 - instance or a dog instance
415:45 - so then when we call this random animal
415:48 - function with the random number and for
415:50 - now just assume that this is really a
415:53 - random number
415:54 - that means the compiler first of all
415:56 - cannot determine the size of the type
416:00 - which gets returned and this is of type
416:03 - that implements the animal trade right
416:06 - cat and dog both implement the trade but
416:10 - we can't know the exact size at compile
416:14 - time meaning we put it behind a pointer
416:18 - in this case a box but a reference would
416:21 - also be possible and that means the size
416:24 - is now known right it's the size of a
416:28 - pointer basically U size 8 bytes in a
416:32 - 64-bit computer
416:34 - but we have another problem over here
416:38 - the return value will be
416:41 - a type that implements the animal trade
416:44 - but at compile time when we call the
416:47 - noise method over here the compiler
416:51 - doesn't know
416:53 - which
416:54 - of these types get returned so he so the
416:58 - compiler can't know which method he has
417:03 - to call is it for the implementation on
417:06 - cat or dog right
417:09 - so this is why we use Dynamic dispatch
417:13 - because that means this over here will
417:16 - get decided at run time so again the
417:20 - compiler will then look up in this B
417:23 - table over here using the V pointer
417:25 - which points to the V Table stores in
417:28 - heaped memory and and then it will check
417:31 - for the concrete type that got allocated
417:34 - on Heap memory this specific methods
417:38 - so for example again this is happening
417:41 - at runtime
417:42 - we return a cat then the compiler will
417:46 - see that the type over here which is
417:48 - concrete is cat so it will see in the v
417:52 - table the methods implemented for the
417:56 - concrete type of cat
417:58 - I hope this makes sense
418:01 - so this is why we need Dynamic dispatch
418:04 - here static dispatch doesn't work
418:07 - because again the output of this
418:10 - function is random
418:15 - so let's see box box is a smart pointer
418:19 - that allows to store data on the Heap
418:22 - rather than this stack and you can use
418:25 - box when you have a type whose size
418:27 - can't be known at compile time it
418:31 - returns a pointer to the data stored on
418:34 - the Heap
418:36 - so what's the difference between a
418:39 - reference and a box in terms of memory a
418:43 - box allocates the data on the Heap and
418:46 - owns it
418:47 - is also responsible for deallocating
418:50 - when the value goes out of scope and the
418:53 - reference only points to a value that is
418:56 - already in memory meaning the reference
419:00 - points to something that is already
419:03 - there while a box allocates and a and
419:08 - the reference also doesn't own anything
419:10 - it just points to something
419:14 - in terms of lifetimes a box can be
419:17 - passed across Scopes while the reference
419:19 - has limited lifetime and we will cover
419:22 - lifetimes very soon a box can be cloned
419:26 - and the reference cannot and the Box can
419:29 - also be used in pattern matching
419:34 - so
419:35 - we have left off over here and I hope by
419:39 - now you know that this over here is not
419:42 - possible we cannot return a type which
419:46 - implements the animal trade because
419:48 - these could vary in size
419:52 - and again over here we return
419:55 - a type that implements the animal trade
419:59 - now if this over here would be really a
420:02 - random number then we don't know exactly
420:05 - at compile time which type gets returned
420:08 - meaning we can't use here the noise
420:11 - method because the compiler can
420:14 - impossibly know at compile time of
420:18 - course which
420:20 - method he has to call is it this one
420:25 - or is it this one right
420:29 - and for that we will use Dynamic
420:32 - dispatch so again we can put
420:37 - this in a box
420:40 - and using here the pin keyword meaning
420:44 - we want to go with Dynamic dispatch here
420:48 - and that means we have to box these
420:51 - instances
421:05 - so now
421:07 - the return type over here is known at
421:11 - compile time meaning we can annotate it
421:13 - it would be a box
421:16 - which holds a type that implements the
421:19 - animal trade
421:21 - and this is using Dynamic dispatch
421:24 - meaning we then can call
421:27 - this noise method on this instance here
421:33 - because the compiler can check for this
421:36 - noise method at run time and not at
421:39 - compile time meaning it is determined
421:42 - which of these will get called at
421:45 - runtime when the program is running
421:48 - let's see
421:53 - and this is working
421:58 - trade bound the infiltrate syntax works
422:01 - for straightforward cases but is
422:04 - actually syntax sugar for a longer form
422:07 - which is called a trade bound when
422:10 - working with generic type parameters
422:13 - often must use trades as bounds to
422:16 - stipulate what functionality a type
422:19 - implements
422:21 - so over here we are calling the sum
422:24 - function with two arguments
422:28 - in this case
422:29 - 2i32 arguments
422:32 - and as you can see we could also call
422:34 - this with floats because we have here
422:37 - defined
422:39 - t t generic type parameter
422:44 - so as you notice X and Y Must Be of the
422:47 - same type T and the type will be T which
422:51 - gets returned and all we do over here is
422:55 - adding X Plus y
422:58 - now again to use this plus operator here
423:02 - we must Define that t over here is a
423:05 - type that implements the add trade
423:10 - because remember this would actually
423:13 - translate to this
423:18 - so it's critical that X
423:21 - implements the add trait right
423:32 - and we also have to Define over here the
423:35 - associated type output to be of type t
423:40 - let's see
423:45 - this is compiling
423:47 - let's actually call the function
423:50 - [Applause]
423:51 - and print out the result
423:58 - [Applause]
424:02 - so as you can see the output would be
424:05 - 10.
424:06 - and we can call it with float right
424:16 - so let's see exercise 8 fix the errors
424:19 - as you can see we have a pair struct
424:22 - which has two Fields holding values of
424:26 - type t meaning they are generic
424:30 - and then we have an implementation block
424:33 - for repair and we Define here an
424:37 - Associated function and this is not a
424:40 - method because it doesn't have self as
424:43 - parameter
424:44 - now over here we are instantiating a new
424:48 - pair
424:49 - and remember self over here uppercase s
424:52 - refers to the type of the implementation
424:56 - block meaning pair
424:58 - and then we return this instance so if I
425:03 - write pair here it would be the same
425:05 - thing
425:08 - then over here we have another
425:10 - implementation block
425:12 - for the type pair
425:15 - and as you can see we Define here that t
425:18 - over here should implement the debug and
425:22 - partial order
425:24 - so the type T over here the type of the
425:28 - two fields
425:29 - the type of the two Fields must
425:32 - Implement debug and partial order
425:36 - then over here we are defining a method
425:39 - compare display which takes a reference
425:43 - to an instance of pair
425:46 - and then checking over here is the value
425:49 - of the X field bigger than or equal to
425:52 - the value of the Y field
425:54 - if that is the case then self dot X will
425:59 - get printed out using debug notation
426:02 - that is why we need
426:04 - T to implement the debug trade otherwise
426:09 - we print out the value of the Y field
426:13 - so as you can see over here we have a
426:16 - custom type unit that holds an i32
426:20 - integer
426:21 - now over here we are instantiating a
426:26 - pair struct
426:27 - and as you can see we are passing here
426:29 - as concrete values for X and Y Fields
426:33 - the unit type
426:36 - our custom type
426:42 - and over here it holds one and here
426:46 - three write an i32
426:50 - the type annotation for that would be
426:54 - we would have a pair instance
426:57 - and T over here would be unit right
427:05 - because X and Y hold a type of unit so T
427:10 - over here will be unit
427:15 - now remember we have over here an
427:19 - Associated function so let's actually
427:21 - use that to
427:24 - instantiate a pair
427:42 - as you can see this is exactly the same
427:45 - thing as this but here we are using the
427:49 - new Associated function that got
427:51 - implemented on the pair type
427:55 - so I can delete that
428:01 - and again when we call on this instance
428:04 - the compare display method then we would
428:07 - have an error because as for now
428:12 - doesn't implement the debug and partial
428:15 - order trades
428:17 - so we have to derive them
428:28 - and by the way we also need the partial
428:31 - EQ trait
428:32 - [Applause]
428:34 - and that's because we are here
428:37 - checking for equality all right so we
428:40 - knew so we need partial equality
428:45 - and because we have now derived these
428:48 - trades for this type it means unit
428:51 - implements debug partial order and
428:54 - partial EQ meaning we can over here
428:57 - compare for equality and ordering and we
429:02 - can print the field out using debug
429:06 - notation
429:08 - let's see
429:12 - and this is running so the largest
429:14 - member is y you will need two
429:18 - so we have here a pair with an X field
429:21 - of unit 1 and the Y field of unit 2.
429:26 - and then the compare display method will
429:29 - give us back you will need two right
429:32 - because the wife
429:34 - because the Y field holds a value that
429:36 - is bigger than the X field compare these
429:40 - two because this is a custom type is
429:42 - only possible because we have derived
429:45 - these trades
429:48 - alright see you in the next topic
429:52 - so before doing more exercises on trade
429:55 - objects I want to cover Associated types
429:58 - now an Associated type allows to specify
430:02 - a type that is associated with the trade
430:06 - when implementing the trade for a
430:08 - specific type we have to specify the
430:11 - concrete type
430:13 - it's basically a type placeholder that
430:16 - the trade methods can use in their
430:18 - signature
430:20 - and it's similar to generic types but
430:23 - they are more flexible because they
430:26 - allow a trade to have different
430:28 - Associated types for different
430:31 - implementing types
430:33 - let's see an example we have here the my
430:37 - trade and this has an Associated type
430:41 - called my type and as you can see we can
430:44 - then use this Associated type over here
430:48 - in the methods we are defining in the
430:52 - trade so we here for example Define that
430:56 - the return type should be of type my
431:00 - type
431:02 - meaning when we implement this trade
431:05 - over here for a concrete type like for
431:08 - example my struct then we have to define
431:11 - the concrete type as you can see when we
431:14 - implement the my trade for my struct we
431:17 - Define here that my type should be i32
431:21 - and as you can see this method over here
431:24 - will then return an i32 type and this is
431:29 - defined over here and we can access the
431:32 - associated type using self uppercase
431:36 - double colon and the name of the
431:39 - associated type
431:40 - now again self here stands for the type
431:43 - we are implementing this Trade four so
431:47 - in this case my struct
431:51 - all right let's do some more exercises
431:54 - practicing trade objects
431:57 - as you can see we have here a trade bird
432:00 - that has one method
432:03 - then we have here two custom types duck
432:06 - and Swan so let's see for duck we have
432:10 - an implementation block
432:12 - and here we Define a method
432:16 - and this method takes a reference to the
432:19 - instance and prints out something
432:23 - and for Swan we also Implement a method
432:27 - now notice this has nothing to do with
432:30 - the trade these are methods that are
432:33 - defined directly on the struct right so
432:39 - here we
432:41 - Define a method fly which again takes a
432:45 - reference to the instance and prints out
432:48 - something
432:49 - now over here we are implementing the
432:51 - birth trait for duck and Swan
432:55 - meaning we have to implement the method
432:58 - defined by the trade
433:03 - so as you can see this Quark method we
433:06 - have to implement for both types
433:10 - then over here we want to instantiate a
433:13 - duck
433:18 - so we then can call on this stack
433:21 - instance the swim method
433:23 - so this will then get executed
433:29 - then over here we call the hatch a bird
433:32 - function with an argument of two
433:37 - and over here we call the hatch a bird
433:39 - function again with an argument of one
433:43 - so as you can see when we provide two we
433:46 - want over here
433:48 - duck
433:49 - when we provide one we want over here a
433:53 - swan
433:54 - and I see that because of the output
433:57 - when calling the quack method
434:03 - so let's implement this function we have
434:07 - seen that the function takes as an
434:09 - argument and interfer so let's call the
434:12 - argument species
434:14 - and let's define it as u8
434:18 - now I will keep the return type open we
434:23 - will see that then
434:25 - so let's see when we get one let's
434:29 - actually match the species argument
434:33 - when we get back one
434:35 - we want to return
434:38 - a swan if we get here for the argument
434:42 - A2 we want to return a duck instance
434:46 - and because we have to handle all the
434:49 - cases I will just panic in case anything
434:52 - else has been passed
434:57 - so over here what would be the return
435:00 - type now think about it when calling
435:03 - this function over here
435:06 - we have to provide the
435:09 - return type
435:11 - now again the return type has to be of
435:16 - known fixed size at compile time
435:20 - now over here we don't know what we'll
435:24 - get actually return that compile time
435:26 - right especially if this argument over
435:30 - here would be something that is
435:33 - generated at runtime
435:36 - meaning we don't know the exact size
435:39 - because this one struct could be larger
435:42 - in size than the duck struct or
435:45 - otherwise
435:46 - so we have actually seen the solution we
435:50 - need to box
435:51 - the return type and
435:55 - V over here Define that it should be
435:59 - dynamically dispatched and that means we
436:02 - have to box these concrete values here
436:18 - and now we are good to go because also
436:21 - another problem would be that in a match
436:25 - every return type has to be of the same
436:28 - type now again over here the function
436:31 - could sometimes return a swan or
436:35 - sometimes a duck right depending on the
436:37 - argument
436:39 - and when we do it like that we actually
436:43 - return a type of box right so they have
436:47 - all the same return type now again
436:50 - because we are here using Dynamic
436:53 - dispatch we have to put it behind a kind
436:56 - of pointer
436:58 - and that means over here we will get
437:02 - a box
437:06 - holding a trade object
437:20 - and the trade object in this case is
437:23 - bird
437:25 - so that means and we have seen that the
437:27 - compiler will then
437:30 - allocate the concrete type for example
437:34 - over here a duck
437:36 - in the Heap memory and we'll create a v
437:39 - table with all the methods because when
437:43 - we call over here the Quark method on
437:45 - bird then at this exact point Dynamic
437:49 - dispatch happens
437:51 - because it is not known at compile time
437:55 - which
437:58 - concrete type got returned here this
438:01 - will be determined at runtime so at
438:05 - runtime the compiler will check the V
438:08 - table and see the right
438:12 - and will execute the right method call
438:16 - right in this case it would be for duck
438:21 - so the compiler will look this method up
438:25 - in the v table for the tag type which
438:29 - has been allocated in Heap memory and we
438:32 - got
438:33 - and notice something over here when we
438:37 - return a trade object the trade object
438:41 - actually only implements
438:45 - the methods from the trade in this case
438:50 - Bird right so we then can't call because
438:54 - we have here a trade object we can't
438:57 - call a method directly defined on the
439:01 - type so for example this swim method is
439:05 - not in the v table that the compiler
439:08 - creates
439:10 - I hope you see that because again we are
439:13 - returning a trade object meaning in the
439:16 - v table are only the methods from the
439:20 - trade
439:24 - so over here because we have
439:26 - created an instance on the concrete type
439:29 - we can call this three method but over
439:32 - here because we have a trade object we
439:36 - can only call methods from the trade
439:39 - let's see
439:43 - and as you can see this is compiling
439:48 - array with trade objects again we have
439:51 - the birth trait with the same method
439:54 - then we have duck and Swan and as you
439:58 - can see these are methods that are
440:01 - implemented directly on the concrete
440:03 - type
440:05 - then over here again implementing the
440:08 - birth trait for duck and so on we have
440:11 - seen that fill in the blank to make the
440:14 - code work so over here we want to have
440:17 - an array because we are here iterating
440:20 - over this Birds
440:22 - variable meaning we want to iterate
440:27 - over
440:28 - an array
440:30 - now let's first annotate
440:33 - we want over here an array of birds
440:37 - right
440:39 - so we want a type that implements the
440:43 - bird trade meaning in this case stock
440:45 - and Swan and this time I will use a
440:49 - reference instead of a box so we Define
440:52 - over here that we want an array
440:56 - holding
440:58 - a type that implements the birth trait
441:02 - and is dynamically dispatched all right
441:05 - and again because using Dynamic dispatch
441:08 - requires that we put it behind some kind
441:12 - of pointer either box or a reference
441:16 - now with this array let's say we want to
441:18 - have two elements one
441:20 - duck and one swan
441:23 - so let's provide here the instances
441:28 - and again we have to put that behind a
441:31 - pointer so the size is known
441:38 - so the size is known at compile time
441:40 - because remember the size of the
441:43 - elements in an array must be known at
441:46 - compile time in this case it would be
441:48 - you size
441:51 - the size of a pointer
441:54 - now then we want over here to iterate
441:57 - over these elements here
442:01 - and then as you can see for each element
442:04 - we are calling on it the Quark method
442:08 - now again because this over here is
442:11 - happening at runtime the Quark method
442:15 - will be determined at runtime which one
442:19 - to run here
442:21 - for stuck or for swan
442:25 - right
442:27 - let's see
442:31 - and this is compiling now overs and here
442:34 - we have the same thing bird.fly
442:38 - the method we have directly implemented
442:41 - on the type isn't available
442:45 - because in a trade object over here only
442:49 - the methods from the actual trade birth
442:52 - are in the v table other methods won't
442:56 - get into DV table and so the compiler
443:00 - cannot look it up at runtime
443:06 - referenced in and boxed in so we have
443:10 - here a trade draw which has one method
443:13 - and we implement the draw trade for u8
443:17 - and f64.
443:20 - as you can see we can Implement our own
443:23 - custom trades for types in the standard
443:27 - Library
443:29 - and all this does over here
443:31 - is it will take
443:33 - a reference of the instance and and it
443:37 - will output the value now in the newer
443:41 - version of rust we don't have 2D
443:43 - reference self here this is happening
443:46 - automatically
443:48 - like that and for f64 the same thing
443:53 - now as you can see we have here an f64
443:57 - and an u8
443:59 - basically the types that implement this
444:03 - draw trade
444:06 - then over here we are calling the
444:08 - function draw with box
444:11 - and as you can see this function over
444:15 - here expects a trade object of the draw
444:19 - trade and this trait object should be
444:23 - boxed all right and then it is calling
444:26 - the draw method again the compiler will
444:29 - then look in the v table and will
444:32 - execute the appropriate method at
444:35 - runtime
444:38 - so let's pass the argument for the draw
444:40 - with box function and in this case we
444:43 - want to draw X so let's pass it X
444:48 - and of course this has to be boxed right
444:53 - like this
444:55 - now over here we want to draw Y and this
444:59 - time we are passing a reference meaning
445:03 - we over here expect a reference
445:09 - to a trade object
445:11 - that implements the draw trade
445:15 - all right
445:17 - and then we are calling the draw method
445:20 - again this time on y
445:25 - let's see
445:28 - and this is compiling
445:37 - let's see exercise four we have a trade
445:41 - full which has one method then we
445:44 - Implement Foo for u8 and string types
445:49 - and as you can see we can Implement our
445:52 - own trades on types that are defined in
445:56 - this standard Library so in this case u8
445:58 - and string
446:01 - then over here in main we have
446:04 - a variable X holding a u8 and Y holding
446:08 - a string
446:11 - basically the types we are implementing
446:14 - for for right
446:18 - and let's see now the function called
446:22 - Static dispatch so we pass here X tu8
446:26 - type and this should be statically
446:30 - dispatched so let's implement this
446:33 - function Implement below with generics
446:36 - so we need here a generic
446:39 - type parameter and we Define here a
446:43 - trade bound meaning we want T to
446:46 - implement the foo trade
446:51 - right
446:52 - because we want the argument to be of
446:55 - type
446:56 - t
446:59 - so it's important that we Define here
447:03 - the trade bound because we call
447:07 - this function only with arguments that
447:11 - implement the full trade
447:14 - and we are defining that in order to be
447:18 - able to call the method
447:21 - method on it basically this method
447:24 - defined here right
447:27 - because then we can pass types of u8 and
447:30 - string to this function and it can call
447:34 - the method because the full trade is
447:38 - implemented for this type any other type
447:41 - that doesn't implement the full trade
447:44 - won't be allowed to be passed to this
447:47 - function
447:48 - so this is static dispatch because the
447:52 - compiler at compile time will actually
447:55 - expand this code and create a function
447:59 - for the concrete types so in this case
448:02 - we are passing u8 to this function so
448:06 - the compiler will create
448:10 - a function like this
448:22 - right and then we'll call it and this is
448:25 - happening at compile time meaning the
448:28 - compiler will fill in the concrete types
448:32 - over here
448:35 - and then of course the compiler will
448:38 - know when we do a method call which
448:41 - method over here it should call right
448:45 - and
448:47 - static dispatch is usually a lot faster
448:50 - than Dynamic dispatch because you don't
448:53 - have to do a lookup it's everything in
448:57 - the binary itself but when you have to
449:00 - do a lookup you have to follow a pointer
449:03 - to Heap memory and then get the data
449:06 - from this memory location which is more
449:09 - expensive
449:11 - so let's see Dynamic dispatch in this
449:15 - case
449:16 - and we use Dynamic dispatch because
449:21 - sometimes it's just not possible to use
449:24 - static dispatch right when the size of
449:28 - the returned type it cannot be known at
449:32 - compile time then we use Dynamic
449:35 - dispatch
449:37 - and let's see how that looks like so
449:40 - over here
449:41 - we are passing a reference to Y so we
449:45 - are passing here
449:49 - a reference to a string
449:53 - now as an argument over here we want a
449:58 - reference right that's what we are
450:00 - passing
450:02 - to a trade object
450:06 - implementing the full trade all right
450:11 - and again because this is dynamic
450:13 - dispatch so this happens at runtime
450:16 - must be behind a pointer so this size is
450:21 - known at compile time
450:23 - because it pointer is always of size U
450:27 - size we have covered that
450:29 - and then we call the method on the
450:33 - argument right
450:35 - the difference is that over here this
450:38 - will then be determined at runtime which
450:43 - method over here to be called right
450:47 - because the compiler will then do a
450:50 - lookup in the v table at runtime and
450:54 - then determine for which type the method
450:57 - should be called
451:00 - let's see
451:04 - this is compiling
451:07 - object safe you can only make object
451:10 - safe trades into trade objects a trade
451:14 - is object safe if all the methods
451:16 - defined in the trade have the following
451:19 - properties the return type isn't self
451:22 - and there are no generic type parameters
451:26 - so let's see exercise 5 use at least two
451:30 - approaches to make it work don't add
451:33 - remove any code line
451:35 - so
451:37 - I think we will go first with static
451:40 - dispatch because it's easier
451:42 - so I will remove this box here
451:51 - and let's see we have a trade here
451:54 - defining one method
451:57 - now this defines that it takes a
452:00 - reference to a self
452:02 - meaning a reference to an instance of my
452:06 - trait and it returns self their self
452:10 - over here refers to the type for which
452:13 - the nitrate is implemented so in this
452:16 - case for example over here my trade is
452:20 - implemented for u32 meaning we implement
452:24 - this method over here
452:26 - and self over here would refer to u32
452:31 - right we can write it either way
452:36 - and
452:38 - u32 and string Implement my trade all
452:42 - right so they both implement the F
452:45 - method
452:46 - then over here we have a function that
452:50 - takes a trade object now in this case
452:53 - you want to use static dispatch so we
452:56 - Define here
452:58 - a generic type
453:00 - right because we are calling it with new
453:03 - 32 and a string
453:05 - now we want to ensure that t this type
453:10 - implements my trade so we can be sure
453:14 - that it implements this F method
453:21 - so this is called trade bound and this
453:24 - makes sure that t implements my trade
453:28 - so we then can call the F method on the
453:33 - provided argument here which is of type
453:35 - t
453:37 - and
453:39 - that's basically it we have implemented
453:42 - the static dispatch for this function
453:45 - over here
453:46 - and what then will happen is
453:50 - when we call this function the
453:53 - roscompiler
453:55 - will take this generic function here and
453:58 - it will provide it with concrete types
454:06 - and it will provide it with concrete
454:09 - types so in this case u32 right we are
454:12 - passing it to 32.
454:14 - and
454:16 - we have we forgot to define the return
454:19 - type so the return type over here would
454:22 - be the return type of the F method
454:26 - now in this case it would be
454:29 - T type right
454:32 - so if we are calling it
454:36 - so if we are calling the F method on a
454:39 - new 32 then the return type will be u32
454:42 - in if we call it on a string then the
454:46 - return type will be string so again we
454:48 - pass here T right
454:52 - because the type we are passing for
454:55 - example u32 will be the return type of
454:59 - this function u32 and that in case means
455:03 - that the return type of this function
455:07 - over here will be
455:09 - u32 right
455:13 - okay
455:14 - and then the same thing happens for a
455:17 - string
455:18 - so the compiler will actually
455:21 - put into these generic type parameters
455:25 - concrete types
455:29 - and that means when we are using static
455:31 - dispatch these method calls here are
455:35 - known at compile time so the compiler
455:37 - knows if you're passing a u32 type then
455:42 - it will call the F method from the eu32
455:46 - implementation of my trade right and in
455:49 - case of string then the compiler will
455:52 - know that the F method can be found in
455:56 - the
455:57 - my trade implementation of string right
456:01 - so everything here is known at compile
456:06 - time and also the size is fixed
456:12 - and this is working
456:14 - now
456:15 - we want here
456:17 - to now use Dynamic dispatch so we solve
456:20 - it in two approaches
456:23 - so before we can even use this straight
456:26 - object over here we have to make the
456:29 - trade itself object safe and we do that
456:33 - when the return type isn't self and
456:36 - there are no generic type parameters so
456:40 - we cannot Define here self we have to
456:44 - provide it concrete types now in this
456:47 - case we want
456:49 - the F method to return a trade object
456:54 - meaning
456:59 - we return a pointer
457:02 - that points to the type that implements
457:05 - my trade all right
457:09 - and over here
457:11 - because we are taking here this function
457:13 - signature and implement it for each type
457:18 - we Implement in my trade for so as you
457:21 - can see the return type must
457:24 - implement the my trade
457:28 - and it has to be boxed so we have to box
457:31 - this over here
457:36 - turn over here A U 32 right
457:41 - which implements the my trade and over
457:45 - here a string
457:47 - [Applause]
457:51 - which also implements my trade
457:55 - so as you can see we got rid of self
457:59 - because again
458:02 - at compile time the return type size has
458:06 - to be known
458:08 - that's why we are putting it behind a
458:12 - box
458:13 - now
458:15 - again the return type of this function
458:19 - would be the return type of Team method
458:22 - calls in this case it would be a boxed
458:26 - trait object
458:28 - right
458:30 - let's see if this is compiling
458:33 - and this is also compiling
458:36 - now I hope you see the difference here
458:39 - when we pass here a trade object
458:44 - basically a type in this case u32 that
458:48 - implements the my trade trade
458:51 - then this method call will be determined
458:55 - at runtime
458:57 - and that's why we have to put this
459:01 - behind pointers so the size remains
459:05 - fixed and known at compiled time
459:11 - and again use whenever possible static
459:14 - dispatch because it's faster and I guess
459:17 - easier to write but Dynamic dispatch has
459:20 - its advantages and you can use it for
459:24 - more flexibility in your code
459:28 - alright see you in the next topic
459:33 - so we have reached the topic of
459:35 - collection types and string is also a
459:38 - collection type meaning we are just
459:40 - repeating because we have covered
459:43 - strings but I think these exercises are
459:47 - good for some repetitions
459:49 - so string is a utf-8 encoded growable
459:53 - string it is the most common string type
459:55 - we used in Daily development it also has
459:58 - ownership over the string contents
460:02 - so let's see fill in the blanks and fix
460:05 - arrows don't use to string don't add
460:07 - remove any code line
460:10 - so as you can see over here we want a
460:13 - string type because we because we are
460:16 - here modifying the swing meaning it has
460:19 - to be growable
460:20 - so let's
460:22 - allocate this data over here on the heat
460:29 - so we have now a string type we can
460:33 - now let's see the poster method
460:38 - as you can see this push stir method is
460:41 - implemented on the string type and it
460:46 - takes as a type for its argument a
460:49 - string literal
460:51 - as you can see we are calling it on a
460:54 - string and providing it an argument of a
460:58 - string literal
461:00 - so we have to delete that because this
461:04 - would actually be a string right
461:07 - we want here a string literal
461:11 - like that
461:13 - and push is for pushing single
461:16 - characters so we want to push here an
461:19 - exclamation mark So s will then here
461:23 - match with this string literal
461:26 - and as you can see we are calling the
461:29 - move ownership function here meaning
461:32 - this function will then take ownership
461:34 - of s and that's not what we want because
461:37 - we are using here as again so what we
461:40 - can do is just clone it
461:43 - so the data passed to move ownership
461:46 - over here is actually cloned
461:50 - right it is copied on the Heap memory
461:54 - and that means we can still use S
461:58 - because s Remains the owner of this data
462:09 - all right
462:11 - then a string is stored as a vector of
462:14 - bytes but guaranteed to always be a
462:17 - valid utf-8 sequence
462:20 - string is Heap allocated growable and
462:23 - not null terminated a string slice is a
462:27 - slice
462:28 - basically a slice to u8
462:31 - integers because as you can see
462:35 - this string type is a vector of u8 inter
462:38 - source
462:40 - that always points to a valid utf-8
462:43 - sequence and can be used to view into a
462:46 - string just like a slice to T is a view
462:50 - into Vector T and we'll cover vectors
462:55 - after this topic
462:58 - so fill in the blanks
463:00 - we have here a string
463:03 - and we want to take a string slice from
463:07 - this string now the easiest method would
463:09 - be just to take a reference to s
463:12 - which means we take a reference to a
463:15 - string type
463:17 - and this can then be inferred by the
463:20 - compiler to a string slice
463:24 - and the second way would be to call the
463:27 - askster method on it
463:30 - this will essentially do exactly the
463:32 - same thing it will take the string s and
463:36 - we'll convert it to a string slice
463:40 - now over here we also want a string
463:43 - slice
463:45 - but we want to provide a specific offset
463:48 - we just want this data over here
463:52 - and that means we take a reference to s
463:56 - and provide it here an offset from zero
463:59 - we can omit the zero on here
464:02 - until index 0 1 2 3 4
464:08 - until index four now we would provide
464:11 - here 5 because 5 is excluded meaning we
464:16 - go from index 0 to 4.
464:22 - and over here as you can see we want to
464:26 - modify the string holding then hello
464:30 - world because we are pushing to it this
464:33 - exclamation mark as you can see we want
464:36 - it hello world and with an exclamation
464:39 - mark
464:40 - so what we can do is taking
464:43 - s over here s mutable reference
464:50 - so this would then hold a mutual
464:53 - reference to a string
464:56 - let's see
464:58 - and this is compiling now notice over
465:01 - here we could also take ownership of s
465:05 - meaning slice 3 will hold a string
465:09 - because we are not using S after this
465:12 - point so slice 3 can be the owner of s
465:17 - but in this case we have to make the
465:19 - variable mutable
465:23 - and this is also working
465:26 - question how many Heap allocations are
465:29 - happening here so we have here a string
465:33 - and
465:34 - when we create a string type then the
465:40 - data that is provided is allocated in
465:43 - Heap memory
465:45 - so this would be the first allocation
465:48 - then over here we are taking from this
465:52 - string over here a reference meaning a
465:55 - string slice and remember a string size
465:59 - is just a view into some data so we are
466:03 - just going to this location and checking
466:06 - what's in there
466:07 - so no allocation is happening
466:12 - and over here we are taking this string
466:15 - slice and convert it to a string meaning
466:19 - a heap allocation is happening over here
466:24 - right because we are taking this string
466:27 - slice
466:32 - [Applause]
466:33 - holding this
466:36 - and then we allocate this
466:39 - into the Heap once more being because we
466:43 - are calling this two string method
466:50 - let's see indexing
466:53 - so we have a string here
466:56 - and we want to index into the first
466:59 - element so slice one should then hold h
467:03 - so we want a string slice
467:07 - so we take a reference to S and provided
467:10 - the offset from 0 to 1.
467:14 - 1 is excluded meaning we just take the
467:17 - first character
467:19 - and that is because H only takes one
467:23 - byte in utf-8 format so
467:27 - ASCII characters in strings usually take
467:30 - one byte while this Unicode characters
467:34 - over here take three bytes so when we
467:38 - take a string slice here
467:41 - we want to access this character
467:45 - now for that we have to provide the
467:48 - right offset so we go from 0 1 2 3 4 5 6
467:55 - 7.
467:56 - starting at index seven and as you can
467:59 - see these Unicode characters hold three
468:03 - bytes meaning
468:04 - we must provide here an offset of 10. 10
468:09 - is excluded meaning we go from 7 8 9.
468:14 - three bytes iterate through all Source
468:17 - in s
468:19 - so to iterate over characters in a
468:23 - string type we use Stitch Source method
468:28 - but that will actually just return the
468:32 - Char we are iterating over but as you
468:35 - can see we want here as return type a
468:38 - tuple which holds the index and the
468:42 - actual character so we can use here to
468:45 - enumerate method
468:48 - and enumerate will return a tuple with
468:52 - the index and the specific character so
468:56 - in the first iteration you would have
468:58 - zero and H right the index and the
469:02 - character
469:04 - so here we are checking if the index
469:06 - over here is 7 then the variable C
469:09 - should hold this character
469:12 - right
469:14 - let's see
469:16 - and this is compiling
469:20 - now there is a crate called utf-8 slice
469:23 - you can import it into your project and
469:27 - this then allows you to slice into a
469:30 - string
469:31 - not using bytes as offsets but just
469:35 - indexing into the individual characters
469:38 - so over here we provide an offset from
469:42 - four to five meaning we want the
469:45 - character at index 4.
469:49 - so we don't have to worry about the byte
469:52 - size of this symbol
469:56 - then fill in the blanks we have here a
469:59 - string
470:00 - now we have seen that a string is
470:03 - actually a vector holding u8 intervals
470:07 - and as you can see we have here some
470:10 - bytes in a vector so this Vector holds
470:14 - u8 inters right
470:17 - and that means these are bytes that can
470:20 - be converted to ASCII characters
470:24 - so in this case these over here will
470:27 - translate to hello
470:29 - all right
470:30 - if you look up this code over here in
470:34 - the ASCII table then we will find that
470:37 - this is represented for the character
470:40 - age
470:41 - and this e l l o
470:46 - so we want to turn a bytes Vector like
470:49 - this into a string so we want to be
470:52 - string here
470:54 - so let's see this method here
470:57 - so in the documentation you can see that
470:59 - the string type implements a method from
471:02 - utf-8
471:05 - and this just takes a vector of bytes
471:10 - and then we can call this Associated
471:13 - function on the string type and provide
471:16 - it as an argument a vector of bytes
471:21 - and this will then convert it to a
471:24 - string so we can try it out
471:27 - so first of all we want to actually
471:29 - mutate the string here to hold the same
471:32 - data as this Vector holds namely hello
471:36 - so we can do that by using poster
471:42 - and we push hello meaning this string
471:45 - then holds hello
471:55 - and
471:56 - then we can take this string type and
472:00 - call from utf-8 method providing it this
472:05 - vector
472:07 - and this should then convert this Vector
472:11 - of bytes into an actual string meaning s
472:15 - and S1 will then hold the same value
472:19 - namely a string hello
472:30 - and of course this actually
472:32 - and this returns a result so we have to
472:36 - unwrap it
472:40 - and as you can see this is compiling
472:45 - so in fact a string is just a vector of
472:50 - bytes right
472:54 - and we'll cover vectors very soon and
472:57 - you will then see how this is actually
473:00 - stored in memory
473:04 - so a string is made up of three
473:07 - components a pointer to some bytes a
473:10 - length and a capacity the pointer points
473:13 - to an internal buffer string uses to
473:16 - store its data the length is the number
473:19 - of bytes currently stored in the buffer
473:22 - always stored on the Heap and the
473:25 - capacity is the size of the buffer in
473:28 - bytes as such the length will always be
473:31 - less than or equal to the capacity
473:36 - we have seen that the string type is a
473:39 - three bird object holding a pointer to
473:42 - the actual data stored in Heap memory
473:45 - the length which shows the length of the
473:48 - string in this case 5 and the capacity
473:51 - and the capacity as you can see here is
473:55 - the total amount of memory received from
473:58 - the allocator
473:59 - so when we allocate a new string type on
474:03 - the Heap the allocator we will find an
474:06 - empty spot and then we'll return a
474:10 - pointer to that location
474:15 - number six if a string has enough
474:17 - capacity adding elements to it will not
474:20 - really allocate
474:22 - so
474:24 - when we run this program over here
474:27 - then we see the capacity of string s
474:35 - now over here we are initializing an
474:39 - empty string
474:41 - meaning we have an empty string so
474:45 - nothing gets allocated to Heap memory we
474:49 - still have a string object but with a
474:53 - length of zero and a capacity of zero
474:58 - then we print it out as you can see Zero
475:02 - over here we are iterating two times
475:05 - modifying this string so in the first
475:07 - iteration s will then hold
475:11 - hello
475:12 - so it would have a length of five but
475:16 - when we print out the capacity it will
475:19 - show 8. so we have a string object that
475:23 - points to this data with a length of 5
475:27 - and a capacity of 8. now this is the
475:31 - default behavior when we don't specify a
475:35 - capacity ourself so
475:39 - when the length exceeds the capacity
475:43 - then rust has to reallocate the data
475:48 - meaning it has to find a new spot in
475:51 - Heap memory that is big enough to hold
475:54 - the data and then we'll return a pointer
475:58 - to the new location so in this case
476:01 - because we have modified the string the
476:04 - length 5 exceeds the capacity zero so it
476:09 - has to reallocate because remember in
476:12 - Heap memory
476:13 - the data is allocated as contiguous
476:18 - block of bytes all right
476:21 - and the default behavior is that the
476:24 - capacity will always double so it starts
476:28 - from 1 then 2 4 8 16 and so on and
476:32 - that's the reason we have here a
476:35 - capacity of 8 even though we only need
476:38 - five right this is a length this is a
476:41 - string of length five but because of the
476:45 - default behavior of the allocator we
476:48 - will get back a capacity of 8. and then
476:52 - in the second iteration we again push
476:55 - hello
476:57 - right so we would have a length of 10
477:01 - but as you can see the capacity doubles
477:04 - so 10 exceeds the length of 8 meaning
477:09 - the allocator will then find a new spot
477:12 - in hit memory to allocate
477:16 - this string over here of length 10. and
477:20 - it will then
477:21 - Reserve 16 bytes of memory in Heap
477:26 - memory and so on if we then exceed 16
477:29 - bytes then it will allocate to a
477:32 - location which holds 32 right it always
477:35 - doubles
477:37 - and this is when you let rust allocate
477:41 - so this is the default Behavior but as
477:44 - you can see this might be expensive so
477:47 - if you
477:48 - start with a capacity of zero and then
477:52 - you modify the string multiple times it
477:55 - means rust has to reallocate your
477:58 - daytime
477:59 - and that means it could potentially be
478:02 - expensive when you mutate this over here
478:05 - multiple times and a lot of
478:07 - reallocations are happening so there is
478:10 - a function called with capacity
478:15 - and then we can Define over here that we
478:18 - want an empty string meaning the string
478:21 - length is zero but we want a capacity of
478:25 - 25 meaning s
478:29 - is allocated in Heap memory and
478:33 - there is enough space reserved for this
478:37 - data
478:39 - to hold 25 elements right so when we do
478:44 - that again
478:47 - then as you can see
478:50 - no reallocation has happened we have
478:54 - only allocated the string one time in
478:56 - heat memory with a capacity of 25.
479:01 - now because the length doesn't exceed
479:04 - the capacity in any of this modification
479:07 - of the string it means that there is no
479:11 - need to re-allocate the data right so
479:15 - when we print out
479:22 - swing s over here in the end
479:27 - then as you can see this is the
479:31 - string that in the end hello
479:34 - hello so we have here 10 elements
479:37 - meaning
479:39 - there is no need for reallocation
479:42 - because a capacity of 25 can hold
479:46 - the string of this size and this can
479:49 - make your program a lot faster
479:52 - so let's see vectors a vector is like an
479:55 - array but dynamically sized meaning they
479:58 - can grow and Shrink it's allocated on
480:02 - the Heap as contiguous block of memory
480:05 - all elements in a vector have to have
480:08 - the same type and there is a special
480:11 - macro vac which you can use to
480:14 - initialize a new vector
480:17 - so all this time we've been dealing with
480:19 - an imposter so in actuality this string
480:22 - type is just a vector of utf-8 bytes
480:27 - that gets allocated in Heap memory
480:31 - so as you can see when we have the S1
480:34 - variable over here then again S1 won't
480:38 - hold the actual data but a pointer to
480:41 - the data allocated in Heap memory
480:44 - alongside a length and a capacity
480:47 - meaning S1 is a three word object of
480:52 - size 24 bytes
480:55 - now
480:58 - as you can see this would be a vector
481:01 - allocated in Heap memory that holds the
481:05 - utf-8
481:07 - bytes over here of course in memory this
481:11 - would be in binary but as you can see
481:14 - this then holds the
481:19 - character code for this character inside
481:22 - the string
481:25 - so let's do some exercises vectors or
481:29 - resizable arrays like slices their size
481:32 - is not known at compiled time but they
481:35 - can grow or Shrink at any time
481:38 - so over here we have a normal array
481:41 - holding three u8 elements
481:46 - now we can convert this array to a
481:50 - vector using the from Associated
481:52 - function and then passing it the array
481:55 - meaning we will then hold a vector
482:01 - of u8 elements and here you can see the
482:05 - difference between an array and a vector
482:08 - we don't provide here the length of the
482:11 - vector because the vector can actually
482:14 - grow or Shrink meaning it's dynamic in
482:18 - its size
482:20 - now the isvac function basically just
482:23 - checks if the provided argument is a
482:26 - vector
482:29 - then as you can see we are shadowing V
482:32 - and we are here initializing it with a
482:37 - vector of these elements so as you can
482:40 - see you can use the VAC macro to quickly
482:43 - create a new Vector like that
482:49 - so this will then hold a vector of u8
482:52 - elements
482:53 - and by the way you can either use square
482:56 - brackets or you can use parentheses it's
482:59 - both exactly the same
483:05 - now as you can see here we are
483:08 - initializing V or basically shadowing it
483:12 - and then we are passing it to is back
483:15 - meaning ownership would be transferred
483:18 - but we are using V here again so let's
483:21 - clone this
483:25 - and over here as you can see we are
483:28 - initializing V1 with Divac macro now we
483:33 - are passing to the back macro the array
483:37 - Mac macro over here won't convert it
483:41 - directly to a vector like this from
483:45 - Associated function did instead we would
483:48 - here have a vector
483:50 - holding
483:52 - this array all right
484:01 - I hope you can see the difference
484:04 - here we have a vector of u8 elements
484:07 - over here we have a vector holding an
484:11 - array of three u8 elements
484:14 - so
484:16 - when we compare over here V and V1 they
484:20 - won't actually be the same right
484:25 - and again let's do clone here
484:28 - just so we can then reuse B1
484:32 - now what we can do over here to fix that
484:35 - is using the VAC new
484:39 - like that
484:41 - and back new basically will then create
484:46 - a new empty Vector meaning it would be
484:49 - an object with length of 0 and capacity
484:53 - of zero
484:55 - now over here we want to iterate over
484:59 - the elements in v
485:06 - let's take a reference here because we
485:09 - are using V again and we don't want this
485:12 - for Loop to take ownership
485:14 - now all we want to do is pushing all the
485:18 - elements from we into V1
485:27 - and because we are here iterating over
485:30 - references of elements we have to
485:33 - de-reference it and by the way we will
485:35 - take a look at that in much greater
485:38 - detail
485:39 - so what we also have to do is making
485:42 - this V1 variable mutable because when
485:46 - pushing to it it has to be mutable
485:50 - alright let's see
485:55 - and this is compiling so in the end V1
485:59 - will hold a vector
486:01 - of U 8 elements meaning V and V1 are
486:07 - exactly the same
486:09 - but remember when you have an array use
486:13 - the from Associated function and not the
486:16 - VAC macro because it won't convert it
486:19 - directly to a vector instead it will
486:22 - create a vector holding an array
486:27 - Evac can be extended with extend method
486:31 - so over here we have a vector
486:34 - let's say these are i-32 values
486:39 - and as you can see we can pop meaning
486:43 - removing the last element so over here
486:50 - the vector will then hold 1 and 2
486:53 - because the last element got popped then
486:56 - we are pushing to it 3.
487:02 - meaning we have a vector holding one two
487:06 - three
487:08 - now over here again we are initializing
487:11 - an empty vector
487:14 - now as you can see we want V1 and V2 to
487:19 - be exactly the same
487:21 - so what we can do is using the extent
487:24 - method
487:26 - and providing it the V1 vector
487:31 - meaning the elements
487:38 - foreign
487:42 - and we have to pass here a reference
487:44 - meaning the elements then from V1 will
487:48 - be
487:49 - put into V2 so again V2 will then be a
487:53 - vector of I 32 elements and they hold
487:57 - exactly the same data right
488:00 - it's basically copying the contents of a
488:05 - vector into another vector
488:09 - turn X into back fill in the blanks
488:13 - so over here we have an array
488:18 - and this array holds i32
488:22 - types and the size of the array would be
488:25 - 3.
488:26 - then as we've seen we can use the from
488:29 - Associated function
488:33 - so we create a vector from this array
488:37 - meaning V1 will then hold a vector of
488:41 - i32
488:43 - types
488:45 - or what we also could do is calling the
488:48 - into method and if a type implements
488:52 - from then it will Implement into and we
488:56 - will take a look at that
488:58 - so we then take this array over here and
489:01 - convert it into a vector of i32
489:06 - values right so that means V1 and V2
489:11 - will be exactly the same
489:15 - now converting a string into a vector
489:21 - so the from trade over here
489:24 - is actually implemented for the vector
489:28 - type so over here we have a string
489:31 - and remember basically a string is a
489:35 - vector of u8 elements
489:38 - and then again we can call here into
489:41 - right converting s
489:44 - into a vector of u8 elements
489:49 - and then over here we have again a
489:51 - string and we call the method in two
489:54 - bytes meaning
489:56 - V2 holds a vector of utf-8 bytes
490:01 - represented as u8
490:04 - and this is actually exactly the same so
490:07 - meaning V1 and V2 will be identical
490:13 - then over here we have a string
490:16 - literally
490:18 - and we want to create a vector from this
490:22 - variable meaning we again use the from
490:25 - Associated function and provide it as an
490:28 - argument over here meaning B3 will then
490:32 - hold a vector of u8 types right
490:37 - so V2 over here and V3 are identical
490:44 - iterators can be collected in two
490:47 - vectors
490:48 - so when we have here an array of 10
490:50 - elements of value 0 and we put it into
490:54 - an iterator we can then collect it into
490:58 - a vector all right and we will see these
491:01 - methods over here in Twitter and collect
491:05 - in much greater detail meaning V4 will
491:09 - then hold a vector
491:12 - and of 10 times 0.
491:21 - like that all right let's see
491:29 - and this is compiling
491:33 - fix the error and implement the code so
491:36 - let's see over here we have an array
491:39 - and we convert this array into a vector
491:43 - using the from Associated function we
491:47 - have seen
491:48 - so this will then hold a vector of I 32
491:51 - types all right
491:55 - now then we are iterating here five
491:58 - times
492:00 - and
492:02 - just print out each element at the
492:06 - specific index
492:08 - here we have to implement some code and
492:11 - actually V in the end should hold a
492:15 - vector with these elements
492:18 - so as you can see
492:21 - we have we are starting with a vector
492:24 - holding one two three and we end with a
492:28 - vector 2 3 4 5 6.
492:32 - now what we want to achieve here is we
492:35 - are adding one to each element
492:38 - then we would have 2 3 and 4.
492:42 - now
492:43 - if we exceed the boundary over here then
492:47 - we want actually to add the new element
492:50 - over here
492:52 - now
492:54 - let's see first in the for Loop here
492:58 - this would actually panic because we are
493:01 - trying to access indexes that are out of
493:05 - bounds so over here we are iterating
493:08 - from 0 to 4 right 5 excluded but we have
493:13 - only three elements meaning meaning
493:16 - indexes 0 to 2.
493:19 - now we can here you stick get method
493:23 - and we have seen this get method before
493:26 - and and this is generally safer because
493:29 - it will return an option
493:33 - [Applause]
493:35 - in this case option i32 because we are
493:38 - dealing with i32 types here
493:42 - and what we then can do over here
493:46 - we want to actually manipulate this
493:49 - Vector so let's first access the
493:52 - elements
493:58 - and as you can see again I use the get
494:01 - method because we want to actually see
494:05 - if
494:08 - the index is out of bounds or not so in
494:12 - case it's not out of bounds we would
494:14 - return a sum right the get method will
494:17 - return a sum
494:20 - and the actual value at that specific
494:23 - index
494:25 - so if we found an element at the
494:28 - specific index over here then we want
494:33 - to access the element and just add to it
494:36 - one right
494:39 - we are then taking the element over here
494:42 - let's see for example in the first
494:44 - iteration I will be zero then we pass 0
494:49 - to this get method meaning we will get
494:53 - back some 1 right so we'll get back some
494:57 - 1 meaning
494:59 - e over here will then hold a value of 1.
495:03 - then we access
495:06 - this array at index 0 right and what we
495:11 - want then to do is taking 1 E over here
495:15 - and add to it one meaning then
495:19 - the first element in this Vector has
495:22 - been modified to then hold two
495:26 - now in the second iteration to do it
495:29 - would be exactly the same thing so I
495:31 - would be 1 we get over here
495:35 - the element at index one and E will then
495:39 - hold two and then over here V at index 1
495:45 - should then hold two plus one right and
495:50 - we assign it meaning
495:54 - in the modified vector the second
495:57 - element will then hold three
496:00 - now we do that again and after we are
496:04 - out of boundaries meaning we return a
496:07 - non here
496:09 - and then we want to push to the vector
496:12 - the index plus two right
496:16 - so for example in the third iteration I
496:20 - would be three right this would be out
496:23 - of bounds there is no index 3 here so we
496:26 - get back a non
496:29 - and then over here we push to V the
496:34 - index in this case 3 plus 2 meaning we
496:39 - then get back 5 right
496:42 - and let's see if this is actually
496:44 - working
496:52 - all right and let's remove this type
496:54 - annotation because this would be of Type
496:57 - U size because of the get method
497:01 - now as you can see
497:03 - when we print out here the output of the
497:07 - get method we would get someone sum two
497:11 - and some three and then two times none
497:14 - because at iteration 3 and 4 we would
497:18 - get back none because there is no
497:21 - element in this index
497:26 - and we are succeeding here because again
497:29 - we have three times sum here and when we
497:32 - have a sum we just add 1 to the value
497:36 - meaning we then have 2 3 and 4.
497:40 - and then we will get back two times none
497:44 - meaning we take the index and
497:48 - increment it by two pushing it to the
497:51 - vector so we get five and six
497:57 - slicing a vac can be mutable on the
498:01 - other hand slices are read only objects
498:04 - to get a slice use reference in Rust
498:07 - it's more common to pass slices as
498:10 - arguments rather than vectors when you
498:13 - just want to provide read access the
498:15 - same goes for string and string slices
498:19 - so over here we have a vector
498:25 - let's say i32
498:28 - then we are taking a slice from V over
498:32 - here
498:33 - meaning this would then be a slice of
498:37 - i32 elements right
498:42 - and this would be the offset meaning we
498:44 - would take from the first element to the
498:48 - last element
498:49 - out of bounds will cause a panic you
498:53 - must use the length here so as you can
498:56 - see again we are taking a string slice
499:00 - foreign
499:01 - but we are here out of bounds right
499:04 - because
499:05 - this would iterate from 0 to 3 for
499:08 - excluded and we have here only zero one
499:13 - two indexes
499:15 - so what we can do is using B dot length
499:18 - meaning we just iterate
499:21 - meaning we provide an offset from zero
499:24 - the first element to V length where the
499:28 - length here is excluded meaning vlanth
499:32 - minus one all right
499:36 - slices or read only node slice and
499:40 - reference to back are different
499:43 - so as you can see we take here immutable
499:46 - reference to a vector
499:48 - and then we can push to this Vector over
499:52 - here
499:54 - the value 4.
499:56 - now we have seen that slices are
499:59 - immutable they are just a view into some
500:02 - data so we can't use a slice to mutate
500:07 - the vector right
500:10 - so over here we want to have a slice
500:15 - of i32 elements right
500:18 - like that and we can remove the mute
500:22 - keyword over here because again we can't
500:24 - modify slices so we have pushed to it
500:28 - for meaning when we take the slice we
500:31 - want to take also this last pushed
500:34 - element right
500:38 - and this is compiling
500:42 - capacity the capacity of a vector is the
500:45 - amount of space allocated for any future
500:47 - elements that will be added onto the
500:50 - vector this is not to be confused with
500:53 - the length of a vector which specifies
500:55 - the number of actual elements within the
500:58 - vector if a vector's length exceeds its
501:02 - capacity its capacity will automatically
501:04 - be increased but its elements will have
501:07 - to be reallocated for example a vector
501:10 - with with capacity 10 and length 0 would
501:14 - be an empty Vector with space for 10
501:17 - more elements pushing 10 or fewer
501:20 - elements onto the vector will not change
501:23 - its capacity or cause reallocation to
501:26 - occur however
501:28 - however if the vector's length is
501:31 - increased to 11 it will have to
501:34 - reallocate which can be slow for this
501:37 - reason it is recommended to use the
501:39 - width capacity function whenever
501:41 - possible to specify how big the vector
501:44 - is expected to get
501:47 - and this we have already covered with
501:50 - strings but now let's see with vectors
501:54 - so over here as you can see we are
501:57 - initializing an empty Vector but with a
502:01 - capacity of 10 so this object here would
502:04 - hold length of 0 and capacity of 10
502:08 - meaning the actual elements inside
502:11 - Vector are zero there are no elements
502:15 - but
502:16 - in Heap memory there were 10 locations
502:20 - allocated for this data right
502:25 - the vector contains no items even though
502:28 - it has a capacity for more so when we
502:32 - call the length method over here we
502:34 - would get back zero right because back
502:38 - doesn't hold any values but it has a
502:42 - capacity of 10 because we have defined
502:45 - that over here
502:48 - these are all done without reallocating
502:51 - so we are then pushing 10 times to the
502:55 - vector right
502:57 - now this means
502:59 - back here holds enough space that this
503:04 - is happening without re-allocating the
503:08 - vector right
503:10 - so after pushing to the vector T Vector
503:13 - with would be of length 10. and capacity
503:18 - 10. right
503:20 - so the length must never exceed the
503:24 - capacity otherwise a re-allocation is
503:27 - happening
503:28 - as we can see here but this may make the
503:32 - vector reallocate so we are pushing
503:35 - another element to the vector meaning
503:38 - the length will be 11. this would exceed
503:42 - the capacity meaning then
503:46 - this whole Vector will be reallocated in
503:50 - Heap memory so when we have a length of
503:54 - 11 then the capacity will be at least 11
503:57 - but it can be more because we have seen
504:00 - that the default behavior when
504:03 - reallocating is that the capacity
504:06 - doubles
504:08 - feeling an appropriate value to make the
504:11 - four done without reallocating
504:14 - so as you can see we have here a vector
504:17 - we want to initialize with a certain
504:20 - capacity then we are pushing 100 times
504:24 - to this vector meaning the length here
504:27 - will be 100 so what we want to do is we
504:31 - want here to initialize a vector with a
504:35 - capacity of 100 meaning we can push 100
504:39 - times without this Vector to be
504:43 - reallocated in Heap memory
504:53 - store distinct types in Vector the
504:56 - elements in a vector must be the same
504:58 - type for example the code below will
505:00 - cause an error
505:02 - so we have here integers and a float
505:06 - this would cause an error because again
505:08 - all of them have to be of the same type
505:12 - but we can use enums or trade objects to
505:16 - store distinct types so over here we
505:20 - again see the IP address enum we have
505:23 - seen before in the examples
505:27 - now fill in the blank we want over here
505:29 - a vector that holds IP addresses
505:34 - meaning at index 0 we want this variant
505:39 - here and at index 1 we want this variant
505:43 - now we can use the back Macro for that
505:51 - and then over here I just copy
505:54 - this
505:56 - variant
505:59 - and
506:00 - this over here right we would then have
506:04 - over here a vector holding types of IP
506:08 - address
506:18 - and because this is a custom type we
506:21 - have to actually Implement partial EQ
506:24 - here
506:33 - so I hope you get the concept we have
506:36 - here a vector holding types of IP
506:40 - address right
506:45 - then over here we have a trade IP
506:48 - address that
506:50 - defines one method display and then we
506:54 - have two Tuple structs V4 and V6 we
506:59 - implement the IP address trade for v2
507:02 - struct and V6 tract meaning we have to
507:06 - implement the specific method
507:10 - and all it does it then basically prints
507:13 - out the value that is stored inside
507:16 - destruct
507:18 - so fill in the blank as you can see we
507:21 - won't hear a vector holding trade
507:25 - objects remember a trade object is boxed
507:29 - or put behind a reference
507:31 - so over here we have a vector
507:35 - holding boxes right
507:39 - and the Box holds
507:43 - a trade object meaning again this is
507:47 - using Dynamic dispatch and we won't hear
507:50 - a type that implements the IP address
507:53 - straight right in this case B4 and V6
507:58 - both are types that Implement IP address
508:07 - and as you can see even though we are
508:10 - holding here different types we can use
508:14 - it using here trade objects to store it
508:17 - in the same vector
508:28 - typo
508:34 - so and then
508:36 - we are iterating over the vector and for
508:40 - each
508:41 - element in here we just call the display
508:45 - method that has to be implemented
508:47 - because we only have types in here that
508:51 - implement the IP address trade
508:54 - and this is exactly where Dynamic
508:57 - dispatch happens and we have covered
508:59 - that
509:01 - let's take a look at hash Maps so a hash
509:04 - map is a data structure to store key
509:07 - value pairs it's allocated on the Heap
509:11 - as it is dynamically sized meaning it
509:13 - can grow and Shrink
509:16 - it allows for efficient lookup insertion
509:19 - and deletion of data so when talking
509:22 - about time complexity this means
509:25 - accessing and modifying elements or
509:29 - entries as they are called in hashmaps
509:32 - would be in the best case at constant
509:35 - time meaning Big O of 1 while in the
509:38 - worst case if you have a lot of
509:40 - collisions then it would be still linear
509:44 - time which is still pretty fast which
509:47 - means Big O of n
509:49 - each key is hashed to a unique index in
509:53 - the underlying array so there are
509:56 - vectors stores values by an integer
509:58 - index hashmap store value spy key it is
510:02 - a hashmap implemented with quadratic
510:05 - probing and simd lookup by default a
510:10 - hashmap uses a hashing algorithm
510:13 - selected to provide resistance against
510:16 - hash those attacks so over here we find
510:19 - some information about the used
510:21 - algorithm for the hash Maps
510:24 - but let's dive into the exercises
510:28 - so the first thing is we actually have
510:31 - to use here a namespace so we are
510:34 - basically importing from the collections
510:37 - module from this standard Library the
510:39 - hashmap type
510:41 - and when using vectors or strings these
510:46 - are all in the Prelude meaning we don't
510:48 - have to import it but a hash map you
510:51 - will have to basically import
510:54 - so over here we are initializing an
510:57 - empty hash map
510:59 - then we insert some entries and again a
511:04 - hash map holds entries of keys and
511:08 - values now important here is that all
511:11 - the keys must be of the same type and
511:14 - all of the values must be of the same
511:17 - type so this over here would cause an
511:21 - error
511:22 - and let's go with integers
511:25 - like that and we annotate the hash map
511:28 - like this
511:30 - [Applause]
511:33 - where key stands for key and v stands
511:36 - for value
511:38 - so over here we use string literals as
511:41 - keys
511:43 - and i32 integers as values
511:50 - then as you can see we can access
511:55 - the entries in a hash map by using again
511:58 - the get method which returns an option
512:02 - we have seen that before when dealing
512:05 - with vectors
512:06 - so we provide the get method
512:09 - the name of the key all right and then
512:14 - we will get back the appropriate value
512:17 - in this case 98 because we are accessing
512:20 - the entry sun phase right so we would
512:25 - get back here
512:26 - a sum
512:28 - an option
512:30 - i32 right this would be the return value
512:35 - some 98 and this would be the type
512:39 - option i32
512:43 - so we can check if
512:46 - the hashmap contains a certain key so
512:50 - for example if the hash map contains the
512:53 - key Daniel this would evaluate to true
512:57 - meaning the code block here will be
513:00 - executed
513:01 - and we can also index into a hashmap
513:05 - using bracket notation like that
513:08 - so again this would then hold
513:12 - the value of the entry Daniel it would
513:16 - be 95 right
513:20 - this would be an i32 again notice the
513:24 - difference between indexing like that or
513:27 - indexing using using get method
513:30 - we will get back the value here directly
513:33 - while here we get back an option so get
513:37 - is generally safer
513:41 - and then over here we are removing
513:44 - Daniel from the hash map
513:47 - right so we can use the remove method
513:50 - and provide it the key
513:53 - the entry we want to delete meaning
513:57 - after deleting Daniel over here the
514:00 - length of the hash map would be 3 right
514:08 - and we can also iterate over a hash map
514:12 - so we provide it here
514:13 - the variable holding the hash map and
514:18 - then
514:20 - the return would be a tuple holding the
514:23 - key and the value and then we just print
514:27 - out the key and the value
514:30 - let's see
514:38 - all right and we would get back here an
514:42 - option
514:44 - holding a reference to i32 all right
514:50 - and over here too we would get back a
514:53 - reference
514:54 - this is what the get method will
514:57 - actually return so as you can see we are
515:00 - printing out the hash map
515:03 - and this would be the key for example
515:06 - Ashley and this would be the value
515:09 - as you can see
515:12 - now notice that the order here is
515:15 - different from what is over there and
515:19 - that's because a hashmap is unordered so
515:22 - the order won't be retained all right
515:28 - and of course we have only three
515:30 - elements here because we have removed
515:33 - the entry of Daniel
515:45 - then over here we have an array holding
515:49 - tuples which holds a string literal and
515:53 - an integer right
516:01 - so we have an array of three elements
516:06 - and each element is of type Tuple
516:10 - and inside the Tuple is a string literal
516:14 - and an i32
516:19 - then over here we are initializing a new
516:23 - empty hash map
516:25 - then we iterate over here through the
516:28 - elements of this team's array
516:33 - so for each element here
516:37 - we insert into this empty hash map here
516:42 - the name over here the string and the
516:46 - value
516:47 - all right
516:52 - Implement team map 2 in two ways tips
516:56 - one of the approaches is to use collect
516:59 - method so we can also
517:03 - implement
517:04 - a hash map from an array holding tuples
517:08 - of keys and values by using the hash map
517:15 - from function so we provide it here
517:19 - teams
517:22 - and this will then directly convert this
517:26 - array holding tuples of keys and value
517:28 - pairs to a hash map
517:31 - meaning we then have a hash map
517:35 - holding string slice keys and i32 values
517:41 - all right
517:43 - and over here we would have the same
517:45 - thing
517:49 - and then when we compare teams map 1 and
517:53 - teams map 2 they should be equal let's
517:57 - see
517:59 - this is compiling
518:01 - now the second approach would be taking
518:04 - this teams array here
518:08 - and we want to put it into an iterator
518:13 - and again we will cover that
518:15 - and then we call collect
518:19 - now when we call the collect method it
518:21 - will basically collect the elements in
518:25 - this iterator into the type we have
518:28 - annotated here
518:33 - again this would compile because we have
518:36 - in teams map 2 the same
518:39 - keys and values as we have in teams map
518:42 - one
518:43 - and as you can see we don't need to
518:46 - write a full-blown for Loop we can just
518:50 - use some simple methods
518:56 - let's see number three fill in the
518:58 - blanks so
519:00 - type inference lets us omit an explicit
519:03 - type signature which would be hashmap
519:06 - string slice and u8 in this example so
519:10 - again we don't have to annotate the
519:12 - types I do it just to make things more
519:15 - clear
519:16 - but we can leave it at that
519:19 - insert a key only if it doesn't already
519:22 - exist
519:24 - so here we are
519:27 - accessing player stats this empty
519:30 - hashmap and we call the entry now the
519:33 - entry checks if
519:37 - an entry exists with this specific key
519:42 - and then we can call over here the or
519:45 - insert method meaning if this entry
519:48 - doesn't exist then we insert this key
519:53 - with this value meaning when we then
519:57 - access player stats with a key of Health
520:01 - we would should get back 100 right
520:04 - because this has been inserted over here
520:09 - insert a key using a function that
520:12 - provides a new value only if it doesn't
520:15 - already exist
520:19 - so
520:20 - again we are trying to access player
520:22 - stats and look for an entry Health now
520:27 - in this case this exists right because
520:29 - we have inserted it at that point
520:33 - now we can also use here the method or
520:36 - insert with the difference to our insert
520:39 - is that we don't provide a concrete
520:42 - value but a function pointer meaning
520:47 - this function will then get executed so
520:50 - this function only returns 42 so that
520:55 - means if the entry Health doesn't exist
520:59 - we insert this key with the value of 42.
521:04 - now again Health exists meaning when we
521:08 - Access Health we will still get 100
521:10 - right
521:12 - because this only executes if N3 isn't
521:17 - found
521:19 - ensures a value is in the entry by
521:21 - inserting the default if empty and
521:25 - returns immutable reference to the value
521:27 - in the entry
521:29 - so we are here
521:32 - checking for the entry health
521:35 - and if it doesn't exist we insert 50
521:40 - right
521:41 - so in this case Health already exists
521:48 - meaning we would get back immutable
521:51 - reference to the existing value 100
521:55 - right
522:00 - so this would be immutable
522:03 - reference to 100.
522:06 - and because it is mutable we can then
522:10 - modify the entry manually so we can hear
522:14 - decrement from Health which holds 100 we
522:19 - decrement 50 meaning the health will
522:22 - then hold
522:24 - 50 right this health variable holds 50.
522:30 - let's see
522:35 - this would be u8 in this case
522:49 - and this is compiling so as you can see
522:51 - when we call entry it will give us back
522:55 - a mutable reference to the value
522:59 - if it already exists to the existing
523:01 - value if it doesn't exist it will here
523:05 - create an entry because this is what the
523:08 - or insert method does and will return
523:12 - immutable reference to the created value
523:18 - and then we can
523:20 - modify
523:22 - this mutable reference
523:25 - right
523:27 - requirements of hashmap key any type
523:31 - that implements C EQ and hash trades can
523:34 - be a key in a hashmap this includes pool
523:37 - intu in string and string slices
523:41 - note that F32 and f64 do not Implement
523:45 - hash likely because floating Point
523:48 - Precision errors would make using them
523:50 - as hashmap Keys horribly error prone
523:54 - all collection classes Implement EQ and
523:57 - hash if their contained type also
524:00 - respectively implements EQ and hash for
524:04 - example a vac holding a type T will
524:08 - Implement hash if T implements hash so
524:12 - if the elements in a collection for
524:15 - example a vector or a tuple or an array
524:18 - implement
524:19 - the hash trade then the collection
524:24 - itself will Implement hash
524:28 - let's see fix the errors tips derive is
524:31 - usually a good way to implement some
524:33 - common use traits as you can see we have
524:36 - here a struct viking with two fields of
524:39 - type string
524:41 - and here we have
524:44 - an associate function for Viking just
524:48 - creating a new Viking instance from the
524:51 - arguments we provide
524:54 - and as you can see use a hashmap to
524:57 - store the Vikings Health points
525:00 - so we are creating here a hash map from
525:03 - an array holding tuples of keys and
525:06 - values
525:08 - now notice we have here a hash map
525:12 - and the type of the keys would be the
525:15 - custom type y King all right
525:21 - the value would be i32
525:27 - use derived implementation to print the
525:30 - status of the Vikings so here we are
525:33 - taking this created hash map as a
525:36 - reference and we would get back a tuple
525:40 - holding the key and the value and then
525:43 - we just print out the key and the value
525:46 - here
525:47 - so we have seen that in order
525:52 - a type can be used as a key in a hash
525:56 - map it has to implement EQ and hash so
526:01 - let's Implement that
526:11 - let's also use the partially queue over
526:13 - here
526:15 - and debug so we can print out the key
526:18 - over here in debug notation let's see
526:34 - and of course we have to implement the
526:36 - hash trade
526:44 - and as you can see it will print out
526:47 - each element in the hash map we have
526:51 - created so we have now a hash map
526:54 - using as key our custom type y King as
526:59 - you can see this would be the key
527:01 - this would be the value
527:03 - of the hashmap
527:07 - capacity like vectors hash maps are
527:10 - growable but hashmaps can also shrink
527:13 - themselves when they have excess space
527:16 - you can create a hash map with a certain
527:19 - capacity using hashmap with capacity or
527:23 - use hashmap new to get a hashmap with a
527:27 - default initial capacity this is
527:30 - recommended
527:33 - so like we did with strings and vectors
527:36 - we can Define when initializing an empty
527:39 - hashmap the capacity right
527:42 - ensuring that when we know we will push
527:46 - a lot of entries that there are no
527:50 - reallocations because remember we
527:53 - allocations are slower
527:55 - so then we are here inserting two
527:58 - entries
527:59 - and as you can see this would be an
528:01 - entry of
528:03 - key i32 and value i32 so the key entity
528:09 - value can be of the same type and over
528:12 - here we insert again another entry
528:16 - indeed the capacity of hashmap is not
528:18 - 100 so we can't compare the equality
528:21 - here
528:23 - so even though we have here defined that
528:26 - the capacity should be 100 it could
528:29 - actually be more than 100 and this is
528:33 - just in case there are collisions there
528:36 - are some
528:39 - internal stuff going on so the RAS
528:43 - compiler will actually allocate more
528:46 - capacity than 100 we defined here
528:52 - shrinks the capacity of the map with a
528:55 - lower limit so when we call map over
528:58 - here our hash map holding two entries
529:01 - and then we can shrink the capacity to
529:04 - 50 right so again the capacity won't
529:09 - probably be exactly 50 then but around
529:13 - 50 so we can shrink the hash map
529:17 - and shrinks the capacity of the map as
529:20 - much as possible so because over here we
529:22 - have only a hash map of two entries 50.
529:27 - spaces in Heap memory would actually be
529:30 - more than we need so we can use this
529:32 - shrink to fit method so that the
529:36 - capacity will shrink around
529:38 - the amount of elements it actually holds
529:42 - again it won't probably be 2 exactly but
529:46 - around this number
529:53 - ownership for types that implement the
529:56 - copy trade like i32t values are copied
529:59 - into hashmap for owned values like
530:03 - string the values will be moved and
530:05 - hashmap will be the owner of those
530:07 - values
530:09 - fix the errors with least changes don't
530:12 - remove any code line
530:15 - so over here we have initialized a
530:18 - variable with a type of i32 and an empty
530:22 - hash map
530:24 - right
530:25 - then we insert here
530:28 - and N3 into M1
530:31 - and using the same exact value for the
530:34 - key and the value meaning we have here a
530:37 - hash map
530:41 - with keys of type i32 and values of type
530:45 - i32
530:48 - over here we have a string
530:52 - and we initialize here an empty hash map
530:57 - then over here we are inserting a new
531:01 - entry using V2 this string here as the
531:06 - key and V1 over here as value so we
531:10 - would have here a hash map
531:15 - using
531:17 - keys of type string and value of type
531:21 - i32
531:24 - and because this is an owned type
531:27 - meaning it doesn't Implement copy this
531:31 - will then actually be moved into the
531:33 - hash map so we can't use V2 here
531:38 - but what we could do to fix that is we
531:41 - could use a string slice of this string
531:44 - right we just provide a reference
531:48 - meaning then the hash map will have
531:51 - type for the keys of string slices right
531:58 - and that means we can then again use V2
532:05 - and again because V1 is of type i32 it
532:10 - means it implements the copy trade
532:12 - meaning even if we pass it as a key in
532:15 - the hash map or as a value it is still
532:19 - usable
532:20 - but when you are dealing with types that
532:22 - don't Implement copy the ownership will
532:26 - get moved meaning hashmap will then be
532:29 - the owner of the type
532:34 - alright and there are some third-party
532:36 - hash lips but I won't cover that in this
532:39 - beginners course so we'll see you in the
532:41 - next topic
532:46 - let's now look at type coercion and we
532:49 - have already seen the S keyword and this
532:52 - is mostly used for converting integers
532:56 - so type conversion also called type
532:59 - casting is coercing a primitive type
533:02 - that can be performed by as keyword
533:06 - as conversions can be Chained and when
533:09 - casting to an unsight type T for example
533:12 - then T Max Plus 1 is added or subtracted
533:17 - until the value fits into the new type
533:21 - and using unsafe methods can lead to
533:24 - undefined Behavior
533:27 - so let's see an example as you can see
533:31 - we have here the largest unsigned 8-bit
533:34 - integer 255.
533:38 - and this would be the binary
533:40 - representation
533:42 - this means that u8 right this data type
533:45 - for unsigned 8-bit integers Max meaning
533:51 - 255 plus 1 will be
533:54 - 256 so for example if we Typecast 1000 s
534:01 - u 8 then let's see what the compiler
534:05 - will do
534:06 - it will subtract
534:09 - 256 this value over here from 1000
534:14 - and then it will check seven hours
534:17 - 744 is still bigger than the largest
534:21 - value it can represent meaning it will
534:24 - do the same thing
534:26 - subtracting
534:28 - 256 will leave us with
534:32 - 488 still bigger than this value so
534:36 - again the same thing it will subtract
534:39 - 256 and this will leave us with
534:43 - 232 meaning this will then be the
534:46 - returned value when we cast 1000 s u 8
534:50 - because remember an 8-bit unsigned
534:53 - integer can't represent 1000 it's out of
534:58 - bounds
535:00 - now when we Typecast
535:02 - -1
535:03 - as u8 then remember an unsight integer
535:09 - cannot represent negative numbers
535:11 - meaning what it will then do it will
535:15 - basically rotate so 0 would be the
535:19 - smallest possible number an 8-bit
535:21 - unsigned integer can represent and then
535:25 - -1 will just basically rotate it will go
535:27 - back to the biggest one meaning this
535:31 - type casting over here will result in
535:34 - 255.
535:38 - so convert by S rust provides no
535:41 - implicit type conversion coercion
535:44 - between primitive types but explicit
535:47 - type conversions can be performed can be
535:50 - performed using the as keyword
535:53 - fix the errors and fill in the blank
535:56 - don't remove any code
535:58 - so over here we have an F 32 float right
536:04 - then we Typecast this float into an u8
536:10 - meaning over here the fractional part
536:14 - will get removed so the value would be
536:17 - 97.
536:20 - and of course this will then hold a u8
536:24 - now we want to Typecast this decimal
536:27 - into HR now this is not possible
536:31 - directly but we have seen that we can
536:33 - chain as statements so we can convert
536:38 - this first to an u8
536:41 - meaning we will get 97 like we did here
536:44 - and then Typecast it to a character so
536:48 - C1 will then hold a character
536:52 - and by the way 97 would be the ASCII
536:55 - code for a
536:59 - and over here as you can see we can
537:02 - Typecast this integer holding an u8 type
537:06 - as Char directly so C2 would also hold
537:10 - HR
537:13 - now as you can see we are here comparing
537:17 - the integer holding 97 with this type
537:22 - casting now this type casting over here
537:25 - converts the B character to its u8
537:30 - representation now B would be
537:33 - represented as 98.
537:36 - so what we can do over here is adding
537:39 - one
537:42 - 297 because remember 97 would be a
537:48 - meaning when we add 1 to 8 we will get
537:51 - back B right so both of them will hold
537:56 - 98.
538:03 - by default overflow will cause compile
538:06 - errors but we can add a global
538:08 - annotation to suppress these errors
538:12 - so as you can see the largest possible
538:16 - number u8 can represent would be
538:19 - 255 meaning this would cause an error
538:25 - because again 1000 is larger than the
538:28 - largest possible number a weight can
538:31 - represent meaning we have here an
538:34 - overflow error now we can actually allow
538:37 - overflowing
538:39 - by using this attribute
538:53 - so
538:55 - distance won't complain right
538:58 - and then when we print out B
539:02 - [Applause]
539:12 - as you can see we would get back
539:15 - 232 because we have seen over here
539:21 - that
539:22 - this would be the result when the
539:25 - compiler performs this operation
539:29 - so we allow here overflowing literals
539:33 - right
539:34 - if we didn't if we comment this out
539:38 - then the compiler will complain because
539:41 - this is actually not possible
539:46 - when casting any value to an unsight
539:49 - type T T Max plus one is added or
539:52 - subtracted until the value fits into the
539:56 - new type that's what we have seen so in
540:00 - this case 1000 as u16 would return 1000
540:05 - right because a u16 can represent a
540:10 - number of 1000 but over here we would
540:14 - have an overflow meaning this would
540:18 - return
540:20 - 232 like we have seen over here
540:25 - for positive numbers this is the same as
540:28 - the modulus
540:30 - so this would actually be the same as
540:35 - uh doing a thousand modulus
540:39 - 256 remember
540:42 - u8 Max
540:44 - plus one
540:49 - meaning 256.
540:54 - now we have also seen in the example
540:57 - when we have
540:58 - -1 and casting that to an unsigned
541:01 - integer it will then basically just
541:04 - rotate so this will return
541:07 - 255. since rust 1.45 the S keyword
541:12 - performs a saturating cast when casting
541:15 - from float to int if the floating point
541:18 - value exceeds the upper bound or is less
541:22 - than the lower round the The Returned
541:24 - value will be equal to the bound crossed
541:28 - so in this case we have a float here
541:32 - casting it to u8 meaning a saturating
541:37 - cost will be performed so it will just
541:40 - return the largest possible number u8
541:43 - can represent which would be 255.
541:49 - now in case we have here A minus 100 as
541:53 - floating point and convert it to u8 this
541:57 - just would return 0.
542:01 - it's a possible number u8 can represent
542:06 - this Behavior incurs a small runtime
542:09 - cost and can be avoided with unsafe
542:12 - methods however the results might be
542:15 - overflow and return unsound values use
542:19 - these methods wisely we can use here in
542:22 - an unsafe block
542:25 - the method to int unchecked
542:30 - so the compiler here won't actually
542:33 - check what's going on so as you can see
542:36 - we are casting 300 floating Point 2 and
542:41 - U int
542:43 - to a u8
542:45 - so as you can see we are here casting
542:48 - 300.0 floating point to
542:52 - and u8 integer and this won't be checked
542:57 - by the compiler that's because it's in
543:00 - an unsafe block
543:03 - now this would return 44 right because
543:09 - 300 minus u8 Max
543:13 - plus one
543:16 - would be 300 minus 256
543:22 - meaning we would be left with 44.
543:26 - and minus 100 Su 8 as you can see we are
543:31 - typecasting this floating point
543:35 - 2 and u8 integer and again this is
543:38 - unchecked so again what the compiler
543:41 - will do here it will take u8 Max
543:45 - plus one meaning 256 and it subtracts
543:51 - 100 meaning we would get 156.
543:58 - and not a number
544:01 - would be converted to zero okay
544:07 - thank you
544:11 - and of course here we have to use again
544:16 - the attribute allow
544:18 - overflowing
544:21 - literals
544:23 - just so this will actually compile
544:26 - because usually this won't compile
544:34 - and as you can see this would be the
544:36 - output
544:39 - now over here we are dealing with raw
544:42 - pointers and we won't cover that in this
544:45 - beginner's course because this is more
544:48 - of an advanced topic
544:50 - so see you in the next topic
544:54 - so we have seen type conversions for
544:57 - integers and types from the standard
545:00 - library but what if we want to convert
545:03 - types that we defined basically custom
545:06 - types and rust has for this T from
545:11 - entity into trade so let's see from and
545:14 - into trades are used for type
545:17 - conversions between different types
545:19 - without requiring explicit costs it's
545:23 - part of the standard library and can be
545:26 - implemented for custom types
545:29 - implementing the from trade for a type
545:32 - will give us the intu implementation for
545:35 - the given type for free meaning when we
545:38 - Implement from we implement it into
545:41 - automatically
545:43 - so always implement the from trade and
545:46 - not the into trade
545:50 - let's see here an example we have a
545:53 - custom type number
545:56 - and then over here we are implementing
545:59 - the from trade right so we want to
546:04 - convert from an i32 to our custom type
546:09 - number right and the from trade
546:13 - implements a method from
546:16 - so we take here as an argument an i32
546:20 - and we will then create a new instance
546:24 - of the number type with the provided
546:27 - value and then return it and that means
546:31 - when we use here the from Associated
546:33 - function on our custom type
546:37 - number and provide it in i32 then this
546:42 - can directly be converted to our custom
546:47 - type right
546:50 - and we can do it in two ways from as
546:53 - we've seen because we have implemented
546:55 - it and I've told you that when we and
546:58 - I've told you that when you implement it
547:00 - from trade T into trade is automatically
547:04 - implemented meaning we can also call the
547:07 - into method on the type we want to
547:11 - convert to but when you use into a type
547:15 - annotation is needed so the compiler
547:17 - knows into what type you want to convert
547:21 - this type right so we convert here
547:25 - a type of i32 into a number
547:30 - and this would be the implementation
547:37 - so the from trade allows for a type to
547:39 - Define how to create itself from another
547:42 - type hence providing a very simple
547:45 - mechanism for converting between several
547:48 - types deformant into trades are
547:51 - inherently linked and this is actually
547:53 - part of its implementation it means if
547:57 - we it means if we write something like
548:01 - this
548:02 - we Implement here
548:04 - so we Implement here the from trade for
548:07 - the custom Type U then we can use
548:12 - U from T right we can then
548:17 - create a u-type from the type T we have
548:22 - implemented the front trade on
548:26 - or we could also use into so we convert
548:30 - T into U
548:33 - the input rate is simply the reciprocal
548:36 - of the from trade that is if you have
548:39 - implemented the from trade for your type
548:42 - then the input rate will be
548:44 - automatically implemented for the same
548:47 - type using the into trade will typically
548:50 - require to type annotations as the
548:54 - compiler is unable to determine this
548:57 - most of the time
548:59 - so for example we can easily convert a
549:02 - string slice into a string
549:07 - as you can see we have over here a
549:09 - string slice and then we can call string
549:13 - and the from Associated function
549:15 - providing it this string literally
549:19 - meaning this will then be converted to a
549:22 - string
549:23 - and we could also use the two string
549:26 - method again this and this is exactly
549:29 - the same
549:31 - and we could also then use the into
549:34 - because remember when we Implement from
549:36 - we get into for free so we can so we
549:42 - convert this my string string literal
549:45 - into a string and again type annotations
549:49 - are needed
549:53 - because the sender library has already
549:55 - implemented this for us
549:59 - input from string slice for string so we
550:02 - can easily convert a string to a string
550:06 - slice and vice versa
550:09 - some implementations of form can be
550:12 - found here
550:13 - so as you can see we have here input
550:17 - from Bool for i32 meaning we can convert
550:24 - Boolean into an i32 so when we have here
550:29 - a Boolean value and call into it will
550:32 - convert this Boolean value into an i32
550:37 - integer in this case this would
550:40 - be zero zero for false and one for true
550:46 - and again when we can use the into
550:49 - method we can use the from Associated
550:51 - function
550:54 - so we call the associated function on
550:56 - the type i32 and provide it here the
551:01 - Boolean value right
551:06 - so this will then actually be exactly
551:09 - the same
551:12 - fix the error in two ways first
551:15 - Implement from Char 4 maybe you should
551:18 - check the docs mentioned above to find
551:21 - the answer
551:22 - second a keyword from the last chapter
551:28 - so let's see the docs
551:34 - so
551:36 - we want here to convert a character
551:42 - so let's see over here as you can see
551:45 - you can see all the types that
551:48 - implemented from trade so we want to go
551:52 - from character
551:54 - and as you can see we can convert a
551:57 - character to either u32 u64 or
552:03 - u128 as well as string so I 32 is not
552:09 - supported
552:12 - and as you notice these are only
552:14 - unsigned types because it's logical a
552:19 - character can't be negative right it
552:21 - can't hold a negative number so we only
552:23 - have
552:25 - unsigned intervals here
552:27 - so we can
552:30 - so we can then in fact convert HR into a
552:34 - u32 let's say
552:37 - so in this case
552:39 - Char implements
552:42 - so in this case
552:43 - we use here u32 right we can convert
552:48 - from HR to Au 32.
552:52 - meaning when we change this over here
552:55 - this should actually work so we provide
552:58 - here a character called the into method
553:00 - and then we should have a new 32.
553:05 - fix the error in two ways so we can't
553:09 - use the as keyword here this is not
553:12 - implemented but what we can do is let's
553:16 - first use the from method
553:33 - so we can create a string or basically
553:37 - converting a character into a string
553:41 - because we have seen in the
553:43 - documentation this is actually
553:45 - implemented
553:48 - and the second way would be to call a
553:53 - and then into right like we did over
553:56 - here
554:04 - Implement from for custom types from is
554:08 - now included in standard Prelude so
554:10 - there is no need to introduce it into
554:13 - the current scope so we don't have to uh
554:18 - so we don't have to import the from
554:21 - trade it's actually in the Prelude
554:23 - meaning we can use it
554:25 - without importing anything so over here
554:28 - we have a custom type number with one
554:31 - field
554:33 - now we want to implement the from trade
554:36 - for our custom number meaning we should
554:40 - be able to convert from an i32 into a
554:45 - number
554:46 - so when we call over here
554:49 - number
554:51 - from
554:53 - right
554:55 - then
554:56 - we should get over here number
555:00 - this would then create an instance of
555:03 - the number struct
555:05 - and the value field here will hold a
555:09 - value of 30 right
555:12 - so
555:14 - and the same thing is when we would call
555:17 - 30
555:18 - like that
555:20 - and call into right this should then
555:24 - convert the
555:27 - i32 integer into the number type
555:31 - automatically
555:33 - and remember we only have to implement
555:36 - the from trade because then we can use
555:39 - from and into
555:42 - both of them
555:44 - so let's see so this over here is the
555:48 - from trade and
555:51 - let's take this function signature over
555:53 - here
555:55 - and copy it like that
556:00 - now in this case self refers to number
556:03 - right
556:04 - and what we want to do is create here a
556:08 - new instance
556:12 - and we just take the value in this case
556:16 - the i32 right
556:19 - and we provide it as a value for the
556:23 - value field
556:26 - and again because the name of this
556:28 - argument matches the name of the field
556:31 - we can use it like that and this is
556:34 - sufficient so let's see
556:39 - and this is compiling so as you can see
556:41 - then it's really easy to convert one
556:45 - type to a custom type we have created
556:51 - when performing error handling it is
556:53 - often useful to implement from trade for
556:56 - our own error type then we can use
556:59 - question mark to automatically convert
557:02 - the underlying error type to our own
557:05 - type now we didn't cover that this will
557:09 - be the next topic but let's see the
557:12 - exercise we have here an enum CLI error
557:15 - now
557:17 - the two variants here IO error and parse
557:21 - Arrow hold Arrow types from the standard
557:24 - Library okay
557:27 - and
557:29 - these are actually the error types that
557:31 - get returned in case of an error when
557:35 - using these specific methods
557:39 - that are implemented in this standard
557:42 - Library
557:44 - so as you can see we want here to
557:47 - implement the from trade for different
557:50 - error kinds from this standard library
557:53 - and we want to convert that to our
557:56 - custom error type CLI error
558:00 - so let's see over here we have the
558:02 - function open and pause file it takes a
558:05 - file name as argument
558:07 - and it returns a result and we will
558:11 - cover results so a result basically says
558:15 - in case of
558:17 - success it will return a result with i32
558:21 - and otherwise CLI error
558:26 - so then we call the read to string
558:29 - function and as you can see this is
558:32 - defined in the fs module FS is used for
558:37 - file manipulation
558:39 - and we provide to this function over
558:42 - here the file name
558:44 - now we pass a reference because this is
558:47 - defined in the documentation of this
558:50 - function we are here using the question
558:53 - mark operator meaning in case of success
558:58 - the result type that will get returned
559:01 - will be unwrapped and contents will hold
559:04 - a string
559:06 - in case of an error it will return the
559:10 - CLI error meaning the rest of this code
559:13 - won't get executed and we just get acli
559:18 - error instead
559:20 - now
559:22 - the error type returned from this
559:25 - function would be IO error
559:29 - so in order this error to be converted
559:32 - to a CLI error we have to implement for
559:35 - this error type the from trade right but
559:40 - let's see what's happening here we then
559:43 - take the contents meaning this string
559:46 - over here that gets returned in case
559:49 - this function call is successful
559:53 - and we then hold over here the contents
559:56 - of the provided file then we trim and
560:01 - then we pause now pause could
560:03 - potentially fail and parsing is
560:05 - basically converting a string to an
560:08 - integer value right so in case of
560:13 - success we will get out an i32 in case
560:18 - of error we'll get back a num pulse and
560:22 - error this is defined in the num module
560:26 - again we will cover error handling and
560:28 - all of that don't worry this is now just
560:31 - about the type conversion
560:35 - and then we return an OK with the num
560:39 - value here we have to wrap it in OK
560:41 - because we return a result type
560:46 - now let's see how we would Implement
560:49 - that so again I will just go to the
560:51 - documentation and copy the function
560:55 - signature
560:59 - like that
561:02 - so we have the function signature
561:06 - and then we can over here see what we
561:10 - want to do so in case we get an i o
561:13 - error we want to convert that to our
561:17 - custom CLI error now how would we do
561:20 - that let's change here
561:23 - the argument to e for error and the type
561:28 - would be IO error right we are
561:33 - implementing it
561:35 - from this type
561:37 - now what we want to do is we just want
561:40 - basically to pass the i o error into the
561:45 - io error variant in our custom type so
561:49 - we can access the variant
561:53 - so we can create an instance
561:58 - remember this is the syntax to access
562:01 - the enum so we access CLI error and then
562:04 - the io error variant
562:09 - and all we do then is just passing this
562:12 - IO error type
562:15 - meaning we then have an instance of this
562:18 - variant holding our i o error and that
562:22 - means we have then implemented the from
562:25 - trade for our custom type so any IO
562:29 - error type can be
562:31 - implicitly converted to CLI error
562:34 - meaning in case this function over here
562:37 - returns an IO error it will implicitly
562:41 - be converted to a CLI error
562:45 - let's do the same thing over here for
562:48 - parse int error this would be the error
562:51 - type from the parse method
562:57 - so again let's change here the argument
563:00 - name and the type would be over here
563:06 - and then we again just access this enum
563:14 - access the pause int Arrow variant
563:18 - and we pass it the actual error that
563:22 - gets returned
563:24 - and this would mean we then create
563:27 - another instance of the pause error
563:30 - variant
563:33 - let's see if this works
563:37 - and as you can see this is compiling
563:39 - meaning in case of an error over here
563:43 - both these Arrow types from the standard
563:47 - Library I or error and parse int Arrow
563:50 - will be implicitly converted to CLI
563:54 - error right
563:57 - try from try into similar to from and
564:01 - into try from and try into our generic
564:04 - traits for converting between types
564:08 - unlike from into try from and try into
564:12 - are used for valuable conversions and
564:15 - return a result instead of a plane value
564:21 - now again we use the result type we will
564:23 - cover that when there is a possibility
564:27 - of an error of something going wrong
564:32 - so as you can see we have here an i16
564:35 - holding 256.
564:39 - into trade has a method in two hence try
564:43 - into has a method
564:47 - try into right this is the method
564:51 - defined on the try into trade so we take
564:55 - this value here and call the try into
564:59 - method on it
565:01 - meaning this will return a result so we
565:04 - match this result in case of an okay
565:07 - then we unwrap the value from the result
565:12 - and if it is an error then we just print
565:16 - out the error over here
565:20 - and
565:21 - return 0.
565:24 - right
565:25 - so in case this succeeds then n will
565:29 - hold a u8
565:31 - and the value in case this fails n will
565:35 - hold a value of 0. now we have seen that
565:40 - when we want to convert an u8
565:44 - then this would actually fail because
565:46 - this is out of boundaries
565:49 - but because we are here
565:52 - basically error handling that means that
565:55 - the program here won't actually panic
566:00 - so in case this fails here which it does
566:03 - then we will just assign to n the value
566:07 - 0 and print out the error so in this
566:11 - case n would be zero
566:16 - and again error handling will be our
566:18 - next topic so don't worry if this seems
566:21 - a little bit strange
566:27 - then over here we have a tuple struct
566:30 - even num and it takes an i32 type
566:36 - we Implement here the try from
566:40 - trade for the custom even num type
566:45 - now here we have an Associated type and
566:49 - we Define that it should be of type unit
566:52 - type okay and then we Implement here the
566:57 - try from function
567:01 - so all this function basically does it
567:04 - takes a value and it checks if it is
567:07 - divisible by zero and then we will
567:09 - return the result in this case okay even
567:13 - num and inside it t value provided
567:16 - otherwise if it is not divisible by 2
567:20 - then we return an error holding our
567:24 - unit type we have defined here as you
567:27 - can see the type
567:29 - in case of an error would be this
567:31 - Associated type error meaning a unit
567:34 - type so we have provided that over here
567:39 - so then we can use the drive from
567:43 - function so when we call even num and
567:48 - try from 8 then this would return okay
567:52 - right because 8 is divisible by two so
567:57 - we would get back a result in this case
568:00 - okay even num and T value we have passed
568:04 - right that's what we defined here
568:09 - now in case we try from a value of 5
568:12 - this would return an error with a unit
568:15 - type inside because again 5 is not
568:19 - divisible by 2.
568:22 - now with try from and try into it's
568:26 - exactly the same like with from and into
568:29 - when we Implement try from then try into
568:33 - is automatically implemented so we can
568:36 - use this try into method here directly
568:40 - so we try here to convert eight into
568:46 - this result right and the result in case
568:49 - of success will will hold the type of
568:52 - even num and otherwise a unit type like
568:55 - defined over here
568:59 - and in this case result will then hold
569:03 - ok
569:06 - even num
569:09 - and the value we have passed eight
569:13 - now when we call try into on 5 then this
569:19 - will actually return error
569:21 - and a unit type inside like we have
569:25 - defined over here
569:27 - let's see
569:31 - and this is compiling see you in the
569:34 - next topic
569:36 - let's now see two more exercises and
569:39 - this time we are converting a custom
569:42 - type into a string
569:45 - so to convert any type to string you can
569:48 - simply use the two string trade for that
569:51 - type rather than doing that directly you
569:54 - should implement the fmt display trait
569:57 - which will automatically provide
569:59 - tostring and also allows you to print
570:02 - the type with print line
570:05 - so again
570:07 - same thing like with from and into if
570:10 - you implement from then into is for free
570:13 - so you usually don't implement this
570:17 - trade directly for a type you implement
570:20 - display and you will get two string
570:23 - implementation for free
570:26 - so let's see we import here fmt
570:30 - and we have here our custom type point
570:34 - now here we are instantiating a point
570:37 - so what we want to achieve here is that
570:40 - when we take the point instance here we
570:42 - have instantiated and converted to a
570:46 - string
570:48 - this should then be the output
570:52 - and we can also use the format macro
570:56 - here
571:01 - basically just providing origin because
571:04 - the format macro will automatically
571:07 - convert that to a string in order to
571:10 - print it out and the output will be the
571:13 - same
571:14 - so let's implement the display trade
571:17 - here so as you can see this is the
571:20 - display trade and it provides one method
571:24 - now let's take it from over here
571:27 - they provide here an example
571:33 - and we can just copy
571:36 - this over here now I remove the lifetime
571:39 - it's not needed
571:41 - and
571:43 - let's implement the fmt
571:47 - method here so as you can see the fmt
571:50 - method provides here a formatter meaning
571:54 - we want to write we can use the right
571:57 - macro here and the right macro works
572:01 - like println or format but the
572:04 - difference is it will write to a buffer
572:08 - in this case f
572:10 - this is the formatter from the fmt
572:13 - module and then
572:16 - we here provide what we want to print
572:19 - out
572:21 - so in this case we want to print out the
572:23 - point is entity values so let's do that
572:33 - [Applause]
572:38 - and then like in a print Ln macro we
572:42 - provided the values so in this case we
572:44 - want cells dot X
572:46 - and self.y we want to print out
572:51 - the X and the Y field
572:54 - and that's basically it we have
572:56 - implemented the display trade for Point
572:59 - meaning our customly created type Point
573:03 - can be converted directly to a string so
573:07 - let's see
573:14 - and this is compiling so
573:24 - if we pass origin here let's see the
573:27 - output
573:29 - as you can see this would be the output
573:33 - so we can even
573:36 - manipulate how the output should look
573:39 - like so instead of just so instead of
573:42 - just printing out the two fields we have
573:44 - even
573:45 - provided the output with a whole
573:48 - sentence right
573:53 - this will be the last one we will be
573:55 - doing we can use parse method to convert
573:58 - a string into an i32 number
574:01 - this is because from string is
574:04 - implemented for i32 type in standard
574:07 - Library
574:08 - to use from string method you need to
574:11 - introduce this trade into the current
574:13 - scope so we have to import this
574:17 - trade from the stir module
574:23 - so over here we want to pause
574:27 - and parsing again means converting a
574:30 - string into an integer so we would here
574:34 - have an i32 type of this value and over
574:39 - here the same thing
574:43 - now we can either annotate the type over
574:47 - here or we could use the turbo fish
574:50 - syntax meaning we can directly annotate
574:54 - the type on the method
574:58 - like that
575:03 - and then because the from string trade
575:06 - is actually implemented for the i32 type
575:10 - we can also
575:12 - call the associated function from store
575:20 - let's do 20 here
575:22 - so this will
575:24 - convert from this string literal into an
575:28 - i32 meaning this will then hold an i32
575:31 - now because all of them hold i32
575:35 - integers we can then do a mathematical
575:39 - operation meaning we just add together
575:41 - all of these values 5 10 and 20.
575:46 - so to be variable will hold an i32 and
575:51 - it should be equal to
575:54 - 35
575:59 - and this is compiling see you in the
576:01 - next topic
576:04 - now we will cover error handling
576:07 - anti-simples form of error handling is
576:10 - to use the Panic macro Panic will print
576:13 - out an error message unwind this deck
576:16 - and finally exit the program now
576:19 - unwinding the stack means that when you
576:23 - actually execute the program then we
576:25 - have seen that the local variables and
576:28 - the function calls will be pushed to
576:30 - this stack now when panicking that means
576:33 - that the compiler will actually delete
576:36 - everything step by step from this stack
576:39 - memory and then exit the program
576:43 - and in multi-threaded programs it will
576:46 - exit the thread in which the Panic
576:48 - occurs not the whole program so we don't
576:51 - deal here with a multi-threaded programs
576:54 - this will be another course but I just
576:57 - want to mention it
576:59 - so let's see exercises
577:02 - as you can see we have here a function
577:05 - drink which takes a string literally
577:09 - if the string literal is lemonade then
577:12 - we print out success
577:14 - otherwise we actually want to panic
577:18 - right
577:20 - because we want to ensure that this line
577:23 - never gets reached meaning never gets
577:26 - printed out
577:27 - so when we pass over here lemonade
577:33 - then this will print out success and
577:36 - then will panic
577:43 - and this would be the output if a
577:46 - program panics threat main panicked at
577:49 - explicit panic and it will provide you
577:52 - the line number
577:54 - at which the Panic occurred in in this
577:57 - case an explicit panic because we have
577:59 - here called the Panic macro
578:04 - common Panic cases make make the code
578:07 - work by fixing all panics
578:11 - so when we call here the S bytes method
578:14 - on a string then it will give us back
578:17 - the array holding the utf-8 bytes of
578:21 - this string now we have seen that
578:24 - actually the utf-8 representation of a
578:27 - would be 97.
578:30 - B would be 98
578:34 - and C would be 99
578:37 - so again if srtq doesn't match if this
578:42 - does evaluate to another value then this
578:45 - then assert EQ will cause a panic over
578:49 - here we have a vector
578:53 - and we try here to access the third
578:57 - index now we only have now we only can
579:01 - go to index 2 right it's the outmost
579:04 - index we can provide
579:06 - so let's change that
579:09 - and this will then hold an i32 right
579:12 - because we are accessing a specific
579:15 - element
579:16 - unwrap May panic when get return a none
579:20 - so the get method over here will return
579:22 - an option meaning it either returns a
579:26 - sum with a value or a non now in this
579:30 - case this would return a non because we
579:33 - don't have any value at index 3. so when
579:38 - we try to unwrap a non
579:41 - value then we will panic
579:45 - now let's hear excess index 1 for
579:48 - example
579:50 - then it will return a sum
579:54 - two right the first element
579:57 - write the element at index one
580:01 - and unwrap we basically just unwrap the
580:04 - inner value so
580:07 - La will then hold a value of 2 of type
580:11 - i32
580:12 - sometimes the compiler is unable to find
580:15 - the Overflow errors for you in compile
580:18 - time so a panic will occur
580:22 - so when we call here the production rate
580:25 - per hour function with a value of 2 then
580:29 - let's see we have here speed
580:32 - the provided argument of type u8 and
580:36 - here we have cph of type u8
580:39 - now as you can see we are inside here
580:44 - multiplying the speed in this case 2 by
580:49 - cph
580:51 - 222 now this would actually result in an
580:55 - overflow because
580:58 - 2 times 221 would be
581:03 - 442 right now remember an u8 can only
581:07 - represent up to the number
581:10 - 255 so this would actually cause a panic
581:14 - but what we can do is just actually
581:17 - taking here a u16 and converting that to
581:22 - u16 meaning when we multiply these
581:25 - together then
581:27 - the result of u16 will still be able to
581:31 - represent the resultant number
581:35 - and over here we can do the same thing
581:45 - and then let's see because of the same
581:47 - reason as above we have to wrap it in a
581:50 - function to make the Panic occur so here
581:54 - we are calling the divide function with
581:57 - two arguments 15 and 0.
582:00 - so to divide function takes two
582:03 - arguments of type u8 and just divides it
582:06 - now this would also panic because we
582:10 - can't divide by zero this is a
582:12 - mathematical Rule and this will always
582:15 - lead to a panic so let's here divide by
582:18 - 1 for example
582:21 - let's see if this is compiling
582:27 - all right and again when we use the get
582:30 - method we will get back a reference to
582:33 - the value and not the actual value so
582:36 - let's change that
582:45 - and this is compiling
582:49 - detailed call SEC by default is stack
582:52 - unwinding will only give something like
582:54 - this
582:55 - so this would be the output if your
582:59 - program panicked though there is the
583:02 - reason of panic and the line of code is
583:04 - showing where the Panic has occurred
583:06 - sometimes you want to get more info
583:09 - about the call stack
583:12 - fill in the blank to display the hole
583:14 - called stack tips you can find the clue
583:16 - in the default Panic info so when we run
583:20 - cargo run this is basically how you
583:23 - execute a program you have written and
583:25 - will cover that then you just provide
583:28 - over here this rust back Trace equals
583:33 - one environment variable and it will
583:35 - then give you
583:38 - detailed information about the Panic
583:41 - that occurred
583:44 - so over here unwinding and abort by
583:47 - default when a panic accuracy program
583:49 - starts unwinding which means rust walks
583:52 - back up to stack and cleans up the data
583:55 - from each function it encounters
583:58 - but this work pack and cleanup is a lot
584:01 - of work the alternative is to
584:04 - immediately abort the program without
584:06 - cleaning up if in your project you need
584:10 - to make the resulting binary as small as
584:12 - possible you can switch from unwinding
584:15 - to aborting by adding below content to
584:18 - cargo.com
584:21 - so
584:22 - we can here Define in this cargo.tamil
584:25 - file and I will show you an example of
584:27 - that
584:29 - how Panic actually behaves so we have
584:32 - two
584:34 - um so we have two options here either
584:36 - unwinding or aborting when choosing a
584:40 - board here then the stack won't get
584:43 - unwinded meaning this will then be the
584:47 - responsibility of the operating system
584:49 - and not of the rust compiler
584:53 - alright see you in the next episode
584:57 - so we have seen the option type and the
585:01 - option type stands for a value that
585:03 - could potentially be absent so let's now
585:06 - look at the result type result is an
585:10 - enum type that represents the outcome of
585:13 - an operation that could potentially fail
585:16 - it has two possible variants okay a
585:20 - value T was found and error and error
585:23 - was found with a value e and as you can
585:27 - see the variance hold the specific
585:30 - information
585:32 - the expected outcome is okay the
585:35 - unexpected outcome is error since result
585:38 - is an enum the possible variance can be
585:41 - matched using a match pattern and that
585:44 - is what we call error handling
585:47 - so let's see an example
585:50 - let's again consider the divide function
585:54 - we have seen before so again we can't
585:57 - divide by zero meaning if the second
586:00 - argument here is 0 then we should return
586:05 - an error otherwise the program will
586:08 - Panic now we can do here error handling
586:11 - meaning we check if Y is zero right or
586:17 - in this case 0.0 because the arguments
586:20 - are floating Point numbers now in case y
586:24 - what's the value of 0 then we return the
586:27 - error variant of the result enum and we
586:31 - provide it an error message all right so
586:36 - in this case
586:38 - we use an explicit return keyword
586:42 - meaning when this returns it won't
586:48 - execute any further it will directly
586:52 - return the error type and stop execution
586:56 - now in case Y is not 0 then we will just
586:59 - divide X by Y and wrap it inside okay
587:03 - because remember result is an enum
587:07 - meaning we have two wrapped the
587:12 - resultant value inside the variant so
587:15 - that means when this function succeeds
587:18 - then we will get back an F 32 right the
587:24 - result of this operation and this is
587:27 - wrapped inside okay because as you can
587:29 - see we are returning a result type now
587:33 - in case of an error we would return this
587:37 - string over here wrapped in the arrow
587:40 - variant
587:47 - and this allows us then when we call the
587:50 - function divide with two arguments
587:54 - that we can then match the result we get
587:59 - back here as you can see we would get
588:01 - back a result type meaning the result
588:05 - type has two variants either okay or
588:09 - error and we can here use pattern
588:12 - matching to the structure the inner
588:16 - value for example this F32 into the
588:20 - variable Val which we then can print out
588:24 - and in case of an error we will get back
588:28 - this string over here the error message
588:31 - and we destructure it into this variable
588:34 - here and then print it out
588:39 - unwrap the unwrapped method takes as
588:42 - input a value of type result and takes
588:45 - out the value which is wrapped inside
588:48 - okay in case of success or panics in
588:52 - case of an error in case it returns an
588:55 - OK variant we just take the value that
588:59 - is wrapped inside
589:01 - otherwise the program will panic
589:05 - so you should use unwrap only if you're
589:08 - a hundred percent sure that the return
589:12 - variant will be okay otherwise you
589:16 - should use match
589:19 - and let's see the question mark operator
589:22 - the question mark operator is a
589:25 - shorthand way to propagate errors or
589:27 - unwrap OK results
589:30 - basically it's the same as unwrap but
589:33 - instead of panic it returns an error it
589:37 - replaces an entire match statement and
589:41 - can and it can even be used in the main
589:44 - function
589:47 - so as you can see over here in the main
589:50 - function we can Define here that main
589:53 - should return a result type
589:57 - and
589:58 - as you can see we have here a string
590:01 - holding a number then we try to parse
590:05 - this string over here into an i32 type
590:10 - now we have seen that the parse method
590:13 - could potentially fail right if we have
590:16 - here a string holding T for example the
590:20 - compiler can't convert it to an i32
590:23 - because it's not a valid number
590:26 - so in case we get back the OK variant
590:30 - remember parse will return a result if
590:34 - we get back okay then we just take the
590:38 - inner value and return it meaning the
590:42 - inner value will then be assigned to the
590:45 - number variable
590:47 - in case of an error we want to return
590:51 - meaning this over here won't get
590:55 - executed it will return before and we
590:59 - just provide the error message over here
591:04 - and in this case because we are using a
591:08 - function from the standard Library this
591:10 - error message is actually provided right
591:13 - so we just take the provided error
591:15 - message and return it
591:18 - and if this didn't fail it means this
591:22 - will get executed and we just print out
591:24 - the unwrapped number now because we
591:28 - return here a result type we have to
591:31 - also return an OK in case everything
591:34 - succeeded now because at the end of Main
591:39 - basically the end of the program has
591:42 - been reached so it doesn't make sense to
591:46 - return any meaningful value so we just
591:49 - return a unit type like that so I've
591:52 - told you that the question mark operator
591:54 - actually replaces an entire match
591:57 - statement meaning
592:00 - this over here would be exactly the same
592:03 - so let's see again we are in Main and we
592:06 - return a result
592:09 - now as you can see we have again a
592:12 - string holding a number
592:14 - then we try to parse over here and again
592:17 - pause returns a result so we have to
592:21 - handle the error case
592:23 - now we can do that appending to it the
592:27 - question mark operator
592:29 - meaning
592:30 - in case this succeeds
592:34 - and it returns an OK with the value in
592:38 - this case 10 but post as an integer then
592:42 - it will just assign it to this variable
592:44 - meaning number will then hold 10 as an
592:48 - i32
592:50 - in case this fails then it will return a
592:55 - pause int error as defined in the parse
592:58 - method
592:59 - okay
593:00 - so this over here is exactly the same
593:03 - like we did over here
593:06 - and when this returns an error
593:09 - the following lines won't be executed
593:13 - in case this succeeds then we have
593:17 - number which holds 10 of type i32 then
593:22 - we'll just print out the post number and
593:25 - then we return a unit type because
593:28 - remember we are here returning a result
593:31 - meaning we have to also return OK
593:33 - variant in case of success
593:38 - but again because we are in Main and
593:41 - this would be the end of the program we
593:43 - don't return any meaningful value we
593:46 - will return a unit type and there is
593:50 - also a concept called type Alias so it's
593:53 - basically just a way giving a name to an
593:57 - existing type
593:58 - so if you like to write u64 like this
594:03 - then you can create a type Alias meaning
594:06 - we can use the type keyword and provide
594:10 - a new name for a specific type and as
594:14 - you can see over here we are then using
594:16 - the new type we have created here and
594:20 - this would at compile time then be
594:22 - replaced with the real type
594:26 - and please don't confuse that with
594:29 - Associated types in trades they are
594:32 - different okay let's see result is an
594:35 - enum to describe possible errors it has
594:38 - two variants okay and error in short
594:42 - words the expected outcome is okay while
594:45 - the unexpected outcome is error
594:48 - so let's see fill in the blanks and fix
594:51 - the errors first of all we are importing
594:53 - the pause and arrow from the num module
594:57 - because we are using here the parse
594:59 - method meaning it will in case of an
595:03 - error return the parse and error
595:07 - now we have here the function multiply
595:09 - that takes two arguments of type string
595:12 - literals okay now
595:16 - as you can see we are here returning OK
595:19 - meaning
595:21 - the return type will be of type result
595:26 - and in case of success
595:30 - or let's actually wait with annotating
595:33 - that let's first see what's happening
595:35 - here so we are taking this string
595:37 - literal and try to parse it to an i32
595:41 - right so again this parse method over
595:45 - here will return a result
595:49 - in case of success we would have
595:54 - okay
595:57 - and the value that was paused so for
596:01 - example when we call here multiply with
596:04 - an argument of 10 for the first
596:06 - parameter then we would have a parsed
596:10 - number 10 right
596:12 - so we would have in case of success and
596:16 - I 32 here
596:18 - in case of an error we would have the
596:21 - parse into error
596:24 - like that
596:28 - and parsing terror is the error type
596:31 - that is defined for this method again
596:33 - this is implemented in the standard
596:35 - Library so this has to comply with what
596:39 - is defined there and N2 is exactly the
596:44 - same
596:45 - but for the second argument
596:49 - then over here
596:52 - we unwrap
596:53 - and remember unwrap will take a result
596:57 - and just unwraps the inner value so in
597:01 - case we have okay
597:04 - let's take the first argument 10
597:09 - then unwrap we'll just unwrap the inner
597:12 - value
597:13 - meaning it Returns the integer i32 right
597:18 - that is wrapped inside the result enum
597:23 - and
597:25 - then over here we are multiplying by N2
597:28 - again we have to unwrap because this is
597:31 - a result type
597:33 - and
597:35 - if this succeeds actually then we will
597:39 - return an OK meaning
597:43 - OK will then hold
597:49 - in this case 10 times 2 will be 20 right
597:57 - like that so we return an i32 in case of
598:02 - success
598:04 - in case of error we we will return a
598:09 - pause and error because that is the
598:11 - error that is defined from the parse
598:13 - method
598:16 - so let's see when we call multiply with
598:19 - these two string literals 10 and 2 then
598:22 - this should actually work right because
598:25 - the compiler is able to parse these into
598:29 - integers
598:32 - so it will pause here and this will then
598:35 - be okay
598:38 - 10
598:39 - and over here we would have okay 2.
598:44 - then we unwrap both of these over here
598:49 - meaning we unwrapped the value from the
598:51 - variant
598:53 - and here are two meaning we multiply 10
598:56 - by 2 and then this would be 20 and we
599:00 - wrap it inside okay because we have to
599:03 - return a variant of the result enum
599:07 - which means that the return type over
599:11 - here would be
599:13 - this right
599:16 - so result in case of success will hold
599:20 - ok
599:23 - and 20. right
599:27 - now in this case this would actually
599:29 - fail because the compiler can't convert
599:33 - T to an integer
599:35 - now we want this to actually assert to 8
599:39 - so let's do here four
599:42 - and this means this will get passed to
599:45 - four
599:47 - and this will get paused to 2 right
599:51 - and then again we just multiply these
599:54 - together and return it wrapped inside
599:57 - the OK variant
600:02 - meaning over here
600:05 - we get back a result
600:08 - and result will then hold ok
600:16 - and eight
600:21 - right now if we unwrap the result over
600:25 - here then it would unwrap the inner
600:28 - value
600:32 - as you can see so unwrap method allows
600:36 - us to unwrap the inner value so
600:40 - okay 8 would be unwrapped to eight
600:48 - question mark operator is almost exactly
600:51 - equivalent to unwrap but question mark
600:53 - operator returns instead of panic on
600:57 - error
600:58 - so let's see we have again the percent
601:00 - error Implement multiply with question
601:04 - mark don't use unwrap here
601:07 - so let's see again we are taking two
601:12 - arguments of type string literal right
601:15 - three and four in this case
601:18 - and
601:20 - let's start to implement so we declare
601:23 - here N1
601:25 - and we take N1 string
601:30 - and try to parse it into an i32
601:36 - right now again we should here use the
601:39 - question mark operator so we append it
601:43 - after the method call here
601:46 - and then we can only use the question
601:50 - mark operator when the return type of
601:54 - the function is a result right because
601:57 - the question mark operator
601:59 - in case of an error will return
602:04 - the error variant and inside it the
602:08 - error value so we return error a result
602:13 - in case of success it should be i32 and
602:17 - in case of failure it should be
602:19 - dispersed in error because again this is
602:22 - defined as the error return value of the
602:26 - parse method now for N2 we do exactly
602:31 - the same
602:42 - and that means if any of these fail then
602:46 - it will immediately return meaning the
602:51 - rest of the function won't get executed
602:53 - and a pause end error will be returned
602:57 - now the question mark operator in case
603:00 - of success it won't return a result it
603:04 - will unwrap so for example when we pass
603:07 - here 3 and this will get passed it will
603:11 - return
603:12 - okay and three
603:15 - right and then the question mark
603:17 - operator like unwrap will unwrap the
603:21 - inner value
603:24 - so N1 will then hold three meaning an
603:27 - i32 integer
603:30 - and N2 the same thing
603:39 - and then all we want to do is just
603:42 - returning and OK in case of success
603:45 - because the return type is result
603:49 - and we want to multiply N1 by N2
603:55 - notice over here that I didn't have to
603:57 - unwrap because we have here I 32 types
604:02 - right
604:03 - while over here we had to unwrap because
604:06 - this held result types
604:10 - you have to remember that
604:13 - let's see
604:21 - and of course I have to change that over
604:24 - here
604:25 - typo
604:27 - and this is compiling
604:29 - so what we had over here when we provide
604:32 - Forum as a string we would have okay
604:35 - four
604:37 - right and then the question mark
604:39 - operator unwrapistic value
604:42 - and then over here we are multiplying
604:45 - three by four which would be 12.
604:49 - then we wrap it inside ok to comply with
604:53 - the function signature
604:56 - so this will then be the returned value
605:00 - right
605:01 - and then over here as you can see we are
605:03 - calling the function and unwrap it
605:06 - because we have here a result type so we
605:10 - unwrapped the inner value
605:13 - because this would return okay 12. and
605:17 - we unwrap it meaning the inner value
605:21 - gets unwrapped
605:26 - let's see over here we have the file
605:29 - type from the fs module and over here we
605:33 - are importing some stuff from the i o
605:36 - module
605:38 - so over here we are opening a file
605:42 - providing here to the open Associated
605:44 - function the name of the file in form of
605:48 - a string literal meaning this will then
605:51 - return a result
605:53 - and in case of success it will hold a
605:57 - file right
606:00 - and in case of error it would be IO
606:03 - error
606:06 - all right
606:09 - and then we are matching f
606:12 - now F holds a result meaning we must
606:16 - over here handle both cases from
606:21 - in case of success and in case of
606:24 - failure so if it is okay then we unwrap
606:27 - the inner value meaning the file and we
606:31 - just assign it to f
606:36 - in case of an error we return the error
606:40 - wrapped inside the error variant of the
606:45 - result type
606:47 - right because this function over here
606:49 - returns a result
606:54 - all right
606:55 - and then over here we are creating a new
606:58 - empty string
607:01 - we then take F over here and read to
607:05 - string meaning the contents of this file
607:09 - over here will be copied to this string
607:13 - meaning s will then hold basically the
607:16 - contents of the file we have opened
607:20 - and we have to provide here a mutable
607:23 - reference because this is defined in the
607:26 - standard Library
607:27 - and then again because this read to
607:30 - string method returns a result we have
607:34 - to match it so in case of okay then we
607:39 - will return over here
607:41 - a string right this string s over here
607:45 - in case of error we will return the
607:49 - error
607:50 - and both of them
607:54 - file open and read to string return an i
607:59 - o error all right
608:05 - now over here fill in the blanks with
608:07 - one code line don't change any code
608:10 - lines
608:11 - as you can see we have here the function
608:13 - read File 2 which returns a result in
608:18 - case of success it's a string in case of
608:21 - error it will be the i o error from this
608:24 - standard Library we here declare a new
608:27 - string
608:28 - and we here initialize a new empty
608:31 - string
608:32 - and
608:33 - I told you that the question mark
608:35 - operator replaces a whole match
608:39 - statement
608:41 - so we can write all of this in one
608:44 - single line so first of all we are
608:47 - opening the file so let's take this
608:51 - and as we've seen open will return a
608:55 - result so we can use the question mark
608:58 - operator here to replace this whole
609:01 - match statement
609:04 - so in case of error it will immediately
609:08 - return and it returns this error type
609:13 - in case of success then
609:16 - we will get OK and a string and this
609:21 - will then unwrap it to the string right
609:27 - and in case of success we will have
609:30 - a value of type file like we saw over
609:35 - here and again file is a type defined in
609:39 - FS module
609:41 - so
609:42 - we have seen that the question mark
609:44 - operator will then unwrap we will
609:47 - basically get something like that
609:51 - and it will unwrap the file inside the
609:55 - OK variant
609:57 - what we then can do is call the read to
610:00 - string method on it right
610:05 - so we are calling read to string and
610:08 - then again we have to append this
610:10 - question mark operator because we need
610:13 - to string also returns a result type
610:16 - right so in case of success we'll then
610:20 - over here mutate s meaning the contents
610:25 - of this file will get read to this
610:29 - string all right or written to the
610:32 - string
610:34 - and then we just return s right the
610:38 - string and that means in case of success
610:41 - we will have as return type a result
610:44 - that is holding a string in case this or
610:49 - this fails then it will return an i o
610:52 - error meaning if this fails then over
610:57 - here a i o error gets returned and this
611:00 - will never be executed
611:03 - and if this fails again we return this
611:07 - error and this will never get executed
611:11 - let's see
611:15 - this is compiling
611:18 - map and then map and then are two common
611:22 - combinators for result t e also for
611:26 - option t
611:28 - so we have over here the parse into
611:31 - error fill in the blank in two ways map
611:34 - and then
611:38 - so we have here the function at 2 taking
611:42 - a string literal and returning a result
611:45 - in case of success holding an i32 in
611:49 - case of error parse and error all right
611:53 - because this is the default error type
611:55 - of the parse method
611:58 - then we are taking this then we are
612:00 - taking this string literal and try to
612:03 - parse it to an i32
612:08 - and then as you can see when we provide
612:11 - here at 2 with a string holding four
612:15 - then we want to get back six
612:18 - so as you can see when we provide four
612:21 - we will get back 6 over here and that
612:24 - means we want to parse this string and
612:28 - then add 2 to the post number and for
612:33 - that we can use map which is really
612:36 - convenient
612:39 - because we not only want to handle this
612:43 - result case but also then
612:46 - modify the value right so
612:51 - n here takes a closure and we will cover
612:55 - closures very soon so we provide here an
612:59 - argument n and n would then hold the
613:03 - parsed number and all we do is adding 2
613:08 - to n
613:10 - right
613:14 - and that's all so
613:18 - let's actually see the map
613:21 - method in the documentation
613:26 - as you can see maps a result te to
613:28 - result u e by applying a function to a
613:31 - contained okay value leaving an error
613:34 - value untouched
613:36 - so
613:38 - when we call the map over here
613:41 - it will perform it will apply a function
613:46 - if
613:48 - this method returns an OK value if it
613:51 - returns an error then it will leave it
613:55 - untouched
613:57 - all right so in this case this would
613:59 - actually succeed right so pause over
614:03 - here will pause this 4 into an i32
614:07 - integer meaning it will then take the OK
614:11 - value
614:12 - and unwrap it so n will then hold A4 and
614:17 - then we just add
614:20 - and
614:21 - and then we just add 2 to 4.
614:25 - right
614:27 - let's see
614:33 - and this compiles now the second
614:35 - approach would be using and then
614:39 - now and then is very very similar to map
614:44 - the difference is here
614:46 - in the
614:48 - closure that the end then method takes
614:52 - so let's go back to map here
614:55 - so over here you can see this is the
614:58 - argument for the closure right and the
615:02 - closure over here returns
615:05 - directly the value
615:08 - all right and over here it will the
615:12 - closure itself will return a result
615:16 - now both of these methods return results
615:19 - over here
615:20 - but the difference is in the closure and
615:24 - you will see what I mean when we are
615:25 - looking at this
615:27 - so
615:28 - this is very similar
615:32 - it will take this past integer and then
615:37 - put the unwrapped value into n and then
615:40 - over here we add 2
615:43 - to 2N now we have seen that map would
615:46 - work like that
615:48 - and and then method will actually return
615:51 - in the closure itself a result so we
615:55 - have to wrap that into ok
615:58 - like that but otherwise they are exactly
616:01 - the same
616:03 - and this succeeds
616:09 - number five with the return type we
616:12 - written we can use pattern matching
616:14 - without unweb but it's all verbose
616:18 - so here again we have the multiply
616:20 - function taking two string literals in
616:23 - case of success it returns an i32
616:27 - otherwise parse and error
616:30 - so over here we are using the match
616:33 - keyword now we want to pause the first
616:36 - string literally the first argument in
616:39 - case of okay then we destructure it into
616:43 - T variable N1 so N1 will then hold the
616:47 - parsed number in case of an error we
616:51 - just return the error type
616:54 - then we match inside this
616:59 - [Music]
617:01 - match arm over here again so we match
617:05 - the second argument parsing it and if
617:09 - this is okay then we get out and two all
617:12 - right and then we can multiply N1 by N2
617:17 - and return the result wrapped in the OK
617:21 - variant
617:24 - because as you can see the function
617:26 - returns a result type
617:29 - and in case of an error it just returns
617:31 - an error
617:33 - so this would be very verbose so
617:36 - rewriting multiply to make it succinct
617:39 - you should use both and then and map
617:42 - here
617:44 - so let's see
617:45 - we take first of all the n one star over
617:50 - here the first string literal all right
617:55 - then
617:57 - we want to parse it
618:02 - to an i32 integer right
618:07 - and let's then use and then
618:13 - so if this succeeds then we will have
618:16 - here n which holds the past integer
618:21 - right and let's actually
618:24 - write it more beautiful like that so we
618:28 - take then n
618:31 - or let's call it or let's call it N1
618:34 - just to make a distinction
618:37 - and then over here we want to parse the
618:40 - second one
618:46 - right we want here the second one
618:50 - and then if this also succeeds we want
618:53 - to multiply N1 and the post and two
618:57 - together so let's use a map here
619:01 - and we would here have N2 right because
619:04 - map over here is called upon the parse
619:07 - method so we would then get back and two
619:11 - and then we just return
619:14 - N1 times N2 and notice because we are
619:19 - using map here we don't have to wrap it
619:21 - inside okay right
619:24 - so this will then return
619:26 - for example when we call it by 10 and 2
619:30 - it will return 20.
619:33 - all right
619:35 - and
619:37 - and then we have seen that it will
619:40 - return the result type so in case of
619:44 - success it it will return okay with an
619:48 - i32 value inside otherwise it will
619:52 - return a pause end error let's see
619:59 - and this is compiling so as you can see
620:02 - when we are calling the multiply
620:04 - function with
620:06 - with 10 and 2 as string literals it will
620:12 - pause the first argument meaning we then
620:15 - have over here
620:18 - okay 10. right
620:22 - and then over here we call the end then
620:25 - Method All right so we take this N1
620:30 - value here
620:31 - basically unwrapping it
620:34 - and inside and then we parse the second
620:38 - number so in this case two right so this
620:41 - will then get parsed into an i32 and we
620:46 - then can map meaning we have N2 over
620:49 - here and two in this case would be okay
620:53 - 2 right
620:55 - and map will take an unwrap the value
620:59 - inside OK meaning we then have N2
621:03 - which holds two
621:06 - over here and then we multiply N1 by N2
621:10 - and return it all right
621:16 - and all we then do is here The Returned
621:20 - value would be of this type right
621:28 - and in this case this would return
621:33 - okay 20.
621:36 - right because it could parse these two
621:39 - numbers and it multiplied it and
621:42 - returned it so we get okay 20 then we
621:46 - pass that to the print function
621:49 - as you can see it takes as an argument a
621:52 - result type then we match it if it is
621:56 - okay then we print out the
621:58 - value wrapped inside okay in this case
622:01 - 20 otherwise we will print out the error
622:07 - and when we call multiply with an
622:09 - argument that can't be paused
622:13 - then you would get a pause int error
622:16 - right so this would then hold a percent
622:19 - error we are providing that 2D print
622:23 - function and then we match the argument
622:26 - this TT and this will then match the
622:29 - error meaning the error will get printed
622:33 - so in the first one so in the first
622:36 - print call n is 20 so we have
622:40 - successfully paused these two numbers
622:42 - and unwrapped the value printing it and
622:47 - in the second one because we provide
622:49 - here an argument that can't be paused we
622:52 - get
622:53 - and pause into arrow and this would be
622:57 - the error message that is provided in
623:00 - this standard Library
623:03 - so type Alias using this type over here
623:07 - everywhere is verbose and tedious we can
623:10 - use Alias for this purpose so at a
623:14 - module level creating aliases can be
623:17 - particularly helpful errors found in a
623:20 - specific module often has the same error
623:23 - type so a single Alias can succinctly
623:26 - Define all Associated results this is so
623:31 - useful even the standard Library even
623:33 - supplies one IO result
623:37 - so as you can see we have here again the
623:40 - pulse and error and we want here to
623:43 - create a type alias
623:46 - now we have here the same multiply
623:50 - function we have seen above so I won't
623:52 - cover that anymore but the return type
623:56 - is defined as res i32
624:01 - and the print function over here takes
624:03 - as an argument a type of rice i32
624:08 - now as you can see exactly the same
624:11 - functions as we had over here
624:14 - but we don't write out the whole type we
624:18 - use here A type Alias so we can Define
624:21 - that here
624:24 - we use res
624:26 - i32 and we want to Define that as a
624:30 - result
624:32 - in case of success holding an I30 tool
624:35 - in case of an error
624:38 - as you can see the parse method would
624:40 - return a parse and error
624:44 - and then instead of writing that all the
624:47 - time in our functions we can use this
624:50 - simple type alias
624:53 - and of course at compile time
624:56 - these type aliases will then get
624:58 - replaced with this
625:01 - concrete type here
625:04 - let's see
625:10 - and as you can see the same output as
625:12 - before
625:13 - using result in F and Main typically the
625:16 - main function will look like this
625:19 - however main is also able to have a
625:22 - return type of result if an error occurs
625:26 - within the main function it will return
625:28 - an error code and print a debug
625:31 - representation of the error debug trade
625:34 - the following example shows such a
625:37 - scenario
625:39 - so as you can see we have here again the
625:41 - percent error and we Define here in the
625:44 - main function that the return type
625:46 - should be of type result in success
625:50 - returning a unit type in case of error
625:54 - it will return a parse and error so over
625:57 - here we have a string literal
626:01 - and we are then trying to parse this
626:05 - string literal to an i32 now again pulse
626:11 - returns a result so we have to handle
626:13 - both cases in case of ok we just take
626:17 - the wrapped value and assign it to
626:21 - number right in this case this would
626:23 - hold an i32
626:26 - in case of an error it will just return
626:29 - the error and it will stop execution
626:32 - from this point
626:36 - and then all we do is we will print out
626:39 - the number so let's see if this is
626:41 - compiling
626:44 - as you can see this is compiling we are
626:46 - printing out the number and don't forget
626:49 - because we return a result type here we
626:53 - have to return
626:56 - the result variant okay with a unit type
627:00 - in case of success we provide here a
627:04 - unit type to the OK variant because
627:08 - the end of main means the end of the
627:11 - program because the end of main means
627:14 - the end of the program so we don't have
627:16 - to actually return anything here right
627:19 - because if the program ends this
627:22 - returned value won't be beneficial but
627:26 - we can just provide the unit type so we
627:30 - comply with the function signature
627:33 - and by the way as we've seen we can here
627:38 - just use the
627:41 - question mark operator so we can replace
627:43 - this match statement by this
627:47 - and this is actually the reason most
627:50 - people use here in main the result type
627:54 - because then it allows us that we use
627:57 - the question mark operator otherwise if
628:00 - we didn't have result here we can't use
628:03 - this operator
628:06 - let's see
628:11 - of course I have to remove the match
628:14 - keyword here
628:17 - and as you can see this would be the
628:19 - same thing
628:21 - all right see you in the next topic
628:23 - let's take a look at cargo now cargo is
628:27 - the official package manager and
628:29 - building tool in Rust it helps automate
628:33 - tasks such as creating new projects
628:35 - building running testing code and
628:38 - managing dependencies a crate is a
628:42 - compilation unit of rust source code so
628:46 - basically a crate is the smallest amount
628:49 - of code the RAS compilers considers at a
628:53 - time and crates.io is the repository for
628:57 - rust packages
629:14 - so as you can see this is the website of
629:17 - crates.io and here you find
629:22 - some libraries for example we have here
629:24 - the rent Library
629:27 - and this allows for creating random
629:31 - numbers
629:35 - and as you can see you can add this very
629:39 - quickly into your own project and we'll
629:42 - see how this will work
629:45 - what is a crate a crate can be of two
629:48 - types either it's a binary crate and
629:51 - that means the program is compiled into
629:54 - an executable binary it's basically a
629:57 - program you can run and binary crates
630:01 - always have the main function in it
630:04 - and a library create a library create is
630:07 - compiled into a library and it doesn't
630:10 - contain a main function but it's
630:14 - considered a collection of reusable code
630:17 - that can be shared across multiple
630:20 - projects
630:22 - and the create route is the source file
630:25 - that is the root module of the crate in
630:29 - binaries it would be source main.rs and
630:33 - in libraries it would be the file lib
630:36 - dot RS
630:40 - then we have modules and a module is a
630:44 - way of organizing code by grouping
630:46 - together related items modules can be
630:50 - imported using namespaces avoiding
630:54 - naming collisions
630:56 - it also controls the privacy of its
630:59 - items like functions trucks enums and so
631:02 - on when compiling the compiler starts
631:05 - from the create route we have seen in a
631:08 - binary crate this would be in main.rs
631:12 - and in a library it would be lib.rs
631:17 - then it checks if the modules are
631:19 - declared and looks for sub modules
631:23 - sub modules could be directly written in
631:26 - line with curly braces it could be
631:29 - written in a separate file which has the
631:33 - module name ending in dot RS or it could
631:37 - be in a separate director which has the
631:40 - same name of the module and a mod.rs
631:44 - file inside it and we'll do exercises
631:47 - and you will see how that works so in
631:50 - case you want to follow these exercises
631:53 - you actually have to install rust on
631:56 - your system so you can go to
631:58 - rosslang.org
632:00 - and then you can click install
632:05 - and over here it will give you a command
632:08 - you can copy
632:11 - then running a terminal
632:17 - and you can just copy
632:20 - this into your terminal now I'm on a
632:24 - Unix like operating system meaning
632:27 - I will use the Linux command but the
632:32 - website will recognize your operating
632:35 - system and provide the appropriate
632:37 - command so if you're on Windows it will
632:40 - give you a command that you can paste
632:44 - into Powershell for example
632:47 - so proceed with installation default you
632:50 - can then press 1 and enter now I have
632:54 - already
632:55 - downloaded that so I want
632:59 - um run it again
633:01 - and then to check if everything is
633:04 - installed correctly you can use these
633:06 - commands
633:10 - first of all we check is the RAS
633:13 - compiler installed if you get back a
633:15 - version it means everything is installed
633:18 - then we check for cargo
633:21 - [Applause]
633:23 - this is fine and rust up
633:29 - and rust up is used for
633:32 - um updating the version of rust on your
633:36 - local system
633:40 - all right
633:43 - all right so let's now see the exercises
633:46 - a package is a project which you create
633:49 - with Cargo in most cases so it contains
633:51 - a cargo.tomel file in it
633:55 - so create a package with below layout
634:00 - now I will do that directly in the home
634:02 - directory but you can do it at any
634:04 - location you want
634:06 - so
634:07 - to create a new package we can use cargo
634:13 - new
634:14 - and then provide the name of the package
634:17 - so we want the name here to be hello
634:19 - package
634:27 - and as you can see that we
634:33 - and as you can see the package has been
634:35 - created so let's C CD hello package and
634:42 - we are now inside our created package
634:46 - right so we have here cargo Tamil and a
634:49 - source directory let's see source
634:55 - and if I print out the contents in main
634:58 - as you can see it contains a simple
635:02 - program
635:03 - that prints out hello world
635:06 - so
635:12 - let me actually
635:14 - do it like that
635:16 - so over here if I now do A3 command
635:22 - as you can see we have exactly the same
635:24 - file structure here we have a cargo
635:27 - Tamil and then resource directory with
635:31 - main.rs inside
635:33 - let's print out the cargo toner
635:39 - and as you can see this matches the file
635:42 - in the exercise
635:46 - create a package with below layout
635:51 - so over here we want to create a library
635:56 - so I'm back in my home directory and we
635:59 - can create the library create right now
636:03 - let's do Park on you then the package
636:05 - name here
636:09 - and then we have to write the lib flag
636:12 - right so this will then create a library
636:18 - and then let's CD into that
636:26 - as you can see we have corgotomel and a
636:29 - source directory
636:30 - now
636:32 - let me print out the cargo thermal file
636:39 - and as you can see again this matches
636:42 - and if we go to the source directory
636:47 - as you can see over here we have a
636:51 - lib.rs file and this just has a basic
636:55 - add function over here together with
636:58 - some tests
637:01 - all right
637:06 - fill in the blank with your answer
637:08 - what's the difference between package
637:10 - number one and package number two
637:14 - now the difference would be package
637:16 - number one is a binary crate
637:24 - and package number two is a library
637:27 - crate
637:34 - all right
637:39 - create a crate is a binary or library to
637:43 - create rules
637:45 - the create route is a source file that
637:47 - the rascompiler starts from and makes up
637:51 - the root module of the crate
637:53 - in package hello package there is a
637:56 - binary create with the same name as the
637:58 - package hello packet and source main.rs
638:03 - is the create root of this binary crate
638:08 - similar to hello package hello package
638:10 - one also has a crate in it however this
638:13 - package doesn't contain a binary crate
638:16 - but a library crate and source lib.rs is
638:21 - the great root
638:24 - so what's the name of the library crate
638:27 - in package hello package one the answer
638:31 - would be it would be hello package one
638:34 - right because as we've seen over here in
638:38 - the package hello package there is a
638:41 - binary crate called hello packet
638:45 - and that means in a package hello
638:47 - package one
638:48 - the name of the library crate would be
638:52 - hello package one and by the way a
638:55 - package is what we have seen over here
638:59 - basically
639:01 - when we create a new project right when
639:05 - we create a new project we create a new
639:08 - package and the package consists of a
639:11 - cargo.tomel file and a source directory
639:14 - together with other stuff
639:21 - add a library create for hello package
639:24 - and describe its files 3 below
639:29 - alright so we want to add in the hello
639:32 - package
639:34 - a library crate
639:41 - so let me remove this over here
639:45 - and we will go inside hello package
639:49 - now over here in this Source directory
639:54 - we want to create a new library create
639:56 - as you can see we have until now a
639:59 - binary crate so let's create
640:03 - a lib dot RS touch is a Linux command
640:07 - that allows to create a new file
640:10 - so then we would have lib RS and Main RS
640:16 - so when we look at T3
640:20 - as you can see we then have the cargo
640:22 - terminal The Source directory and two
640:25 - crates one Library crate and one binary
640:28 - crate
640:31 - so this will then hold lip.rs
640:34 - and main.rs
640:40 - after this step there should be two
640:43 - crates in package hello package a binary
640:46 - crate and a library crate both with the
640:49 - same name as the package
640:52 - a package can contain at most one
640:56 - Library crate but it can contain as many
640:59 - binary crates as you would like by
641:01 - placing files in Source bin directory
641:05 - each file will be a separate binary
641:08 - crate with the same name as the file so
641:11 - create a package which contains three
641:14 - binary crates hello package main one
641:17 - main two one Library create
641:21 - so what we want over here is to have in
641:23 - this Source folder the lib.rs
641:28 - and main.rs
641:31 - then inside the source folder we want to
641:35 - have a bin directory which holds main 1
641:40 - and Main two
641:46 - right
641:47 - so
641:53 - so as we've seen we can have as many
641:55 - binary crates as we want in a package
641:58 - but only one Library create
642:02 - and over here we have some other
642:04 - directories so we have tests for
642:07 - integrated tests benches for Benchmark
642:10 - and examples
642:13 - so let's create these over here
642:23 - so as you can see inside source we
642:25 - already have a library crate and a
642:27 - binary crate now we want to create a new
642:30 - directory
642:32 - called bin
642:36 - then we see the into bin and we create
642:41 - main1.rs and main2.rs
642:46 - so again when we go to the
642:49 - root of the package as you can see we
642:52 - have cargo terminal The Source directory
642:55 - we have inside the source directory a
642:58 - bin directory holding two binary crates
643:01 - main one main two and we have in the
643:04 - source directory
643:06 - lib.rs and main.rs
643:12 - yep as you can see the above package
643:15 - structure is very standard and is widely
643:18 - used in many rust projects
643:21 - so let's see modules modules let us
643:24 - organize the code within a crate into
643:26 - groups for readability and ease of reuse
643:30 - module also controls the privacy of
643:33 - items which is which is whether an item
643:37 - can be seen by outside code public or
643:41 - it's just an internal implementation and
643:44 - not available for outside code private
643:48 - we have created a package named hello
643:51 - package in previous chapter and it looks
643:54 - like this now we actually created over
643:57 - here a bin directory so let's delete
644:00 - that
644:04 - I go into source and then remove the bin
644:07 - directory
644:13 - so as you can see T3 looks exactly the
644:16 - same
644:19 - now it's time to create some modules in
644:21 - the library create and use them in the
644:24 - binary crate let's start
644:27 - so as you can see we can
644:31 - Define some code in the library create
644:34 - and then use it in the binary crate
644:38 - so Implement module front of house based
644:41 - on the module tree below
644:44 - so in the library create we want to
644:47 - create a module front of house
644:49 - and this should then hold two sub
644:53 - modules hosting and serving now hosting
644:57 - holds two functions and serving holes
645:00 - for functions
645:03 - so as you can see
645:06 - we will do that in the library crate all
645:09 - right
645:10 - and again modules allow us to structure
645:13 - our code
645:17 - so
645:20 - [Applause]
645:23 - let's open lib.rs and I will copy this
645:27 - over here so we have to implement front
645:30 - of house
645:32 - now we have seen that front of house
645:34 - module should contain two sub modules
645:38 - namely hosting and serving
645:52 - like that so we have a front of house
645:56 - module that contains two sub modules
645:59 - hosting and serving
646:02 - now we want to add these functions over
646:05 - here add to wait list and see it at
646:08 - table in the hosting module
646:15 - uh
646:18 - at waste list
646:21 - adds to wait list
646:27 - and
646:28 - see it at table
646:34 - so as you can see front of house
646:36 - containing one sub module hosting
646:38 - holding two functions over here
646:42 - now let's see serving
646:46 - I will just copy that
647:08 - like that and
647:19 - doing it like that as you can see it is
647:22 - serving module holds three functions
647:33 - and when we run the code actually
647:39 - we can use the cargo run command
647:43 - and as you can see this is compiling but
647:45 - it gives us warning that we didn't use
647:49 - these functions over here which is okay
647:53 - and of course hello world will get
647:55 - printed from the binary crate
648:00 - right because main just prints out hello
648:04 - world
648:08 - let's call add to waitlist from a
648:10 - function eat at restaurant which is
648:13 - within the library create route
648:15 - so inside lib.rs
648:18 - we are below
648:21 - the module front of house we are
648:24 - creating a new function
648:36 - like that call add to wait list with
648:40 - absolute path
648:42 - so it's like in a file system you can
648:44 - have absolute paths and you can have
648:46 - relative paths so in this case we want
648:50 - to use the absolute path to the add to
648:54 - wait list
648:55 - function over here
648:57 - so we would use for the absolute path to
649:01 - create root
649:02 - then we want the front of house module
649:07 - and we want the sub module hosting right
649:14 - and then over here we can call the
649:17 - function like that add to wait list now
649:21 - this would be considered the absolute
649:24 - path
649:26 - now over here we are using the relative
649:29 - path so we are actually already in the
649:32 - create route right so that means we
649:35 - don't need to use crate here we can
649:37 - directly access front of house
649:46 - hosting
649:49 - and then call the add to wait list
649:53 - function
649:57 - now as you can see it gives me here an
650:00 - error
650:01 - module hosting is private so we can make
650:06 - this public using the pub keyword all
650:09 - right
650:11 - now the same thing with the functions
650:13 - let's make them public
650:16 - like that
650:21 - you can use super to import items within
650:24 - the parent module
650:26 - so
650:28 - again in lib.rs we want to create
650:31 - another module so let's copy that
650:38 - put it below the front of house
650:42 - and as you can see over here we have the
650:44 - back of house module with two functions
650:48 - declared inside it
650:51 - so we have fixed incorrect order and
650:55 - inside this function we call the cook
650:57 - order function over here
651:00 - fill in the blank in three ways using
651:03 - keyword super using absolute path
651:14 - so in order to access the function over
651:17 - here serve order let's first use this
651:21 - super keyword so super means we go one
651:25 - level up right so we are here inside the
651:29 - module back of house we go one level up
651:32 - which would be the create route right
651:35 - lib dot RS so we use super
651:40 - and then we can access front of house
651:45 - and I guess hosting
651:47 - no serving and serve order
651:59 - like that and again serving is private
652:02 - let's do that
652:03 - let's make it a public function
652:10 - and again serving here is private so
652:13 - let's make that public
652:15 - and also the function here
652:19 - like that
652:21 - and the second way would be using
652:24 - absolute path so again you can use here
652:26 - create right create would refer to
652:31 - lib.rs because it is the great root of
652:35 - this package
652:40 - separating modules into different files
652:45 - so
652:47 - as you can see we want to put these
652:52 - modules into their own distinct files
652:56 - please separate the modules and codes
652:58 - above into files resident in below third
653:02 - three
653:03 - so as you can see we have here Main and
653:06 - leap RS crates and here we have the
653:11 - modules we want to split up so we have
653:14 - the module front of house
653:17 - holding hosting and serving this r sub
653:21 - modules and mod.rs and we have over here
653:26 - back of house.rs now we have said that
653:30 - there are three ways to declare modules
653:34 - right the first way would be in the
653:37 - create route for example lib.rs we
653:41 - Define
653:43 - in module and put it right inside the
653:48 - curly braces right all the code is
653:51 - inside these curly braces right the
653:55 - second way would be
653:57 - two
654:00 - in lib.rs
654:02 - declaring the back of house module but
654:06 - without curly braces right only
654:09 - declaring like this for example
654:18 - only declaring the module
654:21 - and that means the compiler will then
654:23 - check
654:24 - is there in Source directory a file
654:29 - named as the same name as we gave it to
654:33 - the module right so we declared a module
654:37 - in lib.rs and then we have to create a
654:40 - file ending in dot RS with the same name
654:44 - as the module we have declared
654:48 - and the Third Way would be if we want
654:51 - the module to be a subdirectory of
654:56 - source then we have to again declare
654:59 - front of house inside lib.rs the same
655:03 - way we did before
655:05 - but we create a directory instead of a
655:09 - file with the same name as the module
655:14 - and then very important
655:16 - the code of the module will then be in
655:20 - mod.rs now in our case we are declaring
655:24 - in
655:25 - mod.rs2 sub modules hosting and serving
655:30 - all right
655:33 - so we want to have this code separated
655:36 - in different files and this is how it
655:39 - should look like
655:41 - so let's start
655:45 - with back of house
655:48 - all right
655:49 - I will copy that
655:54 - and first of all
655:59 - I will delete anything in here
656:04 - and let's declare the module back of
656:09 - house
656:10 - right
656:12 - now we have here declared a module as
656:15 - you can see the file is not found so we
656:18 - can here declare
656:20 - and
656:22 - back of house
656:26 - dot RS
656:28 - and then we can put
656:41 - and then we can put the code of the back
656:45 - of house module directly into this pack
656:48 - of house file removing this over here
656:51 - because we have already declared
656:54 - T module and as you can see back of
656:58 - house file now contains
657:01 - only the code related to this module
657:05 - again we have in lib.rs
657:09 - declared the back of house module then
657:13 - we have over here created a file that
657:18 - has the same name as
657:21 - the module right and in here we are
657:25 - providing the code
657:29 - like that
657:31 - and because we have already declared the
657:34 - back of house module we don't have to
657:36 - redeclare it inside here right
657:41 - now as you can see we also want front of
657:46 - house now the difference is front of
657:48 - house should be a directory holding two
657:52 - sub modules
657:54 - so let's first of all
657:56 - in lib
657:58 - we want to declare front of house module
658:04 - like that
658:08 - then we create the directory with the
658:12 - same name as the module
658:16 - foreign
658:19 - like that
658:23 - then the first thing is we create a file
658:27 - mod.rs this is now
658:30 - the create root of this this will be
658:34 - considered the root of this module
658:37 - mod.rs
658:41 - and as you can see we want here inside
658:45 - front of house two sub modules hosting
658:49 - and serving let's declare them
658:57 - like that
658:59 - and then we can create both of these
659:03 - files let's start with hosting
659:09 - and we just take all the code from the
659:13 - hosting module here
659:22 - like that and let's create serving
659:30 - and we just take the code here from this
659:34 - serving module
659:38 - like that
659:40 - let me remove the comment
659:46 - so
659:50 - and now if we go back
659:53 - to the source directory
659:59 - as you can see we have back of house
660:01 - this is a module we have front of house
660:04 - hosting and serving these are two sub
660:09 - modules and we have here
660:12 - mod.rs exactly like we wanted here now
660:17 - over here by the way
660:19 - this function eat at restaurant will be
660:21 - directly in the lib.rs
660:36 - so as you can see instead of defining
660:40 - the module and putting all the code in
660:43 - curly braces meaning inline
660:46 - we can use
660:50 - um different files to restructure and
660:53 - reorganize our code and this makes the
660:57 - lib.rs file much more clean and readable
661:06 - assessing code in library create from
661:09 - binary crate please ensure you have
661:11 - completed the fourth exercise before
661:13 - making further progress you should have
661:16 - below structures and the corresponding
661:19 - codes in them when reaching here
661:22 - so we have done that
661:25 - now we will call a few Library function
661:28 - now we will call a few Library functions
661:31 - from the binary crate
661:34 - so let's copy that into the binary crate
661:54 - like that now we want to call a function
661:59 - so the output should be sit down please
662:02 - and then a second function which returns
662:05 - yummy yummy now
662:08 - as you can see over here
662:11 - we have to call the eat at restaurant
662:14 - function
662:16 - to get back yummy yummy and sit down
662:20 - please would be in the front of house
662:22 - module in hosting and seat at table
662:27 - function so let's see first of all I
662:31 - want here the module front of house
662:37 - right because the binary crate and the
662:40 - library create are separate from each
662:42 - other so the binary crate over here
662:44 - can't know what is defined in the
662:48 - library crate
662:50 - and then over here we can SD create
662:54 - module
662:55 - and then here we can use an absolute
662:59 - path providing the create route now we
663:02 - have to actually provide here
663:04 - the name of the crate meaning hello
663:09 - package all right
663:11 - and then we can call font of house
663:16 - and
663:18 - let's see
663:20 - front of house hosting seat at the table
663:28 - at table
663:31 - like that
663:38 - and then over here we call hello package
663:42 - and then eat at restaurant
663:46 - this is defined in our
663:50 - lib.rs so again instead of writing here
663:54 - a crate
663:57 - we write the name of the package because
664:00 - we are here in the binary crate so we
664:03 - can use the create keyword in lib.rs but
664:07 - in main.rs we have to write the name of
664:11 - the package
664:13 - let's run that
664:18 - and as you can see we have some errors
664:21 - module serving is private
664:24 - and module hosting is private
664:29 - so to actually access that
664:33 - from the binary crate we have to make
664:35 - them public
664:37 - so let's see
664:43 - first of all we go to lib.rs and we want
664:46 - these two modules to be public so let's
664:50 - make them pop like this which means that
664:54 - these two modules are now accessible for
664:57 - our binary crates the main.rs file then
665:01 - let's go to
665:03 - um front of house
665:08 - and let's here make these two modules or
665:11 - these two sub modules also public
665:17 - like that
665:18 - and
665:23 - if the module itself is public that
665:28 - doesn't mean that the inner functions
665:30 - for example or structs or anything that
665:33 - is inside the module is also public so
665:35 - we have to declare here as you can see
665:38 - this is already done that these
665:40 - functions are also public if we want to
665:43 - access it
665:48 - and as you can see serving also has the
665:51 - public functions
665:53 - now let's check again in lib.rs because
665:56 - we are calling here a function all right
665:59 - this is also public
666:02 - let's run it again
666:07 - and as you can see this is actually
666:09 - compiling it just over here
666:12 - and complaints that we didn't use some
666:15 - of the functions which is okay at the
666:18 - moment
666:21 - now instead of just assorting let's
666:23 - actually print that out
666:36 - and let's do it like that
667:06 - as you can see the output will be sit
667:08 - down please
667:12 - let's call the second one
667:20 - so we want to get this
667:28 - like that
667:34 - let's see
667:41 - all right
667:48 - I copied here the holy uh
667:52 - I copied here the whole assert
667:55 - we don't need this actually let's see
668:01 - and as you can see the output will be
668:03 - sit down please and yummy yummy
668:08 - so we have successfully restructured and
668:11 - reorganized our whole code into
668:14 - different files and folders meaning it
668:17 - is much more organized and much more
668:21 - readable
668:25 - all right see you in the next topic
668:28 - we will now take a look at the debug and
668:31 - display trades so types which want to be
668:34 - printable must Implement either debug or
668:38 - the display trades
668:40 - and automatic implementations are only
668:44 - provided for types in this standard
668:47 - Library so this doesn't apply to our
668:50 - customly created types
668:52 - a debug trade can be implemented by
668:55 - simply using derivable trade
668:58 - and a display trade must be manually
669:01 - implemented
669:04 - let's see
669:05 - we have here print Ln and format
669:08 - printing is handled by a series of
669:11 - macros defined in standard format some
669:15 - of which include format write formatted
669:18 - text to string
669:20 - print same as format but the text is
669:24 - printed to the console print Ln is the
669:27 - same as print but a new line is appended
669:31 - ePrint is the same as format but the
669:34 - text is printed to the standard error
669:38 - and e-print Ln same as e-print but a new
669:42 - line is a pendant
669:44 - all parse text in the same fashion
669:48 - all porous text in the same fashion as a
669:51 - plus rust checks format correctness at
669:54 - compile time
669:56 - so let's see we have here a string
669:58 - literal
670:00 - and we use here the format macro meaning
670:04 - the return type will be string
670:08 - and we want here s to hold a string of
670:12 - hello world
670:14 - so again we use the format macro like we
670:17 - would use the print L and macro we have
670:19 - been using so in this case we want to
670:22 - take S1 over here
670:26 - and then just append the rest
670:30 - so we take hello this will be placed
670:32 - here and then the rest
670:41 - and this is compiling
670:43 - let's actually print that out
670:53 - as you can see this would be the output
670:56 - when printing out s
671:00 - print print Ln fill in the blanks to
671:03 - make it print a hello world I am and
671:06 - turn on the new line Sun face
671:09 - so over here we want to use print
671:12 - because as you can see I am should be on
671:16 - the same line
671:18 - so as we've seen print macro doesn't
671:21 - append a new line character
671:24 - now a new line is defined in C
671:28 - like that all right and this is a symbol
671:33 - that the compiler knows that it should
671:36 - treat it as a new line but in this case
671:40 - print doesn't append it so the next line
671:43 - will be on the same line as this print
671:47 - statement
671:50 - so let's use here print Ln
671:53 - because as you can see after I am we
671:56 - want to have a new line
671:59 - and then over here we can again use
672:01 - print Ln
672:11 - and this would be the output
672:18 - debug and display so all types which
672:21 - want to be printable must implement the
672:24 - standard format formatting trade debug
672:28 - or display
672:29 - automatic implementations are only
672:32 - provided for types such as in this
672:35 - standard Library all others have to be
672:38 - manually implemented
672:40 - let's first look at debug
672:44 - the implementation of debug is very
672:47 - straightforward all types can derive the
672:50 - debug implementation this is not true
672:53 - for display which must be manually
672:55 - implemented
672:57 - and we have used that before this is the
673:00 - debug notation must be used to print out
673:03 - the type which has implemented the debug
673:06 - trade
673:08 - so as you can see over here we have a
673:11 - custom type
673:13 - this structure cannot be printed either
673:16 - with display or debug to make this
673:20 - struct printable with debug we can
673:23 - derive the automatic implementations
673:25 - provided by rust
673:28 - so again we can use a derivable trait
673:31 - meaning this struct over here implements
673:35 - the debug trade meaning we can print it
673:38 - out using debug notation
673:43 - so fill in the blanks and fix the errors
673:46 - as you can see we have here a custom
673:48 - type structure holding an i32 value
673:52 - types in standard and rust have
673:55 - implemented the debug trade
673:58 - so as you can see this is of type i32
674:02 - now all of the types in the standard
674:04 - Library have implemented debug or even
674:08 - display so we can use here
674:11 - to display notation
674:13 - and this will print out fine now over
674:16 - here we must use debug notation
674:21 - because this is a type that we have
674:24 - created and again to use the debug
674:27 - notation we have to derive the debug
674:30 - trade
674:38 - like that
674:40 - and that means structure implements the
674:43 - debug trait and we can then print it out
674:46 - so this i32 type will be printed
674:49 - automatically because it's a type
674:52 - defined in this standard library and
674:54 - over here we just had to derived debug
674:58 - trade and then use debug notation here
675:03 - so format debug definitely makes one
675:06 - type printable but sacrifices some
675:08 - Elegance
675:10 - maybe we can get more elegant by
675:13 - replacing this notation with something
675:16 - else but not this
675:20 - alright let's see we have here
675:23 - a custom type that derives the debug
675:26 - trade
675:28 - then we are here instantiating it
675:32 - and when we now execute the program
675:37 - as you can see the output will be like
675:40 - this now we want the output to look
675:42 - something like that and we can for that
675:45 - use the pretty notation
675:47 - just adding this hashtag symbol between
675:50 - the colon and the question mark
675:55 - and then the output should look much
675:58 - more pretty
676:00 - as you can see the output will then be
676:03 - like this
676:04 - and notice we first had to derive the
676:08 - debug trade in order to print it out
676:11 - using debug notation
676:15 - we can also manually Implement debug
676:18 - trade for our types
676:21 - so as you can see we have here two
676:23 - custom types structure and deep
676:26 - now structure holds a type of i32 and
676:30 - depos a type of structure meaning
676:35 - these are basically nested so we have
676:38 - keep
676:40 - which holds a structure
676:44 - which holds an i32 right
676:48 - the problem with derive is there is no
676:51 - control over how the results look what
676:55 - if I want
676:56 - what if I want this to just show A7
677:00 - so as you can see we are here
677:03 - instantiating it with a value of 7. now
677:07 - when we print it like that then as you
677:10 - can see the whole structure will get
677:12 - printed out but we only want tip value
677:15 - over here
677:16 - so what we can do is we implement the
677:19 - debug trade manually meaning we can
677:23 - manipulate the output
677:25 - so let's see the debug trade in the
677:28 - documentation and as you can see this is
677:31 - the debug trade as defined in this
677:34 - standard Library so let's copy this
677:37 - function signature
677:40 - so we can then over here implement the
677:43 - debug trade
677:47 - and this is found in a module M and this
677:51 - is inside the module fmt from the
677:54 - standard library and we want to
677:56 - implement it for the Deep over here now
678:01 - we remove that
678:04 - and we also remove that because we are
678:06 - implementing debug trade manually right
678:09 - we don't need the derived implementation
678:14 - so let's see deep
678:17 - then I will copy the
678:19 - function signature
678:22 - so here we can use a custom type fmt
678:25 - result
678:32 - and you know what we can use a namespace
678:34 - here
678:37 - so then we don't have to write here
678:39 - standard all the time
678:42 - like that I can delete this lifetime
678:47 - and now we can implement the debug trade
678:51 - namely this fmt method
678:55 - so again we want to write to a buffer so
678:58 - we will still write macro
679:02 - and it should write to this formatter
679:05 - which is provided by the debug trade
679:11 - and then over here all we want to
679:14 - actually print out is
679:17 - in this case self right the instance
679:21 - over here
679:23 - and then we access the first element so
679:27 - when we access the first element in a
679:31 - tuple we use the dot notation like that
679:34 - and inside here we have now accessed
679:38 - structure and we want to access
679:41 - this value this structure
679:44 - struct holes right so we again use zero
679:49 - and that's basically it now it should
679:52 - print out
679:57 - and of course over here
679:59 - fmt formatter this is also from the fmt
680:03 - module and as you can see now 7 will
680:07 - print
680:08 - so all we did over here is manipulating
680:11 - how the output of the debug trade looks
680:15 - like when we use debug notation
680:18 - and as you can see we have defined for
680:20 - the Deep custom type over here how the
680:24 - output should look like so the output
680:27 - will just be the inner element of deep
680:31 - and structure right this i32
680:35 - and we just access that and write it to
680:39 - this buffer
680:41 - all right
680:44 - display here debug is simple and easy to
680:47 - use but sometimes but sometimes we want
680:50 - to customize the output appearance of
680:53 - our type this is where display really
680:56 - shines unlike debug there is no way to
680:59 - derive the implementation of the display
681:02 - trade we have to manually implement it
681:05 - another thing to note the placeholder
681:09 - for display is this and not that so this
681:13 - would be for debug trade for display we
681:17 - are using that and you know that already
681:20 - so make it work as you can see again we
681:23 - are using the fmt module and we have a
681:27 - custom type 0.2d holding two fields of
681:31 - type f64.
681:33 - now we want to implement the display and
681:37 - the debug trade for this custom type
681:40 - meaning when we instantiate this point
681:43 - 2D
681:47 - then we can pass the instance over here
681:50 - and it will
681:53 - give us this output right so we are
681:56 - using here the display notation and
681:59 - debug notation
682:01 - and as you can see we can here Define
682:03 - different outputs
682:05 - so when we pass an instance of point
682:09 - then the display trade actually will
682:12 - output something like that
682:14 - if we use debug notation then we want
682:17 - the output to look something like that
682:19 - and that's what I mean when I say we can
682:22 - manipulate how the output of a custom
682:25 - type will look like
682:28 - so
682:29 - I will
682:31 - take over here this
682:33 - method
682:36 - and I will just copy it over here
682:41 - now let's first implement the display
682:44 - trait as you can see we want the output
682:47 - to look something like that so we Define
682:50 - here
682:51 - lay
682:54 - the X field the value of x field and
682:59 - then plus the value of the by field and
683:03 - we have here an i okay
683:07 - like that
683:08 - and we can access these fields using
683:12 - normal notation self
683:15 - dot X and cell dot y
683:19 - right
683:21 - and for debug notation we want the
683:24 - output to look something like that so
683:26 - let's copy this
683:29 - put it inside here
683:31 - and as you can see we want here
683:34 - the value of the X field and here the
683:38 - value of the Y field
683:49 - and as you can see we are here using
683:52 - curly braces and this is usually for the
683:56 - placeholder so what we have to do here
683:58 - is using two of them meaning this
684:02 - calibrases over here will basically be
684:05 - escaped all right
684:08 - and then over here we have to provide
684:10 - the arguments self.x and self dot y
684:15 - let's see
684:19 - and this is compiling now let's see the
684:21 - actual output
684:32 - [Applause]
684:37 - as you can see I'm using display
684:39 - notation and debug notation and just
684:42 - provided an instance of the point to the
684:45 - type
684:50 - and as you can see this will then be the
684:53 - output
684:56 - so question mark operator implementing
684:59 - fmt display for a structural whose
685:01 - elements must be handled separately is
685:04 - tricky the problem is each right
685:07 - generates a fmt result which must be
685:11 - handled in the same place
685:14 - fortunately Russ provides the question
685:16 - mark operator to help us eliminate some
685:19 - unnecessary codes for dealing with fmt
685:23 - result
685:25 - so
685:28 - let's see again we are using the fmt
685:31 - module and we have here a custom type a
685:35 - struct list
685:37 - a tuple struck list holding a vector of
685:41 - i32 elements right over here we are
685:45 - instantiating this list with a vector
685:48 - holding one two three
685:50 - now as you can see when we put this
685:55 - list over here into the format macro
685:59 - then we want the output to look
686:01 - something like that so we want to print
686:03 - these square brackets the index colon
686:08 - and then the actual value
686:11 - now let's see how this would be
686:14 - implemented notice over here we are
686:17 - implementing the display trade so we can
686:19 - then use it to display the type directly
686:25 - so as you can see this is the function
686:27 - signature from the fmt module
686:33 - and
686:35 - as you can see over here we return a
686:39 - type of fmt result now this is a third
686:42 - now this would be a type Alias and we
686:46 - have covered that
686:49 - now over here
686:51 - we want to extract the value using Tuple
686:55 - indexing and creating a reference to
686:58 - back
686:59 - so the first thing we do is we want to
687:02 - access the vector in the list struct and
687:08 - we do that using Tuple indexing right we
687:11 - want the first element because there is
687:14 - actually only one element on here
687:17 - so we access that meaning we'll get back
687:20 - a reference to a vector
687:24 - holding i32
687:28 - types right
687:30 - here we are taking a reference
687:34 - now then we have basically unwrapped
687:37 - this Vector into this variable
687:40 - now as you can see we use the right
687:44 - macro to write to this buffer this
687:48 - square bracket
687:50 - because as you can see this is what we
687:52 - want to Output
687:54 - so the first thing added to the buffer
687:57 - will be this square bracket then iterate
688:01 - over V in vac while enumerating the
688:04 - iteration count in count so we take this
688:07 - vector and we iterate over it and
688:11 - enumerate meaning we will get back a
688:14 - tuple holding the index and the actual
688:18 - value
688:20 - then for every element except the first
688:24 - add a comma use the question mark
688:26 - operator to return on errors
688:31 - so as you can see if count is not equal
688:34 - to zero
688:36 - meaning if it is in fact the first
688:40 - element then we don't add this comma all
688:42 - right because we don't want to look
688:45 - something like that
688:49 - so this is only after the second
688:53 - iteration that this comma will be added
688:58 - and then we write the actual value over
689:02 - here
689:04 - and this iterates three times right for
689:07 - each element and then in the end it will
689:11 - put into the buffer this square bracket
689:15 - so when we run that
689:19 - as you can see the output would be
689:21 - something like that
689:23 - but this is the output that we want
689:26 - so what's missing over here is we didn't
689:30 - include the indexes right so what we can
689:36 - do over here
689:37 - we want here to be the index and then a
689:41 - colon like here and a space and then the
689:45 - value so we have the index in this count
689:48 - variable so let's use that
689:53 - and again we can then
689:56 - run the program
689:59 - and this succeeded so let's actually
690:01 - print that out
690:13 - as you can see this would be the output
690:16 - so we can really manipulate the output
690:19 - of our custom types using the debug and
690:24 - the display trades and by the way as you
690:28 - can see we are here using the question
690:30 - mark operator because this over here
690:33 - could potentially fail right
690:36 - that's why we are using this here and
690:41 - we use here the result type from the fmt
690:45 - module just in case any of these
690:48 - operations here fail
690:52 - alright see you in the next topic
690:55 - so let's take a look at lifetimes now
690:57 - lifetimes are only necessary when
691:00 - dealing with references and even then
691:03 - most of the time the compiler can
691:06 - actually infer the lifetimes and we
691:09 - don't have to worry about it so let's
691:11 - see
691:12 - a lifetime is another kind of generic
691:15 - ensuring that references are valid as
691:18 - long as needed
691:20 - every reference has a lifetime which is
691:23 - the scope for which the reference is
691:25 - valid
691:26 - most of the time this is implicit and
691:29 - inferred so we don't have to worry about
691:32 - it
691:33 - sometimes though lifetime annotations
691:35 - are needed and that's the case if the
691:38 - compiler can't infer it and lifetime
691:42 - annotations is a concept which most
691:45 - other programming languages don't have
691:48 - so even for experienced programmers this
691:52 - sometimes looks a little bit confusing
691:55 - but in actuality it's a very simple
691:58 - concept and you will understand it very
692:02 - quickly
692:03 - so
692:05 - actually the main aim of lifetimes is to
692:09 - prevent dangling references also called
692:12 - dangling pointers
692:14 - so let's see we are here in Main and we
692:18 - declare a variable R we don't initialize
692:21 - it with a value but just declaring it
692:25 - meaning
692:26 - the compiler will actually infer a
692:30 - lifetime of a for this variable and the
692:34 - lifetime a in this case is valid until
692:38 - the end of the main scope right
692:42 - then over here we have an inner scope
692:45 - and in this scope we are initializing
692:48 - variable x with a value of 5. so the
692:52 - compiler will annotate this variable to
692:56 - be of Lifetime B
692:59 - and as you can see lifetime B is only
693:02 - valid until the end of this scope
693:06 - now then we are assigning a reference to
693:10 - x to the variable R meaning the variable
693:14 - R we have declared here holds a
693:17 - reference to the variable X
693:20 - the problem here is that when X goes out
693:24 - of scope at this point then R Points to
693:28 - something that is not valid anymore
693:31 - right and that's the aim of references
693:35 - to avoid exactly this scenario
693:40 - now to understand lifetimes you have to
693:43 - understand the borrow check or in Rust
693:46 - so the borrow Checker Compares Scopes to
693:50 - determine whether all borrows are valid
693:53 - it's a key part of Russ ownership system
693:56 - it tracks lifetimes of references and
694:00 - ensures that they don't violate the
694:03 - ownership rules these rules ensure that
694:06 - the value is not accessed after it has
694:09 - been moved or freed from memory
694:12 - an important a reference to a value must
694:16 - never outlive the value itself
694:19 - so you have to remember
694:22 - especially the last line
694:24 - a reference to a value must never
694:27 - outlive the value itself
694:30 - so when we go back here as you can see
694:33 - we have here a reference to value 5. now
694:36 - the problem is that this reference
694:38 - outlives the value itself meaning X
694:43 - holding this value we are referencing to
694:46 - goes out of scope meaning the reference
694:50 - on here lifts longer than the actual
694:53 - value it is referring to
694:56 - all right
695:00 - let's see the compiler uses lifetime to
695:03 - ensure all borrows are valid typically a
695:07 - variable's lifetime begins when it is
695:09 - created and ends when it is destroyed
695:13 - so the scope of Lifetime annotate the
695:16 - lifetime of I and borrow 2.
695:20 - lifetimes are annotated below with lines
695:23 - denoting the creation and destruction of
695:25 - each variable
695:27 - I has the longest lifetime because its
695:30 - scope entirely encloses both borrow1 and
695:33 - borrow two the duration of borrow 1
695:36 - compared to borrow 2 is irrelevant since
695:39 - they are disjoint
695:41 - so when we look at this program here
695:46 - what you see is that we have here
695:48 - initialized variable I right
695:52 - now this variable I over here lives
695:55 - until the main scope ends
695:59 - all right
696:01 - basically it outlives this scope and
696:05 - this scope
696:06 - now over here we are assigning a
696:09 - reference to I to borrow one
696:13 - right so borrow one lifetime starts
696:17 - and then we are just printing out borrow
696:20 - one now over here borrow one will go out
696:25 - of scope
696:26 - but it doesn't matter because the value
696:29 - itself still lives on all right
696:34 - and over here the same thing we have
696:36 - power 2 which holds a reference to I
696:40 - meaning
696:42 - that borrow 2 lives inside the scope so
696:46 - we print here borrow two and then it
696:49 - will here go out of scope
696:51 - but again the value here lives on so the
696:55 - actual value outlives
696:58 - T borrows or the references
697:01 - all right
697:04 - example two so over here we have a
697:07 - variable X
697:09 - with a value of 5.
697:12 - and then over here we have a reference
697:15 - to X
697:17 - assigned to variable r
697:20 - and then we are printing out R right so
697:24 - if we execute that it will compile
697:29 - because again as you can see we are
697:32 - declaring here the variable X in this
697:35 - scope so variable X we live until the
697:39 - scope ends and the same thing for the
697:43 - reference to X
697:45 - so the reference to X is assigned to R
697:48 - meaning R will live until the end of
697:52 - this scope
697:53 - so the value and the borrow to the value
697:57 - are both valid
698:00 - all right and over here you can see the
698:03 - lifetime annotations the important thing
698:06 - here is that
698:07 - both
698:09 - the value itself and the reference to
698:11 - the value or valid right the reference
698:16 - here doesn't outlive the actual value it
698:20 - is pointing to
698:22 - annotate R and X as above and explain
698:25 - why this code fails to compile in the
698:28 - lifetime aspect
698:31 - that's actually the example we have seen
698:34 - so we are here declaring r and over here
698:38 - in this inner scope
698:40 - we declare a variable X and initializing
698:44 - it with a value of 5. then we are
698:48 - assigning a reference to X to R
698:52 - the problem here is X will go out of
698:55 - scope so R still points to
698:59 - dislocation but this over here has gone
699:03 - out of scope right so rust won't allow
699:07 - you to compile this program and you will
699:10 - get a compiler Arrow saying X does not
699:14 - live long enough right
699:18 - because
699:20 - the reference to the value lives longer
699:23 - than the actual value lives right
699:29 - meaning the lifetime of X is shorter
699:33 - than the lifetime of r
699:35 - or the lifetime of X holding the value
699:39 - is shorter than the lifetime of R
699:41 - holding the reference to a value and
699:44 - this should never happen
699:47 - so lifetime annotating The Borrowed
699:50 - cycle reuses explicit lifetime
699:52 - annotations to determine how long a
699:55 - reference should be valid but for us
699:58 - users in most cases there is no need to
700:01 - annotate the lifetime because there are
700:04 - several illusion rules before learning
700:06 - these rules we need to know how to
700:09 - annotate lifetime manually
700:12 - so
700:14 - ignoring illusion rules and that's the
700:17 - next topic lifetimes in function
700:20 - signatures have a few constraints
700:23 - any reference must have an annotated
700:26 - lifetime any reference being returned
700:29 - must have the same lifetime as one of
700:32 - the inputs or be static so over here we
700:35 - have a function print one
700:38 - and it takes as an argument a reference
700:42 - to an i32 type alright
700:47 - now this is how we would annotate a
700:50 - lifetime it's actually very similar to
700:53 - generics but we use this apostrophe
700:56 - syntax and a lowercase letter by
701:00 - convention just going from a b c d and
701:03 - so on
701:04 - so in this case we annotate here
701:08 - that the reference
701:11 - that the reference here is of Lifetime a
701:15 - so when we have over here a lifetime
701:18 - annotation
701:20 - then we can provide here
701:23 - then we can annotate it here for our
701:26 - reference right and again we are just
701:29 - dealing with lifetimes when we are
701:31 - dealing with references
701:34 - so in this case we say the reference to
701:37 - the i32 type should be of Lifetime a now
701:42 - when we annotate that to our function it
701:45 - means that
701:47 - the lifetime a must at least live as
701:51 - long as the function itself or we all or
701:55 - we could also say lifetime a must
701:58 - outlive this function so the past
702:02 - reference over here must outlive this
702:05 - function this is just ensuring that the
702:10 - reference passed here lives longer than
702:13 - this function meaning we can ensure that
702:16 - this function always deals with a valid
702:20 - reference right
702:23 - and all we do here is printing out X
702:27 - mutable references are possible with
702:30 - lifetimes as well so if you would have a
702:34 - mutable reference you would annotate it
702:36 - like that
702:37 - first after the Ampersand of course you
702:41 - will always put the lifetime annotation
702:44 - and then the mute keyword and then of
702:47 - course the type
702:52 - multiple elements with different
702:54 - lifetimes in this case it would be fine
702:56 - for both to have the same lifetime a but
702:59 - in more complex cases different
703:02 - lifetimes may be required
703:05 - so as you can see we can
703:07 - Define more than one lifetime over here
703:10 - we have lifetime a and lifetime B
703:13 - meaning the references pairs to this
703:16 - function could be of different lifetime
703:18 - but again
703:21 - lifetime a and lifetime B must outlive
703:25 - this function so the past references
703:29 - over here must outlive the function
703:34 - right
703:36 - and returning references that have been
703:39 - passed in is acceptable however the
703:42 - correct lifetime must be returned
703:45 - so let's take a look at the function
703:48 - pass X as you can see it takes two
703:51 - arguments and both of them are
703:53 - references
703:55 - now this would be of Lifetime a and this
703:59 - would be of Lifetime B again both of
704:03 - these references must outlive this
704:06 - function
704:08 - and we are just returning X which is
704:12 - annotated with a lifetime a meaning the
704:16 - return type will return
704:18 - meaning the return type will be a
704:21 - reference to an i32 with a lifetime of a
704:25 - right this would be the type that is
704:29 - annotated to the X argument here
704:34 - if we would here have y and we return y
704:39 - then we would do it like that right
704:42 - because we are returning a reference
704:44 - with a lifetime annotation of B
704:58 - foreign
705:02 - so as you can see we have here
705:04 - two variables
705:06 - holding i32 types and then we are
705:10 - passing to all of the above functions T
705:14 - reference to these two
705:16 - variables right because all of these
705:19 - functions over here expect a reference
705:22 - to an i32 type
705:26 - now
705:28 - in this case this program will compile
705:36 - as you can see this is compiling because
705:39 - we have here declared X and Y in the
705:43 - main scope meaning they are valid until
705:47 - the end of the scope over here right so
705:53 - t x and y references we pass to the
705:56 - functions outlive all the functions
706:00 - which is a requirement right
706:03 - the best references must outlive the
706:07 - function
706:08 - so we don't have to deal with dangling
706:11 - references
706:14 - and so let's see an exercise to
706:17 - understand it even more make it work by
706:19 - adding proper lifetime annotation
706:22 - so over here we have the function
706:24 - longest that takes two arguments of type
706:27 - string slice
706:29 - now we then test the length of these
706:33 - string slices
706:34 - and if x is
706:37 - and if x
706:39 - is longer than y then we return X
706:43 - otherwise we return y
706:47 - so
706:49 - if we go over here in the main function
706:52 - and let's do some variables
707:06 - as you can see we have two string
707:08 - literals long and longer
707:15 - now we would pass that to this function
707:19 - over here
707:21 - now
707:23 - it could be possible in this case
707:26 - the return type is known at compile time
707:30 - but sometimes this is decided at runtime
707:33 - and when we are passing these arguments
707:37 - to the function over here let's do that
707:40 - actually
707:49 - [Applause]
707:52 - and notice we don't have to pass here a
707:56 - reference because string literals are
707:59 - already references all right now if we
708:03 - would compile that this would actually
708:05 - fail right missing lifetime specifier
708:11 - so what we want to achieve here
708:14 - is first of all we want to add a
708:16 - lifetime parameter like that
708:21 - and then we want to define the lifetimes
708:24 - of these references
708:28 - now in this case the function over here
708:31 - could either return X or Y right
708:35 - depending on which argument has the
708:39 - longer string
708:41 - right so sometimes it might be X that is
708:44 - returned and sometimes it might be y so
708:48 - we can't be sure if we annotate here a
708:52 - and B like that
708:57 - we don't know which one will get
708:59 - returned is it a or b it depends on the
709:03 - arguments right
709:05 - so what we can Define here is that
709:11 - X and Y these two arguments have the
709:15 - same lifetime meaning
709:18 - these two references share the same
709:21 - lifetime they must be declared in the
709:25 - same scope and both of them of course
709:28 - must outlive the function longest
709:32 - so in this case this is what we are
709:35 - providing right we are declaring X and Y
709:38 - over here in the main scope so when we
709:41 - call the longest function with these two
709:44 - references over here it means that these
709:47 - two references still live on even after
709:51 - this function call all right because
709:54 - again the reference of X and Y will
709:58 - leave until the main scope ends
710:02 - now because we have here defined that
710:06 - both of these references have the same
710:09 - lifetime
710:10 - it is clear that the returned
710:14 - string slice must have the same lifetime
710:17 - either X or Y right
710:21 - let's see
710:25 - and as you can see this is compiling in
710:27 - this case longest will return y because
710:31 - it is longer than this than the X string
710:37 - all right
710:40 - a must live longer than the function
710:42 - here reference to string Foo would
710:46 - create a string followed by a reference
710:48 - then the data is dropped upon exiting
710:51 - the scope leaving a reference to invalid
710:54 - data to be returned
710:56 - fix the arrow in three ways as you can
710:59 - see we have the function invalid output
711:02 - we Define here a lifetime parameter a
711:05 - and declare that The Returned reference
711:08 - should be of this lifetime
711:11 - now the problem here is we are
711:15 - creating a new string and returning a
711:20 - reference to it right we are returning a
711:23 - reference to a string the problem is
711:26 - this string was declared inside the
711:29 - function now when
711:32 - the function returns to the caller it
711:36 - means the string over here will get out
711:38 - of scope right because it is declared
711:41 - inside the function
711:43 - so again if we call for example
711:53 - if we call this function
711:56 - then we would get back
711:58 - a reference to a string right the
712:01 - problem is
712:03 - that
712:04 - the reference points to something that
712:07 - isn't valid anymore this string declared
712:10 - here got out of scope so X points to
712:14 - something that is not valid anymore
712:17 - so returning a reference to something
712:20 - declared inside the function is a really
712:23 - bad idea now what we can do over here to
712:26 - fix that and this is probably the
712:28 - easiest fix
712:30 - we just return the string itself right
712:34 - so then ownership will be transferred
712:37 - and X will be the owner
712:39 - all right let's print out X
712:48 - as you can see this is working because
712:51 - we are here
712:52 - declaring a string
712:55 - and then return it meaning the ownership
712:58 - of the string will then be returned over
713:02 - here right so X will become the owner of
713:06 - the returns string from the invalid
713:09 - function
713:12 - the second way to fix that would be
713:15 - returning a string literal
713:19 - right
713:20 - and a string literal actually has always
713:25 - a static lifetime we will come back to
713:27 - that but that actually means that this
713:30 - reference is of static lifetime meaning
713:34 - it is valid throughout the entire
713:37 - program
713:38 - all right because remember a string
713:41 - literal is hard coded into the binary so
713:45 - it lifts as long as the program lives
713:49 - so then over here we will get back a
713:52 - string slice right
713:55 - let's see
713:58 - and as you can see this is also
714:00 - compiling
714:02 - the Third Way would be
714:04 - over here
714:08 - create a string
714:20 - and then we can pass this string to the
714:23 - invalid output so
714:26 - in this case we want here to take
714:29 - a reference to a string right we can
714:34 - also write it like that because remember
714:37 - a reference to a string
714:40 - will be automatically inferred to a
714:42 - string size right
714:45 - so
714:51 - [Applause]
714:55 - so we are then passing a reference to
714:58 - this string right and what we want to
715:01 - return here is s
715:04 - meaning we return here a string slice
715:08 - and we can annotate a lifetime parameter
715:19 - and then we will print out X let's see
715:25 - and this is also working because as you
715:29 - can see we have defined here a string
715:32 - meaning s over here is the owner of this
715:36 - train then we are passing a reference of
715:40 - s to this function right
715:44 - we annotate here a lifetime a meaning
715:48 - the reference over here passed to the
715:51 - argument s must outlive this function
715:55 - which it does right we have declared s
715:58 - here so even after this function call S
716:02 - still lives on right
716:05 - and then all we do is we again return as
716:09 - the past reference right so
716:12 - it will actually have the same lifetime
716:15 - as the past argument
716:18 - all right meaning we have here then a
716:22 - returned string slice
716:28 - all right
716:30 - Point refs takes two references to i32
716:34 - which have different lifetimes A and B
716:37 - these two lifetimes must live at least
716:41 - as long as the function print refs so as
716:44 - you can see we are here in the print
716:47 - refs function declaring two lifetime
716:50 - parameters one for argument X and one
716:54 - for argument y again we are dealing with
716:57 - references meaning
716:59 - we care about the lifetimes if these
717:02 - would be owned types like so
717:05 - then we don't deal with references right
717:08 - [Applause]
717:10 - and then we just print out X and Y to
717:13 - provided arguments
717:16 - make it work if function which takes no
717:18 - arguments but has a lifetime parameter a
717:22 - so over here
717:26 - we can see that we annotate a lifetime
717:29 - parameter a and we have here
717:33 - and i32 integer now error X does not
717:37 - live long enough
717:40 - so we assign to Y over here in reference
717:44 - to X
717:46 - the problem again is that when we
717:49 - annotate this lifetime parameter it says
717:52 - the lifetime a must outlive this
717:56 - function
717:57 - which it doesn't right because
718:00 - the reference over here
718:05 - because the value we are referencing to
718:08 - is declared inside the function meaning
718:11 - it will then be dropped at the end of
718:15 - the scope
718:16 - attempting to use the lifetime a as an
718:19 - explicit type annotation inside the
718:21 - function will fail because the lifetime
718:23 - of reference X is shorter than a a short
718:28 - lifetime cannot be coerced into a longer
718:31 - one
718:33 - so let's see in main we are here
718:37 - destructuring a tuple into the variables
718:40 - 4 and 9 right so 4 will hold 4 and 9
718:45 - will hold 9. borrows of both variables
718:49 - are passed into the function
718:51 - so we are then calling the print refs
718:54 - function with references to 4 and 9
718:58 - right
719:00 - this function over here
719:04 - any input which is borrowed must outlive
719:07 - the borrower in other words the lifetime
719:10 - of 4 and 9 must be longer than D then
719:14 - that of print refs
719:16 - so again when we annotate these
719:19 - lifetimes on a function both of the
719:22 - lifetimes must outlive
719:25 - the function or both of the
719:30 - references passed here must outlive the
719:33 - lifetime of this function which they do
719:36 - right so 4 and 9 are declared in main
719:40 - scope meaning they outlive this function
719:43 - over here
719:44 - so this should actually work
719:49 - so failed borrow contains no references
719:52 - to force a to be longer than the
719:55 - lifetime of the function but a is longer
719:59 - because the lifetime is never
720:00 - constrained it defaults to static
720:05 - so
720:06 - so as you can see we have here declared
720:09 - the lifetime a which states that the
720:13 - reference holding the lifetime of a must
720:16 - outlive the function this is not the
720:19 - case right because we are declaring the
720:21 - value inside the function itself
720:25 - now when we remove that
720:28 - actually this over here will then
720:32 - work all right let's see
720:41 - let's see structs make it work by adding
720:43 - proper lifetime annotation a type of
720:46 - road which houses a reference to an i32
720:50 - the reference to i-32 must outlive
720:54 - borrowed
720:55 - so as you can see we have here a custom
720:59 - type a tuple struct holding a reference
721:03 - to i32
721:06 - now in this case we have to annotate the
721:09 - lifetime and we do it like that
721:12 - and then we pass it to the reference
721:15 - like so and that means this reference
721:18 - here must outlive this struct or the
721:24 - instance we create from it right
721:28 - similarly both references here must
721:31 - outlive this structure
721:34 - again we are here annotating the
721:37 - lifetime and we say that both of them
721:39 - should have the same lifetime which
721:42 - makes it easier right
721:44 - and enum which is either an i32 or a
721:48 - reference to one
721:50 - so as you can see again
721:53 - we can annotate a lifetime basically
721:56 - like a generic type parameter
721:59 - and over here as you can see this
722:01 - variant holds a type of i32 so the enum
722:06 - will be the owner of this type we don't
722:09 - care about any lifetime annotation we
722:13 - only care about lifetime annotations
722:15 - when dealing with a reference
722:19 - like that
722:22 - now let's see we have here i32 and i32
722:27 - and then we are instantiating the
722:30 - borrowed struct with a reference X right
722:36 - so as you can see this would be the
722:38 - borrowed struct and it holds a reference
722:43 - 2x which is i32 right
722:53 - now as you can see we Define here that
722:56 - reference
722:58 - of Lifetime a must outlive
723:01 - this struct or the instance of destruct
723:05 - right so X over here must outlive this
723:10 - instance which
723:12 - which it does right because it again it
723:16 - is declared in main scope meaning X and
723:19 - Y we live until this point here
723:23 - so they outlived The Borrowed struct
723:28 - and over here as you can see we pass
723:30 - here references to the X and Y field of
723:34 - the named borrowed
723:36 - a struct
723:40 - so this would then be an instance now
723:42 - again
723:43 - X and Y in this case first of all they
723:47 - are declared in the same scope so they
723:49 - can have the same Lifetime right
723:52 - they both live in the same scope and
723:55 - both of these variables will end at the
723:59 - same time
724:01 - so
724:03 - this will actually compile right
724:05 - everything over here is safe
724:09 - so as you can see we instantiate clear
724:12 - the either enum
724:17 - and one time with the variant ref
724:19 - holding a reference to X
724:23 - now again as you can see we have here a
724:26 - lifetime parameter a which states it
724:29 - must outlive the instance of the enum
724:32 - which it does right X is valid all the
724:37 - time
724:38 - and the second variant doesn't hold a
724:42 - reference we just pass it to single
724:46 - we just pass it
724:48 - T variable
724:50 - now because this implements copy it's an
724:52 - i32 it means that even then y will still
724:57 - live on so either want to take ownership
725:00 - it will take ownership of the copied
725:03 - value
725:04 - let's see if this is actually compiling
725:13 - and this is compiling
725:16 - make it work so over here we have
725:20 - destruct no copy type and and over here
725:24 - we have struct example and as you can
725:27 - see we annotate here the lifetimes A and
725:30 - B meaning over here the A and B field
725:34 - could hold references that have
725:38 - different lifetimes but they can also be
725:41 - the same all right
725:44 - now let's see in main a tight to FN main
725:47 - stack frame
725:49 - so as you can see we have here an i32
725:52 - and over here we have declared a
725:55 - variable which should be of type example
725:58 - but we haven't initialized it with
726:01 - values all right we haven't instantiated
726:05 - the example struct now notice here we
726:09 - have another scope
726:11 - lifetime B tied to new stack frame so
726:15 - then we have here an instance of the no
726:17 - Copy Type struct
726:21 - and as you can see fix me
726:24 - so then we are instantiating example
726:28 - with the fields over here passing it
726:31 - concrete values as you can see we are
726:34 - passing it a reference to Bar a this and
726:39 - a reference to Bar B so the problem over
726:43 - here is that VAR B will go out of scope
726:48 - at this point right
726:51 - meaning
726:53 - the example struct we have instantiated
726:57 - over here will hold the B field which
727:01 - points to something that is not valid
727:04 - anymore as you can see we are here
727:06 - printing out example now if we would
727:09 - print it out in this scope
727:12 - then this would actually compile
727:16 - and of course this must be your 32
727:19 - because it is a u32 field here as you
727:23 - can see this is compiling fine
727:26 - now even though
727:29 - we are here in a new scope right we have
727:34 - declared Bar B here in the inner scope
727:38 - but even then both of these references
727:43 - are valid right
727:46 - because we are here then using example
727:50 - in the same scope and we have noted that
727:54 - here that you that the lifetime of a and
727:59 - b are different right so the lifetime of
728:04 - bar a
728:07 - is actually longer than the lifetime of
728:10 - Bar B
728:13 - right because for a lives until the end
728:16 - of the main function while Bar B leaves
728:20 - only until this point
728:23 - but again
728:25 - this is safe and this is compiling
728:28 - because the VAR B we have created here
728:32 - and passed a reference
728:34 - to the
728:36 - example struct is valid
728:41 - if we leave this over here then this
728:44 - wouldn't compile right because vorby
728:47 - gets out of scope
728:50 - and
728:54 - we over here say that both A and B must
728:59 - outlive example
729:01 - all right so example is used here but
729:05 - not all references are still valid which
729:10 - would lead to a compiled error
729:12 - but what we can do also is just removing
729:15 - this scope here
729:17 - meaning everything is now declared in
729:19 - main scope so this would also compile
729:22 - right because all the references to
729:25 - these variables are valid
729:31 - let's see here we have again struck no
729:33 - copy type and the example struct we have
729:36 - seen before and as you can see denoting
729:40 - that the lifetimes of these references
729:43 - might differ but they can be the same
729:46 - it's no problem so let's see here fixed
729:49 - function signature we have here the fix
729:51 - me function which takes us an argument a
729:54 - reference to an example instance and it
729:58 - will then return
730:00 - the B field from the provided argument
730:04 - from the example struct right it will
730:08 - return this field over here meaning a
730:12 - reference to no copy type because that
730:15 - is what B is holding
730:18 - now over here we are instantiating no
730:21 - Copy Type
730:27 - and we are instantiating the example
730:31 - struct
730:33 - so we pass for the field a here a
730:37 - reference to one
730:39 - and for B we pass a reference to no Copy
730:44 - Type
730:45 - right
730:48 - [Applause]
730:51 - and then we pass a reference
730:54 - this example instance over here to the
730:57 - fix me function now let's first annotate
731:01 - the lifetime parameter
731:04 - again we do a
731:08 - and over here we say
731:11 - that the past reference to the example
731:15 - instance must outlive this function
731:18 - right which it actually does because
731:21 - here we are instantiating the example
731:24 - struct and passing it to a reference
731:27 - and passing it as a reference to this
731:30 - function meaning example over here will
731:33 - live longer than the function right
731:37 - and we can then Define that no Copy Type
731:43 - must also outlive
731:47 - this fix me function all right which it
731:52 - does because again it's secured the main
731:54 - meaning the end of scope will be at this
731:58 - point
731:59 - so both the instance of example and the
732:03 - no copy type both outlive this fix me
732:08 - function
732:09 - and as you can see we can pass this same
732:12 - lifetime parameter because they are
732:14 - declared in the same scope meaning they
732:17 - have the same lifetime
732:25 - methods are annotated similarly to
732:28 - functions so we have here destruct owner
732:31 - holding an i32 type
732:34 - so annotate lifetimes as in a standalone
732:37 - function as you can see we have here the
732:40 - implementation block for owner and we
732:43 - Implement some methods for this custom
732:46 - type
732:47 - and this is how we would annotate
732:50 - lifetime parameters again same thing
732:53 - again same thing like in functions
733:10 - make it work by adding proper lifetime
733:13 - annotations
733:15 - you have a struct important excerpt
733:18 - and the port field holding a string
733:20 - slice now again string slice is a
733:23 - reference meaning we have here to
733:26 - annotate the lifetime parameter
733:30 - so that means the reference that the
733:33 - port field of destruct is holding
733:36 - outlives the entire struct
733:39 - right
733:41 - and over here we have
733:44 - a method implemented for the important
733:48 - excerpt struct so as you can see we are
733:52 - using a lifetime parameter here but we
733:55 - have to actually first declare it
733:58 - like that
734:03 - and that's basically it it should
734:06 - compile
734:07 - so when distract over here
734:10 - declares a lifetime parameter we have to
734:14 - declare it in the implementation block
734:17 - again but we are here not using it
734:19 - meaning we can do it like that right we
734:22 - don't care about this lifetime parameter
734:25 - here
734:26 - and this lifetime parameter is declared
734:29 - only on the on the method right
734:35 - this is compiling but there is an easier
734:38 - way actually we don't have to use any
734:42 - lifetime here right
734:45 - because we can Define here that
734:48 - the string slice is static
734:52 - meaning it will live throughout the
734:55 - entire program
734:57 - all right
734:59 - illusion some lifetime patterns are so
735:02 - common that the borrowed Checker will
735:04 - allow you to Omit them to Safe typing
735:07 - and to improve readability this is known
735:10 - as illusion
735:12 - illusion exists in Rust only because
735:15 - these patterns are common
735:17 - for a more comprehensive understanding
735:19 - of a lesion please see lifetime illusion
735:22 - in the official book
735:24 - so I have prepared some slides
735:29 - let's see there are three rules of
735:31 - Lifetime illusion the first rule states
735:34 - compiler assigns a lifetime parameter to
735:38 - each parameter that's a reference
735:41 - second if there is exactly one input
735:44 - lifetime parameter that lifetime is
735:47 - assigned to all output lifetime
735:50 - parameters
735:52 - third rule if there are multiple
735:54 - lifetime parameters but one of them is a
735:57 - reference to self or immutable reference
736:00 - to self the lifetime of self is assigned
736:04 - to all output lifetime parameters
736:09 - so let's see an example
736:13 - and
736:14 - before we see the example as you can see
736:17 - lifetime illusion makes writing rust
736:20 - much more easy until this point we
736:23 - didn't worry and care about lifetimes
736:25 - and that's most of the time the compiler
736:28 - just inferred it so we didn't have to
736:31 - worry
736:32 - now let's see here we have the function
736:35 - first word taking a reference okay and
736:39 - returning a reference
736:41 - so the compiler applies the first rule
736:44 - each parameter gets its own lifetime
736:48 - so the compiler behind the scenes will
736:52 - annotate here a lifetime for this
736:54 - function and we'll annotate it for all
736:58 - the references right
737:02 - so the second rule applies because there
737:05 - is exactly one input lifetime
737:08 - again we have only one argument that is
737:11 - a reference
737:13 - so this gets assigned to the output
737:16 - lifetime meaning the output reference
737:20 - here must then be
737:23 - the same reference right we are taking a
737:26 - reference so it must be the same when we
737:28 - are when we are returning a reference
737:32 - so in this case the compiler could infer
737:35 - the lifetime and we don't have to
737:37 - specify them manually
737:39 - so what the compiler will do he will
737:42 - just annotate the same lifetime as for
737:46 - the input argument right
737:49 - so this is all inferred you can write it
737:52 - like that and it will compile you don't
737:54 - have to worry about lifetimes
737:58 - so let's see this example we have the
738:00 - function longest that takes two
738:02 - references as arguments okay and it
738:06 - returns one reference
738:08 - first rule each parameter gets its own
738:11 - lifetime so the compiler will come and
738:14 - annotate
738:16 - A and B each reference gets its own
738:21 - lifetime all right so here the second
738:24 - rule doesn't apply because there is more
738:27 - than one input lifetime also the third
738:30 - rule doesn't apply because this function
738:32 - is not a method we have now to manually
738:36 - annotate the lifetime parameters
738:39 - so as you can see over here the compiler
738:42 - cannot infer
738:44 - The Returned reference here is it of
738:47 - Lifetime a or is it of Lifetime B right
738:52 - so it depends if you return X then you
738:56 - would annotate a lifetime of a if you
738:59 - return B then you would return then you
739:02 - would annotate a lifetime of B and again
739:06 - both lifet times A and B must outlive
739:10 - this function
739:13 - let's see an example in a method so as
739:18 - you can see we have a method taking a
739:20 - reference to self meaning taking the
739:23 - instance as a reference and doesn't take
739:26 - ownership
739:28 - so here the third rule applies which
739:31 - states that if there is a reference to
739:33 - self then all references will have the
739:37 - same lifetime as self
739:39 - right so we can have here any number of
739:43 - arguments all of them will take the
739:46 - exact same lifetime as the lifetime of
739:49 - self because this is inferred and it
739:52 - makes sense right because
739:55 - all of the provided arguments to a
739:59 - method must actually outlive
740:01 - the structure or the enum
740:05 - instance
740:07 - all right so all of the arguments here
740:10 - take
740:12 - implicitly the same lifetime as self
740:17 - all right
740:23 - so let's see remove all the lifetimes
740:26 - that can be elided as you can see over
740:29 - here we have only one input argument
740:33 - and the second thing is we don't even
740:35 - return anything so we don't even have to
740:38 - care about
740:39 - uh the lifetime because we don't worry
740:42 - that it might go out of scope right but
740:46 - in this case we only have one argument
740:49 - meaning the compiler is able to infer
740:51 - that
740:53 - over here again we have only one
740:56 - argument
740:58 - but
740:59 - as you can see the difference is we are
741:02 - returning
741:04 - a reference right
741:07 - so
741:08 - because there is only one argument here
741:13 - the compiler can infer that the
741:17 - reference over here must be the
741:18 - reference that will be returned so we
741:22 - don't have to annotate the lifetimes so
741:25 - let's see over here we have the longest
741:27 - function and
741:30 - the first rule says that the compiler
741:32 - will annotate a lifetime for each
741:36 - reference meaning it will create a and b
741:39 - because we have here two references
741:43 - right two arguments
741:45 - and
741:47 - it will annotate for the first argument
741:50 - a and for the second argument lifetime
741:53 - of B
741:54 - now over here this
741:58 - the compiler cannot infer which lifetime
742:02 - will get returned meaning as you can see
742:06 - we are returning X so the lifetime over
742:10 - here would be a right the lifetime of
742:13 - the argument X
742:16 - but notice both of the references must
742:20 - outlive the function
742:22 - right
742:26 - here we have a struct owner that holds
742:29 - an i32 type
742:31 - annotate lifetimes as in a standalone
742:34 - function
742:36 - so as you can see we have here
742:40 - methods implemented on the owner struct
742:43 - now again when we have a mutable
742:47 - reference or an immutable reference to
742:50 - self then we never have to worry about
742:53 - lifetime annotations because this will
742:56 - get inferred by the compiler
743:00 - all right all references pass to these
743:04 - methods will get the same lifetime as
743:07 - self
743:08 - or SD reference to self
743:12 - now over here we have to annotate the
743:15 - lifetime because this is a struct and we
743:18 - want to ensure that the reference the
743:22 - name field is holding is actually living
743:25 - longer than the instance of a struct
743:28 - person okay and over here the same thing
743:32 - let's see if this is compiling
743:38 - and this is compiling what we could do
743:41 - also here
743:42 - we could remove that and doing it like
743:45 - this all right this should actually also
743:47 - work
743:50 - okay we have here to specify that this
743:53 - string is static in this case we have to
743:56 - explicitly state it and as you can see
743:59 - this is compiling so you don't have to
744:02 - declare here a lifetime parameter you
744:06 - can put here this static Lifetime and
744:10 - static lifetimes will be our next topic
744:14 - let's take a look at static lifetimes so
744:17 - aesthetic lifetime refers to a lifetime
744:20 - that lasts for the entire duration of
744:23 - the program's execution
744:25 - any reference or borrowed value with a
744:28 - static lifetime can be safely used
744:31 - throughout the program
744:33 - and aesthetic lifetime can be coerced to
744:37 - a shorter lifetime if needed
744:42 - so we have seen string literals and they
744:46 - are usually annotated using an ampersand
744:48 - and stir but implicitly it would have a
744:53 - static lifetime
744:55 - so string literals have a static
744:57 - lifetime because they are hard coded
744:59 - into the executable meaning they are
745:02 - valid throughout the entire duration of
745:06 - the program's execution
745:09 - let's see
745:11 - static is a reserved lifetime name you
745:14 - might have encountered it several times
745:17 - so a reference with static lifetime is
745:21 - for example a string literal and this
745:24 - would be the full type annotation
745:29 - static as part of a trade bound
745:32 - so as you can see we are here defining a
745:37 - generic type parameter and we say that
745:39 - the argument provided should be of type
745:42 - T now in the Vera Clause over here we
745:46 - see that t must be of static lifetime
745:51 - though they are all static but subtly
745:54 - different
745:55 - as a reference lifetime Ampersand static
745:58 - indicates the data pointed to by the
746:01 - reference lives as long as the running
746:04 - program but it can still be close to a
746:07 - shorter lifetime
746:09 - there are several ways to make a
746:11 - variable with static lifetime two of
746:14 - them are stored in the read-only memory
746:16 - of the binary
746:19 - fill in the blank in two ways
746:21 - so as you can see we are calling here
746:24 - neat static within argument of V so
746:28 - let's declare that here
746:30 - and as you can see the argument must be
746:33 - of type static string or string literal
746:38 - all right
746:39 - and then we are here checking is the
746:43 - argument equal hello
746:45 - so let's initialize it here
746:50 - so the first way is just initializing it
746:53 - like that without any type annotation
746:59 - because this is simply inferred by the
747:02 - compiler so any string literal is hard
747:06 - coded into the binary means it lives as
747:10 - long as the program's execution Because
747:14 - the actual data of the string literal is
747:17 - living in the binary the second way is
747:20 - just annotating the full type annotation
747:26 - like that
747:33 - and this static lifetime annotation here
747:36 - can also be omitted so we can annotate
747:40 - it like this
747:47 - as you can see the compiler is able to
747:51 - infer the lifetime
747:54 - another way to make static lifetime is
747:56 - using box leak now this is an unsafe
748:00 - method and I won't cover that because
748:03 - it's a more advanced topic
748:06 - but I have solved it and will put it on
748:09 - my GitHub if you want to solve it for
748:12 - yourself
748:14 - static only indicates that the data can
748:17 - live forever not the reference the
748:20 - letter one the letter one will be
748:23 - constrained by its scope
748:25 - so let's see make a string literal and
748:28 - print it so over here we have a string
748:31 - literal meaning it's a string slice of
748:36 - static lifetime
748:40 - then we print it out
748:42 - when static string goes out of scope the
748:44 - reference can no longer be used but the
748:47 - data remains in the binary so
748:52 - at the end of this scope over here
748:55 - this variable will go out of scope
748:58 - meaning it's dropped
749:00 - and that means we can't then use static
749:04 - string anymore because the variable has
749:07 - been dropped now even though the
749:11 - variable now even though the variable
749:14 - has been dropped the data over here is
749:17 - actually still living on right
749:21 - so this is living in the binary a string
749:25 - literal is hard coded into the binary
749:27 - meaning it is of static lifetime meaning
749:30 - it is valid throughout the entire Pro
749:34 - programs lifetime
749:37 - but of course a variable is bound to its
749:41 - scope
749:46 - so to make that work we can
749:50 - take that and copy it over here meaning
749:53 - the variable static string is valid
749:56 - until main ends as you can see
750:04 - static can be close to a shorter
750:06 - lifetime
750:08 - so over here make a constants with
750:11 - static lifetime so this over here is the
750:15 - static keyword meaning we are here
750:17 - creating a constant now constants by
750:20 - conventions are always uppercase right
750:26 - and by the way the difference between
750:28 - conist
750:31 - [Applause]
750:35 - the difference between this and this now
750:37 - both of them live for the entire
750:40 - lifetime of the program both are of
750:43 - static lifetime but the difference is
750:46 - that static will always remain at the
750:49 - same memory location while a const
750:53 - constant will get inlined so when we use
750:57 - for example num const here then it will
751:01 - get inlined meaning the compiler will
751:06 - basically copy that into the code in the
751:10 - function so the memory location could
751:13 - change but static always stays at the
751:16 - same memory location
751:20 - so returns a reference to num there is
751:24 - static lifetime is coerced to that of
751:27 - the input argument
751:30 - so as you can see over here we have a
751:33 - function corostatic and we have defined
751:36 - a lifetime parameter a
751:39 - we Define here that the input reference
751:42 - should be of this lifetime a right
751:46 - meaning the reference we take as an
751:49 - argument to this function must outlive
751:53 - the function itself
751:55 - now we over here actually return
751:59 - this constant right basically a
752:03 - reference to this constant
752:05 - and we can in this case course
752:09 - the static lifetime of this num constant
752:13 - to a shorter lifetime
752:17 - it's no problem right
752:19 - so a is shorter than static right
752:27 - aesthetic lifetime is
752:30 - larger than this a lifetime here meaning
752:35 - aesthetic meaning a reference with a
752:38 - static lifetime lives longer than a
752:43 - because a only defines that it must
752:45 - outlive this function right but we can
752:49 - hear chorus it to a shorter lifetime so
752:54 - it matches with the lifetime annotated
752:57 - on the function
753:00 - make an integer to use for coreostatic
753:03 - so over here we make an integer
753:08 - and then we pass a reference of this
753:12 - integer and called the chorus static
753:15 - function
753:16 - meaning we here returned a reference to
753:20 - an i32 right basically a reference to
753:24 - the number 18.
753:27 - and then we will just print out the
753:30 - result of this function call right
753:34 - now
753:36 - as you can see we have crossed num here
753:39 - to a shorter lifetime
753:42 - but this doesn't change the actual
753:45 - lifetime of this static constant right
753:49 - so even after this scope over here
753:52 - we can still access num because again
753:56 - it's of static lifetime it lives as long
754:00 - as the program is running
754:03 - so even though we have here corrected to
754:06 - a shorter lifetime it doesn't matter it
754:09 - remains static right
754:16 - let's see as a trade bound it means the
754:19 - type does not contain any non-static
754:22 - references
754:23 - for example the receiver can hold on to
754:26 - the type for as long as they want and it
754:29 - will never become invalid until they
754:31 - drop it
754:32 - it's important to understand this means
754:35 - that any owned data always passes a
754:39 - static lifetime bound but the reference
754:41 - to that owned data generally does not
754:46 - so
754:48 - so let's look at function printed as you
754:51 - can see we Define here a generic type
754:54 - parameter meaning the input meaning the
754:57 - input argument here must be of type T
755:00 - now this over here is a trade bound
755:03 - meaning we say the type T must implement
755:06 - the debug trade and
755:10 - T cannot contain any reference that is
755:15 - not of static lifetimes so all
755:17 - references T is containing must be of
755:21 - static lifetime
755:23 - right
755:24 - and over here we do basically the exact
755:26 - same thing but using the impul keyword
755:29 - right this and this is actually quite
755:33 - the same
755:34 - and then over here as you can see
755:38 - 22 takes a reference to T right
755:43 - and again T must implement the debug
755:45 - trade and it cannot contain any
755:48 - non-static
755:50 - references all right
755:53 - so
755:54 - I is owned and contains no references
755:57 - thus it's static
756:00 - [Applause]
756:01 - as you can see we are here initializing
756:04 - I with a value of 5 meaning I is the
756:07 - owner of 5. now when we pass the owner
756:11 - to a function then it would actually
756:14 - comply with this function signature
756:17 - because owned types are also considered
756:20 - static okay
756:24 - now this would actually work
756:30 - because again
756:32 - i32 implements debug and it is
756:36 - considered static because we are passing
756:39 - an owned type right
756:42 - oops reference to I only has the
756:45 - lifetime defined by the scope of main so
756:48 - it's not static
756:50 - right so the so a reference to I has a
756:54 - lifetime that is defined by this main
756:58 - scope
756:59 - so it's not static anymore right
757:02 - so this would actually
757:05 - output and error right
757:10 - and this would be the same thing again
757:13 - print it and print it one would actually
757:16 - be very similar right
757:20 - now this here actually works because we
757:24 - are here passing a reference to I again
757:28 - right so we pass a reference to I
757:32 - and again the reference to I would have
757:35 - a
757:36 - lifetime of this main function now the
757:40 - difference is here that
757:43 - in the argument we defined that
757:46 - the argument should be a reference to T
757:51 - meaning
757:53 - if we
757:54 - think away it is ampersands
757:57 - I would be T right
758:01 - so a reference to T would be a reference
758:03 - to I
758:05 - hope this makes sense
758:07 - so
758:08 - that means again when we pass I directly
758:11 - it would be it would Implement debug and
758:15 - it would be of static Lifetime right so
758:19 - this over here would work
758:23 - now to fix this over here we can
758:28 - do it two ways we can create here the
758:31 - constant I
758:33 - and again constants have a static
758:35 - lifetime as you can see this is
758:38 - compiling
758:40 - and the second thing is we can use this
758:43 - static keyword meaning I is static
758:48 - so this would pass because
758:51 - the argument we are passing
758:54 - or the references we are passing are all
758:57 - of static Lifetime and they implement
759:00 - the debug trade right
759:03 - i32 implements debug and we have ensured
759:08 - that all of them are of static lifetime
759:15 - now the last one here again deals with
759:18 - box leak I won't cover this but again
759:21 - the solution is in my GitHub if you want
759:24 - to solve it you can do that and then
759:26 - compare with my Solutions
759:32 - alright see you in the next one
759:35 - so let's see closures a closure is an
759:38 - anonymous function that is able to
759:40 - capture the values from the scope in
759:43 - which it is defined and if you are
759:46 - coming from python then you might know
759:48 - Lambda functions and in JavaScript they
759:51 - are called Arrow functions
759:54 - and they can be defined inline for
759:57 - example as a function parameter they
760:00 - don't require type annotations and they
760:03 - can take ownership of a value by using
760:06 - the move keyword
760:10 - so all functions and closures
760:14 - implement the F and trades and that is
760:18 - the trait that defines the signature for
760:21 - closures and functions
760:24 - it describes the types the number of
760:27 - arguments and the return type there are
760:30 - three different traits FN ones the
760:34 - closure can be called only once because
760:37 - it takes ownership of the captured
760:39 - values
760:41 - FM mute it might mutate a captured value
760:45 - it can be called more than once and FN
760:49 - it doesn't take any ownership of
760:52 - captured values it doesn't mutate
760:54 - anything and it might not even capture
760:58 - anything from its environment
761:01 - so let's take a look over here we have
761:04 - here initialize the variable x with a
761:07 - value of 1. now over here we would have
761:10 - a closure and closures are defined like
761:13 - that first of all we have these symbols
761:17 - over here and between them we Define the
761:21 - name of the argument
761:23 - and as you can see over here we just add
761:26 - the argument with the value of x so as
761:30 - you can see the closure here is able to
761:34 - capture the value of x something a
761:37 - function can't do right
761:40 - and
761:42 - we then assign this closure to a
761:45 - variable meaning we then can call this
761:48 - closure
761:49 - and calling it like in normal function
761:52 - so in this case as you can see we call
761:54 - the closure using the variable name
761:57 - closure and then providing it an
762:00 - argument right
762:02 - so actually disclosure call should
762:05 - evaluate to 3 because we provide 2 here
762:10 - meaning weld will be 2 and adding X to
762:14 - it one so two plus one will be 3.
762:18 - so disclosure captures the value of x
762:21 - and modifies it the compiler will
762:24 - capture variables in the least
762:26 - restrictive manner possible
762:29 - in this case immutable reference of X is
762:33 - taken rather than taking ownership
762:35 - because it's less restrictive
762:39 - let's see closures can capture the
762:42 - enclosing environments for example we
762:45 - can capture the X variable that's the
762:48 - example we have seen
762:50 - from the syntax we can see that closures
762:53 - are very convenient for on the Fly usage
762:56 - unlike functions both the input and
762:59 - return types of a closure can be
763:02 - inferred by the compiler
763:05 - so we have here a normal function as you
763:08 - can see it takes an argument of type i32
763:11 - and it will just add 1 to T and it will
763:15 - just add 1 to the provided argument and
763:18 - returns it meaning the return type will
763:21 - be i32
763:23 - now closures are Anonymous here we are
763:26 - binding them to references
763:29 - these nameless functions are assigned to
763:31 - appropriately named variables
763:34 - so as you can see we can here create a
763:38 - closure
763:39 - and this and this over here are exactly
763:43 - the same so type annotations enclosures
763:47 - are not required okay
763:52 - and then again we assign the closure to
763:55 - a variable in order so we can call it
763:58 - all right over here we have a variable I
764:01 - with a value of 1.
764:04 - and then we are just calling the
764:06 - function and these two closures with
764:10 - this value over here
764:14 - and a closure taking no arguments which
764:17 - returns an i32 the return type is in
764:21 - third
764:22 - so this would be a very primitive
764:24 - closure just with running one when being
764:27 - called so when we call one here we will
764:31 - just get back one
764:34 - let's execute that
764:37 - you can see when we call this function
764:40 - and these two closures it will just add
764:43 - one to the provided argument
764:47 - and over here we are just returning one
764:54 - capturing closures can capture variables
764:58 - by borrowing or moving but they prefer
765:01 - to capture by borrowing and only go
765:04 - lower when required
765:06 - so they can capture the values either by
765:10 - reference by mutable reference or by
765:13 - value meaning the closure will then only
765:16 - type it captures okay
765:19 - so let's see exercise one make it work
765:22 - with least amount of changes so over
765:25 - here we are initializing a variable
765:27 - color with a string
765:30 - so as you can see over here we have a
765:33 - closure and we assign it to print so we
765:36 - can then call it now this closure here
765:39 - doesn't expect any arguments but it uses
765:43 - the move keyword meaning the captured
765:46 - values will be moved inside this closure
765:51 - right
765:53 - so that means the closure here will
765:56 - become the owner of the captured value
766:00 - this is not always the case so for
766:02 - example over here a immutable reference
766:06 - is sufficient because we are just
766:08 - reading basically this data here we
766:12 - don't mutate anything and we don't need
766:14 - ownership to print something out
766:17 - but as you can see printing two time
766:20 - over here will cause an error right
766:25 - so what we can do is we can remove the
766:27 - move keyword
766:29 - and color can be borrowed immutably
766:32 - again because the closure only holds an
766:35 - immutable reference to color
766:37 - right that means when we don't move the
766:41 - captured value we can then
766:43 - take a reference to color again
766:47 - so this foothold a reference to a string
766:55 - as you can see we print here out two
766:58 - times color green because we are calling
767:00 - this closure two times
767:04 - and this will take an immutable
767:06 - reference of this captured value
767:11 - all right and then we can take another
767:14 - reference of this
767:17 - string
767:19 - so let's see exercise 2 make it work
767:22 - don't use reborrow and count reborrowed
767:25 - don't modify assert EQ
767:28 - so we have over here an i32
767:32 - by the way this is mutable and we have
767:35 - here a closure taking no arguments
767:39 - then as you can see it captures this
767:42 - variable here all right and it mutates
767:46 - it meaning count will then hold one
767:50 - and then we just print out count
767:53 - over here we are calling disclosure
767:57 - and then we are taking a reference to
768:00 - count meaning a reference
768:05 - to an i32 right
768:10 - and then we are again calling
768:13 - this ink closure
768:16 - the closure no longer needs to borrow
768:18 - mutable borrow account therefore it is
768:21 - possible to re-borrow without an error
768:25 - so what is happening over here we have
768:28 - seen that the compiler will take the
768:31 - least restrictive approach so in this
768:34 - case it will take an
768:37 - so in this case the count variable here
768:40 - will be captured as a mutable reference
768:45 - right
768:47 - and
768:49 - that would be a problem because as you
768:51 - can see we are calling Inc and over here
768:55 - we call it again after you're defining
768:59 - an immutable reference to count
769:02 - so maybe you remember that you can
769:05 - either have one mutable reference or any
769:09 - number of immutable references but not
769:12 - both at the same time
769:14 - so this would be a problem
769:17 - so we can call here the move keyword
769:21 - meaning
769:23 - disclosure here takes ownership of this
769:27 - value now again because i32 implements
769:31 - the copy trade it means
769:33 - it will actually get a copy of count
769:37 - so count is still accessible even after
769:40 - this
769:41 - closure call right the closure will just
769:45 - take a copy of the value
769:48 - and that means we can then take an
769:52 - immutable reference again to count and
769:55 - call the closure right
769:58 - and over here the closure no longer
770:00 - needs to borrow a mutual reference to
770:03 - count therefore it is possible to
770:05 - re-borrow without an error
770:07 - so as you can see we are here taking a
770:10 - mutable reference to count again because
770:13 - we don't use this immutable borrow over
770:17 - here again after this point right so
770:21 - this is allowed
770:24 - let's see
770:25 - and as you can see this is compiling and
770:28 - here you can see that count
770:31 - has been modified
770:34 - so let's see exercise 3 make it work in
770:37 - two ways none of them is to remove take
770:38 - movable away from the code
770:41 - so as you can see we have here
770:45 - initialized a variable with a heap
770:49 - allocated i32 integer right
770:54 - then over here we have a closure and we
770:57 - capture here this movable variable
771:02 - now
771:03 - we have seen that actually the compiler
771:06 - will use the least restrictive approach
771:09 - so in this case because we have only a
771:11 - print line it will take this variable
771:14 - here as immutable reference we just need
771:18 - to print it out
771:20 - now over here we are calling the take
771:23 - function as you can see the take
771:25 - function takes an argument of any type
771:28 - but it takes ownership meaning when we
771:32 - call the take function
771:35 - with an argument the argument will then
771:40 - lose its ownership so take function will
771:44 - become the owner of movable in this case
771:48 - right and that means we can't call
771:52 - disclosure two times
771:55 - because in this case again
771:58 - the compiler will try to use the least
772:02 - restrictive approach but in this case
772:04 - it's necessary that this closure over
772:09 - here will Implement F and once so it
772:13 - only can be called one time because
772:16 - again over here move a bell when we call
772:19 - this take function it will take movable
772:22 - and take ownership of it because it's
772:25 - necessary for the compiler to do that to
772:28 - comply with this function signature but
772:31 - what we can do is we say we want a
772:34 - reference right
772:36 - so again the compiler will then
772:39 - implement the F and trade for this for
772:43 - disclosure meaning
772:45 - it can be called two times now we will
772:49 - see a lot of more example of these FN
772:51 - trades so don't worry
772:53 - it just means now because we just need
772:58 - over here immutable references the
773:00 - compiler will actually capture
773:03 - this
773:05 - variable here as an immutable reference
773:08 - right so nothing gets moved inside this
773:12 - closure and movable will remain the
773:15 - owner of the data
773:19 - for comparison the following code has no
773:22 - error
773:23 - foreign
773:25 - so as you can see we have again a heap
773:28 - allocated integer and we have here a
773:31 - closure now as you can see we use the
773:34 - move keyword here
773:36 - and in this case disclosure will capture
773:39 - the movable variable only as an
773:43 - immutable reference because we here only
773:46 - print out the variable we don't need an
773:50 - we don't need a mutual reference and we
773:52 - don't need to take ownership so we can
773:55 - call this closure two times without any
773:59 - problem
774:01 - type in third the following foreclosures
774:04 - has no difference in input and return
774:07 - types
774:10 - so this is actually a function not a
774:13 - closure but as you can see all of them
774:16 - are exactly the same so we can skip the
774:19 - type annotations and we can even skip
774:22 - the curly braces if it is declared on
774:26 - the same line
774:27 - so this over here is exactly the same as
774:31 - writing it like that
774:34 - so over here we have an example closure
774:37 - taking one argument and just returning
774:39 - that argument so then
774:42 - V over here
774:44 - call the example closure with a string
774:49 - meaning
774:50 - over here this would be the argument
774:53 - provided and it returns a string
775:00 - now when you define a closure
775:04 - and call it with a concrete value the
775:07 - compiler will then infer the types of
775:11 - the arguments and the return type so in
775:14 - this case the compiler will annotate the
775:16 - types like that
775:28 - right we take an argument of type string
775:32 - and return the string
775:35 - and that means
775:37 - that we then can't call the closure
775:40 - again with another type
775:43 - this would cause an error okay what we
775:47 - have to do is to convert that to a
775:50 - string
775:51 - let's do it like that so we get back a
775:54 - string here
775:59 - and this is compiling
776:02 - so let's see FN F and mute FN once when
776:06 - taking a closure as an input parameter
776:09 - the closures complete type must be
776:12 - annotated using one of the following
776:15 - trades
776:16 - FN the closure uses the captured value
776:19 - by reference F and mute the closure uses
776:23 - the captured value by mutable reference
776:26 - F and once the closure uses the captured
776:29 - value by value basically taking
776:33 - ownership
776:35 - alright so make it work by changing the
776:39 - trade Bound in two ways
776:42 - so when a function accepts a closure as
776:46 - an argument we have to actually
776:50 - Define what will be the type of the
776:53 - arguments to the closure and the return
776:56 - type of the closure right
776:59 - and we
777:02 - over here can see that a closure
777:04 - implements one of these
777:07 - three trades all right
777:11 - now over here in the fn1's function we
777:15 - Define that the fund argument must be of
777:19 - type f
777:21 - and here we Define the trade bound so F
777:25 - must be a type that implements F and
777:28 - ones
777:29 - taking as argument U size and returning
777:33 - a Boolean value
777:35 - all right
777:37 - and
777:39 - inside this function over here we are
777:42 - just calling the provided func closure
777:45 - and providing its arguments
777:51 - so as you can see we have here a vector
777:55 - [Applause]
777:57 - and we call the FN ones function with an
778:02 - argument of a closure as you can see we
778:05 - can't pass a closure as a function
778:08 - argument
778:10 - now in this case disclosure will
778:14 - implement the fn1 straight right
778:18 - basically meaning it will take ownership
778:21 - of the captured values and it can be
778:25 - only called once
778:28 - so it takes as argument
778:32 - a a type of view size right
778:37 - so
778:41 - and this is necessary here because we
778:44 - are comparing the provided argument 3
778:47 - and 4 with the return value of the Len
778:52 - method right this land method is defined
778:55 - on vectors and it will return EU size so
779:00 - that over here has to be of hue size we
779:04 - have to Define that
779:06 - and all this does is we can provide
779:08 - disclosure an argument and it will check
779:12 - is for example 3 over here is it the
779:17 - same as the length of this vector
779:21 - now the problem here is that we have to
779:25 - change the trade bound because at the
779:28 - moment we are calling the funk closure
779:31 - passed as argument to this function two
779:34 - times while it implements FN once
779:37 - meaning it can only be called once now
779:42 - what we can do over here is we take FN
779:45 - right basically just taking an immutable
779:50 - reference of a captured value now the
779:53 - captured value in this closure here
779:56 - would be X right this vector
779:59 - acoustic because the closure captures it
780:03 - from the environment it is defined in
780:07 - and this should actually work let's see
780:13 - as you can see when we pass this closure
780:16 - to this function and we Define here the
780:20 - closure must implement the FN trade
780:23 - taking a u sizes argument and returning
780:26 - a bull
780:27 - then we are calling the closure right
780:31 - Funk here
780:33 - holds a closure so we are calling it
780:36 - with three in this case this would
780:38 - evaluate to true because the length of
780:42 - vac is three elements right so x dot
780:46 - length will return three meaning it's
780:49 - equal to the provided argument and four
780:52 - of course would return false
780:58 - so we are here initializing a string
781:01 - and over here we are defining a closure
781:04 - it takes an argument and it then
781:08 - modifies the string over here basically
781:11 - pushing the string that was provided in
781:14 - the argument
781:20 - then we are calling the exact function
781:24 - providing it this closure all right
781:29 - then let's see
781:31 - all this function does it takes a
781:34 - closure as an argument
781:37 - and then it will call the closure
781:40 - and it will pass it a string literal
781:43 - right
781:45 - meaning
781:47 - that
781:48 - to this string as
781:51 - this string literal will be pushed right
781:54 - so after calling this closure
781:57 - s should then hold
782:00 - hello
782:02 - all right
782:04 - and then we just print out s
782:08 - now what would be the appropriate trade
782:12 - Bound for this closure
782:16 - think about it we have FN FN mute and FN
782:22 - once so what would be the least
782:25 - restrictive approach
782:28 - it would be FN mute right
782:31 - because we are mutating here this string
782:34 - the captured value
782:37 - but we don't need to take ownership in
782:40 - order to be able to mutate it right now
782:44 - we have to provide the argument this
782:46 - would be of type string slice right we
782:50 - are passing here at this string literal
782:51 - which is string slice
782:54 - and then we have to provide a return
782:57 - type
782:59 - so actually
783:02 - this won't return anything right so we
783:05 - don't here have to provide
783:08 - a return type so let's see if this works
783:19 - and as you can see we have here a
783:21 - lifetime parameter
783:25 - and this is just ensuring that
783:28 - the past string literal here
783:31 - is actually outliving
783:35 - this function exact right which is the
783:38 - case because string literals remember
783:40 - are static lifetime
783:43 - they live the entire duration of the
783:46 - program and as you can see when we print
783:49 - out s it has successfully been modified
783:54 - so it's sufficient to use here F and
783:58 - mute but if we want we can even take
784:00 - ownership
784:02 - but then we have the Restriction that we
784:05 - can only call this closure one time
784:08 - right
784:10 - so if we try that
784:14 - as you can see this is working two
784:19 - which trade does the compiler prefer to
784:22 - use FN the closer uses the captured
784:25 - value by reference
784:27 - FM mute the closure uses the captured
784:30 - value by mutable reference
784:33 - fn1 stick closure uses the captured
784:36 - value by value
784:38 - on a variable by variable basis the
784:41 - compiler will capture variables in the
784:44 - least restrictive manner possible
784:48 - for instance consider a parameter
784:50 - annotated as fn1s to specify that the
784:55 - equation May capture
784:57 - T by reference by mutable reference or
785:00 - taking ownership but the compiler will
785:03 - ultimately choose based on how the
785:06 - captured values
785:08 - based on how the captured variables are
785:11 - used in the closure
785:13 - which trait to use is determined by what
785:16 - the closure does with captured value
785:21 - this is because if a move is possible
785:24 - then any of borrows should also be
785:27 - possible note that the reverse is not
785:30 - true if the parameter is annotated as FN
785:33 - then capturing variables by Mutual
785:36 - reference or by T is not allowed
785:43 - let's see number seven fill in the blank
785:45 - a function which takes a closure as an
785:48 - argument and calls it f denotes that f
785:51 - is a generic type parameter so as you
785:55 - can see we have here the function apply
785:57 - and it takes as an argument a closure
786:00 - and all it does it will then call
786:04 - disclosure right and we have here to
786:07 - define the trade Bound for the provided
786:10 - closure
786:12 - a function which takes a closure and
786:14 - returns an i32
786:17 - so over here we have applied to three
786:19 - again taking a closure and we have 10 to
786:23 - Define here the trade bound
786:26 - the closure takes in i32 and returns an
786:29 - i32
786:32 - and again this function over here will
786:34 - just call the closure and the difference
786:37 - is it will then return The Returned
786:40 - value from the closure so as you can see
786:43 - over here it just calls the closure but
786:46 - it doesn't return anything because
786:49 - here this is a statement it's ending
786:52 - with semicolon here we omit the
786:55 - semicolon meaning the return value of
786:58 - the closure will be the return value the
787:01 - function returns
787:03 - all right
787:05 - so over here we have a string knittering
787:10 - in non-copy type to own creates owned
787:13 - data from borrowed one
787:16 - so as you can see we take a string
787:18 - literal and call the two owned method
787:22 - now the UN now the two ohms method will
787:25 - convert a string slice to a string
787:32 - capture two variables creating by
787:35 - reference and Farwell by value so over
787:39 - here we have a closure
787:42 - then greetings by reference requires FN
787:46 - so
787:48 - as you can see this closure captures the
787:52 - greeting variable now all it does it
787:56 - will print it out meaning
787:58 - to take a an immutable reference would
788:02 - be sufficient so the compiler will
788:05 - implement the FN trade for disclosure
788:08 - because it is sufficient to only take an
788:13 - immutable reference to the captured
788:15 - variable all right
788:18 - mutation forces farewell to be captured
788:21 - by mutable reference now requires FN
788:25 - mute
788:26 - so as you can see we are taking Farwell
788:29 - and we are modifying it
788:31 - now this requires far well over here to
788:35 - to capture as immutable reference again
788:39 - you can see that the compiler tries
788:41 - always to use the list restrictive
788:44 - approach
788:46 - so then the compiler will instead
788:49 - implement the FN mute trade for
788:52 - disclosure all right
788:55 - because again we capture here a variable
788:59 - which needs to be mutated then manually
789:03 - calling drop forces for well to be
789:05 - captured by value now requires FN once
789:10 - so this mem drop here allows that we
789:14 - manually dropped a value from memory
789:18 - right but this actually requires that we
789:23 - take farewell as a value right so the
789:27 - closure should take ownership of this
789:31 - variable
789:33 - meaning the compiler will now implement
789:36 - the fn1 straight for this closure
789:40 - right
789:42 - so as you can see step by step
789:44 - here an immutable reference was
789:47 - sufficient so it just implements the FN
789:50 - trade here a string got mutated so it
789:55 - takes the captured values as f
789:59 - as IMM mutable reference meaning F and
790:02 - mute is implemented and here when a
790:05 - function needs to take ownership then of
790:07 - course the captured value must be
790:10 - captured
790:12 - as owned type meaning fn1s is
790:17 - implemented
790:18 - so that means if this closure implements
790:22 - the fn1 straight it can only be called
790:25 - once because you have inside values
790:30 - that capture
790:32 - the environment values by taking
790:35 - ownership
790:37 - Quality Function which applies to
790:39 - closure
790:40 - so we call the apply function here
790:43 - providing it an argument diary
790:49 - disclosure here right
790:51 - we are calling apply and providing diary
790:56 - now let's see this would be this
791:00 - function and as we've seen
791:03 - because Farwell here gets captured by
791:09 - by value meaning the closure takes
791:12 - ownership we have to Define here that it
791:16 - will be a closure that implements the FN
791:20 - once
791:22 - trait right
791:27 - now as you can see the closure doesn't
791:29 - take any argument and it doesn't return
791:33 - anything
791:36 - so we would annotate it like that
791:39 - so again this just defines that the
791:42 - generic type f
791:44 - must implement the FN once trade
791:51 - and over here double satisfies apply to
791:54 - three straight bound so here we have a
791:57 - closure taking one argument
792:01 - and
792:03 - it Returns the result of this operation
792:07 - right so we call the apply to three
792:10 - function providing it as argument
792:13 - disclosure
792:15 - and as you can see over here apply to 3
792:20 - is a closure
792:23 - generic type f and V here
792:26 - Define that the type f must implement
792:30 - the FN trade
792:31 - and as you can see it takes as an
792:34 - argument an i32 and the return value and
792:38 - the return type will be i32
792:43 - so let's see I take disclosure here
792:49 - and disclosure was passed as an argument
792:53 - to this function and all this function
792:56 - does is it will call the closure with an
792:59 - argument of 3. now X here will be
793:03 - replaced by three
793:05 - and the return will be 2 times 3 which
793:09 - would be 6 right
793:12 - so
793:14 - disclosure then returns an i32 namely 6
793:19 - and as you can see because we omit here
793:22 - this semicolon it means that the return
793:25 - value of this closure will be the return
793:28 - value of this function
793:31 - so when we call this function over here
793:34 - the return value over here will be 6
793:40 - as you can see this is all compiling
793:46 - move closures May still Implement FN or
793:50 - FN mute even though they capture
793:52 - variables by move
793:54 - this is because the trades implemented
793:56 - by closure type are determined by what
794:00 - the closure does with the captured value
794:02 - not how it captures them the move
794:06 - keyword only specifies the letter
794:09 - so the move keyword only specifies how
794:14 - the captured values are captured
794:18 - while the FN trades determine what the
794:23 - closure does with the captured values
794:27 - so as you can see we have here a string
794:30 - and we have here a closure
794:33 - with the move keyword meaning
794:37 - values will get moved inside disclosure
794:40 - now because over here as you can see as
794:43 - in this case
794:45 - doesn't need to be taken as value so the
794:50 - closure doesn't need to take ownership
794:52 - of the data because it will just print
794:55 - it out right so an immutable reference
794:58 - would be sufficient
795:01 - and that's exactly what this says so
795:04 - over here as you can see we are calling
795:07 - the exec function with this closure
795:11 - and when we see over here the exact
795:13 - function takes us an argument a closure
795:17 - that implements the FN ones
795:22 - trade all right so it will in fact take
795:26 - ownership of the captured value
795:30 - and then in the function itself it will
795:32 - just call the closure and Returns the
795:35 - return type of the closure
795:38 - now over here as you can see again we
795:41 - have a string and we have a closure even
795:45 - though we have the move keyword as you
795:47 - can see we Define here that the provided
795:50 - closure to exec only has to implement TF
795:55 - and trade so the string s here will get
795:59 - moved so basically this closure here
796:02 - takes ownership
796:04 - but we can still Define disclosure over
796:06 - here to just Implement FN
796:10 - because again
796:12 - even though we are taking ownership we
796:15 - are just printing out right
796:18 - the difference between move and the
796:21 - event rates is
796:23 - the event rates
796:25 - Define what the closure does with the
796:28 - captured values and move defines how it
796:33 - captures them so it would capture here
796:35 - by taking ownership
796:37 - but the FN trait only defines what are
796:44 - we doing with the captured value in this
796:48 - case you're just printing it out meaning
796:50 - an immutable reference would be
796:53 - sufficient so we can even here pass FN
796:56 - and it still would work
797:01 - fill in a blank so over here we have a
797:03 - string
797:05 - and this would be a closure that takes
797:08 - an argument and returns a string
797:12 - now what we do over here is pushing to
797:17 - this string the provided argument right
797:20 - and then what we do is we will return s
797:27 - meaning the string right
797:31 - so when we call over here this function
797:34 - and provided the closure
797:37 - then we have to implement the FN once
797:41 - rate
797:43 - and it will take as an argument
797:47 - a string literally let's annotate that
797:50 - with the lifetime parameter a
797:55 - and
797:57 - it will return a string right
798:04 - so this would be
798:07 - so this would be the trade bound we are
798:10 - defining here
798:12 - now why did I Implement here FN once or
798:16 - why did I Define that F over here the
798:19 - type of the argument must implement the
798:22 - fn1 straight because as you can see we
798:25 - are capturing s
798:28 - and modify it now over here it would be
798:31 - sufficient to use an FN mute right
798:38 - now
798:41 - again it would be sufficient to just use
798:44 - a mutable reference to S but again we
798:48 - are here returning as right we are
798:53 - returning this captured variable
798:57 - meaning we must be the owner to return
799:00 - something
799:01 - so we have to Define that F should
799:04 - implement the fn1 straight
799:07 - right because we are here returning s
799:10 - meaning
799:12 - the closure must be the owner in order
799:15 - to return it
799:17 - let's see
799:21 - and this is compiling
799:24 - input functions since closure can be
799:27 - used as arguments you might wonder can
799:29 - we use functions as arguments too and
799:33 - indeed we can
799:35 - so as you can see we have here the call
799:37 - me function
799:39 - Implement call me to make it work
799:42 - and over here we have a normal function
799:45 - just printing out something and in main
799:47 - here we have a closure right also just
799:52 - printing out something
799:54 - then we call the call me function here
799:57 - two times one time with a closure and
800:01 - one time with a function
800:04 - and
800:06 - that means let's see
800:09 - first of all we Define we want here A
800:13 - type f which is generic okay so we have
800:17 - to Define here a generic type parameter
800:20 - and then of course we have to define a
800:23 - trade bound right
800:27 - so
800:28 - in this case over here we are not
800:31 - mutating anything and we don't need to
800:34 - take ownership
800:35 - and in fact over here we don't even
800:38 - capture any variables right
800:41 - it will just print out something
800:44 - and it doesn't capture anything so in
800:47 - this case FN
800:49 - so in this case the F and rate is
800:51 - sufficient right and by the way they
800:54 - don't take any argument and they don't
800:57 - return anything
800:59 - so let's see
801:04 - and this will be the output so we call
801:07 - call me providing it to closure the
801:09 - closure implements CFN trade and then
801:13 - call me we'll just call the provided
801:16 - function and closure
801:19 - right
801:20 - meaning when they are called they will
801:22 - just print out this over here
801:26 - course closure first because closure has
801:29 - been called first
801:33 - let's see exercise 10 closure as return
801:36 - types returning a closure is much harder
801:40 - than you may have thought of now it's
801:43 - actually not that hard but you will see
801:46 - fill in the blank using two approaches
801:48 - and fix the error
801:51 - so as you can see we have here the
801:53 - create FN function and we have to Define
801:56 - here the return type so let's first see
802:00 - we have over here a variable that is
802:03 - declared inside the function meaning num
802:07 - will only live as long as this function
802:11 - lives right
802:13 - and then over here we are returning a
802:18 - closure notice we omit here semicolon
802:21 - meaning
802:22 - this whole closure will actually be
802:25 - returned by the function
802:28 - and when we go into main as you can see
802:32 - we call the create FN function
802:36 - then this function should return a
802:39 - closure meaning F and plane will hold a
802:43 - closure basically F and claim will look
802:46 - something like that
802:50 - right
802:51 - holding a closure meaning we then can
802:54 - call the FN plane closure with a
803:00 - integer all right
803:02 - because we have to Define here that X
803:05 - should be of type i32 because we here
803:09 - capture num which is of type i32
803:13 - remember when we perform an operation
803:16 - both values must be of the same type
803:20 - now let's see
803:24 - we call the create FN function
803:28 - then we initialize the num variable
803:32 - and then we have here the closure that
803:36 - will get returned meaning num here will
803:40 - capture this variable
803:44 - and
803:46 - when we then call the closure over here
803:49 - that will get returned by create FN
803:53 - then we provided a value of 1 meaning X
803:57 - will be 1 and num will be 5.
804:02 - right
804:05 - meaning the value the output should be
804:08 - 16.
804:11 - when calling
804:13 - let's write it here after calling the
804:17 - closure itself the output should be 6.
804:20 - now let's see
804:23 - first of all we have to think about how
804:26 - is this num variable captured
804:29 - now again the compiler will use the list
804:33 - restrictive approach so it will just
804:36 - take a reference
804:39 - problem here is
804:42 - that we actually return this closure
804:46 - right so num actually must outlive
804:51 - this function otherwise when we return
804:54 - the closure and num
804:57 - gets out of scope then over here we hold
805:00 - a closure that refers to something that
805:04 - got out of scope so let's use the move
805:08 - keyword here meaning num gets moved into
805:12 - the closure so the closure will become
805:15 - the owner of this
805:20 - variable all right
805:24 - now again here we can use static
805:27 - dispatch or dynamic dispatch now I will
805:31 - go first with static dispatch
805:34 - so in this case we want to return a type
805:38 - that implements the FN trait right
805:41 - because over here we have the closure
805:44 - that we want to return
805:47 - so let's Implement that
805:51 - disclosure should implement the FN trait
805:55 - and
805:57 - again over here FN is sufficient
806:01 - because
806:06 - even though we have captured the num by
806:09 - ownership the actual closure
806:12 - only performs an operation so it doesn't
806:15 - modify num
806:17 - and remember move defines how we capture
806:21 - the closure and the FN trades Define
806:25 - what
806:27 - the closure will do with the captured
806:30 - value alright so FN here is sufficient
806:34 - and disclosure takes as an argument in
806:37 - i32
806:40 - right because the argument and the num
806:42 - variable must match because we are
806:45 - performing an operation on them
806:48 - and the return type should also be i32
806:52 - all right
806:55 - the result of this operation
807:00 - so let's see
807:04 - and this is compiling now let's actually
807:10 - see the output
807:21 - as you can see the output will be 6.
807:25 - now this is using static dispatch now we
807:29 - can also use Dynamic dispatch remember
807:32 - when you when dealing with trade bounds
807:35 - like this
807:37 - we then have to basically box this
807:43 - over here
807:45 - and we put this over here into a box
807:50 - right
807:52 - this would then be a trade object we are
807:56 - using Dynamic dispatch here
807:58 - so let's see
808:03 - and this is also working so we have
808:06 - implemented the return type in two
808:09 - approaches
808:12 - fill in the blank and fix the error
808:15 - so as you can see we have the function
808:17 - Factory taking one argument of type i32
808:21 - over here we have a variable of type i32
808:26 - and if x the provided argument is bigger
808:31 - than 1 then this will be returned
808:35 - and else if it is smaller than one
808:39 - disclosure will be returned so using
808:43 - here the static dispatch approach
808:45 - doesn't work okay we cannot do something
808:49 - like that
808:55 - because over here
808:58 - we don't know exactly which closure gets
809:02 - returned and as you've noticed they are
809:05 - identical right but in fact disclosure
809:10 - is different than this because
809:13 - these have been both declared and they
809:16 - are located in different memory
809:20 - locations all right
809:23 - so even though they are exactly the same
809:27 - the compiler can't know at compile time
809:30 - which of these closures will get
809:34 - returned because they live at different
809:37 - memory locations
809:40 - now what we can do over here is using
809:43 - the dynamic dispatch approach
809:47 - so for that again we are boxing these
809:50 - closures
810:00 - and we Define here that the return type
810:03 - will be a box
810:08 - that holds a trait object namely a trade
810:14 - object that implements the FN trait
810:17 - taking as argument and i32 this x here
810:21 - and returning an i32
810:27 - right let's see
810:33 - right and we have to provide here the
810:36 - main function because otherwise the
810:39 - program won't compiled
810:43 - and this is compiling alright see you in
810:47 - the next topic
810:50 - so iterators will be the last topic we
810:53 - will cover together so let's Dive In
810:56 - iterator allows to perform a task on a
811:00 - sequence of items in turn
811:03 - iterators are lazy meaning they have no
811:06 - effect until methods are called that
811:09 - consume the iterator to use it up
811:13 - all iterators implement the iterator
811:16 - trade which provides the next method
811:19 - which gets called automatically when
811:22 - traversing over some data
811:25 - and some methods consume the iterator
811:28 - While others produce a new iterator from
811:32 - the provided iterator let's see the
811:35 - iterator pattern allows us to perform
811:37 - some tasks on a sequence of items in
811:41 - turn an iterator is responsible for the
811:44 - logic of iterating over each item and
811:48 - determining when the sequence has
811:50 - finished
811:52 - so
811:54 - over here we have a vector and then we
811:57 - are iterating over the elements in this
812:01 - vector
812:03 - and as you can see the variable X will
812:05 - hold in each iteration one element of
812:10 - the vector
812:12 - so when we print that out
812:15 - as you can see in each iteration it will
812:18 - just print out X which means X in the
812:21 - first iteration is 1 then 2 and then 3.
812:26 - in the code buff you may consider for as
812:30 - a simple Loop but actually it is
812:32 - iterating over an iterator by default
812:36 - the for Loop will apply the into ether
812:39 - to the collection and change it into an
812:42 - iterator as a result the following code
812:45 - is equivalent to the previous one
812:48 - so this is happening implicitly
812:52 - that V over here this vector or really
812:56 - any collection
812:58 - will be called with this into either
813:01 - method meaning this collection will be
813:05 - converted to an iterator right
813:09 - and then we Traverse over each item
813:14 - so let's see exercise one refactoring
813:17 - the following code using iterators so we
813:20 - have here an array holding 10
813:24 - Elements which are all zero
813:29 - something like that okay 10 times
813:33 - then we have here a for loop iterating
813:36 - from 0 to array length where the actual
813:40 - length is excluded meaning from 0 to 9
813:44 - right 10 times
813:46 - and then we just index into this array
813:49 - and print out the
813:51 - and print out the element living at the
813:55 - specific index
813:57 - so when we execute that as you can see
814:00 - we print out 10 times 0.
814:03 - now again we don't have to use this
814:05 - syntax we can just pass here
814:08 - the array itself
814:11 - and it will do exactly the same
814:15 - and we have seen that the compiler
814:17 - implicitly will put that into an
814:20 - iterator
814:21 - like that
814:25 - and as you can see this would be the
814:28 - exactly same thing
814:30 - one of the easiest ways to create an
814:33 - iterator is to use the range notation
814:37 - so over here we are initializing an
814:39 - empty vector right then we want to
814:43 - iterate here over a range and in each
814:46 - iteration we are just pushing n to the
814:50 - vector
814:51 - now in the end the length of this Vector
814:54 - should contain 100 elements right so
814:59 - what we can do over here is going from 0
815:01 - to 100 meaning 100 is excluded going
815:06 - from 0 to 99 meaning the vector will
815:09 - then hold
815:10 - elements from 0 to 99.
815:19 - like that right 100 elements
815:26 - and this will compile
815:29 - next Method All iterators Implement a
815:33 - trait named iterator that is defined in
815:36 - the standard Library
815:38 - as you can see this is the iterator
815:40 - trade that is defined in the standard
815:43 - Library it has an Associated type item
815:46 - which basically refers to the type
815:51 - we are iterating over for example a
815:55 - vector of u8
815:57 - then the item type will be u8 right and
816:03 - as you can see each type that implements
816:06 - the iterator trade will need to will
816:10 - implement the next method taking a
816:13 - mutable reference to the instance and
816:16 - returning an option containing
816:20 - the type of the associated type defined
816:23 - here
816:24 - and we can call the next method on
816:27 - iterators directly
816:30 - so over here we have a vector
816:34 - and
816:40 - we can then put that into an iterator
816:43 - right
816:45 - so this will then actually hold an
816:47 - iterator right and not a vector anymore
816:51 - so we put this collection into an
816:54 - iterator meaning we then can use the
816:57 - next method that is implemented for the
817:01 - iterator type and that is actually
817:04 - exactly what is happening when you are
817:06 - doing a for Loop for example in the back
817:10 - the rascompiler will just call next all
817:15 - the time until it reaches a point where
817:18 - there is a non-return because remember
817:21 - this next method will return an option
817:25 - type
817:27 - so
817:29 - when we put that into an iterator and
817:32 - call next we will get a sum
817:36 - and the first element right
817:39 - then sum and two
817:42 - and
817:43 - as you can see
817:45 - we don't have any more elements so it
817:48 - will return Norm right this is the
817:51 - option type and we have covered that
817:59 - and when we put a collection into an
818:02 - iterator it should be mutable right so
818:06 - the next method takes a mutable
818:09 - reference we have seen so we have to
818:13 - make it mutable
818:15 - all right
818:17 - into iter eater and iter mute in the
818:20 - previous section we have mentioned that
818:23 - 4 will apply the into ether to the
818:25 - collection and change it into a iterator
818:28 - however this is not the only way to
818:31 - convert collections into iterators into
818:34 - either eater and intermute all of them
818:37 - can convert a collection into an
818:40 - iterator but in different ways so into
818:44 - ether consumes The Collection once the
818:46 - collection has been consumed it is no
818:49 - longer available for reuse because its
818:52 - ownership has been moved within the loop
818:56 - ether dispers each element of the
818:59 - collection through each iteration thus
819:02 - leaving the collection untouched and
819:04 - available for reuse after the loop
819:08 - and it remute this mutably borrows each
819:12 - element of the collection allowing for
819:14 - the collection to be modified in place
819:20 - so as you can see we have here a vector
819:30 - then we Loop over this Vector here right
819:37 - and
819:39 - all we do here is actually printing out
819:42 - each of the elements
819:45 - now we have seen that implicitly the
819:48 - compiler will call here into iter
819:50 - meaning the iterator will become the
819:54 - owner of this data right so we can't
819:57 - reuse
819:59 - these are after we have put it into this
820:03 - iterator
820:04 - but there is not a solution we
820:09 - can just use either here because it's
820:12 - sufficient that we have a mutable
820:15 - because it's sufficient here that we
820:18 - have an immutable reference right we
820:20 - just want to print it out we don't need
820:23 - to mutate anything or anything else we
820:26 - only need read only data right so let's
820:29 - see
820:32 - and as you can see
820:34 - we then iterate over each element
820:36 - printing it
820:38 - this over here and then we can reuse the
820:42 - collection over here so ownership hasn't
820:46 - been transferred into this iterator
820:50 - five fill in the blank so over here we
820:53 - have a vector
820:55 - with string literals okay
820:59 - and then over here we are iterating over
821:02 - the elements in this vector
821:05 - now as you can see
821:07 - we are here matching the element
821:12 - and if it is immutable reference to the
821:16 - string literal fairies then we will
821:20 - actually modify
821:24 - the elements that we are iterating at
821:28 - this exact moment to this over here
821:32 - if it is anything else then it will be
821:35 - replaced by hello right
821:38 - so in the first iteration
821:43 - name will hold a string literal this
821:47 - over here then we match this and in this
821:51 - case this arm will match meaning we
821:55 - assign string literal hello to this
822:00 - element right so instead of Pop we would
822:03 - then have hello in the first index
822:07 - right
822:08 - so as you can see we are mutating
822:11 - meaning we can here use either mute
822:14 - right we want to take mutable references
822:18 - from this vector but as you can see over
822:22 - here we are again using these names
822:25 - Vector meaning we can't take ownership
822:28 - so let's see
822:33 - and this is compiling and as you can see
822:36 - the first two elements got replaced by
822:39 - hello and the last one ferries has been
822:43 - matched here right name holds a mutable
822:47 - reference to the string slice Ferries
822:52 - and that's why this will get returned
822:54 - meaning it will be assigned to this
822:58 - element
823:01 - let's see exercise 6 fill in the blank
823:04 - as you can see we have here a vector
823:07 - now over here we want to put this Vector
823:11 - into an iterator right now before we do
823:16 - that as you can see this is the vector
823:19 - in the beginning and this is how it
823:22 - should look like in the end so we want
823:24 - to mutate the first element
823:27 - so in this case we take it as mutable
823:32 - references calling The Ether mute method
823:37 - right so we take from here mutable
823:40 - references of the elements in this
823:43 - vector
823:44 - then over here we can call the next
823:47 - method
823:49 - which will then give us back an option
823:52 - type of the first element right so we
823:55 - pet our match here some with the inner
823:58 - value and then what we can do because we
824:02 - get here
824:03 - a new to the reference meaning we can
824:06 - dereference it and assign it a new value
824:09 - like that
824:13 - so we get no output let's actually see
824:16 - the elements
824:31 - as you can see we changed the first
824:33 - element we have mutated it using ether
824:37 - mute right getting bad getting back
824:41 - immutable reference to the elements
824:45 - creating our own iterator we can not
824:48 - only create iterators from collections
824:50 - type but also can create iterators by
824:54 - implementing the iterator trade on our
824:57 - own types
824:59 - so as you can see we have here a custom
825:01 - type counter which has one field and we
825:05 - Implement here the associated function
825:08 - new
825:10 - basically just creating an instance
825:15 - and then over here we implement the
825:18 - iterator trade for counter right
825:22 - so first of all we have to give the
825:25 - associated type a concrete type in this
825:28 - case u32 right basically the type this
825:34 - field is holding
825:36 - then we implement the next method as you
825:40 - can see next takes a mutable reference
825:42 - to the instance and it returns
825:46 - an option
825:48 - that holds a type of the associated item
825:52 - here
825:54 - right it would be u32 in this case
825:57 - so if self.count is less than 5
826:01 - then we increment the count field here
826:05 - and we return
826:08 - the
826:09 - actual count
826:11 - otherwise we return none so if self to
826:16 - account is bigger than 5 then it returns
826:19 - none so as you can see we are then
826:21 - creating a new instance of this counter
826:24 - type
826:25 - using the new Associated function
826:30 - and then as you can see when we call the
826:33 - next method on it right because we can
826:37 - do that because we have implemented the
826:40 - iterator trade for our custom type
826:43 - so when we do that we just get back
826:47 - T value of count as you can see
826:50 - when calling next
826:53 - then over here it checks is the self to
826:57 - count field less than five
826:59 - in this case it is right we didn't
827:02 - increment it so far so it should hold
827:05 - zero
827:07 - and in that case it will increment it by
827:09 - one right the count field over here gets
827:12 - incremented by one
827:14 - and then it returns it
827:17 - and of course packing it into a sum
827:21 - because we return here an option type
827:25 - so that means we get one in the next
827:28 - iteration we get 2 3 4 5 and then as you
827:33 - can see the count field holds a value of
827:37 - 5 meaning this won't get
827:41 - meaning this would evaluate to false and
827:44 - this will get executed right so we will
827:47 - get back a non
827:51 - and over here we have Fibonacci so the
827:55 - Fibonacci sequence
827:58 - starts at zero then one then zero plus
828:02 - one is one then one plus one is two then
828:07 - one plus two is three
828:09 - two plus three is five five plus three
828:12 - is eight and so on right
828:16 - and as you can see we have here distract
828:19 - Fibonacci that has a current field and a
828:23 - next field
828:24 - so as you can see current for example
828:26 - would hold zero and next would hold one
828:32 - and as you can see we are implementing
828:35 - the iterator for Fibonacci
828:40 - so we Define here the return type to be
828:44 - u32 right or basically the type of the
828:48 - items we are iterating over so these
828:52 - both of these fields hold u32
828:56 - and
828:57 - over here we have a function Fibonacci
829:00 - which just returns an instance of the
829:04 - Fibonacci struct with current holding 0
829:07 - and next holding one
829:10 - so notice something here when we call
829:13 - next we actually want to return someone
829:16 - and not some zero so this is important
829:20 - but let's now implement the next method
829:23 - so we have seen that it will return
829:25 - option type holding self item
829:30 - write the type that is defined in the
829:33 - associated type item
829:37 - and then over here I will create a new
829:40 - variable forward
829:42 - and this would then be self dot current
829:46 - plus cells dot next
829:49 - right because
829:53 - so forward in this example would be zero
829:56 - plus one right this would equal one
830:00 - so we can then
830:03 - to go one step forward we want to go
830:07 - like this and then like this right
830:10 - we can assign to self current
830:15 - self next
830:19 - meaning
830:21 - in the next iteration the current field
830:24 - will hold one right
830:28 - and self.next
830:33 - will hold forward
830:35 - right self to current plus self dot next
830:39 - meaning in the next iteration next we'll
830:43 - hold one so we will be at this point
830:45 - right
830:47 - and then all we need to do is we wrap it
830:50 - in sum because again we return an option
830:53 - and we return the current
830:57 - a field over here
831:01 - let's see
831:05 - methods that consume the iterator
831:09 - the iterator trade has a number of
831:11 - methods with default implementations
831:13 - provided by the standard Library
831:16 - consuming adapters some of these methods
831:19 - called the method next we use up the
831:22 - iterator so they are called consuming
831:25 - adapters
831:26 - so over here we have a vector
831:29 - and we put that into an iter notice we
831:33 - take here the iter method meaning it
831:36 - will just take immutable references to
831:39 - the elements
831:41 - and then we call on this iterator this
831:44 - sum method the sum method will take the
831:47 - ownership of the iterator and iterates
831:50 - through the items by repeatedly calling
831:53 - next method
831:55 - right so all this sum method does it
831:58 - will just add together all the elements
832:00 - in the vector notice sum will take
832:04 - ownership of this iterator meaning we
832:08 - can't use V1 eater again right so in
832:13 - this case the total will be six
832:15 - now I can't edit here let's see it in
832:19 - the playground
832:33 - so we have here a vector
832:37 - and then we put it into an iterator and
832:41 - then we call the sum method on the
832:43 - iterator
832:45 - meaning this should then hold
832:47 - i32 and the value should be 6 right just
832:53 - adding all of these together
832:55 - now that means we can't use V1 either
832:58 - again here this is not possible because
833:01 - it is some method will take ownership of
833:06 - the
833:07 - V1 eater
833:09 - variable
833:11 - let's see
833:13 - as you can see this is compiling
833:17 - let's actually print out the result
833:30 - as you can see we would have six
833:37 - collect other than converting a
833:40 - collection into an iterator we can also
833:43 - collect the result values into a
833:45 - collection collect will consume the
833:48 - iterator
833:49 - so over here we have
833:52 - an array
833:54 - which holds two tuples right
833:58 - and each Tuple has as
834:01 - and each Tuple has a string literal and
834:05 - an i32 right
834:08 - then we take this names array here put
834:12 - it into an iterator notice here into
834:15 - either meaning we take ownership of
834:18 - these elements
834:19 - and then we collect meaning we collect
834:23 - it into another collection which has to
834:26 - be annotated here
834:28 - meaning we will then create a hash map
834:31 - with string literals as keys
834:35 - and i32 values right then we print it
834:41 - out here and over here we have a vector
834:44 - of i32 types
834:47 - and we call The Ether method over here
834:52 - meaning we just take references
834:55 - to this vector and then over here we
834:59 - call collect
835:00 - meaning it will get collected
835:04 - into an iterator right because we want
835:08 - here V2
835:10 - meaning
835:13 - and then we annotate here that we want a
835:16 - vector of i32 because as you can see V2
835:20 - should hold a vector with these elements
835:24 - let's see
835:27 - and actually over here we would have
835:30 - references of i32s right because again
835:35 - ether here takes references of these
835:39 - elements meaning they would not equate
835:42 - we want a vector of I 32 elements
835:46 - meaning we can call the input ether
835:49 - and that means
835:51 - ownership of these elements will be
835:55 - transferred to V2 and this would be the
835:58 - output of the print line over here we
836:01 - are printing here out the hash map we
836:04 - have converted
836:07 - iterator adapters methods allowing you
836:10 - to change one iterator into another
836:12 - iterator are known as iterator adapters
836:16 - you can chain multiple iterator adapters
836:19 - to perform complex actions in a readable
836:22 - way but because all iterators are lazy
836:26 - you have to call one of the consuming
836:29 - adapters to get results from calls to
836:32 - iterator adapters so over here fill in
836:35 - the blanks we have a vector
836:38 - and we iterate over the elements just
836:41 - taking immutable references alright then
836:45 - over here you can see we want to modify
836:48 - the elements inside this Vector to look
836:51 - something like that basically just
836:53 - incrementing each element
836:56 - now we can use here map
837:00 - to do that
837:05 - right
837:06 - Now map will create
837:09 - another iterator it will take ownership
837:12 - of this iterator here
837:15 - and it will then
837:18 - create another iterator
837:21 - right but with the
837:24 - modified elements and then we can call
837:27 - here collect
837:28 - to actually put it into a collection
837:31 - meaning this Vector over here
837:34 - let's see
837:39 - all right this is compiling I guess this
837:41 - would be i32
837:43 - so we have taken it from this vector
837:47 - so this is compiling
837:52 - let's actually output
838:03 - [Applause]
838:09 - as you can see we have modified the
838:13 - elements
838:14 - but of course
838:27 - V1 is still accessible
838:31 - and that is because we have called here
838:34 - the eater method meaning we just take
838:38 - immutable references of the elements in
838:42 - this vector
838:43 - meaning the ownership will remain at V1
838:47 - so we have now reached the end of this
838:50 - course and if you have made it this far
838:52 - then your dedication to this language is
838:56 - really impressive and this is only the
838:59 - beginning of your journey I hope this
839:01 - course was helpful
839:03 - don't forget to split the word about
839:05 - free software and I'm out