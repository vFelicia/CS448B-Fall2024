00:01 - What's going on guys, so I decided to make a 
quick crash course on terraform. And if you  
00:05 - don't know what terraform is, it's another 
one of those infrastructure as code tools.  
00:10 - And so it's really great for modeling your cloud 
infrastructure through code. And so for anyone  
00:16 - that actually wants to get more familiarized 
with terraform, or learn another automation tool,  
00:20 - especially with regards to the cloud, you 
know, this crash course is going to be really  
00:24 - helpful for you guys. And I'm going to make 
sure to start from the absolute beginning.  
00:28 - So I'm going to walk you through how to set up 
an AWS account, I'm going to walk you through  
00:32 - how to set up and install terraform. And 
that's going to be across all operating  
00:36 - systems. So I'll show you guys how to install 
it on a Mac on a Windows and a Linux machine.  
00:42 - I'll even show you how to set up a text 
editor like VS code, which I highly recommend,  
00:47 - by the way, and then you know, we'll get started 
learning the core concepts of terraform. And what  
00:51 - it has to offer, I'll show you guys how to create 
resources on AWS within terraform. We'll take a  
00:57 - look at how to modify them how to delete them, 
I'll go over how terraform state works. And we'll  
01:03 - take a look at how we can kind of reference other 
resources within our code. And I even have a like  
01:10 - a mini project where we'll get to deploy a web 
server onto AWS. And you know, it sounds simple,  
01:16 - but there's a lot of things that actually have to 
happen from a terraform perspective to get all of  
01:21 - that to work. So I think that'll be a great 
learning tool. And I think after this course,  
01:26 - or by the time we finish it, you guys would have 
a solid understanding of terraform. And at that  
01:30 - point, you guys can just kind of take it from 
there. And then focus on specific topics that  
01:34 - you want. And, you know, I plan to do a lot of 
a lot more terraform videos. So if you guys have  
01:39 - a specific topic you want me to cover, let me 
know, and I'll be happy to record a video and,  
01:44 - you know, upload it to YouTube. But hopefully 
you guys enjoyed this course. And you know,  
01:48 - if you guys have any questions, just leave them in 
the comments, and I'll try my best to answer them.  
01:55 - To set up an account with AWS, 
just navigate to aws.amazon.com.  
02:02 - And here, we can actually create an 
account and create a root user. So  
02:06 - we want to click on this button right here that 
says create an AWS account. And it's going to  
02:12 - ask for some basic information like an email 
address and a password. So just fill that in.  
02:19 - And then you'll also have to 
provide in a account name,  
02:21 - so I'm just going to call this sloppy networks.  
02:29 - And go ahead and select your account type, you're 
probably just gonna select personal if you just  
02:33 - make an account for yourself, but you work for 
an enterprise, you may want to select personal  
02:38 - or professional. And it's going to ask for 
some basic information like your phone number,  
02:43 - your country your address, and you will 
need to provide all of this information.  
02:56 - And to actually create an AWS account, 
you will actually have to provide your  
02:59 - a credit or debit card information. You know, 
throughout all of these videos that I make,  
03:04 - we're going to stay within the free tier 
so you shouldn't be charged anything  
03:08 - as long as you shut down all of your resources 
when you're done. And if you do end up getting  
03:12 - charged, it'll be at most just a couple of 
cents. But you know, AWS does require it so  
03:16 - you will need to have a credit card to kind of 
follow along with everything that I'm doing.  
03:52 - Once you've finished adding in your credit card 
information, it will ask you to verify your phone  
03:56 - number. So it'll send you a voice, a voicemail 
or a text message depending on what you select.  
04:02 - So just wait for that text message to come in and 
you can just pass in whatever code they sent you.  
04:49 - And we want to make sure that we select 
the free plan so we're not charged.  
04:56 - Okay, and at that point, we 
should have an account set  
05:00 - You will receive an email address probably just 
asking for you to actually confirm that you  
05:05 - created that account. So we'll just go to your, my 
email, I just like this, and then there should be,  
05:12 - nope, it doesn't look like we need to actually 
confirm anything. So it looks like we're done at  
05:16 - this point, we can just select this button right 
here, and just go and sign into the console. And  
05:22 - so we're gonna sign in as the root user at this 
point, because that's all that's been created.  
05:27 - And so we'll just specify the email 
address that we signed in with.  
05:37 - And we're gonna have to pass in the same password. 
Okay, so there you go, we've created an AWS  
05:44 - account. So at this point, you should have 
access to all of the resources within AWS,  
05:49 - you are logged in as a root user. So if you want 
to create other users, you can do that at that  
05:53 - point. Um, but most of my videos, I usually just 
log in as the root user just for simplicity sake.  
06:00 - To install terraform on a Windows machine, there's 
a couple of steps that we have to perform. And the  
06:04 - first step is to download the terraform executable 
file. And so to do that, all we have to do is  
06:09 - just do a quick Google search for terraform. 
And we're going to select that first link,  
06:14 - it's most likely going to be the first link. But 
if you want to navigate directly to their website,  
06:17 - you can just go to www.terraform.io. And then just 
click this download button right here. And here,  
06:24 - we can see all of the different operating 
systems that terraform can run on.  
06:28 - But for installing Windows, we're going to 
focus on that. So we want to select the 64  
06:31 - bit machine because that's what my machine is, 
however, if you're using 32 bits, like 32 bit.  
06:38 - And this will download a zipped folder. And so 
Once that's complete, you know, just right click  
06:42 - and go into show in folder to just navigate to 
your downloads folder, or wherever you store  
06:47 - your downloads. And this is a zip file folder, so 
we want to extract it, so I'll just right click,  
06:52 - extract all. And it's going to pick a 
location. So this is the default location,  
06:56 - I usually just leave that be. And so we'll 
hit extract, it'll pop up in a new window,  
07:00 - we can just close that out. But you'll 
see that right next to that zip folder  
07:04 - is the new folder that we extracted. 
And so I'm going to go into there.  
07:09 - And you'll see that we just have one file in 
here. And that's just the single executable file  
07:14 - that terraform needs to run. And so what we're 
going to do is we're going to copy this file, and  
07:19 - we're going to create a new terraform directory 
where we're going to store this executable file.  
07:24 - Now, where do you create this terraform directory 
does not matter. You can pick whatever location  
07:28 - you feel most comfortable with, if you want to put 
it in my documents, that's fine. If you want to  
07:31 - leave it in downloads, that's fine. The only thing 
that matters is you remember the exact location of  
07:36 - where you're keeping this file. So what I'm going 
to do is I'm going to go to my PC, and I'm gonna  
07:40 - go into my C drive. And I'm just gonna make a 
new folder here, cuz that's where I want to keep  
07:44 - it. And I'm just gonna call this directory 
terraform doesn't really matter what you call  
07:49 - it. And I'm just gonna paste in that executable 
file. Okay, and like I said, before, you know,  
07:55 - the location doesn't matter. The only thing that 
matters is you remember this exact path to this  
07:59 - file. And so to actually get this exact path, go 
up to this search bar right here. Well, actually,  
08:05 - this is the search bar, whatever this is, and just 
click, and you'll see that it'll turn it into the  
08:10 - exact it'll transform it to the exact path. 
So I'm just going to highlight that, copy it.  
08:18 - Okay, and now what we want to do is we want 
to set an environment variable that points to  
08:24 - this path. So I'm just going to go to whoops, 
not command, I want to go to E and V. So just  
08:28 - search for those letters. And there'll be a button 
that says edit the system environment variables.  
08:33 - And then we want to select this button 
down here, this is environment variables.  
08:37 - Okay, and we want to focus on system variables. So 
we'll hit edit. Whoops, we actually want to select  
08:45 - our specific environment variable. And the one we 
want to modify is path. Okay, so we'll hit edit.  
08:51 - And so you'll see all of our environment variables 
for the PATH variable. And what I'm going to do  
08:57 - is hit New. And I'm just going to paste in 
what I copied. So that path to that folder,  
09:02 - hit OK. And OK, and then hit OK. We're done. Okay, 
and so if you have any terminal windows open, make  
09:10 - sure you close it after you make that change. If 
you didn't have one open, then don't worry about  
09:14 - that. And so now what we want to do is we want to 
type in cmd. And we want to open up the command  
09:19 - prompt. And I did not mean for that to be that 
big. And I'm just going to type in terraform dash  
09:28 - v. Okay. And if you see this output, that means 
basically, this command is just going to tell you  
09:35 - what version of terraform you have installed. So 
right now I have version 12 dot 26, you may see  
09:40 - a different version. If you download this in the 
future. The only thing that matters is that we see  
09:44 - this output. So if you see anything else, that 
means there was an issue with your installation  
09:49 - of terraform. I remember I recommend you just 
repeat the steps that I covered in this video.  
09:54 - There really shouldn't be any issues that you 
run into. Just make sure that once you're done  
09:58 - that you see this output and that's it. You can 
now start running terraform on a Windows machine.  
10:05 - Now there's a couple of different ways to install 
terraform. On a Mac machine, however, my favorite  
10:11 - way is through using a tool called homebrew. And 
if you aren't familiar with what homebrew is, it's  
10:15 - a package management tool for Mac OS. So it can be 
used to install all sorts of different packages,  
10:21 - not just terraform on your Mac. So I highly 
recommend that you, you know whether you choose  
10:26 - to use this method or not eventually install 
homebrew it'll make your life a whole lot easier.  
10:31 - And so to actually install homebrew, 
let's just do a Google search for it.  
10:35 - And it should be the first link. So 
brew.sh is the link that you want to go to.  
10:41 - And it's just going to give you this command 
right here to copy. So copy this command.  
10:47 - And we need to go to our terminal now. So I'm 
going to go into finder, I'm going to go into my  
10:53 - applications, and then just look for a terminal. 
So I'm just gonna do a quick search for that.  
11:04 - Okay, and so this is what we want right here 
if you aren't familiar with the terminal.  
11:15 - Okay, and so once the terminals open, just 
copy and paste that line that you copied.  
11:21 - And then hit enter. And so this will 
automatically install homebrew for us,  
11:25 - you will have to provide your password. And 
then it'll just let you know that you need to  
11:32 - hit return to continue. So just hit return. 
And this is going to take a little bit of  
11:36 - time. So I'll pause this video for now and 
touch base with you guys. Once that's done.  
11:48 - Alright, now they brew our homebrew is 
installed, we can actually use homebrew  
11:52 - to install terraform and with homebrew will 
have access to a whole bunch of new commands,  
11:57 - mainly the brew install command. So anytime you 
want to install a package using homebrew all you  
12:02 - to do is type in brew, and then install and then 
the name of the package that you want to install.  
12:07 - So we want to install terraform. So we can 
just do brew, install terraform, hit Enter,  
12:12 - and it's going to download the terraform 
package for us and handle everything that we  
12:15 - need. Alright, now that the terraform installation 
is complete, there's one last thing we need to  
12:22 - do. And that's verify that the installation 
went okay without any issues. And to do that,  
12:26 - all we have to do is just type in one command 
and that's going to be terraform dash v. Okay,  
12:33 - and it should if the installation went okay, just 
print out whatever version that was installed.  
12:37 - And so you can see that I am running version 12 
dot 26. However, if you're watching this video,  
12:42 - my future you'll probably see a different 
version most likely a higher version number.  
12:46 - But the only thing that matters is that 
you see the version getting printed out if  
12:50 - you see anything else, if you see an error, 
that means that the installation did not go  
12:55 - as planned. And so you'll probably have to redo 
the steps that I covered in this video. But you  
12:59 - know, I don't think you should be running into 
any issues, it's a fairly straightforward process,  
13:04 - homebrew will set up everything for you. 
So you shouldn't run into any issues.  
13:10 - To set up terraform on a Linux machine, the 
first thing that we have to do is download  
13:14 - the terraform package. So we can just go to 
www.terraform.io. And on the terraform homepage,  
13:21 - we just want to navigate to that download 
button right here. So we'll select that.  
13:27 - And on this page, just select the operating 
system that you're using. So we're using a 64 bit  
13:32 - Linux machine, if you're using 32 
bit, make sure you select 32 bit,  
13:35 - if you're using FreeBSD, then you know 
just select the appropriate package,  
13:38 - I'm gonna select the 64 bit, want to make sure I 
save the file and then hit OK. So at this point,  
13:46 - it should be downloaded. So I can just you know, 
select this right here, and it's going to take us  
13:50 - to where we download it. And it's the zip file, 
so we will have to extract it. And there's two  
13:54 - different ways of extracting it. And I'll show you 
how to do it through the GUI. And I'll show you  
13:58 - how to do it through the command line depending 
on whichever method you prefer. So I want to  
14:03 - extract this zip file that we just downloaded. 
So I can just select that and then hit extract.  
14:07 - And then we'll hit extract again. And then 
it'll say extraction is completed. And then  
14:11 - we can select Show the files. And it's going to 
show us in our Downloads directory, the original  
14:16 - zip file as well as the unzipped terraform file. 
So this is the file that we really care about.  
14:21 - However, I want to show you guys how to do this 
to the command line because I think that's an  
14:24 - important skill to have. So I'm just going to 
move to trash. Okay, and I'll show you how to  
14:30 - do it through the command line. So we'll just 
go to our applications and search for terminal.  
14:36 - And we want to navigate to where that zip folder 
is. And so I set up my machine to download  
14:42 - all files to the Downloads directory. That's 
usually the default location. And so we'll do CD  
14:48 - downloads. And if I do an ls we should 
see the zip file and I can just do unzip  
14:57 - and then the name of the file. However, if you 
don't actually have the unzip utility, then you'll  
15:01 - have to do a sudo. You know, apt install unzip 
first so that you can get access to that utility.  
15:08 - And then once you have access to that utility, 
you can just do an unzip and then terraform.  
15:12 - Okay, and you'll see that, if 
you were following along on the,  
15:16 - the GUI, you'll see that it did create the file 
for us. And we can verify with an LS. So we've  
15:21 - got the original us. So we get the original zip 
folder, as well as the terraform executable file.  
15:28 - Now we're almost done. However, there's, there's 
one thing that we have to do is we want to move  
15:32 - this to a location that will allow us to run the 
terraform command, regardless of what directory  
15:37 - we're in, because right now, we can only run 
it when we're in this exact directory. And  
15:42 - it's kind of a pain to always have to move to our 
directory to be able to run terraform commands. So  
15:46 - what I want to do is or what I want you guys 
to do is type in the command MV. So this is  
15:51 - going to move a file to a specific location. 
And then we want to move the terraform file,  
15:55 - and we want to move it to slash user slash local 
slash bin. Okay, and it's going to throw an error,  
16:04 - it says permissions denied. So if you see that 
error, just run the same command except put in the  
16:08 - word sudo. beforehand. So this is going to give 
us root privilege. And you need root privilege  
16:13 - to move any folder into this specific directory. 
So hit enter, it's gonna ask for our password.  
16:20 - Okay, and so it looks like it's 
completed. So we'll just move  
16:22 - to that directory and just verify 
that it did actually move it there.  
16:30 - Okay, so it's in the user slash local slash bin 
directory. Now I want you to move back to your  
16:35 - home directory. So you can do a CD and then Tilda 
that's going to take us to our home directory,  
16:41 - or just move to any directory, if you 
want to move to the root directory,  
16:43 - you just move out of that folder. And now what I 
want you to do is type in the command terraform  
16:49 - dash v. Okay, and if you see this output, it 
should print out the version of terraform that  
16:55 - we downloaded. So I'm using version 12, not 
26. However, if you're watching this video  
17:00 - in the future, you're probably going to see a 
different version, that's perfectly okay. The  
17:04 - only thing that I want to ensure is that you see 
some version get printed out, that means terraform  
17:09 - is installed, and everything is working properly. 
However, if it spits out any other message, okay,  
17:15 - if it shows you anything else, like, you know, 
terraform is not a command or anything like that,  
17:19 - that means there was an issue with your 
installation, and I recommend you just,  
17:23 - you know, repeat all the steps that I performed. 
And, and hopefully that fixes any issues that you  
17:29 - may run into. Um, but at this point, you're good 
to go, you can start using terraform. And so you  
17:34 - know, in the next videos, we'll get started on, 
you know, actually playing around with terraform.  
17:39 - Okay, so there's one last step to setting up 
terraform. And this is technically an optional  
17:44 - step, but I highly recommend it. And so what 
we're gonna do is we're going to install a  
17:48 - very powerful text editor. Now you can use any 
text editor of your choice, it's not going to  
17:54 - make a difference. So if you prefer something 
like sublime, feel free to use that. However,  
17:58 - I'm going to be using one that's called Visual 
Studio code. So this is a free text editor that's  
18:03 - provided by Microsoft. It's supported across all 
operating systems. And that includes Windows,  
18:08 - Mac, Linux, and it really is one of the best 
text editors out there. There's a lot of people  
18:13 - that use it. And I highly recommend you guys use 
this if you want to follow along with my videos,  
18:18 - because I'm going to provide a lot of tips within 
VS code that will help make your life a little bit  
18:22 - easier when you're trying to work with terraform. 
So if you want to follow along and get VS code  
18:27 - as well just go to code dot Visual Studio Comm. 
And the website should automatically detect what  
18:33 - operating system you're on. And so you should just 
be able to hit this button. So you can see here  
18:37 - it detected, I'm using Windows, but if you're on a 
Mac, it should say, you know, download for Mac, to  
18:41 - just download that. And you know, moving forward, 
that's what I'm going to be using. But you know,  
18:46 - once again, if you want to use something else, 
feel free to do that. But anyways, once you've got  
18:51 - VS code installed, I do recommend that you install 
an extension. So if you aren't familiar with  
18:56 - extensions, extensions, within VS code just give 
you some extra functionality. So to actually see  
19:02 - your extensions, you know, once you open up VS 
code, it looks like I already had it open, but  
19:07 - you want to navigate to this button right here. 
So this is going to manage all of your extensions,  
19:12 - and just search for terraform. Okay, so once 
you search for terraform, the first one should  
19:16 - be the one that you want. But just to double 
check, make sure it's the one by hashey Corp,  
19:20 - who's the company that makes terraform and just 
do an install. And so this extension is going  
19:25 - to provide us a lot of features that make our 
life easier, so you can take a look at them. But  
19:30 - obviously auto completion is great syntax 
highlighting auto formatting. You know,  
19:35 - all of these are going to make your life a 
lot easier when you're writing terraform code.  
19:39 - But you know, once you have that done, at this 
point VS code set up, that's all you really need  
19:44 - to do. It's just going to behave like any other 
text editor. So you can create and delete and  
19:49 - modify files within here. So it's kind of like 
an ID but we're going to use it for terraform.  
19:56 - Now that we've got terraform installed in 
our environment, for the most Part set up,  
20:01 - the last thing I want to do is just create a 
directory that we can store all of our code in.  
20:06 - And so within my documents, I've created a folder 
called a terraform project. And then within this  
20:11 - folder, I've created a folder called Project one. 
So this is going to be where we're going to start  
20:16 - our code for our first project. And so you know, 
feel free to make a directory wherever you want.  
20:20 - If you want to keep it in downloads, if you want 
to keep it on your desktop, just pick a location.  
20:25 - And once you have that location set to actually 
open a folder in VS code, we can just open up VS  
20:30 - code, go to File, go to open folder, and then 
navigate to wherever that folder is selected.  
20:38 - And then we can open it up. Alright, and so at 
this point, it's going to give us a welcome page,  
20:42 - which we don't care about. So just close 
it out. And you'll see that we've opened up  
20:46 - project one within our root directory, and 
there's no files or folders within there.  
20:50 - Now, terraform is written in a language 
called hashey Corp configuration language  
20:55 - in a file that has a.tf extension. So all 
of our terraform code is going to be stored  
20:59 - in a file with a.tf. Extension. So we're going 
to do is we're just going to do new file,  
21:04 - if you right click here and just do a new 
file, I'm just going to call this main.tf.  
21:12 - And the.tf just signifies that this is a terraform 
file, and you'll see a couple of pop ups.  
21:16 - If you install the extension, just ignore those 
for now. But keep in mind that you don't actually  
21:21 - have to call this main, you can call this you 
know file one, you can call it first project.tf  
21:26 - just make sure it has a.tf extension. Now in 
this file, the first thing that you have to do  
21:30 - is define a provider. And in terraform, we 
have this concept of riders which basically  
21:36 - just allow us or it's a plugin that allows 
us to talk to a specific set of API's.  
21:41 - And if you go to their documentation 
page, so if you just go to terraform.io  
21:46 - slash Doc's slash providers, slash index dot HTML, 
is going to show a list of all of the providers  
21:50 - that terraform supports. So if we download, you 
know, let's say the AWS provider, right, whereas  
21:56 - AWS have provider, that's going to make sure that 
terraform downloads all of the necessary code to  
22:02 - talk to the AWS API, so that we can actually 
create resources within our AWS environment.  
22:09 - But you can see that you know, terraform, 
even though it's really synonymous with,  
22:12 - you know, cloud automation, you can see that it's 
got a ton of providers outside of the cloud space,  
22:18 - it obviously does support, you know, all the 
major cloud providers, as well as some of the  
22:22 - smaller cloud providers. But it also supports 
Kubernetes, it supports VMware, it supports,  
22:27 - you know, like digitalocean, DNS. So it's got a 
lot of support for a lot of different platforms.  
22:34 - Just keep in mind, though, anytime you want to 
work with any of these platforms in terraform,  
22:39 - you will have to install the necessary plugins, 
so that we can talk to those providers. And you  
22:45 - might be wondering, Well, you know, we downloaded 
terraform, you know, shouldn't that come with all  
22:49 - the code to talk to all these guys? Well, think 
about this, guys, you know, for the most part,  
22:54 - are you guys going to be working with all of these 
providers? No, each customer, or each user is  
22:59 - going to have a predefined set of providers that 
they're going to work with. And there's no point  
23:03 - in terraform, shipping out all of the code for all 
of these providers in the installation package.  
23:08 - So instead, on a per user basis, or per 
project basis, terraform will figure out  
23:13 - which plugins need to be installed based off of 
the provider configuration in your terraform file.  
23:20 - So we want to use the AWS provider, because that's 
what we're going to be working with. So let's just  
23:25 - click this. And it's going to give us an example 
on how to actually set that up. And so you can see  
23:31 - that this is the configuration for a provider. And 
hopefully this is big enough for you guys. I'll  
23:35 - just do a control. Let me see if I can make this 
a little bigger. We'll zoom in 110%. I think that  
23:41 - should be good enough for you guys. But yeah, this 
is all we really need. So we can just copy this,  
23:45 - actually, the version is optional. 
So well, we can just leave that out.  
23:49 - I'll just do copy. And I'll just paste that in 
here. And I'm just going to delete the version.  
24:00 - And now we're hard coding the region to be 
US East one. And you know, before I do that,  
24:04 - we'll kind of want to explain exactly, you 
know, what are regions if you're new to AWS,  
24:10 - basically, a region is just a location 
where Amazon or AWS has a data center.  
24:15 - And so there's a whole bunch of different 
regions. And we can actually take a look at  
24:18 - all the different regions that Amazon has if we 
just search for AWS, and login to our console.  
24:25 - And so let's say my account, we want to go 
to AWS management console to log back in,  
24:31 - and I'm going to be logging 
in as my root users will do.  
24:41 - Okay, so this is our management console. And 
if you just select this button right here,  
24:46 - so right now mine says Northern Virginia, 
but yours may say something else.  
24:50 - You can see all of the different regions or data 
centers that the that AWS has, and so it's going  
24:56 - to default and use whichever data center is 
G Graphically closest to you. So I'm on the  
25:02 - east coast in the US. So it defaults to using the 
Northern Virginia data center or what's referred  
25:06 - to as US East one. However, if you're in like 
California, it's going to default to probably us  
25:11 - West one. And so what I would recommend that you 
guys do is that following along with me, I would  
25:16 - recommend that you just use US East one, like 
I am, it's going to, it's going to help prevent  
25:23 - any weird issues with like ami is because for some 
reason, like if you want to deploy an Ubuntu ami,  
25:29 - in one region, like US East one, and one region in 
like us West one, they'll have different names or  
25:34 - IDs, I don't know why AWS decided to do that. 
But it can lead to issues, because if you're  
25:40 - copying my code, the AMI instances might be called 
something else. So just set it to US East one,  
25:46 - and in AWS, or sorry, in terraform, set it to US 
East one. And so that way, you know, my resources,  
25:52 - as well as your resources will get deployed in 
the same exact region. And we should hopefully,  
25:56 - avoid running into any weird issues. All right. 
And so now that we've got the provider set up,  
26:02 - if we go back to the code, it's going to 
keep walking us through how to set things up.  
26:06 - And so the next thing that we have to do is set up 
authentication. Now, authentication can be a bit  
26:12 - tricky with terraform. And what I'm going to do 
is I'm going to start off doing it the wrong way,  
26:16 - I we're going to just hard code our static 
credentials into our terraform file, which is not  
26:21 - recommended. Because obviously, if you're storing 
your actual access keys, within this terraform  
26:27 - file, if you decide to eventually publish your 
code onto you know, GitHub or something like that,  
26:33 - well, then now all of your your, your credentials 
are being stored in GitHub. And so that can be a  
26:38 - security vulnerability. However, I want to start 
off doing it like that, because one, I want to  
26:42 - show you guys how to do it every possible way. 
But also, just to keep things simple. For now,  
26:46 - I promise we'll have some sections later on, 
that covers how to do this in a more secure  
26:51 - manner. But let's start off just by, you know, 
doing the bare minimum, so that we can focus on  
26:57 - learning terraform, before we start worrying, 
worrying about security, or anything like that.  
27:02 - And so basically, all we have to do is get 
our access key and our secret key and pass  
27:06 - it into the provider config. And so to do that, 
let's go back to our AWS Management Console,  
27:12 - and you want to just select your profile name, 
and then just go to my security credentials.  
27:19 - And then here, you want to select this 
access key tab, and you want to select  
27:23 - Create new access key. Okay. And if you do 
show access key, these, this is my access key.  
27:29 - And this is my secret access key. But this 
is what I'm going to paste into terraform.  
27:34 - Alright, so I'm going to copy this 
right here, paste it into my code,  
27:41 - and then go back to here, and then copy 
my access key. paste it into here. Whoops.  
27:59 - Alright, so we've got our access keys set up in 
terraform. Now, when you actually create security  
28:04 - credentials, within AWS, you can only see these 
values once. Okay, so once, once you see these,  
28:11 - you won't be able to get them again. So 
make sure you store them in a safe place,  
28:14 - you can actually hit this download key file, 
and it's going to download a CSV file with all  
28:19 - of that information. So we can just click on 
that. And it'll by default open up in Excel.  
28:24 - But you can see here, this is 
where my access keys are stored.  
28:28 - So just keep that in mind. Because once you hit 
close, if you do try to look at your access keys,  
28:33 - you'll see that we can see the key ID but we 
can't see the secret key anywhere in Amazon  
28:37 - does that for security purposes. So make sure 
you write that down. However, if you lose it for  
28:42 - some other reason, just delete your old one and 
then just create a new access key, and then you  
28:46 - should be good to go. Okay, so now that we have 
our provider set up and our access key set up,  
28:52 - the next thing to do is let's try and figure out 
how we actually create or provision a resource  
28:57 - within AWS. And within terraform, the syntax is 
actually really simple. And this is probably one  
29:03 - of the nicest parts of terraform. And is really 
the main selling point of terraform is that,  
29:07 - regardless of what provider you're using, so 
whether you're trying to create a resource within  
29:12 - AWS, or a resource within Azure or GCP, it's gonna 
use the same exact syntax from a terraform side,  
29:19 - so that you don't actually have to learn the 
underlying API from you know, Azure, or AWS,  
29:24 - or GCP. And the main syntax is going 
to be you type in the word resource.  
29:29 - And then in quotations, you're going 
to first provide the provider name.  
29:34 - Right, and so in our case, we would 
pass in AWS, then you do underscore,  
29:38 - and then you do resource type, right, whatever 
type of resource you're trying to deploy.  
29:43 - And then you have to give it a name. And then 
we're going to do curly braces. And then within  
29:48 - the curly braces, we provide in all of our 
config options. And these are going to be basic  
29:55 - key value pair. So key equals and then you 
know, some value, right and then Key two,  
30:03 - that's going to equal, you know, another 
value. So that's the basic structure  
30:07 - of how to create resources within a provider. And 
so I'm just going to comment that out for now. And  
30:13 - I'm going to walk you through how to deploy an EC 
two instance, within AWS. And if you don't know  
30:19 - what EC two ns is sorry, it's basically just a 
virtual machine within AWS. So if you want to, if  
30:24 - you want a Windows Server deployed in AWS, you're 
going to be doing it in EC two. But you know, you  
30:29 - can obviously deploy any type of machine that you 
want. If you want to deploy Linux, if you want to  
30:33 - deploy a database, you can all do that within ECG 
two. And so before we actually deploy that, within  
30:40 - terraform, I want to kind of walk you through how 
to do it within the AWS console, because I think  
30:45 - it's important to see, you know, how to do it in 
the console, and then how it kind of maps to in  
30:50 - terraform. But obviously, if you guys are already 
familiar with AWS and the console, this is going  
30:55 - to be really trivial. So you may just want to 
fast forward the video. This is more from people  
30:58 - that are also kind of learning about the cloud 
while also learning terraform at the same time.  
31:04 - And we can just go to our Services tab at the top, 
select ECS. And then select instances. And you'll  
31:14 - see that I have one instance, terminated in one 
instance running if you just create an account,  
31:20 - you shouldn't see any instances, I'm 
actually going to just delete this for now.  
31:27 - I'm just going to terminate that. 
And I'm going to just deploy a new  
31:31 - instance. So I'm just gonna hit launch instance.  
31:36 - And here we've got all of the different ami that 
Amazon supports, has millions of different ami is  
31:41 - and you can even create your own. However, 
I want to deploy just a simple Ubuntu ami.  
31:48 - And if you guys don't know what an ami is, it's 
really just an image, okay, so there's going to be  
31:52 - an ami for Ubuntu, there's going to be an ami for 
Windows, there's going to be an ami for Red Hat,  
31:56 - one for Fedora. And I'm going to search for 
Ubuntu and we're going to select the 18.04 LTS  
32:04 - and you can see here, this is the actual ami 
ID that's associated with this Ubuntu server.  
32:09 - So we can hit select. Here we specify the the 
instance type, the EC two instance type. And  
32:16 - so you know, obviously there's different you 
know, sizes and speeds. So some have more CPU,  
32:20 - some have more memory. So obviously, if you want a 
really high performing server, you want to go down  
32:26 - to one of the ones at the bottom. But 
obviously, the more high powered they are,  
32:30 - the more expensive they are. 
So for demonstration purposes,  
32:32 - and for just learning to stick to T to micro 
because it's part of the free tier, so you  
32:36 - shouldn't be charged as long as you shut it down 
accordingly. So we'll just hit review and launch.  
32:42 - And you'll get this page, we'll just launch that. 
And it's going to ask you to provide a key pair.  
32:47 - For now just ignore that. So we can just 
say proceed without creating a key pair.  
32:53 - And we're going to launch that instance. And if 
we select this view instances button, that's going  
32:57 - to take us back to the AWS console, and you can 
see that it's now creating this new instance. So  
33:02 - it's in a pending state at the moment, but if you 
give it a few minutes, it'll eventually turn into  
33:07 - it'll, it'll get colored green, which means 
that will have been fully deployed. And then  
33:11 - at that point, you can actually start using it. 
Um, but that's how we create an AC two instance  
33:17 - within AWS using the console. Let's go ahead 
and create it using terraform. Now, so that  
33:22 - I can really show you how quick it is to do it 
through terraform versus just using the console.  
33:30 - So like I said, the syntax is 
going to be just like this.  
33:35 - So we're going to do resource. And then 
our provider is going to be AWS, right,  
33:41 - it's just based off of what's provided 
here. Then we want to do underscore,  
33:45 - and then the resource type. And you might be 
wondering, Well, what is the resource type? Well,  
33:49 - this is something that you actually have to refer 
back to the documentation. So let's go to the  
33:52 - documentation. I'm already on the AWS provider 
page. And we're just gonna do a Ctrl F for EC  
34:02 - to just keep going down. Actually, that's 
not what I wanted. Here we go, we want to  
34:08 - search EC two on the left side. So just open that 
drop down menu. And we can just unexplained data  
34:15 - sources. We don't care about that. We care about 
the resources section. And so what we want to  
34:20 - do is look for AWS underscore instance. So this 
is how we deploy an EC two instance within AWS.  
34:28 - And it's going to give you an example. And 
this is what I love about the documentation  
34:31 - that examples are super helpful. But 
basically ignore the data. Once again,  
34:36 - we want to focus on just the resource. So this is 
pretty much like the bare minimum of what we need.  
34:40 - We have to specify an ami. And 
don't worry about this goofy syntax.  
34:45 - You know, he's using variables and things 
like that, which we're not going to cover yet.  
34:49 - Instead, what we're going to do is we're going 
to hard code the AMI value in the instance type.  
34:54 - For now we'll ignore the tag so I'm just going to 
copy this and delete But I had started already.  
35:03 - And so you'll see that Remember, the syntax is 
the provider, underscore, and then the name of  
35:08 - the resource type. So in this case, it's just 
instance. And then we have to give it a name.  
35:12 - So this is a name, that's not going to be, you 
know, set in AWS, this is a name, so that we can  
35:19 - reference this resource within terraform. So this 
name is just going to be scoped to just terraform.  
35:25 - It has AWS will not be aware of this name. So 
I'm just gonna give this name of my first server.  
35:35 - But you can call it whatever 
you want. Okay, and so the AMI,  
35:39 - we're going to delete that. And to get the AMI, 
we're going to deploy another Ubuntu server.  
35:45 - And we'll do a launch instance. And then 
if we search for that Ubuntu server, again,  
35:50 - we want to go here and just copy this ami. 
And I recommend you follow these exact steps,  
35:56 - and not just copy what's on my screen, because 
Amazon has a tendency to kind of change up the  
36:00 - AMI IDs. And so you may end up copying this one, 
which may get changed in the future. So you know,  
36:07 - go to here, search for it, and then just grab the 
AMI. And we want to put it in quotations. So we  
36:14 - just paste the AMI in there. And then the instance 
type, we want it to be T to micro just like we  
36:18 - selected within the console. And we'll delete 
the tags. And before I actually run that code,  
36:30 - let me go back to services and EC two. And let's 
just verify what we have running right now. So  
36:35 - I've got two terminated and one running. So once 
this gets deployed, we should see two running.  
36:41 - So make sure you save your configs. Now 
what we need to do is open up our terminal.  
36:46 - And so you know, if you're on Windows, you can 
just hit the search button and just search for CMD  
36:52 - to open up the command line, or you know, 
do whatever the necessary steps are for  
36:57 - a Windows or a Mac. And then you want 
to navigate to wherever this project is.  
37:01 - Okay. So for me, that's going to be in documents.  
37:07 - And then I think it's called terraform. 
And at that one terraform dash projects.  
37:16 - And then if I do a dir, okay, so then we want to 
navigate to this project one. And here we're going  
37:22 - to run our terraform commands. However, it's kind 
of a pain to have to open up the command line,  
37:27 - and then navigate to that folder. Instead, what 
you can do is move this off to the side for now,  
37:33 - we can go to our VS code. And this 
is why I absolutely love VS code,  
37:36 - we can go to new terminal. And it's going to open 
up a terminal. And if it's a if it's a Windows  
37:44 - machine is going to open up a Windows terminal, 
if you're on a Mac, it's gonna open up a macro,  
37:49 - if you're on Linux, it's gonna open a Linux 
terminal. And it's going to automatically  
37:51 - take you to the project directory. So you can 
see it's already navigated to project one,  
37:55 - which is the root of our directory. And so here, 
we can actually run our terraform code instead of  
37:59 - having to kind of flip back and forth between our 
code and and this command line right here. So I'm  
38:05 - just gonna close this out, because we don't need 
that I'm just gonna use VS code moving forward.  
38:12 - Okay, and the first terraform command 
that you need to learn is terraform in it,  
38:16 - okay. And so what terraform in it is going 
to do is it's going to look at our config  
38:22 - in all of our terraform files, which are anything 
that starts with the.tf. And it's going to look  
38:25 - for all of the providers that we have defined. 
So right now we just have one provider.  
38:30 - And so it's going to see that we just have 
provider AWS, and it's going to download  
38:33 - the necessary plugins to interact with the AWS 
API. Let's do that. We'll do a terraform in it.  
38:43 - And let's actually take a look at what 
the output is doing. So you can see here,  
38:46 - it's initializing the back end. And it's now 
initializing the different provider plugins,  
38:51 - and then it's downloading the plugin for 
AWS, if we decided to add in a separate  
38:55 - provider, that would be like provider, 
and then maybe one for Azure,  
38:59 - well, then it would not only download the code 
for AWS, it would also download it for Azure.  
39:10 - Okay, but you should see that terraform has 
successfully initialized if you see some other  
39:14 - kind of error, then you may have to do a little 
bit of troubleshooting, but just make sure you see  
39:20 - that, you know, nice shiny green output. Okay. And 
so we've got that set up. The next step we want  
39:25 - to do is I want to show you the terraform plan 
command and the terraform plan command. What this  
39:31 - does is it kind of does a dry run of your code so 
you can see all the changes that will take place.  
39:37 - It'll kind of show you you know if it's going 
to delete any instances if it's going to create  
39:41 - new instances if it's going to modify instances. 
So it'll just do a dry run so that you can make  
39:46 - sure that you're not accidentally about to break 
your production network or something like that. So  
39:51 - I always highly recommend you run a terraform 
plan, even though it is completely optional.  
39:56 - It'll just be like a quick sanity check so that 
you can just gloss over the changes that will be  
39:59 - made. And you can just make sure that you're not 
going to break anything if you do terraform plan.  
40:07 - And this may take a little while depending on how 
much code you've written, but we just have one  
40:11 - instance. So you should see that it should be 
minimal output, it should be a fairly quick.  
40:15 - But if we kind of scroll up a bit, and 
just take a look at what's happening,  
40:19 - you'll see that it's going to color code things 
depending on the action. So if you see a plus,  
40:24 - that means going to create a resource. If you see 
a minus, and it's usually colored red, I think,  
40:29 - I mean, it's going to delete a resource. And 
then if you see something that's orange with  
40:33 - a Tilda, that means that it's going 
to modify a pre existing resource.  
40:41 - And so if we scroll down a bit, you'll see 
that right now, we're going to be creating  
40:45 - an AWS instance, an EC two instance. And 
you'll see that we're using this ami,  
40:50 - and then you'll see a lot of details are 
not known at this point. So it won't be,  
40:53 - it'll be known only once we actually deploy 
it to the to AWS, because we won't know the  
40:58 - ID that AWS gives it until we actually deploy 
it. So you'll see that most of these fields are  
41:02 - unknown, but except for the ones that we've 
actually specified, like the instance type,  
41:07 - source test, check defaults to true, so some of 
the defaults will automatically get applied. But  
41:12 - this is just letting you know everything that's 
going to get changed. So it's going to be creating  
41:15 - a whole bunch of things for this one instance. 
And so now that we've run the terraform plan,  
41:20 - we can now run the terraform, apply to actually 
run our code. So we'll do terraform apply.  
41:27 - And you'll see that terraform apply will do 
something similar to terraform plan where it will  
41:31 - actually take a look at your code and then figure 
out the changes that will take place. And so this  
41:36 - is just another security check. So you can just 
verify that you're not going to break anything.  
41:40 - And it's going to ask you, you know, do you 
want to make these changes, so to approve them,  
41:43 - hit yes. And it's going to run our code now. And 
hopefully, you know, we don't break anything and  
41:50 - everything passes. But you can see here, it's 
creating our first server right now as we speak.  
41:57 - So we'll let that run, it's going to take some 
time, usually creating instances can take a little  
42:01 - while, sometimes up to like 510 minutes, depending 
on what kind of instance you're deploying.  
42:06 - Especially if you're on something like Azure, 
I think Azure takes a little while for some  
42:10 - reason. Well, actually, that's pretty quick. But 
you can see that it completed. And it'll give  
42:14 - you kind of like a quick overview of the total 
number of changes that were made. So you can see  
42:19 - one resource was added zero were changed, and zero 
were destroyed. And you know, as usual, you know,  
42:24 - just because terraform says it's finished and 
completed, we want to double check within AWS  
42:30 - to see if that instance actually got created. So 
you can see that this was the state before we ran  
42:34 - terraform. So we've got two and a terminated 
state and one in a running state. So if I hit  
42:40 - this little refresh button, it's going to just 
refresh it. And you can see now we have to in  
42:45 - a running state. And this instance right here is 
the one that it got deployed by terraform, because  
42:50 - you can still see that it's an initializing 
state. But if we click on this and just kind  
42:54 - of take a look at the details, you can see that 
it's a T two micro instance, like we specified.  
42:59 - And you can see the AMI, so this is the AMI which 
is using Ubuntu 18.04. And so there you have it,  
43:06 - guys, you've successfully deployed your 
first EC two instance using terraform.  
43:10 - And hopefully, you can really start to 
see the power of terraform, just from  
43:13 - this simple example. Because I mean, what if we 
wanted to deploy 50 different instances, right?  
43:18 - Would you want to manually have to click through 
these windows 50 different times? Or would you  
43:22 - want to just copy and paste a couple of, you know, 
instances right here, and then you're good to go?  
43:32 - Okay, so we've successfully deployed our first EC 
two instance, using terraform. And what I want to  
43:37 - do now is I want you guys to try and guess what 
will happen if we do another terraform. Apply?  
43:43 - I don't actually run this, just try to figure out 
what would happen. And I can pretty much guarantee  
43:48 - you that your guess is going to be incorrect. 
I'm assuming most of you guys that are watching  
43:54 - are probably going to assume that well. terraform 
is going to run this code again. And it's going  
43:58 - to create a another EC two instance. So we would 
end up with two EC two instances. And I'm going  
44:03 - to tell you that that is incorrect, in fact, and 
the reason for that is that terraform is written  
44:10 - in a declarative manner. And what that means 
is that we're not actually giving terraform  
44:16 - a bunch of steps to carry out like a, like a 
normal program would, right? So it's not going  
44:21 - to go through this code and just run through 
each one step by step. Right. So if we wrote,  
44:25 - If we pasted this one, you know, it's not going to 
go and say, okay, we want to deploy one resource,  
44:31 - and then we want to deploy another resource. 
Instead, what's actually happening is that  
44:36 - we're telling terraform, what we want our 
infrastructures to look like in the end.  
44:41 - So we're giving it the exact blueprint of what our 
infrastructure should look like. And so if we look  
44:47 - at our terraform file here, it says that we should 
have just one AWS instance in our infrastructure,  
44:54 - and that is it. So no matter how many times 
we apply terraform or run terraform apply.  
44:59 - We should all We just have one AWS instance. And 
that's this specific instance. Right. So that's  
45:05 - why in terraform, we're not giving any set of 
instructions to carry out, we're trying to define  
45:10 - what our entire infrastructure should look like. 
And then terraform will go in and then figure out  
45:16 - exactly what needs to get deployed, what needs 
to remain the same, what needs to get deleted,  
45:22 - so that our actual state in AWS matches 
what's being defined in our terraform code.  
45:29 - So if we do terraform, but before we do apply, 
I always recommend you do a terraform plan.  
45:34 - So if we do a terraform plan, again, 
it's going to tell us what the changes  
45:38 - that would take place. And you'll see that it's 
actually refreshing the state. So if we look here,  
45:43 - it's refreshing. It's refreshing the state 
of our AWS instance that we actually deploy,  
45:48 - just to make sure it's still there. 
And there are any issues with it,  
45:50 - and that it matches what's here. And then you 
can see here, it's telling us that, Oh, look,  
45:54 - no changes were made, or no changes need to be 
made. infrastructure is already up to date and  
45:59 - matches what's defined in our terraform file. 
If I do a terraform, apply and hit enter,  
46:09 - it's going to once again, refresh the state of 
our AWS instance. So it's just basically talking  
46:13 - to the AWS server, just making sure that instance 
is still alive and working. And then once again,  
46:18 - when we run the terraform, apply, it figures 
out that look, nothing needed to get added,  
46:22 - changed or destroyed. Okay, and this 
is an important concept, I think it's,  
46:27 - it's a little bit challenging at first, but just 
know that once again, it's everything's being  
46:31 - defined in a declarative manner, which is a little 
different than a lot of other automation tools.  
46:36 - But you know, keeping that in mind, I want 
to make a few changes. Just to show you guys,  
46:42 - you know, what terraform will do when we start 
adding, you know, extra properties to this  
46:46 - easy to instance. So the simplest change we can 
make is adding a tag. So if you aren't familiar  
46:52 - with tags, right, you can give any AWS instance, 
a specific set of tags to kind of identify them,  
46:59 - and so that you can actually search 
for them and filter by those tags.  
47:02 - So we'll go back to our code. And actually, 
let's go back to the documentation to see how  
47:07 - we apply a tag. So this is all you have to do, 
you just do tags, and then you just provided  
47:11 - all the tags that you want to give it. So 
we'll copy this, paste it in there. Oops,  
47:34 - I'm just gonna change this tag, I'm just going 
to call this we'll call this Ubuntu server,  
47:39 - we'll just call it Ubuntu. So we're going to give 
it a tag of Ubuntu, make sure you save the code.  
47:47 - And we're going to do a terraform plan now, just 
to see what changes are going to take place.  
47:56 - So it's going to refresh the state. And now 
we've printed out some changes that are going to  
47:59 - take place. And so you know, you'll see that any 
time we're going to change an existing resource,  
48:04 - you'll see this yellow ish orangish color with 
that little Tilda. And so it's saying that  
48:10 - we're going to change something regarding this 
resource right here that we already deployed.  
48:14 - That's the by first server resource. And if we 
scroll down a bit, you'll see that this is the  
48:18 - change that's going to be made. So it's going to 
add in a new tag. Okay. So terraform was smart  
48:23 - enough to know that look, you know, we know what 
the current state is of our resources deployed on  
48:29 - Amazon. And right now it has no tags. But in 
our code, we're telling it to have a tag. So  
48:34 - then terraform goes in and figures out Oh, okay, 
I need to add a specific tag to this resource.  
48:42 - So we'll do a terraform apply now. It's 
going to run that same check we just did.  
48:52 - And once it's doing that, once it's done 
doing that, you can see that it's going  
48:55 - to make one change. And we're going to say 
yes, just so we can complete those changes.  
49:02 - Okay, and it successfully completed 
that it's changed one resource.  
49:06 - We'll go back to the console, we always want to 
make sure that the changes actually took place.  
49:10 - Don't just take Tara forms word for it. 
Okay, and so you can see right here already,  
49:15 - the name got populated. So that's the special tag 
for naming a resource. But if you click on the  
49:21 - resource and just scroll down to tags someplace, 
I forget where it is. Should be Where is it?  
49:34 - Here we go. Yeah, I forgot 
on AWS. It's like this tag.  
49:38 - And so you can see here we've got our tag 
which has a key of name and a value of Ubuntu.  
49:47 - and if we remove that, or comment it out, and 
then hit save, we can do a terraform apply again.  
49:59 - And Tara Form is going to talk with AWS API, just 
to get all the information about our server again.  
50:06 - And it's going to see that it has a tag, but we're 
telling it to not have any tags. So then it's  
50:10 - going to make the necessary changes. And so all 
we can see here is that look, we're going to go  
50:14 - from a name of Ubuntu to null, which means we're 
going to remove that tag, we'll run that. And  
50:22 - it should remove that tag. And if we hit refresh, 
you can see that now there are no longer any tags.  
50:32 - Up to this point, you know, I showed you guys 
how to create instances as well as modifying  
50:36 - instances, I think the next logical step is 
to show you guys how to destroy instances.  
50:42 - And so if we want to destroy the instance that 
we created, we can do a terraform destroy.  
50:55 - Once again, when we run a terraform, destroy, 
it's going to do a refresh of our state.  
50:59 - And it's going to show us what are the changes 
are going to be made. So you can see here,  
51:03 - anything with that dark red dash means we're 
going to delete it. So we're going to delete  
51:08 - that one EC two instance that we've deployed. 
And we're going to delete everything kind of  
51:13 - associated with that. And so when we hit yes, it 
should run that and it should remove it from AWS.  
51:28 - Alright, so it successfully destroyed 
our resource, go back to the AWS console,  
51:33 - you can see if we hit refresh, this guy should 
get removed. And so you can see it's now in a  
51:38 - terminated state, and then I forget how long it 
normally takes me like two more hours, and then  
51:42 - they'll get completely removed from the AWS 
console. But that's how you destroy your all  
51:50 - the instances that were deployed using terraform. 
Keep in mind, though, you know, if we had like, I  
51:56 - don't know, 1010 of these resources, what's going 
to happen is, when you do a terraform, destroy,  
52:02 - it's going to destroy every single resource 
that was created by terraform. So keep in mind,  
52:07 - you know, if you want to destroy a single 
resource, there are some parameters that you  
52:13 - have to pass in to actually make that work. By 
default, the terraform destroy will destroy your  
52:17 - entire infrastructure. So you probably won't be 
actually running that very often. Within within  
52:24 - a production environment, usually, usually, you're 
just, you know, doing terraform applies, and then  
52:30 - you know, making changes and then applying those 
changes. However, I do want to show you a another  
52:35 - thing that we can easily do. So first of 
all, let's actually deploy this once again.  
52:40 - So I'm just gonna do a terraform apply, we're 
gonna have to wait for this to get deployed again.  
52:53 - Okay, and once it's deployed, let's just quickly 
double check that has been created. So this is  
52:57 - the new instance, that's been created. And what 
I want to show you is really the power of that  
53:02 - declar style of writing code that I mentioned 
earlier. So instead of doing a terraform, destroy,  
53:08 - to destroy a specific instance, what we can do 
is just, we can just delete this code right here,  
53:13 - right? And so instead of deleting it, 
I'm just going to comment it out for now,  
53:16 - which is doing the same thing as essentially 
removing that code altogether. If we hit Save  
53:21 - terraform will see that look at this. And within 
our code, there's no resources being defined.  
53:26 - And so terraform will see that it'll check the 
state and it will see that there's actually an  
53:30 - EC two instance, deployed by terraform. And I'll 
say, Hey, wait a minute, that doesn't match.  
53:35 - You know, we should not have any resources 
deployed based off of this terraform file.  
53:39 - So let me go ahead and delete that one resource 
that we've deployed. If I do a terraform apply.  
53:48 - It's going to refresh the state 
like it did before. So it's  
53:52 - is refreshing that instance, that we created. 
And it's saying, whoa, whoa, whoa, wait a minute,  
53:56 - right, based off our code, there should not be an 
AWS instance, deployed at all. So let me go ahead  
54:01 - and destroy this sucker. Though, if we hit Yes, 
he's going to end up destroying it. And so that's  
54:06 - just another example of that declarative nature of 
terraform. And so you can use that as a tool to,  
54:13 - you know, delete instances, or delete any resource 
within AWS, as long as you just delete it from  
54:18 - your terraform file, and then run apply terraform 
is going to figure out what you want and what  
54:22 - you don't want. So you don't actually have to 
delete it from AWS, or do a terraform destroy.  
54:30 - So it looks like it's destroyed it. Let's 
just go back to the console, double check.  
54:35 - And so it looks like it's already 
terminated it so it refreshed it for us.  
54:39 - And so there you have it, guys. So that's 
how you delete resources within terraform.  
54:46 - You can do it through the terraform destroy 
or you can just remove it from your code  
54:49 - and do a terraform apply and terraform 
will figure out what it needs to delete.  
54:55 - Till now we've till now all we've done was 
deploy an AWS instance but it See, anything  
55:01 - you can do with the AWS console, we can do it in 
terraform. So I want to start taking advantage of  
55:06 - some of the other things that terraform can do. 
And I want to start playing around with other  
55:10 - resources within AWS. So if you're already if you 
haven't already done so, I'll go ahead and destroy  
55:16 - the AWS instance that you created, you 
want to do it through terraform. Of course,  
55:20 - I don't do it through the console. So either do 
a terraform destroy or just delete this resource,  
55:26 - and then run a terraform apply 
to get that resource removed.  
55:30 - And once you have it removed, what I want 
to do now is I want to explore how to  
55:34 - create a VPC. And I want to explore how to 
create a subnet within that new VPC. Okay,  
55:41 - and so if you don't know what a VPC is, it just 
stands for virtual private cloud. So it's just a,  
55:46 - a private, isolated network, within your AWS 
environment that you can create as many v PCs  
55:51 - as you want, or there may be a limit, but you can 
have a lot of V PCs, and then each one of these  
55:55 - VP C's by default, is going to be isolated 
from one another. And so to create a VPC,  
56:01 - the first thing that we want to do is always just 
navigate towards the documentation. So if you just  
56:06 - search for a resource, AWS underscore VPC, that's 
going to show you how to create a VPC. And you'll  
56:12 - see that the configuration is dead simple, right, 
all you have to do is just provide a cider block.  
56:17 - And so this just means that for our VPC, the 10.0 
slash 16 is going to be the network that's going  
56:24 - to be used for that VPC. So let's just copy 
this and paste it in here to create a VPC.  
56:34 - And I'm going to change this name, so we can give 
this any name that we want. So I'll just call  
56:38 - this my first VPC. And keep in mind that this is 
just the name that's going to be used within our  
56:44 - terraform. So anytime we want to reference this 
resource, we can just reference first test VPC.  
56:50 - And if we want to give the name within AWS, we 
can provide a tag. So you can take a look at  
56:56 - the configs here, and then this is how you do it. 
So there's a specific tag for naming things. And  
57:02 - that's called main with the capital N. And we'll 
call this we'll call this our production VPC.  
57:07 - Okay, and so this once we run this, we'll create 
a VPC. However, what I want to do now is I want  
57:13 - to create a subnet within that VPC. And this 
is going to be a little bit more challenging.  
57:18 - And I'm going to show you why in a second. But 
if we navigate to the AWS subnet resource, if  
57:25 - you don't know how to find it, the first thing I 
always do is just do terraform. And then you know,  
57:30 - AWS, and then whatever resource you're trying 
to configure. So if you want to see a subnet,  
57:33 - just search for subnet, and it's usually going to 
be either the first or the second one. So we want  
57:38 - AWS underscore subnet. So it's going 
to be the second link in this case.  
57:42 - And you can see how to configure it is pretty 
easy. Alright, so we just specify resource,  
57:46 - AWS subnet, then the name. And then we have 
to specify a VPC ID, we also have to specify  
57:53 - a cider block. So what subnet do we want 
to use for that subnet? That makes sense.  
57:57 - And then any necessary tags. So let's copy 
this. And let's paste it down here. And so  
58:04 - I want to change up a few things. I'm gonna 
change this to I'm going to call this subnet one.  
58:14 - And the cider block 10.0 dot 1.0, slash 24. That's 
fine. Just make sure it falls within this range.  
58:23 - And then for tags, I'm going 
to call this prod subnet.  
58:30 - Okay, and here, we have to specify the VPC ID,  
58:33 - and you're probably thinking, Well, 
you know, we haven't deployed this VPC,  
58:37 - how do we get the VPC ID right, I can't go into 
the console and get it because we haven't actually  
58:41 - created that VPC. This is where the power of 
terraform comes in. Right, we can reference  
58:47 - other resources that are being defined within 
our code. So we want to reference this VPC that  
58:52 - we're creating, and pass in the ID down to this 
field. And the way to do that is pretty simple.  
59:02 - All we have to do is we have to specify 
the resource name. So we'll do AWS  
59:07 - underscore VPC, just like it is up here. 
Then we do a dot, then we have to take the  
59:12 - name of it. And so we'll take this name. 
And so that's why the naming is important.  
59:16 - paste it here. And then we have to get a specific 
property off of that resource. And so every  
59:21 - property has an ID, sorry, every resource has 
an ID property that we can access. So this value  
59:28 - right here is going to get the ID of this VPC that 
gets created from the line above. Okay? And so  
59:34 - that's how we can reference other resources that 
are being defined in our code, right? So you just,  
59:40 - what I do is for simplicity sake, I usually just 
copy this whatever's between the quotations and  
59:47 - I just remove these two quotes, put in a dot and 
then put it in a.id. That's my little shortcut.  
59:55 - Okay, so I think we're good to go. Let's try to 
run this and deploy it. So we'll do a terraform  
60:00 - Apply. Actually, let's do a terraform. 
Yeah, let's do a terraform apply.  
60:06 - And so we'll see all the changes that are 
being made. And let's scroll up a bit.  
60:11 - And so you'll see that we're creating a subnet. 
And we're also going to be creating our VPC. And  
60:17 - you'll see all the details that are 
being passed into it. So we can hit  
60:20 - yes, at this point, and it's going to 
deploy that VPC as well as that subnet.  
60:26 - Okay, it looks like it's already done. That 
was super quick. I guess it's really just  
60:29 - easy to instances that take a long time. But if 
we go back to our dashboard, what is this bear  
60:36 - Who cares? Anyways, let's go to services, search 
for VPC. And let's take a look. So you can see,  
60:47 - by default, there's a default VPC for every user. 
So this is the default VPC that gets created. So  
60:52 - we don't, we can ignore that. I just wanted 
to make sure you guys understood that if you  
60:55 - were confused as to why there's two v PCs. But 
this is the VPC that we created from terraform.  
61:01 - And if we take a look at the details, we've 
got the cider block that we assigned to it.  
61:05 - And then the tags, obviously the name being 
production. And if we go to our subnets.  
61:10 - So there's going to be a whole bunch of subnets 
here, but once again, these are all part of the  
61:14 - default VPC that gets created. And we want to just 
take a look at the one we created, which is prod  
61:19 - dash subnet. And so if we go here, we'll see that 
the VPC that this subnet resides in is this VPC,  
61:27 - which is prod, which is going to be the VPC that 
we created within terraform. And then we also have  
61:34 - the cider block, which the 10.0 dot 1.0 slash 24. 
And so that's pretty much it. Obviously, there's a  
61:41 - tag, which is the name, which you can see right up 
there. Now, there's one thing I want to point out,  
61:46 - you're probably thinking, well, since when we 
create the subnet, and we're referencing the VPC,  
61:52 - the VPC resource has to get declared first. 
And what may be shocking is it actually  
61:58 - does not need to be defined first. And I'm 
going to, I'm going to prove that to you.  
62:05 - I'm going to do a terraform destroy when 
I let that get destroyed real quick.  
62:16 - Okay, so it's been destroyed. Let's just double 
check and make sure. Okay, and so that's gone.  
62:21 - And what I'm going to do is just to prove 
my point, I'm going to copy this, or cut it  
62:25 - and paste it right above right above the VPC. So 
now, within our code, we're defining the subnet,  
62:33 - and we're referencing the VPC, even though the 
VPC is defined beneath it. And once again, guys,  
62:39 - this is just to show you guys that the order 
in which you place your code does not matter  
62:44 - within terraform, which is a little confusing, 
right? If you're familiar with programming,  
62:49 - right, it always follows a sequential order, 
starting from the top and working to the bottom.  
62:55 - Let's make sure we save everything. And then 
let's do a terraform. Apply. And, guys, if you get  
63:03 - tired of having to hit yes, whenever you want to 
destroy or create something, you can always do the  
63:09 - dash dash auto approve, and that's going to skip 
that step. So that way, you can just run it,  
63:15 - step away from your seat, go grab something to 
eat, and then just come back when it's done.  
63:21 - And so you can see here, even though 
the sub net was declared first,  
63:26 - you can see that terraform Actually, I realized 
that this window is probably not that big for  
63:30 - you guys. And so I'm going to make this 
a little bigger for you guys. Let's see,  
63:36 - is there a way to do that? 
me afraid to do a Ctrl Plus,  
63:41 - there we go. But if you take a look at 
the order in which things are created,  
63:48 - you'll see that we create the VPC first, they 
create and it took three seconds to complete.  
63:53 - And then we created the subnet. So terraform does 
not care which order the order in which you define  
63:59 - things because terraform is intelligent enough 
to figure out what needs to get created first.  
64:04 - So terraform knows that a subnet belongs in a VPC. 
And since this subnet is represent is referencing  
64:10 - the VPC or creating, it knows to create the 
VPC first, and then create the subnet. Okay,  
64:16 - so terraform is very intelligent, it can figure 
out what needs to get created. So you don't have  
64:21 - to worry about any of that nonsense. It'll figure 
out what needs to be done. However, I will say  
64:25 - this, there are certain instances where it can't. 
However, if you look at the documentation will  
64:30 - always tell you whenever terraform can't 
figure out what order to create things,  
64:34 - and it'll give you a workaround. So like usually 
you'll have to pass in an extra flag that says  
64:39 - one resource depends on another but for the most 
part terraform will figure out everything for you.  
64:47 - Now, if you guys have been following along, you 
may have noticed that there's a couple of extra  
64:50 - files that gets created on the left side. And so 
you may be wondering what those mean and you know,  
64:55 - that's what I want to cover in this section. So 
we'll start off with this dot terraform folder.  
65:01 - So this folder gets created whenever we initialize 
any plugins. So when we did a terraform in it,  
65:09 - right terraform in it, it's going to create that 
directory, and then it's going to install all the  
65:14 - necessary plugins for our code to run in this 
folder. So since we have just one provider, all  
65:20 - of the code for the, the AWS provider is going to 
get installed into there. And just to prove that  
65:25 - to you guys, I'm going to delete this real quick. 
And it's okay, it's not going to break our code.  
65:33 - It looks like he just deleted one of those 
folders, I want to delete all of them.  
65:37 - Alright. Okay, so they're all deleted. 
And if I try to do a terraform, apply,  
65:44 - it's going to throw an error saying, Look 
at this, we don't have a AWS provider.  
65:48 - And so what we have to do is we have to 
initialize it again. So if I do a terraform in it,  
65:54 - it's going to do that initialization process. 
And when it does that, it's going to create that  
65:59 - folder that we just deleted. There you go. So 
we see the dot terraform folder, and it's got  
66:04 - the configs for AWS, right here. Now 
moving on to the second folder, or sorry,  
66:11 - the second file that you may be wondering out, 
that's going to be the terraform.tf. state. So  
66:17 - what this file is, is that it represents all of 
the state for terraform. And basically, anytime  
66:24 - we create a resource within AWS or any cloud 
provider, we need a way for terraform to keep  
66:30 - track of everything that's created, right? Because 
that way, if we go to modify a parameter, like add  
66:35 - an extra tag, or maybe change the instance type 
to from like a T to micro to a another size,  
66:42 - it needs to be able to check, you know, what is 
the current status of that resource, you know,  
66:46 - what are its configurations and compare it to 
what's in the code. And the way it does that is  
66:50 - it just creates a simple text file. And so we've 
got this terraform.tf state, and it looks like  
66:55 - it's in a JSON format, I can't remember if it is 
fully JSON, it may not be, you know, don't quote  
67:02 - me on that. But we can basically store all of the 
resources that we create when this state file, so  
67:09 - you can see we've got the AWS provider. And 
if we just kind of look through it real quick,  
67:14 - we can see all the resources it's created. 
So we've got the first VPC that we created.  
67:19 - And so you can see all the details about 
that VPC. And then I think someplace,  
67:23 - there's going to be a subnet. So this is the one 
that covers the subnet. And this is going to have  
67:27 - all of the information regarding the subnet. So 
this file is very important, too. For some reason,  
67:33 - you ever go into this and start deleting things, 
you will break terraform. So terraform will have a  
67:39 - mismatched state from what's actually 
being deployed into AWS. So never mess  
67:44 - around with the TF state file. It's a very 
important file. And we it's absolutely crucial  
67:48 - to the overall functionality of terraform. 
And just to kind of show you how this state  
67:53 - file gets updated, I'm just going to create 
another VPC. And I'm just going to take this,  
67:59 - copy this, and we'll just paste it down here. And 
I'm going to call this we'll call the second VPC.  
68:08 - And I'm just going to change the cider 
block. And we'll change this name to say Dev.  
68:16 - And might as well just create a 
new subnet for that guy as well.  
68:22 - I'll call this subnet two. And for the VPC ID, 
I'm going to reference this VPC. So whoops,  
68:29 - that the typo, and we're gonna just change this to 
secondary VPC. And I'm gonna change the subnet to  
68:36 - make sure that this subnet resides within this 
cider block. And we'll call this dev subnet.  
68:44 - Now, if I do a terraform, apply,  
68:57 - do a dash dash auto approve. And 
once again, typos all over the place.  
69:21 - Now if we go back to our TF state file, we can 
take a look at it. We'll see that there we had  
69:27 - subnet one already. That was already in there. And 
then we've got you know, now we have subnet two,  
69:32 - right? So you can see that anytime we create 
an instance or modify an instance within AWS,  
69:37 - we're going to update our state file so that 
we can keep track of all of that information.  
69:42 - Alright guys, so that's all I 
wanted to cover in this video.  
69:47 - Till now, we've only been doing very simple 
tasks like creating an EC two instance,  
69:52 - or creating a VPC or a subnet and we haven't even 
be been able to log into that EC two instance.  
69:58 - And so what I wanted to do was With everything 
that we've learned so far in terraform, I want to  
70:03 - walk you through how to create an EC two instance, 
deploy it on a custom VPC on a custom subnet and  
70:10 - assign it a public IP address, so that not only 
can we SSH to it and connect to it and make  
70:15 - changes on it, we can also automatically set up a 
web server to run on it so that we can handle web  
70:20 - traffic. And you know, this task, it seems like 
a very simple task with a couple of steps. But  
70:27 - it's actually a little more complicated than you 
think. But luckily, we don't actually have to  
70:31 - do anything from a terraform perspective that we 
don't already know how to do. And so I'm going to  
70:36 - walk you through that. And I've actually outlined 
all of the steps that are necessary to do this. So  
70:42 - there's nine total steps, technically 10, we're 
gonna have to do one step outside of terraform.  
70:47 - Just to keep things a little simple, we could do 
it through terraform. But that would get a little  
70:50 - more complicated. But just to walk you through 
the steps, we're going to create a custom VPC.  
70:57 - And then within that VPC, we're going to designate 
a internet gateway. And the reason we need to have  
71:02 - an internet gateway is so that we can actually 
send traffic out to the internet, because we do  
71:07 - want to be able to assign a public IP address to 
this server so that anybody in the world can reach  
71:12 - it, then the next thing that we need to do is we 
want to create a custom route table. Technically,  
71:17 - this would have been optional, but I thought 
it'd be cool to show you guys because these are  
71:20 - all things that you need to be able to do. So 
I wanted to make sure I walk you through that,  
71:24 - we're going to then create a subnet in step four. 
And then anytime you create a subnet, we have to  
71:28 - assign it to a route table, or then they'll get 
assigned to the default route table for your VPC.  
71:34 - And so this will just associate the two together, 
then we're going to create a security group.  
71:38 - And the security group is just responsible for 
determining what kind of traffic is allowed to get  
71:42 - to any one of your EC two instances. So since this 
is a web server, we're going to allow Port 80 and  
71:48 - Port 4434 HTTP and HTTPS traffic, we're also going 
to allow Port 22, so that we can SSH to it and,  
71:56 - you know, obviously connect to it and make changes 
to it. We're going to create a custom interface.  
72:01 - And that's going to be assigned to the subnet 
that was created in step four. And we'll assign  
72:07 - an elastic IP. So an elastic IP in Amazon world 
is just a public IP address that's routable on  
72:13 - the internet. And then we're going to assign that 
to the network interface we created in step seven.  
72:18 - And then finally, we're going to create an 
Ubuntu server, we're going to automatically  
72:22 - through terraform install, and enable Apache. 
And then we're going to assign that IP address  
72:28 - or that network interface that we created in step 
seven to that Ubuntu server. And at that point,  
72:33 - we should have a live running web server. And 
we should be able to connect to it and you know,  
72:37 - do whatever we want with it. Alright, guys. So 
you know, before we get started, the first thing  
72:42 - that we need to do actually is create a key pair 
within AWS. And the key pair is just going to  
72:49 - allow us to connect to these devices. So AWS 
requires us to set up, set up access keys so  
72:57 - that we can connect to these devices. So to set 
up the keys, we need to go to the EC two section.  
73:02 - And then there's a section within here called 
key pairs. Here we go. So you can see I have  
73:09 - one key pair here already, but I'll walk you 
through how to create a new one. So we'll just  
73:12 - do create new key pair. And here, we'll just 
give it a name. Okay, so we'll call this whoops,  
73:27 - we'll just call this access key. If you 
want to give it a better name than this,  
73:30 - I just couldn't think of one. Okay, how about 
this, we'll call this main key, main dash key.  
73:37 - So there's two different file 
formats that you can use.  
73:41 - Go ahead and download the PEM format. For now, 
I'll show you how to actually convert this to  
73:45 - a ppk if you want to use putty. So, you know 
moving forward, though, if you were mainly a  
73:52 - Windows user, download the ppk. So that you can 
use with putty. If you're using Mac or Linux,  
73:57 - you're gonna want the PEM file. So you know, 
download that but you know, for now, even if you  
74:02 - are using a Windows machine, download the PEM 
and I'll show you how to convert it to a ppk.  
74:07 - So we'll create this key pair. And it's going 
to automatically download this for you. So  
74:13 - just remember where it's getting saved to. So it's 
probably gonna get saved in your downloads folder.  
74:17 - And just keep that in mind. Okay, so now that 
we have our key pair set, this is going to  
74:21 - this key is going to allow us to actually 
connect to our server once we've deployed but,  
74:25 - you know, let's go through this 
step by step and tackle each step.  
74:28 - And you'll see that just how easy it is to create 
all these resources. And I'll obviously point you  
74:33 - to all the necessary documentation so that if 
you guys want to read up further on it, you can  
74:39 - and so the first step, create a VPC, you know, 
you guys have already done this. But, you know,  
74:44 - I'll walk you through that. So obviously, I 
already forgot how to actually configure one.  
74:48 - So just search for terraform AWS VPC, this 
is all I do, guys, you know, just Google it,  
74:53 - and Google will tell you what to do. And so here, 
we're gonna define a resource. A VPC resource.  
75:00 - I'm just gonna copy and paste that. I'm 
gonna keep this as the same cider block,  
75:04 - it doesn't really matter for the purpose 
of this project. Now we need to create an  
75:10 - internet gateway. So this is something new. But 
once again, the power of Google, go to terraform,  
75:16 - AWS and then what was it called internet gateway. 
Okay, so there's a couple of things. Really,  
75:26 - the only thing you have to pass in is 
the VPC ID. So we'll just copy this.  
75:30 - And I'm gonna just go in here, paste that in 
there. don't really care about PACs for now.  
75:36 - And we need to pass it the VPC ID. So remember, 
we can reference a another resource within our  
75:41 - terraform code. And so we'll just reference 
this VPC. So we do AWS underscore VPC, then dot,  
75:50 - well, let me give this a more descriptive 
name. I don't like main, we'll call this  
75:56 - prod VPC. Actually, let's give this a tag as well. 
Why not. And we'll just call this a production.  
76:09 - And so to reference this, we'll do AWS underscore 
VPC, then dot m, the name, so prod, dash  
76:17 - VPC. And then we have to do a dot and 
an ID, because we always want the ID  
76:21 - property of this resource, we 
don't want the resource itself.  
76:26 - And don't worry about giving giving us a tag. So 
that's all we need to do. Now we have to create  
76:31 - a custom route table. So this is something that's 
new again. So we'll just search for that terraform  
76:38 - AWS route table. And, you know, 
obviously, we already have this open,  
76:43 - so we could just kind of navigate to wherever 
it is. But there's just so many resources,  
76:48 - it just takes forever to find what you're 
looking for. So I always just Google it.  
76:53 - And so here, we want the AWS route table. And it's 
going to give us an example. So just copy this.  
77:01 - And I'll take you, I'll explain step 
by step what each line is doing.  
77:11 - And I'm going to give this a name, 
we'll call this prod route table.  
77:16 - And we have to reference the VPC ID, so we can 
just copy what we did with the internet gateway.  
77:27 - And we don't really need a tag for this 
route. Oh, let's get let's give it a name.  
77:31 - I think we'll just call this prod as well. Okay, 
and then now here, this is where we define the  
77:38 - routes for this route table. So if you look at 
this, what this is saying is that for the subnet,  
77:44 - the 10.0 dot 1.0, slash 24, we're going to send 
it to the internet gateway. However, what I want  
77:49 - to do is I just want to set up a default route, 
which means all traffic is going to get sent to  
77:54 - the internet gateway. So to do a default route, 
if you guys aren't familiar with networking,  
77:58 - you just do this 0.0 dot zero, slash zero. And 
this is going to send all traffic, all IP all ipv4  
78:05 - traffic wherever this route points. And this is 
the old syntax of referencing other resources. But  
78:12 - remember, we're just going to do it the same way 
we did for the VPC. So let's find the internet,  
78:16 - the AWS internet gateway. And so we just do 
AWS underscore, internet underscore gateway,  
78:23 - then you do dot, and then we just reference the 
name, so we just give it a name or GW. And then  
78:28 - we want the ID property. Okay, and so that's 
all we have to do to create a default route.  
78:34 - And we can also create an ipv6 default route, I'm 
not using ipv6, but you know, we might as well  
78:38 - go put it in. And so for an ipv6 default route, 
it's already been provided. So you just do colon  
78:43 - colon slash zero, it's the equivalent of this. 
But for ipv6, we can delete this and just point  
78:49 - it to the same internet gateway. And you know, 
once again, this is just going to make it so that  
78:54 - our traffic in the in from the subnet that we're 
going to create can get out to the internet.  
79:08 - Right now we have to create a subnet 
where our web server is going to reside on  
79:16 - this, we don't need to kind of search 
how to do because we've already done  
79:19 - this before. So resource AWS underscore 
subnet. And then let's give it a name.  
79:25 - I'm just gonna call it subnet dash one. 
And then we have to give it a VPC ID.  
79:33 - Let's just grab what we did here for 
the internet gateway and just copy that  
79:38 - a lot of copying and pasting here, guys.  
79:43 - And then we have to give it the the actual subnet 
that we're going to use. So the cider block.  
79:50 - And so I'm going to use the 10.0 dot 1.0 slash 
24 subnet. And there's also another optional  
79:58 - property so we can actually start suffi what 
availability zone we want to use. And if you  
80:03 - don't know what an availability zone is, within 
a region, we it's not that just it's not that AWS  
80:09 - just has one data center. Within each region, 
they actually have a couple of data centers,  
80:14 - I'm not really sure how many maybe like 
three to five. And so that way, if one  
80:18 - of their data centers goes down in a region, 
the whole region doesn't go down. So they have  
80:22 - redundancy. And so you can actually deploy 
resources to a specific availability zone.  
80:27 - And we can pass that in bypassing 
any availability zone property,  
80:31 - and then just specifying the name. So we'll just 
do a US dash East dash one, a. And so there's  
80:36 - going to be US East dash one, a one B, one C, and 
so on. But we're just gonna set it into one a.  
80:44 - And then we can give this a tag as well. So we'll 
set the name to prod, underscores or dash subnet.  
80:55 - And so now we've created a subnet, 
we've created a route table,  
80:58 - but we actually have to assign this subnet 
to this route table. And so there's a another  
81:04 - resource, a resource type within terraform. 
That's called route table Association.  
81:12 - And we'll just let me pull up the documentation so 
you guys don't get confused. So we'll do terraform  
81:17 - AWS route table Association. And all this 
does is just a just associate the subnet  
81:23 - with a route table. And so you can see 
here, we have to pass in the subnet ID,  
81:27 - as well as the route table ID. So we'll copy 
this. And then we just need to update the  
81:33 - subnet and the route table. So we can remove that 
and pass in our subnets. So AWS underscore subnet  
81:43 - dot subnet dash one.id. And then let's grab 
the route table. So I'll just copy this,  
81:55 - paste that in there, remove the quotations, lips,  
82:03 - and then just join them together with a dot. And 
then we want to grab the ID. And that's all we  
82:09 - have to do for the route table Association, we 
can just leave it as the name of a because we're  
82:13 - not going to reference that anyways. So the next 
thing we need to do is create a security group,  
82:18 - this is something new again. And so it's always 
good to make sure that you have a security policy,  
82:24 - that's a really clamped down on only the protocols 
that you need. And so we'll just search for that.  
82:41 - And I'm just going to copy this example 
and walk you through what's happening.  
82:49 - So let's give this a name. 
We're going to call this allow  
82:55 - web traffic. And we're gonna change this to allow 
underscore web. So this security group is really  
83:02 - just going to be there to allow just web traffic. 
So we just want Port 22, Port 80 and Port 443.  
83:09 - And description, we can just change this 
to allow web traffic. And we have to point  
83:14 - to our VPC. So there's, we already know how to do 
that, we can just copy the one from the stub net.  
83:24 - Now, this is where we actually apply 
the different rules. So we have Ingress  
83:26 - policy as well as the egress policy. So in 
this example, what this is saying is that  
83:32 - we are going to allow TCP traffic on port 443. 
Right, so the front port and the two port just  
83:37 - means it allows us to specify a range of ports. So 
if I did 4432447, that means we would allow ports  
83:45 - 443 through 447. So when you just do the same 
number of means we're allowing just that port.  
83:51 - And this is the protocol. So you have TCP you have 
UDP, and so on. And then you have, we can actually  
83:57 - clamp down on what subnets can actually reach this 
box. So we can actually put in like our own IP  
84:04 - address of our of our work computer or something 
so that only certain devices can actually reach  
84:10 - this. And so sometimes it's best not to open it 
up to the internet. But since we're creating a web  
84:15 - server, that's meant to be used by anyone we want, 
we want to allow it so that anyone can use it.  
84:22 - So we'll change this to 000. That 
default, that means any IP address  
84:30 - can access it. But if you just wanted like 
one specific IP, you could just do like 1.1  
84:37 - dot one slash 32. And then this would 
mean that you know just that IP address,  
84:41 - I can access it. But we want everyone to be able 
to access it. So we'll do that. And we can have  
84:46 - as many ingress and egress policies as we want. 
And so this is actually technically for HTTPS  
84:51 - traffic. So htt ps traffic. I'm just gonna call 
it that. And what we want is not to HTTPS, but  
85:01 - we want Port 80 and Port 22. So we can just copy 
this Ingress rule and paste it a couple of times.  
85:09 - Hit Save just so it formats it. And this is 
going to be HTTP. And HTTP resides on port 80.  
85:20 - TCP once again, so all web traffic is TCP. 
And then we want it from any IP address.  
85:26 - And then finally, we want one for 
SSH. So this is going to be Port 22.  
85:32 - TCP, and then yes, any IP address. And if 
you look at the example, for the Ingress,  
85:39 - this is just saying that, you know, we're 
allowing all ports in the egress direction.  
85:43 - And when you put n minus one for the protocol, it 
means any protocol. And for the cider block, it  
85:49 - means any IP address. So this is exactly what we 
want for the egress policy. What's more concerning  
85:54 - is always setting up the Ingress policy. And we 
can change the tag to allow, call it allow web.  
86:06 - Alright, now we want to 
create a network interface.  
86:09 - So let's go to documentation for that. 
So terraform AWS network interface.  
86:26 - And so I'm going to copy this.  
86:33 - We're going to change the name, 
I'm going to call this web server,  
86:37 - Nick. And so we need to assign this 
Nic to the subnet that we created.  
86:46 - Let's find our subnet. Where'd it go? Here 
we go. And don't forget to grab just the ID.  
87:08 - And here we need to specify an IP. So what IP 
do we want to give the server we can pick any IP  
87:14 - address within the subnet? Well, not technically 
any IP address, you know, AWS is going to reserve  
87:19 - a couple addresses like the dot one and a couple 
other ones. So I'm just going to do 10 dot 0.1  
87:27 - dot 5010 dot 0.1 dot 50. And then finally, 
we have to pass in a list of security groups.  
87:37 - And so let's pass in the security group 
that we just created in the step above.  
88:06 - And we can actually attach it to a device 
now. But we're going to skip that. And we  
88:12 - can actually specify what Nic we want to use when 
we actually go to the provisioning section for an  
88:17 - EC two instance. So we're going to delete 
that part. And we don't need that for now.  
88:21 - And then now, so this created the private 
IP address for the host. But we also want  
88:25 - to assign it a public IP address so that you 
know anybody on the internet can access it.  
88:31 - And to do that, we need to create an AWS elastic 
IP. So if we search for terraform, AWS AIP.  
88:46 - All we have to do is just we can 
just grab this as an example.  
88:54 - So VPC equals true, I can't I forgot what 
that actually does, we can take a look at  
88:57 - the documentation. So this just means Boolean if 
the IP is in a VPC or not. So it isn't a VPC. So  
89:02 - we have to set it to true. And then network 
interface. So we can specify what network  
89:08 - interface we want assign it to, which is the one 
we created in step seven. So we can copy this.  
89:27 - And then when it says associate with private 
IP, it's going to be the private IP that we  
89:30 - gave right here. And also, I guess, 
I forgot to point out that, you know,  
89:36 - here we're passing in a list of IP. So 
technically, we could have given more than one.  
89:40 - But we're just going to assign one here. And then 
we can just reference that here. Go to 10 dot 0.1  
89:52 - dot 50. Now, you know I told you guys that 
terraform you know does not care about the order  
89:57 - and it will figure out the order at which things 
need to be deployed so that everything works.  
90:02 - However, there are certain gotchas. And 
this is one of the gotchas right here  
90:06 - is that the AWS IP relies on the deployment of 
the internet gateway, which is created up here.  
90:13 - And so if you try to do this through the 
console, and you try to create an elastic IP,  
90:16 - and assign it to a device, that's, you know, on 
a subnet that are in a VPC that doesn't have an  
90:21 - internet gateway, it'll throw an error, because, 
you know, for you to have a public IP address,  
90:26 - you need to have an internet gateway. So deploying 
an elastic IP requires the internet gateway to be  
90:32 - deployed first before the actual elastic IP gets 
deployed. And I guess terraform, by default,  
90:39 - can't figure that on its own. And if you actually 
take a look at the documentation, it even lets you  
90:43 - know that. So it says, elastic IPS may require 
internet gateway to exist prior to Association.  
90:49 - So you can use the depends on to set an 
explicit dependency on the internet gateway.  
90:54 - So what we can do is exactly what it told 
us to do, we can set a depends on flag  
90:59 - and set that equal to the the internet gateway 
that we created. And here, we actually don't  
91:17 - need to specify the.id, we want to actually 
reference the whole object and not just the ID.  
91:26 - All right, guys, we're almost done,  
91:28 - we just got one last step. And 
that's to create our Ubuntu server.  
91:38 - And here, we're going to do resource  
91:41 - AWS underscore instance. And then we'll 
call this web dash server dash instance,  
91:51 - the AMI, so let's grab the AMI from our 
console again. If we do launch instance,  
92:02 - we'll just search for Ubuntu. And 
we'll grab the first ami right here.  
92:14 - The instance type, we're going to do 
the T to micro again, because it's free.  
92:22 - And here, we can also set an availability zone.  
92:29 - And I'm going to make sure this is very important 
to actually set this to the same one that we  
92:33 - used for our subnet. And so if you remember, 
we go all the way back to the top. Where is it?  
92:41 - Where's our subnet? There we go. Our subnet we 
passed in this availability zone, the dash one a.  
92:46 - And there's a reason why I hard coded the 
availability zone because if you don't hard code  
92:50 - it, Amazon will, will pick a random availability 
zone to deploy that. And I've had a couple of  
92:59 - times where where the subnet would get deployed 
in one availability zone, and then my interface  
93:04 - would get deployed in another availability 
zone. And then I couldn't like combine the  
93:08 - two because they're essentially in two different 
data centers. So whenever you get an option,  
93:11 - make sure you to hard code availability zone, or 
then you could lead to issues where it says like,  
93:15 - Oh, you know, you can't have your server 
in, you know, one availability zone,  
93:18 - and then your subnet and another one, 
it just creates all sorts of issues. So  
93:22 - anytime in the documentation, it gives you an 
option to pass it in, go ahead and pass it in.  
93:29 - Now, if you remember the key pair that we created, 
we need to reference that so that we can actually  
93:34 - access our device. And so let me go back to 
the key pair, what did I call it main dash key,  
93:42 - main dash key.  
93:48 - And now we can specify the network interface. 
We do network underscore interface. And if  
93:54 - you're wondering where I'm getting all of this, 
it's all in the documentation. So if I pull up  
93:58 - AWS terraform instance, it's going to walk us 
through how to do all of this. But what we want  
94:05 - to do is we want to scroll down look for network 
interface. So there's a network interface section.  
94:14 - Within word, it actually it didn't 
take me to the right section.  
94:19 - Here we go. There's a network interface section. 
So we have to define a network interface block.  
94:23 - And this is what a block looks like. So you 
can actually create another block within  
94:28 - our resource to define a few extra parameters. And 
so the first thing that we have to do is provide  
94:34 - a device index. And all this is doing is that, you 
know, for any, any EC two instance that we deploy,  
94:40 - we can give it a ton of different interfaces, 
right, we don't have to just give it one. So we  
94:44 - have to tell it which interface you want it to be 
right because you know it's gonna get labeled like  
94:49 - Ethernet one, Ethernet to Ethernet, three, and 
so on. So we're gonna make sure that this is his  
94:54 - first interface. And you can do that by specifying 
the device index and setting it to zero.  
95:03 - And we want to set that to zero, 
because, you know, it's kind of like  
95:08 - it's kind of like, you know, like in any 
programming language, the first number  
95:10 - you start with is a zero instead of one. So 
this is going to mean that this is the first  
95:15 - network interface associated with this device, 
then we have to specify the network interface ID.  
95:22 - So we just have to reference this 
network interface. So we'll copy that.  
95:42 - And now guys, this is where the actual magic 
happens here. So what we're going to do is  
95:46 - we're going to tell terraform, to on deployment 
of this server to actually run a few commands on  
95:51 - the server so that we can automatically install 
Apache. And the way to do that is to use the user  
95:57 - underscore data block. And what we have to 
do is we have to pass in, it's gonna look  
96:01 - a little goofy. But we just say dash that elf, 
and I forget what this stands for. But you just  
96:09 - put that in there. And then now we just type in 
all of the commands we want to run. So just like  
96:13 - with any bash script, we want to start off with 
the, with this goofy header that you always need.  
96:21 - And then now we just specify all of 
the commands that we want to run. So  
96:24 - we'll do a sudo apt update, dash y, we'll 
do a sudo apt install Apache, two dash y.  
96:33 - And then we'll do a sudo 
systemctl. Start Apache two.  
96:40 - And then finally, this last one's kind 
of optional, but what I'm going to do is  
96:43 - I'm going to copy some text to the index dot 
HTML file that gets served by the web server  
96:48 - does that we can confirm that, you know, 
all of these commands actually worked.  
96:54 - I'm just gonna say we'll say echo. And then we 
want to send a string of text. So we'll just say,  
97:01 - your very first web server. And we want 
to redirect that to slash var, slash  
97:07 - www, but HTML slash index dot HTML. And hopefully, 
I wrote all of that without a typo. And then,  
97:17 - you know, obviously, you guys can run any command 
that you want. So you can put in whatever command  
97:21 - so you can install, you can install any package, 
you know, you can modify and configure files all  
97:27 - from here. But once you're done entering in all 
your commands, you just do elf. So elf at the top  
97:33 - starts all the configs. And then the elf at the 
bottom basically tells terraform that we're done.  
97:40 - And then lastly, let's give it some tags. will 
say name equals, we'll just call this web server.  
97:52 - Let's hit save. And now we're 
going to do a terraform.  
97:57 - Apply. And it looks like I messed something up. 
So let's see, depends on what happened here.  
98:09 - A static list expression is required. Ah, 
okay, I already know my mistake. So when  
98:14 - you use the depends on parameter, you 
actually have to pass it in as a list.  
98:19 - And so the reason we pass in this list 
is because we can actually specify  
98:24 - multiple things that we need to wait on, before 
we actually run the elastic IP. So if we wanted to  
98:29 - make sure that you know the VPC got created, 
we can specify that as well as the subnet and  
98:34 - so on. So you can put in as many criteria 
as you want. So that's why we have to pass  
98:39 - it in as a list. Let's do a terraform. Apply 
again. Hopefully it goes through this time.  
98:49 - Looks like it's good. So far. We'll do yes. 
And let's just now it's time to start praying.  
99:07 - And it looks like we got another error 
on line 25. Let's see what happened here.  
99:16 - Yep. And I already figured out the mistake, 
this should be under the AWS route table.  
99:21 - This should not be egress only gateway 
ID. This should just be gateway Id like  
99:25 - it is up here. And that was just because I 
copied and pasted. I forgot to change it.  
99:33 - But you know, just to make sure you 
guys understand what's happening here.  
99:36 - All we're really doing is we're just saying 
that our default route for ipv4 and ipv6 is  
99:41 - going to go towards the internet gateway 
so that we can get out to the internet.  
100:03 - Alright, it looks like it's done, guys. So 
let's just take a look. Let's just verify  
100:07 - in the console that everything is okay. And so 
we'll go to let's go to our EC two instance,  
100:13 - let's see if it got created. And so we've got one 
that's initializing right now. And that's our web  
100:19 - server, you got the previous one. Obviously, I 
did a dry run before this video, although I still  
100:23 - messed up a whole bunch of things. But this is 
very easy to instance, I think things look good.  
100:29 - Obviously, we can go through each and 
everything, you know, make sure our VPC is good,  
100:32 - make sure our subnets good, make sure our route 
tables good. But that's just a waste of time,  
100:37 - because I already know there okay, I instead, 
what I want to do is I want to actually show you  
100:42 - how we can connect to this device or actually, 
let's wait till this is finished initializing.  
100:47 - And once it's initialized, let's just navigate 
to this IP address and see what happens.  
100:52 - So I think it's probably at this 
point already running. So let's just  
100:57 - go to that. And then we'll just go to 
the IP address. So copy the IP address,  
101:01 - and your web browser, go to that. And you can see 
your very first web browser. So this just confirms  
101:07 - that we installed Apache on our server. And we 
copy that text to the index that HTML file to get  
101:13 - served to all the users. So that just confirms 
that everything is working. Okay. However,  
101:18 - now what I want to do is I want to show you 
guys how to actually connect to that device.  
101:22 - Since it has the public IP, we can 
actually SSH to it. And the way to do that,  
101:26 - it's going to vary depending on what operating 
system you're on. So if you're on Windows,  
101:31 - I'm going to walk you through that now. And then 
in a second, I'll show you guys how to do that in  
101:35 - on a Linux or, or a Mac machine. So if you're on 
Windows, the first thing that you need to do is  
101:42 - download a software called putty. It's a little 
annoying that we need to use putty, but just  
101:47 - search for putty. And then let's see if I can so 
just download it here, like this button. And then  
101:53 - you can just download the installer. So 
get the 64 bit if you're using 64 bit,  
101:58 - or get the 32 bit if you're using the 32 bit. So 
after you install it, just go to your search bar,  
102:06 - and just search for putty. And you'll see 
that there's two applications that actually  
102:10 - got installed. There's putty and putty Gen. And 
the first thing that we need to do is we actually  
102:15 - need to open up putty Gen. And the reason we need 
to do this is because this is a PEM file, and I  
102:20 - told you guys that, you know, there's the there's 
the ppk file or PKK. I forget which one it is I  
102:25 - think it's ppk. And then there's the PEM file. So 
Linux machines like to use the PEM file. However,  
102:31 - Petey likes to use the PKK file or the ppk file, 
whatever it is, I can't remember. And so we have  
102:37 - to convert this PEM file to the right format to 
be able to use it on a Windows machine. So the way  
102:43 - to do that is open up the putty Gen application 
like I just showed you, and hit this LOAD button.  
102:51 - And here, select all files. And 
we've got this main dash key dot PEM.  
102:58 - So hit open. And it's important this and then 
all we need to do is select Save private key.  
103:09 - And it's going to give you this warning, go 
ahead and ignore it just hit yes. And then give  
103:13 - it a name. So I'm just going to call this main 
dash key again. And it's going to save it as a  
103:18 - ppk file. So I'll have a pen version as well as a 
ppk version, that I can use it on either machine.  
103:25 - I'll hit save, and I think it should have 
created it so we can just double check.  
103:32 - And let me go to my downloads folder real quick. 
And if I move that over here, you can see that now  
103:39 - we have the main dash key ppk file as well as the 
PEM file. So now what we need to do is we'll close  
103:45 - out of this party, Jen. And we're going to open up 
the regular putty device or the party application  
103:51 - and keep opening up on the other window, which 
is kind of a pain. And now let's go back to our  
103:56 - console. And the way to connect to one of these 
devices, hit this Connect button right here. And  
104:01 - it's going to give you all the information on how 
to connect to this device. And so you'll see that  
104:08 - the user for this device is Ubuntu. And then you 
know, it's going to also give us the IP address,  
104:12 - but we can actually confirm the IP address here. 
The important thing is we know that we need to  
104:18 - login using the user as Ubuntu. So we'll do Ubuntu 
and then to specify the IP address you do at  
104:25 - and then the IP address. So let's copy this IP 
address and paste it in. Now we have to log in  
104:32 - using that ppk file. And to tell putty to use that 
go into this SSH right here. And I know this text  
104:39 - is a little small for you guys. I don't know how 
to make this bigger unfortunately. So you're just  
104:43 - gonna have to bear with me, hit the off button. 
And then there's a section that says private key  
104:48 - file for authentic action. So hit browse, and 
then just find that main, a dash key ppk file,  
104:54 - hit open it open again. And once again 
this opened up in another window.  
105:01 - And it looks like I'm running into some 
issues. So I'm not sure what happened here.  
105:07 - Let me close this out. I'm 
going to open up my terminal.  
105:15 - I should be able to ping 3228 that 248252. Or 
maybe not. Well, that's a problem. Oh, wait,  
105:27 - no, we didn't allow pings. Let's just make 
sure this works again. Okay, so that's good.  
105:34 - Now, why is it that we cannot reach this 
device? So let's check our security group.  
105:38 - Let's view inbound rules. Oh, look at 
this, guys, I messed this up. You see,  
105:44 - we're allowing port two. And we don't 
care about port two, we want Port 22.  
105:48 - So let's go back to our terraform file. 
Let's see where, where I messed that up.  
105:56 - Here we go. This is where I mess 
it up. So this should be Port 22.  
105:59 - We hit save and then do a terraform apply it 
should play this on the fly real quick for us.  
106:07 - Alright, that's been done. Let's just double 
check here. So we'll go to View inbound rules.  
106:12 - Now it says Port 22. And let's open up putty 
again and just perform the same exact steps  
106:21 - we want to go to Ubuntu at 
and then copy this IP address  
106:28 - through SSH, go to our authentication, 
browse, find our main key ppk file it open.  
106:38 - And it should pop up with a 
security alert. So just hit yes.  
106:44 - And at this point, you should be logged in using 
putty. So um, you know we're on a Linux machine,  
106:49 - you can run any command you want. But you 
know if we want to verify Apache is running,  
106:52 - let's just do a system CTL status 
Apache two. I spelled that wrong.  
107:05 - And so and so it's running. And so 
that's how we, you know, connect to  
107:09 - one of these boxes on a Windows machine. Let 
me show you how to do it on a Mac machine.  
107:14 - And let me just copy this PEM file 
to to my Mac machine real quick.  
107:19 - And so remember, we want the PEM file on 
a Mac. And on a Windows we want the ppk.  
107:26 - Okay guys to connect to our web server or an EC 
two instance from a Mac or Linux machine steps are  
107:32 - going to be identical. The first thing that I want 
you to do is go to your web browser and just go to  
107:37 - AWS and log into your console. Because it actually 
kind of walks you through how to do it step by  
107:44 - step, it's actually really easy. So if we go to 
our EC to section and go to running instances,  
107:49 - go to your web server and then tick Connect. And 
so these steps are all you have to do. We have to  
107:54 - do ch mod 400 and then the name of that PEM file 
that we downloaded. And that's just going to set  
107:59 - the permissions to the correct values. And then we 
have to connect to it. So the way to connect to is  
108:05 - you go to your command line, you do SSH dash I and 
then the name and location of your PEM file. And  
108:11 - then we want to connect to it doing Ubuntu at and 
then the IP address. So that's all you have to do.  
108:16 - So let's go to our terminal. And let's find that 
PEM file, but I saved it in my downloads folder.  
108:24 - And so I've got that main dash key dash Pam. So 
we'll do a CH mod 400 main dash key dash Pam.  
108:35 - And now to actually connect to the server, we 
do SSH dash I and then the name of the file. So  
108:42 - main dash key dash Pam. And then now we 
do Ubuntu at and then we need to get the  
108:49 - IP address. So let's go back here. Let's copy the 
IP address. And then paste it in. And then we hit  
108:58 - Enter. And we should get this same warning that 
we got on the Windows machine. So we'll hit yes.  
109:04 - And there you go. You're now connected to 
the device and you can run any commands.  
109:08 - So that's all I wanted to show you guys in 
this video. Hopefully you learned a lot.  
109:12 - You know, I showed you guys how to create a lot 
of different resources. These are all things that  
109:16 - you're going to need to know how to do. And 
hopefully at this point, you guys should feel  
109:21 - relatively comfortable with navigating 
around terraform and creating and deleting  
109:26 - resources. Definitely go ahead and you 
know, once you're done with this project,  
109:31 - do a terraform destroy because we did deploy a 
lot of things and I don't want you guys to get  
109:35 - any kind of unexpected bills, even though we 
are in the free tier. So just do a terraform  
109:41 - destroy and then we can just do a dash dash 
auto proof but you know what happened here?  
109:50 - terraform and oh, not the story. But 
you know we still have a lot of things  
109:58 - to cover when it comes to terraform you know 
You know, I get a chance to cover variables,  
110:03 - or, or modules or things like that. So there's 
still a lot to cover with terraform. I think  
110:09 - that's going to wrap it up probably for this 
video, make some follow up videos. If there's any  
110:13 - topics you guys want me to cover, let me know, and 
I'm happy to do it. You know, terraform has been  
110:18 - something that I really enjoy working with. So 
if you guys want me to do more terraform videos,  
110:22 - also, let me know. And I'll be happy to do 
any videos or any topics that you guys want.  
110:33 - In this video, I'm going to go over a few extra 
terraform commands that I think are helpful.  
110:37 - And if you've already destroyed the 
project that we created in the last video,  
110:42 - go ahead and deploy it again, or at least just 
deploy a few resources, we need a few resources  
110:46 - deployed so that we can actually take a look at 
the output. And so I've already done that. So  
110:51 - I've already, you know, run this terraform 
config. And so we have several different  
110:56 - resources deployed. And the first command that I 
want to show you guys is terraform. State list.  
111:04 - And by the way, guys, if you don't know 
what commands to run, I always just start  
111:08 - off with terraform, hit Enter, and you'll see 
that the command line will kind of help you,  
111:13 - you know, with the different commands that are 
available. So these are all the options that  
111:16 - we have. And so right now, I want to focus on the 
state sub command. So where is this, I think it's  
111:23 - terraform, is down here. So the terraform 
state sub command, so if we do terraform,  
111:28 - state, and then hit enter, you can see all 
of the commands that we have at our disposal.  
111:32 - So we've got left, this is the main one that I'm 
concerned concerned with. So if we do a terraform,  
111:38 - state list, this is going to list out all 
of the resources that we have state for.  
111:42 - So any resource that I've created in 
my topology, you know, we're going to  
111:46 - have an entry in this output. And so you can 
see, we have the elastic IP that I created.  
111:50 - We've got the web server that I created, as well 
as the internet gateway, the network interface,  
111:57 - the route table, the route table Association, the 
security group, the subnet and the VPC. And if  
112:02 - you actually want to see detail, regarding any one 
of these resources, you can do a terraform. State  
112:09 - show and then just copy one of the one of these 
items. So if I want to see detailed output for  
112:14 - the elastic IP, I can copy that and paste it 
in. Oops, it looks like I didn't copy it hold on  
112:21 - terraform state list. And it's got Copy that. 
And sorry, we need terraform state show.  
112:35 - Alright, and so you can see it's going to give us 
a detailed output regarding that state incident  
112:39 - include a lot of information that would normally 
only be stored in the AWS console, so we can see  
112:45 - the IP address, we can see the association ID, 
we can actually see the actual ID of the resource  
112:52 - that gets created in AWS. And then we can see the 
ID of the instance this elastic IP is assigned to  
112:59 - as well as the network interface. And we can even 
see the public IP. And this is super helpful,  
113:04 - because there's gonna be a lot of times 
when you deploy something, and you want  
113:06 - to know what the IP address is, especially the 
public IP. And normally, you'd have to do it  
113:11 - through the AWS console. But you know, we have 
this command so that we can just verify it from  
113:15 - the command line really quickly without having 
to log in. And we could do this with, you know,  
113:21 - really any one of the resources that we've 
deployed. So if we want to see more detail  
113:25 - regarding the web server that we deployed, we 
can copy this and just take a look at that and  
113:30 - just do a terraform state show. And you can 
see all the information that we have regarding  
113:35 - that server that we deployed. So we can see the 
ID, we can see, you know, the AMI that was used,  
113:42 - what availability zone it was deployed 
on, we can see its public IP here as well.  
113:47 - And, you know, a couple of other details that 
would once again normally only be available  
113:51 - in the AWS console. So you know, those are the 
two commands, keep those in mind. So remember  
113:55 - terraform state list, and then terraform state 
show those are going to be the two big ones.  
114:06 - In the last video, I showed you guys how to 
verify the state information for resources that  
114:11 - we've deployed using the terraform state show 
command and the terraform state list command.  
114:16 - And those will allow you to see information like 
the resource ID, it'll allow us to see information  
114:22 - about you know, like, what's the public and 
private IP of EC two instance. So we can see  
114:27 - a lot of detail about these resources that we've 
deployed ourselves. And it's super helpful, super  
114:32 - handy. But I want to show you another thing that 
we can do to actually see that information, right,  
114:37 - because, you know, after you deploy something, 
you know, we can always do a terraform state  
114:46 - list and then whoops terraform state list. And 
so if we wanted to extract the public IP of the  
114:54 - elastic IP that we created, you know, 
we can always do a terraform state  
114:58 - show And then just copy that. And you can see 
here that we can actually see the public IP  
115:08 - under the public IP property of this resource 
that we created. But there's going to be  
115:13 - times where, you know, it's kind of a little 
inconvenient to have to always do a terraform  
115:18 - state list. And then terraform state show for 
all of the details that we want, you know, what  
115:22 - if we could get terraform to automatically print 
that out when we run a terraform apply? And Well,  
115:27 - guys, there is a way to do that. And that's by 
using the terraform output command. So you know,  
115:31 - any one of these properties that we can see, by 
doing a terraform state show on any one of these  
115:35 - resources, we can tell terraform to automatically 
print those out when the resources are created.  
115:41 - And we can do that using the terraform output 
command, I'm going to show you just how simple  
115:44 - it is. So as I said, before, you know, one of 
the main use cases is extracting the public IP,  
115:52 - that's going to get assigned to an elastic 
IP or a EC two instance that gets created.  
115:56 - So we can just do a terraform terraform, we 
can do the output. And then we have to define  
116:04 - an output for this. So I'm just going to call 
this my server underscore public underscore IP.  
116:11 - And then here, we just assign it a value. So 
we get the value from from this right here.  
116:19 - From this terraform state show, so to get 
the value, what we have to do is we have to  
116:22 - pass in the name of our resource, which is AWS, 
underscore E, IP, underscore or dot one. And then  
116:30 - we want to grab the public IP property, okay. So 
we can go down here and we just say value equals  
116:37 - AWS underscore IP, dot one dot public, 
underscore, IP. Okay, and so that will  
116:46 - get this property and it'll print it out into 
the console, when we run terraform. Apply,  
116:50 - follow me save this. And we'll do a terraform 
apply, and then dash dash auto approve.  
117:00 - And let's just wait for that to run. And I 
want you to notice what happens at the end.  
117:08 - Alright, look at that. So the output that we 
created, it's going to print out our server  
117:12 - public IP, so that we don't have to go into 
the terraform. State and verify it ourselves.  
117:17 - And so this can come in handy, because, 
you know, we can print out all the details  
117:21 - that we are concerned with, without having to 
actually go in and check the states ourselves.  
117:26 - And we could obviously, you know, grab any 
other property. So as an example, let's say,  
117:32 - let's see what other properties we can grab 
that I think would be cool. Let's do a terraform  
117:35 - state list, and then terraform state show, and 
then let's check our, our web server instance.  
117:45 - So let's say we want to grab  
117:48 - the private IP of our server, as well 
as the AMI that's being used, or no,  
117:55 - I think the ID would be cool because we were hard 
coding the AMI. So who really cares about that we  
117:59 - already know what it is. And so we can just define 
another terraform output, so we'll do output,  
118:07 - then we have to give it a name. So just give 
it any name you want, I'm just gonna say,  
118:12 - server. We'll call this server, private IP. 
I'm going to do value. And then remember,  
118:24 - we have to set this equal to our 
resource. So we'll copy our resource name.  
118:42 - And remember, we need to get our property name. So 
this is going to be called private underscore IP.  
118:53 - And I can't remember if we can put two values 
in here, but let's just give that a shot.  
118:58 - So let's see if I just copy 
this. And let's print out the ID.  
119:06 - And let's try to terraform apply again. Yep, so it 
looks like we can only set at once. So we'll have  
119:19 - to create another output. And we'll call this 
server ID. I'm just gonna move this down here.  
119:30 - Alright, so now when we do a terraform, 
apply, we should see three different output.  
119:49 - There you guys, there you go, guys. So you 
can see the three different outputs that  
119:52 - we've defined. We've got the server ID, we've got 
the private IP, as well as the public IP. And,  
119:57 - you know, you can always verify the 
app Puts by doing a terraform output,  
120:02 - and it's going to print out all the outputs for 
us. However, if you decide to add another output,  
120:08 - you know, into your config, but you don't want 
to do a terraform apply, because technically  
120:12 - terraform apply could potentially make changes 
to your network. And if you're in a production  
120:16 - network, you don't want to accidentally deploy or 
delete something, just to see what the output is.  
120:22 - So, you know, if you're in that situation, 
you can always do a terraform refresh.  
120:27 - And this should, you know, just refresh all of 
your state. And it'll run the outputs again,  
120:32 - so that you can verify them without actually, you 
know, deploying anything or doing an actual apply.  
120:39 - With the decorative nature of terraform. It's kind 
of an all or nothing situation when you want to  
120:44 - deploy your terraform config, or destroy it. So 
you can either spin up everything that's been  
120:49 - configured in your terraform file or destroy all 
of it. However, terraform does understand that,  
120:55 - you know, there's going to be instances where 
you want to just delete an individual resource.  
120:59 - Or if you're just trying to roll out with 
a deployment to do staged deployments,  
121:03 - where only certain resources are to play are 
deployed one day. And then the next day, another  
121:08 - set of resources that are deployed. And so we can 
target individual resources within our configs  
121:13 - to either apply or destroy them by passing in the 
dash target flag. And so I've got a whole bunch  
121:19 - of resources deployed. And let's say that I just 
want to delete this web server right here, well,  
121:24 - we can do a terraform, destroy, and then we can 
pass the dash target flag, and then I'm just going  
121:30 - to provide the name of the resource. So we'll do 
AWS underscore instance, dot web dash server dash  
121:38 - instance. And so this should leave everything 
else in my configs untouched. So all of these,  
121:44 - you know, the route tables, the subnets, all of 
that should remain untouched. And terraform should  
121:48 - just delete this one easy to instance, let's 
give that a shot. And let's see what happens.  
121:59 - All right. And so if we go up here, 
just to see what's going to change,  
122:02 - you can see that we're going to 
be destroying just one resource,  
122:05 - and that's that web server that we 
targeted. And so you can see here,  
122:10 - only one resource is going to get destroyed. If I 
hit yes, it should then delete just that server.  
122:20 - Alright, so it successfully destroyed just that 
one resource. And if we want to do the exact  
122:25 - opposite thing, and deploy just this one resource, 
we can use the dash target flag once again,  
122:30 - to accomplish that terraform apply dash target 
and the name of the resource that we want to  
122:37 - deploy. So in this case, we're just deploying 
just that web server that we just deleted.  
122:54 - And I'm going to move the apply to here.  
123:09 - Alright, and if we take a look at the 
summary of the changes that'll take place,  
123:12 - we can see that it's going to add one 
resource, which is exactly what we want.  
123:16 - We'll hit yes. And let's just double 
check that everything works. Okay.  
123:24 - And there you have it, guys, we've deployed just 
one individual resource from our terraform config.  
123:29 - So this was just a short video, I just wanted to 
make sure that you guys understood how to target  
123:34 - an individual resource or individual resources 
if you want to deploy just a couple. So that just  
123:39 - hopefully gives you a little bit more flexibility 
on maintaining your infrastructure using  
123:43 - terraform. Now, just like any other programming 
language, terraform does allow us to make use of  
123:50 - variable so that we can reuse values throughout 
our code without having to repeat ourselves.  
123:57 - And right now, inside this example configuration 
file, I've got just a VPC being defined. So we're  
124:03 - going to create a VPC. And then we're going to 
create a subnet within that VPC. So I'm nothing  
124:07 - new up to this point. You guys should already be 
familiar with how to do this. But what I want to  
124:11 - do is I want to take this cider block definition 
for subnet one, and store this value right here,  
124:16 - the 10.0 dot 1.0, slash 24. subnet in a 
variable. And to define a variable in terraform,  
124:22 - it's very easy, all you have to do is just 
type in variable, and then the name of the  
124:27 - variable so we can give it any other name. So I'm 
just gonna call this subnet underscore prefix.  
124:35 - Okay, and within this variable definition, 
we can pass in three arguments or three  
124:41 - parameters. And all three of them are completely 
optional, so we can technically leave this empty,  
124:46 - but the three options are, we can give it a 
description. We can also give it a default value,  
124:57 - as well as a type okay? So, once again, all 
three of these are optional. But a description  
125:03 - is exactly what it sounds you can like, you can 
just give it a description. So we'll say this  
125:11 - is going to represent the 
cider block for the subnet,  
125:16 - the default value, so the default value 
is just going to be what terraform is  
125:20 - going to give this variable if we don't 
actually pass in a value for this variable.  
125:24 - So I'm going to leave this blank for now 
and just comment that out, we don't need it.  
125:30 - And then the type so we can actually perform 
type constraints on variables so that when  
125:35 - a user enters in a value, we can make sure 
that they enter in the proper type for this  
125:40 - variable. So if we're expecting a string, 
you know, we can say type equals string.  
125:47 - And there's a couple of different types 
that terraform supports. So you know,  
125:50 - it supports strings, it supports 
numbers, Booleans, lists, maps, sets,  
125:55 - objects, tuples. And if you're not sure what 
type you're going to use that. And if you're  
126:00 - not really sure what type needs to be passed 
in, you can always just pass in the any argument  
126:04 - to say that we support any type. But you know, we 
can just leave this blank for now. And we'll come  
126:08 - back to using type constraints. So for now, all 
we're going to do is just provide a description.  
126:15 - And I'm going to hit save. And let's see what 
happens when we actually run our code. Now. Well,  
126:19 - actually, one more thing, we actually have 
to, you know, use that variable someplace,  
126:24 - right. So to actually reference a variable in 
our code is very simple. So I'm going to delete  
126:28 - this subnet right here. And to reference a 
variable, we just type in var, and then dot  
126:33 - and then the name of the variable. So that's going 
to be subnet underscore prefix. Alright, and so  
126:40 - you can see that nowhere in our code so far have 
we actually defined the value of subnet prefix,  
126:45 - we just provided a description. So if we do a 
terraform, apply, let's see what happens. And  
126:50 - look at that. So any variable that isn't assigned 
a value terraform will actually prompt the user to  
126:56 - enter in a value for that. So I'm going to give 
this a value of 10.0 dot 1.0, slash 24. And so  
127:04 - this value that I'm passing in is going to get 
assigned to subnet prefix. And so once the AWS  
127:09 - subnet resource runs, it's going to pull that 
value and store it for the cider block. So let's  
127:15 - hit enter. Let's wait for that to run. Okay, so 
the resource has been added. Let's take a look  
127:28 - at the AWS console just to see if that actually 
works. So I'm going to go to this prod subnet.  
127:33 - And so you can see here that it got passed 
in a 10.0 dot 1.0 slash 24. prefix. And  
127:39 - so that just confirms that our variable is 
working. Now, it's kind of a pain to have to  
127:46 - get prompted for what the value of a variable 
should be. So there's other ways of passing  
127:50 - in values or assigning values to a variable. And 
one of those is through a command line argument.  
127:57 - And so what we can do is I can do a terraform. 
Well, first, let's do a terraform destroy.  
128:06 - So we can delete those resources. And it looks 
like I spelled something wrong. Yep, ROI. And  
128:12 - you'll see that when it needs to get destroyed, 
it's going to ask you for a value for that.  
128:18 - That variable that we defined, but for destroying, 
it doesn't actually matter. So you can just  
128:22 - technically just leave it blank, and it 
should be able to destroy things just fine.  
128:25 - We only really care about passing in the 
proper value when we're doing an apply.  
128:30 - Alright, so we've destroyed the resources. 
Now let me show you guys how to assign a value  
128:35 - to a variable through a command line argument. 
So if we're going to do a terraform apply,  
128:40 - we can also do a dash of var. And then set a value 
for a variable. So we're going to reference this  
128:47 - subnet underscore prefix variable. So we'll do 
subnet underscore prefix. And then we can set  
128:53 - it to whatever value we want. So I'm going to do 
the 10.0 dot, let's do 100.0 slash 24. Hit Yes.  
129:12 - And now let's double check in the console to 
make sure that this new value got assigned.  
129:17 - And so you can see here, we've now got our 
10.0 dot 100.0. So the variable assignment  
129:24 - that got assigned on the command line argument 
worked. Now this is cool and all but you know,  
129:34 - in reality, I don't think we're going to use 
either one of these methods to assign variables.  
129:39 - Very often, the best way to do it is actually 
creating a separate file to assign variables  
129:44 - and terraform automatically looks for a 
file called terraform.tf rs for variable  
129:49 - assignments. So we can just create that 
file now and we'll do terraform.tf bars  
130:02 - And here we can define a value for 
that variable. So I'm going to go back,  
130:06 - what was it called? subnet prefix. And so 
what do subnet underscore prefix equals,  
130:13 - and then let's give it the value that we 
want. So we'll do 10.0 dot 200.0, just to  
130:18 - show that something has changed. And so I'm going 
to do an apply without passing in an argument.  
130:31 - It looks like it's still looking for, 
it's still asking for assignment. So  
130:35 - let me cancel that I messed something 
up, I forgot to hit save, probably, yep.  
130:42 - Let's just wait for that to finish up, I cancelled 
out it. So hit save all. And so now because we've  
130:46 - actually defined this variable here, it should 
not prompt us for for a value for that variable.  
131:04 - Okay, so let's hit refresh. And let's take a 
look at the value. And so now it's set to the  
131:09 - 10.0 dot zero slash 24. So those are really the 
three different methods for assigning variables.  
131:17 - Technically, we can also use environment variables 
from your operating system, I'm going to hold off  
131:22 - on using that as an example or giving you an 
example of how to do that, because that's going  
131:26 - to come into play when we worry about how we're 
going to store our credentials for terraform,  
131:30 - instead of just hard coding it into our terraform 
file. So in that scenario, it's really good to  
131:35 - use environment variable. So I'm going to 
hold off on doing a demo of that for now.  
131:40 - Now, the next thing I want to cover is, well, 
first of all, let's say that we didn't want to  
131:46 - use a file called terraform. That TFR let's 
say we wanted to call it something else.  
131:51 - Or let's say we had multiple files for multiple 
variables, which is very common, especially when  
131:55 - your terraform config start to grow. You know, you 
don't want to store everything in just one file.  
132:00 - Well, we can tell terraform to actually look 
for a specific file name. So if I rename this,  
132:06 - actually, before I do that, enter your terraform 
destroy. And so now I'm going to rename this.  
132:24 - I'm going to rename this to let's 
just say, for example, that TFR, okay.  
132:32 - And now for terraform, to actually look for that 
file, we have to explicitly tell it to look for  
132:36 - that file. And we can do that by passing in a 
simple flag. So I'm going to do terraform apply.  
132:45 - And we can pass in the flag dash var dash  
132:49 - file. And then we give it the name of 
the file. So we'll do example.tf bars.  
132:59 - And so you can see that we didn't get prompted to, 
you know, enter value for that variable, because  
133:03 - terraform was able to look at this example dot 
tfrs file and find this value. Now in the earlier  
133:11 - parts of this video, I did mention that one of 
the options to pass into a variable assignment is  
133:16 - a default value. And so this default value can be 
used if the user doesn't input a specific value.  
133:23 - And we can do an example of that just by 
deleting this right here, we'll save that file,  
133:29 - and let's just assign a default value. So we'll 
say default equals 10.0 dot 66.0, slash 24. So if  
133:39 - the user doesn't input a variable assignment, then 
terraform will automatically assign this variable  
133:45 - this value. So once we save that, 
we can then do a terraform apply.  
134:04 - There you go. So even without having a value 
assigned to that variable, you can see that it's  
134:09 - still ran. And if we go to the to AWS console, 
take a look at that, you can see I have assigned  
134:16 - a value of 10 dots here, that's six dots zero. 
So this is a way to apply a default value for a  
134:21 - variable. I'm going to remove this for now just so 
I can do a few more demonstrations using variables  
134:27 - within terraform. I'm also going to rename this so 
I don't have to keep passing in a input argument.  
134:37 - Now I'm going to show you guys how to actually 
perform a type constraint on a variable. So  
134:43 - in this case, the subnet or the cider block needs 
to be a string that holds the value of our subnet.  
134:48 - And so we don't want to receive a variable of any 
other type other than a string. And so what we can  
134:53 - do is we can say, type equals string and so Now, 
if I go to my terraform, read tfrs and do a subnet  
135:06 - underscore prefix equals, and instead of a, 
you know, assigning, you know 10 dot, you know,  
135:11 - zero to zero slash 24, or something as a 
string, let's say I tried to put in a list,  
135:18 - try to assign this value. Alright, let's see 
what happens. Now, when we try to run that.  
135:32 - Oops, it looks like string is not a valid type  
135:34 - specification. So it must 
be a lower s, lowercase s.  
135:43 - c, and so now it throws an error saying the given 
value is not a valid is not valid for a variable  
135:48 - subnet prefix. Because it, it checks to see if 
it's a string, and it sees that it's not a string,  
135:53 - so it throws an error. So this is just a 
another way to make sure that you know,  
135:57 - especially when you're working on large code 
bases, and you're sharing the, your code with,  
136:01 - you know, colleagues, this will just make 
sure that your colleagues don't accidentally,  
136:05 - you know, input a wrong variable type into 
a variable and then, you know, potentially  
136:11 - see an error when they run the config. So it's 
just a another sanity check that you can do.  
136:22 - Now, while this is set to a list, I want to show 
you guys how to actually use a list as a variable.  
136:29 - And so what I'm going to do is, I'm going to,  
136:32 - I've removed that type constraint, and 
I'm going to create a second subnet.  
136:37 - And I'm just going to call this, we'll just call 
this a dev subnet. And we'll call this subnet two.  
136:45 - And here, we're going to specify the cider 
block for both of those subnets. So I'll do  
136:51 - 10.0 dot 1.0. And then for the second one, we 
can pass in a value of 10.0 dot 2.0, slash 24.  
137:00 - We've got a list. And now to reference the 
list, all we have to do is just change this  
137:04 - up a bit. So this is going to be the first object 
in that list. So when you're working with lists,  
137:10 - the first object can be referenced with a 
zero, and the second one will be referenced  
137:15 - with a value of one and so on. So it's 
just like any other programming language.  
137:21 - That to one, and let's give 
this a shot and see if it works.  
137:45 - So now we've got our two different subnets, the 
prod subnet should be a 10.0 dot 1.0. And the  
137:51 - dev subnet should be a 10.0 dot 2.0. All 
right. And there's one more thing I want  
138:00 - to show you guys with variables. And I want to 
show you how to use objects within variables.  
138:05 - So right now we just have a list of strings. 
But we can also have a list of objects too. And  
138:10 - so what I'm going to do is I'm going to change up 
the way I assign the tag. So instead of assigning,  
138:17 - you know, the tag or hard coding it, what I want 
to do is I want to have a variable, that's going  
138:22 - to look like this where we're going to have an 
object and we'll have two properties, we'll have  
138:25 - the cider block. And then we'll also have a name 
property. And so that way the cider block will get  
138:32 - assigned to the cider block and the name will get 
assigned it to the name. And so we'll remove that,  
138:37 - we'll go back to our terraform tfrs file. 
And let's see how we can actually do that.  
138:42 - Here we'll create an object and we'll 
assign it a cider underscore block  
138:50 - should equal that's going to be the 
10.0 dot 1.0 slash 24. And then the  
138:58 - neck and then we have to specify 
a name. So we'll give it a name.  
139:03 - And this is going to be prod underscore subnet. 
And then that's going to be for subnet one.  
139:10 - And then for subnet two, we'll do the same thing 
to assign a property of cider underscore block,  
139:18 - and we'll set that equal to 10.0 dot 2.0 
slash 24. And then the second property is  
139:24 - going to be the name. And that's going 
to be set to dev underscore subnet.  
139:32 - So we're going to have to 
update a few things here. And so  
139:36 - under the cider block, we want 
to grab the cider block property.  
139:45 - And after the name, we're going to have to 
reference that variable. And we'll do a VAR dot  
139:52 - subnet prefix want to grab the first item 
and we'll do dot name And we'll copy this  
140:02 - and just paste it down here, just make sure 
to update it. So it's the second object.  
140:18 - And there you have it, guys, we were able to 
now use a variable, which is a list of objects  
140:22 - to assign values within our terraform 
configuration file. So there's a lot of  
140:27 - flexibility with variables, you definitely 
want to make use of them for as much as  
140:31 - possible so that you're not retyping the same 
thing over and over, across large configs.  
140:37 - So just keep in mind, I it was 
a little confusing at first,  
140:40 - for me, especially because we have to, you 
know, define the variable but we don't assign it  
140:45 - here, we have to assign it in the TF 
bars file. So just keep that in mind.  
140:49 - And the TF files you define a variable and 
then TF bars, you actually assign it a value