00:00 - Stacks are a common programming data
00:02 - structure and many programming interview
00:04 - questions require knowledge of stacks
00:07 - tanishq has helped thousands of people
00:09 - prepare for coding interviews and now
00:11 - he's going to help you understand the
00:13 - stack data structure by demonstrating
00:15 - how to solve a bunch of common coding
00:17 - interview problems the problems go from
00:19 - easier to harder and Denise will be
00:22 - guiding you the entire time my name is
00:24 - Dani sheltery and I'm very excited to
00:27 - bring you this course on Stacks so let's
00:29 - go ahead and get started
00:31 - hello everyone and welcome let's talk
00:34 - about the implementation of Stack we are
00:37 - going to start off with a couple of
00:38 - examples to understand the reason why
00:40 - Stacks are built in first place then
00:42 - we'll look at the implementation level
00:44 - details of stacks in terms of python and
00:48 - C plus plus
00:49 - all right let's get started
00:51 - now if I ask you the question what do
00:53 - you see on the screen you might reply
00:55 - that there looks to be a couple of books
00:57 - present on a shelf so you can call this
00:59 - a stack of books
01:01 - now what would you do if you had to read
01:03 - the first book the book on the top of
01:05 - the stack
01:06 - well you want to read Harry Potter so
01:08 - you will just pull it out of the stack
01:10 - you'll remove it from the stack you'll
01:12 - read it and then you'll push it back on
01:14 - to the stack once again
01:16 - now this is simple and fine but what if
01:19 - you want to read grocking the coding
01:20 - interview now
01:21 - what do you do
01:23 - of course you can drop pulling it out
01:25 - from the middle but all of these books
01:27 - are dense and heavy and you don't really
01:29 - want to disturb the balance of the
01:30 - elements on the top of the stack so what
01:32 - you can do is you can take out the first
01:34 - book
01:35 - you can take out the second one and then
01:38 - finally read grocking the coding
01:39 - interview you read it and then you can
01:42 - put it back on the stack along with
01:44 - these two books
01:46 - what we have just seen is a very
01:49 - important property of stacks that is
01:52 - called the leaf ordering
01:54 - lifo stands for lost in first out
01:57 - saying that the elements that come into
01:59 - the stack towards the end that is the
02:02 - elements that come in the last or the
02:04 - first ones to get out blast in first out
02:09 - now this is a property that will exploit
02:11 - again and again throughout this entire
02:13 - series it's going to be a central
02:15 - property and it's the heart of the
02:17 - reason why we use a stack in many of
02:19 - these questions
02:21 - now let's go ahead and formalize the
02:23 - operations we can do on the stack
02:24 - because we know that if the leaf
02:26 - ordering is being followed we have to
02:28 - use a stack but how do we exactly we use
02:31 - it
02:32 - well let's look at a couple of
02:33 - operations the first operation we saw
02:35 - was removing items from the top of the
02:37 - stack
02:38 - we call this operation formally the pop
02:40 - operation because we are popping the
02:42 - elements out from the top of the stack
02:45 - right so this is going to be the pop
02:47 - operation
02:48 - the second operation we saw was to add
02:51 - the book back onto the stack in other
02:54 - words we're looking at a push operation
02:56 - pushes the formal term used to define
02:58 - saying that we want to add an element
03:00 - onto the stack in other words we'll push
03:02 - an element on the stack
03:04 - now there's a final operation that we do
03:07 - very commonly and that's the peak
03:09 - operation now the peak operation simply
03:11 - says hey go ahead and take a look at the
03:13 - top of the stack go ahead and take a
03:15 - peek at the top of the stack
03:17 - right so these are three operations that
03:20 - we'll keep in mind all right so now
03:22 - let's go ahead and actually look at how
03:24 - these are implemented in terms of python
03:26 - and C plus plus Java implementations are
03:28 - pretty close to both of them so even if
03:30 - you understand just one implementation
03:32 - way you'll be able to do it in any other
03:34 - language I have ensured and tried my
03:36 - best to make sure all of the codes are
03:39 - language agnostic they can be easily
03:41 - translated from one language to the
03:42 - other without having a lot of issues all
03:45 - right so let's go ahead and actually
03:46 - look at how we are implementing these
03:48 - the first thing is how do we initialize
03:50 - this tag and in Python we're going to
03:52 - use the list implementation of Stack
03:54 - because there is no inbuilt internal
03:56 - class for it we're going to create a
03:58 - list empty list of our own to initialize
04:00 - the stack in C plus plus there is so
04:03 - we're going to use stack
04:05 - and we're going to have a stack of int
04:07 - variables and we'll call it as pretty
04:09 - simple all right how do we push in
04:12 - Python we do stack dot append and so we
04:14 - can do stack dot append an item and this
04:16 - is going to return a non-value that is
04:19 - it does not return anything we just
04:21 - append this element onto the top of the
04:23 - stack
04:24 - in C plus plus we simply do s dot push
04:27 - this is going to return a null
04:29 - all right how do we Peak how do we check
04:31 - what is the element at the top of the
04:33 - stack
04:33 - well in Python the way to do that is to
04:36 - use stack of -1 that is it is going to
04:38 - give you the last element on the top of
04:41 - the stack
04:42 - right so in this case it's the element
04:44 - three how do we do it in C plus plus we
04:47 - simply do s dot top
04:49 - now remember this is a slight
04:51 - terminology difference but nothing much
04:53 - you want to look at the top of the stack
04:55 - you want to peek at the top of the stack
04:57 - this is how you do it all right how
04:59 - about pop
05:00 - in Python you do directly stack dot pop
05:03 - and that is going to return your value
05:05 - three this is a crucial Difference by
05:07 - the way in Python you're going to get a
05:09 - return value of 3 however in C plus plus
05:11 - when you do the pop operation you're not
05:14 - going to get any return value
05:16 - all right this is super important
05:18 - especially when it comes to
05:19 - implementation keep the language
05:21 - specific details in your mind
05:23 - all right the last thing which will also
05:25 - very commonly use is to check whether
05:28 - the stack exists or not in other words
05:31 - is the stack empty or not
05:33 - so in Python we can simply use the stack
05:35 - variable and that internally checks its
05:38 - length so in our case we appended one
05:41 - element we checked the top of the stack
05:43 - and then we popped it out so the stack
05:44 - is currently empty in both the cases
05:47 - now if you just use stack if you say if
05:50 - stack colon blah blah blah that is going
05:53 - to return of value of faults
05:55 - because the stack is empty right in C
05:58 - plus plus we can do s dot empty which is
06:00 - a function that is going to work on the
06:02 - stack variable and it's going to return
06:04 - true saying that you know what the stack
06:06 - is indeed empty
06:07 - so again small implementation level
06:09 - details that you have to keep in mind
06:12 - all right so now that we have a better
06:13 - understanding of how do we Implement
06:15 - Stacks let's go ahead and take a look at
06:17 - a real life test case where Stacks will
06:21 - be very helpful to understand hello
06:23 - everyone and welcome back
06:26 - in the previous video we talked about
06:28 - how to implement Stacks in terms of C
06:30 - plus plus and python in this video we're
06:33 - going to take an example problem
06:35 - simplify path to build up our
06:37 - understanding of stacks further in fact
06:40 - this question is present of both lead
06:42 - code and interview bit and has been
06:44 - asked in companies coding interview
06:45 - rounds many times
06:47 - this in fact forms a basis for very
06:50 - important point that how Stacks are
06:53 - being used in the real world as well
06:55 - all right let's go ahead and get started
06:57 - with the formal problem discussion
06:59 - so we're given a path and this path is a
07:02 - Unix path given to us and the goal of
07:04 - this problem is to return the canonical
07:06 - path now if you're not familiar with how
07:08 - paths are unique Unix based paths work
07:11 - I'm going to link to resources down
07:13 - below so you can check them out first
07:15 - anyways we're given a path and we have
07:17 - to follow four conditions to return a
07:20 - canonical path first we have to start
07:22 - from a single slash the slash represents
07:25 - nothing but the root directory
07:27 - second any two directories are separated
07:30 - by a single slash so we can have
07:32 - directory one slash directory 2 slash
07:35 - blah blah blah
07:37 - condition 3 says that we should not end
07:40 - with a trailing slash in other words the
07:43 - slash at the end of it if there is a
07:45 - slash at the end of it you have to
07:47 - return it
07:48 - all right fourth condition which is the
07:50 - most important one it says that it only
07:52 - contains the directories on the path
07:54 - from the root to the Target that is
07:57 - there is no period or double period
07:59 - directories now period and double period
08:02 - have special meanings period basically
08:04 - says that wherever you are stay that is
08:07 - whatever directory you are on currently
08:09 - just stay over there
08:11 - double period means take a step back
08:14 - right so whatever directory you are on
08:15 - take a step back
08:17 - all right let's try to uh formally build
08:19 - up our intuitions and our logic all
08:22 - right let's take a couple of examples to
08:24 - understand this better first things we
08:26 - have a slash home slash SD input the
08:29 - blue is the input and the green is the
08:30 - output which by the way is a common
08:33 - coloring schema followed throughout the
08:35 - rest of the series so you don't have to
08:36 - worry about anything
08:37 - all right so we have slash home slash
08:40 - and what is the output the output is
08:43 - slash home that's because we have a
08:45 - trailing slash at the end of the input
08:46 - which we remove
08:48 - all right let's go ahead and take
08:49 - another example
08:51 - in this case we have slash dot dot slash
08:54 - what it means is we start from the root
08:56 - directory and we have to take a step
08:58 - back because dot dot really means that
09:00 - you have to take a step back from the
09:02 - current directory
09:03 - and then we have a slash at the end so
09:05 - of course you can remove the slash at
09:07 - the end because it's a trailing slash
09:08 - but now this double dot means that from
09:11 - the root directory we have to take a
09:13 - step back but there is no step Backs
09:16 - from the root directory root directory
09:18 - is where you start
09:19 - so in fact this will simply be reduced
09:21 - to staying on the root directory that is
09:24 - from the root if you want to take a step
09:26 - back you will end up at the same route
09:29 - all right let's take another example and
09:31 - this time we have slash home slash slash
09:33 - 1337 slash dot slash
09:37 - first things first remove the trailing
09:39 - slash now what we notice that between
09:41 - home and 1337 there are actually two
09:44 - slashes
09:45 - what does that mean well in our case the
09:48 - implementation level detail is that if
09:51 - there are multiple consecutive slashes
09:53 - all of them will be useless basically
09:55 - and we only have to consider one slash
09:58 - in other words multiple slashes will get
10:01 - compressed to a single slash so we have
10:03 - slash home slash 1337
10:06 - note that the period at the end now
10:07 - means that we have to stay at the
10:09 - current directory
10:10 - so we were at 1337 and we stayed at 1337
10:15 - let's take a look at one final example
10:17 - which is going to be the most important
10:19 - one and this has sort of all of the
10:21 - conditions mentioned in the question so
10:23 - let's go ahead and formally try to break
10:25 - this down to get the logic
10:27 - first things first we start off with the
10:30 - single slash which is going to be a root
10:32 - directory this is by default present in
10:34 - all the test cases we have to start from
10:37 - the root directory
10:38 - now what's the next step we want to go
10:40 - toward the next value which we see is
10:43 - home
10:44 - now what does home mean
10:46 - who means that we have to go One
10:47 - Directory forward that is from the root
10:50 - you have to go to home
10:52 - all right so pretty simple but now you
10:54 - get a dot dot
10:57 - what does this mean this means that you
10:59 - have to take a step back which means
11:02 - that from the root you first went to
11:03 - home but now you have to take a step
11:05 - back and go back to the root
11:07 - all right pretty simple again uh work
11:10 - next we get a dot dot once again and
11:12 - since we are already at the root taking
11:14 - another dot dot simply means that go
11:16 - straight at the root
11:19 - all right so now we get a slash uh TMP
11:22 - and what does that mean
11:23 - that means that now we have to take a
11:25 - step forward we have gotten the
11:26 - directory and so we'll go to slash TMP
11:30 - and then we have a bunch of slashes
11:32 - together that we have two slashes that
11:34 - just gets compressed to one single slash
11:36 - and then we have a DOT
11:38 - now dot simply means that wherever you
11:40 - are stay so you viewer are the slash
11:43 - temp directory and we'll stay over there
11:46 - and of course the last slash at the end
11:48 - is just a trailing one so we'll remove
11:49 - it
11:51 - in other words the final answer we get
11:52 - is slash TMP as we saw in the first line
11:55 - of this slide
11:57 - so now let's go ahead and formally talk
11:59 - about how did we do this
12:01 - how are we going to implement this going
12:03 - forward and going backward thing
12:06 - if you have guessed it yes you are right
12:08 - we have to use the data structure
12:12 - of course this is a playlist of our Sac
12:14 - we have to use a stack
12:16 - but why do we use it again
12:19 - whenever we have a directory like home
12:22 - or slash TMP we have to take a step
12:24 - forward and whenever we have dot dots we
12:27 - have to take a step backwards and a good
12:30 - way to simulate that is by using a stack
12:33 - all right let me go ahead and show you
12:35 - how this formally works out
12:37 - so the first thing we get is uh home so
12:39 - home means that we have to move forward
12:41 - which means that we will push the value
12:44 - home on to the stack
12:46 - that is we'll append this value to the
12:49 - top of the stack
12:50 - now we get a dot dot next what does that
12:53 - mean that means that we have to go back
12:55 - One Directory in other words we have to
12:58 - pop the element out of the stack
13:01 - right we get a dot dot once again but
13:03 - the stack is already empty what do we do
13:06 - this is a special condition and we have
13:08 - to say that you know what if the stack
13:10 - is empty you can't really pop anything
13:11 - and we don't really have to pop either
13:14 - we were at the root and we'll stay at
13:16 - the root so the stack remains as is
13:19 - then we have TMP so what do we do next
13:23 - this is a directory so we append it we
13:26 - push this value on the top of the stack
13:29 - now we get a DOT what does that mean
13:31 - that means whatever directory you are at
13:34 - stay there in other words the stack
13:36 - remains unchanged
13:39 - so if we have to formalize what can we
13:41 - say
13:42 - let's focus on the core Parts first
13:45 - things first how do we start
13:47 - the way we start is at the root and that
13:49 - is nothing but the cue to initialize the
13:53 - stack
13:53 - right whenever we start we're going to
13:55 - initialize the stack now directory means
13:58 - taking a step forward what does that
14:00 - mean
14:01 - that means that we're going to append an
14:03 - element onto the top of the stack in
14:06 - other words we are going to push this
14:07 - directory in the stack
14:10 - right and what does dot dot mean dot dot
14:13 - now means that we have to pop we have to
14:15 - go One Directory backward
14:17 - so whatever you append it just pop it
14:19 - back again
14:20 - and then finally we have a DOT which
14:23 - means that we really do nothing do no
14:25 - operations
14:27 - and this is really it this is it for the
14:30 - logic of this problem let's go ahead and
14:31 - look at the optimize solution and we're
14:33 - going to code it up from scratch all
14:35 - right let's go ahead and look at how do
14:37 - we implement this question in terms of
14:39 - python code
14:41 - the first thing we'll do is initialize
14:42 - the stack to be an empty stack
14:45 - and then we'll start to iterate over the
14:46 - directories
14:48 - in the paths
14:49 - now obviously the path given to us is
14:52 - going to be a string
14:53 - which is separated by these flashes so
14:56 - each of them directories
14:57 - that is any two directories are
14:59 - separated by a single slash
15:01 - so we have to say go ahead and do path
15:03 - dot split
15:05 - by the Slash
15:07 - that is
15:08 - get me the individual directories and
15:10 - we'll see what to do next
15:12 - so what's the first condition we saw
15:14 - remember from the code remember from the
15:16 - logic the first condition we can say is
15:18 - that you know what if you get a DOT that
15:21 - is if you get the operation where the
15:24 - directory
15:26 - we have to move to is a DOT that means
15:29 - that wait don't really do anything
15:31 - right we don't really do any operation
15:33 - on the stack if we get a single Dot
15:36 - so it was the other case we'll have the
15:38 - directory
15:42 - is what if it's a double lot what do we
15:45 - do
15:46 - if it's a double dot we have to do an
15:48 - operation called pop
15:51 - that is we have to go back one step we
15:53 - have to pop the element from the top of
15:55 - the stack so we'll do stack dot pop
15:58 - but now is a very important Edge case
16:01 - right this is a very important condition
16:04 - I'm going to write see it's not always
16:06 - the case that you can pop this directory
16:08 - from the stack
16:09 - that is for stack dot pop to work you
16:13 - have to ensure that stack is not empty
16:16 - because if the stack is empty and you
16:18 - pop an element out of the stack that is
16:21 - going to give you an error whether it be
16:23 - a python or C plus plus or Java all of
16:25 - these languages are going to give you an
16:27 - error if you pop an element out of the
16:30 - empty stack so first we'll go ahead and
16:32 - check hey you know what if the stack
16:34 - exists only then go ahead and do the
16:37 - stack dot pop operation
16:40 - what do we do else what do we do
16:42 - otherwise
16:43 - well in case this Jack is already empty
16:45 - and we get a double dot what does that
16:48 - mean
16:50 - on an empty stack which means that we
16:52 - are at the root and we get a double dot
16:54 - which means that from the root we have
16:56 - to move a step back
16:57 - which means that we just have to stay at
16:59 - the root so the stack remains as is and
17:02 - this condition in the else condition we
17:04 - don't really have to do anything
17:06 - all right it was the final case what the
17:08 - final case is say that go ahead and
17:12 - append this value to the stack append
17:15 - this directory
17:16 - to the stack all right so this is it
17:20 - right we're going to return what
17:22 - well one of the conditions the first
17:24 - condition and the question says that the
17:25 - path starts with a single slash
17:28 - so we're going to go ahead and start
17:29 - with the single slash
17:31 - and since we have all the directories in
17:33 - the stack let's go ahead and do the join
17:35 - operation so we'll do uh
17:38 - join Dot
17:41 - start
17:42 - so what this is going to do is iterate
17:44 - over all the elements in the stack and
17:46 - join them with a slash in the middle
17:49 - all right so before we go ahead and run
17:51 - this code by the way there's one more
17:53 - condition that is important to know
17:55 - see because directories can have a case
17:58 - where we have say double slashes that is
18:01 - if we have slash home slash Foo slash
18:04 - these double slashes are going to give
18:06 - us an issue
18:07 - because when we split when we split this
18:11 - path by slash it means that there is
18:13 - going to be a case where there is one
18:14 - slash and then there's a empty string
18:17 - and then another slash
18:19 - in other words what I'm saying is we
18:22 - have to add one more condition saying
18:24 - that if the directory
18:26 - is actually empty
18:28 - that is if there were multiple
18:30 - consecutive slashes
18:31 - then we don't have to do anything like
18:33 - that
18:34 - right if we get multiple slashes we just
18:37 - look at it as one slash
18:39 - and we don't really do anything
18:40 - right so
18:42 - this is it for the logic of the code and
18:45 - let's go ahead and test this out on a
18:47 - bunch of input test cases
18:50 - looks to be correct so let's go ahead
18:51 - and submit this
18:54 - and we get it accepted
18:57 - all right so this is it for the solution
18:58 - to the problem simplify path
19:00 - hello everyone and welcome back let's
19:04 - talk about the problem main stack on
19:06 - interview bit
19:07 - all right so the goal of this problem is
19:10 - to design a stack that supports a bunch
19:13 - of operations first Operation Push
19:16 - we have to push an element X onto the
19:18 - stack very simple
19:20 - second operation you have to design an
19:22 - operation that returns as the top of the
19:24 - element that is it is going to see what
19:27 - is the top of the stack and return it
19:31 - third operation we have to design a
19:33 - function that pops the value out of the
19:35 - stack we have to remove the top element
19:37 - and return it right so all of these
19:41 - three operations up till now are
19:42 - something we've already seen that are
19:45 - like very basics of what a stack is
19:48 - but now there is a fourth operation
19:49 - given to us getman
19:52 - this function is going to return a value
19:54 - X which is going to be the minimum value
19:56 - of the entire stack
19:58 - now the only constraint that is given to
20:00 - us is that all of the queries should run
20:03 - in constant time that is we should take
20:05 - order of one time each
20:08 - now how do we start to think about a
20:10 - solution
20:11 - once since the problem is about using a
20:13 - stack let's go ahead and create a stack
20:15 - and we'll start to see what do we do
20:17 - once we get the queries all right so
20:19 - this is the simulation will run let's
20:21 - say we get the um
20:23 - query to push the value 7 onto the stack
20:26 - so now this is how the stack is going to
20:28 - look with the value 7 on top of it
20:31 - if you get push 3 we'll just Add 3 to
20:33 - the top of the stack
20:35 - we hit push nine
20:37 - we add 9 to the top of this track
20:40 - now let's go ahead and say that we get
20:41 - the query getman
20:43 - what do we do at this point of time
20:46 - gateman query says that go ahead and get
20:48 - the minimum element of the entire stack
20:52 - which means that a naive way to proceed
20:54 - about it is to go over all of the
20:56 - elements inside of the stack one by one
20:58 - and find the minimum value
21:01 - in this case we find the 3 is the
21:03 - minimum value so we'll go ahead and
21:04 - return 3.
21:06 - now let's say that we get another
21:07 - operation called pop so we'll go ahead
21:10 - and pop the element out of the top of
21:12 - the stack then let's say we get uh get
21:15 - min again
21:16 - what are we going to do iterate over the
21:19 - entire stack go over all of the elements
21:21 - one by one and return three we realize
21:24 - that three is the minimum value right so
21:27 - let's go ahead and say we get another
21:28 - value another Operation Push one so we
21:31 - will add one to the top of the stack
21:32 - getman says
21:34 - well
21:36 - get me the minimum value of all the
21:38 - elements in the stack which means that
21:40 - the value will be 1.
21:42 - now if you realize what we have been
21:44 - doing up till now is all of the
21:46 - operations like portion the pop even the
21:49 - top are going to take order of one time
21:51 - to run as it does in normal stack
21:53 - however the gate main operation is kind
21:56 - of a pain
21:57 - that is because we have to iterate over
22:00 - the entire stack one by one taking order
22:02 - of end time where n is the number of
22:05 - elements in the stack
22:07 - this means that there has to be a better
22:09 - way to do it we have to figure out a way
22:11 - to answer the getman query in order of
22:14 - one time
22:15 - all right so let's go ahead and talk
22:16 - about the optimization
22:18 - this is one of those questions where if
22:20 - you don't know what to do you really
22:23 - would have no idea on how to proceed
22:25 - and in these kind of questions what we
22:27 - are going to do is we're going to create
22:28 - another stack that's right we're not
22:31 - doing just going to have one stack we
22:33 - are going to have two stacks the first
22:35 - is the blue one which we already saw
22:37 - which will handle the queries like push
22:39 - and the Bob in the top
22:40 - but we will also have a green stack
22:43 - which is going to keep a track of the
22:45 - minimum value we have seen up till now
22:49 - let me go ahead and show you the
22:50 - simulation once again and that will make
22:52 - a lot more sense
22:54 - because it's a beautiful way to approach
22:56 - this problem right so let's go ahead and
22:58 - say we get the query push second we get
23:01 - the request to do push seven so we'll
23:03 - just add 7 on the top of the stack now
23:06 - this is the stack we're going to append
23:08 - it to we're going to add it to the blue
23:09 - stack directly whatever query we get we
23:12 - directly apply it to the bluestack
23:15 - the green stack will simply reflect the
23:17 - changes of the blue one
23:19 - so since we added 7 to the stack the
23:21 - minimum value of the stack is now 7 so
23:24 - we'll add 7 to the stack
23:26 - now let's say we get a push 3 Operation
23:28 - what do we do
23:30 - because this is a blue case we'll simply
23:32 - add 3 to the top of the stack but we'll
23:35 - have the three reflect changes in the
23:37 - green stack as well that is the green
23:40 - stack is now going to store a value that
23:42 - is the minimum of 7 and 3 because we
23:44 - have two elements on the top of the
23:46 - stack right
23:48 - so we're going to have minimum of 3 and
23:50 - 7 and so we'll store three
23:52 - now let's say we go ahead and get the
23:54 - value as uh let's say we get a push nine
23:56 - operation
23:57 - now the top of the blue stack will have
23:59 - nine but the top of the green stack will
24:02 - have the value 3.
24:04 - and that is because 3 is the minimum
24:06 - value of 3 and 9 which is going to be
24:08 - the minimum value of the entire stack
24:12 - all right so now what do we do now we if
24:15 - we get a query get min what do we do
24:19 - simply look at the top of the green
24:21 - stack and return that as the answer we
24:25 - are not going to pop out anything at
24:27 - this point of time right
24:28 - as soon as we get a get main query we
24:31 - are going to Peak at the top of the
24:33 - green stack and return that value
24:36 - now let's say we get a operations which
24:38 - says go ahead and pop the element out of
24:40 - the stack
24:41 - so this is going to pop the element 9
24:43 - and now we have to make the green stack
24:45 - we reflect changes of the blue one since
24:48 - we removed an element we will also have
24:50 - to remove the element from the green
24:52 - stack
24:53 - now what if we get a getman query once
24:55 - again
24:56 - if we get a getman query we'll simply
24:58 - look at the top of the stack
25:00 - and since the value 3 will return 3.
25:03 - right so now let's say we get a push one
25:07 - operation what do we do one gets
25:10 - directly pushed onto the green sorry
25:12 - pushed on to the blue stack and the
25:14 - green stack is now going to reflect the
25:16 - changes green stack is going to have the
25:19 - value the minimum of three and one that
25:22 - is it is going to take the minimum of
25:25 - the previous element on the top of the
25:26 - stack
25:27 - the one which we got currently
25:30 - all right so now if I get uh get men
25:33 - again what do we do
25:35 - look at the top of the stack and return
25:37 - one as the answer
25:39 - all right so this is really it for the
25:41 - logic of the code what we have done is
25:43 - we have figured out a way to implement
25:45 - the solution using two stacks so let's
25:47 - go ahead and initialize
25:49 - sorry
25:52 - and uh let's go ahead and create self
25:54 - dot stack
25:56 - and we'll have self dot Min stack right
25:59 - these are the two stacks that we
26:00 - initialize this is the green one
26:03 - and this is the blue one all right now
26:06 - what do we do when we get a push query
26:08 - the stack the stack that we have the
26:11 - blue one is simply going to reflect the
26:13 - changes directly so we'll say when we
26:15 - get a push operation self dot stack dot
26:18 - append X nothing special
26:20 - but what do we do about the Min stack
26:23 - Min stack is going to reflect the
26:25 - changes so I'm going to say
26:27 - self.minstack dot append
26:29 - well I want to append the minimum value
26:31 - of the current X that is I'm going to
26:34 - take the current value and find the
26:37 - minimum with the Min stack top
26:40 - so we'll go ahead and do the main stack
26:42 - find the Top Value and take their
26:44 - minimum right pretty simple
26:46 - this is exactly what we discussed before
26:48 - but now we have to take care about one
26:51 - thing this is a common thing which we
26:53 - have to take here across all the stack
26:55 - questions see what we have tried to do
26:57 - here is that we have to try to access
26:59 - the minus one element on the Min stack
27:02 - that is I'm going to find the top
27:03 - element of the main stack but this will
27:06 - only work
27:07 - when will it work this will only work if
27:12 - the self dot main stack is not empty
27:15 - but if it's empty what do we do
27:18 - look if it's not empty we'll simply take
27:20 - the Min of X and the top of the stack
27:21 - but if it's an empty stack let's just go
27:24 - ahead and directly append this element
27:26 - to the main stack so we'll do self dot
27:28 - mainstack dot append
27:30 - X
27:31 - all right this makes sense
27:34 - so now what do we do when we get the pop
27:36 - operation
27:37 - remember we have to ensure that all of
27:41 - the changes in the stack
27:43 - are reflected in the green one as well
27:45 - so when we do self.stag.pop
27:48 - we have to do the pop operation for the
27:51 - Min stack as well
27:53 - again one more Edge case one more
27:55 - condition you can only do pop when you
27:58 - can only do pop if the stack is not
28:01 - empty so we'll say if
28:04 - self dot stack exist that is there are
28:07 - elements inside of the stack then you
28:08 - can do pop
28:09 - but if the stack is empty pop will
28:12 - really do nothing so we'll just say it's
28:13 - pass right now what do we do when we get
28:16 - top again uh here we have to return what
28:20 - is value at the top of the stack so
28:22 - we'll do stealth dot stack
28:24 - minus 1.
28:26 - but wait a second it is not guaranteed
28:29 - that the self of TAC of minus 1 is going
28:31 - to exist
28:33 - in other words the stack might be empty
28:35 - so if
28:37 - self dot stack exists well then you can
28:40 - go ahead and do this
28:41 - but what do we do otherwise
28:43 - the stack is empty and we are asked to
28:45 - return the top element of the stack
28:48 - well look at the condition
28:51 - in the question mentions something
28:54 - what should top do on an empty stack
28:57 - return -1 so in this case we are going
29:01 - to return
29:02 - -1 right what do we do when we get get
29:04 - min now
29:06 - remember
29:07 - in the top function we return the top of
29:10 - the stack which is the stop of the blue
29:12 - stack but in the getman function we're
29:15 - going to return the top of the green
29:16 - stack so we'll say if self
29:20 - self.minstax exist well then you can go
29:24 - ahead and return the self dot main stack
29:26 - stop
29:28 - but if it does not
29:30 - go ahead and return
29:31 - -1 you can see that there's a lot of
29:33 - paddles between gateman and the top
29:35 - that's because the only thing that
29:37 - changes is the stack in top we use the
29:40 - blue stack and in the green one green
29:43 - one is used in the getman function
29:45 - all right let's go ahead and test this
29:47 - out quickly
29:48 - looks like this is correct so we'll go
29:50 - ahead and submit this
29:55 - all right we get it accepted and this is
29:58 - it for the solution to the problem men
30:00 - stack on interview bit all right that's
30:03 - it hello everyone and welcome back now
30:06 - this is after our first section on where
30:08 - we discuss the stack related questions
30:10 - where we built up our understanding of
30:13 - stacks the implementation level details
30:15 - along with a couple of example problems
30:17 - to help us understand things better
30:19 - in this section we're going to focus on
30:21 - parentheses related questions which is
30:24 - actually going to be a step up from the
30:25 - previous one and is going to lead us to
30:28 - calculator related questions in the next
30:30 - section
30:31 - now why are we talking about parentheses
30:33 - questions in stack playlist
30:35 - you will get the questions answered very
30:37 - soon what we're going to look at is a
30:39 - bunch of example problems like valid
30:41 - parentheses longest valid parentheses
30:43 - written in braces and many more
30:46 - these are commonly asked in interviews
30:48 - and applying Stacks to these problems
30:51 - becomes a crucial part of understanding
30:53 - Stacks themselves
30:55 - all right now we will go ahead and take
30:58 - a look at an example and we'll try to
30:59 - build up our understanding of
31:01 - parentheses related questions and
31:03 - calculated related questions later on
31:06 - because what we're going to understand
31:07 - is the reason why we use Stacks inside
31:12 - of these parentheses questions in the
31:13 - first place
31:16 - all right so given this expression to
31:17 - you let me ask you the question if I
31:19 - give this to you on a paper and I'll
31:22 - give you a pen to solve this how would
31:24 - you go about solving this kind of
31:25 - expression
31:27 - the first thing you would want to do is
31:28 - look at the innermost brackets that is
31:31 - the innermost brackets contain the value
31:33 - D so let's go ahead and evaluate that
31:36 - first
31:37 - right you want to focus on the innermost
31:39 - first and then slowly zoom out to the
31:41 - outermost now what do we do zoom out to
31:45 - we would zoom out to B minus D in The
31:47 - Next Step and this would then finally
31:49 - lead us to the entire expression
31:52 - what we have done is nothing but parsing
31:55 - now parsing is a fancy word for what it
31:58 - means is
31:59 - we have to figure out the structure of
32:02 - the input that is it parsing means to
32:05 - figure out how the input is laid out
32:08 - now why do we want to understand the
32:10 - structure of the input why is this kind
32:12 - of thinking helpful
32:14 - let's take a look at a simple example
32:15 - we'll take this simple example and in
32:18 - this case we have two opening round
32:20 - brackets and two closing round brackets
32:22 - now if I ask you the question can you
32:24 - tell me
32:25 - what is the corresponding opening
32:28 - bracket to this current closing round
32:30 - bracket that is I've highlighted this
32:33 - closing round bracket for you can you
32:34 - tell me which of these
32:37 - is the corresponding current opening
32:40 - bracket
32:41 - pretty simple to answer because we
32:43 - already know the way we do this is by
32:45 - taking the bracket that is the closest
32:47 - we figured that this opening bracket
32:50 - came in the last and was the first one
32:52 - to get a result
32:55 - wait a second
32:56 - the bracket which came in the last was
32:59 - the first one to get resolved that is
33:02 - we're following something of the sort of
33:04 - a leaf ordering
33:06 - that's right this is the reason why we
33:09 - use Stacks in these parentheses
33:11 - questions
33:12 - because when to use stack is answered
33:15 - whenever we see Lee for ordering right
33:18 - so we have seen that we have to use a
33:21 - stack in parentheses questions and in
33:23 - calculator related questions as well but
33:25 - how exactly do we use it
33:27 - how do we use tax in these kind of
33:29 - questions
33:31 - what we are going to do is we are going
33:33 - to do a left to right parsing as I
33:35 - explained earlier parsing is a fancy
33:37 - word what it simply means is we have to
33:39 - understand the structure of the input we
33:41 - have to break it down step by step and
33:43 - understand okay this is what gets
33:45 - resolved first and this is what get
33:47 - resolves later on now left to right
33:49 - simply means that we're going to iterate
33:51 - from the left to the right
33:53 - okay enough talking let me actually show
33:55 - you with an example so this is the
33:57 - example case we took earlier and we have
33:59 - initialized an empty stack on this
34:02 - all right so what do we do next
34:04 - well here's a rule that you have to keep
34:06 - in mind
34:08 - anything that you get which is a opening
34:10 - bracket a character Like A B C D or an
34:13 - operator like plus minus division
34:15 - multiplication anything of that sort you
34:18 - get you simply append it to the stack
34:20 - that is you push
34:22 - everything except close brackets on the
34:26 - top of the stack
34:27 - here's what I mean say we get this
34:29 - opening round bracket we do nothing but
34:31 - push this on the top of the stack
34:33 - then we get a push it on top of the
34:36 - stack then we get Plus
34:38 - open curly bracket B minus open around
34:40 - bracket d
34:42 - the only time V and B do not append
34:45 - items on a stack is when we get a
34:47 - closing bracket this is important this
34:49 - is very important
34:51 - if we get a opening bracket a character
34:54 - or an operator whatever
34:56 - we directly added to the stack without
34:58 - thinking without having second thoughts
35:00 - but as soon as we get a closing bracket
35:03 - of any kind we have to start thinking
35:06 - all right so I already asked you the
35:08 - question of what this closing bracket
35:09 - actually closes what is the
35:11 - corresponding opening bracket and if you
35:13 - see in the stack we actually have that
35:15 - value with us we have this opening round
35:17 - bracket on the top on this stack here
35:19 - however that is not the top element and
35:22 - it might not always be obvious which of
35:25 - these opening brackets am I closing
35:28 - right because we have a currently we
35:30 - have a closing bracket in our hand and
35:32 - we want to figure out hey what is the
35:34 - area that I close
35:36 - what is the area what is the expression
35:38 - that needs to be resolved first because
35:40 - I'm following the leaf forwarding again
35:42 - so what we do is we'll keep on popping
35:44 - these elements of the top of the stack
35:46 - till we see a corresponding opening
35:49 - round bracket here's what I mean as soon
35:52 - as we get this closing around bracket
35:54 - we'll go ahead and start looking for the
35:55 - opening round bracket so we'll pop out D
35:57 - because D is not opening round bracket
35:59 - and so D sort of in an intermediate
36:01 - state
36:02 - we don't really know if D is part of a
36:04 - valid expression or not so we'll just
36:06 - keep it hold
36:08 - right now what we get
36:11 - on the top of the stack you see that
36:13 - there's a opening round bracket
36:15 - what does that mean currently look at
36:18 - the yellow marker we are at a closing
36:20 - round bracket and on the top of the
36:22 - stack we have found a opening round
36:23 - bracket in other words everything inside
36:27 - of both of these brackets is going to
36:30 - get resolved
36:31 - both of these brackets satisfy each
36:34 - other both of them resolve each other
36:35 - and everything in the middle of them
36:37 - will get satisfied so D is actually part
36:40 - of a valid string now right the brackets
36:43 - are balanced in a way
36:45 - all right so now let's go ahead and look
36:47 - at what happens later on we'll keep on
36:49 - iterating and we get a closing curly
36:51 - bracket now what do we do again this is
36:54 - a closing bracket so we have to be
36:56 - careful
36:57 - what do we do we look at the value on
36:59 - the top of the stack this is clearly not
37:01 - opening curly bracket so we'll go ahead
37:03 - and remove it but we'll keep it on hold
37:05 - minus maybe or may not be a part of a
37:08 - valid string
37:09 - all right so we have B now again B is
37:12 - not an opening curly bracket so we can't
37:14 - care about that
37:16 - so B and minus are both at an
37:18 - intermediate State we can't really see
37:19 - anything about
37:21 - what do we get now
37:24 - we have a opening curly bracket in other
37:27 - words we have found the opening for this
37:31 - closing curly bracket which we are on
37:32 - currently
37:34 - in other words what does that mean
37:36 - that means we have resolved everything
37:38 - in the middle of these two brackets so
37:41 - you can see somehow that kind of
37:42 - structure is being followed again we
37:44 - have sort of parsed the input we're
37:45 - trying to understand how this input is
37:47 - laid out all right so now what do we do
37:51 - next let's go ahead and keep on
37:52 - iterating so we get a start again this
37:54 - is not a closing bracket so we'll just
37:56 - add it directly we get a c not a closing
37:59 - bracket added directly and now we get a
38:01 - closing round bracket what do we do next
38:04 - what do we do think about it
38:07 - we're gonna keep on popping these
38:09 - elements out one by one we're gonna keep
38:11 - on popping them out till we get an
38:15 - opening round bracket and as soon as we
38:18 - get an opening round bracket what do we
38:20 - know
38:21 - we know that everything in the middle of
38:23 - both of these brackets is going to be
38:25 - validated
38:27 - and this is the way we have figured out
38:29 - how to parse the input
38:32 - we knew that we had to use a stack
38:34 - because we could see the leaf ordering
38:35 - being followed in the way brackets were
38:37 - opens and closed
38:39 - and then we figured out how to exactly
38:40 - go about looking at the opening and the
38:42 - closing of brackets by using a left to
38:45 - right parsing
38:46 - now a quick small implementation level
38:48 - detail is how do we implement this
38:51 - in the previous example I showed you we
38:53 - were appending these brackets and the
38:55 - pluses and the minuses directly and you
38:58 - can do that you can directly add the
38:59 - elements or you can also add the indices
39:03 - now uh different questions will require
39:05 - different cases but in general if you
39:07 - want one single template just use
39:09 - indices
39:10 - that's because if you append indices to
39:13 - the stack you will obviously have a
39:15 - mapping to the elements as well but if
39:17 - you only append elements to the stack
39:19 - you might forget which indice which
39:21 - index it came from
39:23 - anyways that's a very small level detail
39:25 - but still important to keep in mind just
39:28 - make sure you are consistent with what
39:29 - you are appending to the style whether
39:31 - it be elements or indices right so what
39:35 - is the conclusion let's summarize this
39:36 - once more we figured out in all the
39:38 - parentheses and the calculated questions
39:41 - we have to use a stack why is that
39:44 - because these brackets were following a
39:46 - leaf ordering last ones to get in were
39:49 - the first ones to get out they were the
39:51 - first ones to get a result
39:53 - and how did we figure out how do we use
39:55 - it we know we have to use a stack and we
39:58 - iterate it from the left to the right
40:00 - and we parsed the input we figured out
40:02 - the input and the structure of the
40:04 - string that is given to us and finally
40:07 - you can either add elements or the
40:09 - indexes to the stack that's upon you and
40:11 - that's a small detail you can take care
40:12 - of later on as well
40:14 - all right so keeping these three rules
40:16 - in mind let's go ahead and work out a
40:18 - couple of problems to fully get
40:20 - comfortable with parentheses related
40:22 - questions hello everyone and welcome
40:25 - back let's talk about the problem valid
40:28 - parentheses on lead code this by the way
40:30 - is a slight bit modification of the
40:33 - problem balanced parentheses on entropy
40:35 - bit if we are able to solve this you you
40:37 - will obviously be able to copy paste the
40:39 - code and get it accepted for balanced
40:41 - parentheses as well anyways this entire
40:44 - solution is based upon the understanding
40:46 - from the previous video where we talked
40:48 - about the introduction to all
40:50 - parentheses based questions we figured
40:52 - out how do we use the leaf ordering how
40:54 - do we go from the left to right and
40:55 - pause the input and the way we exactly
40:58 - Implement Stacks so if you haven't
40:59 - checked that video out I'll highly
41:01 - recommend you do because this solution
41:03 - is based entirely on top of that in fact
41:07 - it's going to be a very easy version of
41:09 - what we have seen before
41:10 - all right let me go ahead and show you
41:12 - and take you step by step throughout
41:14 - this problem
41:15 - given a string s containing only
41:18 - brackets we have opening and closing
41:20 - brackets of the type round curly and
41:23 - square
41:24 - and the goal of this problem is to
41:25 - return true if s is valid and false
41:27 - otherwise
41:29 - so looking at the example cases we have
41:31 - the first one Returns the output issue
41:33 - because the closing and the opening
41:35 - brackets match and mix and match
41:38 - appropriately
41:39 - in the second case however there is a
41:42 - spray opening curly bracket which never
41:44 - gets closed in fact it is trying to
41:47 - close the round bracket which is going
41:50 - to be invalid so we have to return false
41:52 - in this case
41:53 - all right let's go and talk about the
41:55 - intuitions and the observations needed
41:57 - to solve this question a bit more
41:59 - formally
42:00 - we'll take the same test case and we'll
42:02 - try to build our understanding from this
42:04 - now if we focus on the opening round
42:07 - bracket we see that it gets close
42:09 - towards the very end we get a closing
42:12 - round bracket towards the very end so
42:14 - both of them resolve each other out
42:16 - all right what about the opening and the
42:19 - closing curly brackets well both of them
42:21 - again mix and match well and this
42:23 - closing bracket is able to close the
42:25 - appropriate opening bracket that is the
42:28 - closing query bracket wants an opening
42:31 - curly bracket to be present before it
42:33 - and it is so we can see that this is
42:36 - also a valid case
42:38 - what about the square brackets again the
42:41 - opening square brackets gets closed by
42:43 - the appropriate closing bracket
42:45 - so this is also valid which means that
42:47 - everything inside of this test case
42:49 - mixes and match as well the opening
42:52 - brackets are closed by the appropriate
42:54 - closing brackets so we return true in
42:56 - this case
42:57 - right let's take another example and
43:00 - this time we have something more
43:01 - interesting going on because we have the
43:03 - same number of opening and the closing
43:05 - brackets that is for one opening around
43:07 - bracket we have one closing round
43:09 - bracket one opening curly bracket we
43:12 - have one closing curly bracket
43:14 - but the ordering in this case is meshed
43:17 - up
43:18 - that's because if you can notice this
43:21 - closing round bracket is trying to close
43:23 - an opening curly bracket
43:26 - obviously this will never work
43:28 - because this closing curly bracket sorry
43:31 - this closing round bracket wants to
43:34 - close an opening round bracket it cannot
43:37 - close the opening curly bracket so
43:39 - brackets in this case do not match
43:42 - and obviously this is contrasted with
43:43 - the case where we have the same number
43:45 - of opening and the closing ground and
43:47 - curly brackets
43:49 - but one of them is invalid and the other
43:52 - is valid
43:53 - so clearly ordering matters
43:55 - and if you notice
43:57 - the input has to follow this Leaf
44:00 - ordering that we discussed in the
44:01 - previous video as well that is the last
44:04 - bracket to get in should be the first
44:07 - one to get out
44:09 - and that was sort of the intuition
44:11 - behind using a stack and we also
44:13 - discussed how do we go from the left to
44:15 - the right and parse the input
44:17 - let's go ahead and do that in the next
44:18 - step
44:19 - one more thing we also discussed that if
44:23 - the brackets open add them directly if
44:25 - the brackets close check what they are
44:28 - closing
44:29 - that is if you get any kind of opening
44:33 - bracket just add it to the stack without
44:35 - thinking Twice But as soon as you get a
44:38 - closing bracket what do you do as soon
44:41 - as you get a closing bracket you have to
44:43 - check whether it closes the right
44:45 - opening bracket or not
44:47 - all right let's go ahead and go ahead
44:49 - with the simulation the first thing
44:50 - we'll do keep on iterating from the left
44:52 - to the right we get the first element as
44:54 - an opening round bracket opening bracket
44:56 - what do we do add directly no thinking
45:00 - then we may trade forward and we get
45:02 - opening curly bracket again since this
45:04 - is opening we'll just add it directly no
45:07 - thinking twice
45:08 - but now what do we get
45:10 - we get a curly closing bracket now we
45:13 - have to be careful we have to be very
45:15 - careful in what we do
45:17 - because as soon as we get a closing
45:19 - curly bracket what do we expect
45:21 - we expect that it closes an opening
45:25 - curly bracket because no other case will
45:28 - work out this closing curly bracket
45:30 - cannot close an opening round bracket or
45:32 - an opening square bracket it can only
45:34 - close and opening curly bracket so now
45:37 - following that leaf ordering again we
45:39 - look at the top of the stack what is the
45:41 - top of the stack
45:42 - it's a opening curly bracket so that's
45:45 - great but this current closing around
45:48 - sorry this current closing curly bracket
45:51 - we found an appropriate opening curly
45:54 - bracket in other words both of them
45:56 - validate each other and satisfy each
45:58 - other pretty nice right all right let's
46:01 - go ahead and continue iterating and we
46:02 - get an opening round bracket since it's
46:04 - opening we added directly
46:06 - but now what to have what happens next
46:09 - we get a closing square bracket
46:12 - what does that mean well this closing
46:14 - square bracket comes in and requests
46:16 - that hey uh can you get me an opening
46:18 - square bracket because that is who I can
46:20 - satisfy right I can mix and match well
46:22 - with the closing or sorry opening square
46:25 - bracket
46:27 - so we go ahead and look at the top of
46:28 - the stack and we see that it's the
46:30 - opening round bracket instead
46:32 - what does this mean
46:34 - this means that this closing bracket is
46:37 - actually invalid
46:38 - and so this was ill-validate the entire
46:41 - expression as soon as we get one invalid
46:44 - case one parentheses messes up as soon
46:47 - as one guy messes up the entire string
46:49 - gets canceled think about it that way
46:51 - right
46:53 - now just to another example is uh what
46:56 - happens if we had a closing round
46:58 - bracket
47:00 - what would happen in this case
47:02 - in this case what would happen is we
47:04 - would be able to mix and match well with
47:07 - the top of the stack
47:08 - so we can say that you know what this
47:10 - closing round bracket will be able to
47:13 - match with the stack top both of them
47:14 - resolve each other and we can move
47:16 - forward with our lives again this is a
47:19 - closing round bracket we'll check the
47:20 - top of the stack is it an appropriate
47:22 - opening bracket
47:24 - yes it is so let's go ahead and close
47:26 - that and we're done
47:29 - now what do we see happening at the end
47:31 - all of these brackets are validated all
47:34 - of the opening brackets have been closed
47:37 - and this is the reason why stack is
47:39 - empty
47:40 - remember this is another important
47:42 - condition which you might miss
47:44 - the stack should be empty at the end and
47:48 - what it says is really is that all of
47:50 - the brackets that opened which we put
47:51 - into the stack remember all the opening
47:53 - were put into the stack and all the
47:55 - closing were removing them from the side
47:57 - so if at the end the stack is empty that
48:00 - is a good sign because we were able to
48:03 - close all the brackets that ever opened
48:07 - now what's another case that could
48:09 - happen let's say that we have another
48:10 - curly bracket towards the end now this
48:13 - is the entire string what would happen
48:16 - in this case we would add it to the
48:17 - stack but this would never get resolved
48:21 - in other words it will be left alone and
48:24 - it would make the entire expression
48:26 - entire parentheses invalid
48:29 - right so it's very important for us to
48:31 - follow a couple of conditions let's go
48:32 - ahead and formalize the logic and that
48:34 - should make a lot more sense
48:36 - all right let's go ahead and talk about
48:38 - the code for the is valid parentheses
48:40 - question all right so first things first
48:42 - we'll go ahead and create a stack which
48:44 - is going to be an empty list
48:46 - next we want to create a mapping from
48:49 - the uh
48:50 - closing bracket to the opening bracket
48:53 - that is for this closing bracket for a
48:56 - closing curly bracket I expect an
48:58 - opening curly bracket to be present on
49:01 - the top of this track right this is
49:03 - something we've discussed already we
49:05 - have to do the same for opening and
49:07 - closing brackets for all the kind now
49:13 - all right cool so now that we have
49:14 - created the mapping we can finally go
49:16 - ahead and start to iterate from the left
49:18 - to the right so we'll go over all the
49:20 - characters in The String given to us
49:23 - now first things we'll check is that if
49:26 - the character is a opening bracket if
49:28 - it's round
49:30 - square or curly opening bracket then
49:33 - don't think twice
49:35 - just append it to the stack
49:38 - right
49:39 - because as soon as we get a opening
49:41 - bracket we directly add it to the stack
49:42 - without thinking twice this is something
49:44 - we've already established
49:46 - else else what do we do
49:48 - in the else condition things get more
49:50 - interesting because now I have to say
49:53 - you know what to check if the mapping of
49:55 - this character if the mapping of this
49:57 - closing bracket maps to the correct
49:59 - value present on the stack top
50:02 - that is for the closing bracket that I
50:05 - have right now can you check if it maps
50:07 - to the correct value that is the opening
50:09 - bracket of curly type on the top of the
50:12 - stack because if it does then it's good
50:14 - then it's good right
50:16 - and we'll see you know what since both
50:18 - of them match both of them resolve each
50:20 - other so I'm just going to do stack dot
50:22 - pop I'm going to remove this bracket
50:24 - that matched
50:26 - all right what do we do in the ash
50:27 - condition what do we say when there's a
50:30 - mismatch
50:31 - as soon as there's a mismatch I'm going
50:32 - to return false I'm going to be
50:34 - merciless as soon as you guys miss much
50:36 - I'm going to return false right away
50:38 - okay there's one more thing that we need
50:40 - to take care of
50:41 - see I've tried to access the stack of -1
50:44 - here what have we learned up till now
50:46 - you just cannot access this stack of -1
50:49 - just whenever you want you have to
50:51 - ensure if the stack exists
50:53 - and only when the stack exists you can
50:55 - do all of these operations well what do
50:58 - you do otherwise
50:59 - what if the stack does not exist
51:02 - what if the stack does not exist and you
51:04 - have a closing curly bracket or closing
51:06 - bracket of any kind rather
51:09 - in that case that closing bracket is
51:11 - trying to close something that doesn't
51:13 - exist in other words we can just set it
51:16 - on pause right away
51:18 - all right so at this point are we done
51:20 - can we return true
51:23 - not so fast this is where another
51:25 - mistake can occur
51:27 - we have to ensure that the stack is
51:29 - empty we have to ensure that the length
51:31 - of the stack is equal to equal to zero
51:35 - why because we already saw this example
51:38 - over here
51:39 - in this case we reached the end of the
51:41 - iteration and we had one curly bracket
51:43 - remaining in the stack
51:44 - and this curly bracket was never
51:46 - resolved it was never popped out of the
51:48 - stack
51:49 - which means that it Still Remains
51:51 - unresolved to this date
51:53 - in other words this entire expression
51:55 - became invalid just because the stack
51:58 - was not empty
52:00 - in just to reframe what does empty stack
52:03 - mean empty stack really means that
52:05 - although the brackets that were input
52:07 - into the stack all of the opening
52:09 - brackets that were ever inputted into
52:10 - the stack have been closed
52:14 - all right cool so let's go ahead and run
52:15 - this code and this gets accepted so
52:18 - let's go ahead and submit this once and
52:20 - we get it accepted as well
52:22 - all right cool so this is it for the
52:23 - solution to the problem valid
52:25 - parentheses hello everyone and welcome
52:28 - back
52:29 - let's talk about the problem redundant
52:31 - braces on interview bid
52:33 - now just a quick aside if you haven't
52:35 - watched the video introduction to
52:36 - parentheses question I highly recommend
52:39 - you watch it because we are directly
52:40 - going to use rules and logic that we
52:42 - formed in that video
52:44 - inside of this question because we're
52:46 - going to apply things directly without
52:47 - talking about it much that's going to
52:49 - make the solution a lot simpler all
52:51 - right anyways let's talk about the
52:53 - problem statement first given a string a
52:55 - containing operators round braces and
52:58 - letters so we have a bunch of operators
53:00 - like plus minus multiplication divide
53:02 - then we have our round braces so we have
53:05 - the opening and closing round brackets
53:06 - and a bunch of letters
53:09 - the goal of this problem is to return
53:10 - one if a has redundant braces and zero
53:13 - otherwise
53:14 - all right so let's go and take a look at
53:16 - some examples how do they find redundant
53:18 - in the first case we have a redundant
53:20 - brace because we have two sets of round
53:23 - brackets wrapping the a plus b when we
53:26 - only ever need one
53:28 - in the second case we see that there are
53:29 - no redundant brackets because we're
53:31 - going to make use of every single one of
53:32 - them
53:33 - so let's go ahead and take a look at
53:35 - some observations and logic from test
53:37 - cases given and really there is just one
53:39 - single observation that we need to pull
53:41 - out from these
53:42 - what is that let's try to build up to it
53:45 - the first test case we see is a plus b
53:47 - wrapped in these two sets of braces
53:50 - why is there redundancy in this because
53:52 - instead of 2 we can just use one right
53:55 - let's take a look at the last test Keys
53:57 - here we have a simple letter A which is
53:59 - wrapped inside of these parentheses
54:02 - but it looks like we don't really need
54:04 - this the example and the problem sector
54:06 - says that you know what this is a case
54:08 - of redundant braces because you don't
54:09 - really need to wrap a in anything else
54:12 - and in the middle we see that we have a
54:14 - plus a plus b in this case there are no
54:17 - redundant braces we're using every
54:18 - single thing
54:20 - now what do you notice
54:22 - there's actually one thing in common
54:24 - with all of them which makes the
54:26 - solution work and this is the central
54:28 - observation of the entire problem
54:30 - what is the observation
54:32 - the observation is there should be no
54:34 - operators in between these braces so in
54:37 - the first one you see between the first
54:39 - set of braces and the second set of
54:40 - braces there are either no letters and
54:43 - no operators right there are no letters
54:46 - or operators
54:47 - in the second one there are both letters
54:49 - and operators and a third one there is a
54:51 - letter but there is not an operator
54:53 - right so we have to ensure that there
54:56 - are no operators between any two sets of
54:58 - braces because if we can make this
55:00 - condition work then
55:02 - will have a case of redundant braces
55:05 - all right just a quick aside what are
55:07 - some of the rules that we saw earlier
55:09 - rules when do we decide when we have to
55:11 - use a stack
55:12 - we use a stack whenever we see a leaf
55:14 - ordering being followed and that is true
55:16 - for all parentheses questions so in this
55:18 - question we're also going to use a stack
55:20 - however we're going to use it we're
55:23 - going to go from the left to the right
55:24 - and parse the input see what uh
55:27 - structure this input is following
55:30 - and finally how do we implement this in
55:32 - this question the elements are the
55:33 - bigger uh Focus instead of the indices
55:36 - so let's just focus on elements let me
55:38 - actually go ahead and show this to you
55:40 - right as we discussed there should be no
55:42 - operators between any two sets of braces
55:44 - this is something we'll keep in mind as
55:46 - we go through the example
55:49 - all right so let's go ahead and iterate
55:51 - from the left to the right one by one so
55:54 - let's say we have the first element and
55:55 - that's the opening bracket so let's just
55:57 - push it on to the stack again if we get
56:00 - opening bracket if we get a operator or
56:03 - if we get a letter we push that onto the
56:05 - stack
56:06 - the only time we don't push an element
56:08 - onto the stack is when we get a closing
56:10 - bracket because then we need to be more
56:12 - careful again this is something I've
56:14 - already explained in the parentheses
56:16 - questions uh the introduction to
56:18 - parentheses questions video if you
56:20 - haven't checked it out if you haven't
56:21 - understood it well enough go ahead and
56:24 - dive into advanced mode right cool so
56:27 - we'll go ahead and continue iterating we
56:29 - get another opening round bracket so
56:31 - we'll just add it to the stack now we
56:33 - get a
56:34 - then we get plus and then we get B
56:37 - nothing special these are just opening
56:39 - brackets operators or letters we add
56:42 - them directly onto the stack without any
56:45 - question
56:45 - only when we get a closing bracket then
56:48 - we have to be careful all right so now
56:50 - that we have gotten a closing bracket
56:52 - let's try to be more careful with what
56:53 - we do
56:54 - what's the first thing we do well this
56:57 - closing round bracket is looking for an
56:59 - opening round bracket to close make
57:01 - sense
57:02 - so we look at the stack top well that's
57:04 - an element B
57:05 - um B is not really useful for us so
57:07 - let's just go ahead and pop that and
57:09 - we'll keep it as an intermediate state
57:11 - we don't really know if B is useful or
57:13 - not
57:14 - and then we see a plus now what does
57:16 - that mean look at the condition on the
57:18 - top right
57:19 - the question wants that there should be
57:21 - no operators if you want to have a
57:23 - redundant brace
57:24 - that is if you can find an operator in
57:27 - this case we have found an operator that
57:30 - means that the expression that we're
57:31 - going to interrupt in these two opening
57:33 - and the closing round brackets is
57:35 - actually going to be a non-redundant one
57:37 - we need those braces in this case again
57:41 - that is just how the problem is defined
57:43 - so now since we have found an operator
57:44 - let's go ahead and keep that in mind and
57:46 - we'll keep on popping these elements out
57:48 - one by one again so we go we pop out
57:51 - plus
57:51 - and then we also pop out a but now what
57:55 - do we have on the stack top there is a
57:58 - opening round bracket
58:00 - and what do we have currently the
58:01 - pointer is pointing to it's losing round
58:04 - bracket which means that everything
58:05 - inside of this has to be considered
58:07 - together right
58:09 - now since we found an operator What can
58:11 - we say about this current highlighted
58:13 - section
58:15 - we can say that this is actually non
58:17 - redundant case so this is actually a
58:19 - valid case of how braces are being used
58:22 - so let's not touch this we'll just keep
58:24 - on iterating forward
58:25 - so now we get a plus again it is not a
58:28 - closing bracket so we can just add it
58:30 - directly no thinking again opening
58:33 - bracket good to go C good to go
58:36 - ah but now we have a closing bracket so
58:38 - let's try to be more careful this time
58:40 - now what do we do
58:42 - the first thing we do is look at the
58:43 - stack top we have our element C again
58:45 - it's not an opening bracket so let's
58:47 - just pop it out keep it as a
58:49 - intermediate state
58:51 - and now what do we have we have a
58:53 - opening bracket so we have found an
58:55 - opening bracket for this current closing
58:57 - bracket what does that mean
58:59 - that means that the entire highlighted
59:01 - expression is what we have to look at
59:03 - right now
59:04 - but look at this
59:06 - there was no operator that we found in
59:08 - the middle
59:09 - right there was no operator in this
59:11 - highlighted expression
59:13 - which means that there are redundant
59:15 - array cells
59:17 - that's correct so this is what it means
59:20 - we have found a redundant bracket and we
59:23 - can return true that yes indeed there
59:25 - are redundant brackets in this input
59:28 - all right so let's go ahead and take a
59:30 - look at the optimized solution and we'll
59:31 - go ahead and code this up
59:33 - right so this is going to be the code
59:35 - where we start from an empty stack again
59:38 - very simple and then we'll go ahead and
59:40 - iterate over all the characters in the
59:42 - input string right
59:44 - now as I mentioned what is the first
59:45 - condition
59:46 - the first condition is if you get a
59:48 - letter if you get a operator or an
59:50 - opening bracket that is if you get
59:52 - anything other than a closing bracket
59:54 - this is directly appended to the stack
59:56 - no thinking at all
59:58 - all right when it goes to the edge
60:00 - condition we have to be a bit more
60:01 - careful
60:02 - so in this condition what we'll do is
60:04 - we'll keep a track of the count and this
60:06 - count keeps a track of account of the
60:08 - number of operators we have seen because
60:10 - remember that is what is going to tell
60:12 - us whether a bracket or whether an
60:14 - expression inside of the input is
60:16 - redundant or not so we'll start the
60:18 - count from 0 and we'll say you know what
60:20 - since we have found this uh closing
60:23 - ground bracket let's just go ahead and
60:25 - keep on popping these elements out from
60:28 - the top of the stack one by one till we
60:30 - get a
60:31 - opening round bracket right till we get
60:34 - a opening round bracket so we'll go
60:36 - ahead and say now if the Pod is actually
60:39 - an operator
60:41 - that is if it's any of the plus minus
60:44 - star or Division if the character is any
60:47 - of these operators then I want you to do
60:49 - count plus one
60:51 - in other words since we have found a
60:54 - positive number of counts of The
60:56 - Operators whatever the expression is
60:58 - going to be is going to be a valid
61:01 - non-redundant expression
61:03 - and of course at the end of this while
61:05 - loop we are going to do a stack dot pop
61:07 - because we want to pop out this uh
61:10 - opening bracket we don't really have any
61:12 - use for this at all
61:14 - anyways now what do we do
61:16 - once we're done with this entire
61:18 - iteration of this while loop we're gonna
61:20 - check what the condition is
61:23 - we're gonna say if the count is zero
61:25 - that is if the count did not change at
61:27 - all in other words we did not encounter
61:30 - any operators if we did not encounter
61:32 - any operators return one we have found
61:36 - the case of redundancy
61:38 - and if not we'll just keep on going
61:40 - forward going forward again and again
61:41 - and again and if throughout the entire
61:44 - iteration of this entire string you find
61:46 - no such redundancy then you can safely
61:49 - return 0. that is the entire string is
61:52 - non-redundant
61:54 - right so let's go ahead and test this
61:56 - out it looks like it works and we'll go
61:58 - ahead and submit this as well
62:01 - cool so this gets accepted and this is
62:04 - it for the solution to the problem
62:05 - redundant braces hello everyone and
62:09 - welcome back let's talk about the
62:11 - problem minimum removed to make valid
62:13 - parentheses this by the way is a medium
62:15 - level question on lead code and we're
62:17 - going to use this problem to build up
62:19 - our solution for longest valid
62:21 - parentheses as well in fact this
62:24 - solution is going to convert that hard
62:26 - problem into an easy one I'm not even
62:28 - kidding all right let's go ahead and get
62:30 - started with the problem statement
62:32 - so we're given a string that contains
62:34 - opening and the closing round brackets
62:36 - and lowercase English letters
62:38 - the goal of this problem is to remove
62:40 - the minimum number of parentheses to
62:42 - make S valid
62:44 - so in the first case we see that there
62:45 - are two opening brackets and one closing
62:47 - bracket and we see that we have to
62:49 - remove any one of these opening brackets
62:51 - to balance these opening and the closing
62:53 - ones out
62:54 - okay pretty simple and so what I've
62:56 - decided to do is I've decided to remove
62:58 - the first opening bracket and keep the
63:01 - second one you can also do it the other
63:03 - way both of them are perfectly fine
63:05 - in the second case we have the input as
63:08 - 1337 wrapped inside of brackets
63:11 - in this case I have to remove no such
63:13 - parentheses to convert it to a valid
63:16 - string because it's already a valid
63:17 - string all right so let's go ahead and
63:19 - take a look at some observations the
63:21 - logic to build up to the solution
63:23 - now we already talked about this test
63:25 - case where we removed the first bracket
63:28 - but I want you to notice one more thing
63:31 - the question clearly mentioned that we
63:33 - can only remove brackets that is we have
63:35 - to remove the minimum number of brackets
63:37 - to make it a valid shrink in other words
63:39 - we're only going to remove brackets and
63:42 - never the lowercase English letters
63:45 - now this is important because what we
63:47 - can do is simplify our life a bit what
63:49 - we can do is look at these characters
63:50 - instead as indices and we can filter out
63:53 - all of those characters which are
63:56 - lowercase English letters
63:58 - in this way we have simplified the
63:59 - problem quite a lot and now we only have
64:01 - to worry about the brackets opening and
64:03 - closing
64:04 - all right so let's go ahead and talk
64:06 - about uh a couple of rules that we
64:09 - discussed previously first was the thing
64:11 - where uh why do we use a stack and when
64:14 - do we use a stack as soon as we see a
64:16 - leaf quadrant being followed we are
64:17 - going to use a stack and in this
64:19 - question is a parenthesis question so we
64:21 - will use the stack the second thing was
64:23 - how do we use it well we're going to go
64:25 - from the left to the right and parse the
64:27 - input that is for every opening bracket
64:30 - we see we'll go ahead and add it to the
64:32 - stack and for regularly every Closing
64:34 - one we are going to remove an opening
64:36 - from the stack
64:37 - so both of them are going to resolve
64:39 - each other this will make sense in a
64:40 - second don't worry about it and the
64:42 - third one is how do we implement this
64:45 - in this case it is better to use indices
64:48 - instead of elements okay because we did
64:51 - a filtering out operation which means
64:53 - that indices are going to be the way to
64:56 - go
64:57 - all right so let's go ahead and get that
64:59 - input set up and now we have an empty
65:01 - stack with this so what we'll do is
65:04 - we'll go ahead and start to iterate from
65:05 - the left to the right so first we'll go
65:07 - ahead and look at the element 0. all
65:10 - right so element at the index 0 is an
65:12 - opening bracket so we're going to add it
65:14 - directly onto the stack no questions
65:16 - asked
65:17 - then we move on and we iterate further
65:20 - and we find another opening bracket at
65:22 - the index four so we'll again add the
65:24 - index 4 to the stack
65:26 - oh by the way I am adding these indices
65:28 - and you have to focus on getting these
65:30 - indices into the stack the brackets are
65:32 - there just for the sake of demonstration
65:34 - and understanding we're actually going
65:36 - to only have indices in the stack not
65:39 - the brackets
65:40 - anyways then we go ahead and reiterate
65:43 - further and we find that we get a
65:44 - closing round bracket
65:46 - now what does this mean
65:48 - we have found a closing round bracket
65:51 - which means that it is going to satisfy
65:53 - the opening round bracket so this 9 is
65:56 - going to get satisfied with the 4.
65:59 - both of them mix and match together and
66:01 - we'll pop the element 4 out of the stack
66:03 - this is the reason why you see 4 and 9
66:05 - in the answer
66:06 - make sense
66:08 - now we reached the end of the iteration
66:09 - but 0 Still Remains on the top of the
66:11 - stack
66:12 - in other words it never gets satisfied
66:15 - it never finds any closing bracket to
66:18 - resolve it
66:19 - so we'll leave 0 out
66:22 - so the minimum remove to make valid
66:24 - parentheses is going to remove the
66:26 - element 0 from the input
66:29 - okay let's go ahead and take a look at
66:31 - another example and this one will really
66:33 - bring forward the core of the problem
66:37 - so let's go ahead and start iterating
66:38 - from the first element we see 0 which is
66:40 - a closing bracket now this closing
66:43 - bracket is going to close an opening
66:45 - bracket
66:46 - but do we have an opening bracket on top
66:48 - of the stack
66:49 - well no we don't even have any brackets
66:52 - on top of the stack we don't have any
66:54 - brackets at all
66:55 - which means that this closing bracket
66:57 - will never get satisfied it will be
66:59 - alone always and forever so we are going
67:01 - to leave it and we're going to iterate
67:03 - further
67:04 - all right so now we get an opening
67:06 - bracket let's go ahead and add it to the
67:07 - stack pretty simple
67:09 - next iteration we see that we get a 4.
67:12 - now this four did what as soon as this 4
67:16 - got an opening bracket
67:19 - popped it out and satisfied both of them
67:21 - so now both the opening and the closing
67:23 - brackets have satisfied each other which
67:25 - means both of them are essential to be a
67:28 - part of the solution
67:30 - right so let's go ahead and continue
67:31 - iterating now we get 6 and this is an
67:34 - opening bracket so let's just go ahead
67:36 - and add it to the stack
67:38 - then we get a 7 also added to the stack
67:40 - and then we get a 9. what do we do when
67:43 - we get a 9
67:44 - that's right we'll pop out the 7 and now
67:47 - both 7 and 9 will satisfy each other
67:51 - at this point we have 1 4 7 and 9 which
67:55 - are the
67:56 - parentheses which satisfy each other in
67:59 - other words they form an essential part
68:01 - of the answer however 0 and 6 have to be
68:04 - removed right we have to remove a
68:06 - minimum number of brackets and this way
68:08 - we have found two brackets to remove
68:09 - from the answer
68:12 - okay pretty simple uh but what would
68:15 - happen say if I get a 10
68:17 - which is a closing bracket just for uh
68:20 - thought process sake
68:22 - as soon as I get this 10 what would
68:24 - happen this 10 is going to satisfy the
68:27 - element on the top of the stack which is
68:28 - the element six so 10 and 6 are going to
68:32 - satisfy each other and so
68:33 - there is where we end the iteration all
68:37 - right let's go ahead and take a look at
68:38 - the optimize solution and uh okay cool
68:41 - let's go ahead and get started now if
68:43 - you notice what we have done up till now
68:45 - is uh have a differentiation between
68:49 - these blue and the green ones right the
68:52 - blue ones were ones that never got
68:54 - satisfied and the green ones were the
68:55 - ones which got satisfied
68:57 - so the first thing I'm going to do is
68:59 - create an array called is okay which is
69:01 - going to be initialized with 0 for all
69:03 - the values of the string in other words
69:05 - I'm going to say none of the elements in
69:08 - the original shrink ever get satisfied
69:10 - that is my initial assumption and I'm
69:12 - going to build upon that later on now
69:15 - I'll also have an initial stack and
69:17 - we'll go ahead and start iterating over
69:18 - all the elements inside of the string so
69:21 - we'll first get its index another
69:22 - character for every single element of
69:25 - the string
69:26 - now if the characters in opening bracket
69:27 - what do we do
69:29 - if the character is an opening bracket
69:30 - we add it to the stack without asking
69:33 - any questions now what happens when we
69:36 - have a closing bracket
69:37 - when we have a closing bracket we'll
69:39 - first ask the question here does the
69:41 - stack exist is there any opening bracket
69:44 - on the top of the stack because if there
69:47 - is what do we do if there is we will pop
69:50 - that element from the top of the stack
69:52 - and assign its index the value 1. saying
69:56 - that this opening bracket which we just
69:58 - popped out is actually a one it is okay
70:01 - it is a green value as we saw in the
70:03 - case for one and seven both of them were
70:06 - opening brackets and they got Satisfied
70:08 - by four and nine respectively
70:10 - so one and seven both get this one
70:13 - and we also assign is okay if I to one
70:15 - as well saying that because 4 was the
70:18 - one that popped out one from the top of
70:20 - the stack one gets satisfied but also
70:23 - four gets satisfied
70:24 - so we're going to satisfy both of them
70:26 - and what is the else condition what if
70:29 - the stack is non-existent what if we get
70:31 - a closing bracket and then we realize
70:34 - that hey wait a second the stack is
70:36 - empty so we can't really close any
70:39 - opening bracket
70:41 - in other words we'll just have to
70:43 - continue unfortunately skipping over
70:44 - this current I
70:46 - alright so was the final lens condition
70:48 - if you get a opening bracket we append
70:51 - it to the stack if you get a closing one
70:53 - we check the stack for emptiness or not
70:55 - and figure out what to resolve but
70:58 - there's a final condition which says if
71:00 - you have English letters well go ahead
71:03 - and also continue because we don't want
71:05 - to mess with any lowercase English
71:07 - letters what we are only going to
71:09 - message
71:10 - we are only going to mess with the
71:13 - indices of the parentheses
71:16 - all right so at the end of this
71:18 - iteration is okay is the array which
71:20 - contains all the information it is the
71:23 - one which contains the information of
71:24 - which all are blue which already do and
71:27 - which one or green the green represents
71:29 - one and blue represents zero right so
71:32 - let's go ahead and
71:34 - iterate further now the goal of this
71:36 - problem is to return the string
71:39 - we have to return the string by removing
71:41 - the minimum number of parentheses
71:43 - Now using this is okay array we have
71:46 - already found out all the parentheses
71:47 - which are essential and which are
71:49 - non-essential
71:50 - so what we are going to do is we are
71:52 - going to go ahead and build the answer
71:53 - character by character once again
71:55 - remember all of this what this tag did
71:58 - was to store the indices of the elements
72:00 - and this is why the is okay thing worked
72:02 - out now we are going to iterate over the
72:04 - string once again and we are going to
72:06 - ask the question hey is the character a
72:09 - bracket or not because if it is a
72:11 - bracket and only if it is okay
72:15 - only if it has been satisfied then we
72:18 - added to the answer
72:19 - because if it's a bracket and it has not
72:21 - been satisfied we'll have to continue
72:23 - we'll have to pass over this test case
72:26 - now was the else condition over here if
72:28 - the character is a bracket then you will
72:29 - have to check if it's okay or not but if
72:32 - a character is not a bracket that is
72:34 - it's a lowercase English letter then by
72:37 - default you have to add it to the answer
72:40 - all right anyways at the final point of
72:43 - time you go ahead and just return the
72:44 - answer so let's go ahead and run the
72:46 - code for sample test cases
72:48 - and some of this
72:51 - all right cool so this is it for the
72:53 - solution to the problem minimum remove
72:55 - to make valid parentheses hello everyone
72:58 - and welcome back let's talk about the
73:00 - problem longest valid parentheses now if
73:03 - you haven't seen the video on minimum
73:05 - remove to make valid parentheses this
73:08 - question will seem out of the blue
73:09 - however if you have seen that this
73:11 - question is just a breeze question
73:13 - because we're going to use the exact
73:15 - same logic as we saw in the previous one
73:17 - all right let's go ahead and talk about
73:19 - the problem statement of formally and
73:21 - we're given a string of just opening and
73:23 - the closing brackets that is we only
73:25 - have opening and the closing around
73:27 - brackets
73:28 - the goal of this problem is to find the
73:30 - longest substring of valid parentheses
73:33 - in other words let's take an example in
73:35 - the first test case we have the opening
73:37 - and the closing brackets which form a
73:38 - length of two but then we have three
73:40 - opening brackets which never get closed
73:43 - in other words the longest substring of
73:46 - valid parentheses is just 2.
73:49 - now the second test case is one where we
73:51 - have opening and closing bracket and
73:52 - then we have a bunch of opening brackets
73:54 - the bin one opening bracket at the end
73:57 - gets closed now what is the longest
74:00 - substring of valid parentheses we have
74:02 - in this case two sets of the length two
74:05 - substring of valid parentheses since
74:07 - both of them are of land 2 will just
74:09 - return to as the answer
74:11 - now what can we say right away about
74:13 - this kind of question
74:15 - this kind of question is actually
74:17 - twofold we have to find two things first
74:19 - first we have to figure out what all
74:22 - parentheses are valid or not
74:24 - because once we have the valid
74:26 - parentheses in hand once we know which
74:28 - of them are valid which of them are
74:29 - invalid we simply have to find the
74:32 - longest substring of them
74:33 - right so this is going to be uh broken
74:36 - down into two parts and if you realize
74:38 - the answer to the first one is something
74:40 - we've already seen
74:42 - all right since there is not a lot to go
74:43 - on let's go ahead and just build up our
74:45 - logic from the previous question
74:48 - as with the previous one we'll set up an
74:50 - is okay variable that is going to be all
74:52 - zeros of the length n in other words
74:54 - it's going to say that you know what
74:56 - I'll assume none of the brackets opening
74:59 - or closing ever get satisfied all of
75:01 - them are zeros
75:03 - we'll also have an initial
75:04 - initialization of this track and then
75:06 - we'll start to iterate our all the
75:08 - characters in the string
75:09 - as before we'll check if the character
75:12 - is a opening bracket or not because if
75:14 - it is an opening bracket will just
75:16 - directly add it to the stack
75:18 - what if it's a closing bracket though
75:21 - in the else Condition it's a closing
75:22 - bracket we'll have to check if the stack
75:25 - exists or not
75:26 - that is for this current closing bracket
75:29 - because I've gone in dl's case for this
75:31 - closing bracket does the stack exist
75:34 - in other words is there a opening
75:36 - bracket is there any opening bracket
75:38 - that you can find which had been put on
75:40 - the stack
75:41 - now if you can find that is the case
75:43 - well then go ahead and make both of them
75:46 - satisfied that is go ahead and pop the
75:49 - element from the top of the stack which
75:50 - is going to be an opening bracket and
75:52 - set its value to 1 that is that opening
75:55 - bracket has been satisfied by this
75:57 - current closing bracket and obviously
75:59 - that also means this current losing
76:01 - bracket has been satisfied so we'll set
76:03 - is okay file to B1
76:06 - and the off chance that the stack is
76:08 - empty and you get a closing bracket well
76:10 - that's just sad we can't really do
76:11 - anything about that I'm sorry
76:13 - anyways once we're done figuring out
76:15 - which of them which of the brackets
76:17 - opening or closing are valid or not we
76:20 - simply have to figure out the longest
76:22 - substring of these valid cases so what
76:25 - we'll do is we'll set up a count which
76:26 - is going to be a running count of all
76:27 - the values and we have a answer which is
76:31 - going to store the maximum of all of
76:32 - these counts so what we're going to do
76:34 - is we're going to iterate in the range
76:36 - of n that is we'll iterate over every
76:38 - single index and we'll ask the question
76:40 - hey is the bracket I'm looking at is the
76:43 - current bracket okay or not because if
76:46 - it is okay well that's great news
76:47 - whatever the count was increase its
76:50 - value by one why because I found the
76:53 - case of a valid parenthesis
76:56 - right so as soon as I know this current
76:59 - bracket is a part of a valid substring
77:01 - go ahead and add one to the count else
77:04 - else what do we do
77:06 - if at this point of time there is a
77:09 - bracket which is a stray bracket which
77:10 - never gets opened or never gets closed
77:12 - well then we unfortunately have to reset
77:15 - the counter from zero
77:18 - okay so the next step is then going to
77:20 - be simply taking a Max of the answer in
77:22 - the count because answer wants to store
77:24 - the maximum possible value of all the
77:26 - counts ever
77:28 - all right so this is it for the code
77:30 - let's go ahead and run it and we'll go
77:32 - ahead and submit this as well
77:33 - and cool this gets accepted
77:36 - so yeah this is it for the solution to
77:37 - the problem long history valid
77:39 - parentheses
77:40 - hello everyone and welcome back this is
77:44 - the start of a new section on calculator
77:46 - related questions it builds on top of
77:49 - our previous work on parentheses related
77:51 - questions we'll be discussed the exact
77:53 - reasons why we use a stack how we use it
77:56 - especially the left to right parsing
77:58 - method and the implementation level
77:59 - details that we need to take care of
78:02 - now what I'm going to do in this video
78:04 - is establish the we just need two steps
78:06 - that's right just two steps we need to
78:09 - know to solve any calculator related
78:11 - question
78:12 - in fact both of these steps individually
78:14 - are interview problems on their own
78:16 - which means that once we solve both of
78:18 - them both of these questions we'll be
78:21 - able to solve any calculator related
78:23 - question that is like killing three
78:25 - birds with two stones
78:27 - all right so the first step is to parse
78:30 - the input from the infix to the postfix
78:32 - notation and the second one is to
78:34 - evaluate the post fix notation
78:36 - now the first question that you should
78:37 - ask is wait what is the post fix
78:40 - notation
78:41 - so let's go ahead and talk about the
78:43 - introduction to the postfix notation
78:45 - first
78:46 - all right let's go ahead and take a
78:47 - simple example and let's see that we
78:49 - have this kind of string that we need to
78:51 - evaluate
78:52 - now the infix notation is formally
78:54 - defined as such
78:55 - in the infix notation the operator is
78:59 - fixed in between the operands
79:02 - again the operator is the focus over
79:05 - here and the operator is going to be
79:07 - fixed in between in the operands now
79:11 - what is the post fixed notation
79:13 - formally speaking postfix notation is
79:15 - where the operator is present after the
79:17 - operands now that might sound a bit
79:20 - unnatural given that what we have been
79:21 - looking at all throughout our life is
79:23 - the infix notation this is the simple in
79:26 - fixed notation over here and if I ask
79:28 - you the question hey how would you go
79:30 - about evaluating this kind of thing what
79:32 - would you do
79:33 - the first thing we'll look at is
79:35 - brackets so we'll evaluate everything
79:37 - inside of the brackets so 3 times 3
79:39 - becomes 9. and so this is the expression
79:42 - that we have now
79:43 - what do we do next we realize that we
79:46 - have to do a division operation first
79:48 - which means that we'll do 9x7 C style
79:51 - division
79:52 - so 9x7 will get rounded off to 1. and
79:55 - now we have 0 minus 1 plus 1. and since
79:58 - plus and minus are of the same priority
80:00 - we'll simply cancel both of them out and
80:02 - say the final answer is nothing but zero
80:06 - now what have we done over here what we
80:08 - have done is simply apply a rule called
80:10 - bod Mass which stands for bracket order
80:13 - division multiplication addition and
80:16 - subtraction
80:17 - this is a rule that is commonly taught
80:19 - in high school math and is the way we
80:21 - evaluate any sort of input given to us
80:24 - however there is a small catch
80:26 - see if you have brackets inside of
80:28 - brackets those brackets inside of
80:30 - brackets need to be resolved first
80:32 - before you evaluate the brackets
80:35 - and if you have brackets inside of
80:36 - brackets inside of brackets then you
80:38 - resolve then you need to resolve the
80:40 - innermost bracket first then zoom out
80:42 - and then zoom out once again
80:44 - you can see that this sort of nesting is
80:47 - what can give rise to such complicated
80:50 - expressions and while the first one on
80:52 - the top is pretty easy to solve using
80:55 - the same in fixed notation the second
80:57 - one becomes much more harder
81:00 - and so the question arose
81:02 - whether we can write the expression
81:04 - unambiguously and we can solve it
81:06 - efficiently
81:07 - that is without having to worry about
81:09 - this Bond Mass rule is there a way we
81:12 - can write this expression and secondly
81:14 - is there an efficient way to solve that
81:16 - expression once you have written it that
81:18 - way
81:19 - this is the idea behind post fixed
81:22 - notation
81:23 - the both fixed notation simply says that
81:25 - the operator is present after the
81:27 - operands in other words if we take an
81:29 - example like this we have 1 2 plus it is
81:33 - equivalent to saying 1 plus 2.
81:35 - again I know this sounds unnatural but
81:38 - bear with me for a second because
81:39 - something interesting is going to happen
81:41 - let's see if we have 1 2 plus 3 star
81:44 - what will that evaluate to
81:46 - 1 2 plus will become 3 and then we have
81:49 - 3 3 star
81:51 - in other words we'll have 3 times 3.
81:55 - what we have done is one plus two inside
81:57 - of brackets that needs to be resolved
81:59 - first and then we'll do times three
82:02 - do you notice something
82:04 - if we go back the other way around we
82:07 - have figured out a way to write these
82:09 - bracketed Expressions into non-bracketed
82:12 - ones that is one plus two which had to
82:14 - be resolved first which were present
82:16 - inside of the brackets we found a way to
82:18 - write that without using the brackets
82:20 - how nice is that we were able to figure
82:23 - out a way to unambiguously write this
82:26 - expression
82:27 - all right so this is the general idea
82:29 - behind using a post-fixed notation and
82:31 - so we can finally formally talk about
82:33 - these two steps again the first step was
82:35 - to convert and parse the input from the
82:38 - infects to the postfix notation and that
82:40 - is something we're going to look at in
82:41 - the next video and then in the next to
82:43 - next one we'll look at how do you
82:45 - evaluate the postrix notation all right
82:48 - so let's get started hello everyone and
82:50 - welcome back let's talk about how do we
82:53 - convert the infects to the post fix
82:55 - notation
82:56 - as we discussed the infix notation is
82:59 - one in where we put the operator in
83:02 - between the operands that is we fix the
83:05 - operator such as a minus between the
83:07 - operands such as 0 and 1. so we have
83:09 - something like 0 minus 1. in the post
83:12 - fixed notation we have the operator
83:14 - after the operands where we have
83:16 - something like 0 1 minus
83:18 - let's go ahead and take a look at some
83:20 - examples to understand this vector in
83:22 - the case we have 1 plus 2 in the infix
83:24 - notation it gets converted to 1 2 plus
83:27 - if we have say 5 minus 6 it gets
83:30 - converted to 5 6 minus
83:32 - and then if we have something like 1
83:34 - plus 2 times 3 we have 1 2 plus 3 times
83:39 - wait a second uh one two sorry one plus
83:43 - two times three will evaluate to 1 plus
83:46 - 6 which is nothing but 7. but if we
83:49 - actually evaluate this
83:50 - will come out to be wrong
83:52 - that's because 1 2 plus will get
83:56 - evaluated to 3 first
83:58 - and then we'll have to do three times
83:59 - three
84:00 - giving us the answer nine
84:02 - this is in fact wrong we are doing one
84:06 - two plus three times which is wrong
84:09 - so what do we have to do instead
84:11 - we have to switch out the ordering of
84:14 - this Plus
84:15 - because now what we have done is we have
84:17 - done one two three Star Plus basically
84:19 - saying go ahead and multiply 2 and 3
84:21 - first so 2 times 3 becomes 6 and so
84:25 - we'll write 1 6 Plus Now 1 6 Plus is
84:28 - what it's nothing but 1 plus 6 which is
84:30 - seven and so now we have the correct
84:32 - answer
84:33 - but if you notice what happened over
84:35 - here we realized something The Ordering
84:38 - of these plus and the star operators
84:39 - changed
84:41 - right we had one plus two times three
84:45 - and it becomes 1 2 sorry it became one
84:48 - two three Star Plus
84:51 - so the ordering of the plus and the star
84:53 - operators change although the ordering
84:56 - of the operands like one two three did
84:58 - not change
84:59 - there's something interesting which
85:01 - we'll come to very soon again
85:03 - all right so now we want to formally
85:04 - talk about how do we convert the infix
85:07 - notation to the postfix notation right
85:09 - so let's go ahead and try to work out
85:11 - the answer one by one
85:13 - so using the board Master will let me
85:15 - know we can say that you know what let's
85:16 - go ahead and do the division operation
85:18 - first all right so we have to do B by C
85:21 - first and how are we going to write d by
85:23 - C
85:23 - we're going to write it as B C slash all
85:27 - right pretty simple up till now then
85:29 - what do we do next
85:30 - we also realize that there's a b by c
85:32 - times D we have to do times D in The
85:35 - Next Step because that is the second
85:37 - operation we have to follow using the
85:38 - board Mass rule so what will how do we
85:41 - write times d
85:42 - well BC by forms one single operand now
85:45 - and so we have to multiply BC by with d
85:49 - BC by is one operating and D is another
85:52 - and so we can write BC by D star
85:56 - all right how do we handle the plus case
85:59 - and the minus case then well it's going
86:01 - to handle the plus one first so we have
86:02 - a plus this entire expression now can we
86:05 - handle that
86:06 - we can write a in the front and plus the
86:09 - end and then we have minus E towards the
86:12 - end so we can write it as e minus
86:15 - right so we followed the bod Mass
86:17 - property and we have written down the
86:19 - infix to the postfix notation
86:21 - in fact if you break it down we have
86:23 - something of this sort first we looked
86:25 - at BC slash then D star then a plus and
86:28 - then e minus
86:30 - following the board Mass rule exactly
86:33 - in fact what we have done here in other
86:35 - words is that we have somehow implicitly
86:37 - encoded the information of the bond Mass
86:40 - rule into the post fixed notation
86:43 - now to evaluate the post fixed notation
86:44 - we won't need this bodmas rule at all
86:46 - because we have already encoded that
86:49 - information in the structuring of the
86:51 - post fixed notation
86:53 - right let me go ahead and explain that
86:55 - further
86:56 - what we have done is that we looked at
86:58 - the bod muscle and we figured out that
87:00 - we have to First Look at brackets then
87:02 - order then Division and multiplication
87:04 - are the same level then addition and
87:06 - subtraction are the next lower level
87:08 - right so this is something we've
87:10 - implicitly encoded into the answer look
87:13 - at the ordering of The Operators we have
87:15 - slash first then star then plus and then
87:18 - minus
87:19 - I also want you to notice another thing
87:21 - which I brought up earlier as well
87:24 - The Ordering of the operands which are a
87:27 - b c d and e remain the same from the
87:31 - infix to the post fixed notation
87:33 - only and Only The Ordering of The
87:36 - Operators change it went from plus slash
87:39 - star minus that is it went from a
87:41 - completely random ordering to a
87:43 - well-defined ordering where we had
87:45 - division multiplication addition and
87:47 - subtraction
87:49 - so now the question is how do we
87:51 - implement this how do we make this
87:53 - happen using formal logic
87:55 - what we're going to do is we're going to
87:57 - go ahead and use a stack to do this let
87:59 - me actually run a simulation and show
88:01 - you how this works
88:02 - the first thing we'll do is we'll start
88:04 - to iterate from the left to the right
88:06 - and so let's say that we get the first
88:08 - element as a since this is the operand
88:10 - and we don't mess with the order of the
88:13 - operands we are just going to write it
88:14 - as a part of the answer directly no
88:16 - thinking twice you see an operand you
88:18 - write it in the answer that's it as
88:20 - simple as that
88:22 - what's the next step
88:23 - the next step is to iterate further and
88:25 - we see that we get a plus sign
88:27 - since the ordering of these operators do
88:30 - change later on we'll keep them in a
88:32 - stack for now and we'll see what to do
88:33 - later on right so now we add this plus
88:36 - to the stack
88:37 - then we get the element B and what do we
88:39 - do since b as an operand We'll add it
88:42 - and obtain it at the end of the post
88:44 - fixed answer
88:46 - all right cool so now we get a slash
88:49 - now I'm going to ask you a very
88:51 - important question is it okay to put
88:53 - this slash after this Plus
88:56 - or should we instead remove this plus
88:59 - first and add the slash later on
89:02 - what should we do
89:04 - let's think about something that is
89:05 - going to happen
89:07 - if you remember stack follows something
89:09 - called the default ring the last one to
89:11 - come in is the first one to get out
89:14 - and notice how the answer on the top
89:15 - right hand side says
89:17 - the answer on the top right hand says
89:19 - that we have to have division then
89:20 - multiplication then addition and
89:22 - subtraction that is we have to follow
89:25 - this highest to lowest ordering in the
89:27 - post fixed notation that is something
89:29 - that we have to encode it by default
89:32 - now if it means that we have to have the
89:34 - highest operation highest priority
89:36 - operators first and the lowest ones
89:38 - later on using this lifo notation what
89:41 - should be the ordering we follow in the
89:43 - stack
89:44 - again the last ones to get in will be
89:47 - the first ones to get out so if you want
89:49 - the highest ones to come first in the
89:51 - answer we'll have to ensure that the
89:53 - highest ones are the first one to leave
89:56 - out of the stack
89:57 - in other words we have to say that the
90:00 - stack follows the lowest to highest
90:02 - ordering
90:03 - so in fact what we have right now plus
90:05 - followed by a slash is okay
90:08 - because in the edge case because in the
90:10 - edge case that we ever decide to remove
90:12 - both of these elements first will pop
90:14 - out slash and then Plus
90:17 - which now exactly follows the ordering
90:19 - we want
90:20 - right so I think that should make a lot
90:21 - more sense now so let's go ahead and
90:23 - continue iterating we get the element C
90:25 - and since this is an operand We'll add
90:27 - it directly add it to the stack
90:30 - now what do we do when we get a slasher
90:32 - uh sorry when we get a star operation
90:35 - remember the board Mass rule
90:37 - it says the first you resolve brackets
90:39 - then order then Division and
90:40 - multiplication at the same level
90:43 - what does it mean for us to get a
90:45 - division and a multiplication right now
90:48 - this is nothing but going to hint us at
90:51 - the fact that this multiplication
90:53 - operator is actually going to take this
90:55 - division operator and kick it out
90:58 - because both of them are of the same
91:00 - priority and remember what is the
91:02 - ordering of the stack The Ordering of
91:04 - the stack goes from the lowest to the
91:06 - highest
91:07 - all right we can't allow elements of the
91:09 - same priority to stick in together so
91:11 - we'll have to kick out the Slash and
91:14 - only then we can add in the star again
91:17 - if you look at it it is still going to
91:19 - maintain lowest to the highest ordering
91:21 - now right it only happens after we kick
91:24 - out the Slash and if you look on the top
91:27 - side top right hand side we can see that
91:29 - you know what this is indeed the correct
91:30 - way to go so we're thinking about this
91:32 - correctly
91:33 - anyways let's keep on iterating further
91:35 - and see what happens we get a d and
91:37 - since this is a what since this is an
91:39 - operand we'll add it directly to the
91:42 - answer
91:43 - then we get a minus and now what happens
91:46 - the priority of minus is much lower than
91:49 - that of multiplication
91:50 - which means that this minus is going to
91:53 - kick out the multiplication you can
91:55 - think about it this way you can think
91:57 - that an undeserving candidate comes a
91:59 - lower priority element comes and it
92:01 - kicks out all the higher priority or the
92:04 - equal priority elements out of the stack
92:06 - it says that you know what you guys are
92:08 - much higher priority than me minus comes
92:10 - in and says you know what addition and
92:12 - multiplication are both either higher or
92:14 - equal to me so I'll kick you both out
92:16 - let me just go and stay in the stack so
92:19 - we'll go ahead and first kick out the
92:20 - multiplication operator and then we'll
92:22 - again compare it with the addition one
92:23 - so now we'll say okay you know what
92:25 - since plus and minus are both of the
92:27 - same priority let's go ahead and kick
92:29 - out plus as well then we'll add minus
92:31 - into the stack
92:33 - okay so now we can go ahead and continue
92:35 - iterating and we get the value e we'll
92:37 - just add it to the answer and then wait
92:40 - a second we have reached the end of the
92:42 - iteration right
92:44 - after e we have reached the end of the
92:46 - iteration so what do we want to do if we
92:48 - want to empty out the contents of the
92:51 - stack and since there is only one single
92:54 - element let's just go ahead and add this
92:56 - at the end
92:57 - so now you can go ahead and compare both
92:58 - of them and realize that you know what
93:00 - we were actually a right all of this
93:02 - logic worked out for us
93:04 - so now we want to go ahead and formalize
93:07 - the logic and write it in terms of code
93:09 - and we're going to follow the exact same
93:11 - things that I taught you before
93:12 - first things first let's create a post
93:14 - fix array which will return at the end
93:16 - and now we'll also create a stack for
93:18 - The Operators the stack is only ever
93:20 - going to store The Operators
93:23 - and not the operands
93:25 - now we want to start iterating over
93:27 - every single element in the infix and
93:30 - we're going to call this element token
93:32 - because it can either be operator or an
93:34 - operand we don't know yet
93:36 - now we'll ask the question hey if the
93:38 - token is not an operator that is if it's
93:42 - a letter or if it's a number or digit
93:43 - something like that if the token is not
93:46 - in the operators then what do we do
93:49 - hit me is that the token is actually an
93:51 - operand and in that case we realize that
93:54 - we just have to directly append it to
93:56 - the postfix notation we don't ask any
93:58 - more questions and that is it for an
94:01 - operand
94:02 - now what happens if we have an operator
94:04 - though
94:05 - then obviously we want to append this
94:07 - item to the stack
94:08 - we want to push the token onto the stack
94:11 - remember stack follows the lowest to
94:13 - highest ordering which means that we
94:16 - have to write one or two lines of code
94:19 - more
94:20 - and this is very important and this is
94:22 - something we'll come to by the way in
94:23 - the next section as well
94:24 - okay so let me explain what's going on
94:26 - here
94:27 - I'm going to say while the stack exists
94:29 - that is while there are elements in the
94:31 - stack and the priority of the element on
94:33 - the top of the stack is greater than the
94:35 - priority of the current token that is
94:37 - we're looking at something like a minus
94:39 - as the current token and the top of the
94:41 - stack is a star
94:43 - which we had a case like that before if
94:46 - we have a case like that then this
94:47 - current token of lower priority is kick
94:50 - out is going to kick out the element
94:53 - from the top of the stack
94:55 - and it's going to kick that element from
94:56 - the top of the stack we'll do stack.pop
94:58 - and whatever the element was kicked out
95:00 - is going to be appended to the post fix
95:02 - one directly
95:04 - so we are going to say while that is
95:06 - true while the current priority of the
95:08 - token is lesser than equals to the
95:10 - priority of the element on the top of
95:12 - the stack then keep on doing this for
95:14 - prep operation because we are strict we
95:17 - want to have a lowest to highest
95:19 - ordering we can't even allow elements of
95:21 - the same priority to be there because
95:23 - even if the priority same we're still
95:25 - going to make a cake operation we're
95:26 - going to kick that element out from the
95:28 - top of the stack and append it to the
95:30 - post fix notation all right
95:32 - good so this should make sense now
95:34 - because we have to follow the lowest to
95:36 - the highest ordering
95:37 - okay what's the last step then are we
95:39 - done
95:41 - if you remember we had the case where
95:43 - there was one single element minus in
95:45 - the stack remaining at the end so we'll
95:47 - actually have to handle cases like that
95:48 - as well and we have to say you know what
95:50 - while the stack exists while there are a
95:52 - bunch of operators in the stack go ahead
95:54 - and pop that element of the stack and
95:56 - append it to the post six now obviously
95:58 - in this kind of case we will only ever
96:00 - have one single element like that
96:03 - okay anyways uh all of this was to
96:07 - convert this kind of input as we saw on
96:09 - the top from the infix notation to the
96:11 - postfix notation
96:13 - but now I ask you the question is it
96:16 - possible
96:17 - to somehow include in Brackets as well
96:19 - because look at the inputs we have never
96:22 - talked about brackets up till now we've
96:24 - only talked about operands and operators
96:27 - what if there are brackets
96:29 - all right let's go ahead and write some
96:31 - more code and since brackets are of
96:33 - higher priority since you know in bodmas
96:36 - you will be always take care of brackets
96:37 - first let's go ahead and handle the
96:39 - cases of brackets in the first two
96:41 - conditions so the first will first thing
96:43 - we'll see is that if the token is an
96:45 - opening bracket what do we do
96:48 - we will append this token on top of the
96:51 - stack we'll say you know what this is
96:53 - going to start of a new expression that
96:55 - we need to take care of earlier on so
96:57 - let's go ahead and append this token on
96:58 - the top of the stack
97:00 - okay now what
97:01 - well we want to say you know what if the
97:03 - token is a closing bracket then we need
97:05 - to do something more
97:08 - as soon as we get a closing round
97:09 - bracket what do we want to do
97:11 - we want to take care of all the elements
97:13 - present between this opening round
97:16 - bracket and the closing round bracket
97:18 - so what we are going to do is we're
97:20 - going to say you know what while the
97:22 - stack of top while the stack top is not
97:26 - an opening bracket go ahead and kick out
97:28 - all the elements one by one
97:30 - so what we are going to say is
97:31 - everything in between of these two
97:33 - brackets between this opening round
97:35 - bracket and the closing round brackets
97:37 - go ahead and pop those elements from the
97:39 - top of the stack and keep on appending
97:42 - them to the post fix notation
97:44 - one last thing that we have to do what
97:46 - is the one last thing the stack top is
97:48 - currently now having the opening round
97:51 - bracket
97:52 - as the Stacked out why is that because
97:54 - that is when the while loop exists
97:57 - because the stack top is going to have
97:58 - the opening round bracket which means
98:00 - that we have to take care of that once
98:02 - again
98:03 - we have to do a stack.pop operation
98:04 - saying that you know what we don't
98:06 - really care about brackets in the post
98:07 - fix notation
98:08 - because that was the whole point of post
98:10 - fixed notation to get rid of the
98:12 - brackets in the weird board Mass
98:13 - ordering
98:15 - now let me ask you this one question and
98:17 - this is a kind of a special trick case
98:19 - that we need to take care of remember
98:21 - the board Mass rule right and what I
98:24 - promised at the start was that we will
98:26 - be able to somehow implicitly encode the
98:29 - information of the infix notation in the
98:31 - postfix notation right and we were able
98:33 - to do that by handling the cases of
98:35 - brackets separately and division
98:37 - multiplication addition subtraction
98:39 - all right
98:40 - but now if I ask you let's go ahead and
98:42 - also formally Define the priority what
98:44 - is that going to look like
98:46 - because we use this priority over here
98:48 - in the while loop right
98:51 - now how do we Define the priority well
98:53 - the priority will be a little bit
98:55 - different
98:56 - so obviously the order has the highest
98:58 - priority then division multiplication
99:00 - and then addition subtraction but the
99:02 - bracket the opening bracket will have
99:05 - the lowest priority
99:07 - why is that you ask
99:10 - it has a very interesting reason behind
99:12 - it all right let's say that we have a
99:14 - bunch of elements in the stack let's say
99:16 - there's a opening bracket and now let's
99:18 - say that the operator is simply a star
99:21 - so we have an opening bracket and a star
99:23 - after it
99:24 - now let's say that the minus comes right
99:27 - so what is minus going to do minus is a
99:29 - lower priority element so it is going to
99:31 - kick out the star out of the stack
99:33 - but at the same time we want to ensure
99:35 - that this minus does not kick out the
99:39 - opening round bracket
99:41 - because it's not minus his job to handle
99:44 - that it's the job of the closing bracket
99:46 - to handle that in its own while
99:48 - condition
99:49 - so we are going to have opening bracket
99:52 - having the lowest priority so that the
99:55 - minus or any other sign in fact is never
99:58 - able to kick it out of the stack all
100:00 - right so in this video we learned how to
100:02 - convert the infix notation to the
100:04 - postfix notation now I promise you in
100:06 - the next one we're going to look at how
100:07 - do we evaluate the post fix notation and
100:10 - that is going to be a so so much simpler
100:12 - than this code hello everyone and
100:15 - welcome back let's talk about how to
100:17 - evaluate the post fix notation in the
100:20 - previous video we looked at how do we
100:21 - convert the infix notation to the post
100:23 - fixed notation and I promised early on
100:25 - that the post switch notation is going
100:27 - to be a very easily computable way to
100:30 - get the answer for any calculator
100:32 - related question
100:33 - what we're going to do is very simple
100:35 - I'm going to create a stack and now
100:37 - we'll see that we're going to start
100:39 - iterating from the left to the right
100:41 - now for elements like 0 which we'll get
100:44 - as operands we are going to push them
100:46 - onto the stack without asking any
100:48 - questions as soon as we get another
100:50 - operand let's say in the case of one we
100:52 - are also going to the push it to the top
100:55 - of the stack
100:56 - but things get a bit more interesting
100:58 - when we get an operator because now what
101:01 - does this operator mean what is this
101:03 - entire 0 1 minus thing mean
101:05 - this means that we have to do 0 minus 1.
101:08 - in other words we have to pop one out of
101:11 - the stack we have to also pop out Zero
101:13 - from the stack take their negation that
101:16 - is do 0 minus 1 because we have gotten a
101:18 - current value as the negative minus sign
101:20 - so we have to do 0 minus 1 and then put
101:23 - it back into the stack
101:25 - right so what did we do you get an
101:28 - operand you add it to the stack no
101:31 - asking questions Twice But as soon as
101:33 - you get an operator go ahead and remove
101:36 - two values from the top of the stack do
101:39 - the evaluation and then add them back in
101:41 - okay let me continue and show you what
101:44 - this means
101:45 - so we get three this is an operand we'll
101:48 - add it to the stack we get another three
101:50 - operand add to the stack
101:52 - what do we do when we get a star as soon
101:55 - as we get a star we'll pop one value out
101:57 - we'll pop another value out multiply
102:00 - both of them since this is a star
102:01 - operation find the value and push this
102:04 - answer back onto the stack
102:06 - okay again what do we do when we get a 7
102:09 - add this one to the stack now what do we
102:12 - do when we get a slash
102:14 - what will the be the next step
102:17 - since we have a slash we're going to pop
102:18 - out the last two elements seven and nine
102:21 - we're going to take the division nine by
102:24 - seven and this is the C style division
102:25 - so we'll get the answer as one
102:27 - so we'll get the answer as 1 and we'll
102:29 - push this back onto the stack
102:32 - and then finally we have the plus
102:34 - operation where we'll pull out one we're
102:37 - also pop out minus one add them together
102:40 - get the answer 0 and then push it back
102:43 - onto the stack
102:45 - at the end of this iteration one thing
102:47 - is guaranteed there will be only one
102:50 - single element inside of the stack and
102:53 - that will be the answer
102:54 - okay so what are the rules formally
102:57 - speaking we do two things first if you
103:00 - have an operand you add it to the stack
103:02 - else you pop the last two elements
103:05 - evaluate them and then add them add
103:08 - their result onto the stack again all
103:11 - right so let's go ahead and look at the
103:12 - code implementation of the same problem
103:14 - this is the problem evaluate reverse
103:17 - polish notation which is the same as the
103:19 - post fix notation on lead code all right
103:22 - what are we going to do first things
103:24 - first initialize a stack right the stack
103:26 - is going to be an empty list
103:28 - I'm also going to Define these Ops which
103:30 - is basically going to Define for this
103:33 - character for this current operator
103:35 - represented as a string as a character I
103:38 - want to do this operation I'm going to
103:40 - do operator dot add for minus I'm going
103:43 - to do the subtraction for the
103:45 - multiplication I'm going to do 1 and
103:47 - then for the division I am not
103:50 - going to do floor Dem
103:52 - right these are the two options because
103:54 - we have one as true div which is just a
103:56 - slash and the floative which is actually
103:59 - double slash so it might look tempting
104:01 - for you to do double slash in when it
104:03 - comes to python code although in other
104:05 - languages you can just do slash and get
104:07 - away with it in Python do not do double
104:10 - slash because that is floor div that
104:12 - does not work as intended as you want
104:15 - and it's going to give you issues when
104:17 - it comes to negative values uh I won't
104:19 - go into much more detail in that you can
104:21 - go check out some of the links down
104:23 - below anyways what we're going to do
104:25 - next is we're going to iterate over
104:26 - these token given in the input tokens
104:29 - so what was the goal we have to first
104:31 - figure out if it's operand or not
104:34 - now we'll say if the token is not in the
104:36 - operators that is if the token is not of
104:39 - plus minus multiplication or division
104:41 - symbols that means it's a integer value
104:44 - given to us so what we're going to do is
104:46 - we're going to convert that token to an
104:48 - end value and append it to the stack all
104:51 - right
104:52 - cool so now what we're going to do in
104:54 - the else condition the else conditions
104:56 - when we have these kind of operators
104:58 - with us
104:59 - so what we want to do is pop out two
105:01 - elements from the top of the stack do
105:03 - the computation and then append the
105:06 - result back into the stack
105:08 - now just a quick run through of what's
105:09 - Happening note that the ordering of
105:11 - these matters a lot we are first going
105:13 - to pop out N2 and then N1
105:17 - again uh look at all of the simulation
105:19 - actually Vijaya I didn't explain it back
105:22 - them but is something very important
105:24 - look at what we have done
105:27 - right so as soon as we get the plus
105:30 - operation what do we do we first pop out
105:32 - this element from the top of the stack
105:34 - which is going to take the second place
105:36 - and then we're going to pop out this
105:38 - element which is going to take the first
105:40 - place so this one we currently popped
105:42 - out this guy is the N1 and the element
105:45 - on the right hand side is the N2 right
105:48 - this makes more sense for division as
105:50 - well as subtraction because they are not
105:52 - exactly commutative all right anyways
105:54 - first will pop out N2 and then will pop
105:57 - out N1 whatever the result is we are
106:00 - going to get it by using this Ops of
106:03 - token that is whatever this token is say
106:06 - it's a plus sign so we'll go ahead into
106:08 - this dictionary and access this operator
106:10 - dot add function and this is going to
106:12 - take into values again N1 and N2
106:15 - whatever the result is we're going to
106:17 - append it to the stack
106:19 - now one last thing that we realized one
106:21 - last thing that we realized was that the
106:23 - stack is going to have only one single
106:26 - element at the end of this iteration
106:27 - which is going to be the answer so we
106:30 - return it at the end and uh now let's go
106:32 - ahead and test the code out
106:34 - so we'll run the code once okay looks
106:36 - good and we'll go ahead and submit this
106:39 - all right cool so this works out and uh
106:42 - yeah this is sort of a formal
106:43 - implementation of evaluating reverse
106:46 - polish notation by the way if this seems
106:48 - too fancy you can write some manual code
106:50 - here as well you can just say LF token
106:53 - is a plus sign just go ahead and do this
106:56 - this this
106:57 - and result will be nothing but
107:01 - N1 plus into and something like this and
107:03 - so you can do LF for all of these sort
107:06 - of cases right if that seems too fancy
107:09 - you can do it this way as well
107:11 - all right cool so this is it and I'll
107:14 - see you in the next one hello everyone
107:17 - and welcome in this video we're going to
107:19 - implement basic calculator one two and
107:22 - three all using the same exact code
107:24 - believe me I'm going to do a copy paste
107:27 - like nothing you've seen before all
107:29 - right so the first thing we want to do
107:30 - with basic calculator is realize that we
107:33 - have already written most of the code in
107:35 - these two functions post function is
107:37 - going to convert the infix notation to
107:39 - the post fixed notation and the second
107:41 - one is going to evaluate the post fix
107:43 - notation again both of these functions
107:46 - have been covered in separate videos of
107:48 - their own which each of their own
107:49 - intuitions observations and formal code
107:52 - that we wrote down
107:54 - in this question however we have to
107:55 - write one more function which is going
107:57 - to do the parsing or the cleaning up
107:59 - thing so we're going to do and create a
108:02 - read function which is going to take in
108:03 - the string and return us the infix
108:06 - notation all right that is the goal of
108:09 - this problem
108:10 - okay why do we do this by the way
108:13 - look at this the input we are given is a
108:15 - string and so we can have a case like 3
108:18 - plus a bunch of spaces one space times
108:22 - 337
108:24 - okay so nothing too special but you can
108:26 - see that this is a hard string to work
108:29 - with mostly because won't it be so nice
108:32 - if you can actually have a list of
108:34 - tokens that we need to focus on that is
108:36 - if you have something like say uh
108:39 - something that gave us three then
108:41 - something that gave us Plus
108:43 - then punch Then star then 337. won't it
108:48 - be nice if we have a infix notation laid
108:50 - out like this right this will make
108:53 - things a lot simpler because we don't
108:54 - have nasty spaces to deal with and all
108:56 - of the numbers have been dealt with that
108:58 - is 337 actually is considered as 337 and
109:03 - not three three and seven right these
109:06 - are some of the cases that we have to
109:07 - handle and so what we are going to do is
109:10 - convert and read the string into the
109:12 - infix notation so the infix notation is
109:16 - going to be a list which will return at
109:17 - the end
109:18 - how do we go about making this happen
109:21 - well we'll go ahead and write a by Loop
109:23 - so we'll say I equals to 0 and while
109:26 - I is lesser than the length of s go
109:30 - ahead and keep on doing some computation
109:32 - the first thing we'll do is clear out
109:34 - all the spaces so if the SFI the current
109:36 - character I'm looking at if it's a space
109:38 - well just go ahead and ignore this I
109:41 - don't really want to mess with this
109:43 - what do we do
109:45 - well in the case of space we simply
109:47 - ignore but in the case of operators we
109:49 - can't really do that because we have to
109:51 - add these individual operators to the
109:53 - infix notation list
109:55 - so what I'm going to say is if if s of I
109:58 - is present inside of the operators by
110:02 - the way these operators is the variable
110:04 - over here which is simply just the
110:07 - brackets and the multiplication division
110:08 - signs blah blah if the current character
110:11 - I'm looking at is an operator well then
110:14 - go ahead and add this to the infix list
110:17 - so I'll do infix dot append the current
110:19 - s of I I'll also do I plus equals to 1.
110:23 - all right what's the else condition vl's
110:26 - condition is some case where we have a
110:28 - digit like 2 or 234 or 345 things like
110:33 - that so we have to handle cases like
110:35 - these separately right what I'm going to
110:37 - do is I'm going to create a number
110:39 - variable which is going to be an empty
110:41 - string and I'm going to say you know
110:42 - what while
110:44 - the SFI dot digit is digit actually so
110:50 - while the SFI I'm looking at is a digit
110:53 - well then go ahead and append this to
110:55 - the number so I'll do number plus equals
110:57 - to the S of I
110:59 - and once I'm done with this oh by the
111:02 - way I'll also do I plus equals to 1
111:03 - always and once I'm done with this
111:05 - iteration when the saturation stops when
111:08 - I get either a space or an operator I'm
111:10 - going to say you know what go ahead and
111:11 - stop at this point of time and please go
111:14 - ahead and do infix dot document p number
111:18 - one thing that we always check whenever
111:20 - we write these by Loops is whether s of
111:22 - I will actually exist or not there might
111:24 - be a case where this I plus 1 might take
111:27 - it out of the length of the string so
111:28 - we'll also have to say
111:30 - keep it limited to that while I is less
111:32 - than length of s and this happens then
111:35 - do these computations
111:37 - okay so we are almost done but there's
111:39 - one more thing that we have to keep in
111:40 - mind and this is sort of a well kind of
111:43 - a pain implementation that we have to
111:45 - take care of
111:46 - because here's the thing the minus could
111:48 - be used as an unary operation that is in
111:51 - the case of -1 and sort of minus of 2
111:54 - plus 3 all of these cases like all of
111:57 - these cases are valid
111:59 - but in one of the codes we have seen
112:01 - previously we did not handle these unre
112:03 - operations so what is a hacky way around
112:06 - this okay this is going to be a very
112:08 - happy way but what we can do is we can
112:10 - add a 0 in front of it so as soon as we
112:13 - get an honorary minus we're going to do
112:16 - 0 minus that thing so in the case of
112:19 - minus 1 we'll instead write it as 0
112:21 - minus 1 and instead of minus of 2 plus 3
112:23 - we are going to write it as 0 minus 2
112:26 - plus 3. this is going to make the rest
112:28 - of the implementation consistent with
112:30 - the logic
112:31 - so we'll have to say you know what uh
112:33 - before you do this please go ahead and
112:34 - check if the SFI is actually a
112:37 - minus sign or not because if it's a
112:39 - minus sign then we need to do some extra
112:41 - steps before we can jump into solution
112:44 - all right when is a character when is
112:47 - this minus sign and unre operated
112:51 - this is a ninery operator in a bunch of
112:53 - cases we have to say first of all if
112:58 - I equals 2 equals to 0 then go ahead and
113:01 - do infix dot append 0.
113:04 - that is if this minus sign is the first
113:07 - thing you ever get in the entire string
113:09 - if it is the first position in the
113:12 - string then you have to append a 0
113:14 - before you append this current operator
113:17 - all right but this is not the only case
113:20 - all right so we can have another case
113:21 - where we say uh say 5 minus of minus 2.
113:27 - all right so this is a case where the
113:29 - preceding element with the element to
113:31 - the previous of this minus is actually
113:33 - an opening bracket so we'll also have to
113:35 - take care of this condition and say that
113:37 - you know what if the current minus the
113:40 - zerothal element is the zeroth place
113:42 - where an append 0 to the infix before
113:45 - you append the minus or we have to say
113:48 - or
113:49 - if the S of I minus 1 If the previous
113:52 - element If the previous character
113:54 - was an opening bracket
113:57 - then what
113:59 - then you have to take care
114:01 - to also append the zero by the way just
114:04 - to make sure that this I minus 1
114:06 - actually exists we have to write one
114:07 - more condition and say that this I minus
114:10 - 1
114:11 - this I minus 1 should be greater than
114:13 - equals to 0. right so pretty simple
114:17 - and uh yeah I think we're done now let's
114:19 - go ahead and run the code once oh by the
114:21 - way we still have to write all these
114:22 - functions now so the first thing we'll
114:25 - do is go ahead and read
114:27 - the S string given as the input and this
114:29 - will get me the infinix notation
114:31 - for the infix notation I'm going to
114:32 - convert it to the post fix notation so
114:35 - post fix
114:37 - equals to in fixed to postfix
114:42 - of impacts
114:43 - and finally I'm going to return
114:46 - evaluate postwix
114:51 - all right cool let's go ahead and test
114:52 - this out hopefully it works
114:54 - ah God damn it okay it's a typo line 20.
115:00 - is digit
115:02 - okay cool fixed again hoping that we
115:06 - don't have any issues
115:07 - let's just hope that we don't have any
115:10 - more issues it's going to be a pain
115:11 - otherwise all right I'm gonna go ahead
115:13 - and submit this let's hope and great we
115:15 - got it accepted cool so now as I
115:18 - promised before we're going to do a
115:19 - massive copy pasting thing I'm gonna
115:21 - control C go here and uh
115:25 - paste this baby over here let's go run
115:28 - the code once again get it accepted here
115:31 - all right cool looks good and once
115:34 - finally in the basic calculator 3 is
115:36 - going to do the submit directly YOLO all
115:39 - right cool so we get this code accepted
115:41 - in all the three questions just by using
115:43 - these simple Logics what did we do we
115:46 - first read the input string and we sort
115:49 - of cleaned it up and converted the
115:51 - string to a list of tokens then we went
115:54 - ahead and evaluated and converted the
115:56 - infix to the post fix notation and
115:58 - finally we evaluated the postrix
116:00 - notation
116:01 - all right cool uh this is it for this
116:03 - video and this ends the string related
116:06 - section of Stack questions next up we're
116:09 - going to look at monotonic Stacks which
116:10 - is more of a mathematical side of stacks
116:12 - all right