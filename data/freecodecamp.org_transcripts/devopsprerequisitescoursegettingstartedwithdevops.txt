00:00 - hello and welcome to the devops
00:02 - prerequisite course
00:03 - the one course that you must go through
00:06 - before starting your devops or cloud
00:09 - journey my name is mumshad manambat and
00:12 - i will be your instructor for this
00:13 - course
00:15 - students who are absolute beginners and
00:17 - are totally new to it or the cloud and
00:20 - devops world require some additional
00:23 - help in starting their journey
00:26 - for example they often run into issues
00:28 - with setting up a basic lab environment
00:31 - using virtualbox or issues with
00:33 - configuring the right kind of networking
00:35 - in virtualbox or trouble with working
00:37 - with the linux cli or text editors like
00:40 - vi editor
00:41 - and sometimes it's trouble with getting
00:43 - a web server to communicate with a
00:44 - database server
00:46 - or at other times it's working with data
00:48 - formats like json or ammo
00:51 - so we have identified a gap and we
00:53 - believe that this is because they are
00:55 - missing some of the basic prerequisites
00:58 - as a devops or cloud engineer it is
01:01 - important to have these basics cleared
01:04 - and that's why we built this course to
01:07 - bridge that gap
01:09 - this course helps you get your basics
01:11 - right so the rest of the journey is
01:13 - smooth
01:15 - now you might be wondering whether you
01:17 - have the background or the experience to
01:19 - get started and i want to assure you
01:21 - that this course is really for anyone
01:24 - who wants to start their devops or cloud
01:26 - journey even if you're from a non-iit
01:28 - background or you don't have a computer
01:30 - science degree or if you're a college
01:32 - student who has no work experience and
01:35 - wants to start your devops or cloud
01:37 - journey
01:38 - this course is also for those who happen
01:41 - to have some experience such as
01:42 - developers who wants to learn a little
01:44 - bit
01:45 - about operations in order to move to a
01:47 - devops role
01:48 - so no coding or programming knowledge
01:50 - required
01:52 - so how does it work with visual learning
01:55 - we simplify complex concepts using
01:57 - illustrations and animations and we have
02:00 - demos where we show you how to put these
02:02 - into practice
02:04 - we have hands-on labs that open up right
02:07 - in your browser where we have
02:08 - pre-configured environments for you to
02:10 - practice with our labs are fun and
02:13 - interactive and hassle free you don't
02:15 - need to do anything to get them to work
02:17 - they just work right in your browser
02:20 - you'll learn by exploring real
02:22 - environments and solving puzzles and
02:24 - you'll troubleshoot and fix broken
02:26 - environments
02:27 - and we will always verify your work and
02:29 - will give you feedback on what went
02:31 - wrong
02:32 - at any time you feel stuck we have a
02:34 - community where you can get help
02:37 - so let's get started and i will see you
02:40 - in the next video
02:42 - so let's take a closer look at the
02:43 - objectives of this course
02:46 - remember that this is a devops and cloud
02:49 - prerequisites course so this is the
02:51 - course that comes before you start an
02:54 - actual devops course and since we cover
02:56 - a lot of concepts we will cover just
02:59 - enough of each topic so you have a fair
03:01 - idea about that topic as well as get
03:03 - some hands-on experience
03:05 - in the first section we start with the
03:07 - basics of linux where you go through and
03:09 - understand basic commands in the linux
03:11 - cli you learn how to work with the vi
03:13 - editor as it's important to be
03:15 - comfortable with at least one text
03:17 - editor in linux
03:18 - you'll use this when you work with files
03:20 - in linux such as configuration files we
03:23 - then look at how to install software and
03:25 - dependencies in linux and then we will
03:27 - see what are services and how to
03:29 - configure them
03:30 - at times you may want to set up your own
03:33 - personal lab environment an environment
03:36 - where your changes are saved and an
03:38 - environment where you can develop your
03:40 - own custom solutions
03:42 - and this section will help you create
03:44 - your own lab as well as troubleshoot and
03:46 - maintain it which is something that most
03:48 - students struggle with especially the
03:50 - networking part in virtualbox and we
03:53 - have some neat lectures and demos that
03:55 - explain those
03:57 - another area that students usually
03:58 - struggle is with networking in linux how
04:02 - are interfaces and ip addresses
04:03 - configured why can't i get a vm to reach
04:06 - the internet or multiple vms to ping
04:09 - each other how do i configure routing
04:11 - what is dns and how do i configure the
04:13 - right dns settings and how do i
04:15 - troubleshoot dns related issues
04:18 - and we cover these along with labs in
04:20 - this section
04:22 - we also look at some of the commonly
04:23 - used data structure languages like json
04:25 - and yaml
04:26 - automation tools like ansible use yaml
04:29 - to develop playbooks and docker and
04:31 - kubernetes use it for building
04:33 - definition files so we have a lot of fun
04:36 - challenges that will help you practice
04:38 - this
04:39 - well let's get started when you're ready
04:43 - in this section we'll go through some of
04:45 - the basics of linux command line
04:47 - if you're already a linux maestro then
04:50 - feel free to skip this section or simply
04:53 - go through the labs and try to complete
04:55 - the challenges and make sure you're
04:57 - comfortable with all of them
05:00 - while designing this course we used
05:02 - stack overflows insights along with the
05:05 - data from surveys we conducted from our
05:07 - student base
05:08 - and which you might have seen in our
05:10 - other courses to identify the most
05:13 - commonly used and most demanding
05:15 - technologies that we will cover in this
05:17 - course that way we can make this course
05:20 - relevant to most of you
05:22 - so you'll see me referring to these
05:25 - often and i hope learning the most loved
05:27 - and wanted technologies will motivate
05:30 - you
05:31 - as per stack overflows insights the most
05:33 - common and the most loved platform used
05:36 - for development work happens to be linux
05:40 - if you're from a windows background i'd
05:42 - highly recommend learning some linux
05:44 - basics as most devops tools have a
05:47 - requirement for linux
05:50 - as part of this course we cover basics
05:52 - of linux os such as how to work with the
05:55 - command line interface how to work with
05:57 - text editors like vi editor we discuss
06:00 - package management and services etc
06:03 - there are different flavors of linux
06:05 - such as ubuntu red hat enterprise linux
06:08 - santos etc we conducted a survey of our
06:12 - students and a good percentage of them
06:15 - requested their preferred os to be
06:17 - centos followed by ubuntu and red hat
06:21 - enterprise linux
06:23 - centos is a free community edition of
06:26 - red hat enterprise linux so learning
06:28 - centos also helps you cover the basics
06:31 - of rhel
06:32 - learning centos will also help you
06:35 - prepare for linux certifications like
06:37 - linux essentials or linux foundation's
06:39 - certified systems administrator
06:41 - certification
06:42 - now since you also cover
06:45 - basics of red hat enterprise linux it
06:47 - also helps you prepare for any red hat
06:50 - exams
06:51 - and that's why we decided that centos is
06:53 - going to be the os of our choice for
06:56 - this course
06:59 - so let us begin our linux crash course
07:02 - in this section you're going to work
07:04 - with linux systems in our lab this is so
07:07 - you get very familiar with the linux cli
07:10 - and some basic commands before you
07:12 - actually deploy a linux system by
07:14 - yourself
07:15 - the next section is about deploying a
07:18 - linux system on your linux laptop using
07:21 - tools like virtualbox
07:23 - when you do that the cli and commands
07:25 - you learn in this section will be handy
07:28 - so i recommend not deploying your own
07:30 - linux system for now instead just rely
07:33 - on our labs and get some good hands-on
07:36 - practice and then in the next section
07:38 - deploy your own vms so we will start
07:42 - assuming a linux system has already been
07:44 - provisioned
07:45 - let's start with shell
07:48 - linux systems have both cli and gui
07:51 - interfaces
07:52 - when you work with linux especially in
07:54 - it you work with the cli and you must
07:57 - get really comfortable with it because
08:00 - most servers that you work with in your
08:02 - work environment
08:04 - won't really have a graphical user
08:06 - interface so we will just focus on the
08:08 - command line
08:10 - the text based command line interface
08:12 - that helps you run commands to interact
08:15 - with the operating system is called the
08:17 - linux shell
08:19 - if you have ever worked on a linux
08:20 - system before you might have noticed
08:23 - that sometimes the cli interface behaves
08:25 - differently as in sometimes you press
08:27 - the backspace button to delete a command
08:29 - and it doesn't work or when you press
08:32 - the tab button to autocomplete it
08:33 - doesn't auto-complete and that's because
08:36 - there are different kinds of shells such
08:38 - as the bourne shell the sea shell
08:41 - z shell born again shell which is known
08:44 - as bash
08:45 - and each of these shells behave
08:47 - differently the older shell which is the
08:50 - born shell or simply known as shell had
08:52 - limitations in the way we interact with
08:54 - it the newer bash shell supports many
08:57 - advanced features such as arithmetic
09:00 - operations conditionals arrays etc
09:03 - you can see which shell you are on
09:06 - by printing the environment variable
09:08 - named shell using the echo dollar shell
09:11 - command
09:12 - the echo command helps you print on the
09:14 - screen and the dollar symbol helps you
09:17 - specify an environment variable
09:20 - let's now get introduced to some basic
09:22 - linux commands we will first look at the
09:25 - commands and you will then work on labs
09:27 - where you will use these commands
09:30 - echo as we just discussed is the command
09:32 - used to print a line of text
09:34 - the word you enter after the echo
09:36 - command will be printed on your screen
09:38 - as simple as that
09:40 - the echo command is usually used when
09:42 - you want to print out an environment
09:43 - variable as we just saw
09:46 - we will discuss about environment
09:47 - variables later
09:49 - the echo command is also used in scripts
09:51 - where you want to print out information
09:53 - onto screen
09:55 - the ls command is used to list all the
09:57 - contents of a directory here we see that
10:00 - we have two files file.txt and
10:02 - file2.conf and a directory named
10:05 - my underscore dir1
10:08 - the cd command stands for change
10:10 - directory and it is used to navigate to
10:13 - new directories in the system
10:15 - for example to get into the my
10:17 - underscore dar-1 directory run the
10:20 - command cd followed by the directory
10:23 - name
10:24 - the pwd command or the present working
10:28 - directory command is used to print the
10:30 - directory you are currently in
10:33 - the mkdir or the make directory command
10:37 - is used to create a new directory
10:39 - in this example we have created a new
10:42 - directory called new underscore
10:43 - directory
10:45 - to run multiple commands one after the
10:47 - other separate them by a semicolon in
10:50 - this case
10:51 - it first changes into the new directory
10:54 - then makes a directory by the name www
10:57 - and then prints the current working
10:59 - directory now even though it's a single
11:01 - execution remember there are three
11:04 - separate commands and executed one after
11:07 - the other
11:09 - at times you might want to create a
11:11 - directory tree for example we want to
11:14 - create a directory slash tmp slash asia
11:18 - india
11:19 - bangalore
11:21 - one way to do that is to run the make
11:24 - directory command three times specifying
11:27 - one directory each time for example
11:29 - first we create the first directory and
11:31 - then we create
11:33 - the india directory in inside asia and
11:36 - then we create the bank load directory
11:38 - inside india
11:40 - a better way to do that would be to run
11:43 - a single command using the
11:46 - p option like this
11:48 - this way it creates the entire directory
11:50 - tree in one shot and does not complain
11:52 - if a particular directory is not
11:54 - available to remove a directory and all
11:57 - of its contents run the rm minus r
12:00 - command and specify the directory name
12:04 - to copy one directory to another
12:05 - location use the cp command but with the
12:08 - dash r option this copies the directory
12:11 - and all of its contents from one
12:13 - location to another
12:15 - let's see some commands to work with
12:17 - files
12:18 - to create a new file run the touch
12:20 - command and provide the file name this
12:22 - creates a new file but with no contents
12:26 - to add some contents to the file use the
12:28 - cad command and the redirection symbol
12:31 - which looks like a forward arrow
12:33 - followed by the file name
12:34 - once this command is issued the prompt
12:37 - will wait for your user input you would
12:40 - be able to add lines of text
12:42 - hit the return key to type in
12:45 - into a new line of text and press the
12:47 - ctrl d combination to exit out of this
12:50 - prompt and save the data to the file
12:53 - to view the contents of a file run the
12:55 - cat command followed by the file name
12:57 - this time without the redirection symbol
13:02 - these are some basic commands to work
13:04 - with files in the cli
13:07 - for editing contents of a file you may
13:09 - need a text editor like vi or vim we
13:12 - also take a look at the basics of vi
13:14 - editor later in this course
13:16 - now while working with devops tools
13:18 - you'll often come across situations
13:20 - where you will have to modify
13:21 - configuration files on linux
13:23 - and these editors will come handy then
13:26 - but to get through this lecture and the
13:28 - the following labs you don't really need
13:30 - a text editor so let's continue to copy
13:33 - a file use the cp command and specify
13:37 - the source file path and name and the
13:40 - target
13:41 - path and name
13:42 - to move a file which is similar to
13:45 - cutting and pasting a file to a
13:48 - different location use the mv command
13:50 - specify the old name and the new path
13:53 - and the file name
13:54 - if the file is moved to the same path
13:57 - but with a different name
13:59 - then it's essentially
14:01 - like renaming the file and that is how
14:04 - you rename a file in linux
14:06 - there's no separate command for that
14:09 - run the rm command to remove
14:12 - or delete a file
14:14 - so that's about it for this section head
14:16 - over to the labs and practice working
14:18 - with these basic linux commands
14:22 - let me quickly introduce you to the
14:24 - hands-on labs in this course
14:26 - the lab interface is divided into two
14:28 - sections here you have a terminal which
14:30 - is a live terminal to a linux host and
14:33 - here you have a quiz portal
14:36 - it takes a few minutes for the labs to
14:38 - load so just give it some time if you
14:40 - need more space for your lab click on
14:43 - this button here to hide the curriculum
14:46 - window that way you can get a more space
14:49 - for your lab
14:50 - so we'll just wait for it to load
14:53 - okay so the lab is loaded and i'm on the
14:56 - linux terminal here and this is my quiz
14:59 - portal in the quiz portal i have various
15:01 - tasks that i am expected to complete
15:04 - the tasks are of two kinds first we have
15:07 - exploratory questions which are these
15:09 - where we ask you to explore the
15:11 - environment and
15:13 - select the right answers from these
15:15 - options
15:16 - let me walk you through a few of these
15:18 - questions in this case this is a
15:19 - multiple choice question so here you
15:22 - have a question
15:23 - and here you have some options so you're
15:25 - supposed to select the right option
15:27 - in case you are not sure how to
15:30 - find the answer to that question we have
15:33 - some hints so clicking on this will tell
15:35 - you exactly what you need to do
15:37 - it'll give you the command that you need
15:39 - to run or a hint to find the right
15:42 - solution
15:43 - we also have a timer so these labs are
15:46 - available for an hour each time so you
15:48 - can access these labs as many times as
15:50 - you want but each time there's a time
15:53 - limit exits in an hour and this lab
15:55 - session also has a number of questions
15:58 - and you can see the question numbers
16:00 - here currently we are on the first
16:02 - question and this lab has a total of 10
16:05 - questions you can also skip through
16:07 - questions in case you go through five
16:09 - questions and then for some reason you
16:11 - have to stop or for some reason the lab
16:13 - terminates in that case you can restart
16:16 - the lab and then you can skip through
16:18 - the questions so let's start with let me
16:20 - show you a few
16:22 - examples in this case we have the
16:24 - question is how many directories and
16:26 - files are present in the home
16:28 - thor test directory
16:30 - so we go to
16:33 - that particular directory here
16:42 - okay and then we list the contents and
16:45 - we see that there are three directories
16:47 - and then three files okay so the correct
16:50 - answer is three directories and three
16:51 - files
16:52 - and that's correct
16:54 - next the question is which text file is
16:56 - not present under the home thor
16:59 - directory so we know that there is files
17:01 - one two and four so 3 is not
17:04 - is the correct answer but let's say
17:06 - you pick the wrong answer and then it's
17:09 - going to tell you that it's wrong so you
17:10 - must select the correct answer
17:13 - and the next question is to create
17:16 - it's now this is a task
17:18 - so this is the second type of question
17:20 - which is not a multiple choice question
17:21 - so here you have to
17:23 - perform the task that you're asked to do
17:25 - and if you don't do it and it's going to
17:27 - check your work and it's going to tell
17:29 - you that the task is not completed so in
17:31 - this case
17:32 - we have to create a
17:34 - file
17:36 - under the
17:37 - home thor directory
17:38 - [Music]
17:40 - so
17:41 - we use the
17:42 - touch command and we create the file you
17:45 - can always refer to the
17:47 - the course material the pdf to get the
17:50 - correct answer
17:52 - or you can refer to the hint so here i
17:54 - create an empty file using the touch
17:56 - command
17:57 - when i check it's successful okay so
17:59 - these are very basic labs and as and
18:01 - when you go through the course the
18:03 - difficulty uh will increase and you'll
18:06 - have more and more complex tasks and
18:07 - challenges to complete now for some
18:09 - reason uh if you'd like to open a new
18:12 - terminal here there are some options so
18:14 - if you click on the plus button and
18:15 - click on open new terminal then you can
18:17 - get a new terminal window so here i have
18:20 - the old terminal and here i have the new
18:21 - one and if you uh
18:23 - at some point in time we will be hosting
18:26 - web servers and if you'd like to access
18:30 - the url of the server then you'll have
18:32 - to click these links and that way it'll
18:34 - open up a new
18:36 - browser and it will forward your request
18:39 - to
18:40 - the host
18:41 - what you're accessing is a terminal to a
18:43 - remote server
18:45 - um i hope you enjoy your learning
18:49 - let us now look at some more linux
18:51 - commands that will help you get through
18:53 - this course
18:55 - we will start with user accounts
18:58 - to know which user you are run the who
19:01 - am i command
19:02 - in this case it says you are user
19:05 - matthew
19:06 - the id command gives you more
19:08 - information about the user such as the
19:10 - user's id which happens to be
19:12 - 1001 and the group id and the groups
19:15 - that the user is part of
19:17 - to switch from one user to another you
19:19 - may use the su command su stands for
19:23 - switch user to switch to user say aperna
19:26 - run the su command followed by the
19:28 - user's name
19:30 - you will then be prompted for the user's
19:32 - password
19:34 - if you're accessing one system from
19:36 - another system using say ssh and you
19:39 - want to log into the other system using
19:41 - a different user than your current user
19:44 - specify the username before the host
19:46 - name followed by an ad symbol
19:52 - when it comes to performing tasks not
19:55 - all users can do all tasks in linux
19:58 - matthew is a regular user and so his
20:01 - access on the system is restricted
20:04 - every linux system has a super user
20:06 - known as the root user the root user has
20:09 - no restrictions on the system and can
20:11 - perform any task which is why in most
20:14 - production environments or enterprise
20:16 - environments access to the root user is
20:19 - restricted and you will almost never log
20:22 - into the systems as a root user
20:25 - now as a normal user what if you wish to
20:27 - perform actions that can only be
20:29 - performed by a root user such as
20:31 - installing and configuring software and
20:33 - services on the system or viewing
20:35 - certain paths such as
20:37 - the root directory
20:39 - a root user can make that possible for a
20:42 - regular user by granting them sudo
20:45 - privileges
20:46 - by making an entry into the etsy sudoers
20:50 - file
20:51 - so the user is still a regular user but
20:55 - with root privileges
20:57 - when a regular user is granted sudo
21:00 - privilege they can now elevate their
21:03 - permission level and perform tasks that
21:05 - they otherwise couldn't by simply
21:08 - prefixing a command with the keyword
21:11 - sudo
21:12 - they'll be asked for their password and
21:14 - on entering the password the command is
21:16 - executed
21:19 - when you look through the labs in the
21:21 - rest of this course you'll work in an
21:23 - environment where you will not have root
21:26 - access instead you will be a regular
21:28 - user with sudo privileges so while
21:31 - making changes to the system you must
21:33 - remember to use the sudo prefix if not
21:36 - you will get permission denied errors so
21:39 - whenever you hit permission denied
21:41 - errors remember that it could be because
21:43 - you haven't used the sudo prefix
21:47 - we will be discussing about a lot of
21:49 - commands through the rest of this course
21:51 - and for the sake of brevity we won't be
21:54 - specifying the sudo prefix each time on
21:57 - all our slides
21:58 - so it is assumed that you will use this
22:00 - prefix while working in the labs
22:04 - let us now look at some commands that
22:06 - will help us download files from the
22:07 - internet
22:08 - at times you will have to download files
22:10 - from the internet such as rpm packages
22:13 - or binary files
22:14 - or images and you can use use the call
22:17 - command and provide the url of the file
22:20 - to download the file
22:22 - add the dash capital o option to save
22:24 - the result to a file otherwise it'll
22:26 - just print
22:28 - the file on screen
22:30 - another tool that can be used to
22:31 - download files is the wget command
22:35 - again specify the full url and with the
22:39 - dash capital o options specify the name
22:42 - of the file that you want it to store
22:44 - locally as
22:48 - at times you may be on a linux system
22:50 - and may not know what operating system
22:52 - you are on
22:53 - to know the current os inspect the
22:56 - release files under the etsy directory
22:59 - the release files may be named
23:00 - differently based on the operating
23:02 - system so use a wild card like this
23:06 - to see more details about the
23:09 - os
23:10 - view these files by running the cat
23:12 - command
23:13 - and you can see that in this case it's
23:15 - centos version
23:17 - 7.
23:18 - let's now talk about package managers in
23:20 - linux
23:21 - package managers help you install
23:23 - various software on the linux system and
23:25 - when you go through devops and cloud
23:27 - courses you will install various
23:30 - software such as web servers database
23:33 - servers and devops tools or dependent
23:35 - softwares
23:37 - and most of these are installed
23:40 - using package managers
23:43 - centos uses an rpm based package manager
23:46 - just like red hat enterprise linux or
23:48 - fedora rpm stands for red hat package
23:52 - manager
23:53 - a software is packaged into a bundle
23:56 - with the extension.rpm
23:59 - to install the package use the rpm
24:01 - command and the dash i option
24:04 - for install and specify the package name
24:08 - to uninstall a package use the
24:11 - e option and to query the database
24:14 - and get details about an installed
24:16 - package use the dash queue option
24:20 - so rpm requires you to point it to the
24:23 - exact location where the rpm package is
24:26 - available
24:27 - you then install that package on the
24:29 - system
24:30 - it does not care about any dependencies
24:33 - that this package may have for example
24:35 - say you were installing
24:37 - another software
24:39 - like ansible and it requires
24:42 - python and other other dependent
24:44 - software
24:45 - so simply installing ansible with the
24:48 - rpm command would not take care of
24:50 - installing python and other dependent
24:52 - libraries if they are all not already
24:54 - installed
24:55 - and that's why you need a solution that
24:58 - can make these easy for you a single
25:01 - command that can query the package find
25:04 - its location and install all
25:06 - dependencies as well as the package
25:08 - itself
25:10 - that's where package managers like yum
25:12 - come into play yum is a high level
25:15 - package manager that uses rpm underneath
25:19 - running a simple yum install ansible
25:22 - command installs ansible and all of its
25:25 - dependent packages
25:27 - searches software repositories that act
25:30 - as warehouses containing hundreds and
25:33 - thousands of rpm package files
25:35 - these repositories can be local that is
25:38 - installed on your laptop for example or
25:40 - on a remote location either a secure
25:43 - server in your enterprise or available
25:46 - publicly in the internet
25:49 - under the hoods yum still makes use of
25:51 - the rpm package manager so when you try
25:54 - to install a package using yum yum
25:56 - searches these repositories finds the
25:59 - required packages and dependencies and
26:02 - installs all of them in the right order
26:05 - so what is this remote repository and
26:08 - how are packages stored there like how
26:11 - does yum find where a particular package
26:13 - is located
26:15 - the information about the repository in
26:17 - a configuration file at path
26:20 - slash etsy
26:22 - m.repos.d
26:24 - directory
26:26 - every operating system comes bundled
26:29 - with its own set of repositories from
26:31 - which you can install a lot of commonly
26:33 - used software and tools so you might not
26:36 - need to edit the list of repositories
26:38 - but at times the default set of
26:41 - repositories may not have the software
26:43 - you need or may not have the latest
26:45 - version of software that you need to
26:47 - install so in that case you will need to
26:50 - configure additional repositories so
26:53 - that yum can find those packages
26:56 - instructions to configure additional
26:58 - repositories are usually made available
27:01 - along with the software itself and we'll
27:03 - see an example of that
27:05 - so to see the list of repositories
27:08 - available on a system run the yum repo
27:11 - list command and here we see that there
27:13 - are a set of centos repositories such as
27:16 - the base and extra repository as well as
27:19 - mongodb and mysql ones so listing the
27:22 - files under the etsym.repost.d
27:25 - directory shows the files where these
27:28 - repositories are configured and if you
27:30 - look inside one of these files you will
27:32 - see the url of the location where all
27:35 - packages are stored
27:37 - now if you visit this url you can see
27:40 - the rpm files that yum will eventually
27:44 - download and install
27:45 - on your local system
27:47 - with the rpm utility so that's kind of
27:50 - how yum finds a package in this case
27:53 - since we are relying on an existing
27:56 - yum repo on centos it takes us to an
28:00 - older version of ansible which happens
28:02 - to be version 2.4 although the latest
28:05 - version as of this recording is 2.9
28:08 - so as i just mentioned the instructions
28:11 - to configure the repo to install the
28:13 - latest version of ansible is available
28:16 - in the ansible documentation page itself
28:19 - so you can configure a new repo using
28:21 - the yum install command itself
28:24 - and running this command adds a new
28:26 - repository to your system which points
28:29 - to the latest version of ansible
28:32 - to see a list of installed or available
28:34 - packages run the yum list command
28:38 - and followed by the package name if you
28:40 - want to search for its particular
28:42 - package it provides the package name and
28:45 - version and if it's an installed package
28:48 - or just
28:50 - an available package
28:51 - to remove an installed package run the
28:54 - yum remove command followed by the
28:55 - package name
28:57 - and to list all available versions of a
28:59 - package run the yum list command but
29:02 - this time with the show duplicates
29:04 - option
29:05 - so here we see two versions of packages
29:08 - for ansible and we can see that each of
29:10 - these
29:11 - are from two separate repositories
29:14 - one is from the extras repository and
29:16 - the other is from the epel repository
29:20 - to install a specific version of a
29:22 - package run the yum install command with
29:25 - the package name followed by a hyphen
29:28 - and the version of the package
29:31 - let's now talk about services in linux
29:35 - once you install a software on servers
29:38 - especially those that run in the
29:40 - background such as web servers or
29:42 - database servers
29:44 - you would need to make sure that those
29:46 - servers or services are running and that
29:49 - they stay running even after the servers
29:51 - are rebooted
29:53 - so services in linux help you configure
29:56 - software to run in the background and
29:59 - make sure that they run all the time
30:02 - automatically when servers are rebooted
30:04 - as well as they follow the right order
30:07 - of startup
30:10 - when any software that runs as a service
30:13 - in the background is installed such as a
30:15 - web server or database server or devops
30:18 - tools like docker they are automatically
30:20 - configured as a service on the system
30:23 - to start that service you run the
30:25 - service start command
30:27 - and providing the service name which
30:29 - happens to be in this case httpd
30:32 - the newer
30:34 - method to start a service is to use the
30:37 - system cuddle command and run the system
30:40 - cuddle start
30:41 - command and provide
30:43 - the service name so in this case
30:46 - system cuddle or system ctl start httpd
30:52 - systemcuddle is the command used to
30:54 - manage services on a systemd managed
30:57 - server both the commands the service
30:59 - command and the system cuddle command
31:02 - serve the same purpose
31:04 - the service command uses the system
31:06 - cuddle utility underneath
31:09 - so we will just focus on using the
31:12 - system cuddle command for the remainder
31:14 - of this lecture
31:16 - to stop a running service run the system
31:18 - cuddle stop command followed by the
31:21 - service name
31:22 - to check the status of a service run the
31:24 - system cuddle status command
31:27 - to configure a service to start
31:28 - automatically when the system boots up
31:31 - run the system cuddle enable command
31:33 - and to disable the service at boot up
31:36 - run the system cuddle disable command
31:39 - once services are configured it is so
31:41 - convenient for administrators to start
31:44 - stop or enable the services you don't
31:47 - have to go looking for the executables
31:50 - to start these services
31:52 - so how do you configure a program or
31:55 - software as a service say for example
31:58 - you have a simple
32:00 - python program and it could be a simple
32:03 - web server that's developed in python
32:06 - and the code is available at opt
32:09 - code myapp.py
32:11 - you can run this server with the python
32:14 - interpreter
32:16 - once it's running if you call
32:18 - the local host for port
32:20 - 5000
32:21 - you see it return hello world which
32:23 - happens to be the response of the web
32:25 - server
32:26 - now i want to configure this as a
32:29 - service
32:30 - you know so you want your program to run
32:33 - as a service so that
32:35 - when you run the system cuddle
32:37 - start command
32:39 - it starts and when you run the system
32:41 - cuddle stop command it stops
32:44 - and similarly you want to configure your
32:46 - application to automatically start when
32:48 - the system boots up and you know even
32:50 - automatically restart in case the
32:52 - application crashes
32:55 - how do you do that
32:56 - as we just saw the system called command
32:59 - line utility is used to manage the
33:02 - systemd services so we must configure
33:04 - our program as a systemd service
33:07 - so how do we do that a systemd service
33:10 - is configured using a systemd unit file
33:14 - these files may be located at etsy
33:18 - systemd
33:19 - system path
33:21 - so let's create a unit file at etsy
33:25 - system the system path
33:26 - the file must be named with the name
33:29 - that you eventually want the service to
33:30 - be known as in this case
33:32 - we'll name it my app
33:34 - and with an extension dot
33:36 - service define a section called service
33:40 - using the square brackets inside the
33:42 - file and provide a directive named
33:45 - execstart under it
33:48 - this is where you specify the command
33:51 - that you will be using to run your
33:53 - application
33:54 - so the same command that we run here
33:56 - we're going to put it over here
33:59 - and that's it that's enough to configure
34:01 - your application as a service
34:04 - run the system cuddle daemon reload
34:06 - command to let systemd know that there
34:09 - is a new service configured and then run
34:12 - the system cuddle start command and
34:14 - provide the name of the service in this
34:16 - case my underscore app
34:20 - let's check the status of the new
34:21 - service using the system calls status
34:24 - command
34:25 - it lists that the service is in an
34:28 - active and running state
34:30 - you can now test by performing a call
34:32 - operation on port 5000 of localhost
34:36 - to stop the application run the system
34:38 - cuddle stop command
34:41 - okay so we have configured our
34:42 - application to run as a service and we
34:45 - are now able to start and stop it as
34:47 - required
34:48 - so how do we configure it to
34:50 - automatically run when the system boots
34:52 - up
34:54 - we configure that in the unit file and
34:56 - the unit configuration file has many
34:58 - other options
35:00 - and the service section is only one of
35:02 - the many sections another section is the
35:04 - install section so in this section we
35:07 - basically need to configure this service
35:10 - to run after a particular service that
35:13 - runs at boot up
35:15 - so one way to specify that is using the
35:17 - wanted by directive we can configure
35:20 - this service to run after the multi-user
35:23 - target run level is started
35:26 - once this is done you can configure the
35:28 - service to start during boot up using
35:30 - the system cuddle enable command
35:34 - you can also provide additional metadata
35:37 - information about the service such as
35:39 - description that would allow
35:41 - others to understand what this service
35:43 - is about
35:44 - now for that add a new section in the
35:46 - file called unit and use the description
35:49 - directive
35:51 - if your application has other
35:52 - dependencies such as commands or scripts
35:55 - that are to be run before starting the
35:57 - application
35:58 - or after starting the application then
36:01 - add the exec start pre and exec start
36:04 - post directives and specify the scripts
36:07 - or commands to be run
36:11 - if you'd like the application to
36:13 - automatically restart in case it crashes
36:16 - specify the restart directive and set
36:18 - its value to always
36:21 - so let's take an example of a real
36:23 - software say docker right well we're not
36:25 - going to talk about docker itself we
36:28 - have you know multiple courses on docker
36:30 - where we
36:31 - talk a lot about docker in this context
36:34 - docker is just an example of a software
36:35 - so and it's the same with any software
36:38 - so you don't really need to know
36:39 - anything about docker to understand this
36:42 - lecture so
36:43 - once docker is installed docker daemon
36:46 - runs as a background process that
36:49 - listens for docker commands
36:51 - when docker is installed an executable
36:54 - named docker d is made available on the
36:56 - system add path slash user slash bin
36:59 - slash docker d
37:02 - this is configured as a service using
37:03 - the system unit file at path
37:06 - lib system the system docker dot service
37:09 - now this file has three sections um the
37:12 - unit service and install section as we
37:14 - just learned and you can see the
37:16 - description as well as some of the other
37:18 - details such as a link to documentation
37:21 - etc and the service section has the
37:24 - command
37:25 - that is run
37:27 - to start the docker daemon which is
37:30 - specified under the exact start
37:33 - section
37:34 - in this section we will learn more about
37:36 - console-based text editors in linux
37:40 - earlier in this course we saw the usage
37:42 - of the cat command to write and redirect
37:45 - data into a file
37:47 - while this works well and has its uses
37:50 - it is a very basic form and offers no
37:53 - additional features and is not feasible
37:55 - when dealing with adding or manipulating
37:58 - large amount of texts or for writing
38:00 - code
38:01 - in the devops and cloud world you'll be
38:03 - working with a number of linux servers
38:06 - and most of the time you'll be accessing
38:08 - them remotely
38:09 - using terminal tools and you'll be
38:11 - modifying content in a number of files
38:14 - configuration files mostly so getting
38:17 - the basics of vi editor comes in really
38:20 - handy in such cases
38:22 - there are a number of text editors
38:25 - available in
38:26 - linux such as vi vim nano etc and in
38:30 - this course we will look at vi editor
38:32 - which happens to be the most popular one
38:36 - vi editor comes installed by default
38:38 - with most operating systems run the vi
38:41 - command and specify the file name to
38:44 - open it
38:45 - the terminal opens the file and you're
38:47 - now inside the vi editor
38:51 - vi editor has two modes of operation the
38:53 - command mode and the insert mode
38:56 - when you open a file in vi editor you
38:59 - are by default in the command mode
39:02 - in this mode you can issue commands to
39:05 - the editor such as to copy and paste
39:07 - lines or delete a line or a word or to
39:10 - navigate between lines etc but you
39:13 - cannot write contents to the file
39:16 - to write contents to the file you must
39:19 - switch to the insert mode to switch to
39:22 - the insert mode type lowercase i
39:26 - once you are in insert mode you may
39:28 - modify the file contents as you would
39:30 - normally
39:31 - to switch back from insert mode to the
39:34 - command mode press the escape key
39:39 - let's see what operations are available
39:41 - in the command mode
39:43 - you may move around through the editor
39:44 - using the arrow keys or the keys k j h l
39:48 - on your keyboard k to go up h to left j
39:51 - to down and l to the right
39:54 - to delete a character press x
39:57 - typing dd deletes the entire line
40:00 - to copy a line type yy and to paste it
40:05 - type in p
40:07 - to scroll the page up or down press the
40:10 - control plus u or d buttons
40:13 - typing in colon takes you to the prompt
40:16 - where you can type in commands
40:18 - to save the changes made to the file and
40:21 - write the file to disk
40:23 - use the colon w command
40:26 - you can optionally specify a file name
40:28 - as well
40:29 - to discard any unsaved changes made to
40:32 - the file and quit whim type in colon
40:35 - queue command
40:36 - to save changes and quit type in colon
40:39 - wq command
40:42 - so how do you find stuff for example i
40:44 - want to find the word off in this file
40:47 - for this type in the command slash off
40:52 - when you do that all occurrences of the
40:54 - word off is highlighted and the cursor
40:57 - is positioned at that location to move
41:00 - your cursor to the rest of the
41:01 - occurrences
41:03 - press the n key
41:05 - and you can continue to press the n key
41:07 - to move the cursor to all future
41:09 - occurrences
41:10 - well that's it for the basics of vi
41:12 - editor for now in this section we will
41:14 - talk about setting up a lab for
41:17 - beginning your studies on devops and
41:19 - cloud technologies
41:21 - at code cloud we have embedded labs for
41:23 - our courses and we provide you a readily
41:26 - available environment to work on but at
41:28 - times you may want to set up your own
41:30 - personal learning environment an
41:32 - environment where your changes are
41:34 - persistent and an environment where you
41:36 - can develop your own custom solutions
41:40 - and this section will help you create
41:42 - your own lab as well as troubleshoot and
41:44 - maintain it which is something that most
41:46 - students struggle with
41:48 - we will discuss the different options
41:50 - available to set up a lab environment
41:52 - such as laptops or cloud we will discuss
41:55 - using virtualbox as a solution to set up
41:58 - labs on your laptop we will discuss how
42:00 - to deploy multiple vms in a virtualbox
42:03 - environment we will discuss networking
42:05 - in virtualbox which is one of the topics
42:07 - that a lot of our students have trouble
42:09 - with such as getting the vms to talk to
42:12 - each other accessing the internet from
42:14 - the from the vms ssh into to the vms etc
42:18 - we will also discuss how to take
42:20 - snapshots to save the state of vms and
42:23 - restore those snapshots we will then
42:25 - discuss how to automate the deployment
42:28 - of vms using vagrant a vagrant is a
42:30 - really neat tool that can help you set
42:33 - up a local lab environment very easily
42:36 - and it is i highly recommend you to
42:39 - learn that and finally we will also look
42:41 - at some options available on the cloud
42:44 - to set up your own lab environment you
42:46 - have two options one is your laptop
42:49 - either office or home
42:51 - the second is on the cloud a private
42:54 - cloud within your organization or a
42:56 - public cloud provider like google aws or
42:58 - azure
42:59 - there are many cloud providers that
43:01 - offer free tier where you can create vms
43:04 - and use them for free we will talk about
43:07 - some of those later
43:09 - for now let's start with a lab setup on
43:11 - a home laptop or desktop environment
43:14 - this could also be an office laptop i
43:17 - personally prefer a home laptop as i can
43:19 - do anything with it as i want i don't
43:22 - need to take approvals or race requests
43:24 - to open up firewalls or get permission
43:26 - to install software on it i want to be
43:29 - independent and do whatever i want to do
43:31 - so you need such an environment to play
43:34 - around with and to break and and then
43:37 - fix it back together and basically do
43:39 - anything that you want to do
43:41 - with it
43:43 - so what is a home lab environment and
43:45 - what are the kind of things that you
43:47 - will be needing it for while going
43:49 - through devops cloud or it automation
43:51 - courses you will often come across a set
43:54 - of tools that you will need to work with
43:56 - tools such as git for source code
43:58 - management
43:59 - build tools like jenkins for running
44:02 - builds programming language frameworks
44:04 - like java python or node.js their
44:07 - dependent libraries and packages web
44:09 - servers like apache web server nginx
44:12 - tomcat servers or databases like mysql
44:15 - mongodb etc or containerization tools
44:18 - like docker or kubernetes
44:21 - and automation tools like ansible chef
44:23 - or puppet
44:25 - um
44:26 - as well as cloud management tools like
44:28 - you know cloud sdks or cloud command
44:30 - line tools and even different operating
44:32 - systems
44:34 - even such as ubuntu centos fedora etc
44:38 - now you can install all of these
44:40 - directly on your laptop and play around
44:43 - with them
44:44 - but at some point it's going to start
44:46 - impacting the performance of your laptop
44:48 - and you might run into compatibility
44:51 - related issues different applications
44:53 - may have a requirement for
44:55 - different versions of these softwares
44:57 - and then you'll try to uninstall and
45:00 - reinstall them and soon you'll see
45:02 - yourself in an installation and clean up
45:05 - loop
45:06 - trying to get it all working
45:08 - and soon uh you'll end up re-imaging
45:10 - your laptop and losing all your
45:12 - configurations and all of the
45:13 - personalization that you did to your
45:15 - laptop
45:16 - so one way to combat that is to do
45:20 - everything that you need to do within a
45:22 - virtual machine
45:24 - on your laptop
45:27 - so this way if things go south you can
45:29 - simply delete your virtual machine and
45:31 - provision a new one or take a backup of
45:34 - your virtual machine and restore state
45:36 - from backup
45:37 - we will discuss how to do that later in
45:39 - this section this also allows you to try
45:42 - different things in different virtual
45:43 - machines and have different operating
45:46 - systems on different virtual machines
45:48 - irrespective of what os you are on say
45:50 - you are on a mac or windows you can have
45:53 - one vm with ubuntu another with centos
45:56 - you can run windows or linux on mac or a
45:58 - windows server on linux or a linux on
46:01 - windows or mac etc and you can have as
46:04 - many systems as you want as long as you
46:06 - have sufficient hardware resources
46:09 - now of course uh all of all of these
46:12 - tools that are listed here some of them
46:13 - definitely need to be on your laptop
46:15 - such as git
46:17 - or you know the a few other popular
46:19 - tools that you would use on a day-to-day
46:22 - basis for development purposes
46:24 - but what i'm referring to here are more
46:26 - of the tools like programming language
46:28 - frameworks or
46:30 - build tools or
46:32 - web servers or databases etc
46:35 - so what is a software that can help you
46:37 - create these virtual machines these
46:40 - virtual machines into which you can you
46:41 - know
46:42 - that those which we can play around with
46:44 - or
46:45 - install applications on
46:48 - it's called as a virtualization software
46:50 - or hypervisors now you might have heard
46:52 - about vmware esx servers or windows
46:55 - hyper-v servers that can create virtual
46:58 - machines
46:59 - these are known as type 1 hypervisors
47:02 - they are installed directly on bare
47:05 - metal such as a laptop or server and
47:07 - then the vms are created on that
47:10 - now these are used in enterprises and
47:12 - production environments where you need
47:14 - to create and manage large number of
47:16 - virtual machines and as such these
47:18 - hypervisors have high
47:20 - resource requirements they also need to
47:22 - be installed and configured directly on
47:24 - the laptop and they are expensive as
47:27 - well a lot of people do use this for
47:29 - home labs especially if they have
47:32 - systems with high resources
47:34 - but that's not what we want here for our
47:37 - purpose there are other solutions
47:38 - available that better suit our needs and
47:41 - are easy to manage
47:43 - and those are type 2 hypervisors there
47:46 - are hypervisors that runs on an existing
47:50 - operating system examples are oracle
47:52 - virtualbox and vmware workstation
47:55 - these allow you to easily
47:58 - get started with virtual machines on
47:59 - your laptops without having to
48:02 - install any other operating system or
48:04 - re-image your laptop so going forward
48:07 - when we say
48:08 - host operating system we are referring
48:11 - to the main os on our laptop and when we
48:14 - talk about guest operating systems we're
48:16 - referring to the vms that are created on
48:19 - the hypervisors which are on the
48:20 - operating system
48:22 - and so these
48:24 - are our topic of interest oracle
48:26 - virtualbox and vmware workstation both
48:29 - of these are very easy to get started
48:31 - with just download and install and off
48:34 - you go
48:35 - but which uh one among the two
48:38 - oracle virtualbox is a free and open
48:41 - source tool it can be installed and used
48:43 - to create virtual machines on windows
48:46 - linux or mac
48:47 - exactly the same way it supports backup
48:50 - and recovery with snapshots and clone
48:52 - features it lets you run multiple vms
48:54 - together and also helps you create
48:57 - separate networks within your laptop for
48:59 - different groups of vms
49:01 - vmware workstation is on the other hand
49:04 - is not a free software it can only be
49:07 - installed on windows or linux and not
49:10 - mac and it supports advanced features
49:12 - like snapshots and clones
49:14 - there is a free version of vmware
49:16 - workstation known as vmware player
49:19 - that's available for windows and linux
49:22 - and vmware fusion which is available for
49:25 - mac
49:25 - however these do not have many features
49:28 - that vmware workstation or virtualbox
49:30 - supports such as
49:32 - running multiple vms at the same time or
49:34 - taking snapshots or performing you know
49:37 - advanced networking configurations
49:39 - so if you ask me considering the cost
49:42 - benefits and the features oracle
49:44 - virtualbox is my choice for a home lab
49:48 - environment
49:50 - so oracle virtualbox is supported on
49:52 - windows linux mac or solaris platforms
49:55 - visit this link to go to the downloads
49:57 - page and download the package for your
49:59 - operating system and this link gives you
50:02 - the list of supported operating system
50:04 - versions
50:04 - with respect to resource requirements
50:07 - oracle virtualbox can be installed on a
50:09 - system with an x86 hardware with memory
50:12 - as small as 5 12 mb and only consumes
50:16 - around 30 mb of disk space for itself
50:19 - however since virtual machines require
50:22 - resources it's a good idea to have
50:24 - additional resources on your host system
50:27 - a lot more actually so a dual core or
50:30 - quad core processor and a memory of at
50:32 - least 4 gb and disk space of at least
50:36 - 100 gb or more will help you set up one
50:40 - or two small vms
50:42 - and you can be really smart in managing
50:44 - resources by allocating vms with only
50:47 - sufficient resources that that it
50:49 - requires and using lightweight os images
50:52 - instead of the full-blown
50:55 - os images so once it's installed open up
50:58 - the virtualbox tool by starting the
51:00 - executable it should be available in
51:03 - your application section or in your
51:06 - program section on windows to create a
51:09 - new virtual machine hit the new button
51:11 - at the top
51:13 - then give your vm a name and specify the
51:15 - location where you want the files of the
51:17 - vm to be created
51:18 - the vm itself and the disks of the vm
51:21 - are stored as a file on the host
51:24 - operating system
51:25 - set the type of the os to linux and
51:28 - since the vm that i intend to create is
51:30 - a centos machine
51:32 - i choose red hat 64 bit as my os version
51:36 - because centos is a community fork of
51:39 - red hat enterprise linux so they're kind
51:41 - of the same except that red hat
51:43 - enterprise linux has a lot more advanced
51:46 - packages and
51:47 - and built-in features but at the core
51:49 - they are the same
51:50 - so from the list of uh options available
51:54 - now you have linux and debian fedora you
51:57 - don't see centos but instead of that you
51:59 - can just select red hat and then you
52:01 - have others like open suse ubuntu etc
52:04 - the next step is assigning memory
52:06 - resources
52:08 - this may differ between different oss if
52:11 - your os is lightweight you may assign a
52:13 - smaller amount of memory
52:15 - 1gb is usually good
52:18 - and next we select the hard disk
52:21 - okay here's where you can create and
52:24 - attach a new disk to the vm
52:27 - now a new disk means it's blank and does
52:29 - not have anything on it it doesn't even
52:32 - have an operating system on it
52:34 - now creating a new vm is like buying a
52:37 - new pc or a laptop
52:40 - without an operating system you decide
52:42 - what cpu memory and disk configurations
52:46 - are needed and then you
52:48 - buy the laptop and
52:50 - get the disks
52:52 - attach the disk to the machine
52:54 - and then
52:55 - the disk is a blank disk and there is no
52:57 - operating system on it so you need to
52:59 - install an operating system using an
53:01 - oscd
53:02 - so just like how you would install an os
53:05 - on a laptop you would need to install an
53:07 - os on a virtual machine created like
53:10 - this
53:11 - now that's one approach but there's a
53:14 - better way and what if the disk you
53:17 - attach already has an os on it a
53:20 - pre-configured pre-built os
53:22 - that way when the vm is created we
53:25 - attach the disk which has the os on it
53:28 - and then when it boots
53:30 - it's ready to go you don't have to
53:32 - manually install the os
53:34 - so how do we create those disks and
53:36 - where do we get such disks from
53:39 - well it so happens that a large
53:41 - collection of such pre-configured disks
53:44 - or images as it is called are available
53:47 - on the internet and one such
53:49 - website is osboxes.org
53:52 - they have a list of images for all kinds
53:55 - of operating systems like ubuntu debian
53:58 - centos fedora etc
54:01 - once an image is downloaded use that as
54:04 - an existing virtual hard disk file while
54:07 - creating the vm
54:09 - and that's it and the vm is now created
54:12 - now all you need to do is start the vm
54:14 - by right-clicking and selecting the
54:16 - normal start option from the menu
54:19 - in the next lecture we will see the
54:21 - different ways of connecting to the vm
54:23 - and working with it
54:24 - and that's one area a lot of people have
54:27 - problems with um like how do you ssh
54:30 - into the vm how do i access a service
54:32 - hosted on the vm etc
54:34 - and that's what we will cover
54:36 - in the next lecture in this demo we're
54:38 - going to see how to set up a lab
54:40 - environment
54:42 - okay so in my case i have a windows
54:44 - system so i will be setting up a lab
54:46 - environment on my windows system it
54:48 - doesn't really matter what operating
54:49 - system you're on you could follow the
54:51 - same instructions to set up a lab
54:53 - environment on linux or your mac
54:56 - operating systems so in our case we're
54:58 - going to install virtualbox so go to
55:00 - virtualbox.org
55:02 - and in the website you will have find a
55:04 - link to download the virtualbox software
55:07 - in the download page you will find these
55:10 - links to download virtualbox for
55:12 - specific operating systems
55:14 - uh in my case mine is windows i'm going
55:16 - to click on windows and i'm going to
55:18 - download
55:19 - the software once downloaded run the
55:22 - executable and follow the instructions
55:24 - in the installation wizard to complete
55:26 - installation
55:28 - in my case i've already installed it so
55:29 - i'm just going to cancel that
55:32 - after you install
55:34 - open up the oracle vm virtualbox
55:36 - interface and it will look something
55:38 - like this
55:40 - now the next step is to deploy virtual
55:41 - machines
55:43 - in order to do that you can either
55:45 - create a machine attach a cd drive of an
55:48 - operating system and follow the
55:49 - instructions
55:50 - to install the operating system as we
55:53 - are familiar with
55:55 - however there's also an another easy way
55:58 - there are pre-installed pre-configured
56:01 - operating system images available on the
56:03 - internet we could use those to easily
56:06 - deploy as many virtual machines as we
56:08 - need
56:09 - for this if you go to the website
56:12 - osboxes.org
56:14 - you will find a lot of pre-installed
56:16 - pre-configured images of various
56:18 - operating systems
56:19 - go to this site and select the vm images
56:22 - virtualbox images link at the top
56:24 - then you will be you'll find a list of
56:26 - various different operating systems from
56:28 - this we will select send os
56:32 - and then it will take us to the centos
56:34 - page
56:35 - here you can see information on
56:36 - downloading the centos image in our case
56:39 - we're downloading the virtualbox image
56:41 - for centos 7 and we're downloading the
56:43 - 64-bit version so remember to download
56:46 - that particular version
56:49 - we will then
56:51 - it is downloaded as a
56:53 - 7z file which is a compressed file so
56:55 - you need a software to uncompress it
56:58 - like guitar or
57:00 - winzip in my case i'm using the 7-zip
57:03 - software to extract the contents of the
57:05 - file into a folder
57:08 - wait for it to finish the extraction
57:11 - process
57:13 - once finished if you go into the folder
57:17 - you will see that there is a folder
57:18 - called 64-bit
57:23 - and inside that folder you you'll find a
57:25 - file with the extension.vdi
57:27 - that stands for virtual disk and that is
57:30 - what we will use to create our virtual
57:32 - machine
57:33 - we're now ready to create a new virtual
57:34 - machine so we go back into the oracle vm
57:37 - virtualbox interface click on new
57:40 - and we fill in the
57:42 - name and operating system
57:44 - now i will name the virtual machine that
57:46 - i'm creating as centos template because
57:49 - as we discussed
57:51 - our goal is to create a template and
57:54 - then use that template to create as many
57:57 - virtual machines as i need
57:59 - so i'm going to name it as centos
58:01 - template i will now select the type as
58:03 - linux
58:05 - and the version since it does not have
58:07 - sent os
58:09 - listed i could simply select
58:11 - other
58:12 - now as you can see under the versions
58:15 - there are 32-bit as well as 64-bit
58:17 - options
58:19 - in our case we downloaded the centos
58:21 - 64-bit version so we must select a
58:24 - 64-bit option
58:26 - now in case you do not see the 64-bit
58:28 - options in this list that is most
58:32 - probably because you do not have the
58:33 - virtualization technology enabled on
58:36 - your laptop
58:37 - to enable virtualization technology on
58:39 - your laptop
58:41 - it is usually under the bios settings
58:44 - if you simply google enable
58:46 - virtualization in bios followed by your
58:48 - laptop model you will see a set of
58:51 - results it's usually it usually looks
58:54 - something like this under the bios under
58:55 - the advanced bios features you'll have
58:58 - something called as virtualization
58:59 - technology
59:00 - and you must
59:02 - ensure that it is set to enable state
59:05 - so once you do that restart your laptop
59:08 - and you will find the 64-bit option and
59:10 - click next
59:12 - in the next
59:13 - here we select a memory size by default
59:16 - it's set to 512 mb
59:18 - and let's change that to around 2gb so
59:21 - we'll set it to 2 gigs
59:24 - in the next step we select the hard disk
59:26 - that we downloaded
59:29 - so in this case
59:31 - the default selection is create a
59:33 - virtual hard disk now but that is not
59:35 - what we want we already have a pre-built
59:37 - image of a hard disk
59:40 - uh downloaded so we're going to specify
59:42 - that select the use an existing virtual
59:45 - hard disk file option
59:46 - and click on browse
59:48 - and browse to the
59:50 - file that we downloaded and extracted
59:52 - which is the centos 7 file with the vdi
59:54 - extension
59:55 - click on ok and that creates the file
59:58 - now before powering on the template we
60:00 - will go into settings and make a few
60:02 - more changes
60:03 - go to system and we'll increase the cpu
60:06 - to around two
60:08 - and we go to network section and we will
60:10 - set the adapter one to bridge network
60:13 - this way my virtual machine gets an ip
60:15 - address as well as it can connect to the
60:18 - internet to download and install
60:20 - packages as required
60:23 - i will now go ahead and power on the
60:24 - system
60:36 - okay i'm now at the login prompt
60:39 - um select the
60:40 - default user which is the o which is os
60:43 - boxes
60:44 - now the password to find out the
60:46 - password for any images downloaded from
60:48 - osboxes.org go to the info section
60:51 - and then you'll see that the username is
60:52 - os boxes and the password is osboxes.org
60:56 - so i'm going to use that password os
60:58 - boxes.org
61:04 - i'll click on sign in to log into the
61:06 - centos system
61:07 - in this demo we're going to see how to
61:10 - set up a lab environment so in our case
61:12 - we're going to install virtualbox so go
61:14 - to virtualbox.org
61:16 - and in the website you will have find a
61:19 - link to download the virtualbox software
61:22 - in the download page you will find these
61:24 - links to download virtualbox for
61:26 - specific operating systems
61:28 - and i'm going to download
61:30 - the software once downloaded run the
61:33 - executable and follow the instructions
61:35 - in the installation wizard to complete
61:38 - installation
61:39 - after you install
61:41 - open up the oracle vm virtualbox
61:43 - interface and it will look something
61:45 - like this
61:46 - now the next step is to deploy virtual
61:48 - machines
61:50 - in order to do that you can either
61:51 - create a machine attach a cd drive of an
61:55 - operating system and follow the
61:56 - instructions
61:57 - to install the operating system as we
62:00 - are familiar with
62:01 - however
62:02 - there's also an another easy way
62:05 - there are pre-installed pre-configured
62:08 - operating system images available on the
62:10 - internet we could use those to easily
62:13 - deploy as many virtual machines as we
62:15 - need
62:16 - for this if you go to the website os
62:19 - osboxes.org you will find a lot of
62:22 - pre-installed pre-configured images of
62:24 - various operating systems
62:26 - go to this site and select the vm images
62:29 - virtualbox images link at the top
62:31 - then you will be you will find a list of
62:33 - various different operating systems from
62:35 - this we will select send os
62:39 - and then it will take us to the send os
62:40 - page
62:41 - here you can see information on
62:43 - downloading the centos image in our case
62:45 - we are downloading the virtualbox image
62:47 - for centos 7 and we're downloading the
62:50 - 64-bit version so remember to download
62:53 - that particular version
62:56 - it is downloaded as a
62:58 - 7z file which is a compressed file so
63:00 - you need a software
63:02 - to uncompress it wait for it to finish
63:05 - the extraction process
63:08 - once finished if you go into the folder
63:12 - you will see that there is a folder
63:13 - called 64-bit
63:16 - and inside that folder you'll find a
63:18 - file with the extension.vdi
63:20 - that stands for virtual disk and that is
63:23 - what we will use to create a virtual
63:24 - machine
63:26 - we're now ready to create a new virtual
63:27 - machine so we go back into the oracle vm
63:30 - virtualbox interface click on new
63:33 - and we fill in the
63:35 - name and operating system i will now
63:37 - select the type as linux
63:40 - and click next
63:42 - in the next
63:43 - here we select a memory size in the next
63:46 - step we select the hard disk that we
63:48 - downloaded
63:50 - so in this case the default selection is
63:53 - create a virtual hard disk now but that
63:55 - is not what we want we already have a
63:57 - pre-built image of a hard disk
64:00 - downloaded so we're going to specify
64:02 - that select the use an existing virtual
64:05 - hard disk file option
64:07 - and click on browse
64:08 - and browse to the
64:10 - file that we downloaded and extracted
64:12 - which is the centos 7 file with the vdi
64:14 - extension
64:15 - click on ok and that creates the file
64:18 - now before powering on the template we
64:20 - will go into settings and make a few
64:22 - more changes
64:27 - go to system and we'll increase the cpu
64:30 - to around two
64:38 - i will now go ahead and power on the
64:40 - system
64:50 - in this lecture we will look at how to
64:52 - connect to the vm we created in the
64:54 - previous video
64:56 - now some of the most frequently asked
64:58 - questions about setting up a local lab
65:00 - environment revolves around connectivity
65:03 - how do we connect to the vm and how do
65:05 - we ssh into it why can't i access the
65:08 - you know something that's hosted on the
65:10 - vm such as the web browser
65:12 - and we'll find answers for these in this
65:15 - video
65:16 - so on our laptop um which we will call
65:19 - as the host system
65:21 - we have deployed oracle virtualbox and
65:24 - created a vm having a centos image which
65:27 - happens to be
65:28 - the same the guest system
65:31 - i'm using mac but it works the same for
65:33 - windows or linux now when a vm is
65:37 - installed and ready you can start the vm
65:40 - either in a normal mode or a headless
65:43 - mode
65:44 - now a normal mode gives you a console to
65:47 - the vm
65:48 - you can see the ui of the vm as you
65:51 - would see a linux laptop boot up it's
65:53 - like looking at the monitor of a machine
65:56 - if the image we downloaded came with a
65:58 - linux gui as well then we can see the
66:01 - gui on the screen and work with the vm
66:04 - like working with any other you know gui
66:07 - the gui is okay to explore and maybe you
66:10 - know play around with initially but
66:13 - when you get into real devops and cloud
66:16 - and automation tasks it would be better
66:18 - to have cli access so i personally never
66:21 - use the gui because
66:23 - it's in fact a bit painful to work with
66:26 - you know switching between your system
66:27 - and the vm ui and since it's a vm the
66:30 - gui and console may be a bit slow you
66:34 - can't easily copy and paste stuff from
66:36 - your host to the guest or you know copy
66:39 - files back and forth
66:41 - you can but it's just not that easy now
66:44 - eventually you need a terminal to work
66:46 - with a linux system
66:48 - that is to run commands for you know
66:50 - installing packages working with
66:51 - services etc
66:53 - so instead of using the terminal inside
66:57 - the gui it is a lot more convenient to
67:00 - use a terminal on your host laptop
67:04 - in the normal mode when the console is
67:06 - closed the vm must be shut down or
67:08 - suspended
67:09 - it pops up this message where it gives
67:12 - you these three options the first one
67:14 - says save the machine state which is
67:16 - suspend and then
67:18 - send or the other options are send a
67:20 - shutdown signal or power off the machine
67:23 - the other option shown here is the
67:26 - headless start so if that is selected
67:28 - the vm still starts but the console
67:31 - window won't be opened
67:33 - the vm can only be accessed remotely
67:35 - using ssh or remote desktop tools for
67:38 - windows
67:39 - the third option is where it can be
67:42 - started in a normal mode but closing the
67:44 - console won't require you to suspend or
67:47 - shut down
67:49 - the vm instead you have you now have a
67:51 - new option
67:52 - that says continue to run in the
67:54 - background
67:57 - so that just
67:58 - selecting that option simply closes the
68:00 - console alone and it continues to keep
68:03 - the the vm running in the background
68:06 - depending on what os has been used on
68:08 - the guest system we have different ways
68:10 - of connecting to it for example say we
68:12 - had a windows system to remotely connect
68:14 - to the windows system without using the
68:16 - console you could use the some kind of
68:19 - remote desktop clients such as the one
68:21 - provided by microsoft
68:24 - now if the guest has a linux operating
68:26 - system as it is in case of centos we can
68:29 - connect to it remotely through ssh using
68:32 - ssh clients like the terminal app in in
68:35 - linux or mac
68:37 - and tools like putty
68:39 - in windows
68:40 - although the vms are within our laptop
68:43 - think of them as separate machines
68:45 - connected to the same network
68:47 - so whatever you need for one system to
68:49 - connect to another system you would need
68:52 - that here for this to work you must have
68:54 - these vms configured with ip addresses
68:57 - and the relevant services must be
68:58 - configured and running on windows you
69:01 - need the
69:02 - remote desktop service to be running
69:04 - and on linux you need the ssh service to
69:07 - be running
69:08 - so make sure ssh server is installed and
69:11 - is in a running state if so you can ssh
69:14 - into the vm from the host system using
69:16 - the terminal on the host and the ip
69:19 - address of the remote vm
69:22 - but how do you configure ssh service and
69:24 - ip addresses on the vm if you can't
69:26 - connect to it on the first place for
69:28 - that
69:29 - you could use the console to perform
69:31 - initial configuration it's a common
69:33 - practice to use the console to perform
69:36 - initial configurations and then once ssh
69:38 - is enabled switch over to the terminal
69:41 - for all future interactions
69:43 - so if you run into issues connecting to
69:45 - a vm check to make sure that the vm has
69:48 - an ip address set and that you are using
69:51 - the right ip address and that ssh
69:53 - service on the remote vm is running
69:57 - so here's a quick example on how to
69:59 - check or set ip addresses in a centos
70:02 - machine
70:04 - run the ip address show command and it
70:06 - lists all interfaces and ip addresses
70:08 - assigned to them
70:12 - the first interface is the loopback
70:14 - interface with the
70:16 - ip127.0.0.1 and the second interface is
70:19 - 0 which is the interface used for
70:21 - connectivity and it has ip addresses
70:24 - 192.168.1.10
70:27 - now if the ip address was not set you
70:29 - can set the ip using the ip address add
70:32 - command and specify the ip address
70:34 - followed by the subnet mask and the
70:37 - device you want to set the ip on which
70:40 - happens to be each 0 in this case
70:43 - now with different operating systems the
70:46 - device names as well as commands may
70:48 - differ so refer to the operating system
70:51 - documentations and find out the right
70:54 - relevant way to set ip address
70:57 - and here's a quick tip on checking the
70:59 - ssh service the ssh
71:01 - service comes by default with centos
71:04 - image
71:04 - to check if the
71:06 - daemon is running run the service sshd
71:09 - status command
71:11 - if it's not running run the service sshd
71:15 - start command
71:16 - to start it
71:18 - well that's it for now we will now head
71:19 - over to a demo and see this in action
71:22 - and in the upcoming lectures we will
71:24 - discuss more about networking in
71:26 - virtualbox
71:30 - okay i'm now at the login prompt
71:32 - um select the default user which is the
71:35 - o which is os boxes
71:38 - now the password to find out the
71:39 - password for any images downloaded from
71:41 - osboxes.org go to the info section and
71:45 - then you'll see that the username is os
71:46 - boxes and the password is osboxes.org
71:50 - so i'm going to use that password os
71:52 - boxes.org
71:57 - i'll click on sign in to log into the
71:59 - centos system
72:02 - i'll open up a terminal
72:06 - and type in ifconfig
72:09 - the ifconfig
72:11 - command
72:13 - tells me the ip address currently
72:14 - assigned to the virtual machine as you
72:17 - can see it is 192.168.1.112.
72:22 - now i will open up a
72:24 - ssh terminal
72:26 - to ssh into that
72:29 - virtual machine
72:30 - in my case i'm using a terminal
72:34 - software called as moba exter i like to
72:37 - use this this is a free software that is
72:39 - available you could use any ssh terminal
72:42 - software you could simply use putty as
72:44 - well
72:45 - so
72:46 - create a new ssh session and specify the
72:50 - ip address which is 192.168.1.112
72:58 - and the username is os boxes
73:02 - click on ok
73:05 - now we'll specify the password which is
73:07 - os boxes.org
73:09 - and i'm logged in
73:12 - so there are different ways to connect
73:14 - to a linux vm on virtualbox depending on
73:16 - how you set up your networking
73:18 - i used uh two different approaches while
73:21 - deploying the vms in windows and mac so
73:25 - i kind of had two demos there windows
73:26 - and mac you don't have to go through
73:28 - them it's kind of the same demo the only
73:30 - difference between the two is that on
73:32 - one i set up a bridge networking and on
73:34 - the other i didn't okay so
73:37 - the one on the left as you see here is
73:39 - the setting on mac
73:40 - and on the one on the right is the
73:42 - setting on windows
73:44 - on the windows deployment i added a
73:46 - bridge adapter and on the mac os um i
73:49 - didn't
73:50 - i just configured the default nat option
73:53 - for the networking adapter
73:55 - now if you had configured the bridge
73:58 - adapter as in windows the vm becomes
74:00 - part of the external network and it gets
74:03 - an ip address assigned to it you can
74:05 - simply ssh to it as you would ssh to
74:08 - another system in your network
74:10 - in case of nat as in the mac setup it
74:13 - doesn't connect to the external network
74:15 - and so does not get an ip address on the
74:18 - external network that we can use to ssh
74:20 - to
74:22 - so we will use port forwarding as we
74:24 - discussed in the previous lecture
74:27 - i also want to point out that this
74:29 - doesn't have anything to do with windows
74:31 - or mac both these network configurations
74:33 - can be configured on either os and it
74:36 - works the same i just chose two
74:37 - different options just to show you the
74:39 - difference between the two
74:41 - okay so let's proceed with the
74:42 - connectivity on mac once the system is
74:44 - powered on if the console looks too
74:47 - small you can go to the view menu and
74:49 - scale visibility to 300 percent
74:52 - there is a welcome screen and wizard
74:54 - within the console so just go through
74:56 - that and close them
75:05 - from the applications menu select
75:07 - terminal we'll now check the ip address
75:10 - of the system so we type in ip address
75:13 - show command to see the ip addresses
75:16 - as you can see it gets an ip address of
75:19 - 10.0.2.15.
75:21 - now this is a private internal ip
75:24 - assigned by the nat router for this vm
75:27 - so this ip is not reachable from
75:29 - anywhere else neither the host or nor
75:32 - any other vms created on this network so
75:35 - don't try to you know ping this ip or
75:37 - ssh this ip
75:38 - from the host you'll not be able to do
75:40 - that
75:41 - if you had multiple vms you will see
75:43 - that all vms configured with nat are
75:46 - isolated and they all get the same ip
75:48 - address assigned and they cannot reach
75:51 - each other however with network address
75:54 - translation they can reach the external
75:56 - world so you should have internet
75:58 - connectivity if your host has
76:01 - internet connectivity you can verify
76:03 - that by trying to ping
76:05 - an external website
76:07 - like this
76:09 - okay so that looks good
76:12 - so how do you remotely connect to this
76:14 - system like if you want to ssh
76:17 - into this vm to perform you know to
76:20 - carry out operations to run commands
76:23 - how do you do that
76:24 - so first verify that the ssh service is
76:27 - running for this run the service sshd
76:31 - status command
76:32 - we see the status is active now our goal
76:36 - is to ssh into this vm from a terminal
76:39 - on our host
76:40 - since it doesn't have an ip address
76:43 - that we can ssh to we will set up port
76:45 - forwarding go to the settings
76:48 - menu of this vm and under the network
76:50 - section select port forwarding
76:58 - add a new rule
77:01 - we will forward a port on our local host
77:04 - to a port on the vm the ssh service
77:07 - listens on port 22 on the vm but we also
77:10 - have an ssh service on our host that
77:13 - uses port 22. so we cannot uh forward 22
77:17 - on our host to the vm so we will
77:19 - configure another port say port 2222
77:23 - on the host to forward to port 22 on the
77:26 - vm so we add a rule for that and we name
77:29 - it ssh port
77:31 - now i could try to ssh to my local host
77:34 - ip or a loopback ip address which is
77:37 - 127.0.0.1
77:40 - and specify port 2222 and if you'd like
77:43 - to log in as root user specify the
77:45 - username
77:46 - before the ip address
77:48 - and enter the password
77:50 - osboxes.org and you're in
77:53 - well we've now connected to our vm and
77:55 - we can now run any commands we'll
77:58 - inspect the release files under the etsy
78:00 - directory using the cad command to
78:02 - verify
78:03 - the version of os um and as we can see
78:06 - that it's centos 7
78:09 - so we've connected to the right system
78:11 - okay
78:12 - so that's it for this demo
78:14 - in this lecture we will look at the
78:16 - various networking options available
78:18 - within virtualbox
78:20 - some of the common issues that our
78:22 - students face with respect to virtualbox
78:24 - is around networking a lot of our
78:27 - students struggle with understanding the
78:29 - different kinds of networks such as nat
78:31 - bridge and host only and what they mean
78:34 - and what type of network to be used when
78:37 - also how do multiple vms connect with
78:39 - each other and how to troubleshoot
78:41 - issues where you can't reach the
78:43 - internet
78:44 - and that's what we will discuss in this
78:46 - video
78:48 - so before getting into networking in
78:50 - virtualbox let us first revise some of
78:52 - the basic networking concepts
78:55 - now computer systems like our laptops or
78:57 - servers have different kinds of
78:59 - interfaces or adapters that are used for
79:02 - connectivity such as wired ethernet
79:04 - interfaces to connect to a lan network
79:06 - through a hub or a switch using a cable
79:10 - and wireless interfaces to connect to
79:12 - the network through wi-fi
79:14 - now irrespective of how they connect to
79:16 - a network once they do they get an ip
79:19 - address assigned either manually or
79:22 - dynamically if there is a dhcp server in
79:24 - the environment
79:26 - an ip address is assigned to an
79:28 - interface in this case we have a laptop
79:31 - that's connected using an ethernet cable
79:34 - to a switch in our home once the
79:36 - connection is established our laptop
79:38 - gets an ip address when you run the ip
79:41 - address show command you see the
79:43 - interface
79:44 - enp0s3 and it has the ip address
79:47 - 192.168.1.5
79:50 - now say you have another adapter a wi-fi
79:52 - adapter and you attach that to the same
79:54 - network but this time through a wi-fi
79:57 - then that interface gets another ip
79:59 - address assigned to it and can be seen
80:01 - in the output of the same command
80:04 - the same laptop now has two separate ip
80:06 - addresses on the same network if any
80:09 - other host were to try to reach our
80:11 - laptop
80:12 - they may do so using any of these ip
80:14 - addresses
80:15 - so what i'm trying to say is every
80:17 - system every computer system has
80:20 - different interfaces and it can have
80:23 - multiple such interfaces and adapters to
80:26 - connect to different networks so it
80:28 - could be the same network which is
80:30 - which is as it is in this case but it
80:32 - could be to connect to different
80:33 - networks
80:34 - some interfaces have internet
80:36 - connectivity depending on what network
80:38 - they're connected to and the others do
80:41 - not
80:44 - once a virtual machine is provisioned in
80:47 - virtualbox if you go to the settings of
80:49 - that vm and in the network tab you will
80:52 - see different networking options
80:54 - to start with there are four adapters
80:57 - this means
80:59 - that you can configure your vm to have
81:01 - up to four network connections
81:04 - now how you configure those and what do
81:07 - you connect these adapters to is up to
81:09 - you
81:10 - by default only the first adapter is
81:12 - enabled and it is attached to nat
81:15 - as you can see there are multiple
81:17 - options available here nat bridge
81:20 - adapter host only adapter
81:22 - being some of them and we will see what
81:24 - these options are next
81:27 - so let's start with a simple example say
81:30 - we have a physical system like our
81:32 - laptop or a pc and it's connected to the
81:35 - network with the address 192.168.1.0
81:40 - so you set an ip for your pc to
81:43 - 192.168.1.10
81:48 - and we have virtualbox on it say for
81:50 - example a on virtualbox we have
81:52 - provisioned multiple virtual machines so
81:55 - there are four virtual machines
81:57 - provisioned now how do these vms talk to
82:00 - each other
82:02 - how do
82:03 - they reach systems outside of your pc
82:06 - now as of now
82:08 - these virtual machines are simply
82:10 - created they don't have any network or
82:12 - any ip address assigned to them so if
82:14 - you log into any of these vms through
82:16 - their console and try to ping one
82:18 - another it would fail and it wouldn't be
82:21 - you wouldn't even know what the ip
82:22 - address is to do a ping in the first
82:25 - place
82:26 - so we create a private network within
82:29 - our pc
82:30 - it's called as a
82:32 - host only network and has an address
82:35 - 192.168.5.0
82:38 - so we attach the virtual interfaces of
82:40 - the vms to this network now i'll explain
82:44 - how we do that in a bit but let me first
82:47 - cover the concepts
82:49 - so once you attach the interfaces or the
82:52 - virtual interfaces of the vms to this
82:54 - network they all get an ip address in
82:57 - the 192.168.5
82:59 - series
83:00 - in that range so one system gets 192 168
83:03 - 5.2
83:04 - another one gets fighter 3 fighter 4 and
83:06 - 5.5
83:08 - our pc is a part of the network so a
83:12 - virtual interface is created on our pc
83:15 - and connected to the same network
83:17 - and it gets an ip192
83:22 - so all the vms and pc itself are now
83:25 - part of a virtual private host only
83:28 - network
83:29 - the reason it's called host only is
83:32 - because the connectivity is contained
83:34 - within this host
83:36 - all the vms can reach each other but
83:38 - they cannot reach the outside world nor
83:40 - can anyone outside this host reach these
83:44 - virtual machines
83:45 - they're all on a private internal host
83:48 - only network so how do you create this
83:51 - host only network and how do you attach
83:52 - vms to this
83:54 - to create this host only network on
83:56 - virtualbox
83:57 - on mac go to file and then host network
84:00 - manager you will have a similar option
84:03 - available for windows and linux as well
84:05 - so just find out where that is
84:08 - once you go into the host network
84:10 - manager
84:11 - inside the host network manager create a
84:14 - new network by clicking on the create
84:16 - button this creates an internal virtual
84:19 - network in our laptop and creates an
84:21 - interface by the name
84:23 - vboxnet0 and assigns our laptop the
84:27 - first ip address on this interface if
84:29 - you run the ifconfig command you see the
84:32 - two ip addresses assigned to my laptop
84:35 - the 192 168 1.10 on the ethernet adapter
84:38 - and
84:40 - 192.168.5.1 on the vbox net zero adapter
84:43 - so that's the
84:44 - network the first network created by
84:46 - virtualbox
84:48 - and you can create multiple such host
84:50 - only networks
84:52 - within virtualbox
84:54 - so now that we have created the network
84:56 - to attach a vm to this network go to the
84:58 - settings page of a vm and under network
85:01 - select the adapter and select attach to
85:04 - host only adapter and select the new
85:06 - network that we created
85:09 - so do that on each vm and since this
85:12 - host only network also has dhcp
85:15 - enabled the vms
85:17 - get an ip assigned automatically
85:21 - okay so that was one scenario let's look
85:23 - at another option so say we have another
85:27 - physical machine in the network
85:30 - so just building off
85:31 - of that previous example where we have
85:34 - on one side we have our host only
85:35 - network and the vms inside it
85:38 - but we also have another host that's
85:40 - attached to this particular network and
85:42 - it has an ip 192 168
85:45 - 1.11
85:47 - the pc has some kind of service running
85:49 - on it such as let's say a database
85:52 - instance
85:53 - for example
85:54 - and our vms on the first pc would like
85:57 - to access this particular database
86:00 - now in the current setup with the host
86:02 - only network the vms are not going to be
86:05 - able to do that
86:07 - is because they are on a host only
86:08 - network and they cannot really reach
86:10 - outside
86:11 - of that host
86:13 - so for this we introduce a nat network
86:16 - so instead of creating a host only
86:18 - network we create a nat network the net
86:22 - network is similar to the host only
86:24 - network where as in
86:26 - we create a private network within the
86:28 - physical system and we attach all the
86:30 - vms to it and they all get an ip address
86:33 - but this time these vms can access the
86:36 - outside world
86:37 - the vms can now access the database
86:40 - using its ip address
86:42 - now for every packet that is sent from
86:44 - the vm to the database the nat engine
86:47 - which sits on the on our host
86:50 - is going to replace the source ip
86:52 - with its own ip address so that when the
86:55 - database receives a request it's going
86:58 - to think that it's all coming from the
87:00 - first pc it is unaware of the vms that
87:03 - are present on the first pc
87:05 - so it processes the request and sends
87:08 - back
87:09 - the data to the first pc
87:12 - the net engine on receiving the response
87:15 - intercepts the packet and changes the
87:17 - address back to the original vm's ip and
87:20 - forwards it back to the vm
87:24 - so that's what's called address
87:26 - translation and that's why network
87:28 - address translation when a request is
87:30 - sent
87:31 - the net the from address is actually
87:34 - translated to the host's address and
87:36 - then the request goes and then when the
87:38 - response is received
87:40 - the the to address is changed back
87:43 - to the original address of the vm that
87:46 - in fact sent the request
87:49 - so with this setup the vms within
87:52 - can access the outside world but
87:54 - remember
87:55 - the outside world is still unaware of
87:57 - the vms that exist within the system
88:00 - so no systems from the outside world can
88:03 - access the vms inside
88:06 - so how do you do that to create a nat
88:08 - network go to the virtualbox preferences
88:12 - page and select network and there you
88:15 - will find nat networks
88:17 - click the plus button and create a new
88:19 - nat
88:20 - network
88:21 - once created to attach a vm
88:24 - to this net network
88:26 - go to the vm settings and under network
88:29 - attach the adapter to nat network
88:32 - now note that it is different from nat
88:35 - so nat and net network are different
88:37 - and then select the name of the net
88:39 - network and that's all so what is
88:43 - nat and net network what is the
88:45 - difference between nat and network and
88:48 - nat
88:50 - nat is the default setting of a vm on
88:52 - virtualbox
88:54 - it works similar to nat network as in
88:56 - the vms can reach the external world and
88:59 - you know uses net and network address
89:01 - translation so that when requests go out
89:03 - they go out with the address of the host
89:05 - and when responses are received the
89:07 - address is replaced by the virtual net
89:09 - router within that vm however you don't
89:12 - have that internal
89:14 - network here
89:16 - so as such the vms are not able to reach
89:19 - each other so each vm is isolated they
89:22 - cannot talk to each other but they can
89:24 - talk to external systems
89:26 - through the host so each in this case
89:29 - each vm kind of gets its own nat router
89:32 - whereas in the earlier case there was a
89:34 - nat network and there was a single net
89:36 - router that that works for all vms in
89:39 - this case there's more isolation between
89:42 - the vms within the host
89:44 - so that was about nat
89:46 - now let's look at another scenario where
89:48 - an external host requires access to the
89:52 - internal vms so we've been talking about
89:55 - internal vms trying to access external
89:57 - services but now let's see what happens
90:00 - if we want uh external services or
90:03 - external vms to access
90:05 - internal vms services or services
90:08 - running on these internal vms
90:10 - so say for example there's a web
90:12 - application running on one of these vms
90:14 - and there are other systems that
90:17 - are on our network such as you know
90:19 - laptops and these laptops want to
90:22 - access the web server that's running
90:24 - inside one of these vms
90:27 - so let's look at another kind of network
90:30 - known as a bridge network the bridge
90:33 - network acts as an extension
90:37 - of the lan network so you don't really
90:39 - have to create a bridge network like how
90:41 - we created the host only network or the
90:43 - net network before
90:45 - the bridge network is always there so
90:47 - you just have to connect to it so once
90:50 - the vms connect to this network
90:52 - this time they get an ip address in the
90:54 - same ip range as that of the external
90:59 - lan network
91:01 - so they're assigned ips in the range 192
91:03 - 168 one dot series
91:05 - and it is as though they are all part of
91:09 - the same external network any device on
91:12 - the network can see them as just another
91:15 - virtual machine on the network so even
91:17 - though they're within the the the first
91:19 - host they're in fact it is as if they
91:22 - are all part of the same network because
91:24 - the host also gets an ip address
91:26 - um in the range 192 168 1.10 and the vms
91:31 - within the host also get an ap address
91:34 - in the same range 1.12 1.13 so it's as
91:37 - if they're all
91:38 - part of the same network but in fact
91:40 - these vms are inside
91:42 - this host
91:43 - so since they're all part of the same
91:46 - network through the bridge network
91:48 - these laptops can access any services
91:50 - that are that are run
91:52 - on these vms
91:54 - so that's about um bridge network okay
91:58 - so we've talked about the three kinds of
92:00 - network host only nat and bridge let's
92:03 - now talk about internet connectivity in
92:05 - each of these cases
92:08 - in case of a nat setup
92:09 - whether it's a nat network or just nat
92:13 - we learned that internal vms can reach
92:15 - external network through network address
92:17 - translation so vms configured with a nat
92:20 - interface can reach internet as long as
92:24 - the host
92:25 - vm has internet connectivity you don't
92:27 - really need amp to do anything else
92:30 - the bridged option as we know is an
92:33 - extension of the external network so it
92:35 - makes the vm as another host on the
92:37 - network so just like all hosts on a
92:39 - network the vm should be able to reach
92:41 - the internet um easily so there's
92:43 - nothing
92:44 - uh really required
92:46 - over there too
92:47 - however in case of a host only network
92:51 - the vms are on an internal private
92:53 - network all vms attached to that
92:55 - internal network can see each other but
92:57 - they can't connect to any systems
92:59 - outside of the host machine the host
93:02 - machine is connected to two networks the
93:04 - internal host only network where the vms
93:06 - are there and the external network that
93:09 - has internet connectivity and that has
93:11 - connectivity the rest of the network
93:14 - so now we can enable the host machine to
93:18 - forward traffic
93:19 - from the internal network to the
93:21 - external network now for this you must
93:24 - enable ip forwarding on the host vm
93:27 - so
93:28 - this is by default disabled on our
93:31 - laptops most laptops have that that
93:33 - functionality so enabling the ip
93:36 - forwarding feature essentially makes our
93:39 - laptop a router so a router that can
93:42 - route traffic one from one network to
93:44 - another
93:46 - now if you think about it you don't
93:47 - really have to do that
93:49 - if all you need is to establish internet
93:51 - connectivity for the vms
93:54 - there are other ways to do that such as
93:56 - by adding an additional adapter to these
93:59 - vms because as we learned earlier that
94:01 - there are each of these has four
94:02 - adapters so you can configure a second
94:05 - adapter and attach it to nat and that
94:08 - way
94:09 - through those adapters those vms will
94:11 - have internet connectivity
94:14 - so that's just
94:15 - another additional option yeah so this
94:17 - is here's what i was talking about so
94:19 - earlier we said that there of each vm
94:21 - can have four adapters so you can
94:23 - configure the second adapter to be
94:24 - attached to nat
94:27 - so now uh when you run into connectivity
94:29 - issues you know
94:31 - where to look at and you know that you
94:33 - should be looking at
94:34 - the number of interfaces that are
94:36 - configured on the vm look at what type
94:38 - of network they're attached to
94:40 - check if those interfaces have ip
94:42 - addresses assigned
94:43 - and you should be able to get a fair
94:45 - idea
94:46 - why you aren't able to
94:48 - reach the internet now before i let you
94:50 - go one more thing that's worth
94:52 - mentioning is about port forwarding
94:55 - so a lecture about virtualbox networking
94:58 - is incomplete without discussing about
95:00 - port forwarding
95:02 - so let's look at what that is
95:05 - let's look at a simple scenario where we
95:08 - have a single vm configured with nat
95:11 - the the default
95:12 - option port forwarding allows us to map
95:16 - a port on the host to a port on the
95:19 - guest
95:20 - for example port 80 on the host could be
95:23 - mapped to port 80 on the guest so that
95:26 - any traffic that comes in on port 80 on
95:29 - the host is forwarded to port 80 on the
95:32 - guest
95:33 - now maybe the guest is running a web
95:35 - server and it's since it's a nat setup
95:38 - as we discussed before external hosts
95:41 - can't reach the vm so configuring a port
95:44 - forward can help the web server receive
95:46 - requests from external hosts even though
95:48 - it's in a setup because the port
95:51 - forwarding forwards traffic from the
95:54 - port on the host to the port on the
95:56 - guest now it need not be the same port
95:59 - either you can map port 8080
96:01 - to port 5000 on the vm earlier we
96:04 - discussed that to ssh into the vm we
96:07 - assign an ip address and then use that
96:10 - ip address to ssh from the host to the
96:13 - guest
96:14 - another way to do that
96:17 - is if you don't know the ip address of
96:18 - the vm
96:20 - and you can map port 22 of the guest
96:24 - which is the port used to establish ssh
96:26 - connection to another port say 2 2 2 2
96:31 - on the host
96:32 - then you can simply ssh to the loopback
96:35 - ip address of the host and port 2222 and
96:39 - that will in fact forward those
96:42 - requests to port 22 on the vm
96:45 - and you should be able to ssh into that
96:47 - so this way you can have multiple vms
96:50 - and multiple different services running
96:51 - on them and you can map those services
96:54 - to ports on the host
96:57 - now this is done under the vm network
97:00 - settings and by going into the port
97:02 - forwarding options here you can see the
97:04 - different rules to map host port to
97:07 - guest port as well as
97:08 - specify the protocols that are used
97:12 - let us now look at deploying multiple
97:14 - vms on virtualbox and configuring
97:17 - networking between them
97:18 - we will also look at some cloning and
97:21 - snapshot functionalities
97:24 - one way to create multiple vms is to
97:26 - simply clone an existing vm so if you
97:29 - plan to create multiple vms then it's
97:31 - good to plan ahead so that you could
97:33 - first create a template vm and then just
97:36 - create multiple clones from it
97:39 - to create a clone for an existing vm
97:42 - right-click the vm and select the clone
97:44 - option
97:45 - note that for this option to appear
97:48 - the vm must be powered off
97:51 - then give the new vm a name
97:53 - i'll name it vm2 and then select the
97:56 - type of clone so there are two types of
97:59 - clones a full clone and a linked clone
98:02 - a full clone creates a full copy of the
98:05 - disk used by the existing vm consuming
98:08 - equal amount of new space
98:11 - a linked clone uses the disk of the
98:13 - existing vm and only consume space for
98:16 - the changes made in the new vm
98:19 - the only concern is when you plan to
98:21 - move a vm from one system to another in
98:24 - case of the linked clone you'll have to
98:26 - copy the disk of the original vm as well
98:30 - or in case you decide to delete the
98:32 - original vm
98:34 - you run into issues as the linked clone
98:36 - has a dependency on it
98:38 - so if you don't plan to copy your vms
98:40 - then linked clone is a good option as it
98:43 - consumes
98:44 - less space on your on your laptop
98:48 - okay so i'll just select the linked
98:50 - clone and continue with it and create
98:53 - the vm
98:54 - so we now have two vms before turning
98:57 - them on let us make some changes so we
99:00 - want the two vms to be able to reach
99:03 - each other so they both
99:05 - must be part of the same network
99:07 - as per the current setting they are
99:09 - configured with nat and so they are
99:11 - isolated from each other
99:13 - we also want the vms to be able to reach
99:16 - the internet
99:17 - as we plan to install software on them
99:20 - so we will leave adapter one with nat
99:24 - that's for the internet and we will
99:26 - configure a second adapter to connect to
99:28 - a host network for that we must first
99:31 - create the host network
99:33 - so go to file and select host network
99:36 - manager
99:39 - a windows systems should also have this
99:41 - option
99:43 - once it's open create a new network
99:46 - i already have a network in this case
99:48 - and i'll add a new network
99:51 - it's named vboxnet1
99:53 - and as you can see it has an ip address
99:56 - range 192.168.57.1
100:00 - if you'd like the vms to get an ip
100:02 - address assigned to them automatically
100:05 - then check this box
100:07 - and then click close
100:10 - then go to the vms network settings and
100:12 - set the second adapter to connect to
100:14 - host only network and choose the newly
100:17 - created network
100:24 - do that for both vms
100:27 - also note that if your system is low on
100:30 - resources feel free to reduce the cpu
100:33 - and memory on these vms as necessary
100:38 - then power on the vms and wait for them
100:40 - to boot up
100:44 - once they are up log in using the
100:47 - osboxes.org user account i had created a
100:50 - user account named matthew on one system
100:54 - that's why you see that there you can
100:56 - also see that on the other system and
100:58 - that's because when we cloned it all the
101:00 - settings get cloned as well
101:05 - now once logged in open up the terminal
101:08 - and inspect the ip addresses
101:14 - here you can see the new interface that
101:16 - was created to connect to the new host
101:18 - only network it's named enp0s8
101:23 - the ip address that got assigned
101:24 - automatically is 192.168.57.3
101:31 - let us now check on the second system
101:37 - the second system gets ip192.168.57.4
101:43 - and remember we said that our host is
101:46 - also part of the network
101:48 - so our host also gets an ip address of
101:51 - 192.168.57.1
101:54 - on the
101:58 - network now they all can reach each
102:01 - other through these ip addresses
102:04 - we can now ssh to these vms using these
102:07 - ip addresses we don't really need that
102:10 - port forwarding rule we configured in
102:12 - the previous demo anymore
102:14 - so ssh and use the root password
102:21 - and i will use another terminal to ssh
102:23 - to the other vm
102:33 - we will also test internet connectivity
102:36 - since we have the first adapter
102:38 - configured for nat we have internet
102:40 - connectivity through that and we see
102:42 - that successful
102:51 - now just to test and show you the
102:54 - difference we'll change the first
102:55 - adapter to use the other host network we
102:58 - had instead of the nat configuration
103:09 - now when we check the ip address we see
103:11 - that it now has another ip on the first
103:14 - interface which earlier was configured
103:17 - with nat
103:21 - and if we try to reach internet now
103:23 - it is not possible
103:27 - so remember that depending on your
103:29 - requirements you must set up your
103:32 - networking configurations
103:34 - if you simply want the vm to have
103:36 - internet connectivity
103:38 - then set it to nat
103:40 - each vm is isolated if you'd like
103:43 - multiple vms to talk to each other and
103:45 - have internet connectivity choose nat
103:48 - network
103:49 - if you want multiple vms to reach each
103:51 - other but no internet connectivity
103:54 - choose host network
103:55 - in this case your host will also be part
103:57 - of the same network and can reach the
103:59 - vms without any port forwarding
104:02 - if you'd like the benefits of multiple
104:05 - networking options then you can have
104:07 - both of these on a single vm as we did
104:09 - in this demo so have one adapter
104:11 - configured to host network and the other
104:13 - adapter with nat
104:17 - now none of these options really make
104:19 - your vms visible to the external network
104:22 - so your vms are essentially hidden
104:25 - if you like all of these and also have
104:28 - your vms visible on the external network
104:31 - then choose the bridged option
104:35 - let's now look at the snapshot feature
104:39 - with the snapshot feature you can create
104:41 - a snapshot or backup of your vm's state
104:44 - at a particular point in time and then
104:47 - restore to that backup at a later point
104:49 - in time
104:54 - let's just pick the first vm for this
104:56 - demo
104:57 - say we have an application or a file
104:59 - created in a directory
105:01 - for example we create a directory slash
105:03 - opt app and under that we create a file
105:07 - named
105:08 - example.txt with the contents and
105:10 - example file
105:12 - so that's the current good state
105:15 - let us now take a snapshot
105:18 - so click on this option on the vm and
105:20 - under that select snapshots
105:22 - there should be a similar option for
105:25 - that on other platforms as well you know
105:27 - in windows and linux so try to find that
105:29 - out
105:31 - here you can see the current state
105:33 - click on the take button to create a
105:35 - snapshot we will name it the good state
105:38 - and provide a description you can now
105:40 - see a good state snapshot created here
105:44 - now we are going to simulate a failure
105:47 - we will echo some junk data to the file
105:50 - to simulate some kind of a corruption
105:54 - okay now that we have messed up our
105:56 - system and lost the original contents of
105:59 - the file
106:00 - how do we restore it
106:02 - go to the snapshots window and right
106:04 - click the snapshot named good state and
106:08 - select the restore option
106:10 - now the restore option is grayed out
106:12 - because the vm is still up
106:15 - so let's first shut it down
106:22 - now the restored option is available
106:25 - click on it to restore state to the
106:27 - snapshot
106:34 - once restored start the vm
106:37 - we again connect to it and if you go to
106:39 - the opt app path you see the example.txt
106:42 - file and if you look into its contents
106:45 - you see that it has the right contents
106:47 - great so this functionality is
106:49 - especially useful when you are testing
106:51 - different software and functionalities
106:54 - on vms for example before making a major
106:56 - change to your vm such as upgrading the
106:59 - version of software or packages
107:01 - you could take a snapshot of the working
107:03 - state to get back to in the future
107:06 - you can also clone a new vm from the
107:09 - snapshot say you made a lot of changes
107:11 - and something went wrong and you're not
107:14 - sure what that is and if you'd like to
107:16 - create a new vm from the previous
107:19 - snapshot that's possible too so right
107:22 - click the good snapshot and choose clone
107:26 - and then follow the same process we
107:27 - followed earlier to create a new vm from
107:30 - that clone
107:33 - let us now get introduced to the basics
107:35 - of vagrant
107:37 - in the previous videos and demos we
107:39 - looked at how to deploy a vm on
107:42 - virtualbox
107:43 - we followed this process of first
107:46 - downloading the image from the
107:48 - osboxes.org website and then we created
107:51 - a new vm we then configured networking
107:54 - such as you know creating host networks
107:56 - and then we went into the settings of
107:58 - each vm and configured the interfaces to
108:01 - use those correct networking settings
108:04 - and then we also configured port
108:05 - forwarding and finally you know booted
108:08 - up the vm we then repeated these tasks
108:10 - for every vm that we wish to create
108:14 - vagrant helps us automate all of these
108:17 - tasks and do all of these with a single
108:20 - vagrant up command
108:23 - that way you don't have to go searching
108:25 - for images of operating systems or
108:27 - download them or create networks or
108:29 - configure port forwarding manually
108:32 - vagrant does all of that automatically
108:34 - so vagrant is especially useful
108:36 - when you have complex systems involving
108:39 - multiple vms and if you plan to deploy
108:41 - and manage
108:42 - the entire setup
108:44 - together to get started visit
108:47 - vagrant.com and click on the download
108:50 - option and then download and install the
108:52 - appropriate version for your os
108:55 - once installed run the vagrant init
108:57 - command and specify the name of the box
109:00 - you'd like to deploy
109:02 - i'd like to deploy a centos 7 box so
109:06 - what is a box
109:08 - a box is a vagrant term and refers to a
109:11 - packaged format of a vagrant environment
109:14 - it contains an os image as well as
109:17 - scripts required to configure the
109:20 - environment
109:21 - you can find a list of all publicly
109:24 - available vagrant boxes at vagrant cloud
109:28 - by visiting
109:29 - app.vagrantup.com
109:31 - boxes
109:33 - search and find the box of your choice
109:38 - running the vagrant init command
109:41 - initializes the vagrant box in the
109:42 - current directory and creates a vagrant
109:45 - file
109:47 - the vagrant file has instructions on
109:49 - customizing your box we will look at
109:51 - that in a bit
109:53 - to start the vagrant box run the vagrant
109:56 - up command
109:57 - and when this is done
109:59 - vagrant downloads the image required to
110:02 - create the vm it then creates the vm
110:05 - gives it a random name and configures
110:08 - any settings such as port forwarding or
110:10 - anything like that
110:12 - and waits for it to be ready
110:16 - running the vagrant command without any
110:18 - options lists all available commands you
110:21 - can see the vagrant box command used to
110:23 - manage installation and removal of boxes
110:27 - we just saw the init and up command that
110:29 - initializes a box and brings up the vm
110:32 - you may use the suspend command to
110:34 - suspend a vm
110:36 - the resume command to resume a vm and
110:39 - the halt command to stop the vm
110:42 - the destroy command to stop and delete
110:44 - the vm and the status command to get the
110:47 - status of a vm
110:49 - if the vagrant file is changed use the
110:52 - reload command to reload the vm
110:55 - you can also take and restore snapshots
110:58 - using the vagrant snapshot command
111:01 - you could ssh into the vm by simply
111:03 - running the
111:05 - vagrant ssh command
111:07 - vagrant will identify the port
111:09 - configured for
111:10 - port forwarding and use that to ssh
111:14 - vagrant also sets up ssh key based
111:16 - authentication so it uses
111:19 - that as well
111:23 - let's take a look at the vagrant file
111:26 - a vagrant file starts with a
111:28 - configuration block
111:29 - within the vagrant configuration block
111:31 - the image used by the box is specified
111:35 - in this case it happens to be centos 7.
111:38 - this is all there is configured in the
111:40 - default vagrant file if you would like
111:42 - to customize this vm this is where you
111:45 - would do it and then you can share this
111:47 - file
111:48 - with others and the vm will boot up the
111:51 - same way in exactly the same way with
111:54 - the same configurations for everyone
111:57 - for example you could configure port
111:59 - forwarding here and say port 8080 on the
112:02 - host will be forwarded to port 80 on the
112:05 - guest
112:06 - or you could configure a directory to
112:09 - sync between the host and the vm that
112:11 - way you can easily move files from your
112:13 - host machine to the vm if you'd like to
112:16 - configure the cpu and memory settings on
112:19 - the vm then you could do that within the
112:21 - provider
112:22 - virtualbox block like this
112:26 - you can also configure a simple shell
112:28 - script to run at boot up using the shell
112:30 - provision block like this
112:33 - so when you run the vagrant up command
112:35 - now background provisions avm following
112:38 - the specifications given in this vagrant
112:40 - file and also runs the shell script
112:43 - given here you may also include multiple
112:46 - vms in this
112:48 - this approach can help you automate the
112:50 - deployment of complex environments on
112:52 - your laptops
112:54 - such as small clusters of popular
112:56 - systems there are boxes that have
112:59 - automated
113:01 - clusters
113:02 - such as kubernetes clusters which has
113:04 - multiple vms
113:07 - virtualbox is just one provider among
113:10 - the many supported by vagrant you can
113:12 - also use vagrant in a vmware environment
113:15 - such as vmware workstation or vmware
113:18 - fusion or in a microsoft hyper-v
113:22 - environment as well
113:24 - so i'd highly recommend you to check out
113:26 - vagrant
113:28 - and get comfortable with it and this
113:31 - will help you easily
113:33 - create and deploy
113:35 - virtual machine or
113:36 - local lab environments as well as save
113:39 - all the work that you did you know your
113:41 - configurations
113:42 - in a vagrant file that way in the future
113:45 - you can just if you'd like to deploy the
113:47 - same kind of lab environment all you
113:50 - need to do is run a background up
113:51 - command and then you can share that
113:53 - vagrant file your custom file with
113:56 - others in the community
113:58 - and
113:59 - help others benefit from that as well
114:01 - let's take a quick demo of vagrant to
114:04 - download and install vagrant go to
114:06 - vagrant vagrantup.com
114:09 - then go to the downloads page and select
114:11 - the right version for your os i'm on mac
114:14 - so i'm going to select mac os
114:17 - and
114:18 - this works the same on all operating
114:20 - systems so you can follow the same
114:22 - instructions that i'm following in this
114:23 - demo
114:25 - once the executable is downloaded
114:27 - install it on your system
114:33 - once installed the command vagrant
114:35 - should be available on your system
114:38 - let us now open up a terminal and create
114:41 - a directory for vagrant where we will
114:43 - store all our vagrant configurations we
114:46 - then cd into that directory and we are
114:48 - now ready to deploy a vm using vagrant
114:52 - now remember you must have the virtual
114:54 - machine provider which in this case is
114:57 - virtualbox already installed on the
114:59 - system
115:00 - so i already have that
115:02 - it could also be vmware workstation or
115:04 - fusion
115:06 - as well so whatever it is that you plan
115:08 - to use remember it must exist on the
115:10 - system before you actually try to bring
115:13 - up a vm using vagrant
115:15 - now if it's anything other than
115:17 - virtualbox then when you run the vagrant
115:19 - up command you must also specify that
115:21 - provider using the provider option
115:25 - now
115:25 - we need to find vagrant boxes to deploy
115:29 - searching for vagrant boxes in google
115:31 - will land you on the vagrant cloud page
115:34 - and here you can search for various
115:35 - boxes for different operating systems
115:37 - and solutions i'll go with centos 7
115:41 - select that
115:42 - in that centos 7 page we see a template
115:45 - for the vagrant file we could copy this
115:47 - and create a vagrant file by ourself
115:50 - manually or if we want vagrant to create
115:53 - that file for us go to the new tab and
115:56 - copy the command the command is a
115:58 - vagrant init
116:00 - and followed by the name centos 7
116:03 - all this command does is create a
116:06 - vagrant file with the image set to
116:08 - centos 7.
116:10 - if you see the contents of the vagrant
116:12 - file we see that it is really just a
116:14 - template with all the options commented
116:16 - out
116:17 - any line that begins with a hash
116:20 - is commented out
116:22 - the only line set is the line with the
116:25 - box name
116:40 - running the vagrant up command now
116:42 - downloads the image and then creates a
116:45 - virtualbox vm with it
116:58 - if you open virtualbox you can see the
117:00 - vm being created it takes a while for it
117:02 - to boot up so give it some time
117:11 - and once it's booted up we see the
117:14 - machine booted and the ready message
117:17 - okay now when you run this vagrant up
117:19 - command and if you were using
117:22 - an environment other than virtual box
117:24 - then this is where you must also specify
117:27 - the provider using the provider option
117:30 - we can now ssh into the vm using the
117:33 - vagrant ssh command so even if you are
117:35 - on a windows environment you don't
117:37 - really need another ssh terminal tool or
117:40 - putty or anything this command just
117:42 - works it also takes care of
117:44 - authenticating you into the vm using ssh
117:47 - keys
117:49 - we are now in and we can test the
117:51 - version by viewing the etsy release
117:53 - files
117:58 - check the status of the vm using the
117:59 - vagrant status command
118:01 - we see it's in a running state to shut
118:03 - down run the vagrant halt command
118:10 - we now see the status is powered off
118:18 - let's now go into the vagrant file and
118:20 - make some changes
118:22 - if you go all the way to the bottom we
118:24 - see the vms resource settings like
118:27 - memory and configuration
118:29 - it's currently commented out
118:32 - if you look at the settings of the vm we
118:34 - see that it has 512 mb of ram and one
118:38 - vcpu
118:39 - local resources can increase boot time
118:42 - for the vm so we'll increase the
118:44 - resources for the vm
118:46 - from the vagrant file
118:49 - so let's uncomment the memory
118:50 - specification as well as the starting
118:53 - and ending of that block
118:55 - now we will leave the memory to 1gb
118:58 - to provide cpu configuration use the
119:02 - vb.cpu's property and we set it to two
119:05 - vcpus
119:10 - we can also rename the vm here not sure
119:13 - if you notice but the vm has a random
119:16 - name assigned to it
119:18 - and all of these settings can be found
119:20 - in the vagrant documentation page
119:22 - we save that file and every time you
119:25 - modify the vagrant file for the changes
119:27 - to take effect you must run the vagrant
119:29 - reload command
119:31 - we wait for it to boot up and we can see
119:33 - that the vm name is already updated to
119:36 - the name we specified
119:52 - go into settings and we see the memory
119:54 - and cpu are set correctly as well
120:03 - at times when you boot up vms using the
120:05 - vagrant up command you might see an
120:08 - error like this
120:09 - it's a timeout error what's happening
120:12 - here is that vagrant starts the vm and
120:15 - waits for it to boot up completely
120:17 - however the vm took more time to boot
120:20 - than vagrant expected this could be
120:22 - because the vm is configured with very
120:24 - few resources and it takes a long time
120:27 - for the vm to load the vm may end up
120:30 - booting properly eventually and then you
120:33 - should be able to access the vm as you
120:35 - would normally
120:36 - but in case you are not sure and you
120:38 - think it's stuck power off the vm using
120:41 - the vagrant halt command
120:47 - and then go to the vagrant file
120:50 - and you can increase the timeout by
120:52 - adding a property config.vm.boot.timeout
120:56 - like this
121:29 - reloading the vagrant file restarts the
121:32 - vm and the next time vagrant waits
121:35 - longer before throwing an error message
121:38 - well that's a quick introduction to
121:40 - vagrant and i hope it will help you set
121:42 - up labs quickly
121:44 - if you'd like to learn more about
121:45 - vagrant please let us know and we can
121:48 - probably create a separate course just
121:50 - for vagrant because there are so many
121:51 - things that you can do with vagrant you
121:53 - can configure multiple vms you can
121:56 - configure scripts as we saw in the
121:57 - lecture
121:58 - so it's a very neat tool to really set
122:01 - up a custom lab environment and then
122:03 - save that configuration
122:05 - so that you can share it with others in
122:08 - this video we get introduced to dns in
122:11 - linux for the absolute beginners we will
122:14 - discuss the basic concepts and view some
122:16 - commands that will help us explore dns
122:19 - configuration on hosts specifically
122:22 - linux hosts
122:23 - at the end of this section you will go
122:25 - through a practice test where you're
122:27 - given a set of challenges related to dns
122:30 - and are asked to solve them on a live
122:32 - practical hands-on lab environment right
122:35 - in your browser
122:37 - we have two computers a and b both part
122:40 - of the same network and they've been
122:42 - assigned with ip addresses 192 168 1.10
122:45 - and 1.11 you're able to ping one
122:48 - computer from the other using the other
122:49 - computer's ip address
122:52 - you know that system b has database
122:54 - services on them so instead of having to
122:56 - remember the ip address of the system b
122:58 - you decide to give it a name db
123:01 - going forward you would like to ping
123:04 - system b using the name db instead of
123:07 - its ip address if you try to ping db now
123:10 - you would see that host a is unaware of
123:13 - a host named db
123:15 - so how do you fix that
123:17 - basically you want to tell system a that
123:19 - system b at ip address
123:22 - 192.168.1.11 has a name db you want to
123:25 - tell system a that when i say db i mean
123:28 - the ip 182 168 1.11
123:31 - you can do that by adding an entry into
123:33 - the hc hosts file on system a mention
123:36 - the ip address and the name you want
123:38 - your host to see system b as we told
123:41 - system a that the ip at 192.168.1.11
123:45 - is a host named db pings to db now gets
123:48 - sent to the correct ip and are
123:50 - successful
123:51 - now there is an important point to note
123:53 - here we told system a that the ip at
123:56 - 192.168.1.11
123:58 - is a host named db
124:01 - host a takes that for granted whatever
124:03 - we put in the etsy host file is the
124:06 - source of truth for host a
124:08 - but that need not be the truth host a
124:11 - does not check to make sure if system
124:13 - b's actual name is db
124:15 - for instance running a host name command
124:18 - on system b reveals that it is named
124:21 - host 2
124:22 - but host a doesn't care it goes by
124:25 - what's in the hosts file
124:28 - you can even full system a to believing
124:31 - that system b is google just add an
124:33 - entry into the host file with an ip
124:35 - mapping to www.google.com
124:38 - then ping google and you will get a
124:40 - response from system b
124:42 - so we have two names pointing to the
124:44 - same system one as db and another as
124:47 - google and we can use either names to
124:49 - reach system b
124:52 - you can have as many names as you want
124:54 - for as many servers as you want in the
124:56 - etsy hosts file
124:58 - every time we reference another host by
125:00 - its name from host a through a pin
125:03 - command or ssh command or through any of
125:05 - the applications or tools within this
125:07 - system it looks into its etsy hosts file
125:10 - to find out the ip address of that host
125:13 - translating hostname to ip address this
125:16 - way is known as name resolution
125:20 - within a small network of few systems
125:22 - you can easily get away with the entries
125:25 - in the sc hosts file on each system i
125:28 - specify which are the other systems in
125:30 - the environment and that's how it was
125:32 - done in the past
125:35 - until the environment grew and these
125:37 - files got filled with too many entries
125:39 - and managing these became too hard
125:42 - if one of the servers ip changed you
125:44 - would need to modify the entries in all
125:47 - of these hosts and that's where we
125:49 - decided to move all these entries into a
125:52 - single server who will manage it
125:54 - centrally we call that our dns server
125:58 - and then we point all hosts to look up
126:00 - that server if they need to resolve a
126:02 - host name to an ip address instead of
126:04 - its own etsy host files
126:07 - so how do we do that how do we point our
126:10 - host to a dns server
126:13 - our dns server has the ip1921
126:17 - every host has a dns resolution
126:19 - configuration file at
126:22 - etsyresolve.conf you add an entry into
126:25 - it specifying the address of the dns
126:27 - server
126:28 - we say name server and point it to
126:30 - 182.168.1.100
126:33 - and that should be it
126:35 - once this is configured on all of your
126:37 - host every time a host comes up across a
126:40 - hostname that it does not know about it
126:42 - looks lit up from the dns server
126:45 - if the ip of any of the host was to
126:47 - change simply update the dns server and
126:50 - all hosts should resolve the new ip
126:52 - address going forward you no longer need
126:55 - any entries in the etsy hosts file in
126:58 - any of the hosts
126:59 - but that does not mean you can't have
127:01 - entries in hosts file you still can for
127:05 - example
127:06 - say you were to provision a test server
127:08 - for your own needs
127:10 - you don't think others would need to
127:11 - resolve the server by its name so it
127:13 - need not be added to the dns server in
127:15 - that case you can add an entry into your
127:18 - host's hc host file to resolve this
127:21 - server you can now resolve the server
127:23 - however no other system will be able to
127:26 - do that so a system is able to use host
127:28 - name to ip mapping from the etsy host
127:30 - file locally as well as from a remote
127:33 - dns server
127:34 - what if you have an entry
127:36 - in both places one in your etsy hosts
127:39 - file and another in dns i have an entry
127:42 - in my local file set to 192.168.1.115
127:46 - and someone added an entry for the same
127:48 - host to 192.168.1.116
127:51 - on the dns server
127:53 - in that case the host first looks in the
127:56 - local hc host file and then looks at the
127:59 - name server so if it finds the entry in
128:01 - the local etsy hosts file it uses that
128:05 - if not it looks for that host in the dns
128:07 - server
128:08 - but that order can be changed the order
128:11 - is defined by an entry in the file at c
128:14 - ns switch.conf
128:16 - the line with the host's entry as you
128:19 - can see the order is first files and
128:21 - then followed by dns
128:23 - files refers to etsy host file and dns
128:26 - refers to the dns server so for every
128:29 - host name the host first looks into the
128:32 - etsy hosts file and if it cannot find it
128:34 - there it then looks at the dns server
128:37 - this order can be modified by editing
128:39 - this entry in the file
128:42 - as per this order our host would resolve
128:44 - the test server to 192.168.1.115
128:49 - what if we try to ping a server that is
128:51 - not in either list for example i try and
128:54 - ping www.facebook.com
128:56 - i don't have facebook.com in my etsy
128:58 - host file and i don't have it in my dns
129:00 - server either so in that case it will
129:02 - fail
129:03 - you can add another entry into your
129:05 - resolve.conf file to point to a name
129:08 - server that knows facebook for example
129:11 - 8.8.8.8 is a common well-known public
129:14 - name server available on the internet
129:16 - hosted by google that knows about all
129:19 - websites on the internet
129:20 - you can have multiple name servers like
129:22 - this configured on your host but then
129:24 - you will have to configure that on all
129:26 - your hosts in their network you already
129:28 - have a name server within your network
129:30 - configured on all the hosts so in that
129:32 - case you can configure the dns server
129:34 - itself to forward any unknown host names
129:37 - to the public name server on the
129:39 - internet
129:40 - you should now be able to ping external
129:42 - sites such as facebook.com
129:45 - until now we've been just trying to read
129:46 - systems with their names like web db nfs
129:49 - etc but we just tried to ping facebook
129:52 - at
129:53 - www.facebook.com
129:55 - what is this name with your www.com at
129:58 - the end it's called a domain name and it
130:00 - is how ips translate to names that we
130:02 - can remember on the public internet just
130:04 - like how we did for our hosts
130:06 - now the reason they are in this format
130:08 - separated by dots is to group like
130:10 - things together
130:11 - the last portion of the domain name
130:15 - the.coms.nets.edu.org etc are the
130:17 - top-level domains they represent the
130:19 - intent of thewebsite.com for commercial
130:22 - or general purpose
130:23 - dot
130:24 - net4network.edu for educational
130:26 - organizations and dot org for non-profit
130:30 - organizations
130:31 - let's look at one in particular in
130:33 - google's case the dot is the root
130:36 - that's where everything starts dot com
130:39 - is a top level domain google is the
130:42 - domain name assigned to google and www
130:45 - is a sub domain
130:47 - the sub domains help in further grouping
130:49 - things together under google for example
130:51 - google's map service is available at
130:53 - maps.google.com
130:55 - so maps is a subdomain google's storage
130:58 - service is available at drive.google.com
131:01 - mobile apps are available at
131:02 - apps.google.com
131:04 - google's email service are available at
131:06 - mail.google.com
131:08 - you can further divide each of these
131:10 - into as many sub-domains based on your
131:13 - needs so you begin to see a tree
131:15 - structure forming
131:18 - when you try to reach any of these
131:20 - domain names say apps.google.com from
131:23 - within your organization your request
131:25 - first hits your organization's internal
131:27 - dns server it doesn't know who apps or
131:30 - google is so it forwards your request to
131:33 - the internet on the internet the ip
131:35 - address of the server serving
131:37 - apps.google.com
131:38 - may be resolved with the help of
131:40 - multiple dns servers a root dns server
131:43 - looks at your request and points you to
131:45 - a dns serverserving.coms
131:47 - a.com dns server looks at your request
131:49 - and forwards you to google and google's
131:52 - dns server provides you the ip of the
131:54 - server serving the app's applications
131:58 - in order to speed up all future results
132:00 - your organization's dns server may
132:03 - choose to cache this ip for a period of
132:06 - time
132:07 - typically few seconds up to few minutes
132:10 - that way it doesn't have to go through
132:11 - the whole process again each time
132:15 - so that was out in the public
132:17 - what about your organization your
132:19 - organization can have a similar
132:21 - structure too for example your
132:22 - organization could be called as
132:24 - mycompany.com and have multiple
132:26 - sub-domains for each purpose the www for
132:29 - external facing website
132:31 - mail.mycompany.com for accessing your
132:33 - organization's mail drive for accessing
132:36 - storage paid or company.com for
132:38 - accessing the payroll application hr for
132:40 - accessing hr application etc all of
132:43 - these are configured in your
132:45 - organization's internal dns server
132:49 - the reason we discussed all of these is
132:51 - to understand another entry in the etsy
132:53 - resolve.com file
132:55 - remember this is the file where we
132:57 - configured the dns server to be used for
132:59 - our host with that we were able to
133:01 - resolve servers in your organization
133:03 - with just their names like web we have
133:05 - now introduced more standard domain
133:07 - names like
133:08 - web.mycompany.com or
133:10 - db.mycompany.com etc now when you ping
133:13 - web you can no longer get a response of
133:15 - course this is because we are trying to
133:17 - ping web but there is no record for by
133:19 - the name web on my dns server instead it
133:22 - is
133:23 - web.mycompany.com so you have to use
133:26 - web.mycompany.com
133:28 - now i can understand if someone outside
133:30 - our company wants to access our web
133:32 - server he would have to use
133:33 - web.mycompany.com
133:35 - but within our company your own company
133:38 - you want to simply address the web
133:39 - server by its first name web just like
133:42 - how you address other members in your
133:43 - family simply by their first names which
133:46 - is not the case when someone outside
133:47 - your family addresses them using their
133:50 - full names so what do you do to
133:52 - configure web to resolve my
133:55 - web.mycompany.com
133:57 - you want to say when i say web i mean
134:00 - web.mycompany.com
134:02 - for that you make an entry into your
134:04 - host's etsyresult.com file called search
134:09 - and specify the domain name you want to
134:11 - append next time you try to ping web you
134:14 - will see it actually tries
134:16 - web.mycompany.com now your host is
134:19 - intelligent enough to exclude the search
134:21 - domain if you specified a domain in your
134:23 - query like this you may also provide
134:26 - additional search domains like this so
134:28 - it would mean when i say web i mean
134:31 - web.mycompany.com or
134:32 - web.prod.mycompany.com
134:35 - so your host would try searching all of
134:38 - these domain names when you look for a
134:40 - hostname
134:41 - finally a word about record types so how
134:44 - are the records stored in the dns server
134:47 - we know that it stores ip to host names
134:50 - that's known as a records storing ipv6
134:53 - to host names is known as quad a records
134:56 - mapping one name to another name is
134:58 - called cname records for example you may
135:01 - have multiple aliases for the same
135:03 - application like a food delivery service
135:06 - may also be reached at eat or hungry
135:09 - that's where a cname record is used name
135:12 - to name mapping
135:13 - there are many more but that's all we're
135:15 - going to look at for now
135:17 - now ping may not always be the right
135:19 - tool to test dns resolution
135:22 - there are a few other tools as well such
135:24 - as ns lookup you can use ns lookup to
135:27 - query a host name from a dns server
135:30 - but remember nslookup does not consider
135:33 - the entries in the local etsy hosts file
135:36 - so if you add an entry into the local sc
135:38 - host file for your web application and
135:41 - if you try to do an ns lookup for that
135:43 - web application
135:44 - it is not going to find it
135:46 - the entry for your web application has
135:48 - to be present in your dns server ns
135:51 - lookup only queries the dns server
135:55 - the same goes with dig
135:57 - dig is another useful tool to test dns
136:00 - name resolution it returns more details
136:02 - in a similar form as is stored on the
136:05 - server in the upcoming practice
136:07 - exercises section you will practice
136:09 - viewing configuring and troubleshooting
136:11 - dns in a lab environment on actual
136:14 - systems through some fun and challenging
136:16 - exercises
136:18 - in this series of lectures we get our
136:21 - networking basics right
136:24 - we look at basic networking concepts
136:26 - like switching routing gateways etc
136:30 - we then understand dns
136:32 - we look at how to configure dns settings
136:36 - on a linux system
136:38 - so let's get started
136:41 - so what is a network we have two
136:43 - computers a and b laptops desktops vms
136:47 - on the cloud wherever
136:49 - how does system a reach b
136:53 - we connect them to a switch and the
136:54 - switch creates a network containing the
136:57 - two systems
136:58 - to connect them to a switch we need an
137:01 - interface on each host
137:03 - physical or virtual depending on the
137:05 - host
137:06 - to see the interfaces for the host we
137:09 - use the iplink command
137:12 - in this case we look at the interface
137:14 - named e0
137:16 - that we will be using to connect to the
137:18 - switch
137:19 - let's assume it's a network with the
137:21 - address 192.168.1.0
137:25 - we then assign the systems with ip
137:27 - addresses on the same network
137:29 - for this we use the command ipaddr
137:33 - once the links are up and the ip
137:36 - addresses are assigned the computers can
137:38 - now communicate with each other through
137:40 - the switch
137:42 - the switch can only enable communication
137:45 - within a network which means it can
137:48 - receive packets from a host on the
137:50 - network and deliver it to other systems
137:53 - within the same network
137:56 - say we have another network containing
137:59 - systems cnd at address 192.168.2.0
138:04 - the systems have ip address
138:07 - 192.168.2.10 and 2.11 respectively
138:10 - how does a system in one network reach a
138:13 - system in the other
138:15 - how does system be with the
138:17 - ip192.168.1.11
138:20 - reach system c with the ip 2.10 on the
138:24 - other network
138:26 - that's where a router comes in
138:28 - a router helps connect two networks
138:32 - together
138:33 - it is an intelligent device
138:35 - so think of it as another server with
138:37 - many network ports
138:39 - since it connects to the two separate
138:41 - networks it gets two ips assigned
138:45 - one on each network
138:47 - in the first network we assign it an ip
138:50 - address 182 182.168.1.1
138:53 - and in the second we assign it an ip 2.1
138:57 - now we have a router connected to the
138:59 - two networks that can enable
139:00 - communication between them
139:03 - when system b tries to send a packet to
139:06 - system c
139:07 - how does it know where the router is on
139:10 - the network to send the packet through
139:13 - the router is just another device on the
139:16 - network
139:17 - there could be many other such devices
139:21 - that's where we configure the systems
139:24 - with a gateway or a route
139:27 - if the network was a room the gateway is
139:30 - a door to the outside world to the other
139:32 - networks or to the internet
139:35 - the systems need to know where that door
139:38 - is to go through that
139:40 - to see the existing routing
139:42 - configuration on a system run the route
139:45 - command it displays the kernel's routing
139:48 - table and within that as you can see
139:51 - there are no routing configurations as
139:53 - of now
139:54 - so in this condition your system b will
139:57 - not be able to reach system c it can
140:00 - only reach other systems within the same
140:02 - network in the range 192.168.1.0
140:07 - to configure a gateway on system b to
140:10 - reach the systems on network 2.0 run the
140:14 - ip route add command and specify that
140:17 - you can reach the
140:19 - 192.168.2.0 network through the door or
140:22 - gateway at 192.168.1.1
140:26 - running the route command again shows
140:28 - that we have a route added to reach the
140:31 - 182 168 2.0 series network through the
140:34 - router
140:36 - now remember
140:37 - this has to be configured on all the
140:39 - systems for example if the system c is
140:43 - to send a packet to system b
140:45 - then you need to add a route on system
140:47 - c's routing table to access the network
140:50 - at 1.0 through the router configured
140:53 - with the ip address 2.1
140:57 - now suppose these systems need access to
141:00 - the internet say they need access to
141:02 - google at
141:05 - 172.217.194.0 network on the internet
141:08 - so you connect the router to the
141:10 - internet and then add a new route in
141:12 - your routing table to route all traffic
141:15 - to the network
141:17 - 172.217.194 through your router
141:20 - there are so many different sites on
141:23 - different networks on the internet
141:25 - instead of adding a routing table entry
141:27 - for the same router's ip address
141:29 - for each of those networks you can
141:32 - simply say for any network that you
141:34 - don't know a route 2
141:36 - use this router as the default gateway
141:40 - this way any request to any network
141:42 - outside of your existing network goes to
141:45 - this particular router
141:47 - so in a simple setup like this
141:50 - all you need is a single routing table
141:52 - entry with the default gateway set to
141:55 - the router's ip address
141:57 - remember instead of the word default you
142:00 - could also say 0.000
142:02 - it means any ip destination
142:05 - both of these lines mean the same thing
142:08 - a 0.000
142:10 - entry in the gateway field indicates
142:13 - that you don't need a gateway for
142:15 - example in this case for system c
142:17 - to access any devices in the
142:21 - 2.0 192.168.2.0
142:22 - it doesn't need a gateway because it is
142:24 - in its own network
142:26 - but say you have multiple routers in
142:28 - your network one for the internet
142:33 - another for the internal private network
142:35 - then you will need to have two separate
142:38 - entries for each network
142:40 - one entry for the internal private
142:42 - network and another entry
142:45 - with the default gateway for all other
142:47 - networks including public networks so if
142:50 - you're having issues reaching internet
142:52 - from your systems
142:54 - this routing table and the default
142:55 - gateway configuration
142:57 - is a good place to start
143:00 - let us now look at how we can set up a
143:02 - linux host as a router
143:05 - let's start with a simple setup
143:07 - i have three hosts a b and c
143:10 - a and b are connected to a network
143:12 - 192.168.1
143:14 - and bnc to another on 192.168.2
143:18 - so host b is connected to both the
143:20 - networks using two interfaces each zero
143:22 - and et1
143:24 - a has ip1821681.5
143:28 - c has 182 168 2.5 and b has an ip on
143:32 - both the networks 1.6 and 2.6
143:36 - how do we get a to talk to c so
143:39 - basically if i try to ping 2.5 from a it
143:43 - would say network is unreachable and by
143:45 - now we know why that is host a has no
143:48 - idea how to reach a network at 192.168.2
143:54 - we need to tell host a that the door or
143:56 - gateway to network 2 is through host b
144:00 - and we do that by adding a routing table
144:03 - entry
144:04 - we add a route to access network
144:06 - 192.168.2
144:09 - while the gateway 192.168.1.6
144:14 - if the packets were to get through to
144:16 - host c host c will have to send back
144:19 - responses to host a
144:22 - when host c tries to reach host a at
144:26 - 192.168.1 network it would face the same
144:29 - issue so we need to let host c know that
144:32 - it can reach host a through host b which
144:35 - is acting as a router
144:37 - so we add a similar entry into host's
144:39 - routing table this time we say to reach
144:42 - network 192.168.1.0
144:45 - talk to host b at 192.168.2.6
144:50 - when we try to ping now we no longer get
144:53 - the network unreachable error message
144:56 - that means our routing entries are right
144:58 - but we still don't get any response back
145:02 - by default in linux packets are not
145:05 - forwarded from one interface to the next
145:07 - for example packets received on each
145:10 - zero on host b
145:12 - are not forwarded to elsewhere through
145:15 - each one
145:17 - this is this way for security reasons
145:19 - for example if you had e0 connected to
145:22 - your private network and it's one to a
145:24 - public network we don't want anyone from
145:27 - the public network to easily send
145:29 - messages to the private network unless
145:31 - you explicitly allow that
145:33 - but in this case since we know that both
145:35 - are private networks and it is safe to
145:37 - enable communication between them
145:39 - we can allow host b to forward packets
145:42 - from one network to the other
145:44 - whether a host can forward packets
145:46 - between interfaces is governed by a
145:49 - setting in this system at file proc says
145:54 - net
145:54 - ipv4
145:56 - ip underscore forward
145:59 - by default the value in this file is set
146:01 - to 0 meaning no forward
146:04 - set this to 1 and you should see the
146:05 - pings go through
146:07 - now remember simply setting this value
146:10 - does not persist the changes across
146:12 - reboots for that you must modify the
146:14 - same value
146:16 - in the etsy
146:17 - syscontrol.conf file
146:20 - so let's take away some key commands
146:22 - from this lecture
146:24 - this will be handy in the upcoming
146:25 - lectures
146:26 - iplink is to list and modify interfaces
146:29 - on the host
146:31 - ipaddr command is to see the ip
146:34 - addresses assigned to those interfaces
146:37 - ipaddr add command is used to set ip
146:40 - addresses on the interfaces
146:42 - now remember changes made using these
146:45 - commands are only valid till i restart
146:47 - if you want to persist these changes you
146:50 - must set them in the etsy network
146:52 - interfaces file
146:54 - ip route or simply the route command is
146:57 - used to view the routing table
146:59 - and ip route add command is used to add
147:02 - entries into the routing table and
147:04 - finally remember the command to check if
147:08 - ip forwarding is enabled on a host if
147:10 - you are working with a host configured
147:11 - as a router
147:13 - in this lecture we will talk about ip
147:15 - addresses and ports from a web
147:17 - applications perspective so one of the
147:20 - common issues that
147:21 - we've seen students especially beginners
147:24 - struggle with while working with web
147:26 - applications are related to connectivity
147:30 - so what ip addresses do we use and what
147:33 - are port numbers and what port numbers
147:36 - to use what is the difference between
147:38 - localhost 127.0.0.1
147:41 - and the ip addresses of the server or
147:44 - why does it matter and why can't i
147:46 - access the web server from another
147:47 - system
147:48 - if there's a web server and database
147:50 - server then why is one not able to reach
147:52 - the other so things like these are are
147:54 - some of the common questions that we get
147:56 - all the time
147:57 - so now through this lecture i'd like to
148:00 - clarify all of this and going forward
148:03 - whenever you run into any similar issues
148:05 - you should be able to follow these steps
148:07 - and troubleshoot and fix issues easily
148:10 - so let's take a step back and
148:13 - understand a little bit about the basics
148:15 - of networks and ips
148:17 - so computer systems like our laptops or
148:20 - servers have different kinds of
148:22 - interfaces or adapters
148:24 - for connectivity such as wired ethernet
148:26 - interfaces to connect to a lan network
148:28 - through a hub or a switch using a cable
148:31 - and the wireless interfaces to connect
148:33 - to the network through wi-fi so
148:36 - irrespective of how they connect to a
148:38 - network once they do they get an ip
148:41 - address assigned an ip address is
148:44 - assigned to an interface
148:46 - in this case we have a laptop that's
148:48 - connected using an ethernet cable 2s
148:51 - switch in our home
148:52 - once the connection is established our
148:55 - laptop gets an ip address assigned to it
148:57 - on the network
149:00 - when you run the
149:02 - ip address show command you see the
149:04 - interface enp0s3
149:07 - has the ip address 10.0.2.15.
149:13 - now say you have another adapter a wi-fi
149:15 - adapter and you attach that to the same
149:18 - network but this time through a wi-fi
149:21 - then that interface gets another ip
149:24 - address assigned to it and can be seen
149:26 - in the output of the same command
149:29 - the same laptop now has two separate ip
149:33 - addresses on the same network
149:35 - so if any other host in the network were
149:38 - to try to reach our laptop they may do
149:41 - so using the any of these ip addresses
149:45 - each of these network interface cards
149:47 - are divided into multiple logical
149:49 - components known as ports
149:52 - now you can have up to 65
149:55 - 535
149:56 - ports on each ip address each port is a
150:00 - communication endpoint programs can
150:02 - listen on these ports for requests so
150:05 - when you run a web server it listens for
150:08 - requests on these interfaces on one of
150:10 - these ports
150:12 - for instance a python
150:14 - flask web server listens on port 5000 by
150:17 - default now you can change that by
150:20 - specifying the
150:21 - port number as a parameter inside the
150:24 - run call like this
150:26 - we have now configured the application
150:28 - to listen on port 8000 but on what ip
150:32 - address and we have two ip addresses
150:34 - configured on our host
150:35 - the port on which of these interfaces or
150:37 - ip addresses is the application going to
150:40 - listen on
150:41 - you can also specify the ip address on
150:44 - which the server should listen on using
150:46 - the host option like this
150:48 - the application now listens on ip
150:51 - 10.0.2.15 on port 8000 so anyone trying
150:55 - to access my application on this ip
150:58 - address and port will be able to view my
151:00 - server however they won't be able to
151:02 - access the server on the other interface
151:05 - on ip 10.0.2.16.
151:08 - so what if i want my application to be
151:11 - available through both these ips then
151:14 - instead of specifying the ip address of
151:17 - a single interface you must specify
151:21 - 0.0.0.0 in that case the server will
151:24 - listen on all available interfaces
151:27 - we now have our application available on
151:29 - all interfaces and anyone can access it
151:33 - what if we are not ready
151:35 - yet to make it available to the external
151:38 - world for example
151:40 - we are only developing our application
151:42 - and don't want
151:43 - anyone else to access it except for
151:46 - maybe ourselves from within our laptop
151:49 - in that case remove the host
151:51 - specification in the application run
151:53 - call
151:55 - but when we do that it does not listen
151:57 - on any interface so then how do we test
152:00 - it by ourselves if it's not available on
152:02 - any interface what i p do we use in a
152:05 - browser to access our application
152:08 - when no option is specified the server
152:10 - listens on ip127.0.0.1
152:15 - by default
152:16 - this is known as the loopback address
152:19 - apart from the two interfaces we talked
152:21 - about earlier
152:22 - every host has a built-in virtual
152:25 - interface known as the loopback address
152:29 - the information about this interface is
152:31 - also visible under the
152:34 - output of the ip address show command
152:36 - its name is hello and the ip assigned is
152:40 - 127.0.0.1
152:43 - every host has this loopback interface
152:46 - built into it and all of them have the
152:48 - same ip address set on it 127.000
152:52 - when you refer to the ip127.0.0.1
152:56 - it is like referring to yourself it's
152:59 - like saying i me or myself
153:02 - anything you send to ip127.0
153:07 - is sent to the same host
153:09 - nothing sent to this address leaves the
153:12 - host system
153:13 - so from within your host if you wish to
153:15 - test your application you can simply
153:18 - open up a browser and type in
153:21 - 127.0.0.1 followed by the port at which
153:24 - the server is listening to access the
153:26 - web server
153:28 - now instead of typing in the ip address
153:30 - you can also say localhost because
153:33 - localhost is the standard network name
153:36 - associated with the loopback ip address
153:39 - and that also means that you cannot
153:41 - access this web server from any other
153:44 - host other than this host
153:46 - the 127.
153:48 - ip address is an ip address used to
153:52 - refer to this host from only within this
153:55 - host
153:57 - every other host has their own
154:00 - internal loopback interface with the
154:02 - same ip address of
154:05 - 127.0.0.1 and if you try to access the
154:08 - web server using this loopback ip
154:10 - address from the second host you won't
154:12 - be able to connect to the first host it
154:14 - look for a web server on its own host
154:17 - which does not exist so the request
154:19 - fails
154:20 - so remember that this particular ip
154:22 - address or the host name localhost refer
154:25 - to the local host itself and it can only
154:27 - be reached from within that host well
154:30 - that's it for now head over to the labs
154:32 - and practice working with
154:34 - ip addresses and ports and i will see
154:36 - you in the next lab
154:42 - hello and welcome to this lecture in
154:44 - this lecture we take a look at what yaml
154:47 - files are
154:48 - if you are familiar with yaml already
154:50 - feel free to skip this section and head
154:52 - over to the next section
154:54 - if you have not worked with yaml in the
154:56 - past i would highly recommend going
154:58 - through this because the rest of the
155:00 - course depends entirely on yaml
155:04 - if you have worked with other data
155:05 - structure formats like xml or json you
155:09 - should be able to easily pick it up
155:11 - don't worry if you haven't worked on any
155:13 - of these you should still be able to
155:14 - easily pick it up going through the
155:16 - coding exercises that accompany this
155:18 - course
155:21 - a yaml file is used to represent data in
155:24 - this case configuration data
155:26 - here is a quick comparison of a sample
155:29 - data in three different formats the one
155:32 - on the left is xml where we display a
155:35 - list of servers and their information
155:38 - the same data is represented in json
155:41 - format in the middle and finally in yaml
155:44 - format to the right
155:46 - take a minute to compare the three
155:47 - formats
155:58 - let's take a close look at yaml
156:01 - if you take the data in its simplest
156:03 - form such as key value pair
156:06 - this is how you would define it in yaml
156:09 - key and value separated by a colon
156:12 - the keys are fruit vegetable liquid and
156:16 - meat and the values are apple carrot
156:19 - water and chicken
156:22 - remember you must have a space followed
156:24 - by a colon differentiating the key and
156:28 - the value
156:29 - let's take a look at how an array is
156:31 - represented
156:32 - we would like to list some fruits and
156:35 - vegetables we would say fruits followed
156:38 - by a colon on the next line enter each
156:41 - item with a dash in the front
156:43 - the dash indicates that it's an element
156:46 - of an array
156:48 - how about a dictionary
156:50 - a dictionary is a set of properties
156:53 - grouped together under an item
156:55 - here we try to represent nutrition
156:57 - information of two fruits
157:00 - the calories fat and carbs are different
157:03 - for each fruit
157:05 - notice the blank space before each item
157:09 - you must have equal number of blank
157:11 - spaces before the properties of a single
157:13 - item so they are all aligned together
157:21 - let's take a closer look at spaces in
157:23 - yaml
157:24 - here we have a dictionary representing
157:26 - the nutrition information of banana
157:29 - the total amount of calories fat and
157:32 - carbs are shown
157:35 - notice the number of spaces before each
157:37 - property that indicates these key value
157:40 - pairs fall within banana
157:42 - but what if we had extra spaces for fat
157:45 - and carbs
157:47 - then they will fall under calories and
157:50 - thus become properties of calories which
157:53 - doesn't make any sense
157:55 - this will result in a syntax error which
157:57 - will tell you that mapping values are
157:59 - not allowed here because calories
158:01 - already have a value set which is 105
158:05 - you can either set a direct value or a
158:07 - hash map you cannot have both
158:10 - so the number of spaces before each
158:12 - property is key in yaml you must ensure
158:16 - they are in the right form to represent
158:18 - your data correctly
158:24 - let's take it to another level
158:26 - you can have lists containing
158:28 - dictionaries containing less
158:30 - in this case i have a list of fruits and
158:33 - the elements of the list are banana and
158:35 - grape but each of these elements are
158:38 - further dictionaries containing
158:40 - nutrition information
158:45 - a lot of students
158:47 - new to yaml have reached out to me
158:49 - asking when to use a dictionary or a
158:52 - list
158:53 - so let me explain this a little bit
158:55 - better
158:56 - first of all it is important to
158:58 - understand that all of what we discussed
159:01 - so far such as xml json or yaml are used
159:05 - to represent data
159:07 - it could be data about an organization
159:10 - and all of its employees and their
159:11 - personal details or it could be data
159:14 - about a school and all of its students
159:16 - and their grades or it could be data
159:19 - about an automobile manufacturing
159:21 - company and all of its cars and its
159:24 - details
159:25 - it could be anything
159:27 - let's take an example of a car
159:30 - a car is a single object and it has
159:33 - properties such as color model
159:36 - transition and price
159:38 - to store different information or
159:40 - properties of a single object
159:43 - we use a dictionary
159:45 - in this simple dictionary i have
159:47 - properties of the card defined in a key
159:50 - value format
159:52 - this need not be as simple as this for
159:55 - example in case we need to split the
159:57 - model further into model name and make
160:00 - ear
160:01 - you could then represent this as a
160:04 - dictionary within another dictionary in
160:07 - this case the single value of
160:09 - model
160:10 - is now replaced by a small dictionary
160:13 - with two properties
160:15 - name and ear
160:17 - so this is a dictionary within another
160:20 - dictionary
160:23 - let's say we would like to store the
160:24 - name of six cars
160:26 - the names are formed by the color and
160:28 - the model of the car
160:30 - to store this we would use a list or an
160:33 - array as it is multiple items of the
160:36 - same type of object
160:38 - since we are only storing the names we
160:41 - have a symbol list of strings
160:46 - what if we would like to store all
160:48 - information about each car everything
160:50 - that we listed before such as the color
160:53 - model transition and price
160:56 - we will then modify the array from a
160:59 - list of strings to a list of
161:02 - dictionaries
161:03 - so we expand each item in the array and
161:06 - replace the name with the dictionary we
161:09 - built earlier
161:11 - this way we are able to represent all
161:13 - information about multiple cars in a
161:16 - single yaml file using a list of
161:20 - dictionaries
161:28 - so that's the difference between
161:31 - dictionary list and list of dictionaries
161:35 - i hope you understood the difference
161:36 - between the three and when to use each
161:39 - of these
161:42 - before we head over to exercises let's
161:44 - take a look at some key notes
161:47 - dictionary is an unordered collection
161:49 - whereas lists are ordered collection so
161:52 - what does that mean
161:54 - the two dictionaries that you see here
161:56 - have the same properties for banana
161:59 - however you can see that the order of
162:01 - properties fat and carbs do not match
162:04 - in the first dictionary fat is defined
162:07 - before carbs and in the second
162:08 - dictionary carbs comes first followed by
162:11 - fat
162:12 - but that doesn't really matter the
162:14 - properties can be defined in any order
162:17 - but the two dictionaries will still be
162:19 - the same as long as the values of each
162:21 - property match
162:24 - this is not the same for lists or arrays
162:27 - arrays are ordered collection so the
162:29 - order of items matter
162:31 - the two lists shown are not the same
162:34 - because apple and banana are at
162:36 - different positions
162:38 - this is something to keep in mind while
162:40 - working with data structures
162:44 - also remember any line beginning with a
162:46 - hash is automatically ignored and
162:49 - considered as a comment
162:56 - we are now ready to head over to the
162:57 - coding exercises and have fun playing
163:00 - with yaml files
163:03 - well you have reached the end of the
163:05 - devops prerequisites course
163:07 - congratulations you now have enough
163:10 - knowledge to get started with any of the
163:12 - devops and cloud courses out there
163:14 - you'll now be comfortable working with
163:16 - linux systems basic applications basic
163:18 - networking yaml and other configuration
163:21 - files so what's the next step
163:24 - you have now completed the devops
163:26 - prerequisites course in the get your
163:28 - basics rights section
163:30 - the other course available in this
163:31 - section is the linux basics course
163:34 - linux plays a key role in the devops and
163:36 - cloud world so it's always helpful to
163:39 - get real good hands-on experience
163:41 - working with linux systems our linux
163:43 - basics course is a good start and it's
163:45 - an engaging and fun course developed in
163:48 - a story format and with lots of hands-on
163:50 - labs as you did in this course
163:52 - to start your journey with containers
163:54 - and the cloud native world get started
163:56 - with the docker for the absolute
163:58 - beginners course
163:59 - it's a course that will help you get a
164:01 - good understanding of the importance of
164:03 - containers and the role of docker in the
164:05 - cloud native computing world
164:07 - this course will pave way to the
164:09 - kubernetes for beginners course
164:11 - knowledge about container native
164:12 - technology like docker is a prerequisite
164:15 - for learning kubernetes
164:16 - kubernetes is one of the most trending
164:18 - technology in it industry as of today
164:21 - and it's a very in-demand skill
164:23 - once you complete the beginner's course
164:25 - you can target the kubernetes
164:27 - certifications like cka and ckad
164:31 - our courses have labs and multiple mock
164:33 - exams that will help you clear
164:35 - certification easily kubernetes is a
164:37 - prerequisite for red hat open shift
164:39 - after completing the ckad course where
164:42 - you'll learn how to configure and deploy
164:44 - applications on kubernetes
164:46 - you can then proceed to the red hat open
164:48 - shift course
164:51 - in the automation category start with
164:52 - the most popular automation tool
164:55 - ansible our ansible for the absolute
164:58 - beginners course is targeted for those
165:00 - who have zero experience in automation
165:02 - or scripting with this course you will
165:04 - be able to implement automation
165:06 - solutions without any experience in
165:08 - coding no coding or programming
165:10 - experience required
165:12 - in fact none of these courses require
165:14 - any kind of coding or programming
165:16 - experience whatever you have learned in
165:18 - this devops prerequisites course
165:20 - is sufficient to go through any of these
165:22 - courses
165:23 - you may choose to learn other systems
165:25 - like puppet and chef as well
165:28 - the ansible for the absolute beginners
165:30 - course will also help you prepare for
165:32 - the ansible certification exam
165:34 - and we plan to have a lot more courses
165:37 - added to this path in the future so
165:40 - check out this page whenever you get
165:41 - time
165:42 - we also have the code cloud engineer
165:45 - program that will help you
165:47 - get more hands-on experience this is a
165:50 - simulated job environment that you can
165:52 - enroll
165:53 - for free and start while getting tasks
165:56 - assigned to you
165:57 - for more details check out
165:59 - engineer.codcloud.com
166:01 - well that's it for now thank you so much
166:03 - for joining me in this course and i hope
166:05 - to see you in our next courses