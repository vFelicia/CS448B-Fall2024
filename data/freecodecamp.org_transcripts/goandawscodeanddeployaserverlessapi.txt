00:00 - The Gold programming language can be 
used to deploy serverless stacks to AWS  
00:04 - in this course. Akhil Sharma will 
teach you how to code and deploy  
00:08 - a complete serverless stack with basic CRUD 
functions on AWS using go. This is a complete  
00:15 - serverless stack. Right, so you're using DynamoDB 
serverless, you're using lambda serverless again,  
00:22 - and then we'll be using API gateway again, 
serverless. Now API gateway helps us  
00:27 - enables anybody across the world to interact 
with our lambda function, right. So we'll be  
00:31 - deploying all these three things. From the AWS 
console, right, we'll be using the AWS console,  
00:37 - and then we'll make settings for all these three 
things. And we'll deploy all of this. And anybody  
00:42 - across the world can use our lambda function. So 
this is more like a real world scenario. So I'm  
00:48 - in a terminal now. And you don't really have to 
keep this project in your go route. Because it's  
00:54 - Golang. One point 12. And anyways, they had, 
you know, go mod in it, which we're going to  
00:58 - do anyways, out here, go modern, it takes care 
of everything. I mean, you don't have to really  
01:02 - do anything manually. Alright. So here, we will 
say, we will make a directory first we will say,  
01:08 - Go server less, and YT. Alright, and we'll 
cd into this. Go serverless tack YT. For yt  
01:16 - is basically YouTube, I'm making this project for 
YouTube specifically. Alright, and here, I'll say  
01:22 - go mod in it. And which is basically 
github.com/akil/go server less. So that's  
01:35 - my project. It's initialized go mod for me, go 
mod is basically like my package json file. If  
01:40 - you're from a Java background, it will have all my 
dependencies for me, you know, easily listed out.  
01:46 - So now what I can do is I can just open this 
project up, and code editor, which is VS code,  
01:56 - in my case, just as a pointer, right, I'm using 
windows inside Windows, I have something called  
02:03 - as WsL. Inside that I'm using Ubuntu 20.04. And I 
use multiple different versions of open to write  
02:09 - Stan this for this particular video I'm using 
over in 20.04. And in my open 20.0. For instance,  
02:16 - I have VS code setup. Alright. Now, I don't 
want to install a lot of extensions for calling  
02:24 - because I know when I'll start typing, I'll start 
writing a lot of code. I'll make some mistakes,  
02:29 - right with Golang. I'll make some mistakes, but 
I will fix them. But don't worry, I don't have  
02:33 - extensions, because I don't want to like start, 
you know, ballooning up my instance. Because  
02:38 - this is just one of the instances that I use. On 
my Windows PC. For over two, I have, like 1015  
02:44 - different versions of Uber, right. So if you need 
to go line, by the way, main.go file is your main  
02:51 - file right in the project. And this is how you 
start to main.go file, you say package main and  
02:56 - you say import. And because you'll import some 
packages, right? Not everything you'll have.  
03:02 - Inside go Lang go. Lang is very modular, you have 
to install a lot of external packages, and a lot  
03:06 - of, you know, packages that come with coal, and 
you have to specifically tell that, you know,  
03:10 - this package from cola. And so the the third party 
packages that we'll be using will be mostly around  
03:18 - lambda. Alright, so we'll talk about them in a 
while. And then the most important thing here  
03:25 - will always be func main, because that's 
your entry point into the program,  
03:29 - right, the func main. Now, before I start 
writing anything in main.go file, what I'll  
03:34 - do is I'll just try and create, like a very simple 
project structure, I need the build folder, right,  
03:42 - because I'm going to keep my build of this 
entire project in my build folder. And that's,  
03:45 - I'm going to zip it up, and then I'm going 
to keep take that zip file to my lambda,  
03:50 - sorry, my AWS lambda console. Alright, 
so that's why I need the build folder.  
03:54 - And I need my CMD folder, because that's where I 
usually keep my main not sorry, not in the build,  
04:00 - but in my CMD folder, I keep my main.co file. 
Alright, and then you will have a package folder.  
04:09 - So if you work with Golang, before this, like 
the very standard kind of structure, right,  
04:14 - nothing, nothing new. So package will, 
as you already know, will have handlers,  
04:19 - right handlers to handle the API's. And then 
you will have I'll have a folder for user.  
04:26 - I'll explain to you why I'm doing 
that. And then I have a very simple  
04:30 - validation functions where I'll keep that in 
a folder called validators. validators. Sorry.  
04:37 - That's it. Yeah, so in validators, I will 
have just one little file of Pedley like  
04:45 - five, six lines of code, I think. It's just 
going to be as email valid just to check if  
04:49 - my email is valid for the user. And here in my 
user, I'll have a file called user.co. Alright,  
04:59 - and my handler That's where my main logic 
resides. So this is a very short, very small  
05:03 - project handlers, I'll just have two files, 
I'll have API response.go, because I need this  
05:11 - file for my API gateway, I'll build it, you'll 
understand what it is. And then it's handlers.co.  
05:20 - Right? Now, my user.go file is kind of a 
combination of my models, and my, almost like my  
05:31 - controllers as well, you know, so I have handlers. 
But you know, user.go file will have a lot of  
05:37 - code, which kind of which talks my database, 
alright, directly talk to my database. So  
05:42 - I'll have those models like those structs as well, 
at the same time, we'll have model functions,  
05:46 - those. So database functions at the same time, 
I'll head over to your main go file. And func  
05:51 - main, I think what I'll do is I'll start 
with this place, right, once I was taught,  
05:59 - get environment AWS region. So AWS region 
is very important, because that's where your  
06:07 - lambda will go and set. Right. So with 
AWS, if you've worked with AWS a lot,  
06:12 - you know that he has different regions, right. So 
my particular AWS is considered configured with  
06:17 - India, which is Asia Pacific South one. So 
if you have been using the CLI and setup is,  
06:22 - it'll be amazing. Otherwise, also, I don't 
think you should have a problem, right.  
06:27 - But just try and just try and set up a CLI. 
It's very easy, just a five minute process.  
06:32 - And it will be very simple for you to follow 
along with all of my other videos as well,  
06:36 - because in my other videos, it's a 
prerequisite. So how do you create a session?  
06:43 - So you will say session dot new session. 
Now, if I'm calling this old, who is  
06:53 - here, right, so I need to have us here. That's the 
package, right? And if I'm calling session here,  
06:58 - session is something that AWS lambda gives me, 
AWS gives me sorry, so I'll say github.com/now.  
07:05 - Looking at the documentation for the AWS packages, 
at the same time, you can do that otherwise,  
07:11 - in case you're the type of person who wants to, 
like know exactly which package you're installing,  
07:16 - because I'm that type of person, I want to install 
any extra packages, right. So if you're like me,  
07:21 - you, you might want to open up, just like 
I've done, you might want to open up the  
07:26 - AWS SDK, it's called so I'll say AWS 
slash AWS SDK for go, you want to,  
07:32 - we want to open up the documentation. And 
here you'll see it will just slash session.  
07:39 - Alright, and to create the new 
session, you will say AWS dot config  
07:53 - and the bracket which will be curly braces 
bracket, you will say region, AWS taut  
08:02 - string and say that you'll 
pass the region alright.  
08:19 - Alright, right. And then, as you know, with 
all everything to do with Golang, whenever we  
08:26 - haven't, we get two things usually right, 
we get the thing that we're looking for,  
08:30 - which is the earpiece session which will come 
from the session function, right, or sorry,  
08:34 - the new session function, which is a part 
of the session package that we have here.  
08:40 - And we get the error. So with go Lang, 
you have to like keep handling errors,  
08:46 - and this is a very neat and clean way of handling 
errors because at every stage you know where that  
08:51 - is coming from and you can handle it there itself. 
So if there's an error just return right and  
08:57 - I want to create a variable called 
Dinah client which for my DynamoDB and  
09:06 - dot new and how you create a 
new client will say AWS session  
09:14 - perfect which you just created out here. So 
you've created the session and then we'll say  
09:20 - lambda dot start and handler. So this you may not 
understand right now not a problem. So firstly,  
09:30 - we want DynamoDB How do you get DynamoDB you get 
it like this, it'll say github.com/aws/aws SDK go  
09:40 - slash service slash Dynamo DB. Alright, 
so you have session you have DynamoDB and  
09:54 - you want AWS itself and the first place we will 
say github.com slash AWS SDK co slash class.  
10:08 - To get this lambda function or sorry, the lambda 
package, which has the Start function, you need  
10:17 - the Start function, or you will do is you'll 
say github.com/aws/aws Lambda go slash lambda.  
10:31 - Cool. So far, so good. That's what I needed, you 
know. And I need something called as the handler,  
10:43 - which we'll talk about. Okay, 
for now, I'm creating a constant  
10:53 - called table name. Stable name is 
lambda user. I'll say lambda in go user.  
11:06 - And now it's time to create my handler, 
which is this basically. So I'm passing  
11:12 - by handler there. In my handler, 
what I'm doing is, I have a request.  
11:20 - Basically, I accept some things right. And this 
function, and I return some things, and it has  
11:25 - some definition. So what does it accept? 
It accepts events dot API, Gateway  
11:34 - proxy. requests. So you're wondering what's 
events? Right? So events is basically what?  
11:48 - Go Lang. lamda will give us so I'll come 
here. And I'll say github.com/aws/aws,  
12:03 - lambda go slash events. Perfect.  
12:15 - And the other thing that this 
accepts is star events dot API.  
12:25 - Okay, to a proxy response. Sorry, I meant that 
this it accepts a request, returns a response.  
12:38 - I'm not sure what I said actually, before that. 
What I'm trying to say here is that, you know,  
12:43 - this is a function that accepts something and 
it turns something, obviously accepts requests,  
12:47 - obviously returns a response, right? No 
complication there. That's what you want to do.  
12:53 - And what you will do here is you will switch 
the HTTP method. So you'll say switch,  
13:00 - insert request dot HTTP method. So what are 
the methods that you have you have get POST,  
13:07 - PUT and DELETE? That's all you have. So 
for every single different history method,  
13:15 - we want to call a different function. How do you 
do that? So you'll say switch. So we've already  
13:20 - switched, right? We already switched. It's 
like, it's 830 here, so I'm kind of sleepy.  
13:27 - I usually get sleepy at 11pm. But somehow, I am 
sleepy earlier, because I woke up really early.  
13:33 - I've joined this martial arts class that that, 
you know, gets me to wake up at 5am these days. So  
13:44 - so you'll have something 
called as handlers. Right?  
13:48 - And where will those handlers come in 
from it's basically these handlers that  
13:52 - you want to import. So which are basically your 
own creation, your you know, the handlers or your  
13:58 - own creations will say github.com/kill/go 
server less, righty slash packets slash  
14:09 - handlers.  
14:14 - Cool. So you're saying to go Lang is that 
this is my project github.com/search Go to go  
14:22 - serverless whitey? And say that I have a 
folder called package instead of I have a  
14:27 - package called handlers. Right? And handlers 
the file. On top of that file will say package  
14:37 - handlers and it belongs to the handlers 
folder, then go Lang understands, okay,  
14:41 - this is what we're talking about. Alright. That's 
the format. I mean, though, the folder name  
14:44 - and the package name have to be the same. Just 
letting you know, in case you didn't know that.  
14:51 - I mean, I'm pretty sure you knew that, but I'm 
just making sure right. So you have requests table  
14:58 - name and Dinah client Right, so you sent this to 
this function called handlers dot get user, which  
15:04 - we'll work on in a while. So that was your case 
get. Now you have more cases, right you have,  
15:11 - depending on the HDB method, so you have post, 
you will have put, and you'll have Delete. For  
15:26 - post, you'll see return handlers dot create. User. 
Again, you'll pass request comma, table name,  
15:36 - comma Dyna client. For put you'll pass written, 
and lawyers dot update user request comma, sorry,  
15:49 - request comma, table name, comma, diner client. 
And for delete, process two handlers dot delete  
16:01 - user. And same thing as you pass 
the same things comma, Dinah client.  
16:08 - And after delete, you will just give it a default. 
If you work with case switching case statements,  
16:16 - you obviously know this default, right? And try to 
keep the orientation same. It won't affect it. But  
16:25 - just as a good habit, you know, I mean, I don't 
do it many times. But I try to do it these days.  
16:36 - Alright. So by default, you want to call 
this function called unhandled. Method,  
16:44 - which is again in your handlers file or handlers 
package. And this is the entire picture. I mean,  
16:51 - I don't think we're missing anything. We have the 
OS package down here, we have events lambda AWS  
16:57 - session DynamoDB. Yeah, there's one more package. 
Actually, if you look at the AWS SDK, document,  
17:05 - then you want to import it was SDK, go slash, 
service slash DynamoDB slash Dynamo DB I face.  
17:20 - Just keep these packages. And what I think we 
should do is we should just say go mod tidy.  
17:30 - So we'll get us all the package 
that we've just talked about.  
17:34 - And usually, like many times I do this at the end 
of the end of the video, right? But this time,  
17:39 - I'm just doing it beforehand itself, because many 
people they can start freaking out, Hey, you're  
17:44 - installing all these packages? If not, you've not 
run the command go might go more tidy. Or you're  
17:49 - making so many mistakes, man while typing. Why 
don't install some extensions, I've explained to  
17:54 - you why don't why don't install extensions, right. 
So, so with Golang, I mean, what happens is that,  
18:00 - you know, we usually come from JavaScript 
kind of a background, and then we think that,  
18:04 - oh, you know, if you're making all these 
mistakes, and the complete program will crash, and  
18:09 - it will be difficult to solve it with go Lang. 
Golang is very different from other programming  
18:12 - languages, right? Make as many mistakes as 
you want. And once you run the program, Golang  
18:20 - will really handle everything for you will tell 
you which line, what's the problem, it's quite  
18:24 - intelligent. Right? It's not like your regular 
other programming languages like JavaScript.  
18:35 - So here, one thing that we missed out was to 
create the data client in the first place,  
18:40 - right, so the client has in the variable, and the 
defining the type of variable the data client is,  
18:47 - so what type of time they will 
be. That's why we will use this  
18:51 - or maybe ifs, right, we'll say dot Dynamo.  
19:00 - Dynamo DB. API. Just make sure 
you get this right. All right.  
19:10 - So that's your main file, 
your main file is complete.  
19:14 - And now you want to start handling handlers. So 
here, since these two files belong to the same  
19:21 - folder, call handlers. We wanted to both to be 
package handlers. Right? So we'll say, package  
19:31 - handler yours. Right. That's clear. Now, I'm 
hoping and after writing the package, you say  
19:38 - import and then you have your main function for in 
this case, this the main function of this file is  
19:47 - called API response, accepts some things, return 
some things and has a function definition.  
19:58 - What does it accept accepts status, which 
is int and body, which has an interface.  
20:09 - What does it return? It returns the event start, 
API gateway proxy response, comma error. All  
20:26 - right. For importing, you'll say and 
coding slash JSON github.com/aws/headress,  
20:43 - lambda Gqo slash events. Okay. All we're 
doing with this is basically defining  
20:57 - the response, right? So we'll say response 
is equal to events dot API gateway response.  
21:09 - And the response, you're just setting the headers. 
Pretty standard. Because the way we're going  
21:20 - to set up these headers are something that we've 
already seen so many times. It's basically content  
21:24 - type and application JSON. So we're saying that 
we're returning JSON from our lambda function,  
21:33 - write nothing out of the ordinary. So we'll say 
response dot status code is equal to status.  
21:46 - And so basically, you're like 400, or 300,  
21:51 - or something like that. And then you'll 
say String body comma JSON dot Marshall.  
22:03 - So you're, if you've been with Golang, you 
already know it's marshalling and marshalling and  
22:07 - marshalling sorry, is Golang, doesn't understand 
JSON on its own. So it needs the help of  
22:14 - JSON marshalling, which is part of this encoding 
slash JSON package. And so whenever you send  
22:21 - some JSON, from postman into post postman, or 
maybe terminal, wherever you send some JSON,  
22:29 - it basically we want coolant to understand it, 
and also the information that Golang produces  
22:35 - for it to become JSON, and send it as a 
response that also needs, you know, help,  
22:41 - go Lang itself with boats. So that's what's called 
marshalling and unmarshalling. There are hundreds  
22:45 - of videos about it. On YouTube, you can check 
it out, nothing fancy or nothing complicated.  
22:52 - You have to do that in, you know, almost all the 
other languages, right, which are not JavaScript,  
22:56 - which is like basically, Java and Python, all 
these languages, you have to do something like  
23:00 - that, right? Because any language that's not 
JavaScript does not understand JSON, by default,  
23:06 - because JSON is JavaScript Object Notation. 
So this is your API response to go. Alright,  
23:13 - that's it. I mean, there's nothing much going on 
here in this file. But the other file in handlers,  
23:22 - package handlers, this is where we're 
going to spend some time because  
23:27 - obviously, there will be a lot going on 
here, right. So the main functions that  
23:34 - usually will be there will be based on our main go 
file. So main, go File requires get user function,  
23:40 - create user, update, user, delete user and 
anonymous method. unhandled method, sorry.  
23:44 - So these are the functions that obviously that 
you need to create, right? So we'll say get user.  
23:53 - And he will say Create User. He will say 
Update user and delete users. Update user  
24:13 - and delete user. Alright, so here. The 
last function that we want to keep here  
24:21 - is unhandled. Method. Right? So for let's 
say, if somebody uses the patch method,  
24:29 - because we're handling, get POST, PUT, delete, 
if somebody uses patch, then we'll say that, hey,  
24:35 - it's not handled, right. So 
we'll say unhandled method,  
24:39 - except some things return some things and 
so, function definition. Alright, so this is,  
24:46 - in general, this is how your handles file is 
going to be like. And what we can do is we can  
24:54 - work on our is email validated, valid 
file So we'll say package validators.  
25:05 - And there's a package that you get with 
go Lang. It's called regular expressions.  
25:12 - And we're just creating a simple function where 
we just saying if the email is valid or not,  
25:18 - right, really simple. All it 
does is accepts an email string.  
25:26 - And returns a Boolean, like, true or false.  
25:32 - We'll take a variable called Alex email, we'll use 
the like expression, regular expression package.  
25:38 - And if you look at the regular expression 
documentation, like I have in front of me,  
25:43 - go to the Golang official documentation and 
check out dragon regular expression package,  
25:48 - I highly recommend you to open it if you 
want, because that's what I've done out here,  
25:51 - in my other screen will use the 
function called must compile.  
26:00 - And I'm going to copy and paste 
a regular expression string here.  
26:06 - You don't really need to understand what 
this does, you just get it directly from the  
26:12 - documentation. But if you really want to 
know, basically, you're just checking if  
26:16 - you know the numbers are between A to Zed A to 
Z, and zero to nine, that kind of stuff, right?  
26:21 - That's all it's doing. And it's 
also checking for at at symbol.  
26:25 - Right. But obviously, if it's anywhere, it needs 
to have an ad, right. So those kind of things,  
26:30 - just basic email validation check is happening 
out there, do check out the regular expression  
26:36 - document if you want to really understand 
what this regular expression does, alright.  
26:40 - But if you want to save time, just 
copy and paste it like I just did.  
26:44 - And now we want to check the length of email. 
If email, if another female doesn't three, or  
26:54 - length of email is more than 254 or 
Arex, email variable, not match string.  
27:11 - Then you'll just return false. Right, 
so this returns either true or false.  
27:16 - If these conditions are not met, then you return 
false otherwise, you return true, that means  
27:21 - everything is fine. And email is valid. Right? 
Obviously, if this is not proper, it's not working  
27:27 - properly. If length is more length is less, 
we'll say that the email is not valid. Otherwise,  
27:33 - I will say to you can change these numbers as 
you want. But I've kept them to be three and 254.  
27:38 - All right, change it on your test. So now we'll 
go to our user.go file. And we'll just add a very  
27:46 - 10,000 feet level, I'll just set up this file. Now 
what I want should happen is that for my handlers,  
27:54 - like domain control, you know what that will go to 
the main file to our, you know, to this function,  
27:59 - basically. And this function is calling the Get 
User function and create user function update  
28:03 - user. And all these functions are, as you know, 
mentioned in the handlers, right. And from the  
28:07 - handlers from handlers, you will call the 
functions in your user.go file. And these  
28:11 - functions will be actually the database functions 
that actually talk to the database, right. So  
28:16 - every function that you have here, except for 
the unhandled method, because it doesn't do much,  
28:20 - these four crud functions that we have, they 
have an equivalent function in your user.co file,  
28:26 - a complete like one to one function in your user 
go file that talks to the database. Alright,  
28:31 - so let's do that. Let's create those functions. 
So firstly, as you know, when we start off a file,  
28:37 - we import some things. And then here, I'll 
also want to define some variables, some  
28:42 - errors that I want to define. So the functions 
that I want to have here and my user.go file,  
28:49 - which will have one to one 
relationship with these four functions,  
28:52 - the first function will be called I'll 
call it fetch user. So that means is  
29:01 - my Get User function gets called My handlers. 
And this function will call in my user.go file,  
29:06 - the fetch user function, which directly 
gets the user from the database itself,  
29:10 - the database, in this case being DynamoDB. 
Alright, so it accepts some things,  
29:15 - return some things and has a function definition 
simple. The second function I want to have is  
29:20 - for getting multiple users actually, so 
I'll say func fetch users. Similarly,  
29:33 - will look very similar. Then I want to have 
a create function. So we'll have create user  
29:42 - and then it has update user you just have to keep 
looking here and then creating these functions.  
29:59 - Then you have the law as well as delete 
user, right, so you will come here  
30:11 - right, if it doesn't get deleted, then you 
don't have to return anything specific special,  
30:15 - you can just return an error. That's why 
from the return here is just an error.  
30:21 - Right? And that's about it. So we have managed 
to one functions, all of these, but one extra  
30:27 - function is there is just fetch users. Alright, 
so we'll see where to get where to use it.  
30:33 - So from a 10,000 feet perspective, this is your 
user.go file, and this is your handlers file.  
30:39 - So what we'll do is we'll start with Nora handlers 
function, and then at the same time, we'll start  
30:42 - working on our user.co functions. And here, 
you'll all obviously, import some things, right.  
30:54 - The first thing that I need is net slash 
HTTP. Then I need my lambda event. So I'll say  
31:00 - github.com/ad/aws, lambda go slash events. Now, 
it's possible that I'm importing these, but you're  
31:10 - not understanding why I'm importing these. So you 
might get confused. So now there are two ways to  
31:14 - do it. One is when I'm actually writing the code, 
and then I use this events packet somewhere,  
31:19 - and then I come in come up and you know, import 
it. Or I know, you know which ones I need. So  
31:24 - I'll just import them right in the beginning 
itself. So they can use them later on. So I'm just  
31:29 - doing this. So try not to get confused, because 
we'll actually be using these packages in just  
31:34 - like two, three minutes. Don't worry, you know 
why we are importing them, we will reuse it. So  
31:41 - please be patient.  
31:44 - Slash AWS. Right. So these are the same package 
that we already use in our main.go file.  
31:53 - And we'll say github.com/aws/check it go slash 
service slash, no DB slash Dynamo DB I face.  
32:08 - Great. One thing that I need here, because I would 
want to call these functions, like I told you,  
32:15 - right, I want to call this function. So that's 
why I want to import this user package and my  
32:20 - handlers file. How would I do that? I would say 
github.com/achill/go, server less writing slash  
32:35 - package, slash user. So inside package inside 
the user package, we've inputted it here.  
32:47 - Alright, and then before I get started, these 
functions I want define a very variable called  
32:53 - error method not allowed. Is equal to method 
not allowed? And why do I need to create this?  
33:09 - Because firstly, we'll be working 
on this function unhandled method,  
33:12 - right? So that's why you want to call 
this function. So here, this returns and  
33:19 - event API gateway event. So it will say 
API, Gateway proxy response, comma, error.  
33:29 - Right, so we will send response from 
here, or it will send an error. And  
33:34 - here we'll say return pay API response, the 
response that you want to send is HTTP dot.  
33:41 - When we say HTTP, we are talking about the 
history package Nesta history package, alright,  
33:46 - status. Method, not allowed comma. Header method 
not allowed, which we have just defined together,  
33:55 - right? That's what you're saying. 
So you're saying that we have,  
34:00 - you know, something for get post put in place, 
but we don't have something for patch, so  
34:05 - patch or any other method that somebody wants 
to use. So if you get something like that,  
34:09 - like an unhandled handle method, so you'll send a 
response saying that, hey, this meter is not loud.  
34:17 - Alright. And I want to create another variable, 
but it's actually a struct, right? So it's an  
34:26 - error body. And I'll be using it a lot so 
just bear with me as to why I'm creating it.  
34:32 - This struct has a variable 
called error message, string.  
34:42 - Error comma, omit empty. Now 
for your get user. You have  
34:58 - he accepts something and you turn something 
Before I get user, what do you accept? What do  
35:03 - you what does the function get you get a request 
right from postman, the request that you get is  
35:11 - part of a savings packet. So you can 
say events dot API gateway request,  
35:20 - comma table name, which is string, 
comma, Dyna client, dot Dynamo DB API.  
35:35 - And what does it return? returns the 
response, obviously. So we'll say events,  
35:40 - dot API gateway, proxy response, comma, Irish.  
35:49 - Straightforward. And actually, this, these two 
things, right, was going to accept and was going  
35:58 - to return is going to be used by all of the 
functions. So what you do is you just copy  
36:04 - and you just paste it here for 
CREATE USER for update user, as well.  
36:15 - And for delete user as well.  
36:24 - Awesome. So we've done a lot of heavy 
lifting. Now, I want to start working on the  
36:32 - function definitions for 
these all these functions.  
36:36 - Right, so the first thing that you'll say is 
email, request dot query, string parameters.  
36:50 - So if you've guessed, what's happening here 
is you want to get the user but by using the  
36:55 - email ID of that user. So for my request, 
you will have your query string parameters,  
37:02 - which will pass an email and that we're 
going to capture in a variable called email.  
37:06 - And then we will check the length. So we'll 
say if length of email is greater than zero,  
37:16 - then you'll get a single user. So we'll say user 
dot fetch user, which we've just created together,  
37:21 - right? We have not created the definition. But 
you know which function I'm talking about. It's  
37:25 - in my user package, which has been imported here 
already. So fetch user is going to take the email,  
37:35 - table name and donor client.  
37:41 - And I'm going to capture this in the result, or 
the when there's going to be an error. And if  
37:47 - there's an error, I'll handle the error. 
So I'll say if error not equal to nil.  
37:51 - Return API response has to 
be dot, status, bad request.  
38:03 - Comma, or body. So everybody's a struct 
that I've already defined. And in our body,  
38:10 - I want to pass AWS dot string error dot error.  
38:29 - And otherwise, you'll say hello, DB dot, 
everything is okay. So we'll say status. Okay?  
38:34 - If everything goes well, and you'll 
pass the result from this function.  
38:41 - Now if if you want multiple users,  
38:50 - you'll say user dot fetch users say 
same thing, they will name a client.  
39:04 - And what you will do is, you will again, use 
result and error to capture the values coming from  
39:10 - this function. And if there's an error, and you'll 
check if error is not equal to nil, you will  
39:16 - return the API response, saying HTTP dot status, 
bad request because there's an error, right?  
39:24 - And you'll send the error body, just like 
we did earlier error body is a struct that  
39:28 - we've already defined. That's the error body that 
we're sending, which is basically JSON. And here  
39:33 - the error body. Inside that, we're going to send, 
you're going to send a WS dot string, header dot.  
39:45 - Got it? But if everything went well, and 
there was no error, then we're going to return  
39:51 - API response and HTTP dot 
status. Okay. Commerce result  
40:01 - So the basic gutsier get user. 
Now what we can do is we can  
40:07 - work on our fetch user and fetch users both 
of these functions in our user.co file.  
40:10 - Or we can work on our CREATE USER function in 
our handlers. So I think I'll do the former,  
40:16 - I'll work on fetch users, and I'll work on 
fetch user, let me just check if everything is  
40:22 - recording, yes, everything is recording perfectly. 
I just need to keep making sure otherwise, you  
40:26 - know, I end up making a long video when nothing 
has recorded. And that leads to a big problem.  
40:32 - Alright, so before I do anything with 
users, I want to first create a user right.  
40:39 - So like I said, this file is a mix of 
that model file that you usually create,  
40:42 - where you define the structure of how the user 
is going to look like. So I'll say user struct.  
40:50 - Email. Now, since this user struct is small, and 
we don't have multiple stocks, like if this was a  
40:58 - e commerce, for example, then you would have had 
users and orders and you know, all those different  
41:02 - like products and so many different stocks, 
right. So you'd have to have like a model  
41:06 - separate Models folder for all these different 
models. And then you'll have, you'd have,  
41:10 - you know, database functions separately, 
and controllers or something like that,  
41:15 - right. But since we don't have that, we have a 
very small project, which just has users and users  
41:20 - all itself, it's a very small struct, because 
you just have email, first name and last name.  
41:28 - You don't have too much here, right, you can 
combine controllers and models into the same file.  
41:34 - Now, email is going to be a string  
41:41 - which is going to say JSON. And you 
say, like this JSON email, because  
41:47 - for Gulags purposes, it'll be emailed with 
a capital E, whereas JSON where it's stored,  
41:52 - it's going to be emailed with a small 
e. So you need to pay a telco like  
41:56 - that, you know, there are two versions 
of it one, the JSON version, the another  
42:00 - is the version that Golang understands, 
because Golang does not understand JSON,  
42:04 - as I've already told you. So that's why we also 
have to use some marshalling and unmarshalling.  
42:10 - To get it to understand and interact with JSON. 
Alright, so you'll have first name and last name.  
42:17 - And then what we'll do is we'll 
create our fetch user function,  
42:20 - what does it accept. So if you actually go to 
handlers, you will see the fetch user function  
42:26 - accepts email table name to a client. So we'll 
say here, email, and table name, which is string.  
42:35 - And your Dinah client, which is of type, you 
already know that dB, I face dot DynamoDB API.  
42:45 - And it just returns a user. Obviously, I mean,  
42:48 - you fetch user, you return that particular 
user or return error, if nothing works out.  
42:55 - You define a variable called input. And 
it's of type DynamoDB dot get item input.  
43:11 - So we'll have to define the key based on which our 
database function will run to find that particular  
43:17 - user. And you already know that the user will be 
formed for the database based on the email ID. So  
43:21 - we take an email id, you take an email ID, and 
then we want to find the user that's associated  
43:26 - with that email id. Alright, so straightforward. 
We'll say DynamoDB dot attribute value.  
43:37 - And we're going to say email because we want 
to run a query on email. So email is equal to  
43:42 - s equal to AWS dot string, dot, sorry, inside 
that bracket will pass email. Now the string  
43:50 - is a function that is given to us by AWS package 
Aerospike. It is something that we'll have to  
43:55 - import out here. All right. And similarly 
with the DynamoDB. So we'll have to also  
43:58 - import the DynamoDB package. So come here on your 
import, and firstly called encoding slash JSON,  
44:06 - because like I told you Golang does not understand 
JSON by default. So you'd need encoding slash JSON  
44:12 - package to use the marshalling and unmarshal 
like functions and I need the errors package  
44:17 - also. Then I want to get my hands on the events. 
Now we'll be using it soon. To send responses and  
44:34 - the usual ones. As you can see, I need DynamoDB 
and I need AWS. So let's get those ones. So I'll  
44:40 - say AWS slash AWS SDK, go slash AWS and also 
github.com/aws/aws SDK go slash Dynamo DB.  
45:03 - And what I'll also do well also 
get this particular package.  
45:12 - Yeah, let me do that for now. So 
I'll say github.com/aws/aws is  
45:18 - a case called slash service slash, Dynamo. 
dB slash Dynamo DB. I face. All right.  
45:36 - Now coming here, you've already 
passed this. And after this bracket,  
45:47 - you need to specify the table name in which this  
45:51 - function is going to run. So we'll use the regular 
string function again, to pass the table name.  
45:59 - And after this bracket, you want to use your 
data client to finally start getting the item.  
46:10 - Input is this basically the query that 
you created, right and get item is the  
46:13 - function that you get an error client. And 
you will capture that end result an error.  
46:22 - So, standard practice, if there's an error, 
we'll have it on the header soon return nil  
46:28 - for the value and will return errors 
dot new error failed to fetch record.  
46:44 - So you must be wondering, Where's What 
is this error come from? Probably never  
46:49 - seen this error, right? Because this is 
a new error that I've created on my own.  
46:52 - How can I create my own errors, I can 
create my own errors like this. So error  
46:59 - failed to fetch record is 
equal to fail to fetch record.  
47:07 - And similarly, I can define any errors that I want 
in this variable defined as a variable, right?  
47:17 - So you've, you know, created a query that is 
similar to MongoDB, right, you've created a query  
47:23 - based on the email, because you want to search 
for that email so that you can retrieve the user  
47:28 - and you've run the function get in get item for 
DynamoDB. And you've passed the query to it,  
47:34 - and you've received that in something 
called as result or you received an error.  
47:38 - If there's an error, you handle the 
error. But if the result is fine,  
47:41 - and nothing really happened, then you 
would do something right. But before that,  
47:48 - we will create a variable called item 
and it will be basically a new user.  
47:54 - And here you will say error is 
equal to Dynamo DB attribute.on.  
48:06 - Martial map. Okay, so DynamoDB attribute is 
another. By the way, if you have not opened  
48:13 - up the DynamoDB and AWS SDK, go, documentation, do 
that, because I have it open on my other screen,  
48:20 - you can do that as well. And then 
everything will make a lot more sense,  
48:23 - because these are actual packages inside 
that main package. Right? So I'm using those.  
48:29 - And once you go through the documentation, you 
will understand where to use, which one, are you  
48:35 - or if you really don't care about that, you can 
just keep following along with what I'm doing. But  
48:41 - I just recommend that you just read it because you 
know, everything will make more sense. Here I need  
48:50 - this package right done, what do we attribute? 
This is helping me unmarshalling the user.  
48:56 - So first, let me write the 
whole code. So I'll say result,  
49:00 - sorry, not here. He'll per record 
will say result, dot item comma item.  
49:13 - And this error if this error is not equal to nil,  
49:17 - what we want to do we want to return nil comma, 
errors dot new error failed to on Marshall record.  
49:35 - So you must be wondering what's happening here, 
right? When you get the data from your DynamoDB  
49:42 - using the get item function into result. You 
want to unmarshal data into an actual user,  
49:50 - which the front end can understand as a 
JSON basically. So you use the user struct  
49:59 - and and you don't take that in a variable 
called item. Right? So item is basically  
50:07 - a variable of type user. And then, you know, 
you want the data that's coming from your  
50:13 - result or item, you want that to be unmarshal and 
brought into item so that now whatever has come as  
50:20 - JSON becomes, you know, the type, which is user, 
which is understood by go Lang, but and it's  
50:26 - captured in a variable called item. Right? So 
I've tried to explain to you every single line,  
50:33 - in case you don't understand it, to check 
out what's marshalling and unmarshalling.  
50:36 - Alright. And if you have any, like, if you still 
have any confusions, you can just put it in the  
50:41 - comments below. I'll sort it out for you. But 
it's nothing very difficult, right, we just  
50:47 - taking what's coming from DynamoDB, 
the JSON, and you're on marshalling it,  
50:51 - to make it into a struct, right? Which is of 
type user, which has email first name, last name,  
50:56 - something that can be understood by ko lang. And 
you're capturing that in a variable called item,  
51:00 - which is obviously of type user, right? 
That's struck that we have defined.  
51:06 - This is standard practice, I do this in all 
my other videos as well, in case you're new  
51:09 - to this channel, I have hundreds of videos 
on ko lang, you can check all of them out.  
51:15 - Like literally hundreds of videos on Cola, 
right? Check them out, build projects with me.  
51:19 - And you'll understand very everything 
very easily. So if everything went well,  
51:24 - if there was an error, obviously, you 
sent nil and you sent the errors. But if  
51:27 - everything went well, you'd return the item, 
and then you will return nil for the error.  
51:32 - Now you'd want to also work 
on the fetch users function,  
51:36 - though, plural fetch users function. How do 
you do that you are passing table name there.  
51:45 - As you can see, here, you're passing given him 
an ANA client. So Duolingo has been passed,  
51:49 - which is obviously a type of string to 
pass 10 Nine, a client which is of type,  
51:55 - you already know, Dynamo DB, I face dot 
DynamoDB API. And you return multiple users.  
52:07 - How you doing multiple users, you return basically 
a slice of users, when users is the struct that  
52:15 - you've defined, right? So you're using a struct, 
you're making a slice of all those users,  
52:19 - and then that's what you're returning. I hope that 
makes sense. If you don't know basics of like,  
52:25 - of Kulang, like slices and structs, then I highly 
recommend you check out the basic tutorials before  
52:33 - you get more confused. So I want to use a function 
by the DynamoDB gives me it's called Scan input.  
52:49 - To get access to a table name, which has AWS dot,  
52:54 - string, and table name that we are already 
passing here. Right. And he will say Dinah client,  
53:06 - thought scan and you want to scan the input, the 
query that you just created. So here, as you saw,  
53:16 - we had a more elaborate query, because we had 
to get a particular user with email. But with  
53:22 - fetch users, you just getting all the users, you 
don't have a specific query that, okay, you know,  
53:26 - for this email, get a particular user saying, 
Give me all the users. So you don't have any  
53:31 - query as such, you're just passing the table name. 
So that's when your diner client, but can you just  
53:35 - pass the input, that's it. And scan is like get 
all, you know, you can say that. So if you've used  
53:44 - that MongoDB, it's, you have find, find all 
something like that. Here, you just have scan,  
53:50 - find and find one you have 
in MongoDB. So you just have  
53:53 - scan, alright, scan and get it. So you're doing 
scan to get all the results. And you're going  
54:01 - to capture that in a variable called result. And 
then you will obviously, if you have an error, you  
54:05 - know that standard way to handle errors is like 
this. You'll say return nil for the value when  
54:14 - you return an error. She'll say errors 
dot new error, failed to fetch record.  
54:23 - And, again, like we did out here, item will define 
item, right? The item here is not just a user,  
54:34 - it's a slice of users, multiple users because 
we're getting all the users from our database.  
54:41 - And, again, the same thing that we've just 
done here. We'll do the same thing here.  
54:45 - So we'll say or do just copy the whole thing 
actually. Copy and paste. But there's only one  
54:55 - more little change instead of result 
or item. You'll have result dot items.  
55:02 - Because obviously from AWS, you'll get multiple 
items, multiple users, that's what you're getting.  
55:06 - And you're returning your item. And 
for the error, you're returning.  
55:14 - Make sense. So we've done quite a bit, right, 
we've already done the Get User function and  
55:20 - get user function had fetch user and fetch 
users two functions from your user.co file.  
55:26 - Now there are three functions left here, and three 
functions appear because we've already taken care  
55:31 - of the unhandled method function, you don't have 
to anything more here. So just three functions  
55:35 - left here, three functions left here. And all 
the other files are kind of complete. Right?  
55:41 - So if you reach this far, congratulate yourself, 
because you've come you've come a long way. Right?  
55:50 - So now let's start thinking about how our 
CREATE USER function is going to work. Alright.  
55:59 - So for the CREATE USER function, 
let's let's start building that.  
56:03 - There's actually not much happening there. All 
these functions, right? Create User, update,  
56:08 - user, delete user, like, they're all going to 
look very, very similar. So going to say user,  
56:14 - because you know, you want to call the CREATE USER 
function, the user package, so we'll say user dot  
56:21 - create user, which is this function, 
that's what you're calling,  
56:25 - right? And you're passing it three things 
request, table name, and a client makes sense.  
56:33 - Nobody will respond to this function returns, you 
want to capture that in a variable called error,  
56:38 - sorry, result, and you will get an error 
which will be captured an error. And you know,  
56:44 - the process from here, if there's an error, which 
means error, not equal to nil, you will return  
56:50 - API response, HTTP dot, status, bad request, 
comma, error body and what will be the URL  
56:58 - body. Everybody in this case, by the way, is, 
sorry, the struct that we want to define right?  
57:05 - So was there in the body, it's AWS dot string, 
with a single or sorry, string, e RR dot error.  
57:17 - Comma. Okay. And you'll return API 
response. HTTP dot status created.  
57:31 - Comma result. So if that means if there 
is no error, everything goes well,  
57:36 - then you will say he should be 
dot status created. Alright. And  
57:44 - that's about it. That's it, actually, that's your 
CREATE USER function, there's nothing more to it.  
57:49 - Alright. And then for your update user function, 
very similar. You'll obviously call the user,  
57:56 - just like you did here, user dot create, user 
here, you'll call user dot update user method.  
58:01 - So we'll say, update user. And you'll pass three 
things request, table name and diner client.  
58:10 - And you will capture that in result comma, 
header. And then you'll check again, if error  
58:18 - is not equal to nil. return an API response has 
to be dot again, status, bad request, comma,  
58:30 - error body inside the body. Again, the 
same thing, it was a string or a dot.  
58:39 - Alright, but if everything went well, if the user 
did get updated, then you'll return API response.  
58:48 - And you'll say SDP dot status, okay? That 
everything went well, and you'll return  
58:55 - the result. So that means what's happening, 
these two functions CREATE USER update user  
59:03 - is that these two functions are being 
called. That means a lot of the logic  
59:08 - the main logic is going to happen in these two 
functions, right? Because not much happened  
59:12 - in the handlers. Similarly, let's work on our 
delete user function. Here. You'll say user dot  
59:21 - read user, insert request, comma, table 
name comma Diana client. Here also,  
59:32 - though, the only thing you will learn from here is 
the error, right? If the user didn't get deleted,  
59:38 - you will turn the error. You don't need to return 
the result and result from the delete function.  
59:44 - So if the result is not equal to nil, you will 
return API response. You know by now what we're  
59:52 - going to say we're going to say says bad request 
and we're going to also send the error body  
59:56 - which will have AWS dot 
string And the error itself.  
60:05 - But if everything went well, you 
would want to return the response with  
60:12 - status, okay? And you will 
return nil for the error  
60:24 - okay  
60:32 - so that's that's about it.  
60:39 - And yeah, that's it, I think the entire file is 
complete. Now, we don't have anything else to do.  
60:48 - I've also gone through the AWS SDK documentation, 
I don't think anything else needs to be  
60:53 - done in the handler. So everything looks alright 
to me. And now we will have to work on our  
61:00 - user of go file and all these different 
functions that exist on a user.go file.  
61:06 - For your CREATE USER function, we're all 
it's going to accept depends on what you're  
61:13 - sending from here, which is request a preliminary 
client. So here, you'll say request, events dot  
61:20 - API gateway proxy request, comma table name, 
which will be string, and then a client,  
61:28 - which will be you already know, there 
might be a face dot nanodegree API.  
61:35 - So what is it going to return, it's going to 
return the user that has been just created,  
61:40 - or an error. So here, the first thing 
that we'll do is we'll create a variable  
61:47 - here, which is of type user user being the 
struct that we will define that means you will  
61:52 - have email first name and last name. Alright. 
So let's start from there. Now we'll use you,  
61:59 - why'd we create this variable you is because we 
want to capture what's coming from postman. So  
62:05 - from postman or from let's say, the terminal 
wherever will send the JSON of the user with  
62:11 - the email, first name and last name. And 
that data needs to be unmarshal into you,  
62:18 - so that Golang is able to understand it and also 
perform any operations on it. So what do you want  
62:23 - to do is we want to use the JSON encoding slash 
JSON package to call the unmarshal function.  
62:39 - And what you want to do is you want 
to pass the request dot body to it.  
62:45 - Comma ampersand you if error is 
not equal to nil, and also here.  
62:58 - He called the right syntax for the if statement. 
And if error is not equal to null, then  
63:03 - we'll return nil, and we'll return something for 
the errors. We'll say error, invalid user data.  
63:17 - But we don't have this error here, right? We don't 
have this error error fail to unmarshal record.  
63:25 - We don't have error, invalid user 
data, we just have error fail to  
63:28 - fetch record. That's all we have defined. 
Now let's define all the other errors.  
63:34 - Let me define all the other errors that I'll need 
in this entire file and the beginning itself.  
63:41 - So we'll say error failed to unmarshal 
record is equal to fail to unmarshal. Record  
63:53 - and error and add error and valid user 
data is equal to and valid user data.  
64:15 - invalid email also will be there and valid 
email is equal to invalid email. Then we'll have  
64:30 - good not Marshal item and 
could not delete item so.  
64:56 - Then we'll have could not put 
item so we'll say Could not  
65:04 - Dynamo put item as equal to code not 
Dynamo put item. And user already exists.  
65:26 - user does not exist, or the user does not exist. 
So why do I need all these errors? Obviously,  
65:41 - by now you would have understood, I'll just give 
you an example that when creating a user, right,  
65:47 - if we check if that user already exists, then 
we don't need to create that user. That's why  
65:51 - we need this kind of an error. And if you want, if 
you're updating a user, then or deleting a user,  
65:56 - we can use this, that user does not exist. So 
I trying to update that user, right? That's  
66:00 - why I'm just thinking about all type of error 
functions, I'll need error statements I'll need.  
66:06 - So depending on that, I've just created 
them. So going back to your create users,  
66:14 - right here, now, we will start 
validating the email. So we'll say  
66:22 - validators dot validators is the package that 
we have created together, right, this one.  
66:29 - And the function that we created in 
that package was his email valid.  
66:37 - And you is the variable that you define. And 
now after unmarshalling, the request that you in  
66:43 - the body body is of the request that you got from 
let's say, postman, or from the terminal as JSON.  
66:49 - You captured that in you. So now you can now 
go Lang can easily understand you because it's  
66:55 - unmarshal, right? It's not just one and more, 
so you can access you dot email. And you can  
67:02 - run the validation function on it. So here the 
spelling is wrong. Should I when is email valid?  
67:10 - And you'll return nil, comma, errors, 
dot new error, invalid email. Right? And  
67:30 - how how the reason why I created this error is 
because I want to see if that user already exists,  
67:37 - right? So if the user already exists, then you 
don't need to create it. So we need to throw an  
67:41 - error. So we will check if the user already 
exists, right? So I won't put that comment,  
67:47 - actually, I was just trying to show you. So 
to check if the user actually exists, you have  
67:52 - to run the fetch user function, you will say u 
dot male comma table name, comma Diana client.  
68:03 - And to capture whatever comes from 
this function in current user,  
68:09 - and we won't handle the error, 
so I'll put a blank there.  
68:15 - So if current user is not equal to null, 
that means there is this user exists, right?  
68:21 - If current user is not equal to null, and length 
of current user dot email is not equal to zero,  
68:33 - then you return nil comma, errors 
dot new error user already exists.  
68:47 - And so all of this if the user 
exists, but if the user doesn't exist,  
68:51 - he will just say that user right, 
so how do you save that? So first,  
68:54 - to save that, obviously, whatever you 
now have in you, you want to start  
69:03 - want to start marshaling it right? So 
that DynamoDB can understand it now.  
69:07 - So you will say Dynamo DB, attribute dot 
Marshall map, you and you'll capture this in AV  
69:24 - and you'll check for the error. So if there's 
an error, we will return nil. And errors dot new  
69:32 - error could not Marshal items which you've already 
defined, we've already defined this error right?  
69:46 - And now, you want to start creating your data 
that you will be sending to DynamoDB. So how would  
69:56 - you do that? You'll say DynamoDB dot put Item 
input item is Av. Comma. table name is AWS dot,  
70:13 - string table name. And finally, you'll see 
Dana client dot put item, and you'll send  
70:26 - this input that you've defined here. So 
yes, missed the is equal to sign by mistake.  
70:32 - Similar to fetch users, right, you created this 
input, and then you call the ANA client function.  
70:36 - Similarly, you're doing that the same thing here, 
you're calling the put item function. And you'll  
70:44 - capture that in a blank actors blank variable or, 
and, or you will get an error from here. And if  
70:52 - error is there, then you will just handle it very 
easily. You'll say return nil, comma, errors dot  
70:56 - new error, could not timer put item right here 
faded this error already. But if everything went  
71:06 - well, you just want to return the user are nil. 
Awesome. So this is your CREATE USER function.  
71:21 - And now you're left with update user and 
delete user. Everything else you've taken  
71:28 - care of right, the handlers are go file 
is complete API responses complete as  
71:32 - as an email validator is complete, 
and may not go as complete.  
71:38 - And I think for our user file, we have imported 
all the packages except for validators. So you  
71:46 - need validators. So you'll say github.com, 
the validators package that you've already  
71:50 - created? We talk I'm talking about that one. 
So we'll say go serverless yt, slash PKG slash  
72:00 - validators. It will also check what else 
am I missing for handlers? I think I've  
72:07 - already imported user. And I don't need 
any more packages. For API response.  
72:17 - I don't need more packages. For his email valid, 
I don't need anything else. My main.go file,  
72:23 - probably, I might have missed something. So it has 
handlers has always even slammed on AWS session  
72:30 - DynamoDB DynamoDB is, so everything is proper, 
based on the AWS SDK, go right, check out this  
72:38 - documentation, you will know why I'm importing 
these packages and how I've used these functions.  
72:42 - You already know that because you've been building 
it with me, alright. Then we'll come here,  
72:51 - again, back to our user.co file. And let's 
start working on the update user function.  
72:57 - So what does it accept, accepts request, which is 
of type events, and thought API gateway requests,  
73:07 - comma, table name, which is string comma, 
Dinah client, which is of type DynamoDB, I face  
73:15 - dot DynamoDB. API returns a user the 
updated user. And, or fine, I mean,  
73:27 - or it sends back an error. And we're going to do 
a lot of things which are going to be very similar  
73:33 - to the Create User function, which is basically we 
create the user. First we created the user, right,  
73:39 - which is the variable u, which is of type user. 
And we're going to unmarshal, just like we did,  
73:47 - we're going to unmarshal the request body that 
you get. So request dot body, comma ampersand you  
74:02 - so by mistake, yeah, so I have to 
close the bracket here, because  
74:09 - this is together. And this is this variable view.  
74:16 - Okay. And her nautical tunnel, if you don't want 
to follow along, you can just copy and paste  
74:22 - this part, right? I'm not copying and pasting 
because this syntax might be new to many people.  
74:27 - Because it's DynamoDB, kind of working with 
DynamoDB. So I'm writing everything by hand.  
74:34 - If you want to copy and paste, if 
you're very comfortable with DynamoDB,  
74:38 - go ahead and do that. You don't need 
to, you know, practice along with me.  
74:43 - Then you want to fetch the user and see if that 
user even exists. So you will say your email  
74:47 - comma, table name comma, data client. And you 
want to capture that in current user Adding on  
75:03 - a check or the current user. So if current user 
not equal to nil, is exactly what you did in the  
75:12 - create function as well. And length of 
current user dot email is equal to zero  
75:28 - then you'll return nil comma errors 
dot nao error, user does not exist.  
75:39 - So for the CREATE USER function, we were 
checking for the user associated with that  
75:44 - email, because we want to see, you know, 
that is really exists, we don't want to  
75:48 - add that user. But for update, we're doing the 
reverse, we're checking for that user. Because  
75:52 - only if that user exists, we can update 
the data for that user make sense? And  
75:59 - exactly the same things will do, because now you 
want to start. So now that the user, you know,  
76:06 - if the user doesn't exist, will throw an error. 
But if the user exists, then you want to start  
76:10 - updating the table with the new data. How do you 
do that? Whatever you've unmarshal right now,  
76:16 - from JSON to unmarshal, to something that Golang 
understands, now you want to start marshaling it  
76:21 - to something that DynamoDB understands. 
So you already know what you want to use,  
76:26 - you want to use the marshal map function. To pass 
you to it, because you've just done marshaled.  
76:35 - And which packages is a part of so it's 
part of the Dynamo DB attribute package  
76:46 - we will capture it in a variable called 
AV or we'll get an error. And now we can  
76:52 - easily handle the error. So if error 
not equal to nil, return nil comma,  
76:59 - errors dot new error could 
not Marshal it, this one.  
77:06 - Really, really straightforward. Now you just 
want to create your input item and then you  
77:11 - want to just call it and a client function, 
only two steps remaining. So you will say  
77:15 - input is equal to ampersand Dyna, more dB, dot 
put item input, and the item is equal to Av  
77:28 - comma, the table name will be equal 
to AWS dot string. table name.  
77:39 - And the last thing is you'll use Diana 
client dot put item and you'll pass the input  
77:55 - and if error not equal to 
nil, nil comma errors dot  
78:08 - new error could not Dynamo put 
item return ampersand you come on.  
78:19 - Soon now even my update function is complete 
everything looks okay. And all I want to do now  
78:28 - is run the Gomati command to get all 
of the packages that are not there.  
78:49 - So I think it's taking a while 
I can't find my phone anyways.  
78:54 - So while that's happening in the background, we 
can start working on the delete user function.  
79:04 - So as you can see, it's all installed. I had 
a couple of issues actually. As you can see,  
79:13 - and most of the issues were because I had a couple 
of spelling mistakes here instead of SDK added an  
79:18 - S KD you know, so a small small few mistakes I had 
made. Just make sure you get these tight. You can  
79:26 - easily get them on AWS SDK go documentation or 
if I put a mostly I'll put this code on GitHub.  
79:36 - So you can just pick it up from there. Alright, 
make sense? Just pick it up from there instead of  
79:41 - typing in all yourself because I made a couple 
of mistakes. So it was it was taking a while.  
79:46 - But now it's install all these packages. So then 
your user.go file, everything works perfectly  
79:54 - right? Like we don't know if it works 
perfectly but everything looks perfect to me.  
79:58 - And all the packages are in place. All you need 
to do now is work on your read user function,  
80:07 - which is actually the most actually the like 
the easiest function. So it takes request,  
80:13 - events dot API gateway request, comma 
table name, which is of type string client,  
80:20 - which is a type already know, you already 
know that. Dot DynamoDB API. Alright.  
80:29 - So what you want to put in the function 
definition, you want the email of the user, right?  
80:34 - So request dot, query string parameters, 
and the parameters, email, then you will  
80:42 - create your input to the function which is of type 
DynamoDB. Hen dot, delete item input, item, input  
81:03 - star DynamoDB dot attribute.  
81:10 - Value. Basically, you're passing the email, and 
then finding the user and deleting the user with  
81:17 - it associated to that particular email. Right? 
Nothing complicated. So you will say AWS dot  
81:26 - string. And you pass email to that.  
81:32 - After this, you'll say table name. 
AWS dot string, pass the table name.  
81:44 - And now that you have your input ready, 
just like we've done all other functions,  
81:47 - you take the data client, you call the DynamoDB 
function, which is delete item in this case, and  
81:56 - you pass the input to it. And put basically has 
your query for deletion, which is the email ID.  
82:05 - And you get the error. If there was an error  
82:14 - will return errors dot new error 
could not delete item. Perfect.  
82:27 - Otherwise, we just return 
null, nothing. Basically,  
82:29 - that means that the user has been deleted. 
Now, I'm sure there are a lot of errors.  
82:34 - Because I'm not using any type checking extension 
or any go Lang extension, right. So there will be  
82:39 - a lot of errors here. So I need to start solving 
them one by one before I deploy it to the cloud.  
82:47 - So to find those issues, and to fix them, I'll 
head over my terminal. And I'll head over to the  
82:53 - CMD folder and has a co build main.co and starts 
giving me errors, right? So it says on this file,  
83:06 - line number eight. Yeah, I can see the issue, 
it has to be doubled. Right. That's what  
83:12 - makes it the or operator. So you will run the 
command again. And now you will get all these  
83:19 - nice headers that we were expecting, right? And 
now we want to go start solving them one by one.  
83:25 - So starting from line 37, all the way to line 145 
too many errors. So when it says too many errors,  
83:30 - that means that even after you solve 
these, it will give you many more errors,  
83:35 - right? So this is why I don't really, you know, 
use extensions, because Because Golang takes  
83:42 - care of everything, it tells you which exact line 
which part, what you're missing, you don't like  
83:48 - it's a no brainer, right? You don't have to apply 
a lot of brains just solve these issues, just like  
83:52 - go Lang once you do, and everything will run. So 
that's why I'm so chilled out all the time, man.  
83:59 - So if I go back to your code, on line 37, what 
could be the issue is that I have not put a comma  
84:07 - here and comma here. basic syntax issues, right? 
That's what it says it says basic syntax issues.  
84:13 - Here also you need to put a comma. And let's 
keep putting commas wherever you know, I think  
84:21 - it will need commas so this needs comma here, 
which is line 58. In my case, you can check it  
84:29 - out where you know, it is for you. For CREATE USER 
again, I'll just put a comma here just to be sure.  
84:37 - And I'll put a comma in the input part which is 
this. Alright, and in the update user function.  
84:50 - Again, let's go to the input area. Here I've 
put the commas or haven't seen any issues here.  
85:01 - And for delete, definitely you need to put a 
comma here as well as here as well as here. So  
85:10 - now if we run it, a lot of the errors 
have gone away, right? And now you have  
85:19 - some other errors. There are some syntax 
errors also, like for syntax errors, and one.  
85:26 - This one was that you're not able to  
85:29 - refer to this function. So let's try 
and fix those as well, at the same time.  
85:38 - So let's hover over back to our code. Let me 
see the line first line says 88, line 88, blah,  
85:46 - blah, blah, blah, blah, yes, M is small, whereas m 
should be large. What was I thinking? Am I stupid,  
85:53 - you know, that I was not able to? That I didn't 
make them, you know, large, because obviously, the  
86:00 - function is martial map with the capital M. 
Right? So this just means that no matter how  
86:05 - stupid you are, go, Lang takes care of everything, 
right? So you don't need to be the smartest guy  
86:09 - on the planet. So let's look at others stupid 
mistakes. So 108 comma missing? It's a syntax  
86:17 - error. Super simple, right? It's even telling 
you expecting comma, right? I mean, how obvious  
86:23 - can edit statements be? And then people, you know, 
tell me download this extension? I, I don't have  
86:30 - done it an extinction man. Go Lang does everything 
for me. And missing statement after label wonder  
86:36 - if I wonder if I miss you statement after label 
blah, blah, blah, blah, blah? Yeah, obviously,  
86:43 - the physical sign is off. And then 147 147. put a 
comma here, right after 147. And then unexpected.  
87:00 - Yep. Found it. Now let's run it. Now. Let's 
see some more errors. Yes, so it found some  
87:09 - more errors. And now you have to go to Line 
Number 66, and 76 and 140. But these are not  
87:18 - syntax errors. So here, you will have to think a 
little bit as to why the there's an error there.  
87:27 - So head over back to your 
code on line. 66. Lines 66.  
87:35 - Yeah, so it says, let's look at the error it 
says, cannot use results dot result or items.  
87:43 - And something something something 
to do with this function called  
87:47 - on Marshal map. That is because you're receiving 
items, not item, you're receiving multiple items,  
87:53 - right? So you can't use unmarshal map function 
here, you'll just see use unmarshal list of maps.  
88:02 - Super simple, man, super simple. 36, line 76. 
Alright, it says blah, blah, blah, blah, blah,  
88:12 - request dot body. See it says 
request dot body undefined.  
88:16 - And it also says does not have body with capital 
B. Right? I mean, you don't, you can be the  
88:24 - stupidest person on the planet and fix this issue, 
because you just had to make this be capital.  
88:29 - Right? So that's how intuitive go Lang is. And 
then you go to Line Number 140. Line Number 140.  
88:37 - I mean, I can guarantee you that you can't do any 
like something like this with any other language,  
88:41 - right? It says there's a problem with 
this function, obviously, because there's  
88:44 - a spelling mistake here. Parameters. 
Everything is fixed now. And now let's  
88:49 - see. So it gives me another error. It says 
unmarshal. Just off map is wrong. Yeah,  
88:55 - because I made mistake. Again, it should have 
been unmarshal list of maps, not map. Awesome.  
89:06 - So now, now that your user.go file is sorted 
as an IT first shows you the syntax errors,  
89:12 - you've solved them, then you solve the logical 
errors. And now it's giving you some issues  
89:16 - with the handlers file right handles. 
It's giving you all these syntax errors,  
89:20 - we'll solve them and we'll give you some 
logical errors. We'll solve them as well.  
89:24 - And then we're good to go. Right? So we're on 
the right path. Now let's go back to our code.  
89:32 - So whenever your code and start from 
line 19, line 19, put a comma here, line  
89:43 - for it to fall to put a comma here, it was saying 
it's accepting expecting a comma from you, right?  
89:48 - And line 54. Comma, line 59 Blah, 
blah, blah, blah, blah Pratama.  
89:59 - Line 62. 60 and 72 and 66 for comma 32, comma. 
All right? Now you start getting the real  
90:10 - errors, right, the real errors. So, line 22, we 
just solved this issue on the other file line 22  
90:18 - Because the spelling of parameters is 
wrong. And now you're going to worry about  
90:26 - line nine, line nine. So one thing to notice is 
that it's line nine, but another file API response  
90:37 - would go. So open up the API responded, go file. 
And here I can see there's an issue. Alright, I've  
90:49 - fixed the issue. It was basically to do with those 
brackets. And now it's starting to show me issues  
90:56 - with may not go file, which is what I want. I want 
to fix the main.go file issues. But on line 44,  
91:03 - line 44. Let me see what's happening. Okay, yeah, 
I can see it, I can see the issue, it's basically  
91:11 - all the cases have to be together. And by 
mistake, I'd written this outside the bracket,  
91:20 - also the switch bracket, and I've included 
inside. So that error should also go away.  
91:28 - And now when I do this, it's created the goal 
build may not go file for me. So let me see if  
91:34 - it has Yeah, I can see the 
main file, I just have to  
91:39 - move it here to my build folder. And I've hit the 
build file, without any issues, no errors, right.  
91:46 - So now let's start the deployment process. Before 
you do anything else, you need to first create  
91:57 - a zip file. So you'll just come here it will say 
zip minus gr M and build slash main dot zip. From  
92:08 - build slash main. So build is your folder main is 
the build that you've created for any folder, and  
92:16 - build slash main dot zip will be the zip file 
using the zip function. Maybe in your Linux,  
92:21 - you don't have zip, you'll have to install it 
using sudo. apt get install zip. So now if we  
92:29 - check here, we can see the main dot zip file in 
my build folder. And now we ready to kind of start  
92:37 - uploading it on lambda, or ADA plus lambda. But as 
remember, as you remember, I told you that I have  
92:43 - Windows installed on that I'm running WsL on that 
I'm running this open too. And on top of that I've  
92:49 - built this folder, right? So I need to be 
able to access this main dot zip file from my  
92:57 - windows for my windows to be able to install, 
like upload it on my AWS code and lambda lambda  
93:04 - dashboard. So for that, I'll do something.  
93:10 - So to in order to help me to do that, 
I have to run this command explorer  
93:18 - dot exe. Dot. Now hopefully it should 
open. Yeah, it has it has opened up the  
93:26 - Explorer at this location 
for me, and I'll copy this.  
93:31 - I'll put this on my desktop. Awesome. And now 
I can start to deploy this on my AWS console.  
93:42 - So you want to start deploying, but there's one 
thing I wanted to change is this table name.  
93:49 - So I'll keep this table name same as my, the 
name of my program. Go serverless righty.  
94:02 - Okay, just for consistency sake, because we'll 
have to create this table in DynamoDB. And  
94:10 - let me just search. If I was using the other table 
name, so you'll just control Zed. And we'll just  
94:17 - see if I was using this table name 
anywhere else in any other file.  
94:24 - This only place there's only one place I was using 
it. So here's the table name has to be changed.  
94:30 - It will say go server less writing. Okay, and 
now is when we start deploying. So log into  
94:40 - your console and head over to lambda. You have 
to just create function go server less writing  
94:51 - server using Golang one point x I think we'll have 
to change the execution roles create new role from  
94:58 - AWS policy demo This option is what you have to 
select, and the roll name, go serverless, righty  
95:08 - execute from the templates, you have to choose 
Simple micro service permissions create function  
95:18 - successfully created, right? Now 
you want to change the handler.  
95:25 - So as you know, our main, the file that we'll 
be uploading is called the main file. That's  
95:30 - what our build is called right. So we'll 
have to change the handler to mean upload  
95:37 - the zip file and upload it, go back to AWS 
and go to DynamoDB. Can you will click on  
95:59 - Create Table Table names table 
name is what you selected here  
96:05 - go server less whitey. Simple, right? Because 
we've kept everything the same name so  
96:15 - and primary key. So it says enter the partition 
key name, I think this is the primary key here  
96:21 - is the primary key. The primary key in our 
case is email. Which is string, obviously.  
96:30 - And everything else is same. And we 
can just create the database active,  
96:34 - it's now active. So now we can proceed to the 
next stage, which is configuring your API gateway.  
96:44 - So head over to your API gateway. 
Create API. Now to build a REST API.  
97:01 - Protocol, let's test select new API here. 
And now you want to put the API name,  
97:10 - which is cool. Server less ID. 
And you then create the API.  
97:30 - From the Actions to create method, select any.  
97:45 - And here you'll select integration type 
lambda function. And check this use lambda  
97:52 - proxy integration. And you have the name of the 
lambda function here, which is go serverless YT.  
98:03 - And you have to also have to ensure 
this is checked default timeout.  
98:25 - Now we need to deploy our API. 
So from actions deploy API  
98:38 - select new stage, stage 
name of staging and deploy.  
98:55 - So this is your URL that you get here. 
Which we will be using right now to test.  
99:07 - So let's test it out. I'm, I'm expecting 
some errors to be there. But not a problem.  
99:15 - Let's clear our screen. And first, we'll have 
to build this command. So just give me a second.  
99:25 - So here are my four commands. And obviously, this 
is post which is creating a user this is get all  
99:34 - users get a particular user by email ID. And this 
last command is for update. Now we can use postman  
99:42 - or you can you just use curl which are the same 
thing right? And you set your header header and  
99:47 - you tell it was the request which is post 
and the data that you send which is email  
99:51 - which is my email address, my name my last name 
and this is the the unique link that I just got  
99:59 - this Link is the unique link that I just got 
from my invoke URL. Okay, so I'll post these,  
100:07 - I'll post this command somewhere, how do I post 
it? Now? Okay, so I'll do is I'll upload this  
100:12 - project on GitHub, and then in the description, 
I think I'll just post these commands so that  
100:16 - you can just copy and paste them quickly. I 
think that will be the best option. Or you  
100:22 - can just use postman when given you have to use 
these commands if you don't want to. Alright.  
100:28 - And similarly, for the update, you say it's 
request, but you have the new data is going  
100:35 - to find email based on that, because email 
is our primary key, as you already know,  
100:39 - and this is my API link will follow 
commands, I need one more command, which is  
100:47 - the Delete command. So I'll change that to this.  
101:00 - So you will get all these in the and 
API gateway documentation on how to  
101:07 - call these API's, you can get that 
also. And so I'm just copying those,  
101:11 - and I'm just changing those commands. Alright. 
So what we'll do now is we'll try and test it.  
101:19 - I'm pretty sure that we some error 
will fail. But let's do it anyway.  
101:35 - Oh, so it worked. It worked. 
Alright. So it created this user,  
101:39 - which is amazing. Restaurant the second command.  
101:51 - Sorry, this command  
101:58 - is not copying and pasting.  
102:05 - Now returning the get all users command. 
So we'll get all the users only one user  
102:09 - is S, which is getting that. And then we'll 
get the particular user. particular user has  
102:17 - this email id, it will get that user also for 
me, because there's only one user right now.  
102:25 - Yes, so that's also working. And now we will 
work on our put function. So sick, it's taking my  
102:35 - email address and changing my first name to 
lalala and last name to blah, blah, blah,  
102:39 - right? So it's done that you update is working. 
And now we have to work on the delete function.  
102:51 - So if the delete function works, it won't 
return anything. So we will check if  
103:00 - that user is still there, so 
we're getting all the users.  
103:06 - That means delete work, because it's an empty 
array, right? That same user is not there anymore.  
103:11 - Perfect. So that means everything is working. I 
hope you enjoyed this tutorial. It's a long video,  
103:18 - I know there's a lot to follow. There's a lot to 
learn there. And I hope you really enjoyed it. I  
103:23 - hope you learned a lot in this project. And very 
soon I'll have I'll have one more project coming  
103:29 - up with serverless tag, but it's a little more 
advanced, we'll have multiple lambda functions,  
103:33 - we'll have CloudFormation, we'll have you know, 
those CloudFormation scripts. So everything will  
103:38 - be through YAML files, and then AWS CLI. And we'll 
also use AWS, Sam for the entire setup. So that's  
103:45 - going to be really complicated. So make sure 
you've done the AWS lambda, you know that video  
103:51 - and you've done the serverless video. And then 
you read a little bit more about how serverless  
103:55 - works and all the different technologies. And 
that will really help you in the next upcoming  
103:59 - video. There'll be slightly longer actually much 
longer, and they'll have like way more complicated  
104:04 - project, right. So the point of that is where this 
is like a monolith serverless project, right? That  
104:09 - will be serverless microservices project, there'll 
be API gateway CloudFormation. They will be a lot  
104:17 - more technologies. I will use AWS, Sam for all 
the writing all the configuration files. Anyhow,  
104:23 - so I hope you're enjoying it and do subscribe to 
the channel if you haven't already. And there are  
104:27 - hundreds of videos on go Lang on my channel, check 
them out. And I also keep sharing some nice advice  
104:32 - on you know, your development career. So keep 
watching that as well. Alright, so see you and  
104:39 - connect with me on LinkedIn. There's the LinkedIn 
link in my description box below. Thank you