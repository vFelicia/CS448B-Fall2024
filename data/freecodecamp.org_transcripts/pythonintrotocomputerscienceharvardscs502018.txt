00:00 - [MUSIC PLAYING]
00:50 - DAVID MALAN: This is CS50
and this is lecture 6.
00:53 - And you'll recall that last week
we introduced web programming
00:56 - by way of HTML and CSS, or
at least the building blocks
00:58 - because we don't actually have
the ability to program yet.
01:01 - It's just markup, HTML and
CSS with stylization thereof.
01:04 - But we introduced this metaphor last
week of a protocol called TCP/IP.
01:08 - And we related it to,
of course, an envelope.
01:10 - And on this envelope,
virtually, on the front
01:12 - was at least two pieces of information.
01:14 - And if anyone remembers
what were those two
01:17 - pieces of information in the to field?
01:19 - Someone else who we
didn't hear from recently?
01:22 - Yeah?
01:22 - AUDIENCE: An IP address.
01:23 - DAVID MALAN: Yeah.
01:23 - An IP address, a numeric address that
uniquely identifies your computer
01:26 - and someone else's computer.
01:27 - And one other thing, if you remember.
01:32 - Oh, come on.
01:32 - It was like two minutes ago.
01:33 - OK.
01:34 - Yeah.
01:34 - AUDIENCE: A port number.
01:35 - DAVID MALAN: A port number.
01:36 - So another number, shorter number,
that's just a number like 80 or 443
01:40 - referring to HTTP or
HTTPS, or other numbers,
01:44 - like 25 for email and the like.
01:45 - And so together these unique addresses
allow you to send information
01:49 - to not only a specific
computer, but a specific service
01:51 - running on that computer.
01:53 - And in order to actually request
information from that server,
01:57 - there's this other protocol called
HTTP, Hypertext Transfer Protocol.
02:01 - This is what's inside of the envelope.
02:03 - So when the server opens
it up, metaphorically,
02:06 - looks inside, this is the command that
that server reads in order to decide
02:10 - what it should actually respond with.
02:12 - And so this request here
is telling the server--
02:15 - otherwise known as www.example.com
in this particular example--
02:19 - to send back what exactly
in its own envelope to me
02:23 - and my laptop if I were to request this?
02:27 - AUDIENCE: A specific web page.
02:29 - DAVID MALAN: A specific web page.
02:31 - And someone else, which web
page specifically, presumably?
02:33 - AUDIENCE: Index.
02:34 - DAVID MALAN: Yeah, so index.html,
which we said last week
02:36 - just tends to be the default file
name on a server for a web page
02:40 - that's just selected by default. And
it doesn't have to be called this,
02:43 - but it's a human convention.
02:44 - And the rest of this is just a verb
saying, literally, get me that file.
02:48 - This is just telling the
server what version of HTTP
02:50 - I speak so that humans can improve
it and upgrade it over time.
02:54 - But this would tell the
server to return index.html.
02:57 - Meanwhile, we saw more
sophisticated get queries
03:00 - when we started talking about
Google, and any website that
03:03 - has not just a front end, like
HTML and CSS, but also a back end.
03:07 - And a back end is where the
logic is, where the server is,
03:10 - and the interesting work, ultimately.
03:12 - And so this slash search
indicates some kind
03:15 - of software running on Google
servers as of last week
03:18 - that's simply responds to requests.
03:20 - And what did question mark q equals cats
do or represent in that demonstration?
03:27 - AUDIENCE: User input.
03:28 - DAVID MALAN: Yeah, user input.
03:29 - So the question mark just says, that's
it for the file name or the URL.
03:32 - Here comes the user's input.
03:34 - Q is just literally the
HTTP parameter or input
03:38 - that Larry and Sergey,
founders of Google,
03:40 - 20 years ago decided would represent
the user's input, q for query.
03:44 - Equal just means that query that
the human typed in was cats.
03:47 - But the human doesn't
even have to type this in.
03:49 - Once you understand HTTP, if you
really wanted to be kind of a nerd,
03:53 - you could go to
www.google.com/search?q=cats and it
03:58 - would induce the search for you
because at the end of the day,
04:00 - that's all the browser is doing.
04:02 - When you have these web forms that
you now have the ability to create,
04:05 - it's just automating the process
of generating these HTTP messages.
04:09 - Now, the server hopefully responds with
a message you never, ever actually see,
04:13 - HTTP 200, which literally means OK.
04:17 - Of course, many of us have seen numbers
other than 200 appear, like what?
04:22 - 404, which means?
04:24 - File not found.
04:25 - Now, why the humans
decided years ago to tell
04:28 - other humans what that
numeric code is, I mean,
04:31 - that is an uninteresting detail.
04:33 - But the world, for whatever reason,
has revealed in many web sites 404.
04:36 - But it just means the same thing.
04:38 - Everything is not OK.
04:39 - A file was not found.
04:40 - You might see something else like this.
04:42 - We saw this with Harvard,
in fact, curiously,
04:44 - that Harvard had moved permanently.
04:46 - Now, Harvard was responding to
certain queries with HTTP 301s
04:51 - in order to achieve
what feature or effect?
04:55 - Why?
04:56 - Yeah.
04:56 - AUDIENCE: Redirections.
04:57 - DAVID MALAN: Redirections.
04:58 - So this is kind of a low-level
way of describing it.
05:00 - But 301, even though it
says moved permanently,
05:03 - that's a more technical
hint to the browser saying,
05:05 - Harvard moved not to whatever
URL you just came from,
05:08 - but to this URL specifically.
05:10 - And now Harvard was probably, if you
recall, redirecting me from what URL?
05:14 - If I wasn't already at that
URL, where might I have been?
05:19 - Maybe dot com, if they actually own
multiple domains and were redirecting.
05:22 - That could work.
05:23 - What else?
05:23 - Yeah.
05:25 - AUDIENCE: Just HTTP.
05:26 - DAVID MALAN: Yeah.
05:26 - Maybe I just typed in HTTP, and
Harvard, in the interest of security,
05:30 - wants to force my browser to
request this page again via HTTPS.
05:36 - Sometimes a website might prepend
the www if you haven't typed it in,
05:40 - or you can be redirected most anywhere.
05:42 - In fact, if you go to CS50's own
website by just typing CS50.harvard.edu,
05:47 - watch the URL.
05:47 - You'll be redirected to a more specific
page, depending on the time of year.
05:51 - So we use these tricks, as well.
05:53 - 404 not found might look
like this, but inside deeper
05:56 - of that metaphorical envelope is
the actual contents of the web page.
06:00 - So you get back not
only these HTTP headers,
06:03 - as they're called, in the top
of the response, so to speak,
06:06 - but you also get back HTML, yet
another language we looked at,
06:10 - this one actually a language,
but not a programming language.
06:13 - These tags tell the browser
exactly what to do and to render.
06:17 - We introduced this style tag, though.
06:19 - What did that allow us to
do that HTML alone did not?
06:27 - Yeah.
06:29 - Use CSS to beautify the
site and just make it nicer.
06:31 - HTML, for the most
part, is about structure
06:34 - and about tagging the contents
of your web page in a way
06:37 - that the browser finds helpful.
06:38 - But CSS is really for the user's
benefit, at the end of the day,
06:41 - and his or her eyes,
because it really lets
06:43 - you control font size and
positioning and lower-level stuff
06:46 - that you might have started tinkering
with with the most recent problem set.
06:49 - Now, we'd proposed that
you probably shouldn't just
06:51 - start typing CSS inside
of your HTML page
06:54 - because it's just a little harder
to maintain as your examples get
06:57 - more sophisticated.
06:58 - So you might factor it out.
06:59 - And odds are you did
this for the problem
07:01 - set because when making a home
page, if you have the same CSS
07:04 - styles across multiple files, it would
be pretty silly and inefficient to copy
07:08 - and paste them again and again when
you can factor them out like this.
07:11 - Lastly, we looked at
JavaScript, last time,
07:14 - another programming language
that's super similar
07:16 - to see, at least at first glance.
07:18 - But it actually gets rid
of a lot of the lower level
07:20 - headaches like pointers and
memory addresses and that
07:22 - that we've struggled
with in recent weeks.
07:24 - But most important was how we used it.
07:27 - So you can consider a web page like
this as once it's loaded by your browser
07:31 - as just being a tree structure.
07:32 - Thinking back a couple of weeks to
our discussion of data structures
07:35 - and each of these nodes in the tree we
saw in JavaScript can be manipulated.
07:40 - And via that very simple
principle, writing
07:43 - code that modifies this existing
tree in the browser's memory,
07:47 - means you can make much more dynamic
things like Gmail and Facebook
07:51 - and any number of websites
that are constantly changing.
07:53 - You did not do this yet
for the problems set.
07:55 - You made static web pages just
by hard coding HTML and CSS.
07:59 - But starting next week, once we have,
thanks to this week, the vocabulary
08:02 - of Python will you start
to make things more dynamic
08:04 - and then even bring back
into play JavaScript,
08:07 - bringing all of these
various threads together.
08:11 - And to include the JavaScript, recall,
we used either a script tag at the top
08:14 - or refactored it out to a file.
08:16 - Or in some cases, it's
necessary or beneficial
08:18 - to move it down to the bottom of
the file or factor it out like that,
08:22 - but more on that down the road.
08:24 - So any questions on last week or
on HTTP, HTML, CSS, or TCP/IP?
08:32 - No?
08:33 - Anything at all?
08:35 - Oh, yeah?
08:36 - AUDIENCE: So in what case
would you put the script
08:38 - tag up at the top [INAUDIBLE]
08:41 - DAVID MALAN: Good question.
08:42 - So in what cases would you put
the script tag up at the top
08:44 - versus at the bottom?
08:45 - If the code you're writing
in JavaScript manipulates
08:49 - the DOM, the tree that I had on
the screen just a moment ago,
08:52 - the catch is that that tree needs
to exist when your code is executed.
08:56 - So if you, for instance, have JavaScript
code up here in the head of your page,
09:01 - but the nodes in the
tree, the tags that you
09:04 - want to manipulate in changing
things to red to green to blue
09:07 - like we did last week, or making things
blank, are down here in the page,
09:11 - you can't write your code up here
and have it change things in the page
09:14 - down here because it's
happening out of order.
09:16 - So similar in spirit to C where things
have to happen in the right order,
09:20 - if you want to change
something down here,
09:22 - your code needs to at
least be down here,
09:25 - or you need to use some
fancier techniques to say,
09:28 - I'm going to write my code up
here but wait a few seconds
09:31 - before executing it until
the whole webpage is loaded.
09:34 - So for most of the examples we
looked at, this was not an issue.
09:36 - But we'll come back to
this perhaps before long.
09:39 - All right, so let's now
take the same approach
09:42 - that we did last time of introducing
one language by way of another.
09:45 - You'll recall, of course, that we
started the whole semester with Scratch
09:48 - and then we transitioned a few
weeks back now to C. Last week
09:51 - we made some comparisons
with JavaScript.
09:52 - Let's do the same thing
briefly with Python
09:54 - but then spend more time at the
keyboard comparing the two to see
09:57 - what actually is different about these.
10:00 - So why in another
language, though, first?
10:02 - We have Scratch, C, JavaScript,
Python, not to mention HTML and CSS
10:07 - for different purposes.
10:09 - Like, why do we have all of
these darn languages already?
10:11 - Why didn't humans just decide,
that's it, we're all using Scratch?
10:16 - We're all using C or
JavaScript or Python?
10:19 - What's, perhaps, the
intuition behind that?
10:23 - Why are there so many damn languages,
not to mention in this one course?
10:27 - Yeah?
10:28 - AUDIENCE: [INAUDIBLE]
10:29 - DAVID MALAN: Say once more?
10:31 - AUDIENCE: Different ones are
good for different things.
10:32 - DAVID MALAN: Yeah, different ones
are good for different things.
10:34 - And this probably goes without saying
for something like Scratch, right?
10:36 - It's so visual.
10:37 - It's so graphical and animated.
10:39 - It makes sense that the puzzle pieces--
10:41 - or that the language itself
is based on puzzle pieces
10:43 - and dragging and dropping.
10:44 - So maybe languages are tailored
to certain applications.
10:47 - But is that true for C,
Python, and JavaScript, which
10:51 - are all text-based languages we'll see?
10:54 - AUDIENCE: [INAUDIBLE]
for example, they're
10:57 - different levels of abstraction.
10:58 - DAVID MALAN: OK.
10:59 - Different levels of abstraction.
11:01 - AUDIENCE: C is very [INAUDIBLE] actually
dealing with a lot of things that you
11:06 - don't have to think about in Python--
11:08 - DAVID MALAN: Good.
11:10 - AUDIENCE: --where these sort of
things are taken care of for you,
11:14 - such as memory allocations and so on.
11:18 - And so depending on what level of
abstraction you want to work on
11:22 - and what parts you want to manipulate.
11:24 - DAVID MALAN: OK, good.
11:25 - Bringing it back to
abstraction does make sense.
11:27 - C is, indeed, very low level, literally
having the ability to manipulate memory
11:31 - and via pointers and so forth.
11:32 - And that's great because you can do
anything you want with the computer.
11:35 - But it comes at great
risk and great cost.
11:37 - One, the cost is human time.
11:39 - It's just painful to write
that kind of code sometimes.
11:41 - Two, it's also very risky because if you
make a mistake, even a simple mistake,
11:48 - the whole computer can crash.
11:49 - And we didn't see
examples of this, but you
11:51 - can make your code
vulnerable to a hacker
11:53 - if he or she is able to somehow
exploit a memory-related bug
11:56 - and read all of the passwords in
your program, or something like that.
11:59 - So with great power comes
great responsibility
12:01 - is kind of the mantra of C down here.
12:03 - But JavaScript we saw allows us to
do things a little more high-level.
12:07 - There were no pointers.
12:08 - There was no memory.
12:08 - We didn't talk about
things at that level.
12:10 - We talked about things
at the level of a tree,
12:12 - a DOM in memory and changing colors and
positioning of things on the screen.
12:16 - And that's, indeed, a higher level.
12:18 - Now, Python is not
necessarily even web-centric.
12:21 - It's more of a multi-purpose language.
12:23 - People use Python to write
command-line programs,
12:26 - like we will soon, at the keyboard,
like we've been doing with C.
12:29 - You can also, though,
use it, as we'll see
12:31 - next week, to generate other languages.
12:33 - So next week we will
write code in Python,
12:35 - the language we're about to see,
to generate another language, HTML
12:39 - and CSS.
12:40 - Some of you probably noticed in your
homepages that you had some redundancy.
12:44 - You probably had similar
tags or similar structure,
12:46 - maybe a similar menu across pages.
12:48 - Python and other languages
will let us factor that
12:51 - out and generate those
commonalities a lot more
12:53 - easily, among many other things.
12:55 - And it's also arguably
easier and faster to write
12:58 - because it comes with so many more
features, as we will soon see.
13:02 - So in fact-- you know what?
13:03 - Let me do this.
13:03 - Let me go ahead and open up CS50 IDE.
13:07 - Let me go ahead and create a new file.
13:09 - And out of curiosity,
of our recent problem
13:11 - sets, what was maybe among the most
challenging programs you've written?
13:16 - AUDIENCE: Crack.
13:17 - DAVID MALAN: OK, crack was a good one.
13:18 - What else?
13:19 - AUDIENCE: Resize.
13:20 - DAVID MALAN: Resize, recover.
13:21 - Yeah, definitely the forensics ones.
13:22 - And more people probably
did recover and resize.
13:24 - So let's take resize, for example.
13:26 - So let me go ahead and write a program
in a file called resize.py for Python,
13:30 - instead of .c, and see if we can't
spend, what, few hours, couple days,
13:35 - as you probably did in
C, implementing resize.
13:38 - Well, let me go ahead and do this.
13:40 - I'm going to go ahead and--
13:42 - let's see.
13:42 - First I'm going to import some
features that just come with Python.
13:46 - And I'm going to go ahead
and say from sys import argv.
13:50 - And I'm going to go ahead and
also do from pil import image.
13:54 - Don't know yet what these are.
13:55 - We'll tease this apart in a moment.
13:57 - But then let me just do a check.
13:58 - If the length of--
14:00 - rather, if the length of
argv does not equal 4,
14:04 - I'm going to go ahead and exit for the
user and say the usage of this program
14:08 - is Python resize.py
and in file, out file.
14:12 - So even though some of this
should look cryptic at the moment,
14:15 - there's some commonalities--
argv, you recall, from C,
14:18 - and this usage string that we printed
out whenever anything went wrong.
14:21 - That looks very similar in spirit to C.
14:23 - And what did we do in resize?
14:25 - If you implemented resize,
like the less comfy version,
14:27 - to increase the size of things, you
probably declared a variable like an
14:31 - and got sys--
14:33 - or rather, argv bracket
one to get access to it.
14:36 - I'm going to go ahead and convert
that or cast that to an int.
14:39 - You probably had an infile variable
that gave you access to argv two.
14:43 - You probably had an out file variable
that gave you access to argv three,
14:46 - and so forth.
14:47 - And it turns out in
Python, you know what?
14:49 - I can actually use a library, code
that other people have written.
14:53 - Let me come up with a variable
called in image, like infile.
14:56 - This is my input image.
14:58 - And that's going to equal
image.open because I
15:01 - want to open this thing called infile.
15:03 - And then the width--
15:04 - let me get the width and the
height of the existing image
15:07 - by doing input image.size.
15:09 - And then let me go ahead and make a
new image-- out image, I'll call it--
15:12 - which is going to equal the input
image calling a resize function
15:17 - and doing the width times n, which is
the number the human probably typed in,
15:22 - and height times n, which is
the number the human typed in.
15:26 - Then let me go ahead and just
save the outfile as follows.
15:29 - Outfile, OK.
15:32 - Done.
15:33 - Problem set three.
15:37 - Tada.
15:39 - OK, either really exciting or
really, really disheartening perhaps.
15:43 - So with the right language,
as you say, can you
15:45 - solve problems so much more easily.
15:48 - Now, I'm being a little
disingenuous because I'm also
15:51 - leveraging what's called a library.
15:52 - And we had access to these
in C. And undoubtedly
15:54 - we could have dug a little
deeper on the internet
15:56 - into other people's available code and
found maybe a library for bitmap files.
16:02 - But notice that there is no
dealing with padding now.
16:05 - There's no dealing with arrays.
16:07 - There's no dealing with memory because
I'm using the right tool for the job.
16:11 - And if I wrote this
code correctly-- and let
16:13 - me cross my fingers that
I didn't make any typos.
16:16 - Let me go ahead here
and get myself a copy
16:20 - of smiley, which I brought with me.
16:23 - So that was the tiny little
image from last week.
16:25 - Let me go ahead and
open this in the IDE.
16:27 - Smiley, super small.
16:28 - Just a few pixels there.
16:30 - And let me go ahead now and run Python,
which we'll see why in a moment,
16:33 - resize.
16:34 - Let's increase this by a factor of 10,
increasing Smiley, and call it out.bmp.
16:40 - Now let me go ahead and open out.bnp
and voila, it indeed seems to work.
16:45 - Right, no funky colors.
16:47 - No weird sizes.
16:49 - No padding.
16:49 - No padding of all things.
16:51 - It's just now Python.
16:53 - So you can probably glean some of
the logic that's going on here.
16:56 - But some of it certainly should
and probably does look magical.
16:59 - So let's use today to tease this
apart and appreciate not only
17:02 - what you can do with another
language like Python,
17:04 - but how it's similar and
different and how it actually
17:07 - is built upon something like C.
So let's do some comparisons first
17:11 - so that we can see that it's
not a huge stretch to introduce
17:13 - yet another language so quickly.
17:15 - So recall that in Scratch if we wanted
to set a variable, like counter,
17:18 - to zero, you might simply
do something like this,
17:20 - setting it equal to zero at left.
17:22 - In C, we would do the same
thing here at the right.
17:24 - In JavaScript, this instead
looked a little different.
17:27 - What did we do in JavaScript?
17:29 - Yeah, we used let instead because we
don't specify explicitly the type.
17:33 - But we do need to tell the computer, let
me have this variable called counter.
17:37 - In Python, it's going to be that.
17:41 - So we've gotten rid of the type still.
17:43 - We've gotten rid of any mention
of let or another keyword.
17:46 - And we've gotten rid of--
perhaps most gratifyingly--
17:50 - semi-colons are gone.
17:52 - No more semi-colons.
17:53 - And no more curly braces in the
way you've seen them thus far.
17:56 - So that was C, JavaScript,
and now Python.
17:59 - So how about something like this?
18:00 - In Scratch, if you wanted to
increment a counter by one,
18:03 - you would use a block like this.
18:04 - In C, we would do the same
on the right here in code.
18:07 - In JavaScript, did it look
any different on the right?
18:13 - No.
18:14 - You haven't had occasion
to use this yet.
18:16 - But one of the sort of revelations of
JavaScript was that's also JavaScript.
18:20 - It was identical.
18:21 - Something like this, though, is Python.
18:24 - So it's almost the same.
18:26 - But I've gotten rid of the semi-colon.
18:27 - But the logic is exactly the same--
18:29 - set counter on the left equal to
whatever it is on the right plus one
18:32 - additional value.
18:33 - What about this?
18:34 - This in C had what effect?
18:38 - Incrementing the variable.
18:39 - So this is exactly the same.
18:40 - It's sort of a nice shorthand
notation for doing counter equals
18:43 - counter plus 1, which just
gets a little tedious to type.
18:46 - We had that same syntax in JavaScript.
18:48 - And you can probably guess in
Python, what's it going to look like?
18:51 - AUDIENCE: Same thing without the--
18:52 - DAVID MALAN: Same thing
minus the semi-colon.
18:54 - So pretty nice pattern so far.
18:56 - Languages just keep getting
trimmer and trimmer, if you will.
18:58 - In C, recall that we
could just do plus plus,
19:01 - which was another trick for
automating that same process.
19:04 - JavaScript allows for the same.
19:06 - And if you really like this syntax,
I can't show you a slide for Python.
19:09 - Doesn't exist.
19:10 - Can no longer do plus plus.
19:11 - So we're paying a price.
19:13 - The author of Python did not
include this in the language.
19:15 - But that's OK.
19:16 - We at least have this one,
which is not too horrible.
19:18 - So what else did we look at last time?
19:20 - An if condition like this,
comparing if x is less than y,
19:23 - in C it looks like this.
19:25 - In JavaScript it looks
like this same thing.
19:27 - In Python, it looks like this.
19:31 - So gone are the curly braces.
19:34 - Added is a colon.
19:36 - And what you don't see yet is that
indentation is going to be important.
19:40 - So any of you have been a little
fast and loose with style 50
19:43 - and, like we've seen at office
hours, all of your code,
19:46 - however many lines you've
written for whatever reason
19:48 - is all aligned on the left and
nothing is actually indented.
19:50 - Now Python is not
going to tolerate that.
19:52 - Python requires indentation for logic.
19:55 - And so this is actually a
stylistic feature of the language.
19:57 - It forces you to adopt good visual
stylistic habits because the code just
20:02 - won't run if you haven't
indented it properly.
20:04 - So anything that's going to
happen if x is less than y
20:07 - needs to be indented, say, four
spaces underneath that colon.
20:11 - What else have we seen?
20:12 - In C or in Scratch we had
this block for if's and elses.
20:14 - In C it looks like this.
20:16 - In JavaScript it looks like this.
20:18 - In Python it's going to look like
this, albeit with indentation
20:21 - below each of those colons.
20:23 - How about this?
20:23 - When we had three-way a fork in
the road-- if else, if else--
20:27 - in C it looks like this.
20:28 - JavaScript looked the same.
20:30 - In Python, looks a little funky.
20:32 - It's going to look like this--
20:34 - elif but three colons, this time two.
20:36 - What else?
20:37 - We also looked at forever loops in
Scratch, in C, and in JavaScript.
20:41 - You could use exactly the same
syntax in Python, almost the same.
20:45 - Gone are the curly braces,
added is the colon.
20:48 - And the slight subtlety, if
you noticed, true and false
20:52 - are now proper nouns, if you will.
20:54 - Capital T capital F
is necessary to write.
20:56 - How about a for loop?
20:57 - So in Scratch, we could very
easily say, repeat this 50 times.
21:00 - C and JavaScript is a little
pedantic in that you have
21:03 - to initialize and increment and check.
21:05 - Both C and JavaScript
take that same approach,
21:08 - although in JavaScript we of
course use let instead of int.
21:11 - Python is a little more succinct
although a little less explicit
21:15 - step by step.
21:16 - You just do this.
21:17 - For i in range of 50 is the way
of saying start iterating at 0,
21:23 - count all the way up to
but not including 50,
21:25 - thereby giving you a range of values.
21:28 - So this is the one that's
perhaps the most weird
21:30 - thus far, but still a little
more succinct to write.
21:33 - So in C, we had so many data types--
bool, char, double, float, int, long,
21:37 - string--
21:37 - the last of which, of course,
came from the CS50 library.
21:40 - And there's others
that you can use in C,
21:42 - as you might recall, from
problem set 3, perhaps.
21:44 - In Python, we're going to shorten
this list, at least initially,
21:47 - to just these data types.
21:48 - In Python, we're going to have bools
for true-false, floats for real numbers,
21:52 - ints for integers, and
then strs for strings.
21:56 - Just a little more succinct, but it
does actually exist. str in Python
21:59 - is a real thing.
22:00 - It is not a CS50 addition.
22:02 - There are other data types
that come with Python.
22:04 - In fact, this is where the
language gets powerful.
22:07 - And those of you who came
from a Java background or C++,
22:11 - the subset of you who
have programmed before,
22:13 - you have more features in Python just
like you do in those other languages
22:16 - that we did not have in C. In Python,
you have dictionaries or hash tables.
22:21 - You have lists, which are arrays,
but that can automatically resize.
22:25 - You don't have to decide in
advance how big or small they are.
22:28 - Range we just saw, it's a range
of values, like 50 of them,
22:31 - set in the mathematical sense.
22:33 - It's a collection of things
that ensures you don't
22:35 - have duplicates in that collection.
22:37 - And then tuple is a combination
of things kind of like for math
22:40 - when you have x comma y or
latitude comma longitude.
22:43 - Any time you have pairs or
triples or more of things,
22:46 - those are called tuples.
22:47 - And those are common in math courses
and higher-level CS theory classes,
22:51 - as well.
22:52 - But we do give you, at
least in this first week
22:54 - of our look at Python, a
few functions from CS50,
22:57 - among them getFloat, getInt, and
getString, which behave exactly
23:01 - like their C counterparts.
23:02 - And this is just going
to allow us to start
23:04 - writing code very reminiscent of
what we did the last few weeks.
23:08 - But let's consider
what's going to change
23:10 - as we're about to start
writing our own programs.
23:12 - In C, when you wanted to use
the CS50 library, you of course
23:16 - included its header file.
23:17 - That syntax is going to change in
Python so that for this first week when
23:20 - you want to use the CS50 library,
you're going to instead say
23:24 - from CS50 import and then a comma
separated list of the functions
23:29 - that you want to import
or use in your code.
23:31 - So it's a little more precise.
23:32 - This syntax is not saying
give me everything.
23:34 - Give me this, this,
and this other thing.
23:36 - And if you want to use one or more,
you can just separate them by commas.
23:39 - As an aside, especially those of
you who have seen Python before,
23:42 - there's other ways to do this.
23:44 - There are several approaches.
23:45 - This is, perhaps, the most
comparable for our purposes today.
23:48 - What else are you're
going to have to know?
23:50 - In C you had to compile your code.
23:52 - And you did so with clang, like this.
23:54 - And then you ran your
program with dot slash hello.
23:57 - Or more simply, you
did make hello and then
23:59 - we'd figure out the command for you
in the IDE or the sandbox or lab.
24:02 - In Python, you're going to
skip the compilation step.
24:05 - When you want to run
a program in Python,
24:07 - you're going to do just
what I did quickly before.
24:09 - You're just going to run the command
Python and then the name of the file
24:13 - that you want to run.
24:14 - And the reason for this is as follows.
24:16 - In the world of C, recall that we
had this sort of pipeline process
24:20 - where we have our source
code as our input.
24:24 - And then we wanted to get to the point
of machine code, the zeros and ones.
24:29 - And what was standing in between
source code and machine code,
24:32 - just to be clear?
24:34 - What process?
24:36 - Yeah, so compiling.
24:37 - So we had a compiler in the
middle whose purpose in life
24:40 - is by definition to translate
one language to another.
24:44 - It happens to be an English-like
language to a computer-like language,
24:47 - but a compiler is a general term that
just converts one thing to another.
24:50 - And so this pipeline
for C looked like this.
24:53 - And that's why you had to run
Clang explicitly, or make.
24:56 - You had to induce that
middle man operation
24:58 - to convert the language to
something the computer understands.
25:01 - Python and other languages are not
typically compiled in the same way.
25:06 - They're generally said
to be interpreted,
25:09 - whereby you don't compile
them into zeros and ones
25:11 - and then run the program.
25:12 - You instead run a program that
someone else wrote called Python.
25:17 - And that program is, by
definition, an interpreter.
25:20 - And that interpreter's
purpose in life, as the word
25:22 - implies, is to read your code
top to bottom, left to right,
25:25 - and just do exactly
what you tell it to do,
25:27 - step by step by step, without doing
the upfront work of converting things
25:32 - to zeros and ones.
25:33 - So in the human world, if I
speak English and someone there
25:35 - speaks Spanish and we don't
speak each other's language,
25:38 - we might put a third human in between
us, obviously a human interpreter.
25:41 - The role is very similar.
25:43 - The interpreter listens
to me and then translates
25:45 - that to something the
computer understands.
25:46 - But it doesn't get into zeros and ones.
25:48 - It just goes from one
directly to the other.
25:51 - So the difference here in
Python is that you still
25:53 - are going to write source code,
like I quickly did for resize.
25:56 - And ultimately, we
want to actually get it
25:59 - into a program called an interpreter.
26:04 - And so the step ideally
just looks like this.
26:07 - But as an aside, Python is a
pretty sophisticated language.
26:11 - And even though we have the
pleasure of running it just
26:14 - with one step instead of these two
steps, there actually is, as an aside,
26:18 - some magic going on underneath the hood.
26:21 - And for the curious, there actually
is, for performance reasons,
26:25 - a compiler built into Python that
actually converts it to something
26:28 - intermediary called bytecode.
26:31 - And bytecode is what's
actually interpreted.
26:34 - And so this is why Python,
while potentially slower than C
26:38 - at certain tasks because you're not
going to the low level zeros and ones,
26:42 - can actually be used in business
applications and popular websites
26:45 - and such.
26:45 - And that didn't really work very well.
26:47 - And so it can be highly
performing, as well.
26:51 - But more on that in a little bit.
26:52 - So with that said, if these
are the differences not only
26:55 - syntactically but also
mechanically, let's go ahead
26:58 - and actually write a program.
27:00 - So let me go ahead and go into the IDE.
27:03 - Let me close our examples from before.
27:04 - And let's start more simply because
resize was a mouthful all at once.
27:07 - Let me go ahead and create
a file called hello.py.
27:10 - And instead of writing
this program in C,
27:13 - let me go ahead and
just write hello world.
27:15 - So let's go ahead and do this.
27:17 - Print hello world.
27:19 - Done.
27:20 - That's my first program in Python,
and truly my first program in Python,
27:23 - not sort of coming out
swinging with resize.
27:26 - So what is not present in this file
that was in something like hello.c?
27:32 - There is no main
function necessary here.
27:35 - What else is missing?
27:37 - AUDIENCE: Printf.
27:38 - DAVID MALAN: There is
no mention of printf.
27:39 - It's instead print, which is
a little more human friendly.
27:41 - AUDIENCE: Libraries.
27:42 - DAVID MALAN: There is no mention
of header files or libraries
27:45 - at the top of the file.
27:46 - I just dived right in and got to it.
27:48 - Yeah?
27:49 - AUDIENCE: No semi-colons.
27:50 - DAVID MALAN: No semi-colons.
27:51 - What else?
27:55 - What else?
27:55 - Yeah?
27:56 - AUDIENCE: No backslash n.
27:57 - DAVID MALAN: No backslash n.
27:58 - I probably-- I haven't
run it yet, but I think
28:00 - I will get that for free
this time with Python.
28:02 - I don't have to be so explicit.
28:04 - Was there another hand here?
28:06 - AUDIENCE: There's no f in printf.
28:08 - DAVID MALAN: There's
no f in printf, yep.
28:10 - Something else?
28:14 - There's no indentation.
28:15 - Though to be fair,
there's only one line.
28:16 - But there's no indentation.
28:18 - That's fair.
28:18 - That's fair.
28:19 - There's no curly braces, as well.
28:21 - There's no mention of int.
28:22 - There's no mention of void.
28:23 - I mean, my God.
28:24 - Why didn't we just do this last time?
28:26 - And so this is why languages evolve.
28:29 - People realized years ago,
gee, C is serving us well.
28:32 - Once I understand pointers
and the syntax, OK, I got it.
28:35 - But my God, it's just so tedious to
write even the simplest of programs
28:38 - because I have to do hash includes,
standard io.h, int main void, I mean,
28:42 - all of this syntactic overhead
that's getting in the way of you just
28:46 - doing the work you care
about, which in simplest form
28:48 - here is just printing hello world.
28:50 - So Python and a lot of more
modern languages-- among them,
28:53 - Ruby and PHP and others--
28:56 - just get rid of a lot of that
overhead so that you can just get down
28:58 - to work more quickly right away.
29:01 - So how do I go ahead and run this?
29:02 - In C, recall, I would have
done dot slash hello.py.
29:06 - But we just said a moment ago
that's not the right approach.
29:09 - How do I go and run this program?
29:11 - Yeah, so I run literally a program that
is coincidentally called Python itself.
29:16 - That is the interpreter.
29:17 - That's the man in the middle between
me and my Spanish-speaking friend that
29:20 - just has to convert hello.py
into whatever the computer itself
29:25 - understands.
29:26 - And so there, indeed,
we have hello world.
29:28 - And as you notice, there's
no backslash n on my code.
29:30 - But I am moving the
cursor to the new line.
29:33 - So Python just decided, you know what?
29:34 - It's so damn common to have new lines,
let's just add those by default.
29:37 - You know, the price we're
going to pay is it's
29:39 - a little annoying to get rid of them.
29:41 - But we'll see that in a little bit, too.
29:43 - So just a tradeoff.
29:44 - All right, let's do another one.
29:45 - That's just a simplest
of possible programs.
29:48 - Let's go ahead and do, say,
something a little fancier
29:51 - that allows us to do
something more than that.
29:54 - So let's go ahead, say,
and compare not just
29:58 - that, but let's actually
go get some user input.
30:00 - So for user input, there's
a few ways to do this.
30:03 - We'll do it the CS50 way initially,
but these are training wheels this week
30:06 - that we'll use for just a
week before we take them off,
30:08 - just bridging us from C to Python.
30:11 - Let me go ahead and
call this string zero.py
30:13 - because I'm dealing with strings.
30:15 - And let me go ahead and do
s to give me a variable.
30:18 - Get string.
30:19 - Let me prompt the human for his or her
name like this and then let me go ahead
30:23 - and say hello.
30:24 - And so and now I just have to
consider how to print out their name.
30:28 - And in Python, I can
actually just do this.
30:30 - I don't need to do percent s.
30:32 - I don't need to put a second-- or, I
do need to put a second comma here.
30:36 - But I can just do this,
which is a little simpler.
30:39 - And this is not correct.
30:40 - I'm not practicing what I preached.
30:43 - Get rid of the f.
30:44 - Just print what you
want to print, indeed.
30:46 - So s, notice, is apparently a
variable because I'm assigning
30:49 - it a value from right to left.
30:51 - But notice that I'm not
specifying the type.
30:53 - So Python does have type. str we
said is the string equivalent.
30:57 - But you don't have to mention it.
30:58 - Python, like JavaScript, will just
figure it out, even without a keyword
31:01 - like let.
31:02 - But I do need to add one thing.
31:05 - What's that?
31:05 - AUDIENCE: You need to
import the getString?
31:07 - DAVID MALAN: Yeah,
getString is a CS50 thing.
31:09 - And we're only going to use it for
a week, but I do need to import it.
31:12 - And the syntax with which to do this
is to say, from the CS50 library,
31:15 - import a function called get string.
31:17 - I don't need to import
any more with commas.
31:20 - That one suffices for this program.
31:21 - Yeah.
31:23 - AUDIENCE: Would you want to--
31:25 - instead of saying hello your name, would
you want to first getName that says
31:29 - [INAUDIBLE]?
31:32 - You're not indicating where
the error is [INAUDIBLE]..
31:35 - DAVID MALAN: Sure, let me come
back to this in one second.
31:37 - Let's run this program first
to demonstrate that it indeed
31:40 - does what we saw it do last week.
31:42 - And let me go ahead here and do
this time Python of string 0.
31:50 - Let me go ahead and it's
just waiting for my name.
31:53 - So I'll type in David.
31:54 - Hello, David.
31:54 - But as you propose, what if
you wanted to flip this around?
31:57 - Well, suppose I wanted to say
the person's name and then
32:01 - something like hello because I'm
just excited to see them, instead.
32:06 - Let's see what this does.
32:07 - Let me go ahead now and
run Python of string 0.
32:10 - Type in my name.
32:12 - And it's almost what
I think you intended.
32:14 - But there is a bug--
32:16 - an aesthetic bug, at least.
32:17 - So it seems with Python's
print function you don't need
32:19 - to use the placeholder like percent s.
32:21 - But it would seem to presumptuously add
a space for you after everything you're
32:27 - passing in as an input to print itself.
32:31 - So notice print is
taking how many arguments
32:33 - according to this highlighted portion?
32:37 - How many arguments might you infer?
32:39 - AUDIENCE: S space and then the thing.
32:42 - DAVID MALAN: Two?
32:43 - Yeah, so two.
32:44 - One is s, comma, and then the rest
is what's highlighted in green here.
32:48 - Yes, there's a second comma there,
but it's inside of the string.
32:51 - So just like in C, that's
sort of a red herring.
32:53 - There's only two arguments here.
32:54 - But it seems that the print
function-- and you would know this
32:56 - by reading that documentation-- if you
pass in two or three or more arguments,
33:00 - it prints all of them.
33:01 - But separates them with a single space.
33:02 - So this isn't quite right.
33:03 - So this is actually a great
motivation for cleaning this up.
33:06 - If I want to actually improve this
program and tidy it up a little bit,
33:10 - let me do that in version one here.
33:11 - Let me create another file
called, say, string1.py.
33:15 - Let me start where we
started a moment ago.
33:17 - And let me actually use a placeholder
akin to C. So if I want to do,
33:21 - for instance, hello so-and-so, it turns
out you can actually say, hey Python,
33:27 - put a variable called s right here.
33:30 - However, if I run this as is,
there's still going to be a bug.
33:34 - It's not quite solved yet.
33:36 - But when I hit Enter now
and type in my name--
33:38 - all right, this is
obviously stupid looking.
33:41 - So it seems that I need to tell Python
that this string that I'm passing in,
33:45 - hello comma so and so,
is a formatted string.
33:48 - It's a placeholder string that
it should make some changes to.
33:52 - And this is a little weird,
cryptic syntactically in Python.
33:55 - But the way you do this in Python is
you put an f before the string itself.
34:01 - So I'm sorry, we got rid
of the f a moment ago.
34:04 - So we just called it print.
34:05 - Now we're reusing a different f here.
34:07 - And it's stupid-looking
syntax, admittedly.
34:09 - But this just means hey, Python,
the following double quotes
34:12 - or single quotes that
you're about to see should
34:14 - be formatted by you in a special way.
34:16 - And it literally goes at
the beginning of the string
34:18 - even though that does
admittedly look weird.
34:21 - But if I now rerun this Python
string one and type in my name now,
34:24 - now it does the substitution.
34:26 - So I can flip it around
logically much more flexibly now
34:29 - and do something like hello because
now I'm passing in one argument
34:33 - that print will format for me.
34:35 - So when I type in my name now, I'm not
going to get that superfluous space.
34:38 - And now I have complete control
over the formatting of the string.
34:42 - So you know, sort of two steps forward,
one step back, perhaps, syntactically.
34:46 - But it does allow us to do
what we want this to do.
34:48 - We could write the
same program using ints
34:50 - and floats using getInt and getFloat.
34:52 - Would look exactly the same.
34:53 - You don't need to worry about percent
s versus percent i versus percent f.
34:57 - You just type in the variable
name inside of those curly braces.
35:01 - All right, let me go ahead
and do some quick math.
35:04 - Let me go ahead and do this.
35:06 - Let me go ahead and create a new file.
35:07 - We'll call this ints.py for integers.
35:10 - And let me go ahead and
get this access to--
35:13 - how about the CS50 library's get
int method or function which exists.
35:18 - Then let me go ahead
and declare a variable
35:20 - called x and get an int from the user
and just prompt him or her for x.
35:23 - Then let me go ahead
and do the same thing
35:25 - and just get y from them, as well.
35:27 - And then down here, let me
just do some simple math.
35:29 - And we did this way back in
week one by printing as follows.
35:34 - Let me go ahead and just
print out x plus y equals--
35:38 - and this is what's cool now
about this curly brace feature.
35:42 - You can actually do not
just variable's names,
35:46 - but you can do simple
operations in there, too.
35:48 - I can literally do math inside of those
curly braces and print out that value.
35:52 - But of course, this alone is just going
to literally print the curly braces.
35:55 - What do I have to add?
35:56 - Yeah, so it looks a little weird.
35:58 - But this now will solve that problem.
36:00 - It will print literally x plus y
equals whatever the actual sum is.
36:05 - AUDIENCE: Just following
up, what does f mean?
36:07 - DAVID MALAN: Format.
36:08 - Format the following string for me.
36:10 - Good question.
36:11 - Let's do just a few copy/paste
but change the operator here.
36:14 - So x minus y, I want to
see what this looks like.
36:19 - X, say-- what did we do last time?
36:21 - Multiplying by y.
36:22 - I want to do that math, too.
36:23 - I can divide as well.
36:26 - And then we had one
more, which was modulo,
36:29 - or modular arithmetic, which,
recall, was the percent sign.
36:31 - So syntactically, it's identical to see.
36:33 - We're just adding this curly brace
notation just for the print function
36:36 - right now.
36:37 - Let me go ahead and run this.
36:38 - Python of ints.py.
36:40 - And let me go ahead
and do one and say two.
36:44 - So 1 plus 2 is 3.
36:46 - 1 minus 2 is negative 1.
36:48 - 1 times 2 is 2.
36:50 - 1 divided by 2 is 0.5.
36:53 - And 1 then divide by 2 and
take the remainder is 1.
36:57 - So I think this checks
out mathematically.
37:00 - But you should be a little
surprised by one of these outcomes.
37:06 - Say again?
37:07 - AUDIENCE: You're getting a float.
37:08 - DAVID MALAN: Yeah, I'm getting a float.
37:10 - Like, Python itself seems to
have fixed a bug in C itself.
37:14 - What happened in C when you divided
1, an integer, by 2, an integer, in C?
37:20 - You would get another integer.
37:21 - And what's the closest
integer you can represent
37:23 - that doesn't have a decimal point?
37:26 - 0, because the C would truncate
everything after the decimal point.
37:29 - And yet, Python seems to
have fixed this problem.
37:32 - And this is actually a
somewhat recent phenomenon.
37:34 - And this a huge religious
debate as to whether or not
37:36 - you should just keep the historical
definition of division, which
37:40 - is floor division, so to speak, or
we should make it truly division,
37:44 - like we all grew up learning in school.
37:45 - Python took the latter approach and made
division mean division, true division,
37:50 - where if you divide two
ints you get back a float.
37:52 - Of course, this is a
problem if people want
37:54 - to write code that assumes that
it's going to be truncated.
37:56 - That can actually be a powerful feature.
37:59 - So it turns out, and you won't have
terribly many occasions to use this,
38:02 - but the compromise in the world
was, all right, if you really
38:05 - want the old behavior of the division
in Python, we will give it back to you.
38:11 - You have to use two slashes.
38:12 - So again, another one of these
two steps forward, one step back.
38:15 - But it's there, so problems can
still be solved in the same way.
38:18 - And this, if I save it and
rerun that same code, 1 and 2,
38:22 - now I get back 0, just as I would in
C, which does have some applicability.
38:27 - Let's do one other example
now involving some numbers.
38:29 - And let me go ahead and
call this floats.py.
38:32 - And let me do the same thing, from
CS50 import getFloat this time.
38:36 - So I can deal with
floating point values.
38:38 - Let me declare a variable
x and get a float
38:40 - and we'll ask the user for a variable x.
38:42 - Then let's go ahead and get another
float, and just as before, call it y.
38:45 - But this time both of
them are, indeed, floats.
38:47 - Then let me go ahead and do
some math, x plus y equals z.
38:51 - Let's give myself a third variable.
38:52 - And then let me just go ahead
and print out a similar message--
38:55 - x divided by y equals z.
39:00 - All right, and let me go ahead
and save this, clear my terminal,
39:03 - and do Python of floats.py.
39:05 - 1 divided by 10 this time.
39:08 - And I get-- dammit, bug.
39:09 - How do I fix this?
39:11 - All right, so just a simple f.
39:12 - Make it a format string.
39:13 - No big deal.
39:14 - So let's rerun this, 1, 10.
39:16 - OK, hoo, hoo.
39:19 - That's a new one.
39:21 - What is going on there?
39:27 - AUDIENCE: [INAUDIBLE]
39:29 - DAVID MALAN: I did define z in the line
above it, and what was your comment?
39:32 - AUDIENCE: You used x plus y.
39:33 - DAVID MALAN: I did use x
plus y, but I think I--
39:36 - oh, wait, OK.
39:37 - I'm sorry.
39:37 - Let's-- OK, so we can fix that.
39:41 - Let's-- sorry.
39:44 - There.
39:45 - OK, so 110.
39:48 - Hmm, still wrong.
39:51 - Good catch, thank you, though.
39:54 - Why is 1 plus 2 11--
39:57 - or 1 plus 10, 11?
40:01 - Yeah?
40:01 - AUDIENCE: [INAUDIBLE].
40:03 - DAVID MALAN: Wait, wait, wait.
40:04 - Sorry.
40:06 - AUDIENCE: [INAUDIBLE]
40:08 - [LAUGHTER]
40:10 - DAVID MALAN: This brings me back to
my earlier point as to how tired I am.
40:13 - So this is correct.
40:14 - So Python does math correctly.
40:19 - But-- OK, horrifying.
40:21 - All right, so now let's
do division and try
40:24 - to make the point I think I meant to
make late last night where I if I do 1
40:28 - divided by 10, OK, 1 divided by 10,
as expected, does actually work here.
40:35 - So 0.1, that's correct.
40:36 - But remember in C-- let me
dig myself out of this hole--
40:39 - remember in C what happened
if we dug a little deeper
40:42 - and we looked a little past
the first decimal point.
40:44 - So how do I do this in Python?
40:46 - It's actually pretty similar.
40:47 - Let me go ahead and not just
show myself z but go ahead
40:50 - and print out to, let's say, two
decimal places that same value.
40:54 - The syntax here is weird.
40:56 - It's different from C. But you literally
take the variable that you want
40:59 - to format, you put a
colon and then a dot--
41:02 - because you want to adjust the dot--
41:03 - and then you want to
say something like 2f.
41:06 - So this is saying, hey,
Python, format the variable
41:09 - that's to the left of the
colon using two decimal points.
41:13 - And by the way, it's a
floating point value.
41:15 - So this f has a different meaning.
41:16 - This is f as in float.
41:18 - The f to the left is in format.
41:20 - So let me go ahead and run this.
41:22 - 1 divided by 10.
41:23 - And OK, still looking pretty good.
41:25 - Let's do maybe three decimal
places, save that, rerun it.
41:28 - 1 divided by 10.
41:30 - Still pretty good.
41:31 - Let's get a little ambitious.
41:33 - Let's do it 50 decimal places
out, 1 divided by 10, and damn it.
41:37 - Python has not fixed
this fundamental problem.
41:40 - So we describe this problem as what?
41:45 - What's the sort of buzzword here to
sort of explain or forgive this issue?
41:50 - AUDIENCE: [INAUDIBLE]
41:51 - DAVID MALAN: This is an integer
overflow, related in spirit.
41:53 - Integer overflow literally
happens when you're
41:55 - doing lots of addition and something's
rolling over from a big value
41:58 - to a small or even a negative.
42:01 - Similar in spirit.
42:01 - Yeah?
42:02 - AUDIENCE: [INAUDIBLE]
42:08 - DAVID MALAN: Yeah.
42:08 - If you want to have an infinite
amount of precision all the way out,
42:12 - you need an infinite amount of memory.
42:13 - And no Mac or PC or phone has
an infinite amount of memory.
42:16 - At some point, a line is drawn in the
sand and you can only be so precise.
42:20 - And so imprecision was the analog
in the floating point world
42:24 - to overflow, recall, where if you
only have a finite number of bits
42:27 - you can do really well up to a point.
42:29 - But eventually, the computer's
got to estimate that value for you
42:32 - because you can't represent
an infinite number of values.
42:35 - So this is to say Python is
just as limited, fundamentally,
42:38 - as some other languages
like C. So we've not
42:40 - gotten rid of all of those problems.
42:42 - But frankly, in the world of
data science and analytics,
42:45 - it's certainly important
precise mathematics.
42:47 - So there are solutions to this problem.
42:49 - But it requires special
libraries, typically,
42:52 - importing something that allows
you to use as much memory
42:55 - as you want more than just
the default amount of memory.
42:58 - So that problem there still exists.
43:00 - Let me go ahead and open
up one other example here.
43:03 - And in fact, in C, you'll recall
that we had this example here.
43:07 - In C we had a program called overflow.c.
43:13 - And notice that this code
in C from a few weeks
43:16 - back just multiplied i by 2, by 2, by 2.
43:19 - So it was doing
exponentiation, so to speak--
43:21 - 1 to 2 to 4 to 8, 16,
32, 64, and so forth.
43:25 - What happened if we waited
long enough and watched
43:27 - this program a few weeks back?
43:30 - AUDIENCE: You go to 5
billion instead of--
43:32 - DAVID MALAN: Yeah, we hit
roughly 5 billion or 4 billion--
43:36 - or rather, we technically hit, I think,
2 billion, and then it rolled over.
43:39 - And it actually created a problem.
43:41 - So let me actually do this.
43:42 - Let me go ahead and make
overflow so we can demonstrate
43:44 - the points that you made earlier about
integer overflow, which is, indeed,
43:47 - this one.
43:48 - Let me go ahead now and run overflow.
43:50 - I'll expand my window just so we
can fit a little more in the screen.
43:54 - And as this runs--
43:55 - whoops, let me fix this.
43:57 - Here we go.
43:59 - Let me go ahead and make overflow.
44:01 - And now 1, 2, 4, 8,
16, 32, and so forth.
44:06 - It's a little slow to start,
but doubling and doubling
44:08 - is going to get us up to a
big value pretty quickly.
44:11 - This is indeed going to overflow
once we hit roughly 2 billion.
44:13 - Why?
44:14 - Why two billion, give or take?
44:16 - Why that value in C?
44:18 - Yeah?
44:19 - AUDIENCE: [INAUDIBLE]
44:21 - DAVID MALAN: Yeah, that's
how much an integer
44:23 - can store because we're calling C. An
int is typically 32 bits or 4 bytes.
44:27 - And with 32 bits, you can represent
four billion possible values.
44:31 - And if half of those values are
positive and half of them are negative,
44:34 - it stands to reason that the highest
you can count is roughly 2 billion.
44:37 - And indeed, once we try to count up
just doubling one billion, we overflow.
44:41 - So to your point earlier,
overflow is still an issue,
44:44 - but in the context of integers.
44:46 - But now let's try a
Python version of this.
44:49 - Let me go ahead now and
open up overflow.py,
44:52 - which is a program I wrote in advance.
44:54 - It's on the course's
website, as always, if you
44:56 - want to take a look more closely.
44:58 - And if I go into this file in weeks
one, overflow.py, we see this code.
45:04 - So it's almost the same.
45:05 - But notice I'm using another
library that we've not
45:07 - seen before, from time import sleep.
45:09 - It's kind of cute.
45:10 - So this allows me to sleep for a second.
45:12 - That's going to get tedious
quickly, but that's OK.
45:14 - Let's do this real fast.
45:15 - If I go into the source
six directory, weeks one,
45:18 - and run Python of overflow.py, it's
the same function-- or same program,
45:23 - functionally.
45:24 - But honestly, this is
getting a little tedious.
45:26 - Let's go ahead and not sleep for a
second every time, save and reload.
45:31 - Let's just run the thing.
45:32 - Whew, look at it go.
45:35 - Only up there.
45:36 - Look up there.
45:38 - What's it doing differently?
45:42 - It's counting a lot
higher than 2 billion.
45:44 - So what might you infer
about integers in Python?
45:47 - AUDIENCE: [INAUDIBLE]
45:48 - DAVID MALAN: Say again?
45:50 - AUDIENCE: An integer is defined
to be quite a number of bits.
45:54 - DAVID MALAN: OK, an integer is
defined to be quite a number of bits.
45:57 - And indeed, that's the case.
45:58 - Python is not actually this slow.
46:00 - It's because we're running a web
based IDE and the internet itself
46:02 - is a little slow.
46:03 - And so what's happening here is just
the internet is getting in the way.
46:06 - But suffice it to say that Python is
counting up way, way higher than C was.
46:10 - And that's the power you get by
just using larger data types.
46:13 - We could have done this in C. We
could have used longs, for instance.
46:16 - But notice that with Python you just
get more by default out of the box.
46:20 - Let's go ahead and take
a five minute break here.
46:22 - And when we resume, we'll
introduce some more syntax
46:24 - and solve some more problems.
46:25 - All right, so let's take a
look at a few other examples
46:28 - that are comparable to what we did
back in week one and look at a few
46:31 - from week two and three
and really take a look
46:34 - not just at the syntax, ultimately,
but some of the features of Python.
46:37 - And of course, we need the ability
to express ourselves conditionally
46:40 - or logically with control flow.
46:42 - And so let me propose
a quick program here
46:44 - that we'll just call conditions.py,
reminiscent of conditions.c
46:47 - some time ago.
46:48 - Let me go ahead and import
from CS50 getInt this time
46:52 - and get myself another x
with getInt x from the user.
46:56 - Then let me go ahead and ask
them for getInt y from the user.
47:00 - And then let me go ahead
and just compare them.
47:02 - And so per our comparison
with Scratch a bit ago,
47:04 - I can simply say if x is
less than y, then go ahead
47:08 - and print out, for instance, print x is
less than y, just as we did weeks ago.
47:14 - Elif if x is greater
than y, we can go ahead
47:16 - and print out x is greater than y.
47:20 - And then we can still have a
third condition, else, just
47:23 - like in C, where we print out, for
instance, the logical conclusion.
47:26 - x is equal to y.
47:28 - So just to point out
some of the differences,
47:30 - indentation is ever so important now.
47:32 - And it's got to be consistent.
47:33 - You can't have four spaces and three.
47:35 - You've got to have, for
instance, four all the way.
47:37 - Notice that I've got the
colons consistently there.
47:39 - But notice that I don't need the
parentheses, either, anymore.
47:44 - And with Python, there's
sort of a buzzword, Pythonic.
47:46 - There is a Pythonic way of doing things.
47:48 - You can have parentheses around x,
less than y, or x greater than y,
47:53 - just like in C. But it doesn't
add anything logically, arguably.
47:56 - And if it doesn't make
your code more readable,
47:58 - don't clutter your code
with additional characters.
48:00 - And so that's a general
rule of thumb now.
48:02 - Python is much more trim
when it comes to syntax, only
48:06 - introducing it when it really solves
a problem, which in this case,
48:08 - it doesn't really.
48:09 - Yeah?
48:10 - AUDIENCE: Quick question,
the lines [INAUDIBLE],,
48:12 - those are grouped right together,
one to the next, one to the next,
48:15 - and one to the next.
48:16 - If you were to put an
additional line between them,
48:18 - would that break the code?
48:19 - DAVID MALAN: No, not at all.
48:20 - I can have as much whitespace
vertically as I want if.
48:23 - I want to add some comments,
indeed, I can do that.
48:25 - And why don't we do that, in fact,
because the commenting syntax
48:27 - for Python is a little different.
48:29 - In C, we were in the habit
of doing slash slash.
48:31 - Python, it's actually
a little more succinct.
48:33 - You can just use a single hash.
48:34 - And you can say gets x from user here.
48:37 - I can say get y from user here.
48:39 - And then I can say something
like compare x and y.
48:42 - And if I really wanted to, I
could put comments in here.
48:44 - That is perfectly fine.
48:46 - But I'll just keep it more compact
with this particular example.
48:49 - So any questions on the conditional
syntax or what we've just done here?
48:54 - All right, let Me whip
up another example,
48:56 - this time doing some comparisons.
48:59 - This time, let me create
a file called answer.py,
49:02 - which is reminiscent of a quick example
we did weeks ago called answer.c.
49:05 - Let me go ahead and from
CS50 import getString.
49:09 - And this time, let me
go ahead and declare
49:12 - a variable, C. And let me go ahead
and get a string from the user--
49:15 - whoops-- get a string from
the user for their answer
49:18 - to whatever question
it is we care about.
49:19 - And then if it's meant to be a
yes/no answer, let's check for that.
49:22 - If c equals equals y or
c equals equals little y,
49:28 - then go ahead and say, just
for the sake of demonstration,
49:32 - yes, because the human
presumably meant that.
49:34 - Elif c equals equals capital
n or c equals equals little n,
49:40 - then go ahead and print
out, for instance, no.
49:43 - So a short program, but what
are some of the takeaways?
49:47 - Well, what's different clearly among
these lines, 5 through 8, versus C,
49:51 - weeks ago?
49:53 - Yeah.
49:53 - AUDIENCE: For or you have to do--
49:55 - DAVID MALAN: Yeah, none of those
stupid vertical bars or the ampersand
49:58 - ampersand.
49:58 - If you want to do something or or
and it together, just say and and
50:02 - or, much like Scratch,
actually, some weeks ago.
50:05 - Notice, too-- how are
we comparing strings?
50:08 - Turns out Python does
not have chars, per se.
50:12 - C did have chars, single characters.
50:14 - Python only has strings.
50:16 - It has strings, ints, floats,
and then some fancier things,
50:19 - but it doesn't have chars.
50:20 - So that's why I am
deliberately using string.
50:22 - But when we use strings in C,
how did we compare two strings?
50:28 - Str comp, right, because of the whole
annoying pointer comparison thing.
50:31 - Well, it turns out now
in Python if you want
50:33 - to compare two strings character
by character by character,
50:37 - equal equals is back.
50:38 - And it does exactly what you expect
it to do, even if it's a full word.
50:43 - So if you're actually checking for, for
instance, yes or yes from the human,
50:47 - you can still use equal equals,
as well, even though it's
50:50 - more than now one character.
50:52 - So that's a wonderful feature, too.
50:53 - And it just makes the code
more readable and a lot easier
50:56 - to write right out of the gate.
50:58 - All right, so now recall that
in C we spent a little while,
51:02 - as well as in Scratch, taking a look
at a few examples about coughing,
51:05 - of all things.
51:06 - And in fact, in Python and C--
51:08 - rather, in Scratch and in C--
51:09 - we did a zero example that
looked a little like this.
51:12 - If you want to simulate the notion
of Scratch the cat coughing,
51:14 - you might, of course, do this.
51:16 - And then if he's going to cough
three times, you might do this.
51:19 - And we ran this and it just did
cough, cough, cough on the screen.
51:22 - I won't bother running it
because it will just do that.
51:24 - But this was bad design
we claimed weeks ago.
51:26 - What was the gist of
why this is bad design?
51:31 - I mean, I literally copied and pasted.
51:32 - And the odds are if you're ever
doing that in CS50 or in programming
51:35 - more generally, you're
probably being a little lazy
51:38 - and there's a better way to do it.
51:39 - And it's a more
maintainable way to do it.
51:41 - So of course, we introduced weeks
ago, both in Scratch and in C,
51:45 - the ability to in cough
one, this time, do a loop.
51:49 - And I can do a loop slightly differently
in Python and in C. But for i
51:53 - in the range of 3, go
ahead and print out cough.
51:57 - So the syntax for the for
loop is a little different.
51:59 - But it's pretty
straightforward, nonetheless,
52:01 - once you remember that you
use for, variable name, then
52:04 - the preposition in, and then the word
range with a parenthesis and its--
52:08 - parentheses and the value
you want to care about.
52:10 - But then we saw an opportunity, recall,
to actually abstract coughing away.
52:16 - Coughing, at least in our textual form,
is just the act of printing something.
52:19 - So we introduced in
version two some time ago,
52:22 - the following approach in cough two.
52:25 - I instead defined a function called
cough that did the coughing for me.
52:28 - And we've not seen this yet in Python.
52:30 - So how do you define a function
in Python called cough?
52:33 - Put another way, how do you make
your own custom puzzle piece,
52:36 - just as we did in Scratch?
52:38 - Well, you define it with def.
52:40 - And then you have it do
exactly what you want
52:42 - it to do by just indenting the lines
of code that belong to that function.
52:45 - So there's no return value.
52:47 - There's no need for an
input at the moment.
52:49 - But we do have the colon.
52:50 - And we have the indentation.
52:51 - No curly braces, nothing else.
52:53 - How do I now use this function?
52:55 - Well, here's where we have a few
options stylistically in the program.
52:59 - The simplest way to call this function
would be quite simply like this.
53:03 - Go ahead and for i in range
3, go ahead now and cough.
53:09 - And this should look a little weird.
53:11 - It looks, indeed, a little sloppy.
53:12 - But let's see if it works.
53:13 - So if I go ahead and run
Python of coughtwo.py,
53:17 - it seems to cough, cough, cough.
53:19 - But I say this is a little
weird because what am I
53:24 - doing that's very different now from C?
53:28 - There's no what?
53:29 - There's no main function.
53:31 - I just have some code right
here on the left of the screen.
53:34 - And yet, I do have a function here.
53:36 - And in Python, this is OK.
53:37 - Because you're using an
interpreter and reading the file
53:40 - top to bottom, left to right, you don't
strictly need a function called main.
53:43 - It's just going to
interpret all of your code.
53:45 - And when it's seen the
definition of a function, OK.
53:47 - It's going to say, OK, got it.
53:49 - I now know what the verb cough means.
53:50 - I will do this anytime
I see it down here.
53:53 - But we're going to run into a problem.
53:56 - And if, indeed, I did what
my first instinct was,
53:58 - which was to put the logic, the
main part of my program at the top
54:02 - and to define cough down
here, let's see what happens.
54:05 - Let me zoom out.
54:06 - Let me go ahead and rerun coughtwo.py.
54:08 - And now we start to see the
first of our error messages.
54:11 - And they're going to look just as
cryptic at first glance as is clang
54:14 - and make were.
54:15 - Arrested assured that help 50 can help
with Python error messages, as well.
54:19 - But let's just try to parse what I
do understand. cough2.py, line two
54:23 - in module whatever that is, name error.
54:26 - Name cough is not defined.
54:28 - So what's your gut here?
54:29 - What is that really--
54:31 - what's the explanation for that error?
54:32 - Because cough is clearly defined--
54:34 - literally with the define def verb--
54:37 - right there on line four now.
54:40 - What--
54:41 - AUDIENCE: You're calling
cough before it's defined.
54:41 - DAVID MALAN: Yeah, I'm trying
to call it before it's defined.
54:44 - Python is trying to
take me very literally.
54:46 - And it's going to do top
to bottom, left to right.
54:48 - And if it doesn't see
until the bottom something
54:50 - it's supposed to be doing at the
top, it's just not going to work.
54:53 - So there is a solution to this and
it starts to get a little ugly.
54:56 - But it's a more generalized solution.
54:58 - It turns out that even though main
is not required in a Python program,
55:01 - many programmers just
create one nonetheless
55:04 - to address this particular problem.
55:06 - And they specifically
do something like this--
55:09 - def main-- and then below it
they indent everything there.
55:13 - And then you need one specific
feature to solve this problem now.
55:18 - I've now defined main and I've
defined cough, which theoretically
55:21 - solves this problem just
as it did in C. There
55:24 - is no notion of a prototype in Python.
55:26 - That is not the solution to copy paste
the name of the function up above.
55:30 - But when I do this now,
literally nothing happens.
55:33 - But I did get rid of the error.
55:35 - So just reason through this, perhaps.
55:38 - Especially if you've never
programmed Python before,
55:40 - why might nothing now be happening?
55:44 - AUDIENCE: Not calling main?
55:45 - DAVID MALAN: I'm not calling main, yeah.
55:47 - So whereas in C--
55:49 - and frankly, in Java, C++, and a few
other languages-- main is special.
55:53 - It just gets called by default.
In Python, main is not special.
55:57 - I've chosen this name main just
because so many other languages use it,
56:00 - but it has no special significance.
56:02 - If you want to call main,
you have to do it yourself.
56:05 - And so this is a little
weird, admittedly.
56:08 - But you can literally do this down here
because your code will be executed top
56:12 - to bottom, left to right.
56:13 - By the time line 10 is reached,
both main has been defined
56:16 - and cough has been defined,
which means you're good to go.
56:19 - So if I now go down here and run Python
of cough2, now it actually works.
56:23 - Now, as an aside, this is
not Pythonic, if you will.
56:27 - Most people would actually do this
if the name equals equals main,
56:33 - then do this.
56:34 - This is for lower level reasons that
let me wave my hand out for today.
56:38 - But long story short, the addition
of this cryptic-looking line
56:40 - solves other problems
that we're just not going
56:42 - to trip over this week
and probably next.
56:44 - So this is the common way to do it.
56:46 - But if you just ignore that, the
effect of this cryptic-looking code
56:49 - is just to call main yourself
at the very bottom of your file.
56:52 - So when we start writing
more interesting programs,
56:54 - this is just going to
become conventional.
56:55 - If you want to start writing
functions and so forth,
56:58 - odds are you'll benefit
by writing a main function
57:00 - and putting more code in there.
57:02 - So let's do one final example with
cough that actually now parameterizes
57:07 - the code, just as we did weeks ago in
Scratch and C. This will be cough3.py.
57:12 - Let me start as I did
just a little bit ago.
57:14 - But suppose I want to
achieve this effect.
57:16 - I want the computer to cough three
times by passing in an input.
57:20 - I now do need to modify
cough to take an input.
57:23 - And in C, I would have
said something like int n.
57:26 - But you don't have to
specify data types in Python,
57:29 - you just have to specify the
parameter name or the argument name.
57:32 - So that's nice and simple.
57:33 - And now down in here, in cough
is where I should probably
57:36 - say for i in the range of 3, do this.
57:41 - But this isn't quite right.
57:42 - What fix do I want to make here?
57:44 - Yeah.
57:45 - Now I can just pass in n.
57:46 - So range is just a function
that takes an argument that I've
57:48 - been hard coding as three just because.
57:51 - But you can generalize
it with n, as well.
57:53 - So now again, per our discussion
of abstraction weeks and weeks
57:56 - ago, do we have a sort of
beautiful version of coughing,
57:59 - even though it's looking
way more cryptic.
58:01 - But by step by step by step
did we get to the point
58:04 - of having a main function that
takes an abstraction, cough.
58:07 - Do it this many times.
58:08 - Now the implementation details are
hidden in this custom puzzle piece,
58:11 - if you will.
58:11 - And the two lines at
the bottom just kick off
58:14 - the whole execution of the program.
58:16 - But that's the only stuff that's
really Python-specific now.
58:20 - Yeah?
58:21 - AUDIENCE: Can we use the cough
function on line 11 [INAUDIBLE]??
58:27 - DAVID MALAN: Could use the
cough function on line 11?
58:31 - Yes.
58:31 - You could absolutely just do this, for
instance, and get rid of main again.
58:37 - It's just a convention.
58:38 - Once you start writing more
sophisticated programs with functions,
58:41 - you should probably introduce
main just to keep it tidy.
58:45 - AUDIENCE: With the [INAUDIBLE].
58:49 - DAVID MALAN: You could do that.
58:50 - Then you're starting to be non-Pythonic.
58:53 - Like, yes, you could do cough3
but people would look askew at you
58:59 - because it's just not done that way.
59:01 - That's what Pythonic means.
59:03 - Yeah, other questions?
59:04 - AUDIENCE: You need to have the
[INAUDIBLE] come after the for i
59:08 - in range n so that it
knows what the cough is?
59:15 - DAVID MALAN: Not in this case.
59:17 - So the order now is OK because
first Python is seeing here's
59:22 - the definition of main.
59:23 - OK, I got it.
59:24 - And then it's saying, here is the
definition of cough, OK, I got it.
59:27 - But it's not actually
calling those functions yet.
59:30 - The Python errors are thrown
only at what's called runtime,
59:33 - the running of the program's time,
which means only when main is called
59:37 - does Python actually
execute line 4 and then see,
59:40 - ooh, I need to call a
function called cough.
59:42 - But that's OK because it
saw it earlier when it first
59:45 - read the file top to bottom.
59:47 - So it matters when the
functions are called,
59:49 - not where they appear, per se, in
the file, the order in which they're
59:54 - called.
59:54 - Other questions?
59:57 - All right, yes?
60:00 - AUDIENCE: I don't know
where you [INAUDIBLE] from.
60:04 - How do you define n as an integer?
60:07 - DAVID MALAN: How did I
define n as an integer?
60:09 - This is what's nice about Python.
60:10 - If you want a variable
or a parameter, just
60:12 - start using it without
mentioning its data type.
60:14 - So the fact that I put n in
parentheses in this function
60:18 - means, hey, Python, let this
function take an input called n.
60:21 - And it can actually be any
data type-- int, float, string,
60:24 - or even something else.
60:26 - It's up to me to use it
responsibly as a number
60:28 - and to call it
responsibly with a number.
60:32 - Good question.
60:33 - Yeah?
60:34 - AUDIENCE: So it's possible
for a variable to change type?
60:36 - DAVID MALAN: It is, indeed,
possible for a variable
60:39 - to change type, a good observation.
60:40 - So yes, Python is not as
strongly-typed language, so to speak.
60:45 - C is strongly-typed in that
if you make something an int,
60:48 - it is staying an int forever.
60:49 - Python is loosely typed, whereby
x can be an int initially.
60:53 - But if you really want to turn
it into a string, you can.
60:55 - But the convention there would be, yes,
you can do that, but don't do that.
61:00 - So Python has the, frankly,
the sort of arrogance
61:02 - of being sort of an adult language.
61:04 - Yes, you could do that, but just don't.
61:06 - Why do we have to protect
you from yourselves?
61:08 - And so in that sense, you need to be
a little more responsible about it.
61:11 - But again, there are
arguments both ways.
61:13 - That induces potential bugs
that C would catch for you.
61:16 - And this is where humans start
to disagree about the upsides
61:19 - and downsides of languages, whether a
language should be strongly or loosely
61:23 - or not even typed at all.
61:25 - A good observation.
61:26 - So let's look at a paradigm
that was super common in C
61:29 - when we wanted to do
something again and again
61:31 - to see how it actually is a little
differently done in Python now.
61:34 - Let me go ahead and create
a file called positive.py
61:37 - and go ahead and write a
program a little quickly here.
61:40 - So from CS50, let me go
ahead and import getInt,
61:44 - so we can get integers from the user.
61:46 - Let me go ahead and
define a main function
61:47 - that simply does i, which will be
my variable, gets a positive int,
61:53 - and asks the user, just
as we did weeks ago,
61:56 - if you'll recall, for
a positive integer.
61:58 - And then just goes ahead and
very boringly prints it out.
62:02 - So that's all this program does.
62:03 - And let me go ahead and
just from recollection--
62:06 - though it's totally fine to copy/paste
this cryptic-looking string,
62:08 - we would just be remiss in not
showing you how most people do this.
62:13 - So if I do this, this
is a complete program,
62:15 - except for the fact that
what does not exist yet?
62:21 - Get positive int probably does not
exist, just as it didn't in week one,
62:24 - because we have to invent it ourselves.
62:25 - Get int exists, but get
positive int does not.
62:28 - And just for demonstration's
sake, let's try this.
62:30 - Python of positive.py,
notice we have name error get
62:33 - positive int not defined.
62:34 - OK, so we can fix that.
62:36 - We can literally define, or def, it.
62:38 - So get positive int.
62:40 - It's going to take a
prompt from the user,
62:42 - just as it did weeks ago, the string
that you want to show to him or her.
62:45 - And now let me go ahead
and get a positive integer.
62:49 - What type of programming
construct did we
62:51 - use in C to do something
again and again and again?
62:55 - AUDIENCE: Loop.
62:55 - DAVID MALAN: A loop, for
sure, but more specifically,
62:58 - to do something at least
once and then maybe again
63:00 - and again and again if
they don't cooperate?
63:02 - AUDIENCE: While.
63:03 - DAVID MALAN: Do while.
63:04 - No do while in Python.
63:06 - So that handy feature for
user input does not exist.
63:09 - So that's fine.
63:10 - We need to solve this just differently.
63:12 - And honestly, in C, you could have
solved that problem differently.
63:15 - You don't need do while.
63:16 - We could have taken it away from you.
63:17 - C could take it away.
63:19 - You could still solve every problem
that we have in the past weeks
63:21 - using a for loop or a while loop.
63:23 - Do while just is a nice handy feature.
63:26 - But we can simulate it.
63:27 - And the Pythonic way of
doing this is as follows.
63:30 - Deliberately induce an
infinite loop, because you
63:32 - do want to loop potentially.
63:34 - But the logic is going to
be, give me an infinite loop
63:37 - and I will break out of it when
I'm ready to break out of it.
63:40 - This would be the convention.
63:41 - So while the following is true do this.
63:43 - Go ahead and declare
a variable called n.
63:46 - Get an int from the user and
pass in that same prompt.
63:48 - So get int, we wrote-- the staff--
63:50 - prompt is whatever I typed in up here.
63:52 - So just copy/paste from the C version.
63:55 - And then under what circumstances do I
want to break out of this infinite loop
63:59 - if the function is to be
called to get positive int?
64:01 - AUDIENCE: [INAUDIBLE]
64:02 - DAVID MALAN: Yeah, so
if n is greater than 0,
64:04 - then I do have the keyword
break still, just as I did in C.
64:08 - I can break out of this loop.
64:09 - And then once I do that, I can
go ahead and just return n.
64:13 - Or for that matter, I could
condense this a little bit.
64:16 - I could just return n immediately
and tighten it just a little bit.
64:19 - So multiple ways to do this.
64:21 - Otherwise it's just going
to loop and loop forever.
64:23 - So let me go ahead now
and run positive.py
64:26 - through Python, positive integer like
negative 1, maybe negative 2, 0, OK, 1.
64:32 - And now it, indeed, co-operates.
64:34 - So this is just a common paradigm.
64:36 - This is the kind of thing when
learning a new language that honestly
64:38 - tends to hang people up initially.
64:40 - You need to learn the
JavaScript way of doing things.
64:42 - You need to learn the
Python way of doing things.
64:44 - But then you start to notice
these so-called design patterns.
64:47 - Anytime in Python you want to
do something again and again,
64:49 - yes, you want to loop.
64:50 - But if you want to do something
definitely once and maybe again?
64:54 - You still just use a
loop, but you deliberately
64:56 - induce, typically, an infinite loop, and
just break out of it when you're ready.
65:00 - So a very common approach.
65:01 - So not everything translates
literally from C back and forth.
65:06 - Any questions then on that?
65:10 - Yeah, in the back?
65:11 - AUDIENCE: Is that something you
just did with the while for loop,
65:15 - is that [INAUDIBLE] initializing
a variable called [INAUDIBLE]
65:19 - to a negative number and then
do while n is less than 0--
65:23 - DAVID MALAN: Really good question.
65:24 - Is this approach preferable
to instead declaring, maybe
65:27 - in here, a variable that is equal to
some known value, like zero or whatnot,
65:32 - and then updating it?
65:33 - Short answer, yes, because
your approach, while correct,
65:36 - is not as well-designed, arguably
because it's just not necessary.
65:40 - And the Pythonic way, and
really the well-designed way
65:43 - to do most things would
be use as few lines
65:45 - as you can so long as it's still
readable and understandable,
65:47 - which I would argue this is once
you're comfortable with the syntax.
65:50 - But this does bring up an interesting
point about one other topic in C. Scope
65:56 - has now gone out the window, at
least as we previously saw it.
65:59 - Scope referred to
where a variable lives.
66:02 - And we defined it essentially
casually between two curly braces,
66:05 - the most recently opened curly braces.
66:07 - Well, no curly braces anymore so it
turns out that variables by default
66:10 - have function scope here.
66:12 - So when you declare n on line 9,
you can use it in Python on line 10.
66:17 - And you know what?
66:18 - You can even use it on line 12,
even though it was declared inside
66:22 - of this loop higher up.
66:24 - So once you declare a
variable on this line,
66:27 - you can use it anywhere on a subsequent
line within that same function.
66:30 - So in some sense, it's a little
sloppy that you're allowed to do this.
66:33 - But on the other hand,
it's very convenient
66:35 - because you don't have
to deal with those things
66:37 - like declaring the variable up
here just to use it down here.
66:40 - So it's one less thing to think about.
66:42 - All right, let's take a look
just a few examples from week two
66:46 - wherein we introduced arrays
and strings more generally
66:49 - to see what has changed now, as well.
66:51 - You'll recall that in week two, perhaps,
we had an example about capitalization.
66:56 - And let me go ahead and look
at the third version of that,
66:59 - capitalize too, but
convert it to Python.
67:01 - The purpose in life was to
take input from the user
67:04 - and just capitalize
every character therein.
67:06 - So if I type in my
name in all lowercase,
67:08 - it should come back as all uppercase.
67:10 - So from the CS50
library, let me go ahead
67:12 - and import getString so that I
have some input from the user.
67:16 - Then let me go ahead and just get a
string from the user, like their name.
67:20 - And then I want to go ahead
and capitalize everything.
67:24 - So let me go ahead and do this.
67:27 - And this is a fancy feature.
67:29 - In C I would have done a for int
i is zero i less than strlen.
67:33 - I mean, you perhaps remember the
paradigm for iterating over a string.
67:36 - Python is just so much more pleasant.
67:38 - For c in s--
67:40 - that will induce a loop over the string
s, giving you access to every character
67:46 - at a time, calling that variable c.
67:49 - And so what is it I want to
do, just as a preliminary step,
67:52 - a baby step, if you will, let's just
print out c, just to see what happens.
67:56 - Let me go ahead down here and
do Python of capitalize two.
68:01 - Let me go ahead and type
in my name, all lowercase.
68:03 - All right, and why is
it showing up vertically
68:06 - like that, one character per line?
68:08 - Yeah, you get the free line--
68:10 - free new line this time.
68:11 - So let's see how you can disable that.
68:13 - It's stupid looking, honestly.
68:15 - But you say end equals quote unquote,
thereby revealing a new feature
68:20 - of Python that C does not have.
68:21 - It turns out that Python has not only
positional arguments, as it's called,
68:26 - whereby you just pass in
arguments between commas.
68:28 - That's what we've been doing in C.
68:30 - But Python also has
named arguments, whereby
68:33 - you can specify the
name of the argument,
68:35 - then an equals sign, then the value.
68:38 - And the power of named arguments,
even though this is a tiny example,
68:42 - means that you can sometimes pass
in your arguments in any order.
68:46 - You don't have to remember.
68:47 - You don't have to pull up
CS50 manual or the man pages
68:49 - to remember what is the order
of all these darn arguments.
68:52 - You can pass them in in any
order, but by specifying
68:55 - the name of the argument, an
equals sign, and its value.
68:58 - And in Python 2, you can
have optional arguments.
69:01 - Obviously, in all of
the examples thus far,
69:02 - I have never typed the word
end and an equals sign yet.
69:06 - But what Python does support is
default values for arguments.
69:09 - And so if you look in the documentation
for Python, this is equivalent--
69:14 - this cryptic looking sequence-- this
is equivalent to the default behavior,
69:18 - which is to type none of that at all.
69:20 - End implies, for the print function,
that you should end every line
69:25 - with that default character.
69:26 - Therefore, if you want
to override it, you
69:28 - can just change it to the
empty string, quote unquote.
69:31 - So if I now run this again and
run it through with my name,
69:36 - now I get it like that,
one character at a time.
69:39 - But you can do weird things,
like ha ha ha ha ha--
69:42 - not that you would.
69:43 - I don't know why I went with that.
69:45 - But I mean, that does
the exact same thing
69:48 - because you're just
changing the line ending.
69:50 - So don't do that, but do something
else like this with it, instead.
69:54 - So suppose I want to now
capitalize the first character.
69:57 - It turns out that strings in Python
are more powerful than strings
70:02 - in C. In C, there is no string.
70:05 - That was a lie.
70:06 - It's just a sequence of characters as
referenced by an address in memory.
70:09 - In Python, a string is an actual object.
70:12 - It's a data structure.
70:13 - And if you think about C, we had
structs toward the very end of our look
70:16 - at C, nodes and structs and
student structures and the like.
70:19 - A string in Python is like
this container inside of which
70:22 - somewhere are all of those characters.
70:23 - But in that container or structure
is also built-in functions,
70:27 - features of a string
that you can just call.
70:29 - So in C, we would have
said something like toUpper
70:33 - and then passed as input to
a function called toUpper
70:36 - the character that we care about.
70:37 - Python kind of flips the logic around.
70:40 - Strings come with built-in
functionality that
70:43 - allow you to operate on the
given character automatically.
70:47 - So in Python, the syntax is
actually the character itself.
70:50 - Use the dot notation
because it's a structure.
70:52 - And then you can literally do--
70:54 - oops.
70:55 - You can literally do upper.
70:58 - So this is to say, built into
the string type in Python
71:04 - is a bunch of features, one of
which is a function called upper.
71:07 - And the syntax with which you call
it is the name of the variable
71:10 - or the name of the string dot name of
the function open paren, close paren.
71:14 - And that's just now the paradigm.
71:16 - There's no C type library.
71:17 - There's no to upper or to lower.
71:19 - Those features now built
into the strings themselves.
71:22 - And this is an example
of encapsulation, or more
71:24 - generally, object oriented
programming, something
71:26 - you'll explore if you take
a class like CS51 that
71:29 - bakes into the data types itself
all of the relevant functionality.
71:33 - It does not relegate
them to another library.
71:37 - So if I clean this up by just
moving the cursor to the next line,
71:41 - now hopefully you'll indeed see David
typed out in all caps, the same idea
71:45 - as before.
71:46 - What about this length of a string?
71:48 - This one is pretty trivial,
but if I go in here,
71:50 - let me go ahead and create a
file called str len of .py.
71:54 - If I want to see the length of a
string, from CS50 import getString,
71:57 - just as we did before.
71:59 - Let me go ahead and get a string
for myself, like my name again.
72:01 - And then here, if I want to print
the length of the string, in Python--
72:04 - in C, you would say strlen.
72:06 - In Python, it's a little different.
72:08 - You actually just say len for length.
72:10 - So if I go ahead and run
this through strlen--
72:13 - strlen-- type in my name.
72:15 - Hopefully I, indeed, see five.
72:17 - And there's no notion that you need
to care about the backslash zero
72:20 - in order to terminate the string.
72:23 - Yeah?
72:25 - AUDIENCE: So this upper [INAUDIBLE]
72:31 - DAVID MALAN: No, in fact.
72:32 - So that's a really good observation.
72:34 - Let's rewind and actually
improve upon this
72:37 - rather than just translate it from what
was our comparable example in C. Let
72:42 - me go ahead here and
actually say, you know what?
72:45 - S gets s upper.
72:48 - And then let me just print s, perhaps.
72:50 - Let's see what happens.
72:51 - Let me go back here and
run Python of capitalize 2.
72:55 - Enter David.
72:57 - And it operates on the whole string.
72:58 - Good intuition.
72:59 - And honestly, I don't need to do this.
73:01 - I could just say upper here and
really trim this down and do
73:07 - Python of capitalize, type in my name.
73:11 - That still works.
73:12 - And if I really want to be fancy,
I don't even need s at all.
73:15 - I can take this, get rid of that,
put this here, immediately call
73:20 - upper on the user's input and whittle
this down to one line, type in David,
73:24 - and that, too, works.
73:25 - So you just get lots and lots
and lots of more expressiveness.
73:28 - Good question.
73:29 - So how do you even know
that things like this exist?
73:31 - Well, quick aside.
73:32 - Google will truly be your
friend in cases like this.
73:35 - And you'll want to know at this point,
there's different versions of Python.
73:38 - The world is kind of
holding out and is still
73:40 - using, a lot of people, version 2 of
Python, which is older by many years
73:43 - now.
73:44 - We are using version 3.
73:45 - And this is where the world is going.
73:47 - And indeed, Python 2 will be
officially deprecated or phased out
73:50 - in a couple of years, theoretically.
73:52 - So when you Google, you just
want to be mindful of this
73:54 - so that you don't accidentally make your
way to old tutorials, old documentation
73:57 - and the like.
73:57 - So let me go ahead and Google
Python 3 string, or str, and upper,
74:03 - just to see if I can get
to the documentation.
74:05 - Here you have a number of tutorials.
74:07 - But if we focus down here, what you're
generally going to want to look for,
74:11 - at least for the official
documentation, is docs.python.org.
74:15 - You see in the URL it's version
3, and that's where we want to go.
74:18 - So let me go ahead and click on
this, common string operators.
74:21 - And I will disclaim this--
74:22 - I think, personally,
Python's documentation
74:24 - is not terribly newbie-friendly.
74:26 - Like, it's written fairly
arcanely and you kind of
74:28 - have to really dig to
understand certain things.
74:30 - That's fine.
74:31 - You'll get comfortable
with it over time.
74:33 - But if you're feeling a
little overwhelmed by,
74:34 - oh my God, I just want to know about
upper, everyone feels this way too.
74:39 - So control F or Command
F is your friend, upper.
74:42 - Let me go ahead and search for this.
74:44 - And it's not actually
on this page, is it?
74:47 - String-- string methods.
74:50 - Here we go.
74:50 - String methods.
74:52 - OK, so under string methods, let
me go ahead and search for upper.
74:56 - And down here, indeed,
is the documentation.
74:59 - So the convention will be the name
of the data type in question--
75:02 - str for string--
75:03 - the name of the function here.
75:04 - It would tell you in parentheses if it
takes any arguments, but it doesn't.
75:08 - And so it returns a copy of the string
with all of the cased characters
75:11 - converted to uppercase-- that just
means the letters of the alphabet
75:14 - essentially--
75:15 - and then some additional
documentation, and so forth.
75:17 - It gets pretty low-level pretty quickly.
75:19 - These are the equivalent
of the man pages.
75:21 - And there is no CS50
reference for Python.
75:23 - That was just for C. So
just realize that there's
75:25 - this documentation available.
75:27 - And you'll notice there's
bunches of functions.
75:29 - Strip is actually kind of a
popular one, or L strip or R strip.
75:33 - If you have whitespace at the
beginning or end of a line
75:35 - because your human got a little
sloppy or there's new lines in a file,
75:39 - you can call strip on a string and
get rid of whitespace to the left
75:42 - and right to kind of clean it up.
75:43 - Terribly useful for things
like data science applications
75:46 - and analysis of data where you
just kind of clean up messy data.
75:48 - So many functions like
that are built in for you.
75:51 - All right, so let's take a look at a few
other examples reminiscent of features
75:55 - we did have in C, such as this one here.
75:58 - Suppose I want to write
a program that takes
75:59 - command line arguments,
much like resize,
76:02 - with which we started today's story.
76:06 - Let's not even use the CS50 library.
76:08 - Let's do this.
76:09 - If you want access to argv, recall
in C it looked like this-- int,
76:13 - argc, string, argv.
76:19 - It looked like this in C.
76:20 - Well, unfortunately, if
you're not using main,
76:22 - it would be nice if you can
still use command line arguments.
76:25 - And you can, but you
have to import them.
76:27 - It's a library that
provides you with access.
76:29 - From the sys or system library,
you can import argv in Python.
76:33 - And that gives you access to
command line arguments as a feature.
76:36 - Then you can say something like this.
76:38 - If the length of argv--
76:40 - which is just an array, recall, in C--
76:43 - equals equals 2, then
go ahead and say hello.
76:47 - And let's go ahead and print out
whatever the user typed in, argv 1.
76:52 - Else, let's just by
default say hello world.
76:56 - So in English, what's happening?
76:57 - If the user typed in a command line
argument-- say, hello so-and-so.
77:01 - Else if the human did not type in
exactly one command line argument,
77:04 - just say, by default, hello world.
77:07 - So let me save this.
77:08 - Do Python of argv1, or rather zero.
77:11 - Enter.
77:12 - OK, I didn't type in a
word after the command.
77:14 - So now let's do it again and
I'll type in Brian's name.
77:18 - Enter, hello Brian.
77:19 - Let's do it again.
77:21 - Veronica, enter.
77:23 - Now, there's something that's not quite
the same as C. How many words did I
77:27 - just type at the prompt?
77:30 - 3.
77:31 - So that would suggest that this
is argv 0, argv 1, and argv 2.
77:37 - And yet, I'm printing
argv 1, not argv 2.
77:41 - So how do I think about this?
77:43 - The code is correct, but
it's different from C.
77:47 - What does argv technically store
when you run a command like these?
77:57 - Remember, let's rewind.
77:58 - In C, argv 0 stored what?
78:02 - AUDIENCE: Name of the file.
78:03 - DAVID MALAN: The name of the file or
the name of the program you just ran.
78:06 - Notice, though, the program
I just ran is called Python.
78:09 - And so you would think that
argv 0 would have Python in it,
78:13 - but it doesn't because notice
if I'm printing argv 1,
78:16 - you would think that's 0, 1.
78:17 - You would think I just said
hello argv 0 .py, But I didn't.
78:20 - argv 1 clearly prints Veronica or Brian.
78:24 - So it stands to reason
argv 0 is this, which
78:27 - means this is, like, argv negative 1.
78:28 - Python is excluded from the
argument vector, as it's called.
78:32 - The command line arguments do not
include the name of the interpreter.
78:35 - But otherwise, it works exactly the
same as it did once upon a time.
78:39 - And notice, too, with
this new for construct,
78:43 - notice what you can do whenever you
have access to an array of things.
78:46 - If I go into argv1.py and import
argv again, let me go ahead now
78:52 - and just-- you know what?
78:53 - For s in argv, go ahead and print out s.
78:57 - It's really succinct.
78:59 - What is this going to do?
79:00 - Let me go ahead and do
Python of argv1, enter.
79:04 - And it just prints out
the name of the file.
79:06 - If I go ahead and say foo,
bar, baz, three random words,
79:09 - it prints out all of those words.
79:11 - And so what's powerful about
Python is honestly this for loop.
79:14 - There's no int i, less than,
plus plus, any of that.
79:17 - You just say, give me
a variable called s
79:19 - and iterate over the entirety of the
thing on the right, which is presumed,
79:22 - in this case, to be an array.
79:25 - You can be even more powerful than that.
79:26 - If I-- just like in C weeks ago--
79:29 - look at characters in these
strings-- let me do argv2.py--
79:32 - suppose that this iterate
over each string in argv,
79:38 - and then here iterate over each
character in s, I can do for c in s
79:46 - and now print out the character.
79:49 - So now when I run this same
command but on argv2.py,
79:53 - notice what's going to happen.
79:55 - Let me raise this a little bit.
79:57 - Enter.
79:59 - It prints every character
from every word one at a time.
80:03 - But it did so this time based
on using these two for loops.
80:06 - So what does this mean?
80:07 - When you have an array,
as we've called it,
80:10 - you can iterate over
everything in the array.
80:12 - When you have a string, you can iterate
over every character in the string.
80:15 - And this is where Python
just gets wonderfully
80:17 - flexible to do this again and again.
80:20 - All right, let's take a look at--
80:23 - let's see-- compared strings already.
80:25 - We copied strings.
80:26 - Let's go ahead and do this in Python.
80:29 - Recall that we ran into a
fundamental limitation of C,
80:32 - and it would seem programming,
when we had example called swap
80:35 - and no swap back in the
day where I was just
80:38 - trying to swap two values, x and y.
80:40 - And recall that I hardcoded
something like x is 1 and y is 2.
80:44 - And the whole goal was simply to
first say, x is such and such,
80:48 - y is such and such.
80:50 - Let me go ahead and make
that a format string.
80:53 - Then I wanted to print this again.
80:55 - But somewhere in here, I
wanted to swap x and y.
80:58 - So to punctuate our sort of
exploration of just what Python can do,
81:01 - if you want to swap two variables,
x and y, that's fine, just do it.
81:07 - And it's this magical shell
game that just works in Python.
81:10 - Now, technically these are what
are called tuples on the left.
81:13 - It's a x comma y pair.
81:15 - It's latitude comma longitude.
81:16 - So there's an actual underlying
mental model for what's going on here.
81:20 - But in effect, you're
literally switching them
81:22 - and you don't need the
temporary variable.
81:24 - Python the language takes
care of that for you.
81:28 - All right, let's look at
a more powerful feature
81:30 - still, this time using what's
actually called a list.
81:33 - So a moment ago I was using
argv 0, 1, 2, as our examples.
81:38 - And I was calling them arrays.
81:40 - They're not arrays anymore.
81:41 - Python does not have arrays.
81:43 - Python has lists.
81:44 - And lists sounds
reminiscent of linked lists.
81:46 - And indeed, they are.
81:47 - In Python, you have
lists that are resizable.
81:50 - You don't have to decide in advance
how big they are or how small they are.
81:53 - They will just grow and shrink for
you just like a linked list will,
81:57 - but you don't have to write
the linked list yourself.
81:59 - Yeah?
82:00 - AUDIENCE: [INAUDIBLE]
82:04 - DAVID MALAN: Sure.
82:05 - AUDIENCE: [INAUDIBLE]
82:10 - DAVID MALAN: Oh, sure.
82:11 - Let me open that file up in argv1.
82:15 - This one here?
82:16 - AUDIENCE: No, it was, like, [INAUDIBLE].
82:19 - DAVID MALAN: Oh, this one here.
82:20 - AUDIENCE: Yeah.
82:21 - [INAUDIBLE] bracket
notation [INAUDIBLE]..
82:23 - DAVID MALAN: Yes, you can still--
so argv, I called it an array,
82:26 - but that was a white lie a moment ago.
82:27 - It's actually a list, a linked list.
82:29 - But whereas a linked list in C does
not allow you to use square brackets,
82:32 - you have to use a for
loop or a while loop
82:34 - to iterate over the whole thing to find
what you're looking for, in Python,
82:38 - if something is in a list, you can
just use, yes, the square brackets
82:41 - to get at that specific element.
82:42 - AUDIENCE: Or I'm saying you
could use the f right before--
82:45 - DAVID MALAN: Oh, I could have, yes.
82:47 - I didn't use the F, just because
frankly it just gets ugly eventually.
82:52 - But yes, I could have also done this
to achieve the exact same effect.
82:56 - It just starts to look cryptic.
82:58 - OK, so let's actually introduce a list,
which itself is a data type in Python,
83:03 - as well as in languages
like C++ and Java,
83:07 - if some of you have that
background, as well.
83:09 - So here, in list.py, let me
go ahead and do the following.
83:13 - Let me first import from
the CS50 library getInt
83:15 - so that we can get some
ints from the user.
83:17 - Let me give myself an array, a.k.a.
83:19 - now a list in Python.
83:22 - So in C you can't really
express quite this idea.
83:25 - In Python, if you want a
variable called numbers
83:29 - and you want to initialize
it to an empty list,
83:31 - you just literally do open
bracket, close bracket.
83:33 - No number in between them.
83:35 - And as before, no semi-colon.
83:37 - Let's now do the following
forever until I break out of this.
83:40 - Let me go ahead and get
a number from the user,
83:43 - just by asking them for some number.
83:45 - Then let me say, if not number,
go ahead and break out of this.
83:49 - This is going to, as an
aside, just let me quit out
83:51 - of this by hitting Control D as we
discussed ever so briefly a while back.
83:55 - But that's just a UI feature.
83:57 - So this is what's kind of cool.
83:58 - Suppose I want to implement
the notion of checking
84:02 - if the number the user's typed in
is in the list already, and if so,
84:06 - not add it.
84:07 - I'm going to go ahead and do that.
84:08 - But first, let's just do this--
84:10 - numbers.append number.
84:13 - And this is a new feature.
84:14 - So what do I want to do here?
84:16 - For number in numbers--
84:17 - I'll explain this in a second--
84:20 - let me go ahead and print number.
84:21 - So what is this program aspiring to do?
84:23 - At the very top, I'm importing getInt.
84:26 - At the very top below that, I'm
just giving myself an empty array,
84:29 - now called a list, called numbers.
84:31 - Then I do the following forever.
84:33 - Go ahead and get the
number from the user.
84:35 - If he or she did not actually type
in a number, just break out of this.
84:38 - The program is done.
84:39 - But here's the new feature.
84:40 - Just as with strings, they
are objects, so to speak.
84:44 - They are data structures
that have functions built in.
84:46 - So do lists have functions built in.
84:49 - There is literally a function
inside of every Python list
84:52 - called append that literally does that.
84:54 - You call append and it
appends whatever its input
84:56 - is to whatever the list itself is.
84:59 - So in C, you might have
had to use realloc.
85:03 - You might have had to add
something to the end of the list.
85:06 - None of that happens anymore.
85:07 - Just at a high level, you
say append this to the list
85:10 - and let the language
take care of it for you.
85:12 - Then down here, left-aligned
all the way at the end,
85:15 - is just saying, for number in numbers.
85:17 - Like, iterate over all of the numbers
in the list and print out one at a time.
85:21 - So let's try this.
85:22 - Let me go down here and do Python of--
85:25 - this is list.py-- and let me go ahead
and type in a number like 13, 42, 50.
85:31 - And I'm going to hit Control D,
which means that's it, I'm done.
85:34 - And there we see the three numbers.
85:36 - It looks a little stupid
because you know what?
85:38 - I think I need a print here.
85:39 - Let's fix this.
85:40 - Let me rerun this.
85:42 - 13, 42, 50, Control D, there we go.
85:45 - One per line.
85:46 - But what this program has is
honestly kind of a bug, potentially.
85:50 - Suppose I want unique
numbers, now I have three 13s.
85:53 - But I'd ideally just want one copy
of every number for whatever reason.
85:56 - I want uniqueness.
85:57 - Well, notice how easily
you can express that.
86:00 - If my goal is to only conditionally
add a number to the numbers list
86:05 - if it's not already there,
how would you do this in C?
86:08 - You have an array called numbers
and you want to first check
86:11 - is a number in that array.
86:13 - What would you do in English?
86:15 - AUDIENCE: A for loop.
86:16 - DAVID MALAN: A for loop, right?
86:17 - You'd probably start at
the left, iterate over
86:18 - the whole array looking for the number
and then conclude true or false,
86:21 - it's in there.
86:22 - It's not hard but it's
a little annoying.
86:24 - You have to write more code, a couple
of lines, four lines for a for loop.
86:27 - In Python, just say what you mean.
86:30 - If number not in numbers, append it.
86:35 - And it reads much more like English.
86:37 - At the end of the day, some human wrote
the for loop that does that operation.
86:41 - But we, the more modern programmers, can
just now say, if number not in numbers,
86:46 - append it.
86:46 - And so it is meant to
read more English-like.
86:48 - So let's try this now.
86:50 - 13, 13, 50, done.
86:53 - Now I just get one copy of the 13
because it's checking that for me.
86:56 - Now, running time is still an issue.
86:58 - Consider this,
theoretically, you're still
87:01 - wasting some time looking for
a number because someone wrote
87:04 - code that's probably linear search.
87:05 - Maybe it's binary search if it's sorted.
87:07 - But someone wrote that code.
87:08 - But the point is, with these
higher level languages,
87:10 - these more modern languages like Python,
that is not our problem, necessarily.
87:14 - It only becomes our problem
if the program is just
87:17 - too slow for some reason and we really
need to get into the weeds of why.
87:22 - All right, let's look at a
final feature syntactically
87:25 - before we try this to a
more generalized problem.
87:27 - Let me go ahead and save
a file called struct0.py,
87:30 - which is reminiscent of
struct0.c a few weeks back.
87:33 - And let me go ahead and from the
CS50 library import getString.
87:37 - Let me go ahead and give myself an array
this time called students that's empty,
87:41 - or a list called students.
87:43 - And then let me just get three
students for the sake of discussion.
87:46 - So for i in range 3, that
just iterates three times,
87:50 - let me go ahead and ask
the user for their name.
87:52 - So getString, ask them for their name.
87:55 - Then let me go ahead and
ask them for their dorm
87:57 - and go ahead and get string for dorm.
88:00 - And then that's enough.
88:01 - Let me now go ahead and
append the student to my list.
88:04 - So students dot append.
88:07 - But I don't really have
a student structure yet.
88:09 - Now, there's many ways we
can solve this, but let
88:11 - me propose the simplest one.
88:13 - It turns out in Python you can declare
hash tables so wonderfully simply.
88:19 - A hash table is just a
collection of key value pairs.
88:21 - And I would argue at this point in
my example I have keys and values.
88:25 - I have a name which is a key and
the value, like David or whatever,
88:29 - another key called dorm, and then
a value which is like Matthews
88:33 - or wherever.
88:34 - And so keys and values.
88:35 - So it would be kind of nice if I
could create for myself a hash table--
88:38 - or even a try, for that matter--
that allows me to store this data.
88:41 - Well, it turns out in
Python, I can do just that.
88:44 - I can go ahead and create
an object called student
88:47 - using curly bracket notation.
88:49 - And you can literally do this.
88:51 - The name shall be one key.
88:53 - And now it's going to
take on that value.
88:55 - Dorm shall be another key and
it's going to take on that value.
88:59 - So I could call this
anything I want-- x and y
89:02 - and have the values David and Matthews
or whatever it is I'm going to type in.
89:05 - But if you want a very
generalized data structure
89:09 - that isn't just a list of values from
left to right, but has metadata--
89:13 - a key, or if you think of a
spreadsheet, a column name
89:16 - called name and a column name called
dorm, each of which has values--
89:20 - you just use curly braces.
89:21 - And you put the keys in
quotes and then a colon.
89:24 - And then if you've got multiple
keys, you just put a comma.
89:26 - So it's a little cryptic, but this is
just like a container, a hash table,
89:31 - that contains words and values.
89:33 - Now, in p set 4, when
you implemented speller,
89:36 - you actually just said yes or no,
is the word in the dictionary?
89:40 - But you certainly could
have stored more information
89:42 - instead of just Boolean values.
89:43 - You just tended to not need to do that.
89:47 - So what does this mean for me?
89:48 - At this point in the
story, I have an object,
89:50 - as it's called in Python, that
stores these keys and these values.
89:54 - So if later on I want to iterate
over them, I can do this.
89:57 - For student in-- oh,
you have to append it--
90:01 - so student.append student.
90:04 - Let's add the student to the list.
90:06 - So for student in
students, which is just how
90:08 - you iterate over every one
of the things in that list.
90:10 - Let me just go ahead and say a
sentence like, I want to say so and so
90:16 - is in this dorm.
90:18 - So how do express that?
90:19 - Well, so and so, I need to get
access to the student's name.
90:22 - And the way I can do this is as follows.
90:25 - I could say, let's go ahead and
say curly brace student bracket
90:30 - name close bracket.
90:33 - And then here, I can go ahead and say--
90:36 - oops, let me put quotes in here--
90:38 - and then here I can say student
bracket quote unquote dorm.
90:42 - So this is admittedly the most
cryptic example we've done thus far.
90:45 - But let's tease it apart
as a format string.
90:47 - So if I zoom in on
this, what am I doing?
90:50 - The curly braces and the f
just means format this string.
90:52 - So you can ignore the curly braces
as part of our story from earlier.
90:56 - Student is the name of the
variable in the for loop.
90:58 - So it's the current student.
90:59 - The square brackets are new.
91:01 - In C, the only time we used square
brackets was in what context?
91:05 - AUDIENCE: Arrays.
91:06 - DAVID MALAN: Arrays.
91:07 - And what did we always put
in those square brackets?
91:10 - A number.
91:11 - Yeah, so 0, 1, 2.
91:12 - You can index into an array.
91:14 - What's cool about an object--
91:16 - or a hash table more generally,
as we're now defining it--
91:20 - is you can index into the variable
using not numbers, but words.
91:25 - So you could think of student
as being like a list or an array
91:29 - with two values-- name and dorm.
91:30 - But it's nice to be able to refer
to those not as zero and one
91:33 - or some stupid arbitrary
number, but rather by keys--
91:36 - name and dorm.
91:38 - So this syntax here, though
cryptic, says go inside the student
91:41 - object and get me the value
of the key called name.
91:44 - And this says the same thing about dorm.
91:47 - So an object in Python--
91:50 - or more generally a hash table-- allows
you to associate keys with values.
91:54 - And this is quite simply
the syntax you use for that.
91:56 - So let me go ahead and run this.
91:58 - Struct0.py, type in my name.
92:01 - Let's say Matthews.
92:03 - Let's do, like, Veronica, Weld.
92:07 - Let's do Brian.
92:08 - Brian, where did you live?
92:09 - AUDIENCE: Which year?
92:10 - DAVID MALAN: Freshman year.
92:11 - AUDIENCE: Pennypacker.
92:12 - DAVID MALAN: Pennypacker, enter.
92:14 - Not that these specifics
really matter, but now we
92:17 - have expressed all of these sentences.
92:19 - So the short of it now is we
didn't quite see this in C,
92:21 - but we did see a hint of this
when we implemented our own hash
92:25 - table in C so that we can actually
access keys and values arbitrarily.
92:30 - So let's do a-- actually, let
me pause here for any questions
92:35 - before we bring back Mario.
92:39 - All right.
92:39 - So let's now not just do examples
for the sake of demonstration,
92:43 - but rewind to an old friend
that we've seen a few times
92:47 - and just look at a
few different screens.
92:48 - So in Super Mario Bros,
running left to right
92:50 - you might recall or have seen that
there's stuff like this in the sky.
92:53 - And Mario's supposed to
run under it and jump up
92:55 - and he gets coins or whatever by jumping
up and hitting these question marks.
92:59 - So this is mostly a very
contrived way of saying,
93:01 - suppose we want to
print out four question
93:03 - marks on the screen just like Super
Mario Bros, how could we do it?
93:06 - It's going to be a little black
and white, a little textual,
93:08 - but how do I print out
four question marks?
93:10 - Well, let me go over here and
let me create a file called,
93:14 - let's say, Mario0.py.
93:17 - And how do I do this?
93:18 - What's the simplest way to do
this, print four question marks?
93:22 - OK, I heard print.
93:24 - OK, four question marks.
93:25 - Very good.
93:26 - So let's go ahead and run Mario0.
93:28 - Correct, that's right.
93:29 - So this is not bad.
93:31 - It's one string, not a huge deal.
93:32 - Let's do it at least with a
loop, as we've been often doing,
93:35 - just to improve the
design, even though this
93:37 - is a very tiny, tiny, tiny example.
93:39 - So Mario1.py, let's go ahead and print
this out with a loop, for instance.
93:44 - So how do I do this?
93:45 - How do I print four question
marks, but one at a time?
93:49 - For i in range four,
print, question mark.
93:56 - Save, all right.
93:57 - So Python, Mario.
93:58 - Does anyone want to yell
out, no, don't do that?
94:01 - OK, thanks.
94:02 - That's great.
94:02 - All right, so why did you
not want me to do that?
94:05 - Because they're all vertical.
94:06 - So we did have a fix for this how.
94:08 - Do I tell print, don't end your
lines with the default new line?
94:12 - So and equals just quote unquote to
override the default backslash n value.
94:17 - So now I can rerun this.
94:18 - All right, it's a little buggy.
94:20 - So how can I fix this and only
put a newline after the last one?
94:24 - AUDIENCE: [INAUDIBLE]
94:25 - DAVID MALAN: Yeah, honestly,
just do print nothing.
94:27 - And that will have the effect
of printing a new line for free.
94:30 - So let's do this.
94:31 - OK.
94:32 - Now we've got a good example there.
94:33 - All right, so it turns out we
actually printed along the way
94:36 - a separate example, which looked
like this, albeit with four blocks.
94:40 - So we won't-- let's go ahead
and do this now vertically,
94:43 - not with question marks,
but with hashes like bricks.
94:45 - So if we want to print
out those three hashes,
94:47 - allow me to draw some inspiration
from this and let's say in Mario2.py,
94:53 - let me go ahead and just
say for i in range of three,
94:58 - go ahead and print out just one block.
95:01 - And as you've been
advising, just do this--
95:03 - or rather, no, let's use
the default to print out
95:06 - a vertical bar of three blocks.
95:08 - So this is Mario2.py.
95:10 - And now we've done something
reminiscent of that.
95:12 - But now things get a little
interesting if we go underground.
95:16 - And let's focus on this square.
95:17 - So three by three, for instance,
because we've not quite
95:20 - seen something like this.
95:22 - So in our last example here, let's see.
95:24 - Could we get maybe a brave volunteer
to come on up, tie some of these ideas
95:28 - together?
95:30 - Is that a hand back there?
95:31 - Come on down.
95:33 - So this will be Mario3.py, the
goal of which is to print a brick,
95:39 - a bigger brick--
95:40 - it's like 3 by 3-- hello again.
95:43 - ANDREA: Hello.
95:44 - DAVID MALAN: For the
audience, what's your name?
95:45 - ANDREA: Andrea.
95:46 - DAVID MALAN: Andrea, nice to see you.
95:47 - ANDREA: Nice to see you.
95:47 - DAVID MALAN: All right,
so the goal at hand
95:49 - is to print a three
by three grid of just
95:52 - hashes reminiscent of those bricks.
95:54 - All right, you're in charge.
95:56 - ANDREA: All right.
95:57 - Should I do, like, a loop or something?
95:59 - DAVID MALAN: Whatever gets the job done.
96:04 - All right, for.
96:07 - OK, good.
96:15 - OK, interesting.
96:23 - OK, print, quote
unquote, print, yeah, OK.
96:27 - ANDREA: OK.
96:28 - Oh, right.
96:29 - DAVID MALAN: Key detail.
96:30 - ANDREA: What was it, a hash?
96:31 - DAVID MALAN: A hash is fine, yeah.
96:32 - ANDREA: OK.
96:33 - DAVID MALAN: All right.
96:34 - And before we do this, does everyone
want her to run this program
96:40 - and be correct?
96:42 - AUDIENCE: Don't do it.
96:42 - DAVID MALAN: No, why?
96:45 - Someone who claims no, what?
96:46 - What's your concern?
96:47 - AUDIENCE: N equals--
it'll do it [INAUDIBLE]
96:50 - DAVID MALAN: Good, OK.
96:51 - So you fixed that.
96:52 - Good.
96:53 - Any other concerns?
96:55 - Yeah?
96:57 - AUDIENCE: [INAUDIBLE]
97:01 - DAVID MALAN: OK.
97:02 - Is it going to go up and down?
97:03 - Well, let's see.
97:03 - Can you walk us through
verbally-- do we have--
97:09 - can you walk us through
what the program does?
97:12 - [LAUGHTER]
97:15 - ANDREA: For i in range 3, so this
will happen three times, then j
97:19 - in range three, the next thing
will also happen three times.
97:22 - So we print a hash.
97:23 - And then we another
hash and another hash
97:25 - because the end is the quotation marks.
97:28 - DAVID MALAN: OK.
97:29 - ANDREA: And then that happens
and then we print a new line.
97:35 - And then it should
execute that three times.
97:38 - DAVID MALAN: All right.
97:39 - What do you think?
97:40 - Do you-- the duck is convinced.
97:42 - All right, why don't you
go ahead and save the file.
97:44 - Let's try.
97:45 - No harm in trying, so
right or wrong, let's see.
97:48 - This is called Mario3.py, and I think
we have round of applause if we could.
97:53 - Very nicely done.
97:55 - All right.
97:56 - So let's-- and if you'd like one more.
97:58 - So let's take a look
at one final example,
98:00 - coming full circle from where we began.
98:02 - We of course looked at resize.
98:04 - And let's open that up, just to see how
I got away with writing so little code
98:09 - and actually getting that job done.
98:11 - So in resize.py, which
is where we began,
98:14 - notice that I had a few lines that
hopefully look a little more familiar
98:17 - now.
98:17 - But we didn't exactly introduce
all of these features ourselves.
98:21 - So it turns out in line
one and line two we have
98:24 - one unfamiliar and one familiar line.
98:26 - Line two just gives us access to
a command line arguments, which
98:29 - we needed for resizing the bitmap.
98:30 - Line one is where a lot of
the power is coming from.
98:34 - It turns out there's a library
in Python called pillow
98:36 - that you can install by typing a
certain command at your terminal.
98:39 - It doesn't necessarily
come with your Mac or PC.
98:41 - You have to download it and
install it with a command.
98:43 - And then if you read
its documentation, it
98:45 - will say, from pill for
pillow import image.
98:48 - Now, that's not a specific image.
98:50 - That's the name of a
library called the image
98:52 - library that comes with that software
that someone freely made available.
98:56 - So that's just saying, give me
access to an image-related library.
99:00 - And undoubtedly, there could exist
similar things in C. But we of course
99:03 - did things very hands-on low-level.
99:06 - All right, if the length of argv is
not 4, yell at the user with the usage.
99:10 - And that's just if they don't cooperate
by typing in as they should, this.
99:13 - It's a little more verbose
now because we have Python
99:15 - and we have the file extension.
99:17 - But we could technically clean
that up if we really wanted.
99:19 - Lines 7, 8, and 9, there's
nothing really new there.
99:23 - I'm just declaring three
variables implicitly typed.
99:26 - I don't have to bother
saying int or string.
99:28 - I'm accessing argv 1, 2,
and 3, which is 1, 2, and 3.
99:33 - And then I'm doing one thing line 7.
99:35 - What is line 7 doing that's important?
99:39 - AUDIENCE: [INAUDIBLE]
99:41 - DAVID MALAN: I'm changing the
argument from what is technically
99:43 - a string by default-- because
indeed, it came from the human hands
99:46 - at a keyboard-- and
converting it into a number.
99:49 - Now, as an aside, if the user does
not provide a number like 2 or 10,
99:53 - this code could break.
99:54 - To be fair, I should really
have some error checking
99:56 - to make sure if the user typed
in hello and not 2 or 10,
100:00 - I need to catch that error.
100:01 - So I'm being a little sloppy.
100:02 - But it was really meant to
demonstrate succinct code.
100:06 - So now we have infile and outfile
defined exactly as before.
100:09 - So we have just three lines left that
actually implement most of the magic.
100:13 - Yeah.
100:14 - AUDIENCE: [INAUDIBLE]
100:22 - DAVID MALAN: Wait, say
the last part again.
100:24 - AUDIENCE: [INAUDIBLE]
100:26 - DAVID MALAN: Yes.
100:28 - AUDIENCE: There was almost [INAUDIBLE]
100:33 - DAVID MALAN: Good observation.
100:34 - So this is not just converting the
user's input to the equivalent ASCII
100:38 - value because that's not what we want.
100:40 - This int used here is
actually converting it
100:44 - as via a2i, a function that you've
probably used a couple of weeks ago,
100:48 - it's just named a
little more succinctly.
100:50 - There is a function via which you
could convert a character or a string
100:53 - to its ASCII equivalent.
100:55 - But that's not what's going on here.
100:56 - It does the more intuitive
turn this into an integer
100:59 - without using a cryptically
named function like a2i.
101:01 - So let's scroll down just a little
further to these last few lines
101:04 - and see what's going on.
101:05 - Some of them you would only
know how to do from having
101:08 - read the documentation just as we did.
101:09 - This says give me a
variable called in image.
101:11 - Could have called it anything.
101:13 - I'm just trying to be
consistent with in file.
101:14 - This says, use the image library.
101:17 - Use its open function
that comes with it.
101:19 - So image is some kind of
structure, inside of which
101:21 - is some useful
image-related functionality.
101:23 - So call its open function
on the name of the file,
101:26 - then go ahead and extract
its height and width.
101:29 - So turns out this is
another tuple, if you will.
101:32 - Tuples, again, are like x comma
y, latitude comma longitude.
101:35 - You'd only know that it is a
tuple from the documentation.
101:37 - So when I say width comma height, this
is taking what's technically a list
101:42 - of size two-- or really, a tuple--
101:43 - and it's just extracting for
me the width and the height.
101:46 - But let me wave my hands
at that particular syntax.
101:48 - The rest of this just
says the following.
101:50 - Give me a new variable called out image.
101:52 - Call the input image's resize function,
another piece of functionality
101:56 - built into it, just
like open, and change it
101:59 - by this width and this height--
the original width times n,
102:03 - the original height times n.
102:05 - No padding manipulation, that's all
the responsibility of the library.
102:08 - Some other human dealt
with all of that for us.
102:11 - And this last line,
perhaps not surprisingly,
102:13 - saves the output image
to that file name.
102:16 - So in just, what, 15
lines of code and fewer
102:18 - if we get rid of some of
the whitespace can you
102:20 - implement the entirety of resize.
102:22 - But really focusing on
the logic of the problem,
102:24 - I want to take an input from the user.
102:26 - I want to scale it up by a factor of n.
102:27 - And I want to save out the file.
102:28 - That's what you care about.
102:30 - You don't necessarily care about getting
into the weeds of exactly what it
102:33 - was you had to do when you did it in C.
102:36 - So let's do one final example here.
102:39 - You'll recall from problem set four
you implemented your own spell checker.
102:42 - And odds are you did a try
or a hash table or the like.
102:45 - And it turns out that is
non-trivial, certainly in C.
102:48 - And it's non-trivial certainly for
the first time in any language.
102:51 - But let me take a stab at
doing this now in Python.
102:53 - Let me go into source 6 where
I have a speller example.
102:57 - And notice that in this folder today
I've brought a few files with me.
103:00 - So I've brought a copy
of the dictionaries
103:03 - from p set four, a copy of the text
files, like la-la land and the like
103:06 - in text.
103:07 - And then I brought two files--
dictionary.py and speller.py--
103:11 - the latter of which is an
implementation of speller.c in Python.
103:14 - And I'm not going to pull that one
up because we wrote that one entirely
103:17 - for you.
103:18 - But let me go ahead and write, for
instance, just my own dictionary.
103:22 - So dictionary.py is the
analog of dictionary.c.
103:28 - And let's go ahead and set this up.
103:31 - Let me go ahead and create
this file in a separate folder
103:33 - for now, so dictionary.py.
103:36 - And there's a few
functions in dictionary.c
103:38 - which we should probably
get around to implementing.
103:40 - What are those functions?
103:41 - AUDIENCE: Load.
103:43 - DAVID MALAN: Load was
one, and load takes
103:45 - the name of a file or a dictionary.
103:46 - So let's do this.
103:47 - And I'll just say to do.
103:48 - Come back to that.
103:49 - What other functions
were in dictionary.c?
103:52 - Check, so def check.
103:53 - And what did check take as an input?
103:56 - A word, yep.
103:56 - So we'll come back to this and
just come back to that to do.
103:59 - What other functions?
104:00 - AUDIENCE: Size.
104:01 - DAVID MALAN: Size was one, so def size.
104:04 - This did not take input, but it just
returned the size of the structure.
104:07 - So we'll come back to that.
104:07 - And lastly?
104:08 - AUDIENCE: Unload.
104:09 - DAVID MALAN: OK, so unload.
104:10 - All right, so this is the Python
version of the distribution code
104:13 - for speller for your dictionary file.
104:15 - So unload also didn't take an argument.
104:17 - So that's something for us to do, too.
104:19 - So what's the gist of
making a spell checker?
104:22 - You are loading words in your load
function from a dictionary file.
104:25 - And the goal is to load
those somehow into memory.
104:27 - You had a design decision
for the p set in C,
104:30 - where you could make
a hash table or a try
104:32 - or even a linked list or even an array.
104:34 - But odds are the first of those
two were probably more efficient.
104:37 - So it turns out that in
Python, you have the ability
104:40 - to store words pretty readily in
any number of data structures.
104:43 - You have not just ints
and floats and strings,
104:46 - but you clearly have
lists, as we've seen.
104:49 - We call them objects
or hashes, hash tables.
104:52 - And there's other
things, too, even called
104:54 - sets, where a set is kind of
just a collection of words
104:57 - which would be very nicely searchable.
105:00 - And so you know what?
105:01 - If I want to ultimately
load some words, let
105:03 - me give myself a global
variable called words
105:05 - and just initialize it to an empty set.
105:08 - So I have a global variable called
words and nothing is in it just yet.
105:11 - But it's a set of words.
105:13 - How do I go about loading
words into that dictionary?
105:15 - Well, let's go ahead
and implement load here.
105:17 - So let me go ahead and declare
a variable called file and open
105:20 - this dictionary in read
mode, just as in C.
105:24 - And then how do I integrate
over the lines in a file?
105:26 - We've not seen that.
105:27 - But I do know how to iterate
over the strings in an array
105:30 - and the characters in a string.
105:31 - So let me go with my
instinct for line in file.
105:35 - Indeed, this will do exactly
what you want it to do.
105:38 - Then let me go ahead and add to my
words data structure the following line.
105:44 - And then let me close the file.
105:46 - And then let me just say return
true because all is well.
105:49 - Done.
105:50 - All right, so I'm cutting
a few corners, technically.
105:53 - Let me use that function
I alluded to earlier.
105:55 - Let me go ahead and call
r strip and strip off
105:58 - the new line because in
the file, technically,
106:00 - when you're reading in those words,
every line ends with a backslash zero.
106:03 - That's now part of the word.
106:04 - So a minor correction there
that I'm stripping off the line.
106:07 - But that's it for load.
106:08 - How do I now check if a
given word is in that set?
106:13 - Well, I can just say, if
word in words return true.
106:18 - Else, return false.
106:21 - Done with check.
106:22 - How do I return the size
of this data structure?
106:26 - How about I just return the length
of that structure, words, and then
106:30 - unload--
106:30 - heck, Python's doing this all for me--
106:33 - done.
106:35 - Let me shrink this.
106:37 - And you know what?
106:37 - This is a little verbose.
106:39 - I don't actually need
to do this if else.
106:40 - I could just return word in words and
that will return a Boolean for me.
106:44 - And honestly, if I want to
lower case it, that's easy.
106:46 - I can just do this
and take care of that.
106:48 - Now it's even better.
106:49 - That's p set 4.
106:54 - Excited?
106:56 - Wish we had done this in C?
106:57 - So what is the whole
point of all of this,
106:59 - because the goal wasn't to create
sort of great angst and wonder now.
107:03 - But the whole point of having introduced
C over these past few weeks is to,
107:07 - one, none of this now
do you take for granted.
107:09 - I mean, you might be longing for
having implemented this in Python.
107:12 - And you might have had to
read some documentation
107:13 - and figure out the various syntax.
107:15 - But my God.
107:16 - We whittled down what probably took
most of you hours into just seconds
107:20 - once you're more comfortable
with the language.
107:22 - But also, to our very
earliest point today,
107:23 - once you have the right language
and the right tool for the job.
107:27 - Now, it's not to say that this
is perfect, because in fact,
107:30 - let's go ahead and do some tests.
107:31 - Let me go into my terminal window here.
107:34 - And I actually brought my own
solution in my C folder here.
107:38 - Let's see.
107:38 - I have my own code to speller
implemented in C here.
107:43 - And let me go ahead and run a test.
107:45 - Let me go ahead and run speller
on, say, the text Shakespeare.
107:49 - That's a pretty big input.
107:50 - Let's go ahead and hit Enter.
107:51 - And this is my spell checker running.
107:53 - And all the words are outputting.
107:54 - And the time total to run speller
in C was, say, 0.9 seconds.
107:58 - So that's actually pretty good.
108:00 - In a second window, let me go up
here in another terminal window.
108:03 - And let me go into today's code and
into the speller folder where I have
108:08 - a Python version that I'm going
to run as follows-- speller.py--
108:12 - let me go ahead and
run it on Shakespeare.
108:15 - So we've not looked at speller.py.
108:16 - But it is essentially line for line a
port, a translation, from C to Python.
108:20 - But you're welcome to
look at that online.
108:22 - And it's using my dictionary.py file.
108:25 - Let me go ahead and run that.
108:27 - It's running through all the words.
108:28 - Top is Python, bottom is C. Here we go.
108:33 - Here we go.
108:36 - Here we go.
108:38 - Now, this is a bit misleading because
again, the internet is the way.
108:41 - We're using a web-based IDE, and so it's
funny that that appears so many times.
108:46 - And you'll see it's not 10, 20
seconds, however long that was.
108:48 - That was just the internet being slow.
108:50 - And all we're timing is your
functions in both C and Python.
108:53 - But what's the takeaway
between Python and C?
108:58 - Same inputs.
109:01 - What do you see?
109:02 - Yeah?
109:03 - AUDIENCE: Be more concise [INAUDIBLE].
109:05 - DAVID MALAN: Yeah, I
wouldn't say concise.
109:07 - That's more aesthetic.
109:08 - It's more--
109:09 - AUDIENCE: Specific [INAUDIBLE].
109:10 - DAVID MALAN: Well, not
even that, I think.
109:12 - These are correct.
109:13 - Both of them are correct.
109:14 - All the important numbers
at the top are identical.
109:18 - But what is clearly different, though?
109:21 - It's slower.
109:22 - So Python seems to be slower, right?
109:24 - It takes in total-- if we
just look at two numbers--
109:27 - 1.55 seconds in Python, if
you ignore the internet speed
109:30 - and just look at the code
performance, versus 0.9.
109:32 - So it's almost twice as slow as
C. So what's the takeaway there?
109:37 - Well, yes, it took me, what, 10,
20, 30 seconds to write the code.
109:42 - But it's taking me
twice as long to run it.
109:44 - Now, not a big deal,
of course, when we're
109:45 - talking a few seconds here and there.
109:46 - But if this were a big data set that
you're analyzing for some project
109:49 - or for work or for any kind of analysis
project and the data is much larger
109:54 - than even this-- especially in
the medical field or the like--
109:57 - maybe you don't want to use Python.
109:58 - Sure, you can bang out the code in
just a few minutes, maybe a few hours.
110:01 - But once you run it, damn, it's
slower than using something like C.
110:05 - Whereas in C, might take
you more time upfront.
110:08 - And you might not even
have the comfort with C
110:10 - anymore so it's going to take an even
longer because you have to go relearn
110:12 - the language.
110:13 - But when you run it, wow,
it runs twice as fast.
110:16 - You therefore need
less RAM, potentially,
110:18 - less hardware or less expensive hardware
because you can get away with more.
110:21 - So again, this theme we keep seeing
in data structures and algorithms
110:24 - is trade-offs.
110:25 - Like, developer time is a resource
and it is wonderful that I
110:28 - and now you would be able to
write code so much more quickly.
110:31 - But you do have to
pay a price somewhere.
110:33 - And there's clearly a price with Python.
110:35 - And it's not because Python
is poorly implemented.
110:37 - But what is the fundamental
difference between the paradigm
110:40 - of programming in C versus in
Python as we've seen it today?
110:44 - What's different?
110:45 - Yeah?
110:46 - AUDIENCE: [INAUDIBLE] line by
line, whereas C, it essentially--
110:52 - [INAUDIBLE] optimize running
it, it will run [INAUDIBLE]..
110:57 - DAVID MALAN: Indeed.
110:57 - And let me flip it around.
110:58 - So with C, you're compiling
down to zeros and ones.
111:00 - And that compiler is super smart.
111:02 - And it's going to move
things around in memory.
111:03 - It's going to talk the computer's
native language of zeros and ones.
111:06 - Python is, indeed, reading your code, by
contrast, line by line, top to bottom,
111:10 - left to right.
111:11 - And even though technically underneath
the hood there is a compilation step,
111:14 - there is nonetheless
some overhead involved.
111:16 - The mere fact that we're no
longer running clang and then
111:18 - getting 0's and 1's or running make and
getting zeros and ones, that's great.
111:22 - But we have to pay the price somewhere.
111:24 - So this is going to be thematic.
111:25 - Like, there is no holy grail among
languages or tools or techniques.
111:28 - There's going to be trade-offs
among your comfort, your familiarity
111:31 - or recollection of a language,
how easy it is to use,
111:33 - how succinctly you can type it, and
then how efficiently you can actually
111:37 - run it on the screen.
111:39 - And with C, hopefully now-- we
will not write any more C-code--
111:42 - you have an appreciation in
Python of when you create a hash--
111:45 - or a list, rather--
111:47 - or if you create a set or a hash
table or the like, what you're really
111:50 - getting access to is someone
else's implementation of p
111:53 - set four and p set three and p set
two and p set one, in some form,
111:57 - but now exposed to you in a more
powerful and more modern language.
112:01 - So let's end there officially today.
112:02 - And next week, we'll do the same thing,
but in the context of web programming.