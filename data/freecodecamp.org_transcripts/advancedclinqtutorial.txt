00:00 - learn about Link in this Advanced
00:02 - c-sharp course Gavin long teaches this
00:05 - course he is an experienced developer
00:07 - and course creator and also a free code
00:10 - Camp team member link provides a set of
00:12 - operators that enable developers to
00:14 - query protect and filter data in arrays
00:17 - Collections and other data sources it
00:20 - can be used to query and manipulate data
00:22 - from databases XML documents and net
00:25 - objects
00:26 - hi and welcome I'm Gavin long I've been
00:28 - a full stack software engineer for over
00:30 - 20 years about three years ago I created
00:33 - an advanced c-sharp course on the
00:35 - gavinlan YouTube channel you'll find the
00:37 - gavinlan YouTube channel at this
00:38 - location and you'll see a playlist for
00:41 - the advanced c-sharp course on the
00:43 - homepage of the gavinlan YouTube channel
00:45 - here is the URL for the advanced c-sharp
00:48 - course playlist the idea behind the
00:51 - course was to explain the more advanced
00:53 - c-sharp features of the language in an
00:55 - easy to understand way to help c-sharp
00:58 - developers who are familiar with the
00:59 - basics of the language Advance their
01:02 - skills to the next level the course may
01:04 - also help those developers who may use
01:06 - the advanced features of c-sharp like
01:09 - for example Link in their day-to-day
01:10 - tasks but perhaps don't fully understand
01:12 - the Technologies at a deeper level free
01:16 - code Camp has kindly allowed me to share
01:18 - a subset of the advanced c-sharp course
01:20 - it's the seventh part of the advanced
01:22 - c-sharp course with you on the free code
01:25 - Camp YouTube channel so in this video
01:27 - we'll look in detail at a set of
01:30 - Technologies named Link Link stands for
01:32 - language integrated query and is very
01:34 - powerful where sophisticated queries can
01:37 - be made against collections of objects
01:39 - and for example you can perform
01:40 - filtering ordering and grouping
01:43 - operations on data sources with a
01:46 - minimum of code I hope you enjoy this
01:48 - course and benefit from it
01:51 - [Music]
02:00 - hi and welcome to the first part of a
02:03 - video series on link
02:05 - this video is also the first part of the
02:08 - seventh tutorial in an advanced c-sharp
02:10 - course later in this tutorial we're
02:13 - looking at a code example to help with
02:15 - our understanding of Link but let's
02:17 - first answer the question what is link
02:20 - link stands for language integrated
02:22 - query
02:23 - link is defined in the Microsoft docs as
02:26 - the name for a set of Technologies based
02:29 - on the integration of query capabilities
02:32 - directly into the c-sharp language
02:35 - link was originally released as a major
02:37 - part of NET Framework 3.5 in 2007
02:43 - here is a paragraph
02:44 - from the Microsoft docs which provides
02:47 - an excellent overview of what link is
02:50 - language integrated query link is the
02:53 - name for a set of Technologies based on
02:56 - the integration of query capabilities
02:57 - directly into the c-sharp language
03:00 - traditionally
03:02 - queries against data are expressed as
03:05 - simple strings without type checking at
03:08 - compile time or intellisense support
03:12 - furthermore you have to learn a
03:14 - different query language for each type
03:16 - of data source SQL databases
03:19 - XML documents various web services and
03:23 - so on
03:24 - with link a query is a first class
03:27 - language construct just like classes
03:30 - methods events
03:32 - you write queries against strongly typed
03:34 - collections of objects by using language
03:37 - keywords and familiar operators
03:41 - the link family of Technologies provides
03:44 - a consistent query experience for
03:46 - objects link to objects relational
03:49 - databases linked to SQL and XML link to
03:53 - XML
03:55 - note that you can write link queries in
03:57 - c-sharp for SQL Server databases XML
04:00 - documents ado.net datasets and any
04:03 - collection of objects that support the I
04:06 - enumerable interface or the generic I
04:09 - enumerable interface
04:11 - so for example you can perform link
04:13 - queries against collection types like an
04:15 - array generic list generic dictionary
04:18 - generic Q generic stack Etc
04:22 - basically any collection type that
04:25 - implements the I enumerable interface or
04:27 - the generic I enumerable interface
04:31 - link support is also provided by Third
04:34 - parties for many web services and other
04:36 - database implementations
04:39 - you can create custom providers using I
04:42 - queryable
04:43 - custom providers will not be discussed
04:45 - in detail in this video series
04:48 - if you would like to learn more about
04:50 - implementing your own custom provider
04:52 - please navigate to this URL
04:55 - in this video series we'll primarily
04:57 - focus on linked to objects and link to
05:01 - entities
05:02 - linked to entities provides language
05:04 - integrated query link support that
05:07 - enables developers to write queries
05:09 - Against The Entity framework conceptual
05:12 - model using either Visual Basic or
05:14 - visual c-sharp
05:16 - so Entity framework core is a modern
05:18 - object database mapper for net it
05:21 - supports link queries change tracking
05:24 - updates and schema migrations
05:28 - Entity framework core or EF core can be
05:31 - used to work with many databases
05:33 - including SQL databases on-premises and
05:36 - Azure sqlite MySQL postgres and Azure
05:41 - Cosmos DB
05:43 - in this video series we won't look at
05:46 - link to data set or link to XML please
05:48 - navigate to this URL for more
05:50 - information on linked dataset and please
05:53 - navigate to this URL for more
05:55 - information on linked to XML
06:04 - to get started with link in this video
06:06 - we'll focus on link to objects so that
06:09 - we can first get a basic idea of what
06:11 - the implementation of Link looks like in
06:13 - code and how it can be used for querying
06:16 - c-sharp collections
06:19 - so in the spirit of cross-platform
06:21 - Development I've decided to demonstrate
06:23 - this code example on my Mac platform
06:26 - using visual studio 2019 for Mac
06:29 - Community Edition
06:30 - if you have a Mac platform and wish to
06:33 - follow along on your Mac and you don't
06:35 - yet have Visual Studio installed
06:38 - you are able to download and install
06:40 - Visual Studio Community Edition 2019
06:42 - free of charge from this location all
06:45 - links mentioned in this video are
06:47 - available Below in the description
06:51 - if you are using a Windows OS please
06:54 - don't let the fact that I'm using a Mac
06:56 - platform put you off following along
06:58 - with this tutorial in terms of the code
07:01 - example that we'll create in this video
07:03 - the coding experience using visual
07:06 - studio for Mac is almost exactly the
07:08 - same as the coding experience using
07:11 - visual Studio for Windows so this should
07:13 - not be a barrier for a learner to follow
07:15 - along with this demonstration
07:17 - if you haven't yet installed Visual
07:19 - Studio 2019 on your windows platform
07:22 - please view a video created by this
07:25 - channel which provides a guide to
07:27 - installing Visual Studio 2019 Community
07:30 - Edition free of charge
07:33 - so firstly let's create a.net core
07:35 - console application
07:49 - let's name this project the pretend
07:52 - company application
07:57 - before we write calling client code in
08:00 - the main method we are going to add two
08:02 - standard Library projects
08:04 - let's first add a standard Library
08:05 - project named TCP data
08:13 - let's then add another standard Library
08:15 - project named TCP extensions
08:19 - foreign
08:32 - so let's now go to our project that we
08:34 - named TCP data let's delete the class
08:37 - that has been automatically generated
08:39 - for the TCP data project
08:45 - let's add a new class named employee
08:51 - let's add six autoimplemented properties
08:54 - to the employee class ID as int first
08:58 - name as string last name as string
09:00 - annual salary as decimal is manager as
09:04 - Boolean and lastly Department ID as int
09:09 - okay
09:13 - let's add another class to the TCP data
09:16 - project
09:17 - let's name this class Department
09:21 - let's add three Auto implemented
09:23 - properties to our department class
09:25 - ID as int short name as string and long
09:29 - name as string let's add a class named
09:32 - data to our TCP data project let's make
09:35 - this class a static class
09:38 - so let's add two public static methods
09:41 - to the data class
09:43 - let's first create a static method named
09:45 - get employees which returns a generic
09:49 - list strongly typed as employee let's
09:52 - ensure
09:53 - that we include the appropriate using
09:55 - directive for the use of generic list
09:57 - objects at the top of our code editor
10:01 - so let's include a using directive to
10:04 - the
10:05 - system.collections.generic namespace
10:06 - like this
10:18 - let's write the code to add some made up
10:21 - employee records to a generic list that
10:24 - is strongly typed with the user-defined
10:26 - type employee
10:54 - foreign
11:57 - let's write code to return the list of
12:00 - employee records to the calling client
12:02 - code
12:06 - foreign
12:30 - let's add another static method and
12:33 - let's name this method get departments
12:39 - this method also returns a generic list
12:41 - object but this generic list object is
12:44 - strongly typed as Department
12:47 - let's write the codes to add some made
12:49 - up Department Records to a generic list
12:51 - that is strongly typed with the
12:54 - user-defined type Department
13:04 - foreign
13:16 - let's write code to return the list of
13:18 - Department Records to the calling client
13:21 - code
13:25 - foreign
13:31 - so as you can see the get employees
13:34 - method returns a list of employee
13:36 - records and the get departments method
13:38 - returns a list of Department Records
13:42 - so in order to gain an understanding for
13:44 - how Link Works let's ensure that we
13:47 - properly understand two fundamental
13:49 - concepts I.E the concept of extension
13:52 - methods and the concept of Lambda
13:54 - expressions
13:55 - so let's go to our TCP extensions
13:58 - project
13:59 - let's delete the class that was
14:01 - auto-generated by Visual Studio when we
14:04 - created the project
14:05 - let's add a class named extension
14:08 - so in order for our extension method to
14:10 - work we must make the extension class a
14:13 - static class
14:15 - so we are going to add a method named
14:17 - filter
14:18 - the idea here is we want a way where we
14:21 - can extend the functionality of any
14:23 - generic list that is strongly typed with
14:26 - any c-sharp data type including
14:28 - user-defined types we can achieve this
14:31 - by creating our own extension method so
14:34 - for example if we want to filter
14:35 - employee records by criteria that we are
14:38 - able to specify through a Lambda
14:40 - expression on a generic list that is
14:42 - strongly typed as the employee
14:45 - we can do this through our filter
14:47 - extension method this will be
14:49 - demonstrated in the calling client code
14:51 - in a bit
14:53 - so how do we create our own custom
14:55 - extension method
14:57 - so I'll first create the method
14:59 - signature for the filter extension
15:01 - method
15:02 - first notice that our method like the
15:05 - class in which it resides must be static
15:08 - which is achieved by including the
15:10 - static keyword
15:12 - in the relevant extension methods method
15:14 - signature
15:15 - so if we look at the first parameter in
15:18 - the filter methods method signature we
15:20 - can see
15:22 - that we are using for this keyword
15:24 - preceding the data type of the first
15:26 - parameter which is a generic list of
15:29 - type t
15:30 - this keyword in this context indicates
15:33 - to the compiler that the relevant method
15:35 - can be called on an object of the data
15:37 - type of the relevant parameter in this
15:40 - example that is a generic list which
15:42 - contains a type T placeholder as we know
15:45 - from the video series on c-sharp
15:47 - generics a developer is able to pass a
15:50 - data type argument to the parameter of
15:53 - type T which can be any c-sharp data
15:56 - type including user-defined types
15:59 - the data type specified will be chosen
16:02 - depending on the requirement that needs
16:03 - to be met by The Calling client code
16:06 - we'll demonstrate the consumption of
16:08 - client-side code for the filter
16:09 - extension method in a bit
16:13 - so let's look at the second parameter
16:15 - which is of the delegate type func for
16:18 - more information about the func delegate
16:20 - type please view a video created by this
16:22 - channel on this topic a link to this
16:25 - video is available Below in the
16:26 - description
16:27 - the first data type parameter passed to
16:30 - the funk delegate type represents the
16:33 - first data type of the first parameter
16:34 - of the method referenced by the relevant
16:37 - argument passed into this parameter
16:40 - the last parameter in the funcdelegate
16:42 - type definition is the return type of
16:45 - the method referenced by the argument
16:47 - passed into this parameter so the first
16:50 - parameter passed into the funk delegate
16:52 - is of type T and the second parameter is
16:54 - of type bull
16:56 - note that a predicate delegates type can
16:59 - be used to define method definitions for
17:01 - a method that returns a Boolean value
17:04 - so we could replace the funk delegate
17:07 - type with a predicate delegate type
17:08 - let's use the funk delegate type but
17:11 - please note that we could also achieve
17:13 - the same end using the predicate
17:15 - delegate type
17:17 - and as you can see this method will
17:19 - return a list of objects of type t to
17:21 - the calling client code
17:24 - so let's complete the logic for this
17:26 - method let's implement the code for the
17:28 - filter method
17:31 - so basically we are looping through the
17:33 - list on which the filter extension
17:35 - method is invoked we are then adding its
17:38 - elements to a new generic list also of
17:40 - type T whether or not we add this list
17:44 - item is based on the Boolean value
17:46 - returned by a method reference passed
17:49 - into the second parameter of the filter
17:51 - method so the relevant method reference
17:54 - is stored in the argument passed to the
17:56 - parameter named funk
17:58 - as you can see the method that the
18:01 - variable named Funk references accepts
18:03 - an argument of type t
18:06 - so we are passing in each item stored in
18:09 - the calling clients list
18:11 - which is the generic list on which
18:13 - calling client code will invoke the
18:15 - filter extension method
18:17 - if the method that the func variable
18:19 - references returns true the items stored
18:22 - in the iterated list is added to a new
18:25 - list
18:26 - we then return the new list containing
18:28 - the filtered items to the calling client
18:30 - code so this effectively means that the
18:33 - calling client code is able to use our
18:36 - filter method to filter any generic list
18:38 - based on a method created in the calling
18:41 - client code this method created in the
18:43 - calling client code will contain the
18:45 - logic for filtering the relevant generic
18:48 - list
18:49 - a reference to this method will be
18:51 - passed into the second parameter of our
18:53 - filter extension method and must adhere
18:55 - to the method definition represented in
18:58 - the second parameter of the filter
18:59 - method I.E the definition represented in
19:03 - the func delegate type
19:05 - so we are now going to implement the
19:07 - calling client code and you'll see that
19:10 - the method passed into the second
19:11 - parameter of our filter method will be
19:14 - an anonymous method I.E a method that is
19:17 - not named this method will be expressed
19:19 - as a Lambda expression
19:23 - we'll now see how we are able to filter
19:25 - a generic list using our filter
19:27 - extension method through calling client
19:29 - code in the main method of our
19:31 - application
19:34 - right so let's go to the.net core
19:36 - console project and write the calling
19:38 - client code in our main method
19:43 - firstly let's reference our two standard
19:45 - Library projects from our.net core
19:47 - console project
19:50 - so let's right click the dependencies
19:52 - node in the.net core console project and
19:55 - tick TCP data as well as TCP extensions
20:00 - so let's test our filter extension
20:02 - method in a bit I'll further elucidate
20:06 - why it is important to understand
20:07 - extension methods and Lambda expressions
20:10 - with regards to link
20:13 - through the magic of how extension
20:15 - methods work in c-sharp we should be
20:17 - able to call the extension method on any
20:19 - generic list object
20:21 - so let's define a generic list that is
20:24 - strongly typed as the employee user
20:26 - defines type
20:28 - so we have a red squiggly line under our
20:30 - generic list type definition so to fix
20:33 - this we need to include a directive at
20:36 - the top of our code to the
20:38 - system.collections.generic namespace
20:41 - we can see that there is a red squiggly
20:43 - line under the code that strongly types
20:46 - our generic list as the user's defined
20:48 - type employee
20:50 - so to fix this let's include a directive
20:52 - at the top of our code to the TCP data
20:55 - namespace
20:56 - great
20:58 - so through the magic of extension
21:00 - methods we should see the filter method
21:02 - appear in the intellisense drop-down
21:04 - list when we add a DOT after the
21:07 - employee list variable
21:13 - okay so why are we not seeing the filter
21:16 - method appearing in our intellisense
21:18 - drop-down list
21:20 - the reason for this is because we
21:22 - haven't included a using directive to
21:25 - the appropriate namespace so let's
21:27 - include a using directive at the top of
21:29 - our code to the appropriate namespace IE
21:32 - TCP extensions
21:34 - so now if we add a DOT immediately after
21:37 - the employee list variable the magic of
21:40 - extension methods is revealed to us and
21:43 - we can see our filter method in the
21:45 - intellisense drop down list
21:47 - so note that when we Open brackets to
21:50 - pass in appropriate arguments to the
21:52 - filter method we see that only one
21:54 - parameter is required this parameter was
21:58 - the second parameter we defined for this
22:00 - method
22:01 - so why is the first parameter in the
22:03 - filter method not listed when we open
22:05 - the brackets in this way
22:07 - well the answer to that question is this
22:09 - is how extension methods work
22:11 - the consumer of the code IE the calling
22:14 - client code does not need to pass in the
22:16 - first parameter this is automatically
22:18 - handled behind the scenes as it were
22:21 - by default the first parameter is the
22:24 - object on which the relevant extension
22:25 - method is invoked
22:28 - so in this case the list of employees
22:30 - stored in the employee list variable
22:33 - is passed into the filter method into
22:35 - this parameter automatically
22:38 - so if we look at the filter extension
22:40 - method we can see that this keyword
22:42 - precedes the definition of the first
22:45 - parameter
22:46 - that this keyword in this context
22:49 - is telling the c-sharp compiler that the
22:52 - argument passed into this parameter is
22:54 - the object on which the relevant
22:56 - extension method is invoked so we have
23:00 - access to the argument passed into the
23:02 - first parameter automatically
23:05 - okay so the second parameter
23:08 - accepts a delegate object
23:10 - that points to a method that needs to be
23:13 - created on the calling client so this
23:15 - method that we'll create essentially
23:17 - tells the filter method how we want our
23:20 - list filtered
23:22 - so we are able to Define this method and
23:25 - the calling client code through the use
23:27 - of a Lambda expression
23:29 - a Lambda expression is a concise way to
23:32 - represent an anonymous method if we look
23:34 - at the definition of the relevant
23:36 - delegate parameter we need to define a
23:39 - method that accepts an argument of type
23:42 - T and returns a Boolean value
23:45 - so the c-sharp compiler has enough
23:47 - information to infer that the intended
23:50 - type for type T is employee in this
23:53 - context we are calling the filter
23:55 - extension method on a strongly typed
23:57 - generic list the generic list is
24:00 - strongly typed with the employee user
24:02 - defined type
24:04 - so say we want to filter our employee
24:07 - list based on the value of each relevant
24:09 - employee items is manager property
24:12 - we want to filter the list where we only
24:15 - want to return those employee records
24:18 - where is manager is true
24:20 - so we want to return all the records
24:22 - from our list where the relevant
24:24 - employees are managers
24:28 - so to achieve this we can pass in this
24:31 - Lambda expression
24:33 - here we are telling the filter method
24:35 - how we want our list filtered
24:40 - let's write code to print the results to
24:42 - the console screen
24:55 - foreign
25:07 - let's run the code
25:19 - okay so we have no data
25:22 - ah we of course need to populate our
25:25 - employee list with data no so let's
25:27 - assign the value returned from data.get
25:30 - employees to the employees list variable
25:46 - right let's run the code
25:50 - great and you can see that only the
25:53 - employee records whether relevant is
25:55 - manager property value is set to true or
25:58 - returned to the calling client code
25:59 - great
26:01 - and we can of course inject the converse
26:04 - of this logic into our filter method
26:06 - through the relevant Lambda expression
26:08 - like this
26:10 - so we are now saying we only want to
26:12 - bring back employees who are not
26:14 - managers let's run the code
26:19 - great
26:27 - and for good measure let's modify our
26:30 - Lambda expression so that the filter
26:32 - method only returns employees that earn
26:35 - less than 50 000 a year
26:44 - great
26:45 - and because we have used generics for
26:47 - our filter method we can call the filter
26:49 - method on a list of various c-sharp
26:52 - types including user-defined types so
26:55 - let's prove this and call our filter
26:57 - extension method on a list of
26:59 - departments
27:02 - foreign
27:10 - let's filter the Departments based on
27:13 - the Department's short name so let's
27:15 - bring back the finance department and
27:17 - the human resources department
27:31 - foreign
27:58 - let's bring back only those departments
28:01 - with IDs greater than one
28:03 - so the point of this is to show you the
28:06 - flexibility that the combination of
28:08 - extension methods and Lambda Expressions
28:10 - create when writing the calling client
28:13 - code
28:14 - the combination of extension methods and
28:16 - Lambda Expressions not only provide this
28:18 - flexibility but at the same time ensure
28:21 - that the calling client code is clean
28:23 - and concise
28:25 - once we understand how extension methods
28:28 - and Lambda Expressions work they are
28:30 - incredibly powerful tools
28:32 - so how do extension methods and Lambda
28:35 - Expressions work in relation to the
28:37 - topic of this video link language
28:39 - integrated query
28:41 - extension methods and Lambda expressions
28:44 - are fundamental to how link is
28:46 - implemented in c-sharp
28:49 - the enumerable class and the queryable
28:51 - class are two static classes that
28:53 - contain extension methods the
28:54 - innumerable class and the queryable
28:56 - class are both members of the
28:59 - system.link namespace
29:02 - so to gain access to the extension
29:04 - methods provided through link we can
29:07 - simply include a using directive to the
29:09 - system.link namespace
29:12 - without including a using directive to
29:15 - the system.link namespace you can see
29:17 - that we are not able to access the where
29:20 - extension method provided by link to
29:22 - perform our filtering operation on a
29:25 - collection that implements the I
29:27 - enumerable interface
29:29 - so let's include the system.link
29:31 - namespace
29:35 - we now have access to Links where
29:37 - extension method so we can now replace
29:40 - our custom filter extension method with
29:42 - the where link extension method like
29:44 - this
29:46 - we don't need to create our own filter
29:48 - extension methods to perform such
29:50 - queries on our data link has got us
29:53 - covered for this
29:55 - you know
30:30 - link also provides us with a SQL like
30:33 - query syntax so for example if we wanted
30:36 - to produce a query result by joining
30:39 - selected fields from data selected from
30:42 - our collection of employee objects with
30:45 - selected fields or field in this case
30:47 - from data in our collection of
30:50 - Department objects we can use Link query
30:53 - syntax to perform our inner join
30:55 - operation on these two collections of
30:58 - data like this
31:00 - and the link query we want to include
31:02 - the department long name field so that
31:05 - we can have a descriptive name for our
31:08 - department in our results set rather
31:10 - than displaying a result that only
31:13 - contains the department ID which is
31:15 - available in the employee type so we can
31:18 - achieve this result by using the join
31:21 - clause in a link query to perform our
31:23 - inner join on our collection of employee
31:25 - objects with our collection of
31:27 - Department objects we have the
31:29 - department ID property in the employee
31:31 - type so we can join using this
31:34 - department ID property in the employee
31:36 - type to the ID property which is a
31:39 - member of the department type
31:42 - so say we were to write the equivalent
31:44 - query using transact SQL against the SQL
31:47 - Server database that contained an
31:50 - employee table with the same data schema
31:52 - as our employee type and the department
31:55 - table that contains the same schema as
31:58 - our department type the transact SQL
32:00 - query syntax would look something like
32:02 - this
32:03 - we are using an inner join to join data
32:06 - in an employee table with data in a
32:08 - department table
32:10 - we are able to make the join because the
32:12 - employee table contains the department
32:13 - ID
32:15 - which can be joined in our query the ID
32:17 - of the department table
32:20 - so you can see the similarities and
32:22 - syntax between the transact SQL syntax
32:24 - and the link query syntax
32:27 - the link query is dealing with objects
32:30 - encapsulating the employee and
32:32 - Department Records
32:34 - the employee list collection is like the
32:36 - employee table and the department list
32:38 - is like the department table in this
32:40 - particular context
32:42 - we have a select Clause a from clause
32:46 - and a join clause in the Syntax for both
32:48 - the link query and the transact SQL
32:51 - query however the from clause in the
32:53 - link query appears at the beginning of
32:56 - the query and the select clause in the
32:58 - link query appears at the end of the
33:00 - query
33:01 - so there are differences in The Ordering
33:03 - of the Clauses When comparing the syntax
33:06 - of the transact SQL query with the
33:08 - syntax of the relevant link query
33:11 - an advantage of link is it can be
33:13 - leveraged in our c-sharp code to query
33:16 - data in a standardized way
33:19 - that is independent from the format of
33:21 - the underlying data source the data
33:24 - source could be a mongodb database a
33:27 - sqlite database a SQL Server database
33:30 - Etc
33:31 - this will not affect the syntax of our
33:34 - link queries
33:36 - so the object layer provided by link can
33:39 - be used for abstracting our queries of
33:42 - the data from the underlying data source
33:45 - and by using link we also have the added
33:48 - advantage of compile time strong typing
33:51 - and the type checking provided by the
33:53 - c-sharp compiler
33:57 - let me draw your attention to the select
33:59 - clause we are able to return the data as
34:03 - an i enumerable collection of anonymous
34:05 - types
34:07 - we are assigning The Collection returned
34:09 - by the link query to a variable preceded
34:12 - by the VAR keyword
34:14 - beginning with c-sharp version 3
34:16 - variables that are declared at method
34:19 - scope can have an implicit type VAR
34:24 - through the use of the VAR keyword the
34:27 - c-sharp compiler is able to infer the
34:29 - types included in the collection
34:31 - returned from the query
34:34 - so we are able to return a collection of
34:36 - objects that are of an anonymous type
34:39 - that we have defined directly within the
34:42 - link query
34:44 - Anonymous types provide a convenient way
34:47 - to encapsulate a set of read-only
34:49 - properties into a single object without
34:51 - having to explicitly Define a type first
34:55 - you can see how the use of anonymous
34:57 - types can provide the developer with
34:59 - flexibility and convenience when
35:01 - constructing relatively complex queries
35:13 - okay
35:54 - note that Microsoft recommends using the
35:57 - query syntax where possible as opposed
35:59 - to using relevant extension methods for
36:01 - the same purpose this is because of the
36:03 - readability Advantage provided in the
36:06 - relevant query syntax
36:09 - there are however times
36:11 - where you'll need to use appropriate
36:13 - extension methods included within the
36:15 - link namespace because some
36:17 - functionality in link does not have a
36:19 - query syntax counterpart
36:22 - for example if we wanted to calculate
36:24 - the average salary for all employees we
36:27 - would need to use the average extension
36:29 - method like this
36:31 - the same applies if we wish to query for
36:34 - the highest salary from a list of
36:35 - employee records we would need to use
36:38 - the max extension method like this
36:40 - this functionality cannot be performed
36:43 - through the use of query syntax
36:46 - but where possible query syntax is
36:48 - preferable
36:49 - due to the code readability advantage
36:52 - that this syntax provides
36:54 - I hope you've enjoyed this video which
36:57 - provides an introduction to link
36:59 - this video was created to help with the
37:01 - understanding of the fundamentals of
37:03 - Link the advantages that link provides
37:04 - and how we are able to implement basic
37:07 - link queries in code
37:09 - link provides us with an integration of
37:11 - query capabilities directly into the
37:14 - c-sharp language it is a very powerful
37:16 - technology that decouples query logic
37:19 - from relevant types of underlying data
37:22 - formats link provides a layer of
37:24 - abstraction that provides the developer
37:27 - with easy to implement Syntax for
37:29 - querying collections of objects
37:32 - the relevant collection types must
37:34 - implement the I queryable or generic I
37:37 - queryable interface or the innumerable
37:39 - or generic I enumerable interface
37:42 - note that the I queryable interface
37:45 - inherits from the I enumerable interface
37:47 - and the generic I queryable interface
37:50 - inherits from both the I enumerable
37:52 - interface and the generic I enumerable
37:55 - interface
37:57 - a suite of extension methods and query
37:59 - syntax are made available to c-sharp
38:01 - developers which provide flexibility
38:03 - when constructing powerful readable
38:05 - queries against data encapsulated with
38:08 - an appropriate c-sharp collections
38:11 - this video is a basic introduction to
38:13 - leveraging link in the c-sharp language
38:16 - and the next tutorial we'll delve deeper
38:18 - into the subject matter
38:21 - [Music]
38:29 - hi and welcome to the second part of a
38:32 - video series on link this video is also
38:35 - the second part of the seventh tutorial
38:37 - in an advanced c-sharp course
38:39 - link stands for language integrated
38:42 - query in the first part of this video
38:44 - series we looked at an overview of Link
38:48 - we discussed that link is the name for a
38:50 - set of Technologies based on the
38:53 - integration of query capabilities
38:54 - directly into the c-sharp language
39:04 - in this video we'll demonstrate examples
39:09 - where we'll create link queries using
39:11 - methods syntax and subsequently show how
39:14 - we can express the same link query using
39:16 - query syntax as discussed in the
39:19 - previous video in this series query
39:21 - syntax is recommended because the logic
39:24 - within the query syntax is easier to
39:26 - read
39:27 - in this video we'll look at code
39:29 - examples using the following link
39:31 - operators select where join and group
39:35 - join we'll discuss what is meant by
39:37 - Method chaining and demonstrate an
39:39 - example that makes use of method
39:42 - chaining in the context of a link query
39:44 - we'll look at what is meant by deferred
39:46 - execution of Link queries and what is
39:49 - meant by immediate execution of Link
39:51 - queries we'll discuss the inherent
39:53 - advantages of deferred execution in the
39:56 - context of Link
39:58 - to further clarify our understanding of
40:00 - deferred execution we'll create a code
40:02 - example where we'll Implement deferred
40:05 - execution for our own custom extension
40:07 - method for an I enumerable type
40:11 - we'll demonstrate how the c-sharp yield
40:13 - keyword is implemented in the relevant
40:15 - code example as part of code to
40:19 - implement deferred execution
40:22 - at the end of the tutorial we'll look at
40:25 - the join operator and the group join
40:27 - operator
40:29 - we'll create code examples to help
40:30 - clarify our understanding of these two
40:33 - link operators
40:35 - in the first part of this video series
40:36 - we discussed that extension methods and
40:39 - Lambda expressions are fundamental to
40:41 - how Link Works
40:43 - we created our own extension method for
40:45 - filtering a generic list that can be
40:48 - strongly typed with any c-sharp type
40:50 - including user-defined types
40:53 - we then demonstrated how a Lambda
40:55 - expression can be created and calling
40:57 - client code which enables the calling
40:59 - client code to determine how the
41:01 - relevant list of data must be filtered
41:05 - the reason we created our own filter
41:07 - extension method was to help us
41:09 - understand the fundamentals of Link Link
41:11 - functionality is encapsulated in two
41:14 - static classes that are members of the
41:16 - system.link namespace these two static
41:19 - classes are named queryable and
41:21 - enumerable
41:23 - these classes mostly contain extension
41:26 - methods
41:32 - as with the previous video in the series
41:34 - I'm going to demonstrate the code
41:36 - examples in this video on my Mac
41:38 - platform if you are using a Windows
41:40 - platform the fact that I'm using visual
41:42 - studio for Mac should not be a barrier
41:44 - to follow along with these code examples
41:47 - the code creation process is almost
41:49 - exactly the same experience when
41:51 - compared to implementing the same code
41:53 - using visual Studio for Windows
41:56 - so let's create a net core console
41:59 - project
42:10 - let's name this project link examples
42:12 - underscore one
42:19 - so to save time let's copy data related
42:22 - code that we created in the previous
42:24 - video of this series from the
42:26 - appropriate GitHub repository
42:29 - so please navigate to this URL in your
42:31 - browser to access the relevant GitHub
42:33 - repository
42:35 - as always all urls referred to in these
42:38 - videos can be accessed through
42:40 - appropriate links included Below in the
42:42 - description
42:44 - so let's copy the data related
42:46 - functionality from this repository to
42:48 - the project we have just created
42:50 - so in your browser window click the
42:53 - directory icon labeled TCP data like
42:56 - this
42:57 - click the class icon labeled employee
43:01 - let's copy the code for the employee
43:03 - class from this page to our clipboards
43:06 - like this
43:14 - and simply paste the contents of the
43:17 - clipboard below the program class in our
43:19 - new project
43:21 - let's also copy the code for the
43:23 - Department class like this to our
43:25 - clipboards
43:31 - and paste the contents of our clipboards
43:33 - below the employee class within our new
43:35 - project
43:37 - let's then copy the code in the data
43:39 - class to our clipboards
43:41 - foreign
43:51 - then paste the contents of our
43:54 - clipboards below the department class in
43:56 - our new project like this
43:58 - so we have some red squiggly lines
44:00 - within our data class
44:02 - to fix this let's include a directive to
44:04 - the
44:05 - system.collections.generic namespace at
44:08 - the top of our code like this
44:10 - we are just creating throwaway code in
44:12 - this video to help us understand the
44:14 - relevant topics discussed in this video
44:17 - so we are not too concerned with code
44:18 - neatness in this video
44:22 - in our main method let's create a
44:24 - strongly typed generic list
44:26 - that is strongly typed with the employee
44:28 - user defined type let's name our generic
44:31 - list variable employee list
44:34 - let's assign the value returned from the
44:36 - data.get employees method to the
44:39 - variable we have just named employee
44:41 - list
44:42 - this line of code will populate the
44:44 - employee list collection with made up
44:46 - data that was hard-coded in the data
44:49 - class in the previous video of this
44:51 - series
44:53 - let's define a generic list that is
44:55 - strongly typed with our department
44:57 - user-defined type let's name our
45:00 - variable for this list Department list
45:03 - let's assign the value returned from the
45:05 - data.get Departments method to the
45:08 - variable we have just named Department
45:10 - list
45:11 - this will populate the department list
45:13 - collection with made up data that was
45:16 - hard-coded in the data class in the
45:18 - previous video of this series
45:21 - so let's create a link query that makes
45:23 - use of the select link operator
45:26 - in order to use a link operator we of
45:29 - course need to include a using directive
45:31 - to the system.link namespace
45:34 - for this query we want to select
45:36 - everything from the data stored in our
45:38 - employee list collection
45:40 - we can do this by simply invoking the
45:42 - select method on the employee list
45:44 - object like this
45:47 - the select method is an extension method
45:49 - provided to us through link
45:52 - we can shape our data through the use of
45:54 - a Lambda expression like this
45:58 - we discussed Anonymous types in the
46:01 - previous video of this video series
46:04 - so the select operator returns an i
46:07 - enumerable collection of objects the
46:10 - Lambda expression passed into the select
46:12 - extension method provides an instruction
46:15 - on how we wish to shape each item of
46:18 - data within the returned I enumerable
46:20 - collection
46:23 - this is specifically expressed through
46:25 - this Anonymous type
46:28 - Anonymous types provide a convenient way
46:31 - to encapsulate a set of read-only
46:33 - properties into a single object without
46:36 - having to explicitly Define a type first
46:40 - you can see how the use of anonymous
46:42 - types can provide the developer with
46:44 - flexibility and convenience when
46:46 - constructing queries
46:49 - so here we are providing an instruction
46:51 - that we want each item of data in The
46:54 - Returned I enumerable collection to
46:56 - contain a full name property which is a
46:58 - concatenation of the first name and the
47:00 - last name properties of the relevant
47:02 - employee record and a property
47:04 - containing the employee's annual salary
47:08 - so let's write the code to Output the
47:11 - results of this query to the console
47:12 - screen
47:30 - let's see the code in action
47:38 - great
47:40 - so if we want to filter this data we can
47:43 - do this by chaining the where extension
47:45 - method to our select operator like this
47:50 - method chaining is a common Syntax for
47:52 - invoking multiple method calls in C
47:55 - sharp
47:56 - each method returns an object allowing
47:59 - calls to be changed together in a single
48:02 - statement without requiring variables to
48:05 - store the intermediate results
48:08 - so the select operation will return an
48:10 - innumerable collection object we can
48:13 - filter this returned innumerable
48:15 - collection within the same link query by
48:17 - chaining the where extension method to
48:20 - the select extension method
48:23 - the where extension method filters the
48:25 - data stored in the inumerable object
48:27 - returned from the select method
48:30 - through a Lambda expression passed to
48:32 - the where extension method the Lambda
48:35 - expression provides instructions to the
48:37 - where extension method on how the data
48:40 - must be filtered
48:41 - once the data has been filtered through
48:44 - the wear extension method and our
48:46 - innumerable collection of results is
48:49 - assigned to our results variable
48:51 - we are then traversing our results using
48:54 - a for each Loop and displaying each item
48:56 - in the I enumerable collection to the
48:58 - console screen
48:59 - we discussed the VAR keyword which
49:01 - allows for local implicit typing within
49:04 - methods in the previous video of this
49:06 - series please view the previous video in
49:09 - this series for more details
49:11 - so here we are implementing link
49:13 - explicitly using the extension methods
49:16 - provided by link we are using the select
49:19 - operator and the where operator in a
49:21 - link query
49:22 - implemented using method syntax
49:28 - let's run the code
49:30 - great we can execute the same
49:32 - functionality using query syntax
49:41 - so let's comment out the previous code
49:43 - and include a comment to label this code
49:45 - so that we are able to refer to this
49:47 - code later if need be
49:49 - so let's first implement the link query
49:51 - using query syntax without the where
49:54 - clause
49:58 - foreign
50:20 - let's run the code
50:27 - great
50:28 - let's implement the link query
50:30 - implemented using query syntax and this
50:33 - time include the where Clause within the
50:35 - link query using query syntax
50:49 - let's run the code
50:53 - excellent
50:55 - and we get exactly the same result when
50:57 - compared to running the query that we
50:59 - implemented using method syntax
51:02 - but we have constructed our link code
51:04 - using link query syntax as opposed to
51:06 - using relevant extension methods the
51:09 - query syntax is more readable and we
51:11 - don't need to chain our extension
51:13 - methods as we did in the previous
51:15 - example where we changed the where
51:16 - extension method to the select extension
51:19 - method
51:20 - let's take a closer look at our query
51:23 - where we used method syntax versus the
51:26 - same query where we used query syntax
51:31 - note that standard query operators in
51:34 - our query syntax are converted into
51:36 - extension Methods at compile time
51:40 - so standard query operators are
51:42 - essentially the same as their
51:43 - counterpart extension methods
51:46 - Microsoft recommends using query syntax
51:49 - as opposed to directly implementing the
51:51 - relevant extension methods where
51:53 - possible
51:55 - as discussed this is due to the
51:57 - readability Advantage inherent in the
51:59 - query syntax
52:01 - there are times when you will need to
52:02 - use extension methods directly where
52:06 - equivalent query syntax is not available
52:09 - we looked at a few examples of this in
52:11 - the previous video of this series for
52:14 - example using aggregate functionality
52:16 - like for example finding the average Min
52:18 - or Max annual salary for a collection of
52:22 - employee records we would need to use
52:24 - the respective average Min or Max
52:27 - extension methods to calculate and
52:29 - return the relevant values
52:33 - the developer is able to execute link
52:35 - queries with deferred execution or
52:38 - immediate execution
52:41 - so let's first understand what is meant
52:43 - by deferred execution
52:45 - deferred execution means that the
52:47 - evaluation of an expression is delayed
52:49 - until its value is required this
52:52 - improves performance because only
52:54 - necessary executions are carried out I.E
52:57 - at the point where the relevant value is
52:59 - required
53:01 - let's use our last query example to
53:03 - illustrate this point
53:04 - so when we first assign the value
53:07 - returned by our query to our results
53:09 - variable
53:10 - the query is not executed
53:13 - it is only when we Traverse the items in
53:15 - our results variable that the actual
53:18 - execution takes place I.E with each
53:20 - iteration of the for each Loop an
53:22 - execution is performed whereby the
53:25 - relevant item is evaluated and returned
53:27 - from the collection
53:30 - another advantage of deferred execution
53:32 - is that an update to the relevant data
53:35 - collection will immediately be reflected
53:37 - in the results
53:42 - so for example let's add a record to our
53:45 - employee collection
53:48 - note the salary for this new employee is
53:51 - above 50 000 so this employee should
53:53 - appear within our results
53:59 - let's run the code
54:10 - and you can see that this is proof that
54:12 - the results are evaluated within the for
54:14 - each Loop
54:16 - and the query itself is not executed at
54:19 - the line of code where the relevant
54:21 - query is located
54:23 - the execution of the query is deferred
54:25 - until the results are traversed within
54:27 - the relevant for each Loop
54:30 - to further understand the concept of
54:32 - deferred execution let's create a code
54:34 - example where we'll Implement deferred
54:37 - execution for our own custom extension
54:40 - method for an innumerable type that is
54:42 - strongly typed as the employee
54:44 - user-defined type
54:58 - let's create a static class named
55:00 - innumerable collection extension methods
55:04 - let's create a static method within the
55:06 - static class that we have just created
55:07 - and let's name this method get high
55:10 - salaried employees
55:13 - we discussed extension methods in the
55:15 - previous video for this video series
55:17 - for more information on extension
55:19 - methods please access a link to this
55:21 - video as discussed a link to this video
55:24 - is available Below in the description
55:27 - so let's implement the code for the get
55:28 - high salaried employees extension method
55:31 - like this
55:51 - note the use of the yield keyword
55:53 - you can use a yield return statement to
55:56 - return each element one at a time
55:59 - the sequence returned from an iterator
56:02 - method can be consumed by using a for
56:05 - each statement or link query
56:08 - each iteration of the for each Loop
56:10 - calls the iterator method when a yield
56:13 - return statement is reached in the
56:16 - iterator method
56:17 - the relevant value in the eye
56:19 - innumerable collection is returned and
56:22 - the current location in code is retained
56:25 - execution is restarted from that
56:28 - location the next time that the iterator
56:31 - function is called
56:35 - let's go to our main method
56:37 - and Implement a query that calls our
56:39 - extension method on the employee list
56:42 - collection
56:55 - let's copy and paste the code that we
56:57 - have already written to Traverse the
56:59 - results and output the relevant data
57:09 - and let's add another employee record to
57:12 - the employee list collection as we did
57:14 - before
57:34 - foreign
57:45 - and you can see that the new employee
57:47 - record is reflected in the results the
57:49 - results are kept up to date due to
57:51 - deferred execution
57:57 - note that deferred execution
57:59 - re-evaluates on each execution which is
58:02 - known as lazy evaluation
58:05 - the converse of deferred execution is
58:08 - immediate execution immediate execution
58:11 - means the relevant query is executed
58:14 - immediately
58:15 - to execute a query immediately we need
58:18 - to apply an appropriate two conversion
58:21 - method to the query
58:23 - so let's copy the previous code example
58:30 - let's uncomment the relevant code let's
58:33 - change this code so that the query
58:35 - executes immediately
58:37 - we can use the two list conversion
58:39 - method for this purpose
58:41 - we are using query syntax here so in
58:43 - order for us to use the toolless
58:45 - conversion method we first need to wrap
58:48 - the relevant query in Brackets add a DOT
58:51 - and then the to list conversion method
58:56 - we are explicitly typecasting the I
58:58 - enumerable value returned from the query
59:01 - to the list type through the
59:03 - implementation of the two list
59:05 - conversion method we are also executing
59:08 - the query immediately
59:11 - let's uncomment the rest of the relevant
59:13 - code for this example
59:18 - and let's run the code
59:24 - you can see that the execution of our
59:26 - query is immediate because this time
59:28 - after we've added a new employee the
59:31 - query has not been evaluated again to
59:34 - include the new employee record and the
59:36 - results this is of course why the new
59:38 - employee does not appear within the
59:39 - results output to the screen
59:42 - this proves that our query has executed
59:44 - immediately at the line of code where
59:46 - the query is located
59:49 - and remember that query syntax does not
59:52 - support two operators so we need to wrap
59:54 - our query in Brackets as we have done
59:56 - here and call whichever two method is
60:00 - appropriate for example to list two
60:03 - array or two dictionary
60:05 - by calling the relevant to method in
60:08 - this case the two list method we are
60:10 - causing our query to execute immediately
60:12 - without the two conversion method the
60:15 - relevant query execution would be
60:17 - deferred until the relevant results are
60:20 - iterated
60:22 - so let's move on to the join operator
60:25 - and then we'll look at the group join
60:27 - operator and highlight the difference
60:29 - between these two join operations
60:32 - in the previous video in this series we
60:35 - looked at the join operator and
60:36 - discussed how we can perform an inner
60:39 - join on two inumerable collections using
60:42 - a link query
60:43 - so here we have two collections that we
60:46 - wish to join in this specific use case
60:49 - we need to include a descriptive
60:51 - Department name in our results displayed
60:53 - to the user we only have a department ID
60:57 - field in our employee type so in order
60:59 - to merge the properties from our
61:01 - employee type with the relevant property
61:04 - from our department type we need to join
61:07 - records of type Department that reside
61:09 - within our department list collection
61:11 - with records of type employee that
61:14 - reside within our employee list
61:15 - collection we can do this by matching
61:18 - the ID field in the department records
61:21 - that reside in the department list
61:22 - collection with the Department ID
61:24 - property of employee records that reside
61:26 - in the employee list collection
61:29 - we can do this through link by using the
61:32 - join operator
61:33 - later we'll demonstrate a join operation
61:36 - but using the group join operator we'll
61:39 - also discuss the differences between the
61:41 - join operator and the group join
61:43 - operator
61:45 - let's look at the relationship between a
61:47 - collection of Department Records with
61:49 - the collection of employee Records
61:51 - Department Records have a one-to-many
61:54 - relationship with employee records
61:58 - a specific Department can have many
62:00 - employees as members
62:03 - a specific employee cannot belong to
62:05 - more than one department at a point in
62:07 - time
62:09 - data collections can also have
62:11 - one-to-one relationships with one
62:12 - another or many too many relationships
62:15 - with one another so in this example we
62:17 - are going to look at how we can use Link
62:19 - to implement a join operation between
62:22 - two collections of records that have a
62:24 - one-to-many relationship with one
62:26 - another I.E one Department to many
62:28 - employees
62:30 - so let's Implement a query that joins
62:32 - the department list collection with the
62:35 - employee list collection where the ID
62:37 - property of the relevant objects of type
62:39 - Department match the department ID
62:41 - property of the relevant objects of type
62:44 - employee
62:45 - so the Syntax for this link query would
62:48 - look like this when we implement the
62:50 - join operation using method syntax
62:53 - so to join Department Records to
62:55 - appropriate employee records we can use
62:58 - the join extension method and invoke the
63:00 - extension method on the department list
63:03 - collection
63:04 - the first argument we need to pass into
63:06 - the join method is the collection on
63:08 - which we want to join the department
63:10 - list collection
63:11 - so we pass in the employee collection
63:15 - object here
63:16 - the second argument is the key from the
63:19 - outer collection the department list
63:21 - collection so the outer join key is the
63:24 - ID property that resides in the
63:26 - department type we can express this
63:28 - argument as a Lambda expression like
63:30 - this
63:31 - the third argument is the inner join key
63:34 - which is the department ID property
63:36 - which is a member of the employee type
63:39 - we can express this argument as a Lambda
63:41 - expression like this so we are joining
63:43 - on the ID property which is a member of
63:45 - the department type with the Department
63:47 - ID property which is a member of the
63:50 - employee type
63:53 - we can define an anonymous type where we
63:56 - are able to shape the data for each item
63:58 - in an i enumerable collection that we
64:01 - want returned from the relevant query
64:04 - here we are defining an anonymous type
64:06 - within our link query that includes the
64:08 - employee full name which is a
64:10 - concatenation of the employee's first
64:11 - name and last name the employee's annual
64:14 - salary as well as the relevant
64:16 - Department objects long name property
64:19 - the long name property will give us a
64:21 - descriptive Department name in our
64:23 - results
64:25 - we are including the department types
64:27 - long name property and the relevant
64:28 - Anonymous type this is the whole point
64:30 - of joining the department list
64:31 - collection with the employee collection
64:34 - so that we are able to include a
64:36 - descriptive Department name within our
64:37 - results we only have the department ID
64:40 - as a member of our employee type so if
64:42 - we only return to results from the
64:45 - employee list and wanted to include
64:47 - Department information we would be
64:49 - restricted to the department ID property
64:51 - which is an integer value and is
64:54 - unlikely to be meaningful to a user
65:01 - foreign
65:02 - thank you
65:03 - let's run the code
65:10 - great
65:12 - but as discussed where it is possible to
65:14 - use Query syntax rather than method
65:17 - Syntax for our link queries
65:19 - we should use Query syntax because the
65:21 - logic expressed and the relevant query
65:23 - is far easier to read
65:26 - so let's write the same query using
65:28 - query syntax
65:59 - okay
66:14 - foreign
66:22 - as you can see it is far easier to read
66:25 - and it is also similar to query
66:27 - languages with which we may already be
66:29 - familiar for example transact SQL let's
66:33 - Express what a similar query and
66:35 - transact SQL might look like
66:37 - so let's imagine that we have a table in
66:40 - a SQL Server database that could map to
66:42 - our employee type
66:44 - let's say this table has the same name
66:46 - as our employee type let's also imagine
66:49 - that we have a table in the same SQL
66:51 - Server database that contains a table
66:53 - schema that could map to our department
66:56 - type
66:57 - let's say this table has the same name
67:00 - as our department type
67:02 - so the transact SQL would look something
67:04 - like this
67:07 - you can see how the from Clause the join
67:09 - clause and the select Clause are
67:11 - implemented in both the link query
67:13 - syntax and the transact SQL syntax
67:16 - even though the link query contains the
67:19 - same Clauses in a different order to the
67:21 - comparative Clauses in the transact SQL
67:24 - query for someone who is familiar with
67:26 - transact SQL and not necessarily
67:28 - familiar with link query syntax this
67:31 - link query syntax at a glance should be
67:33 - fairly easy to understand
67:36 - so the point here is that link query
67:39 - syntax is similar to query syntax with
67:42 - which many of us will already be
67:44 - familiar so this makes the
67:46 - implementation of Link queries using
67:47 - query syntax more intuitive
67:51 - as discussed the link query syntax is
67:53 - also more readable than the equivalent
67:55 - link query implemented using method
67:57 - syntax so the key takeaway here is to
68:01 - use Link query syntax rather than method
68:03 - syntax where possible because it is more
68:06 - intuitive to implement and easier to
68:08 - read
68:09 - let's run the code
68:16 - great
68:19 - so let's look at the group join link
68:21 - operator and while we might want to use
68:23 - the group join operator in our link
68:25 - queries
68:27 - we have just performed an inner join
68:29 - using the join operator this query will
68:33 - only return those records based on the
68:35 - ID property of relevant objects of the
68:38 - department type in the department list
68:40 - collection matching with the Department
68:42 - ID property of relevant objects of the
68:45 - employee type in the employee list
68:46 - collection diagrammatically an inner
68:49 - join query can be represented like this
68:53 - what if we wanted to return through a
68:55 - link query all the Department Records in
68:57 - our department list collection and only
68:59 - employee records where the department ID
69:01 - property of employee objects and the
69:04 - employee list collection match the ID
69:06 - property of Department Records in the
69:08 - department list collection so if we were
69:11 - to write to the transact SQL version of
69:13 - this query it would look something like
69:15 - this
69:16 - we would use a left outer join to
69:18 - achieve the desired result
69:21 - this query would bring back all
69:23 - Department Records but only those
69:25 - employee records where the relevant
69:27 - employee records department ID values
69:29 - match the ID property of the relevant
69:32 - Department Records
69:34 - so diagrammatically we can represent a
69:37 - left outer join query like this
69:40 - so let's look at the diagram
69:42 - representing an inner join operation and
69:44 - compare the diagram to the diagram
69:46 - representing the left outer join
69:48 - operation
69:50 - so let's use our group join operator in
69:52 - a link query to return all Department
69:54 - Records from the Department list
69:56 - collection but only the employee records
69:59 - from the employee list collection with a
70:01 - department ID property that matches an
70:04 - ID property of a department record in
70:06 - the department list collection
70:08 - so here we are implementing our query
70:10 - using method syntax
70:13 - you can see the implementation of the
70:15 - group join operation using method syntax
70:18 - is very similar to The Way We
70:20 - implemented the join operation in the
70:22 - previous example
70:52 - let's run the code
70:54 - note the way we have structured our
70:56 - output is clearly different when
70:58 - outputting the results of our group join
71:00 - query when compared to the way we
71:02 - structured our output of the results of
71:06 - our join query but note that at the
71:08 - moment the same join between Department
71:10 - Records and employee records has
71:12 - occurred
71:13 - the reason for this is not because the
71:16 - group joined and the join operators
71:18 - perform the same type of join operation
71:20 - it is because currently each of the
71:22 - records in the employee list collection
71:25 - match with a department record in our
71:27 - department list collection
71:29 - let's change our data to highlight a key
71:32 - difference in the join operation and the
71:34 - group join operation
71:36 - let's do this by going to the code where
71:39 - we have hard-coded made up employee and
71:41 - Department Records and added these
71:43 - records to their respective collections
71:46 - let's ensure that the technology
71:48 - department which has an ID of three does
71:51 - not match with a department ID property
71:53 - of any of the employee objects in our
71:55 - employee list collection
71:57 - we only currently have one employee that
72:00 - is in the technology department
72:01 - according to our data let's change the
72:04 - relevant Department ID so that there are
72:06 - no employees that are members of the
72:09 - technology department so let's change
72:11 - this department ID property now no
72:14 - employees are members of the technology
72:16 - department according to our data
72:31 - let's run the code
72:37 - so you can see our technology department
72:40 - record is being returned along with all
72:43 - the other department records in the
72:45 - department list collection even though
72:47 - its ID property doesn't match the
72:50 - department ID property of any employee
72:52 - records stored in the employee list
72:54 - collection
72:56 - so simply put Department information for
72:59 - departments that contain employees are
73:02 - included in the query results and
73:04 - departments that don't contain any
73:07 - employees are also included in the query
73:09 - results
73:10 - in this example the technology
73:12 - department has returned even though it
73:14 - contains no matching employee records
73:17 - so here we have performed a left outer
73:19 - join query using links group join
73:22 - operator
73:24 - so let's rewrite this link query using
73:26 - query syntax
74:03 - you can see here that the group join
74:06 - extension method does not get explicitly
74:09 - called when we Implement our query using
74:12 - query syntax the into keyword is used
74:15 - within the query to create a group of
74:17 - employees for each department
74:20 - so as discussed link query syntax does
74:24 - not match exactly when comparing link
74:27 - query syntax to familiar query languages
74:29 - like transact SQL but in many ways it
74:33 - does resemble a language like transact
74:35 - SQL in this sense link query syntax is
74:38 - more intuitive to implement than method
74:40 - syntax when implementing link queries
74:44 - and just to labor the point as discussed
74:46 - it is also better to implement link
74:48 - query Syntax for our link queries then
74:51 - implementing method Syntax for the same
74:54 - purpose because of better readability
74:58 - let's run the code
75:02 - great and we get the exact same result
75:05 - as when we ran the same query that was
75:09 - implemented using method syntax
75:11 - now that we have changed the data so
75:14 - that the technology department does not
75:16 - match with any employee records let's
75:18 - run our join operation that we created
75:21 - earlier
75:34 - notice that the results of the join
75:36 - operation doesn't include the technology
75:38 - department this is because the join
75:41 - operation performs an inner join and
75:43 - with the group join operation we are
75:45 - able to perform a left outer join
75:47 - operation
75:48 - so let's comment out our join query and
75:51 - uncomment our group join query
76:00 - and for good measure let's run the code
76:02 - again
76:06 - and as you can see the technology
76:08 - department is now included in the
76:10 - results displayed to the screen even
76:13 - though the technology department does
76:15 - not have any matching employee records
76:17 - great
76:19 - so the left outer join operation returns
76:22 - all records from the outer left
76:24 - collection in the query but does not
76:26 - return records from the inner collection
76:29 - where the inner collection records do
76:31 - not match any of the outer collection
76:34 - records
76:35 - so if there were employee records in the
76:38 - employee list collection that did not
76:40 - match any of the Department Records in
76:42 - the department list collection these
76:44 - employees would not appear in the
76:46 - results outputted to the screen we can
76:48 - prove this let's change the department
76:50 - ID of this employee record where the
76:53 - first name property is Bob and the last
76:54 - name properties Jones
76:59 - we have changed the department ID
77:00 - property for this record to six and
77:03 - there's no matching Department record
77:07 - I.E no Department record has an ID of
77:10 - six let's run the code
77:20 - and you can see that the employee record
77:22 - with first name Bob and last name Jones
77:25 - does not appear within the results
77:28 - however even though the human resources
77:30 - department has no matching employee
77:32 - records it is still included in the
77:35 - results output to the screen great let's
77:38 - add Bob Jones back into the human
77:40 - resources department like this and let's
77:42 - run the code
77:47 - excellent
77:49 - so hopefully this made it clear how we
77:52 - are able through link to use the join
77:54 - operator to perform inner join queries
77:56 - between two object Collections and how
77:59 - we are also able to perform left outer
78:01 - join queries using the group join
78:03 - operator
78:07 - [Music]
78:09 - foreign
78:11 - [Music]
78:18 - to the third part of a video series on
78:21 - the link technology using c-sharp this
78:24 - video is also part of the seventh
78:26 - tutorial in an advanced c-sharp course
78:28 - link was introduced with c-sharp version
78:31 - 3 which was released on the 19th of
78:34 - November 2007.
78:36 - link stands for language integrated
78:39 - query
78:46 - in this video we are going to focus on
78:48 - code examples that make use of several
78:51 - link operators
78:53 - the code examples demonstrated in this
78:55 - video will hopefully help us gain an
78:57 - understanding of a broad array of
79:00 - operators that are made available to us
79:02 - through link
79:03 - we'll learn how we can use these
79:05 - operators to query and transform data
79:08 - this quote from the Microsoft docs
79:10 - provides a basic definition of standard
79:13 - query operators and can be found at this
79:15 - URL
79:17 - the standard query operators are the
79:20 - methods that form the link pattern most
79:23 - of these methods operate on sequences
79:25 - whereas sequence is an object whose type
79:28 - implements the generic I.E numerable
79:31 - interface or the generic I queryable
79:34 - interface
79:36 - a lot of the more frequently used query
79:38 - operators have dedicated c-sharp keyword
79:42 - syntax that enables them to be called as
79:45 - part of a query expression as discussed
79:48 - in the previous video in this video
79:49 - series it is advantageous to use Query
79:52 - syntax rather than method syntax where
79:55 - possible because query syntax is more
79:57 - readable note that query expression
79:59 - Clauses are translated into calls to
80:02 - query Methods at compile time
80:05 - for a useful tabular representation of
80:07 - standard query operators that have
80:09 - equivalent query expression Clauses
80:11 - please navigate to this URL we discussed
80:15 - what is meant by deferred execution and
80:17 - immediate execution in the previous part
80:19 - of this video series
80:21 - for a useful tabular classification of
80:23 - operators in terms of deferred execution
80:26 - or immediate execution please navigate
80:28 - to this URL
80:31 - for additional information on deferred
80:33 - execution versus immediate execution and
80:36 - Method syntax versus query syntax please
80:39 - View the second part of this video
80:41 - series
80:42 - so to gain an understanding of several
80:44 - useful link operators let's create a few
80:47 - code examples
80:49 - as with the previous video in this
80:51 - series I'll be demonstrating these code
80:54 - examples on my Mac platform using visual
80:57 - studio for Mac
80:58 - the code creation process for these code
81:00 - examples is almost exactly the same
81:03 - process as creating the equivalent code
81:05 - examples on a Windows platform using
81:08 - visual Studio for Windows
81:10 - the fact that I'm using visual studio
81:12 - for Mac should not be a barrier for a
81:14 - learner to follow along with the
81:15 - creation of these code examples
81:19 - start by creating a.net core console
81:21 - project
81:22 - we created a project in the previous
81:24 - video named link examples underscore one
81:27 - let's name this project link examples
81:29 - underscore 2.
81:31 - in order to save time let's copy data
81:33 - related classes that have already been
81:35 - created in the previous videos of this
81:37 - series and incorporate these classes
81:39 - into our new project these classes
81:42 - contain class definitions for an
81:44 - employee and a department record as well
81:47 - as code that adds several made up
81:48 - objects of type employee and Department
81:51 - to their respective collections
81:53 - as in the previous parts of this video
81:55 - series we can then use these collections
81:58 - of strongly typed objects in our link
82:00 - query examples
82:02 - so to copy the relevant code let's
82:05 - navigate to this URL I.E to a GitHub
82:08 - repository that was created in the
82:10 - previous video
82:11 - let's click on the directory icon
82:13 - labeled link examples underscore one
82:16 - then let's click on the file icon
82:18 - labeled program.cs
82:21 - let's copy the employee class to our
82:23 - clipboards
82:34 - and paste the contents of our clipboards
82:36 - within the new project that we have just
82:39 - created
82:41 - let's copy the department class to our
82:43 - clipboards and paste the contents of our
82:46 - clipboards below the employee class
82:48 - within our new project
82:50 - lastly let's copy the data class to our
82:53 - clipboards
82:57 - and paste the contents of our clipboards
82:59 - below the department class within our
83:01 - project
83:02 - so in the previous video we looked at
83:05 - the following operators
83:06 - the select projection operator the where
83:09 - filter operator the join and group join
83:12 - join operators in this video we'll
83:15 - create code examples that implement the
83:17 - following operators
83:19 - we'll start by looking at the following
83:21 - sorting operators order by order by
83:24 - descending then by and then by
83:26 - descending
83:27 - we'll then look at these grouping
83:29 - operators Group by and to lookup
83:32 - we'll then look at these quantifier
83:34 - operators or any and contains
83:38 - we'll then look at the following
83:40 - filtering operator of type
83:43 - note that another example of a filtering
83:45 - operator is the where operator we have
83:48 - looked at the where filter operator in
83:50 - the previous parts of this video series
83:53 - lastly we'll look at the following
83:55 - element operators element at element at
83:58 - or default first first or default last
84:02 - last or default single and single or
84:05 - default
84:06 - we'll look at even more link operators
84:08 - and create code examples in the next
84:10 - video
84:13 - the next video will be the final video
84:15 - in this video series on link
84:18 - right let's get started so let's start
84:20 - by looking at the data related classes
84:22 - that we copied from GitHub we have the
84:25 - employee class which provides a
84:27 - definition for an employee record we
84:29 - have the department class which provides
84:31 - a definition for a department record
84:34 - we have the data class that contains
84:36 - code where lists of hard-coded made up
84:39 - employee and Department objects are
84:41 - added to their respective collections
84:43 - within their respective methods and
84:44 - returned from their respective methods
84:47 - in the previous video in this series we
84:49 - looked at join operators namely the join
84:52 - operator and the group join operator
84:54 - so in the context of join operations the
84:58 - department collection has a one-to-many
85:00 - relationship with the employee records
85:02 - in the employee collection
85:05 - this simply means that one or many
85:07 - employees can be members of a specific
85:09 - Department a specific employee can be a
85:12 - member of only one department at a point
85:15 - in time
85:16 - so let's go to our main method
85:19 - we can use the data dot get employees
85:22 - method to return a collection of made up
85:24 - employee records
85:27 - let's use this method to assign the
85:29 - relevant collection of employee records
85:32 - to a local variable named employee list
85:35 - the employee list variable is defined as
85:38 - a generic list that is strongly typed as
85:41 - employee
85:43 - so here we have red squiggly lines
85:44 - because we need to include a using
85:46 - directive to the
85:48 - system.collections.generic namespace
85:50 - let's use the data dot get departments
85:53 - method to return a collection of made up
85:56 - Department Records that have a
85:58 - one-to-many relationship with the
86:00 - relevant collection of employee records
86:02 - and let's assign the relevant returned
86:04 - collection of Department Records to a
86:07 - variable named Department list
86:09 - the department list variable is defined
86:12 - as a generic list that is strongly typed
86:14 - as Department
86:16 - so let's get into the creation of our
86:19 - examples
86:21 - sorting operators order by
86:25 - so let's create an example for the order
86:28 - by operator in this example we want to
86:30 - return all employee records from the
86:33 - employee list collection and order by
86:35 - Department ID
86:37 - to make things a little bit more
86:39 - interesting let's say we want to include
86:41 - the department name within our outputted
86:43 - results
86:44 - the problem here is that the department
86:46 - name does not exist in the employee type
86:49 - so we need to join the employee list
86:51 - collection to the department list
86:53 - collection so that we can include the
86:56 - department name in our results
86:58 - we can do this by using the join
87:00 - operator
87:02 - so let's write this query using method
87:04 - syntax so that we can see all the link
87:07 - extension methods used in the relevant
87:10 - query
87:11 - so we first need to make sure that we
87:14 - include a using directive to the
87:16 - system.link namespace this director will
87:19 - give us access to the relevant link
87:21 - operators that we will be implementing
87:23 - in our code examples
87:25 - we know that the system.link namespace
87:27 - contains two static classes namely
87:30 - innumerable and queryable and these
87:33 - static classes mostly contain extension
87:35 - methods our link operators which are
87:38 - implemented in the form of extension
87:39 - methods are implemented within the
87:42 - enumerable and queryable static classes
87:45 - so this link query joins the employee
87:48 - list collection to the department list
87:50 - collection on the department ID property
87:53 - of each of the relevant employee records
87:55 - with the ID property of relevant
87:57 - Department Records
88:21 - foreign
88:57 - before we run this query let's alter the
89:00 - data a bit let's make the employee
89:02 - record pertaining to Sarah Jameson a
89:04 - member of the technology department by
89:06 - changing the relevance Department ID
89:08 - property from two to three let's also
89:11 - change the department for the employee
89:14 - record pertaining to Jane Stevens to the
89:16 - technology department by changing the
89:18 - relevance Department ID from 2 to 3.
89:21 - this change to the data will make the
89:24 - effects of our sorting operators more
89:26 - apparent when we view our results
89:29 - so if we run the query first without the
89:32 - use of any order by operators note that
89:35 - the data appears to us in the same order
89:38 - as it was added to the employee list
89:42 - but now let's say there is a requirement
89:44 - to order our results by the department
89:46 - ID property in ascending order
89:49 - we can do this by chaining the order by
89:52 - extension method to the end of the query
89:54 - like this
89:55 - for more information on method chaining
89:58 - please view the previous video in this
90:00 - series
90:01 - so we can pass in a Lambda expression to
90:04 - the order by extension method to
90:05 - indicate that we wish to order the
90:07 - results by the department ID property
90:12 - let's run the code
90:14 - and you can see that the results are now
90:17 - ordered in ascending order by Department
90:19 - ID
90:20 - if we look at the code that added each
90:22 - department to the department collection
90:24 - we can see that the human resources
90:27 - department has an ID of one the finance
90:29 - department has an ID of two and the
90:31 - technology department has an ID of three
90:35 - our results have been ordered in
90:36 - ascending order based on the department
90:38 - ID property of the employee record
90:43 - so we can clearly see the effects of the
90:46 - order by operator on our results great
90:49 - if the requirement changed such that we
90:52 - needed to order our results by the
90:54 - department ID property in descending
90:56 - order we can chain the order by
90:58 - descending extension method instead of
91:00 - the order by extension method for this
91:02 - purpose
91:03 - our results are now ordered by
91:05 - Department ID in the reverse order when
91:07 - compared to the previous output great
91:12 - so let's say that we want to order our
91:14 - results by the department ID property in
91:17 - ascending order and then by the annual
91:19 - salary property also in ascending order
91:22 - so let's replace the order by descending
91:25 - extension method with the order by
91:27 - extension method in our results like
91:29 - this then let's chain the then buy
91:31 - extension method to the query like this
91:34 - we can then pass a Lambda expression to
91:37 - indicate that we wish to further order
91:39 - our results by the annual salary
91:42 - property the then by extension method
91:44 - will order the results produced by the
91:46 - order by sorting operator in ascending
91:49 - order
91:56 - great
91:58 - and if we want to order by the annual
92:01 - salary property in descending order we
92:03 - can replace the then buy extension
92:05 - method with the then by descending
92:07 - extension method for this purpose
92:21 - excellent
92:34 - we can represent sorting operations
92:37 - within link queries that are represented
92:39 - using query syntax like this
93:00 - note the order by and descending
93:03 - keywords in the query syntax version of
93:06 - the relevant query
93:08 - we use the order by keyword within our
93:11 - query to order by our first specified
93:13 - property
93:15 - if we want to subsequently sort on other
93:18 - properties instead of chaining the then
93:20 - by extension method to our query and
93:22 - query syntax subsequent Properties by
93:25 - which we wish to sort are separated by
93:27 - commas
93:28 - the descending keyword can follow any of
93:31 - the properties that we wish to sort in
93:34 - descending order
93:35 - the default order is ascending order
93:53 - thank you
94:34 - so let's look at the group by and to
94:37 - lookup grouping operators
94:39 - let's start with the group by operator
94:42 - so this operator is akin to the group by
94:45 - Clause we would apply in a transact SQL
94:48 - query
94:49 - so we can implement the group by
94:51 - operator using the group by extension
94:53 - method or the group and the buy keywords
94:56 - within query syntax to perform the same
94:59 - operation
95:00 - so let's say we wish to query the
95:03 - employee list collection
95:05 - and group our results by the department
95:07 - ID property
95:09 - the query using query syntax would look
95:11 - like this
95:13 - this query is simply grouping our
95:15 - results by the department ID property
95:23 - using method syntax this query would
95:25 - look like this
95:41 - in all of the link query examples using
95:44 - query syntax that we have looked at up
95:46 - till this point in this video series we
95:49 - have ended all our queries with a select
95:52 - operator
95:54 - notice that this query does not end with
95:57 - a select operator
95:58 - it is important to note that a link
96:00 - query implemented in query syntax must
96:03 - either end with a select operator or a
96:06 - grouping operator
96:08 - notice how this query does not end with
96:11 - a select operator but a grouping
96:13 - operation is being performed at the end
96:15 - of this query
96:17 - so we can Traverse the results of this
96:20 - grouping operation using nested for each
96:23 - Loops the outer loop traverses each
96:26 - group that has been created based on the
96:29 - department ID property the inner loop
96:32 - traverses the item members within each
96:34 - of the groups that have been created in
96:37 - our query based on the department ID
96:39 - property
96:44 - great
96:48 - we could also include the order by
96:50 - operator within our query like this
96:59 - let's run the code
97:04 - great
97:05 - we can implement the same query using
97:08 - methods syntax using the to lookup
97:10 - extension method like this
97:27 - great
97:28 - we can also include sorting
97:30 - functionality through the order by
97:32 - operator through the implementation of
97:35 - method chaining like this
97:56 - great
97:57 - note that the two lookup method performs
98:00 - the same operation as the group by
98:02 - operator the only difference is the
98:05 - execution of the group by operation is
98:07 - deferred whereas the execution of the
98:10 - two lookup operation is executed
98:12 - immediately
98:14 - we discussed deferred execution and
98:16 - immediate execution in the previous part
98:18 - of this video series for more
98:21 - information on deferred execution and
98:23 - immediate execution please View the
98:25 - second part of this video series the
98:27 - link to this video has been included
98:29 - Below in the description
98:30 - note that the results returned from a
98:33 - group by operation and a two lookup
98:35 - operation return a group contained in a
98:39 - special type of collection that
98:41 - implements an eye grouping generic
98:44 - interface
98:58 - so let's look at the all any and
99:01 - contains quantifier operators let's
99:04 - first look at the all and any operators
99:09 - let's create a variable named annual
99:11 - salary compare and assign it with a
99:13 - value of twenty thousand
99:16 - let's Implement a block of code related
99:18 - to the all operator
99:50 - let's Implement a similar block of code
99:53 - related to the any operator
99:56 - so the all and any operators return a
99:59 - Boolean value
100:01 - the return value will equal true if the
100:04 - elements in the relevant collection
100:06 - satisfy a condition passed to the
100:08 - relevant method this condition can be
100:10 - passed in the form of a Lambda
100:12 - expression
100:17 - this query will return true if all
100:19 - employee records
100:21 - have annual salary property values that
100:24 - are greater than twenty thousand
100:37 - this query will return true if one or
100:40 - more employee records have an annual
100:42 - salary property value that is greater
100:44 - than twenty thousand
101:05 - let's run the code
101:09 - foreign
101:15 - this is an expected result
101:18 - let's change the annual salary compare
101:20 - variable to a hundred thousand
101:33 - great
101:36 - and let's change the annual salary
101:38 - compare variable to 40 000.
101:51 - so let's move on to the contains
101:54 - operator
101:55 - so we want to be able to assess whether
101:58 - an employee record exists within our
102:00 - collection of employee records
102:03 - the contains operator will return true
102:05 - if we pass in an object that is equal in
102:08 - value to an object within the relevant
102:11 - collection
102:12 - to understand how the contains operator
102:14 - Works let's create an employee record
102:16 - that we know matches an employee record
102:19 - within the employee list collection
102:21 - let's copy this record for the employee
102:24 - named Douglas Roberts that is a member
102:26 - of the relevant employee collection
102:35 - and paste it in our main method
102:39 - let's name the variable that stores a
102:41 - reference to the employee record we wish
102:43 - to find within the employee list
102:45 - collection search employee
102:48 - so how can we assess whether the
102:50 - employee record pertaining to Douglas
102:52 - Roberts exists within the employee list
102:55 - collection
102:56 - we can use the contains extension method
103:00 - we can simply pass the variable we named
103:02 - search employee to the contains
103:04 - extension method which we have invoked
103:06 - on our employee list collection object
103:10 - so the contains method returns true if
103:13 - the search employee object matches any
103:15 - of the objects within the employee list
103:17 - collection and false if the search
103:19 - employee object does not match with any
103:22 - of the objects stored within the
103:24 - employee list collection
103:26 - so let's write code to write an
103:28 - appropriate narrative to the screen
103:29 - based on the Boolean value returned by
103:33 - our query
103:51 - let's run the code
103:58 - and this is not the result we expected
104:00 - because we literally copied and pasted
104:02 - the code representing one of the
104:04 - employee objects that has been added to
104:06 - the employee list collection from our
104:08 - data class to the main method as our
104:10 - search object so why is our output
104:12 - indicating that the search employee
104:14 - object does not match any of the objects
104:16 - stored within our employee list
104:19 - collection this result is unexpected
104:22 - the answer is that the compiler knows
104:24 - how to compare built-in C sharp types
104:26 - like for example integer or bull
104:29 - the employee type is a user-defined type
104:32 - or custom type we need to tell the
104:34 - compiler how we wish to compare two
104:36 - objects of type employee to establish
104:39 - where the two employee objects are equal
104:41 - so we can do this by creating a class
104:43 - that implements the generic I equality
104:46 - comparer interface
104:49 - the eye equality compare interface is a
104:52 - member of the
104:53 - system.collections.generic namespace
104:56 - we have already included a using
104:59 - directive to this namespace within our
105:00 - code
105:01 - so let's create a class named employee
105:03 - comparer and let's indicate that we want
105:06 - the employee comparer class to implement
105:08 - the I equality compare a generic class
105:11 - that is strongly typed with the employee
105:13 - user-defined type
105:15 - so let's hover our Mouse pointers over
105:17 - the red squiggly line and create the
105:19 - stubs for the methods that we need to
105:21 - implement like this
105:25 - so two method stubs have been generated
105:27 - one named equals and the other named get
105:30 - hash code so the get hash code method is
105:33 - used for the purpose of uniquely
105:34 - identifying an object we can implement
105:37 - the code for the get hashed code method
105:39 - by returning the hash code of the ID
105:42 - property of the relevant employee object
105:44 - like this
105:46 - the equals method must be implemented in
105:48 - a way that establishes how we wish
105:50 - employee objects to be compared when
105:53 - determining whether two employee objects
105:55 - are of equal value
105:57 - so let's say that we are satisfied with
105:59 - comparing the relevant employee objects
106:01 - based on their ID first name and last
106:04 - name properties to establish equality
106:06 - between the relevant employee objects
106:10 - so we can achieve this with the
106:12 - following code
106:13 - if the relevant properties are equal
106:15 - return true else return false
106:18 - so we are already passing in the search
106:21 - employee objects to the contains method
106:23 - let's also pass a newly instantiated
106:26 - object of type employee comparer to an
106:29 - overload version of the contains method
106:31 - like this
106:32 - and now we are telling the compiler how
106:34 - we want to compare our employees search
106:37 - object with the objects stored within
106:40 - the employee list collection
106:45 - let's run the code
106:50 - and this is an expected result the
106:53 - contains method now returns true as
106:56 - expected because our search record
106:57 - matches the employee record for Douglas
107:00 - Roberts within the collection on which
107:02 - we are performing our search great
107:06 - so now let's look at the of type filter
107:09 - operator so before we use the of type
107:11 - filter operator in our code examples
107:14 - let's create a method named get
107:16 - heterogeneous data collection
107:18 - heterogeneous in this context of course
107:21 - is referring to the storage of objects
107:23 - of multiple different data types within
107:26 - the same collection
107:28 - so we can store objects of multiple
107:30 - different data types in an arraylist
107:32 - note that Microsoft does not recommend
107:34 - using arraylists for new development it
107:37 - is far better to use strongly typed
107:39 - lists to store collections of data
107:42 - for more detail as to why strongly typed
107:45 - lists are recommended please view a
107:47 - video on generics created by this
107:49 - channel a link to this video has been
107:51 - included Below in the description
107:53 - so a use case where we could apply a
107:56 - link query on an arraylist could be
107:59 - perhaps we have a legacy piece of code
108:01 - that includes an arraylist containing
108:03 - objects of multiple types and we need to
108:06 - filter the relevant arraylist based on
108:08 - specific types
108:10 - we can achieve this using the of type
108:12 - link operator
108:14 - we'll look at how we can do this in a
108:16 - bit let's first add some made up data to
108:18 - an arraylist
108:19 - so the arraylist stores integers strings
108:22 - objects of the employee user defined
108:25 - type and objects of the department
108:27 - user-defined type
108:42 - foreign
109:03 - let's go to our main method and write
109:05 - code to use the of type operator to
109:08 - query this arraylist based on specified
109:10 - data types
109:12 - let's query for all string values in our
109:15 - arraylist
109:38 - great
109:41 - so let's query all integer values in our
109:44 - array list
109:56 - foreign
110:01 - great let's query for all objects of the
110:05 - employee user defines type
110:35 - great let's query for all objects of the
110:38 - department user defines type
111:00 - excellent
111:05 - so you can see how we can query an
111:07 - arraylist for objects of a specified
111:09 - type using generics and the of type
111:11 - Operator by passing in the relevant type
111:13 - between angle brackets like this
111:16 - this will return those objects within
111:18 - the arraylist that are of the specified
111:20 - type
111:27 - let's move on to the element operators
111:29 - let's look at the element at element at
111:32 - or default first first or default last
111:35 - last or default single and single or
111:38 - default element operators
111:40 - so let's first look at the element at
111:42 - operator
111:43 - so the element at operator is used for
111:47 - querying for an item in a collection
111:49 - that resides at a specified ordinal
111:52 - location within the relevant collection
111:54 - so we can pass an integer value
111:56 - representing the relevant element's
111:58 - location in the relevant collection into
112:00 - the element add method to return the
112:02 - desired items value from the relevant
112:05 - collection like this
112:20 - great and our query has returned the
112:22 - value for the relevant element
112:27 - foreign
112:34 - but what happens if we pass in a value
112:36 - representing a position in the relevant
112:38 - collection where an element does not
112:40 - exist so let's try this let's pass in a
112:42 - value of 8.
112:55 - right so it is important to note that no
112:58 - item exists within the relevant
113:00 - collection at ordinal position 8. so in
113:03 - this case an argument out of range
113:05 - exception is thrown
113:08 - this brings us to an important point
113:10 - about the difference between the element
113:12 - at and the element at or default method
113:16 - if we replace the element at method with
113:19 - the element at or default method and we
113:21 - query the relevant collection for an
113:23 - item at a position where the desired
113:26 - item does not exist within the relevant
113:27 - collection the element at or default
113:29 - method does not throw an exception
113:32 - but rather Returns the default value for
113:35 - the desired items relevant data type
113:39 - let's briefly discuss what we mean by
113:42 - default value for a particular data type
113:44 - the c-sharp language Associates default
113:47 - values for c-sharp data types so if for
113:50 - example we are querying a collection of
113:52 - integers using the element at or default
113:55 - method for a value that did not exist at
113:58 - the specified location in the relevant
114:00 - collection the element at or default
114:03 - method would return the default value
114:05 - for the integer data type which is a
114:07 - value of zero
114:10 - the integer value of 0 is the default
114:12 - value for the integer data type in C
114:15 - sharp if however we are querying a
114:17 - collection containing a reference type
114:19 - object like an object of our
114:22 - user-defined type employee the default
114:24 - value returned by the element at or
114:27 - default method would be null null is the
114:30 - default value for reference type data
114:32 - types like user-defined types or the
114:34 - string data type
114:36 - for more detail regarding default values
114:39 - in c-sharp please navigate to this URL
114:43 - so let's use the element at or default
114:45 - method to query the relevant collection
114:47 - of employees for a value at position 8.
114:51 - I.E where no employee object is present
114:54 - within the relevant collection we can
114:56 - then write code to check if the returned
114:58 - value is null
115:08 - and you can see that an exception is not
115:10 - thrown and no results are outputted to
115:13 - the screen which is an expected result
115:15 - because the query returned a null value
115:31 - let's pass in a value of 2
115:45 - thank you
115:57 - and then one
116:03 - and in both cases the appropriate result
116:06 - is outputted to the screen
116:07 - so let's write code to Output an
116:10 - appropriate narrative to the user based
116:12 - on the value returned from the element
116:13 - at or default method
116:19 - so let's pass in a value of 12.
116:29 - the output indicating that the return
116:31 - value is null I.E the employee object
116:34 - does not exist in the collection as
116:36 - output to the screen this is an expected
116:39 - result great
116:41 - so the first operator Returns the first
116:43 - element in a collection if no condition
116:46 - is specified we have the option of
116:49 - passing a condition to the first method
116:51 - or we can leave the brackets following
116:54 - the first method empty if we do not
116:56 - specify a condition the query will
116:58 - return the first element in the relevant
117:00 - collection if a condition is specified
117:03 - the first operator will return the first
117:06 - element in the collection that satisfies
117:08 - the specified condition we can specify a
117:12 - condition in the form of a Lambda
117:14 - expression right to prove this let's
117:16 - first create a strongly typed list of
117:18 - integer values
117:21 - foreign
117:29 - this collection using the first operator
117:32 - and don't provide a condition passed as
117:34 - an argument to the first method
117:36 - the query Returns the first item in the
117:38 - collection as expected
117:41 - so let's pass a condition in the form of
117:43 - a Lambda expression to the first
117:45 - extension method
117:46 - so this condition is simply querying the
117:48 - collection for the first even number in
117:51 - the collection
117:52 - let's run the code
117:56 - great
118:00 - but now what happens if we alter the
118:02 - collection of values so that no value
118:05 - satisfies the condition I.E no even
118:07 - numbers exist within the relevant
118:09 - collection
118:17 - an invalid operation exception is thrown
118:20 - so if we don't want an exception to be
118:22 - thrown we can replace the first operator
118:25 - with the first or default operator
118:28 - as you may have guessed
118:30 - where no items in the relevant
118:32 - collection satisfy the relevant
118:33 - condition this method will not throw an
118:35 - exception but will rather return the
118:38 - default value of the relevant data type
118:41 - we know that the default value for the
118:43 - integer dates type is zero
118:46 - let's write code to Output an
118:48 - appropriate narrative to the screen if
118:50 - the relevant condition is not satisfied
118:57 - let's run the code
119:03 - and this is an expected result
119:06 - so let's include an element in the
119:08 - relevant list that does satisfy the
119:09 - condition
119:14 - excellent
119:17 - so the last and last or default
119:19 - operators work in much the same way as
119:21 - the first and the first or default
119:23 - operators the only difference is that
119:26 - the last item in the collection is
119:27 - returned where no condition is specified
119:34 - the last item that satisfies a specified
119:37 - condition and the collection is returned
119:39 - when a condition is specified
119:44 - the last method will throw an exception
119:46 - if an appropriate element is not present
119:49 - within the relevant list
120:01 - we can use the last or default method
120:03 - rather than the last method to return
120:06 - the default value for the relevant data
120:08 - type in the case where an appropriate
120:10 - element in the relevant collection is
120:12 - not present
120:24 - great so let's move on to the single and
120:27 - single or default element operators
120:30 - the single operator Returns the only
120:32 - element in a collection or one element
120:34 - that satisfies a specified condition
120:36 - from a collection we have the option of
120:39 - passing a condition into the single
120:41 - method through the use of a method
120:43 - overload or we can leave the brackets
120:46 - following the single method empty which
120:48 - means we have chosen not to pass in a
120:50 - condition into the single method
120:53 - if we choose not to pass in a condition
120:55 - into the single method and there is more
120:57 - than one element or zero elements in the
120:59 - collection and invalid operation
121:01 - exception will be thrown if however
121:04 - there's only a single element in the
121:06 - collection the value for this element
121:08 - will be returned by the query
121:12 - if we do choose to pass in a condition
121:14 - and zero or more than one element
121:16 - satisfies the condition an invalid
121:18 - operation exception will be thrown
121:21 - if we pass in a condition to the single
121:23 - method and only a single element
121:25 - satisfies the condition the value for
121:28 - this single element will be returned
121:30 - from the relevant single operation
121:33 - let's apply the single operator to a
121:36 - collection of employees
121:37 - let's first modify the data for our list
121:40 - of employees so that only one employee
121:43 - element exists within the relevant
121:45 - employee collection
121:48 - foreign
122:00 - let's write code using the single
122:03 - operator to query the relevant employee
122:05 - list
122:06 - foreign
122:11 - this is an expected result
122:17 - let's now include the employees that we
122:20 - just commented out back within the
122:21 - relevant employee list
122:29 - let's run the code
122:36 - and an invalid operation exception is
122:39 - thrown as expected this is because more
122:41 - than one employee resides in the list
122:44 - if there is only one item in the
122:47 - relevant collection the value for this
122:48 - item is returned
122:51 - if there are zero items or more than one
122:53 - item in the collection and the condition
122:55 - is not specified for the single operator
122:57 - and invalid operation exception is
123:00 - thrown
123:02 - so let's test the single method and this
123:05 - time specify a condition where one item
123:07 - within the relevant collection satisfies
123:10 - the specified condition
123:20 - great
123:21 - let's specify a condition where more
123:24 - than one item in the relevant collection
123:26 - satisfies the specified condition
123:34 - as you can see an invalid operation
123:36 - exception is thrown
123:39 - so let's test the same scenario I.E more
123:43 - than one element in the relevant
123:44 - collection satisfies the specified
123:46 - condition but this time let's use the
123:49 - single or default method
123:52 - that's interesting
123:54 - so note where more than one element
123:56 - satisfies the specified condition when
123:59 - the single or default method is applied
124:01 - in the relevant query an invalid
124:04 - operation exception is thrown just like
124:07 - when the single method is applied to
124:09 - perform the same operation
124:11 - so we can use the single or default
124:14 - method instead of the single method if
124:16 - we don't want an exception to be thrown
124:18 - under the scenario where no elements
124:20 - exist within the collection the default
124:23 - value for the data type will instead be
124:25 - returned by the query
124:27 - if a condition is specified for the
124:30 - single or default method and no elements
124:32 - satisfy the condition the same result
124:35 - will be produced I.E the default value
124:38 - for the data type of the elements stored
124:41 - in the collection will be returned by
124:43 - the query
124:45 - if a single item is present within the
124:47 - relevant collection and the single or
124:49 - default method is applied to perform a
124:51 - query against the relevant collection
124:53 - the single elements value that exists
124:56 - within the relevant collection will be
124:57 - returned by the query
125:00 - [Music]
125:09 - hi and welcome to the fourth and final
125:12 - part in this video series on the link
125:15 - technology using c-sharp this video is
125:18 - also part of the seventh tutorial in an
125:20 - advanced c-sharp course
125:22 - this video is a continuation of the
125:24 - previous three videos in this video
125:26 - series on link so I recommend viewing
125:29 - the previous three videos in this video
125:31 - series before viewing this video
125:36 - in the previous video in this series we
125:38 - looked at code examples where certain
125:40 - link operators were implemented to query
125:42 - and transform data this video is a
125:45 - continuation of the previous video in
125:47 - this series where we'll create code
125:49 - examples using some of the other link
125:52 - operators to gain a broader
125:53 - understanding of what can be
125:55 - accomplished using the Link Technology
125:57 - in c-sharp so in the previous videos in
126:00 - this series we have created code
126:02 - examples using the following link
126:03 - operators
126:05 - the Sorting operators order by order by
126:08 - descending then buy and then by
126:11 - descending the grouping operators Group
126:13 - by and to lookup The quantifier
126:16 - Operators all any and contains
126:20 - the filter operators of type and where
126:23 - the element operators element at element
126:27 - at or default first first or default
126:30 - last last or default single and single
126:33 - or default the join operators join and
126:37 - group join
126:38 - we have already looked at the select
126:40 - projection operator and we'll also look
126:43 - at the select operator in this video and
126:45 - in addition to this we'll also look at
126:47 - the select many projection operator
126:51 - so in this video we'll look at the
126:53 - following link operators the equality
126:56 - operator sequence equal
126:58 - the concatenation operator concat
127:02 - the set operators distinct except
127:05 - intersect and Union
127:08 - the generation operators default of
127:11 - empty empty range and repeat operators
127:15 - the aggregate operators aggregate
127:18 - average count sum and Max
127:22 - the petitioning operators skip skip
127:24 - while take and take while
127:28 - the conversion operators to list two
127:30 - dictionary and two array
127:33 - and lastly the projection operators
127:35 - select and select many
127:38 - we'll also look at the following
127:40 - keywords that are useful when used in
127:43 - queries implemented in query syntax
127:45 - namely the let and into keywords
127:50 - we have looked at the select projection
127:52 - operator already in previous videos but
127:54 - we'll look at this operator again in
127:56 - this video as well as look at the select
127:58 - mini projection operator we'll then be
128:01 - able to gain an understanding of the
128:02 - difference between the select and the
128:04 - select many projection operators
128:07 - as in the previous videos I'll be
128:10 - demonstrating the code examples on my
128:11 - Mac platform if you are using a Windows
128:14 - platform to follow along the experience
128:16 - of creating these code examples will be
128:18 - almost exactly the same so the fact that
128:21 - I'm using visual studio for Mac should
128:23 - not be a barrier for a learner using
128:25 - visual Studio for Windows to follow
128:27 - along with the creation of these code
128:30 - examples okay so let's create a.net core
128:33 - console project
128:40 - foreign
128:59 - so the official release of dotnet 5 has
129:02 - now been released so I'll be running
129:05 - this project using the new.net5.net
129:07 - runtime
129:09 - for more information on the significance
129:11 - of the.net 5 runtime please View the
129:14 - second part of this Advanced c-sharp
129:16 - course I've included a link to this
129:18 - video Below in the description
129:20 - the project we created in the last video
129:22 - was named link examples underscore 2.
129:25 - let's name this project link examples
129:27 - underscore 3.
129:42 - so as we did in the previous video let's
129:45 - navigate to this URL where we can access
129:48 - code on GitHub for the project that was
129:50 - created in the previous video of this
129:53 - series
129:54 - here we can copy the data related code
129:56 - that we created in our previous project
129:59 - so that we can reuse these data related
130:02 - classes in this project
130:05 - let's click the directory icon labeled
130:07 - link examples underscore 2.
130:10 - let's then click the file icon labeled
130:12 - program.cs
130:15 - let's copy the class named employee
130:19 - and paste the contents of our clipboards
130:22 - to our new project
130:24 - let's do the same for the Department
130:25 - class
130:31 - and the data class
130:35 - okay so we won't be using the get
130:37 - heterogeneous data collection method
130:39 - that resides in the data class in this
130:41 - video so let's delete this method
130:44 - let's refresh our memories about the
130:46 - classes we have just copied and pasted
130:48 - from GitHub the employee class contains
130:52 - a definition for an employee record
130:54 - the department class contains a
130:57 - definition for a department record
130:59 - the data class contains hard-coded made
131:02 - up data for employee records and
131:04 - Department Records the employee records
131:07 - are stored in a generic list strongly
131:09 - typed as employee the Department Records
131:12 - are stored in a generic list that is
131:14 - strongly typed as Department
131:16 - we can access the data stored in the
131:18 - employee list collection from calling
131:20 - client code in this case this will be
131:23 - the main method by calling the static
131:25 - method named get employees we can access
131:28 - the data stored in the department list
131:30 - collection by calling the static method
131:33 - named get departments note that the data
131:36 - class in which these methods reside is a
131:38 - static class
131:40 - let's navigate to the main method and
131:43 - before we create our example code let's
131:45 - add the appropriate using directives
131:48 - first let's add a using directive to the
131:52 - system.collections.generic namespace
131:55 - the generic list type is a member of
131:57 - this namespace
131:59 - let's also add a using directive to the
132:02 - system.link namespace once we have added
132:04 - our system.link using directive we can
132:07 - access our link operators on collection
132:09 - types that implement the I enumerable
132:12 - interface so for example list types
132:15 - implement the innumerable generic
132:18 - interface so we are able to access
132:20 - extension methods stored within the
132:22 - innumerable static class which is a
132:25 - member of the system.link namespace by
132:27 - including a using directive to the
132:29 - system dot link namespace
132:31 - the queryable static class also includes
132:34 - link extension methods and is a member
132:36 - of the system.link namespace for more
132:39 - information on how extension methods
132:41 - work in c-sharp please view the first
132:43 - video in this video series a link to
132:45 - this video has been included Below in
132:48 - the description
132:50 - before we get started creating our code
132:51 - examples I want to draw your attention
132:53 - to what might be an issue for visual
132:56 - studio for Mac users when we run our
132:58 - code interactively through Visual Studio
133:00 - for Mac by default the output may appear
133:04 - in the terminal console window within
133:06 - visual studio for Mac like this
133:09 - this is absolutely fine for testing code
133:12 - but you may prefer to present the output
133:14 - externally I.E in a terminal console
133:17 - window outside of visual studio for Mac
133:21 - if you'd prefer to present your output
133:23 - externally I.E outside of visual studio
133:25 - for Mac please navigate to visual studio
133:28 - format preferences then Under The
133:30 - Heading marked other select the item
133:33 - labeled terminal
133:36 - in the right pane of the relevant dialog
133:38 - box ensure that the enable integrated
133:40 - terminal checkbox is unchecked
133:45 - this is obviously not a functional issue
133:47 - it really comes down to personal
133:49 - preference
133:52 - let's define a generic list variable
133:54 - named employee list that is strongly
133:56 - typed as employee and let's assign the
133:59 - collection of employee records returned
134:01 - by the data dot get employees static
134:04 - method to the employee list variable
134:07 - let's define a generic list variable
134:10 - named Department list that is strongly
134:12 - typed as department and let's assign the
134:15 - collection of Department Records
134:16 - returned by the data.get department
134:19 - static method to the department list
134:21 - variable okay so we are now ready to
134:24 - query and transform data using link
134:27 - so let's start with the equality
134:29 - operator sequence equal
134:32 - so the use case here is we want to
134:35 - compare two lists of data and we want to
134:37 - know if these two lists contain elements
134:39 - of equal value and each element in each
134:42 - of the relevant lists are stored in the
134:44 - same order if each item in each list
134:47 - matches in terms of value and order the
134:49 - sequence equal method will return true
134:51 - if any of the items in each of the
134:54 - relevant lists does not match in terms
134:56 - of value and order the sequence equal
134:58 - method returns false let's create a
135:01 - generic list named integer list one
135:05 - that are strongly typed as integer let's
135:08 - copy and paste this line of code to the
135:11 - next line let's change the name of the
135:14 - second list to integer list 2.
135:27 - let's run the code
135:32 - and the sequence equal method returns
135:34 - true because the values and sequence of
135:37 - elements in integer list 1 is identical
135:39 - to the values and sequence of elements
135:42 - in integer list 2.
135:44 - let's change the order of the items in
135:47 - integer list 2 so this sequence of
135:49 - values is not equal to the sequence of
135:52 - values stored in the list named integer
135:54 - list one
135:56 - let's run the code and this is an
135:59 - expected result
136:01 - let's change integer list to once again
136:03 - for good measure
136:09 - and this is an expected result great
136:12 - so let's change the data in instillus 2
136:15 - so that the order and values in the
136:18 - lists are equal
136:20 - and now the result is true which is an
136:23 - expected result
136:25 - that was pretty straightforward I.E
136:27 - comparing two sequences of values of a
136:31 - primitive data type IE the integer data
136:33 - tab but what if we want to test this
136:35 - type of equality between two lists that
136:38 - are strongly typed with a complex type
136:41 - like for example our employee uses
136:43 - defined type
136:45 - so let's Define a variable named
136:47 - employee list compare as a generic list
136:49 - type that is strongly typed as employee
136:53 - and let's assign The Collection returned
136:55 - from the data dot get employee's static
136:58 - method to our employee list compare
137:01 - variable
137:02 - let's run a sequence equal operation and
137:04 - compare the values stored within our
137:06 - employee list compare collection with
137:09 - the values stored within the employee
137:11 - list collection
137:13 - so one would expect the result of the
137:15 - sequence equal operation to return true
137:17 - because both collections contain exactly
137:20 - the same data let's see what happens
137:29 - oh and false is returned
137:32 - the reason why false is returned is
137:35 - because we need to tell the compiler how
137:38 - to establish equality between objects of
137:41 - the relevant complex type IE in this
137:43 - case the employee type so we achieved
137:46 - this in the previous video in this
137:48 - series by implementing the built-in I
137:50 - equality comparer generic interface so
137:54 - let's copy the relevant code for this
137:55 - that we implemented in the previous
137:57 - video in the series
137:59 - let's navigate to the GitHub repository
138:02 - at this URL that contains the code we
138:05 - created in the previous video in this
138:07 - series
138:09 - let's copy the class named employee
138:12 - comparer to our clipboards
138:14 - and paste the contents of our clipboards
138:17 - to our projects like this
138:21 - we have red squiggly lines so let's fix
138:23 - this by bringing in the appropriate
138:25 - using directive so here we have
138:27 - implemented a class named employee
138:29 - comparer that implements the generic I
138:31 - equality compare interface that is
138:34 - strongly typed as employee
138:36 - this gives us a way of telling the
138:38 - compiler how we want objects
138:41 - in our lists of type employee to be
138:43 - compared when determining equality
138:46 - between the relevant objects
138:50 - so we are explicitly doing this here in
138:52 - the equals method where we are comparing
138:54 - the ID first name and last name
138:56 - properties between two employee objects
138:59 - we are returning true if the relevant
139:02 - properties of the relevant two objects
139:04 - are equal and false is returned if any
139:07 - of the relevant properties of our two
139:09 - objects are not equal within the get
139:12 - hash code method we are returning the
139:14 - hash code of the ID property of the
139:17 - relevant employee objects for more
139:19 - information on hash codes please
139:21 - navigate to this URL
139:25 - so now let's go to our main method and
139:28 - we can pass in a new instance of the
139:30 - employee comparer class to an overloaded
139:33 - version of the sequence equal method
139:35 - this object will tell the compiler
139:37 - explicitly how we want our employee
139:40 - objects to be compared
139:42 - let's run the code
139:47 - and now the sequence SQL operator works
139:49 - as expected so note that we need to tell
139:52 - the compiler how we want objects that
139:55 - are defined as complex types to be
139:57 - compared when determining equality
139:59 - between the relevant objects
140:01 - we can do this by creating a class that
140:04 - appropriately implements the I equality
140:07 - comparer generic interface great
140:10 - let's move on to the concatenation
140:12 - operator named concat
140:15 - we can use the concat operator to append
140:18 - one collection of data to another
140:19 - collection of data
140:21 - so let's see the concat operator in
140:24 - action let's create a collection of
140:26 - integer values
140:31 - let's then create another collection of
140:33 - integer values
140:39 - let's append the second collection of
140:41 - integer values with the first collection
140:44 - of integer values using the concat
140:46 - operator
140:48 - let's write code to Output the results
140:50 - of this concatenation operation to the
140:52 - screen
140:53 - let's run the code
141:00 - great
141:01 - let's do another example but this time
141:04 - let's append a collection that contains
141:06 - a collection of objects of a complex
141:08 - type to another collection of objects of
141:11 - the same complex type the complex type
141:13 - we'll use in this example will be our
141:16 - employee user defined type
141:19 - once again we can use the concat
141:21 - operator to achieve what we want here
141:37 - let's run the code
141:43 - great
141:44 - let's move on to the aggregate operators
141:48 - let's first look at the aggregate
141:51 - operator
141:52 - using the aggregate operator we can
141:54 - perform a custom operation on values
141:56 - within a collection
141:58 - let's say we have a requirement where we
142:00 - need to provide a total for the annual
142:03 - salaries of our employee records
142:05 - we also need to include the addition of
142:08 - an appropriate annual salary bonus in
142:10 - the final result let's say a manager
142:13 - gets a bonus of four percent and
142:15 - employees that aren't managers get a
142:17 - bonus of two percent so let's say we
142:20 - have a use case where we need a result
142:21 - that is a total of all employee annual
142:25 - salaries which must include each
142:27 - employee's bonus
142:29 - we can take this added complexity into
142:31 - account when totaling up our employee
142:34 - annual salaries through the use of the
142:36 - aggregate operator
142:40 - so the first argument is the seed value
142:44 - so let's provide zero for this argument
142:47 - using this argument we are initializing
142:50 - the value that will be returned by our
142:52 - aggregate operator
142:54 - the next argument is of a delegate type
142:57 - where we can include the logic for our
143:00 - aggregation functionality in the form of
143:02 - a Lambda expression so as you can see in
143:04 - our Logic for the relevant Lambda
143:06 - expression argument we are checking to
143:08 - see if the relevant employee is a
143:11 - manager whereby we need to add a bonus
143:13 - of four percent to the relevant
143:15 - employees annual salary if the employee
143:18 - is not a manager we need to add a bonus
143:20 - of two percent to the relevant employees
143:23 - annual salary
143:24 - we can then include the appropriate
143:26 - bonus amount in our calculation so we
143:29 - are adding up all employee annual
143:31 - salaries which includes each employee's
143:34 - appropriate bonus
143:36 - let's run the code
143:41 - great
143:48 - say we want to Output a comma delimited
143:51 - string from our employee list collection
143:55 - each delimited item containing the
143:57 - employee full name a dash then the
144:00 - employee annual salary each annual
144:02 - salary must include the appropriate
144:04 - bonus
144:05 - we also want to include a label
144:08 - preceding the comma delimited string
144:11 - we can achieve this using the aggregate
144:13 - operator like this
144:16 - the first argument is the label where an
144:19 - appropriate value could be something
144:21 - like employee annual salaries including
144:23 - bonus
144:25 - then the logic of our aggregation
144:27 - functionality
144:28 - can be expressed in a Lambda expression
144:31 - for the second argument like this
144:34 - we can apply the same logic to include
144:36 - appropriate bonuses from our previous
144:38 - example
145:06 - let's run the code
145:10 - great but we have a slight issue where a
145:13 - comma is presented at the end of our
145:16 - string
145:17 - we don't want this comma in our final
145:20 - result
145:21 - we can express this by passing a Lambda
145:23 - expression as our third argument to an
145:26 - overloaded version of the aggregate
145:27 - operator
145:29 - this argument allows us to perform a
145:31 - final operation on the results produced
145:34 - by the Lambda expression passed in as
145:36 - the second argument
145:38 - we first need to include another data
145:41 - type argument with an angle brackets
145:43 - following the aggregate method to
145:45 - declare the data type of the final
145:47 - output I.E provided by the Lambda
145:49 - expression we are passing in to the last
145:51 - parameter of this overloaded version of
145:54 - the aggregate method
145:57 - in the Lambda expression passed in as
145:59 - our final argument we are using the
146:02 - substring method to remove two
146:03 - characters from the end of the result
146:06 - which means a comma and a space will be
146:09 - removed
146:14 - this result is what we want excellent
146:18 - so let's move on to the average
146:20 - aggregate operator
146:22 - so to find the average annual salary for
146:25 - a list of employees we can apply this
146:28 - code
146:41 - great if we want to find the average
146:44 - salary for all employees in the
146:46 - technology department we can use method
146:49 - chaining and the where operator to
146:51 - achieve this like this
147:02 - great
147:04 - for more information on method chaining
147:07 - please View the second part of this
147:09 - video series
147:11 - let's move on to the count aggregate
147:13 - operator
147:14 - so if we want to know how many employee
147:17 - records we have in our collection of
147:18 - employee records we can apply the count
147:21 - operator like this
147:24 - great
147:26 - if we want to know how many employees or
147:28 - members of the technology department we
147:30 - can pass in a condition as an argument
147:32 - to the count operator
147:35 - the condition that is passed in as an
147:37 - argument to the count method can be
147:39 - expressed in the form of a Lambda
147:41 - expression
147:43 - great
147:44 - let's move on to the sum aggregate
147:47 - operator
147:48 - so let's keep this simple we just want
147:50 - the sum total of all annual salaries of
147:54 - all employee records stored in our
147:57 - employee list collection we can apply
147:59 - the sum operator to achieve this
148:03 - great
148:04 - let's move on to the max aggregate
148:07 - operator
148:08 - so if we want to return the highest
148:11 - annual salary property of all employee
148:13 - records stored in our employee list
148:16 - collection we can apply the max
148:18 - aggregate operator in a link query like
148:20 - this
148:22 - great
148:23 - let's move on to the generation
148:25 - operators namely default of empty empty
148:29 - range and repeat
148:32 - let's first look at the default fmt
148:35 - operator
148:36 - so we can use the default if empty
148:38 - operator to return a new I enumerable
148:41 - collection that when for example we
148:43 - apply the element at method on the new
148:46 - collection to check if the new
148:47 - collection is empty the operation will
148:50 - return the default value for the
148:52 - relevant type used to strongly type the
148:55 - relevant collection
148:57 - a query using for example the element at
149:00 - method against a collection returned
149:03 - from a default of empty operation will
149:05 - not throw an exception if the collection
149:08 - is empty the default value of the type
149:11 - with which the relevant collection is
149:13 - strongly typed will instead be returned
149:15 - for more information on default values
149:18 - for C sharp dates types please navigate
149:20 - to this URL
149:23 - we'll see later how we can pass in a
149:25 - value to the default of empty method to
149:28 - specify our own default value that we'd
149:31 - prefer to be returned when for example
149:33 - the element at method is used to check
149:35 - if the relevant collection is empty
149:37 - rather than the default c-sharp value
149:40 - for the relevant data type
149:43 - let's look at an example using the
149:45 - default fmt method
149:46 - so let's create an empty list of integer
149:49 - values let's perform a default fmt
149:52 - operation on this collection of integer
149:55 - values and assign The Returned
149:57 - collection to a new collection of
149:58 - integer values let's use the element at
150:01 - operator and pass in 0 to the element at
150:03 - method to check if the collection is
150:06 - empty
150:12 - you can see that the element at operator
150:15 - Returns the default value for the
150:17 - integer data type which is zero this is
150:20 - an expected result let's create another
150:22 - example but this time let's use the
150:24 - employee data type to strongly type our
150:26 - collections as discussed the default
150:29 - value for a reference type in c-sharp is
150:32 - null
150:33 - but as discussed we can pass in a
150:35 - default value that we would prefer to be
150:37 - returned by for example the element at
150:40 - operator when the relevant collection is
150:42 - empty
150:44 - so let's person an employee object where
150:47 - the ID property of the relevant employee
150:49 - object is set to zero
150:52 - null is not returned as would be the
150:54 - case if we hadn't passed in a value to
150:57 - the default fmt method because we have
150:59 - specified our own default value where
151:02 - the ID property of the default employee
151:04 - object is zero
151:14 - great
151:17 - similarly we could have set the default
151:20 - value for our integer collection example
151:23 - by for example passing in
151:26 - 999999 to the default if empty method
151:30 - instead of returning the default c-sharp
151:33 - value for an integer which is zero nine
151:36 - nine nine nine nine nine is returned
151:38 - this is an expected result excellent
151:42 - right let's look at the empty method
151:46 - so we can use the empty method to
151:49 - generate a new empty collection
151:52 - so for example we want to create a new
151:54 - innumerable generic collection of
151:56 - employee records we can do this by using
151:59 - the empty operator like this
152:02 - note the empty method is not an
152:05 - extension method of a numerable or I
152:07 - queryable like other link methods it is
152:10 - a static method included in the
152:12 - enumerable static class
152:14 - so for example we could instantiate a
152:17 - new empty generic list strongly typed
152:19 - with the employee user defined type
152:21 - through the use of the empty method
152:24 - we can then chain the two list
152:26 - conversion operator to this operation
152:29 - and return an empty generic list we are
152:32 - using the two list operator to convert
152:34 - an i enumerable generic collection that
152:37 - is strongly typed with the employee
152:38 - dates type to a generic list that is
152:40 - strongly typed as employee
152:43 - so for good measure let's add a new
152:45 - employee item to our new list that we
152:48 - have generated through the use of the
152:49 - empty method and the use of the two list
152:52 - conversion operator
152:54 - let's write code to write the items or
152:57 - in this case one item stored in our new
152:59 - list to the screen
153:07 - great
153:09 - let's move on to the range generation
153:11 - operator
153:13 - we can use the range operator to return
153:15 - a collection of values that are within a
153:18 - specified range so let's clarify this
153:21 - with an example
153:22 - we want to return a range of integer
153:24 - values in a collection where the first
153:26 - item in the range has a value of 25 and
153:29 - each subsequent item is incremented by a
153:32 - value of 1 until there are a total of 20
153:35 - values in the relevant collection
153:38 - we can achieve this by using the range
153:41 - method like this
153:42 - in this example the first argument
153:44 - specified is 25.
153:46 - this is the value of the first element
153:48 - and the second argument specifies the
153:51 - number of elements to include in the
153:53 - relevant generated collection
153:55 - when each item is added to the
153:58 - collection It Is incremented by a value
154:00 - of one so the second item will be 26 the
154:03 - third item will be 27 the fourth item
154:06 - will be 28 and so on
154:08 - let's run the code
154:11 - great so using the range operator we
154:13 - have generated a collection of integer
154:15 - values that fall within a specified
154:17 - range excellent
154:19 - let's say we want to generate a
154:20 - collection of a specified amount of
154:23 - elements where a value for each element
154:25 - in the collection is repeated
154:27 - we can use the repeat operator for this
154:30 - purpose like this
154:50 - great
154:51 - let's move on to the set operators
154:53 - namely distinct except intersect and
154:58 - Union
154:59 - let's start with distinct so let's say
155:01 - we have a strongly typed generic list
155:03 - that contains a list of integer values
155:06 - some of which are repeating values we
155:09 - want to perform a query against this
155:11 - list of integer values where we only
155:13 - want distinct values returned
155:16 - we can achieve this by applying the
155:18 - distinct operator to our query like this
155:38 - great
155:39 - let's say that we have two collection of
155:42 - a specific type and we want to return
155:44 - elements with values in our first
155:46 - collection that are not equal to any of
155:49 - the values of the elements in our second
155:51 - collection we can achieve this by using
155:53 - the accept operator let's look at an
155:56 - example of using the accept operator
155:58 - applied to two collections of integer
156:01 - values
156:25 - so one and two are returned in our
156:28 - results collection because these values
156:30 - exist in our first collection and don't
156:32 - exist in the second collection
156:34 - the values 3 and 4 exist in our first
156:37 - collection and also exist in our second
156:40 - collection
156:41 - the values five and six exist in our
156:44 - second collection and even though these
156:45 - items don't exist in our first
156:48 - collection
156:49 - the accept operator does not return
156:51 - these items as part of the results
156:54 - collection because in this example the
156:56 - accept operator returns values that
156:59 - exist in the first collection and don't
157:01 - exist in the second collection
157:03 - let's try an example using complex types
157:06 - let's use our employee type
157:09 - let's create a generic list strongly
157:11 - typed as employee
157:13 - let's copy data
157:16 - that we know will exist within our
157:18 - employee list collection and add these
157:21 - items to the list we have named employee
157:23 - list 2. let's add some additional items
157:26 - to the employee list to collection
157:48 - let's then call the accept method on the
157:51 - employee list collection and pass in the
157:53 - employee list 2 collection as an
157:55 - argument to the accept method then let's
157:58 - assign the results of this operation to
158:00 - an implicitly typed variable named
158:03 - results we have of course used the VAR
158:06 - keyword to implicitly type our results
158:08 - variable
158:09 - let's write code to Traverse the results
158:11 - and output the results to the screen
158:38 - let's run the code and see what happens
158:41 - and this result is not expected the
158:44 - output contains all items within the
158:47 - employee list collection
158:48 - I would have expected that the items
158:51 - that were copied from the data class and
158:53 - added to the employee list 2 collection
158:55 - as well as the other items that we added
158:58 - to the employee list collection would be
159:00 - excluded from the results
159:03 - the reason for the unexpected results is
159:06 - because we have not told the compiler
159:08 - how to compare employee objects when
159:10 - determining if one employee object is
159:13 - equal to another employee object
159:15 - so how can we let the compiler know how
159:18 - we want one employee to be compared to
159:20 - another employee within our collections
159:22 - when determining equality between the
159:25 - two relevant objects
159:27 - you may have guessed already how we can
159:29 - achieve this we first need to create a
159:31 - class that implements the IE quality
159:34 - comparer generic interface
159:36 - we can then write code to establish how
159:39 - one employee object should be compared
159:40 - to another employee object when
159:43 - determining equality between the
159:44 - relevant objects
159:46 - we have already included the code for
159:48 - this which we applied when we created
159:51 - code to perform a sequence equal
159:53 - operation on two lists that were
159:55 - strongly typed as an employee so we have
159:58 - our class named employee comparer that
160:00 - implements the IE quality comparer
160:02 - generic interface
160:04 - so we can reuse this class for our
160:06 - example that performs an accept
160:08 - operation on two generic lists that are
160:11 - strongly typed as employee
160:14 - so all we need to do is create a new
160:17 - object of type employee comparer and
160:19 - pass this object into an overloaded
160:22 - version of the accept method like this
160:26 - let's run the code
160:30 - great
160:32 - this is now an expected result let's
160:35 - move on to the intersect operator
160:39 - so we can use the intersect set operator
160:42 - to return a collection containing only
160:44 - those items that exist in the employee
160:47 - list collection that are equal to the
160:49 - items that exist within the employee
160:51 - list 2 collection
160:52 - and now that we know we are comparing
160:54 - elements in two collections that are
160:57 - strongly typed with the employee complex
160:59 - type we need to pass in a new object of
161:02 - the employee comparer type I.E a type
161:05 - that appropriately implements the
161:06 - generic IE quality comparer interface
161:09 - this tells the compiler how to compare
161:11 - two objects of type employee when
161:13 - determining if the relevant employee
161:15 - objects are equal let's run the code
161:24 - and this is an expected result great
161:28 - let's move on to the union operator the
161:31 - union extension method requires two
161:33 - Collections and returns a new collection
161:36 - that includes distinct elements from
161:38 - both the collections
161:41 - we can again use the same data we have
161:43 - used in the previous two examples to
161:46 - test the union operator right let's
161:48 - write the code for this you will notice
161:50 - we are also passing in an object of type
161:52 - employee comparer to the union method
161:56 - Let's test the code
162:01 - great
162:02 - so let's see what happens in this
162:04 - example when we don't pass in an object
162:06 - of type employee comparer to the union
162:09 - method
162:13 - you can see that duplicate records are
162:15 - included in the results as a consequence
162:17 - of not passing in an object derived from
162:20 - a class that appropriately implements
162:22 - the generic I equality comparer
162:24 - interface and of course we know we have
162:26 - already created such a class so let's
162:28 - ensure that we pass in our object of
162:30 - type employee comparer to the union
162:32 - method so that only distinct employee
162:35 - objects are included within our results
162:38 - excellent so let's move on to the
162:41 - partitioning operators these
162:43 - partitioning operators include the skip
162:45 - skip while take and take while operators
162:49 - let's first look at the skip operator
162:52 - use the skip operator to skip over a
162:55 - given number of elements in a sequence
162:56 - and then return the remainder
163:00 - so let's query our employee list
163:01 - collection using the skip operator
163:04 - let's skip over two of the elements
163:06 - stored in our employee list collection
163:08 - and return the remainder of the elements
163:11 - using the skip operator
163:18 - great this is an expected result
163:21 - let's look at the skip while operator
163:24 - using the skip while operator bypasses
163:27 - elements in a sequence as long as a
163:29 - specified condition is true and then
163:31 - Returns the remaining elements
163:34 - let's see this operator in action
163:37 - so the condition here is Skip elements
163:40 - in our sequence of employee objects in
163:42 - the employee list collection while the
163:44 - relevant employee object's annual
163:46 - salaries are above 50 000.
163:56 - great this is an expected result
164:01 - just to make things a little bit more
164:03 - clear on how this operator Works let's
164:05 - add a new employee record to the
164:07 - employee list collection this employee
164:10 - record has an annual salary of 100 000
164:13 - which of course is above fifty thousand
164:20 - let's run the code
164:24 - and you can see that while the condition
164:26 - is true the items in the relevant
164:28 - collection are skipped I.E will not be
164:31 - returned from the query however all
164:33 - subsequent elements in the sequence will
164:36 - be returned once the condition returns
164:38 - false
164:40 - even though the last element in the
164:42 - relevant sequence has an annual salary
164:44 - property greater than fifty thousand it
164:46 - is still returned because the third
164:49 - element in the sequence caused the
164:51 - condition to return false
164:53 - the fact that the last element has an
164:55 - annual salary above 50 000 and therefore
164:58 - causes the condition to be true doesn't
165:01 - mean that the last item will be returned
165:03 - by our query note that once the
165:06 - condition returns false all items from
165:08 - that point will be returned from our
165:11 - query
165:12 - right let's move on to the take
165:14 - partition operator
165:16 - the take operator is used to return a
165:19 - specified number of contiguous elements
165:21 - from the start of a sequence
165:24 - let's see this operator in action
165:37 - this is an expected result great
165:41 - the first two elements in the relevant
165:42 - sequence of elements in our employee
165:45 - list collection are returned by our
165:47 - query
165:48 - so let's move on to the take while
165:50 - partitioning operator
165:52 - the take while operator returns elements
165:55 - from a sequence as long as a specified
165:57 - condition is true and then skips the
166:00 - remaining elements
166:02 - so let's use the same condition that we
166:04 - used in the skip while operator example
166:07 - so here we are using the take while
166:09 - operator to return elements from the
166:12 - relevant sequence that have an annual
166:14 - salary above 50 000.
166:17 - so the first two elements in the
166:18 - sequence are returned by our query
166:21 - as soon as the third element is
166:23 - evaluated and the condition returns
166:24 - false the elements from that point
166:27 - onwards in the relevant sequence will
166:30 - not be returned by our query
166:32 - so for example the fact that the fifth
166:35 - element in the employee list collection
166:37 - has an annual salary property that is
166:39 - greater than 50 000 is irrelevant
166:42 - because when the third element causes
166:44 - the condition to return false and in
166:46 - terms of the take while operator this
166:48 - means that from that point onwards the
166:51 - rest of the elements and the relevant
166:52 - sequence will not be returned by our
166:55 - query great
166:57 - let's look at the conversion operators
167:00 - to list two dictionary and two array
167:04 - so let's look at the two list conversion
167:06 - operator a query written in query syntax
167:09 - will return an i enumerable collection
167:12 - containing the results of the query what
167:14 - if we need our results to be returned as
167:17 - a generic list
167:19 - we can achieve this using the two list
167:21 - conversion operator
167:23 - let's create an example to clarify this
167:25 - point
167:27 - so for this example let's query our
167:29 - employee list collection for employee
167:32 - records that have an annual salary
167:34 - property greater than fifty thousand
167:36 - using query syntax
167:39 - note the red squiggly lines here
167:41 - this is because we are attempting to
167:44 - assign an inumerable collection to a
167:47 - variable of type generic list
167:50 - the compiler is telling us that we have
167:53 - created a type mismatch
167:56 - so we can use the two list operator to
167:58 - convert the I enumerable collection
168:00 - returned by our query to a generic list
168:02 - by wrapping the relevant query in
168:05 - Brackets adding a DOT after the last
168:08 - bracket and applying the two list
168:10 - operator like this so now you can see
168:13 - the red squiggly lines disappear because
168:15 - we have removed the type mismatch
168:18 - let's run the code
168:28 - excellent
168:29 - as discussed earlier in this video
168:31 - series wherever a two conversion
168:34 - operator is applied to a query as we
168:36 - have done here
168:38 - this causes the query to execute
168:40 - immediately I.E query execution is not
168:43 - deferred it is executed immediately
168:48 - so if we want to convert an innumerable
168:50 - collection returned from a query to a
168:53 - dictionary object
168:55 - we can apply the two dictionary operator
168:57 - to the query let's create an example to
169:00 - clarify what is meant by this so as in
169:03 - the previous example here we have a
169:06 - standard query written in query syntax
169:08 - to query our employee list collection
169:10 - for all elements where the relevant
169:13 - elements have annual salary properties
169:15 - that have values greater than fifty
169:18 - thousand so this is a basic query that
169:21 - will return an i enumerable collection
169:24 - but what if we want to return a
169:27 - collection where each element has a
169:29 - unique key associated with the relevant
169:31 - element
169:32 - we can do this by converting the query
169:34 - result to a dictionary generic
169:37 - collection type
169:39 - so let's alter our code so that the
169:42 - innumerable collection returned by our
169:44 - query is converted into a generic
169:46 - dictionary collection So within angle
169:49 - brackets after two dictionary we need to
169:51 - pass in two data types the first data
169:55 - type declares the data type of the
169:57 - values stored in the dictionary
169:59 - the second data type declares the data
170:01 - type of the key that will be used to
170:04 - uniquely identify each element in the
170:06 - collection so the First Dates type is of
170:09 - type employee and the second data type
170:11 - is of type int note that we want each
170:15 - element to be keyed on the employee ID
170:18 - property
170:19 - we can express this by passing in an
170:22 - appropriate Lambda expression to the two
170:24 - dictionary method like this
170:27 - so let's Traverse the key values stored
170:30 - in our dictionary object using a for
170:32 - each Loop
170:33 - note how we are able to use the key
170:35 - values to retrieve the values of each
170:38 - element stored in the dictionary
170:41 - we are doing this by passing in the
170:43 - relevant key within square brackets to
170:46 - the dictionary object
170:49 - here we are outputting the key as well
170:51 - as each employee's first name and last
170:53 - name to the screen
171:05 - and as you can see we have each
171:07 - employee's ID which we have designated
171:11 - as our key value followed by the
171:13 - corresponding employees first name and
171:15 - last name properties excellent
171:18 - we have successfully converted a query
171:21 - result from an innumerable collection to
171:24 - a dictionary object
171:26 - as discussed when we call any of the two
171:29 - conversion operators on a query result
171:32 - this causes our query to execute
171:34 - immediately for more information on
171:36 - deferred execution versus immediate
171:39 - execution please View the second part of
171:41 - this video series
171:44 - for good measure let's also create a
171:47 - result using the two array conversion
171:49 - method
171:50 - so if we try to assign the results of
171:53 - this query to a variable defined as an
171:56 - array of employees the compiler
171:59 - complains of a type mismatch the query
172:02 - result is returned as an innumerable
172:04 - collection and not an array of employee
172:06 - objects
172:08 - to remove the type mismatch we can apply
172:10 - the two array method like this
172:26 - great
172:28 - so let's discuss the let and the into
172:30 - Clauses that can be applied when using
172:33 - query syntax to represent a link query
172:37 - let's look at the Microsoft docs for an
172:40 - overview of the let Clause this overview
172:43 - of the let Clause can be found at this
172:45 - URL
172:48 - in a query expression
172:50 - it is sometimes useful to store the
172:53 - result of a sub-expression in order to
172:56 - use it in subsequent clauses
172:59 - you can do this with the let keyword
173:03 - which creates a new Range variable and
173:06 - initializes it with the result of the
173:09 - expression you supply
173:12 - once initialized with a value the range
173:15 - variable cannot be used to store another
173:19 - value
173:20 - however if the range variable holds a
173:22 - queryable type it can't be queried
173:27 - so let's look at a basic example using
173:30 - the let keyword in a link query
173:32 - let's say we wish to query our employees
173:35 - based on employee initials now we don't
173:39 - have an initials property for an
173:40 - employee record but within our query
173:43 - using the let keyword we can extract the
173:46 - initials from each employee records
173:48 - first name and last name properties and
173:51 - assign the result
173:52 - of this extraction process to a variable
173:55 - named initials directly within our query
173:58 - using the let keyword this allows us to
174:02 - use the initials variable in our where
174:04 - Clause as well as reuse the initials
174:07 - variable within our select clause
174:11 - through the use of the let Clause we can
174:13 - also apply a condition and based on the
174:16 - evaluation of that condition store a
174:19 - value in a variable that can be used
174:21 - later in the query like for example
174:24 - within aware clause
174:27 - here we have a condition where we need
174:29 - to add an appropriate bonus to the
174:31 - annual salary property based on whether
174:34 - the employee is a manager or not a
174:36 - manager if the employee is a manager we
174:39 - need to add a bonus of four percent to
174:41 - the relevant employee records annual
174:43 - salary property if the employee is not a
174:46 - manager we need to add a bonus of two
174:48 - percent to the relevant employee records
174:50 - annual salary property we can store the
174:53 - relevant annual salary plus bonus value
174:54 - for each employee record by assigning
174:57 - the value returned by a ternary operator
174:59 - to a variable we have named this
175:02 - variable annual salary plus bonus the
175:05 - let clause in this example enables us to
175:07 - reuse the annual salary plus bonus
175:10 - variable both within the where clause
175:12 - and the select Clause later in the query
175:15 - thank you
175:50 - foreign
176:05 - let's run the code
176:15 - excellent
176:17 - let's look at the into keyword
176:20 - we can use the into keyword in a link
176:22 - query to collate data within a group and
176:25 - then after this operation we are able to
176:27 - perform a filter operation within the
176:30 - same query if required on the grouped
176:33 - data through the use of aware clause
176:36 - so for example let's use a link query to
176:40 - First create a group of high earning
176:42 - employees based on a condition let's say
176:45 - that the employee must earn above 50 000
176:47 - to fit into the relevant group we can
176:50 - use the where Clause at this point in
176:52 - the query to appropriately filter the
176:55 - relevant employee records and the into
176:57 - keyword to put the filtered data into
177:00 - the relevant group of high earning
177:02 - employees
177:04 - so we can use the into keyword to group
177:06 - The High earning employees into a group
177:08 - named High earners let's say we then
177:11 - want to further filter this group of
177:14 - high earning employees by management
177:16 - status
177:18 - so we only want these employee records
177:20 - where the is manager property is set to
177:22 - true return from our query
177:25 - we want to know which of those High
177:27 - earning employees are managers
177:30 - so we can use another where Clause
177:32 - within our query to filter the high
177:34 - earner group based on the relevant
177:36 - condition
177:37 - we have used a where Clause earlier in
177:39 - our query to create the group of high
177:42 - earning employees
177:43 - then once the group is created through
177:46 - the use of the into keyword we can
177:48 - further filter the group of high earning
177:50 - employees based on each employee records
177:53 - is manager property
177:55 - so we are able to include another where
177:57 - clause in our query to filter the
177:59 - grouped data let's run the code
178:07 - great
178:08 - so lastly let's look at the select and
178:11 - the select many projection operators
178:14 - in this video series we have already
178:16 - looked at the select projection operator
178:19 - so the focus in this example is on the
178:22 - select many operator
178:24 - we want to know how it differs from the
178:26 - select operator and in what
178:28 - circumstances we may wish to apply the
178:30 - select many operator in a link query
178:33 - let's navigate to a Microsoft docs
178:35 - webpage to see what the Microsoft docs
178:38 - say about these two projection operators
178:42 - projection refers to the operation of
178:45 - transforming an object into a new form
178:48 - that often consists only of those
178:51 - properties that will be subsequently
178:53 - used
178:54 - by using projection we can construct a
178:58 - new type that is built from each object
179:01 - you can project a property and perform a
179:04 - mathematical function on it you can also
179:07 - project the original object without
179:09 - changing it
179:10 - select projects values that are based on
179:14 - a transform function
179:16 - select many projects sequences or values
179:20 - that are based on a transform function
179:22 - and then flattens them into one sequence
179:26 - to understand the difference between the
179:29 - select many operator and the select
179:31 - operator let's modify our department
179:33 - class so that it includes a property
179:35 - that stores a collection of employees
179:38 - we have already discussed that
179:40 - Department Records have a one-to-many
179:42 - relationship with employee records so
179:45 - each department object will now store a
179:48 - collection of related employee records
179:51 - let's also alter the get Department's
179:54 - static method that resides in the data
179:56 - static class so that the get
179:58 - Department's static method accepts an
180:01 - argument containing a collection of
180:03 - employee objects
180:05 - then for each department object added to
180:07 - the department list collection within
180:09 - the get Department static method let's
180:12 - include a query to return an appropriate
180:14 - collection of employees I.E those
180:16 - employee records that have a department
180:18 - ID property matching the ID property of
180:22 - the relevant Department object
180:37 - so let's go to the main method and pass
180:39 - in the collection of employees to the
180:41 - get Department method so now the get
180:44 - departments method will return a
180:46 - collection where each department
180:47 - contains a related collection of
180:50 - employee records
180:53 - so now what if we want to query the
180:55 - department list collection for all
180:58 - employees we can achieve this using the
181:01 - select operator but when traversing the
181:04 - results of the select operation we will
181:06 - need to use an outer and an inner for
181:08 - each Loop like this
181:10 - in this scenario the select many
181:13 - operator is better to use for this
181:16 - purpose the select many operator is
181:18 - better in this case because we can use
181:21 - one for each Loop to Traverse the
181:23 - results of our query
181:25 - unlike where we needed to use an
181:28 - additional nested for each Loop to
181:30 - Traverse the results of our query where
181:33 - we used the select operator
181:37 - behind the scenes as it were the select
181:39 - many operator appropriately flattens the
181:41 - results
181:42 - and this means we don't need to use a
181:45 - nested for each Loop to Traverse the
181:47 - results of our query
181:48 - we are able to use one for each Loop for
181:51 - this purpose
182:12 - excellent
182:14 - so we have covered a lot of ground in
182:17 - this video series on link operators I
182:19 - would encourage you to practice using
182:21 - these operators to become proficient in
182:23 - writing link queries this is a very
182:25 - powerful technology and it's used with
182:28 - Entity framework to perform database
182:30 - queries in modern.net applications
182:33 - Entity framework is now the recommended
182:35 - technology to use a.net for implementing
182:38 - database related functionality in.net
182:41 - applications if we navigate to this
182:43 - Microsoft docs webpage we can see this
182:46 - paragraph that states Entity framework
182:49 - core is a modern object-based mapper
182:52 - for.net it supports link queries
182:55 - change tracking updates and schema
182:59 - migrations EF core works with many
183:01 - databases including SQL database
183:04 - on-premises and Azure sqlite MySQL
183:08 - postgres and Azure Cosmos DB
183:12 - this makes link a very important
183:15 - technology to learn for net Developers
183:17 - link enables developers to write one set
183:20 - of code that can be applied to handle
183:22 - data related functionality for multiple
183:24 - different data sources in link
183:27 - expression trees are used to represent
183:30 - structured queries that Target sources
183:32 - of data that implement the generic I
183:36 - queryable interface
183:38 - if you would like to delve deeper into
183:40 - expression trees please navigate to this
183:43 - URL
183:45 - so let's summarize what we have learned
183:47 - in our four part series on using the
183:49 - Link Technology in C sharp in the first
183:53 - part of this video series we created our
183:55 - own extension method to filter data we
183:58 - also demonstrated how a Lambda
184:00 - expression can be used to express a
184:02 - condition that can be passed into our
184:04 - extension method to filter the data and
184:07 - return the filtered results from a query
184:10 - the reason we created the filter
184:12 - extension method is because link is
184:14 - mostly made up of extension methods
184:16 - stored in two static classes namely a
184:19 - static class named enumerable and a
184:22 - static class named queryable
184:24 - we are able to access the extension
184:27 - methods Within These static classes by
184:29 - including a using directive to the
184:32 - system.link namespace the innumerable
184:34 - and queryable classes are both members
184:37 - of the system.link namespace
184:40 - in the second part of this series we
184:43 - demonstrated examples using the select
184:45 - where join and group join operators we
184:48 - also discussed the difference between
184:51 - when a query is executed with deferred
184:53 - execution or immediate execution we
184:56 - discussed how a link query is executed
184:58 - with deferred execution but we can make
185:01 - the link query execute immediately by
185:04 - applying a two conversion operator to
185:07 - the query for example two list two
185:10 - dictionary or two array
185:13 - in the third video in this series we
185:15 - demonstrated code examples using the
185:18 - following link operators
185:20 - sorting operators order by order by
185:23 - descending then buy and then by
185:25 - descending grouping operators group buy
185:28 - and to lookup
185:30 - quantifier operators or any and contains
185:34 - filter operators of type and where
185:38 - element operators element at element at
185:41 - or default first first or default last
185:45 - last or default single and single or
185:48 - default
185:53 - in the fourth and final video in this
185:55 - series we demonstrated code examples
185:57 - using the following link operators the
186:00 - equality operator sequence equal
186:03 - the concatenation operator concat
186:07 - the set operators distinct accept
186:10 - intersect and Union
186:12 - the generation operators
186:15 - default if empty empty range and repeat
186:19 - operators
186:20 - the aggregate operators aggregate
186:23 - average count sum and Max
186:27 - the partitioning operators skip skip
186:30 - while take and take while
186:34 - the conversion operators to list two
186:37 - dictionary and two array
186:40 - projection operators
186:42 - select and select many
186:45 - in this video we also looked at code
186:48 - examples using the let and the N2
186:50 - keywords
186:51 - I hope you've enjoyed this video series
186:53 - on using the Link Technology in c-sharp
186:56 - I hope you enjoyed this part of the
186:57 - advanced c-sharp course where we looked
187:00 - in a fair amount of detail at a set of
187:01 - Technologies named link
187:03 - please find the full Advanced c-sharp
187:05 - course on the gavinlan YouTube channel
187:07 - you'll see the video series on the home
187:09 - page the playlist for the entire
187:12 - Advanced c-sharp course can be found at
187:14 - this location
187:16 - I hope to see you soon thank you and
187:18 - take care