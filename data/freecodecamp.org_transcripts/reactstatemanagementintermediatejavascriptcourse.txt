00:00 - In this intermediate react course about React 
state management, Jack Harrington will teach  
00:04 - you about hooks state context, using request 
libraries for state management, Redux, and more.
00:10 - Hi, I'm Jack Harrington. I'm a principal 
full stack software engineer. And I am  
00:15 - super excited to be here on Free Code Camp, 
talking about my favorite topic, which is  
00:21 - react state management. And the first thing I 
want to answer about React state management is,  
00:27 - what is state management. So state management 
is basically half of your React app. When you  
00:33 - think about it, you've got the presentation 
side of the house, that's the HTML and how  
00:38 - you format it. And then there is the data 
that's in your application, the state,  
00:45 - and to me state in state management is the beating 
heart of a React app. And why do I say that? Well,  
00:51 - it actually is, the only time a React app will 
rerender is when state changes when you add an  
00:58 - item to a cart, when you remove an item from 
a cart. That's the time when the React app re  
01:04 - renders. And so state is the engine that moves 
your React app. In fact, I would go so far as  
01:11 - to say that reacts whole job is to turn state 
into HTML, at least in the web context. So in  
01:20 - this video, I'm going to give you a complete 
overview of all of the different ways that you  
01:25 - can manage state in your React application. And 
that's going to start off with React Native state  
01:31 - management. This is the hooks we've all come to 
know and love things like use state use reducer,  
01:37 - use memo and use the fact we are going to drill in 
deep on these hooks and make sure that we really  
01:46 - understand them because they are the foundation 
upon which all of the other state management  
01:52 - models are built. In the second section, we're 
going to talk about indirect state managers. These  
01:59 - are third party libraries like React, query, 
react location, React Router, it's not their  
02:07 - primary job to manage state, but react query, 
for example, it goes off and agrees data from  
02:13 - the server and it gets it back. And now it holds 
that data which has an effect managing that state.  
02:18 - And perhaps the combination of native hooks, 
and one of these third party libraries, like  
02:27 - React query or application is enough for your 
state management needs for your application.  
02:33 - And then in the third section of the video, we're 
gonna talk about direct state managers. These are  
02:38 - third party libraries whose sole function is to 
manage state, things like Redux, Joe tie vow,  
02:47 - sheEO and zouche done, and we'll talk about the 
different models and which one you might want to  
02:52 - select for your application. And then, at the end, 
we'll talk about some new things that are coming  
03:00 - with some react RFCs that are just coming out 
next Jas 13. That changed the way that we think  
03:06 - about how we might want to manage state in our 
application. And I'll sum up by giving you some  
03:11 - recommendations about what I suggest you might 
think about in terms of choosing state management  
03:16 - technologies for your app. But it all starts with 
getting to know react hooks really well. So let's  
03:22 - get right into it. So we're going to start off by 
taking a look at native state management in React,  
03:28 - and in particular, concentrating on the use 
state hook. So to do that, I'm going to build  
03:33 - a VT application, I'll do that using yarn, create 
Veet then either the name of the application that  
03:39 - you want, so I'm going to going to use native use 
date. And now V which is a awesome way to create  
03:47 - web applications can take multiple templates, 
I'm going to use the template for React.  
03:56 - Alright, now I'm gonna bring that up in VS code.  
03:59 - Alright, so here we have our 
application and bring up the console.  
04:04 - And then we'll do yarn to install all the 
dependencies. And then yarn dev to start it up.  
04:12 - And I'll click on this link. And there you go. 
Awesome. Here's our application. It's even got  
04:19 - a little bit of interactivity, a little state in 
this case, but we're just gonna remove everything  
04:24 - that we see here to start. So where is that 
located? Let's locate it over map dot JSX.  
04:30 - And I'm going to remove pretty much all of this.  
04:35 - But we'll keep around Eustache because we know 
we're gonna need it. Okay, so the first thing  
04:40 - we're gonna do is experiment with using a numeric 
state a number. And actually a counter is the best  
04:46 - way to do that. So we're going to basically 
we implement this from scratch. Now all of  
04:50 - this code is available to you on GitHub for free 
in the link in the description down below. But  
04:55 - you can just follow along me if you please. So 
okay, so here's our end. We're gonna it define  
05:00 - that we have some state associated with this 
component. So to do that we say use state.  
05:09 - And we'll start our counter off at a 
given number, say let's start with 10.  
05:14 - Now the output of use eight is an array. So let's 
go and get data array. And within that array,  
05:21 - the first item is the current value of that 
piece of state. So we'll call that count.  
05:28 - And then the second item is a setter 
function, you call that function to set  
05:32 - that piece of state. So call that set count. 
Now let's create a button that has the count.  
05:43 - And let's take a look see what it looks like. 
All right, so we've got a button down here,  
05:48 - kind of hard to see a little bit. But it's got 
10 on it, but it doesn't do anything yet. So we  
05:54 - want to create an onclick. So how do we do 
that? Well use unclick. And then we give it  
06:00 - a function. So we're gonna say add one is our 
function. And then we'll define that function.  
06:10 - So here's a mistake that I've seen people 
do. See, we will do count plus plus,  
06:14 - I think the idea is that well, count is just 
a count. And when I said it, it should be  
06:19 - retained. So let's try that out. Let's see if that 
actually works. But click on that nothing happens.  
06:26 - And so why is that? Well, we're seeing that we're 
getting an assignment to a constant variable. Now,  
06:31 - what's outputting? That is actually console ninja, 
you want to go grab that? That's my folks that  
06:36 - Wallaby link to that also in the description down 
below. It's free. And it's super handy like this.  
06:40 - So well, okay, we get it. This is defined as a 
const. Right? So let's go and redefine that as a  
06:47 - let, and maybe that will work. All right, let's 
give it a try. Now, click still doesn't work,  
06:53 - but we don't get an error. Interesting. Okay. 
So why is this? Well, learning why this is,  
07:00 - is really critical to understanding pretty much 
all of state management in React. So I want to  
07:06 - spend a bit of time on it. And one of the things 
I want to do is I want to use a workbook to show  
07:13 - how this is actually working. So I'm going to 
create in as another extension called cuaca, a  
07:21 - worksheet. And what we'll do is I'm going 
to create a function that returns a value  
07:26 - kind of like use date, so we'll 
call that function get state.  
07:34 - And let's say that it has some value and say 42.
07:43 - And then when he called get 
state, or just returns that value,  
07:46 - now down here, I'm gonna call get state. 
Now currently just returns 42. But I'm  
07:53 - gonna go store that somewhere. So I need to 
store that in a new value, so like my value.  
08:00 - And we'll just ask cuaca, what my value is. 
It's 42. And now if I set it to something else,  
08:13 - now my value is 22. Cool. But what happens when 
I go and get the state again, so I'll say my  
08:21 - value again. And now my value again, is still 42. 
Because setting the value of a return, just sets  
08:33 - your local copy. So scalars, and that includes 
strings, numbers, and booleans. So a number in  
08:41 - this case, are returned and passed by value, where 
arrays and objects are passed and returned by  
08:50 - reference. And there's a huge difference there. 
So when you're returning something by value,  
08:55 - you don't get it, you get a copy of it, which 
is not the same thing. Now you could say, Oh,  
09:03 - Jack, you know, you got it all wrong. And 
this is returning an array. Okay, fine.  
09:09 - Go try the same thing with array. All right, 
yeah. So we see that, again, my values 42,  
09:15 - we set the local copy to 22. And then we again, 
set that and there's no difference, same sort  
09:23 - of thing down here. Right, all we're doing is 
just d structuring a scalar within an array.  
09:30 - Now there actually is a way to kind of make 
get state do this. And that's the beauty of  
09:35 - JavaScript enclosures. But when you hack around 
that much, you're not actually representing how  
09:41 - React is actually managing state. And the proof is 
in the pudding. The proof is in this doesn't work.  
09:48 - So what works is to use that set count function 
that's given to us to set that count to be the  
09:57 - count plus one, or whatever you So let's go over 
here and try it again. And now it works perfectly.  
10:05 - So now I mentioned that count is associated with 
this particular instance of this component. But  
10:11 - this component is the app, right? So we 
only have one. So what if we're going to  
10:16 - have multiple ones of these, let's go and 
take an app and just rename it counter.  
10:21 - And then we'll make a new app, then we'll just 
make a bunch of counters and see how that works.  
10:27 - Now we have one counter down here. Let's go make 
a bunch. Cool. Now we've got four count buttons.  
10:35 - And now we can click on each one of them. And 
they all independently set. And that's what I  
10:40 - mean by the state being coupled with the instance 
of that component, each one of these components,  
10:47 - these counter components, maintains its own 
count. And thus, going back over here, we can go  
10:56 - in independently, you take each one of these, and 
they all maintain their states individually. So  
11:02 - we talked about how to manage a scalar, a simple 
scalar using use eight. Let's talk about how to  
11:08 - manage an array. So we do that a lot as well. So 
I'm going to create an array of names. And then  
11:14 - we're going to have an ability to add a name to 
that. So let's get rid of one of these counters.  
11:21 - And I'll create a new function, which 
is a component called name list.  
11:26 - So let's create some state 
to hold that list of names.  
11:31 - Jack, Jill and John. In fact, actually, 
let's go fix this to be const. Again,  
11:36 - so that's good, okay, good. And now 
we're going to render that state.
11:49 - Nice, and let's go and 
actually put it into our app.  
11:57 - All right, good looking list there. Alright, 
so we want to be able to add an item  
12:02 - to that array. So we need an input field. 
So that's another thing you can do,  
12:08 - you can have multiple pieces of state 
associated with the same component. So  
12:13 - we're just going to have another, here's a 
state called name, which is a scalar string.
12:24 - And then we need an input field.  
12:29 - Now when this text changes, we get an event. And 
that event has a value for the current target the  
12:36 - target of that event being that input. And within 
that target, we have the current value, that would  
12:43 - be the last thing that the user typed or the last 
state of the text field. So we just set the name  
12:50 - to that target value. And again, we're using the 
setter, right, we don't want to go and say name  
12:56 - equals target value, because we know for strings, 
and for numbers and Booleans, we get back copies,  
13:03 - we don't get back the real thing. So we can't 
just set it, we got to use that setter set name.  
13:09 - So now we've got our set. Let's go take a look. 
And see that works. seems to work pretty well.  
13:14 - Cool. So now let's go and add a button so we can 
add an item to the list. Now we need to add a  
13:24 - click handler that is going to respond to clicking 
on Add name to add that name to that list.
13:35 - Okay, so here we have ADD name. So how 
are we going to implement on this? Well,  
13:39 - what we could do is good just 
a push the name on to list.  
13:48 - Alright, let's go check this out. I'm gonna go 
and add some just random text in there. I'll  
13:52 - hit Add name, and nothing happens. But here's 
an interesting deal. If I change the state of  
14:00 - the component, we'll get a rerender. So 
if I backspace, that's going to change  
14:06 - the state of the Name field, which calls 
set name, set name then does two things.  
14:14 - It sets the name. And it also in queues a 
rerender request for this particular component.  
14:22 - When the rerender happens, we get that same list. 
And then we print it out. Now that's the big  
14:30 - difference here between scalars and references. 
So strings, numbers, and billions are scalars.  
14:38 - You get back the value, a copy of the value 
and then that's it, you got the local copy. But  
14:45 - when it comes to objects and arrays, JavaScript 
manages those by reference. And when you give  
14:52 - react a reference to this particular array, it 
then holds not the array data. It's setup, but  
15:00 - it holds a reference to that array. And then 
it gives us back that same array reference,  
15:07 - we then use an in place command push to mutate 
that data of that array in place. And that's why  
15:19 - as we add more items, when we do a 
refresh, we actually get that updated data.  
15:27 - The problem is that react has no idea that 
we've done that. So the second part of what  
15:35 - a setter does, which is to in queue, a 
request for a rerender of a component  
15:41 - doesn't happen. So what if we did 
this? What if we said setlist?  
15:46 - And we'll just give it the same list again, I 
mean, hey, you know, we've made a change, which  
15:51 - is just going rerender. Okay, let's try that. So 
fresh, add the name again, and nothing happens.  
16:00 - So here's the deal. When I call any 
setter, when it comes to use date,  
16:05 - it looks at the old value, and it looks at the new 
value. And if the old value and new value are the  
16:11 - same, it just says I don't care. Thanks. But you 
know, you're not really doing anything. So what  
16:18 - we're doing in this case is where we are giving it 
back exactly the same reference as we had before.  
16:23 - So it's looking at those two references and 
saying, oh, that's the same array. And so you're  
16:28 - just asking me to do nothing really. And so it 
doesn't in-q A rerender request. So we need to do  
16:35 - in order to make this work is instead of in place, 
mutating the array, we create a new array that has  
16:42 - the contents of the old array, plus the new name. 
So maybe we do that as we create a new array.  
16:50 - We'll give it all of the old 
array, so list in this case,  
16:55 - and then we give it our new name. Now we 
don't have to do that push anymore. Hit save.  
17:04 - And away we go. Even better, we can do 
set name and set that to an empty string.  
17:13 - Then after we add it, that's set to an empty 
string. And it's important to know that with  
17:18 - React 17 with React 18. These setters are 
batched. So you do setlist it says that  
17:25 - value in queues a request, set name runs, right 
after that sets that name again and queues a  
17:33 - request to rerender. The component. React says 
hey, I've already got one for this component,  
17:38 - and it just ignores it. And then when the rerender 
comes round, both of those values have been set.  
17:46 - Now the last thing I want to cover about 
use state before we move on to use reducer  
17:50 - is that you state also can take a function 
as a starting point. So let's just take our  
17:59 - example here of a single simple string, 
and then we'll give it a function.  
18:04 - And that function will return 
a string and says, Jack.  
18:12 - And there you go now is initialized 
jack. So the value of doing it this way,  
18:16 - is that if you've got some sort of 
complex calculation that you need,  
18:21 - in the creation of this use state, you can 
do it all within that function. And that  
18:26 - function will guaranteed only ever get run 
once, when that component is first created.  
18:33 - Let's continue to take a look at native state 
management in react by taking a look at use  
18:37 - reducer, which is another way to store state in 
connection with a component just like you state.  
18:44 - Alright, let's go and create another example 
application. We'll call this one native use  
18:49 - reducer. And again, this is available to you in 
the GitHub repository associated with this video.
18:58 - And I'll bring it up in VS code.  
19:01 - Let's install it and then run it and bring 
it up in the browser. Okay, it looks good.
19:10 - So let's pare this down again.  
19:17 - Okay, we're all cleaned up. But before we get into 
use reducer, I do want to talk a little bit about  
19:22 - a reducer function in general. And a good way to 
do that would be to open up a TypeScript workbook  
19:29 - and look at the reduce method on an array. 
So let's give ourselves an array of numbers.  
19:39 - And we want to total up those numbers. 
So let's start with the total.  
19:46 - And then we'll iterate through all the numbers and 
then add that to the total. And eventually, well,  
19:54 - what do we get? We get 6010 plus 20 plus 3060. 
Think that makes sense. All right. So Another  
20:00 - way to do that is to use a reducer function. 
So numbers has a function called reduce.  
20:08 - And that reduce function takes two 
parameters, it takes a reducer function,  
20:14 - which returns something, and then it takes an 
initial value. So our initial value here would  
20:20 - be the same as this total would start off at 
zero. So that's easy enough. So this reducer  
20:27 - function takes two parameters, it takes the 
current value, which would be zero to start.  
20:31 - And then it takes the number at the given index 
as it indexes through the entire array. So starts  
20:40 - out with 2010 20, and 30. So we'll call that 
N. And the output of a reducer is the new value  
20:50 - for the next iteration. So in this case, we want 
to take the existing value, so starting at zero,  
20:56 - and then add on each number as we go through. 
Now, if we look at this, we get 60 as the output,  
21:04 - how cool is that? So this function right here, 
that we pass to reuse is called the reducer. And  
21:11 - it takes two parameters, it takes the current 
value, and then it takes some new value. And in  
21:18 - the case of numbers, because we're iterating 
through an array, it takes each one of the  
21:22 - numbers as we go through. And then the output of a 
reducer is what the next iterations input will be.  
21:32 - So this reducer pattern is going to show up in two 
places. In this video, it's going to show up in  
21:37 - the user reducer example that we're going to build 
here. And it's also going to show up in Redux. So  
21:42 - learning how reducer is work is beneficial across 
state management. Okay, so what do we want to do  
21:49 - with use reducer here? Well, we want to rebuild 
this example of a list of names and then an input  
21:54 - name, and build it all in one piece of state 
management. And so we'll bring in user reducer.  
22:04 - And we'll invoke it. And the first thing that's 
designed on is what's going to be in the state,  
22:10 - so the state is going to have a list 
of names start off with an empty array,  
22:13 - and then it's going to have the current 
name, which will just be an empty string.  
22:19 - And that is going to be the state. So use 
reducer, just like use state returns an array,  
22:28 - that array has two elements to it. The 
first is the current state. So in this case,  
22:33 - that would be this object here. And then it 
also returns a dispatch. And that's a way to  
22:39 - invoke the reducer function that we're going 
to add. So let's create our reducer function.  
22:46 - And the reducer function takes the existing 
state, which I'll just name, state,  
22:52 - and then it'll take some sort of action, 
right, and that's what's going to be sent to  
22:58 - that dispatch. So we'll just call that action. 
So by convention, action is usually an object,  
23:05 - and that object has a type on it. And then you 
use that type in the switch statement to then  
23:10 - mutate that state and return a new state based 
on that data that you get with that action. So  
23:19 - let's just start with setting that name. So we'll 
create a switch statement. And we will switch on  
23:24 - a type which comes in from that action. So when 
we dispatch, we're going to dispatch an object  
23:28 - that has a type on it. And then we'll create a 
case. And let's call this one set name, because  
23:36 - our first thing is we want to be able to set that 
name for that input field. So let's do set name.  
23:43 - And now we want to return a new version of state. 
So we take all of the existing state, and then we  
23:53 - have a name that comes in on a key called payload. 
And that's kind of by another convention, you can  
24:00 - really rename these keys all you want. But it's 
very common to see type and payload. So the second  
24:07 - value that comes out of this array is dispatch. 
And we're going to use that when it comes to  
24:13 - our input. So let's go create the input here. So 
we're gonna have an input, where the type is text.  
24:20 - And the value is the name that comes out of 
here. So that right there, we get state name,  
24:26 - and that gives us the State DOT name. And 
then the onchange we are going to dispatch  
24:33 - and then we're gonna give it an object 
and that object is going to have a type.  
24:37 - That type is going to be checked here. We're going 
to pass set name, and then we're going to give it  
24:43 - a payload and that payload is again that target 
value. So the target of the event is this input.  
24:49 - And then dot value is going to give you your 
current value. So let's take a look see how we  
24:54 - go and you know what just to check it let's go 
and add in a div weary output the Current State
25:06 - All right, let's have a look. Okay, so we've got 
our input field over here. Hello. Oh, nice. So  
25:14 - what's actually happening here. So what's actually 
happening here, let's kind of walk through it step  
25:19 - by step is we have an input field, it has the 
current name on it. And then every time we get  
25:25 - a change event, which tells us we have some sort 
of new text, we dispatch to this reducer function,  
25:33 - a type of set name and the payload that then 
gets given the current state, which we know  
25:39 - is going to be this names as an empty array, 
and then the current name, whatever that is,  
25:45 - and then an action, that action 
has that type in it set name.  
25:49 - And then we just create a new object 
with that state and that payload.  
25:55 - But let's talk about that whole references and 
scalars thing and mutating a reference in place.  
26:01 - So let's just say that we're not going to do 
that, we are going to instead just return state.  
26:08 - And we'll just set the name to that 
payload. Let's see what happens.  
26:16 - Refresh, we type and nothing happens. And 
again, this is because React is looking at  
26:24 - the references coming out of use reducer. 
And saying, hey, this matches the existing  
26:29 - reference. So it can't see it's not going to 
compare by contents, it's not going to look  
26:34 - at the inside the object and say, look, the 
name is different between these two things,  
26:38 - it's going to look at the reference to the object. 
So that's why we have to create a new object here.  
26:46 - And then just mutate the fields that we want to 
mutates, we return all of the existing fields,  
26:52 - which mean all of names. And then we just 
override the key for name and change it to  
26:58 - whatever is coming in off that payload. So 
now we need to allow for the customer to  
27:03 - add an item to the array. So let's 
create a new case called add name.  
27:11 - And we're going to turn another new object, that 
new object is going to have all of the existing  
27:15 - state again, that includes names and names, but 
we're going to override names to be a new array  
27:22 - that has all of the existing names in it plus the 
name that we send with the payload of this action.  
27:30 - And I think actually, also, we 
should just reset the name to  
27:34 - air. So easy, there it is, we can actually 
mutate multiple fields at the same time.  
27:39 - It's pretty cool. Alright, let's go down 
here. And we will make a button out of this.  
27:46 - Call this add name. And with an onclick 
handler, we will then dispatch add name.  
27:53 - And you know what, actually, we don't really even 
need a payload here because we already have the  
27:58 - state. So let's go and just do add name. So this 
is going to be state DOT names we already have  
28:05 - just stayed on in there. Yeah, that makes more 
sense. Okay, cool. So I think that's really clean,  
28:11 - right? All you're doing is basically say, hey, 
just add the name. Okay, let's take a look.  
28:19 - Add name and now we don't really 
know, maybe it added maybe didn't  
28:23 - at least it remove the existing name. 
So that's a plus. So let's go and see  
28:28 - what we have that list of names to 
see if we actually added a name.
28:37 - Hey, pretty cool. So as you can see, use reducer 
is a nice way of managing more complex state. So  
28:47 - in this case, we have an object that has two 
keys in it, you can imagine you would have  
28:53 - an object who have a lot of data in it a lot 
of different keys, this would be a much nicer  
28:59 - way to do that. And you could go and take this 
reducer, pull it out of the component code itself,  
29:05 - and then test it independently and not have to 
worry about testing it through a React component.  
29:11 - So I think it's actually a really nice way 
if you have complex state to model that.  
29:18 - Alright, now one more trick I want to show 
you when it comes to use reducer, I really  
29:22 - like this one. So let's go and call this name 
list. And then we'll make another app component.  
29:33 - Then we'll use namelist in there. Okay, so we're 
gonna go and make ourselves a little user form.  
29:43 - And in here we're gonna have two 
input fields, first and last name.  
29:53 - So let's make a div. And then within that we'll 
have an input type of text. And at this point,  
29:59 - we'll just say that Our value is going 
to be some state and state at first,  
30:03 - and then we'll have state DOT last.  
30:09 - Okay, so let's use a reducer for that. So 
we'll say use reducer. And we won't specify  
30:16 - our reducer function quite yet. Let's go in and 
set our initial state to have first and last.  
30:26 - And then we'll get that 
state as well as a dispatch.  
30:31 - All right, great. Okay, cool. So let's 
invoke user form here and see if it works.  
30:39 - Nicely, I have two fields there, 
but they don't do anything.  
30:43 - So here's the trick. And I really love 
this one. So what we're going to do is  
30:46 - we're going to combine the state existing 
state with whatever comes in on the action.  
30:56 - Just like that, it's so easy. Fact actually, 
we can make it just a little easier.  
31:04 - How cool is that. And now what we 
can do is over here, in our onchange,  
31:13 - we can just dispatch with 
whatever key we want to change.  
31:19 - So we send the first then first overrides 
just first, but everything else remains  
31:24 - the same. And the same with last. So 
let's give this a try around last.  
31:32 - And now you have two fields. And let's prove 
it out. Let's go and put two divs down here.  
31:40 - First is first, is a dot first, 
and we'll make a new div for last.  
31:51 - Perfect. That's sweet. So you don't have to have 
a whole raft of C functions. Using this little  
32:02 - pattern here, you can manage very easily, large 
object state and make all the mutations that you  
32:09 - want. It's a nice pattern when it comes to use 
reducer. Alright, so next up, we're going to take  
32:14 - a look at two ways to observe state, use callback 
and use memo. So now that we know how to declare  
32:21 - state using use state and use reducer, let's talk 
about three hooks that allow you to monitor state,  
32:27 - that would be use memo, use callback and 
use effect. And in this part of the video,  
32:34 - I'm going to cover just use memo and use callback. 
So let's talk about use memo because I think it's  
32:39 - actually the most simple, yet somehow the 
most misunderstood. So I like to think of  
32:46 - use memo as use calculated value. So let's 
take a simple example of a list of numbers.  
32:53 - So here, we would define some state, we 
got 1020 and 30 in there in our array,  
32:58 - and we want to total it up. And in fact, 
we want to use that nifty reducer pattern  
33:03 - that we saw before. So how do we do that? 
Well, we could just do something like this.  
33:12 - We take numbers we call reduce on it, then 
with that accumulator, starting at zero,  
33:18 - we add each number in succession to that 
accumulator, return the new accumulator,  
33:24 - and then that gives us our total. So we 
just actually just put that down in here.  
33:31 - But of course, I need to bring 
a new state. So let's do that.  
33:37 - And I'll see like, oh, there we go. Total 60s 
1020 30. Together is 60. Makes sense? Now imagine  
33:45 - if you will, if this array was monstrous, huge, 
crazy, huge 1000s of values, well, we wouldn't  
33:53 - want to recompute that anytime that app rerender, 
which is what's going to happen here every time  
33:58 - react re renders our component, the entire 
function gets called. So we want to do is we  
34:03 - only really want to recalculate total when numbers 
changes. So let's bring in our friend use memo  
34:11 - or use calculated value, as I like to call it. 
So as he's my my work, well use metal it takes  
34:17 - a function and that function does the 
calculation. So let's do that first.
34:27 - Alright, so far, so good. And then it 
takes a list of dependencies in an array.  
34:34 - And this is where a lot of folks 
get into trouble. So basically,  
34:39 - anything that you read from should go into 
the dependency array. So in this case,  
34:44 - we are reading from numbers. And that means 
that we want to put numbers in the dependency  
34:49 - array and what this will do is it will only 
calculate this total only run this function.  
34:57 - Anytime numbers changes, and in this case, case, 
numbers won't change because we initialize it,  
35:02 - but we don't actually add anything to it or 
change it in any way. So let's run it again.  
35:09 - And there we go. So there are two times when you 
want to use use memo. And this is a really good  
35:14 - example of one of them. The first time you want to 
use use memo is when you're calculating any value  
35:20 - and the process to create that value, it might 
take a while. So any kind of complex calculation  
35:27 - that you want to do, and in this case, numbers 
could be arbitrarily large. So that qualifies, so  
35:33 - no matter what the output is, if it's a number or 
a string, or Boolean, another array or an object,  
35:40 - that's fine, you want to use use memo, whenever 
you've got a complex calculation that you don't  
35:45 - want to do on every render, you 
want to just be smart about it,  
35:48 - you want to make sure that you only run it when 
you need it. The other time you want to use use  
35:50 - memo is when you're creating an array, or an 
object. And that's because react compares arrays  
35:57 - and objects by reference. And so it's important 
to stabilize references, as we've seen before  
36:02 - in the start of this video. So references 
are really important, and you want to keep  
36:06 - those stable. So let me show you an example of 
that. So we'll start off with a list of names.  
36:16 - Perfect, The Beatles, John, Paul, 
George, and Ringo. Get up go by Oh,  
36:20 - that's awesome. And now let's go and 
sort those. So a great sort of names.
36:26 - And you know, it would just do an in 
place sort. And then let's help with that.  
36:37 - So now we've got the names, but you know what, 
I also want to put the sort of names there.
36:45 - Now let's take a look. Okay, well, that's actually 
just joined that all together using our comma.
36:57 - Okay, all right. So we've got a good sort of names 
on here. But we actually have the same sorted list  
37:04 - up here. So why is that the me we start with John, 
Paul, George, and Ringo. And then actually names.  
37:12 - Okay, so what's actually happening here is that 
sort is doing an in place sort. It's actually  
37:17 - mutating, named in place. So yeah, we're getting 
a copy of the reference to that array, but that  
37:22 - array has been sorted. So the first thing we want 
to do is actually copy names before we sort it.  
37:30 - And then we sort the copy. Alright, so now 
this looks good. We have our original names,  
37:34 - and we have our assorted names, and our original 
names haven't been touched. So let's go back to  
37:39 - the code. And let's see. So this is good. But 
every time this component re renders, it's going  
37:48 - to rerun this sword. That's not particularly 
bad in this case, because AP is only gonna  
37:52 - render the ones. So let's go and put in a use memo 
around this. Again, we'll make this a function.  
38:02 - And so what does this depend on? Well, 
it depends on names. So names changes,  
38:06 - we want to rerun that sort. So this use of use 
memo falls into both categories. And when I think  
38:14 - it would be important to use use memo. First, it's 
an expensive calculation, potentially, you could  
38:20 - have a very long list of names, and you don't want 
to read run that sword on every single rerender.  
38:25 - Awesome. It also falls into my second category, 
which is that it results in an array or an object.  
38:32 - So this is a really good use of use memo. Let me 
tell you about when I don't think you should use  
38:38 - memo and that's for very simple calculations, for 
example, was about adding two numbers together.  
38:45 - So now we got count one and count two. 
I'm gonna go add buttons for those.
38:54 - All right, looks good. Let's go to trial. 
Perfect. And now we want to get a total of  
38:59 - these two. So right now, that'd be around 
seven, right? So let's go in make a total.  
39:04 - So I'm going to create a count total. And I'm 
going to start off by using a memo and have  
39:13 - an add count one to count two. And then 
I'll just put that in the div down here.  
39:21 - Hey, nice. Okay, cool. I'm gonna get back to 
seven. How cool is that? All right. So this is  
39:28 - not a good use of use memo. And it's because the 
calculation is simple. And it results in a scalar  
39:35 - number or a string or Boolean, so you don't really 
have to use it at in this case, it's really just  
39:40 - overhead in this case. So all you need to do is 
just do an in place. Count one plus count two.  
39:48 - That's it. So now that you know what use memo 
is, let's talk about some of the myths around  
39:53 - it. The first myth around us memo is it is somehow 
connected to react memo to our in no way related,  
40:02 - so I'm not sure how that happened. I guess 
somebody was like us memo. They need to like,  
40:09 - somehow react memo. But it's not that it's just 
us memo is its own thing again think like use  
40:15 - calculated value and react memo which memorizes 
components and is a good performance enhancement  
40:22 - in certain circumstances is just completely, 
really unrelated. So the other myth that  
40:27 - I've heard about use memo is it is a performance 
killer. And I'm not really sure where that comes  
40:33 - from, I think it might come from the CS concept 
of memoization. So with classic memorization,  
40:41 - you memorize a function, and then that memorized 
function remembers every single set of parameters  
40:51 - that sent to it, and only if it sees a new set of 
parameters is a calculated new value, otherwise,  
40:56 - it will send back a value from that cash that 
it has and that cash could get huge get crazy,  
41:02 - the potential number of parameters you can send to 
it the combinatorial, and you just get like a big  
41:09 - data in memory hit use memo doesn't do that 
use memo is a single level memoization All  
41:16 - it's doing is basically saying, hey, let's look 
at this dependency, right? Is the dependency  
41:22 - array the same as the last time that I saw it? 
If it is, then I'm just gonna give you back the  
41:28 - last value that you created. Otherwise, I'm gonna 
allow you to create a new value for the new data.  
41:35 - And then I'm gonna hold on to that, but it's only 
a single level. So there really isn't any kind of  
41:41 - performance or memory hit when it comes to use 
memo. All right, let's talk about use callback.  
41:49 - So use callback is another kind of misunderstood 
hook. People don't use it when they should,  
41:54 - should use it when they don't need to. Let's 
try and demystify it a little bit. Okay,  
42:00 - so we have this list of names, right, John, Paul, 
George, and Ringo. And we have a sorted names use  
42:08 - memo. So let's go and create a generic component 
that sorts in a list of incoming strings.  
42:16 - We'll call it sorted list, you give it 
a list of strings, and it sorts them,  
42:21 - and then displays them. So first, let's grab this 
use mellowed out here, we're gonna need that.  
42:27 - And so it's now the sorted list. And it will 
depend on list. And then we will return a div  
42:38 - that has our sorted list joined. Cool. All 
right. So let's go down here and replace  
42:44 - this sort of names with a sorted list. And 
we'll give it the list, which is our names.
42:56 - And  
42:57 - it looks really good. And it's doing its sorting 
and everything still works. So looks good. So I  
43:03 - want to see how often this sort of list runs. So 
I'm going to make this into a curly brace function  
43:09 - and just return that sword. And I'll put it in 
my console log. Cool. And we can see that we are  
43:19 - running the sword twice. But that's because we're 
actually mounting the component twice. That's our  
43:24 - React 18 thing. When you're in dev mode in strict 
mode and react 18 Every component gets run twice.  
43:31 - So that's not a big deal. But let's go and click 
on all these buttons. And we can see that we're  
43:38 - not getting run anymore. This component 
is re rendering. I'm going to add that to  
43:48 - sorted list render. And now we can see that 
every time I click this count, we do get a  
43:53 - sorted list render, you can see that's 20, right, 
they're getting 20 times that call. By the way,  
43:58 - this is console ninja that's putting 
in the console in context like that.  
44:04 - Really excellent extension 
and it's free to try it out.  
44:07 - So okay, so now let's go and say that we want 
to make the sorted list a little bit smarter, we  
44:15 - want to be able to give this sort function a sort 
comparator. So let's say that you want to do your  
44:22 - string sorting somehow slightly differently. So 
we're going to allow you to have a sort function  
44:32 - and we're going to send that 
sword function on to sword  
44:37 - and now we got to define that sword function. 
So down here, we will define our sword function.  
44:45 - And we will say that we are going to take two 
strings, and we're just going to compare the two  
44:51 - and we'll pass that sort 
function on to our sorted list.
44:58 - Nice and So this sorting still works. In fact, we 
can, let's see, you just multiply this by negative  
45:04 - one. And now we get the inverse, we get Ringo, 
Paul, John George. But we've actually messed up  
45:10 - because we don't have our sort function in our 
list of dependencies. Because if sort function  
45:15 - were to change, we were to give it a different 
algorithm, we would want a different result. So  
45:19 - let's go and add that to our list of dependencies. 
So now, let's hit this button a couple of times.  
45:27 - And now we can see that every single time we 
render, we also run sort. So what's happening  
45:37 - there? Well, what's happening there is that every 
time that we rerun app, which is every time we  
45:43 - click that button, because we set the state, the 
state then says, you need in queue a rerender,  
45:50 - of the app component, that then reruns this 
whole component all the way down the line.  
45:56 - And we create a store function. And 
then we pass it on to our sorted list.  
46:03 - And now the sword function is the 
same implementation each time,  
46:09 - we're not changing the implementation. But we are 
changing the reference every time. We're creating  
46:16 - a new function every time that we go through this. 
Now, is it any different if it were to do this?  
46:23 - Is there some magic in React that will make it 
so that that's not a problem? Oh, let's try.  
46:33 - Nope, still gets called every single time. So 
there's no difference between doing it in line  
46:38 - like this. And having it called out like that? 
So how do we stabilize the reference to that  
46:46 - sort function, so that when we get down here 
to our dependency array, we keep seeing that  
46:52 - the search function is the same every single 
time? Well, one thing to do would be just  
46:56 - to pull this out of the function entirely. Up 
there, now we've got this global sort function.  
47:04 - Give it a try. Alright, so that works, we're 
not getting a complete one to one match between  
47:10 - rendering and running that sort. But I'm not 
super happy about having this outside of the  
47:16 - component like that. I don't think that's all that 
clean. I'd rather have it where I had it before,  
47:21 - right in the component. So how do we do 
that? Well, we can use use callback for that.
47:32 - So you can wrap this function and use callback.  
47:37 - And then what's the dependency right? 
Well, the dependency array in this case,  
47:41 - is empty. Because we're not actually using any 
data that's in this function. We're not using  
47:48 - total or names or count or any of that this 
is just a simple stock comparison function,  
47:55 - we just want to make sure that that reference 
remains the same over time. So we're just going to  
47:59 - use an empty dependency array there. That way we 
only ever create sort func once. Let's hit save.  
48:06 - Try it again. Hit a bunch counts. And there 
we go. Now we have a stabilized version of  
48:12 - our source function. And we will only ever call 
sorted list appropriately if the list changes  
48:18 - or the search function changes. But we're 
not going to rerun it on every single go.  
48:23 - So that's why use callbacks important. So when 
should you use use callback, when you should use  
48:28 - use callback if the callback you're creating 
like unclick or the unchanged or whatever is  
48:35 - going on to a nested component has a property. 
So in this case, we're passing sword function  
48:41 - as a property to the sorted list. And you 
don't know the internals of sorted list.  
48:49 - Maybe it depends on that sword function. And if 
that sword function reference changes, it's going  
48:55 - to go and update. So make sure that you stabilize 
references that you send to a React component. If  
49:03 - you're just using a simple HTML element like 
input, you don't need to use use callback for  
49:11 - something like onchange. It's overkill. The other 
time that you want to use use callback is if you  
49:17 - are creating a custom hook, which we'll get to in 
just a bit. Anytime that you create a callback in  
49:23 - a custom hook, you want to make sure that you use 
use callback to do that because you have no idea  
49:28 - what the component that's going to use that hook 
is going to do with that callback. And you want to  
49:35 - make sure that the reference to that callback is 
absolutely stable over time. Alright, so the next  
49:41 - thing we're gonna take a look at is everybody's 
favorite hook use effect. So let's talk about  
49:45 - use effect. Everyone's favorite hook. It's not 
actually that complicated, but it does have a lot  
49:51 - of foot gun potential. In fact, it's the hook 
that is the one that's most often the culprit  
49:57 - when it comes to infinite loops. inside of React 
apps. So let's talk about how to do it right,  
50:04 - and how to avoid those pesky infinite loops. So we 
have a VT app here, it's called native user fact,  
50:11 - it's checked into the GitHub repo in the source 
linked in the description down below. And this  
50:16 - is our starting point. So it's just a standard VT 
app. Currently, app was nothing. But we do have  
50:25 - some extra stuff in here in the public directory, 
we got a list of names Jack, Jill and Jane. And  
50:31 - then we have corresponding JSON files for each 
one of our people. Not a particularly great API.  
50:38 - But one of the things that we use use effect 
for a lot is to make API requests. So let's  
50:46 - do that. Let's actually use a combination of 
use state and use effect to fetch the names.  
50:56 - So first, we have to define our 
data. And that will be our names.  
51:02 - We'll start off with an empty array. 
And then let's just print it out.  
51:08 - Let's take a look. And now I currently have 
names with nothing, because we have an empty  
51:14 - array over here. So let's go populate that 
array. Well, one way we could do that would  
51:19 - be to do fetch right here. Let's go and get our 
names at JSON. Then we get our response back.  
51:32 - And then we set the names. He's easy, 
lemon squeezy, we'll take a look. And  
51:38 - there they are. Ah, oh, wait, hold on. 
What's going on here? Oh, oh, wow. Yeah,  
51:46 - we blew up. So here's what's happening. So a 
render app app, then declares that state names,  
51:53 - then starts a fetch, then that goes off and 
asynchronously runs, we then return our HTML with  
52:04 - our names in it. Eventually, this fetch responds, 
we then get this asynchronous then where we get  
52:11 - the JSON out of it. That again, asynchronously 
responds, then we do this, then here, where we  
52:18 - then set the names, which starts the whole process 
over again, because what set names does as we know  
52:24 - from before, it sets the names a state, and it 
in queues, a rerender. So it redraws the names,  
52:31 - which in turn, runs app, which in turn now goes 
and gets the new names that we got. So yay, we're  
52:38 - cool. Good for that. But then we start another 
batch right away, and so are in an infinite loop.  
52:45 - So how do we get around this? Well, we use use 
effect. And use effect would allow us to say,  
52:50 - hey, only go do this thing once. So what 
does use effective? Well, it takes a function  
52:56 - that is going to call once the Dom has rendered 
or really whenever react wants to call your use  
53:04 - effect, but not going to call it right away, 
it's going to hold it and then call it whenever  
53:12 - it wants to when the dependency array changes. 
So let's put our fetch inside that. And then  
53:20 - for a dependency array, we'll just use an empty 
dependency array. We're not depending on anything,  
53:24 - we're not reading anything inside of this 
user fact. So we don't have to put anything  
53:30 - in the dependency right? So let's save that 
out and see, is this gonna work? thing? Oh,  
53:35 - it works. And it's rock solid, stable. How cool 
is that? Yay. Now it actually does go and fetch  
53:44 - names dot JSON twice. So let's talk a little bit 
about why that's happening. And why that's not  
53:51 - really a huge problem. So what's happening is with 
React a team, every time it renders a component in  
54:00 - dev mode, with strict mode enabled, it mounts 
it, which renders it, it unmount it, which,  
54:11 - in the case of a use effects should call 
a cleanup function if we define one,  
54:14 - but we haven't defined one here, and then 
it remounts it again. And that remounting  
54:22 - calls that use effect again. So we get called 
twice. And a lot of people freaked out about this  
54:29 - and wasn't very, we're very happy about it. But 
that's what it is. So if you want to not do that,  
54:36 - you can actually disable that by removing 
strict mode from your app over in the  
54:41 - main dot JSX. Again, this only happens in dev 
mode. It's not gonna happen in production, but  
54:47 - I do got tweaked about it. So 
there we go. So let's try it again.  
54:52 - It refresh and now we only get named JSON, the 
ones right now the use of what we have here is  
54:58 - not an infinite loop. This is a saw to use 
effect, a good pattern. Let's go and kind of  
55:04 - build on this by taking names and turning into a 
list of buttons. And when we click on the button,  
55:10 - we'll go and load the corresponding data. And 
that will show us how to use a dependency array  
55:15 - with our use effect and do it safely. So we'll 
start off by mapping our names into buttons.  
55:23 - We'll turn these into buttons. So now when we 
click on one of these, we want to say that that  
55:28 - is our new selected name. So we need some state 
to store that. So let's call that selected name.  
55:37 - And we'll start off at null. And 
then if you click on that button,  
55:41 - we're going to set that selected name 
to whatever name you just clicked.
55:49 - And just to check if this works, 
let's put that in a div down here.  
55:55 - Jack Joel Jain perfect, works great. Okay, so now 
we want to do is we want to go and get the data  
56:04 - when this selected name changes. So let's go and 
build a use effect where we look at selected name.  
56:13 - And then we fetch whatever name that 
is. So we'll use a template string here.  
56:20 - And then we'll give it the selected name dot JSON. 
And what's the so we need some place to store the  
56:27 - data. So we need a data for that selected person 
will call that selected name details. And so down  
56:35 - here, instead of set names with the response back 
from the JSON, we'll do set selected name details.  
56:42 - And we'll just take that data cool. 
And now we've got our data in there,  
56:47 - I'll take a look. So in the div down here, and we 
will JSON string five. And because it's an object,  
56:54 - and react doesn't like when we just render 
objects directly, so let's JSON stringify that  
57:01 - put in our selected name details and see we get 
all right, so we start off with no, that's good,  
57:07 - because we start off with our selected name 
details as null over here. And then as you cook on  
57:12 - Jill, we set the selected name to Jill, that then 
triggers this use effect because this selected  
57:22 - name, which is now Jill, is different from what 
we had before, we should know. So we have an array  
57:27 - with Nolan it now we have an array with Jill 
in it. And so that triggers that use effect.  
57:34 - But here's an interesting little side note, 
we also got a no dot JSON request. So what the  
57:40 - heck's up with that? Well, what happened there is 
that we started off with the selected name it No.  
57:46 - And then we came down here and react 
said, Hey, cool. So we're loading.  
57:52 - We don't know what was in that dependency right 
before root didn't have a dependency right before.  
57:56 - So whenever you're gonna have in here is gonna 
be different. So the dependency array had an  
58:01 - array with no one it. And so it ran you that 
our use effect with a selected name that No,  
58:09 - which is not what we want. So all we need to 
do to get around that is then to just bracket  
58:16 - this in a an F, and say, Well, hey, only go get 
the data if we actually have a selected name.  
58:24 - So there we go. But now that 
I've shown you all this,  
58:30 - this is actually the wrong way to do it. Because 
really, we are responding to a user event here,  
58:35 - we're doing this onclick we have our data right 
there, what we should do is we should do it  
58:43 - right in the callback. So instead of having 
the selected name, and then the use effect,  
58:52 - what we should do instead is create a 
callback, called like on select name.  
58:58 - And this is going to be a name. And 
then we'll just go and fetch that name.
59:10 - Now we can get rid of all this use effects stuff.  
59:15 - And over here, we will just call that 
on select a name change with the name.  
59:22 - And let's see how it works. Perfect, and very 
reliable and no potential problem with use effect.  
59:32 - And this is something I see a lot where folks 
use a combination of state and to use effect,  
59:38 - when in reality, they're just responding to 
some user interaction and they should just go  
59:45 - and do the action. Right at that point. It's the 
simplest thing to do. And it's the right thing to  
59:51 - do in this case. So you really want to as cool 
as US fact is limit the amount that you use it  
59:59 - to justify things where you need it, like, 
for example, this use effect up here. Okay,  
60:05 - so let's talk about when use effect gets a little 
bit hairy. And that's when use effect depends  
60:12 - on data that it also writes. So to experiment 
with that, let's create a stopwatch component.  
60:21 - And what this stopwatch is going to do is 
it's going to have a an incrementing time.  
60:26 - So it starts off at zero and it just 
every second goes up by one. So return  
60:35 - a div that has time  
60:39 - with a timer on it. So far, so good. So let's 
bring that down in here, and we'll use it.  
60:46 - There we go. Time is zero. Cool. So what do we 
need to do to get this going? Well, we need to use  
60:53 - a set interval. So now we know that we're going 
to put a set interval right here, and just set  
61:00 - the time to the time plus one, and then do 1000, 
that just like that fetch that we had before,  
61:07 - you're going to run into an infinite loop. Because 
every second, we're going to set that time,  
61:11 - that setting at the time is going to force 
a rerender of the entire stopwatch function,  
61:18 - which is going to get the new time, Yay, it's 
gonna be one. And then it's going to run another  
61:23 - set enroll, which is going to create lots and lots 
and lots and lots of intervals. So we don't want  
61:29 - to do that. Well, we want to go and create one 
interval. So let's go and use use effect for that.  
61:37 - And we know from before that we want to 
create an empty dependency right here,  
61:41 - because we only want this 
interval to get created once.  
61:45 - So let's try this out and see 
this works. So I'm gonna hit Save.  
61:51 - And now we go from zero and we got a one. We stick 
there. So what's the deal? What's what on console  
61:58 - log, and see what's up. So we'll do console dot 
log. And we'll just put in time, well, what's  
62:03 - time, because that should be going up and up and 
up. Right, that number. So it's it save to go,  
62:10 - zero to one. But if we look back at our code, we 
can see in the console, which is out here, with  
62:17 - console ninja, we're just getting a time at zero 
over and over and over again. So what's happening?  
62:24 - Well, what's happening is that we first 
initialized this effect when we got our  
62:32 - initial component render, and at that time, 
time value was zero. And what JavaScript did  
62:39 - was we created a closure here, and we captured 
time, zero. And so now inside of this function,  
62:51 - time is forever going to be locked at zero. So 
what's one option? Well, we could go and add  
62:59 - time in there as a dependency so that when time 
changes, we rerun this, and we get a new value  
63:06 - for time. But that's going to run into the same 
infinite loop problem, because we're going to go  
63:10 - and create interval after interval after interval 
after interval. Another option is that there's a  
63:18 - secondary way to call a setter on use day. One 
way is to just give it the new value. Another  
63:29 - way is you give it a function, and that function 
takes the previous value, and then you get to  
63:35 - return whatever the new value is. So in this case, 
that would be time plus one. So let's hit Save.  
63:42 - And now we have a working timer. And if we 
were to go into here and put in a console log,  
63:50 - we would see that this number for time, the actual 
current value goes up and up and up. And in fact,  
63:57 - I can make this a little bit easier to 
understand by just putting in like, for example,  
64:00 - like T to distinguish it from time, because time 
is captured, then this function, but T is just  
64:08 - the current value for time. And there's one more 
thing to know about use effect. And that's that  
64:15 - the function that you give us effect can return 
a cleanup function. And that cleanup function  
64:21 - we had called whenever the all these effects 
is getting kind of unmounted or gotten rid of,  
64:29 - and the new use effect is coming in. So in this 
case, what we're going to want to do is we're  
64:35 - going to want to clear that interval that we've 
created. So I'm going to capture that interval ID  
64:43 - and then I'm going to return a cleanup function. 
Or I clear that interval. And that makes this  
64:51 - a solid timer interval. I asked actually this 
question a lot when it comes to interviews and  
64:57 - if you were to give me this code, probably mine 
is that console Ugh, definitely give you a passing  
65:02 - grade on your interview. So of course, there's 
a lot to understand and know about you the fact  
65:07 - but use the fact that is really important as 
you build your own custom hooks. Or if you just  
65:12 - want to use React Native state management as the 
state management foundation of your application,  
65:18 - use effect is the kind of thing that you're going 
to really need to become familiar with. And make  
65:24 - sure that you are very comfortable with it, yes, 
you can get yourself into some serious hot water  
65:29 - with use effect. But in all honesty, it is an 
understandable thing. And when you understand  
65:35 - the fundamentals of JavaScript and how they work 
with use effect, it actually is a lot less spooky,  
65:43 - so just spend a lot of quality time with it. 
And I swear, you will get a lot better at it.  
65:50 - I mentioned early on that there was this other 
way of storing state in a component called use  
65:55 - ref. So we'll take a look at that next. Okay, 
let's take a quick look at use ref. It is one  
66:00 - more way to associate state with a component 
in React. The interesting thing about use ref,  
66:05 - though, is that when you change the value of a 
reference, it doesn't actually cause a component  
66:11 - rerender. So that can be convenient in some cases. 
But there's actually two ways that folks use use  
66:16 - ref. So let me show you the first way, the most 
common way, and then I'll show you about the state  
66:21 - management side of it. After that. This is the 
native use ref folder in our GitHub repository of  
66:29 - applications. We're looking over there. So I'm 
gonna bring in use ref. And the first thing I'm  
66:35 - gonna use it for is, I think, the most common 
use case, which is to get a reference to an  
66:39 - HTML element. So in this case, we'll create an 
input element and then get a reference to that.  
66:45 - So we have this text element. And now we want to 
set focus on that input when it first starts up.  
66:52 - So I'm going to create a ref, a reference to that 
element by using use ref and then just starting  
66:59 - off with the initial value of No. And then I will 
use ref equals, and then just give it that graph.  
67:08 - Now let's see if this works. Okay, it looks 
good. We can go and add stuff in there.  
67:14 - But what we want is we want that input to be 
initially given the focus, so they get the  
67:19 - little blinking cursor in there when it starts 
up. So how do we do that? Well, we need to one  
67:24 - know that the reference is defined as something 
that means that the component will have rendered,  
67:32 - and then we will have gotten a reference to that 
element. And the way that we know that is if we  
67:37 - use a use effect, because use effect runs after 
all that happens. So let's bring in user fact.
67:49 - And we want this to only happen once. So what 
do we do, we give it an empty dependency array.  
67:56 - And then within that dependency array, we just 
focus on the current. So what is current? Well,  
68:03 - when you have a reference, you have a current 
value associated with that reference. You don't  
68:10 - just do input ref dot focus. Because input ref 
is itself, just a pointer to current and current  
68:19 - is the thing that you can set or read from. So 
let's hit save, see how we do. And now anytime  
68:27 - that the page refreshes, we automatically 
set focus to that element. So super easy,  
68:32 - nice. That is the way you get access to elements 
in React. And that's the primary use of user.  
68:41 - But there's another use, and that is to maintain 
state without doing any updates. Let's build out  
68:47 - an example here. So we're going to have a list 
of names. And then we're going to use this input  
68:51 - fields to go and add a new name to our list of 
names. So let's get that all set up. So we have  
68:58 - our use date with our empty array of names 
to start, let's go and put that into a div.  
69:04 - Cool. So now we need a button 
that we can use to say, hey,  
69:08 - add this name that we just typed into 
this list. So let's create an on ad name.  
69:16 - And we'll assign that to the onClick. Now remember 
from before, when I talked about use callback,  
69:22 - we're not using a use callback here because 
I'm just passing this on Add name function  
69:28 - to this HTML element is not its own React 
component. So I know exactly what's going  
69:36 - to happen with that unclick it's not going 
to create any kind of referential identity  
69:41 - problems like we would have with passing that on 
Add name to a nested React component that may do  
69:48 - I don't know what was that on Add name. Now 
we need to do is we need to go and set names  
69:56 - to the current names plus, the value of this 
component was pretty cool, right? Because we  
70:06 - already have a link to this input. Or we can just 
reach out and grab it. So we can say, okay, cool,  
70:14 - get the value from that component. This is called 
an uncontrolled input in React. And it's actually  
70:20 - the most efficient way to manage an input. 
You don't have to use that set and get value.  
70:27 - And then one last thing we can do is we can just 
set that value to an empty string. Cool. So let's  
70:33 - give this a try. Oh, looks like it's blown up. 
Let's see why. So I got my name inspector console.  
70:41 - We didn't bring in new state. Make sense? 
Okay. So let's get back over here. Use state.  
70:46 - Cool. And there we go. All right. So Jack, and 
name Hey, wow. So what about use ref? In this  
70:55 - world? Well, let's say instead of having just the 
names, each one of these had like Id one is John,  
71:05 - and Id two is Jane. So you have an ID and a name. 
So it's not just a name, it's structure. And let's  
71:16 - go make names. Sing that tune. So this is going to 
be name. And then name dot name. On exactly great,  
71:24 - fine. Okay, looks good. So now there we go. 
But now when I do add Name, foo, this is gonna  
71:31 - blow up because add name, I'm just adding the 
single value, right, I'm just adding a string,  
71:38 - what we really need to do is have an ID with 
something that's a 10. Right now, and then a name.  
71:47 - There we go. So we want to track this ID, and we 
want a an incrementing ID auto incrementing ID.  
71:57 - So that's where something like use ref is going 
to come in handy. We don't necessarily want to  
72:02 - use use date for that ID because we don't really 
care that the UI gets updated when we change that  
72:10 - value. So we can just manage the ID using a ref. 
So let's create that Id ref by using use ref and  
72:21 - then starting it at one. And now down here. We can 
just use ID ref dot current. And we can just treat  
72:28 - it like a value i current Boss Boss. Let's take 
a look. Current Boss, boss. Nice. And then down  
72:35 - here. Current Boss, boss. Awesome. And just to 
check, let's go in add in the name.id down here.  
72:43 - All right, so there we go. Yeah, one is John. Two 
is Jane, just like you set up right here with the  
72:48 - one and the two. And then we have Jack, let's 
see what I get. I get three. How cool is that.  
72:56 - So you can set this value current without forcing 
a refresh of the React tree, which is great. Of  
73:04 - course, we matter. In this case, since in all 
honesty, I just on Add named as a set name, which  
73:11 - in turn actually still rerender the component but 
I think in some cases is valuable to hold state  
73:17 - in a use ref like this. And it's just good to 
know that that's there, if you need it. Next up,  
73:22 - we're gonna start finishing up our look at Native 
react state management, by getting into context,  
73:28 - and also creating your own custom state management 
hooks, exciting stuff. And that's going to  
73:33 - culminate in us building our own pokimane search 
application seems like it's time to start wrapping  
73:39 - up React Native state management, before we get 
into indirect state management, like React query,  
73:45 - and and state managers like Redux and Joe 
tie and all those. But before we do that,  
73:51 - we need to talk about context. And we also need 
to talk about custom hooks, because those are  
73:58 - the ways to kind of package and redistribute 
state in a native react state management model.  
74:06 - We also need to talk about TypeScript. So you 
might have noticed that I haven't been using  
74:11 - TypeScript up until well, now. And the reason 
is, because I want us to focus on the model of  
74:19 - state management and learning about the reactive 
nature of state in the native react state model,  
74:27 - declaring, say, using new state and use reducer. 
And then monitoring state using use callback,  
74:34 - use memo and use effect. But now it's time to 
talk about TypeScript. Because in reality, you're  
74:41 - probably going to want to use TypeScript when 
you're using almost any state management system,  
74:44 - including React Native state management. 
So from here on out, we will be doing  
74:49 - TypeScript. So now the native context app that 
you're looking at right here is basically the same  
74:57 - thing we've been looking at so far. Except that I 
use the react dash TS template, invite the bullet.  
75:04 - So it's the TypeScript version. And I've also 
added tailwind and a Pokemon JSON file that has a  
75:13 - list of Pokemon in it, including what was or which 
apparently is a grass and poison, and Pokeyman  
75:19 - has all these stats. And we'll be using this 
datasource going forward, as we take a look at  
75:27 - how to actually put all of what we learned into 
practice. So that starts with learning about  
75:33 - custom hooks. So let's go and build ourselves 
a custom hook to go and get that pokimane data.  
75:41 - So what are the things we're no we're gonna need, 
or no, we're gonna need state, we're gonna have  
75:46 - to hold it. So let's bring in use state. And we 
also know that custom hooks start with the word  
75:51 - use. And so I guess I'll just say use Pokeyman as 
the name of this custom hook, and custom hooks are  
75:57 - implemented as functions. So let's create our 
use boogeyman function. Now, I don't think it  
76:01 - needs to take any arguments, we just have used 
boogeyman, and it will have a list of Pokemon  
76:07 - that it will then return. So now we have our 
state, we'll initialize it to now in fact,  
76:13 - actually, let's be nice, let's initialize it 
to an empty array. The next thing we need to  
76:19 - do in our use Pokemon hook is to use an effect 
to go and do that fetch. So let's try that out.
76:31 - So use a fact takes a function, 
and also takes a dependency array,  
76:36 - we only want to load the Pokeyman once, so 
which dependency already we use, we use an  
76:41 - empty dependency array. So now let's do our 
fetch. And we'll get our local Pokeyman json file  
76:52 - which will then convert the response on and 
take the data, and then we'll set the Pokemon  
76:58 - with that data. But of course, we don't 
have set pokemons I was gonna add that.  
77:06 - And now just give it the data. So now we have 
a problem that we don't actually see yet,  
77:11 - which is that that type of Pokemon 
isn't what we expect type boogeyman is  
77:16 - a never array. So what does 
that mean? Well, it means that  
77:22 - TypeScript can't infer what this array is 
going to be. So it defaults to saying, well,  
77:28 - never can have an empty array, it has to be empty 
for its whole life. That's the only thing that I  
77:34 - can guarantee about. So we need to define what a 
Pokemon looks like. And then tell you state that  
77:41 - is going to be an array of that. So how do we do 
that? Well, we define an interface for Pokemon.  
77:48 - So we look over here, Pokemon JSON and got ID 
name type, which is an array of strings. And  
77:53 - that corresponds to this interface, ID name, type, 
which is an array of strings, and then all of the  
77:59 - parameters for that book came out. And now with 
this interface, we can then tell you state that  
78:06 - this is going to be a pokey Monterrey. And the 
way that we do that is we use the generic syntax,  
78:11 - and then we put in a Pokemon array. And now if 
I look over here at Pokemon command, Caveman AI,  
78:17 - we are getting back a pokimane array. But if 
you're like, shouldn't have been able to infer  
78:23 - the type of the Pokemon from Polygon JSON. I 
mean, yeah, it's sitting right there. Well, no,  
78:31 - because we get Pokemon JSON at runtime. So it has 
really no idea what the structure of that is until  
78:38 - we tell it what the structure of that is. So this 
is your first lesson in native react hook typing.  
78:45 - Honestly, it doesn't get a whole lot more complex 
than this, you notice that there is no typing on  
78:48 - user fact, there is no typing on this use Pokeyman 
hook, we could add return typing if we wanted to  
78:54 - by just saying we're going to have a list of 
Pokemon, which is going to be either an array  
78:59 - of Pokemon or no, but honestly, par is going to 
have an array Pokeyman. And but that's it. So  
79:07 - you really don't have to use TypeScript a lot 
when it comes to react state management. Okay,  
79:14 - so let's see what we're getting back. Let's do 
use pokimane down here, and we'll get our broken
79:24 - and the easiest way to do this and just find out 
is this a JSON stringify it and let's see we get  
79:33 - and we get a whole bunch of data. Nice. 
Love it. So now we got our data source.  
79:39 - Let's say that we want to go and make 
a Pokemon list that shows Pokemon.
79:48 - So it's gonna take Pokeyman as a prop, and that 
Pokeyman prop is going to be an array bogeyman.  
79:55 - And you know what, let's do it a little bit 
nicer reformatting. And this will create a  
79:58 - div. We'll map through our Pokeyman 
we'll create a div for each one. And  
80:03 - let's try this out. So we're going to do 
Pokemon list and then give it a Pokemon.  
80:11 - There we go, a nice list of boogeyman a long 
list above, what if we don't want to have to  
80:18 - prop drill everything, because here we're doing 
what's called prop drilling, we're taking data,  
80:22 - and we are sending it down as props. Maybe this 
Pokeyman list is deep inside of our hierarchy  
80:28 - of React components. And we don't want to have 
to go and grill that Pokemon property all the  
80:35 - way down. And maybe we have a bunch of different 
components that use boogeyman and we just don't  
80:39 - want to have to shuffle that data all round is an 
easier way to do that. And the answer is yes. And  
80:45 - it's context. That's what we need to do. We 
need to provide this put your own data down  
80:52 - to anyone who wants to use it. And the way that 
we do that is we route it through context. So we  
80:56 - need to create some context. So the first thing 
we need to use out of React is create context.  
81:06 - And you know what, I'm just going to start off 
looking at context, just by creating, like,  
81:12 - very simple context, we'll just say like 
a theme provider or something like that.  
81:17 - So we're going to create a theme context.  
81:22 - Okay, so now how do we use this theme 
context? Well, we need to wrap components  
81:27 - that consume the context with a context 
provider. And when we do that, is we  
81:35 - instantiate a theme context dot provider. So 
automatically, when you do create context,  
81:41 - you get back a dot provider, and it's a React 
element that you can use to provide value down any  
81:48 - specified value by just specifying the prop for 
the value. So in this case, we're gonna say dark  
81:55 - is the value the current value, it starts off 
defaulting to light. So now how do we consume  
82:01 - this, let's just give it a try. Let's 
go over into pokeymon list and try and  
82:04 - see if we can consume theme context. 
So I can show you how Rao's around.  
82:08 - So we'll bring in the use context 
hook, which is how you access context.  
82:16 - And in this case, we're just going 
to get the theme by using that use  
82:20 - context hook and pointing it at that theme 
context. So let's see what the theme is.  
82:27 - And the theme is dark, nice. If I go 
over here, and I change that value to  
82:33 - light, our theme is light. And we can see that we 
don't actually have to prop drill down the theme.  
82:42 - We just have that theme context. And wherever 
we want to use that theme. We just use context,  
82:48 - we give it the context, and we get 
the value back. Okay, so obviously,  
82:53 - we don't want to do theming. Or maybe we do, 
you can do that for yourself if you like,  
82:57 - what we want to do is use this pokemon data. 
So we're gonna provide this pokemon data  
83:04 - down to the rest of the application through this 
context. So I'm gonna call this pokemon context.  
83:13 - And okay, so what are we gonna put in there as 
a starting state, what we could do is, we could  
83:21 - say that we have just a, an array of Pokemon, 
because that's the output of what is of this use  
83:27 - Pokemon here. And let's see, does that work? So 
Pokemon context, let's go down here to the context  
83:35 - generator, look at my context was given a value 
value is going to be the output of us Pokeyman.  
83:47 - Looking pretty good. Now, we don't have put 
him on there. So we actually get rid of it.  
83:52 - And now we can pick up Pokemon from the boogeyman 
context. And so I'll rename this pokemons GTX.  
84:04 - And if I look at that, then the context 
is an object where we have Pokemon.  
84:11 - But it's a little easier. This is beauty Pokeyman.  
84:16 - And there we go. Well, we don't have a theme, was 
it? Let's get rid of that. All right. Looks good.  
84:22 - Nice. So now using context, we can see that we 
can move around all that data without doing any  
84:30 - properly. But there's a few things that I don't 
like one, I don't like to use context directly.  
84:36 - So I want to make a hook that gets us access to 
that context data that's named appropriately. And  
84:44 - unfortunately, use Pokeyman is kind of camping 
on that name, because use Pokeyman would be a  
84:49 - really good name for that hook. So what I'm 
going to use, instead of use Pokeyman Well,  
84:55 - we could do something like use Pokemon source 
that kind of works through that. So down here,  
85:05 - this is going to be the source hook that has the 
data in it. And then we can do something like,  
85:13 - define us Pokemon, by just returning 
the US context from the Pokemon context.  
85:20 - And now down here, we can just use bogeyman. 
Alright, it's starting to look a little cleaner,  
85:26 - I like that. And now there's one more fix up, I 
think we should do around this context sharing  
85:31 - mechanism, before we get into actually kind of 
fleshing out this app and using all of the other  
85:35 - hooks that we've seen. So the first thing we need 
to do is get the typing right, on create context.  
85:41 - So the way that we do that is 
to use that generic syntax.  
85:45 - And what are we going to have in our context, 
where we're going to have the return type of the  
85:51 - US Pokemon source function. So this is us poking 
around source, we're gonna have the return type of  
85:56 - that. And it's either gonna be that or undefined. 
So now we can just set this to undefined.  
86:05 - Now, the problem is that the 
output of us Pokeyman is either  
86:09 - all of the cool stuff that we got from us 
boogeyman, source, or undefined. And so down here,  
86:15 - as we use it, it's like, Ah, you could be 
undefined dude. And you're not handling that.  
86:20 - But we know that it's always going to be valid, 
we know that we're always gonna have a value.  
86:25 - So one thing we could do is, we could just use an 
exclamation point that basically tells TypeScript  
86:29 - Hey, it's always gonna be not undefined. 
But another thing I've seen people do,  
86:34 - and I'm kind of torn on whether exactly this 
is the right idea, but I think it's fine is to  
86:39 - instead of allowing for undefined, so we just go 
back to something like this. We just take an empty  
86:45 - object. And we can take that empty object Intel 
and why basically, to Typescript and tell it that  
86:52 - it is a return type from that use pokemons source. 
So the way that we do that is we say as unknown.  
87:01 - And then as the return type of use pokemons source 
comm I have to go through this two step with  
87:06 - TypeScript. You know, honestly, once you get this 
set up, you won't really see most of this typing,  
87:12 - and you'll just be using it and it'll be fine. 
So little hacks like this aren't necessarily that  
87:19 - tough, you're only gonna have these a few 
places in your code base. Alright, well,  
87:24 - I think we got a pretty good start. Here, we have 
our Pokemon data. And we've got tailwind, we have  
87:28 - a bunch of knowledge about these other hooks that 
we can use. So we can make an application that  
87:34 - gives us a searchable Pokemon index. That even 
looks pretty cool. Alright, we'll do that next.  
87:41 - Alright, we're starting off at exactly the 
same point, I've just taken the native context  
87:46 - directory and cloned it to native Pokemon. 
So if you're following along on the GitHub,  
87:51 - this is the native Pokemon app. And what we 
have is we have a list of the Pokemon cool.  
87:59 - So the first thing I want to do is kind of 
refactor this a little bit, it's get a little  
88:02 - messy. So I'm gonna go and take all of the 
stuff that's related to the data the store,  
88:07 - and I'm gonna pull that out and put it in 
its own file, we'll call that store dot TSX.  
88:15 - Pop that all down in there. Alright, so what do 
we need out of here? Well, we need most of it,  
88:19 - actually, we need to use boogeyman source. And we 
need put you on context. And we need use Pokeyman.  
88:27 - Cool. So now let's go back over 
here, and get rid of all of that.  
88:36 - And then import it from that store.  
88:47 - Not too shabby. Let's hit save, try, refresh.  
88:50 - Refreshing. I love it. But there's one thing I 
am not quite sold on. I don't like that the app  
88:56 - is having to maintain this connection between us 
working on source and Pokemon context provider.  
89:01 - And I think we can kind of hide that elegantly. By 
making a Pokemon provider component, I think it's  
89:07 - actually pretty easy. So let's go over here to 
our store. And then we will export a new component  
89:17 - called Pokeyman provider, which will take children  
89:23 - where those children are a React node type. Now 
put our children in there. And now we can get  
89:31 - rid of the export of the Pokemon context, as 
well as the export of the US Pokemon source.  
89:37 - Nobody else needs to know about the US. So let's 
bring in Pokemon provider over and out on TSX.
89:45 - And here we go. Nice. Again, let's try it out. 
Very good. Cool. So let's make this a bit swanky.  
89:56 - Right. So the first thing we're going to do is 
we're going to wrap the whole Have in a centering  
90:02 - tag. And tailwind, that means setting the max 
width of the screen and then auto, the x axis. So  
90:10 - MX auto, kind of bring it in from the sides. Let's 
take a look at that up. Nice, very cool. So now  
90:16 - it's kind of in a little bit. So now we're gonna 
model pokeymon in an HTML sense as a list item. So  
90:25 - in order to bracket that, you have to have a UL 
or an unordered. list. And so for our tailwind,  
90:30 - we're gonna say that this is a grid. And let's 
take a look, see how that goes. Pretty good, nice.  
90:38 - And then we're gonna bring in a bunch of HTML, 
which is going to format our pokimane. And,  
90:43 - of course, all of this code available to 
you in GitHub for free. I'm gonna type  
90:47 - it all in because there's a whole bunch of 
tailwind, but I do need to go and add a key.  
90:53 - And let's take a look. Wow, that's pretty 
cool. So the next thing we want to do is  
91:00 - have a search box. So I'm going to create a 
search box up here. And we're going to provide  
91:07 - for searching so let's go and create a 
component for this called Search box.
91:15 - And we will return input tag in there, give it 
some nice tailwind Ng, and we'll take a look. Ah,  
91:25 - whoa, that's good. Looking already. Nice. So 
now we need a place to store that data, right,  
91:32 - we need to hold the search term. So let's go over 
here and take a look at our use Bergamot source  
91:39 - because I think that's a good spot for it. Now, 
we could just add another item in here for search.  
91:47 - And in fact, actually, you don't even need 
to specify string. They're just that will do.  
91:52 - But I do want to show how to type use 
reducer. So let's use a reducer for this. And  
92:01 - let's see how we go. So we're 
going to use use reducer.  
92:07 - And the initial type is going to be a 
an array of Pokemon and a search term.  
92:12 - Fair enough. Now we need to bring in user 
reducer. Cool, okay. And we need a reducer,  
92:22 - right. And that's going to take two things is 
going to take the current state, and it's going  
92:26 - to take an action. And we're gonna have that 
big switch statement in there. But currently,  
92:31 - it's complaining about our lack of typing. 
So let's go and add some typing here. So  
92:36 - let's first type state. And we'll 
call this the put you on the state.
92:43 - So what is that? Well, that is going to be an 
array boogeyman and then the search string. Fair  
92:53 - enough, that's pretty easy. And then the action 
was was put together some action. So the first one  
92:59 - we're gonna have is like the set of the Pokemon 
itself. So let's call those Pokemon actions.
93:03 - And it's going to have a  
93:10 - type where we say set Pokemon, and the payload 
is going to be an array Pokemon. So now we just  
93:17 - need to start implementing on this, so I need 
to switch on that action and set that pokimane.  
93:25 - So we're gonna return the existing 
state with the new payload.  
93:30 - And that's it. Yeah, pretty good. So that's how 
you type a use reducer. So now the output of that  
93:38 - is going to be the data and the dispatch. So let's 
get that out of there. The first parameter is  
93:45 - going to be that object. And from that parameter, 
we're going to grab the Pokemon and the search.  
93:51 - And then we're going to grab that dispatch. Oh,  
93:57 - okay, looking good so far, but now down here  
94:00 - that set Pokeyman. So we need to 
replace that with that dispatch.
94:06 - And what is the
94:07 - type on that will set Pokeyman? And was 
the payload, the data? So now coming out of  
94:13 - this function, we're also going to return 
the search string. And we just return it  
94:22 - and have a look at us bogeyman and say, What are 
you getting out of there is getting the array  
94:26 - Pokemon, and that's our string. So let's go use 
that. So we'll go over here to our search box,  
94:32 - we will grab our user schema and instead 
of boogeyman, we'll just grab search  
94:37 - and set that as the value. So to see this all 
wired up, let's do something fun. Let's call this  
94:46 - set the initial state 
something foo. Yeah, perfect.  
94:54 - So now we need to have a 
way of setting that search.  
94:59 - So let's uh, Add another 
option for our postman action.
95:06 - And we'll call this one set search  
95:09 - and give it a string as the payload. Now we need 
to switch on that type and return an updated
95:20 - state that has the new search in it. Easy 
peasy, lemon squeezy. But we need a way  
95:28 - to actually dispatch that. And we're not 
exposing dispatch. So what do we do? Well,  
95:32 - we need a set search function. Now we need 
to return that. So this set search function  
95:38 - is going to take a search string 
and return nothing a void.  
95:44 - So how do we define that? 
Well, we can come down here,  
95:48 - we can say that set search is a search 
string and dispatches a type of set search  
95:57 - with a payload of that search. 
Cool, and then we return it.  
96:04 - But I didn't say something 
early on about use callback,  
96:08 - and custom hooks that you should always use use 
callback in custom hooks when you're defining  
96:15 - a function that you're returning. So let's 
do that. Let's bring in our use callback.
96:27 - And then down here with set search, 
I'm going to call use callback.  
96:31 - And what do we use for the dependency array? Well, 
we use an empty dependency array because there  
96:35 - are no dependencies. There's nothing going on in 
here except for the dispatch, which is a constant,  
96:40 - and then search, which is given as a parameter. 
So there's nothing we need to depend on.  
96:46 - Okay, so let's go take a look over in our app. And  
96:52 - we will do set search on that value, and 
then we need to bring in set search. Cool.  
97:00 - So that probably works. I'm hoping we'll work on 
the idea that at work. So let's get rid of this  
97:08 - while we're here. And we'll go back up to our 
store. So now we need to have like a searched  
97:13 - set of Pokemon. So we have our 
Pokemon, we have our search term,  
97:19 - we need to calculate the array 
that falls within that search.  
97:27 - So when we think about using a calculated 
value, what do we use? We use memo. So let's  
97:34 - go bring in our friend use memo. And so we'll 
create a new array of the filtered program on  
97:43 - using them ml and will return a filter where 
we take any poking around with a name includes  
97:50 - that search. So what is the dependency 
array going to look like in this case?  
97:58 - Let's have a think about that for a second. 
So what are we reading from here? Well,  
98:01 - we're reading from Pokeyman. So that's clearly 
got to go in there. And we're also reading  
98:06 - from the search, because we're including 
search there. So let's give that a go. Now,  
98:11 - what do we do with filter bogyman? Well, we can do 
is we can just say, well, the poem on the return  
98:18 - isn't the original whole list of Boogeyman. 
It's just the filter boogeyman by just saying  
98:23 - filter Boogeyman. So now let's try and filter this 
down to be you lb, and we have just the Baltimore  
98:32 - How cool is that? See, that's the 
reactive nature of React state management.  
98:39 - You're creating this connection between 
the original data source Pokemon,  
98:43 - and that search term. And then when either of 
those things changes, this use memo triggers,  
98:50 - and then we get an updated filter Pokemon. So 
once you get those relationships set up, right,  
98:57 - it actually is a very elegant system. Okay, so 
let's just take the top 20 here, because this  
99:05 - gets a little crazy, and we've got to eat 800 of 
these things. So let's just slice off the top 20.  
99:12 - Now make a little bit more efficient. 
Alright, so another feature thing, I want to  
99:17 - make this case insensitive. So the way we do that 
is we would lowercase everything and compare that.  
99:25 - Cool, and now if I go over here, and I 
type in bu LV lowercase, or whatever case,  
99:32 - it finds all sorts of case insensitive. That's 
nice. And then I guess the last thing I want to  
99:38 - do is I want to sort the Pokeball on the 
way out, and I think that's another good  
99:44 - use for use memo. So let's go and create 
a sorted version of the filter Pokeyman.
99:57 - So we're gonna take that filter bogeyman and we'll 
just sort Under the name, so we'll do a dot name.  
100:02 - And then locale and compare that to be dot name. 
So what do we need to depend on? Well, the only  
100:11 - thing we're reading from here is filter Pokeyman. 
So let's add filter Boogeyman. And now we've got  
100:16 - started to bug him on. Put that in there for alpha 
Pokemon. And cool. Now we have a sorted list. So  
100:25 - let's see. VOB are you Oh, yeah. Okay, there you 
go. So, B, G, S T sorted. Alright, so this is very  
100:34 - cool. We've learned all about reacts native state 
management system, we've used a lot of it in this  
100:40 - particular example, I certainly recommend if 
you want to, to stop the video at this point,  
100:45 - work through this example, get comfortable with 
it. Because this set of hooks, use a use reducer  
100:53 - use callback, use memo use effect, that is the 
underpinnings of state management in react in  
101:00 - 2022. Everything else kind of fits on top of that. 
So if you're using indirect state management,  
101:05 - like React, query, react form, or react 
application, those work in conjunction  
101:12 - with these hooks. If you're using something 
like redox, or Joe tie, or recoil, or Zustand,  
101:21 - you're going to use a combination of that, and 
also the native hooks built in. So it's really  
101:29 - important to get a foundation set where you 
really feel comfortable with all of those hooks  
101:36 - and in particular, obviously, use the fact that 
it trips a lot of folks up. So now we're gonna  
101:40 - get into indirect state management by taking a 
look at one of my favorite libraries react query.  
101:46 - So now that we understand the foundation of 
native react state management, it's time to  
101:51 - take a look at third party libraries and see 
how they can help us make our lives easier. And  
101:56 - we're going to take a look at two, we're gonna 
take a look at React query and react location.  
102:02 - Let's go take a look over their websites. 
So here's our current site, obviously,  
102:06 - in our 10 stack query site. Now, react 
location react query are both part of  
102:12 - hinterlands Lee's hand stack, it's really cool. 
So react query is primarily designed to do is  
102:18 - allow you to easily query data from a server 
as well as post data to a server to mutate it  
102:23 - can be used actually, to manage any promise. So 
it's a generally awesome library, there's another  
102:29 - one called SW R from versal. That's also really 
good. I think react query is currently like 12k,  
102:35 - SBRs, 4k, so you can decide for yourself which 
one you want to use, they're fairly similar.  
102:40 - React location is a 10 stack version of React 
Router, we're going to use that because we're  
102:47 - going to turn our single page app into a multi 
page app. So let's start off with React query and  
102:55 - make it a little easier on ourselves to query the 
Pokeyman. So let's go over here and take a look  
103:01 - at the inspector and look at the network. And 
we can see that when we refresh, we're actually  
103:08 - getting pokeymon dot JSON twice. And this freaks 
a lot of folks out. But it really just as a matter  
103:15 - of being in development mode was strict mode on 
so why does this happen? Well, if I look over here  
103:21 - in Maine, we can see that react strict mode is on. 
And in React 18 strict mode, what happens is react  
103:28 - automatically when it first gets your component 
it mounts it and then an unmount set, and it  
103:34 - rebounds it and the idea is to help you look for 
any leaks that you might have particularly in use  
103:40 - effects that you don't close out properly. But 
the net result is that things like use effect,  
103:47 - which we use down here. If they have 
well, any dependency, right, honestly, but  
103:53 - people believe that the empty dependency race as 
this is only going to happen on load or on Mount.  
103:59 - And what happens is use effect gets run twice 
because you mount unmount and then rebound. So  
104:06 - actually, the contract is true use effect with 
an empty dependency rate only ever gets run once  
104:11 - on a mount. But it just happens that react 
18 in strict mode with development mode  
104:15 - on actually mounts you twice. So yeah, 
that's why you get two calls. But hey,  
104:20 - it's fine. Let's go and replace basically 
all of this fetch code with React query.  
104:28 - So how are we going to do that we're going to 
start by bringing in the React query library.  
104:34 - Get started. Let's see we need to install. So 
we're going to yarn add tan stack rack weary
104:47 - and then I'll bring up the site again.  
104:52 - So now what we need to do is we need to on the 
app side build a query client provider as well  
104:58 - as a query client Now that query client is 
basically a cache. So that's actually going  
105:05 - to help us with this double problem. Because when 
we ask react query to go and get that put you on  
105:11 - JSON for us the first time, it's gonna 
go and get it. And then the second time,  
105:14 - it's gonna say, Hey, I've already got this 
thing cache, you don't need to worry about  
105:17 - that. And it's going to handle that for us. 
So how do we get that process started? Well,  
105:21 - we got to bring in the Create Client provider, as 
well as a great client creator from the 10 stack.  
105:28 - And then we'll create our query client. 
And then we'll wrap our whole app in a  
105:33 - query client provider. This is again, like 
context thing, like we learned earlier.  
105:39 - This is just a context based provider that is 
managed by that tan snack, react query. So let's  
105:46 - give this a try. See if it works. Hit refresh, and 
everything is still refreshing. Cool. So let's go  
105:54 - over to our stored at TSX. And see how we can use 
this well, we can use this by bringing in US query  
106:02 - from pans dat. And now down here, we're gonna 
make some changes. So I'm gonna get rid of this,  
106:11 - as well as the Pokemon, because we're not going 
to manage the Pokemon ourselves anymore, we're  
106:15 - going to use canned stack for that. So we're gonna 
get rid of anything that would be setting Pokemon.  
106:22 - And initializing it cool, awesome. 
And we'll get rid of our use effect.  
106:28 - And we don't need to set Pokemon.  
106:31 - Alright, looks good. So now, we can use use query. 
So what what is use query do. So now we can use  
106:40 - use query. So let's bring in use query. And it 
takes a bunch of parameters. The first one is a  
106:47 - query identifier. So put an array which says 
that this is going to be the Pokemon array.  
106:55 - So that uniquely identifies this particular 
query for caching purposes, then you need to  
107:02 - give it a fetcher. So we're going to give it fetch 
Pokemon dot JSON. And then we're going to get the  
107:06 - JSON from that request. So we have to provide it 
with the fetcher. And it actually doesn't do that  
107:11 - for us, which is kind of interesting thing. But 
again, use query is more of a promise watcher,  
107:17 - it doesn't really care what promises you throw at 
it. So in this case, we're throwing a fetch at it,  
107:23 - which is the query, that isn't the title of the 
talk. Okay. And then the last thing we need to do  
107:30 - is give it what the initial data is. So when 
it's not got the request done, what do you  
107:37 - actually want to put in there in the meantime, 
and we'll just put an empty array in there.  
107:43 - Okay, that's cool. So let's go and 
get the data out of this. So we'll get  
107:51 - an object from it. That object contains 
data. And we can just rename that to Pokemon.  
107:58 - But this is actually typed as any currently. 
So let's cast that to a Pokemon array.  
108:08 - And now we have an array of Pokemon. Let's give 
it a try and see we go, refresh. Nice. It's that  
108:16 - easy. Literally, how cool was that. So we don't 
have to have that use state or use reducer that  
108:22 - holds that data, we don't have to have use the 
fact that go gets that data, we can just use  
108:27 - React query, and then let it manage the data. And 
that's what I mean by an indirect state manager  
108:34 - is react queries primary job is to manage that 
promise. But in doing that, it also has to get  
108:42 - the data from that promise, which it retains, and 
it stores for us. So it manages part of our data.  
108:47 - So let's go see if it's actually solved our double 
network call problem, go to Network. And yeah,  
108:52 - now we're only getting that Pokeyman JSON, just 
the ones even in React 18 in development mode.  
108:59 - Alright, so now it's time to turn our awesome 
single page app into a multi page app using React  
109:05 - application. And in doing this, we're going to see 
that the URL is going to contain part of the data  
109:12 - because what I want to do here is I want to be 
able to click on one of these and get detail about  
109:17 - Beedrill or blast noise or whatever it is. And 
that's going to go to a slash Pokeyman slash ID.  
109:25 - And that ID is going to be part of 
our data, right? It is part of our  
109:30 - data model for the application. So let's 
go and see how we do react application.  
109:36 - So go over an installation, and we see that 
all we need to do is bring in React location,  
109:43 - stop server, paste that line in, start the server 
again. And so what do we need to do? Well, we need  
109:51 - to bring in a few things from our React location. 
We need to bring in a link. That's what we're  
109:56 - going to use to do the client side links or any 
Use outlet, which is a way where you can specify  
110:03 - where the content of the route is supposed to 
go, which is effectively like the query client.  
110:08 - So we're going to create one of those like that, 
we're gonna use the router, which is a component  
110:15 - that wraps the application gives us that context. 
And then we're also going to use use matches the  
110:20 - way we can get the parameter from the route. So 
the next thing we need to do is give ourselves a  
110:26 - list of routes. Now routes are listed as an array. 
Each array has a path and then an element that you  
110:33 - want to render. When you go to that particular 
path, there's actually a whole bunch of stuff  
110:37 - around this are as loaders, everything else, 
there's children elements, that is a really  
110:43 - a much more robust system than what I'm showing 
up here, I just want to kind of show off sort of  
110:48 - the basics. So in this case, our current route 
is slash, and what we want to show in there is  
110:53 - our search box and our Pokemon list. So what 
are we gonna do this, we're gonna go and wrap  
110:58 - our div in that router, give it that location, 
as well as the routes that we just created.
111:11 - And we'll finish off the router. And now we can 
take this content section and replace that with  
111:16 - the outlet. So whatever the route is, that content 
is going to go in here and our nice MX auto kind  
111:24 - of put it all together. If you had like a header, 
we go above that, if you have like a footer or go  
111:29 - below it, all that kind of stuff. All right, 
let's go over here. Hit refresh. And there  
111:34 - you go. So we can try this out, see if that's 
actually the case or not to say div main route.  
111:41 - Refresh, cool. We are on the main route. 
And currently we're talking in French.  
111:46 - That's kind of cool. All right. Okay, 
let's get rid of the main route there.  
111:51 - And now we want our detail route. So 
we want a Pokemon detail component.  
112:00 - Here. And where we want to put 
that we will put that on a path.  
112:06 - Like Pokemon. And then ID and the colon ID means 
that anything in the slot here is going to be  
112:15 - assigned to a parameter called ID. And there's 
a bunch of different things you can put on that.  
112:19 - But that's pretty standard way to define routes. 
And we'll just point that at the Pokemon detail.  
112:29 - All right, and then the last thing you need to 
do is we need to make each one of these Pokemon  
112:35 - clickable can they currently not? So let's 
go back over here. And we'll use that link.  
112:44 - Give it the key, say that we're 
going to the Pokeyman at that PID.  
112:53 - Get rid of this key and then finish off the link.  
112:59 - And there we go. So let's see. Okay, hey, now 
we got a little finger. Let's click on that.  
113:06 - And we have our detail page again in French, but 
not really. Okay, cool. Nice. So how do we get the  
113:15 - ID from this? Well, we use that use match to get 
the ID from the parameter that is ID right here.  
113:25 - So we bring in use match, we get the ID, 
and then we need to get our list of Pokemon.  
113:30 - And then within that, we need to find the Pokemon 
that corresponds to that ID. So we do a find.  
113:36 - And then we do that parts of the end, I'm 
just going to use plus ID there because  
113:41 - I like that a little bit better. And 
then if we don't have any Pokemon data,  
113:44 - we can just say, you know, 
no Pokemon found or whatever.
113:48 - Because we already have the data. But if 
we do have the data, let's Stringify that.
113:55 - And let's see, we get click on Beedrill. And 
nice, now we get our data. Now all we need to  
114:03 - do is just format it. So I'm gonna actually bring 
in a fairly big block to format this and give us  
114:08 - something that you can play with and have some fun 
with. Alright, so I'm gonna replace this div with  
114:14 - this code, and we'll walk through it. So at the 
top, we're gonna have a container div, it's gonna  
114:20 - give us a little margin, then we're gonna have a 
home link, that's going to link back to slash, so  
114:25 - we have a way to get back, then we're gonna have 
a two column grid that's going to have the image  
114:30 - of the Pokemon, and then over in the other one 
will have a bold name. So the Pokemon data here,  
114:38 - change that out. Alright, and then we'll have 
our stats. And then we go through each one of  
114:43 - the stats, so hitpoints, attack events, special 
attacks, special defense, all that stuff. And with  
114:47 - that, we create a two column grid where we have 
the stat name, and then we have the Pokeyman data.  
114:52 - So here's a little fun little piece of TypeScript 
in here. stat is just going to be a string, HP so  
114:59 - and so forth. and Pokemon data is a type object. 
So it doesn't know that stat is going to be a key  
115:08 - from that type. But we can basically tell it that 
it is going to be that by saying that this stat is  
115:15 - going to be a key of the type of Pokemon data. 
So we're gonna get the type from Pokemon data,  
115:22 - which has a Pokemon. And then we're gonna get 
a key from that type, and all the keys and that  
115:27 - type, our HP attack, and so on and so forth. 
And so that's why we don't get any issues with  
115:32 - TypeScript right there. Nice, a cool looking 
Beedrill, and all of the information about it.  
115:40 - Alright, so really, what are we talking 
about here, what we're talking about,  
115:43 - as an indirect state manager, that in this case, 
this react application library is holding the  
115:52 - ID of our Pokemon was is essential data to 
the function of the page. And so this ID in  
115:58 - conjunction with all of the work that we've 
done in use Pokeyman gives us an ability to  
116:05 - run that detail page and show the Pokemon that the 
person is interested in. So it's a combination of  
116:11 - our native state management that we've already 
built, as well as smartly leveraging third party  
116:18 - libraries like React Router, in addition to 
replication. And if you're doing lat forms  
116:24 - management, I might recommend that you might look 
at something like React hook form, or Formic or  
116:29 - final form, because all of those will manage the 
fields for you. So if you have a big form that has  
116:35 - lots of different fields with lots of different 
validations, you don't need to manage all the  
116:39 - state of the actual form fields themselves, you 
can let that third party library do that for you.  
116:45 - And I use rakshak form and swear by it. So go 
check that out. If you look at the GitHub repo  
116:51 - this associated with this video that's linked 
to in the description down below, you'll find  
116:56 - a direct Pokemon starter folder. And this direct 
Pokemon starter is what we're going to use as we  
117:02 - experiment with these different state managers. 
So what is this? Well, this is a simple starter  
117:09 - that we have for this particular application, 
I grab the search box, we get the Pokemon list,  
117:13 - and all of it is basically sort of unimplemented 
and is waiting for us to implement on the store.  
117:20 - And the first direct state manager that we are 
going to play with is one called sushi Don,  
117:25 - it's very popular, and is a unidirectional Data 
Manager. So I'm gonna go and clone this direct  
117:31 - Pokemon starter and create one called direct 
Pokemon to show and, and get started with it.  
117:38 - Alright, so I'm gonna go and copy recursively 
that direct Pokemon starter to direct Pokemon  
117:45 - switched on and then bring it up in VS code.  
117:49 - All right, now the first thing I 
need to do is install switch donde.  
117:55 - And I just gotta I gotta show you the homepage 
resist. This is amazing. So this is the sushi Don  
118:00 - homepage, it shows you a little bit about how to 
use sush. Don, I just love it. Because like it's  
118:06 - a bear. It's cool. I just love this page. So well, 
whatever. Anyway, so Okay, so there's our zouche  
118:11 - on the page. And we can see from it how we create 
a Tucson store, we use create. And that's going to  
118:18 - give us back our own custom hook that's going 
to manage that store for us. And we can use a  
118:23 - setter to set it from a method. So let's try it 
out. Let's go back over here to our source and  
118:29 - in the store. And we'll bring in that create. 
And now we're going to create use Pokeyman.  
118:36 - So what do we want in our Pokemon 
store? Well, we want the Pokemon list,  
118:41 - we probably want a list of all the Pokemon in 
the store. Because the Pokemon is gonna be like a  
118:46 - filtered and sorted version of it, we want a full 
list of Pokemon. So we'll call that all Boogeyman.  
118:53 - We'll have a way to set the Pokemon. 
So that'll be a setter and you give it  
118:58 - the Pokemon. And then we also need 
the search string, all that search  
119:04 - and a way to set that search. Okay, now let's 
start this up. So we'll create a Pokemon array,  
119:11 - which is just empty, the whole pokimane array is 
empty. And we'll set the all Pokeyman function  
119:17 - to take a Pokemon array and then 
set that all Pokemon to that array.  
119:23 - And we'll set search to an empty string, 
and then we'll have a setter for a search.  
119:28 - So I'm also going to go and set pokimane 
here, because I can implant the searching  
119:33 - filter and right away but I do want 
to have that Pokemon data available.  
119:37 - All right, so let's go over to our app and 
bring it in. So let's bring in US Pokemon.  
119:47 - And then up here, we're going to get 
search and set search from use Pokeyman.  
119:53 - Now this is one way to do it. Another way to 
do it is to use what's called a selector. So  
119:58 - here's here's how select It works. So let's say we 
want to get search in particular. So we'll use use  
120:04 - Pokeyman. And that will get given a function which 
gets given the state. And we peel off from that,  
120:10 - the search. And I think that's actually the best 
way to go. Because what a selector allows you  
120:17 - to do is say, Hey, I only want this part of the 
store. So only when that store part updates do,  
120:25 - I actually want to get updated. And that's a 
way to kind of select down from the store. So  
120:29 - we have large stores that are being looked 
at by a bunch of different components. But  
120:33 - the components update on different things. They 
should all use selectors. And I think it's just  
120:37 - best practice to really start off by using 
selectors. So we also got to get set search.  
120:46 - And now we can implement on this. 
So search is going to go into value.  
120:50 - And this is going to call set search. With the 
event target value, gotta bring in the event.  
120:57 - And Cool. All right, and then down here and 
the boogeyman list, we will have our Pokemon.
121:07 - And we will run. Okay, nice. Let's give it a try. 
Yarn dev to bring up the server and here we go.
121:18 - So, nothing, so why nothing? Well, we haven't 
actually gone and gotten the data yet,  
121:27 - but at least it's not blowing up. So that's a 
good thing. All right, so let's, uh, let's go and  
121:32 - fetch the data, your mind our JSON  
121:40 - and then get the JSON from that. And then we're 
going to call that set all Pokemon method on that  
121:48 - hook. Seems weird, right, but it actually works. 
So the first thing we need to do is reference  
121:53 - the hook. So use Pokemon. And then we got to get 
the state from that that state includes set all  
122:01 - Pokemon, and we can use that to set that Pokemon. 
So let's try now. All right, cool. So what this  
122:09 - is showing us is that you have this externalized 
state manager in this Tucson hook us Boogeyman.  
122:19 - But you can talk to it outside of a React 
component context, which is one of the things that  
122:26 - we look for in direct state managers, direct state 
managers should be able to be accessed by a unit  
122:32 - test, or by code that's external to the React 
tree, or code that's internal to the React tree.  
122:39 - And that's a sign of a good direct state manager. 
And Sushant is a very good direct state manager.  
122:45 - Okay, so I think we're doing good. The only 
problem is that we don't actually search  
122:49 - anything. So we click that and nothing. So let's 
go make an admin so so let's go make ourselves  
122:55 - a filter and sort function that takes a list of 
Pokemon all Pokemon and a search, and then gives  
123:00 - us back the list of Pokemon matches that search 
also sorted. So we'll call that search and sort.  
123:10 - bogeyman, it'll take a list of the Pokemon, 
it'll take a search string, and then
123:18 - it will filter through that. 
And then sort them by name.  
123:28 - But also, we only want to get the 
top 10. So let's just slice that off.
123:34 - And there we go. Okay, cool. So 
now we have our search and sort.  
123:37 - Let's go down here to our set all 
Pokemon. And for Pokemon, we can  
123:46 - call that set in search, we have Pokemon, but 
we also have our search. So where's our search  
123:52 - coming from? Well, our search, we gotta go get 
that. So we're going to you bring in the GET  
123:58 - parameter, and then we'll call get, and 
that'll give us the search the current search.  
124:08 - So we're gonna do the same 
thing down here in search.  
124:12 - So we're going to set Pokeyman to be the 
search and sort of Pokemon, but in this case,  
124:16 - we don't have the pokemon so we need to 
go get that but we do have the search.
124:28 - And let's here we go. Perfect. 
Love it, and so fast. And you  
124:36 - see why people really love swift on it is 
a very concise, very easy way to make a new  
124:45 - custom hook that manages data for you externally 
to the React tree. So you can make it global.  
124:50 - But it also integrates really well with your React 
app. And also with any other hooks. You could use  
124:57 - things like use memo or use state or user research 
In conjunction with this, you can have Sushant  
125:02 - manage the global data, and then any local data 
managed with basic react hooks. So, awesome stuff.  
125:11 - So I've talked a little bit about how Tucson 
is a uni directional state manager. And that's  
125:17 - like Redux. So what is a unidirectional state 
manager means well, it means that the data flow  
125:23 - in a unidirectional Data Manager only goes in one 
way, in order to mutate the store, you have to  
125:30 - dispatch a action or call a method on the store 
that then changes a store. And because you're  
125:39 - subscribed to the store, you then get updated, and 
only goes in one direction. The next thing we're  
125:44 - gonna look at is Val sheEO. And Val sheEO, is an 
example of a bi directional statement, or you can  
125:50 - actually just directly set a value and get updated 
if that value is updated somewhere else. So it's a  
125:58 - bidirectional connection to the state manager. If 
you've heard of mob X, Val shield is very similar,  
126:05 - just a little bit smaller. Okay, let's go try out 
value. Okay, so I've cloned direct Pokemon starter  
126:15 - into a new directory called direct Pokemon Val 
sheEO, and added Val shield to it. And so let's go  
126:19 - over and check out Val sheEO. And see what it's 
about. Well, this is the Val sheEO, MPM page.  
126:24 - And it shows you that basically, we're creating 
a proxy. So our state is held in this proxy,  
126:33 - we use a proxy to create that. And then inside of 
React, we use the use snapshot hook to connect to  
126:41 - that proxy. So in the case of, for example, 
a counter, we get the snapshot of the state,  
126:47 - so that would include count zero. And then when 
we click, we just add on to the count, we just set  
126:53 - the value, and automatically, this component will 
rerender. Because we know that we also subscribe  
127:01 - to count over here, it's just a really nice way 
to manage data. Okay, so let's go and create  
127:09 - our store based on our proxies and snapshots. 
So I'm going to bring in proxy from Bauccio.  
127:21 - And we'll create a couple proxies, we'll create 
the search proxy by saying we have a proxy and  
127:27 - the query string is an empty string. And then we 
also have to have a proxy for all of the Pokemon.  
127:36 - So far, so good. And now we know we need 
to go fetch it. So let's do the fetch work.  
127:44 - And then get the JSON back from that. And 
then with that Pokemon, we're just going  
127:48 - to set that value. That's all we need to do, we 
just need to set all Pokeyman Pokeyman. to that.  
127:54 - And let's see, so Okay, cool. Let's go 
over to our app dot TSX. And bring this in.  
128:01 - Alright, so to use our proxies, we need to 
use snapshots. So let's bring in new snapshot  
128:08 - from value, and that will bring in our proxies 
from that store, and now it's gonna get it.  
128:19 - So we're going to get a snapshot of the 
search proxy, and we'll use that as the  
128:25 - value. And then on the change, we'll just set 
that value. Search dot query equals the event  
128:33 - target value. So use snapshot is really what's 
doing the subscription to that proxy. It's  
128:40 - connecting that proxy with React, so that when 
search changes, this user snapshot, basically  
128:48 - fires set some state that state has given back 
to us as a snap, and we can then display it. And  
128:54 - that's how Bauccio fits into the React rendering 
cycle. In order to set it you just go and set  
129:00 - the value of the proxy directly. So there's a 
little bit of a differential there, you don't  
129:05 - want to just call like search that query because 
that's not actually going to connect you directly.  
129:10 - Okay, so now here with Pokemon list, let's 
go and get that all Pokemon and get that.  
129:20 - And now down here, we can just take the Pokemon 
from that snap, and let's see, are we working?  
129:29 - We are, of course, we got crazy 
numbers of boogeyman because  
129:32 - we've got all the boogeyman in 
the list, and we don't search.  
129:36 - So how do we fix that? Well, we fix that by 
using another utility from vallecito called  
129:43 - derive and derive allows us to derive data 
from multiple proxies. So let's bring in derive  
129:51 - from the utils. And then derive allows us to 
create a new proxy. So we'll call that Pokeyman  
130:00 - And you give it an object. And then with an 
object you give it some call this key list.  
130:07 - Now let's do the function that takes and 
getter. And then we can use that get her to  
130:11 - get other proxies. So we get the search, get 
the query from that convert to lowercase, and  
130:16 - we get all the Pokemon and then filter it based 
on that query. Pretty cool, right? So now, we can  
130:24 - get rid of exporting all boogeyman and go back 
over here to app dot TSX. Changes to Pokeyman.  
130:32 - J that boogeyman and let's see 
snapback what we call it again, list.  
130:36 - Cool. Hit refresh. Bu lb. Oh, okay. Let's 
get on here. Oh, okay. And on to lowercase.  
130:51 - Cool. And I think we also slice and 
sword right? So let's do the slice.  
130:57 - Take the first 10 and then sword.  
131:05 - Perfect. Love it. And now we only have a 10. 
Great. Awesome. How cool is that? I mean,  
131:13 - that is a very, very simple state management 
model. When you set a value, you just set it.  
131:19 - And then over here, we just do the same thing with 
all Pokeyman. We just we just set it up, how cool  
131:24 - was that, and then use that snapshot to go 
and subscribe to it that's very clean. And  
131:29 - then this derive. I love this. So this ability 
to just take multiple data sources and derive  
131:36 - some data from it dynamically, that is just 
great. And it automatically updates anytime  
131:41 - that search changes or on clicking on changes, 
the thing just automatically re renders. I love  
131:48 - that. The another great thing that I love about 
state managers like this. And along that line,  
131:54 - another model of state management that I'm really 
excited about is called atomic state management.  
132:03 - And there's three state managers out there 
that really define the current state of atomic  
132:07 - management, there was the original library recoil 
from Facebook, there is the Jo tiny library from  
132:14 - dicey carto that she caught Oh, just happen to 
also write val, sheEO and soussan. So if you want  
132:19 - to subscribe to somebody on Twitter, and learn 
all about state, definitely a good follow. And  
132:24 - he's also written a great book recently on state 
management. So you might want to check that out.  
132:30 - And also there is nano stores. So 
those three libraries recoil Joe tie,  
132:35 - and Anna sores are excellent places to look 
when it comes to atomic state management,  
132:38 - I'm going to choose to use Joe tie, 
and we're gonna go check that out next.  
132:43 - All right, so let's take a look at the Joe tie 
atomic state management library and how to use it  
132:48 - in the list of directories that is in the GitHub 
repo associated with this video, there is direct  
132:55 - Pokeyman Joe tie. And this is where this code 
lives. It's a clone currently of direct Pokemon  
133:00 - starter, and we'll just go through it one by 
one. So let's go over and look at the store.  
133:06 - And this is we're going to start building out 
our atoms. So what are we talking about here,  
133:10 - let's go over to our Joe type page and see how 
this works. So we bring in atom, which is how we  
133:17 - define a piece of state and use atom, which is how 
we use it in the React context. So for example,  
133:23 - you have a text atom that you've created by using 
Atom Hello. And then you can have another atom  
133:30 - that depends on that atom. So shut when text atom 
changes, this uppercase atom will get recomputed  
133:36 - to do to uppercase. So again, you're creating 
this network of data. If you think about like an  
133:42 - Excel spreadsheet, or a Google Sheet, right, 
you can imagine text Adam would be a cell,  
133:48 - and then uppercase atom would be another 
cell that references that original cell.  
133:53 - But uppercase is it. And that's one of 
the cool things about this atomic state  
133:57 - management system is you create this web of 
state and just automatically updates itself.  
134:04 - And then to interact with it you use use atom, 
give it the atom that you want to talk to.  
134:09 - And then you get back basically a value and I 
set up just like you would with US state. So  
134:14 - it's very, very simple. So the first thing we 
want to do is bring in that Adam from Joe tie.
134:22 - And let's declare our search, Adam.  
134:27 - Fair enough, easy. But how do we get the list 
of all the Pokeyman? Well, that's actually a  
134:33 - little bit cooler. And I'm going to do it a little 
bit differently than I have with the other ones.  
134:37 - So we're going to use this Adams with query. And 
this allows us to use tans, Dax, query core. So  
134:46 - it's basically react query, now connected to a 
Jota atom. So let's go and add these libraries  
134:56 - and then start the server up again. And then 
we import So Adam has a query. And now we just  
135:02 - need to create an all Pokemon atom that uses 
that Adams a query. So we're saying to Adams a  
135:08 - query that we are getting back a, an array of 
Pokemon, we give it a function, you give it a  
135:13 - query key just like we did with us query before, 
where you give it a unique key for your query,  
135:19 - in this case, Pokemon. And you give it a function, 
just like we did before with us query, now we're  
135:24 - giving it that exact same fetch function to go 
get that data and that gives us back all Pokemon.  
135:29 - And so let's try this out. So we got our search, 
and we got our Pokemon, that's probably enough to  
135:33 - get started. So let's go over here, app dot TSX. 
And bring this in will bring in US Adam from Joe  
135:38 - tie. And also bringing us Adam value us Adam 
value just subscribes to the value of the Adam.  
135:45 - So we'll use Adam the original, which is just 
like you stage to go and get the search Adam,  
135:51 - because we're going to want to set and 
get that. And we use Adam value for the  
135:55 - all Pokemon because all we want to do is just 
get the value of that. Now let's get our atoms  
136:05 - from that store, and then for 
the search box, let's use that
136:13 - said the value. And then here 
with the event said that search.  
136:23 - Good enough. Now with the added 
value, we're going to get our Pokemon
136:30 - on the all Pokeyman atom, and we just 
display it, hit save, go back over to our  
136:38 - display and Bob's your uncle. Nice, but it was 
urging. So we need to go and create an atom  
136:47 - that looks at both the all Pokemon atom and the 
search atom. And when either of those changes,  
136:54 - updates itself. So let's go and create a boogeyman 
atom that depends on both of those things.
137:04 - So in this case, we give it a function, 
that function takes a getter. And with that,  
137:10 - we can get the current value of the search item 
by just getting a search item, the current value  
137:14 - of all Pokemon by getting the all Pokemon and we 
just filter. So let's go make this to lowercase.  
137:26 - And then we'll use to lowercase in there.  
137:32 - And now we've got our Pokemon Adam. So let's 
go and get rid of that export because I don't  
137:37 - need that and go over to our app and bring 
in the Pokemon. Adam, let's call it that.  
137:45 - Let's get out of the way. And then down 
here. All boogeyman becomes boogeyman Adam.  
137:52 - Hit save. Hit refresh. Be you lb 
nice. Perfect. Wow, that's cool.  
137:59 - You know, I do like this cascade model. And 
currently we're just filtering but we also want to  
138:05 - slice and we want to sort. So let's create another 
atom that depends on pokimane atom that has that.  
138:14 - So it takes the existing pokimane 
atom. And then it sorts it  
138:27 - based on the name, and oh, we also got a slice it.  
138:34 - Cool. And now we got to sort of put them on 
Adam. And we can go back over here to our app.  
138:39 - Bring that in instead. And depend on 
that. Let's see. Does it work? Yeah,  
138:45 - blast away started out. Okay, you will be cool. 
And also is it? Yep, it's trimming down to 10.  
138:53 - How cool was that. So now we can see that we have 
this cascade of atoms in the store, we've got our  
138:59 - search atom, which is basically a simple piece of 
text. And then we got our all pokimane atom which  
139:05 - is in a synchronous atom that is based on 10 stack 
query, it goes off and makes that query and then  
139:11 - set itself. And that automatically integrates 
with the other atoms such that when it updates,  
139:17 - any dependent atoms get updated, which includes 
this pokimane atom, which subscribes to both  
139:23 - the search atom and also the all pokimane atom 
and then returns for its own sake the filtered  
139:30 - version of that data. So this is how you derive in 
this Joe tie or recoil or nano stores type system.  
139:40 - And then we have another atom that listens to 
bokeem on atom and so you when you any of these  
139:44 - things update, like the search updates, you get 
this awesome, automatic cascade. And the thing I  
139:53 - really like about it is is that cascade and it is 
slightly different from the native react version  
140:00 - of that, because we only we kind of have that 
in the native react system, right, we've got use  
140:05 - date, and use reducer, which are effectively atom. 
And then we have use memo, which is basically a  
140:14 - way of deriving another atom from the original 
atom. The only problem is the based on the nature  
140:20 - of React, we have to mend the dependency raise, 
notice that we don't have to do that here. By  
140:26 - getting the atom, we're automatically subscribing 
to it, which is a much, much cleaner way to  
140:31 - work. And you don't have to worry about the fact 
that you might have dependency arrays that might  
140:36 - not have all of the stuff in it that you actually 
need. So it removes another potential for error.  
140:44 - The next and last direct statement we're 
gonna take a look at is the venerable Redux.  
140:50 - So I realize getting to Redux at pretty much 
the end of the video is kind of like walking a  
140:57 - whole marathon and saying, Hey, here's Everest, 
it's just a little bit at the end, no big deal.  
141:03 - Redux is a huge state management ecosystem. 
Essentially, Redux is the longest surviving react  
141:12 - state manager, it's been around since the days of 
class based components. And probably actually even  
141:18 - before that, and I gotta say, it can be a little 
daunting. So what we're gonna do is we're gonna  
141:27 - use the Redux toolkit to simplify it a little bit. 
Redux toolkit gives you a bunch of helpers on top  
141:35 - of Redux, that reduces a lot of the boilerplate, 
which is a lot of folks, gripes with Redux is that  
141:44 - there's a lot of boilerplate. It also has a React 
query equivalent built right into it. So that's  
141:50 - pretty cool. So we will use that to go and get 
our data for us. So this is the Redux toolkit.  
141:55 - And I've created our app. Our app is in the direct 
Pokemon Redux folder. And it is just a clone of  
142:03 - the direct Pokeyman starter as we deal with all 
these. Now, this is what we're going to add to the  
142:11 - code. We're gonna add Redux, which is the base 
library for Redux and react Redux, which is  
142:16 - the couplers, basically, between react and Redux, 
basically just hooks, and the Redux Toolkit, which  
142:23 - as I said, Is this simplifying stuff, simplifying 
functions that allow us to really easily create  
142:31 - stores and slices. So we'll get into that what 
that is in a second. Let me start at the server.  
142:39 - And then bring it up, and we got our search box. 
Awesome. Okay, so let's go over here to our store.  
142:46 - And so what are we gonna do, we're gonna create a 
Redux store, and our Redux store is going to have  
142:51 - slices in it. So now, when react first started, 
the idea was you'd have one ginormous store that  
142:58 - would have all of your data in it. And folks got 
going rather, hey, that doesn't scale really well,  
143:05 - because of having one big store with all the 
data in it for the entire application, peoples  
143:10 - are running over each other. And so it's nice as 
a way to slice the data into parts and pieces so  
143:15 - that you can manage it better. So let's bring 
in a few imports from Redux toolkit, the first  
143:21 - would be create slice, so we're going to create 
a slice to hold our search state. So this is just  
143:28 - going to be the search me the text string of the 
search and also a way to set the search. So we're  
143:34 - going to create a slice that slice name, as you 
can call search, the initial value, the initial  
143:40 - state of this slice is just gonna be a search with 
an empty string in it. And then we're gonna have  
143:45 - our reducers. So we talked about reducers, when it 
came to use reducer, this is a set of functions,  
143:52 - each one of which is effectively a reducer. In 
this case, we've got a set search, and it takes  
143:57 - a state and an action. And the little difference 
here with Redux toolkit versus traditional Redux  
144:04 - is that in traditional Redux, you would return 
a state where that particular value is mutated,  
144:10 - but the rest of the were the same, but you return 
an entirely new state with all you know, new keys,  
144:17 - whereas in this case, Redux toolkit is making it a 
little bit easier in that you can just go set the  
144:22 - values in the state, and then it does the merging 
of your changes with the original state. And it's  
144:28 - actually fairly common. And this is actually 
fairly controversial in Redux world. And as far as  
144:34 - I know, I'm not a huge Redux person, honestly, but 
I'm gonna give you the best I got here. So okay.  
144:42 - So this search slice has gotten us a lot of stuff. 
So let's take a look. So slice has an actions,  
144:48 - and a reducer and name. So we're going to 
export out of here, the action for a set  
144:55 - search coming out of actions. And now we're going 
to configure a store that Has that reducer in it.  
145:02 - So we're going to use the Configure 
store, it's going to give us back  
145:05 - a store that we're going to export. 
And we're just going to give it that  
145:08 - reducer from the search. So that is how we 
register each slice into the overall store.  
145:18 - Now, if you do store dot get state, which you 
can do from anywhere, you can do it externally  
145:25 - to Redux, you can do it inside the React tree, 
this is all not connected to react right now, you  
145:32 - get the state. So that would include search dot 
search, because it's the search slice and within  
145:37 - that the search value. And so the root state 
of this store is the type of the output of get  
145:46 - state what it just looked at. So if we do Command 
K, Command eye on that, we can see that our root  
145:51 - state as he searched slice, and within that the 
search value. And then finally, we want to make  
145:57 - a selector. So talking about selectors in the in 
the case of soussan. Selectors allow you to go and  
146:04 - take a store and get out just the data that you 
want for the particular component. So we want to  
146:10 - create selectors for everything that we need. So 
in this case, we're going to create select Search,  
146:13 - and that's gonna give us back the selector, the 
value for the search current value for the search.  
146:20 - Okay, so let's go over to our app dot TSX 
and start wiring this up to the search box.
146:26 - So to do that, we bring in a couple things from 
react Redux. Now, I mentioned that react Redux  
146:30 - are the hooks that connect Redux to react. 
So here are the things we need to bring in,  
146:35 - we need to bring in a use selector. That's a 
hook that given a selector goes and gets the  
146:41 - data based on that selector. Use dispatch just 
gives you a dispatch function for the current  
146:47 - store that you call to dispatch actions just like 
we did with use reducer. Use the state and use  
146:53 - dispatch use dispatch exactly the same way with 
Redux, which is why folks kind of think like,  
146:58 - oh, Redux Redux became use reducers. 
And it's not that easy. But yeah, yeah,  
147:03 - I mean, some of these concepts are very 
similar, like, for example, this match.  
147:07 - And then the provider and the provider 
is a context, you give it a store,  
147:11 - and then it provides that store down to 
these hooks. So it's bringing that store  
147:20 - from the local store.  
147:26 - And then let's provide that.  
147:32 - I mean, I love how Redux is so, so old, and 
has been around for so long, that the provider  
147:40 - is literally named provider. It's amazing. 
Like other other state management libraries,  
147:45 - they have, you know, Redux, or whatever, 
you know, library name, provider, whatever,  
147:50 - query provider, whatever have you. This one is 
just it's provider. It's just provider. You could  
147:56 - rename it if you want. But that's what comes 
out of library. I think it's the music. Okay,  
147:59 - so we got our store. And now we want to go 
get use selector to go and get the search  
148:06 - value. So we need to bring in that selector 
for search. So we need to use that selector.  
148:15 - And give it that Select Search. And then we 
also need to get a dispatcher. So we just call  
148:20 - use dispatch and get our dispatcher. And that just 
basically grabs it from the context and brings it  
148:26 - in. Okay, so this becomes the value of search and 
dispatch, we're going to it's going to dispatch  
148:34 - a set search with the event target value. So we 
need to bring in event right here. And let's see,  
148:42 - actually, let's go and set this to a value for so 
foo. See, we've got, Hey, how's that, and it looks  
148:50 - like it's working. That's great. So we've got 
our slice for the search part of our local store.  
148:58 - So now the next thing we want to do is want to 
get the Pokeyman JSON. And that means bringing  
149:02 - in the query part of reax toolkit. So we're going 
to bring in the Create API and the fetch base  
149:10 - query functions from the toolkit query. So that's 
the query part. And then the React version of the  
149:17 - query. So again, with redox, like everything is 
sort of, there's the basic, and then there's the  
149:22 - React. Okay, so we want to go and do is we want 
to build out our create API for our Pokemon JSON.  
149:30 - So we do is we invoke that create API, we give it 
our path. So pokimane API, we give it the fetch  
149:37 - base query. So anytime I say that everything 
that we do with this particular API is going  
149:41 - to be off of slash. And it's only going to have 
one endpoint and that endpoint is get Pokeyman.  
149:46 - And that is going to call query with you my JSON. 
So we're gonna get basically slash Pokeyman. JSON  
149:54 - there. Let's get rid of Yeah, that looks a little 
better. Oh, okay. Okay, now let's take a look at  
150:01 - what's in pokimane API. So inside pokimane API, 
we have our endpoints. Within that we've got get  
150:06 - Pokemon. And within that we have our use query, 
how cool is that it's automatically created a  
150:14 - use query for us. So let's go and actually 
export that. So we have our use of inquiry.  
150:24 - And we'll just export that. Take a 
look over here, bring it in here.  
150:33 - And now we can use it.  
150:39 - And we'll give it no parameters 
because nothing going in.  
150:45 - And the output here is either a, an array 
bogeyman or undefined. So let's just say  
150:50 - that if we have data than once use it. And if we 
don't, then we'll use the empty array. All right,  
150:58 - not working. Oh, I remember what it was. Okay, 
more wiring to be done. Okay, so we've got this  
151:04 - pokimane API needed, we'll go bring 
this down here and add it as a reducer.  
151:10 - Okay, let's take a look. Oh, where it is? Yes, 
we have Redux. And it's going I love it. Okay. So  
151:20 - now we have, you know, bulb or whatever. Cool. So 
let's say that we want to go and trim that down.  
151:26 - Well, if you look at the docs, the docs tell you 
at this point, if you want to derive some data,  
151:33 - one way to do it would just be to integrate this 
with an existing tool that allows you to listen  
151:39 - to data, and then derive data from that. And 
what tools do we have for that? Well, we have  
151:43 - good old use memo. So we can use parts of our 
existing React Native hook set and integrate  
151:52 - them with what we have from Redux, let's 
bring in use my mouse and see how this works.
152:01 - So we want to filter and we want to sort the 
data based on the search. So let's first get  
152:06 - the search right? In that, so we want to 
filter and we want to sort the podium on.  
152:14 - And it's going to rely on the data as well as the 
search. And we're going to return out of this.  
152:26 - The data or an empty array, if it exists, because 
it might not exist might be known, filtered.  
152:37 - by that name, of course, we want to 
do our little to lowercase thing.
152:42 - And then we want to slice it.  
152:52 - And then we want to sort it. Nice. Okay, so 
that'll give us our filtered and sorted bogeyman,  
153:00 - or empty array, so we don't have to go check for 
any more. Let's hit save and see if it works.  
153:05 - So it's giving us 10. That's 
great. And let's say you lb noice.  
153:11 - Perfect. Okay, so that is one way to do it. 
Another way to do it is to actually start the  
153:21 - requests for hooking on JSON externally to the 
app, and then create a selector over in the store  
153:28 - that listens for when that data is done, and 
then looks to see if it can take that data from  
153:36 - the search and do the same thing, but do it over 
on the store side. So we're basically creating a  
153:41 - selector that's doing that kind of work for us. 
So let's bring in a create selector function.  
153:51 - And then we will create a selector. And the first 
parameter is to create a selector are a set of  
153:57 - functions that select out parts and pieces, 
you can have as many as you want, apparently,  
154:02 - and the first part gives us our Pokemon. So we're 
getting our data from Pokemon API endpoints,  
154:07 - get Pokemon select undefined. That's the parameter 
that we put in and then the state or the state  
154:14 - coming in through deep state and we get the data. 
Okay, and then we can go and take this basically,  
154:23 - and drop it in here. So we're 
gonna take that boogeyman  
154:30 - and filter it on that search value. So this 
could be undefined. So let's go handle that.  
154:40 - All right, cool. So select Pokeyman I like it. So 
let's see. Now let's go over here to our app. And  
154:48 - instead of using that use memo, we are instead 
going to just select out boogeyman based on that  
154:57 - slight bogeyman selector Okay, and pokimane
155:07 - Okay, let's give it a try. So nothing to why 
is that? Well, we gotten rid of the query  
155:14 - that we did, he used to do this use playground 
query and give it undefined that initiated the  
155:20 - query. So now we have to initiate the query over 
here in the store. And the way that we do that  
155:25 - is pretty much anywhere, you can do store dot 
dispatch, which is again, nice, because you  
155:33 - can talk to Redux, both in the React context, 
as well as in the external to react context.  
155:40 - And then we want to call that pokimane 
API with the endpoint of the get Pokeyman,  
155:47 - where we initiate it with at undefined. All right, 
let's go to try, Hey, okay, now what's happening  
155:56 - is externally to react, we are initiating the 
fetch of the hook Yvonne JSON here. And then  
156:06 - when the store updates, because that get Pokemon 
returns a value is then stored in our store. And  
156:13 - that store changing then updates any subscribers, 
it looks to see what the selector is slightly out,  
156:20 - in this case, the selector is looking at the 
output of the get Pokeyman, as well as the search  
156:26 - and then using the to, to select out a mutated 
version of the postman list where we filtered  
156:35 - it and sliced it and sorted. So you can use 
selectors for more than just selecting data,  
156:40 - you can actually mutate the data in the store. 
And the selector is actually the right place  
156:46 - to do that in this model. Okay, so one more 
thing that people love about this is the Redux  
156:54 - tools. So if I go here, over here, 
Redux, we can see that as I type,  
157:04 - we are setting the surge, and you can see all 
of the different actions. And this is because  
157:09 - I have the Redux Dev Tools installed in my Chrome 
and I'm in dev mode. And so that's automatically  
157:17 - registered those things together. So that's, 
that's, that's pretty cool. So you can see like  
157:21 - the, the pending query, you can see the fulfilled 
query with the data. It's pretty neat, you know,  
157:28 - and you can also do this cool, like, time travel 
debugging people will think is really slick, dude.  
157:35 - Yeah. Nice. Okay, so there you have it. So Redux. 
Of course, all the code is available to you in  
157:43 - GitHub in the link in the description below. And 
of course, in this, this one is in the direct  
157:47 - Pokeyman, Redux directory. Now, before we get to 
wrapping all this up, I do want to talk about one  
157:53 - more technical thing, check this out. So times 
they are changing in React land. And one of the  
157:59 - biggest changes has been a recent RFC or request 
for comment, that would add first class support  
158:06 - for promises to react. And the way that you do 
that is kind of different in the client side code,  
158:14 - versus the server side code. So on the client 
side code, you now have this ability to use a  
158:20 - new hook called use that you give it a promise. 
And then when that promise is fulfilled,  
158:27 - you get the data from that promise, or I 
guess you get undefined in the meantime.  
158:32 - So let's try this out. Because I think it's worth 
knowing about this is not out there 100% Yet,  
158:37 - it is in the experimental build of React, as well 
as in next Jas 13. So it definitely is coming.  
158:44 - There might be some changes between now and when 
it actually gets out there. But I think it's worth  
158:49 - knowing, because it will fundamentally change how 
we do state management in React going forward is  
158:54 - adds a lot of new functionality, but also could 
replace some existing functionality that we have.  
158:59 - So I'll let you be the judge. So let's go over to 
the terminal. And we'll do another create V app.  
159:09 - And we'll call this one 
native use. And you know what,  
159:13 - I'm just going to use just basic 
react, not TypeScript for this.  
159:17 - Bring it up with VS code. And now let's go over 
to the package json. And in order to get on to  
159:22 - this new experimental build, I need to change 
the React and react DOM versions to experimental  
159:31 - and then do my yarn and my yarn Dev.  
159:41 - And so we now have our app. Cool. All 
right. So let's go and try this out.  
159:47 - So I'm gonna go create a new file in public 
called data dot JSON is going to basically
159:58 - and what we want to do is want to go 
get that Add data. So we're gonna go  
160:01 - over here to our app dot j SX, and let's 
see, get rid of everything basically.  
160:07 - So how would we do this before? Well, we do this 
before by having some use date, and we'd have a  
160:12 - use effect. And we'd use the use effect to get the 
fetch, or we could use rack weary and SW are, as  
160:18 - we've seen, but now we can do something really 
cool. We can basically just create a request here.  
160:26 - And what do you say data dot JSON. And 
then we'll get the JSON out of that.  
160:34 - So now we have this promise just kind of floating 
out in space with our data. So let's bring in use.  
160:47 - And then we can just get our 
data by using that promise.  
160:53 - And let's Stringify that and see how it goes.  
161:01 - How cool is that? That's really neat. That 
being said, you want to see a browser freak out,  
161:07 - watch this. So I mean, come on, right? Why 
not just go and put that in here. Like that,  
161:15 - I mean, it'd be a lot easier to get rid of that. 
Hit Save, hit refresh. And now nothing happens.  
161:25 - But lots of stuffs happening in our dev tools, 
we're going to get in data dot JSON a whole bunch.  
161:33 - So why is that? Well, what's happening here? 
And let me actually stop our. Alright, so what's  
161:39 - happening here is that we run app app then first 
starts off a fetch that returns a new promise.  
161:49 - And we use that promise, we get the data back 
the data started, no, or undefined or whatever.  
161:55 - And we put that out. And then finally, this fetch 
actually resolves, and we get our data. Use picks  
162:03 - up on that, because added to then to it, and it 
gets the data and returns a cool that intern re  
162:09 - renders app. And you and then we create another 
fetch. Now, it's exactly the same fetch. I know,  
162:19 - I know, I know, that's frustrating, because it's 
exactly the same fetch doing exactly the same  
162:23 - thing. But it's a new reference to a new promise 
to a new fetch, even though that is doing exactly  
162:30 - exactly exactly the same thing. It is a different 
promise. So use the end says, Oh, you made a new  
162:38 - promise. Cool. All right, I'll go wait for that 
one. And so we get is an infinite loop, every  
162:43 - data to JSON resolves gets us some data. And it's 
so fast, it never even gets to the point where  
162:52 - react can actually get enough spare time to put 
anything up on the screen. That's why we don't  
162:58 - even get anything on the screen, in this case. And 
that's why I initially created the promise at the  
163:03 - top level here, because that means there only 
be the one that one promise that gets resolved.  
163:10 - Now we can go back over to our localhost. 
And it works. Cool. So there you go. So  
163:17 - that's us now on the server side of the house, 
it actually is a little bit different again. So  
163:22 - we take a look over here at the first class 
support, if you look for the server stuff,  
163:30 - await in Server components. The idea 
now is that you can have a component  
163:36 - that is server side rendering only, in 
this case called node that can await  
163:44 - data, right in the function, you can create 
this component asynchronously. This is cool,  
163:49 - this is huge. This is something that we never 
had before in React is anything function.  
163:54 - And react will wait for this function to resolve 
because it's a promise, and we can await it.  
164:02 - And once it's done, then the server will render 
the page and give it out. So this is really cool.  
164:09 - And I think there's a lot of potential here. It 
certainly is game changing in terms of how it  
164:13 - will change state management and react. For the 
better for the worse, I don't know. We'll see as  
164:19 - next Jas 13 becomes more prominent, but it is very 
cool. And it's certainly worth keeping up with. So  
164:25 - in summary, let me give you some advice on how 
I think you should decide technology choices  
164:32 - when it comes to state management in React. 
I think first and foremost for local state.  
164:38 - You should endeavor to use native state 
management, use date, use reducer,  
164:44 - use memo use callback. At the point where you 
get to use the fact you might want to think  
164:49 - about using a third party library, something 
like a React query or an SBR because those  
164:57 - libraries are going to probably do a better 
job. job at managing queries, then you would  
165:03 - potentially do building it on your own. Those 
are just great libraries, they got re fetching,  
165:08 - they've got mutations is fantastic stuff, and 
they're definitely going to be leveraged. And  
165:13 - I think a combination of native state management, 
plus react query and maybe get server side prompts  
165:21 - if you're in the next Jas world might be enough 
for average applications to manage the state.  
165:29 - And then if you have additional needs, in 
particular, to allow for global state, so  
165:35 - you've got different parts of the React tree, and 
you need to get saved from one place to another,  
165:40 - then you can either look at doing context, 
if you have state that's fairly slow moving,  
165:47 - I think that's a good opportunity to move state 
around using context. Or you can use something  
165:54 - like a Jewish dawn or Joe tie or Bauccio or Redux, 
as we've seen, and there are lots of different  
166:01 - options in that space. But I think I've shown you 
some of the best. Well, I hope you enjoy this.  
166:07 - If you have any questions or comments after all 
this be sure to put that in the comment section  
166:12 - down below. And if you liked the video, hit that 
like button. And if you really liked the video,  
166:16 - head on over to my channel and subscribe to 
it because I do videos well, not this long,  
166:23 - but I do good videos, and they come out every 
couple weeks or so I think you'll enjoy them.  
166:28 - Certainly if you're a React dev it's worth 
the subscribe. It's free. See you next time.