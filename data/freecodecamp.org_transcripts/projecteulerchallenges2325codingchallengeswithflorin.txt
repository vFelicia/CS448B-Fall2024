00:19 - hello hello and welcome
00:22 - another live stream in which we are
00:24 - going to continue our journey to solve
00:26 - project Euler challenges so far we solve
00:31 - 22 problems or challenges or however
00:35 - however you want to call them and if
00:39 - we're going to solve the well all of the
00:42 - 100 ones in the project order one have
00:45 - the challenge then we are almost a
00:49 - quarter away right hopefully today we
00:52 - are going to get problem 25 and solve it
00:55 - we'll see
00:56 - hello everyone say hi in the chat if
00:58 - your life and we can start with problem
01:03 - 23 let's see what this says non abundant
01:11 - abundant sums all right that's an
01:14 - interesting word a perfect number is a
01:17 - number for which the sum of its proper
01:20 - divisors is exactly equal to the number
01:25 - for example the sum of the proper
01:27 - divisors of 28 would be 1 2 4 7 and 14
01:32 - added up which is 28 all right so that
01:37 - means 28 is a perfect number good a
01:41 - number n is called deficient if the sum
01:46 - of its proper divisors is less than n
01:49 - and it's called abundant if the sum
01:52 - exceeds all right so then the perfect is
01:58 - equals right then deficient is less and
02:02 - abundant is higher all right good
02:05 - as 12 is the smallest abundant number so
02:11 - for which the sum of its divisors is
02:13 - bigger than a number right we have 1 2 3
02:16 - 4 & 6 to be 16 the smallest number that
02:21 - can be written as the sum of 2 abundant
02:25 - numbers is 24 all right so 24 to
02:30 - abundant number that means 12 and 12
02:32 - right okay
02:35 - by mathematical analysis it can be shown
02:38 - that all integers greater than 20
02:42 - thousand 123 can be written as the sum
02:46 - of the two abundant numbers what can be
02:50 - written as sum of 12 on numbers alright
02:53 - so let's see again all integers greater
02:56 - than oh okay that's interesting
03:02 - however this upper limit cannot be
03:05 - reduced any further by analysis even
03:08 - though it is known that the greatest
03:10 - number that cannot be expressed as the
03:14 - sum of two abundant number is less than
03:16 - this limit yeah so this is why I'm
03:19 - reading out everything this is pretty
03:21 - interesting and probably a little
03:25 - confusing all right let's see again so
03:28 - this upper limit cannot be reduced any
03:31 - further by analysis even though it is
03:33 - known that the greatest number that can
03:35 - that cannot be expressed the sum of the
03:37 - abundant numbers is less than this limit
03:41 - all right let's see what we need to find
03:44 - the sum of all possible positive
03:47 - integers less or equal than n which were
03:51 - given here which cannot be written as
03:55 - the sum of two abundant numbers
04:01 - okay so they sounds complicated all
04:10 - right so we have to do a lot of
04:12 - calculations well let's let's see so we
04:18 - need to go over all the numbers from 1
04:22 - to N right so let's write it down pretty
04:28 - confusing this one yeah a lot on to the
04:29 - right I actually take it took a look
04:34 - before in the stream just to see what we
04:36 - have to do and it got me confused there
04:40 - but let's see we already for those of
04:43 - you who joined for the first time this
04:46 - is what how we roll all right reading
04:49 - the text then we're solving it by
04:52 - solving small pieces the time right and
04:56 - then we unite those pieces and hopefully
04:59 - it works well we got so far so hopefully
05:04 - we'll get further we'll see all right so
05:09 - is 1 then I less than equal to n I plus
05:16 - plus right good so we have that which is
05:19 - a good start
05:21 - ok so let's see again find the sum of
05:23 - all positive integers which cannot be
05:27 - written as a sum of two abundant numbers
05:32 - all right so what we know that an
05:36 - abundant number has the sum of its
05:39 - divisors bigger than a number right all
05:43 - right now we kind of need to go over all
05:49 - the numbers let's think so find the sum
05:55 - of all positive integers which can be
05:57 - written as a sum so already when you say
05:59 - some there are two numbers right when
06:02 - it's at numbers and
06:06 - some of the numbers from 1 to n cannot
06:10 - be written as a sum of two abundant
06:12 - numbers but for that we need to see all
06:15 - bonded numbers right which could
06:18 - potentially be added to get that number
06:23 - does it make sense it kind of makes in
06:26 - my mind but yeah it's it's it's
06:29 - confusing a bit all right let's see we
06:34 - will need a function which will give us
06:37 - all the divisors right we did this a
06:39 - couple of times so let's let's do it
06:44 - again
06:44 - I guess let's put this here and let's
06:48 - see how we did it get divisors and we
06:53 - pass in a number and here let's see we
07:02 - go up to half of it right 1 2 4 7 14 yet
07:07 - so forth let I equals 1 I less than
07:11 - number divided by 2 I plus plus and
07:17 - we're going to create a div Visser's
07:20 - array all right and we're going to
07:24 - return this tvs are three like that and
07:29 - here we're going to do if number modulus
07:33 - I is zero then it means the peas are and
07:37 - we're going to push it here they feel
07:40 - sort push I all right so at least one
07:45 - thing it's done now we need to see if it
07:50 - is abundant so function let's see how
07:55 - we're going to do it we're going to give
07:57 - this function the number and the
07:59 - divisors we're going to add the visitors
08:01 - and we're going to compare it to the
08:03 - number right so he is abundant
08:09 - let's think so is abundant the number we
08:12 - can just pass in the number actually
08:13 - let's not pass the divisors and here
08:16 - we're going to get a divisor so Const
08:18 - the deserts will be get abusers of the
08:21 - number I said that let's say number
08:24 - let's be consistent here number alright
08:30 - oops I had all right sorry I had I had
08:36 - the wrong overlay my back
08:39 - that's the overlay from my own Street
08:41 - all right good
08:46 - but yeah give these life signal like
08:49 - anyway and feel free to support the
08:52 - pre-cut cap if we go camp channel by
08:57 - becoming a member by donating I can I
08:59 - think you can do that yeah all right
09:01 - good close the parentheses there so what
09:05 - we did here we got the divisors and now
09:09 - let's see we need to have the sum so the
09:13 - sum will be divisors and let's use the
09:16 - good old reduce accumulator number
09:20 - emulator plus number and 0 so this goes
09:28 - over all the numbers in the divisors and
09:30 - as them all up in this accumulator and
09:32 - and returns it yet so now what we want
09:35 - to do is to see if sum is greater than
09:41 - number if it is then this number is
09:44 - abundant right get get get get get so we
09:50 - did that
09:52 - we're one step closer now let's see
09:54 - again find the sum of all positive
09:56 - integers which cannot be written as the
10:00 - sum of two abundant numbers okay now
10:07 - what I'm thinking
10:12 - [Music]
10:15 - you
10:17 - we somehow need to store all of these
10:21 - abundant numbers and let's see
10:29 - [Music]
10:30 - thinking
10:34 - okay so we need to go over the numbers
10:36 - from 1 to N
10:39 - this song so we're going to need two
10:40 - numbers from the abundant array which
10:44 - you don't have yet but we're going to
10:46 - create and if we cannot find a sum then
10:53 - we will store that number okay let's see
11:01 - but how about the Sun so these sums we
11:06 - could I'm thinking in order to store the
11:10 - abundant numbers we could use an array
11:14 - we could use an object which is a set
11:17 - I'm thinking I'm going to use an array
11:19 - so let's see abundant numbers will be an
11:26 - empty array and we're going to go over
11:28 - all of these numbers and we're going to
11:31 - check if it's an abundant number
11:33 - although I'm not sure if we should go
11:36 - over all of them but let's see
11:40 - hello our pan welcome how are you today
11:45 - okay
11:48 - if is abundant we have this function
11:52 - right he's abundant he's abundant I then
11:58 - we wanted to abundant I guess and that's
12:02 - a long name but hello
12:04 - push pie and let's return this abundant
12:10 - numbers let's see what we get
12:14 - I want to console the clock
12:17 - yes
12:21 - all right abundant number 36 why we
12:27 - don't have 12 so that's an itch already
12:34 - hmm
12:38 - okay don't like this is it because there
12:42 - are a lot of numbers here No
12:45 - so something something is wrong
12:53 - let's see what's the output of calling
12:58 - console that log is abundant tough we
13:02 - know that that should be right because
13:04 - it says here and well it's logical for
13:07 - it to be let's see it's false okay so
13:12 - that's not good let's see the divisors
13:17 - DB source
13:21 - one two three six
13:25 - KIC we went from one up to number
13:30 - divided by two
13:31 - but we need two equals here all right
13:34 - good so now that will work properly good
13:44 - we don't need this anymore all right
13:47 - look at that so now these are all the
13:49 - bundle numbers
13:53 - which is interesting to say the least we
13:58 - don't have any bundle number above 1,400
14:06 - that's weird
14:09 - let's see
14:15 - okay it's somehow weird right but I
14:19 - guess all right so we have all these
14:23 - abundant numbers now
14:29 - as I said that none don't know exactly
14:30 - if we should go over all the numbers
14:32 - here and to create a banner numbers from
14:34 - them but now what I want to do is to
14:36 - create an interesting loop this is not
14:40 - the most optimal way to do it but
14:43 - hopefully it will work said every
14:47 - programmer ever
14:49 - [Music]
14:51 - we want to go over these numbers and
14:54 - then go through the bundle numbers array
14:59 - and check all them to see well add them
15:05 - up
15:09 - let's see so we want to add them up to
15:13 - see if we have that number
15:17 - or we could do something else I just had
15:20 - an idea
15:23 - we know that we need to find the sum of
15:26 - two abundant numbers right and we have
15:28 - an array of those about numbers so what
15:31 - if instead of going over all the numbers
15:34 - and checking of the array again to find
15:37 - the sum what if we create the array of
15:41 - the sum of the Bunin numbers does that
15:46 - make sense
15:47 - so let's here let me write this down
15:51 - maybe that would make sense then add up
15:54 - lengths so we go over all of these twice
16:00 - this will be still less than doing this
16:07 - basically every time we go over the
16:10 - numbers from here
16:15 - okay
16:18 - and we basically want to add them up
16:24 - in another array so we have bundle
16:26 - numbers come some of bundled yeah it's a
16:31 - weird okay let's see
16:41 - Let X be abundant numbers of I and left
16:49 - Y the abundant numbers so we get two
16:52 - numbers from this abundant array and we
16:56 - add them up so sum of abundant that push
17:01 - X plus y so we basically now have all
17:05 - the subs right and the last thing to do
17:07 - is to go over this array those are these
17:11 - numbers from 1 to N and check if we have
17:20 - if we don't have the Sun because we have
17:24 - to find the sum of all positive integers
17:25 - which cannot be written as a sum of two
17:28 - abandon numbers all right I feel like
17:33 - we're getting closer but let's see one
17:35 - thing I feel we'll have in this is that
17:40 - we'll have a lot of duplicate numbers
17:43 - which is I guess fine
17:48 - not a number here
17:50 - [Music]
17:52 - that's not good
17:58 - and it broke the browser here let me not
18:07 - counsel this for now
18:11 - let's optimize this pit so comes some I
18:17 - guess we could just cross here it'll be
18:21 - X plus y if some let's see
18:29 - some of abundant includes so if it
18:34 - includes already
18:37 - don't want that it so if it's not
18:39 - included we want to push it so basically
18:43 - now we're sure that we won't have the
18:46 - number twice right band and why do they
18:50 - have to be so weird my mates
18:55 - okay
18:58 - is this a way we can speed this up a bit
19:02 - so we're getting all the bundle numbers
19:05 - and then we adding them up
19:15 - King
19:18 - what if when we get an abundant number
19:23 - we add we added up with all the numbers
19:27 - already here
19:31 - we away so we don't do this again but
19:33 - let's go with it for now
19:35 - let's hope that this won't break
19:38 - maybe we can test with smaller numbers
19:42 - like thousand all right and now
19:46 - hopefully we don't have duplicate
19:48 - numbers we still have not a number which
19:50 - is weird
19:51 - why is that
19:54 - we should only have numbers
20:01 - okay so we get number from there we do
20:05 - the sum
20:12 - number is not a number some I want to
20:17 - console that vlog
20:19 - X Y and some I want to see where is that
20:23 - not a number
20:27 - sorry one dad
20:31 - well I want to run that list
20:37 - okay twelve undefined eighteen undefined
20:43 - what's the index
20:51 - zero 246
20:59 - okay so act why is undefined
21:09 - this is weird
21:23 - why is that why we have undefined
21:28 - index two four six
21:33 - the last one
21:36 - yeah 2:46 is the last one
21:41 - but why we cut that
21:45 - if it's abundant
21:49 - we push
21:52 - and we push and find
21:58 - oh that's why we go up to the inclusive
22:03 - alright good good gets it we find the
22:07 - bug and we squished it yet so now that's
22:11 - done
22:13 - we shouldn't see not the number now
22:17 - which is good we're one step closer all
22:22 - right
22:24 - get so these are basically all the sums
22:31 - a lot of time
22:36 - what we want now we're getting closer
22:43 - let's see so what we won now find the
22:46 - sum of all positive integers less than n
22:50 - which cannot be written
22:55 - as the sum of two abundant numbers
23:00 - so we go over the numbers right from 1
23:06 - to N and if that number is not in this
23:09 - array then we want to add them up to a
23:12 - song right I think that's let's see
23:17 - let's sum 0 well actually let me put it
23:21 - here for let I again 1 I less than
23:30 - we're going to optimize this a bit
23:33 - eventually I less than equal to n so
23:37 - over all of the numbers I plus plus and
23:43 - here if we don't have it in the sum of
23:49 - abundant so pretty much anything like
23:53 - this here it doesn't think it's not
23:55 - included then we want some plus equals I
24:00 - and we want returned it son
24:07 - right so something's not Oh
24:16 - all right we're getting a number that's
24:20 - not the number we want
24:25 - the tests maybe there yeah
24:29 - time out alright alright a lot of loops
24:32 - here which is not good we need to
24:39 - optimize this
24:44 - and the idea from the chat
24:49 - okay so
24:53 - you
24:55 - today today to do
24:59 - could this oops look at this here that's
25:06 - one improvement
25:13 - I think so if we had abundant numbers
25:20 - and then we do this
25:33 - okay
25:39 - [Music]
25:41 - let's see let's ban don't be and find
25:50 - and if this is abundant then abandoned
25:56 - well bi and let's see why did they do
26:04 - this I want I still want to push it but
26:09 - if we have abundant
26:16 - over the abundant numbers so let's
26:19 - abandon numbers push band and
26:26 - I guess I can do this here okay
26:31 - now I want to go over abundant numbers
26:34 - numbers for each number and I want to do
26:39 - the sum here sum of abundant that push
26:43 - naam plus abundant right so we kind of
26:48 - create some here pretty much what we do
26:50 - here right X will be the abundant number
26:55 - and Y will be the bundle all the bundle
26:58 - numbers from the sum we already sorry
27:01 - abundant numbers here oh yeah that's
27:04 - good this abundant numbers alright so
27:09 - now we should not need this but then
27:13 - again this could be done here so we push
27:17 - the number
27:19 - I guess we don't dis then we can use I
27:22 - so we push the I and when we push it we
27:26 - go over all of them and we add them up
27:31 - inside to create a sum of abundance and
27:33 - we can do also this to check if we don't
27:38 - have it already
27:39 - do we need to do that this will kind of
27:42 - go over all the numbers
27:47 - worse adding more number at having
27:50 - duplicate numbers or going over the
27:54 - array to check all of the numbers and
27:58 - don't push it otherwise I guess this
28:02 - will slow it down a bit
28:07 - and then we're already going here over
28:13 - let's see how this improves it the
28:18 - bundle is not defined okay number sorry
28:24 - all right we don't get a good number now
28:29 - but let's see if it still times out if
28:32 - it is then oh yeah then we're still not
28:38 - good at doing a very good job
28:42 - staking a lot where can we improve
28:53 - you
28:55 - like key
28:57 - and ideas in the chat don't leave me
29:04 - maybe someone
29:07 - last time I did a extreme summer reached
29:11 - out to me and Facebook to tell me you
29:15 - did run there so you can do that
29:18 - alright this card I'm thinking how can
29:26 - we improve this
29:34 - you
29:38 - like we could save some time
29:43 - this up there because basically were but
29:46 - we don't have all the sums
29:53 - how many numbers do we have here ban
29:55 - hamma ban on the length
30:00 - Oh
30:02 - that many numbers what if we do this
30:08 - will that help
30:13 - I've come some num plus I and then we do
30:19 - this
30:23 - whoa
30:25 - that helps a bit that helps a bit Oh
30:30 - from 1689 Sam's
30:42 - and thousand that's a bit all right so
30:46 - then let's leave this there the idea
30:49 - should be the same
30:53 - how the number changes infinite loop
30:56 - online eight
30:59 - oh well
31:09 - I don't like this here
31:20 - yeah let's see still times out no not
31:25 - good
31:27 - we have a loop here we have another loop
31:30 - here
31:34 - yes
31:36 - here's the thing we can simplify here we
31:40 - get the divisors and here we add them up
31:42 - why not have the sum of the desserts
31:49 - [Music]
31:51 - well I guess let's move this and here
31:55 - we're going to create a sum we save some
31:58 - loops it's all about performance now sum
32:01 - is zero and if it's divisible than sum
32:04 - plus equals I so then we don't need this
32:07 - and we don't need this and we don't need
32:11 - this
32:13 - right so we just check if it is at his
32:21 - or right here
32:28 - and thinking how could we check our
32:30 - performances
32:36 - still turned out
32:40 - perfect
32:46 - so
32:48 - okay
32:52 - there are a lot of numbers that's why
32:57 - Oh oops
33:01 - oops we need to return some here
33:04 - but I guess it's still time doubt but
33:07 - still at least we don't have the link
33:11 - there
33:15 - else
33:21 - you
33:23 - one thing I noticed and maybe we can use
33:26 - is that you saw how many abundant
33:31 - numbers we had which were under well
33:36 - less than 10,000
33:45 - abundant numbers
33:48 - that flank
33:52 - 339 numbers and when we go to to 20,000
34:00 - 10:41 that's not good
34:05 - maybe the wicked competitor is messing
34:09 - with us again or is it maybe not
34:15 - should
34:22 - yeah Candace back here
34:26 - it's weird that always in the stream the
34:29 - first one is the hardest
34:33 - all right you can see how this name
34:35 - number changes so it's probably not
34:43 - you know what let's get this code and
34:46 - let's run it in vs code which should be
34:49 - about faster and well at least we can
34:55 - see what we get right so let me open
34:59 - this NBS code
35:02 - well it won't be timed out the worst
35:04 - will break the Mac but we've been there
35:07 - scripted yes
35:13 - if it breaks just be patient I'll be
35:17 - back it happened once so hopefully it
35:22 - won't happen again
35:26 - all right and now let's go with small
35:30 - number just to see how well it works
35:35 - node script the GS
35:39 - alright okay so that's good
35:44 - that's the lacked at least let me do
35:50 - something note man scrape Jas - Q so
35:56 - this will run always whenever we save
35:59 - alright now let me put this to the right
36:03 - oh it's fine
36:05 - what about ten thousand
36:13 - yep
36:16 - so this takes a while
36:21 - you
36:27 - you
36:29 - each
36:31 - sad
36:35 - do we have some mistakes somewhere this
36:38 - is why it's not faster who knows
36:53 - just trying to see what's happening here
36:58 - yeah that's definitely not fast
37:05 - okay
37:14 - I don't know how we can improve this
37:18 - so getting to be abundant we need to get
37:21 - all the desires and to well check if the
37:27 - sum is greater so
37:30 - yeah look at how much it took to do all
37:33 - that
37:38 - it was something to test let's see
37:42 - console that time
37:46 - you
37:48 - you
37:50 - you
37:52 - the name of the timer I just want to see
37:55 - how well fast it is get so time and time
38:02 - and so on so that time Hey
38:07 - well started and we're going to run it
38:12 - again your console that time end
38:19 - let's put bigger camp okay and let's run
38:27 - it with last numbers
38:32 - okay call milliseconds that's good
38:36 - let's see 3000
38:43 - what
38:47 - that's faster
38:50 - yes
38:53 - something's wrong with that
38:57 - alright that's about 10,000
39:05 - oh whoops whoops here is where I want to
39:11 - have it after it calls the function
39:15 - right my bad
39:18 - all right 29:34 3741 33 good but about
39:25 - 3000 now
39:29 - all right now this is more likely
39:34 - okay you can see that 600 ish if we have
39:38 - 5000 will it be let's see so for
39:48 - a thousand was 33 so should yeah that
39:53 - felt right
39:56 - that times the amount so this is five
39:59 - seconds
40:04 - three seconds and for ten thousand well
40:07 - it will be
40:09 - yeah it shouldn't be double or triple
40:12 - because we have more numbers and it
40:16 - needs to calculate between more numbers
40:21 - all right in the meantime let's see
40:27 - let's do small adjustments and see if we
40:30 - can sort of improve it
40:34 - step-by-step and eventually have it well
40:38 - be submitted or at least
40:42 - oh we could at least see if we have the
40:46 - correct number right what is it
40:50 - so for ten thousand we need this number
40:56 - oh yeah but we're not doing the sum here
41:01 - so let's this son
41:06 - three seconds oh yeah yes let's see
41:13 - we're going over the numbers we check if
41:15 - it's abundant if it is we push it to
41:18 - this array and then we go over the array
41:22 - and we get the sums
41:27 - right because we need to see if that
41:29 - number is in between some
41:34 - you know when you start to go on a path
41:36 - you kind of don't see other paths though
41:40 - maybe this is where I'm stuck now three
41:44 - seven three one zero zero four three
41:48 - seven three one zero four so at least we
41:50 - know we have the correct answer but now
41:55 - we just need to speed it up all right
41:58 - yeah at least we have the characters
42:00 - they should work but the time out can we
42:04 - use
42:06 - this statement which I don't understand
42:12 - however this upper limit cannot be
42:16 - reduced any further by analysis even
42:18 - though it is known that the greatest
42:21 - number that cannot be expressed as the
42:25 - sum of two banner numbers is less than
42:29 - this limit
42:35 - okay
42:39 - so the greatest number that cannot be
42:42 - expressed is less and not sure if that
42:45 - tells us
42:51 - to create this number that cannot be
42:53 - expressed is less yeah okay doesn't help
42:57 - I think does it Lauren where are you
43:03 - you're my you're the Joey to my
43:07 - Chancellor or the otherwise all right
43:10 - yes so it takes 33 seconds
43:13 - which is a lot a lot of numbers
43:18 - what else do we know
43:25 - [Music]
43:30 - one loop another look
43:42 - yeah
43:47 - another loop
43:50 - well-well-well they speed up let's let's
43:53 - try it with 3000 let's run it a couple
43:58 - of times and see how much we get
44:03 - right around 6:00
44:06 - let's write it down for three thousand
44:09 - is round six
44:11 - I know sixty six ninety six thirty
44:16 - yeah all right around that what if we
44:18 - don't day so we just push
44:27 - okay look at that so you can see that
44:29 - it's faster is the same thing with more
44:32 - numbers
44:35 - you
44:42 - this is if way
44:45 - check
44:48 - for 3,000 is round
44:53 - and read if we don't check all right
44:59 - maybe using a catch like a dick to store
45:02 - the numbers he's a thief abundant like
45:05 - in bull if the numbers in the cache you
45:08 - don't need to check for TV source
45:14 - wait a second for deserves
45:23 - but we we don't so we just get the
45:29 - number
45:33 - you
45:35 - we get the numbers diffusers
45:41 - well I kind of have one idea we could
45:44 - spit up things although I'm not sure how
45:48 - much what would work we kid a check here
45:52 - if sum is greater
45:59 - but I'm not sure how that will work
46:02 - because if we go up to half of it
46:07 - how many divisors could have
46:13 - 12 has the most and only the last one
46:16 - yeah that won't help
46:18 - alright let's continue this this pad so
46:20 - for five thousand we have let's run two
46:27 - more times
46:29 - 1.6 1.5 1.9 all right that's not good
46:35 - yeah I guess
46:39 - if we don't check and if we check just
46:45 - died trying to find little things to
46:49 - speed it up
46:51 - well look at that difference so if we
46:55 - check well it's a lot more
47:02 - because is that function is abundant got
47:05 - called every time
47:07 - but don't ya
47:13 - I know we kind of check all the numbers
47:17 - if they are abundant which we shouldn't
47:20 - really because we all need to get the
47:23 - sums
47:26 - all right so we know they've done in
47:28 - only laughs we don't need to check it's
47:31 - faster that way
47:34 - so 10,000 should be faster now
47:37 - last time it was 30 so minutes sorry
47:41 - seconds where it was
47:44 - we had the correct answer somewhere
47:48 - here yeah 33 seconds
47:54 - yeah these are just small clicks I'm not
47:57 - sure 20 seconds so that's all but so ah
48:02 - good don't like this
48:12 - always goes and it checks I don't want
48:18 - to do that how fast will it
48:21 - be whoa
48:24 - [Music]
48:29 - whoa no dad's fast
48:37 - basically we go over
48:40 - disarray 10,000 times
48:49 - this is where they right now how
48:53 - can we check it's not included all right
48:57 - I have another idea
49:00 - we can use an object so some of well I
49:03 - guess somewhat abundant old be an object
49:06 - and
49:15 - some of abundant of some will just be
49:22 - set through or whatever so now we have
49:25 - an object where the property is the
49:28 - number and the values true so we don't
49:34 - do this we don't do this and so let me
49:38 - show you what's the sum abundant now how
49:41 - it looks like the last numbers obviously
49:47 - look at that see so we basically have
49:49 - all the numbers here this is probably
49:53 - faster way so now instead of doing this
49:59 - we just need to check if some of
50:05 - abundant
50:08 - of I write if it's true well if it's not
50:13 - true
50:15 - then we add it up to the Sun
50:19 - does it make sense so we get the sum
50:23 - there in the sum of abundance and it
50:26 - will be set it through and now if this
50:32 - number is not there then it means that
50:36 - it cannot be written as a sum of two
50:39 - abundant so then we added up to what the
50:42 - final saw a lot of sums a lot of things
50:44 - that's it well look at how fast that is
50:50 - now
50:54 - okay this should this should be now the
50:58 - way although one thing we could do here
51:00 - is be false and that remove this so if
51:05 - it is in disarray then it falls it's not
51:08 - well it can be written as a sum and we
51:11 - don't want to add it up for the final
51:13 - countdown all right let's see how fast
51:17 - is now for ten thousand look at that
51:22 - it's fast but it's not right why it's
51:25 - zero
51:29 - if some abundant of I
51:38 - oh I guess it's undefined it sounded
51:43 - fine then we added alright look at that
51:49 - whoo this was hard let's copy this over
51:56 - and still taking a lot but finally way
52:04 - did it oh boy let's say
52:11 - this was hot how long it took
52:15 - Inc it to the web
52:18 - you can't see a timer here anymore but
52:21 - how long have been extreme Oh for almost
52:25 - an hour
52:25 - whoa yeah
52:30 - so that was the issue we were going over
52:34 - a raise to check if it's inside and
52:37 - that's pretty slow so just checking the
52:40 - object I guess a set could do but I
52:43 - don't know exactly after you set that
52:45 - well so we're doing the object trick
52:48 - Thank You Larry all right
52:53 - let me remove this and this
52:59 - and yeah
53:04 - okay I guess this could be set to pretty
53:07 - much anything if it's not in there so
53:10 - it's undefined then you want to
53:15 - to be done all right Sammy tango good
53:21 - [Laughter]
53:23 - no permutations ouch this is hard oh but
53:35 - well at least we're closer to at least
53:38 - doing 25 problems
53:39 - Lex lexicographic permutation x' a
53:44 - permutation is an ordered arrangement of
53:47 - objects for example 3 1 2 4 is one
53:51 - possible permutation of the digits 1 2 3
53:54 - 4 if all of the permutations are list
53:58 - numerically or alphabetically
54:00 - we call it lexographic
54:05 - order the last lexographic permutations
54:08 - of 1 2 & 1 0 & 2 are well-pleased
54:16 - what is the end lexicographic
54:19 - permutation of the digits
54:24 - this
54:27 - okay
54:28 - [Laughter]
54:36 - we're busted I don't know I remember
54:40 - always googling how to do permutations
54:47 - okay and also need to have them in order
55:03 - and look at how many numbers there
55:09 - Emilia
55:14 - okay
55:16 - pretty fun these challenges are getting
55:20 - harder harder
55:22 - it's a classical interview question for
55:24 - Google I believe yep probably so I guess
55:31 - I won't be hired by Google then
55:44 - you
55:52 - how we're going to do this 0 1 2 0 2 1 1
56:02 - 0 2 1 0
56:07 - two zero one two one zero all right this
56:12 - is four three zero one two three zero
56:20 - zero one three two
56:24 - zero what's the next
56:31 - what's the next
56:33 - 3 - 2 - 1 0 2 3 1 0 3 2 0 3 1 2 0 3 2 1
56:49 - and then all of these again wait 1 in
56:54 - front
56:59 - looks like a recursive function to me
57:00 - yeah I know it is recursive function
57:06 - the table
57:12 - let's think I don't know how we did it
57:18 - so
57:22 - you
57:24 - when do we know when to swap
57:34 - you
57:37 - if we would have all the permutations
57:40 - then while it will be easy right we just
57:45 - get the end here
57:51 - this
57:52 - take another hour
57:59 - and not the best recursive functions
58:02 - hah and trying to remember how we did
58:07 - should we just look for how to do it
58:11 - and for some reason failed it's cheating
58:13 - with
58:17 - the permutations
58:22 - and they also have to be in order
58:27 - you
58:31 - you
58:35 - take your time this is fun yeah fun
58:37 - watching probably I bet it's fun for you
58:44 - [Music]
58:47 - curse now how can we move this to the
58:52 - right and then
58:55 - a kiss first
58:58 - what's the logic here
59:03 - zero zero zero zero zero zero
59:06 - 1 1 1 1 1 1 2 2 2 2 2
59:14 - zero
59:17 - so we prepped here we have two six six
59:20 - numbers times 4 right - 24 permutations
59:28 - here we have so this is 24 here we have
59:33 - 6 what's the Matt here
59:44 - I think one times two times three
59:47 - one times two times three times now
59:51 - there is a ho doesn't matter how many
59:56 - they are we need to find the end one
60:05 - look at this
60:09 - we have here zeroes
60:13 - one's and then his twos look at how we
60:16 - have here to add them well the millionth
60:20 - almost the millionth number is to here
60:24 - so we probably have
60:30 - million permutations
60:36 - for the
60:38 - one element is that element like a
60:41 - returns a with two characters you can
60:44 - serve the second char before and after
60:46 - the a so you have two permutations okay
60:54 - but what's next let's let's read about
61:05 - let's see what we could use
61:12 - - loosely speaking an arrangement of its
61:15 - numbers okay we know what it is how can
61:17 - we find it
61:26 - you
61:30 - you
61:39 - okay
61:43 - you
61:53 - you
61:56 - in random we could random them up until
62:01 - we have them out that'll be fun
62:13 - you
62:27 - generational in a lexical order oh okay
62:31 - this is text we can read it maybe we'll
62:34 - get an idea this is not cheating right
62:39 - there are many ways to systematically
62:41 - generate our permutation of a given
62:43 - sentence segments let me zoom in here
62:52 - one classic simple and flexible
62:55 - algorithm is based upon finding the next
62:57 - permutation in lexicographic order if it
63:00 - exists it can handle repeated values for
63:03 - which case it generates each distinct
63:05 - multiset prepetition ones even for
63:09 - ordinary permutations it is
63:10 - significantly more efficient than
63:12 - generating values for the Lamar code in
63:16 - EXO graphic order
63:19 - possibly using the factorial number
63:21 - system and converting those to
63:23 - permutations it begins by sorting the
63:25 - sequence in weekly increasing order
63:27 - which gives it's like lexicographical in
63:31 - minimal permutation and then repeats
63:33 - advancing to the next permutation as
63:35 - long as one is found the method goes
63:39 - back to narayana pandita sorry if I
63:44 - mispronounced your name 14th century
63:48 - India and has been rediscovered
63:50 - frequently let's see the following
63:52 - algorithm generates the next permutation
63:54 - vector graphically after given after a
63:57 - given permutation it changes the given
64:01 - permutation in place
64:03 - look into the factorial number system
64:08 - well so we're learning here it's not
64:12 - cheating we're learning you can use this
64:15 - okay find the largest index K such that
64:19 - a of K is less than a of K plus 1
64:27 - if no such index exists the fermentation
64:30 - is the last fermentation
64:33 - okay you lost in the first but okay it's
64:37 - a crap oh I think I know find the
64:41 - largest index L greater than K such that
64:44 - a of K less than eval
64:48 - swap the values of a of k with that of a
64:51 - of L reverse the sequence from a k plus
64:56 - 1 up to and including the final amount a
64:58 - of n okay let's see we have an example
65:04 - for example given the sequence which is
65:08 - an increasing order and given that the
65:11 - index is 0 based the steps ours are
65:14 - false index K of 2 the K equals 2
65:20 - because 3 is placed that an index that
65:24 - certifies the condition of being the
65:26 - largest index that is still less than a
65:28 - k plus 1 which is 4
65:31 - all right index L equals 3 because 4 is
65:36 - the only value the sequence is the
65:37 - greater than 3 in order to satisfy the
65:42 - condition
65:44 - the values of a 3 & 8 a 2 & a 3 are
65:48 - swapped to form a new sequence
65:54 - the sequence after K index
65:58 - to the final element is reversed
66:03 - oh the sequence after K minus index a to
66:14 - editor's NYK - index
66:19 - all right so the final event is reversed
66:21 - because only one value lies after they
66:23 - index the three the sequence remain
66:26 - unchanged in this distance that's the
66:28 - leg lexographic successor of the initial
66:31 - state is permitted
66:34 - following this algorithm the next liquid
66:36 - graphic the permutation will be 1 3 2 4
66:44 - why
66:45 - [Laughter]
66:49 - and largest index case such that largest
66:54 - in this case is that half K less than
66:58 - so what's now here
67:02 - index k death no such that a of K is
67:09 - less than afk
67:13 - No
67:16 - [Laughter]
67:19 - okay
67:23 - at which point a of K less than 8 K plus
67:26 - 1 does not exist
67:33 - you
67:35 - you
67:39 - find the largest okay I think I
67:42 - [Music]
67:44 - see it which is hard to follow yeah
67:49 - so we find the largest K which is three
67:54 - here because well we can go we need to
67:57 - have a k plus one which will be 4
68:02 - yet when we found that we also need an
68:05 - of L which will be well this needs to be
68:10 - greater so it will be for this case and
68:12 - we swap them right ok now we have this
68:18 - here we find 2 to be well largest
68:31 - for
68:33 - [Music]
68:35 - and then L will be three again
68:40 - the largest integer greater than cases
68:42 - that yeah
68:44 - and we swapped them
68:47 - but that's not true right in the
68:50 - sequence after K minus index
68:54 - reverse the sequence from a k plus 1 up
68:57 - to and including the final program
69:00 - element
69:07 - oh I think I say
69:11 - this one so as I said this
69:16 - all these properties
69:20 - and then we'll reverse them 4 2 3 4 2 3
69:24 - 1
69:34 - No I still it is hot let's see why I
69:38 - said to look into factorial number
69:39 - system
69:45 - [Music]
69:50 - a lot of pretty stuff here permutations
70:02 - no idea
70:08 - well we kind of have the algorithm we
70:11 - just need to implement it
70:14 - largest case there's a day of cases in a
70:17 - K plus-1 no such indexes is the
70:19 - permutation is the last rotation find
70:22 - the largest index L greater than K such
70:25 - that a of K less than 800 so we go from
70:28 - the right we go from the hole
70:45 - I'm thinking
70:48 - the largest queso
70:51 - I still don't and fully understand how
70:55 - we went from this to this if we can find
70:58 - out them I think we're done if that's a
71:04 - big if
71:09 - okay find the largest index L greater
71:12 - than K such that is it on the right okay
71:16 - yeah
71:19 - I find the largest index al greater than
71:22 - K such that Oh
71:24 - so yeah I was right there we swap these
71:28 - two
71:32 - the sequence from a K plus-1
71:39 - which is the
71:51 - so up the valleys
71:58 - then if we swap them it will count this
72:02 - will be the one which was swapped or
72:04 - it's the one which will be up to and
72:10 - including the final element
72:13 - so for some reason okay let's let's
72:18 - write it down
72:23 - so we have one two three four we go here
72:29 - we find the largest which is well
72:31 - second-to-last likely like well and this
72:35 - one and we go one two four three now
72:39 - will be this K will be this what we're
72:43 - doing with our by the way yeah we're
72:45 - swapping them good now that's the first
72:50 - thing next we get this this is K this is
72:56 - K plus 1 and this is K well
73:02 - and we
73:06 - welp them so it will be one for two
73:09 - three but then it does this reverse the
73:13 - sequence from a k plus 1 up to and
73:17 - including the final element so I think
73:20 - this one now
73:25 - one when we inverse them three to four
73:31 - right let's find let's see if we managed
73:35 - to find the correct next element then
73:38 - your goal
73:42 - uhh
73:42 - [Music]
73:45 - test
73:53 - the largest case is a take a less than a
73:57 - k plus one so what's the largest three
74:02 - now
74:04 - all this is not the don't doesn't go
74:07 - there
74:08 - so three now
74:13 - and then the largest L greater than K
74:17 - such that a k less a of K is less than a
74:23 - of L
74:25 - for
74:28 - we swapped them on four to three and
74:32 - then we reverse
74:36 - from K plus 1
74:41 - these reverse thing is not familiar to
74:43 - me
74:46 - although I but looking at it it should
74:50 - be 1 3 4 - right
74:55 - we get to death probably this is our
75:02 - ending the project Euler charge
75:09 - they're just well more likely to be even
75:13 - harder than harder
75:15 - you
75:17 - can we find something else
75:25 - okay
75:30 - let's read more
75:34 - maybe maybe maybe I don't understand
75:37 - that
75:37 - right for some reason although I have
75:39 - everything they're not sure if you do if
75:42 - you do and then let me know if you do
75:49 - let's see permutations in lexo graphical
75:54 - order
76:04 - yeah I feel like
76:10 - you
76:17 - all right let's look at this this eye
76:20 - feels a bit better so
76:25 - so the given string and non-decreasing
76:27 - order and printed the first fermentation
76:29 - is always a string sorted in non
76:32 - decreasing order start generating next
76:35 - higher permutation do it until next
76:38 - higher permutation is not possible if we
76:43 - reach a permutation where all craft is
76:45 - assorted in non increasing order then
76:47 - that permutation is the last get steps
76:52 - to generate the next higher permutation
76:54 - take the previously printed permutation
76:56 - and find the rightmost character in it
76:59 - which is smaller than its next character
77:03 - let us call this character is the first
77:05 - character so something similar write
77:07 - that K we had
77:18 - where are you
77:19 - [Music]
77:29 - okay so find the largest cases that yeah
77:32 - so it's second to second to largest okay
77:36 - now find the ceiling of the first
77:39 - character ceiling is the smallest
77:42 - character on the right the smallest
77:46 - largest index greater than K okay so
77:50 - then I don't see them being the same
77:52 - here
77:52 - now find the ceiling of the first
77:55 - character ceiling is the smallest
77:56 - character on the right of first
77:58 - character
78:07 - have changed
78:13 - so a lot of missing the factorial number
78:16 - system if you have one two three the
78:18 - total permutations are n factorial which
78:21 - is six so if you see the permutations of
78:24 - two and three are and
78:27 - after being too
78:32 - you will have a change on the left most
78:35 - digit after two permutations
78:39 - Oh
78:42 - I think I see we're going
78:46 - two three one two two equals change one
78:48 - change to one three
78:52 - yeah kind of see where you're going but
78:55 - still I don't know how to apply it
78:58 - let's see again here find the ceiling of
79:00 - the first connector seeing is the
79:02 - smallest character of on right of first
79:04 - character which is greater than first
79:08 - director let us call the co character
79:11 - the second character
79:14 - swap the two characters found in a buff
79:16 - step sort the substring in um this
79:20 - creasing border after the original index
79:24 - of first character
79:28 - sort
79:30 - let us consider the string ABCDEF let
79:33 - previously printed permutation of the DC
79:37 - EF e ba the next permutation is sorted
79:42 - out order should be d e ABC f
79:50 - let us understand above steps voila the
79:55 - first character will be C C path ok the
80:00 - second character will be e
80:04 - why isn't it
80:10 - smallest character on right of first
80:13 - character which is a greater where is e
80:17 - on the right here
80:21 - it's f on the right okay after swapping
80:24 - this - we got d e f CBA
80:36 - you
80:40 - what
80:43 - you
80:45 - does anyone understand what they're
80:47 - doing here
80:49 - first character is C the second
80:52 - character is E
80:54 - for swapping the two we got
80:58 - so swapping this with this isn't it DC a
81:02 - BEF
81:08 - the final step is so disappearing after
81:11 - the character ya know
81:20 - get it alright let's go back to what he
81:23 - said so you know the leftmost character
81:25 - going from zero to one in the sequence
81:28 - change it after counting nine
81:35 - nine factorial of nine is it factorial
81:41 - or just exclamation mark yeah I see here
81:45 - the implementation but I won't look
81:53 - okay
82:03 - a lot things here
82:06 - you
82:08 - one second
82:16 - so I know the left-most character going
82:18 - from zero to one in the sequence change
82:20 - it after counting nine factorial
82:25 - by Alex and what did I do in the mean in
82:28 - those well meantime
82:33 - I don't know
82:37 - okay introduction previously permutation
82:46 - oh this is while coding I don't want to
82:49 - get cut just copy paste code I want to
82:52 - understand the logic behind it I don't
82:58 - boiler problem 24 this is what we have
83:03 - to do so yeah no no no
83:12 - okay
83:17 - recorder
83:19 - man
83:24 - you
83:28 - hmm so 0 1 2 3 will change to 1 after 3
83:36 - factorial which are 6 characters so then
83:39 - 2 will change after 1 factorial
83:45 - will change after
83:53 - zero one two three
83:58 - after three factorial right which is 6
84:01 - this will change after 2 factory which
84:04 - is 2
84:06 - this will change after
84:16 - well this will change these two were
84:19 - always changing right
84:22 - so 0 1 3 2 and then 2 factorial now
84:29 - these changes and changes with the last
84:32 - one right right
84:35 - 0 2 these changes with this one say this
84:43 - is what I don't get
84:46 - changing but to what they should be here
85:00 - let me look at the next one maybe we
85:03 - take a break from this one
85:07 - 1000 digits Fibonacci number
85:15 - what's the index of the first term in
85:18 - the Fibonacci sequence to contain n
85:19 - digit
85:26 - you
85:28 - yeah I guess this will be easier let's
85:35 - do this and I'm going to
85:39 - learn more about fermentations and we're
85:43 - going to do it next week okay
85:46 - just addresses them get it now
85:51 - [Music]
85:54 - so Fibonacci is well for those of you
85:59 - don't know we get to start with one and
86:01 - one and then the next number will be
86:03 - that previous two numbers added up so 1
86:06 - + 1 - 2 + 1 3 3 + 2 5 and so on and so
86:10 - forth
86:19 - sorry Laurent I missed ya
86:28 - let's let's do this one seems easier
86:31 - Fibonacci the 12th or f12 is the first
86:37 - time to contain three digits
86:39 - what's the index of the first term in
86:41 - the Fibonacci sequence to contain n
86:43 - digits alright so we need to add the
86:46 - Fibonacci numbers up and we need to get
86:50 - the digits and when we get the first
86:53 - number to be two-digit we just yell it
86:57 - out
87:01 - oh we all doubt the index yeah it's a
87:05 - tough one although if you know
87:07 - permutations then shouldn't be the tough
87:09 - but alright okay so let's see what
87:13 - functions do we need I need the function
87:15 - to
87:16 - [Music]
87:18 - calculate digits and we get the number
87:22 - let's call it an and we return and plus
87:27 - we convert it to a string all right
87:30 - guess we could say to string that lect
87:35 - all right and here we start with let's
87:38 - see let a be one let B be one and let
87:45 - index be
87:50 - to
87:52 - and while
87:57 - while to don't do this
88:05 - while too
88:08 - let temp or well I guess you can stamp B
88:11 - a a B
88:14 - sorry not sorry
88:19 - okay so we store be yeah a
88:26 - okay I'm losing it now B equals B plus a
88:33 - and a equals B right so the next one
88:37 - will be the previous two and a equals
88:41 - temp not be this is why we store it
88:44 - alright and index plus plus if get
88:54 - digits get digits count if get digits
88:59 - count of B equals and then we return
89:04 - index
89:13 - all right how how can be this so easy
89:21 - and then the previous one so hard how I
89:28 - don't understand I really don't
89:31 - understand
89:34 - okay
89:39 - as I said if you know permutations then
89:42 - well it's not part but yeah I know I
89:51 - don't like having all this all than this
89:55 - one not be solved
90:04 - nine factorial is 360 2880 so and item
90:12 - in the sequence will have the digits
90:15 - zero
90:20 - at the beginning because did not change
90:22 - for at many numbers
90:28 - and trying to see what Lauren is saying
90:31 - here
90:35 - I understand what you mean but how can I
90:38 - use that
90:44 - because I don't see that okay
90:59 - you
91:07 - k-stew because three is placed the next
91:10 - certified condition of being the largest
91:12 - index
91:14 - that is less than a Custer which is four
91:16 - okay
91:17 - now history because
91:22 - the sequence is created entry in order
91:24 - to satisfy the condition a K less than a
91:29 - how the values of a to a of two and a
91:33 - half there swap from the from this week
91:35 - sequence
91:38 - sequence after k-
91:43 - I don't see this K - index K of index
91:51 - to the final element is reversed because
91:55 - only one value lies after this index the
91:58 - three the sequence remain unchanged in
92:01 - this instance
92:01 - that's the lexographic successor of the
92:05 - assist LT is permeated
92:10 - sequence from a K plus-1
92:14 - including the final element so basically
92:17 - tastes fun
92:24 - you
92:37 - you
92:39 - [Music]
92:43 - you
92:48 - order of all permutations of n equals
92:50 - length of N equals 4 generated by
92:53 - different algorithms the permutations
92:56 - are color code color coded where one is
93:00 - red with yellow trees green four is blue
93:04 - you
93:06 - yeah
93:11 - you
93:22 - you
93:34 - all right I don't know what to do
93:38 - we should we continue this next
93:47 - some reason so yeah
93:51 - we also need to implement it so we need
93:54 - to go over the Ray if we have an array
93:56 - right and we need to find this condition
94:04 - then find the largest index L greater
94:07 - than K such that then we need to find
94:09 - this condition yeah all right I'm going
94:15 - to stop here
94:21 - I'm going to read more about it and then
94:24 - we're going to it next week
94:27 - I'm sorry about that but
94:33 - I just don't get it now oh well what
94:42 - else we have here
94:44 - this looks also funny
94:55 - yeah numbers all right thank you for
94:59 - watching sorry I couldn't finish that
95:01 - one maybe you could which is perfect let
95:06 - me know you can DM me well you can email
95:08 - me or you can join the discord and we
95:12 - can talk there but they couldn't figure
95:14 - out now but I will somehow someday thank
95:18 - you for watching I wish you have a great
95:21 - day and I'll see you next time bye