00:00 - dr charles severance is one of the
00:01 - world's most popular software
00:03 - instructors and he's the instructor for
00:05 - this c programming course this course is
00:08 - a little different than some of our
00:09 - other courses dr chuck is going to take
00:11 - you through a classic and important book
00:14 - on c programming you will occasionally
00:16 - have to pause the video to do some
00:18 - assignments to check your comprehension
00:20 - it's going to be a challenge but it will
00:22 - definitely be worth it if you want to
00:23 - have a deep understanding of the c
00:25 - programming language and if you're
00:27 - completely new to programming you may
00:29 - want to watch dr chuck's python for
00:31 - everybody course first
00:33 - welcome to c programming for everybody
00:34 - my name is charles severance and i'm
00:36 - your instructor for this course
00:38 - this course and website is dedicated to
00:40 - learning the classic version of c
00:42 - programming language from the 1978 book
00:45 - written by brian w kernighan and dennis
00:47 - m ritchie
00:48 - this book places the reader in the
00:50 - middle of the 1970s transition from a
00:52 - hardware-centered computer science to a
00:54 - focus on writing portable and efficient
00:57 - software c was used to develop operating
01:00 - systems like unix minix and linux
01:03 - programming languages like perl python
01:05 - java and javascript and ruby are all
01:07 - written in c
01:09 - software like early tcp networking stack
01:11 - implementations that made the internet
01:13 - possible were written in c
01:15 - and the first web browsers and web
01:17 - servers were written in c
01:20 - writing software in c enabled major
01:22 - advances in computer architecture and
01:23 - performance
01:25 - operating systems compilers and
01:26 - utilities could be recompiled to work on
01:28 - a new hardware platform once we had a c
01:31 - compiler for the new hardware
01:33 - so much software has been written in c
01:35 - over the past 40 years that there's a
01:37 - very good chance that much of the
01:39 - software that you use every day was
01:41 - either written in c or written in a
01:44 - programming language that was written in
01:46 - c
01:47 - so we study c less as a programming
01:49 - language to use on a daily basis and
01:51 - more as the foundation of modern
01:52 - software and computing
01:54 - in many ways c is the technology
01:56 - equivalent of the rosetta stone in that
01:58 - it provides a connection between the
02:00 - programming languages of the past and
02:02 - the programming languages of the present
02:04 - the name cc4e in www.cc4e.com
02:09 - refers to the original unix command cc
02:12 - which was the command that you used to
02:14 - compile your c program
02:16 - cc stood for c compiler and it is
02:19 - featured on the first page of the first
02:21 - chapter of the knrc book
02:24 - programmers like me from the 1970s and
02:26 - 1980s typed cc on unix systems like the
02:30 - att 3b2 to compile and run their first
02:33 - hello world program in c
02:36 - this material is being presented under
02:38 - fair use as we are making use of
02:39 - material from a copyrighted work that is
02:41 - out of print and not broadly available
02:43 - in any format the book is also not
02:45 - available in any accessible format we
02:47 - are making use of this material in a
02:49 - teaching and research context with a
02:50 - focus on studying its contribution to
02:53 - computing history
02:54 - the material is available for free and
02:56 - online to anyone who wants to learn
02:58 - about the history of a c language
03:00 - computing and computer architecture
03:02 - welcome to the course
03:04 - [Music]
03:09 - welcome to c programming for everybody
03:12 - my name is charles severance and this is
03:14 - my reading of the 1978 c programming
03:17 - book written by brian kernighan and
03:19 - dennis ritchie at times i add my own
03:21 - interpretation of the material from a
03:23 - historical perspective
03:25 - chapter 0 introduction
03:28 - c is a general purpose programming
03:30 - language it has been closely associated
03:32 - with the unix system since it was
03:34 - developed on that system and since unix
03:36 - and its software are written in c
03:38 - the language however is not tied to any
03:41 - one operating system or machine and
03:43 - although it has been called a system
03:45 - programming language because it is
03:47 - useful for writing operating systems it
03:49 - has been used equally well to write
03:51 - major numerical text processing and
03:54 - database programs
03:56 - c is a relatively low level language
03:58 - this characterization is not pejorative
04:01 - it simply means that c deals with the
04:02 - same sort of objects that most computers
04:05 - do namely characters numbers and
04:08 - addresses
04:09 - these may be combined and moved about
04:12 - with the usual arithmetic and logical
04:14 - operators implemented by actual machines
04:17 - c provides no operations to deal
04:19 - directly with composite objects such as
04:22 - character strings sets lists or arrays
04:25 - considered as a whole
04:26 - there is no analog for example of the
04:29 - pl1 operations which manipulate an
04:32 - entire array or string
04:34 - the language does not define any storage
04:36 - allocation facility other than static
04:38 - definition and the stack discipline
04:40 - provided by the local variables of
04:41 - functions there is no heap or garbage
04:44 - collection like that provided by algol
04:46 - 68.
04:48 - finally c itself provides no input
04:51 - output facilities there are no read or
04:53 - write statements and no wired in file
04:56 - access methods
04:57 - all of these higher level mechanisms
05:00 - must be provided by explicitly called
05:02 - functions
05:04 - i would note that the lack of a heap or
05:06 - garbage collection feature in c is both
05:09 - one of the great strengths of the
05:11 - language and at the same time is likely
05:13 - the reason that the average programmer
05:15 - will never develop or maintain a major c
05:18 - application during their career
05:20 - c provides a simple feature using malloc
05:23 - and free functions that allow a
05:25 - programmer to request a certain amount
05:27 - of memory be allocated dynamically use
05:29 - the memory and then return the memory to
05:32 - the c runtime library for reuse
05:34 - for example to convert a jpeg image to a
05:37 - png image our application will read the
05:39 - jpeg data into memory then convert the
05:42 - image into a png image in memory and
05:44 - then write the png data out to a file
05:47 - we don't know how large the images will
05:49 - be in advance so we request whatever
05:52 - size we need from c and then give it
05:54 - back when we're done
05:56 - the term heap refers to the memory that
05:59 - c manages on our behalf when we need to
06:01 - borrow a bit of memory and give it back
06:03 - later
06:04 - there are a couple of issues with a
06:06 - simple heap implementation
06:08 - first if we forget to call free when we
06:11 - are done with a memory we have created a
06:13 - memory leak and our program will
06:15 - eventually run out of memory and abort
06:18 - c places the onus of giving back any
06:20 - dynamically allocated memory on the
06:22 - programmer
06:24 - modern languages like java javascript
06:26 - and python keep track of when we stop
06:29 - using dynamic memory using a dynamic
06:31 - memory layer that can automatically
06:33 - reclaim the memory
06:36 - the more difficult problem is after a
06:38 - series of calls to malik and free the
06:40 - heap space becomes fragmented and some
06:42 - cleanup is needed this cleanup is called
06:45 - garbage collection
06:47 - efficient memory allocation and garbage
06:49 - collection has been the subject of
06:51 - decades of computer science research
06:54 - the java language has built a number of
06:57 - increasingly effective garbage
06:59 - collection approaches over the years
07:01 - kernighan and ritchie in one simple
07:03 - paragraph define most of the problem as
07:05 - out of scope for the c language which
07:08 - makes it a bit challenging for us to
07:10 - make good use of dynamic memory
07:11 - allocation in c but when we do it
07:13 - properly it performs very well
07:16 - if you are currently using a language
07:19 - like java python or php
07:22 - every time you create a new string
07:24 - through concatenation without thinking
07:26 - about memory allocation remember to
07:28 - appreciate the decades of work by
07:30 - computer scientists that made it easy
07:32 - for you
07:33 - kernighan and ritchie knew that garbage
07:35 - collection was difficult so they left it
07:38 - out of the c language and put it into a
07:40 - run time library
07:42 - back to chapter zero
07:44 - similarly c offers only straightforward
07:47 - single thread control flow constructions
07:50 - tests loops grouping and subprograms but
07:53 - not multi-programming parallel
07:55 - operations synchronization or
07:57 - co-routines
07:59 - though the absence of some of these
08:00 - features may seem like a grave
08:02 - deficiency you mean i have to call a
08:04 - function to compare two character
08:06 - strings
08:07 - keeping the language down to modest
08:09 - dimensions has brought real benefits
08:12 - since c is relatively small it can be
08:14 - described in a small space and learned
08:16 - quickly
08:17 - a compiler for c can be simple and
08:19 - compact compilers are also easily
08:22 - written using current technology one can
08:24 - expect to prepare a compiler for a new
08:26 - machine in a couple of months and to
08:28 - find that eighty percent of the code of
08:30 - a new compiler is common with existing
08:33 - ones
08:34 - this provides a high degree of language
08:36 - mobility because the data types and
08:38 - control structures provided by c are
08:40 - supported directly by most existing
08:42 - computers the runtime library required
08:45 - to implement self-contained programs is
08:47 - tiny on the pdp-11 for example it
08:50 - contains only the routines to do 32-bit
08:53 - multiplication and division and to
08:55 - perform subroutine entry and exit
08:57 - sequences
08:58 - of course each implementation provides a
09:01 - comprehensible compatible library of
09:03 - functions to carry out input output
09:05 - string handling and storage allocation
09:08 - operations but since they are only
09:10 - called explicitly they can be avoided if
09:12 - required and they can also be written
09:14 - portably in c itself
09:17 - again because the language reflects the
09:19 - capabilities of current computers c
09:21 - programs tend to be efficient enough
09:23 - that there is no compulsion to write
09:25 - assembly language instead the most
09:28 - obvious example of this is the unix
09:30 - operating system itself which is written
09:32 - almost entirely in c
09:34 - of 13 000 lines of system code only
09:38 - about 800 lines at the very lowest level
09:41 - are an assembler
09:42 - in addition essentially all of the unix
09:45 - application software is written in c
09:47 - the vast majority of unix users
09:50 - including one of the authors of this
09:52 - book do not even know the pdp-11
09:55 - assembly language
09:57 - i would note that in this preface the
09:59 - authors are carefully explaining the
10:01 - fact that many of the well-established
10:04 - programming languages of the 1960s and
10:06 - 1970s like fortran cobalt pascal algol
10:10 - and pl1 were solving many of the use
10:13 - cases that were needed by us programmers
10:16 - by adding syntax to the languages the
10:18 - creators of c and unix were advocating
10:20 - for a more minimal set of programming
10:22 - language constructs and more reliance on
10:24 - calling function in provided runtime
10:27 - libraries to meet programmer use cases
10:30 - it may have seemed a strange approach
10:32 - for experienced programmers in the 1980s
10:34 - but over time it has allowed c to expand
10:38 - to meet a very wide range of programmer
10:40 - needs without requiring major revisions
10:42 - to the core language or
10:44 - compiler back to chapter 0.
10:47 - although c matches the capabilities of
10:50 - many computers it is independent of any
10:52 - particular machine architecture and so
10:54 - with a little care it is easy to write
10:57 - portable programs that is programs which
10:59 - can be run without change on a variety
11:01 - of hardware
11:03 - it is now routine in our environment
11:05 - that software developed on unix is
11:06 - transported to local honeywell ibm and
11:09 - inner data systems in fact the c
11:12 - compilers and runtime support on these
11:14 - four machines are much more compatible
11:16 - than the supposedly ansi standard
11:19 - versions of fortran the unix operating
11:21 - system itself now runs on both the
11:24 - pdp-11 and the interdata 832
11:27 - outside of programs which are
11:29 - necessarily somewhat machine dependent
11:31 - like the compiler assembler and debugger
11:34 - software written in c is identical on
11:36 - both machines
11:37 - within the operating system itself the 7
11:40 - 000 lines of code outside of the
11:42 - assembly language support and the i o
11:44 - device handlers is about 95 percent
11:46 - identical
11:49 - as a note before unix and c if you are
11:51 - running the vendor operating system and
11:54 - writing in the best language for systems
11:56 - like the pdp 11 and inner data 732 the
11:59 - user experience was completely different
12:02 - today we take for granted that we expect
12:04 - to be able to download the same
12:06 - application for windows mac os or a
12:09 - linux system even in the 1970s those
12:12 - that were using unix and c could write
12:14 - code once and move it between two
12:16 - hardware platforms and expect that it
12:19 - would work with no or relatively few
12:22 - changes
12:23 - back to chapter zero
12:25 - for programmers familiar with other
12:26 - languages it may prove helpful to
12:29 - mention a few historical technical and
12:31 - philosophical aspects of c for contrast
12:34 - and comparison
12:36 - many of the most important ideas of c
12:38 - stem from the considerably older but
12:40 - still quite vital language bcpl
12:43 - developed by martin richards the
12:45 - influence of bcpl on c proceeded
12:48 - indirectly through the language b which
12:50 - was written by ken thompson in 1970 for
12:53 - the first unix system on the pdp-7
12:57 - although it shares several
12:58 - characteristic features with bcpl c is
13:01 - in no sense a dialect of it
13:03 - bcpl and b are typeless language
13:06 - the only data type is the machine word
13:09 - and access to other kinds of objects is
13:11 - by special operators or function calls
13:14 - in c the fundamental data objects are
13:16 - characters integers of several sizes and
13:19 - floating point numbers in addition there
13:22 - is a hierarchy of derived data types
13:24 - created with pointers arrays structures
13:26 - unions and functions
13:29 - c provides the fundamental control
13:31 - constructions required for
13:32 - well-structured programs
13:34 - statement grouping decision making with
13:36 - if
13:37 - looping with termination test at the top
13:39 - using for and while or at the bottom
13:41 - using do and selecting one of a set of
13:44 - possible cases switch
13:46 - all of these were provided in bcpl as
13:48 - well
13:49 - though with somewhat different syntax
13:51 - that language anticipated the vogue for
13:54 - structured programming by several years
13:57 - c provides pointers in the ability to do
13:59 - address arithmetic the arguments to
14:01 - functions are passed by copying the
14:03 - value of an argument and is impossible
14:05 - for the called function to change the
14:07 - actual argument in the caller
14:09 - when it is desired to achieve call by
14:11 - reference a pointer may be passed
14:13 - explicitly and the function may change
14:15 - the object to which the pointer points
14:17 - array names are passed as the location
14:20 - of the array origin so array arguments
14:22 - are effectively call by reference
14:25 - any function can be called recursively
14:27 - and its local variables are typically
14:29 - automatic or created anew with each
14:32 - invocation
14:33 - function definitions may not be nested
14:35 - but variables may be be declared in a
14:38 - block structured fashion
14:39 - the functions of a c program may be
14:42 - compiled separately
14:43 - variables may be internal to a function
14:46 - external but known only within a single
14:48 - source file or completely global
14:50 - internal variables may be automatic or
14:52 - static
14:53 - automatic variables may be placed in
14:55 - registers for increased efficiency but
14:58 - the register declaration is only a hint
15:00 - to the compiler and does not refer to
15:02 - specific machine registers
15:06 - c is not a strongly typed language in
15:08 - the sense of pascal or algol 68 it is
15:11 - relatively permissive about data
15:13 - conversion although it will not
15:15 - automatically convert data types with
15:16 - the wild abandon of pl1
15:19 - existing compilers provide no run time
15:21 - checking of array subscripts or argument
15:24 - types
15:24 - etc for those situations where strong
15:27 - type checking is desirable a separate
15:29 - version of the compiler is used this
15:31 - program is called lint
15:33 - apparently because it picks up bits of
15:35 - fluff from one's program lint does not
15:38 - generate code but instead
15:40 - applies a very strict check as to many
15:43 - aspects of the program as can be
15:45 - verified at compile and load time it
15:48 - detects
15:48 - type mismatches inconsistent argument
15:51 - use
15:52 - unused or apparently uninitialized
15:55 - variables potential portability
15:57 - difficulties and the like programs which
15:59 - pass unscathed through lint enjoy with
16:02 - few exceptions freedom from type errors
16:05 - about as complete as do for example
16:07 - alcohol 68 programs we will mention
16:10 - other lint capabilities as the
16:12 - occasion arises
16:14 - i would note that separately checking
16:16 - for things that might be wrong into the
16:18 - lint program keeps the c compiler simple
16:21 - and easy to port to a new computer
16:24 - the lint program was naturally a very
16:26 - portable text processing application
16:29 - while there's some overlap between a
16:31 - lint program and a compiler
16:34 - over time there's quite distinct
16:35 - research and expertise in how to lint
16:38 - versus how to compile
16:40 - modern lint programs look at programs in
16:42 - far more detail than most compilers
16:45 - separating concerns of lint and the c
16:47 - compiler also allowed lint programs to
16:51 - use more memory and take more time to
16:53 - execute than compilers
16:55 - since the typical developer might use
16:57 - the compiler many times per day and run
16:59 - lint less often it was nice for the
17:01 - compiler to run quickly and make light
17:03 - use of computer resources
17:06 - we call this idea of building two
17:08 - smaller complementary programs that each
17:10 - specialize in one task
17:12 - separation of concerns and it is an
17:14 - important principle in computer science
17:17 - by keeping each component simple in
17:18 - focus we can more easily build test and
17:22 - verify each component
17:24 - unix and c showed the benefits of taking
17:27 - many small components approach to solve
17:29 - an overall set of problems
17:32 - back to chapter zero
17:34 - finally
17:35 - c like any other language has its
17:37 - blemishes some of the operators have the
17:39 - wrong precedence
17:41 - some of the syntax could be better there
17:43 - are several versions of the language
17:45 - extent differing in minor ways
17:48 - nonetheless c has proven to be an
17:50 - extremely effective and expressive
17:52 - language for a wide variety of
17:54 - programming applications
17:56 - the rest of this book is organized as
17:58 - follows chapter 1 is a tutorial
18:00 - introduction to the central part of c
18:03 - the purpose is to get the reader started
18:05 - as quickly as possible since we believe
18:07 - strongly that the only way to learn a
18:09 - new language is to write programs in it
18:12 - this tutorial does assume a working
18:14 - knowledge of the basic elements of
18:16 - programming there is no explanation of
18:18 - computers of compilation nor the meaning
18:22 - of an expression like n equals n plus
18:23 - one
18:24 - although we have tried where possible to
18:26 - show useful programming techniques the
18:28 - book is not intended to be a reference
18:30 - work on data structures and algorithms
18:33 - when forced to make a choice we have
18:34 - concentrated on the language
18:38 - chapters two through six discuss the
18:39 - various aspects of c in more detail and
18:42 - rather more formally than does chapter 1
18:44 - although the emphasis is still on
18:46 - working examples of complete useful
18:48 - programs rather than isolated fragments
18:51 - chapter 2 deals with basic data types
18:54 - operators and expressions and chapter 3
18:56 - treats control flow if else while 4 etc
19:01 - chapter 4 covers functions and program
19:03 - structure external variables scope rules
19:06 - and so on
19:07 - chapter 5 discusses pointers and address
19:09 - arithmetic and chapter 6 contains the
19:12 - details of structures and unions
19:14 - chapter 7 describes the standard cio
19:17 - library which provides a common
19:19 - interface to the operating system this
19:21 - io library is supported on all machines
19:23 - that support c so programs which use it
19:26 - for input output and other system
19:28 - functions can be moved from one system
19:30 - to another
19:32 - essentially without change
19:34 - chapter eight describes the interface
19:36 - between c programs
19:38 - and the unix operating system
19:40 - concentrating on input output the file
19:42 - system and portability
19:44 - although some of this chapter is unix
19:46 - specific programmers who are not using
19:48 - unix systems should still find useful
19:50 - material here
19:51 - including some insight on how one
19:53 - version of the standard library is
19:55 - implemented and suggestions on achieving
19:57 - portable code
19:59 - appendix a contains the c reference
20:01 - manual this is the official statement of
20:03 - the syntax and semantics of c and except
20:07 - for one owns compiler the final arbiter
20:09 - of any ambiguities and omissions from
20:11 - earlier chapters
20:13 - since c is an evolving language that
20:15 - exists on a variety of systems some of
20:17 - the material in this book may not
20:19 - correspond to the current state of
20:21 - developments for a particular system
20:23 - we have tried to steer clear of such
20:26 - problems and warn of potential
20:27 - difficulties when in doubt however we
20:30 - have chosen generally to describe the
20:32 - pdp-11 unix system
20:34 - since that is the environment of the
20:36 - majority of c programmers appendix a
20:38 - also describes implementation
20:40 - differences on the major c systems
20:46 - chapter 1 a tutorial introduction
20:48 - let us begin with a quick introduction
20:50 - to c our aim is to show the essential
20:53 - elements of the language in real
20:54 - programs but without getting bogged down
20:57 - in details formal rules and exceptions
21:00 - at this point we are not trying to be
21:02 - complete or even precise
21:05 - we want you to get as quickly as
21:07 - possible to the point where you can
21:08 - write useful programs
21:10 - and to do that we have to concentrate on
21:12 - the basics
21:14 - variables and constants arithmetic
21:16 - control flow functions and the rudiments
21:18 - of input and output
21:20 - we are quite intentionally leaving out
21:22 - of this chapter features of c which are
21:25 - of vital importance for writing bigger
21:27 - programs these include pointers
21:30 - structures and most of c's rich set of
21:33 - operators
21:34 - several control flow statements and a
21:36 - myriad of details
21:39 - this approach has its drawbacks of
21:41 - course
21:42 - most notable is that the complete story
21:44 - on any particular language feature is
21:46 - not found in a single place
21:48 - the tutorial by being brief may also
21:51 - mislead
21:52 - and because they cannot use the full
21:54 - power of c the examples are not as
21:57 - concise and elegant as they might be
21:59 - we have tried to minimize these effects
22:02 - but be warned
22:03 - another drawback is that later chapters
22:05 - will necessarily repeat some of this
22:07 - chapter
22:08 - in any case experienced programmers
22:11 - should be able to extrapolate from the
22:12 - material in this chapter to their own
22:14 - programming needs
22:16 - beginners should supplement it by
22:17 - writing small similar programs of their
22:19 - own
22:20 - both groups can use it as a framework on
22:23 - which to hang the more detailed
22:24 - descriptions that begin in chapter 2.
22:27 - 1.1 getting started
22:31 - the only way to learn a new programming
22:32 - language is by writing programs in it
22:35 - the first program to write is the same
22:37 - for all languages print the words hello
22:41 - world
22:42 - this is the basic hurdle
22:44 - to leap over it you have to be able to
22:46 - create the program text somewhere
22:48 - compile it successfully
22:50 - load it
22:51 - run it and find out where your output
22:53 - went
22:54 - with these mechanical details mastered
22:57 - everything else is comparatively easy
23:01 - in traditional c
23:02 - the program to print hello world is
23:06 - main open parenthesis closed parenthesis
23:09 - open curly brace
23:11 - printf parentheses double quote hello
23:14 - comma space world backslash n double
23:17 - quote
23:18 - close parentheses semicolon close curly
23:21 - brace
23:23 - the modern minimal version of this
23:24 - program needs a bit more syntax we add a
23:27 - single line at the beginning
23:30 - hashtag
23:31 - include space
23:33 - left angle brackets
23:36 - stdio.h right angle bracket pound
23:39 - include
23:40 - stdio.h we have to add that line for the
23:43 - modern program
23:45 - back to the book
23:47 - just how to run this program depends on
23:49 - the system that you're using
23:51 - as a specific example on the unix
23:53 - operating system you must create the
23:56 - source program in a file whose name ends
23:58 - in dot c such as hello dot c
24:02 - and then you compile it with the command
24:04 - cc
24:06 - space hello.c
24:08 - if you haven't botched anything such as
24:10 - omitting a character or misspelling
24:12 - something the compilation will proceed
24:14 - silently and make an executable file
24:17 - called a dot out
24:19 - running that by the command
24:21 - a dot out will produce hello comma world
24:24 - as its output
24:26 - on other systems the rules will be
24:28 - different check with a local expert on
24:32 - modern systems we use the gcc compiler
24:35 - with the dash ansi option to accept the
24:37 - legacy syntax of c
24:40 - so we use gcc space minus ansi
24:44 - space hello.c
24:47 - and to run the resulting a dot out file
24:49 - you usually you need to prepend the
24:51 - local directory because most shell
24:54 - configurations do not include the
24:55 - current path in the paths to search for
24:58 - applications so you need to write
25:00 - dot slash a dot out
25:05 - now for some explanations about the
25:07 - program itself
25:08 - a c program whatever its size consists
25:12 - of one or more functions which specify
25:14 - the actual computing operations that are
25:16 - to be done
25:18 - c functions are similar to functions and
25:20 - subroutines of a fortran program or the
25:23 - procedures of pl1 pascal etc
25:27 - in our example main is such a function
25:30 - normally you are at liberty give
25:32 - functions whatever names you like but
25:34 - main is a special name
25:36 - your program begins executing at the
25:38 - beginning of main
25:40 - this means every program must have a
25:42 - main somewhere
25:44 - main will usually invoke other functions
25:46 - to perform its job
25:48 - some coming from the same program and
25:51 - others from libraries of previously
25:53 - written functions
25:55 - one method of communicating data between
25:58 - functions is by arguments
26:00 - the parentheses following the function
26:02 - name surround the argument list here
26:05 - main is a function of no arguments
26:08 - indicated by open parentheses close
26:11 - parentheses
26:12 - the curly braces enclose the statements
26:15 - that make up the function they're
26:17 - analogous to the due end of pl1 or the
26:20 - begin end of algol or pascal and so on
26:24 - a function is invoked by naming it
26:27 - followed by a parenthesized list of
26:29 - arguments
26:30 - there is no call statement as there is
26:33 - in fortran or pl1 the parentheses must
26:36 - be present even if there are no
26:38 - arguments
26:40 - in the above text the authors were
26:42 - making connections to the popular
26:44 - general purpose programming languages of
26:46 - the time
26:47 - when the book was written it was not all
26:49 - assured that c and c like languages
26:52 - would ever evolve past writing high
26:54 - performance applications
26:56 - like operating system kernels and device
26:58 - drivers
26:59 - by comparing c to these more general
27:02 - purpose languages the authors are trying
27:04 - to plant the seed that c could have
27:07 - value as a general purpose language
27:10 - back to the text
27:12 - the line that says
27:13 - printf parentheses double quote hello
27:16 - comma space world backslash and double
27:19 - quote close parentheses semicolon
27:22 - is a function call
27:24 - which calls a function named printf
27:27 - with the argument
27:28 - hello world
27:30 - printf is a library function which
27:31 - prints the output to the terminal unless
27:34 - some other destination is specified
27:37 - in this case it prints the string of
27:38 - characters that make up its argument
27:42 - any sequence of any number of characters
27:44 - enclosed in double quotes is called a
27:46 - character string or string constant
27:50 - for the moment our only use of the
27:52 - character strings will be as arguments
27:54 - to printf and other functions
27:56 - the sequence backslash n
27:59 - in the string is c notation for the new
28:02 - line character
28:03 - which when printed advances the terminal
28:06 - to the left margin on the next line
28:08 - if you leave out the backslash n
28:11 - a worthwhile experiment by the way you
28:13 - will find that your output is not
28:15 - terminated by a line feed the only way
28:17 - to get a new line character into the
28:19 - printf argument is with backslash n
28:23 - if you try to break it into two lines
28:26 - like printf quote hello world and then
28:29 - just hit the return
28:31 - double quote
28:33 - close parentheses
28:35 - semicolon on a new line the c compiler
28:37 - will print out unfriendly diagnostics
28:39 - about missing quotes
28:41 - printf never supplies a new line
28:43 - automatically so multiple calls can be
28:46 - used to build up an output line in
28:47 - stages
28:49 - our first program could have just as
28:51 - well been written as
28:53 - main open parenthesis closed parenthesis
28:55 - open curly brace
28:57 - printf quote hello quote
29:00 - semicolon
29:02 - printf quote world quote semicolon print
29:05 - f backslash n semicolon and then on a
29:10 - sixth line closed curly brace and it
29:12 - would have produced the identical output
29:15 - note that backslash n represents only a
29:18 - single character an escape sequence like
29:20 - backslash n provides a general and
29:23 - extensible mechanism for representing
29:25 - hard to get or invisible characters
29:28 - among the others that c provides are
29:30 - backslash t for tab
29:32 - backslash b for backspace
29:35 - backslash double quote for double quote
29:37 - and backslash backslash for the
29:39 - backslash itself
29:42 - 1.2
29:43 - page 8
29:45 - variables and arithmetic
29:47 - the next program prints the following
29:49 - table of fahrenheit temperatures in
29:51 - their centigrade or celsius equivalents
29:53 - using the formula c equals parenthesis 5
29:56 - divided by 9
29:58 - closed parenthesis parenthesis f minus
30:00 - 32.
30:03 - the table contains fahrenheit of 0
30:05 - celsius of negative 17.8 fahrenheit at
30:08 - 20 celsius of negative 6.7 fahrenheit of
30:12 - 40 celsius of 4.4 and so forth here is
30:16 - the program itself
30:18 - for reference this program is on page 29
30:22 - of the textbook
30:25 - so it starts with pound include stdio.h
30:29 - to include the standard library then it
30:31 - has a comment that says print the
30:32 - fahrenheit celsius table for f equals
30:35 - zero comma twenty comma dot dot dot
30:37 - comma three hundred
30:40 - close comment
30:42 - main open parenthesis close parenthesis
30:45 - open curly brace
30:47 - int
30:48 - lower comma upper comma step semicolon
30:52 - float
30:53 - far
30:54 - comma celsius
30:56 - lower equals zero semicolon followed by
30:59 - a comment
31:01 - upper equals 300 semicolon followed by a
31:04 - comment
31:05 - step equals 20 semicolon followed by a
31:08 - comment
31:10 - far equals lower
31:12 - and then
31:14 - while open parenthesis far less than or
31:17 - equal to upper closed parenthesis open
31:19 - curly brace
31:21 - celsius equals parenthesis 5.0 slash 9.0
31:26 - closed parenthesis
31:28 - asterisk
31:30 - open parenthesis far minus 32.0
31:34 - close parentheses semicolon
31:38 - then a printf statement printf open
31:41 - parentheses double quote percent 4.0 f
31:46 - space percent 6.1 f
31:50 - backslash n close quote comma far
31:53 - comma celsius
31:55 - close parentheses semicolon
31:58 - far equals far plus step
32:03 - and then a closing curly brace to finish
32:05 - the while statement and then a closing
32:07 - curly brace to finish the main statement
32:11 - the first two lines
32:13 - slash star print fahrenheit to celsius
32:16 - table for f equals zero comma twenty dot
32:19 - dot dot three hundred
32:21 - star slash are a comment
32:24 - which in this case explains briefly what
32:26 - the program does any characters between
32:30 - star and star slash are ignored by the
32:32 - compiler they may be used to freely make
32:35 - the program easier to understand
32:38 - comments may appear anywhere a blank or
32:40 - new line can
32:42 - in c all variables must be declared
32:45 - before use
32:46 - usually at the beginning of a function
32:49 - before any executable statements
32:51 - if you forget a declaration you will get
32:53 - a diagnostic from the compiler a
32:56 - declaration considered consists of a
32:58 - type and a list of variables that have
33:01 - that type as in
33:02 - int
33:03 - lower comma upper comma step semicolon
33:07 - float far celsius semicolon
33:11 - the type int
33:13 - implies that the variables listed are
33:15 - integers
33:16 - float stands for floating point i.e
33:19 - numbers which may have a fractional part
33:22 - the precision of both int and float
33:24 - depends on the particular machine that
33:26 - you are using
33:27 - on the pdp-11 for instance an int is a
33:30 - 16-bit signed number
33:32 - that is one that lies between negative
33:35 - 32
33:37 - eight
33:38 - and positive thirty two thousand seven
33:40 - sixty seven
33:42 - a float number is a thirty two bit
33:44 - quantity which amounts to about seven
33:46 - significant digits with a magnitude of
33:49 - about ten to the minus thirty eight
33:51 - and
33:53 - 10 plus 38.
33:55 - chapter 2 lists the sizes
33:58 - for other machines
34:00 - i would note that the 1970s was a time
34:03 - of transition in the amount of memory
34:05 - installed in computers
34:06 - the c language int type was 16 bits in
34:10 - the older but more generally available
34:11 - computers like the pdp-11
34:14 - c could be used to write programs like
34:16 - the unix operating system that made
34:18 - efficient use of available memory in
34:21 - particular the 1978 version of c did not
34:25 - require that computers support 32-bit
34:27 - integers
34:29 - but
34:30 - 32768 is a pretty small number the size
34:33 - of an integer affected the maximum size
34:35 - of arrays and strings
34:37 - a lot of early c programs use the long
34:40 - type to get at least a 32-bit integer
34:42 - capable of representing numbers up to
34:45 - about 2 billion
34:47 - in modern modern computers and databases
34:49 - we tend to choose between 32-bit and
34:52 - 64-bit integers
34:54 - back to the text
34:55 - c provides several other basic data
34:58 - types besides int and float
35:00 - char
35:01 - is a character a single byte short is a
35:04 - short integer
35:06 - long is a long integer and double is a
35:09 - double precision floating point
35:12 - size of these objects are also machine
35:14 - dependent and details are in chapter 2.
35:17 - there are also arrays structures and
35:19 - unions of these basic types and pointers
35:22 - to them and functions that return them
35:24 - all of which we will meet in due course
35:28 - the actual computation in our
35:29 - temperature conversion program begins
35:31 - with the assignments lower equals zero
35:34 - upper equals 300 step equals 20
35:38 - far equals lower all ending with
35:40 - semicolon
35:42 - these set the variables to their
35:44 - starting vari values
35:46 - individual statements are terminated by
35:48 - semicolons
35:50 - each line of the table is computed in
35:52 - the same way so we use a loop which
35:54 - repeats once per line this is the
35:57 - purpose of the while statement
36:00 - while parentheses far less than or equal
36:03 - upper close parentheses open curly brace
36:06 - then the body of the loop and then close
36:08 - curly brace
36:10 - the condition in the parentheses is
36:12 - tested if it is true i.e far is less
36:15 - than or equal to upper the body of the
36:17 - loop
36:18 - all of the statements included between
36:20 - the open curly brace and the closed
36:22 - curly brace are executed
36:24 - and the condition is retested if true
36:27 - the body is executed again
36:29 - when the test becomes false i.e
36:32 - far exceeds upper the loop ends and
36:35 - execution continues at the statement
36:36 - that follows the loop
36:38 - there are no further statements in the
36:40 - program so it terminates
36:43 - the body of a while loop can be one or
36:45 - more statements enclosed in braces as
36:47 - the temperature converter
36:49 - or a single statement without braces as
36:52 - in
36:53 - while open parentheses i less than j
36:56 - closed parenthesis i equals two times i
36:59 - semicolon
37:01 - in either case the statements controlled
37:03 - by the while are indented by one tab
37:06 - stop so you can see at a glance what
37:09 - statements are inside the loop
37:11 - the indentation emphasizes the logical
37:14 - structure of the program
37:16 - although c is quite permissive about
37:18 - statement positioning proper indentation
37:21 - and the use of white space are critical
37:23 - in making programs easy for people to
37:25 - read
37:26 - we recommend writing only one statement
37:29 - per line and usually leaving blanks
37:31 - around operators the position of the
37:34 - braces is less important we have chosen
37:37 - one of the several popular styles pick a
37:40 - style that suits you and then use it
37:42 - consistently
37:45 - i would add that with these words the
37:47 - authors triggered a great debate about
37:50 - how to best indent code and use curly
37:53 - braces that continues to this day
37:55 - the intention style used in this book is
37:58 - often referred to as the k and r style
38:01 - it tends to put open braces at the end
38:03 - of statements like if and while to keep
38:06 - code more compact in terms of the number
38:08 - of lines of code
38:09 - the best advice is not to debate at all
38:13 - when you modify someone else's code just
38:15 - imitate the style that they used when
38:17 - they wrote their code
38:20 - back to the text
38:24 - most of the work gets done in the body
38:26 - of the loop
38:27 - the celsius temperature is computed and
38:29 - assigned to the celsius variable by the
38:31 - statement celsius equals open
38:34 - parenthesis 5.0 slash 9.0 close
38:38 - parenthesis
38:39 - asterisk open parenthesis far
38:42 - minus
38:43 - 32.0 close parentheses semicolon
38:46 - the reason for using 5.0
38:49 - 9.0 instead of the simpler looking five
38:52 - slash nine is that in c as in many other
38:55 - languages
38:56 - integer division truncates so that any
38:59 - fractional part is discarded thus
39:02 - five slash nine
39:04 - is zero
39:05 - and of course so would then all the
39:07 - temperatures be zero
39:09 - a decimal point in a constant indicates
39:11 - that it is floating point so that 5.0
39:15 - over 9.0 is
39:18 - 0.555 repeating which is what we want
39:22 - we also wrote 32.0 instead of 32
39:26 - even though since far is a float 32
39:29 - would automatically be converted to flow
39:31 - before the subtraction
39:33 - but as a matter of style it's wise to
39:35 - write floating point constants with
39:37 - explicit decimal points even when they
39:39 - have integral values it emphasizes their
39:42 - floating point nature for human readers
39:45 - and ensures the compiler will see things
39:47 - the way you do as well
39:49 - i would note that for those of you
39:51 - familiar with python
39:53 - before python 3
39:55 - integer division truncated and returned
39:58 - an integer just like c
40:01 - in python 3 one of the major
40:03 - improvements was that the division of
40:05 - two integers performed the division
40:07 - operation in floating point and returns
40:10 - a floating point result
40:13 - c and python 2 made the choice because
40:16 - of efficiency
40:17 - integer division with truncation
40:19 - especially for 16-bit numbers was quite
40:21 - fast in the 1970s computers compared to
40:24 - floating point division that kept the
40:26 - fractional part intact
40:29 - early pdp-11 computers did integer
40:31 - division in hardware
40:33 - while all floating point was done with
40:35 - loops and functions so it was far slower
40:38 - if you wanted to write fast code in the
40:40 - 1970s you avoided floating point numbers
40:43 - except for special situations
40:47 - modern computers usually do 64-bit
40:49 - floating-point operations almost at the
40:52 - same speed as integer division so we
40:54 - don't need to allow programmers to avoid
40:56 - using floating point computations in
40:59 - their code
41:00 - the detailed rules for when integers are
41:02 - converted to floating point are in
41:04 - chapter 2.
41:05 - for now notice that the assignment far
41:09 - equals lower semicolon
41:11 - and the test while far less than or
41:14 - equals upper
41:15 - both work as expected the int is
41:18 - converted to a float before the
41:19 - operation is done
41:22 - this example also shows a bit more of
41:25 - how printf works printf is actually a
41:28 - general purpose format conversion
41:30 - function
41:31 - which we will describe completely in
41:33 - chapter 7.
41:34 - its first argument is a string of
41:36 - characters to be printed with each
41:39 - percent sign indicating where one of the
41:42 - other second third etc arguments is to
41:45 - be substituted and what form it is to be
41:47 - printed in
41:49 - for instance in the statement
41:51 - printf
41:52 - parentheses double quote percent 4.0 f
41:56 - space percent 6.1 f
41:59 - backslash n double quote comma far comma
42:02 - celsius
42:03 - the conversion specification percent 4.0
42:07 - f says that a floating point number is
42:09 - to be printed in a space at least four
42:11 - characters wide with no digits after the
42:14 - decimal point percent 6.1 f describes
42:19 - another number to occupy at least six
42:21 - spaces with one digit after the decimal
42:24 - point
42:25 - analogous to the f 6.1 of fortran
42:29 - or the f parentheses six comma one of
42:32 - pl1
42:34 - parts of a specification may be omitted
42:37 - percent six f says that the number is to
42:39 - be at least six characters wide
42:42 - percent.2f requests two places after the
42:45 - decimal point but the width is not
42:47 - constrained
42:49 - and merely
42:50 - percent f says to print the number
42:52 - itself as floating point
42:54 - printf also recognizes percent d for
42:57 - decimal integers percent o for octal
43:00 - percent x for hexadecimal and percent c
43:02 - for characters and percent s for a
43:05 - character string and percent percent for
43:08 - the percent itself
43:10 - each percent construction in the first
43:13 - argument of printf is paired with its
43:15 - corresponding second third etc
43:18 - argument
43:19 - they must line up properly by number and
43:21 - type or else you'll get meaningless
43:23 - answers
43:25 - by the way
43:26 - printf is not part of the c language
43:29 - there is no input or output defined in c
43:31 - itself
43:33 - there is nothing magic about printf it's
43:35 - just a useful function which is part of
43:38 - the standard library of routines that
43:40 - are normally accessible to c programs
43:43 - in order to concentrate on c itself we
43:45 - might we won't talk much about io
43:49 - until chapter seven
43:51 - in particular we'll defer formatted
43:54 - input until then
43:55 - if you have to input numbers read the
43:58 - discussion of the function scanf in
44:00 - chapter 7 section 7.4
44:03 - scanf is much like printf except that it
44:06 - reads input instead of writing output
44:09 - the balance between building a feature
44:12 - into the language itself and providing
44:14 - it as a function in a library is
44:16 - something that computer language
44:17 - designers struggle with many years later
44:20 - for example in python 2
44:23 - print was a language element
44:26 - in python 3 one of the non-upwards
44:28 - compatible and somewhat unpopular
44:30 - changes was changing print to be a
44:33 - function
44:34 - many programmers feel that a print
44:36 - statement is a more elegant way to
44:38 - express printing but from a compiler and
44:40 - language design perspective a function
44:43 - call with a variable number of
44:44 - parameters is seen as technically more
44:46 - elegant and flexible
44:49 - with kernighan and richie focused on
44:51 - keeping everything small and portable
44:53 - they opted to keep all input output
44:55 - functionality in libraries the syntax is
44:58 - a little more complex
45:00 - but given how computing has changed in
45:02 - the past 30 years it is the right choice
45:06 - section 1.3 the for statement
45:09 - as you might expect there are plenty of
45:11 - different ways to write a program let's
45:13 - try a variation on the temperature
45:15 - converter
45:16 - this is sample code is on page 11 of the
45:19 - textbook
45:21 - pound sign include less than stdio.h
45:24 - greater than
45:26 - main open parentheses closed parenthesis
45:29 - open curly brace
45:31 - int
45:33 - bar that is f a h r semicolon
45:38 - four open parenthesis far equals zero
45:41 - semicolon
45:42 - far less than or equal to three hundred
45:45 - semicolon
45:46 - far equals far plus 20 close parenthesis
45:50 - printf
45:51 - open parentheses
45:53 - double quote percent 4d space percent
45:56 - 6.1 f backslash n close print a close
46:00 - quote
46:02 - comma far
46:05 - comma open parenthesis 5.0 slash 9.0
46:09 - close parentheses
46:10 - asterisk open parenthesis far minus 32
46:14 - close parentheses close parenthesis
46:17 - semicolon
46:19 - this code produces the same answers as
46:21 - the one before but it certainly looks
46:22 - different one major change is the
46:24 - elimination of most of the variables
46:26 - only far fahr remains as an int to show
46:30 - the percent d conversion in printf
46:33 - the lower and upper limits of the step
46:35 - size appear only as constants in the for
46:37 - statement itself
46:39 - the 4 is a new construction and the
46:41 - expression that computes the celsius
46:43 - temperature now appears as the third
46:45 - argument of printf
46:46 - instead of in a separate assignment
46:48 - statement
46:51 - this last change is an instance of a
46:53 - quite general rule in c in any context
46:57 - where it is permission permissible to
46:59 - use the value of a variable of some type
47:01 - you can use an expression of that type
47:04 - since the third argument of printf has
47:07 - to be a floating point value to match
47:08 - the percent 6.1 f
47:11 - any floating point expression can occur
47:14 - there
47:15 - the 4 itself is a loop a generalization
47:19 - of while
47:20 - if you compare it to the earlier while
47:22 - its operation should be clear
47:24 - it contains three parts separated by
47:27 - semicolons the first part far equals
47:29 - zero is done once
47:31 - before the loop proper is entered the
47:33 - second part is the test or condition
47:35 - that controls the loop
47:37 - far less than or equal to 300.
47:40 - this condition is evaluated if it is
47:42 - true the body of a loop in this case a
47:45 - single printf is executed then the
47:47 - reinitialization step
47:49 - far equals far plus 20 is done and the
47:52 - condition is reevaluated
47:54 - the loop terminates when the condition
47:56 - becomes false
47:57 - as with the while the body of the loop
48:00 - can be a single statement or a group of
48:02 - statements enclosed in braces
48:04 - the initialization and re-initialization
48:07 - parts can be any single expression
48:10 - the choice between while and four is
48:12 - arbitrary and should be based on what
48:14 - seems clearer
48:15 - the four is usually appropriate for
48:17 - loops in which the initialization and
48:19 - reinitialization
48:20 - are single statements and logically
48:22 - related since it is more compact than
48:24 - while and keeps the loop control
48:27 - statements together in one place
48:31 - i would note that the syntax of the for
48:33 - and while loop is a feature of c and
48:36 - derived c like languages
48:38 - in modern languages we tend to have two
48:41 - kinds of loop structures
48:42 - determinant and indeterminate
48:45 - the four and the while loop structures
48:47 - in c are both indeterminate because you
48:50 - must read them closely to make sure they
48:52 - are properly constructed and for example
48:55 - are not unintentionally infinite loops
48:58 - an example of a determinant loop is the
49:01 - for each loop in php or the for loop in
49:04 - python the semantics of both of these
49:06 - loops is to iterate all the elements in
49:08 - a collection
49:10 - but since collections are never infinite
49:13 - you can be assured that these
49:14 - determinant loops will not run forever
49:17 - section 1.4 symbolic constants
49:21 - a final observation before we leave
49:23 - temperature conversion
49:25 - it's a bad practice to bury magic
49:27 - numbers or magic constants like 320
49:31 - or
49:32 - 320 in a program they convey little
49:35 - information to someone who might read
49:36 - the program later and they're hard to
49:39 - change in a systematic way
49:41 - fortunately
49:42 - c provides a way to avoid such magic
49:45 - numbers
49:46 - with the pound sign defined construction
49:48 - at the beginning of a program we can
49:50 - define a symbolic name or symbolic
49:52 - constant to be a particular string of
49:55 - characters thereafter the compiler will
49:57 - replace all unquoted occurrences of the
50:00 - name by the corresponding string
50:02 - the replacement for the name can
50:04 - actually be any text at all it's not
50:06 - related to numbers
50:09 - so this is a sample code on page 13 of
50:12 - the text
50:13 - pound sign include
50:16 - less than stdio.h greater than
50:20 - next line pound define space lower space
50:23 - zero
50:24 - next line pound define space upper space
50:28 - 300
50:29 - pound define space step space 20.
50:33 - for these pound sign statements i would
50:35 - note
50:36 - that they have to start in the first
50:38 - column
50:40 - the rest of this sample code is the code
50:42 - itself
50:43 - main open parenthesis closed parenthesis
50:45 - open curly brace
50:47 - int
50:48 - far fahr
50:51 - for
50:52 - open parentheses far equals uppercase
50:55 - lower
50:56 - semicolon far less than or equal to
51:00 - uppercase upper
51:02 - semicolon far equals far plus uppercase
51:06 - step then the same print statement
51:09 - printf
51:10 - open parentheses double quote percent 4d
51:13 - space percent 6.1 f backslash n quote
51:17 - comma
51:18 - far
51:19 - comma
51:20 - percent 5.0 9.0
51:24 - close parentheses asterisk open
51:27 - parenthesis
51:28 - far minus 32 close parenthesis close
51:30 - parenthesis semicolon and then to end
51:33 - the program close curly brace the
51:36 - quantities uppercase lower uppercase
51:38 - upper and uppercase step are constants
51:41 - so they do not appear in declarations
51:44 - symbolic names are commonly written in
51:46 - uppercase so they can be readily
51:48 - distinguished from lowercase variable
51:50 - names
51:51 - notice that there is no semicolon at the
51:54 - end of a pound defined statement
51:56 - since the whole line after the defined
51:58 - name is substituted there would be too
52:00 - many semicolons in the four
52:03 - section 1.5 a collection of useful
52:06 - programs
52:07 - we are now going to consider a family of
52:09 - related programs for doing simple
52:11 - operations on character data
52:14 - you will find that many programs are
52:15 - just expanded versions of the prototypes
52:18 - we discuss here
52:19 - character input and output
52:22 - the standard library provides functions
52:23 - for reading and writing a character at a
52:25 - time getchar
52:27 - fetches the next input character each
52:30 - time it is called and returns the
52:32 - character as its value that is
52:34 - after c equals get char open parentheses
52:38 - close parenthesis the variable c
52:40 - contains the next character of input
52:42 - these characters normally come from the
52:44 - terminal or keyboard but that need not
52:46 - concern us until chapter 7.
52:48 - the function put char open parentheses c
52:51 - close parenthesis is the complement of
52:53 - getchar
52:55 - put chair open parenthesis c close
52:58 - parenthesis
52:59 - prints the content of the variable c on
53:01 - some output medium again usually the
53:04 - terminal or screen
53:06 - calls to put char in printf may be
53:08 - interleaved the output may be a p will
53:10 - appear in the order in which the calls
53:12 - are made as with printf there is nothing
53:16 - special about gachar and putchar they
53:18 - are not part of the c language but they
53:20 - are universally available
53:24 - once again i would note that the authors
53:26 - are making the case that the syntax of
53:28 - the language should not include syntax
53:30 - for input output operations but instead
53:33 - call library functions
53:35 - keeping the compiler small and easy to
53:37 - port new systems was important to the
53:39 - creators of c
53:41 - and even if something like put char was
53:43 - part of the language syntax it would be
53:46 - translated at runtime to call a function
53:49 - programming languages from the 1960s
53:51 - tended to have a small set of use cases
53:53 - read some input run some calculation and
53:55 - then write some output
53:57 - so it seemed like a few language
53:58 - elements would be sufficient to describe
54:00 - all programs
54:01 - but as programs started to make network
54:03 - connections draw buttons on a screen or
54:06 - respond to api calls over the network
54:08 - it would have been difficult to keep
54:10 - expanding the core language syntax for
54:12 - each new use case
54:14 - but it was extremely natural to add new
54:16 - libraries to languages like c with
54:18 - functions to call to accomplish these
54:21 - new use cases
54:23 - file copying given getchar input char
54:26 - you can write a surprising amount of
54:27 - useful code without knowing anything
54:29 - more about input output the simplest
54:32 - example is a program which copies its
54:34 - input to its output one character at a
54:36 - time in outline here's what we do
54:40 - get a character
54:42 - while the character is not the end of
54:44 - file signal
54:45 - i'll put the character we just read and
54:47 - then get a new character
54:50 - converting this into c gives us the
54:52 - sample code on page 14 of the textbook
54:55 - pound includes stdio.h
54:59 - main open parentheses closed parentheses
55:01 - open curly brace
55:03 - int
55:03 - c
55:04 - semicolon c equals get char open
55:07 - parenthesis close parenthesis semicolon
55:10 - while c
55:12 - not equal eof uppercase eof close
55:15 - parenthesis open curly brace put char c
55:19 - c equals get char semicolon close
55:22 - parentheses close curly brace
55:25 - the relational
55:28 - operator exclamation equals means not
55:31 - equal to
55:34 - the main problem is detecting the end of
55:36 - the input by convention getchar returns
55:39 - the value which is a not a valid
55:41 - character when it encounters the end of
55:42 - input
55:43 - in this way programs can detect when
55:46 - they did not get a character and they've
55:48 - actually simply run out of input
55:50 - the only complication which is a serious
55:52 - nuisance is that there are two
55:54 - conventions in common use about what
55:56 - that endophile value really is
55:59 - we have deferred this issue by using the
56:02 - symbolic name eof capital eof for the
56:05 - value whatever it might be
56:07 - in practice eof will be either negative
56:10 - one or zero so the program must be pro
56:14 - seated by the appropriate pound define
56:17 - eof -1 or pound-defying eof0 to work
56:22 - properly by using the symbolic constant
56:24 - eof to represent the value that getcha
56:27 - returns when the end of file occurs we
56:29 - are assured that only one thing in the
56:31 - program defines on the specific depends
56:35 - on the specific value
56:37 - numeric value of eof
56:41 - i would
56:42 - note most of that is incorrect modern c
56:46 - compilers actually define eof in the
56:48 - stdio.h include file so you never define
56:51 - eof in your code
56:52 - in modern c the value of eof is minus
56:55 - one
56:56 - you should just include stdio.h and use
56:58 - predefined eof constant to check for end
57:00 - to file
57:01 - the nuisance of different values for eof
57:04 - was resolved shortly after 1978.
57:08 - continuing with the text
57:10 - we also declare c to be an int not a
57:12 - chair char so that it can hold the value
57:15 - which get char returns as we'll see in
57:17 - chapter two the value is actually an int
57:20 - because it must be capable of
57:21 - representing and defile in addition to
57:23 - all possible characters
57:26 - so the program for copying could
57:28 - actually be written more concisely by
57:30 - experienced c programmers in c
57:34 - any assignment such as c equals get char
57:37 - open parentheses close parenthesis can
57:39 - be used in an expression
57:41 - its value is simply the residual value
57:45 - being assigned to the left hand side
57:48 - if the assignment of a character to the
57:50 - variable c is put inside the test part
57:52 - of a while statement the file copy
57:54 - program can be written as shown in the
57:57 - example code on page 15 of the textbook
58:01 - pound include stdio.h
58:04 - main open parenthesis close parenthesis
58:07 - open curly brace
58:08 - int space c semicolon
58:11 - while open parenthesis open parenthesis
58:15 - c equals get char open parenthesis close
58:17 - parenthesis close parenthesis not equal
58:20 - eof close parenthesis put char c
58:24 - parentheses c close parenthesis
58:26 - semicolon close curly brace
58:28 - the program gets a character assigns it
58:31 - to c and then tests whether the
58:33 - character was the end of file signal
58:35 - if it was not the body of the wireless
58:37 - executed printing the character
58:40 - the while then repeats when the input is
58:42 - end of input is finally reached the wild
58:45 - terminal terminates and so does main
58:48 - this virtual version centralizes the
58:50 - input there is now only one call to get
58:52 - char and shrinks the program
58:55 - nesting an assignment is a test of one
58:57 - of the places where c
58:59 - permits a valuable conciseness it is
59:01 - possible to get carried away and create
59:04 - impenetrable code
59:05 - though a tendency that we will try
59:07 - though that is a tendency we will try to
59:10 - curb
59:11 - it's important to recognize that the
59:13 - parentheses around the assignment within
59:15 - the conditional are really necessary the
59:18 - precedence of exclamation equal not
59:21 - equals is higher than that of equals the
59:23 - assignment operator which means that in
59:26 - absence of parentheses the relational
59:28 - test exclamation equals would be done
59:30 - before the assignment
59:32 - equals
59:33 - so the statement
59:35 - c equals get char parentheses open
59:37 - parentheses close parenthesis not equal
59:38 - eof is equivalent to
59:41 - c equals get char open no sorry
59:45 - is equivalent to
59:46 - c equals open parenthesis get char open
59:49 - press the close parenthesis not equal
59:51 - eof
59:52 - close parenthesis
59:53 - this has the undefined desired effect of
59:57 - setting
59:59 - [Music]
60:01 - it is important to recognize that the
60:03 - parentheses around the assignment within
60:05 - the conditional are really necessary the
60:08 - precedence of exclamation equals is
60:10 - higher than that of
60:12 - equals which means that in the absence
60:15 - of parentheses the relational test not
60:18 - equals would be done before the
60:19 - assignment so the statement c equals get
60:22 - char not equal eof is equivalent to
60:26 - c equals open parenthesis getchar not
60:28 - equal eof close parenthesis
60:31 - this has the undesired effect of setting
60:33 - c to zero or one depending on whether or
60:36 - not the call of getchar encountered the
60:39 - end of file
60:40 - more on this in chapter 2.
60:43 - the next program counts characters it is
60:45 - a small elaboration of the copy program
60:48 - this sample code is on page 16 of the
60:50 - textbook
60:52 - pound include stdio.h
60:54 - main open parenthesis close parenthesis
60:57 - open curly brace
60:59 - long
61:00 - nc semicolon
61:02 - and c equals 0 semicolon
61:05 - while
61:06 - open parenthesis get char open
61:08 - parentheses close parenthesis
61:10 - exclamation equal eof
61:13 - plus plus nc semicolon
61:16 - printf
61:17 - double quote percent ld backslash n
61:21 - double quote comma nc parentheses
61:24 - semicolon close curly brace
61:27 - the statement plus plus nc semicolon
61:30 - shows a new operator plus plus
61:33 - which means increment by one
61:35 - you could write nc equals nc plus one
61:39 - but plus plus nc is more concise and
61:43 - often more efficient there is a
61:45 - corresponding operator minus minus to
61:47 - decrement by one
61:49 - the operators plus plus
61:53 - and minus minus can either be prefix
61:55 - operators
61:57 - plus plus c and c or postfix
62:01 - and c plus plus
62:03 - these two forms have different values
62:04 - and expressions as will be shown in
62:06 - chapter two but plus plus nc and nc plus
62:10 - plus
62:10 - both increment and c for the moment
62:13 - we'll stick to the prefix form
62:17 - the character counting program
62:18 - accumulates its count in a long variable
62:21 - instead of an int
62:22 - on a pdp 11 the maximum value of an int
62:25 - is 32
62:27 - 767 and it would take relatively little
62:30 - input to overflow that counter if it
62:32 - were declared as an int in honeywell and
62:35 - ibm c
62:36 - long and int are synonymous and much
62:38 - larger the conversion specification
62:41 - percent ld signals to printf that the
62:44 - corresponding argument is a long integer
62:48 - we again as a note we again see another
62:51 - reference to the fact that the number of
62:53 - bits of the int type is in transition in
62:55 - 1978.
62:57 - the older pdp-11 used a 16-bit integer
62:59 - to save limited memory on a small
63:02 - almost obsolete computer while later
63:04 - computers from ibm and honeywell have
63:06 - already switched to their int type to be
63:09 - 32 bits this allowed code originally for
63:12 - written for the pdp-11 like unix or even
63:15 - the c compiler to be recompiled on the
63:17 - ibm or honeywell with very few changes
63:21 - to cope with bigger numbers you can use
63:24 - a double which is a double length float
63:27 - we will also use a for statement instead
63:29 - of a while to illustrate an alternate
63:31 - way to write a while loop
63:33 - this code is the second sample code on
63:36 - page 16 of the textbook
63:39 - pound include stdio.h
63:41 - main open parentheses closed parentheses
63:43 - open curly brace
63:45 - double
63:46 - nc semicolon four open parenthesis nc
63:50 - equals zero semicolon
63:52 - get our open parenthesis close
63:54 - parenthesis not equal eof semicolon plus
63:58 - plus nc
63:59 - close parenthesis
64:01 - and then a semicolon the semicolon in
64:03 - this case is an empty statement because
64:05 - there's nothing in the body of the of
64:07 - the for loop and at the end we say
64:10 - printf double quote
64:12 - percent dot zero f backslash n
64:17 - double quote comma nc close parentheses
64:20 - semicolon
64:21 - close curly bracket
64:24 - printf uses percent f for both float and
64:26 - double
64:28 - percent.0f
64:30 - suppresses printing of the non-existent
64:32 - fraction part
64:34 - the body of the for loop here is empty
64:36 - because all the work is done in the test
64:38 - and reinitialization parts of the for
64:40 - loop
64:41 - but the grammatical rules of c require
64:44 - that a for statement have a body the
64:46 - isolated simply semicolon technically a
64:49 - null statement is there to satisfy that
64:52 - syntax requirement we put it on a
64:54 - separate line to make it more visible
64:57 - before we leave the character counting
64:59 - program observe that if the input
65:01 - contains no characters the while or for
65:05 - test fails on the very first call to get
65:07 - char so that the loop program produces
65:10 - zero the right answer
65:13 - this is an important observation
65:15 - one of the nice things about while and
65:17 - four is they are tested at the top of
65:20 - the loop proceed before proceeding with
65:22 - the body
65:23 - if there is nothing to do
65:25 - nothing is done
65:27 - even if that means never going through
65:28 - the loop body
65:30 - programs should act intelligently
65:33 - when hand handed input like no
65:35 - characters
65:36 - the while and the four statements help
65:38 - ensure that they do reasonable things
65:40 - with boundary conditions
65:44 - line counting the next program counts
65:46 - lines in its input input lines are
65:48 - assumed to be terminated by the newline
65:51 - character backslash n that has been
65:53 - carefully appended to every line written
65:55 - out
65:56 - this is sample code on line 17 of the
65:58 - textbook
65:59 - pound includes
66:01 - stdio.h
66:03 - main open parenthesis close parenthesis
66:05 - open curly brace
66:08 - int
66:09 - c comma nl semicolon
66:12 - nl equals zero semicolon
66:15 - while
66:16 - open parenthesis open parenthesis c
66:18 - equals get char open parentheses close
66:20 - parenthesis close parenthesis not equal
66:23 - eof close parenthesis
66:26 - if open parenthesis c
66:28 - double equals single quote backslash n
66:31 - single quote close parentheses
66:33 - plus plus nl semicolon
66:37 - printf
66:38 - double quote percent d backslash n
66:40 - double quote comma nl
66:43 - close parentheses semicolon close curly
66:45 - brace
66:47 - the body of the while loop now consists
66:49 - of an if
66:50 - which in turn controls the increment
66:52 - plus plus nl
66:54 - the if statement tests its parenthesized
66:57 - condition and if true does the statement
67:00 - or group of statements inside braces
67:02 - that follow
67:03 - we have again indented to show what is
67:06 - controlled by what
67:08 - the double equal sign in is the c
67:10 - notation for is equal to like fortrans
67:13 - dot eq dot
67:15 - this symbol is used to distinguish the
67:17 - equality test
67:18 - the question being asked from the single
67:21 - equal sign used for assignment
67:23 - since assignment is about twice as
67:25 - frequently used as equality testing in
67:28 - typical c programs
67:29 - it's appropriate that the operator be
67:31 - half as long
67:34 - a single character can be written
67:36 - between single quotes to produce a value
67:38 - equal to the numerical value of the
67:39 - character in the machine's character set
67:41 - this is called a character constant
67:44 - so for example single quote a single
67:47 - quote is a character constant in the
67:48 - ascii character set its value is 65 the
67:52 - internal representation of the character
67:54 - a
67:55 - of course
67:56 - double single quote a single quote is to
67:59 - be preferred over 65 its meaning is
68:01 - obvious and it is independent of a
68:03 - particular character set
68:06 - these escape sequences that are used in
68:08 - character strings are also legal in
68:10 - character constants so in tests and
68:12 - arithmetic expression expressions
68:15 - single quote backslash n single quote
68:18 - stands for the value of a new line
68:20 - character
68:21 - you should note carefully that single
68:23 - quote backslash n is a single quer
68:26 - character
68:27 - and an expressions is equivalent to a
68:29 - single integer on the other hand double
68:32 - quote backslash n double quote is a
68:34 - character string which happens to
68:36 - contain only one character the topics of
68:40 - strings versus characters is discussed
68:42 - further in chapter two
68:45 - the numeric values that are shown for
68:47 - characters are using the ascii character
68:49 - set
68:50 - the character sets in the 1970s were
68:52 - quite intricate most were eight bits
68:55 - long to conserve computer memory and
68:56 - only support a hundred or so latin-like
68:59 - characters
69:00 - this is why early programming languages
69:02 - use special characters like asterisk and
69:05 - curly brace in their syntax very
69:07 - carefully they needed to choose
69:09 - characters
69:10 - that were commonly available on computer
69:12 - keyboards from different manufacturers
69:15 - modern programming languages like python
69:17 - 3 and ruby store internal string values
69:19 - using the unicode character set so they
69:22 - are all able to represent all the
69:24 - characters in all languages around the
69:26 - world
69:28 - modern languages tend to represent 8-bit
69:31 - values in the range from 0 to 256 using
69:34 - a byte or similar type
69:36 - python 2 strings were stored as 8 bit
69:39 - bytes and python 3 strings are stored as
69:42 - 32-bit unicode characters
69:44 - moving to unicode was a major effort in
69:47 - the python 2 to python 3 transition
69:52 - word counting
69:54 - the fourth in our series of useful
69:55 - programs counts lines words and
69:58 - characters
69:59 - with a loose definition that a word is
70:01 - any sequence of characters that does not
70:03 - contain a blank a tab or a new line
70:07 - this is a very very bare bones version
70:10 - of the unix utility wc
70:14 - this example is on
70:16 - page 18 in the textbook
70:20 - pound include stdio.h pound define yes
70:24 - 1 pound to find no
70:26 - 0.
70:28 - main
70:29 - open parenthesis close parenthesis open
70:31 - curly brace
70:32 - int
70:33 - c comma nl comma nw comma nc come in
70:37 - word
70:40 - inward equals no
70:43 - l equals nw equals nc equals zero
70:47 - while
70:48 - open parenthesis open parenthesis c
70:50 - equals get char
70:52 - not equal to eof
70:55 - open curly brace plus plus nc
70:59 - if
71:00 - parentheses c double equals
71:02 - quote backslash n quote parenthesis plus
71:06 - plus nl
71:08 - if
71:09 - open parenthesis c
71:11 - double equals
71:12 - single quote space single quote
71:15 - double vertical bar
71:18 - c
71:19 - double equals
71:21 - single quote backslash n
71:23 - single quote
71:25 - double vertical bar
71:26 - c
71:27 - equals equals
71:29 - single quote backslash t
71:31 - single quote close parenthesis
71:33 - inward equals no
71:36 - else if open parenthesis inward
71:38 - equal equal no
71:40 - close parenthesis open curly brace
71:43 - inward equals yes semicolon plus plus nw
71:48 - semicolon
71:50 - close curly brace close curly brace
71:53 - printf
71:54 - open parenthesis
71:56 - double quote percent d space percent d
71:59 - space percent d backslash n double quote
72:02 - comma
72:03 - nl
72:05 - comma nw comma nc close
72:08 - curly brace
72:11 - every time the program encounters the
72:14 - first character of a word it counts it
72:17 - the variable inward records whether the
72:20 - program is currently in a word or not
72:23 - initially it is not in a word which
72:26 - which is assigned the value no
72:28 - we prefer the symbolic constants yes and
72:30 - no to the literal values one and zero
72:32 - because they make the program more
72:34 - readable
72:35 - of course in a program as tiny as this
72:37 - it makes little difference but in larger
72:38 - programs the increase of clarity is well
72:41 - worth the modest
72:43 - effort to write it this way to make it
72:45 - more readable
72:47 - you will also find that it's easier to
72:49 - make changes to programs where numbers
72:51 - appear only as symbolic constants
72:54 - the line
72:56 - nl
72:56 - equals nw equals nc equals zero
73:02 - sets all three variables to zero this is
73:04 - not a special case
73:06 - but a consequence of the fact that an
73:08 - assignment has a value and assignments
73:11 - associate right to left
73:14 - it's really as if we had written nc
73:17 - equals open parenthesis nl equals open
73:20 - parenthesis nw equals zero close
73:23 - parentheses close parenthesis semicolon
73:27 - the operator double vertical bar
73:29 - vertical bar vertical bar means or so
73:31 - the line
73:32 - if open parenthesis
73:34 - c double equals
73:36 - single quote space single quote vertical
73:39 - bar vertical bar c double equals single
73:42 - quote backslash n single quote double
73:44 - vertical bar c double equals quote
73:48 - backslash t
73:50 - quote parenthesis says
73:52 - if c is a blank or c is a new line or c
73:54 - is a tab
73:56 - the escape sequence backslash t is a
73:58 - visible representation of the tab
73:59 - character
74:01 - there is a corresponding operator which
74:02 - is double ampersand for and
74:05 - expressions connected by
74:07 - double ampersand or double vertical bar
74:09 - are evaluated left to right and it is
74:11 - guaranteed that the evaluation will stop
74:14 - as true as true soon as the truth or
74:17 - falsehood for the overall expression is
74:20 - known
74:21 - thus if c contains a blank there is no
74:24 - need to test whether contends contains a
74:26 - new line or tab so these tests are not
74:29 - made this isn't particularly important
74:31 - here but is very significant in more
74:33 - complicated situations as we will soon
74:36 - see
74:39 - i would note that the double vertical
74:40 - bar and double ampersand are the norm
74:42 - for boolean operators in c like
74:44 - languages when a new language was being
74:46 - designed it was really easy to just
74:48 - adopt the c convention for logical
74:49 - operators because while they may seem
74:51 - cryptic
74:52 - millions of software developers were
74:55 - already familiar with the operators in
74:57 - this way the relationship between c and
75:00 - c like languages is like the
75:02 - relationship between latin and romance
75:04 - languages including english
75:07 - back to the text
75:09 - the example also shows the c else
75:11 - statement which specifies an alternative
75:14 - action to be done if the condition part
75:16 - of an if statement is false the general
75:18 - form is
75:19 - if
75:20 - open parenthesis expression close
75:22 - parenthesis statement one
75:24 - else statement two
75:26 - one and only one of the two statements
75:28 - associated with an if then else is done
75:31 - if the expression is true statement one
75:33 - is executed if not statement two is
75:36 - executed
75:37 - each statement can actually be in fact
75:39 - quite complicated in the word count
75:41 - problem the one after the else is an if
75:45 - that controls two statements in braces
75:49 - section 1.6 arrays
75:52 - understanding the capabilities and
75:54 - limitations of c arrays is one of the
75:56 - most important topics
75:58 - in our historical look at the c
76:00 - programming language
76:02 - most importantly the number of elements
76:04 - in an array declaration must be a
76:06 - constant at compile time and the size of
76:10 - an array cannot be adjusted using an
76:13 - array declaration while the program's
76:14 - running
76:15 - this inability to automatically resize c
76:18 - arrays as data is added leads to a class
76:22 - of security laws that are generally
76:24 - referred to as buffer overflow where a
76:27 - program reads more data in that can fit
76:30 - into an array and is tricked to
76:31 - overriding other data or code in
76:33 - compromising an application
76:36 - later in this book we will create
76:37 - dynamic array-like structures in c using
76:40 - pointers and the standard library cialoc
76:44 - function
76:45 - python has support for a non-dynamic
76:47 - arrays buffers python buffers are
76:49 - generally not used except for
76:51 - programmers writing library code
76:53 - that talks to low-level code written in
76:55 - a language other than python or talking
76:57 - to operating system things like linux
77:00 - the more commonly used python list and
77:04 - dictionary structures can change their
77:06 - sizes automatically
77:08 - as elements are added and deleted at
77:10 - runtime
77:11 - java has support for non-dynamic arrays
77:15 - like c which are
77:17 - given a length at the moment they are
77:18 - created and the array length cannot be
77:20 - increased nor decreased without making a
77:22 - new array and copying all the elements
77:24 - from the first to the second array
77:27 - java does provide list and map
77:29 - structures that automatically adjust
77:30 - their length as data is added or removed
77:33 - java has a class called arraylist which
77:36 - can be dynamically extended but provides
77:39 - array-like linear access
77:42 - it is a list internally but it can be
77:45 - used like an array externally
77:48 - the underlying technique that is used to
77:51 - implement language structures like
77:52 - python's list
77:54 - is dynamic memory allocation in a linked
77:56 - list structure
77:57 - linked lists are one of the most
77:58 - important data structures in all of
78:00 - computer science
78:02 - we will cover dynamic allocation and
78:04 - implementing data structures in c
78:06 - in chapter 6.
78:08 - for now we will merely examine the
78:11 - syntax of c arrays but keep in mind that
78:14 - allocating an array in c is very
78:17 - different than creating a list
78:20 - in python
78:22 - back to the text
78:24 - let us write a program to count the
78:26 - number of occurrences of each digit of
78:29 - white space characters blank tab and new
78:31 - line and all other characters
78:33 - this is an artificial problem to solve
78:36 - but it permits us to illustrate several
78:38 - aspects of c
78:40 - in one program
78:42 - there are 12 categories of input so it
78:45 - is convenient
78:46 - to use an array to hold the number of
78:48 - occurrences of each digit rather than 10
78:51 - individual variables
78:53 - actually 12 individual variables
78:55 - here is one version of the program on
78:57 - page 21
78:59 - in the textbook
79:01 - and i would note that
79:03 - as these programs get larger and larger
79:05 - it is harder and harder for you to just
79:07 - listen to me read them and you have to
79:09 - go look at them in the textbook
79:12 - so i recommend that you go check out the
79:14 - textbook in page 20 and find this
79:17 - actual code
79:19 - found include
79:21 - io dot h
79:23 - main open parenthesis closed parenthesis
79:24 - open curly brace
79:26 - int
79:27 - c
79:28 - comma i comma n white comma n other
79:32 - semicolon int
79:34 - n digit
79:35 - open square bracket 10 close square
79:37 - bracket semicolon
79:40 - and white equals n other equals 0
79:43 - semicolon
79:44 - 4 open parenthesis i equals 0 semicolon
79:48 - i less than 10 semicolon plus plus i
79:51 - open let me close parenthesis
79:54 - end digit open square bracket
79:56 - i close square bracket equals zero
79:59 - semicolon
80:02 - now we're going to have a loop to read
80:04 - all of our input
80:06 - while double open parentheses c equals
80:08 - get char open parenthesis close
80:10 - parentheses and another closed
80:11 - parenthesis not equal eof close
80:14 - parenthesis
80:16 - if open parentheses c greater than or
80:19 - equal to
80:20 - single quote 0 single quote
80:23 - double ampersand
80:24 - c less than or equal single quote 9
80:27 - single quote close parenthesis
80:29 - plus plus
80:30 - in digit
80:32 - open square bracket c minus single quote
80:35 - 0 single quote close square bracket
80:38 - semicolon
80:39 - else if
80:41 - open parenthesis c double equals space
80:45 - quote space quote
80:48 - or double vertical bar c double equals
80:52 - single quote backslash n single quote
80:54 - double vertical bar c double equals
80:57 - single quote backslash t single quote
80:59 - close parenthesis
81:01 - plus plus
81:02 - and white
81:04 - semicolon
81:05 - else plus plus in other
81:08 - that if statement was a sort of three
81:09 - branches if checking to see if we were
81:11 - doing a digit
81:13 - a white space character or some other
81:16 - character
81:17 - at the end of the while loop or not the
81:19 - end of the while loop and so we say
81:20 - printf
81:21 - parentheses double quote digits equals
81:24 - double quote close parenthesis semicolon
81:26 - now we'll note in this that there is no
81:29 - new line so we can have these print defs
81:31 - kind of concatenate outward without
81:33 - going to a separate line
81:36 - four parenthesis i equals zero semicolon
81:39 - i less than 10 semicolon plus plus i
81:43 - close parenthesis
81:44 - printf
81:45 - double quote space percent d double
81:48 - quote
81:49 - comma n digit
81:51 - open square bracket i close square
81:54 - bracket close parenthesis semicolon
81:58 - printf open parenthesis
82:00 - double quote backslash n white space
82:03 - equals percent d
82:05 - comma other equals percent d backslash n
82:09 - double quote comma
82:10 - and white comma n other closed
82:13 - parentheses semicolon close curly brace
82:17 - let's go through the code
82:19 - the declaration int in digit open square
82:22 - bracket 10 closed square bracket
82:24 - semicolon declares n digit to be an
82:27 - array of 10 integers
82:30 - array of subscripts always start and 0
82:33 - in c rather than 1 as in fortran or pl1
82:36 - so the elements are end digit sub zero
82:38 - and digit sub one dot dot dot end digit
82:41 - sub nine
82:43 - square brackets are the sub
82:45 - this is reflected in the for loops which
82:47 - initialize and print the array
82:50 - a subscript can be integer any integer
82:53 - expression which of course includes
82:54 - integer variables like i and integer
82:57 - constants
82:59 - this particular program
83:01 - relies heavily on the properties of
83:04 - character representation of the digits
83:06 - for example
83:08 - if c greater than or equal to single
83:11 - quote 0 single quote double ampersand c
83:14 - less than or equal to single quote 9
83:17 - single quote close parenthesis
83:19 - determines whether it's a digit
83:22 - that is if the numeric value of the
83:24 - digit
83:26 - and the numeric value of the digit is
83:29 - c minus double quote 0 double quote this
83:31 - only works if double quote 0 double
83:34 - quote 1
83:35 - etc are positive and increasing order
83:38 - and there's nothing but digits between 0
83:39 - and 9.
83:41 - fortunately this is true for all
83:43 - conventional character sets
83:45 - by definition
83:47 - arithmetic involving chars and ends
83:50 - converts everything to int before
83:51 - proceeding so char variables and
83:53 - constants are identically
83:56 - essentially identical to instant
83:58 - arithmetic contexts
84:00 - this is quite natural and convenient for
84:02 - example c minus single quote 0 single
84:04 - quote is an integer expression that
84:07 - gives us a value between 0 and 9 an
84:09 - integer value between 0 and 9
84:11 - corresponding to the character quote 0
84:13 - quote to quote 9 quote stored in c and
84:16 - is thus a valid subscript for the ten
84:20 - element array and digit
84:23 - the decision as to whether the character
84:25 - is a digit a white space or something
84:26 - else is made by the sequence if open
84:29 - parenthesis c greater than or equal to
84:32 - quote zero quote double ampersand c less
84:35 - than or equal
84:37 - quote zero quote i quote nine quote
84:39 - close parentheses
84:41 - plus plus end digit open square bracket
84:43 - c minus quote zero quote close bracket
84:47 - semicolon else if
84:50 - c double equals single quote or
84:53 - c double equals single quote backslash n
84:56 - or c double equals single quote
84:58 - backslash t
85:00 - plus plus n white else
85:02 - plus plus and other
85:04 - the pattern
85:06 - if
85:07 - in parentheses condition statement else
85:10 - if parentheses conditions statement
85:12 - else statement occurs frequently in
85:14 - programs as a way to express a multi-way
85:17 - decision the code is simply read from
85:19 - the top of the bot to until the bottom
85:22 - until some condition is satisfied at
85:24 - that point the corresponding statement
85:26 - part is executed and the entire
85:28 - construction is finished
85:30 - of course
85:31 - statement can be several statements in
85:33 - closed embraces
85:35 - if none of the conditions are satisfied
85:37 - the statement after the final else is
85:39 - executed if present
85:41 - if the final else and statement are
85:43 - omitted as in the word count program no
85:45 - action takes place
85:47 - there can be an arbitrary number of else
85:50 - if
85:51 - condition
85:52 - statements groups between the initial if
85:54 - and the final else
85:56 - as a matter of style it is advisable to
85:58 - format this construction as we have
86:00 - shown with proper indentation so that
86:03 - long decisions do not march off the
86:05 - right side of the page
86:07 - the switch statement to be discussed in
86:09 - chapter 3 provides another way to write
86:11 - multi-way branching that is particularly
86:13 - suitable when the condition being tested
86:16 - is simply whether some integer or
86:18 - character expression
86:20 - matches one of a set of constants
86:23 - for contrast we will present a switch
86:25 - version of this program in chapter three
86:29 - functions in c a function is equivalent
86:32 - to a subroutine or function in fortran
86:34 - or a procedure in pl1 pascal etc
86:38 - a function provides a convenient way to
86:40 - encapsulate some computation in a black
86:42 - box which can then be used without
86:44 - worrying about its innards
86:46 - functions are really the only way to
86:48 - cope with the potential complexity of
86:50 - large programs
86:51 - with properly designed functions it is
86:54 - possible to ignore how a job gets done
86:56 - knowing what is done is sufficient
87:00 - c is designed to make the use of
87:02 - functions easy convenient and efficient
87:05 - you will often see a function only a few
87:07 - lines long called only once just because
87:10 - it clarifies some piece of code
87:13 - so far we have used functions like
87:15 - printf
87:16 - getchar and put char
87:18 - that have been provided for us
87:20 - now it's time to write a few of our own
87:22 - since c has no exponentiation operator
87:25 - like the double asterisk of fortran or
87:27 - pl1
87:28 - let us illustrate the mechanics of
87:30 - function definition by writing a
87:32 - function
87:33 - power open parenthesis m comma n close
87:36 - parenthesis to raise an integer
87:39 - into a positive power n
87:42 - that is the value of power parentheses 2
87:45 - comma 5 is 32.
87:48 - this function certainly doesn't do the
87:50 - whole job of
87:52 - exponentiation since it only handles
87:54 - positive powers of small integers
87:57 - but it is best to confuse only one issue
87:59 - at a time
88:01 - here is the function power and a main
88:03 - program to exercise it so you can see
88:05 - the whole structure at once
88:07 - this sample code is on page 23 of the
88:10 - textbook
88:11 - pound include stdio.h
88:14 - main open curly brace
88:17 - int i semicolon
88:19 - for for parenthesis i equals 0 semicolon
88:23 - i less than 10 semicolon plus plus i
88:26 - close parentheses
88:27 - printf
88:29 - double quote percent d space percent d
88:31 - space percent d backslash n double quote
88:34 - comma
88:35 - i comma power open parenthesis two comma
88:38 - i close parenthesis comma
88:41 - power
88:42 - open parenthesis negative three comma i
88:45 - close parenthesis close parenthesis
88:47 - semicolon close curly brace the end of
88:50 - the main now we begin the function
88:53 - power open parenthesis x comma n close
88:56 - parenthesis
88:58 - int
88:59 - x comma n semicolon open curly brace
89:03 - int i comma p
89:05 - p equals one
89:08 - four
89:10 - open parenthesis i equals 1 semicolon i
89:12 - less than or equal to n semicolon plus
89:15 - plus i
89:17 - p equals p times x semicolon return open
89:22 - parenthesis p close parenthesis
89:24 - semicolon close curly brace
89:27 - each function has the same form
89:29 - function name open parenthesis argument
89:32 - list if any
89:35 - followed by argument declarations
89:37 - if any
89:39 - followed by the body of the function
89:40 - which includes declarations and
89:42 - statements
89:44 - the functions can appear in either order
89:46 - and in one source file or two
89:49 - if of course the source file appears in
89:50 - two files you will have to say more to
89:52 - compile and load it when it fall appears
89:54 - in one but that's an operating system
89:56 - matter not a language attribute
89:59 - for the moment we'll just assume that
90:00 - both function functions are in the same
90:02 - file so whatever you learned about c
90:05 - programs running them will not change
90:08 - the function power is called twice in
90:10 - the line printf open parenthesis double
90:13 - quote percent d space percent d space
90:16 - percent d backslash n double quote comma
90:19 - i comma power open parenthesis two comma
90:22 - i close parenthesis comma power open
90:26 - parenthesis negative three comma i close
90:28 - parenthesis close parenthesis
90:31 - each call passes two arguments to the
90:34 - power function which each time returns
90:36 - an integer to be formatted and printed
90:38 - in the expression power open parenthesis
90:41 - two comma i
90:42 - is just an integer
90:44 - as two and i are
90:46 - not all functions produce an integer
90:47 - value and we'll take this up in more
90:49 - detail in chapter four
90:51 - in power
90:53 - the arguments have to be cleared
90:54 - appropriately so their types are known
90:56 - before the beginning of the body of the
90:58 - function
90:59 - this is done by the line int x comma n
91:03 - semicolon
91:04 - that follows the function name
91:06 - the argument declarations go between the
91:09 - argument list and the opening left brace
91:12 - each declaration is terminated by a
91:14 - semicolon the names used for power and
91:17 - for its arguments are purely local to
91:19 - power and not accessible to any other
91:21 - functions
91:22 - other routines can use the same names
91:24 - for their variables without conflict
91:27 - this is also true of the variables i and
91:29 - p within the function the i in power is
91:33 - unrelated to the i in main
91:35 - the value that power
91:37 - computes is returned to main by the
91:39 - return statement
91:41 - which is just as in pl1 any expression
91:45 - must occur within the parentheses
91:48 - a function need not return a value a
91:50 - return statement with no expression
91:52 - causes control but no useful value to be
91:55 - returned to the call caller as does
91:57 - falling off the end of a function by
92:00 - reaching the terminating right curly
92:03 - brace
92:05 - section 1.8 arguments call by value
92:09 - one aspect of c function which may be
92:11 - unfamiliar to programmers who are used
92:13 - to other languages particularly fortran
92:15 - and pl1
92:16 - in c all function arguments are passed
92:19 - by value
92:21 - this means that the called function is
92:23 - given the values of its arguments in
92:25 - temporary variables actually on a stack
92:28 - rather than their addresses
92:30 - this leads to some different properties
92:33 - than are seen with call by reference
92:35 - languages like fortran and pl1
92:38 - in which the called routine has handled
92:40 - the address of the argument not its
92:42 - value
92:44 - it may seem strange
92:46 - that the authors are calling so much
92:47 - attention to the fact that function
92:49 - arguments are passed call by value in
92:51 - the very first chapter
92:53 - most modern programming languages like
92:55 - python php or java pass single value
92:59 - arguments by value by default
93:01 - and to pass in an argument by reference
93:03 - you need to do something special like
93:05 - adding the ampersand in the function
93:07 - declaration in php
93:10 - passing by reference was the norm before
93:13 - c and passing by value was the norm
93:16 - after c
93:17 - since modern languages were deeply
93:19 - influenced by and often written in c
93:22 - passing by value is the norm for modern
93:24 - languages
93:26 - it's nice because it isolates the data
93:28 - in the calling code from the called code
93:31 - so the called code can't easily mess
93:33 - with its arguments either intentionally
93:36 - or by mistake and create an unexpected
93:39 - side effect and possibly a bug or
93:41 - security flaw in the calling code
93:44 - it was a bit of work to make pass by
93:47 - value work and see c implements a call
93:50 - stack
93:50 - where a bit of memory is automatically
93:53 - allocated at each function call and c
93:55 - makes a copy of the values in the
93:57 - calling code to pass them into the call
93:59 - code in a way that the calling code can
94:01 - see the values and change their local
94:03 - copies without affecting the values in
94:05 - the calling code
94:07 - the same call stack that made it
94:09 - possible
94:10 - for c function arguments to be passed by
94:12 - value
94:13 - also made it possible for a function to
94:15 - call itself
94:16 - recursively fortran functions could not
94:19 - be called recursively until the 1990
94:21 - version of fortran
94:23 - if you know your python you know that
94:26 - simple variables like integers and
94:27 - strings are passed by value while
94:30 - structured data like dictionaries and
94:31 - lists are passed by reference i.e the
94:34 - called function can modify its arguments
94:37 - we will later see this in c as well
94:41 - talking about call stacks recursive
94:43 - functions and the fact that arrays and
94:45 - structures are called by reference is
94:47 - jumping ahead somewhat
94:49 - so for now
94:50 - let's just remember the author's point
94:52 - that normal valuable
94:54 - values like integers and floats
94:57 - are passed by value in c back to the
95:00 - text
95:01 - the main distinction is that in c the
95:04 - called function cannot alter a variable
95:06 - in the calling function it can only
95:08 - alter its private temporary copy
95:11 - call by value is an asset however not a
95:14 - liability
95:15 - it usually leads to more compact
95:17 - programs with fewer extraneous variables
95:20 - because arguments can be treated as
95:21 - conveniently initialized local variables
95:23 - in the called routine
95:25 - for example here is a version of power
95:28 - which makes use of this fact
95:31 - this code is on page 24 of the text
95:36 - power
95:37 - open parenthesis x comma n close
95:40 - parenthesis
95:41 - and
95:42 - x comma n semicolon open curly brace int
95:46 - i comma p semicolon
95:49 - for
95:50 - open parenthesis p equals one semicolon
95:53 - n greater than zero semicolon minus
95:56 - minus n close parentheses
95:59 - p
95:59 - equals p times x
96:02 - semicolon
96:03 - return open parenthesis p close
96:05 - parenthesis semicolon
96:07 - close curly brace the argument n is used
96:11 - as a temporary variable and is counted
96:13 - down until it becomes zero
96:16 - there is no longer a need for the
96:18 - variable i as in the previous example
96:20 - whatever is done to end inside the power
96:23 - function has no effect on the argument
96:25 - that power was originally called with
96:28 - when necessary it is possible to arrange
96:30 - for a function to modify the variable in
96:32 - the calling routine
96:34 - the caller must provide the address of
96:36 - their variable to be set technically a
96:39 - pointer to the variable
96:41 - and the called function must declare the
96:43 - argument to be a pointer and reference
96:46 - the actual variable indirectly through
96:48 - it
96:49 - we will cover this in detail in chapter
96:52 - 5.
96:53 - when the name of an array is used as an
96:55 - argument the value passed to the
96:57 - function is actually the location
97:00 - or address of the beginning of the array
97:03 - there is no copying of the elements in
97:05 - the array
97:06 - by subscripting this value the function
97:09 - can access and alter
97:11 - any element of the array in the calling
97:14 - code
97:15 - this is the topic of the next section
97:19 - now i would recommend that you're
97:21 - careful looking at the code samples in
97:23 - the rest of this chapter recall
97:25 - that in c array sizes do not grow and
97:28 - shrink dynamically at all after they're
97:30 - allocated the authors statically
97:32 - allocate character arrays capable of
97:34 - handling up to 1 000 characters long
97:38 - their code works but it is somewhat
97:40 - brittle so look at the next two sections
97:42 - as examples of c syntax with many
97:45 - important concepts about character
97:47 - strings stored as arrays and calling
97:49 - patterns when passing arrays to
97:51 - functions as parameters that but not
97:53 - exactly the best practice when handling
97:56 - dynamically sized data
97:58 - back to the text
98:00 - probably the most common type of array
98:02 - in c is an array of characters to
98:04 - illustrate the use of character arrays
98:06 - and functions to manipulate them let's
98:08 - write a program that reads a set of
98:09 - lines and prints the longest the basic
98:12 - outline is simple enough
98:14 - while there's another line
98:16 - if it's longer than the previous longest
98:19 - save it and its length and at the very
98:21 - end print the longest line
98:24 - the outline makes it clear that the
98:25 - program divides naturally into pieces
98:28 - one piece gets a new line another checks
98:30 - it another saves it and then the rest
98:32 - controls the process
98:34 - since things divide so nicely it'd be
98:37 - it would be well to write them that way
98:39 - too
98:40 - accordingly let's write first a separate
98:43 - function called getline to fetch the
98:46 - next line of input this is a
98:47 - generalization of getchar
98:50 - to make the function useful in other
98:52 - contexts we'll try to make it as
98:53 - flexible as possible
98:55 - at the minimum
98:56 - getline has to return a signal but
98:59 - possible end of file
99:01 - a more generally useful design would be
99:02 - to return the length of the lan
99:04 - line or zero if the end of file is
99:07 - encountered
99:08 - zero is never a valid line length since
99:10 - every line has at least one character
99:13 - even a line containing only a new line
99:15 - has length one
99:17 - i would note that here in chapter one we
99:19 - have changed the book's original use of
99:21 - the function name getline to get
99:23 - underscore line in the code examples
99:25 - because it conflicts with stead the
99:27 - stdio.h
99:29 - that defines getline as a library
99:31 - function
99:32 - in this chapter the authors are
99:33 - providing examples around function
99:35 - naming and linking in later chapters
99:37 - code samples will simply use the
99:39 - built-in git line without an underscore
99:42 - to read an input
99:45 - when we find a line that is longer than
99:47 - the previous longest it must be saved
99:49 - somewhere this suggests a second
99:51 - function copy to copy the new line to a
99:54 - safe place
99:55 - finally we need a main program to
99:57 - control getline and copy
100:00 - here is the result
100:02 - the sample code for this is on page 26.
100:06 - and it's a bit long so you might want to
100:08 - show take a look at the sample code in a
100:11 - browser
100:13 - pound include stdio.h
100:16 - pound define max line 1000
100:20 - main
100:20 - open for an enclosed paren
100:23 - open curly brace
100:24 - int len
100:26 - semicolon which is the current line
100:27 - length
100:28 - int max semicolon which is the maximum
100:32 - length we've seen so far
100:34 - char
100:35 - line open square bracket
100:37 - max line close square bracket semicolon
100:41 - a character array that's the current
100:42 - input line
100:44 - and then char
100:45 - save
100:46 - open square bracket max line close
100:48 - square bracket semicolon
100:50 - which is a character array that has the
100:52 - longest line where we're going to save
100:54 - it
100:56 - onto the code
100:58 - max equals zero
101:00 - while
101:02 - open parenthesis open parenthesis len
101:04 - equals get line open parenthesis line
101:06 - comma max line close parenthesis close
101:09 - parenthesis greater than zero
101:12 - if
101:13 - len is greater than max
101:16 - open curly brace max equals len to save
101:20 - it and then copy line comma save
101:25 - close curly brace
101:27 - if open parenthesis max greater than
101:29 - zero
101:31 - i.e there was a line
101:33 - print f open parenthesis
101:35 - double quote percent s
101:38 - double quote comma save
101:39 - close curly brace to end the main
101:41 - program
101:43 - now we're in the first function
101:45 - get line open parenthesis s comma limb
101:49 - close parenthesis
101:51 - char
101:52 - s open bracket close bracket semicolon
101:56 - since it's being passed in as an
101:58 - argument
101:59 - we don't need to know the length of it
102:02 - and the
102:03 - next argument is int
102:05 - lim semicolon so getline takes
102:09 - a character array
102:11 - of unknown length and a limit that tells
102:14 - us the length of the character array
102:16 - open curly brace
102:18 - int
102:19 - c comma i semicolon
102:22 - four
102:23 - open parenthesis i equals zero semicolon
102:26 - i less than lim minus one
102:30 - double ampersand
102:31 - parenthesis
102:33 - c equals get char open parentheses close
102:35 - parenthesis close parenthesis not equal
102:38 - e o f
102:39 - and
102:40 - double ampersand c not equal
102:45 - single quote backslash n back
102:47 - single quote semicolon plus plus i
102:53 - and in the body of the loop it's s
102:56 - open square bracket i closed square
102:59 - bracket equals c
103:01 - from now on i'll read that s sub i
103:03 - equals c
103:07 - at the end of the loop we say if open
103:10 - parenthesis c double equals single quote
103:12 - backslash n single quote close
103:14 - parenthesis open curly brace
103:17 - s sub i equals c
103:20 - plus plus i close curly brace
103:24 - s sub i equals quote backslash zero
103:29 - quote semicolon
103:32 - return open parenthesis i close
103:34 - parenthesis semicolon
103:36 - close curly brace and that's the end of
103:38 - the get line function
103:41 - and now we're on to the copy function
103:44 - copy open parenthesis s1
103:47 - s2 close parenthesis the purpose of this
103:49 - function is copy s1 to s2 assume that s2
103:53 - is big enough
103:55 - the declaration is char s1
103:58 - open square bracket close square bracket
104:00 - comma s2 open square bracket close
104:02 - square bracket
104:06 - a note these arrays have a size we just
104:08 - don't know what they are and we hope
104:10 - that they're large enough
104:12 - the body of the copy function starts
104:15 - with open curly brace
104:17 - int i
104:18 - semicolon
104:20 - i equals zero
104:23 - while
104:24 - open parenthesis open parenthesis s two
104:27 - sub i equals s one sub i close
104:30 - parenthesis not equal
104:33 - single quote backslash zero single quote
104:35 - plus plus i
104:37 - close curly brace to end the copy
104:39 - function
104:42 - main and getline communicate both
104:44 - through a pair of arguments and a
104:45 - returned value in getline the arguments
104:48 - are declared by the lines char
104:51 - s
104:52 - open square bracket close square bracket
104:53 - semicolon int
104:55 - lim semicolon
104:57 - which specify that the first argument is
104:59 - an array
105:00 - of unknown length and the second is an
105:03 - integer
105:04 - the length of the array s is not
105:06 - specified in getline since it's
105:08 - determined in main
105:10 - getline
105:12 - uses return to send a value back to the
105:14 - caller just as the function power did
105:17 - some functions return a useful value
105:19 - others like copy are only used for their
105:22 - effect and return no value
105:24 - getline puts the character backslash 0
105:27 - the null character whose integer value
105:30 - is zero at the end of the array it's
105:32 - creating to mark the end of the string
105:34 - of characters
105:35 - this convention is also used by the c
105:38 - compiler
105:39 - with a when a string constant like
105:41 - double quote
105:42 - h-e-l-l-o backslash n double quote is
105:46 - written in a c program the compiler
105:49 - creates an array of characters
105:51 - containing the characters of the string
105:53 - and adds a backslash zero
105:56 - at the end to terminate it so that
105:58 - functions such as printf can detect the
106:00 - end
106:02 - so
106:03 - that would lead to an array that has
106:06 - h e
106:08 - l
106:09 - l o backslash n backslash zero so it's a
106:14 - five character array
106:16 - with a new line which is a sixth
106:18 - character and then backslash zero which
106:20 - is an actual character again
106:22 - we don't know the arrays don't know
106:24 - their length and so you use the
106:26 - backslash 0
106:27 - as the indicator of the end of a string
106:31 - the percent s format specification in
106:33 - printf expects a string represented in
106:36 - exactly this form if you examine copy
106:39 - you will discover that it too relies on
106:41 - the fact that its input argument s1 is
106:44 - terminated by backslash zero
106:47 - and it copies this character backslash
106:50 - zero
106:50 - into the argument
106:52 - output argument s2
106:55 - all of this implies that backslash 0
106:58 - is not part of normal text it's merely a
107:00 - marker
107:02 - it is worth mentioning in passing
107:04 - that even a program as small as this one
107:08 - presents some sticky design problems
107:11 - for example
107:12 - what should maine do if it encounters a
107:14 - line which is bigger than its limit
107:17 - getline
107:19 - works properly and then it stops
107:21 - collecting when the array is full
107:23 - even if no new line has been seen
107:26 - by testing the length in the last
107:27 - character returned main can determine
107:31 - whether the line was too long then cope
107:32 - with it as it wishes
107:34 - in interest of brevity we have ignored
107:37 - this issue
107:40 - there is also no way for a user of
107:42 - getline function to know in advance how
107:45 - long an input line might be
107:47 - so getline checks for overflow on the
107:50 - other hand a user of the copy function
107:52 - already knows or should be able to find
107:54 - out how big the strings are so we have
107:57 - have chosen not to add error checking to
108:00 - it
108:03 - section
108:05 - section 1.10 scope
108:08 - external variables
108:09 - the variables in main
108:11 - line save etc are private or local to
108:16 - main
108:17 - because they are declared within main no
108:19 - other function can have direct access to
108:21 - them
108:22 - the same is true of the variables in the
108:24 - other functions for example the variable
108:26 - i in getline is unrelated to the i in
108:29 - copy
108:31 - each local variable in a routine comes
108:33 - into existence only when a function is
108:35 - called and disappears when the function
108:37 - is exited
108:39 - it is for this reason that such
108:41 - variables are usually known as automatic
108:43 - variables following terminology in other
108:46 - languages
108:47 - we'll use the term automatic henceforth
108:50 - to refer to these dynamic local
108:52 - variables
108:53 - chapter 4 discusses the static storage
108:55 - class in which local variables do retain
108:58 - their values between function
108:59 - invocations
109:01 - because automatic variables come and go
109:03 - with function in invocation
109:06 - they do not retain their values from one
109:08 - call to the next and must be explicitly
109:10 - set upon each entry
109:12 - if they are not set they will contain
109:15 - garbage
109:16 - as an alternative to automatic variables
109:19 - it is possible to define variables which
109:21 - are external to all functions that is
109:23 - global variables which can be accessed
109:26 - by name by any function that cares to
109:29 - this function is rather like fortran
109:31 - common or pl1 external
109:34 - because external variables are globally
109:36 - accessible they can be used instead of
109:38 - arguments to communicate data between
109:40 - functions furthermore because external
109:43 - variables remain in existence
109:45 - permanently rather than appearing and
109:47 - disappearing as functions are called and
109:48 - exited they retain their values even
109:51 - after the functions that set them are
109:54 - done
109:55 - an external variable has to be defined
109:57 - outside of any function this allocates
110:01 - actual storage for it the function also
110:03 - must be declared and each function that
110:05 - wants to access it
110:07 - this may be done either by an explicit
110:10 - extern declaration or implicitly by
110:13 - context
110:14 - to make the discussion concrete let's
110:16 - rewrite the longest line program with
110:19 - line save and max
110:22 - as external variables this requires
110:24 - changing the calls declarations and
110:27 - bodies of all three functions
110:30 - this sample code is on page 29 of the
110:33 - textbook and it's pretty long but i'll
110:36 - read it for you pound include stdio.h
110:40 - pound define max line 1000.
110:44 - and we're still outside of main char
110:46 - line
110:47 - open bracket max line close bracket
110:50 - semicolon
110:52 - char save open bracket max line
110:55 - semicolon
110:56 - int max semicolon those are our three
110:59 - global variables
111:01 - starting the main
111:03 - main open friend close paren
111:05 - open curly brace
111:08 - intlen
111:10 - extern int max so we're saying that this
111:13 - is an integer but it's also not to be
111:15 - allocated inside of main
111:18 - extern char save
111:20 - open
111:21 - square bracket close square bracket
111:24 - the line length the length of the save
111:27 - array is defined above so we don't need
111:29 - to define it here
111:32 - max equals zero semicolon
111:34 - while
111:35 - double parenthesis land double left
111:37 - parenthesis len equals get line
111:40 - parenthesis greater than zero
111:42 - parenthesis
111:43 - if parenthesis len greater than max
111:47 - open curly brace
111:48 - max equals len
111:50 - copy open parenthesis no parenthesis
111:53 - semicolon no parameters to copy
111:55 - because it's going to simply talk to the
111:57 - global variables
111:58 - close curly brace
112:00 - after the loop finishes we say if open
112:02 - parenthesis max greater than zero
112:05 - then printf
112:07 - open parentheses double quote percent s
112:09 - double quote comma save
112:12 - close parenthesis semicolon
112:14 - close close curly brace and that is the
112:17 - end of the main
112:19 - so now we have the getline function
112:20 - which is specialized to deal with
112:23 - external variables
112:25 - okay
112:28 - so
112:29 - we start get line open parentheses close
112:31 - parenthesis no parameters open curly
112:34 - brace int comma c comma int c comma i
112:39 - semicolon these are local variables
112:41 - extern char line open curly brace closed
112:45 - curly brace semicolon
112:48 - this is the our reference inside of
112:51 - getline to the global variable line
112:55 - four open parenthesis i equals 0
112:58 - semicolon i less than max line minus 1
113:02 - max line minus 1 max line is a
113:04 - predefined constant at compile time
113:09 - for i less than max line -1 double
113:11 - ampersand parenthesis c equals get char
113:14 - open parenthesis close parenthesis close
113:16 - parenthesis not equal eof
113:19 - double ampersand
113:21 - i.e and
113:22 - c not equal single quote backslash n
113:26 - single quote semicolon plus plus i
113:29 - lines sub i equals c
113:32 - that's the for loop that in effect reads
113:34 - characters one at a time and puts them
113:35 - in line
113:38 - after the for loop
113:40 - we say if open parenthesis c double
113:43 - equals
113:44 - single quote backslash n single quote
113:46 - close parentheses open curly brace
113:48 - line sub i equals c plus plus i
113:52 - close curly brace this ensures that we
113:55 - append the new line to the function
113:59 - line sub i
114:01 - equals
114:03 - single quote backslash zero backslash
114:05 - that's semicolon the
114:07 - that's the string termination character
114:10 - return i
114:12 - return open parenthesis i close
114:14 - parentheses this is the length that
114:16 - getline is returning and then close
114:18 - curly brace to end the getline function
114:21 - and then we have the copy function and
114:22 - it's again it takes no parameters copy
114:25 - open parentheses close parenthesis curly
114:27 - brace and i
114:29 - extern
114:30 - char
114:31 - line
114:32 - open bracket close bracket
114:34 - comma save open bracket close bracket
114:37 - semicolon
114:38 - i equals 0
114:40 - while
114:41 - parentheses open parenthesis open
114:43 - parenthesis save sub i
114:45 - equals line sub i
114:48 - close parenthesis is not equal
114:50 - quote backslash zero quote
114:53 - plus plus i
114:56 - close curly brace for copy
114:59 - so the external variables in main
115:01 - getline and copy are defined by the very
115:04 - first lines in the example above outside
115:07 - of main which state their type and cause
115:10 - storage to be allocated for them
115:12 - syntactically
115:13 - external definitions are just like the
115:15 - declarations we used previously but
115:18 - because they occur outside of any
115:20 - function including outside the main
115:22 - function the variables are external
115:24 - before a function can use or access an
115:27 - external variable the name of the
115:29 - variable must be made known to the
115:31 - function one way to do this is to write
115:34 - an extern declaration in the function
115:36 - the declaration is the same as before
115:38 - except for the added keyword
115:41 - extern
115:42 - in certain circumstances the extern
115:45 - declaration can be admitted omitted
115:48 - if the external definition of the
115:49 - variable occurs in the same source file
115:52 - before it's used in a particular
115:54 - function then there's no need for an
115:56 - extern declaration in the function
115:58 - the extern declarations in main and
116:00 - getline and copy are thus redundant in
116:02 - fact common practice is to place all
116:05 - definition of all external variables at
116:08 - the beginning of the source file and
116:10 - then omit all extern declarations
116:14 - if the program is in several source
116:16 - files and a variable is defined in say
116:18 - file 1 and used in file 2 then an extern
116:22 - declaration is needed in file 2 to
116:24 - connect the two occurrences of the
116:26 - variables
116:27 - this topic is discussed at length in
116:29 - chapter 4.
116:30 - you should note that we are using the
116:32 - words declaration and definition very
116:35 - carefully when we refer to external
116:36 - variables in this section
116:38 - definition refers to the place where the
116:40 - variable is actually created or assigned
116:42 - storage declaration
116:45 - refers to places where the nature of the
116:46 - variable is stated but no storage is
116:49 - allocated
116:50 - by the way there is a tendency to make
116:52 - everything inside an extern variable
116:54 - because it appears to simplify things
116:57 - argument lists are short and variables
116:59 - are always there when you want them but
117:01 - external variables are always there
117:03 - also when you don't want them the style
117:06 - of coding is fraught with peril since it
117:08 - leads to programs whose data connections
117:10 - are not at all obvious
117:12 - variables can be changed in unexpected
117:14 - and even inadvertent ways and the
117:16 - program is hard to modify when it
117:18 - becomes necessary the second version of
117:21 - the longest line program is inferior to
117:23 - the first partly because of these
117:25 - reasons and partly because it destroys
117:28 - the general at generality of two quite
117:30 - useful functions by hardwiring them into
117:33 - the names of the variables they will
117:35 - manipulate
117:37 - section 1.11
117:39 - summary
117:40 - at this point we have covered what might
117:42 - be called the conventional core of c
117:44 - with this handful of building blocks
117:46 - it's possible to write useful programs
117:48 - of considerable size
117:51 - it probably a good idea if you paused
117:53 - long enough to do so the exercises that
117:56 - follow are intended to give you
117:57 - suggestions for programs of somewhat
118:00 - greater complexity than the ones
118:02 - presented in this chapter
118:04 - after you have this much sea under
118:06 - control it will be well worth your
118:08 - effort to read on for the features
118:11 - covered in the next few chapters are
118:13 - where the power and expressiveness of
118:15 - the language begin to become
118:18 - apparent this work
118:21 - is based on the 1978 c programming book
118:24 - written by brian w kernighan and dennis
118:26 - m ritchie
118:27 - their book is copyright all rights
118:29 - reserved by att
118:31 - but is used in this work under fair use
118:33 - because of the book's historical and
118:35 - scholarly significance
118:37 - its lack of availability and the lack of
118:39 - an accessible version of the book
118:41 - the book is augmented in places to help
118:43 - understand its rightful place in a
118:45 - historical context amidst the major
118:47 - changes of the 1970s and 1980s as
118:50 - computer science evolved from a
118:52 - hardware-first vendor-centered approach
118:54 - to a software-centered approach where
118:56 - portable operating systems and
118:58 - applications written in c could run on
119:00 - any hardware
119:02 - this is not the ideal book to learn c
119:04 - programming because the 1978 edition
119:07 - does not reflect the modern c language
119:09 - using an obsolete book gives us an
119:11 - opportunity to take students back in
119:13 - time and understand how the c language
119:16 - was evolving as it laid the groundwork
119:18 - for a future with portable applications
119:24 - chapter 2 types operators and
119:26 - expressions
119:28 - variables and constants are the basic
119:30 - data objects manipulated in a program
119:33 - declarations list the variables to be
119:34 - used and state what type they have and
119:36 - perhaps what their initial values are
119:39 - operators specify what is to be done to
119:41 - them expressions combine variables and
119:43 - constants to produce new values these
119:46 - are the topics of this chapter
119:48 - section 2.1 variable names
119:52 - although we didn't come out and say so
119:54 - there are some restrictions on variable
119:56 - and symbolic constant names
119:58 - names are made up of letters and digits
120:00 - the first character must be a letter
120:02 - the underscore counts as a letter it is
120:05 - useful for improving the readability of
120:07 - long variable names
120:08 - upper and lower case are different
120:11 - traditional c practice is to use
120:12 - lowercase for variable names in all
120:14 - uppercase for symbolic constants
120:18 - only the first eight characters of an
120:19 - internal name are significant although
120:21 - more may be used for external names such
120:24 - as function names and external variables
120:26 - the number must be less than 8 because
120:28 - external names are used by various
120:30 - assemblers and loaders
120:32 - appendix a lists the details furthermore
120:35 - keywords like if else int float etc are
120:39 - reserved you can't use them as variable
120:41 - names and they must be in lower case
120:44 - i would note that in modern c languages
120:46 - the limitation of the first eight
120:48 - characters of a variable name being
120:49 - unique has been extended in most c
120:51 - variants
120:53 - at least 30 characters of a variable are
120:55 - treated as unique the it character
120:57 - limitation was to reflect the typical
120:59 - limitation of identifier length in
121:00 - assembly language programming and
121:02 - runtime linkers of the time
121:05 - naturally it's wise to choose variable
121:07 - names that mean something that are
121:08 - related to the purpose of the variable
121:10 - and are unlikely to get mixed up
121:12 - typographically
121:14 - section 2.2 data types and sizes
121:17 - there are only a few basic data types in
121:20 - c
121:20 - char which is a single byte
121:23 - capable of holding one character in the
121:24 - local character set
121:26 - and
121:27 - an integer typically reflecting the
121:29 - natural size of integers on the host
121:31 - machine
121:32 - float a single precision floating point
121:35 - and double is a double precision
121:37 - floating point
121:38 - in addition there are a number of
121:40 - qualifiers which can be applied to end
121:42 - short
121:43 - long and unsigned
121:45 - short and long refer to different sizes
121:47 - of integers
121:49 - unsigned numbers
121:50 - obey the arithmetic of modulo 2 to the n
121:53 - where n is the number of bits in an int
121:56 - unsigned numbers are always positive
121:59 - the declarations for qualifiers look
122:00 - like
122:02 - short int x semicolon
122:05 - long int y semicolon
122:08 - unsigned and z semicolon
122:13 - the word in can be omitted in such
122:15 - situations and typically is the
122:18 - precision of these objects depends on
122:19 - the machine at hand the table below
122:22 - shows some representative values
122:25 - on a dec pdp 11 a char is 8 bits on into
122:29 - 16 a short is 16 a char is 32 a float is
122:33 - 32 a double is 64.
122:36 - on a honeywell 6000
122:38 - which uses ascii character set a char is
122:40 - 9 bits an int is 36 bits as short as 36
122:44 - bits a char is 36 bits and a float is 36
122:47 - bits and a double is 32 bits
122:50 - on the ibm 370 which is ebcdic
122:54 - in its character set a char is 8 bits
122:56 - and int is 32 bits as short is 16 bits a
123:00 - char is 32 bits a float is 32 bits and a
123:03 - double is 64 bits
123:05 - and so on the intent is that short and
123:08 - long should provide different lengths of
123:09 - integers where practical
123:12 - int will normally reflect the most
123:14 - natural size of a particular machine
123:17 - as you can see each compiler is free to
123:20 - interpret short and long as appropriate
123:21 - for their own hardware
123:23 - about all you should count on is that
123:25 - short is no longer than long
123:30 - in this table we see that in the
123:31 - mid-1970s
123:33 - c was designed to support a range of
123:35 - computer generations the pdp-11 was a
123:37 - common previous generation computer that
123:40 - had less memory so variable sizes were
123:42 - kept small
123:43 - the more modern computers in the chart
123:45 - had a bit more memory and could afford
123:47 - to have slightly larger larger sizes
123:49 - the idea of a natural size is the size
123:52 - that could be loaded computed and stored
123:55 - in usually of single machine language
123:58 - instruction
123:59 - you knew as a programmer that when used
124:00 - int the machine code you would generate
124:03 - would not need to include an extra
124:05 - instructions for a simple line of code
124:07 - like x equals x plus one semicolon
124:11 - modern int values in c are 32 bits long
124:13 - and long values are 64 bits long
124:16 - even though modern computers can do
124:18 - 64-bit computations in a single
124:20 - instruction using the shorter int type
124:22 - when appropriate can save on memory
124:24 - storage and memory bandwidth using int
124:26 - values
124:27 - interestingly the length of a 32-bit int
124:30 - leads to a unix and c problem with dates
124:34 - that is called the year 2038 problem a
124:37 - common way to represent time in unix c
124:39 - programs was as a 32-bit integer of the
124:42 - number of seconds since
124:44 - january first 1970. it was quick and
124:47 - easy to compare or add or subtract
124:51 - these second counter dates in code and
124:53 - even in databases but the number of
124:55 - seconds since january 1st 1970 will
124:58 - overflow a 30-bit number on the 19th of
125:01 - january in 2038.
125:03 - by now in order to avoid systems in
125:06 - order to avoid problems most systems
125:08 - have converted to storing these number
125:10 - of second values in long or 64-bit
125:13 - values
125:14 - which gives us almost 300 billion years
125:16 - until we need to worry about overflowing
125:18 - second timer counters again
125:21 - back when c was developed we had two
125:23 - different character sets and two
125:25 - different character variable lengths the
125:27 - world generally standardized on the
125:29 - ascii character set for the core western
125:31 - characters and the unicode utf-8 to
125:34 - represent all characters in all
125:36 - languages worldwide
125:38 - but that is a story for another time for
125:40 - now just think of the char type as also
125:43 - a byte type it is 8 bits in length and
125:46 - can store ascii
125:48 - modern languages like python or java
125:50 - have excellent support for wide
125:52 - character sets in our historical look at
125:54 - c we will not cover wide or multi-byte
125:57 - characters
125:59 - also if you look at the float and double
126:00 - types you will see different bit sizes
126:04 - even worse
126:06 - each of these computers in the 1970s did
126:08 - floating point computation using
126:10 - slightly different hardware
126:11 - implementations and the same code run on
126:14 - different computers would give slightly
126:16 - different results and have unpredictable
126:18 - behavior on overflow underflow and other
126:21 - extraordinary floating point operations
126:24 - this was solved by the introduction of
126:26 - the ieee 754
126:29 - standard in 1985 which standardized
126:31 - floating point format
126:33 - this standardized both the length of the
126:35 - float and the double but also ensured
126:37 - that the same set of floating point
126:39 - calculations would produce the exact
126:41 - same result
126:43 - on different processors
126:45 - 2.3 constants int and float constants
126:49 - have already been disposed of except to
126:51 - note that the usual
126:54 - 123.456 e minus 7 or
126:58 - 0.12
127:00 - e3 scientific notation for floats is
127:04 - also legal
127:05 - every floating point constant is taken
127:07 - to be double so the e notation
127:10 - serves for both float and double
127:13 - long constants are written in the style
127:15 - 1 2 3 capital l
127:17 - an ordinary integer constant that is too
127:20 - long to fit into an int is also assumed
127:23 - to be a long
127:24 - there is a notation for octal and
127:26 - hexadecimal constants
127:28 - a leading zero on an int constant
127:31 - implies octal
127:33 - and a leading zero x or zero x upper
127:36 - case indicates hexadecimal
127:39 - for example the decimal 31 can be
127:41 - written as 037 in octal and 0x1 f
127:47 - or 0x1 f where f is capitalized in hex
127:51 - hexadecimal and octal constants may also
127:54 - be followed by the letter l to make them
127:57 - long
127:58 - a character constant is a single
128:00 - character written in single quotes as in
128:02 - quote x quote the value of the character
128:05 - constant is the numeric value of the
128:07 - character in the machine's character set
128:10 - for example the ascii character set
128:12 - 0
128:13 - or quote 0 quote is 48 and an ebcdic
128:17 - quote 0 quote is 240. both quite
128:20 - different from the numeric value zero
128:23 - writing quote zero quote instead of a
128:25 - numeric value like 48 or 240 makes the
128:28 - program independent of the particular
128:30 - value
128:31 - character constants participate in
128:33 - numeric operations just like any other
128:36 - numbers
128:37 - although they are most often used in
128:38 - comparisons with other characters
128:42 - a later section treats conversion rules
128:46 - certain non-graphic characters can be
128:48 - represented in character constants by
128:50 - escape sequence like backslash n for
128:53 - newline backslash t for tab backslash
128:56 - zero for null backslash backslash for
128:58 - backslash itself and backslash quote for
129:01 - single quote etc these look like two
129:04 - characters but they're actually only one
129:07 - in addition an arbitrary byte space bit
129:10 - pattern can be generated by writing
129:14 - single quote backslash and then three
129:16 - digits single quote where the three
129:19 - digits is one to three octal digits as
129:21 - in
129:22 - pound define space form feed single
129:26 - quote backslash zero one four
129:28 - single quote which is ascii for a form
129:31 - feed
129:32 - we mentioned
129:34 - form feed here because in the 1970s we
129:36 - sent much of our output to printers
129:38 - physical printers a form feed was the
129:41 - character we would send to the printer
129:42 - to
129:44 - advance to the top of a new page
129:47 - the character constant quote backslash
129:50 - zero quote
129:52 - represents the character with the value
129:54 - zero
129:56 - quote backslash zero quote is often
129:59 - written instead of zero to emphasize the
130:01 - character nature of some expression
130:05 - a constant expression is an expression
130:07 - that only involves constants
130:10 - such expressions are evaluated at
130:11 - compile time rather than run time and
130:14 - accordingly may be used in
130:16 - any place a constant maybe as in
130:19 - pound define
130:20 - max line 1000
130:23 - char
130:25 - line open bracket max line plus 1 close
130:28 - bracket
130:31 - semicolon
130:32 - or
130:33 - seconds equals 60 times 60 times hours
130:39 - a string constant is a sequence of zero
130:42 - or more characters surrounded by double
130:44 - quotes as in double quote i
130:47 - space am space a space string double
130:50 - quote
130:52 - or
130:52 - double quote double quote which is a way
130:55 - to show an empty string
130:57 - the quotes are not part of the string
130:59 - but only serve to delimit it the same
131:02 - escape sequences used for character
131:04 - constants apply in strings
131:06 - backslash double quote represents the
131:08 - double quote character
131:10 - technically a string is an array whose
131:13 - elements are single characters
131:15 - the compiler automatically places the
131:17 - null character backslash zero at the end
131:20 - of each such string so programs can
131:22 - conveniently find the end this
131:24 - representation means that there is no
131:26 - real limit on how long a string can be
131:29 - but programs have to scan one to
131:31 - completely determine its length
131:34 - the physical storage required is one
131:36 - more location than the number of
131:38 - characters written between the quotes
131:40 - the following function sterlin
131:43 - taking the parameter s returns the
131:45 - length of the character string s
131:47 - excluding the terminal backslash zero
131:51 - sterling open parentheses s close
131:53 - parenthesis
131:55 - char
131:56 - s
131:57 - open bracket close bracket semicolon
131:59 - open curly brace
132:01 - int space i semicolon
132:04 - i equals zero semicolon
132:08 - while parentheses s
132:10 - sub i
132:12 - exclamation equals
132:14 - quote backslash zero quote close
132:17 - parentheses
132:18 - plus plus i semicolon
132:21 - return parentheses i parentheses
132:24 - semicolon close curly brace
132:27 - be careful to distinguish between the
132:29 - character constant and a string that
132:31 - contains a single character single quote
132:34 - x single quote is not the same as double
132:36 - quote x double quote the former is a
132:39 - single character used to produce the
132:41 - numerical value of the letter x of the
132:42 - machine's character set the latter is a
132:45 - character string that contains one
132:46 - character the letter x and a backslash
132:49 - zero
132:51 - section 2.4
132:53 - all variables must be declared before
132:55 - use although certain declarations can be
132:57 - made implicitly by context
132:59 - a declaration specifies a type and is
133:02 - followed by a list of one or more
133:04 - variables of that type as in
133:06 - int
133:08 - lower comma upper comma step semicolon
133:11 - char
133:12 - c comma line
133:15 - open bracket 1000 close bracket
133:17 - semicolon
133:19 - variables can be distributed among
133:20 - declaration in any fashion the list
133:23 - above could we could be equally well
133:25 - written as
133:27 - int lower semicolon in upper semicolon
133:30 - in step semicolon char c semicolon char
133:35 - line open bracket 1000 close bracket
133:37 - semicolon the latter form takes more
133:40 - room but it is convenient for adding a
133:42 - comment to each declaration or for
133:44 - subsequent modifications
133:47 - variables may also be initialized in
133:49 - their declaration although there are
133:51 - some restrictions
133:52 - if the name is followed by an equal sign
133:54 - in a constant that serves as an
133:56 - initializer as in char
133:59 - backslash equals
134:01 - single quote backslash backslash single
134:03 - quote semicolon
134:05 - int
134:06 - i equals 0 semicolon
134:09 - float eps equals 1.0 e minus 5 semicolon
134:15 - if the variable in question is external
134:17 - or static the initialization is done
134:20 - once only conceptually before the
134:22 - program starts executing
134:24 - explicitly initialized automatic
134:26 - variables are initialized each time the
134:28 - function they are in is called
134:30 - automatic variables for which there is
134:32 - no explicit initializer have undefined
134:35 - that is garbage values
134:37 - external and static variables are
134:39 - initialized to zero by default but it is
134:41 - a good style to state the initialization
134:44 - anyway
134:45 - we will discuss initialization further
134:47 - as new data types are introduced
134:51 - section
134:52 - 2.5 arithmetic operators
134:56 - the binary operators
134:58 - are
134:58 - plus
135:00 - minus
135:00 - asterisk and slash
135:03 - and the modulus operator percent
135:05 - there is a unary minus but no unary plus
135:10 - integer division truncates any
135:12 - fractional fractional part the
135:15 - expression x percent y
135:18 - produces the remainder when x is divided
135:20 - by y and is thus zero when y divides x
135:24 - exactly
135:26 - for example a year is a leap year if it
135:29 - is divisible by 4 but not by 100
135:32 - except that years divisible by 4 are
135:34 - leap years therefore
135:37 - if parentheses year percent for equal
135:40 - equal zero
135:42 - and and
135:43 - year percent
135:45 - 100 not equal zero
135:48 - or
135:49 - year percent 400 equal equal zero it's a
135:53 - leap year
135:54 - else it's not
135:56 - the percent operator cannot be applied
135:58 - to float or double
136:01 - the plus and minus operators have the
136:03 - same precedence
136:04 - which is lower than the identical
136:07 - precedence of asterisk slash and percent
136:10 - which are in turn lower than unary minus
136:14 - arithmetic operators group from left to
136:16 - right a table at the end of this chapter
136:19 - summarizes precedence and associativity
136:21 - for all operators
136:23 - the order of evaluation is not specified
136:26 - for associative and commutative
136:28 - operators like asterisk and plus
136:31 - the compiler may rearrange a
136:33 - parenthesized computation involving
136:35 - these thus
136:37 - a plus open parenthesis b plus c closed
136:39 - parenthesis can be evaluated as
136:43 - open parenthesis a plus b close
136:44 - parentheses plus c
136:46 - this rarely makes any difference but if
136:49 - a particular order is required explicit
136:52 - temporary variables might be used
136:54 - the action on overflow or underflow
136:57 - depends on the machine at hand
137:00 - i would note that the above
137:02 - paragraph allows the compiler
137:09 - i would note that the above paragraph
137:11 - allowing the compiler to reorder
137:13 - computations even in the parentheses
137:15 - presence of parentheses is known as the
137:17 - knr c arrangement license
137:21 - as the authors state it almost never
137:23 - makes a difference unless an expression
137:25 - contains a value computed in a function
137:27 - call or is there a pointered lookup to
137:29 - find a value for the computation that
137:31 - might fail
137:32 - the rule was subtly adjusted in the iso
137:35 - version of c but iso c still does not
137:38 - strictly force the order of otherwise
137:40 - commutative operations even in the pr
137:43 - presence of parentheses
137:46 - the good news is that as long as you
137:47 - keep your expression simple you don't
137:49 - have to worry about this rule sometimes
137:50 - the real value of parentheses is to
137:52 - communicate your intentions to the human
137:54 - readers of your code
137:56 - if you are writing code that depends on
137:58 - the order of overflow
138:00 - function calls and pointer dereferences
138:02 - in a single mathematical expression
138:04 - perhaps you should break your expression
138:07 - into multiple
138:08 - statements section 2.6 relational and
138:12 - logical operators the relational
138:14 - operators are greater than greater than
138:17 - or equal
138:18 - less than less than or equal
138:20 - they all have the same precedence
138:22 - just below them in precedence are the
138:24 - equality operators double equals and
138:27 - exclamation equals which have the same
138:29 - precedence
138:30 - relationals have lower precedence than
138:33 - arithmetic operators so expressions like
138:35 - i less than limb minus 1 are taken as i
138:39 - less than open parenthesis limb minus 1
138:42 - close parenthesis as would be expected
138:45 - more interesting are the logical
138:47 - connectives double ampersand and double
138:50 - vertical bar and an or
138:53 - expressions connected by double
138:55 - ampersand or double vertical bar are
138:56 - evaluated left to right and the
138:58 - evaluation stops as soon as the truth or
139:01 - falsehood of the result is known
139:04 - these properties are critical in writing
139:07 - programs that work
139:09 - for example
139:10 - here is a loop from the input function
139:12 - get line which we wrote in chapter one
139:14 - for parenthesis i equals zero semicolon
139:18 - i less than lim minus one double
139:20 - ampersand
139:21 - parenthesis
139:23 - c equals get char open parenthesis close
139:25 - parenthesis close parenthesis not equal
139:28 - single quote backslash n single quote
139:31 - double ampersand
139:33 - c exclamation equal e o f semicolon plus
139:37 - plus i
139:39 - close parenthesis
139:41 - s sub i equals c
139:44 - clearly before reading a new character
139:46 - it is necessary to check that there's
139:48 - room to store the array so the test i
139:50 - less than lim minus 1 must be made first
139:54 - not only but if this test fails
139:58 - we must not go on and read another
139:59 - character
140:00 - similarly it would be unfortunate if c
140:03 - were tested against eof before getchar
140:05 - was called
140:06 - the call must occur before the character
140:09 - c is checked against dof
140:12 - the precedence of double ampersand and
140:15 - is greater than that of double vertical
140:17 - bar or and both are lower than the
140:20 - relational inequality operators so
140:22 - expressions like i
140:24 - less than limb minus one double
140:26 - ampersand parenthesis c equals char open
140:29 - print close paren close paren not equal
140:32 - single quote backslash n single quote
140:35 - double ampersand c not equal eof needs
140:38 - no extra parenthesis but since the
140:40 - parentheses of
140:42 - not equals is higher than assignment
140:44 - parentheses do need to be added in
140:46 - open print c equals get char open print
140:49 - close paren close print not equal
140:51 - backslash n
140:53 - to achieve the desired result
140:56 - let's take a brief digression
141:00 - one of the great debates of the 1970s
141:02 - was how to use structured programming
141:05 - to avoid any use of go-to statements
141:07 - that lead to completely unreadable
141:09 - spaghetti code
141:10 - structured code was easier to read debug
141:13 - and validate structured code advocated
141:16 - for if then else else if while do loops
141:19 - and do while loops where the loop exit
141:21 - test was at the top or the bottom of the
141:23 - loops respectively
141:26 - there was a move from flowcharts with
141:28 - lines boxes and arrows to to structure
141:30 - programming techniques
141:31 - like nashi schneiderman diagrams that
141:33 - you did used nested boxes to emphasize
141:36 - the structured nature of the code
141:39 - the proponents of each approach tended
141:41 - to approach the problem based on the
141:42 - language they used
141:44 - algol and pascal programmers were strong
141:46 - advocates of structured programming and
141:48 - those languages had syntax that
141:50 - encouraged the approach
141:52 - fortran programs
141:54 - had decades of flowchart use and style
141:57 - flowchart style thinking intended to
142:00 - avoid full adoption of structured
142:01 - programming
142:03 - kurdian and ritchie chose a middle path
142:05 - and made it so that c could support both
142:07 - approaches to avoid angering either side
142:10 - of the structure programming debate
142:13 - one area where the structured code
142:14 - movement kept hitting a snag
142:16 - was implementing a loop that reads a
142:18 - file and processes data until it reaches
142:21 - the end file
142:23 - the loop must be able to handle an empty
142:25 - file or no data at all
142:29 - there are three ways to construct a read
142:31 - and process until eof loop and none of
142:33 - the approaches are ideal
142:36 - the loop constructions that you can do
142:38 - are a top tested loop with prime a
142:40 - priming read before the loop
142:42 - a bottom tested loop with a read as the
142:44 - first statement in the loop and then if
142:46 - then else is the rest of the body of the
142:48 - loop
142:49 - a top tested infinite loop with a
142:51 - priming read and a middle test and exit
142:53 - and a top tested loop with a side effect
142:56 - read in the test of the loop
142:58 - which is the way that kernighan and
142:59 - ritchie chose to document
143:01 - in this chapter
143:03 - all of this
143:04 - serves to explain the syntax
143:06 - while
143:07 - open parenthesis open parenthesis c
143:10 - equals get char open paren close print
143:12 - close parenthesis not equal eof close
143:15 - parenthesis open curly brace body of the
143:18 - loop close curly brace this construct is
143:21 - a topped tested loop which most
143:23 - programmers prefer
143:24 - and it folds the priming read and puts
143:27 - its value inside the variable c
143:31 - but since the getchar might also return
143:33 - eof we need to check if we actually
143:35 - receive no data at all and need to avoid
143:37 - executing the body of the loop
143:39 - or exit the loop
143:41 - if eof were defined as zero instead of
143:45 - minus 1. the loop could have been
143:46 - written
143:47 - while open parenthesis c equals get char
143:50 - open paren close paren close parenthesis
143:53 - open curly brace body of the loop close
143:55 - curly brace
143:56 - now
143:58 - the get jar function returns a character
143:59 - or zero and the test itself is looking
144:01 - at the side effect or residual value of
144:04 - the assignment statement to decide to
144:06 - start and or continue the loop body
144:09 - the problem with using zero is end of
144:11 - file if you are reading a binary file
144:13 - like jpeg data a zero character might
144:16 - make perfect sense and we would not want
144:18 - to incorrectly end the loop because of a
144:21 - zero character in input data that does
144:23 - not end a file
144:25 - so we get the double parentheses syntax
144:28 - the side effect call to getchar and test
144:30 - the return value
144:32 - within the while test
144:34 - i'm quite confident that this is far
144:36 - more detail that you wanted here in
144:37 - chapter two but as it is as good a time
144:40 - as any to understand how much thought
144:42 - goes into a programming language how it
144:44 - is designed and documented
144:46 - by the time we finish chapter 3 and look
144:48 - at the break and continue statements
144:50 - which are in languages like python and
144:52 - java you will see that this 50 year old
144:55 - structured programming debate
144:58 - debate is still unresolved in the minds
145:00 - of many software developers
145:03 - back to the book
145:05 - the unary negation operator logical
145:08 - negation operator converts a non-zero or
145:11 - true operand into zero in a zero or
145:13 - false operand into one
145:16 - a common use of exclamation which we
145:18 - often call bang is in constructions like
145:21 - if open parenthesis exclamation point in
145:24 - word close parenthesis
145:26 - rather than if open parenthesis inward
145:29 - equal equals zero
145:31 - it is hard to generalize about which of
145:32 - these two forms is better construction
145:35 - like exclamation inward read quite
145:37 - nicely as if not in word
145:40 - but more complicated ones can be hard to
145:42 - understand
145:44 - section 2.7 type conversions
145:48 - when operands of different types appear
145:50 - in expressions they are converted to a
145:51 - common type according to a small number
145:54 - of rules
145:55 - in general the only conversions that
145:57 - happen automatically are those that make
145:59 - sense such as converting an integer to a
146:01 - floating point in an expression like f
146:04 - plus i expressions that don't make sense
146:07 - like using a float in a subscript are
146:10 - disallowed
146:12 - first
146:13 - chars and inst may be freely intermixed
146:16 - in arithmetic expressions
146:18 - every chart in an expression is
146:19 - automatically converted to an end
146:22 - this permits considerable flexibility in
146:24 - certain kinds of character
146:25 - transformations
146:27 - one is exemplified by the function a to
146:29 - i which converts a string of digits into
146:32 - its numeric equivalent
146:34 - a to y open parenthesis s close
146:36 - parenthesis
146:37 - char s open bracket close bracket
146:40 - semicolon
146:42 - open curly brace int i comma n semicolon
146:46 - n equals zero
146:48 - four parenthesis i equals zero semicolon
146:51 - s sub i greater than or equal to quote
146:54 - zero quote double ampersand
146:57 - s sub i less than or equal to double
147:00 - quote nine quote semicolon plus plus i
147:04 - close parentheses
147:06 - n equals 10
147:09 - asterisk n plus
147:11 - s sub i minus single quote 0 single
147:14 - quote semicolon
147:16 - return open parenthesis and close
147:18 - parentheses semicolon close curly brace
147:21 - to end the function
147:22 - as we discussed in chapter 1 the
147:24 - expression s sub i minus quote 0 quote
147:28 - gives the numeric value of the character
147:30 - stored in sub i because the values 0
147:33 - 1 etc form a continuously increasing
147:36 - positive sequence positive sequence
147:39 - another example
147:41 - of the card chart in conversion is the
147:43 - function lower which match a single
147:46 - character to lower case for the ascii
147:48 - character set only
147:50 - if the character is not an upper case
147:52 - letter lower is returned unchanged
147:55 - here's a function
147:56 - lower open parentheses c closed
147:58 - parenthesis
148:00 - int c semicolon open curly brace
148:04 - if open parenthesis c greater than or
148:07 - equal to quote capital a quote
148:10 - double ampersand c
148:12 - less than or equal to quote z quote
148:15 - uppercase z
148:17 - parenthesis return
148:20 - open parenthesis c plus
148:22 - quote lowercase a quote minus quote
148:25 - uppercase a quote close parentheses
148:28 - semicolon else return c
148:31 - this works for ascii because the
148:33 - corresponding upper and lowercase
148:35 - letters are a fixed distance apart as
148:38 - numeric values and each alphabet is
148:40 - contiguous
148:41 - there is nothing but letters between a
148:43 - and z
148:44 - this latter observation is not true of
148:47 - the ebcdic character set on ibm 360 370
148:50 - architectures so this code fails on such
148:52 - systems it converts more than letters
148:56 - there is one subtle point about the
148:57 - conversion of characters to integer
149:00 - the language does not specify whether
149:02 - character where the variables of type
149:04 - char are signed or unsigned quantities
149:07 - when char is converted to an int
149:10 - can it ever produce a negative number
149:13 - unfortunately this varies from machine
149:15 - to machine reflecting differences in
149:17 - architecture
149:18 - on some machines
149:21 - for instance a char whose left most bit
149:24 - is one will be converted to negative
149:27 - integer using sign extension
149:29 - on others a char is promoted to an in by
149:31 - adding zeros at the left end and is thus
149:34 - always positive
149:38 - the definition of c guarantees that any
149:40 - character in the machine standard
149:42 - character set will never appear to be
149:44 - negative so these characters may be used
149:46 - freely in expressions as positive
149:48 - quantities but
149:49 - arbitrary bit patterns stored in
149:51 - character variables may appear to be
149:53 - negative on some machines yet positive
149:56 - on others
149:58 - the most common occurrence of this
149:59 - situation is when the value negative 1
150:02 - is used for eof consider the code
150:05 - char
150:06 - c semicolon
150:08 - c equals get char open print close paren
150:11 - semicolon if open print c double equals
150:15 - eof close paren dot dot dot
150:18 - on a machine which does not do sign
150:20 - extension c is always positive because
150:23 - it returns a char
150:24 - yet eof is negative as a result this
150:27 - test always fails to avoid this we have
150:29 - been careful to use int instead of char
150:32 - for any variable which holds a value
150:35 - returned by the function getchar
150:38 - the real reason for using int instead of
150:40 - char is not related to any questions of
150:42 - possible sign extensions it is simply
150:45 - that getchar must return all possible
150:47 - characters so that it can be root used
150:49 - to read arbitrary input and in addition
150:52 - a distinct eof value
150:54 - thus its value cannot be represented as
150:56 - a care
150:57 - char but must instead be stored as an
151:00 - int
151:02 - as an aside since the book was written
151:05 - before the getchar function was
151:06 - standardized the text is somewhat vague
151:08 - in this section
151:10 - shortly after the book was published
151:11 - getchar was put into the stdio.h library
151:15 - and declared to return an integer so as
151:18 - to accommodate
151:19 - all possible characters and the integer
151:21 - -1 value to indicate the end file
151:25 - the above code would be better written
151:27 - with c declared as an integer
151:30 - intc semicolon
151:32 - c equals get char open paren close paren
151:34 - semicolon
151:36 - if
151:37 - open print c double equal eof close
151:39 - paren dot dot
151:41 - while the conversion from char to int
151:43 - may or may not have sign extension and
151:46 - yes it still depends on the
151:47 - implementation 50 years later the
151:50 - conversion from into char is predictable
151:52 - with the top bits being simply discarded
151:56 - if you're using the library function get
151:58 - s to read a file line by line we don't
152:00 - need to worry about this conversion
152:02 - since git s returns a pointer to a
152:04 - character array i.e a string it
152:07 - indicates that reach has reached end of
152:09 - file by returning the null pointer i.e
152:11 - there is no more data to give
152:15 - back to the textbook
152:18 - another useful form of automatic type
152:20 - conversions is that relational
152:21 - expressions like i greater than j and
152:24 - logical expressions constructed by
152:26 - double ampersand and double vertical bar
152:28 - and and or respectively are defined to
152:30 - have the value 1 if true and 0 if false
152:33 - thus the assignment
152:36 - is digit equals c greater than or equal
152:39 - to quote 0 quote double ampersand c less
152:42 - than or equal to quote 9 quote sets the
152:44 - variable is digit to 1 if c is a digit
152:47 - and 0 if it's not
152:50 - in the if test of a
152:52 - in a test part of an if while or four
152:55 - true just means non-zero
152:59 - implicit arithmetic conversions would
153:01 - work much as expected
153:03 - in general if an operator likes c or
153:05 - asterisk for multiplication which takes
153:08 - two operators i.e a binary operator if
153:10 - it has operated operands of different
153:13 - types the lower type is promoted to the
153:15 - higher type before the operation
153:16 - proceeds and the result is the higher
153:18 - type
153:19 - more precisely for each arithmetic
153:21 - operator the following sequence of
153:24 - conversion rules
153:25 - is applied
153:26 - char and short are converted to int and
153:29 - float is converted to double
153:31 - then if either operand is double the
153:33 - other is converted to double and the
153:34 - result is double
153:36 - otherwise if either operand is long and
153:38 - the other is converted to long the
153:39 - result is long
153:40 - otherwise if either operand is
153:42 - operand is unsigned the other is
153:44 - converted to unsigned and the result is
153:46 - unsigned otherwise
153:49 - the operands must be int and the result
153:51 - isn't
153:52 - note that all float values in an
153:54 - expression are converted to double all
153:56 - floating point arithmetic in c is done
153:59 - in double precision
154:01 - conversions take place across
154:03 - assignments
154:04 - the value of the right side is converted
154:06 - to the type of the left
154:08 - which is the type of the result a
154:10 - character is converted to an integer
154:12 - either by sign extension or not as
154:14 - described above the reverse operation
154:17 - into char is well behaved excess high
154:19 - order bits are simply discarded thus in
154:22 - int i semicolon char c semicolon i
154:26 - equals c
154:27 - c equals i the value of c is unchanged
154:31 - and this is true whether or not sign
154:33 - extension is involved
154:35 - if x is float and i is int then x equals
154:39 - i and i equals x both cause conversions
154:44 - float to end causes truncation of any
154:46 - fractional part
154:48 - double is converted to float by rounding
154:50 - longer ins are converted
154:52 - to shorter ones by or to charge by
154:55 - dropping excess high order bits
154:58 - since a function argument is an
155:00 - expression type conversions also take
155:03 - place when arguments are passed to
155:04 - functions
155:06 - in particular char and short become int
155:08 - and float becomes double and that is why
155:10 - we have declared function arguments to
155:12 - be int and double even when the function
155:15 - is called with char and float
155:17 - finally
155:18 - explicit type conversions can be forced
155:22 - also we call it coerced in any
155:24 - expression with a construct called the
155:26 - cast
155:28 - in the construction open parenthesis
155:30 - type name close parentheses expression
155:32 - the expression is converted to the named
155:34 - type by the conversion rules above
155:37 - the precise meaning of cast is in fact
155:40 - as if the expression were assigned to a
155:42 - variable of the specified type which is
155:45 - then used in place of the whole
155:47 - construction
155:48 - for example the library square root sqrt
155:52 - expects a double argument and will
155:54 - produce nonsense if inadvertently handed
155:56 - something else so if n is an integer
156:01 - sqrt open parenthesis open parenthesis
156:04 - double close parenthesis n close
156:06 - parenthesis converts n to double before
156:09 - passing it to sqrt
156:12 - note that the cast produces the value of
156:14 - n in the proper type the actual content
156:16 - of n is not altered the cast operator
156:20 - has the same
156:21 - precedence as other unary operations as
156:24 - is summarized in the table at the end of
156:26 - this chapter
156:29 - section 2.8 increment and decrement
156:32 - operators
156:33 - c provides two unusual operators for
156:35 - incrementing and decrementing variables
156:38 - the increment operator plus plus adds
156:40 - one to its operand the decrement
156:43 - operator minus minus subtracts one
156:45 - we have frequently used plus plus
156:47 - increment variables as in if open
156:50 - parentheses c equals equals single quote
156:53 - backslash n single quote closed
156:54 - parenthesis
156:56 - plus plus nl semicolon
156:59 - the unusual aspect is that plus plus and
157:01 - minus minus may be used either as prefix
157:04 - operators ie before the variable as in
157:07 - plus plus n or postfix after the
157:09 - variable n plus plus
157:12 - in both cases the effect is to increment
157:14 - n
157:15 - but the expression the residual value of
157:18 - the expression plus plus n
157:20 - increments n before using its value
157:23 - while n plus plus increments and after
157:26 - its value has been used
157:28 - this means that in a context
157:30 - where the value is used
157:32 - not just the effect
157:34 - plus plus n and n plus plus are
157:36 - different if n is 5
157:38 - then x equals n plus plus semicolon sets
157:42 - x to 5 the old value
157:44 - but x equals plus plus n semicolon sets
157:49 - x to 6
157:50 - the new value
157:51 - in both cases n becomes 6.
157:54 - the increment and decrement operators
157:56 - can only be applied to variables
157:59 - an expression like x equals open
158:01 - parenthesis i plus j close parenthesis
158:03 - parenthesis plus plus is illegal
158:08 - in a context where no value is wanted
158:10 - just incrementing effect as in if open
158:13 - parentheses c double equals single quote
158:15 - backslash n
158:17 - single quote close parenthesis and l
158:19 - plus plus semicolon
158:20 - choose prefix or postfix according to
158:22 - taste
158:23 - but there are situations where one or
158:25 - the other is specifically called for for
158:28 - example consider the function squeeze s
158:31 - comma c which removes all occurrences of
158:34 - the character c from the string s
158:39 - squeeze open parenthesis s comma c close
158:41 - parenthesis
158:42 - char
158:44 - s
158:45 - open
158:45 - bracket close bracket semicolon int c
158:48 - semicolon open curly brace int i comma j
158:52 - semicolon
158:54 - for parenthesis i equals j equals zero
158:58 - semicolon
159:00 - s sub i
159:02 - not equal to
159:04 - single quote backslash zero single quote
159:06 - semicolon i plus plus close parentheses
159:10 - if
159:11 - open parenthesis s sub i
159:13 - not equal to c close parenthesis
159:16 - s sub j plus plus
159:19 - close parenthesis equals s sub i
159:23 - and outside the for loop totally s sub j
159:26 - equals
159:27 - backslash quote
159:32 - s sub j
159:34 - equals quote backslash zero quote
159:36 - semicolon close curly brace
159:40 - each time a non-c a character other than
159:44 - what's in the variable c occurs is
159:46 - copied into the current j position and
159:49 - only then is j incremented to be ready
159:51 - for the next character this is exactly
159:53 - equivalent to
159:55 - if open parenthesis s sub i not equal to
159:57 - c close parenthesis open curly brace
160:00 - s sub j equals s sub i
160:04 - semicolon j plus plus semicolon close
160:07 - curly brace
160:09 - another example of a similar
160:11 - construction comes from the getline
160:12 - function we wrote in chapter one where
160:14 - we can replace if open parenthesis c
160:16 - double equals quote backslash n quote
160:20 - close parenthesis open curly brace s sub
160:22 - i equals c
160:24 - semicolon plus plus i semicolon close
160:27 - parenthesis by the far more compact
160:30 - if parentheses c double equals quote
160:33 - backslash end quote close parentheses s
160:36 - sub i plus plus equals c semicolon
160:40 - in a third example the function stir cat
160:43 - concatenates the string t to the end of
160:45 - the string s
160:46 - stir cat does assume that there's enough
160:48 - space in s to hold the combination
160:52 - here's the code
160:53 - stir cat open parentheses s comma t
160:56 - close parenthesis
160:58 - char
160:59 - s open bracket close bracket comma t
161:02 - open bracket close bracket semicolon
161:05 - open curly brace int i comma j semicolon
161:10 - i equals j equals 0 semicolon
161:14 - while open paren
161:16 - s sub i not equal
161:19 - single quote backslash zero single quote
161:21 - close paren i plus plus
161:24 - in this we'd find the end of s
161:27 - while open parenthesis open parenthesis
161:30 - s sub i plus plus equals
161:33 - t sub j plus plus close parenthesis not
161:36 - equal backslash zero
161:38 - close parentheses semicolon
161:41 - that code copies the rest of t
161:43 - into s
161:44 - close curly brace
161:46 - as each character is copied from t to s
161:48 - the postfix plus plus is applied to both
161:51 - i and j to make sure they are in
161:53 - position for the next pass
161:55 - through the loop
161:58 - section 2.9 bitwise logical operators
162:01 - c provides a number of operators for bit
162:04 - manipulation
162:05 - these may not be applied to float or
162:07 - double
162:09 - ampersand is bitwise and vertical bar is
162:12 - bitwise inclusive or
162:15 - carrot is bitwise exclusive or
162:18 - less than less than is left shift and
162:20 - greater than greater than is right shift
162:22 - and tild is one complements and it's a
162:25 - unary operator
162:26 - the bitwise and operator
162:29 - ampersand is often used to mask off some
162:31 - set of bits for example
162:34 - c equals n ampersand 0 1 7 7 sets to 0
162:40 - all but the lower 7 bits of n the
162:43 - bitwise or operator is used to turn bits
162:45 - on
162:46 - x equals x vertical bar mask
162:50 - sets to 1 the x bits that are set to one
162:53 - in mask
162:55 - you should carefully distinguish the
162:57 - bitwise operator ampersand and vertical
162:59 - bar from the logical connectives double
163:01 - ampersand and double vertical bar which
163:04 - imply left to right evaluation of a
163:06 - truth value
163:07 - for example if x is 1 and y is 2 then x
163:12 - single ampersand y is 0
163:15 - while x double ampersand y is 1.
163:18 - think about that for a moment
163:21 - the shift operators less than less than
163:23 - and greater than greater than
163:25 - perform left and right shifts
163:27 - respectively of their left operand by
163:29 - the number of bit positions given by the
163:31 - right operand
163:32 - thus
163:33 - x less than less than 2 shifts x left by
163:37 - two positions filling the vacated bits
163:39 - with zero
163:41 - this is the equivalent to multiplication
163:43 - by four
163:44 - right shifting an unsigned quantity
163:46 - fills the vacated bits with zero
163:49 - right shifting a sine quantity will fill
163:51 - the sine bits
163:53 - arithmetic shift on some machines such
163:55 - as pdp 11 and with and with zero bits
163:58 - logical shift on other
164:01 - the unary operator tilled
164:03 - yields the ones complement of an integer
164:06 - that is
164:07 - it converts each one bit into a zero bit
164:10 - and vice versa
164:11 - this operator typically finds use in
164:14 - expressions like
164:15 - x
164:16 - ampersand tilled
164:19 - 077
164:20 - which masks the last six
164:23 - bits of x to zero
164:25 - note that x ampersand tilde 0 7 7 is
164:29 - independent of word length
164:31 - and is thus preferable to for example
164:35 - x
164:36 - ampersand 0 1 7 7 7 0 0 which assumes
164:40 - that x is a 16 bit quantity
164:43 - the portable form involves no extra
164:45 - cause since killed zero seven seven is a
164:48 - constant expression and thus evaluated
164:50 - at compile time
164:53 - to illustrate the use of sum of the bit
164:55 - operators consider the function get bets
164:58 - open parenthesis x comma p comma n which
165:01 - returns the right adjusted n bit field
165:03 - of x that visit begins at position p
165:07 - we assume that position
165:09 - 0 is at the right end and that n and p
165:12 - are sensible positive values for example
165:15 - get bits
165:16 - open print x comma 4 comma 3
165:19 - close print returns the three bits in
165:22 - bit positions 4 3 and 2 write adjusted
165:27 - here we go with the code
165:28 - get bits open print x comma p comma n
165:32 - unsigned x comma p comma n semicolon
165:35 - open curly brace
165:38 - return
165:40 - open parenthesis open parenthesis x
165:42 - greater than greater than open
165:44 - parenthesis p plus 1 minus n close
165:46 - parenthesis close parenthesis
165:48 - and ampersand
165:50 - tild open parenthesis till 0
165:54 - less than less than in closed
165:56 - parenthesis close parenthesis semicolon
165:58 - close curly brace
166:00 - x greater than greater than parenthesis
166:03 - p plus one minus n
166:05 - close parenthesis moves the desired
166:06 - field to the right end of the word
166:08 - declaring the argument to be x
166:11 - declaring the argument x to be unsigned
166:13 - ensures that when it is right shifted
166:15 - vacated bits will be filled with zeros
166:17 - not sign bits regardless of the machine
166:19 - the program is run on
166:21 - tilde zero is all one bits shifting it
166:25 - left n bit positions with tilde 0 left
166:28 - shift
166:29 - tilde 0 less than less than n creates a
166:32 - mask with the zeros in the right most n
166:34 - bits and ones everywhere else
166:36 - complementing that with tilled makes a
166:39 - mask with ones in the right most bits
166:43 - bitwise operators may seem unnecessary
166:45 - for modern computers
166:47 - but if you look at the internal
166:48 - structure of tcpip packets the values
166:51 - are packed very tightly into the headers
166:52 - in order to save space
166:54 - c made it possible to write portable
166:57 - tcpi implementations on a wide range of
166:59 - hardware architectures
167:01 - bitwise operators also play an important
167:04 - role in encryption decryption and
167:06 - checksum calculations
167:08 - modern languages like java and python
167:10 - support bitwise operators following the
167:12 - same patterns that we established in c
167:15 - so that things like tcpip and encryption
167:17 - algorithms can also be implemented in
167:19 - these languages
167:21 - by defining these operators it kept
167:23 - software developers from needing to
167:25 - write non-portable assembly language to
167:27 - implement these low-level features in
167:29 - operating systems and libraries
167:32 - section 2.10 assignment operators and
167:35 - expressions
167:37 - expressions such as i equals i plus 2 in
167:40 - which the left-hand side is repeated on
167:42 - the right can be written in the
167:44 - compressed form i plus equals 2 using an
167:47 - assignment operator like plus equals
167:50 - most binary operators operators like
167:53 - plus that have a left and right operand
167:55 - have a corresponding
167:57 - assignment operator op equals where op
168:00 - is one of plus
168:01 - minus
168:03 - asterisk for multiplication slash for
168:05 - division percent for modulo
168:08 - less than less than
168:09 - left shift
168:11 - greater than greater than right shift
168:14 - ampersand bitwise and
168:16 - carrot exclusive or
168:17 - vertical bar bitwise or
168:20 - if e1 and e2 are expressions then e1
168:25 - operand equals e2 is equivalent to e1
168:28 - equals e1 operand e2
168:31 - except that e1 is only computed once
168:33 - note the parentheses around e2
168:38 - x
168:39 - star equals y plus 1 is actually
168:42 - x equals x times parenthesis y plus 1
168:46 - close parenthesis rather than
168:48 - x times y plus 1.
168:51 - as an example function bit count counts
168:53 - the number of one bits in its integer
168:55 - argument
168:57 - here's the code
168:59 - bit count open parentheses in close
169:01 - parenthesis unsigned and semicolon
169:05 - open curly brace into b
169:09 - four open parenthesis b equals 0
169:11 - semicolon
169:13 - and exclamation equals 0 semicolon
169:16 - n
169:18 - greater than greater than equal 1
169:21 - close parenthesis
169:24 - if open parenthesis in ampersand
169:27 - 0 1
169:28 - close parenthesis
169:30 - b plus plus semicolon
169:33 - return
169:34 - open print b close print semicolon curly
169:37 - brace
169:38 - quite apart from its conciseness
169:41 - assignment operators have the advantage
169:43 - and that they correspond better to way
169:45 - the way people think we said we say add
169:47 - 2 to i or increment i by 2 not take i
169:51 - add 2 and put the result back in i
169:53 - thus
169:54 - i plus equal to
169:56 - in addition for a complicated expression
169:58 - like
170:00 - yy val
170:01 - open
170:02 - bracket yypv open bracket p3 plus p4
170:07 - close bracket plus yypv
170:10 - open bracket p1 plus 2 p2 close bracket
170:14 - close bracket plus equals 2
170:16 - the assignment operator makes it code
170:18 - easier to understand since the reader
170:20 - doesn't have to check painstakingly that
170:22 - too long expressions are indeed the same
170:25 - or wonder why they're not
170:27 - an assignment operator may even help the
170:29 - compiler to produce more efficient code
170:32 - we have already used the fact that the
170:34 - assignments statement has a side effect
170:36 - value and can occur in expressions the
170:39 - most common example is while open
170:42 - parentheses open parenthesis c equals
170:44 - get char open parenthesis close
170:46 - parenthesis close parenthesis
170:48 - exclamation equal eof close parentheses
170:51 - and then the rest of the loop
170:53 - assignments using other assignment
170:55 - operators plus equal minus sql can also
170:57 - occur in expressions although it's a
170:59 - less frequent occurrence
171:01 - the type of an assignment expression is
171:03 - the type of its left operand
171:05 - section 2.11 conditional expressions
171:09 - the statements
171:10 - if parentheses a greater than b
171:13 - close parentheses c equals a semicolon
171:16 - else z equals b semicolon of course
171:20 - compute z in the maximum of a and b
171:23 - the conditional expression written with
171:25 - a ternary operator which is question
171:27 - mark and colon provides an alternate way
171:29 - to write this and similar constructions
171:32 - in the expression e1 question mark e2
171:36 - colon e3
171:37 - the expression e1 is evaluated first
171:40 - if it is non-zero true then the
171:42 - expression e2 is evaluated and that is
171:45 - the value of the conditional expression
171:47 - otherwise e3 is evaluated and that is
171:49 - the value only one of e 2 and e 3 are
171:52 - evaluated thus to set the z to set z to
171:56 - the maximum of a and b we say
171:59 - z equals parentheses a greater than b
172:02 - close parentheses question mark a
172:05 - colon b
172:07 - and this implements z equals max of a
172:10 - and b
172:11 - it should be noted that the conditional
172:13 - expression is indeed an expression and
172:15 - can be used just as any other expression
172:18 - if e1 and if e2 and e3 are different
172:21 - types their type of the result is
172:23 - determined by the conversion rules
172:24 - described earlier in this chapter for
172:27 - example if f is a float and n is an end
172:29 - then the expression
172:31 - parentheses n greater than zero closed
172:33 - parenthesis
172:34 - question mark f colon n
172:37 - is of type double regardless of whether
172:40 - n is positive or not
172:42 - parentheses are not necessary around the
172:44 - first expression of a conventional
172:46 - expression since the precedence of
172:48 - question mark colon is very low just
172:50 - above assignment they are advisable
172:53 - anyway however since they make the
172:54 - condition part of the expression easier
172:57 - to see
172:58 - the conditional expression often leads
173:00 - to succinct code for example
173:03 - this loop print prints n elements of an
173:06 - array 10 per line with each column
173:08 - separated by one blank and with each
173:10 - line including the last terminated by
173:12 - exactly one new line
173:14 - here's the code four parentheses i
173:17 - equals zero semicolon i less than n
173:20 - semicolon i plus plus close parentheses
173:24 - printf open parentheses double quote
173:26 - percent 6d percent c
173:30 - double quote comma
173:32 - a sub i
173:34 - comma
173:36 - open parenthesis
173:37 - i percent 10
173:39 - double equal 9
173:41 - or double vertical bar i double equal n
173:44 - minus 1 close parenthesis question mark
173:48 - single quote backslash n single quote
173:50 - colon single quote space single quote
173:54 - close parenthesis semicolon
173:56 - a new line is printed after every tenth
173:58 - element
173:59 - and after the nth and all elements are
174:01 - followed by one blank although this
174:03 - might look tricky it's instructive to
174:05 - try to write it without the conditional
174:07 - expression section 2.12 precedence in
174:11 - order of evaluation
174:12 - the table below summarizes the rules for
174:14 - precedence and associativity of all
174:17 - operators including those which we have
174:19 - not yet discussed
174:20 - operators on the same line have the same
174:22 - precedence
174:23 - rows are in order of decreasing
174:25 - precedence so for example
174:28 - asterisk slash and percent all have the
174:31 - same precedence which is higher than
174:33 - that of plus and minus
174:37 - parentheses
174:38 - square brackets
174:39 - the arrow operator and the dot operator
174:42 - are first with the right left to right
174:45 - associativity
174:47 - next precedence is exclamation
174:50 - tilled
174:51 - plus plus
174:52 - minus minus
174:54 - single minus
174:59 - the cast
175:01 - multiplication
175:03 - bitwise and size of with left with right
175:06 - to left
175:07 - associativity
175:09 - then
175:10 - multiplication division and modulo with
175:12 - left right associativity
175:15 - then plus and minus with left to right
175:17 - associativity
175:19 - then
175:20 - left shift which is less than less than
175:22 - and right shift which is right
175:24 - greater than greater than with left to
175:26 - right associativity
175:28 - then logical operators less than less
175:30 - than or equal to greater than or greater
175:32 - than or equal to with left to right
175:33 - associativity
175:35 - then comparison double equals
175:38 - not equal exclamation equal left to
175:40 - right
175:41 - then we have some bitwise operators the
175:44 - bitwise and with left to right
175:46 - associativity
175:47 - then the bitwise exclusive or with left
175:50 - right associativity which is a carrot
175:53 - then the single vertical bar which is
175:55 - bitwise or with left to right
175:57 - associativity
175:58 - then we have amber sand ampersand which
176:01 - is and the logical and left to right
176:03 - associativity then double vertical bar
176:06 - which is the logical or with left to
176:08 - right associativity then the ternary
176:10 - operator which is question mark and
176:12 - colon with right to left associativity
176:15 - then the assignments
176:18 - equals plus equals minus sets equals etc
176:21 - with right to left associativity and
176:23 - then the comma which we'll cover in the
176:25 - next chapter with left to right
176:26 - associativity the operators
176:29 - dash
176:30 - greater than and dot are used to access
176:32 - members of structures they'll be covered
176:34 - in chapter six along with size of
176:37 - in chat
176:38 - and then in chapter five we'll discuss
176:40 - asterisk indirection and ampersand
176:43 - address of
176:45 - note that the precedence of the bitwise
176:47 - logical operators ampersand carrot and
176:49 - vertical bar falls below
176:51 - double equals and exclamation equals
176:54 - that this implies that bis bit testing
176:56 - expressions like if
176:59 - parentheses parentheses x ampersand mass
177:02 - close parenthesis
177:03 - equal equals zero close parenthesis must
177:06 - be fully parenthesized to get proper
177:08 - results
177:10 - as mentioned before expressions
177:12 - involving one or more of the associative
177:14 - and commutative operators like multiply
177:17 - plus
177:18 - bit y z end bit lies orbit li and
177:21 - bitwise exclusive or can be rearranged
177:23 - even when parenthesized in most cases
177:25 - this makes no difference whatsoever in
177:28 - situations where it might explicit
177:30 - temporary variables can use
177:32 - to force a particular order of
177:33 - evaluation
177:35 - c like most languages does not specify
177:38 - in what order operands of an operator
177:40 - are evaluated for example
177:42 - in a statement like x equals f open
177:45 - parentheses close parentheses plus g
177:47 - open parentheses close parenthesis
177:48 - semicolon f may be evaluated before v g
177:53 - or vice versa
177:54 - thus if f or g
177:56 - alters an external variable that the
177:58 - other depends on
178:00 - x can depend on the order value of
178:02 - evaluation again
178:04 - intermediate results can be stored in
178:06 - temporary variables to ensure a
178:08 - particular sequence
178:10 - similarly the order which function
178:12 - arguments are evaluated is not specified
178:16 - so
178:17 - the statement
178:18 - printf open parentheses double quote
178:21 - percent d space percent d backslash n
178:24 - double quote comma
178:25 - plus plus n comma power open parenthesis
178:29 - two comma n close parentheses close
178:31 - parentheses
178:32 - is wrong
178:34 - it can and often does produce different
178:35 - results on different machines depending
178:38 - on whether or not n is incremented
178:39 - before power is called the solution of
178:42 - course is to write
178:44 - plus plus n semicolon
178:46 - printf open parentheses double quote
178:48 - percent d space percent d backslash n
178:51 - double quote comma
178:53 - n comma power open parenthesis two comma
178:56 - n close parentheses close parenthesis
178:59 - function calls nested assignment
179:01 - statements and increment and decrement
179:02 - operators cause side effects
179:05 - some variables change as a byproduct of
179:07 - the evaluation of an expression
179:10 - in any expression involving side effects
179:12 - there can be subtle dependencies on the
179:15 - order in which variables taking part in
179:17 - the expression are stored
179:20 - one unhappy situation is typified by the
179:22 - statement
179:23 - a sub i equals i plus plus
179:27 - the question is whether or not the
179:29 - subscript
179:30 - is the old value of i or the new value
179:33 - the compiler can do this in different
179:35 - ways and generate different answers
179:37 - depending on its interpretation
179:40 - when side effects i.e assignment to
179:42 - actual variables takes place is left to
179:44 - the discretion of the compiler since the
179:46 - best order strongly depends on machine
179:49 - architecture
179:50 - the moral of this discussion is writing
179:52 - code which depends on the order of
179:54 - evaluation is a bad programming practice
179:57 - in any language
179:59 - naturally it is necessary to know what
180:01 - things to avoid
180:03 - but if you don't know how they are done
180:04 - on various machines that innocence may
180:07 - help to protect you
180:08 - the c verifier lint
180:10 - will detect most dependencies on order
180:13 - of evaluation
180:15 - i would add that the real moral of the
180:17 - story is to use side effect operators
180:19 - very carefully
180:21 - they are generally only used in
180:22 - idiomatic situations and then use it
180:25 - written using simple code
180:27 - the authors are happy to tell you
180:30 - everything that you can do and see in
180:32 - great detail
180:33 - and they are also suggesting that just
180:35 - because you can do something does not
180:37 - mean that you should do something
180:39 - remember that a key aspect of writing
180:41 - programs is to communicate with future
180:43 - human readers of your code
180:45 - including you reading your own code in
180:47 - the future
180:48 - with modern day compilers and optimizers
180:51 - you gain little performance by writing
180:53 - dense or obtuse code
180:56 - write the code describe what you want
180:57 - done and let the compiler find the best
180:59 - way to do it
181:01 - one of the reasons that a common senior
181:03 - project in many computer science degrees
181:04 - was to write a compiler is to make sure
181:07 - that all computer scientists
181:09 - understand that they can trust the
181:11 - compiler to generate great code
181:16 - this work
181:17 - is based on the 1978 c programming book
181:20 - written by brian w kernighan and dennis
181:22 - m ritchie
181:23 - their book is copyright all rights
181:25 - reserved by at t
181:27 - but is used in this work under fair use
181:30 - because of the book's historical and
181:31 - scholarly significance
181:33 - its lack of availability and the lack of
181:36 - an accessible version of the book
181:38 - the book is augmented in places to help
181:39 - understand its rightful place in a
181:41 - historical context amidst the major
181:43 - changes of the 1970s and 1980s as
181:47 - computer science evolved from a hardware
181:49 - first vendor-centered approach to a
181:51 - software-centered approach where
181:53 - portable operating systems and
181:54 - applications written in c could run on
181:56 - any hardware
181:58 - this is not the ideal book to learn c
182:00 - programming because the 1978 edition
182:03 - does not reflect the modern c language
182:06 - using an obsolete book gives us an
182:08 - opportunity to take students back in
182:09 - time and understand how the c language
182:12 - was evolving as it laid the groundwork
182:14 - for a future with portable applications
182:20 - chapter 3 control flow
182:23 - the control flow statements of a
182:25 - language specify the order in which the
182:27 - computations are done
182:29 - we have already met the most common
182:31 - control flow constructions of c in
182:33 - earlier examples
182:35 - here we will complete the set and be
182:36 - more precise about the ones discussed
182:38 - above
182:40 - 3.1 statements and blocks an expression
182:45 - such as x equals zero or i plus plus or
182:49 - printf open paren
182:51 - dot dot dot close paren becomes a
182:53 - statement when it is followed by a
182:55 - semicolon as in
182:57 - x equals zero semicolon
183:00 - i plus plus semicolon
183:02 - printf open parentheses something closed
183:05 - parentheses semicolon
183:07 - in c the semicolon is a statement
183:10 - terminator rather than a separator as it
183:13 - is in algol like languages
183:16 - the braces the curly braces open curly
183:20 - brace and closed curly brace are used to
183:22 - group declarations and statements
183:24 - together into a compound statement or
183:27 - block so that they are syntactically
183:29 - equivalent to a single statement
183:32 - the braces that actually surround the
183:33 - statements of a function are one obvious
183:36 - example
183:37 - braces around multiple statements after
183:39 - an if
183:40 - else while or four are another
183:43 - variables can actually be declared
183:45 - inside any block we will talk about this
183:48 - in chapter four
183:50 - there is never a semicolon after the
183:52 - right curly brace that ends the block
183:56 - ah see how do i love thee let me count
183:59 - the ways
184:00 - quote by dr chuck with homage to
184:03 - elizabeth barrett browning
184:06 - the humble semicolon is why spacing and
184:08 - line ends do not matter in c and c like
184:10 - languages it means that we as
184:13 - programmers can focus all of our white
184:15 - space and line ends on communicating our
184:18 - intent to humans
184:21 - this freedom is not an excuse to write
184:23 - obtuse code or dense code
184:26 - for example see the obfusicated pearl
184:28 - contest but instead
184:30 - freedom to describe what we mean or use
184:33 - spacing to help us understand or
184:35 - maintain our code
184:37 - we can take a quick look at how a few
184:39 - other c like languages that came after c
184:42 - treat the semicolon java is just like c
184:45 - in that the semicolon terminates
184:46 - statements
184:47 - python treats the semicolon as a
184:49 - separator like alcohol allowing more
184:52 - than one statement on a single line but
184:54 - since
184:55 - python treats the end of a line as a
184:57 - statement separator you generally never
185:00 - use semicolon in python
185:02 - but for people like me who automatically
185:04 - add a semicolon when typing code too
185:06 - fast at least python ignores the few
185:09 - semicolons i mistakenly add to my code
185:11 - out of habit
185:13 - javascript treats the semicolon as a
185:15 - separator but since javascript ignores
185:18 - the end of the line it's treated as
185:20 - white space semicolons are required when
185:22 - a block of code consists of more than
185:25 - one statement
185:27 - when i write javascript i meticulously
185:29 - include semicolons at the end of all
185:32 - statements because any good programmer
185:34 - can write c in any language
185:39 - back to the text 3.2
185:42 - if else
185:44 - the ifl statement is used to make
185:45 - decisions
185:46 - formally the syntax is
185:49 - if parentheses expression parentheses
185:52 - statement 1
185:54 - else statement 2 where the else part is
185:57 - optional
185:58 - the expression in parentheses is
186:00 - evaluated if it evaluates to true that
186:03 - is the expression has a non-zero value
186:06 - statement one is done if it is false the
186:09 - expression is zero
186:11 - and there's an else part statement two
186:12 - is executed instead
186:15 - since an if simply tests the numeric
186:18 - value of the expression certain coding
186:21 - shortcuts are possible the most obvious
186:23 - is writing if open parentheses
186:26 - expression
186:27 - instead of if open parenthesis
186:29 - expression not equal zero close
186:32 - parenthesis
186:34 - sometimes this is natural and clear
186:36 - other times it's cryptic
186:40 - because the else part of an if else is
186:42 - optional there is an ambiguity
186:44 - when an else is omitted from a nested if
186:47 - sequence
186:49 - this is resolved the usual way the else
186:52 - is a cl associated with the closest
186:54 - closest previous else list if
186:59 - for example
187:01 - if
187:02 - open parenthesis n greater than zero
187:04 - closed parenthesis
187:06 - if
187:07 - open parenthesis a greater than b close
187:09 - parentheses
187:10 - z equals a semicolon
187:13 - else z equals b
187:16 - the else with the z equals b goes with
187:18 - the inner if as we have shown by the
187:20 - indentation in the above example
187:22 - if that's not what you want braces must
187:24 - be used to force the proper association
187:28 - if n greater than zero open curly brace
187:32 - if a greater than b
187:34 - z equals a semicolon closed curly brace
187:37 - else z equals b
187:40 - this ambiguity is especially pernicious
187:43 - in situations like
187:45 - if open parenthesis n greater than zero
187:48 - for open parenthesis i equals 0
187:50 - semicolon i less than n semicolon i plus
187:53 - plus closed parenthesis
187:56 - if open parenthesis
187:58 - s sub i greater than 0 close parentheses
188:00 - open curly brace printf
188:03 - string dot
188:05 - parenthesis semicolon return open
188:08 - parenthesis i close parenthesis
188:09 - semicolon close curly brace
188:13 - else and this is where it's wrong
188:15 - printf
188:16 - open parenthesis error and is zero
188:19 - closed parenthesis semicolon
188:22 - the indentation in the above example
188:24 - shows unequivocally what you want but
188:26 - the compiler does not get the message
188:29 - and associates the else with the inner
188:31 - if
188:32 - this bug can be very hard to find
188:35 - by the way
188:38 - notice that there is a semicolon after z
188:40 - equals a in
188:42 - if open parenthesis a greater than b
188:45 - close parenthesis z equals a semicolon
188:48 - else z equals b semicolon
188:52 - that is because grammatically a
188:53 - statement follows the if and an
188:55 - expression like z equals a is always
188:59 - terminated by a semicolon
189:03 - section 3.3
189:05 - else if
189:07 - the construction if open parenthesis
189:10 - expression close parentheses statement
189:12 - else blank if open parentheses
189:16 - expression close parentheses statement
189:19 - else if
189:20 - open parenthesis
189:22 - expression close parentheses statement
189:24 - else statement occurs so often that it's
189:27 - worth a brief separate discussion the
189:30 - sequence of ifs is the most general way
189:32 - of writing a multi-way decision the
189:34 - expressions are evaluated in order
189:37 - if any expression is true the statement
189:39 - associated with it is executed and this
189:41 - terminates the whole chain the code for
189:45 - each statement
189:47 - is either a single statement or a group
189:48 - of statements in phrases
189:50 - the last else
189:52 - handles the none of the above or default
189:54 - case where none of the other conditions
189:56 - was satisfied
189:57 - sometimes there is no explicit action
189:59 - for the default in that case the
190:01 - trailing else statement can be omitted
190:05 - or it may be used for error checking to
190:07 - catch an impossible condition
190:10 - to illustrate three-way decision
190:12 - here is a binary search function that
190:14 - decides if a particular value x occurs
190:17 - in the sorted array v
190:19 - the elements of v must be in increasing
190:22 - order the function returns the position
190:24 - a number between 0 and n minus 1 if x
190:27 - occurs in v n minus 1 if not
190:31 - this sample code is on page 54. it is
190:34 - the first example on page 54 in the book
190:38 - binary open parenthesis x comma v comma
190:42 - n close parenthesis
190:44 - int x
190:46 - comma v
190:47 - open square bracket close square bracket
190:49 - comma n semicolon open curly brace
190:54 - int
190:54 - low comma high comma mid semicolon
190:58 - low equals zero semicolon high equals n
191:02 - minus one semicolon
191:05 - while open parenthesis low less than or
191:07 - equal to high close parenthesis
191:10 - open curly brace
191:11 - mid
191:12 - equals open parenthesis low plus high
191:15 - close parenthesis
191:16 - slash 2 semicolon
191:19 - if
191:20 - open parenthesis x less than
191:22 - v submid close parenthesis
191:26 - high equals mid minus 1 semicolon
191:30 - else if open parenthesis x greater than
191:34 - v sub mid close parenthesis low equals
191:37 - mid plus one
191:39 - else
191:41 - return open parenthesis mid close
191:43 - parenthesis semicolon close curly brace
191:45 - closing the while
191:48 - and then return open parenthesis -1
191:50 - close parentheses semicolon close curly
191:52 - brace to end the function
191:55 - the fundamental decision in this code is
191:57 - whether x is less than greater than or
192:00 - equal to the middle element v submit at
192:02 - each step
192:03 - this is a natural for elsa
192:09 - i would note that in the above examples
192:11 - the else and the if in c are two
192:14 - language constructs that are just being
192:16 - used idiomatically to construct a
192:19 - multi-way branch or else if pattern with
192:22 - indentation that captures the idiom
192:25 - if we are pedantic about the indentation
192:27 - above the of the above sequence we would
192:30 - be separating the else and if and
192:32 - indenting each succeeding block further
192:34 - as follows with brackets or added for
192:37 - clarity
192:39 - if
192:40 - open parenthesis expression close
192:41 - parentheo parentheses open curly brace
192:43 - statement close curly brace else
192:47 - open curly brace if open parenthesis
192:50 - expression close parenthesis open curly
192:52 - brace statement close curly brace else
192:56 - open curly brace and now we're quite
192:58 - indented at this point if open
193:00 - parenthesis expression close parentheses
193:03 - open curly brace statement closed curly
193:05 - brace
193:06 - else open curly brace statement close
193:09 - curly brace close curly brace glows
193:11 - curly brace
193:14 - java and javascript keep the else and if
193:16 - as separate language elements and
193:18 - document their idiomatic usage and
193:20 - indentation just like c
193:23 - but in python
193:25 - life is a single keyword in a new
193:28 - language construct that achieves the
193:31 - same idiom as shown below
193:34 - if open parenthesis expression close
193:36 - parentheses colon block
193:38 - lf
193:40 - open parenthesis expression close
193:41 - parenthesis
193:42 - colon block
193:43 - alif
193:45 - if lf parentheses expression parentheses
193:49 - colon block else colon block
193:52 - the c
193:54 - java javascript and python idioms
193:56 - thankfully look the same when the
193:58 - idiomatic indentation is used
194:01 - even fortran 77 supports elf the else if
194:05 - construct to implement multi-way logic
194:14 - section 3.4 switch
194:17 - the switch statement is a special
194:18 - multi-way decision maker that tests
194:20 - whether an expression matches
194:23 - one of a number of constant values and
194:25 - branches accordingly
194:27 - in chapter one we wrote a program to
194:29 - count the occurrences of each digit
194:31 - white space and all other characters
194:34 - using a sequence of if else if else
194:38 - here's the same program with a switch
194:41 - this is the first example program on
194:43 - page 55.
194:47 - pound include
194:49 - less than stdio.h
194:53 - main open parentheses closed parenthesis
194:55 - open curly brace
194:57 - int c comma i
195:00 - come n white comma n other comma n digit
195:03 - open square bracket 10 close square
195:05 - bracket
195:06 - a 10 element array
195:09 - and white equals and other equals 0
195:12 - for i equals 0
195:14 - i less than 10 i plus plus and digit sub
195:17 - i equals 0.
195:21 - while parentheses parenthesis c equals
195:24 - get char open paren close paren close
195:26 - paren not equal e o f
195:28 - close paren
195:30 - switch
195:31 - open parentheses c close parenthesis
195:33 - open curly brace
195:36 - case quote zero quote colon case quote
195:39 - one quote colon
195:41 - case
195:42 - quote two qu quote colon case quote
195:45 - three quote colon case quote four quote
195:49 - colon case quote five quote colon case
195:53 - quote six quote colon case quote seven
195:57 - quote colon case quote eight quote colon
196:01 - case quote nine quote colon
196:05 - end digit sub c minus quote zero quote
196:08 - close bracket plus plus
196:11 - break
196:13 - now that that bit of code right there
196:14 - was to take all the of zero through nine
196:17 - and
196:18 - guide it to the line of code that
196:20 - incremented the particular element of
196:22 - the end digit array by one
196:26 - continuing after the break semicolon
196:28 - case quote space
196:30 - quote colon
196:31 - case quote backslash end quote colon
196:34 - case quote backslash t quote colon
196:38 - and white
196:39 - plus plus semicolon break
196:42 - default colon and other plus plus colon
196:46 - break semicolon
196:50 - close curly brace
196:52 - print f
196:53 - open parenthesis double quote digits
196:56 - equals double quote close parenthesis
196:58 - semicolon
197:00 - 4 open print i equals 0
197:02 - i less than 10
197:04 - i
197:05 - semicolon i plus plus close parenthesis
197:08 - printf
197:09 - open parenthesis percent space percent d
197:13 - close double quote comma end digit sub i
197:17 - close parenthesis semicolon
197:20 - printf
197:21 - quote backslash n white space equals
197:24 - percent d comma other equals percent d
197:28 - backslash n double quote comma and white
197:31 - comma n other closed parenthesis
197:33 - semicolon close curly brace
197:39 - the switch statement evaluates the
197:41 - integer expression in parentheses in
197:43 - this case the character c and compares
197:45 - its value
197:47 - simultaneously to all the cases each
197:50 - case must be labeled by an integer or
197:52 - character constant or constant
197:54 - expression
197:55 - if a case matches the expression value
197:58 - execution starts at that case the case
198:01 - labeled default is executed if none of
198:03 - the other cases is satisfied
198:06 - default is optional if there isn't if it
198:08 - isn't there and none of the cases
198:10 - matches no action at all takes place
198:13 - cases in default can occur in any order
198:16 - cases must all be different
198:19 - the break statement causes an immediate
198:21 - exit from the switch
198:23 - because the cases serve as labels
198:26 - after the code for one case is done
198:30 - execution falls through to the next
198:33 - unless you take explicit action to
198:35 - escape
198:36 - break and return are the most common
198:38 - ways to leave a switch
198:40 - a break statement can be used to force
198:43 - an immediate exit from a while four and
198:46 - do loops as well as will be discussed
198:48 - later in this chapter
198:52 - falling through the cases is a mixed
198:54 - blessing
198:55 - on the positive side
198:56 - it allows multiple cases for a single
198:58 - action as with blank tab or new line in
199:00 - this example but it also implies that
199:03 - normally each case what must end with a
199:05 - break to prevent falling through to the
199:07 - next
199:08 - falling through from one case to another
199:10 - is not robust being prone to
199:12 - disintegration when the program is
199:14 - modified
199:15 - with the exception of multiple labels
199:17 - for a single computation fall throughs
199:20 - should be used sparingly
199:22 - as a matter of good form put a break
199:25 - after the last case in this case default
199:28 - although it's logically unnecessary
199:30 - someday when another case gets added at
199:32 - the end this bit of defensive
199:34 - programming will save you
199:38 - uh the switch statement what is there to
199:40 - say i think that the switch statement
199:43 - was added to c c to compete with the
199:45 - earlier fortran computed go to statement
199:48 - or just to keep low level assembly
199:50 - language programmers from switching into
199:52 - assembly language to implement the
199:53 - concept of a branch table
199:56 - the authors spend most of the previous
199:58 - section apologizing for the switch
199:59 - statement so you should perhaps take
200:01 - this as a hint and never use it
200:05 - there are very few situations where a
200:07 - branch table outperforms a series of
200:09 - this if then else checks and those are
200:13 - likely deep in a library or operating
200:15 - system code
200:16 - programmers should only use switch if
200:19 - they understand what a branch table is
200:22 - and why a branch table is more efficient
200:24 - for the particular bit of a program
200:26 - they're writing
200:27 - otherwise
200:28 - just use elsif and do the readers of
200:31 - your code a favor
200:35 - 3.5 loops while and four
200:39 - we have already excounted the while and
200:42 - for loops in while open parenthesis
200:44 - expression close parentheses statement
200:46 - the expression is evaluated if it is
200:49 - nonzero the statement is executed and
200:51 - the expression is reevaluated this cycle
200:54 - continues until the expression becomes a
200:56 - zero at which point execution return
200:58 - resumes after the statement
201:01 - the for statement four open parenthesis
201:04 - expression one semicolon expression two
201:07 - semicolon expression three closed
201:10 - parentheses statement is equivalent to
201:12 - expression one semicolon while open
201:15 - parenthesis expression two closed
201:17 - parenthesis open curly brace
201:19 - statement
201:21 - expression three semicolon close curly
201:24 - brace
201:25 - grammatically the three components of
201:27 - the four are expressions
201:30 - most commonly expression one and
201:31 - expression three are assignments or
201:33 - function calls and expression two is a
201:35 - relational expression
201:37 - any of the three parts can be omitted
201:39 - although the semicolons must remain
201:42 - expression if expression one or
201:44 - expression three is left out
201:47 - it is simply dropped from the expansion
201:50 - if the test expression two is not
201:51 - present it is taken as permanently true
201:54 - so the code
201:56 - for open parenthesis semicolon semicolon
201:59 - closed parenthesis open curly brace dot
202:01 - dot close curly brace is an infinite
202:03 - loop
202:04 - presumably to be broken by some other
202:06 - means such as a break or a return
202:10 - whether to use while or for is largely a
202:13 - matter of taste
202:14 - for example
202:16 - in the code
202:17 - while open parentheses open parenthesis
202:19 - c equals get char open paren close paren
202:21 - close parenthesis equal equal
202:24 - quote space quote
202:26 - or
202:26 - c equal equal quote backslash end quote
202:30 - or
202:31 - c equal equal quote backslash t quote
202:34 - close parentheses semicolon
202:36 - skipping white characters
202:38 - there is no initialization or
202:40 - re-initialization so a while seems more
202:42 - natural
202:44 - the four is clearly superior when there
202:46 - is simple initialization and
202:48 - reinitialization
202:50 - since it keeps the loop control
202:51 - statements close together and visible at
202:54 - the top of the loop this is the most
202:56 - obvious in
202:57 - 4
202:58 - open paren i equals 0 semicolon i less
203:01 - than n semicolon i plus plus close paren
203:04 - which is the c idiom for processing the
203:08 - first n elements of an array
203:10 - the analog of a fortran or pl1 do loop
203:14 - the analogy is not perfect however since
203:16 - the limits of a for loop can be altered
203:18 - within the loop and the controlling
203:20 - variable i retains its value when the
203:22 - loop terminates for any reason
203:25 - because the components of the four are
203:27 - arbitrary expressions for loops are not
203:30 - restricted to arithmetic progressions
203:33 - nonetheless is bad style to force
203:35 - unrelated computations into a four it is
203:38 - best reserved for loot control
203:41 - operations
203:44 - as a larger example here is another
203:46 - version of the a to i function for
203:49 - converting a string to its numeric
203:50 - equivalent
203:52 - this one is more general it
203:54 - copes with optional leading white space
203:57 - and an optional plus or minus sign
204:00 - chapter 4
204:01 - shows a to f which does the same
204:03 - conversion for floating point numbers
204:06 - the basic structure of the program
204:07 - reflects the form of the input
204:09 - skip white space if any get the sign if
204:12 - any get the integer part and convert it
204:15 - each step does its part and leaves a
204:17 - clean slate for the next the whole
204:19 - process terminates on the first
204:21 - character that would not be part of a
204:23 - number
204:25 - this is the first example
204:27 - on page 58 of the textbook
204:32 - a to i open paren s close paren which is
204:35 - going to convert s to an integer
204:37 - char
204:38 - s open square bracket close square
204:41 - bracket semicolon
204:43 - open curly brace int
204:45 - i comma n comma sine semicolon
204:49 - 4
204:50 - i equals 0
204:52 - s sub i equal equal
204:55 - quote space quote or s sub i equals
204:59 - equals quote backslash end quote or
205:02 - s sub i equals equals backslash quote
205:05 - backslash t quote semicolon
205:07 - i plus plus
205:09 - semicolon
205:11 - skip white space this is a for loop with
205:14 - an empty loop body
205:16 - sine equals one semicolon
205:19 - if s sub i equal equal plus or
205:24 - s sub i equal equal quote minus quote
205:27 - close parenthesis
205:29 - sine
205:30 - equals
205:32 - and here we use a
205:33 - ternary operator
205:35 - open parentheses s sub i plus plus equal
205:39 - equal quote plus quote close parenthesis
205:43 - question mark 1 colon minus 1 semicolon
205:49 - for open parentheses n equals 0
205:52 - semicolon s sub i greater than or equal
205:54 - to quote 0 quote and s sub i less than
205:58 - or equal to quote 9 quote i plus plus
206:01 - close parenthesis
206:03 - n equals 10 times
206:06 - n plus s sub i minus quote 0 quote
206:10 - semicolon
206:12 - return open parenthesis sine times n
206:15 - close parenthesis semicolon close curly
206:18 - brace to end the function
206:20 - the advantages of keeping loop control
206:22 - centralized are even more obvious when
206:24 - there are separate several nested loops
206:27 - the following function is a shell sort
206:29 - for sorting an array of integers the
206:31 - basic idea
206:32 - of the shell
206:34 - sort is that in early stages far apart
206:36 - elements are compared rather than
206:37 - adjacent ones as in simple interchange
206:39 - sorts this tends to eliminate large
206:42 - amounts of disorder quickly so later
206:44 - stages have less work to do the interval
206:46 - between the compared elements is
206:48 - gradually decreased to 1 at which point
206:51 - the sort becomes an effectively an
206:52 - adjacent interchange method
206:55 - this sample code is the second example
206:58 - in page 58 of the textbook
207:02 - shell open parentheses v comma and close
207:05 - parenthesis int v open square bracket
207:08 - close square bracket comma n semicolon
207:11 - open curly brace
207:13 - int
207:14 - gap comma i comma j comma temp
207:19 - four open paren gap equals n divided by
207:22 - two semicolon gap
207:25 - greater than zero semicolon
207:27 - gap
207:29 - slash equals to close parenthesis
207:32 - 4 open parenthesis i equals gap
207:35 - semicolon i less than n
207:38 - i plus
207:40 - close parenthesis
207:42 - 4
207:43 - and now we're 3d nested in the for loops
207:46 - 4 open parenthesis j equals i minus gap
207:49 - semicolon j greater than or equal to 0
207:52 - and
207:54 - v sub j
207:56 - greater than v sub j plus gap semicolon
207:59 - j minus equals gap close parenthesis
208:03 - open curly brace
208:04 - temp equals v sub j
208:07 - v sub j equals v sub j plus gap
208:11 - semicolon v sub j plus gap equals temp
208:14 - semicolon just a swap of v and v b sub j
208:17 - plus gap p sub j and v sub j plus cap
208:20 - close curly brace and that close the
208:23 - inner innermost for loop and
208:26 - and then the next closed curly brace
208:27 - closes the function
208:30 - there are three nested loops
208:32 - the outermost loop controls the gap
208:34 - between the compared elements shrinking
208:36 - it from n over two by a factor of two
208:38 - each pass until it becomes zero the
208:40 - middle loop compares each pair of
208:42 - elements that is separated by cap
208:44 - the innermost loop reverses any elements
208:46 - that are out of order
208:48 - since gap is eventually reduced to one
208:50 - all elements are eventually ordered
208:52 - correctly
208:53 - note that the generality of the 4 makes
208:56 - the outer loop fit the same form as the
208:58 - others
208:59 - even though it is not an arithmetic
209:01 - progression
209:06 - one final c operator is the comma
209:09 - which most often finds use in the for
209:11 - statement
209:12 - a pair of expressions separated by a
209:14 - comma is evaluated left to right and the
209:17 - type and value of the result are the
209:20 - type and value of the right operand thus
209:23 - in a for statement it is possible to
209:25 - place multiple expressions in the
209:26 - various parts
209:28 - for example to process two parallel
209:30 - indices
209:32 - this is illustrated in the function
209:33 - reverse which reverses the function
209:35 - string in place
209:38 - this code is from page 59 of the
209:41 - textbook and it is the first example on
209:43 - page 59.
209:45 - pound include less than string.h greater
209:48 - than
209:49 - reverse open paren s close paren
209:52 - char
209:53 - s open square bracket close square
209:55 - bracket semicolon
209:57 - open curly brace int c comma i comma j
210:02 - for open parenthesis i equals zero comma
210:05 - j equals stirling sub s minus one
210:10 - semicolon
210:11 - i less than j semicolon i plus plus
210:15 - comma j minus minus close parenthesis
210:18 - open curly brace
210:20 - c equals s sub i s sub i equals s sub j
210:23 - semicolon s sub j equals c semicolon
210:27 - close curly brace
210:29 - close curly brace to end the function
210:31 - the commas that separate the function
210:33 - arguments variables declarations etc are
210:36 - not comma operators and do not guarantee
210:39 - left to right evaluation
210:42 - section 3.6 loops do while
210:46 - the while and for loops share the
210:48 - desirable attribute of testing the
210:50 - termination condition at the top rather
210:52 - than at the bottom as we discussed in
210:53 - chapter one
210:55 - the third loop in c the do while tests
210:57 - at the bottom after making each pass
210:59 - through the loop body the body is always
211:01 - executed at least once
211:04 - the syntax is as follows
211:06 - do
211:07 - statement while open parenthesis
211:09 - expression close parenthesis semicolon
211:12 - the statement is executed then the
211:14 - expression is evaluated if it is true
211:16 - statement is evaluated again and so on
211:19 - if the expression becomes false the loop
211:21 - terminates
211:23 - as might be expected do while is much
211:26 - less used than while in four accounting
211:28 - perhaps five percent of all loops
211:31 - nonetheless it is from time to time
211:33 - valuable as the following as in the
211:35 - following function i to a which converts
211:37 - a number to a character string the
211:39 - inverse of a to i the job is slightly
211:41 - more complicated than it might be
211:42 - thought at first
211:44 - because the easy methods of generating
211:45 - the digits generate them in the wrong
211:47 - order
211:48 - we've chosen to generate the string
211:50 - backwards and then reverse it
211:53 - this is the first sample code on page 61
211:57 - page 60 of the textbook
212:00 - i to a open parenthesis n comma s close
212:04 - parenthesis char
212:06 - s open square bracket close square
212:07 - bracket semicolon
212:09 - int n semicolon
212:12 - open curly brace
212:13 - int i comma sine semicolon
212:17 - if
212:19 - open parenthesis open parenthesis sine
212:22 - equals n
212:23 - close parenthesis less than zero
212:26 - close parenthesis
212:28 - n equals minus n semicolon that's a bit
212:31 - of a complex if i would say there
212:33 - it has an assignment statement that both
212:35 - copies n into sine
212:38 - and then evaluates as to whether or not
212:40 - it's less than zero the n or sign is
212:42 - less than zero because it's a side
212:44 - effect assignment statement for the
212:45 - residual value
212:48 - but the net result is sign contains n
212:51 - and then it's negated um
212:53 - then n is made positive
212:55 - so continuing
212:57 - i equals 0 semicolon
212:59 - do
213:00 - open curly brace
213:02 - s sub i plus plus
213:05 - equals n
213:06 - modulo 10
213:08 - plus
213:10 - quote 0 quote
213:12 - semicolon
213:14 - close curly brace while
213:16 - parenthesis parenthesis n slash equals
213:19 - 10
213:20 - close parenthesis
213:21 - greater than zero close parenthesis
213:24 - semicolon
213:26 - if open parenthesis sine less than zero
213:29 - close parenthesis
213:31 - s sub i plus plus
213:33 - equals quote dash quote
213:36 - or minus sign semicolon
213:39 - s sub i
213:40 - equals quote
213:42 - 0 quote semicolon in a sense to
213:44 - terminate the string and then we call
213:46 - the function reverse reverse open
213:48 - parenthesis s close parenthesis
213:50 - semicolon close curly brace
213:54 - the do while is necessary or at least
213:56 - convenient since at least one character
213:58 - must be installed in the array s
214:00 - regardless of the value of n
214:03 - we have also used braces around the
214:04 - single statement that makes up the body
214:06 - of the do while even though they are
214:08 - unnecessary so the hasty reader will not
214:10 - mistaken mistake the while part for the
214:13 - beginning of a while loop
214:16 - i would note that it's important for any
214:18 - language to provide top tested loops and
214:19 - bottom tested loops but don't feel bad
214:22 - if you write code for years and never
214:24 - feel like a bottom tested loop is the
214:26 - right way to solve a problem you're
214:27 - facing it is usually rare to write a
214:29 - loop that you insist will run once
214:32 - regardless of its input data
214:37 - section 3.7 break
214:41 - it is sometimes convenient to be able to
214:44 - control loop exits other than by testing
214:46 - at the top or the bottom
214:49 - the break statement provides an early
214:51 - exit from a for while or do just as it
214:54 - does from the switch statement
214:56 - a break statement causes the innermost
214:58 - enclosing loop or switch to be executed
215:01 - immediately
215:02 - the following program removes trailing
215:05 - blanks and tabs from the end of each
215:07 - line of input using a break to exit from
215:09 - a loop
215:10 - when the rightmost character is
215:11 - non-blank non-tab is found
215:14 - this example code is on page 61 of the
215:17 - textbook and it is the first example on
215:19 - that page
215:21 - pound include less than stdio.h
215:25 - pound define max line 1000
215:28 - main open parenthesis close parenthesis
215:31 - open curly brace
215:33 - int
215:34 - n
215:35 - semicolon char
215:37 - line open bracket
215:39 - max line close bracket
215:44 - semicolon
215:45 - while open paren open paren n equals get
215:48 - line open paren line comma max line
215:51 - close paren close brand greater than
215:52 - zero close brand open curly brace
215:55 - while open cur open parenthesis
215:59 - minus minus n greater than or equal to
216:02 - zero close parenthesis
216:03 - if open parenthesis line sub n not
216:06 - equals a quote space quote and
216:09 - line sub n not equal quote backslash t
216:12 - quote and
216:14 - line sub n not equal quote backslash end
216:17 - quote
216:19 - close parenthesis break
216:21 - line
216:22 - sub n plus one equals quote backslash
216:25 - zero quote semicolon
216:27 - printf
216:29 - double quote percent s backslash n
216:31 - double quote comma line close
216:33 - parenthesis semicolon
216:35 - close curly brace to end the while and
216:37 - then close curly brace to end the main
216:41 - getline returns the length of the line
216:44 - the inner while loop starts at the last
216:46 - character of line
216:47 - recall that minus minus n decrements end
216:50 - before using the value and scans
216:53 - backwards looking for the first
216:54 - character that is not a blank tab or new
216:56 - line the loop is broken when one is
217:00 - found or when n becomes negative that is
217:03 - when the entire line has been scanned
217:06 - you should verify that this is the
217:07 - correct behavior even when the line
217:09 - contains only white space characters
217:12 - an alternative to break is to put the
217:14 - testing in the loop itself
217:19 - while open parenthesis open parenthesis
217:21 - n equals get line open parenthesis line
217:23 - comma max line close parenthesis close
217:25 - parenthesis greater than zero close
217:27 - parenthesis open curly brace
217:31 - while open paren minus minus n greater
217:34 - than
217:34 - equal to zero and open for n line sub n
217:38 - equal equal
217:39 - quote space quote or line sub n equals
217:43 - quote backslash t quote or line sub n
217:46 - equals
217:48 - quote backslash n quote close paren
217:50 - close paren semicolon
217:53 - dot dot
217:54 - close curly brace this is inferior to
217:57 - the previous version because the test is
217:59 - harder to understand
218:01 - tests which require a mixture of and or
218:06 - not
218:06 - and parentheses should generally be
218:10 - avoided 3.8 continue
218:15 - the continue statement is related to
218:17 - break but less often used it causes the
218:20 - next iteration of the enclosing loop for
218:22 - a while or do to begin
218:24 - in the while and do this means that the
218:25 - test part is executed immediately
218:28 - in the four control passes to the
218:30 - re-initialization step
218:32 - control by the way continue applies only
218:34 - to loops not to switch a continue inside
218:37 - a switch statement inside of a loop
218:40 - causes the next loop iteration
218:42 - as an example
218:43 - this fragment processes only positive
218:46 - elements in the array a negative values
218:48 - are skipped
218:51 - 4 open paren i equals 0 semicolon i less
218:54 - than n semicolon i plus plus close paren
218:58 - open curly brace
219:00 - if open paren a sub i less than 0 close
219:03 - paren
219:04 - continue
219:06 - this line skips the negative elements
219:08 - and then the rest of the body of the
219:10 - loop taut is
219:12 - will run only for the positive elements
219:14 - of the loop and the loop finishes with a
219:16 - close curly brace
219:19 - the continue statement is often used
219:21 - when part of the loop that follows is
219:23 - complicated so that reversing a test and
219:24 - indenting another level would nest the
219:26 - program too deeply
219:30 - it's time for a bit of an aside
219:32 - now that we have seen the break and
219:34 - continue language structures in c that
219:36 - also have made it into c like languages
219:38 - and learned about middle tested loops it
219:40 - is time to revisit the structured
219:42 - programming debate
219:43 - and the need for priming operations when
219:45 - a program must process all data until it
219:48 - finishes and still handle the there is
219:50 - no data at all situation
219:53 - in the previous chapter the author
219:54 - somewhat skirted the issue by using a
219:56 - top tested while loop and a side effect
219:58 - statement with residual value that was
220:00 - compared to eof to decide when to exit
220:03 - the loop
220:04 - int c colon while open parenthesis open
220:08 - parenthesis c equals get char open paren
220:10 - close paren close parenthesis not equal
220:12 - eof close parenthesis open curly brace
220:15 - process your data
220:16 - close curly brace
220:18 - and just for fun now that we do know
220:20 - about the for loop let's rewrite this
220:22 - loop as a for loop to make sure we
220:24 - really understand how for loops work
220:28 - in c semicolon for
220:31 - friend c equals get char open print
220:33 - close print semicolon
220:35 - c not equal eof semicolon c equals get
220:38 - char open print close paren close paren
220:41 - curly brace process your data close
220:44 - curly brace for the for loop
220:46 - now you will almost never see a read all
220:49 - characters until eof written this way
220:51 - because because it is not the way knr
220:54 - told us
220:55 - knr told us to reuse a while loop for
220:57 - this
220:58 - but the for loop formulation is probably
221:00 - clearer to many
221:02 - than the while formulation especially to
221:04 - a reader who's not familiar with the
221:06 - assignment side effect idiom commonly
221:08 - used in c
221:09 - in particular the four formulation does
221:11 - not require
221:13 - that the assignment statement has a
221:15 - residual value of the value that was
221:17 - assigned
221:19 - the first part of the four is a priming
221:20 - read the second part of the four is a
221:22 - top text tested exit criteria that works
221:25 - both for no data and after all data has
221:27 - been read and processed and the third
221:29 - part of the four is done at the bottom
221:31 - of the loop to advance to the next
221:32 - character
221:34 - or encounter eof before going back to
221:36 - the top and doing the loop test the call
221:38 - to get char is
221:40 - done twice in the for formulation of the
221:42 - read all available data loop and while
221:45 - we don't like to repeat ourselves in
221:46 - code it is a if it is a small and
221:48 - obvious bit of code perhaps this code
221:51 - is more clear with a bit of repetition
221:56 - so with all this is background
221:58 - you can take this page of the document
222:00 - and sit down with a friend at a coffee
222:02 - shop and debate as long as you like
222:05 - about which is the better formulation
222:06 - for the read all available
222:08 - data but if at that coffee shop you
222:11 - asked dr chuck's opinion neither of
222:13 - these is ideal because in the real world
222:15 - we build data oriented loops that
222:16 - usually do a lot more than get one
222:18 - character from standard input
222:21 - my formulation of a data loop will upset
222:23 - the structured programming purists and
222:26 - probably upset kernighan enrichy as well
222:29 - but i write code in the real world so
222:30 - here is my version
222:34 - int
222:35 - c semicolon
222:37 - while open paren one close print open
222:40 - curly brace
222:41 - c equals get char
222:43 - if open friends c double equals eof
222:46 - close paren break
222:48 - process your data and then close curly
222:50 - brace to end the loop and if i wanted to
222:52 - skip blanks and new lines i could use
222:55 - both break and continue further angered
222:58 - angering the structured programming
222:59 - purists
223:02 - int c semicolon while open parenthesis
223:05 - one closed parenthesis open curly brace
223:07 - c equals get char open
223:09 - parenthesis close parenthesis semicolon
223:12 - if
223:13 - open parenthesis c equal equal eof close
223:16 - parenthesis break
223:17 - if open parenthesis c equal equal quote
223:20 - space quote or
223:22 - c equal equal quote backslash end quote
223:25 - close parenthesis continue
223:27 - then process your data
223:28 - close parenthesis
223:30 - i use this middle tested approach
223:32 - because usually the data i am processing
223:34 - is coming from a more complex source
223:36 - than the keyboard and i don't want a
223:38 - function with two to three parameters
223:40 - stuck inside of a sine side effect
223:42 - statement in a while test
223:44 - and also sometimes you want to exit loop
223:46 - not just based on the return value from
223:48 - the function
223:49 - but instead based on the complex
223:51 - structure that came back from the
223:53 - function itself
223:55 - as these data processing loops get more
223:57 - complex the middle tested loop is a
223:59 - tried and true pattern
224:01 - even kernighan and ritchie point out its
224:03 - benefits above
224:05 - and with that i have now triggered
224:08 - endless coffee shop conversations about
224:10 - the best way to write a data handling
224:13 - loop
224:18 - section 3.9 go to's and labels
224:22 - c provides the infinitely abusable go-to
224:26 - statement and labels to branch to
224:28 - formally the go-to is never necessary
224:32 - and in practice
224:33 - it is almost always easy to write code
224:36 - without it we have not used go to in
224:38 - this book
224:39 - nevertheless we will suggest a few
224:41 - situations where go-to's might find a
224:44 - place the most common
224:45 - use is to abandon processing in some
224:48 - deeply nested structure such as breaking
224:50 - out of two loops at once
224:52 - the break statement cannot be used
224:53 - directly since it leaves the only the
224:55 - most inter innermost loop thus
224:59 - four open parentheses.close parenthesis
225:02 - four open parenthesis.close parenthesis
225:04 - open curly brace do some stuff if open
225:07 - parenthesis disaster close parenthesis
225:09 - go to error semicolon
225:12 - close curly brace dot dot dot dot dot
225:14 - and then error colon
225:17 - and then clean up the mess
225:18 - this organization is handy if the
225:21 - error handling code is non-trivial and
225:23 - if errors can occur in several places a
225:25 - label has the same form as a variable
225:27 - name and is followed by a colon
225:29 - it can be attached to any statement in
225:32 - the same function as the go to
225:37 - another example
225:38 - consider the possibility of finding the
225:40 - first negative element in a
225:42 - two-dimensional array
225:43 - multi-dimensional arrays are discussed
225:45 - in chapter five
225:47 - one possibility is four
225:49 - open parenthesis i equals zero semicolon
225:52 - i less than n
225:54 - semicolon i plus plus close parentheses
225:57 - four open parenthesis j equals zero
226:00 - semicolon j less than m semicolon j plus
226:04 - plus close parenthesis
226:05 - if open parenthesis v sub i sub j less
226:09 - than zero close parenthesis go to found
226:13 - other one and then you handle and you
226:15 - keep going and then found colon
226:18 - include is where it comes to uh jumps to
226:22 - code involving a go to can always be
226:24 - written without want but though perhaps
226:27 - at the price of somewhat repeated tests
226:28 - or an extra variable for example the
226:31 - array search becomes
226:33 - found equals zero four open parenthesis
226:37 - i equals zero semicolon i less than n
226:40 - ampersand ampersand exclamation found
226:43 - semicolon i plus plus
226:46 - four open parenthesis j equals zero
226:48 - semicolon j less than m ampersand
226:51 - ampersand exclamation found
226:53 - semicolon j plus plus
226:56 - found equals v sub i sub j less than
226:59 - zero
227:00 - if found
227:01 - continue else not found although we are
227:04 - not dogmatic about the matter it does
227:07 - seem that go to go to statements should
227:09 - not should be used sparingly at if at
227:11 - all
227:13 - i would add before we leave control flow
227:16 - i need to say that i agree with
227:17 - structured programming experts as well
227:19 - as kernighan and ritchie in that the
227:21 - go-to is universally a bad idea
227:24 - there are a lot of little details that
227:26 - make them a real problem
227:28 - things like how the stack works in
227:29 - function calls and how code blocks
227:31 - happen and patching the stack up
227:33 - correctly when a go to happens in the
227:35 - middle of a deeply nested mess
227:38 - you might be tempted to use a go to when
227:40 - you want to exit multiple nested loops
227:42 - in a single statement break and continue
227:44 - only exit the innermost loop the authors
227:46 - use this example above
227:48 - but are quite lukewarm when describing
227:50 - it as the use of go to
227:53 - usually if your problem is that complex
227:56 - putting things in a function and using
227:58 - return or adding a few if statements is
228:00 - a better choice
228:01 - the dr chuck middle tested loop data
228:03 - processing solves this because the loop
228:06 - is always the innermost loop
228:08 - also as new languages were built the
228:11 - concept of exceptions became part of
228:13 - language design and was by a by far more
228:16 - elegant solution
228:17 - to a path of some deeply nested code
228:19 - that just needs to get out
228:21 - so most of the time you think the go-to
228:24 - might be a good idea you should lean
228:26 - towards a throw catch pattern to make
228:28 - your intention clear
228:30 - it is one of the reasons why we prefer
228:32 - languages like java or python over c
228:35 - when writing general purpose code
228:41 - this work
228:42 - is based on the 1978 c programming book
228:45 - written by brian w kernighan and dennis
228:47 - m ritchie
228:48 - their book is copyright all rights
228:50 - reserved by at t
228:52 - but is used in this work under fair use
228:55 - because of the book's historical and
228:56 - scholarly significance
228:58 - its lack of availability and the lack of
229:01 - an accessible version of the book
229:03 - the book is augmented in places to help
229:05 - understand its rightful place in a
229:06 - historical context amidst the major
229:08 - changes of the 1970s and 1980s as
229:12 - computer science evolved from a hardware
229:14 - first vendor-centered approach to a
229:16 - software-centered approach where
229:18 - portable operating systems and
229:19 - applications written in c could run on
229:22 - any
229:22 - hardware this is not the ideal book to
229:25 - learn c programming because the 1978
229:28 - edition does not reflect the modern c
229:30 - language
229:31 - using an obsolete book gives us an
229:33 - opportunity to take students back in
229:34 - time and understand how the c language
229:37 - was evolving as it laid the groundwork
229:40 - for a future with portable applications
229:45 - chapter 4 functions in program structure
229:48 - functions break large computing tasks
229:50 - into smaller ones and enable people to
229:53 - build on what others have done instead
229:54 - of starting over from scratch
229:56 - appropriate functions can often hide
229:58 - details of operation from parts of the
230:00 - program that don't need to know about
230:02 - them thus clarifying the whole and
230:04 - easing the pain of making changes
230:07 - c has been designed to make functions
230:09 - efficient and easy to use
230:12 - c programs generally consist of numerous
230:14 - small functions rather than a few big
230:15 - ones
230:16 - a program may reside on one or more
230:18 - source files in any convenient way
230:21 - the source files may be compiled
230:23 - separately and loaded together along
230:25 - with previously compiled functions from
230:27 - libraries we will not go into that
230:29 - process here since the details vary
230:31 - according to the local system most
230:34 - programmers are familiar with library
230:36 - functions for input and output like get
230:38 - char input chart and numerical
230:40 - computations like sine cosine and square
230:43 - root in this chapter we will show more
230:46 - about writing new functions
230:49 - 4.1 basics
230:51 - to begin let us design and write a
230:54 - program to print each line of input that
230:56 - contains a particular pattern or string
230:58 - of characters
230:59 - this is a special function of the unix
231:02 - utility program grap
231:04 - for example searching for the pattern
231:06 - the in the set of lines now is the time
231:09 - for all good men to come to the aid of
231:12 - their party we'll produce the output now
231:15 - is the time
231:17 - men to come to the aid of their party
231:20 - the basic structure of the task falls
231:23 - neatly into three pieces
231:25 - while there's another line
231:26 - if that line contains a pattern print it
231:30 - although it's certainly possible to put
231:32 - the code for all of this in one main
231:33 - routine
231:34 - a better way is to use the natural
231:36 - structure to advantage by making each
231:38 - part a separate function
231:40 - three small pieces are easier to deal
231:42 - with than the one big one because
231:44 - irrelevant details can be buried in the
231:47 - functions and the chance of unwanted
231:49 - interactions minimized and the pieces
231:51 - might even be useful later in their own
231:54 - right
231:56 - while there is another line is getline a
231:58 - function we wrote in chapter one and
232:00 - printed is printf which someone has
232:03 - already provided for us
232:04 - this means that we need to only write a
232:06 - routine which decides if the line
232:09 - contains an occurrence of the pattern
232:11 - we can solve that problem
232:13 - by stealing a design from pl1 the
232:16 - function index
232:18 - s comma t returns the position or index
232:21 - in the string s where the string t
232:23 - begins
232:24 - or -1 if s doesn't contain t
232:28 - we use 0 rather than 1 as the starting
232:30 - position in s because c arrays always
232:33 - begin at position 0.
232:35 - when we later need more sophisticated
232:37 - pattern matching
232:38 - we only have to replace index the rest
232:40 - of the code can remain the same
232:43 - recall that because the modern stdio.h
232:47 - defines a getline function whenever the
232:49 - book writes this function to teach a
232:51 - feature of functions we rename it to get
232:54 - underscore line
232:56 - given this much design filling in the
232:58 - details of the program is
233:00 - straightforward here's the whole thing
233:02 - so you can see how the pieces fit
233:03 - together
233:04 - for now the pattern to be searched for
233:07 - is a literal string in the argument of
233:09 - index which is not the most general of
233:11 - mechanisms
233:12 - we will return shortly to a discussion
233:14 - of how to initialize character arrays
233:16 - and in chapter 5 we will show how to
233:18 - make the pattern
233:19 - a parameter that is set when the program
233:21 - is run
233:23 - this is also a new version of getline
233:25 - you might find it instructive to compare
233:27 - it to the one in chapter one
233:31 - pound include stdio.h
233:33 - pound define max line 1000
233:36 - main open parenthesis closed parenthesis
233:38 - open curly brace
233:40 - char
233:41 - line open square bracket max line close
233:44 - square bracket semicolon
233:46 - while parentheses get line open
233:48 - parenthesis line comma max line close
233:51 - parenthesis greater than zero
233:53 - close parenthesis
233:54 - if
233:55 - open parenthesis index open parenthesis
233:57 - line comma double quote the double quote
234:01 - close parenthesis greater than or equal
234:03 - to zero
234:05 - close parenthesis printf open
234:07 - parenthesis double quote percent s
234:10 - double quote comma line
234:12 - close parenthesis semicolon
234:15 - and a close curly brace to finish the
234:16 - main function
234:20 - next function is get line
234:22 - get
234:23 - line open parenthesis s comma limb close
234:26 - parenthesis
234:27 - char s
234:28 - open square bracket close square bracket
234:30 - semicolon available
234:46 - c equals get char open frame close paren
234:48 - close paren not equal e o f
234:51 - double ampersand
234:53 - c not equal
234:55 - double quote backslash n double quote
234:57 - semicolon plus plus i close parentheses
235:00 - s sub i equals c
235:04 - that loop basically read until it found
235:06 - a new line or end of file
235:09 - if
235:11 - open parenthesis c double equals
235:13 - quote backslash end quote close
235:15 - parenthesis open curly brace
235:17 - s sub i equals c
235:19 - plus plus i semicolon close curly brace
235:22 - closing the f
235:28 - s sub i equals quote backslash zero
235:31 - quote
235:32 - semicolon to terminate the string
235:34 - properly return
235:36 - open paren
235:38 - i close paren
235:40 - semicolon to return the length of the
235:43 - line and then close curly brace to
235:45 - finish the getline function
235:47 - and now the new code
235:49 - index open parenthesis s comma t close
235:52 - parenthesis char
235:54 - s
235:54 - open square bracket close square bracket
235:56 - comma t open square bracket close square
235:59 - bracket semicolon i would note that
236:02 - when we are declaring a character array
236:05 - and we don't give the length of the
236:06 - array that means that we're inside of a
236:09 - function the length of the array exists
236:11 - but it was from the callings calling
236:13 - code
236:14 - so
236:15 - char
236:16 - s
236:17 - open square bracket close square bracket
236:19 - t open square bracket close square
236:21 - bracket semicolon means
236:23 - parameters s and t are strings of some
236:26 - length and we will use backslash 0 to
236:28 - know when that length is done
236:30 - beginning the code in index with an open
236:33 - curly brace int
236:35 - i comma j comma k
236:37 - semicolon
236:39 - and then we have two nested for loops
236:42 - four open print i equals zero
236:44 - s sub i not equal to quote backslash
236:47 - zero quote semicolon i plus plus open
236:50 - curly brace
236:53 - four
236:54 - j equals i comma k equals zero
236:57 - semicolon
236:59 - t s t sub k not equal to backslash zero
237:03 - and double ampersand s sub j double
237:07 - equals t sub k semicolon j plus plus k
237:11 - plus plus
237:12 - semicolon
237:15 - if open print t sub k double equals
237:18 - quote backslash zero quote close paren
237:21 - return open paren i close paren
237:24 - semicolon close curly brace
237:27 - return
237:28 - open paren minus one close paren
237:30 - semicolon curly brace
237:36 - each function has the form
237:38 - name
237:39 - argument list if any
237:42 - in parentheses
237:43 - argument declarations if any open curly
237:46 - brace declarations and statements if any
237:48 - close curly price as suggested various
237:51 - parts may be absent a minimal function
237:53 - is dummy open paren close paren open
237:56 - curly brace closed curly brace which
237:59 - does nothing a do nothing function is
238:02 - sometimes useful as a placeholder during
238:04 - program development the function name
238:06 - may also be preceded by a type if the
238:08 - vert function returns something other
238:10 - than an integer value this is the topic
238:12 - of the next section
238:15 - a program is just a set of individual
238:18 - function definitions communication
238:19 - between the functions is in this case by
238:22 - arguments and values returned by the
238:24 - functions it can also be via external
238:27 - variables the functions can occur in any
238:29 - order in the source file and the source
238:31 - program can be split into multiple files
238:33 - so long as no function is split
238:36 - the return statement is the mechanism
238:38 - for returning a residual value from the
238:41 - called function to its caller
238:43 - any expression can follow return
238:46 - return open parentheses expression close
238:48 - parentheses
238:50 - the calling function is free to ignore
238:52 - the return value if it wishes
238:54 - furthermore there need
238:57 - there is no need to have an expression
238:59 - after the return
239:00 - in that case no value is returned to the
239:02 - caller control also returns to the
239:04 - caller with no value when execution
239:07 - falls off the end of the function by
239:09 - reaching the right closing brace it is
239:12 - not illegal but probably a sign of
239:14 - trouble if a function returns a value
239:16 - from one place and no value from another
239:19 - place
239:20 - in any case
239:21 - the residual value of a function which
239:23 - does not return one is certain to be
239:25 - garbage
239:26 - the c verifier lint checks for such
239:29 - errors
239:31 - the mechanics of how to compile and load
239:33 - a c program which resides on multiple
239:35 - source files vary from one system to the
239:37 - next on the unix system for example the
239:40 - cc command mentioned in chapter one does
239:42 - the job
239:43 - suppose that three functions are in
239:45 - three files called main.c
239:47 - getline.c and index.c then the command
239:51 - cc main.c getline.c index.c compiles the
239:56 - three files and places the resulting
239:58 - relocatable object code in files main.o
240:02 - getline.o and index.o and loads them all
240:04 - into an executable file named a dot out
240:08 - if there is an error say in main.c that
240:11 - file can be recompiled by itself and the
240:13 - result loaded with the previous object
240:15 - files with the command cc main.c
240:19 - getline.o index.o
240:21 - the cc command uses the dot c suffix
240:23 - versus the dot o suffix naming
240:25 - convention to distinguish source files
240:28 - from object files
240:30 - i would note that this cc example
240:32 - exactly as the authors wrote it does not
240:34 - quite work as described in modern c
240:36 - compilers if you want to compile your
240:39 - source code and leave the compiled
240:40 - object code around after the compile you
240:43 - add the minus c option to the compiler
240:45 - column
240:46 - modern c compilers generally do accept
240:48 - multiple files with either dot c or dot
240:50 - o suffixes and conv combine them into a
240:54 - runnable application
240:55 - section 4.2 functions returning
240:58 - non-integers
241:00 - so far none of our programs has
241:02 - contained any declaration of the type of
241:04 - a function
241:05 - this is because by default a function is
241:08 - implicitly declared by its appearance in
241:10 - an expression or statement such as while
241:14 - open paren get line open paren line
241:16 - comma max line close paren greater than
241:18 - zero close print
241:20 - if a name which has not been previously
241:22 - declared occurs in an expression and is
241:25 - followed by a left parenthesis it is
241:27 - declared by context to be a function
241:29 - name
241:30 - furthermore
241:31 - by default the function is assumed to
241:33 - return an int
241:35 - since char promotes to int in
241:37 - expressions there is no need to declare
241:39 - functions that return char these
241:42 - assumptions cover the majority of
241:43 - classes including all of our examples so
241:45 - far
241:48 - i would add
241:49 - that's not true quite true anymore in
241:52 - modern c languages you are required to
241:54 - provide a type for each function if you
241:56 - leave off the type for a function
241:58 - declaration at a minimum you will give
242:00 - us get a stern warning message
242:02 - but sometimes functions do not intend to
242:04 - return anything at all and so the void
242:07 - type was invented to indicate that a
242:10 - function returns nothing
242:11 - the rule of requiring a type on a modern
242:14 - function definition in c
242:16 - even if it's void allows the compiler to
242:18 - check to make sure all of your return
242:19 - values in a function
242:21 - match the expected return type
242:25 - back to the text
242:27 - but what happens if a function must
242:28 - return some other type
242:31 - many numerical functions like square
242:33 - roots sine and cosine return double
242:35 - other specialized functions return other
242:37 - types to illustrate how to deal with
242:39 - this let us write and use the function a
242:42 - to f
242:43 - which converts its argument string s to
242:46 - its double precision floating point
242:48 - equivalent
242:49 - a2f is an extension of a to i
242:52 - which we wrote versions of in chapters
242:54 - two and three
242:55 - it handles an optional sign and decimal
242:57 - point and the presence or absence of
242:59 - either the integer or fractional part
243:03 - we note that this is not a high quality
243:05 - input conversion routine it takes doing
243:07 - everything takes a bit more space than
243:09 - we care to use here in this book
243:11 - first
243:12 - a to f must declare the type of the
243:14 - value it returns since it's not int
243:17 - because float is converted to double in
243:19 - expressions there is no point in saying
243:20 - that a to f returns float we might as
243:23 - well make use of the extra precision and
243:24 - thus declare it to return double
243:27 - the type name precedes the function name
243:29 - like this
243:31 - double
243:32 - a to f
243:33 - open parenthesis s close parenthesis
243:36 - char
243:36 - s open square bracket close square
243:39 - bracket open curly brace
243:41 - double val comma power
243:43 - int i comma sine semicolon
243:46 - for
243:47 - i equals zero semicolon s sub i double
243:50 - equals quote space quote or
243:53 - s sub i double equals quote backslash
243:56 - end quote or
243:58 - s sub i
243:59 - eq double equals quote backslash t quote
244:02 - semicolon i plus plus
244:05 - semicolon
244:06 - that skips the white space
244:08 - sine equals one
244:10 - if s sub i double equals quote plus
244:14 - quote or
244:15 - s sub i double equals quote minus quote
244:19 - sine equals
244:20 - and now we're going to use a ternary
244:22 - operator here paren s sub i plus plus
244:26 - close
244:27 - bracket
244:28 - double equals quote plus quote close
244:30 - paren
244:31 - question mark
244:32 - 1 colon minus one semicolon
244:36 - and that basically tells us it it makes
244:39 - sine be one or negative one based on the
244:41 - presence or absence of a plus or minus
244:46 - for val equals zero semicolon
244:48 - s sub i greater than or equal to quote
244:50 - zero quote double ampersand s sub i less
244:53 - than or equal to double quote nine quote
244:55 - i plus plus
244:57 - close paren
244:59 - val equals 10 times val
245:02 - plus s sub i minus quote zero quote
245:05 - semicolon
245:06 - what this is doing is multiplying the
245:08 - current value by 10 in effect shifting
245:10 - it left and then adding in that new
245:12 - lower empty spot
245:14 - the digit that we're encountering which
245:16 - is somewhere between the character 0 and
245:17 - the character 9.
245:19 - continuing
245:20 - if parentheses s sub i double equals
245:23 - quote dot quote close parentheses
245:26 - i plus plus
245:30 - four open parenthesis power equals one
245:34 - semicolon s sub i greater than or equal
245:37 - to quote zero quote double ampersand s
245:40 - sub i less than or equal to quote nine
245:43 - quote semicolon i plus plus
245:45 - open curly brace
245:47 - val equals 10 times val plus s sub i
245:51 - minus quote zero quote
245:54 - again shifting the number to the left as
245:57 - its as we encounter characters
245:59 - power star equals 10 semicolon
246:03 - close curly brace
246:05 - return
246:06 - open parenthesis sine times val
246:10 - over power close parenthesis
246:13 - semicolon
246:14 - close curly brace
246:18 - second and just as important the calling
246:20 - routine must state that a to f returns a
246:23 - non-end value the declaration is shown
246:25 - in the following primitive desk
246:27 - calculator
246:28 - barely adequate for checkbook balancing
246:31 - which reads one number per line
246:33 - optionally preceded by sign and adds
246:34 - them all up printing the sum after each
246:37 - input
246:40 - this example is from page 70 of the
246:42 - textbook
246:43 - pound include
246:45 - stdio.h pound define max line 100
246:49 - main open parenthesis close parenthesis
246:52 - open curly brace double sum comma a to f
246:56 - open parenthesis close parenthesis
246:57 - semicolon
246:59 - char line open square bracket max line
247:02 - close square bracket semicolon
247:04 - sum equals zero
247:06 - while open parenthesis get line open
247:08 - parenthesis line comma max line close
247:10 - parenthesis greater than zero
247:13 - close parenthesis
247:15 - printf
247:16 - quote backslash t
247:19 - percent.2f
247:21 - backslash n comma sum plus equals a to f
247:26 - open parenthesis line close parenthesis
247:29 - close parenthesis
247:30 - semicolon
247:32 - close curly brace
247:34 - that code used the plus a plus equals
247:36 - side effect operator and merge the call
247:39 - to a to f right into the parameter of
247:42 - the second parameter of printf
247:45 - the declaration double sum a to f open
247:48 - parentheses close parentheses says that
247:50 - sum is a double variable and that a to f
247:53 - is a function that returns a double
247:55 - value
247:56 - as a mnemonic it suggests that sum and a
247:58 - to f parenthesis dot dot are both double
248:01 - precision floating point values unless a
248:04 - to f is explicitly declared in both
248:06 - places c assumes it returns an integer
248:09 - and you will get nonsense answers
248:13 - if a to f itself and the call to it in
248:16 - main aren't typed inconsistently with
248:18 - this with in the same source file it
248:20 - will be detected by the compiler but if
248:22 - as is more likely a to f were compiled
248:25 - separately the mismatch would not be
248:27 - detected and a to f would return a
248:29 - double which maine would treat as an end
248:32 - and meaningless answers would result
248:35 - lind catches this error
248:38 - given a to f we could in principle write
248:40 - a to i to convert a string to an integer
248:43 - in terms of it
248:45 - int a to i open parentheses s close
248:48 - parentheses char s open square bracket
248:51 - close square bracket semicolon open
248:53 - curly brace double
248:55 - a to f open parenthesis close
248:57 - parenthesis semicolon
248:59 - return open parenthesis
249:01 - a to f
249:02 - close parentheses s close parentheses
249:04 - close parentheses semicolon close curly
249:07 - brace
249:08 - note the structure of the declarations
249:10 - in the return statement the value in the
249:12 - expression in return expression is
249:14 - always converted to the type of the
249:16 - function before the return is taken
249:19 - therefore the value of a to f
249:21 - a double is converted automatically to
249:24 - int when it appears
249:26 - in a return since the function a to i
249:29 - returns an end
249:32 - the conversion of a floating point value
249:33 - to in truncates
249:35 - any fractional part as we discussed in
249:37 - chapter two
249:38 - more on function arguments
249:41 - in chapter one we discuss the fact that
249:43 - function arguments are passed by value
249:45 - that is the called function receives a
249:48 - private temporary copy of each argument
249:51 - not its address
249:52 - this means that the function cannot
249:54 - affect the original argument in the
249:56 - calling function
249:57 - within a function each argument is in
250:00 - effect a local variable initialized to
250:02 - the value with which the function was
250:04 - called
250:05 - when an array name appears as an
250:07 - argument to a function the location of
250:09 - the beginning of the array is passed
250:12 - elements are not copied the function can
250:15 - alter elements of the array by
250:17 - subscripting from this location
250:19 - the effect is that arrays are always
250:21 - passed by reference
250:23 - in chapter 5 we will discuss the use of
250:26 - pointers to permit functions to affect
250:29 - non-arrays in calling functions
250:32 - a bit of a digression
250:35 - since including array as an argument
250:37 - passes the location or memory address of
250:39 - the array into the function the function
250:41 - cannot can change the items in the array
250:43 - using array subscripts
250:45 - in particular the array contents are not
250:48 - copied when an array is passed into a c
250:50 - function
250:51 - when we get destructs in a future
250:53 - chapter we will find that the content of
250:55 - structs
250:56 - also are passed using the address of the
250:58 - entire struct so structs are passed by
251:00 - reference as well
251:03 - when thinking about past by reference or
251:05 - pass by value remember that a char
251:07 - variable is a single item similar to int
251:09 - and passed by value i.e is copied in c
251:13 - strings are arrays of characters so they
251:16 - are passed by reference
251:18 - python follows this design for the same
251:21 - efficiency reason as c
251:23 - normal single variables like int or
251:25 - float are copied before being passed
251:27 - into a function and therefore passed by
251:30 - value
251:31 - collections like list or dict are passed
251:34 - into functions by reference so the
251:36 - contents can be changed within a
251:38 - function
251:39 - python strings are not technically
251:41 - copied when being passed into a function
251:43 - but the way assignments happen in python
251:46 - make it seem like strings are passed by
251:48 - value
251:49 - since they can never be modified
251:52 - you can learn more with a bit of web
251:54 - research but the easy way is to imagine
251:56 - in python that strings are passed by
251:58 - value with a clever trick to avoid
252:01 - requiring a copy for every function call
252:04 - php follows the same pattern of passing
252:06 - numbers and strings by value and passing
252:08 - arrays as reference
252:10 - php passes strings by value without
252:13 - recover without requiring a copy again
252:16 - using clever runtime code
252:18 - because in java javascript and php
252:21 - strings are objects of course which we
252:24 - haven't discussed much yet
252:26 - those languages can make sure that
252:28 - strings act as if they were passed by
252:30 - value and not passed by reference the
252:32 - way they are always passed in c
252:35 - c made decisions on its run time based
252:37 - on getting the maximum performance out
252:39 - of the hardware of the 1970s at the
252:41 - expense of making it too easy to write
252:44 - code that overwrites memory and leads to
252:46 - corrupted programs that have dangerous
252:48 - and undefined behavior
252:50 - languages like php java and javascript
252:53 - add a small amount of runtime overhead
252:56 - to do things like store the length of an
252:57 - array and make sure we programmers don't
253:01 - over reference the array and overwrite
253:03 - random bits of our program's code or
253:05 - data
253:07 - the creators of c placed more priority
253:09 - on speed and efficient use of memory
253:12 - than safety
253:13 - it is like driving an autom automobile
253:16 - in the rain without abs automatic
253:18 - braking system it is fast but dangerous
253:21 - and should be reserved by highly skilled
253:24 - and very careful programmers
253:26 - and drivers and those drivers should
253:28 - probably be on a race course
253:31 - by the way
253:32 - back to the text
253:34 - by the way there is no entirely
253:36 - satisfactory way to write a portable
253:38 - function that accepts a variable number
253:40 - of arguments because there is no
253:41 - portable way for the called function to
253:43 - determine how many arguments were
253:45 - actually passed in a given call
253:48 - thus you can't write a truly portable
253:50 - function that will compute the maximum
253:52 - of an arbitrary number of arguments as
253:55 - will the max functions that are built in
253:57 - to fortran and pl1
254:00 - it is generally safe to deal with a
254:01 - variable number of arguments if the
254:03 - called function doesn't use an argument
254:05 - that was not actually supplied and if
254:07 - the types are consistent printf the most
254:11 - common c function with a variable number
254:12 - of arguments uses information from the
254:15 - first argument which is the formatting
254:17 - string to determine how many other
254:20 - arguments are present and what their
254:21 - types are it fails badly if the caller
254:24 - does not supply enough arguments or if
254:26 - types are not what the first argument
254:28 - says it is also
254:30 - non-portable and therefore must be
254:32 - modified for different programming
254:34 - environments
254:36 - alternatively if arguments are of known
254:38 - types it is possible to mark the end of
254:40 - the argument list in some agreed-upon
254:42 - way such as a special argument value
254:45 - often zero that stands for the end of
254:47 - the arguments
254:49 - interestingly modern languages like
254:51 - python php and java go to great lengths
254:54 - to make variable length argument lists
254:56 - work predictably and portably the syntax
254:58 - for variable length argument lists in
255:00 - these language can be a bit obtuse at
255:02 - times but at least it's allowed
255:04 - documented reliable
255:06 - and portable
255:08 - section 4 external variables
255:11 - a c program consists of a set of
255:14 - external objects which are either
255:16 - variables or functions the adjective
255:18 - external
255:20 - is used primarily in contrast to
255:22 - internal which describes arguments and
255:24 - automatic variables defined inside
255:26 - functions
255:28 - external variables are defined outside
255:30 - any function and are thus potentially
255:32 - available to many functions
255:35 - functions themselves are always external
255:37 - because c does not allow functions to be
255:39 - defined inside other functions
255:42 - by default external variables are also
255:45 - global so that all references to such a
255:47 - variable by the same name
255:49 - even from functions that are compiled
255:50 - separately are references to the same
255:53 - thing
255:54 - in as this sense external variables are
255:56 - analogous to fortran common or pl1
255:59 - external
256:01 - we will later see how to define external
256:02 - variables and functions that are not
256:04 - globally available but instead only
256:06 - visible within a single source file
256:10 - because external variables are globally
256:12 - accessible they provide an alternative
256:15 - to function arguments and return values
256:17 - for communicating data between function
256:20 - any function may access an external
256:21 - variable by referring it to by name
256:25 - if the name has been declared somehow if
256:28 - a large number of variables must be
256:30 - shared among functions external
256:31 - variables are a more convenient and
256:33 - efficient than long argument lists
256:36 - as pointed out in chapter 1 however this
256:38 - reasoning should be applied with some
256:40 - caution for it can have a bad effect on
256:43 - program structure and lead to programs
256:45 - with many data connections between
256:48 - functions
256:49 - a second
256:50 - reason for using external variables
256:53 - concerns initialization in particular
256:55 - external arrays may be initialized but
256:57 - automatic
256:59 - ie internal arrays may not we will treat
257:01 - initialization near the end of this
257:03 - chapter
257:05 - the third reason for using external
257:07 - variables is their scope and lifetime
257:10 - automatic variables are internal to a
257:12 - function
257:13 - they come into existence
257:15 - when the routine is entered and
257:16 - disappear when it's left
257:18 - external variables on the other hand are
257:20 - permanent they do not come and go so
257:22 - they retain values from one function
257:24 - invocation to the next
257:26 - thus if two functions must share some
257:28 - data yet neither calls the other it is
257:30 - often most convenient if the shared data
257:33 - is kept in external variables rather
257:35 - than passed in and out via arguments
257:39 - let's examine this issue further with a
257:40 - larger example
257:42 - the problem is to write another
257:44 - calculator program better than the
257:46 - previous one
257:47 - this one permits plus minus asterisk and
257:51 - slash
257:52 - and equals
257:54 - equals will print our answer
257:56 - because it is somewhat easier to
257:57 - implement the calculator will you use
257:59 - reverse polish notation instead of in
258:02 - fixed notation
258:04 - reverse polish notation is the scheme
258:06 - used by for example hewlett-packard
258:09 - pocket calculators
258:11 - in reverse polish notation each operator
258:14 - follows its operators
258:16 - operands
258:17 - an infix expression like open
258:19 - parenthesis 1 minus 2 close parentheses
258:22 - c star open parenthesis 4 plus 5
258:25 - close parenthesis equals is entered as
258:28 - 1
258:29 - 2
258:30 - minus
258:31 - 4
258:32 - 5 plus star equals
258:36 - parentheses are not needed in reverse
258:38 - polish notation the implementation is
258:41 - quite simple
258:43 - each operand is pushed onto a stack
258:46 - when an operator arrives the proper
258:48 - number of operands two for binary
258:50 - operators are popped
258:52 - the operator applied to them and the
258:54 - result is pushed back onto the stack
258:56 - in the example above one and two are
258:59 - pushed then replaced by their difference
259:01 - negative one
259:02 - next four and five are pushed then
259:04 - replaced by their sum nine
259:06 - and then the product of negative one and
259:08 - nine which is negative nine replaces
259:10 - them on the stack and then the equal
259:12 - sign operator prints the top element
259:15 - without removing it
259:17 - so intermediate steps in a calculation
259:19 - can be checked
259:21 - the operations of pushing and popping a
259:23 - stack are trivial but by the time error
259:26 - detection and recovery are added they're
259:28 - long enough so it's better to put each
259:30 - in a separate function than to repeat
259:31 - the code throughout the whole program
259:34 - and there should be a separate function
259:35 - for effects fetching the next input
259:37 - operator or operand
259:39 - thus the overall structure of the
259:40 - program is
259:41 - while
259:43 - next operator or operand is not into
259:45 - file if it's a number push it
259:48 - else if it's an operator pop operands do
259:51 - the opera operation and push the result
259:53 - else error
259:55 - the main design decision that has not
259:56 - yet been discussed is where the stack is
259:59 - that is what routines access it directly
260:03 - one possibility is to keep it in main
260:05 - and pass the stack and current stack
260:07 - position to the retrains that push and
260:08 - pop it
260:10 - but maine doesn't need to know about the
260:11 - variables that control the stack it
260:13 - should only think about pushing and
260:15 - popping so we
260:16 - have decided to make the stack and its
260:19 - associated information
260:21 - external variables accessible to push
260:23 - and pop but not to main
260:26 - translating this outline to code is easy
260:28 - enough the main program is primarily a
260:31 - big switch
260:32 - on the type of operator or operand this
260:35 - is a more typical use of switch than the
260:37 - one shown in chapter 3.
260:40 - this sample code is from page 74 of the
260:44 - textbook
260:47 - pound include stdio.h
260:50 - pound define maxop 20 pound defined
260:53 - number quote zero quote
260:56 - this is going to be a single we found a
260:57 - number and pound to find two big quote
260:59 - nine quote a signal that the string is
261:01 - too big
261:04 - main open parenthesis close parenthesis
261:07 - open curly brace
261:09 - int
261:10 - type semicolon
261:12 - char s open square bracket max op close
261:15 - square bracket semicolon
261:17 - double
261:18 - opt 2
261:20 - a to f open parenthesis close
261:21 - parenthesis
261:22 - comma pop open parenthesis close
261:24 - parenthesis comma push open parenthesis
261:27 - close parenthesis semicolon
261:32 - while open parenthesis open parenthesis
261:34 - type equals get up open parenthesis s
261:36 - comma max op
261:38 - close parenthesis close parenthesis not
261:40 - equal e o f close parenthesis
261:44 - switch open parenthesis type close
261:46 - parenthesis open curly brace
261:48 - case number colon
261:51 - note that number is a predefined
261:53 - constant above
261:54 - push open parenthesis a to f open
261:57 - parenthesis s close parenthesis close
261:59 - parenthesis semicolon break
262:02 - case quote plus quote
262:05 - colon
262:06 - push open parenthesis pop open paren
262:09 - close paren plus pop open for n close
262:11 - paren close paren
262:13 - semicolon break semicolon
262:16 - case
262:17 - quote asterisk quote colon
262:20 - push open paren pop open paren close
262:23 - paren
262:24 - asterisk pop open paren close paren
262:28 - close paren semicolon break semicolon
262:30 - that was the multiplication
262:32 - case
262:34 - quote minus quote colon
262:37 - op 2 equals pop open for n close paren
262:41 - push open paren pop minus op2
262:45 - close print semicolon
262:47 - break semicolon that was subtraction
262:50 - case open print slash close paren
262:54 - colon op 2 equals pop open paren
262:58 - semicolon if up to
263:02 - not equal 0.0 push open print
263:06 - pop open paren close print slash opt2
263:10 - close paren semicolon else
263:12 - printf double quote zero divisor popped
263:16 - backslash n double quote
263:18 - close paren semicolon break
263:22 - case quote equal
263:25 - quote colon printf open paren double
263:28 - quote backslash t percent f backslash n
263:32 - double quote comma
263:33 - push open paren pop open friend close
263:36 - paren close paren close friend semicolon
263:39 - so to print it we pop it and
263:42 - push it and then print the residual
263:44 - value of the push function
263:46 - the next line is break semicolon
263:49 - case
263:50 - quote c quote colon
263:52 - clear open paren close print
263:54 - semicolon break semicolon
263:57 - case too big
263:59 - colon
264:00 - print f
264:02 - double quote percent dot 20 s
264:06 - space dot dot dot is too long backslash
264:08 - n double quote comma s close paren
264:11 - semicolon break semicolon
264:14 - default colon
264:15 - print f
264:17 - open paren double quote unknown command
264:19 - percent c backslash n
264:21 - double quote comma type open print close
264:24 - print semicolon break semicolon close
264:27 - paren close curly brace to finish the
264:29 - switch statement and then close
264:31 - curly brace to finish
264:34 - the main
264:36 - so now we're going to have a separate
264:38 - file that has some of these functions
264:39 - defined
264:41 - this file is on page 75 of the textbook
264:47 - this file will be compiled separately
264:49 - but then later linked all together with
264:51 - the main program but we're going to
264:52 - define
264:54 - push
264:54 - pop and clear in this file
264:58 - pound include
264:59 - stdio.h pawn define maxval 100
265:04 - maximum value that would be the maximum
265:06 - value of our stack the maximum size of
265:08 - our stack maximum depth of our stack
265:10 - now we are declaring variables outside
265:13 - of any function these are the external
265:15 - variables
265:16 - int sp equals zero
265:19 - double val open square bracket max val
265:22 - close square bracket semicolon
265:25 - and so those variables are external
265:27 - variables and they're outside of all of
265:29 - the functions but we can use them in any
265:31 - function and there's just one copy no
265:33 - matter what function we're using it so
265:34 - now we define our functions
265:37 - double push open paren f close paren
265:41 - double f semicolon open curly brace if
265:44 - open paren sp
265:47 - less than max val close paren return
265:49 - open paren val open square bracket sp
265:52 - plus plus close square bracket equals f
265:56 - close paren semicolon
265:58 - else
265:59 - open curly brace
266:01 - printf double quote air colon stack full
266:04 - backslash n double quote closed paren
266:06 - semicolon
266:08 - clear open paren close print semicolon
266:11 - return open print zero close paren
266:13 - semicolon close curly brace
266:16 - to finish the else and then close curly
266:19 - brace to finish the double function the
266:21 - push function
266:24 - and now we define the pop
266:26 - double pop open print close paren open
266:30 - curly brace if open paren sp greater
266:32 - than zero close paren return open paren
266:36 - val open square bracket minus minus sp
266:40 - close square bracket close curly brace
266:42 - semicolon else open curly brace printf
266:48 - open paren double quote error colon
266:50 - stack empty backslash n close quote
266:54 - close double quote
266:55 - close paren semicolon clear open paren
266:58 - close paren semicolon return open print
267:01 - zero close paren semicolon close curly
267:04 - brace to finish the else and then close
267:06 - curly brace to finish the double
267:09 - and the last function we're going to
267:10 - define is the clear function
267:12 - which is quite simple clear open paren
267:14 - close paren open curly brace sp equals
267:17 - zero semicolon
267:20 - close paren
267:21 - i would note that
267:23 - just read this one carefully
267:25 - they're very good at using side effect
267:28 - operators and side effect assignments
267:30 - and to keep this code very simple and
267:32 - succinct
267:34 - and you really have to understand a lot
267:36 - of the other stuff that you've
267:37 - covered in the book up to this point
267:40 - back to the text
267:42 - the command c clears the stack with the
267:44 - function clear which can also be used by
267:47 - push and pop in case of error we'll
267:49 - return to get op in a moment
267:52 - as discussed in chapter one a variable
267:54 - is external if it is desi defined
267:57 - outside the body of any function
268:00 - thus the stack and stack pointer which
268:02 - must be shared by push pop and clear are
268:05 - defined outside the three functions but
268:08 - if main itself does not refer to the
268:10 - stack or stack pointer their
268:11 - representation is carefully hidden
268:14 - thus the code for the equal operator
268:16 - must use
268:18 - push
268:19 - open print pop parentheses parentheses
268:21 - close parenthesis close parenthesis
268:23 - semicolon to examine the top of the
268:25 - stack without disturbing it notice also
268:27 - that because plus and multiplication are
268:30 - commutative operators the order in which
268:32 - the popped operands are combined is
268:33 - irrelevant but for the minus and slash
268:35 - operators the left and right operands
268:37 - must be distinguished
268:40 - this example code above shows why it's
268:42 - important to remember the k and r c
268:45 - arrange rearrangement license as it
268:47 - applies to operators that are
268:48 - associative and commutative
268:50 - if the code for the minus operator were
268:52 - written written push open paren pop open
268:55 - print close print minus pop open print
268:58 - close paren
268:59 - close print semicolon there is no
269:02 - guarantee that the left pop will run
269:05 - before the right pop
269:07 - and since these functions access global
269:09 - variables and have side effects
269:11 - it is important to force the compiler
269:14 - not to rearrange the order of the
269:15 - function calls to force the evaluation
269:17 - order the code is broken into two
269:19 - statements op2 equals pop open print
269:22 - close print semicolon push open open
269:25 - paren
269:26 - pop open paren close paren minus op2
269:29 - close paren semicolon now you might
269:31 - think that the lesson here is that the k
269:33 - rc arrangement license which was done to
269:36 - allow optimization and performance is a
269:38 - bad idea
269:40 - but the more important lesson is that
269:41 - writing low level utility functions like
269:44 - push and pop that use global variables
269:46 - and have side effects is a dangerous
269:49 - pattern in any programming language
269:52 - section 4.5
269:54 - scope rules
269:55 - the functions and external variables
269:57 - that make up a c program need not all be
270:00 - compiled at the same time the source
270:02 - text of the program may be kept in
270:04 - several files and previously compiled
270:06 - routines may be loaded from libraries
270:09 - the two questions of interest are
270:11 - how are declarations written so that
270:13 - variables are properly declared during
270:15 - compilation and how our declarations set
270:19 - up so that all the pieces will be
270:21 - properly linked or connected when the
270:23 - program is loaded
270:25 - the scope of a name is the part of the
270:28 - program over which the name is defined
270:31 - for an automatic variable
270:33 - declared at the beginning of a function
270:35 - the scope is the function in which the
270:36 - name is declared and variables of the
270:39 - same name in different functions are
270:41 - unrelated
270:42 - the same is true of the arguments of the
270:44 - function
270:46 - the scope of an external variable lasts
270:48 - from the point at which is it is
270:50 - declared in a source file to the end of
270:52 - that file
270:54 - for example if val sp push pop and clear
270:58 - are defined in one file in the order
271:00 - shown above that is intsp equals zero
271:04 - double val open square bracket maxval
271:06 - close square bracket semicolon
271:08 - double push open print f close paren
271:11 - open curly brace dot dot close curly
271:13 - brace double pop open print close paren
271:16 - open curly brace dot dot dot close curly
271:18 - brace clear open paren close paren open
271:21 - curly brace dot dot dot close
271:23 - curly brace then the variables val and s
271:26 - p may be used in push pop and clear
271:29 - simply by naming them and no further
271:31 - declarations are needed
271:33 - on the other hand
271:35 - if an external variable is to be
271:37 - referenced before it is defined or it is
271:39 - defined in a different source file from
271:41 - the one in which it's being used then an
271:43 - extern declaration is mandatory
271:46 - it is very important to distinguish
271:48 - between the declaration of an external
271:51 - variable and its definition
271:53 - a declaration announces the property of
271:55 - the variable its type its size etc
271:59 - a definition also causes storage to be
272:02 - allocated
272:03 - if the lines int
272:05 - sp semicolon
272:07 - double val open square bracket maxval
272:10 - close square bracket semicolon appear
272:12 - outside any function they define the
272:15 - external variables sp and val
272:17 - and cause the storage to be allocated
272:20 - and also serve as the declaration
272:22 - for the rest of that source file
272:25 - on the other hand the lines extern int
272:28 - sp
272:29 - extern double val open square bracket
272:32 - close score bracket semicolon
272:34 - declare for the rest of the source file
272:36 - that sp is an int and val is a double
272:39 - array whose size is determined and
272:41 - allocated elsewhere
272:43 - but they do not create variables or
272:45 - allocate storage for them there must be
272:49 - only one definition of an external
272:52 - variable among all the files that make
272:54 - up the source program
272:55 - other files may contain extern
272:57 - declarations to access it
273:00 - there may also be an extern declaration
273:02 - in the file containing the definition
273:05 - any initialization of an external
273:08 - variable goes only with the definition
273:11 - array sizes must be specified with the
273:14 - definition but are optional with the
273:17 - extern declaration
273:19 - although it is not a likely organization
273:22 - for this program
273:23 - val and sp could be defined and
273:26 - initialized in one file and the
273:28 - functions push pop and clear defined in
273:31 - another
273:33 - then these definitions and declarations
273:35 - would be necessary to tie them together
273:38 - in file 1 we would see int sp 0
273:42 - semicolon double val open square bracket
273:45 - max val close square bracket semicolon
273:48 - and then in file 2
273:50 - x turn in sp semicolon x turn double val
273:54 - open square bracket close square bracket
273:56 - semicolon
273:57 - double push open print f close paren
274:00 - open curly brace dot dot close curly
274:02 - brace
274:03 - double pop open frame close paren
274:06 - open curly brace dot dot dot close curly
274:08 - brace
274:10 - clear open friend close paren open curly
274:13 - brace dot dot dot close curly brace
274:15 - because the x turned declarations in
274:18 - file two lie ahead and outside the three
274:20 - functions they apply to all
274:23 - one set of declarations suffices for all
274:26 - of file 2.
274:29 - for larger programs the pound include
274:32 - file inclusion facility discussed later
274:34 - in this chapter allows one to keep only
274:37 - a single copy of the extern declarations
274:40 - for the program and have that inserted
274:42 - in each source file it's as it's being
274:45 - compiled
274:46 - let us now turn to the implementation of
274:48 - getup the function that
274:51 - fetches the next operator or operand the
274:54 - basic task is easy
274:56 - skip blanks
274:57 - tabs and new lines if the character is
275:00 - not a digit or a decimal point return it
275:03 - otherwise collect a string of digits
275:05 - that might include a decimal point and
275:07 - return number a single signal that a
275:11 - number has been collected
275:15 - the routine is substantially complicated
275:17 - by an attempt to handle the situation
275:19 - properly when the input number is too
275:20 - long
275:22 - get up reads digits perhaps with an
275:25 - intervening decimal point until it
275:27 - doesn't see anymore but only stores the
275:29 - ones that fit
275:30 - if there was no overflow it returns
275:33 - number in the string of digits
275:35 - if the number was too long however getup
275:37 - discards the rest of the input line so
275:39 - the user can simply retype the line from
275:41 - the point of error it returns too big as
275:44 - the overflow signal
275:50 - this example code
275:52 - is from page 78
275:54 - of the textbook and you can view it at
275:57 - www.cc4e.com
276:01 - code
276:03 - page 78
276:05 - get up
276:06 - open friend s comma lim close paren char
276:10 - s open square bracket close square back
276:12 - at semicolon
276:13 - int lim semicolon open curly brace
276:17 - int i comma c semicolon
276:20 - while open paren open paren c equals get
276:23 - ch open paren close paren close paren
276:26 - double equals quote space quote or
276:29 - c double equals quote backslash t quote
276:32 - or c double equals quote backslash end
276:35 - quote close paren semicolon
276:38 - skip all the blanks
276:41 - if c is not equal
276:44 - quote dot quote and
276:47 - open paren c less than quote zero quote
276:50 - vertical bar vertical bar c greater than
276:53 - quote nine quote close paren close paren
276:55 - return s return open paren c close paren
276:59 - s sub zero equals c
277:01 - four paren i equals one semicolon open
277:04 - paren c equals get chart open paren
277:07 - close paren close print greater than or
277:09 - equal to quote zero quote and c less
277:12 - than or equal to quote nine quote
277:14 - semicolon i plus plus
277:17 - inside the for loop
277:19 - if i less than limb
277:22 - s sub i equals c
277:24 - if open for n c double equals quote dot
277:27 - quote
277:29 - close paren open curly brace we begin to
277:31 - collect the fraction
277:33 - if
277:34 - open print i
277:35 - less than limb
277:37 - close paren s sub i equals c
277:41 - four open paren i plus plus
277:45 - c equals get char open paren close paren
277:47 - close paren greater than or equal to
277:49 - quote zero quote
277:51 - ampersand ampersand c less than or equal
277:53 - to quote nine quote
277:55 - semicolon i plus plus closed paren
277:58 - if open prime i less than limb close
278:01 - paren s sub i equals c
278:04 - close curly brace to close the if
278:06 - statement where we're collecting the
278:07 - fraction
278:09 - if open paren i less than limb close
278:12 - paren open curly brace
278:15 - this means the number is good
278:17 - ungetch is ch open friends c close paren
278:21 - semicolon
278:22 - s sub i equals quote backslash zero
278:25 - quote semicolon
278:27 - return
278:28 - open paren number close print and recall
278:30 - that number is a predefined constant
278:33 - close curly brace else open curly brace
278:37 - if it's too big we're going to skip to
278:39 - the end of the line
278:40 - while open paren c not equal
278:43 - quote backslash end quote and c not
278:47 - equal eof open paren
278:49 - c equals get char open for enclosed
278:52 - paren semicolon
278:53 - s sublim minus one equals quote
278:56 - backslash zero quote semicolon
278:58 - return too big semicolon close curly
279:02 - brace to finish the if and then close
279:04 - curly brace to finish the function
279:06 - recall that too big is a
279:08 - constant that indicates that we've read
279:10 - too much
279:12 - back to the text
279:14 - what are get ch and unget ch well it is
279:17 - often the case that a programming
279:19 - reading input cannot determine that is
279:21 - read enough until it is read too much
279:23 - one instance is collecting characters
279:25 - that make up a number
279:27 - until the first non-digit is seen the
279:29 - number is not complete but then the
279:31 - program has read one character too far
279:34 - and that is a character it is not
279:36 - prepared for
279:37 - the problem would be solved if it were
279:39 - possible to unread the unwanted
279:40 - character then every time the program
279:42 - reads one character too many it could
279:44 - push it back on the input so that the
279:46 - rest of the code would behave as if it
279:48 - never been read
279:50 - fortunately it is easy to simulate
279:52 - ungetting a character by writing a pair
279:54 - of cooperating functions getch delivers
279:57 - the next input character to be
279:59 - considered
280:00 - ungetch puts the character back on the
280:02 - input so the next call to get ch will
280:04 - return it again
280:06 - how they work together is simple
280:09 - unget ch puts puts the pushed back
280:11 - characters into a shared buffer a
280:13 - character array gets the ch reads from
280:15 - the buffer is there's anything there and
280:17 - then it calls get char if the buffer is
280:19 - empty
280:20 - there must be an index variable which
280:21 - records the position of the current
280:23 - character in the buffer
280:25 - since the buffer and index are shared by
280:27 - get ch and unget ch and must retain
280:29 - their values between calls they must be
280:32 - external to both routines
280:34 - thus we can write getch and ungetch and
280:37 - their shared variables as follows
280:40 - this is on page 79 of the textbook you
280:43 - can see the code at www.cc4e.com
280:47 - code and go to page 79
280:50 - pound include
280:51 - stdio.h
280:53 - found to find buff size 100
280:56 - char buff open square bracket buff size
280:58 - close square bracket semicolon
281:00 - int buff p equals zero semicolon those
281:04 - are the external variables outside any
281:05 - function
281:08 - here's the first function get ch open
281:10 - friend close paren open curly brace
281:13 - return open parenthesis open parenthesis
281:16 - buff p greater than zero close
281:18 - parenthesis question mark
281:20 - buff
281:22 - open square bracket minus minus buff p
281:24 - close square bracket colon
281:27 - get char open paren close paren close
281:29 - paren semicolon close curly brace to
281:31 - finish the get ch function
281:34 - the unget ch function pushes a character
281:36 - back on input
281:39 - ch open paren c close paren into c
281:42 - semicolon
281:43 - open curly brace
281:45 - if open paren buff p greater than buff
281:48 - size printf
281:49 - open prin double quote unget ch colon
281:53 - too many characters backslash n double
281:56 - quote
281:56 - close paren semicolon else
281:59 - buff
282:00 - open square bracket buff p plus plus
282:03 - close square bracket equals c semicolon
282:06 - and then close curly brace to finish the
282:08 - ungetch function
282:11 - we have used an array for pushback
282:12 - rather than a single character since the
282:14 - generality may come in handy later
282:18 - section 4.6 static variables static
282:22 - variables are a third class of storage
282:25 - in addition to the x turn and automatic
282:28 - that we've already met
282:30 - static variables may either be internal
282:33 - or external
282:34 - internal static variables are local to a
282:36 - particular function just like automatic
282:38 - variables are but unlike automatics they
282:41 - remain in existence rather than coming
282:44 - and going each time the function's
282:45 - activated
282:46 - this means that internal static
282:48 - variables provide private permanent
282:51 - storage in a function
282:52 - character strings that appear within a
282:54 - function such as the arguments of printf
282:57 - are internal static
282:59 - an external static
283:01 - variable is known within the remainder
283:03 - of the source file in which it's
283:05 - declared but not in any other file
283:08 - external static thus provides a way to
283:10 - hide names like buff and buff p in the
283:13 - get ch unget ch combination
283:16 - which must be external so they can be
283:18 - shared
283:19 - yet which should not be visible to users
283:21 - of get ch and unguess ch so there's no
283:23 - possibility of conflict if the two
283:26 - routines are compiled in one file as in
283:29 - static char buff open square bracket
283:32 - buff size close square bracket semicolon
283:35 - static int buff p equals zero semicolon
283:39 - get ch open frame close paren open curly
283:42 - brace dot dot close curly brace unget ch
283:45 - open paren c close paren open curly
283:47 - brace dot dot dot close curly brace then
283:49 - no other routine will be able to access
283:52 - buff and buff p
283:54 - in fact
283:55 - they will not conflict with the same
283:57 - names in other files of the same program
284:01 - static storage whether internal or
284:03 - external is specified by prefixing the
284:07 - normal declaration with the word static
284:09 - the variable is external if it's defined
284:12 - outside of any function and internal if
284:14 - defined inside a function
284:16 - normally functions are external objects
284:19 - their names are known globally
284:21 - it is possible for a function however to
284:23 - be declared static
284:25 - this makes its name unknown outside the
284:28 - file in which it's declared
284:31 - in c
284:32 - static
284:33 - connotates
284:35 - not only
284:36 - permanence but also a degree of what
284:39 - might be called
284:40 - privacy internal static objects are
284:44 - known only inside one function
284:46 - external static objects variables or
284:49 - function are are known only within the
284:51 - source file in which they appear their
284:54 - names do not interfere with variables or
284:57 - functions
284:58 - of the same name in other files
285:01 - external static variables and functions
285:04 - provide a way to conceal data objects
285:07 - and any internal routines that
285:09 - manipulate them so that other routines
285:11 - and data cannot conflict even
285:13 - inadvertently
285:15 - for example getch and ungetch form a
285:18 - module for character input and pushback
285:21 - buff and buff p should be static so
285:23 - they're inaccessible from the outside
285:26 - in the same way push pop and clear form
285:29 - a module for stack manipulations
285:32 - val and sp should also be external
285:35 - static
285:37 - 4.7
285:38 - register variables
285:40 - the fourth and final storage class is
285:42 - called register
285:44 - a registered declaration advises the
285:46 - compiler that the variable in question
285:48 - will be heavily used when possible
285:51 - register variables are placed in machine
285:53 - registers
285:54 - which may result in smaller and faster
285:57 - programs
285:58 - the register declaration looks like
286:00 - register int x
286:03 - semicolon
286:04 - register char c semicolon and so on the
286:08 - in part may be omitted register can only
286:10 - be applied to automatic variables and
286:12 - the formal parameters of a function
286:14 - in this latter case the function
286:16 - declaration looks like
286:18 - f open paren c comma n close paren
286:22 - register int c comma n semicolon open
286:25 - curly brace register int i semicolon and
286:28 - then dot dot
286:29 - close curly brace
286:32 - in practice there are some restrictions
286:34 - on register variables reflecting the
286:36 - realities of the underlying hardware
286:39 - only a few variables in each function
286:41 - may be kept in registers and only
286:42 - certain types are allowed
286:44 - the word register is ignored for excess
286:47 - or disallowed declarations
286:49 - and it is not possible to take the
286:51 - address of a register variable a topic
286:53 - that will be covered in chapter 5. the
286:55 - specific restrictions vary from machine
286:58 - to machine
286:59 - as an example on the pdp-11
287:02 - only the first three registered
287:03 - declarations in a function are
287:06 - effective and the types must be int char
287:09 - or pointer
287:12 - as a quick aside the description of the
287:14 - details of the implementation of the
287:16 - register modder modifier on the pdp-11
287:18 - is a delightful peek into how the c
287:22 - compiler generated runtime code on that
287:24 - particular system in the 1970s
287:27 - as compilers have become more
287:28 - sophisticated the compiler could decide
287:31 - which variables to keep in registers far
287:33 - better than the programmer could
287:35 - and since
287:37 - how variables would be allocated to
287:38 - registers might be different on
287:40 - different hardware architectures the
287:42 - register indication is generally ignored
287:43 - by modern c compilers so you should
287:46 - probably never use it in your code
287:48 - as a matter of fact
287:49 - i wrote the following sample c program
287:52 - and compiled it with the minus capital s
287:54 - option so i could see the generated
287:56 - assembly language with and without the
287:58 - register declaration
288:00 - with optimization there was no
288:02 - difference between the code generated
288:04 - with or without the registered
288:05 - declaration
288:07 - the reason the generated assembly code
288:09 - was identical once you take a look at it
288:11 - was regardless of the use the register
288:13 - keyboard was that the c optimizer on my
288:16 - arm based computer in 2022 realized the
288:19 - best way to implement the code was to
288:20 - keep both of the variables in registers
288:23 - because the loop code was so simple and
288:25 - the cpu in my computer has plenty of
288:27 - registers and optimized any loading and
288:29 - storing of the data for these variables
288:32 - right out of the program
288:34 - in 1978 the authors likely included the
288:38 - register function as a feature to
288:40 - convince the experienced assembly
288:43 - language programmers that they should
288:45 - write all but the lowest lowest level
288:48 - code in c
288:50 - so write a little tiny bit in c and then
288:52 - i mean write a little tiny bit in
288:54 - assembly language and write everything
288:56 - else in c
288:57 - so here's an example that's not in the
288:59 - textbook it's on page 81 if it were in
289:02 - the textbook you can see this code at
289:05 - www.cc4ed
289:08 - code page 81
289:11 - and this is code that i wrote to play
289:13 - with the register keyword to mostly
289:16 - convince myself it was pointless to use
289:18 - it but here we go
289:20 - pound include stdio dot h
289:23 - int
289:24 - main open prime close print open curly
289:27 - brace
289:28 - int compute semicolon
289:30 - register end enter
289:33 - semicolon scanf open for n double quote
289:36 - percent d
289:38 - close quote comma ampersand compute
289:41 - close parenthesis semicolon
289:43 - printf open parenthesis double quote
289:45 - compute space percent d backslash n
289:48 - double quote comma compute close
289:50 - parenthesis semicolon
289:52 - four
289:53 - open print iter equals zero semicolon
289:56 - enter less than one thousand semicolon
289:58 - iter plus plus close parenthesis open
290:01 - curly brace compute equals open
290:03 - parenthesis compute times 22 close
290:05 - parenthesis times seven
290:08 - if compute
290:09 - greater than one thousand compute equals
290:12 - compute modulo one thousand
290:15 - close curly brace printf
290:18 - open paren double quote compute space
290:20 - percent d backslash n close quote comma
290:24 - compute
290:25 - semicolon close curly brace now some of
290:27 - these i wrote this code in a way
290:30 - that
290:31 - tries to convince the
290:33 - uh the the optimizer that i'm actually
290:35 - going to use these values that's why i
290:37 - read the value from input as compared to
290:40 - a constant it would actually optim the
290:41 - optimizer so so so smart that it would
290:43 - just eliminate all the constant
290:45 - calculations so
290:47 - but that's my sample
290:49 - playing with register
290:52 - section 4.8 block structure
290:55 - c is not a block structured language in
290:58 - the sense of pl1 or algol in that
291:01 - functions may not be defined within
291:02 - other functions
291:04 - on the other hand variables can be
291:06 - defined in a block structured fashion
291:08 - declarations of variables including
291:10 - initializations may follow the left
291:12 - brace that introduces any compound
291:15 - statement
291:16 - not just the one that begins a function
291:18 - variables declared this this way
291:21 - supersede any identically named
291:23 - variables in outer blocks and remain in
291:26 - existence until the matching right race
291:29 - for example
291:31 - if open parentheses n greater than zero
291:33 - close parenthesis open curly brace int i
291:36 - semicolon
291:37 - declare a new i
291:39 - four open parenthesis i equals 0
291:42 - semicolon i less than n semicolon i plus
291:45 - plus
291:46 - close parenthesis and dot dot the rest
291:48 - of the for loop and then a closed curly
291:50 - brace for the if
291:51 - the scope of the variable i
291:54 - is in the true branch of the if this i
291:57 - is unrelated to any other i in the
292:00 - program
292:01 - block structure also applies to external
292:03 - variables given the declarations
292:06 - int x semicolon f open parenthesis
292:10 - closed parenthesis open curly brace
292:12 - double x
292:13 - semicolon dot dot dot close parenthesis
292:17 - then within the function f occurrences
292:19 - of x refer to the internal double
292:22 - variable outside of f they refer to the
292:25 - external integer this is
292:28 - same is true of the names of formal
292:30 - parameters
292:32 - for example
292:34 - in z semicolon outside of any function
292:37 - f open parenthesis z close parenthesis
292:40 - double z semicolon open curly brace dot
292:43 - dot close curly brace within function f
292:47 - z
292:48 - refers to the formal parameter not the
292:50 - external variable
292:52 - section 4.9 initialization
292:55 - initialization has been mentioned in
292:57 - passing many times so far but always
293:00 - peripherally to some other topic this
293:02 - section summarized some of the rules now
293:05 - that we have discussed the various
293:06 - storage classes
293:08 - in absence of explicit initialization
293:10 - external and static variables are
293:12 - guaranteed to be initialized to zero
293:15 - automatic and register variables have
293:17 - undefined or garbage values
293:20 - simple variables not arrays or
293:22 - structures may be initialized when they
293:24 - are declared by following the name with
293:27 - an equal sign and a constant expression
293:30 - int x equals one semicolon jar s quote
293:34 - equals single quote backslash single
293:37 - quote single quote semicolon
293:40 - a constant of a single character that is
293:42 - a single quote itself
293:45 - long day equals 60 times 24 semicolon
293:49 - which is the minutes in a day
293:51 - for external and static variables the
293:53 - initialization is done once conceptually
293:56 - at compile time for automatic and
293:58 - register variables it is done each time
294:00 - the function or block is entered
294:02 - for automatic and register variables the
294:04 - initializer is not restricted to being a
294:06 - constant it may in fact be any valid
294:10 - expression involving previously defined
294:12 - values
294:13 - even function calls
294:15 - for example the initializations of the
294:17 - binary search program that we wrote in
294:20 - chapter 3 could be written as
294:22 - binary open parenthesis x comma
294:25 - v comma n close parenthesis int
294:29 - x comma v open square bracket close
294:32 - square bracket comma n semicolon
294:35 - open curly brace
294:37 - int low equals zero semicolon and high
294:40 - equals n minus one semicolon and in mid
294:43 - followed by the rest of the function and
294:45 - then close curly brace
294:47 - instead of
294:51 - initializing these as the first
294:52 - executable statements and we would do
294:54 - this with binary open paren x comma v
294:58 - comma n close paren int x comma v open
295:02 - square bracket close square bracket
295:04 - comma n semicolon
295:06 - open curly brace
295:08 - int low comma mid comma high
295:11 - semicolon low equals 0 semicolon high
295:15 - equals n minus 1 semicolon and so forth
295:19 - in effect initializations of automatic
295:21 - variables are just shorthand for
295:23 - assignment statements
295:25 - which form to prefer is largely a matter
295:27 - of taste we have generally used explicit
295:30 - assignments because initializers and
295:32 - declarations are harder to see
295:35 - automatic arrays may not be initialized
295:37 - external and static arrays may be
295:39 - initialized by following the declaration
295:42 - with a list of initializers enclosed in
295:45 - braces and separated by commas
295:47 - for example the character counting
295:50 - program of chapter 1 which originally
295:52 - was
295:53 - main open parentheses closed princely
295:56 - open curly brace
295:57 - int c comma i comma n white comma n
296:01 - other
296:02 - int n digit open square bracket 10 close
296:05 - square bracket semicolon
296:07 - n white equals n other equals zero
296:12 - four open parenthesis i equals zero
296:14 - semicolon i less than ten semicolon i
296:17 - plus plus closed parenthesis
296:19 - and digit sub i equals 0 and then the
296:22 - rest of the code
296:23 - followed by a closed curly brace
296:25 - finishing main
296:28 - this could be written instead using
296:30 - initializers as follows int and white
296:33 - equals 0 semicolon int and other equals
296:36 - zero semicolon int n digit open square
296:39 - bracket 10 close square bracket equals
296:41 - open curly brace
296:43 - zero com zero comma zero comma zero
296:46 - comma zero comma zero comma zero comma
296:48 - zero comma zero comma zero
296:51 - close curly brace
296:53 - ten zeros in a row and
296:55 - separated by commas and in braces
297:00 - and then the main code is simply main
297:02 - open paren close paren open curly brace
297:05 - in comma c comma i and then the rest of
297:07 - the main code close curly brace the idea
297:09 - is is that with the initializers and
297:11 - with the external variables outside of
297:13 - the main function you do not need to
297:15 - initialize them even with a for loop in
297:18 - the beginning of the main program
297:20 - these initializations are actually all
297:23 - unnecessary since they're all zero
297:25 - anyways but it's a good form to make
297:27 - them explicit anyway
297:28 - if there are fewer initializers than the
297:30 - specialized size the others will be zero
297:33 - it is an error to have too many
297:35 - initializers
297:37 - regrettably there is no way to
297:39 - specify the repetition of an initializer
297:41 - nor to initialize an element in the
297:43 - middle of the ray without supplying all
297:45 - the intermeaning intervening values as
297:47 - well
297:49 - character arrays are a special case of
297:51 - initialization
297:53 - a string may be used instead of the
297:55 - braces in commas notation
297:58 - as in
297:59 - char
298:00 - pattern open square bracket close square
298:02 - bracket equals double quote th e double
298:05 - quote semicolon
298:07 - this is a shorthand for the longer but
298:10 - equivalent char pattern open square
298:12 - bracket close square bracket equals open
298:15 - curly brace single quote t single quote
298:18 - comma single quote h single quote comma
298:22 - single quote e single quote comma single
298:24 - quote backslash zero single quote close
298:27 - curly brace semicolon
298:30 - when the size of an array of any type is
298:33 - omitted the compiler will compute the
298:35 - length of the array by counting the
298:37 - initial
298:38 - initializers in this specific case
298:41 - the size of pattern is four
298:43 - three actual characters plus the
298:45 - terminating backslash zero
298:49 - i would note that the primary difference
298:51 - between c and c influence like languages
298:54 - like java php and javascript this key is
298:58 - that c
298:59 - strings are character arrays while in
299:01 - the other languages strings are objects
299:04 - these string objects do have inside
299:07 - themselves an array of bytes or
299:09 - characters but they also keep track of
299:11 - things like the length of the string and
299:13 - provide functionality like extract a
299:16 - substring in the methods in these
299:17 - objects
299:19 - in c
299:20 - there is a set of library functions that
299:21 - perform string operations like compare
299:23 - two strings
299:25 - while cut string comparison is built
299:26 - into the string objects in each of the
299:28 - other languages
299:30 - strings as character arrays allow
299:32 - programmers to build very fast low-level
299:35 - code in libraries and operating systems
299:38 - but to write the code well you need to
299:39 - understand what is really going on at
299:42 - the low level
299:44 - section 4.10 recursion
299:47 - c functions may be used recursively that
299:50 - is a function may call itself either
299:52 - directly or indirectly
299:55 - one traditional example involves
299:57 - printing of a number as a character
299:58 - string as we mentioned before
300:00 - the digits are generated in the wrong
300:02 - order
300:04 - low order digits are available before
300:06 - four high order digits but they have to
300:08 - be printed in the other way around
300:11 - there are two solutions to this problem
300:13 - one is to store the digits in an array
300:15 - as they are generated and then print
300:17 - them in reverse order as we did in
300:18 - chapter 3 with eye to a
300:21 - the first version of print d follows
300:23 - this pattern
300:24 - this is sample code on page 85 of the
300:27 - textbook you can view the sample code at
300:33 - com www.cc4e.com code page 85 example
300:36 - one
300:38 - pound include stdo dot h
300:41 - print d open paren and close paren
300:44 - in
300:46 - open curly brace char
300:48 - s open square bracket 10 close square
300:51 - bracket semicolon and i semicolon
300:55 - if parenthesis n less than 0 parenthesis
300:58 - open curly brace put char
301:01 - open prin single quote dash
301:03 - single quote close paren semicolon
301:06 - n equals minus n semicolon close curly
301:09 - brace
301:11 - i equals zero
301:13 - semicolon
301:14 - do open curly brace
301:16 - s sub i plus plus
301:19 - equals n modulo 10 plus quote zero quote
301:24 - which gets the next character while
301:27 - parentheses parenthesis
301:30 - equal 10 close parenthesis greater than
301:32 - zero
301:34 - close parenthesis semicolon
301:37 - then we reverse the string while open
301:39 - print minus minus i greater than equal
301:41 - to zero close paren put char open paren
301:45 - s sub i
301:46 - close paren semicolon close curly brace
301:49 - to end the print d function
301:53 - the alternative is a recursive solution
301:56 - in which each call of print d first its
301:58 - calls itself to cope with any leading
302:00 - digits then prints the trailing digit
302:03 - after that call returns
302:05 - this is an example on page 85 of the
302:08 - textbook in its example
302:11 - pound include
302:13 - stdio.h print d open paren n close paren
302:18 - int n semicolon open curly brace
302:22 - int i semicolon if open friend n less
302:26 - than zero close paren open curly brace
302:29 - put chair
302:30 - open paren single quote dash single
302:32 - quote close paren semicolon
302:36 - n equals minus n semicolon close curly
302:39 - brace to finish the if
302:42 - if
302:43 - open paren open print i equals n over 10
302:47 - close print not equal 0
302:51 - close print
302:52 - print d
302:53 - open print i closed paren semicolon
302:55 - that's the recursive call
302:57 - and after the recursive call comes back
302:59 - we do put char open paren
303:01 - n modulo 10 plus
303:04 - single quote 0 single quote close paren
303:06 - semicolon close curly brace to end the
303:08 - print d function
303:11 - when a function calls itself recursively
303:13 - each invocation gets a fresh set of all
303:16 - the automatic variables quite
303:17 - independent of the previous set
303:20 - thus in print d 123
303:23 - the first print d has n equals 123.
303:27 - it passes 12 to a second print e
303:29 - then prints three when that one returns
303:31 - in the same way the second print d
303:33 - passes one to a third which prints it
303:36 - and then prints 2.
303:38 - recursion generally provides no saving
303:40 - in storage since somewhere a stack of
303:42 - values is being processed or has to be
303:44 - maintained nor will it be faster but
303:47 - recursive code is more compact and often
303:50 - much easier to write and understand
303:52 - recursion is especially convenient for
303:55 - recursively defined data structures like
303:57 - trees we will see a nice example in
303:59 - chapter 6.
304:02 - as an aside ah recursion recursion
304:06 - recursion
304:07 - recursion is a beloved concept in
304:10 - computer science
304:11 - it is often taught early in most
304:13 - programming courses because it is just
304:15 - so cool
304:17 - most examples are sadly like computing
304:20 - factorial or the example above
304:22 - converting an integer to a string and
304:24 - they're not good uses a recursion
304:26 - actually
304:27 - but when you do finally find yourself in
304:29 - need of traversing a tree-based
304:31 - structure like an xml document or
304:33 - parsing a mathematical expression with
304:35 - parentheses recursion is the ideal
304:38 - solution so the problem in a sense is
304:40 - not recursion but when it is taught and
304:43 - what examples are used
304:46 - interestingly kernighan and ritchie
304:48 - include the correct warning about using
304:51 - recursion when it is not
304:54 - the best solution in the above text
304:56 - and it bears another read
304:59 - back to the book
305:02 - recursion generally provides no saving
305:05 - in storage since somewhere a stack of
305:07 - values is being processed or has to be
305:09 - maintained nor will it be faster
305:11 - but recursive code is more compact and
305:14 - often much easier to write and
305:16 - understand
305:17 - recursion is especially convenient for
305:19 - recursively defined data structures
305:21 - like trees we will see a nice example in
305:24 - chapter 6.
305:27 - i couldn't have said it better
305:32 - section 4.11 the c
305:36 - preprocessor
305:37 - c provides certain language extensions
305:40 - by means of a simple macro preprocessor
305:44 - the pound defined capability which we
305:46 - have used is the most common of these
305:47 - extensions
305:49 - another is the ability to include the
305:50 - entire contents of other files during
305:52 - compilation
305:54 - file inclusion
305:56 - to facilitate handling of pound defines
305:58 - and declarations among other things c
306:01 - provides a file inclusion feature
306:03 - any line that looks like pound include
306:06 - space double quote file name double
306:08 - quote
306:09 - is replaced by the contents of the file
306:11 - name the quotes are indeed mandatory
306:14 - often a line or two of this form appears
306:16 - at the very beginning of each source
306:17 - file to include common pound-defined
306:19 - statements and extern declarations for
306:21 - global variables pound includes may be
306:24 - nested
306:25 - pound include is the preferred way to
306:27 - tie declarations together for a large
306:29 - problem and in a large program
306:31 - it guarantees that all the source files
306:33 - will be supplied with the same
306:35 - definitions and variable declarations
306:37 - thus eliminating a particularly nasty
306:39 - kind of bug
306:40 - of course when an include file is
306:42 - changed all the files that depend on it
306:44 - must be recompiled
306:48 - macro substitution
306:50 - a definition of the form pound define
306:53 - yes one calls for a macro substitution
306:56 - of the simplest kind
306:59 - repeat replacing a logical name by a
307:02 - string of characters names in the pound
307:05 - of fine have the same forms as the c
307:07 - identifiers the replacement text is
307:09 - arbitrarily normally the replacement
307:11 - text is the rest of the line
307:14 - a long definition may be continued by
307:16 - pasting a backslash at the end of the
307:18 - line to be continued the scope of the
307:20 - name defined with pound define is from
307:22 - from its point of definition to the end
307:25 - of the source file
307:26 - names may be redefined and a definition
307:28 - may use previous definitions
307:31 - substitutions do not place take place
307:34 - within quoted strings so for example if
307:37 - yes is a defined name there would be no
307:40 - substitution in printf open paren double
307:42 - quote yes double quote close paren
307:46 - since implementation of pound define is
307:48 - a macro pre-pass not part of the
307:51 - compiler proper there are very few
307:53 - grammatical restrictions on what can be
307:55 - defined for example
307:57 - alcohol fans can say
307:59 - pound define
308:00 - then and then nothing
308:03 - pound define begin
308:05 - open curly brace
308:07 - pound define end
308:09 - semicolon close curly brace and then
308:11 - write
308:12 - approximate algo
308:14 - if
308:15 - paren i greater than zero close paren
308:17 - then begin
308:19 - a equals one semicolon
308:22 - b equals two
308:24 - end
308:27 - it is also possible to define macular
308:29 - macros with arguments so the replacement
308:31 - text depends on the way the macro is
308:33 - called
308:34 - as an example define a macro called max
308:37 - like this
308:38 - pound define max open paren a comma b
308:44 - open paren open paren a close paren
308:46 - greater than open paren b close print
308:49 - question mark open parent a closed paren
308:52 - colon open paren b close paren close
308:55 - paren
308:56 - now the line x equals max open paren p
309:00 - plus q comma r plus s close paren
309:03 - semicolon will be replaced in the
309:06 - preprocessor by the line
309:08 - x equals open paren open paren p plus q
309:12 - close paren greater than open paren r
309:14 - plus s close paren question mark open
309:17 - paren p plus q close print colon open
309:20 - paren r plus s close paren close print
309:23 - semicolon
309:24 - this provides a maximum function that
309:27 - expands into inline code rather than a
309:29 - function call
309:31 - so long as the arguments are treated
309:33 - consistently this macro will serve for
309:35 - any data type there is no need for
309:37 - different kinds of macs for different
309:39 - data types as there would be with
309:41 - functions
309:42 - of course if you examine the expansion
309:44 - of max above you will notice some
309:46 - pitfalls the expressions are evaluated
309:49 - twice it is bad if they involve side
309:51 - effects like function calls increment
309:54 - operators or perhaps push and pop like
309:56 - we've used before
309:57 - some care has to be taken with
309:59 - parentheses to make sure the order order
310:01 - of evaluation is preserved
310:04 - consider the macro
310:06 - pound defined square open paren x close
310:09 - paren equals
310:11 - x times x
310:13 - when it is invoked as square open paren
310:17 - z plus one
310:19 - close paren
310:20 - there are even some purely lexical
310:22 - problems
310:23 - there can be no space between the macro
310:25 - name and left parenthesis that
310:26 - introduces the argument list
310:28 - nevertheless macros are quite valuable
310:31 - one practical example is the standard io
310:33 - library to be described in chapter 7 in
310:36 - which git char and put char are defined
310:38 - as macros obviously put chart needs an
310:41 - argument thus avoiding the overhead of a
310:44 - function call per character profit
310:46 - process
310:47 - other capabilities of the macro
310:49 - processor are described in appendix a
310:54 - as a bit of a long aside
310:57 - in this section we are talking about the
310:59 - preprocessor
311:00 - it's probably a good time to talk a bit
311:02 - about why we use this terminology
311:05 - for those of you with a computer science
311:07 - degree from back in the day many of you
311:09 - wrote a compiler as a senior project
311:10 - just like i did
311:12 - building a compiler was a great project
311:14 - because part of the goal of computer
311:16 - science is to understand the
311:17 - technologies that make programming
311:19 - process possible from the language
311:21 - syntax down to the hardware
311:23 - the compiler that translates our source
311:25 - code into machine code is an essential
311:28 - part of the technology stack that we use
311:31 - early compilers for languages like the
311:33 - early fortran variants tended to be
311:35 - translators they just translated code
311:37 - one line at a time from a high-level
311:38 - language to assembly language
311:40 - you could think of early fortran
311:42 - programs in the 1950s and the 1960s as
311:45 - just more convenient ways to write
311:47 - assembly language for programmers that
311:49 - knew assembly language you always needed
311:51 - to be aware of assembly language and the
311:53 - translation
311:55 - that it was going to write
311:57 - fast fortran
311:59 - programs were small and optimization was
312:01 - done at the fortran level often leading
312:03 - to some hard to understand code
312:06 - by the mid-1970s programming languages
312:09 - were based on parsing theory and we used
312:11 - what is called a grammar to define the
312:13 - language
312:14 - kernighan and ritchie kept io statements
312:16 - out of the c language to keep its formal
312:18 - definition i.e its grammar as simple as
312:21 - possible
312:22 - as these new languages emerge they
312:24 - allowed for more theoretical and
312:26 - powerful approach to converting source
312:27 - code to machine language
312:30 - the theoretical advances in compiler and
312:32 - language design meant that parts of the
312:34 - compiler might be reusable across
312:37 - multiple programming languages
312:39 - each language could have its own syntax
312:41 - and grammar rules and they could be
312:43 - plugged into the compiler and poof you
312:45 - would have a new programming language
312:47 - it got to the point where unix system
312:50 - unix systems had a tool called yak which
312:53 - stood for yet another compiler compiler
312:56 - you would give it a grammar for your new
312:57 - language and it would make a compiler
312:59 - for you
313:00 - as a matter of fact the javascript
313:02 - language that was created in 10 days
313:04 - back in 1995 was possible because
313:07 - brendan ike had a lot of experience with
313:09 - compiler generators
313:11 - he defined a grammar for javascript and
313:13 - generated his first compiler
313:15 - part of what made a compiler generate
313:17 - generator possible is the idea of a
313:19 - multi-step compiler or the tasks of a
313:22 - compiler were broken down into a series
313:24 - of simpler and more well-defined steps
313:27 - here are the steps of a typical c
313:29 - compiler in the 1970s
313:32 - first a preprocessor step that takes c
313:34 - code with syntax like pound define and
313:36 - pout include as its input and produces
313:38 - raw c code output with o's instructions
313:41 - processed and or expanded the
313:43 - preprocessor processor was a c to c
313:46 - transformation
313:48 - next
313:49 - a parser step that took the raw c code
313:51 - applied the grammar to the language and
313:53 - created what is called a parse tree
313:55 - think of the tree as a hierarchy of
313:57 - statements grouped into blocks grouped
313:59 - into functions etc of things like a loop
314:01 - or just one node in a parse tree
314:04 - after that a code generation would turn
314:06 - the parse tree into some kind of
314:08 - simplistic
314:09 - portable internal code that expanded
314:11 - things like loops and if-then-else
314:12 - statements into code
314:15 - after that a code optimization that
314:18 - looked at the internal code and moved
314:19 - things around
314:21 - eliminating any redundant computations
314:24 - say don't compute the same things twice
314:26 - this step is why the authors make such a
314:28 - big fuss about how there are times where
314:30 - c might do things in a slightly
314:32 - different order in an expression even in
314:34 - the presence of parentheses remember the
314:37 - knrc arrangement license back in chapter
314:39 - 2
314:41 - that rule removes constraints on the
314:42 - compiler's optimization step so it can
314:45 - generate the most efficient code
314:48 - i would note that all the steps up to
314:50 - this point did not depend in any way on
314:53 - the actual machine language of the
314:54 - system that they were running on this
314:56 - meant a preprocessor parser code
314:59 - generator and code optimizer could
315:01 - literally be written in c and used on
315:03 - any architecture
315:05 - the final step is a code generator
315:08 - that takes the optimized intermediate
315:11 - code and generates the actual assembly
315:13 - and machine language for the processor
315:15 - for fun you can add the minus capital s
315:17 - parameter to your c compiler and see the
315:19 - resulting assembly language output for
315:21 - your system
315:23 - if you look at the machine language
315:24 - generated on intel or amd processor
315:27 - and compare it to the machine language
315:29 - on an arm processor it will look very
315:31 - different
315:33 - because all but the final compiler steps
315:35 - did not depend on the computer where the
315:36 - program is being run you could actually
315:38 - create a c compiler on a new computer
315:40 - architecture by writing a code generator
315:43 - on the new computer then running all but
315:45 - the last step of the compiler on one
315:46 - computer then copying the internal code
315:49 - generated by the compiler to the new
315:50 - compiler and running the code generation
315:52 - step on the new computer
315:55 - then you actually have a working c
315:57 - compiler
315:58 - on the new computer and the first step
316:00 - is usually to recompile the c compiler
316:02 - itself from source code to produce a
316:04 - fully native c compiler on the new
316:06 - computer that can compile all the rest
316:08 - of the c code you have including
316:10 - possibly the mostly portable elements of
316:13 - the unix operating system on the new
316:15 - compiler
316:17 - yes describing how to cross compile and
316:18 - bootstrap a c compiler onto a new
316:20 - computer hardware architecture can give
316:22 - you a headache if you think about it too
316:24 - much
316:25 - but this notion of bootstrapping a c
316:26 - compiler onto a new architecture was an
316:29 - important technique to move c and then
316:31 - unix to a wide range of very different
316:34 - computer architectures
316:36 - we see this in action as the unix-like
316:38 - mac os operating system over the past 20
316:40 - years was delivered initially on a
316:42 - motorola 68 000 family processors then
316:46 - on powerpc processors and then on intel
316:49 - processors and most recently on
316:51 - arm-based processors built by apple
316:54 - using the software portability patterns
316:56 - that come from c and unix and described
316:58 - by kernighan and ritchie in this book
317:00 - apple now makes their own hardware that
317:03 - can be tuned and evolved over time as
317:06 - their operating system and their
317:08 - applications requirements
317:10 - dictate
317:11 - the use of a grammar by the way is to
317:13 - define a programming language is one of
317:15 - the reasons that syntax errors are so
317:17 - obtuse
317:18 - the compiler is not looking at your code
317:20 - like a human it is following a very set
317:24 - of simple rules to parse your code and
317:26 - it's stuck with something
317:27 - logical and gives you a message like
317:29 - unexpect
317:31 - unexpected statement block or constant
317:34 - on line 17 and the error is nowhere near
317:36 - line 17.
317:39 - modern compilers are more sophisticated
317:42 - of course than the steps above but these
317:43 - steps give you a sense the compiler does
317:45 - many things to make it so your code can
317:48 - actually run
317:49 - very efficiently
317:51 - and given that kernighan and richie were
317:52 - building a programming language c a more
317:54 - mostly portable operating system written
317:56 - in c unix and a mostly portable c
317:58 - compiler written in c
318:01 - some of their innovative work and
318:03 - research into compiler design finds it
318:06 - its way into this book so we have a
318:08 - section in this chapter called the c
318:10 - preprocessor
318:12 - so here we are at the end of chapter
318:14 - four
318:15 - and it's a good time to talk about the
318:17 - word address
318:19 - up to this point in the book if you
318:20 - count them the word address has been
318:22 - used 10 times without a precise
318:24 - definition beyond the notion that data
318:27 - is stored in memory and the address of
318:29 - the data is where the data is stored in
318:30 - memory
318:33 - in the next chapter this notion of the
318:35 - address where the data is stored becomes
318:38 - very real and tangible as we explore
318:41 - pointers as well as the ampersand and
318:43 - asterisk operators
318:46 - up to now
318:47 - an experienced javascript php or java
318:49 - programmer can view c as just another
318:52 - set of similar syntax rules with a few
318:55 - quirky runtime bits
318:57 - but in the next chapter
318:59 - we will deeply explore the concept of
319:01 - data allocation and location
319:04 - it turns out that every programming
319:07 - language pays a lot of attention to data
319:09 - allocation and location but the runtime
319:11 - environments of modern languages work
319:14 - very hard not to expose you to those
319:16 - details
319:17 - just because modern languages hide the
319:19 - difficult bits from us it does not mean
319:22 - that those languages solve the problem
319:24 - using magic
319:26 - eventually the problem needs to be
319:28 - solved
319:30 - and that is why the compiler and
319:32 - low-level runtime elements of language
319:34 - like php
319:35 - javascript and java are usually written
319:37 - in c
319:39 - so the builders of those languages can
319:41 - solve the difficult data storage and
319:43 - allocation problems
319:45 - for you
319:47 - this work
319:48 - is based on the 1978 c programming book
319:51 - written by brian w kernighan and dennis
319:54 - m ritchie
319:55 - their book is copyright all rights
319:57 - reserved by at t
319:58 - but is used in this work under fair use
320:01 - because of the book's historical and
320:03 - scholarly significance
320:05 - its lack of availability and the lack of
320:07 - an accessible version of the book
320:09 - the book is augmented in places to help
320:11 - understand its rightful place in a
320:13 - historical context amidst the major
320:15 - changes of the 1970s and 1980s as
320:18 - computer science evolved from a hardware
320:20 - first vendor-centered approach to a
320:22 - software centered approach where
320:24 - portable operating systems and
320:26 - applications written in c could run on
320:28 - any hardware
320:30 - this is not the ideal book to learn c
320:32 - programming because the 1978 edition
320:34 - does not reflect the modern c language
320:37 - using an obsolete book gives us an
320:39 - opportunity to take students back in
320:41 - time and understand how the c language
320:44 - was evolving as it laid the groundwork
320:46 - for a future with portable applications
320:52 - chapter 5 pointers and arrays
320:55 - before we start chapter 5 a quick note
320:58 - from your narrator
320:59 - from time to time i have been adding
321:01 - some of my interpretation to this book
321:04 - but i won't be adding anything to this
321:06 - chapter
321:07 - i think that sections 5.1 through 5.6
321:11 - contain some of the most elegantly
321:13 - written text in the book
321:15 - the concepts are clearly stated and the
321:17 - example code is short direct and easy to
321:21 - understand
321:22 - pointers are the essential difference
321:24 - between c and any other modern
321:27 - programming language
321:28 - so pay close attention to this chapter
321:31 - and make sure that you understand it
321:33 - before continuing
321:35 - this chapter is as strong now as it was
321:37 - in 1978
321:39 - and so without further ado we read and
321:41 - listen as kernighan and ritchie teach us
321:44 - about pointers and arrays
321:48 - a pointer is a variable that contains
321:50 - the address of another variable
321:52 - pointers are very much used in c
321:55 - partly because they are sometimes the
321:57 - only way to express a computation
322:00 - and partly because they usually lead to
322:02 - more compact and efficient code than can
322:05 - be obtained in other ways
322:08 - pointers have been lumped with a go-to
322:10 - statement as a marvelous way to create
322:12 - impossible to understand programs
322:15 - this is certainly true when they are
322:17 - used carelessly and it is easy to create
322:20 - pointers that point somewhere unexpected
322:23 - with discipline however pointers can
322:25 - also be used to achieve clarity and
322:28 - simplicity
322:29 - this
322:30 - is the app aspect that we will try to
322:32 - illustrate
322:35 - section 5.1
322:37 - pointers and addresses
322:40 - since a pointer contains the address of
322:42 - an object it is possible to access the
322:45 - object indirectly through the pointer
322:48 - suppose that x is a variable say int
322:51 - and that px is a pointer created in
322:55 - some as yet unspecified way
322:58 - the unary operator ampersand gives the
323:01 - address of an object so the statement
323:04 - px equals ampersand x semicolon
323:08 - assigns the address of x to the variable
323:11 - px
323:12 - px is now said to point to x
323:16 - the ampersand operator can be applied
323:18 - only to variables and array elements
323:21 - construct like ampersand open paren x 1
323:24 - close paren and ampersand 3 are illegal
323:29 - it is also illegal to take the address
323:31 - of a register variable
323:34 - the unit the unary operator asterisk
323:36 - treats its operand as the address of the
323:39 - ultimate target
323:40 - and accesses that address to fetch the
323:42 - contents thus
323:44 - if y is also an int
323:48 - y equals star p x semicolon
323:52 - assigns to y the contents of whatever px
323:56 - points to
323:57 - so the sequence
323:59 - px equals ampersand x semicolon
324:02 - y equals star px semicolon assigns the
324:06 - same value to y as does y equals x
324:12 - it is also necessary to declare the
324:14 - variables that participate in all of
324:15 - this
324:16 - int x comma y semicolon int star px
324:21 - semicolon the declaration of x and y is
324:24 - what we have seen all along
324:26 - the declaration of the pointer px is new
324:30 - int star px semicolon
324:33 - is intended as a mnemonic
324:35 - it says that the combination star px is
324:38 - an end
324:39 - that is if px occurs in the context star
324:43 - px it is equivalent to a variable of
324:46 - type int
324:47 - in effect the syntax of the declaration
324:50 - for a variable
324:51 - mimics the syntax of expressions in
324:54 - which the variable might appear
324:56 - this reasoning is useful in all cases
324:59 - involving complicated declarations
325:02 - for example double a to f open
325:05 - parenthesis close parenthesis comma star
325:07 - dp semicolon
325:09 - says that in a particular expression a
325:12 - to f open friend close friend and star
325:14 - dp have values of type double
325:18 - you should also note the implication in
325:20 - the direction declaration
325:23 - that a pointer is constrained to point
325:24 - to a particular kind of objects
325:28 - pointers can occur in expressions for
325:30 - example
325:31 - if px points to the integer x then star
325:35 - px
325:36 - can occur in any context where x could
325:39 - y equal star px plus 1
325:43 - sets y to 1 more than x
325:48 - printf open parenthesis double quote
325:50 - percent d backslash n double quote comma
325:54 - star px close paren prints the current
325:57 - value of x
325:59 - and
326:00 - d equals square root open paren open
326:03 - paren double
326:04 - close paren star p x close paren
326:08 - produces in d the square root of x which
326:11 - is coerced into a double before being
326:13 - passed to square root
326:16 - in expressions like y equals star px
326:20 - plus 1 the unary operators
326:22 - star and ampersand bind more tightly
326:26 - than arithmetic operators so this
326:28 - expression takes whatever px points at
326:31 - adds one and assigns it to y
326:33 - we will return shortly to what
326:36 - y equals star open paren px plus one
326:39 - close paren might mean
326:43 - pointer references can also occur on the
326:46 - left side of assignments
326:47 - if px points to x
326:50 - then
326:51 - star px equals zero sets x to zero
326:55 - and star px plus equals one
326:58 - increments it as does open paren star px
327:02 - close paren plus plus
327:04 - the parentheses are necessary in this
327:06 - last example without them
327:08 - the ink expression would increment px
327:11 - instead of what it points to because
327:13 - unary operators like star
327:16 - and plus plus are evaluated right to
327:19 - left
327:21 - finally since pointers are variables
327:23 - they can be manipulated as other
327:25 - variables can
327:27 - if py is another pointer to int
327:30 - then py equals px
327:33 - copies the contents of px into py
327:37 - thus making py point to whatever px
327:40 - points to
327:42 - section 5.2 pointers and function
327:45 - arguments
327:47 - since c passes arguments to functions
327:50 - by call by value there is no direct way
327:54 - for the called function
327:55 - to alter the variable in the calling
327:57 - function
327:59 - what do you do if you really have to
328:02 - change an ordinary argument
328:04 - for example
328:05 - a sorting routine might exchange two out
328:07 - of order elements with a function called
328:09 - swap
328:10 - it's not enough to write swap open
328:12 - parentheses a comma b close parentheses
328:15 - semicolon where the swap function is
328:18 - defined as and this is sample source
328:20 - code on page 91 of the textbook and you
328:23 - can see it at www.cc4e.com
328:27 - code
328:29 - this is a wrong swap by the way this
328:31 - this is showing you the code that you're
328:33 - not supposed to do
328:35 - swap open paren x comma y close paren
328:39 - int x comma y
328:41 - semicolon open curly brace
328:43 - int temp semicolon temp equals x x
328:47 - equals y semicolon y equals temp
328:50 - semicolon close curly brace
328:53 - because of call by value swap can't
328:56 - affect the arguments a and b in the
328:58 - routine that called it
329:00 - fortunately there is a way to obtain the
329:03 - desired effect
329:05 - the calling point program passes
329:08 - pointers to the values to be changed
329:10 - the call is swap open parentheses
329:13 - ampersand a comma ampersand b close
329:16 - parentheses semicolon
329:18 - since the operator ampersand gives the
329:21 - address of a variable
329:22 - ampersand a is a pointer to a
329:25 - in swap itself the arguments are
329:27 - declared to be pointers and the actual
329:29 - operands are accessed through them
329:32 - so the correct code is on page 92
329:36 - swap open paren px comma py close paren
329:41 - int star px comma star py semicolon
329:46 - open curly brace
329:47 - int temp semicolon
329:50 - temp equals star px semicolon
329:53 - star px equals star py semicolon
329:57 - star py equals temp semicolon and closed
330:01 - curly brace
330:05 - one common use of pointer arguments is
330:07 - in functions that must return more than
330:09 - a single value
330:11 - you might say that swap actually returns
330:13 - two values the new values of its
330:14 - arguments
330:16 - as an example consider a function getint
330:19 - which performs a free format input
330:21 - conversion by breaking a stream of
330:22 - characters into integer values one
330:25 - integer per call
330:27 - getint
330:28 - has to return the value that it found or
330:30 - an end to file signal when there is no
330:32 - more input
330:33 - these values have to be returned as
330:35 - separate objects for no matter what
330:38 - value is used for eof that could also
330:41 - be a value of the integer
330:44 - one solution which is based on the input
330:46 - function scanf that we will describe in
330:48 - chapter seven
330:50 - is to have get in to return eof as its
330:53 - function value it finds end of file and
330:55 - other any other return value singles a
330:58 - normal integer
330:59 - the numeric
331:01 - value of the integer it found is
331:02 - returned through an argument which then
331:04 - must be a pointer to an integer
331:07 - this organization
331:08 - separates the end of file status from
331:10 - the returned numeric value
331:14 - the following loop fills an array with
331:16 - integers by calls to getint
331:19 - int
331:20 - n comma array open print size close
331:22 - paren semicolon
331:24 - for n equals zero
331:27 - n
331:28 - less than size
331:30 - double ampersand
331:31 - get int open paren ampersand v close
331:34 - print not equal eof semicolon and plus
331:37 - plus close parentheses
331:40 - array sub n equals v
331:44 - each call sets v to the next integer
331:46 - found in the input
331:48 - notice that is essential to write
331:51 - ampersand v instead of v as the argument
331:54 - to get int
331:55 - using plane v is likely to cause an
331:57 - addressing error since getint believes
332:00 - that it's been handed a valid pointer
332:03 - getint is an obvious modification to a
332:06 - to i which we wrote earlier
332:09 - the sample code is on page 93 of the
332:12 - textbook and you can see this sample
332:13 - code at
332:17 - dot www.cc4e.com slash code
332:20 - pound include stdio.h
332:22 - getint open paren pn
332:25 - close print
332:26 - int star pn
332:29 - semicolon
332:30 - open for open curly brace
332:33 - int c comma sign
332:36 - while open print open print c equals get
332:38 - ch open praying close paren close print
332:41 - double equals quote space quote
332:44 - or
332:45 - c double equals quote backslash n quote
332:49 - or
332:50 - c double equals backslash t
332:53 - quote
332:55 - close paren semicolon this loop we've
332:57 - done before and it skips the white space
333:01 - sine equals one semicolon if open paren
333:04 - c double equals quote plus quote or
333:08 - c double equals quote minus quote close
333:10 - paren open curly brace
333:13 - equals open parenthesis double equals
333:16 - quote plus quote close paren question
333:19 - mark 1 colon -1 semicolon
333:23 - c equals gut ch
333:26 - to advance the character
333:27 - semicolon
333:29 - and then close curly brace that those
333:31 - four lines record the sign
333:34 - now
333:35 - four
333:36 - star pn equals zero
333:38 - c greater than or equal to quote zero
333:40 - quote and c less than or equal to quote
333:42 - 9 quote
333:43 - colon
333:44 - semicolon c equals get ch open paren
333:48 - close paren close curly brace
333:51 - star pn equals 10 times star pn plus
333:56 - c minus quote zero quote
334:00 - star pn star equals sine
334:06 - if open paren c not equal to eof close
334:10 - print on get ch open paren c close paren
334:13 - semicolon
334:15 - return c
334:20 - throughout get int star pn is used as an
334:23 - ordinary int variable
334:26 - we have also used getch and ungetch as
334:29 - described in chapter four
334:31 - so the one extra character that must be
334:33 - read can be pushed backed on to the
334:34 - input section 5.3 pointers and arrays
334:38 - and see there is a strong relationship
334:40 - between pointers and arrays
334:42 - strong enough that pointers and arrays
334:45 - should really be treated simultaneously
334:48 - any operation which can be achieved by
334:50 - array subscripting can also be done with
334:53 - pointers
334:55 - the pointer version will in general be
334:57 - faster
334:58 - but at least to the uninitiated somewhat
335:00 - harder to grasp immediately
335:03 - the declaration int a sub 10
335:07 - defines an array a of size 10 that is a
335:11 - block of 10 consecutive objects named a
335:14 - sub 0
335:15 - a sub 1
335:17 - dot dot a sub 9. the notation a sub i
335:20 - means the element of the array i
335:23 - positions from the beginning
335:25 - if
335:27 - p a
335:28 - is
335:30 - a pointer to an integer
335:33 - declared as int star pa
335:36 - then the assignment
335:38 - pa
335:39 - equals
335:40 - ampersand a
335:42 - sub zero
335:43 - sets pa to 0.2 the zeroth element of a
335:49 - that is pa contains the address of a sub
335:53 - zero
335:55 - now the assignment
335:56 - x equals star pa will copy the contents
336:00 - of a sub 0 into x
336:04 - if pay a points to a particular element
336:07 - of array a
336:08 - then by definition pa
336:11 - points to the next element
336:13 - nope
336:18 - if pa points to a particular element of
336:21 - an array a then by definition pa plus 1
336:25 - points to the next element
336:27 - and in general
336:29 - a minus i points to i elements before p
336:32 - a and p a plus i
336:35 - points to i elements after
336:37 - thus if p a points to a sub zero
336:42 - star parentheses pa plus 1 closed
336:46 - parenthesis refers to the contents of a
336:49 - sub 1.
336:51 - pa plus i is the address of a sub i
336:56 - and star print
337:01 - and star open paren pa plus i
337:05 - is the contents of a sub i
337:08 - these remarks are true regardless of the
337:10 - type of the variables in the array a
337:13 - the definition of adding one to a
337:15 - pointer and by extension all pointer
337:18 - arithmetic
337:19 - is that the increment is scaled by the
337:21 - size of the storage of the object that
337:23 - is pointed to
337:26 - thus in pa plus i
337:28 - i is multiplied by the size of the
337:31 - objects that pa points to before being
337:33 - added to pa
337:35 - the correspondence between indexing and
337:38 - pointer arithmetic is evidently very
337:41 - close
337:42 - in fact a reference to an array is
337:44 - converted by the compiler
337:46 - to a pointer to the beginning of the
337:48 - array
337:49 - the effect is that the array name is a
337:52 - pointer expression this has quite a few
337:55 - useful implications
337:57 - since the name of an array is a synonym
337:59 - for the location of the zeroth element
338:03 - the assignment
338:04 - pa equals
338:07 - ampersand a sub zero can also be written
338:10 - as p a
338:12 - equals a
338:16 - rather more surprising at least at first
338:18 - sight is the fact that a reference to a
338:20 - sub i can also be written as
338:23 - star open paren a plus i close paren
338:27 - in evaluating a sub i
338:30 - c converts it to star open paren a plus
338:33 - i close paren immediately the two forms
338:37 - are completely equivalent
338:39 - applying the operator ampersand to both
338:41 - parts of this equivalence it follows
338:43 - that ampersand a sub i and a plus i are
338:46 - also identical
338:48 - a plus i is the address of the ith
338:51 - element beyond a
338:53 - as on the other side of this coin if p a
338:56 - is a pointer
338:57 - expressions may use it with a subscript
339:00 - p a sub i
339:02 - is identical to star open paren pa plus
339:06 - i close print
339:08 - in short
339:09 - any array and index expression
339:12 - can be rewritten as a pointer and an
339:14 - offset and vice versa even in the same
339:17 - statement
339:19 - there is one difference between an array
339:21 - name and a pointer that must be kept in
339:23 - mind
339:24 - a pointer is a variable
339:27 - so pa equals a
339:29 - and pa plus plus are sensible operations
339:34 - but an array name is a constant not a
339:36 - variable constructions like a equals pa
339:40 - or a plus plus
339:42 - or
339:42 - p equals ampersand a
339:45 - are illegal
339:47 - when an array name is passed to a
339:49 - function
339:50 - what is passed is the location of the
339:52 - beginning of the array
339:54 - within the call function this argument
339:56 - is a variable just like any other
339:59 - variable and so an arrayname argument is
340:02 - truly a pointer that is a variable
340:05 - containing an address
340:07 - we can use this fact to write a new
340:09 - version of stirlin
340:11 - which computes the length of the string
340:14 - the sample code is on page 95 of the
340:16 - book and you can see it in www.cc4e.com
340:21 - code
340:23 - page 95.
340:25 - int stirlin open paren s close prin
340:29 - char
340:30 - star s semicolon
340:33 - open curly brace
340:35 - int n semicolon
340:38 - four
340:39 - open parenthesis n equals zero semicolon
340:42 - star s not equal quote backslash zero
340:46 - quote semicolon
340:48 - s plus plus
340:49 - close paren
340:51 - n plus plus
340:53 - return open print and close paren
340:56 - semicolon
340:57 - close curly brace
341:00 - incrementing s is perfectly legal since
341:03 - it's a pointer variable
341:05 - s plus plus has no effect on the
341:08 - character string in the function that
341:10 - called sterlin but merely increments the
341:12 - stir lens private copy of the address
341:16 - as the formal parameters in a function
341:18 - definition
341:19 - char
341:20 - s open square bracket close square
341:22 - bracket
341:23 - semicolon and
341:25 - char
341:26 - star s semicolon are exactly equivalent
341:31 - which one should be written is
341:32 - determined largely by how expressions
341:34 - will be written in the function
341:36 - when an array name is passed to a
341:38 - function the function can at its
341:40 - convenience believe that has been handed
341:42 - either an array or a pointer and
341:43 - manipulated accordingly
341:45 - it can even use both kinds of operations
341:48 - if it seems appropriate
341:50 - and clear
341:52 - it is possible to pass part of an array
341:55 - to a function
341:56 - by passing a pointer to the beginning of
341:59 - the subarray
342:01 - for example if a is an array
342:04 - f open friend ampersand a sub 2 close
342:08 - print
342:09 - and
342:10 - f open paren a plus 2 close print
342:14 - both pass to the function f the address
342:16 - of the element a sub 2
342:19 - because ampersand a sub 2 and a plus 2
342:22 - are both pointer expressions that refer
342:25 - to the third element of a
342:29 - within f the argument declaration can
342:32 - read
342:34 - f open paren
342:36 - array
342:37 - close paren int array open bracket close
342:40 - bracket semicolon
342:42 - dot dot dot or
342:45 - f
342:45 - open paren
342:47 - array closed paren and star array
342:50 - semicolon
342:53 - so far as f is concerned the fact that
342:55 - the argument
342:57 - really refers to part of a larger array
343:00 - is really of no consequence
343:04 - section 5.4 address arithmetic if p is a
343:08 - pointer then p plus plus increments p to
343:11 - point to the next element of whatever
343:13 - kind of object p points to
343:16 - and p plus equals i increments p to the
343:20 - point i elements beyond where it
343:22 - currently does
343:23 - these and similar constructions are the
343:25 - simplest and most common form forms of
343:28 - pointer or address arithmetic
343:30 - c is consistent and regular in its
343:33 - approach to address arithmetic its
343:35 - integration of pointers arrays and
343:37 - address arithmetic is one of the major
343:40 - strengths of the language
343:42 - let us illustrate some of the properties
343:44 - by writing a rudimentary storage
343:46 - allocator but useful in spite of its
343:48 - simplicity
343:50 - there are two routines alec open paren
343:52 - and close paren returns a pointer p to n
343:56 - consecutive character positions which
343:58 - can be used by the caller of alec for
344:00 - storing characters
344:02 - free open paren p close print releases
344:05 - the storage thus acquired so it can
344:07 - later be reused
344:09 - these routines are rudimentary because
344:12 - the calls to free must be made in the
344:14 - opposite order to the calls on alec
344:17 - that is storage managed by alec and free
344:20 - is a stack or last in first out
344:24 - the standard c library provides
344:25 - analogous functions which have no such
344:27 - restrictions and in chapter 8 we'll show
344:30 - how improved versions as well in the
344:32 - meantime however
344:33 - many applications really only need a
344:35 - trivial alec to dispense little pieces
344:37 - of storage of unpredictable sizes at
344:40 - unpredictable times
344:42 - the simplest
344:44 - implementation is to have alec hand out
344:46 - pieces of a large character array which
344:48 - we will call alec buff
344:50 - this array is private to allocan free
344:53 - since they deal in pointers and not
344:55 - array indices no other routine need know
344:57 - the name of the array which can be
344:59 - declared as external static that is
345:01 - local to the source file containing
345:03 - allocan free and invisible outside it
345:06 - in practical implementations the array
345:08 - may well not even have a name it might
345:11 - be obtained by asking the operating
345:13 - system for a pointer to some unnamed
345:15 - block of storage
345:18 - the other information needed is how much
345:20 - alec buff has been used we use a pointer
345:23 - to the next free element called alex cp
345:26 - when alec is asked for n characters it
345:28 - checks to see if there is enough room
345:31 - left in alec buff
345:33 - if so alec returns the current value of
345:35 - alec p ie the beginning of the free
345:37 - block and then increments it by n to
345:40 - point to the next free area
345:42 - free p
345:43 - merely sets alec p to p
345:46 - if p is inside alec buff
345:49 - this next code example is on page 97 of
345:52 - the textbook
345:53 - you can see the code at www.cc4e.com
345:58 - code
346:00 - pound include stdio.h
346:04 - to find null zero it's a pointer value
346:06 - for in the error report
346:08 - pound define alec size 1000 the size of
346:11 - the available space
346:13 - static char alec buff open square
346:16 - bracket alex size close square bracket
346:18 - semicolon
346:19 - static chair
346:21 - char star alec p equals alec buff next
346:25 - free position initialized to the start
346:27 - of the array
346:29 - char
346:30 - star alec open paren
346:32 - and close paren return a pointer to n
346:35 - characters
346:36 - int n semicolon open curly brace
346:40 - if alec cp plus n
346:43 - less than or equal to
346:45 - alec buff plus alec size close paren
346:48 - open curly brace
346:50 - meaning we have space
346:52 - alex cp plus equals n return
346:55 - alex cp minus n close parenthesis
346:58 - semicolon
347:00 - close curly brace else if there's not
347:02 - enough room return open paren null close
347:05 - paren semicolon close curly brace
347:09 - free open paren p close print this
347:12 - function will free the storage pointed
347:13 - to by p
347:15 - char star p
347:16 - open curly brace if open paren p greater
347:20 - than equal to alec buff and
347:23 - p less than alec buff plus alex size
347:26 - alex cp equals p
347:28 - close curly brace
347:31 - some explanations
347:33 - in general a pointer can be initialized
347:35 - just as any other variable can though
347:37 - normally only meaningful values are null
347:39 - discussed below or an expression
347:41 - involving the address of a previously
347:43 - defined data of the appropriate type
347:46 - the declaration static char star alex cp
347:50 - equals alec buff
347:51 - defines alex cp
347:55 - to be a character pointer and
347:56 - initializes it to point to alec buff
347:59 - which is the next free position when the
348:01 - program starts
348:03 - this could also have been written
348:05 - static char stala star alex cp equals
348:09 - ampersand alec buff sub-zero semicolon
348:12 - since the array name is the address of
348:15 - the zeroth element
348:17 - whichever is more natural
348:19 - the test
348:20 - if open paren alec p
348:24 - plus n less than or equal to alec buff
348:27 - plus alex size checks if there's enough
348:29 - room to satisfy a request for n
348:31 - characters if there is
348:33 - the new value of alec p
348:35 - would be at most one beyond the end of
348:38 - alec buff if the request can be
348:40 - satisfied
348:41 - alec returns a normal pointer notice the
348:44 - declaration of the function itself
348:46 - if not alec must return some kind of
348:49 - signal that there's no space left c
348:52 - guarantees that no pointer that validly
348:54 - points to data will ever contain a zero
348:56 - so a return value of zero can be used to
348:59 - signal an abnormal event
349:02 - in this case no space we write null
349:04 - instead of zero however to indicate more
349:07 - clearly that this is a special value for
349:09 - a pointer
349:11 - in general integers cannot be
349:13 - meaningfully assigned to pointers but
349:15 - zero is a special case
349:18 - tests like if open for n alec p plus n
349:22 - less than or equal to alec buff plus
349:24 - alex size and
349:26 - if open paren p greater than or equal to
349:29 - alec buff and p less than alec buff plus
349:32 - alex size shows several important facets
349:36 - of pointer arithmetic first
349:38 - pointers may be compared on certain
349:40 - circumstances
349:42 - if p and q point to members of the same
349:45 - array then relations like less than
349:47 - greater than equal etc work properly
349:52 - p greater than q is true for example if
349:56 - p points to an earlier member of the
349:58 - array than q
350:00 - the relations double equals and not
350:02 - equals exclamation equals also work
350:05 - any pointer can be meaningly compared
350:08 - for equality or inequality with null
350:12 - but all bets are off if you do
350:14 - arithmetic or compu comparisons with
350:16 - pointers that point to different arrays
350:19 - if you're lucky you get obvious nonsense
350:21 - on all machines
350:23 - if you're unlucky your code will work on
350:25 - one machine but collapse mysteriously on
350:27 - another
350:29 - second we've already observed that a
350:31 - pointer and an integer can be added or
350:33 - subtracted the construction p plus n
350:37 - means the nth object beyond the one p
350:40 - currently points to this is true
350:42 - regardless of the kind of object p is
350:44 - declared to point at the compiler scales
350:47 - n according to the size of the objects p
350:50 - points to
350:51 - which is determined by the declaration
350:53 - of p
350:54 - for example on the pdp 11 the factors
350:58 - are one for char
350:59 - two for int and short and four for long
351:02 - float and dub and float and eight for
351:04 - double
351:05 - pointer subtraction is also valid
351:08 - if p and q point to members of the same
351:11 - array
351:12 - p minus q is the number of elements
351:15 - between p and q
351:17 - this fact can be used to write yet
351:19 - another version of sterlin
351:23 - sterling open for n s close paren char
351:26 - star s semicolon open curly brace
351:30 - char star p
351:32 - equals s semicolon while star p not
351:35 - equal backslash
351:37 - a single quote backslash zero single
351:40 - quote close paren p plus plus semicolon
351:44 - return
351:45 - open print p minus s close paren
351:47 - semicolon close curly brace
351:51 - in its declaration p is initialized s
351:54 - that is to point to the first character
351:57 - in the while loop each character in turn
352:00 - is examined until backslash zero at the
352:02 - end is seen
352:03 - since backslash zero is zero and since
352:06 - while tests only whether the expression
352:08 - is zero it is possible to omit the
352:11 - explicit test and such loops are often
352:14 - written as
352:15 - while open paren star p close paren p
352:19 - plus plus semicolon
352:21 - because p points to characters p plus
352:24 - plus advances p up to the next character
352:26 - each time
352:28 - and p minus f's gives the number of
352:30 - characters advanced over that is the
352:32 - string length
352:33 - pointer arithmetic is consistent if we'd
352:36 - been dealing with floats which occupying
352:38 - more storage than chars and if p were a
352:40 - pointer to a float p plus plus would
352:42 - advance to the next float
352:44 - thus we could write another version of
352:46 - alec which maintains say floats instead
352:48 - of chars merely by changing char to
352:50 - float throughout alec and free
352:53 - all the pointer manipulations
352:55 - automatically take into the account the
352:57 - size of the object pointed to so nothing
353:00 - else has to be altered
353:02 - other than the operations mentioned here
353:04 - adding or subtracting a pointer in an
353:06 - integer subtracting or comparing two
353:08 - pointers
353:09 - all other pointer arithmetic is illegal
353:12 - it is not permitted to add two pointers
353:14 - or to multiply or divide or shift or
353:16 - mask them or add float or double to them
353:22 - section 5.5 character pointers and
353:25 - functions
353:27 - a string constant written as double
353:29 - quote i am a string double quote is an
353:32 - array of characters in the internal
353:34 - representation the compiler terminates
353:36 - the array with the character backslash
353:38 - zero so programs can find the end
353:40 - the length in storage is thus one more
353:43 - than the number of characters between
353:44 - the double quotes
353:46 - perhaps the most common occurrence of a
353:48 - string constant is arguments to
353:50 - functions as in printf open paren double
353:53 - quote hello comma world backslash n
353:56 - double quote
353:57 - when a character string appears like
353:59 - this in a program
354:00 - access to it is through a character
354:02 - pointer what printf receives is a
354:05 - pointer to the character array
354:08 - character arrays of course need not be
354:10 - function arguments if message is
354:12 - declared as char star message
354:16 - then the statement
354:17 - message equals double quote now is the
354:19 - time double quote semicolon assigns
354:22 - message to a pointer to the actual
354:24 - characters this is not a string copy
354:28 - only pointers are involved
354:30 - c does not provide any operators for
354:32 - processing an entire string of
354:34 - characters as a unit in the language
354:38 - we will illustrate more aspects of
354:40 - pointers and arrays by studying two
354:42 - useful functions from the standard i o
354:44 - library to be discussed in chapter 7.
354:47 - the first function is stir copy open
354:49 - paren s comma t which copies the string
354:52 - t to the string s
354:54 - the arguments are written in this order
354:56 - by analogy to assignment where one would
354:59 - say s equals t
355:01 - to assign t to s
355:02 - the array version is first
355:06 - stir copy open paren s comma t close
355:10 - paren char s open square bracket close
355:12 - square bracket comma t open square
355:15 - bracket close square bracket semicolon
355:17 - open curly brace
355:19 - int i semicolon
355:21 - i equals zero semicolon while open paren
355:25 - open for n s sub i
355:27 - equals t sub i
355:29 - close paren not equal quote backslash 0
355:32 - quote close parenthesis i plus plus
355:35 - semicolon
355:36 - close curly brace
355:40 - you'll note in that while statement that
355:41 - there is a
355:42 - copying of the actual characters as an
355:45 - assignment and then the side effect of
355:46 - the result of that assignment is
355:48 - compared to the new line at the end of
355:50 - string which terminates the while loop
355:54 - for contrast here is a version of stir
355:56 - copy with pointers and this is on page
355:59 - 100 of the textbook and you can see all
356:02 - the code in the textbook at www.cc4e
356:07 - code and again this is example number
356:09 - two on page 100.
356:12 - stir copy open paren s comma t close
356:15 - paren
356:17 - char
356:18 - star s comma star t semicolon open curly
356:21 - brace while open paren open paren star s
356:25 - equals star t
356:26 - close prin not equal single quote
356:29 - backslash zero single quote close print
356:31 - open curly brace
356:33 - s plus plus comma
356:35 - semicolon t plus plus semicolon close
356:38 - curly brace
356:39 - close curly brace to end the function
356:42 - because the arguments are passed by
356:44 - value stir copy can use s and t in any
356:48 - way it pleases here they are
356:50 - conveniently initialized pointers which
356:52 - are marched along the arrays a character
356:54 - at a time
356:55 - until the backslash terminates
356:58 - then t has been copied to s
357:01 - in practice their copy would not be
357:03 - written as we showed above
357:05 - a second possibility might be and this
357:07 - is the third example on page 100 of the
357:10 - textbook
357:11 - stir copy open vern s comma t close
357:14 - paren char star s comma star t semicolon
357:18 - open curly brace while
357:20 - paren paren star s plus plus
357:24 - equals star t plus plus close prin
357:28 - not equal quote backslash zero quote
357:32 - close paren
357:34 - semicolon curly brace
357:36 - this moves the increment and s and t
357:38 - into the test part the value of star t
357:41 - plus plus is the character that t
357:43 - pointed to before t was incremented
357:46 - the post fix plus plus doesn't change t
357:50 - until after this character has been
357:51 - fetched
357:52 - in the same way the character is stored
357:55 - in the old position of s before s is
357:57 - incremented
357:58 - the character is also the value that is
358:01 - compared against backslash zero to
358:03 - control the loop
358:04 - the net effect
358:06 - is that the characters are copied from t
358:09 - to s up to and including the terminating
358:12 - backslash zero
358:14 - as the final abbreviation
358:18 - of this solving this problem
358:21 - we can observe that the comparison
358:22 - against backslash zero is redundant so
358:24 - the function is often written as and now
358:26 - this is the first sample code on page
358:29 - 101
358:31 - of the textbook
358:33 - stir copy open paren s comma t close
358:36 - paren char star s comma star t semicolon
358:40 - open curly brace
358:42 - while open paren
358:44 - star s plus plus
358:47 - equals
358:48 - star t plus plus closed paren semicolon
358:52 - curly brace
358:55 - although this may seem cryptic at first
358:57 - the notational convenience is
358:59 - considerable and the idiom should be
359:01 - mastered
359:02 - if for no other reason then you will see
359:04 - it frequently in c programs
359:07 - the second routine
359:09 - is stir comp open for n s comma t
359:13 - which compares the character strings s
359:15 - and t
359:17 - and returns
359:19 - negative zero or positive according to
359:21 - as s is lexigraphically less than equal
359:24 - to or greater than t
359:26 - the value returned is obtained by
359:27 - subtracting the characters at the first
359:29 - position
359:31 - where s and t disagree
359:33 - this is the second example on page 101
359:37 - of the textbook
359:39 - which you can see at www.cc4e.com
359:43 - code
359:45 - stir comp open paren s comma t close
359:48 - parent
359:49 - char s open square bracket close square
359:52 - square bracket comma t open square
359:54 - bracket close square bracket semicolon
359:57 - open curly brace int i semicolon i
360:01 - equals zero semicolon
360:03 - while
360:04 - s sub i double equals t sub i
360:07 - close paren open print s sub i plus plus
360:11 - double equals single quote backslash
360:14 - zero single quote close paren return
360:16 - zero return open paren s sub i minus t
360:20 - sub i
360:21 - close paren semicolon close curly brace
360:25 - the pointer version of stir comb
360:27 - is the first example on page 102 of the
360:30 - textbook
360:31 - stir comp open paren s comma t close
360:34 - paren char star s comma star t
360:38 - open curly brace
360:40 - 4
360:41 - open paren
360:42 - semicolon
360:44 - star s double equals star t
360:47 - semicolon s plus plus comma t plus plus
360:51 - close paren
360:52 - if open for n star s equal equal single
360:56 - quote backslash zero single quote close
360:58 - paren
360:59 - return open print 0 close paren
361:02 - return open print star s minus star t
361:06 - close paren semicolon close curly brace
361:09 - since plus plus and minus minus are
361:11 - either prefix or postfix operators the
361:14 - combination of star and plus plus and
361:17 - minus minus occur although less
361:20 - frequently
361:21 - for example star
361:23 - plus plus p
361:26 - increments p before fetching the
361:28 - character that p points to
361:31 - star minus minus p decrements p first
361:36 - section 5.6 pointers are not integers
361:41 - you may notice in older c programs a
361:43 - rather cavalier attitude towards copying
361:46 - pointers
361:47 - it has generally been true that on most
361:49 - machines a pointer may be assigned to an
361:52 - integer and back again without changing
361:54 - it no scaling or conversion takes place
361:56 - and no bits are lost
361:58 - regrettably this has led to the taking
362:00 - of liberties with routines that return
362:02 - pointers which are then merely passed to
362:04 - other routines
362:06 - the requisite pointer declarations are
362:07 - often left out for example consider the
362:10 - function stir save open paren s close
362:13 - paren which copies the string s into a
362:15 - safe place obtained by a call to alec
362:18 - and returns a pointer to it properly
362:20 - this should be written as
362:22 - this is the first example on page 103 of
362:25 - the textbook you can see the sample code
362:27 - at www.ccfree.com
362:30 - code
362:32 - pound include stdlib.h
362:35 - char star serv stir save open print s
362:38 - close paren save a string somewhere
362:41 - char star s semicolon open curly brace
362:45 - char star p star alec open paren close
362:48 - paren semicolon if open paren open paren
362:52 - p equals alec open paren sterling open
362:55 - paren s close paren plus one close paren
362:58 - close print not equal null
363:00 - close paren stir copy open paren p comma
363:03 - s
363:04 - close
363:05 - paren semicolon return open paren p
363:09 - close paren semicolon curly brace
363:12 - in practice
363:13 - there would be a strong tendency
363:16 - mistaken tendency that is to emit
363:18 - declarations this is the example 2 on
363:22 - page 103
363:24 - pound include stdlib dot h
363:27 - stir save open paren s close paren
363:31 - open curly brace char star p semicolon
363:34 - if parentheses parentheses
363:37 - p equals alec
363:39 - open paren sterlin open paren s
363:42 - close print plus one close print close
363:45 - print not equal no close paren stir copy
363:47 - open paren p comma s
363:50 - close paren semicolon return open paren
363:52 - p close print semicolon
363:56 - this will work on many machines since
363:58 - the default type for functions and
364:00 - arguments is int
364:02 - an int and pointer can usually be safely
364:05 - assigned back and forth
364:06 - nonetheless
364:08 - this kind of code is inherently risky
364:10 - for it depends on the details of the
364:12 - implementation and machine architecture
364:15 - which may not hold for the particular
364:16 - compiler you use
364:18 - it is wiser to be complete in all
364:20 - declarations the program lind will warn
364:23 - of such constructions in case they creep
364:25 - in inadvertently
364:28 - section 5.7 multi-dimensional arrays
364:32 - in general
364:33 - rectangular multi-dimensional arrays are
364:35 - used in computational programs like a
364:37 - weather simulation
364:39 - and were
364:40 - a way
364:41 - back in the day to write c code that
364:43 - could accept fortran multi-dimensional
364:45 - arrays as parameters so that
364:46 - computational or statistical libraries
364:49 - can be written in c
364:51 - arrays of pointers are a better mapping
364:53 - to the typical operating system in
364:55 - string manipulation use cases that are
364:57 - more the core of c applications
365:00 - we also call these ragged arrays because
365:02 - each row can be a different length
365:04 - this also works well as data is
365:06 - dynamically allocated in c as compared
365:08 - to the more static allocation approach
365:11 - that's typical in fortran's
365:12 - multi-dimensional arrays
365:16 - now to the textbook
365:18 - c provides for rectangular
365:19 - multi-dimensional arrays although in
365:21 - practice they tend to be much less used
365:23 - than the arrays of pointers in this
365:25 - section we will show some of their
365:27 - properties
365:28 - consider the problem of date conversion
365:30 - from the day of the month to the day of
365:32 - the year and vice versa for example
365:35 - march 1st is the 60th day of a non-leap
365:38 - year and 60 first day of a leap year
365:41 - let us define two functions to do the
365:43 - conversions day of year converts month
365:45 - and day to the day of the year and month
365:48 - day converts the day of the year into
365:49 - the month and the day
365:51 - since this ladder function returns two
365:52 - values the month and day arguments will
365:54 - be pointers
365:56 - month day open parenthesis 1977 comma 60
366:01 - ampersand m comma ampersand d close
366:04 - parentheses
366:05 - sets m to three and d to one which is
366:08 - march first
366:11 - these functions both need the same
366:12 - information a table of the number of
366:14 - days in each month 30 days half
366:17 - september et cetera since the number of
366:19 - days per month differs for leap years
366:22 - and non-leap years it's easier to
366:24 - separate them into two rows of a
366:26 - two-dimensional array rather than try to
366:28 - keep track of what happens in february
366:30 - during computation
366:31 - the array and the functions performing
366:33 - the transformations are as follows
366:36 - this is example
366:38 - number one on page 104 of the textbook
366:41 - and you can see the code at www.cc4e.com
366:46 - code
366:50 - static int day tab
366:53 - open paren to close print open paren 13
366:57 - close print equals
366:59 - open curly brace
367:01 - open curly brace
367:02 - 0 comma 31 and then a number of numbers
367:06 - close curly brace comma open curly brace
367:09 - 0 comma 31 29 and then a bunch of
367:12 - numbers close curly brace close curly
367:15 - brace semicolon
367:18 - day of the year
367:20 - open paren year come a month come a day
367:23 - int year come a month comedy semicolon
367:25 - open curly brace
367:27 - int i comma leap semicolon
367:30 - leap
367:31 - equals 0 year modulo 4 double equals 0
367:36 - and
367:37 - year modulo 100 not equal 0 or year
367:41 - modulo 400 equals equals 0
367:44 - semicolon for open paren i equals one
367:48 - i less than month i plus plus close
367:51 - paren
367:52 - day plus equals day tab open square
367:55 - bracket leap close square bracket
367:58 - open square bracket i close square
368:00 - bracket semicolon
368:02 - return open paren day close paren
368:05 - semicolon close curly brace
368:08 - then the month day function
368:10 - month day open paren year come a year
368:13 - day come a p month come a p day close
368:15 - paren
368:17 - int
368:18 - year come a year day star p month comma
368:22 - star p day
368:23 - semicolon
368:24 - open curly brace int i come a leap
368:27 - semicolon
368:29 - leap equals year
368:31 - percent four double equals zero
368:34 - and year percent 100 not equal zero or
368:38 - year percent 1400
368:41 - double equals zero
368:43 - for i equals one year day greater than
368:46 - date tab open square bracket leap close
368:49 - square bracket open square bracket i
368:51 - close square bracket semicolon i plus
368:54 - plus close parenthesis your day minus
368:57 - equal day tab open square parenthesis
369:00 - open square bracket leap close square
369:02 - bracket open square bracket i close
369:04 - square bracket semicolon star p month
369:07 - equals i
369:09 - p day equals year day semicolon close
369:13 - paren
369:15 - the array day tab has to be external to
369:17 - both day of year and month day so they
369:19 - can both use it
369:21 - date tab is the first two dimensional
369:23 - array we've dealt with
369:25 - in c by definition a two-dimensional
369:27 - array is really a one-dimensional array
369:30 - each of which elements is also an array
369:33 - hence subscripts are written as day tab
369:36 - open square bracket i close square
369:38 - bracket open square bracket j close
369:40 - square bracket
369:42 - rather than
369:43 - day tab
369:44 - open square bracket i comma j close
369:46 - square bracket as in most languages
369:50 - other than this a two-dimensional array
369:52 - can be treated much the same in the same
369:54 - way as other languages elements are
369:56 - stored by rows that is the rightmost
369:58 - subscript varies fastest as elements are
370:02 - accessed in storage order
370:04 - an array is initialized by list of
370:06 - initializers and braces each row of a
370:09 - two-dimensional array is
370:11 - initialized by a corresponding sub-list
370:13 - we started the array day tab with a
370:15 - column of 0 so that month numbers can
370:18 - run from the natural 1 to 12 instead of
370:20 - 0 to 11. since space is not a premium
370:23 - here this is easier than adjusting
370:25 - indices
370:27 - if a 2 dimensional array is to be passed
370:28 - to a function
370:30 - the argument definition
370:32 - declaration in the function must include
370:34 - the column dimension the row dimension
370:36 - is irrelevant since what is passed in as
370:39 - before
370:40 - it is a pointer
370:41 - this is in this particular case it's a
370:43 - pointer to objects which are arrays of
370:45 - 13 ins thus the array day tab
370:49 - if it's to be passed to a function f the
370:51 - declaration would be
370:52 - f open friend date tab close paren int
370:56 - day tab
370:57 - open square bracket 2 close square
370:59 - bracket open square bracket 13 close
371:01 - square bracket semicolon
371:03 - open curly brace dot dot dot close curly
371:06 - brace
371:07 - the argument declaration in f could also
371:10 - be int date tab
371:12 - open square bracket close square bracket
371:14 - open square bracket 13 closed square
371:16 - bracket semicolon
371:18 - since the number of rows is actually
371:20 - irrelevant
371:21 - it could also be seen as
371:23 - int open print star day tab close print
371:27 - open bracket 13 closed bracket
371:31 - semicolon which says that the argument
371:33 - is a pointer
371:34 - to an array of 13 integers
371:36 - the parentheses are necessary since the
371:38 - brackets have higher precedence than
371:40 - asterisk without parentheses the
371:43 - declaration int star day tab sub 13
371:48 - close square bracket
371:50 - semicolon is an array of 13 pointers to
371:52 - integers as we shall see
371:54 - in the next section
371:56 - section 5.8 pointer arrays pointers to
371:59 - pointers
372:01 - since pointers are variables themselves
372:03 - you might expect that there would be
372:05 - uses for arrays of pointers
372:08 - this is indeed the case let us
372:10 - illustrate by writing a program that
372:12 - will sort
372:13 - a set of text lines into alphabetic
372:15 - order than a stripped-down version of
372:18 - the unix utility sort
372:20 - in chapter three we presented a shell
372:22 - sort function that would sort an array
372:24 - of integers this same algorithm will
372:27 - work except that now we have to deal
372:29 - with lines of text which are of
372:30 - different lengths and which unlike
372:32 - integers can't be compared or moved in a
372:34 - single operation
372:36 - we will need a data representation data
372:39 - structure that will cope efficiently and
372:41 - conveniently with variable length text
372:43 - lines
372:44 - this is where an
372:46 - array of pointers enters
372:48 - if the lines to be sorted are stored and
372:51 - in one long character array maintained
372:52 - by alec perhaps then each line can be
372:55 - accessed by a pointer to its first
372:57 - character
372:58 - the pointers themselves can be stored in
373:00 - an array
373:02 - two lines can be
373:03 - compared by passing their pointers to
373:05 - stir comp
373:07 - when two out of order lines have to be
373:09 - swapped or exchanged the pointers in the
373:12 - pointer array are exchanged not the text
373:14 - lines themselves
373:15 - this eliminates the twin problems of
373:17 - complex storage management and high
373:20 - overhead that would go with moving the
373:22 - text of the actual lines
373:24 - the sorting process involves three steps
373:27 - read all the lines of input
373:29 - sort them and then print them in order
373:32 - as usual it's best to divide the program
373:35 - into functions that match this natural
373:36 - division with the main routine
373:38 - controlling things
373:40 - let us defer the sorting step for a
373:42 - moment and concentrate on the data
373:43 - structures and the input in output
373:46 - the input routine has to collect and
373:47 - save the characters in each line and
373:49 - build an array of pointers to the lines
373:51 - it will also have to count the number of
373:53 - input lines since that information is
373:55 - also needed for sorting and printing
373:57 - since the input function can only cope
373:59 - with a finite number of input lines it
374:01 - can return some illegal line count like
374:03 - negative 1 if too much input is
374:05 - presented the output routine only has to
374:08 - print the lines in order in the order in
374:10 - which they appear in the array of
374:12 - pointers
374:14 - this next code segment
374:16 - is actually a combination of three
374:18 - successive sample code segments uh
374:21 - starting on page 106 of the textbook and
374:23 - it's pretty complex
374:25 - so you might be best it might be best
374:28 - for you to see them on www.cc4e.com
374:32 - slash code line 106 example one
374:36 - okay
374:38 - pound include stdio.h pound includes
374:41 - string.h pound define lines 100. the
374:45 - maximum lines of support
374:46 - to be sorted
374:48 - main open paren close paren
374:50 - char
374:51 - line ptr
374:53 - open brick ombud square bracket lines
374:55 - close square bracket semicolon int n
374:57 - lines which is the number of lines read
375:01 - if
375:02 - open paren open paren n lines equals
375:04 - read lines open paren line ptr comma
375:07 - lines close praying close paren greater
375:09 - than or equal to zero
375:11 - close paren open curly brace sort open
375:14 - paren line ptr comma n lines close paren
375:18 - write lines open print line ptr comma n
375:20 - lines close paren semicolon
375:23 - close curly brace else
375:25 - print f
375:26 - open paren double quote input too big to
375:29 - sort
375:30 - backslash n
375:32 - close double quote
375:34 - close paren semicolon and close curly
375:36 - brace to end the main program
375:39 - this next routine is actually from page
375:41 - 107 of the textbook but we combined them
375:44 - into one
375:45 - pound defined maxland1000
375:48 - readlines openpren line ptr comma max
375:52 - lines close paren
375:54 - char star line ptr open square bracket
375:57 - close for a square bracket semicolon
375:59 - this is an array of pointers to
376:01 - characters
376:03 - an array of pointers pointers being you
376:05 - know long like four bytes characters
376:07 - being generally one byte int max line
376:10 - semicolon open curly brace
376:13 - int
376:14 - len comma n lines
376:16 - semicolon char star p
376:19 - star alec open print close paren comma
376:21 - line
376:22 - open square bracket max lane close
376:24 - square bracket semicolon
376:28 - so
376:28 - just to recall alec is a function we do
376:31 - we did later i mean did earlier that
376:33 - allows us to allocate uh
376:36 - some text of a
376:38 - varying length and then lines so maxlen
376:40 - is a place that we're going to
376:42 - read each line into
376:45 - beginning the code of read lines
376:47 - n lines equals zero while open paren
376:50 - open paren
376:51 - len equals get line open paren line
376:54 - comma max len close paren close friend
376:56 - greater than or equal to zero close
376:58 - paren
376:59 - if
377:01 - open print n lines greater than equal to
377:03 - max lines close paren return open paren
377:05 - minus one close paren semicolon
377:08 - else if
377:10 - open print open paren p equals alec open
377:13 - paren len close paren close paren
377:16 - double equals null
377:17 - close paren return minus one
377:20 - so those two tests basically make sure
377:22 - that we
377:23 - don't get too many lines and that we
377:26 - have enough space in our
377:28 - al dynamic data area that alec is
377:31 - managing for us
377:33 - so continuing with the if we're at the
377:35 - else opens curly brace line sub len
377:39 - minus one
377:41 - equals
377:42 - quote backslash zero quote semicolon
377:45 - stir copy
377:47 - p
377:48 - comma line
377:49 - close paren semicolon
377:52 - line ptr sub n lines plus plus equals p
377:56 - semicolon
377:57 - close curly brace that finishes the else
378:00 - segment return n lines semicolon and
378:04 - close curly brace
378:05 - to finish the read lines function
378:08 - now
378:09 - at a high level we're reading a line
378:13 - into a
378:14 - allocated automatic variable line
378:17 - and then we are
378:19 - calling alec to get another
378:22 - cop place to copy that line then we're
378:24 - making a copy of that line
378:26 - and then we are remembering the pointer
378:28 - to the beginning of that line in line
378:30 - ptr and that's the
378:31 - essence of it
378:34 - okay
378:39 - write lines open paren line ptr comma n
378:42 - lines close paren char star line ptr
378:46 - open square bracket close square bracket
378:47 - semicolon
378:49 - again
378:50 - an array of pointer characters
378:53 - int n lines semicolon
378:55 - which is the number of character
378:57 - pointers in line ptr open curly brace
379:00 - int i semicolon
379:02 - four paren i equals zero semicolon i
379:05 - less than n lines semicolon i plus plus
379:08 - close paren printf open paren
379:11 - double quote percent s backslash n
379:13 - double quote comma line ptr sub i close
379:17 - paren semicolon close curly brace a
379:20 - simple loop that goes through the array
379:22 - of character pointers and then prints
379:24 - each one out using printf
379:27 - the main new thing is the declaration
379:30 - for
379:32 - line ptr char starline ptr sub
379:36 - open square bracket lines close square
379:38 - bracket semicolon says that line ptr is
379:41 - an array of lines elements each element
379:44 - of which is a pointer to a char
379:46 - that is line ptr sub i is a character
379:50 - pointer and star line pr ptr sub i
379:54 - accesses a character
379:57 - since line ptr itself is an array that
380:00 - was passed to right lines it can be
380:02 - treated as a pointer exactly in the same
380:04 - manner as our earlier examples and the
380:06 - function can be written instead as
380:08 - right lines open paren line ptr comma n
380:12 - lines close paren
380:14 - char starline ptr open square bracket
380:16 - close square bracket semicolon int and
380:19 - line semicolon open curly brace
380:22 - while open paren minus minus n lines
380:25 - greater than or equal to zero close
380:27 - paren
380:28 - printf
380:29 - open paren double quote percent s
380:32 - backslash n double quote comma star line
380:35 - ptr plus plus close paren semicolon
380:39 - that code by the way was on page 108
380:42 - example one
380:44 - of the textbook
380:47 - starline ptr points initially to the
380:49 - first line but each increment of
380:53 - line ptr advances it to the next line
380:56 - while n lines is counted down
380:59 - with input and output under control
381:02 - we can proceed to sorting
381:04 - the shell sort from chapter 3 needs
381:06 - minor changes
381:08 - the declarations have to be modified and
381:10 - the comparison operation must be moved
381:13 - into a function but the basic algorithm
381:15 - remains the same which gives us some
381:17 - confidence that it will still work
381:19 - and this is the second example on page
381:22 - 108 of the textbook and you can see this
381:24 - example at www.cc4e.com
381:29 - code
381:31 - start sort open paren v comma n close
381:34 - paren
381:36 - char star v open square bracket close
381:38 - square bracket semicolon
381:41 - and and semicolon open curly brace
381:44 - so we're getting an array of pointers to
381:46 - the beginnings of lines
381:48 - and how many of those pointers matter
381:51 - and the rest of it is shell sort
381:54 - with the stir comp being used
381:57 - to do the string comparison so it's a
382:00 - three nested for loop
382:02 - with a simple if test in it
382:05 - so here we go
382:07 - open curly brace for the sort function
382:09 - int gap comma i comma j semicolon char
382:12 - star
382:14 - semicolon and that's a pointer to a
382:16 - character
382:17 - four open paren gap equals n over two
382:20 - slash i mean semicolon
382:23 - gap greater than zero semicolon gap
382:25 - slash equals two close parenthesis 4
382:29 - i equals gap semicolon i less than n
382:32 - semicolon i plus plus close parenthesis
382:36 - for open paren j equals i minus gap
382:39 - semicolon j greater than or equal to
382:41 - zero semicolon
382:43 - j minus equals gap close paren open
382:46 - curly brace
382:48 - so that's sort of the shell part of the
382:50 - shell sort and now we have to do our
382:52 - comparison if
382:54 - open paren stir comp open print
382:59 - v sub j comma v sub j plus gap
383:03 - close paren less than or equal to zero
383:06 - close paren break and note that that's
383:09 - only breaking the
383:11 - third deep for loop which it just goes
383:13 - and then runs the next iteration of the
383:15 - second for loop
383:17 - now we do the swapping
383:18 - temp equals b sub j semicolon v sub j
383:22 - equals a v sub j plus gap semicolon
383:25 - v sub j plus gap equals temp now that's
383:28 - just swapping
383:30 - pointer values so the the strings that
383:32 - are pointed to by these two pointers v
383:34 - sub j and v sub j plus gap
383:37 - if they're out of order we're going to
383:39 - swap
383:40 - the pointers in the array and move them
383:42 - so that
383:43 - if you then go through like we did in
383:45 - write lines earlier
383:46 - then um they come out in order but we
383:49 - literally read the data once
383:52 - we copy it once into the its final
383:55 - destination using alec alec and stir
383:57 - copy but once we sort it which is the
384:00 - most complex part of the calculation
384:03 - we're only moving the pointers back and
384:04 - forth so the sort is very efficient and
384:07 - requires no extra
384:09 - memory than what we had before the sort
384:12 - so that's really nice and it sorts in
384:13 - place
384:16 - so back to the text since any individual
384:19 - element of v
384:20 - which is an alias to line pointer ptr
384:23 - is a character pointer temp could also
384:26 - should also be one so one can be copied
384:28 - to the other
384:29 - we wrote the program about as
384:30 - straightforwardly as possible so as to
384:32 - get it working quickly it might be
384:34 - faster for instance to copy the incoming
384:36 - lines directly into an array made by
384:39 - read lines rather than copying them into
384:40 - line and then to a hidden place
384:42 - maintained by alec but it's wiser to
384:45 - make the first draft of something easy
384:47 - to understand
384:48 - and worry about efficiency later
384:51 - the way to make this program
384:52 - significantly faster is probably not by
384:55 - avoiding an unnecessary copy of the
384:57 - input lines
384:58 - just instead replacing the shell store
385:01 - sort by something quicker and better
385:03 - like quick sort is much more likely to
385:05 - make a real difference that matters
385:08 - in chapter one we pointed out that
385:10 - because while in for loops test the
385:11 - termination condition before executing
385:13 - the loop body even once they help to
385:16 - ensure that the programs will work at
385:17 - their boundaries in particular with no
385:20 - input
385:21 - it's illuminating to walk through the
385:23 - functions of the sorting program
385:25 - checking what happens if there is no
385:28 - input text at all
385:30 - section 5.9 initialization of pointer
385:34 - arrays
385:35 - consider the problem of writing a
385:37 - function month name open paren and close
385:40 - paren which returns a pointer to a
385:42 - character string containing the name of
385:43 - the mf month
385:45 - this is an ideal application for an
385:47 - internal static array
385:49 - month name contains a private array of
385:51 - character strings and returns a pointer
385:52 - to the proper one when called the topic
385:55 - of this section is how
385:57 - that array of names is initialized
386:00 - the syntax is quite similar to the
386:02 - previous initializations this is sample
386:05 - code from page 109 of the textbook which
386:07 - you can see
386:08 - at
386:10 - www.cc4e.com code
386:13 - char
386:14 - star month name open paren close print
386:18 - so the return value for this function is
386:19 - a character pointer
386:21 - int
386:22 - n semicolon open curly brace static char
386:27 - star name open square bracket close
386:29 - square bracket equals open curly brace
386:32 - quote
386:33 - illegal month quote
386:35 - comma
386:36 - double quote january double quote comma
386:39 - double quote february double quote comma
386:42 - and so forth down to double quote
386:44 - december double quote
386:46 - close curly brace semicolon
386:49 - the body of the
386:51 - function is one line return open paren
386:54 - open paren n less than 1 or n greater
386:57 - than 12 close paren question mark
387:00 - name sub 0
387:01 - colon
387:02 - name sub n
387:04 - close paren semicolon close curly brace
387:08 - the declaration of name which is an
387:10 - array of character pointers is the same
387:12 - as line ptr in the sorting example
387:15 - the initializer is simply a list of
387:17 - character strings
387:18 - each assigned
387:20 - to the corresponding position in the
387:22 - array more precisely the characters of
387:25 - the i string are placed somewhere else
387:27 - and a pointer to them
387:29 - is stored in name sub i
387:31 - since the name size of the array name is
387:34 - not specified the compiler itself counts
387:36 - the initializers and fills in the
387:38 - correct number
387:40 - section 5.10 pointers versus
387:43 - multi-dimensional arrays
387:46 - newcomers to see are sometimes confused
387:48 - about the difference between a
387:50 - two-dimensional array and an array of
387:52 - pointers such as name in the example
387:54 - above
387:55 - given the declarations int
387:58 - a open square bracket 10 close square
388:01 - bracket open square bracket 10 close
388:03 - square bracket semicolon and int star b
388:06 - open square bracket 10 close square
388:09 - bracket semicolon
388:11 - the usage of a and b may be similar
388:14 - in that a sub 5 5 and b sub 5 5 are both
388:18 - legal references to a single integer
388:21 - but a is a true array all 100 storage
388:24 - cells have been allocated and the
388:26 - conventional rectangular substrip
388:28 - calculation is done to find any given
388:30 - element for b however the declaration
388:33 - only allocates 10 pointers
388:36 - each must be set to point to an array of
388:38 - integers
388:39 - assuming that each does point to a 10
388:42 - element array
388:43 - then there will be 100 storage cells set
388:46 - aside plus the 10 cells for the pointers
388:49 - thus the array of pointers uses slightly
388:52 - more space and may require an explicit
388:54 - initialization step but it has two
388:57 - advantages
388:58 - accessing an element is done by
389:00 - indirection through a pointer rather
389:01 - than by a multiplication and an addition
389:04 - and the rows of the array may be of
389:05 - different lengths that is each element
389:08 - of b need not point to a 10 element
389:11 - vector some may point to two elements
389:13 - others may point to 20 and some to none
389:15 - at all
389:16 - although we have phrased this discussion
389:18 - in terms of integers by far the most
389:20 - frequent use of arrays of pointers is
389:22 - like that shown in month name to store
389:25 - character strings of a diverse lengths
389:28 - section
389:29 - 5.11
389:31 - command line arguments
389:33 - in environments that support c there is
389:36 - a way to pass command line arguments or
389:38 - parameters to a program when it begins
389:40 - executing
389:41 - when main is called to begin execution
389:43 - it is called with two arguments
389:46 - the first conventionally called arg c is
389:48 - the number of command line arguments the
389:50 - program was invoked with the second arg
389:53 - v is a pointer to an array of character
389:55 - strings that contain the arguments one
389:57 - per string
389:59 - manipulating these character strings is
390:01 - a common use of multiple levels of
390:03 - pointers
390:05 - i would note that back in 1978 the two
390:08 - largest bodies of c code were likely the
390:10 - at t unix kernel itself and unix
390:12 - utilities like grep
390:14 - ls or the login shell
390:16 - so writing an operating system was fresh
390:18 - on the mind of the authors while writing
390:20 - this book
390:21 - these topics find their way into the
390:23 - text of this book
390:25 - in a sense a likely second order goal of
390:28 - the book was to train programmers that
390:29 - might learn c
390:30 - and then might help build and maintain
390:32 - unix
390:33 - the 1978 edition of this textbook fits
390:36 - nicely into a series of att bell labs
390:39 - technic reports like the portability of
390:42 - c programs in the unix system written by
390:44 - stephen c johnson and dennis m ritchie
390:46 - published in the bell system technical
390:48 - journal volume 57 number six part two
390:52 - july through august 1978 pages
390:55 - 2021 through 2048.
390:58 - you can see this one online if you
391:00 - search for it
391:03 - back to the
391:04 - textbook the simplest illustration of
391:07 - the necessary declarations
391:09 - and use is in the program echo which
391:12 - simply echoes its command line arguments
391:14 - in a single line separated by blanks
391:17 - that is if the command echo hello comma
391:20 - world is given the output is hello comma
391:23 - world
391:24 - by convention arg v sub 0 is the name by
391:28 - which the program was invoked so argc is
391:30 - at least 1.
391:31 - in the above example argc is three and
391:34 - args arc v sub zero arc v sub one and
391:37 - args v sub two are echo
391:41 - hello comma and world respectively
391:45 - the first real argument is arc v sub 1
391:47 - and the last is
391:48 - arg v
391:50 - sub rxc minus 1
391:52 - and if argc is 1 there are no command
391:55 - line arguments after the program name
391:58 - this is shown in the source code to echo
392:00 - and this source code is on page 111 of
392:02 - the textbook and you can see this source
392:04 - code at www.cc4e.com
392:08 - code
392:10 - pound include stdio.h
392:13 - pound includes string.h
392:15 - main open paren argc comma arc fee close
392:18 - paren int argc semicolon char star argv
392:23 - open square bracket close square bracket
392:24 - semicolon
392:26 - open curly brace int i semicolon
392:29 - for open paren i equals one semicolon i
392:33 - less than rxc semicolon i plus plus
392:37 - close paren
392:39 - print f open paren
392:41 - double quote percent s percent c
392:45 - double quote comma
392:47 - arg v sub i
392:50 - comma
392:51 - open paren i less than r c minus one
392:54 - close paren question mark
392:56 - single quote space single quote colon
392:58 - single quotes
393:00 - backslash n single quote close
393:02 - parenthesis
393:03 - semicolon close curly brace to end it
393:07 - since argv is a pointer to an array of
393:10 - pointers there are several ways to write
393:12 - this program that involve manipulating
393:14 - the pointer rather than indexing an
393:16 - array
393:17 - let us show two variations and this is
393:19 - the example
393:20 - number two on page 111 of the textbook
393:24 - pawn include stdio.h pawn includes
393:27 - string.h
393:29 - main open paren rxc comma argv close
393:32 - paren
393:33 - int argc semicolon char star argv open
393:37 - square bracket close square bracket
393:39 - semicolon
393:40 - open curly brace
393:42 - while open paren minus minus arg c
393:45 - greater than zero close paren printf
393:48 - open paren double quote percent s
393:50 - percent c
393:51 - double quote comma star
393:55 - plus plus arg v comma open paren rxc
393:59 - greater than one close paren question
394:00 - mark single quote space single quote
394:03 - colon single quote backslash n single
394:06 - quote close paren semicolon
394:08 - close curly brace
394:10 - since
394:11 - arc v is a pointer to the beginning of
394:13 - an array of argument strings
394:15 - incrementing it by one plus plus rv
394:18 - makes it point to the at the original
394:21 - array arc v sub one instead of arc b sub
394:24 - zero
394:25 - each successive increment moves it along
394:27 - to the next argument
394:29 - star arc v is then the pointer to that
394:31 - argument
394:32 - at the same time argc is decremented and
394:35 - when it becomes zero there are no
394:37 - arguments left to print
394:40 - another version the third version on
394:43 - page 111 of the textbook
394:46 - pound include stdio.h pound includes
394:49 - string.h main open paren arg c com argv
394:53 - close paren
394:55 - int argc semicolon char star arc v open
394:59 - square bracket close square bracket
395:00 - semicolon open curly brace while
395:04 - open paren minus minus arg c greater
395:06 - than zero close paren
395:09 - print f open paren open paren argc
395:12 - greater than one close paren question
395:14 - mark double quote percent s blank double
395:17 - quote colon
395:19 - double quote percent s backslash n
395:22 - double quote comma
395:23 - star plus plus arg v close paren
395:26 - semicolon close curly brace
395:29 - this
395:30 - version so shows that the format
395:32 - argument of printf can be an expression
395:34 - just like any of the others this usage
395:37 - is not very frequent but worth
395:38 - remembering
395:40 - as a second example
395:43 - let's make some example enhancements to
395:45 - the pattern finding program from chapter
395:47 - 4.
395:48 - if you recall we wired the search
395:50 - pattern deep into the program
395:52 - and this is an obviously unsatisfactory
395:54 - arrangement for flexible code following
395:57 - the lead of the unix utility grep which
396:00 - stands for the generalized regular
396:02 - expression parser
396:04 - let us change the program so that the
396:06 - pattern to be matched is specified by
396:07 - the first argument on the command line
396:11 - this is example one on page 112 of the
396:13 - book which you can see at www.cc4e.com
396:18 - code
396:20 - pound include sddio.h
396:22 - pound includes string.h upon define max
396:25 - line 1000
396:27 - main open paren arg c comma arg v close
396:30 - paren int r c semicolon char star arc v
396:33 - open square bracket close square bracket
396:35 - semicolon open curly brace
396:37 - char line open open square bracket max
396:41 - line close square bracket semicolon
396:44 - if open paren argc not equal to close
396:47 - paren printf
396:48 - double quote usage colon find pattern
396:51 - backslash n
396:53 - double quote close paren semicolon else
396:56 - while open pren getline open print line
397:00 - comma max line close paren greater than
397:02 - zero close paren
397:03 - if
397:04 - index open paren line comma arg v
397:07 - sub 1 close paren greater than or equal
397:10 - to 0 close paren printf
397:13 - open paren double quote percent s double
397:16 - quote comma line close paren semicolon
397:19 - close curly brace
397:22 - the basic model can now be elaborated to
397:24 - illustrate further pointer constructions
397:26 - suppose we want to allow two optional
397:29 - arguments
397:30 - one says print all the lines except
397:33 - those that match the pattern
397:34 - the second says precede its print each
397:37 - printed line with its line number
397:40 - a common convention for c programs is
397:43 - that an argument beginning with a minus
397:45 - sign introduces an optional flag or
397:47 - parameter
397:48 - if we choose minus x for accept to
397:52 - signal the inversion and minus n number
397:55 - to request line numbering then the
397:57 - command find space minus x space minus n
398:01 - the with the input now is the time for
398:04 - all good men to come to the aid of their
398:07 - party should produce
398:09 - two comma for all good men
398:15 - optional arguments should be permitted
398:16 - in any order and the rest of the program
398:18 - should be insensitive to the number of
398:20 - arguments which were actually present
398:22 - in particular the call to index should
398:24 - not refer to arg v sub 2 where a single
398:27 - flag argument and to arc v sub 1 when
398:30 - there was no single flag furthermore
398:32 - it's convenient for users if option
398:35 - arguments can be concatenated and as in
398:38 - find space dash nx space the
398:43 - here is the program
398:46 - and this program is on
398:48 - page 113 of the textbook
398:51 - and it is complex enough that i suggest
398:53 - that you take a look at it at
398:55 - www.cc4e.com
398:59 - code
399:01 - it's it's about 35 lines long
399:05 - the commentary on the program hopefully
399:07 - now you're watching looking at it arc v
399:10 - is incremented before each optional
399:11 - argument and argc is decremented if
399:14 - there are no errors at the end of the
399:16 - loop arg c should be 1 and star argv
399:18 - should point to the
399:20 - point to the pattern
399:21 - note that
399:23 - star plus plus arc v is a pointer to an
399:26 - argument string
399:27 - open paren star plus plus arc v close
399:30 - paren
399:31 - open square bracket zero square square
399:33 - bracket
399:34 - is its first character the parentheses
399:37 - are necessary for without them the
399:39 - expression would be star plus plus open
399:41 - paren arg v sub subzero
399:44 - close paren which is quite different and
399:47 - wrong
399:48 - an alternate valid form would be star
399:51 - star
399:52 - plus plus arg v
399:55 - section 5.12 pointers to functions in c
399:59 - a function itself is not a variable but
400:01 - it is possible to define a pointer to a
400:03 - function which can be manipulated passed
400:06 - to functions placed in arrays and so on
400:09 - we will illustrate this by modifying the
400:11 - sorting procedure written earlier in
400:13 - this chapter so that if the optional
400:15 - argument minus n is given it will sort
400:18 - the input lines numerically instead of
400:20 - lexographically
400:21 - a sort often consists of three parts a
400:24 - comparison
400:25 - which determines the ordering of any
400:27 - pair of objects
400:29 - an exchange which reverses their order
400:31 - and a sorting algorithm which makes
400:33 - comparisons and exchanges until the
400:35 - objects are in order
400:37 - the sorting algorithm is independent of
400:39 - the comparison and exchange operations
400:42 - so by passing different comparison and
400:44 - exchange functions to it we can arrange
400:45 - to sort by different criteria this
400:48 - approach is taken in our new sort
400:51 - the lexigraphic comparison of the two
400:53 - lines is done by stir comp and swapping
400:55 - by swap as before
400:57 - we'll also need a routine num comp which
401:00 - compares two lines on the basis of
401:01 - numeric value and returns the same kind
401:04 - of condition indication as stir comp
401:05 - does
401:06 - these three functions are declared in
401:08 - main and pointers to them are passed to
401:10 - sort
401:11 - sort in turn calls the functions via
401:13 - pointers we have skimped on error
401:15 - processing processing for arguments so
401:17 - as to concentrate on the main issues
401:21 - this sample code is from page 115 of the
401:23 - textbook which you can view at
401:25 - www.cc4e.com
401:30 - code
401:32 - pound include stdio.h
401:34 - pawn include string.h pawn defined lines
401:37 - 100
401:38 - main open paren rxc comma arg v close
401:42 - current
401:43 - int argc semicolon
401:45 - char star arg fee open square bracket
401:48 - close square bracket semicolon open
401:50 - curly brace
401:52 - char star line ptr open for open bracket
401:57 - lines close square bracket semicolon
401:59 - this is the pointers to the text lines
402:01 - so we're going to be reading
402:03 - in the lines saving them and keeping an
402:05 - array of the pointer and then we're
402:06 - going to sort that way
402:08 - int n lines semicolon
402:10 - int stir comp open paren close print
402:13 - comma num comp
402:14 - open paren close paren which are
402:16 - comparison functions
402:19 - and swap open paren close print
402:21 - semicolon int numeric equals zero and
402:24 - this is going to be one if it's a
402:25 - numeric sort
402:27 - first we parse the arguments
402:30 - if open paren arg c greater than one
402:32 - ampersand ampersand arg v sub one sub
402:35 - zero equal equal
402:37 - quote minus quote
402:39 - and arg v opens bracket one close
402:42 - bracket open bracket one close bracket
402:45 - double equals quote end quote close
402:48 - paren numeric equals one
402:53 - if open paren open paren n lines equals
402:56 - read lines open paren line ptr comma
402:58 - lines close paren close paren greater
403:00 - than or equal to zero close paren open
403:03 - curly brace
403:05 - if open paren numeric close paren sort
403:08 - open print line ptr n lines num comp
403:11 - comma swap close paren semicolon else
403:15 - sort open print line ptr
403:17 - comma n lines
403:19 - comma stir comp comma swap close paren
403:22 - write lines line pr ptr comma n lines
403:25 - close paren
403:27 - close curly brace else print f open
403:30 - paren double quote input too big to sort
403:33 - backslash n
403:35 - double quote close paren semicolon
403:39 - stir comp num comp and swap are
403:42 - addresses of functions
403:43 - since they're known to be functions the
403:45 - ampersand operator is not necessary in
403:48 - the same way that it is not needed
403:50 - before an array name
403:51 - the compiler arranges for the address of
403:54 - the function to be passed
403:56 - the second step is to modify our sort
403:58 - function
404:00 - and this is the first example on page
404:02 - 116 of the textbook
404:05 - sort open paren v comma n comma comp
404:09 - comma e x c h exchange
404:12 - close paren
404:14 - char
404:15 - star v open square bracket close work
404:18 - square bracket
404:19 - semicolon that's our pointer
404:23 - array of pointers
404:24 - int
404:25 - and semicolon
404:28 - int open friends start comp
404:31 - close paren open print close paren comma
404:34 - open paren star exchange
404:36 - close paren open prayer and close paren
404:38 - semicolon that declared the
404:41 - type and the fact that these are
404:42 - pointers to functions it's a little more
404:44 - complex here in the called code
404:49 - open curly brace int gap comma i comma j
404:52 - semicolon
404:54 - and now we're going to do the three
404:56 - nested for loops for the
404:58 - quick sort no shell sort
405:01 - um
405:02 - and then the only really change is in
405:04 - the code checking to see if the
405:07 - uh two items pair of items are out of
405:09 - order and then what we do so
405:11 - four open paren gap equals n over two
405:14 - semicolon cap greater than zero
405:16 - semicolon graph gap slash equals two
405:19 - close paren
405:21 - for open print i equals gap semicolon i
405:24 - less than n semicolon i plus plus closed
405:26 - paren
405:28 - four open paren j equals i minus gap
405:31 - semicolon j greater than or equal to
405:33 - zero semicolon j minus equals gap close
405:36 - paren open curly brace and now here
405:39 - starts the different code
405:41 - if open print open print star comp
405:44 - close print
405:46 - open paren v sub j comma v sub j plus
405:49 - gap
405:50 - close paren less than or equal to zero
405:54 - close paren break
405:57 - open print star ex exchange
406:00 - close prin open print ampersand v sub j
406:04 - comma ampersand v sub j plus gap
406:09 - close paren semicolon close curly brace
406:12 - for the for loop and then close curly
406:14 - brace
406:15 - for the sort function
406:17 - and so really all we're doing is we're
406:19 - checking the order of the two items b
406:22 - sub j and b sub j plus gap
406:24 - and if they're out of order i.e less
406:26 - than or equal to zero i mean greater
406:28 - than or equal to uh greater than zero
406:31 - then we just exchange them with the
406:33 - provided exchange function and so the
406:34 - key thing here is it looks exactly like
406:36 - the previous time we wrote this code
406:38 - except we're calling
406:39 - the pointer to the comparison function
406:41 - and the pointer to the exchange function
406:44 - which
406:45 - is makes this flexible
406:47 - so it can handle different kinds of data
406:51 - back to the textbook
406:54 - the declaration should be studied with
406:55 - some care
406:57 - int open paren star comp close paren
407:00 - open paren close paren says that comp
407:03 - is a pointer to a function that returns
407:06 - an int
407:07 - the first set of parentheses are
407:09 - necessary without them int star comp
407:12 - open prank close paren
407:14 - would say that comp is a function
407:16 - returning a pointer to an end which is a
407:18 - quite different thing
407:20 - the use of comp in the line if open
407:23 - paren open paren star com close paren
407:26 - open print v
407:27 - sub j comma v sub j plus gap close print
407:31 - less than or equal to zero close paren
407:34 - is consistent with the declaration
407:36 - comp is a pointer to the function and
407:38 - star comp is the function
407:41 - and
407:42 - open paren star comp close paren
407:45 - open paren v sub j comma v sub j plus
407:48 - gap close
407:49 - paren is the call to it the parentheses
407:52 - are needed so the components are
407:54 - correctly associated
407:56 - we've only we've already shown stir comp
407:59 - which compares two strings
408:00 - here is num comp which compares two
408:03 - strings on a leading numeric value
408:06 - this is sample code from page 117 of the
408:08 - textbook
408:09 - which you can
408:11 - see at www.cc4e.com
408:15 - code
408:16 - numcomp open paren s1 comma s2 close
408:20 - paren char star s1 comma star s2
408:23 - semicolon
408:25 - open curly brace double a to f open
408:28 - frame close paren comma v1 comma v2
408:32 - v1 equals a to f open paren s1 close
408:35 - paren
408:36 - semicolon v2 equals a to f open print s2
408:40 - close paren semicolon if
408:43 - open paren v1 less than v2 close print
408:46 - return open print -1
408:48 - else if open print v1 greater than v2
408:52 - close paren return open print 1 close
408:55 - paren semicolon else
408:57 - return open paren
409:00 - 0 close paren semicolon close curly
409:02 - price
409:05 - the final step is to add the function
409:07 - swap which exchanges the two pointers
409:09 - this is adapted directly from what we
409:11 - presented earlier in the chapter
409:14 - swap open paren px comma py close paren
409:18 - char star px
409:20 - open square bracket close square bracket
409:22 - comma star py open square bracket close
409:25 - square bracket semicolon
409:27 - open curly brace char star temp
409:30 - semicolon
409:31 - temp equals star px semicolon star px
409:34 - equals star py semicolon star py equals
409:38 - temp semicolon close curly brace
409:41 - there are a variety of other options
409:43 - that can be added to the sorting program
409:46 - some make challenging exercises
409:48 - [Music]
409:50 - this work
409:52 - is based on the 1978 c programming book
409:55 - written by brian w kernighan and dennis
409:57 - m ritchie
409:58 - their book is copyright all rights
410:00 - reserved by at t
410:02 - but is used in this work under fair use
410:04 - because of the book's historical and
410:06 - scholarly significance
410:08 - its lack of availability and the lack of
410:10 - an accessible version of the book
410:12 - the book is augmented in places to help
410:14 - understand its rightful place in a
410:16 - historical context amidst the major
410:18 - changes of the 1970s and 1980s as
410:22 - computer science evolved from a
410:23 - hardware-first vendor-centered approach
410:26 - to a software-centered approach where
410:28 - portable operating systems and
410:29 - applications written in c could run on
410:31 - any hardware
410:33 - this is not the ideal book to learn c
410:35 - programming because the 1978 edition
410:38 - does not reflect the modern c language
410:40 - using an obsolete book gives us an
410:42 - opportunity to take students back in
410:44 - time and understand how the c language
410:47 - was evolving as it laid the groundwork
410:49 - for a future with portable applications
410:55 - chapter 6 structures
410:57 - a structure is a collection of one or
410:59 - more variables possibly of different
411:01 - types grouped together under a single
411:03 - name for convenient handling
411:05 - while we talk about data structures and
411:07 - how to use them in every language
411:09 - this section is about understanding how
411:11 - software developers carefully control
411:13 - the low level shape of their data items
411:15 - to solve their problems
411:17 - when you first learn about the c struct
411:19 - keyword you might think it's equivalent
411:20 - to a python dict
411:22 - a dynamic key value store like a php
411:24 - array java myapp or javascript object
411:27 - but nothing is further from the truth
411:29 - these other languages provide us with
411:31 - easy to use data structures where all
411:33 - the challenging problems are solved
411:36 - this chapter tells or told the creators
411:40 - of python php java and javascript how to
411:43 - solve the complex problems and build
411:45 - convenient and flexible data structures
411:47 - which we now all use in those
411:49 - object-oriented languages
411:51 - one way to look at this code in this
411:53 - chapter is to think of it as a lesson on
411:55 - how one might build python's list and
411:58 - dict data structures
412:00 - if the code in the chapter takes you a
412:02 - little while to figure out
412:04 - mentally make a note of thanks for all
412:06 - the hard work that modern languages
412:09 - invest to make their high level data
412:11 - structures flexible and easy to use
412:14 - back to the textbook
412:16 - the traditional example
412:18 - of a structure is a payroll record an
412:21 - employee is described as a set of
412:22 - attributes such as name address social
412:24 - security number salary etc
412:26 - some of these in turn could be
412:28 - structures a name has several components
412:30 - as does an address and even a salary
412:33 - structures help organize complicated
412:35 - data particularly in large programs
412:38 - because in many situations they permit a
412:40 - group of related variables to be treated
412:42 - as a unit
412:43 - instead of separate entities in this
412:45 - chapter we'll try to illustrate how
412:47 - structures are used
412:48 - the programs that we will use are bigger
412:50 - than many others in the book but are
412:52 - still of modest size section 6.1 basics
412:56 - let us revisit the date conversion
412:58 - routines of chapter 5.
413:00 - a date consists of several parts such as
413:02 - the day month and year and perhaps the
413:04 - day of the year and the month name
413:06 - these five variables can all be placed
413:09 - in a single structure like this
413:11 - struct
413:12 - date open curly brace
413:15 - in day semicolon in month semicolon in
413:19 - int year semicolon and year day
413:21 - semicolon char
413:23 - mun name
413:25 - open square bracket for closed square
413:26 - bracket semicolon curly brace semicolon
413:30 - the keyword struct introduces a
413:32 - structure declaration which is a list of
413:34 - declarations
413:36 - enclosed embraces an optional name
413:39 - called the structure tag may follow the
413:40 - word struct as with date here the tag
413:43 - names this kind of a structure and can
413:46 - subsequently be used as shorthand for
413:48 - the detailed declaration
413:50 - the elements or variables mentioned in a
413:52 - structure are called its members
413:54 - a structure member or tag and ordinary
413:58 - ie non-member variable can have the same
414:00 - name without conflict since they are
414:02 - always distinguished by context
414:05 - of course as a matter of style one would
414:07 - normally use the same names only for
414:09 - closely related objects
414:12 - the right brace that terminates the list
414:14 - of members may be followed by a list of
414:16 - variables just as for any basic type
414:19 - that is struct open curly brace dot dot
414:22 - dot close curly brace
414:24 - x comma y comma z semicolon
414:27 - is syntactically analogous to int
414:30 - x comma y comma z semicolon in the sense
414:33 - that each statement declares x y and z
414:36 - to be variables of the named type and
414:38 - causes space to be allocated for them
414:41 - a structured declaration that is not
414:43 - followed by a list of variables
414:45 - allocates no storage it merely describes
414:47 - a template or the shape of the structure
414:50 - if the declaration is tagged however the
414:52 - tag can be used in later definitions of
414:54 - the actual instances of the structure
414:57 - for example given the declaration of
414:59 - date above
415:01 - struct date d
415:03 - defines a variable d which is a
415:05 - structure of type
415:06 - date an external or static structure can
415:09 - be initialized by the following by
415:11 - following its definition with a list of
415:12 - initializers for the components
415:15 - struct date d
415:18 - equals open curly brace 14 comma 7 comma
415:21 - 1776 comma 186 comma double quote j u l
415:26 - double quote close curly brace semicolon
415:30 - a member of a particular structure
415:32 - is referred to in an expression by
415:34 - construction of the form structure name
415:37 - dot member
415:39 - the structure member operator dot
415:41 - connects the structure name in the
415:43 - member name to set leap from the date in
415:46 - structure d for example
415:48 - leap equals d dot year modulo four
415:51 - double equals zero
415:53 - and d dot year modulo 100 not equal to
415:56 - zero or d dot year modulo 400
416:00 - double equal zero semicolon
416:03 - or to check the month name
416:05 - if open paren stir comp
416:07 - open paren d dot mun name comma
416:10 - double quote aug double quote close
416:13 - paren double equals zero
416:15 - close paren dot dot
416:17 - or to convert the first character of the
416:19 - month named lower case
416:21 - d dot mon name sub zero equals lower
416:25 - open paren d dot name sub zero close
416:28 - paren semicolon
416:32 - structures may be nested a payroll
416:34 - record might actually look like struct
416:36 - person open curly brace char name open
416:40 - square bracket name size close square
416:42 - bracket semicolon char address open
416:44 - square bracket adder size
416:46 - close square bracket semicolon long zip
416:49 - code semicolon
416:51 - long ss number semicolon double salary
416:55 - struct date birth date semicolon struct
416:58 - date hire date
417:00 - semicolon close curly brace semicolon
417:04 - the person structure contains two dates
417:07 - if we declare emp as struct person amp
417:11 - semicolon then emp.birthdate.month
417:15 - refers to the month of birth
417:18 - the structure member operator
417:20 - dot associates left to right
417:23 - section 6.2 structures and functions
417:27 - there are a number of restrictions on c
417:29 - structures the essential rules are that
417:31 - only operations you can perform on a
417:33 - structure are to take its address with
417:35 - ampersand and access one of its members
417:38 - this implies that structures may not be
417:40 - assigned or copied to as a unit and that
417:43 - they cannot be passed or returned
417:45 - from functions
417:47 - these restrictions will be removed in
417:49 - forthcoming versions furnace
417:50 - destructures do not suffer these
417:52 - limitations however so structures and
417:54 - functions do work together comfortably
417:56 - finally automatic structures like
417:59 - automatic arrays cannot be initialized
418:01 - only external or static structures can
418:04 - this prediction was indeed accurate
418:06 - modern c compilers do support the
418:07 - copying of a structure with a single
418:09 - assignment statement given that a c
418:11 - structure is just a fixed length block
418:13 - of memory it's easy easy to generate
418:15 - machine code to copy it a key bit to
418:17 - remember that when the c structure is
418:19 - copied it is done as a shallow copy
418:22 - a shallow copy copies the values of the
418:24 - variables and the pointers in the
418:25 - structure but does not make copies of
418:27 - any data which the pointers point to
418:30 - a structure that contains other
418:32 - structures i.e not pointers to
418:34 - structures and those structures are
418:36 - shallow copied as well
418:38 - back to the text
418:40 - let us investigate some of these points
418:42 - by rewriting the date conversion
418:44 - functions in the last chapter to use
418:45 - structures since the rules prohibit
418:47 - passing of a structure to a function
418:49 - directly we must either pass the
418:51 - component separately or pass a pointer
418:53 - to the whole thing
418:55 - the first
418:56 - alternative uses of de avere which as we
418:58 - wrote in chapter 5
419:01 - d year day equals
419:03 - day of year open for n d year comma d
419:07 - dot month comma d dot day close paren
419:10 - semicolon
419:11 - the other way is to pass a pointer if
419:13 - we've declared higher date as struct
419:16 - date higher date semicolon and rewritten
419:18 - day of year we could then say
419:20 - higherdate.year day equals day of year
419:22 - open paren ampersand higher date close
419:25 - paren semicolon
419:27 - to pass a pointer to higher date to day
419:29 - of year the function has to be modified
419:31 - because its argument is now a pointer
419:33 - rather than a list of variables
419:36 - this example code is on page 122 of the
419:39 - textbook and you can see it at
419:41 - www.cc4e.com
419:44 - code
419:46 - struct date open curly brace
419:48 - int day semicolon int month semicolon
419:53 - in
419:54 - ear semicolon int year day semicolon and
419:58 - mun name open square bracket four close
420:00 - spread square bracket
420:02 - semicolon closed curly brace semicolon
420:06 - static int day tab
420:08 - open square bracket two close square
420:10 - bracket open square bracket 13 close
420:12 - square bracket equals open curly brace
420:15 - open curly brace zero come at 31 come at
420:18 - 28 come a 31 come a 30 come at 31 come
420:20 - with 30 come a 31
420:22 - 31 come a 30
420:24 - come a 31 come a 30 31 close curly brace
420:28 - comma and then another list just as long
420:30 - as that co with a closed curly brace and
420:33 - a semicolon that just initialized the
420:36 - lookup table for the days in each month
420:39 - now on to the function
420:41 - day of year open paren pd close paren
420:44 - struct date star pd semicolon open curly
420:48 - brace
420:49 - and i come a day come a leap semicolon
420:53 - day
420:54 - equals pd
420:56 - minus
420:57 - greater than day semicolon
421:00 - leap equals pd minus greater than year
421:04 - percent for double equals zero
421:07 - and
421:08 - pd
421:09 - minus greater than year percent 100 not
421:12 - equal to zero
421:14 - or
421:15 - pd
421:16 - minus greater than year percent 400
421:19 - double equal zero semicolon
421:23 - four open paren i equals one semicolon i
421:26 - less than pd
421:28 - minus greater than month semicolon i
421:31 - plus plus close paren
421:33 - day plus equals day tab
421:37 - open square bracket leap close square
421:39 - bracket open square bracket i close
421:41 - square bracket semicolon
421:43 - return open paren day close paren
421:46 - semicolon close curly brace
421:50 - the
421:50 - declaration struct date star pd says
421:53 - that pd is a pointer to a structure of
421:56 - type date
421:57 - the notion exemplified by pd
422:00 - minus
422:01 - greater than year
422:03 - i think i'll call that at this point pd
422:06 - right arrow because that's really what
422:07 - it is it's the minus greater than looks
422:09 - like an arrow to the right so i'm going
422:11 - to call it right arrow but it's really
422:12 - two characters
422:14 - pd right arrow year is new
422:17 - if p is a pointer to a structure then pd
422:20 - right arrow member of structure refers
422:22 - to the particular
422:24 - member the operator right arrow is a
422:27 - minus sign followed by a greater than
422:30 - since pd points to the structure the
422:32 - year member could also be referenced as
422:35 - open paren star pd closed paren dot ear
422:39 - but pointers to structures are so
422:41 - frequently used that the right arrow
422:43 - notation is provided both
422:45 - as a convenient shorthand the
422:47 - parentheses are necessary in open paren
422:50 - star pd close paren dot ear because the
422:52 - precedence of the structure member
422:54 - operator dot is higher than
422:57 - the pointer lookup operator asterisk
422:59 - both right arrow and dot associate to
423:02 - left from left to right so
423:05 - p right arrow q right arrow mem
423:09 - and
423:10 - emp dot birthdate dot month r open paren
423:14 - p right arrow q close paren right arrow
423:17 - mem and open parent emp dot birth date
423:20 - close paren dot month
423:22 - for completeness here is the other
423:25 - function month day rewritten to use the
423:27 - structure
423:29 - this is the first example on page 123 of
423:31 - the text which you can look at the
423:33 - source code at www.cc4e.com
423:36 - code
423:38 - i won't read the struct and the date the
423:40 - destruct date definition in the struct
423:42 - in
423:43 - static in day tab definition we'll just
423:45 - go month day
423:47 - month day open paren pd close paren
423:50 - struct date star pd semicolon
423:53 - open curly brace
423:55 - end i comma leap
423:58 - semicolon
423:59 - leap equals pd right arrow year
424:03 - percent four double equals zero and pd
424:05 - right arrow year percent 100 not equal
424:08 - to zero or pd right arrow year
424:11 - percent 400 double equals 0 semicolon
424:15 - pd right arrow day equals pd right arrow
424:18 - year day
424:20 - four open print i equals one semicolon
424:24 - pd right arrow day greater than day tab
424:27 - subleap sub i semicolon
424:30 - i plus plus close paren
424:32 - pd right arrow day minus equals
424:35 - day tab subleap sub i semicolon
424:39 - pd right arrow month equals i semicolon
424:43 - close curly brace
424:46 - the structure operators
424:48 - right arrow and dot together with
424:50 - parentheses for argument lists and
424:52 - square brackets for subscripts are the
424:54 - top of the precedence hierarchy and then
424:56 - thus bind very tightly
424:59 - for example given the declaration struct
425:01 - open curly brace
425:03 - int x int star y
425:06 - semicolon close
425:08 - curly brace star p semicolon then
425:12 - plus plus p right arrow x increments x
425:16 - not p
425:18 - because the implied parenthesization is
425:20 - plus plus open paren p right arrow x
425:23 - close paren
425:24 - parentheses can be used after the
425:26 - binding
425:27 - open paren plus plus p
425:30 - right arrow x increments p before
425:32 - accessing x and open paren p plus plus
425:36 - close paren right arrow x increments p
425:38 - afterward
425:39 - the last set of parentheses is
425:41 - unnecessary
425:43 - in the same way star p right arrow y
425:46 - fetches whatever y points to star
425:50 - p right arrow y plus plus increments y
425:53 - after what
425:55 - after accessing whatever it points to
425:57 - just like star s plus plus
426:00 - open paren star p
426:02 - right arrow y
426:04 - close paren plus plus increments
426:06 - whatever y points to and star p
426:10 - plus plus right arrow y
426:12 - increments p after accessing whatever y
426:15 - points to
426:17 - section 6.3 arrays of structures
426:21 - structures are especially suitable for
426:23 - managing arrays of related variables
426:26 - for instance consider a program to count
426:28 - the occurrences of each c keyword
426:31 - we need an array of character strings to
426:32 - hold the names and an array of integers
426:34 - to hold the counts
426:36 - one possibility is to use two parallel
426:39 - arrays keyword and key count as in
426:42 - char star keyword open square bracket n
426:45 - keys close square bracket semicolon
426:48 - int key count open square bracket n keys
426:51 - close square bracket semicolon but the
426:53 - very fact that the arrays are parallel
426:55 - indicates a different organization is
426:57 - possible
426:58 - each keyword entry is really a pair
427:01 - char star keyword semicolon
427:03 - int key count semicolon and there's an
427:06 - array of the pairs
427:08 - the structure declaration struct key
427:11 - open curly brace char star keyword
427:13 - semicolon int key count semicolon close
427:16 - curly brace key tab open square bracket
427:19 - n keys close square bracket semicolon
427:23 - defines an array key tab of structures
427:24 - of this type and allocate storage to
427:26 - them each element of the array is a
427:28 - structure this could also be written
427:31 - struct key open curly brace char star
427:35 - keyword semicolon int key count
427:38 - semicolon
427:39 - close curly brace semicolon
427:41 - struct key key tab open square bracket
427:44 - and keys close square bracket semicolon
427:49 - since the structure key tab actually
427:51 - contains a constant set of names it's
427:52 - easiest to initialize it once and for
427:54 - all when it's defined
427:56 - the structural initialization is quite
427:57 - analogous to the earlier ones the
427:59 - definition is followed by a list of
428:00 - initializers and closed embraces
428:04 - struct key open curly brace char star
428:07 - keyword semicolon int key count
428:10 - semicolon close curly brace
428:13 - key tab open square bracket close square
428:15 - bracket equals open curly brace
428:17 - double quote break comma 0 comma double
428:21 - quote case comma 0 comma double quote
428:24 - char comma 0 comma
428:27 - and so forth
428:28 - down to double quote unsigned double
428:30 - quote comma 0 comma double quote while
428:34 - double quote comma 0
428:36 - closed curly brace semicolon
428:39 - these
428:41 - initializers are listed in pairs
428:43 - corresponding to the structure members
428:45 - it would be more precise to enclose
428:47 - initializers for each row or structure
428:49 - in the braces as in
428:51 - open curly brace double quote break
428:53 - double quote comma zero close curly
428:56 - brace comma open curly brace double
428:58 - quote case double quote comma zero
429:02 - close curly brace comma and so forth
429:05 - but the inner braces are not necessarily
429:07 - when the initializers are simple
429:08 - variables or character strings and when
429:10 - all are present
429:12 - as usual the compiler will compute the
429:14 - number of entries in the array key tab
429:15 - if the initializer is present and the
429:17 - open square bracket close square bracket
429:19 - is left
429:20 - empty the keyword counting program which
429:23 - begins with a definition of key tab the
429:26 - main routine reads the input repeatedly
429:27 - by calling a function get word that
429:30 - fetches input one word at a time each
429:32 - word is looked up in key tab
429:35 - with a version of binary the binary
429:36 - search function we wrote in chapter
429:38 - three
429:39 - of course the list of keywords has to be
429:41 - given in increasing order for this to
429:43 - work
429:45 - here is the first example on page 125 of
429:49 - the textbook
429:50 - you can see this
429:53 - at www.cc4e.com
429:56 - code
429:58 - pound include stdio.h
430:01 - pound define max word 20
430:05 - pound defined letter quote a quote
430:08 - main open prem close paren open curly
430:11 - brace
430:12 - int n comma t semicolon
430:15 - char word open square bracket max word
430:18 - close square bracket semicolon
430:21 - while open paren open print t equals get
430:24 - word open paren word comma max word
430:27 - close paren close paren not equal eof
430:29 - close paren
430:31 - if open friend t double equal letter
430:34 - close paren
430:35 - if double
430:37 - open paren open paren n equals
430:40 - binary open paren word come a key tab
430:42 - comma n keys close paren close paren
430:44 - greater than or equal to zero
430:46 - close paren
430:47 - key tab sub n dot key count plus plus
430:52 - four open paren n equals zero semicolon
430:57 - and less than n keys semicolon and plus
430:59 - plus
431:00 - if open open paren key tab sub n dot key
431:03 - count greater than zero close paren
431:06 - print f
431:08 - double quote percent for d space percent
431:10 - s backslash n double quote comma
431:13 - key tab sub n dot key count comma key
431:17 - tab sub n dot keyword close paren
431:20 - semicolon and then a closed curly brace
431:22 - to finish main
431:25 - binary
431:26 - to find the word in the in the table
431:29 - binary open paren word comma tab comma n
431:32 - close paren
431:33 - char star word
431:35 - semicolon struct key tab open square
431:38 - bracket close work square bracket
431:40 - semicolon
431:41 - int n
431:43 - open curly brace
431:44 - int low comma high comma mid comma cond
431:48 - low equals zero semicolon high equals n
431:51 - minus one semicolon
431:53 - while open paren low less than or equal
431:56 - to high close paren open curly brace
431:59 - mid equals paren low plus high close
432:02 - paren over to
432:05 - semicolon
432:06 - if
432:07 - open paren open paren conned equals stir
432:10 - comp open paren word
432:12 - comma tab comma open square bracket mid
432:15 - close square bracket dot keyword close
432:17 - print close friend less than zero close
432:19 - paren hi
432:21 - equals mid minus one semicolon else if
432:25 - open paren con
432:27 - greater than zero close paren low equals
432:29 - mid plus one semicolon else
432:32 - return open paren mid close paren
432:34 - semicolon
432:35 - close curly brace to finish the while
432:37 - and then return open paren minus one
432:39 - close paren semicolon
432:42 - close curly brace and that's really a
432:43 - rewrite of the binary function
432:46 - from the earlier part where we're just
432:49 - taking the keyword and count and
432:53 - and look in and looking up in the array
432:56 - but then using the dot keyword to find
432:58 - the actual keyword
433:00 - back to the text we'll show function get
433:03 - word in a moment for now it suffices to
433:05 - say it returns letter each time it finds
433:07 - a word and copies the word into its
433:10 - first argument
433:11 - the quantity n keys is the number of
433:13 - keywords in key tab although we could
433:15 - count this by hand it's a lot easier and
433:17 - safer to do it by machine especially if
433:20 - the list is subject to change
433:22 - one possibility would be to terminate
433:24 - the list of initializers with a null
433:25 - pointer and then the loop along key tab
433:27 - just runs until the end is found
433:30 - but this is more than as needed since
433:32 - the size of the array is completely
433:34 - determined at compile time the number of
433:37 - entries is just the size of key tab
433:39 - divided by the size of the struct key
433:43 - c provides a compile time op unary
433:46 - operator called sizeof which can be used
433:48 - to compute the size of any object
433:51 - the expression size of open paren object
433:54 - close paren yields an integer equal to
433:56 - the size of the specified object
433:59 - the size is given in unspecified units
434:01 - called bytes which are the same size as
434:04 - a char closed paren
434:07 - the object can be an actual variable or
434:08 - an array or structure or the name of a
434:11 - basic type like int or double or the
434:13 - name of a derived type like a structure
434:15 - in our case the number of keywords is
434:18 - the array size
434:19 - divided by the size of one array element
434:22 - and this computation is used in a pound
434:24 - define statement to set the value of n
434:26 - keys
434:28 - pound define n keys
434:30 - open paren size of open or print key tab
434:33 - close print
434:34 - divided by size of open paren struct key
434:38 - close paren close paren
434:41 - now for the function get word we have
434:43 - actually written a more general get word
434:45 - than is necessary for this program
434:47 - but it is not really much more
434:49 - complicated
434:50 - get word returns the next word from the
434:52 - input where a word is either a string or
434:55 - of letters or digits beginning with a
434:57 - letter or a single character the type of
434:59 - the object that is is the returned
435:01 - function as a function value
435:04 - it is the letter if the token is a word
435:06 - eof render file or the character itself
435:09 - if it's non-alphabetic
435:13 - this sample code is on page 127 of the
435:15 - textbook which you can see at
435:17 - www.cc4e.com
435:20 - code
435:22 - pound define letter quote a quote pound
435:25 - defined digit quote zero quote
435:27 - get word open paren w comma limb close
435:31 - paren
435:32 - char
435:33 - star w
435:34 - colon semicolon
435:36 - int lim semicolon open curly brace int c
435:41 - comma t semicolon
435:43 - if open paren type open paren c equals
435:47 - star w plus plus equals get ch open
435:50 - paren close paren close paren not equal
435:53 - letter close print open curly brace
435:56 - start w
435:58 - equals quote backslash zero quote
436:00 - semicolon
436:02 - return open for nc close paren semicolon
436:05 - close curly brace
436:07 - that if statement has got some stuff
436:09 - going on in it you might want to look at
436:10 - it very closely
436:12 - while open paren minus minus limb
436:15 - greater than zero close paren open curly
436:18 - brace
436:18 - t
436:19 - equals type open friend c
436:21 - equals star w
436:23 - plus plus equals get ch open paren close
436:26 - paren
436:27 - close point semicolon
436:29 - if if open friend t not equal letter and
436:33 - t not equal digit close paren
436:36 - open curly brace unget ch open paren c
436:39 - close paren semicolon
436:42 - break semicolon close curly brace star
436:45 - open paren w minus one close paren
436:48 - equals quote backslash zero quote
436:51 - semicolon
436:52 - return open paren letter close paren
436:55 - semicolon
436:56 - close curly brace close curly brace
437:00 - that that example code
437:02 - has a lot of stuff about pointers and
437:04 - incrementing pointers and dereferencing
437:05 - pointers etc so take a good look at that
437:08 - code
437:10 - back to the text
437:11 - get word uses the routines get ch and
437:13 - unget ch which we wrote in chapter 4.
437:16 - when the collection of alphabetic of an
437:18 - alphabetic token stops get word has gone
437:20 - one character too far that call to unget
437:23 - ch pushes that character back on the
437:25 - input for the next call
437:27 - getword calls another function called
437:29 - type to determine the type of each
437:30 - individual character for input
437:32 - here is a version that's only for ascii
437:36 - this code is the second example on page
437:38 - 127 of the textbook at www.cc4e.com
437:44 - code
437:46 - type open paren c close paren in c
437:50 - semicolon
437:51 - yeah open curly brace if
437:53 - open paren c greater than or equal to
437:55 - quote a quote and c less than or equal
437:58 - to quote z quote or
438:01 - c greater than or equal to quote
438:03 - uppercase a quote and c less than or
438:05 - equal to
438:06 - quote uppercase z quote close paren
438:09 - return
438:10 - letter semicolon
438:13 - else if open paren c greater than or
438:15 - equal to quote zero quote and c less
438:18 - than or equal to quote nine quote close
438:19 - paren return open friend digit close
438:22 - paren semicolon
438:24 - else
438:25 - return open paren c close paren
438:28 - semicolon
438:29 - close curly brace
438:31 - the symbolic constants letter and digits
438:34 - can have any values that do not conflict
438:36 - with
438:36 - non-alphanumeric values and eof the
438:39 - obvious choices are
438:41 - quote a quote and quote zero quote
438:44 - get word can be faster if calls to the
438:46 - function type are replaced by references
438:48 - to the appropriate array type the
438:50 - standard c library provides macros like
438:53 - is alpha and is digit which operate in
438:55 - this manner
438:57 - section 6.4 pointers to structures
439:00 - to illustrate some of the considerations
439:02 - involved with pointers and arrays of
439:04 - structures let us write a keyword
439:06 - counting program again
439:08 - this time using pointers instead of
439:10 - array indices
439:12 - as an aside i would note that it's a
439:14 - classic early assignment in any
439:16 - programming language to do a word
439:17 - frequency program here is a python
439:19 - program from my python for everybody
439:21 - course to count words from an input
439:23 - stream
439:24 - handle
439:25 - equals open
439:27 - open parenthesis single quote romeo dot
439:29 - txt close single quote comma quote r
439:32 - quote close parenthesis
439:34 - words equals handle dot read open print
439:37 - close print dot split open friend close
439:39 - paren
439:40 - counts equals dict open paren close
439:43 - paren
439:44 - four word in words colon
439:48 - counts subword equals
439:51 - get open paren word comma zero close
439:54 - paren plus one print open parent counts
439:57 - close paren
439:58 - this section in this book implements a
440:01 - less general word counting program in c
440:04 - the code depends on several functions
440:05 - from earlier in the book and the code
440:07 - below is pretty complex where the
440:09 - programmer only has access to low-level
440:11 - language without powerful and
440:12 - easy-to-use data types like python's
440:14 - list or dict
440:16 - it is likely that keto van rossen read
440:18 - this book took a long look at this code
440:21 - and designed the dick data structure in
440:22 - python so the rest of us can write a
440:25 - data parsing and word frequency
440:26 - programming program in the above six
440:29 - lines of code without worrying about
440:31 - dynamic memory allocation pointer
440:33 - management string length and a myriad of
440:35 - other details that must be solved when
440:37 - you're solving this program in c
440:41 - since python is open source you can
440:43 - actually look at the c code that
440:45 - implements the dict object in a file
440:47 - called dict object dot c
440:49 - it is almost 6 000 lines of code and
440:51 - includes other files or utility code
440:55 - there thankfully we only have to write
440:57 - one line of python to use it counts
440:59 - equals dict open friend close paren
441:02 - we will leave the complex bits to the c
441:04 - programmers that build and maintain
441:07 - this section is not showing us how to
441:09 - use the python dict object
441:11 - rather it is showing how one would build
441:13 - a dick like structure using c
441:18 - so
441:18 - continuing with section 6.4 pointers to
441:21 - structures
441:23 - the external definition of key tab do
441:25 - not need to change but main and binary
441:27 - do need modification this is
441:30 - example on page 129 of the textbook
441:34 - and that is available at www.cc4e.com
441:38 - code
441:42 - pointer version of counting c keywords
441:45 - main open paren close paren open curly
441:47 - brace int t semicolon
441:50 - char word open square bracket max word
441:52 - close square bracket semicolon struct
441:55 - key star binary open paren close paren
441:58 - comma star p semicolon
442:01 - while open paren open paren t equals get
442:04 - word open paren word comma max word
442:06 - close paren close paren
442:08 - not equal e o f close paren
442:11 - if open print t equal equal letter close
442:15 - paren
442:16 - if open paren open paren b equals binary
442:19 - open paren word comma key tab comma n
442:22 - keys close paren close paren not equal
442:25 - null close paren
442:26 - p right arrow key count plus plus
442:30 - for p equals key tab p less than key tab
442:34 - plus n keys semicolon p plus plus close
442:37 - parenthesis
442:38 - if open paren p right arrow key count
442:41 - greater than zero
442:42 - close paren printf
442:44 - open paren
442:46 - double quote percent for d space percent
442:48 - s backslash n
442:50 - double quote comma
442:52 - p right arrow key count comma p right
442:55 - arrow keyword
442:58 - and now we look at the binary search
443:04 - struct key star binary open paren word
443:07 - come tab comma n close paren
443:10 - char star word struct key tab open
443:13 - square bracket close square bracket
443:15 - semicolon
443:16 - int n
443:18 - open curly brace
443:20 - int cond semicolon
443:22 - struct key star low equals ampersand tab
443:26 - sub zero
443:27 - semicolon struct key star high equals
443:30 - ampersand tab sub n minus one semicolon
443:34 - struct key equals mid
443:38 - while open paren low less than or equal
443:40 - to high close paren open curly brace
443:43 - mid equals low plus high minus low
443:48 - divided by 2.
443:50 - if open paren open for n cond
443:53 - equals stir comp word comma mid
443:56 - right arrow keyword close print close
443:58 - paren
444:00 - less than zero close paren
444:02 - hi
444:02 - equals mid minus one semicolon else if
444:06 - close print con greater than zero close
444:08 - paren
444:09 - low equals mid plus one semicolon
444:12 - else return open paren mid close print
444:15 - semicolon
444:17 - close curly brace to finish the while
444:19 - and then return open paren null close
444:22 - paren
444:24 - close curly brace
444:26 - there are several things worthy of note
444:28 - here first the declaration of binary
444:31 - must indicate that it returns a pointer
444:34 - to the structure type key instead of an
444:36 - integer this is declared both in main
444:38 - and in binary if binary finds the word
444:41 - it returns a pointer to it if it fails
444:43 - it returns null
444:45 - second
444:47 - all the accessing elements of key dab is
444:50 - done by pointers
444:51 - this causes one very significant change
444:53 - in binary
444:55 - the computation of the middle element
444:57 - can no longer be simply mid equals paren
445:00 - low plus high close paren
445:02 - divided by two
445:04 - because the addition of two pointers
445:05 - will not produce any kind of useful
445:08 - answer even when divided by two and is
445:10 - fact illegal this must be changed to
445:13 - mid equals low plus open paren high
445:16 - minus low close paren divided by two
445:19 - which sets mid to the point to point to
445:22 - the element halfway between low and high
445:25 - you should also study the initializers
445:27 - for low and high
445:29 - it is possible to initialize a pointer
445:32 - to the address of a previously defined
445:34 - object and that is precisely what we
445:36 - have done here
445:38 - in main we wrote four open paren p
445:41 - equals key tab semicolon p less than key
445:44 - tab plus n keys semicolon p plus plus
445:48 - close paren
445:50 - if p is a pointer to a structure any
445:52 - arithmetic on p takes into the account
445:54 - the actual size of the structure so
445:57 - p plus plus increments p by the correct
445:59 - amount to get to the next element in the
446:01 - array of structures
446:03 - but don't assume that the size of a
446:04 - structure is the sum of the sizes of its
446:06 - members because alignment requirements
446:08 - for different objects
446:10 - potentially may cause holes in the
446:12 - structure
446:13 - finally an aside on program format when
446:17 - a function returns a complicated type as
446:19 - instruct key star binary open paren word
446:23 - comma tab comma n close paren
446:26 - the function name can kind of be hard to
446:28 - see and or find with a text editor
446:31 - alternately
446:33 - another style is sometimes used
446:35 - on two lines now struct key star on the
446:38 - first line in binary open paren word
446:41 - comma tab comma n close paren
446:44 - the spacing is mostly a matter of
446:46 - personal taste pick the form you like
446:48 - and hold to it
446:50 - section 6.5 self-referential structures
446:54 - before we start this section a slightly
446:56 - longer aside from your narrator
446:59 - up to now i've resisted the temptation
447:01 - to augment the book with my own bits of
447:03 - code
447:04 - but we have reached the single point in
447:06 - the book where i feel that there is too
447:07 - big of a conceptual leap between two
447:10 - sections so i'm going to add some of my
447:12 - own narrative between sections 6.4 and
447:14 - 6.5
447:16 - the rest of this chapter talks very
447:17 - nicely about binary trees and hash
447:19 - tables both essential low-level data
447:22 - structures in computer science and both
447:24 - excellent ways to understand pointers
447:26 - and how c can be used to build data
447:28 - structures like the python dictionary
447:30 - however
447:31 - the authors skip separately describing
447:33 - the structure of a dynamic dynamically
447:36 - constructed linked list which is the
447:38 - first and foundational collection data
447:40 - structure in computer science it should
447:42 - be understand be understood before
447:44 - moving to tree and hash map structures
447:48 - linked lists form the foundation of the
447:50 - python list object java array object php
447:53 - numeric key arrays and javascript arrays
447:55 - the linked list can be dynamically
447:58 - extended and items can be added in the
448:00 - middle efficiently as well as being
448:02 - pushed or popped on or off the front or
448:04 - back of the list
448:06 - linked lists are used also to implement
448:08 - cues as well as other aspects of
448:10 - operating system
448:11 - i will attempt to mimic the author's
448:14 - writing style in this new section of the
448:15 - book i'll write some sample code using a
448:17 - more modern dialect of c so it's easier
448:19 - to run on a modern compiler
448:23 - section
448:25 - 6.5.1 linked lists bonus
448:28 - content suppose we want to read a file
448:31 - and print the file in reverse order we
448:33 - don't know how many lines will be in the
448:35 - file before we read the file so we can't
448:37 - simply use an array of pointers to
448:39 - strings and character arrays like lines
448:42 - in a sense we need a dynamic array that
448:45 - grows as we encounter new lines when we
448:47 - reach the end of the file we then just
448:48 - loop through our stored lines from the
448:50 - end to the beginning so we can print
448:52 - them out in reverse order
448:54 - one solution is to make a data structure
448:56 - called a doubly linked list of character
448:58 - strings
448:59 - in addition to each line of data we will
449:01 - store a pointer to the previous line and
449:04 - the next line as well
449:05 - as well as a pointer to the first item
449:08 - we add to the list and then we'll call
449:10 - this the head of the list and then the
449:11 - most recent item we've added to the list
449:13 - which we'll call the tail of the list
449:16 - we will see a singly linked list as part
449:18 - of the hashmap data structure in a
449:20 - following section
449:22 - a single link list can only be traversed
449:24 - in a forward direction a doubly linked
449:26 - list can be traversed either forwards or
449:28 - backwards
449:29 - given that our linked list of strings
449:30 - will keep expanding as we get new lines
449:33 - we avoid hard coding array sizes like
449:35 - pound define maxlen1000 in the previous
449:37 - chapter we were building a program to
449:40 - sort a file
449:41 - going back to the description of a line
449:43 - in our doubly linked list it is clearly
449:45 - a structure with three components struct
449:48 - l node open curly brace char star text
449:51 - semicolon struct l node star prev
449:54 - semicolon struct l node star next
449:57 - semicolon close curly brace
450:01 - this recursive definition of l node
450:04 - might look chancy but it's actually
450:06 - quite correct it is illegal
450:08 - for a structure contained to contain an
450:10 - instance of itself but struct l node
450:13 - star prev declares preeve to be a
450:15 - pointer to an l node not an l node
450:18 - itself
450:20 - we'll write this code in a more modern c
450:22 - dialect using modern memory allocation i
450:24 - o routines provided by the standard c
450:26 - library
450:27 - this code is on page 130 of the textbook
450:31 - available at
450:35 - slash www.cc4e.com
450:37 - pound include stdio.h pound include std
450:41 - live.h pawn includes string.h
450:44 - pound define max line 1000 this is the
450:47 - length of the line not the number of
450:48 - lines struct l node open curly brace
450:52 - char star text semicolon
450:55 - struct l node star preview semicolon
450:58 - struct l node star next semicolon close
451:02 - curly brace semicolon
451:04 - now we have our main program to print
451:06 - the lines in reverse
451:08 - and we will use int main open paren
451:10 - close paren because we're coding in a
451:13 - modern dialect of c
451:15 - open curly brace struct l node star head
451:19 - equals null semicolon struct l node star
451:22 - tail equals null semicolon char line sub
451:26 - max line semicolon
451:29 - while
451:30 - open paren f get s open paren line comma
451:33 - max line comma s t d i n close paren not
451:36 - equal null close print open curly brace
451:41 - char star save equals open print char
451:45 - star
451:46 - close prin malloc open prin sterlin open
451:49 - print line close paren plus one close
451:52 - paren semicolon
451:54 - stir copy
451:56 - save come align
451:58 - struct l node star new equals
452:02 - open paren struct l node star close
452:04 - paren malloc open paren size of struct l
452:07 - node close paren close paren semicolon
452:10 - new right arrow text equals save new
452:13 - right arrow next equals null
452:15 - new right arrow preview equals tail and
452:18 - tail equals new
452:20 - if
452:21 - head
452:22 - equals equals null
452:24 - close paren head equals new semicolon
452:28 - close curly brace to finish the while
452:31 - now we'll print it all out
452:33 - four open paren struct l node star
452:36 - current equals tail semicolon current
452:39 - not equal to null
452:40 - semicolon current equals current right
452:43 - arrow prev
452:44 - close parenthesis open curly brace
452:47 - printf open paren double quote
452:49 - s close
452:51 - double quote comma current right arrow
452:54 - text close paren semicolon
452:57 - close curly brace to finish the four and
452:58 - then close curly brace
453:00 - to finish the main
453:03 - interestingly if we wanted to print the
453:05 - list in forward order or if we did have
453:07 - only a singly linked list our loop would
453:08 - look as follows
453:11 - four open paren struct l node star
453:13 - current equals head semicolon current
453:15 - not equal to null semicolon current
453:18 - equals current right arrow next closed
453:20 - paren open curly brace
453:23 - printf open paren double quote percent s
453:26 - double quote comma current right arrow
453:28 - text
453:29 - close paren
453:30 - semicolon close curly brace
453:34 - in general we use the variable names
453:36 - head tail and current as well as next
453:38 - and pre or similar names when writing
453:41 - code that builds or uses a linked list
453:43 - or so other programs will quickly
453:44 - understand what we are talking about
453:47 - after a while reading a for loop to
453:49 - traverse a linked list becomes as
453:51 - natural as reading a for loop that
453:53 - progresses through a sequence of numbers
453:56 - sections 6.5.2 binary trees
453:59 - suppose we want to handle the more
454:01 - general problem of counting the
454:02 - occurrences of all the words in some
454:04 - input
454:05 - since the list of words isn't known in
454:07 - advance we can't conveniently sort it
454:09 - and use a binary search
454:11 - yet we can't do a linear search for each
454:13 - word that has arrived to see if it's
454:14 - already been seen
454:16 - the program would take forever
454:18 - more precisely what is the expected
454:20 - running time and it would grow
454:21 - quadratically with a number of input
454:23 - words
454:24 - how can we organize the data to cope
454:27 - efficiently with a list of arbitrary
454:29 - words
454:31 - our solution is to keep the set of words
454:33 - seen so far sorted at all times
454:37 - by placing each word into its proper
454:39 - position in the order as it arrives
454:42 - this should this shouldn't be done by
454:44 - shifting the words in a linear array
454:45 - though that takes too long instead we
454:49 - will use a data structure called a
454:51 - binary tree
454:53 - the tree contains one node per distinct
454:55 - word
454:56 - each node contains a pointer to the text
454:58 - of the word
455:00 - a count of the number of occurrences of
455:01 - the word
455:02 - a pointer to the left child
455:04 - node and a pointer to the right child of
455:06 - node
455:08 - no node may have more than one
455:10 - at more than two children it might have
455:13 - only zero or
455:14 - one the nodes are maintained so that any
455:17 - node in the left tree contains only
455:19 - words that are less than the words at
455:20 - the node and the right tree only
455:22 - contains words that are greater
455:24 - to find out whether a new word is
455:25 - already in the tree one starts at the
455:27 - root and compares the new word to the
455:28 - word starting at that node
455:30 - if they match we found it
455:33 - if the new word is less than the tree
455:35 - word the search continues down the left
455:37 - otherwise the right child is searched
455:39 - there is no child in the required
455:40 - direction then the word is not in the
455:42 - tree and
455:44 - in plaque in fact the proper place for
455:46 - it to be
455:47 - is the missing child
455:49 - this search process is inherently
455:51 - recursive
455:53 - since the search for many node uses a
455:55 - search from one of its children
455:56 - accordingly recursive routines for
455:58 - inserting and printing will be the most
456:00 - natural
456:03 - going back to the description of a node
456:05 - is clearly a structure with four
456:06 - components
456:08 - struct t node open curly brace char star
456:13 - word
456:13 - int count semicolon
456:16 - struct t note star left semicolon struct
456:19 - t node star right semicolon closed curly
456:22 - brace
456:24 - this recursive declaration of a node
456:26 - might look chancy but actually it's
456:28 - quite correct
456:29 - it's
456:30 - illegal for a structure to contain an
456:32 - instance of itself but struck t node
456:35 - star left semicolon declares left to be
456:38 - a pointer to a node not a node itself
456:42 - the code for the whole program is
456:43 - surprisingly small given the handful of
456:46 - supporting routines that we've already
456:47 - written these are get word to fetch
456:49 - input and alec to provide space for
456:51 - squirreling the words away
456:53 - the mahin routine simply reads words
456:57 - with getword installs them in the tree
456:58 - with tree
457:00 - this is the first example on page 131 of
457:03 - the textbook which you can see at
457:05 - www.cc4e.com
457:08 - code
457:10 - pound include stdio.h pound defined max
457:14 - word 20 pound defined letter single
457:16 - quote a single quote
457:18 - main open paren close paren open curly
457:21 - brace struct t node star root comma star
457:26 - tree open print close paren semicolon
457:28 - char word open square bracket max word
457:31 - close square bracket semicolon and t
457:34 - semicolon
457:35 - root equals null
457:38 - while open paren open parent t equals
457:41 - get word open paren word comma max word
457:44 - close print close paren not equal eof
457:46 - close paren
457:47 - if open paren t double equal letter
457:50 - close paren root equals tree open paren
457:53 - root comma word close paren semicolon
457:57 - tree print
457:58 - open paren
457:59 - root close paren semicolon close curly
458:02 - brace
458:04 - tree itself is straightforward
458:07 - a word is presented by main to the top
458:09 - level root of the tree
458:11 - at each stage that word is compared to
458:13 - the word already stored at the node and
458:15 - is percolated down either to the left or
458:17 - right subtree by a recursive called a
458:19 - tree
458:20 - eventually the word either matches
458:22 - something already in the tree
458:24 - in which case the count simply is
458:25 - incremented or a null or pointer is
458:27 - encountered indicating the node must be
458:30 - created and added to the tree if a new
458:32 - node is created tree rent turns a
458:34 - pointer to it which is installed in the
458:36 - parent node
458:40 - this is
458:41 - the example on page 132 of the textbook
458:44 - at wwe
458:47 - code
458:51 - pound includes string dot h
458:53 - struct t node open curly brace char star
458:57 - word semicolon int count semicolon
459:00 - struct t node star left semicolon struct
459:04 - t node star right semicolon
459:06 - close curly brace semicolon
459:10 - struct t node star tree open paren p
459:13 - comma w close paren we're going to
459:15 - install
459:16 - w at or below p
459:19 - struck t node star p semicolon char star
459:23 - w open curly brace struct t node star t
459:27 - alec
459:28 - open paren close paren semicolon char
459:31 - star stir state stir save open for n
459:34 - close paren semicolon
459:36 - int conned semicolon
459:39 - if open paren p double equal null
459:43 - close paren open curly brace
459:45 - we've got a new word p
459:47 - equals t alec open print close paren to
459:50 - make a new note
459:52 - p right arrow word equals stir save open
459:54 - paren w close paren semicolon p
459:57 - right arrow count equals 1
460:00 - p right arrow left equals p right arrow
460:02 - right equals null
460:06 - close curly brace else if
460:09 - open paren open print con equal stir
460:12 - comp w comma p right arrow word close
460:15 - paren close paren
460:16 - double equals zero close paren
460:19 - p right arrow count plus plus
460:22 - indicate that we've seen the word one
460:24 - more time
460:27 - else if open paren conned less than zero
460:30 - close paren
460:32 - lower will go into the left part of the
460:33 - tree
460:37 - p right arrow left equals tree
460:40 - p right arrow left comma w
460:43 - close paren semicolon else
460:46 - p right arrow right
460:48 - equals tree open friend p right arrow
460:51 - right comma
460:53 - w
460:54 - close paren semicolon
460:56 - return open paren p close paren
460:58 - semicolon
460:59 - close curly brace
461:02 - and that's a bit of code it's not much
461:04 - and it's beautiful
461:06 - recursion is happening the return p at
461:08 - the very end is really really important
461:10 - because we're kind of always overriding
461:12 - it but we're okay
461:14 - so um
461:16 - the overriding works its way back up to
461:18 - the recursion because it's recursive
461:19 - it's using pointers away we go
461:22 - back to the text
461:24 - storage for the new node is fixed by a
461:27 - routine called t alec which is an
461:29 - adaptation of the alec we wrote earlier
461:31 - it returns a pointer to a free space
461:34 - suitable for holding a tree node
461:36 - we'll discuss this more in a moment the
461:38 - new word is copied to a hidden place by
461:41 - stir save the count is initialized and
461:43 - the two children are made null
461:45 - this part of the code is executed only
461:47 - at the edge of the tree when a new node
461:49 - is being added
461:50 - we have unwisely for a production
461:52 - program omitted error checking on the
461:55 - values between returned by stir save and
461:58 - t alec
461:59 - tree print
462:01 - prints the tree in left sub tree order
462:04 - at each node it prints its left sub-tree
462:06 - all the words less than this word then
462:08 - the word itself then the right sub-tree
462:10 - all the words greater
462:13 - if you feel shaky about recursion draw
462:15 - yourself a tree and printed with tree
462:17 - print
462:18 - it's one of the cleanest recursive
462:20 - routines you can find
462:24 - this example code is on page 133 of the
462:27 - textbook which you can see at
462:29 - www.cc4e.com
462:32 - code
462:35 - i won't read
462:38 - the struct node code
462:40 - just tree print
462:43 - tree print open paren p close paren
462:46 - struct t node star p semicolon open
462:49 - curly brace if open paren p not equal to
462:52 - null close parend
462:55 - curly brace open curly brace tree print
462:58 - open paren p air right arrow left close
463:01 - paren semicolon printf percent 4d space
463:05 - percent s backslash n double quote comma
463:08 - p right arrow count comma p right arrow
463:11 - word sum print close parenthesis
463:13 - semicolon
463:15 - tree print open print p right arrow
463:18 - right close paren semicolon close curly
463:21 - brace for the if and then close curly
463:22 - brace for the tree print function
463:26 - again i agree with the authors and that
463:28 - is one of the cleanest and most
463:29 - beautiful and most applicable uses of
463:32 - recursion that you will probably ever
463:33 - see in all your career
463:36 - i'm not a fan of recursion in all uses
463:38 - cases but you really can't do this any
463:40 - other way well
463:43 - back to the text
463:44 - practic as a practical note if the pre
463:46 - tree becomes unbalanced because the
463:48 - words don't arrive in random order the
463:50 - running time of the program can grow too
463:52 - fast as a worst case if the forwards are
463:55 - already in order
463:57 - this program does an expensive
463:58 - simulation of linear search there are
464:00 - generalizations of the binary tree
464:02 - notably
464:03 - 2 3 trees avl trees and i would add
464:06 - balanced binary trees which do not
464:08 - suffer from this worst case behavior but
464:10 - we will not describe them here
464:13 - before we leave this example it's also
464:15 - worth a brief digression on a problem
464:17 - related to storage allocators clearly
464:20 - it's desirable that there only be one
464:22 - storage allocator in a program
464:24 - even though it allocates different kinds
464:26 - of objects but if one allocator is to
464:28 - process requests for say pointers to
464:30 - chars and pointers to struck t nodes two
464:33 - questions arise
464:34 - first
464:35 - does it meet the requirement of most
464:37 - real machines that objects of a certain
464:39 - types must satisfy alignment
464:41 - restrictions for example integers must
464:44 - often be located uneven addresses
464:47 - second
464:48 - what declarations can cope with the fact
464:50 - that alec necessarily returns different
464:52 - kinds of pointers
464:54 - alignment requirements can generally be
464:56 - satisfied easily at the cost of some
464:58 - wasted space merely by assuring ensuring
465:01 - the allocator always returns a pointer
465:03 - that meets all alignment restrictions
465:06 - for an example on the pdb11 it is
465:08 - sufficient
465:09 - that alec always returns an even pointer
465:12 - since any type of object may be stored
465:14 - at an even address the only cost is a
465:17 - wasted character on the odd length
465:19 - requests
465:20 - similar actions are taken on other
465:22 - machines
465:23 - thus the implementation of alec may not
465:25 - be portable but its usage is
465:28 - the alec of chapter 5 does not guarantee
465:31 - any particular alignment in chapter 8
465:33 - we'll show how to do the job right
465:37 - as an aside by now you know that when
465:39 - the authors mentioned the pdp-11 they
465:41 - are sharing some aspects of the
465:43 - challenge of making c work on previous
465:45 - generation computers with short memory
465:48 - words and small amounts of memory and at
465:50 - the same time making them work well on
465:52 - the incoming generation of computers
465:53 - with larger words and more memory
465:56 - the research thought
465:58 - and care that went into making sure the
466:01 - c code was portable across multiple
466:03 - generations of computer hardware is on
466:05 - display in the previous paragraph
466:09 - the question of the type declaration for
466:12 - alec is a vexing one for any language
466:14 - that takes its type checking seriously
466:17 - in c the best procedure is to declare
466:19 - that alec returns a pointer to char and
466:21 - then explicitly coerce the pointer into
466:24 - the desired type with a cast
466:26 - therefore if p is declared as char star
466:30 - p semicolon then
466:32 - open paren struct t node star close
466:35 - paren p converts it into a t node
466:37 - pointer expression
466:38 - thus t alec is written as
466:41 - t node star t alec open paren close
466:44 - paren open curly brace char star alec
466:48 - return open paren open print struct t
466:51 - node star close print alec open paren
466:54 - sizeof open prin struct t node close
466:58 - prin close paren close print
467:01 - this is more than is needed for current
467:03 - compilers but represents the safest
467:05 - course for the future
467:09 - i would add
467:10 - that these concerns that the authors
467:12 - mentioned in this section are also
467:14 - nicely resolved in modern c compilers in
467:16 - the nc version of c they introduce the
467:18 - notion of the void type
467:20 - the void type indicates the lack of a
467:22 - type
467:23 - much like null is used to indicate not a
467:26 - valid pointer
467:27 - or not a flying toy
467:30 - in 1978 because the chart type was
467:33 - generally the most native type on any
467:34 - system it was often used as the generic
467:37 - pointer needed to return memory from an
467:39 - allocation function
467:41 - in modern c we use pointers to void and
467:43 - then cast the returning pointer
467:45 - to be a pointer to whatever struct or
467:47 - other data we just allocated
467:49 - if we were writing alec the alec routine
467:51 - in this book using modern c it would
467:53 - return a pointer to white
467:56 - the 1978 version is char star alec open
467:59 - paren close paren and the modern version
468:01 - is void star alec open paren close paren
468:07 - we've left the book alone we haven't
468:08 - used void throughout the book
468:10 - but it is a testament to the foresight
468:12 - of the authors
468:13 - that all the pointer casting code in
468:16 - this book still works today the same
468:20 - regardless of whether the memory
468:22 - allocation functions return char or void
468:24 - pointers to the allocated data
468:26 - sections 6.6 table lookup
468:30 - as an aside in this section we finish
468:33 - our quick tour of the implementations of
468:35 - the three core data structures in
468:36 - computer science
468:38 - one the linked list two the tree and
468:41 - three the hash map as described in this
468:43 - section
468:44 - a singly linked list is also part of a
468:46 - hashmap implementation so you can
468:48 - compare it
468:49 - to the doubly linked list code
468:50 - introduced in the earlier bonus section
468:52 - 6.5.1
468:55 - this section is worth understanding well
468:58 - because not only is it an excellent
468:59 - review of pointers and structures but
469:02 - also because one of the most common
469:04 - questions
469:05 - on a face-to-face programming interview
469:07 - is draw a hashmap on the whiteboard and
469:09 - explain how it works
469:11 - this is an easy question if you study
469:13 - and understand this section of the book
469:15 - and almost impossible if you have not
469:20 - in some ways this section is the most
469:22 - intricate data structure that's
469:23 - described in the book
469:24 - it is why it is so popular in coding
469:26 - interviews
469:28 - chapters 7 and 8 talk about lots of
469:30 - practical things like input output of
469:32 - the unix operating system
469:34 - elegant data structures and their use
469:36 - are core concepts in computer science
469:39 - understanding them highlights the
469:40 - difference between a good programmer and
469:43 - a computer scientist
469:45 - in a sense understanding how a hashmap
469:48 - is the secret handshake of computer
469:50 - science
469:51 - and it is the secret handshake
469:54 - because of this book and this section of
469:57 - this book
469:58 - written back in 1978
470:01 - and used in a course
470:03 - that the person interviewing you may
470:05 - have took when they were in college
470:08 - hash maps were difficult for them to
470:10 - understand back then and so if you
470:12 - understand the concept then you must be
470:14 - solid
470:16 - so i hope you pay close attention to
470:19 - this section and remember the handshake
470:22 - back to the text
470:25 - in this section we will write the
470:26 - innards of a table lookup package as an
470:29 - illustration of more aspects of
470:30 - structures this code is typical of what
470:33 - might be found in the symbol table
470:34 - management routines of a macro processor
470:37 - or a compiler
470:38 - for example consider the c pound define
470:41 - statement when a line like pound define
470:43 - yes one is encountered the name
470:46 - replacement text
470:47 - the name yes and the replacement text
470:49 - one are stored in a table
470:52 - later when the name yes appears in a
470:53 - statement like inward equals yes
470:55 - semicolon it must be replaced by one
470:59 - there are two major routines that
471:01 - manipulate the names and replacement
471:03 - texts
471:04 - install open paren s comma t close paren
471:07 - records the name s and replacement t in
471:10 - the table
471:11 - s and t are just character strings
471:14 - lookup open paren s close print searches
471:16 - for s in the table and returns a pointer
471:19 - to the place where it was found or null
471:21 - if it wasn't there
471:23 - the algorithm used is a hash search the
471:26 - incoming name is converted to a small
471:29 - positive integer which is then used to
471:31 - index into an array of pointers
471:34 - an array element points to the beginning
471:36 - of a chain of blocks describing the
471:38 - names that have the hash value
471:40 - and if it is null then no names have
471:43 - hashed to that value
471:45 - a block in the a block in the chain is a
471:48 - structure containing pointers to the
471:50 - name the replacement text and the next
471:52 - block in the chain
471:54 - a null next pointer marks marks the end
471:57 - of the chain
471:59 - struct and list open paren
472:02 - char star name semicolon char star def
472:06 - semicolon
472:08 - struct
472:09 - endless star next semicolon close curly
472:12 - brace semicolon
472:15 - the pointer array is just pound define
472:18 - hash size 100
472:21 - static struct and list star hash tab
472:25 - open square bracket hash size close
472:27 - square bracket semicolon
472:30 - the hashing function which is used by
472:32 - both lookup and install simply adds up
472:35 - the character values in the string and
472:37 - forms the remainder modulo
472:40 - the array size this is not the best
472:42 - possible
472:43 - algorithm but it has the merit of
472:45 - extreme simplicity
472:48 - hash open paren s close paren char star
472:52 - s semicolon open curly brace int hash
472:56 - val
472:58 - four
472:58 - open curly brace hash val equals zero
473:02 - star s not equal quote single quote
473:05 - backslash zero single quote semicolon
473:08 - close paren
473:10 - hash val plus equals star s plus plus
473:14 - semicolon
473:16 - return open paren hash val modulo
473:20 - percent hash size close paren semicolon
473:23 - close curly brace
473:25 - as an aside
473:27 - hashing functions are one of the
473:28 - foundational notions in computer science
473:32 - hashing functions are used for
473:33 - everything from high performance
473:35 - in-memory structures
473:36 - organizing databases
473:39 - data digital signing network packet
473:41 - checksums security algorithms and much
473:44 - more
473:45 - the above text is a really great example
473:49 - of a really simple hashing function
473:52 - you should understand this simple
473:54 - presentation well so that when you
473:56 - encounter a more complex implementation
473:59 - or use of hashing you can fall back on
474:01 - this text to understand that at its core
474:05 - hashing is a very simple concept
474:09 - so much of this chapter is a succinct
474:11 - example of some of the most powerful
474:14 - concepts in computer science
474:16 - please don't look at the eight code
474:18 - lines of code above and think i got that
474:20 - and just jump to the next bit
474:22 - this chapter is showing you the way of
474:24 - the master programmer
474:27 - wax on
474:28 - wax off
474:30 - be patient
474:31 - slow down
474:33 - and enjoy your time here
474:36 - back to the text the hashing process
474:39 - produces a starting index in the array
474:41 - hashtag if the string is to be found
474:43 - anywhere it will be in the chain of
474:45 - blocks beginning there
474:47 - the search is performed by lookup
474:49 - if lookup finds the entry already
474:51 - present it just returns a pointer to it
474:53 - if not it returns null
474:56 - here's the code struct and list star
474:59 - lookup open paren s close paren
475:03 - char star s
475:04 - semicolon open curly brace
475:08 - struct and list star np semicolon
475:13 - for
475:14 - open paren np equals tab sub hash open
475:18 - paren s close paren
475:22 - close square bracket semicolon np not
475:24 - equal null semicolon np equals np right
475:28 - arrow next close parenthesis
475:31 - if stir comp open print s comma np right
475:34 - arrow name close paren double equals
475:36 - zero return open print np close paren
475:39 - semicolon
475:42 - return open print null close print
475:44 - semicolon close curly brace
475:46 - install uses lookup to determine whether
475:49 - the name installed is already present if
475:51 - so the new definition must supersede the
475:54 - old one
475:55 - otherwise a complete newly new entry is
475:58 - created
475:59 - install returns no
476:00 - if for any reason there's no room for a
476:02 - new entry
476:06 - struct and list star install open friend
476:10 - name common death close paren
476:12 - jar star name comma star def semicolon
476:16 - open curly brace
476:17 - struct
476:18 - endless star np comma star lookup open
476:22 - print close brand semicolon char
476:25 - stir save comma star alec open print
476:28 - close paren semicolon
476:29 - int
476:30 - val semicolon
476:33 - if open paren open paren np equals
476:36 - lookup open paren name close paren close
476:38 - print double equal null
476:41 - close paren open curly brace i.e it's
476:44 - not found np
476:46 - equals open paren struct end list star
476:49 - close paren alec open paren size of open
476:52 - paren star np close paren close paren
476:55 - semicolon
476:57 - np equals null return null that means
477:00 - the allocation failed
477:02 - if open paren open paren np right arrow
477:05 - name
477:06 - equals
477:08 - stir save open paren name close print
477:10 - close paren double equals null close
477:12 - paren return
477:14 - open paren
477:15 - null close paren semicolon
477:20 - hash val
477:21 - equals
477:24 - open paren np right arrow name close
477:28 - brand semicolon
477:30 - np next equals
477:32 - tab open square bracket hash val close
477:35 - for bracket second semicolon
477:38 - hash tab open square bracket hash valve
477:41 - close spur bracket equals np semicolon
477:44 - we're actually pushing these new ones to
477:47 - the head of this singly linked list
477:50 - and so those last two
477:52 - statements push the the most recent top
477:55 - of the list
477:56 - forward and then replace with the new
477:59 - one at the top of the list the list does
478:00 - not stay in any order
478:04 - so
478:07 - we have a closed curly brace to end all
478:09 - that if for the not found code
478:12 - close curly brace else this is the
478:14 - already code click already their code
478:17 - free
478:18 - open paren np right arrow def close
478:21 - paren semicolon
478:22 - free the previous definition
478:24 - that's the string part of the
478:27 - the
478:28 - the pound define
478:30 - if open paren np
478:32 - right arrow def
478:34 - equal stir save open paren def close
478:37 - print close print
478:39 - equals null close print return open
478:42 - paren null close paren semicolon
478:44 - return open print np close print
478:47 - semicolon close curly brace so that last
478:50 - bit there was to
478:53 - if you have a pound define with the same
478:57 - keyword and a different later you have
479:00 - it later a different uh definition you
479:02 - can replace the definition so that last
479:04 - bit was replacing the definition
479:06 - again this code is a pretty intricate
479:09 - it's really both the hash table and a
479:11 - singly linked list going on at the same
479:13 - time so take a close look at this on
479:16 - page 136 of the book
479:20 - stir save merely copies the string given
479:22 - its argument to a safe space obtained by
479:25 - a call to alec we've showed this code in
479:27 - chapter five since calls to alec and
479:29 - free may occur in any order and since
479:31 - alignment matters the simple version of
479:33 - alec
479:34 - is just not adequate here
479:37 - see more in chapters 7 and 8.
479:42 - as an aside one of the reasons that the
479:43 - authors make vague forward-looking
479:45 - statements we know that they talk about
479:46 - dynamic memory is that large-scale
479:48 - memory management in a programming
479:50 - language is still a subject of active
479:52 - research 40 years later
479:55 - back in 1978 it was absolutely not a
479:58 - settled topic you can see this when the
480:00 - authors build a simple non-production
480:02 - memory allocation scheme with their own
480:04 - alec and free routines backed by a fixed
480:07 - length static extern array of characters
480:10 - dynamic allocation is essential to
480:12 - writing competency programs but it is
480:14 - likely that the production grade dynamic
480:16 - memory support was still somewhat
480:17 - non-portable when the book was written
480:19 - so they used simple self-contained
480:21 - implementations in this book
480:23 - modern dynamic memory support is through
480:26 - the mala c alec and free functions in
480:28 - the standard library these functions
480:30 - request dynamic memory blocks from the
480:32 - operating system and manage those areas
480:34 - on behalf of your c code
480:36 - on unix and unix-like systems the memory
480:39 - allocation layer asks the underlying
480:41 - operating systems for blocks of memory
480:43 - through the sbrk interface
480:46 - even with virtual memory programmers
480:48 - must carefully manage their use of
480:50 - dynamically allocated memory because
480:52 - memory is never unlimited
480:55 - section 6.7 fields
480:58 - when storage space is at a premium it
481:00 - may be necessary to pack several objects
481:02 - into a single machine word
481:05 - one especially common use is a set of
481:07 - single bit at flags in applications like
481:09 - compiler symbol tables
481:11 - externally imposed data formats such as
481:13 - interfaces to hardware devices also
481:16 - often require the ability to get at
481:18 - pieces of a word
481:20 - as an aside we are going to go now from
481:23 - low level programming to even lower
481:26 - level programming
481:27 - the unix operating system is written in
481:29 - c and unix needs to have for example an
481:32 - implementation of the internet protocol
481:34 - so it can be connected to the internet
481:36 - one of the most important internet
481:37 - protocols is the transmission control
481:39 - protocol tcp
481:42 - in order to implement tcp you need to
481:44 - send very precisely formatted data
481:46 - across the network the data is very
481:48 - tightly packed in order to save precious
481:51 - network bandwidth the exact format of a
481:54 - tcp header is described in the tcp
481:57 - wikipedia page
481:58 - if you look at the header you will find
482:00 - that it bits 96 through 99
482:03 - tcp expects a four bit integer that
482:06 - defines the data offset
482:09 - exactly what this data means is less
482:11 - relevant unless you're actually writing
482:12 - the tcp implementation but it does
482:15 - demonstrate that we need to control our
482:17 - data layout at times on a bit by bit
482:19 - basis
482:20 - this section covers how we can use
482:22 - struct to build up a tcp header in c
482:26 - which can be parsed and set without
482:27 - using masking and shifting operations
482:29 - with hard-coded numbers
482:31 - the section below is simpler than
482:32 - constructing a valid tcp header using a
482:34 - carefully packed struct but it does lay
482:36 - the groundwork for these more complex
482:38 - situations
482:40 - now back to the text
482:42 - imagine a fragment of a compiler that
482:44 - manipulates a symbol table
482:46 - each identifier in a program has certain
482:49 - information associated with it for
482:50 - example whether or not it's a keyword
482:53 - whether or not it's external and or
482:54 - static and so on the most compact way to
482:57 - encode such an information is a set of
482:59 - one-bit flags in a single char or int
483:02 - the usual way this is done is define a
483:04 - set of masks
483:06 - corresponding to the relevant bit
483:08 - positions as in
483:10 - pound-defying keyword 0-1 pound-define
483:13 - external 0-2 and pound defined static 0
483:16 - 4. the numbers of course must be powers
483:18 - of 2 so that the shifting works
483:21 - then accessing the bits become a matter
483:23 - of bit fiddling with shifting masking
483:25 - and complementing operators which were
483:27 - described in chapter 2.
483:29 - certain idioms of fear appear frequently
483:32 - flags
483:33 - vertical par equals external vertical
483:35 - bar static
483:36 - turns on the external and static bits
483:39 - and flags while flags ampersand equal
483:42 - tilled open paren external or static
483:45 - closed paren semicolon turns them off
483:48 - and if open paren open print flags
483:52 - ampersand paren external vertical bar
483:55 - static close paren close print equal
483:57 - equal zero
483:58 - dot dot dot is true if both bits are off
484:02 - although these idioms are readily
484:04 - mastered as an alternative c offers the
484:07 - capability of defining and accessing
484:09 - fields within a word directly rather
484:11 - than by bitwise logical operators
484:14 - a field is a set of adjacent bits within
484:16 - a single int the syntax of field
484:19 - definition and access is based on
484:21 - structures for example the symbol table
484:24 - palm defines above could be replaced by
484:26 - the definition of three fields
484:29 - struct
484:30 - unsigned is keyword colon one semicolon
484:35 - unsigned is extern colon one semicolon
484:39 - unsigned is static colon 1 semicolon
484:42 - closed curly brace flags
484:45 - this defines a variable called flags
484:47 - that contains three 1-bit fields the
484:50 - number following the colon
484:52 - represents the field width in bits
484:54 - the fields are declared unsigned to
484:56 - emphasize that they are really unsigned
484:58 - quantities
485:00 - individual fields are referenced as
485:02 - flags.is keyword
485:04 - flags.is extern etc just like other
485:07 - structure members
485:09 - fields behave like small unsigned
485:10 - integers and may partic participate in
485:13 - arithmetic expressions just like the
485:15 - other integers thus the previous
485:17 - examples may be written much more
485:18 - naturally as
485:20 - flags is underscore extern equals flags
485:24 - is static equals one semicolon
485:28 - turn the bits on
485:31 - flags is extern equals flags is static
485:35 - equals one semicolon to turn the bits on
485:38 - flags dot is extern equals flags dot is
485:41 - static equals zero turns them off
485:44 - and if open paren flags dot is extern
485:47 - double equals zero and flags dot is
485:50 - static double equals zero close paren
485:52 - dot dot to test them
485:55 - a field may not overlap an int boundary
485:58 - if the width would cause this to happen
486:00 - the field is aligned to the next in
486:02 - boundary fields need not be named
486:04 - unnamed fields with a colon and width
486:07 - only are used for padding the special
486:09 - width 0 may be used to force alignment
486:11 - to the next int boundary there are a
486:14 - number of caveats that apply to fields
486:15 - perhaps the most significant
486:17 - fields are assigned left to right on
486:19 - some machines and right to left on
486:22 - others reflecting the nature of
486:23 - different hardware
486:24 - this means that although fields are
486:26 - quite useful for maintaining internally
486:28 - defined data structures the question of
486:31 - which end comes first have to has to be
486:33 - carefully considered when picking apart
486:36 - externally defined data
486:38 - other restrictions to bear in mind
486:40 - fields are unsigned they may only be
486:42 - stored in ins or equivalently unsigned
486:45 - they are not arrays and they do not have
486:47 - addresses so the ampersand operator
486:49 - cannot be applied to them
486:51 - section 6.8 unions
486:54 - a union is a variable which may hold at
486:56 - different times
486:58 - objects of different types and sizes
487:00 - with the compiler keeping track of the
487:02 - size and alignment requirements
487:04 - unions provide a way to manipulate
487:06 - different kinds of data in a single area
487:08 - of storage without embedding any machine
487:11 - dependent information in the program for
487:14 - example again from a compiler symbol
487:16 - table suppose constants may be ins
487:19 - floats or character pointers the value
487:22 - of a particular constant must be stored
487:23 - in a variable of the proper type yet it
487:26 - is most convenient for table management
487:28 - if the value occupies the same amount of
487:30 - storage and is stored in the same place
487:33 - regardless of its type
487:35 - this is the purpose of a union to
487:37 - provide a single variable which can
487:39 - legitimately hold one of several types
487:42 - as with fields the syntax is based on
487:45 - structures
487:47 - union
487:48 - u tag open curly brace int ival
487:51 - semicolon float f val semicolon char
487:55 - star p-val semicolon closed curly brace
487:58 - u-val
487:59 - the variable u-val will be large enough
488:02 - to hold the largest of these three types
488:03 - regardless of the machine it is compiled
488:05 - of
488:06 - compiled on
488:07 - the code is independent of hardware
488:09 - characteristics any one of these types
488:12 - may be assigned to uval and then used in
488:14 - expressions so long as the usage is
488:16 - consistent the type retrieved must be
488:19 - the type most recently stored it is the
488:21 - responsibility of the programmer to keep
488:23 - track of what type is currently stored
488:25 - in the union the results are machine
488:27 - defendant dependent if something is
488:30 - stored as one type and extracted as
488:32 - another type
488:34 - syntactically members of a union are
488:36 - accessed as union name dot member or
488:40 - union pointer right arrow member
488:43 - justice for structures
488:45 - if the variable you type is used to keep
488:47 - track of the current type start in uval
488:49 - then one might see code as if open paren
488:53 - you type double equals int close paren
488:56 - printf
488:57 - paren
488:59 - double quote percent d backslash n
489:01 - double quote comma
489:02 - uval dot ival close parent semicolon
489:06 - else if
489:07 - open paren you type double equal float
489:09 - close paren
489:10 - print f
489:12 - open paren double quote percent f
489:14 - backslash n double quote comma u val dot
489:17 - f val
489:19 - close paren semicolon else if open paren
489:22 - you type double equals string close
489:24 - paren print f
489:25 - double quote percent s backslash n
489:28 - double quote comma u val dot p val close
489:31 - paren semicolon
489:33 - else printf
489:34 - open paren double quote bad type percent
489:37 - d and you type backslash n double quote
489:40 - comma you type
489:41 - close paren semicolon
489:46 - unions may occur in structures and
489:49 - arrays and vice versa the notion for
489:51 - accessing a member of a union in a
489:53 - structure or vice versa is identical
489:55 - that to that for nested structures
489:58 - for example in the structure array
490:00 - defined by struct
490:02 - open curly brace char star name
490:05 - semicolon int flags semicolon
490:08 - and you type semicolon
490:10 - union open curly brace
490:13 - int ival semicolon float f val semicolon
490:16 - char star p val semicolon
490:19 - close curly brace u val semicolon close
490:23 - curly brace sim tab open square bracket
490:26 - end sim close square bracket
490:29 - the variable i val is referred to as
490:33 - sim tab sub i dot u val dot ival
490:37 - and the first character of the string p
490:39 - val by star
490:41 - sim tab sub i
490:43 - dot uofl.pival
490:46 - in effect a union is a structure in
490:48 - which all the members have offset zero
490:50 - the structure is big enough to hold the
490:52 - widest member and the alignment is
490:54 - appropriate for all types in the union
490:57 - as with structures the only operations
490:59 - currently permitted on unions are
491:01 - accessing a member and taking the
491:03 - address
491:04 - unions may not be assigned to pass to
491:06 - functions or returned by functions
491:08 - pointers to unions can be used in a
491:10 - manner identical to pointers to
491:11 - structures
491:14 - as it aside the above limitations on
491:16 - unions are just no longer accurate like
491:18 - structures modern c compilers can assign
491:20 - the contents of the union to another
491:22 - union variable you can also pass unions
491:25 - into functions by value and receive a
491:28 - union as the return type of a function
491:30 - the storage allocator in chapter 8 shows
491:32 - how a union can be used to force a
491:34 - variable to be aligned on a particular
491:37 - kind of storage
491:38 - boundary section 6.9 type def
491:43 - c provides a facility called typedef for
491:45 - creating new data type names for example
491:49 - the declaration type def space int space
491:52 - length semicolon
491:54 - makes the name length a synonym for end
491:58 - the type length can be used in
492:00 - declarations cast etc in exactly the
492:03 - same ways int can be
492:06 - length len comma maxlen semicolon length
492:09 - star lengths open square bracket close
492:11 - four bracket semicolon
492:15 - similar the declaration type def char
492:19 - star string semicolon makes string a
492:23 - synonym for char star or a character
492:26 - pointer which then may be used in
492:28 - declarations like string
492:30 - p
492:31 - comma line ptr open square bracket lines
492:34 - close square bracket comma alec open
492:36 - paren close paren semicolon
492:39 - note that the type being declared in a
492:41 - typedef appears in the position of a
492:43 - variable name
492:45 - not right after the word typedef
492:47 - syntactically typedef is like the
492:50 - storage class
492:51 - extern static etc
492:54 - we've used uppercase letters in these
492:56 - examples to emphasize the names
493:00 - a more complicated example we could make
493:02 - typedefs for the tree nodes shown
493:03 - earlier in the track chapter
493:06 - typedef struct t node open curly brace
493:10 - char star word semicolon hint count
493:13 - semicolon struct t node star left
493:17 - semicolon struct t node star right
493:20 - semicolon close curly brace
493:23 - tree node comma star tree ptr
493:28 - this creates three two new type keywords
493:31 - called tree node which is a structure
493:33 - and tree ptr which is a pointer to the
493:36 - structure
493:37 - then the routine t alec could become
493:40 - tree ptr t alec open paren close print
493:43 - open curly brace char star alec
493:46 - open print close paren semicolon return
493:49 - open paren open paren tree ptr close
493:52 - print alloc open print size f open paren
493:57 - tree node close print close paren closed
493:59 - brand semicolon closed curly brace
494:03 - it should be emphasized that a typedef
494:05 - declaration does not exactly create a
494:07 - new type in any sense
494:10 - it merely adds a new name for some
494:11 - existing types nor are there any new
494:14 - semantics
494:15 - variables declared this way have exactly
494:17 - the same property as variables who
494:19 - whose declarations are spelled out
494:21 - explicitly
494:22 - in effect typedef is like defined
494:26 - except that since it's interpreted by
494:27 - the compiler it can cope with textual
494:30 - substitutions that are beyond the
494:32 - capabilities of the c macro preprocessor
494:35 - for example
494:37 - typedef int
494:38 - open paren star
494:40 - pfi close print
494:43 - open for enclosed print semicolon
494:45 - creates
494:46 - the type pfi
494:48 - to mean
494:49 - pointer to a function returning integer
494:52 - which can be used in context like
494:54 - pfi stir comp comma num comp comma swap
494:59 - in the sort program in chapter 5.
495:01 - there are two main reasons for using
495:03 - typedef declaration
495:05 - the first is to parameterize a program
495:07 - against portability problems if type
495:09 - defs are used
495:11 - for the data types which may be machine
495:13 - dependent only typedefs need to change
495:15 - when the program is moved
495:17 - one common situation is to use typedef
495:19 - names for various integer quantities and
495:22 - then make an appropriate set of choices
495:24 - of short int and long for each host
495:28 - machine
495:29 - the second purpose of type defs is to
495:31 - provide better documentation for a
495:33 - program a type called tree ptr may be
495:37 - easier to understand
495:38 - than one declared only as a pointer to a
495:41 - complicated structure
495:43 - finally there's always the possibility
495:45 - that the futures a compiler or some
495:48 - other program such as lind may make use
495:50 - of the information contained in typedef
495:52 - declaration to perform some extra
495:55 - checking on the program
495:58 - this work
495:59 - is based on the 1978 c programming book
496:02 - written by brian w kernighan and dennis
496:04 - m ritchie their book is copyright all
496:07 - rights reserved by at t
496:09 - but is used in this work under fair use
496:12 - because of the book's historical and
496:14 - scholarly significance
496:16 - its lack of availability and the lack of
496:18 - an accessible version of the book
496:20 - the book is augmented in places to help
496:22 - understand its rightful place in a
496:24 - historical context amidst the major
496:26 - changes of the 1970s and 1980s as
496:29 - computer science evolved from a
496:31 - hardware-first vendor-centered approach
496:33 - to a software-centered approach where
496:35 - portable operating systems and
496:36 - applications written in c could run on
496:39 - any hardware
496:41 - this is not the ideal book to learn c
496:43 - programming because the 1978 edition
496:45 - does not reflect the modern c language
496:48 - using an obsolete book gives us an
496:50 - opportunity to take students back in
496:52 - time and understand how the c language
496:55 - was evolving as it laid the groundwork
496:57 - for a future with portable applications
497:03 - chapter 7 input and output
497:06 - input and output facilities are not part
497:09 - of the c language so we've de-emphasized
497:11 - them in our presentation thus far
497:14 - nonetheless real programs do interact
497:16 - with their environment in much more
497:18 - complicated ways than those we've shown
497:20 - before
497:22 - in this chapter we will describe this
497:24 - standard io library
497:26 - a set of functions designed to provide a
497:28 - standard i o system for c programs
497:30 - the functions are intended to present a
497:32 - convenient programming interface yet
497:35 - reflect only operations that can be
497:37 - provided on most modern operating
497:39 - systems
497:40 - the routines are efficient enough that
497:42 - users should seldom feel the need to
497:44 - circumvent them for efficiency
497:46 - regardless of how critical the
497:47 - application
497:49 - finally the routines are meant to be
497:51 - portable
497:52 - in the sense that they will exist
497:54 - in compatible form on any system or c
497:56 - exists and that programs which confine
497:59 - themselves
498:01 - to facilities provided by the stated
498:03 - library can be moved from one system to
498:05 - another essentially without change
498:08 - we will not try to describe the entire
498:10 - io library here we are more interested
498:12 - in showing the essentials of writing c
498:14 - programs that interact with our
498:15 - operating system environment
498:18 - section 7.1
498:19 - access to the standard library
498:22 - each source file that refers to the
498:24 - standard library function must contain
498:26 - the line pound include stdio.h near the
498:29 - beginning
498:30 - the file
498:32 - stdio.h defines certain macros and
498:34 - variables used by the i o library
498:37 - the use of angle brackets less than and
498:40 - greater than instead of the usual double
498:42 - quotes directs the compiler to search
498:44 - for the file in a directory containing
498:46 - the standard header information
498:48 - in unix this is often somewhere like
498:51 - slash user slash include
498:54 - furthermore it may be necessary when
498:56 - loading the program to specify the
498:57 - library explicitly for example on the
499:00 - pdp-11 unix system the command to
499:02 - compile a program would be
499:04 - cc
499:06 - source files etc
499:08 - dash ls capital s
499:11 - where dash l capital s indicates loading
499:13 - from the standard library
499:16 - section 7.2
499:20 - standard input and output
499:22 - catch our input char
499:24 - the simplest input mechanism is to read
499:26 - a character at a time from the standard
499:29 - input generally the user's terminal or
499:31 - keyboard with getchar getchar returns
499:34 - the next input character each time it's
499:36 - called
499:37 - in most environments that support c
499:39 - a file may be substituted for the
499:41 - terminal by using the less than config
499:43 - convention
499:44 - if a program prog uses get char then the
499:47 - command line prog less than infile
499:51 - causes probe to read infile instead of
499:53 - the terminal
499:54 - or keyboard
499:55 - the switching of input is done in such a
499:57 - way that prog is oblivious to the change
499:59 - in particular the string less than
500:01 - infile is not included in the command
500:04 - line arguments in argv
500:06 - the input switching is also invisible if
500:08 - the input comes from another program by
500:10 - a pipe mechanism
500:12 - the command line other probe vertical
500:15 - bar prog
500:16 - runs two programs other prog and prog
500:18 - and arranges for the standard input for
500:20 - prog to come from the standard output of
500:23 - other prog
500:25 - cat char returns the value eof when it
500:28 - encounters end-to-file on whatever input
500:30 - is being read the standard library
500:32 - defines the symbolic eof constant to be
500:35 - -1 with a pound defined in the file
500:38 - stdio.h
500:40 - but test should be written in terms of
500:42 - eof not negative 1. so is to be
500:45 - independent of the specific value for
500:47 - output put char open paren c close paren
500:51 - puts the character c on the standard
500:53 - output which is also by default the
500:56 - terminal
500:57 - or screen
500:58 - the output can be directed to a file by
501:00 - using greater than
501:02 - if probe uses put char prog greater than
501:05 - out file will write the standard output
501:06 - onto outfile instead of the terminal
501:09 - on the unix system a pipe can also be
501:11 - used
501:12 - prog vertical bar another prog puts the
501:15 - standard output of prog into the
501:17 - standard input of other prog
501:20 - again
501:20 - prog is not aware of the redirection
501:25 - output produced by printf also finds its
501:27 - way to the standard output and calls to
501:29 - put char and printf may be interleaved
501:32 - a surprising number of programs read
501:34 - only one input stream and write only one
501:37 - output stream
501:38 - for such programs i o with getchart
501:41 - putchar and printf may be entirely
501:43 - adequate and is certainly enough to get
501:45 - started
501:46 - this is particularly true given file
501:48 - redirection in a pipe file for
501:50 - connecting the output of one program to
501:51 - the input of the next
501:53 - for example consider the program lower
501:56 - which maps
501:57 - input to lower case
501:59 - this is an example on page 145 with a
502:02 - textbook that you can see at
502:04 - www.cc4e.com
502:08 - code pound include stdio.h
502:12 - pound includes c type dot h
502:15 - main open print close paren
502:17 - open curly brace int c
502:20 - while open paren open paren c equals get
502:23 - char open paren close paren close print
502:25 - not equal to eof close paren
502:29 - put char
502:30 - is upper open paren c close paren
502:32 - question mark two lower open paren c
502:35 - close paren colon c close paren
502:38 - semicolon close curly brace
502:42 - the functions is upper and two lower are
502:44 - actually macros defined in c type dot h
502:47 - the macro is upper tests whether its
502:49 - argument is an uppercase letter
502:50 - returning non-zero if it is and zero if
502:52 - it's not the macro two lower converts an
502:55 - uppercase to lowercase letter
502:57 - regardless of how these functions are
502:59 - implemented on a particular machine
503:00 - their external behavior is the same
503:02 - so programs that use them are shield
503:04 - shielded from the knowledge of their
503:06 - character set
503:07 - to convert multiple files you can use a
503:10 - program
503:11 - like the unix cat to collect files cat
503:15 - file1 file2.verticalbar
503:18 - lower greater than output and thus avoid
503:21 - learning how to access files from a
503:22 - program
503:24 - the cad example is presented later as
503:26 - example code in this chapter
503:28 - as an aside
503:30 - the standard io library functions
503:32 - getchar and put char can actually be
503:35 - macros and thus
503:37 - avoid the overhead of a function call
503:39 - per character we'll show this how this
503:41 - is done in chapter 8.
503:44 - section 7.3 formatted output printf
503:48 - the two routines printf for output and
503:51 - scanf f4 input which we describe in the
503:53 - next section permit translation to and
503:55 - from character representations of
503:57 - numerical quantities
503:59 - they also allow generation or
504:00 - interpretation of formatted lines
504:03 - we've used printf informally throughout
504:05 - the previous chapters here is a more
504:07 - complete and precise description
504:10 - printf open paren control com arg1 comma
504:13 - card 2 etc close paren
504:16 - printf converts formats and prints its
504:19 - arguments on the standard output under
504:21 - this under the control of the string
504:23 - control the control string contains two
504:26 - type of objects ordinary characters
504:28 - which are simply copied to the output
504:30 - stream
504:31 - and conversion specifications each of
504:33 - which causes conversion and printing of
504:36 - the next successive argument to printf
504:39 - each conversion specification is
504:41 - introduced by the character sense sign
504:43 - and ended by a conversion character
504:46 - between the percent and the conversion
504:48 - character there may be a minus sign
504:50 - which specifies left adjusted of the
504:53 - left adjustment of the converted
504:54 - argument in its field
504:56 - a digit string specified a minimum field
504:59 - width
505:00 - the converted number will be printed in
505:02 - a field at least this wide and wider if
505:04 - necessary
505:05 - if the converted argument has fewer
505:07 - characters than the field it will be
505:09 - padded on the left or right if the left
505:12 - adjustment indicator's been given to
505:14 - make up the field width
505:16 - the padding character is normally blank
505:18 - in zero if the field width is specified
505:21 - with a leading zero
505:22 - this zero does not imply an octal field
505:25 - with
505:26 - a period
505:27 - which separates the field width from the
505:28 - next digit string
505:30 - a digit string
505:32 - that specifies the precision which
505:34 - specifies the maximum number of
505:35 - characters to be printed from a string
505:37 - or the number of digits to be printed to
505:39 - the right of the decimal point of a
505:41 - float or a double
505:43 - a length modifier the letter l
505:46 - which indicates that the corresponding
505:49 - data item is along rather than an end
505:54 - conversion characters and their meanings
505:56 - are
505:57 - d
505:58 - the arguments converted to decimal
505:59 - notation o the argument is converted to
506:02 - unsigned octal notation without a
506:04 - leading zero
506:05 - x
506:06 - the argument is converted to unsigned
506:08 - hexadecimal notation without the leading
506:10 - 0x
506:12 - u the argument is converted to unsigned
506:14 - decimal notation
506:16 - c
506:17 - the argument is taken to be a single
506:19 - character
506:20 - s the argument is a string
506:23 - characters from the string are printed
506:24 - until a null character is reached or the
506:26 - number of characters indicated by the
506:28 - present precision specification is
506:30 - exhausted
506:32 - e the argument is taken to be a float or
506:34 - a double and converted to decimal
506:36 - notation of the form
506:38 - optional minus sign
506:40 - m dot nnn
506:42 - capital e plus or minus xx where the
506:45 - length of the string of the ends is
506:46 - specified by the precision the default
507:03 - by precision
507:04 - the default precision is 6.
507:06 - note that the precision does not
507:08 - determine the number of significant
507:09 - digits printed in the f format
507:13 - g
507:14 - says use percent e or percent f which
507:17 - ever is shorter
507:19 - and non-significant zeros are not
507:20 - printed
507:22 - if the character after the percent is
507:24 - not a conversion character the character
507:26 - is simply printed thus percent may be
507:29 - printed as percent percent
507:32 - most of the format conversions are
507:34 - obvious and have been illustrated in the
507:36 - earlier chapter
507:37 - one exception is the precision field as
507:40 - it relates to strings the following
507:42 - table shows the effect of a variety of
507:45 - specifications in printing hello comma
507:47 - world which is 12 characters we put
507:50 - colons around each field so you can see
507:52 - its actual width
507:54 - colon percent 10 s colon
507:58 - colon hello world colon
508:01 - it's 12 characters long
508:03 - and so we get 12 characters printed
508:05 - because we haven't really told it to
508:06 - strictly limit that
508:09 - colon percent minus 10 s colon
508:12 - colon hello comma world colon no extra
508:15 - spaces
508:16 - again 12 characters are used even though
508:19 - if we said 10 it expands it to 12 and
508:22 - the fact that it's left justified seems
508:23 - how we're printing more than the width
508:25 - of the field
508:26 - doesn't make any difference
508:28 - colon percent 20 s colon
508:32 - colon eight spaces then hello comma
508:35 - world colon
508:36 - eight spaces are put in on the left
508:38 - because it by default is right justified
508:42 - colon
508:43 - percent minus 20 s colon
508:47 - prints colon hello comma world and then
508:50 - eight spaces and then colon
508:52 - we've told it to left justify so the
508:54 - eight spaces are added to fill it out to
508:56 - 20 spaces after hello world
509:00 - colon percent 20.10 s colon
509:04 - gives us colon and then 10 blanks and
509:07 - then hello comma w o r colon
509:10 - now in this case we've told it we really
509:13 - only want 10 characters from the string
509:15 - and so the the ld is truncated
509:19 - percent minus 20.10 s colon
509:24 - hello comma w o r
509:27 - and then 10 spaces
509:29 - and it's less justified so the ten
509:30 - spaces are at the end
509:32 - right before the colon
509:34 - colon percent dot 10 s colon colon hello
509:39 - comma wor colon so now the overall field
509:42 - that's printed is exactly 10 characters
509:44 - and it is the leftmost 10 characters
509:49 - warning
509:50 - printf uses its first argument to decide
509:53 - how many arguments follow and what their
509:55 - types are it will get confused and you
509:57 - will get nonsense answers if there are
509:59 - not arguments enough arguments or they
510:02 - are of the wrong
510:04 - type as an aside formatted output is
510:08 - difficult the design of c printf was
510:10 - inspired by the earlier format statement
510:13 - in fortran and alcohol in order to
510:15 - compete with those languages c needed to
510:17 - ship with solid support for formatted
510:19 - output the approach chosen by c
510:21 - percolated into c like languages php and
510:24 - java simply have a function called
510:26 - printf that mimics most of the c formats
510:30 - python has evolved its approach to
510:32 - formatted output over the years an early
510:35 - initial solution had a syntax that used
510:37 - percent to provide c like formatting
510:39 - there was also a format method on the
510:41 - string object
510:44 - for example
510:45 - x
510:47 - equals 421.34
510:51 - print open paren double quote x is
510:53 - percent 7.2 f
510:56 - double quote percent open paren x comma
510:59 - close paren close paren
511:02 - that uses the percent operator and sends
511:04 - a tuple but the syntax of percent seven
511:07 - point two f is the same another option
511:10 - is
511:10 - print open paren double quote x is
511:14 - open curly brace y colon 7.2 f
511:19 - close curly brace double quote dot
511:21 - format open paren y equals x close paren
511:25 - close paren
511:26 - this sends a set of key value pairs
511:30 - and it's a little clunky
511:33 - the latest and least clunky way to do it
511:36 - in modern python is what we call f
511:38 - strings
511:39 - and the code is print
511:41 - f double quote
511:45 - print open paren f double quote x is
511:49 - open curly brace x colon 7.2 f close
511:53 - curly brace double quote close paren
511:57 - but even after all this evolution much
511:59 - of this output formatting still traces
512:01 - its design inspiration from the nc
512:03 - printf capabilities back in 1978.
512:10 - formatted input scanf
512:12 - the function scanf is the input analog
512:15 - of printf providing many of the same
512:17 - conversion facilities but in the
512:19 - opposite direction
512:21 - scanf open paren control com arg1 comma
512:24 - r2 etc close paren scanf reads
512:27 - characters from standard input
512:28 - interprets them according to the format
512:30 - specified in control and stores the
512:32 - results in the remaining arguments the
512:34 - control argument is described below
512:37 - the other arguments each of which must
512:39 - be a pointer
512:41 - indicate where the converting
512:42 - corresponding converted input should be
512:45 - stored
512:46 - the control string usually contains
512:48 - conversion specifications which are used
512:50 - to direct interpretation of input
512:52 - sequences
512:53 - the control string may contain blanks
512:56 - tabs or new lines we call these white
512:58 - space characters which are ignored
513:00 - ordinary characters
513:02 - not
513:02 - percent which are expected to match the
513:04 - next non-white character space character
513:07 - of the input stream
513:08 - conversion specifications consisting of
513:11 - the character percent an optional
513:13 - assignment suppression character
513:14 - asterisk
513:15 - and an optional number specifying the
513:17 - maximum field width and a conversion
513:19 - character
513:21 - a conversion specification directs the
513:23 - conversion of the next input field
513:26 - normally the result is placed in the
513:27 - variable pointed to by the corresponding
513:30 - argument
513:31 - if assignment suppression is indicated
513:33 - by the asterisk character however the
513:35 - input field is parsed but then simply
513:37 - skipped no assignment is being made
513:40 - an input field is defined as a string of
513:42 - non-white space characters extent it
513:44 - extends to either the next white space
513:46 - character or until the field width if
513:48 - specified is exhausted
513:50 - this implies that scanf will read across
513:53 - line boundaries to find its input since
513:55 - new lines are white space
513:58 - the conversion character indicates the
514:00 - interpretation of the input field the
514:01 - corresponding argument must be a pointer
514:04 - as required by the call by value
514:05 - semantics of c
514:07 - the following conversion characters are
514:08 - legal
514:10 - d
514:11 - a decimal integer is expected on input
514:13 - the corresponding argument should be an
514:15 - integer pointer
514:17 - o
514:18 - an octal integer at with or without a
514:20 - leading zero is expected on input the
514:22 - corresponding argument should be an
514:24 - integer pointer
514:26 - x
514:27 - a hexadecimal integer with or without
514:29 - the leading zero x is expected in the
514:31 - input this corresponding argument should
514:33 - be an integer pointer
514:35 - h
514:36 - a short integer is expected in the input
514:39 - the corresponding argument should be the
514:41 - point a pointer to a short integer
514:43 - c
514:44 - a single character is expected the
514:46 - corresponding argument should be a
514:48 - character pointer the next input
514:50 - character is placed at the indicated
514:52 - spot
514:53 - the normal skip over white space
514:54 - characters is suppressed in this case to
514:56 - read the next non-white space character
514:59 - use percent one s
515:02 - s
515:03 - a character string is expected the
515:05 - corresponding argument should be a
515:07 - character pointer pointing to an array
515:09 - of characters large enough to accept the
515:10 - string and turn the terminating
515:12 - backslash zero which will be added
515:15 - f
515:16 - a floating point number is expected the
515:19 - corresponding argument should be a
515:21 - pointer to a float
515:22 - the conversion character e is a synonym
515:24 - for f
515:25 - the input formats for floats is an
515:27 - optional sign a string of numbers
515:29 - possibly containing a decimal point and
515:31 - an optional exponent field containing an
515:34 - upper or lower case e followed by
515:36 - possibly a signed integer
515:38 - the conversion character d o and x may
515:42 - be preceded by l the letter l
515:45 - to indicate that a pointer to a long
515:46 - rather than end appears in the argument
515:48 - list
515:49 - similarly the conversion characters e or
515:52 - f may be preceded by the letter l to
515:55 - indicate that it's a pointer to a double
515:57 - rather than a float in the argument list
516:01 - for example the call
516:04 - int i
516:05 - float x
516:07 - char
516:08 - name open square bracket 50 close square
516:10 - bracket close
516:11 - a semicolon
516:13 - scanf open parenthesis double quote
516:16 - percent d space percent f space percent
516:19 - s
516:20 - double quote comma ampersand i comma
516:23 - ampersand x comma name
516:26 - close paren semicolon with the input
516:28 - line
516:29 - 25 space 54.32
516:32 - e minus 1 space thomson
516:35 - we'll assign the value 25 to i
516:38 - the value 5.432
516:41 - to x and the string thompson properly
516:43 - terminated with a backslash 0 to name
516:46 - the three input fields may be separated
516:48 - by as many blanks tabs and new lines as
516:51 - desired
516:54 - the call
516:55 - int i semicolon float x semicolon char
516:59 - name open square bracket 50 close square
517:01 - bracket semicolon
517:03 - scanf double quote percent to d space
517:07 - percent f
517:08 - space
517:09 - percent star d
517:11 - space percent to s
517:14 - double quote comma ampersand i comma
517:16 - ampersand x common name close
517:18 - parentheses
517:20 - with input 56789 space 0 1 2 3 space
517:26 - 4 5 a 7 2 will assign 56 to i
517:31 - 7 89.0 to x
517:35 - skip over 0 1 2 3 and place the string
517:39 - 45 in name
517:42 - the next call to any input routine will
517:44 - begin searching at the letter a
517:47 - in these two examples
517:49 - name
517:50 - is a pointer and thus must not be
517:52 - preceded by an ampersand
517:55 - as another example the rudimentary
517:58 - calculator of chapter 4 can now be
518:00 - written with scanf to do the input put
518:02 - conversion
518:04 - this is example code on page 150 the
518:06 - textbook which you can see at
518:07 - www.cc4e.com
518:10 - code
518:12 - pound include stdio.h
518:14 - main open paren close paren open curly
518:17 - brace double sum comma v semicolon sum
518:21 - equals zero
518:23 - while open paren scanf open paren double
518:26 - quote percent l f
518:28 - double quote comma ampersand v
518:32 - close parenthesis not equal eof close
518:34 - parentheses printf open parenthesis
518:37 - double quote backslash t
518:39 - percent.2f backslash n
518:43 - double quote comma sum plus equals v
518:46 - close parenthesis semicolon close curly
518:48 - brace
518:50 - scanf stops when it's in when it
518:52 - exhausts control string or when some
518:55 - input fails to match the control
518:56 - specification it returns as its function
518:59 - residual value the number of
519:01 - successfully matched and assigned input
519:03 - items this can be used to decide how
519:05 - many input items were found
519:07 - on end to file eof is returned note that
519:10 - this is different from zero which means
519:12 - that the next input character does not
519:14 - match the first specification in the
519:16 - control string the next call to scanf
519:19 - resume searching immediately after the
519:21 - last character already returned
519:24 - a final warning the arguments to scanf
519:26 - must be pointers
519:28 - by far the most common error is writing
519:31 - scanf open paren double quote percent d
519:35 - percent comma n
519:37 - close paren semicolon instead of scanf
519:40 - open paren double quote percent d double
519:44 - quote comma ampersand n close paren
519:47 - semicolon
519:49 - section 7.5 in memory format conversion
519:53 - the functions scanf and printf have
519:55 - siblings called scan f and s printf
519:58 - which perform the corresponding
520:00 - conversion but operate on a string
520:02 - instead of a file the general format is
520:06 - s printf open paren string comma control
520:10 - comma arg one comma r two dot dot close
520:13 - paren
520:14 - s scan f open paren string comma control
520:17 - comma arg one comma r two et cetera
520:20 - close paren
520:22 - sprint s print f formats the arguments
520:25 - in arg1 arg2 etc according to control as
520:28 - before but it places the result in a
520:30 - string instead of on the standard output
520:32 - of course string had better be big
520:34 - enough to receive the result as an
520:36 - example
520:37 - if the name is a character array and n
520:39 - is an integer then
520:41 - s printf open paren name comma
520:44 - double quote temp percent d double quote
520:47 - comma n
521:03 - arg2 etc these arguments must be pointer
521:07 - the
521:08 - call scanf open paren name comma double
521:12 - quote temp percent d double quote comma
521:15 - ampersand n
521:16 - close parenthesis semicolon
521:18 - sets n to the value of the digits
521:22 - following
521:23 - temp in name
521:27 - section 7.6 file access
521:30 - as inside the next two sections do a
521:33 - nice job of covering file input and the
521:35 - notion of the standard error with simple
521:37 - sample code
521:38 - but the authors are also making a subtle
521:41 - point about unix
521:42 - and how the design of c makes it easy to
521:44 - build unix utilities
521:47 - by the end of section 7.6 we see a 29
521:50 - line program that is pretty much a
521:52 - complete implementation of the core
521:55 - functionality of the unix cat command
521:58 - part of the philosophy of unix was to
522:00 - build commands that are each simple
522:01 - building blocks that can be composed
522:03 - using standard input standard output
522:06 - redirection as well as pipes
522:08 - these next two sections are a gentle
522:10 - celebration of the design principles
522:12 - that underlie the unix operating system
522:15 - also
522:16 - while we're talking about the linkage
522:17 - between c and unix there is a
522:20 - unix-related easter egg earlier in the
522:22 - chapter
522:22 - see if you can find it
522:24 - bonus points if you already noticed it
522:30 - the programs written so far have all
522:32 - read the standard input and written the
522:33 - standard output which we have assumed
522:36 - are magically predefined for a program
522:38 - by the local operating system
522:40 - the next step in i o is to write a
522:42 - program that accesses a file which is
522:43 - not already connected to the program
522:46 - one program that clearly illustrates the
522:48 - need for such operations is cat which
522:51 - concatenates a set of name files onto
522:53 - standard output cad is used for printing
522:55 - files on a terminal and is a general
522:57 - purpose input collector for programs
522:59 - which do not have the capability of
523:01 - accessing files by name for example the
523:04 - command cat
523:05 - x dot c y dot c prints the contents of
523:09 - the files x dot c and y.c on the
523:11 - standard output
523:13 - the question is how to arrange for the
523:15 - named files to be read that is how to
523:17 - connect the external names the user that
523:19 - the user thinks of to the statements
523:20 - which actually read the data
523:22 - the rules are simple before it can be
523:25 - read or written the file has to be
523:26 - opened by the standard library function
523:28 - f open
523:30 - f open takes an external name like x dot
523:32 - c or y dot c does some housekeeping and
523:35 - negotiating with the operating system
523:37 - some details of which do not need to
523:38 - concern us and returns an internal name
523:41 - which then must be used for subsequent
523:42 - reads or rights of the file
523:45 - the internal name is actually a pointer
523:47 - called the file pointer to a structure
523:49 - which contains information about the
523:51 - file such as the location of a buffer
523:53 - the current character position in the
523:55 - buffer whether the file is being read or
523:57 - written and similar
523:59 - users don't need to know the details
524:01 - because part of the standard i o
524:02 - definitions are obtained from stdio.a
524:06 - and it's a structured definition called
524:09 - file
524:10 - the only declaration needed for a file
524:12 - pointer is exemplified by
524:14 - file star f open open paren close paren
524:17 - comma star fp semicolon
524:21 - that says that fp is a pointer to a file
524:24 - and f open returns a pointer to a file
524:27 - note that file is a type name like int
524:30 - not a structure tag it's implemented as
524:32 - a typedef details on how all this works
524:35 - on the unix system are given in chapter
524:38 - eight
524:39 - the actual call to f open in a program
524:41 - is
524:42 - fp equals
524:44 - f open open paren name comma mode close
524:48 - paren semicolon
524:50 - the first argument of f open is the name
524:52 - of the file as a character string the
524:55 - second argument is the mode also a
524:57 - character string which indicates how one
524:59 - intends to use the files
525:01 - allowable modes are read
525:04 - are
525:04 - write w or append a
525:08 - if you open a file which does not exist
525:10 - for writing or appending it is created
525:12 - if possible
525:14 - opening an existing file for writing
525:16 - causes the old constants to be discarded
525:19 - trying to read a file that does not
525:20 - exist is an error and there may be other
525:23 - causes of error as well like trying to
525:25 - read a file when you don't have
525:26 - permission
525:27 - if there is any error f open will return
525:30 - the null pointer with a value of null
525:33 - which for convenience is also defined in
525:35 - stdio.h
525:37 - the next thing needed is a way to read
525:39 - or write the file once it is open
525:41 - there are several possibilities of which
525:44 - get c and putsy are the simplest
525:46 - getc returns the next character from a
525:49 - file
525:50 - it needs the file pointer to tell what
525:52 - file thus
525:53 - c
525:54 - equals getc open paren fp close paren
525:58 - places in c the next character from the
526:00 - file referenced by fp and eof when it
526:03 - reaches end of file
526:05 - put c is the inverse of get c
526:08 - put c open paren c comma f p close paren
526:11 - puts the character c on the file fp and
526:14 - returns c
526:16 - like getchar and putchar gets the input
526:18 - c may be macros instead of functions
526:21 - when a program is started three files
526:23 - are automatically opened and file
526:25 - pointers are provided for them
526:27 - these files are the standard input the
526:30 - standard output and the standard error
526:32 - output the corresponding file pointers
526:35 - are called stdin
526:36 - sddi out and stder
526:40 - normally these are all connected to the
526:42 - terminal but stdn and std out may be
526:45 - redirected to files or pipes as
526:47 - described in section 7.2
526:50 - getchar and putchar can be defined in
526:53 - terms of getc put c std in and std out
526:56 - as follows
526:57 - pound define get char open for n close
527:00 - paren get c open paren stdin close paren
527:05 - pound define put char open paren c close
527:08 - paren put c open for n c comma std out
527:12 - close paren
527:13 - for formatted input or output files the
527:16 - function f scan f and f printf may be
527:19 - used these are identical to scanf and
527:21 - printf
527:23 - save that the first argument is a file
527:25 - pointer that specifies the file to be
527:26 - read or written the second string is the
527:29 - control the
527:30 - second argument is the control string
527:34 - with these preliminaries out of the way
527:36 - we are now in a position to write the
527:38 - program cat to concatenate files
527:41 - the basic design is one that has been
527:43 - found convenient for many programs if
527:45 - there are command line arguments they
527:47 - are processed in order if there are no
527:49 - arguments the standard input is
527:51 - processed this way the program
527:53 - can be used standalone or part of a
527:55 - larger process
527:58 - this example is on page 153 of the
528:01 - textbook and you can see it at
528:03 - www.cc4e.com
528:07 - code
528:09 - pound include stdio.h
528:12 - main open paren argc comma argv closed
528:15 - paren
528:16 - int argc semicolon
528:18 - char star argv
528:20 - open square bracket close square bracket
528:22 - semicolon
528:24 - open curly brace
528:26 - file star fp comma star f open open
528:30 - chrome close print semicolon
528:33 - if open paren rxc double equals one
528:36 - close paren
528:38 - there is no standard there's no
528:40 - arguments so we're going to copy the
528:41 - standard input
528:43 - file copy open paren
528:45 - stdin close paren semicolon else
528:49 - while open paren minus minus rxc greater
528:51 - than zero
528:53 - close paren
528:54 - if
528:56 - open paren open paren fp equals f open
528:59 - open paren star plus plus arc v comma
529:03 - quote r quote close paren close paren
529:06 - double equals null close paren open
529:07 - curly brace
529:09 - print
529:11 - f open print double quote cat colon
529:14 - can't open
529:16 - space percent s backslash n double quote
529:19 - star comma star r v close paren
529:22 - semicolon
529:24 - break semicolon
529:26 - close curly brace else open curly brace
529:29 - file copy open paren fp close paren
529:31 - semicolon f close open paren fp close
529:35 - print semicolon
529:36 - close curly brace for the if then else
529:39 - and then close curly brace for the main
529:42 - and now we have the file copy function
529:45 - we're going to open read all the
529:47 - contents of a file pointer and send it
529:49 - to standard output
529:50 - file copy open paren fp close paren
529:54 - file star fp semicolon open curly brace
529:58 - int c semicolon while open paren open
530:02 - for n c equals get c open paren fp close
530:06 - print close paren not equal eof close
530:09 - paren put c open paren
530:12 - c comma std o ut close paren semicolon
530:16 - close curly brace
530:18 - the file pointers std in and std out are
530:22 - predefined in the i o library as the
530:24 - standard input and the standard output
530:26 - they may be used anywhere an object of
530:28 - type file star can be they are constants
530:31 - however not variables so don't try to
530:33 - assign to them
530:35 - the function f close is the inverse of f
530:37 - open it breaks the connection between
530:39 - the file pointer and the external name
530:40 - that was established by x f open freeing
530:43 - the file pointer for another file
530:45 - since most operating systems have some
530:47 - limit on the number of simultaneously
530:49 - open files a program may have it's a
530:51 - good idea to free things when they're no
530:53 - longer needed as we did above in cat
530:56 - there's also another reason for f close
530:58 - on an output file it flushes the buffer
531:00 - in which put c is collecting output
531:03 - fclose is called automatically for each
531:05 - open file when a program terminates
531:08 - normally
531:10 - section 7.7 error handling stder and
531:15 - exit
531:16 - the treatment of errors in the previous
531:19 - implementation of cat is not ideal the
531:21 - trouble is that if one of the files
531:23 - can't be accessed for some reason the
531:25 - diagnostic is printed at the end of the
531:27 - concatenated output
531:29 - that is acceptable if the output's going
531:31 - to a terminal but it's really bad if
531:33 - it's going to a file or some other
531:35 - program via pipeline
531:37 - to handle this situation better a second
531:39 - output file called stderr is assigned to
531:42 - the program in the same way that stdin
531:45 - and std out are
531:48 - if at all possible output written on
531:50 - stderr appears on the user's terminal
531:54 - even if the standard output
531:56 - is redirected
531:58 - let's revise cat to write its error
532:01 - messages onto the standard output file
532:06 - this is really only a couple of lines of
532:08 - code different between the example on
532:11 - page 153 this is the example on page 154
532:15 - of the textbook which of course you can
532:17 - see at
532:18 - www.cc4e.com
532:22 - code
532:23 - pound include stdio.h
532:26 - pound include stdlib.h
532:29 - open paren argh c comma arc v close
532:32 - paren int argc semicolon
532:35 - char star arc v open square bracket
532:37 - close square bracket
532:38 - semicolon open curly brace
532:41 - file star fp comma star f open
532:45 - open paren close paren semicolon
532:48 - if open for n r c double equal one close
532:51 - paren
532:52 - here we have no arguments
532:54 - file copy open paren s t d i close
532:57 - parent semicolon else
532:59 - while open paren minus minus argc
533:02 - greater than zero close paren
533:05 - if open paren open paren fp equals f
533:08 - open open print star plus plus arg v
533:11 - comma
533:13 - double quote r double quote close paren
533:15 - and close for n double equal null
533:17 - close paren open curly brace
533:19 - f print f open paren std e r r comma
533:25 - double quote cat colon
533:27 - can't open
533:28 - percent s backslash n double quote comma
533:32 - star r v close paren semicolon
533:35 - exit open paren one close brand
533:38 - semicolon close curly brace else open
533:42 - curly brace file copy open paren fp
533:46 - close paren semicolon
533:48 - file close open print fp close paren
533:50 - semicolon close curly brace to finish
533:53 - the if and then exit
533:55 - open paren zero close paren semicolon
533:58 - close curly brace
534:00 - to the uh change the finish the main
534:03 - and file copy we is the same from the
534:05 - previous so
534:07 - this program signals errors two ways the
534:10 - diagnostic output produced by fprintf
534:13 - goes to stderr so it finds its way to
534:15 - the user's terminal instead of
534:17 - disappearing down a pipeline pipeline or
534:19 - into an output file the program also
534:22 - uses the standard library function exit
534:24 - which terminates execution when it's
534:26 - called the argument of exit is available
534:28 - to whatever process called this one so
534:30 - the success or failure of the program
534:32 - can be tested by another program that
534:34 - uses this one as a sub process
534:37 - by convention a return value of 0
534:40 - signals all as well and various non-zero
534:42 - values signal abnormal situations
534:45 - exit calls f-close for each open output
534:48 - file to flush any buffered output then
534:51 - calls a routine named underscore exit
534:53 - the function underscore exit causes
534:55 - immediate termination without any buffer
534:57 - flushing of course it may be called
534:59 - directly if desired
535:01 - section 7.8 line input and output
535:05 - the standard library provides a routine
535:08 - f git s which is quite similar to the
535:09 - getline function we've used throughout
535:11 - the book
535:12 - the call fcds open paren line comma max
535:15 - line comma fp close paren reads the next
535:18 - input line including the new line from
535:20 - the file fp into the character array
535:23 - line
535:24 - at most max line minus 1 characters will
535:27 - be red the resulting line is terminated
535:30 - with backslash zero normally f cades
535:33 - returns line on end to file it returns
535:35 - null
535:36 - our getline returns line length and zero
535:38 - friend to file
535:40 - for output the function f put s writes a
535:42 - string which need not contain a new line
535:44 - to a file f put s open paren line comma
535:48 - fp close paren
535:50 - to show there's nothing magic about the
535:52 - functions like f get s and f put s here
535:55 - they are copied directly from the unix
535:58 - standard io library
536:01 - this
536:02 - code example is on page 155 of the
536:05 - textbook which you can view at
536:06 - www.cc4e.com
536:09 - code
536:11 - char
536:12 - star
536:12 - f get s open paren s comma n comma iop
536:16 - close paren
536:17 - char star s semicolon
536:20 - in n semicolon register file star iop
536:25 - semicolon
536:26 - open curly brace
536:28 - register int c semicolon register char
536:32 - star cs semicolon
536:34 - cs equals s semicolon
536:37 - while open paren minus minus n greater
536:39 - than zero double ampersand open paren c
536:43 - equals get c open paren iop close print
536:46 - close paren not equal eof close paren
536:50 - if
536:51 - open paren open paren star cs plus plus
536:54 - equals c close print equal equal
536:58 - quote backslash n quote close paren
537:01 - break semicolon
537:03 - star cs equals
537:06 - quote backslash zero quote
537:08 - semicolon return
537:11 - open paren open paren c
537:13 - double equals e o f
537:15 - and c s double equals s close paren
537:19 - question mark null
537:21 - colon s close paren semicolon close
537:25 - curly brace
537:27 - the function f put s is as follows
537:30 - f put s open paren s comma iop close
537:33 - paren
537:35 - register char star s register file star
537:38 - iop semicolon open curly brace
537:42 - register int c semicolon while open
537:45 - paren c equals star s plus plus close
537:49 - paren
537:50 - put c open for n c comma iop close paren
537:54 - semicolon close curly brace
537:58 - section 7.9 some miscellaneous functions
538:02 - the standard library provides a variety
538:04 - of functions a few which stand out is
538:06 - especially useful we've already
538:08 - mentioned the string functions sterlin
538:11 - stir cpy
538:12 - stir cat and stir comp here are some
538:15 - others
538:16 - character class testing and
538:18 - conversion several macro rows perform
538:21 - character tests and conversions
538:24 - the function is alpha open paren c close
538:26 - print returns non-zero if c is
538:29 - alphabetic zero if not the function is
538:32 - upper open paren c close paren is
538:35 - returns non-zero if c is upper case
538:38 - zero if not
538:39 - is lower open paren c close paren is
538:42 - non-zero if c is lower case is zero if
538:44 - not
538:45 - is digit open paren c close paren is
538:47 - non-zero fc is a digit zero if not
538:50 - is space open friends c close paren
538:54 - is non-zero if c is blank tab or new
538:56 - line zero if not
538:58 - two upper open paren c close paren
539:00 - convert c to upper case
539:02 - two lower open parenthesis close paren
539:05 - convert c
539:06 - to lower case those all worked on single
539:09 - characters
539:11 - on get c
539:12 - the standard library provides a rather
539:14 - restricted version of the function
539:16 - ungetch which we wrote in chapter four
539:19 - it's called ungetc
539:21 - ungetc open paren c comma fp close paren
539:25 - pushes the character c back onto the
539:27 - file fp
539:29 - only one character of pushback is
539:31 - allowed per file
539:33 - unget c may be used with any of the
539:35 - input functions in macros like scan f
539:37 - get c or get char
539:40 - system call the function system open
539:43 - paren s close paren executes the command
539:46 - in the character string s
539:48 - then resumes the execution of the
539:50 - current program the contents of s
539:53 - depends strongly on the local operating
539:55 - system
539:56 - as a trivial example on unix the line
539:59 - system open for end double quote date
540:02 - double quote close paren semicolon
540:04 - causes the date program to be run it
540:07 - prints the time and date of the day on
540:10 - unix
540:12 - storage management
540:15 - the function c alec is rather like the
540:17 - alec we have used in previous chapters
540:19 - see alec open paren n comma size of
540:23 - open paren object close paren close
540:25 - paren
540:26 - returns a pointer to enough space for n
540:29 - objects of the specified size or null if
540:32 - the request cannot be satisfied the
540:34 - storage is initialized to zero the
540:36 - pointer has the proper alignment for the
540:38 - object in question but it should be cast
540:40 - to the appropriate type as in
540:42 - char star c alec open friend close paren
540:45 - semicolon int star ip semicolon ip
540:50 - equals open paren int star close paren c
540:53 - alec open paren n comma size of open
540:57 - paren int close paren close paren
540:59 - semicolon
541:01 - c free open paren p close print
541:04 - free space pointed to by p
541:07 - where p is originally obtained by a call
541:09 - to see alec there are no restrictions on
541:12 - the order in which space is freed but it
541:14 - is a ghastly error to free something
541:17 - not obtained by calling seahawk
541:20 - chapter 8 shows the implementation of a
541:23 - storage allocator like c alec in which
541:25 - the allocated blocks may be freed in any
541:28 - order
541:30 - this work
541:31 - is based on the 1978 c programming book
541:34 - written by brian w kernighan and dennis
541:36 - m ritchie
541:38 - their book is copyright all rights
541:40 - reserved by at t
541:41 - but is used in this work under fair use
541:44 - because of the book's historical and
541:46 - scholarly significance
541:48 - its lack of availability and the lack of
541:50 - an accessible version of the book
541:52 - the book is augmented in places to help
541:54 - understand its rightful place in a
541:56 - historical context amidst the major
541:58 - changes of the 1970s and 1980s as
542:01 - computer science evolved from a hardware
542:03 - first vendor-centered approach to a
542:05 - software-centered approach where
542:07 - portable operating systems and
542:08 - applications written in c could run on
542:11 - any hardware
542:13 - this is not the ideal book to learn c
542:15 - programming because the 1978 edition
542:17 - does not reflect the modern c language
542:20 - using an obsolete book gives us an
542:22 - opportunity to take students back in
542:24 - time and understand how the c language
542:26 - was evolving as it laid the groundwork
542:29 - for a future with portable applications
542:35 - chapter 8 the unix system interface
542:38 - the material in this chapter is
542:39 - concerned with the interface between c
542:41 - programs and the unix operating system
542:44 - since most c programs are on unix
542:46 - systems this should be helpful to a
542:47 - majority of the readers
542:49 - even if you see on a different machine
542:51 - however you should be able to glean more
542:53 - insight into c programming from studying
542:55 - these examples
542:57 - this chapter is divided into three major
542:59 - areas input output file system and a
543:02 - storage allocator the first two parts
543:05 - assume a modest familiarity with the
543:07 - external characteristics of
543:10 - unix
543:11 - chapter 7 was concerned with a system
543:13 - interface that is uniform across a
543:14 - variety of operating systems on any
543:17 - particular system the routines of the
543:19 - standard library have to be written in
543:21 - terms of the i o facilities that are
543:22 - actually available on the host system
543:25 - in the next few sections will describe
543:27 - the basic system entry points for i o
543:29 - and uni on the unix operating system and
543:31 - illustrate how parts of the standard
543:33 - library can be implemented with them
543:38 - but
543:38 - as an aside the dual nature of c and
543:41 - unix has been on display throughout the
543:43 - book
543:44 - and while this chapter is called the
543:46 - unix system interface
543:48 - in a sense it's less about unix in
543:50 - itself and very much about why c is such
543:53 - a great programming language
543:55 - let me explain
543:57 - before unix and c became the norm
544:00 - operating systems and operating system
544:01 - utilities those commands were used
544:03 - interactively and batch jobs were quite
544:06 - often written in the assembly language
544:07 - of the computer which it was supporting
544:10 - often there were not well-documented api
544:12 - calls between utilities in assembly
544:14 - language and the assembly language which
544:16 - implemented the operating system
544:18 - smart
544:20 - vendor programmers would just look at
544:21 - the operating system code and write
544:23 - their utility code to work with it
544:25 - this section shows that a language that
544:28 - has features like structures arrays
544:31 - pointers
544:32 - a preprocessor and unions was
544:35 - sufficiently rich
544:37 - so that we could document all the
544:39 - intricate interfaces with an operating
544:41 - system using a relatively high level
544:44 - language and then we could write our
544:46 - utility code like cat
544:48 - in a high-level language as well
544:51 - in this chapter the authors are almost
544:53 - shouting
544:54 - quit using assembly language to build
544:56 - your operating system and utility code
544:59 - further they are showing us examples
545:01 - designed to answer the question that
545:03 - might come from programmers used to the
545:05 - old ways like can we do
545:08 - x y z and c
545:10 - the author's emphatic answer in the
545:12 - increasingly intricate code samples is
545:15 - c is not a toy language that's only
545:17 - something used by a few att computer
545:19 - scientists in a research lab
545:21 - if you're doing serious system stuff
545:24 - that needs maximum performance and
545:26 - readability and reliability use c
545:30 - this chapter shows c in all its glory
545:33 - and shows why it was such an important
545:36 - language
545:37 - to enable the world of technology we
545:39 - have 40 years later
545:41 - at the end of the chapter we'll talk a
545:42 - little bit about see how c enabled the
545:45 - creation of easier to use programming
545:47 - languages and why it was so important to
545:51 - invent c inspired languages like python
545:53 - ph g and and php and java
545:56 - once c became the established systems
545:59 - programming language
546:01 - section 8.1
546:03 - file descriptors
546:05 - in the unix operating system all input
546:07 - and output is done by reading or writing
546:10 - files because all peripheral devices
546:12 - even the user's terminal are files in
546:14 - the file system
546:16 - this means that a single homogeneous
546:18 - interface handles all communications
546:20 - between a program and peripheral devices
546:24 - in the most general case before reading
546:26 - or writing a file it is necessary to
546:28 - inform the system of your intent to do
546:30 - so
546:31 - a process called opening the file
546:34 - if you're going to write on a file it
546:36 - may also be necessary to create it
546:38 - the system checks for your right to do
546:40 - so
546:41 - does the file exist do you have
546:43 - permission to access it and if all is
546:45 - well returns to the program a small
546:47 - positive integer called the file
546:49 - descriptor
546:50 - whenever i o is to be done on the file
546:52 - the file descriptor is used instead of
546:54 - the name to identify the file
546:57 - this is roughly analogous to the use of
547:00 - read open paren five comma dot dot dot
547:02 - and write open paren six comma dot dot
547:04 - dot in fortran
547:07 - all information about an open file is
547:09 - maintained by the system
547:11 - the user refers to the file only by the
547:14 - file descriptor
547:16 - since input and output involving the
547:17 - user terminal is so common
547:20 - special arrangements exist to make this
547:22 - convenient
547:23 - in the command interpreter the shell
547:25 - runs a program it opens three files with
547:28 - files descriptors 0 1 and 2 called the
547:32 - standard input standard output and
547:34 - standard error output
547:37 - all of these are normally connected with
547:38 - a terminal so if a program reads file
547:40 - descriptor 0 and writes to file
547:42 - descriptors 1 and 2 it can do terminal i
547:44 - o without worrying about opening the
547:46 - files
547:48 - the user of the program can redirect
547:50 - input output to and from files with less
547:53 - than and greater than
547:55 - for example probe less than in file
547:58 - greater than out file
548:00 - in this case the shell changes the
548:02 - default assignments for file descriptors
548:04 - 0 and 1 from the terminal to the named
548:07 - files
548:08 - normally file descriptor 2 remains
548:10 - attached to the terminal so error
548:12 - messages can go there
548:14 - similar observations hold if the input
548:16 - or output is associated with a pipe
548:19 - in all cases it must be noted that the
548:22 - file assignments are changed by the
548:24 - shell not the program
548:26 - the program does not know where its
548:27 - input comes from nor where its output
548:30 - goes so long as it uses file 0 for input
548:33 - and 1 and 2 for output section 8.2
548:37 - low level i o read and write
548:41 - this lowest level of i o in unix
548:43 - provides no buffering or any other
548:45 - services
548:46 - it is in fact a direct entry into the
548:48 - operating system all input and output is
548:51 - done by two functions called read and
548:53 - write
548:54 - for both the first argument is a file
548:57 - descriptor
548:58 - the second argument is a buffer in your
549:00 - program where the data is to come from
549:02 - or go to
549:03 - the third argument is the number of
549:05 - bytes to be transferred the calls are
549:08 - and read equals read open paren fd comma
549:12 - buff comma n close brand semicolon
549:15 - and written equals write open paren ft
549:19 - fd comma buff comma n close paren
549:22 - semicolon
549:24 - each call returns a byte count
549:26 - which is the number of bytes actually
549:28 - transferred
549:29 - on reading the return the number of
549:31 - bytes returned may be less than the
549:32 - number of number asked for a return
549:35 - value of zero bytes implies end to file
549:38 - and negative one indicates an error of
549:40 - some sort for writing the return value
549:43 - is the actual number of bytes written it
549:45 - is generally an error if this isn't
549:47 - equal to the supposed number that was
549:50 - asked to be written
549:52 - the number of bytes to be written read
549:54 - or written is quite arbitrary the two
549:57 - most common values are 1 which means 1
550:00 - character at a time or unbuffered and
550:02 - 512 which corresponds to the physical
550:05 - block size on many early peripheral
550:07 - devices
550:09 - this ladder size will be most efficient
550:11 - even but even a character at a time i o
550:13 - is not inordinately expensive
550:17 - putting these facts together we can
550:18 - write a simple program to copy its input
550:21 - to its output
550:22 - the equivalent of the file copying
550:25 - program written for chapter one
550:27 - in unix
550:28 - this program will copy anything to
550:30 - anything
550:31 - since input and output can be redirected
550:34 - to any file or device
550:36 - this example is on page 161 of the
550:38 - textbook which you can
550:40 - view at w www.cc4e.com
550:43 - code
550:45 - pound include standard stdio.h
550:49 - pound defined buff size
550:51 - 512. this is the best size for pdp 11
550:54 - unix
550:56 - modern computers it probably should be
550:57 - larger
550:58 - main open print close print open curly
551:01 - brace
551:02 - char buff open square bracket buff size
551:05 - close square bracket semicolon
551:07 - int n
551:08 - semicolon while open paren open paren n
551:12 - equals read open paren zero comma buff
551:16 - comma buff size close paren close paren
551:19 - greater than zero close paren right open
551:22 - paren one comma buff comma n close paren
551:26 - semicolon close curly brace
551:29 - if the file size is not an exact
551:31 - multiple of buff size some read will
551:33 - return a smaller number of bytes to be
551:35 - written by write
551:37 - the next call after that read will
551:39 - return zero
551:41 - it is instructive to see how read and
551:42 - write can be used to construct higher
551:44 - level routines like get char and put
551:46 - char for example here is a version of
551:48 - get char which does unbuffered input
551:52 - this is the second example on page 162
551:56 - of the textbook
551:58 - pound include
551:59 - stdio.h pound define
552:02 - cmask0377
552:04 - and this is a mask an octal mask to make
552:07 - sure characters are greater than zero
552:10 - get char open paren close paren open
552:13 - curly brace
552:14 - char c
552:16 - semicolon return open paren open paren
552:19 - read open paren 0 comma ampersand c
552:24 - comma 1 close print greater than 0 close
552:27 - print question mark
552:29 - c ampersand c mask
552:32 - colon e o f
552:34 - semicolon close curly brace
552:37 - c must be declared char because read
552:40 - accepts a character pointer the
552:42 - character being returned must be masked
552:44 - with 0 3 7 7 to ensure that it's
552:46 - positive otherwise
552:48 - sign extension might make it negative
552:50 - the constant 037 is appropriate for
552:54 - ascii
552:55 - and the pdp-11 but not necessarily for
552:57 - every other machine
553:00 - the second version of get char does its
553:03 - input in big chunks
553:05 - and hands out the characters one at a
553:07 - time
553:09 - this is the
553:10 - first example on page 162 of the
553:12 - textbook which you can see at www.ccf
553:17 - code
553:19 - pound include stdio.h
553:21 - pound define cmask0377
553:25 - pound define buff size 512.
553:29 - now we do the buffered version of get
553:30 - char
553:31 - get char open friend close paren open
553:34 - curly brace
553:35 - static char buff open square bracket
553:38 - buff size close square bracket
553:41 - static char star buff p equals buff
553:44 - semicolon static int n equals zero
553:48 - semicolon
553:49 - those variables are static so that they
553:52 - they are long lived and exist from call
553:55 - to call
553:57 - the beginning of the code if open paren
554:00 - n double equals 0 close print open curly
554:02 - brace n equals read
554:05 - open paren 0 comma buff comma buff size
554:07 - close paren semicolon
554:10 - buff p equals buff semicolon close curly
554:13 - brace return
554:15 - open paren open paren minus minus n
554:18 - greater than equal to zero close paren
554:21 - question mark star buff p plus plus
554:24 - ampersand c mask colon eof close print
554:28 - semicolon close curly brace
554:30 - section 8.3 open create close unlink
554:36 - create is not created it's create
554:38 - without the e so i'll just call it creat
554:40 - for now
554:42 - other
554:43 - than the default standard input and
554:45 - output and error files you must
554:46 - explicitly open files in order to read
554:48 - or write them there are two system entry
554:50 - points for this
554:52 - open and create open is rather like the
554:55 - f open discussed in chapter seven except
554:58 - that instead instead of returning a file
554:59 - pointer it returns a file descriptor
555:01 - which is just an int
555:03 - int fd semicolon
555:06 - fd equals
555:08 - open
555:09 - open paren name comma rw mode close
555:12 - paren semicolon
555:13 - as with f open the name argument is a
555:15 - character string corresponding to the
555:17 - external file name the access mode
555:20 - argument is different however rw mode is
555:22 - a zero for read one for right and two
555:25 - for read write access
555:26 - open returns negative one if any error
555:28 - occurs otherwise it returns a file valid
555:31 - file descriptor
555:33 - it is an error to open a file that does
555:35 - not exist the entry point create is
555:38 - provided to create new files or to
555:40 - rewrite old ones
555:41 - fd equals create open paren name comma p
555:45 - mode close paren semicolon
555:47 - returns a file descriptor if it was able
555:50 - to create the file name
555:52 - and negative one if not if the file
555:53 - already exists create will truncate it
555:55 - to zero length it is not an error to
555:58 - create a file that already exists
556:01 - if the file is brand new create creates
556:03 - it with the protection mode specified in
556:05 - the p mode argument
556:07 - in the unix file system there are nine
556:09 - bits of protection information
556:11 - associated associated with each file
556:13 - controlling read write and execute
556:16 - permission for the owner of the file for
556:18 - the owner's group and for all others
556:20 - thus a three-digit octal number is the
556:23 - most convenient
556:24 - format for specifying permissions
556:28 - for example zero seven five five
556:30 - specifies read write and execute
556:33 - permission for the owner and read and
556:35 - execute permission for group and for
556:37 - everyone else
556:39 - to illustrate here
556:41 - a simplified version of the unix utility
556:44 - cp a program that copies one file to
556:47 - another the main simplification is that
556:49 - our
556:50 - version only copies one file and does
556:52 - not permit the second argument to be a
556:54 - directory
556:56 - and this example code is on page 163 of
557:00 - the textbook which you can see at
557:02 - www.cc4e.com
557:05 - code
557:07 - found include stdio.h
557:09 - pound include std live.h pound defined
557:12 - buff size
557:13 - 512
557:15 - pound defined p mode 0 6 4 4 rw read and
557:19 - write for owner read for group and
557:20 - others
557:21 - int
557:22 - open paren arg c comma arg v
557:25 - close paren
557:27 - the format will be we're going to have
557:28 - two files copy file one file two
557:32 - int
557:33 - argc semicolon char star arc v open
557:36 - square bracket close square bracket
557:37 - semicolon open curly brace int
557:40 - f1 comma f2 comma n semicolon char buff
557:45 - buff size
557:46 - semicolon
557:48 - if open paren
557:50 - arg c not equal to three close paren
557:53 - error open paren double quote usage
557:55 - colon cp from 2
557:58 - double quote common null
558:00 - close paren semicolon
558:02 - if
558:03 - open paren open paren f1 equals open
558:07 - open paren arg v sub one comma zero
558:11 - close print close paren equal equal
558:13 - minus one close paren error
558:16 - open for n double quote cp colon can't
558:19 - open percent s double quote comma arg v
558:22 - sub 1
558:24 - close paren semicolon
558:26 - if
558:27 - open paren open paren f2 equals create
558:30 - open print arc v sub 2 comma p mode
558:32 - close paren close paren
558:34 - equal equal minus 1
558:36 - close paren air open friend quote cp
558:40 - colon can't create percent s
558:43 - double quote comma arg v sub 2
558:46 - close paren semicolon
558:49 - while open paren open print n equals
558:52 - read open paren f1 comma buff comma buff
558:55 - size close paren close print greater
558:57 - than zero close paren
558:59 - if open paren write open print f2 comma
559:02 - buff comma n close paren not equal
559:05 - and close paren air
559:07 - open paren double quote cp
559:10 - colon right ear double quote comma null
559:13 - close paren semicolon
559:15 - exit open paren
559:17 - zero close paren semicolon close curly
559:20 - brace that's the end of the main program
559:22 - the error
559:24 - routine is going to print the error
559:25 - message
559:28 - air open paren s1 comma s2 close paren
559:32 - char star s1 comma star s2 semicolon
559:37 - open paren
559:38 - printf open paren s1 comma s2 close
559:42 - paren semicolon printf double quote
559:45 - backslash n double quote close paren
559:47 - semicolon
559:48 - exit open paren 1 close paren semicolon
559:52 - close curly brace
559:53 - there is a limit on the number of files
559:55 - which the program may have open
559:57 - simultaneously according any program
560:00 - which intends to process many files must
560:02 - be prepared to reuse file descriptors
560:05 - the retain close breaks the connection
560:07 - between a file descriptor and an open
560:09 - file and frees the file descriptor for
560:12 - use with some other file
560:14 - termination of a program by exit or
560:16 - return from the main program
560:18 - closes all open files
560:22 - the function unlink open print file name
560:24 - close print removes the file name from
560:26 - the file system
560:29 - section 8.4
560:31 - random access seek and l-seek
560:34 - file i o is normally sequential each
560:37 - read or write takes place at a position
560:39 - in the file right after the previous one
560:42 - when necessary however a file can be
560:44 - read or written in any arbitrary order
560:47 - the system call lseq provides a way to
560:50 - move around in a file without actually
560:51 - reading or writing
560:53 - lseq open paren fd comma offset comma
560:57 - origin close paren semicolon
561:00 - forces the current position in the file
561:02 - whose descriptor is fd to move to the
561:04 - position offset which is taken relative
561:07 - to the location specified by origin
561:10 - subsequent reading or writing will begin
561:12 - at that position
561:13 - offset is a long
561:15 - fd and origin are ints origin can be 0 1
561:19 - or 2 to specify that the offset is to be
561:22 - measured from the beginning
561:23 - from current position or from the end of
561:25 - file respectively
561:27 - for example to append to a file seek to
561:30 - the end before writing
561:31 - l seek open print ft
561:34 - comma 0l
561:36 - comma 2 close print semicolon to get
561:40 - back to the beginning i.e rewind to the
561:42 - beginning
561:43 - l seek open paren fd comma 0l comma 0
561:49 - parentheses semicolon
561:52 - note that the 0l argument could also be
561:55 - written as open parent long close paren
561:58 - 0.
561:59 - with lseq it's possible to treat files
562:02 - more or less like large arrays at the
562:04 - price of slower access
562:06 - for example the following simple
562:08 - function reads any number of bytes from
562:11 - any arbitrary place in a file
562:14 - get open paren fd comma pause comma buff
562:18 - comma n close paren
562:21 - int fd comma n
562:23 - long pause semicolon char star buff
562:27 - semicolon open curly brace
562:30 - l seek open parenthesis fd comma pause
562:33 - comma 0 close paren semicolon
562:37 - return open paren read open paren fd
562:41 - comma buff comma n close paren close
562:44 - paren semicolon close curly brace
562:47 - in pre-version 7 unix the basic entry
562:49 - point to the i o system is called seek
562:52 - seek is identical to lseq except that
562:54 - its offset argument is an int rather
562:56 - than a long
562:58 - accordingly since pdp 11 integers only
563:00 - have 16 bits the offset specified for
563:03 - seek is limited to 65535
563:07 - for this reason origin values of 3 4 and
563:10 - 5 cause seek to multiply the given
563:12 - offset by 512 which is the number of
563:15 - bytes in one physical block on a 11 and
563:17 - then interpret origin as if it were 0 1
563:20 - or 2 respectively thus to get to an
563:23 - arbitrary place in a large file requires
563:25 - two seeks the first one selects the
563:27 - block
563:28 - then one which has origin equal to one
563:31 - and then moves to the desired desired
563:34 - byte within the block
563:36 - once again we see c in unix straddling a
563:39 - major improvement in computer hardware
563:41 - in 1978.
563:42 - the natural name for a function to
563:44 - randomly move around a file would be
563:45 - seek but in early versions of unix seek
563:48 - took an integer as the offset but on
563:50 - small word computers like pdp-11 have an
563:52 - integer that can't represent a large
563:54 - number so seek used a complex set of
563:56 - rules to handle larger files
563:58 - the only logical thing was to have the
564:00 - offset be along and then for upwards
564:02 - compatibility make a new function called
564:05 - lseq that we use to this day
564:08 - section 8.5
564:10 - an example implementation of f open and
564:13 - get c
564:14 - let us illustrate how some of these
564:16 - pieces fit together by showing an
564:18 - implementation of the standard library
564:19 - routines f open and get c on the pdp 11.
564:24 - recall that files in the standard
564:25 - library are described by file pointers
564:27 - rather than file descriptors
564:29 - a file pointer is a pointer to a
564:31 - structure that contains several pieces
564:33 - of information about the file a pointer
564:35 - to a buffer so the file can read in
564:36 - large chunks
564:38 - count of the number of characters left
564:39 - in the buffer a pointer to the next
564:41 - character position in the buffer and
564:43 - some flags describing read write mode
564:45 - and the file descriptor the data
564:47 - structure that describes a file is
564:49 - contained in the file stdio.h which must
564:52 - be included by pound include in any
564:55 - source file that uses routines from the
564:57 - standard library
564:58 - it is also included by functions in that
565:00 - library
565:01 - in the following excerpt from the pdp-11
565:04 - stdio.h
565:05 - names which are intended for use only by
565:08 - functions of the library begin with
565:09 - underscore
565:11 - so they are less likely to collide with
565:13 - the names of a user program
565:16 - as a side note i won't read the
565:18 - underscores
565:19 - because they
565:20 - confuse your understanding so the
565:22 - underscores are there in the code you
565:23 - can look at it online
565:25 - but i'm not going to read the
565:26 - underscores
565:29 - so this is basically some definitions
565:32 - for stdio.h
565:34 - pound define buff size
565:37 - pawn define and file 20.
565:40 - type def struct io buff open curly brace
565:43 - char star ptr
565:45 - int
565:46 - cnt semicolon char star base semicolon
565:51 - int flag semicolon int fd semicolon
565:54 - close curly brace
565:56 - file semicolon
565:58 - extern file iob
566:01 - open square bracket end file
566:03 - close square bracket semicolon pound
566:06 - define stdin
566:08 - open paren ampersand iob sub zero close
566:11 - paren
566:12 - pawn define std out
566:14 - open paren ampersand iob sub one close
566:17 - paren pound define std air open paren
566:20 - ampersand iob sub 2 close print
566:24 - pawn define read 01 pound define right
566:28 - o2 pondifying unbuff 04 pound define big
566:32 - buff zero one zero
566:34 - upon define eof
566:36 - zero two zero pondifying air
566:39 - zero four zero pound defined null zero
566:43 - pawn define eof open prin
566:46 - minus one close paren
566:49 - upon define gets e open paren p
566:52 - close paren open paren minus minus open
566:55 - paren p close paren right arrow cnt
566:59 - greater than or equal to zero question
567:01 - mark
567:02 - star open paren p close paren right
567:04 - arrow ptr plus plus
567:07 - ampersand zero three seven seven colon
567:11 - fill buff open paren p close print close
567:14 - print palm define get char
567:18 - open paren close friend
567:20 - get c
567:21 - open paren std high n close paren
567:24 - pound define put c
567:26 - open parent x comma p close paren
567:28 - open paren minus minus open paren p
567:31 - close paren right arrow cnt greater than
567:35 - or equal to zero question mark
567:37 - star
567:38 - open paren p close paren
567:40 - right arrow ptr plus plus equals open
567:43 - paren x close print colon
567:46 - flush buff open paren open paren x close
567:48 - paren comma p close print close paren
567:52 - pound define put char open paren x close
567:55 - paren put c open paren x come std out
567:59 - close paren
568:01 - the f c in macro normally just
568:03 - decrements the counts advances the
568:04 - pointer and returns the character
568:06 - we do this in a very long defined
568:08 - continued by a backslash if the count
568:11 - goes negative however get c calls the
568:13 - function fill buff to replenish the
568:15 - buffer real initialize the structure
568:17 - contents and return a character a
568:20 - function may present a portable
568:21 - interface yet itself contain
568:23 - non-portable constructs
568:25 - cat c masks the character with zero
568:27 - three seven seven which defeats the sign
568:30 - extension done by the pdp 11 and ensures
568:32 - that all characters will be positive
568:35 - although we will not discuss any details
568:37 - we've included the definition of put c
568:39 - to show that it operates in much the
568:41 - same way as getsy calling a function
568:44 - flush buff when its output buffer is
568:46 - full
568:47 - the function f open and fill buff can
568:50 - now be written most of f open is
568:52 - concerned with getting a file opened and
568:54 - positioned at the right place
568:56 - and setting the flag bits to indicate
568:57 - the proper state
568:59 - f open does not allocate any buffer
569:02 - space this is done by fill buff when the
569:04 - file is first read
569:07 - you can look at this sample code from
569:08 - page 167 at www.cc4e.com
569:13 - code
569:14 - i won't read it here because it's pretty
569:16 - long and intricate so you'll have to go
569:19 - watch it online or view it online
569:23 - back to the text the function fill buff
569:25 - is rather more complicated the main
569:27 - complexity lies in the fact that phil
569:29 - buff attempts to permit access to the
569:31 - file even though there may not be enough
569:33 - memory to buffer the i o if the space
569:36 - for a new buffer cannot be obtained from
569:38 - cat c alec all is well
569:41 - if not
569:42 - filbuff does unbuffered i o using a
569:45 - single character stored in a private
569:46 - array
569:47 - the first call to get c for a particular
569:50 - file finds a count of zero which forces
569:52 - a call a fill buff if phil buff finds
569:54 - that the file is not open for reading it
569:56 - returns eof immediately
569:58 - otherwise it tries to allocate a large
570:00 - buffer and failing that a single
570:03 - character buffer setting the buffering
570:05 - information in flag appropriately
570:08 - once the buffer is established phil buff
570:11 - simply calls read to fill it
570:13 - and sets the count and pointers
570:15 - and returns the character at the
570:16 - beginning of the buffer
570:18 - subsequent calls to fill buff will find
570:20 - a buffer already allocated
570:23 - the only remaining loose end is how
570:24 - everything gets started the array iob
570:27 - must be defined initialized and
570:29 - initialized force
570:31 - stdin std out and std err
570:36 - file iob open square bracket and file
570:39 - close square bracket equals open curly
570:41 - brace open curly brace null comma 0
570:44 - common null comma underscore read comma
570:47 - 0 comma close curly brace comma and
570:50 - that's the standard in
570:52 - the next one is
570:53 - open curly brace null comma 0 common
570:56 - null
570:57 - comma underscore right comma 1 comma
571:00 - close curly brace comma and that's the
571:02 - standard out definition the
571:05 - the sub 1 position and then the next one
571:07 - is open curly brace null comma 0 common
571:10 - null comma underscore right
571:13 - vertical bar
571:15 - underscore on buff comma 2 close print
571:18 - and that is the standard error entry
571:20 - close curly brace semicolon
571:23 - the initialization of the flag part of
571:25 - the structure shows that std standard in
571:27 - is to be read standard out is to be
571:29 - written and standard out is to standard
571:31 - error is to be written unbuffered
571:34 - section 8.6
571:36 - example listing directories
571:39 - i would note that the sample code in
571:40 - section 8.6 shows how we can write
571:43 - applications like ls to interact with
571:45 - directories in a unix file system
571:47 - however the code in this section is not
571:49 - portable to modern unix systems so we'll
571:51 - leave the code as it is in this section
571:54 - it's a good idea to read the code and
571:56 - get an outline of how to work with
571:57 - directories on unix if you want to write
571:59 - code to handle directories you'll need
572:01 - to consult more modern documentation
572:04 - given the complexity of the code in this
572:07 - section we are not going to include it
572:09 - in the
572:10 - copy of this book in this particular
572:12 - media
572:13 - similarly
572:14 - section 8.7
572:16 - example a storage allocator
572:18 - consists of a lot of really complex code
572:21 - and so we will leave that for you to see
572:24 - online
572:26 - at
572:28 - www.cc4e.com book
572:30 - slash chap08.md
572:34 - dynamic memory is hard
572:36 - modern languages like python ruby and
572:38 - java give us high level objects like
572:41 - strings lists and dictionaries
572:43 - these structures automatically expand
572:45 - and correct contract and can be copied
572:47 - into a temporary variable used and then
572:49 - discarded modern languages depend on
572:52 - efficient memory allocation
572:55 - a problem when dynamic memory is heavily
572:57 - used is a fragmentation of the free
572:59 - space
573:00 - you can get to the point where you have
573:01 - plenty of memory but each of the free
573:03 - memory areas is so small that you can't
573:05 - allocate a new memory block
573:07 - when this happens the runtime
573:09 - implementations of these systems run a
573:11 - step called garbage collection where
573:13 - everything pauses and free areas are
573:15 - moved around to make sure that the free
573:17 - memory is in a few large contiguous
573:19 - areas
573:20 - rather than many small non-contiguous
573:22 - areas
573:24 - language developers have been improving
573:25 - garbage collection algorithms for the
573:27 - past 40 years and there is still
573:30 - much work to do
573:32 - now that the authors have established
573:34 - all the reasons that make see the ideal
573:36 - portable systems programming language
573:38 - which i hardly agree with
573:40 - it's time to talk about where c comes up
573:42 - short as a general purpose language for
573:44 - those of us not working on the source
573:46 - code to linux the most challenging
573:48 - aspect of c is the lack of dynamic
573:51 - structures that we can use without the
573:52 - need to carefully allocate use without
573:54 - the regard to the length of dynamically
573:56 - allocated memory and not worry about
573:59 - calling c free every single time we call
574:01 - c alec
574:02 - if a programmer without strong
574:04 - programming skills a good understanding
574:06 - of a testing regimen and a proper
574:08 - defensing defensive programming attitude
574:10 - is let loose in c they will invariably
574:13 - write poor code
574:15 - their c code will make poor use of
574:16 - resources run the system out of memory
574:19 - or produce code that is riddled with
574:20 - security holes and bugs that seem to
574:23 - randomly appear
574:25 - a decade after c emerged and became
574:27 - popular guido van rossum designed a
574:29 - language called python
574:31 - it was one of a number of languages that
574:33 - was built using c and added an
574:35 - object-oriented layer that greatly
574:37 - simplified writing programs that used
574:39 - dynamic memory and added guard rails so
574:42 - programmers did not unintentionally
574:43 - write dangerous or insecure code the key
574:46 - value-add features that make python more
574:48 - appropriate for general purpose
574:50 - programming are the string object list
574:52 - object and dis dict object that handle
574:55 - all aspects of creating and using
574:57 - variables and collections of variables
575:01 - the book has one foot note unix is a
575:04 - trademark of bell laboratories
575:06 - but of course there's more
575:09 - actually the trademark for unix is no
575:10 - longer owned by at t it is owned by the
575:13 - open group but that is a story for
575:15 - another day
575:16 - the unix story arc includes att unix
575:19 - berkeley software de distribution which
575:21 - we call bsd sun microsystems minix linux
575:25 - the open software foundation unix
575:27 - international and others
575:29 - the short version of that story is that
575:31 - at t unix was poised to take over the
575:33 - world as an open source product long
575:36 - before the words open source were ever
575:38 - spoken
575:40 - at t should have and could have defined
575:43 - open source and changed everything by
575:45 - the early 1980s
575:47 - except for a few at t intellectual
575:49 - property lawyers it took over a decade
575:52 - for computer science to pivot away from
575:54 - a nearly exclusive focus on c and a t
575:58 - unix
575:59 - the linux operating system was open
576:01 - source from its inception and became the
576:03 - standard barrier for unix-like operating
576:05 - systems
576:06 - and continues to be the way most of us
576:08 - encounter quote unix
576:10 - it is almost certain that the computer
576:12 - that served this media to you runs linux
576:15 - but that is a story for another time
576:19 - in 1978
576:21 - unix and c were in their glory days and
576:23 - showed the entire computer science field
576:26 - and technology industry the right way
576:28 - forward
576:29 - from that point forward hardware could
576:31 - evolve independently from software
576:34 - with the systems programming language
576:35 - and operating systems patterns sorted
576:37 - the previous 40 years have seen an
576:39 - amazing innovation in hardware
576:42 - capability and performance
576:44 - this 1978 c programming book by brian w
576:48 - kernighan and dennis m richie was the
576:50 - big bang moment for modern computing and
576:53 - computer science
576:55 - we owe them a debt of gratitude for
576:58 - making whatever we do today possible
577:01 - if you have made it to the end of this
577:02 - chapter in this book as your narrator i
577:04 - would like to congratulate and thank you
577:07 - it has been an honor to record and
577:09 - narrate a book of such historical
577:12 - significance for you
577:14 - cheers
577:16 - this work
577:17 - is based on the 1978 c programming book
577:20 - written by brian w kernighan and dennis
577:23 - m ritchie
577:24 - their book is copyright all rights
577:26 - reserved by at t
577:28 - but is used in this work under fair use
577:30 - because of the book's historical and
577:32 - scholarly significance
577:34 - its lack of availability and the lack of
577:36 - an accessible version of the book
577:38 - the book is augmented in places to help
577:40 - understand its rightful place in a
577:42 - historical context amidst the major
577:44 - changes of the 1970s and 1980s as
577:47 - computer science evolved from a hardware
577:49 - first vendor-centered approach to a
577:51 - software-centered approach where
577:53 - portable operating systems and
577:55 - applications written in c could run on
577:57 - any hardware
577:59 - this is not the ideal book to learn c
578:01 - programming because the 1978 edition
578:03 - does not reflect the modern c language
578:06 - using an obsolete book gives us an
578:08 - opportunity to take students back in
578:10 - time and understand how the c language
578:13 - was evolving as it laid the groundwork
578:15 - for a future with portable applications
578:20 - [Music]
578:34 - you