00:00 - [MUSIC PLAYING]
00:00 - Hello, Free Code Campers.
00:01 - Welcome to this workshop
on declarative gestures
00:05 - and animations in React Native.
00:07 - I'm William, maker of the "Can
it be done in React Native" YouTube series
00:11 - In this workshop, I would
like us to do five things.
00:14 - First, to discuss why the topic
of gestures and animations
00:19 - is so peculiar in React Native,
and what kinds of strategies
00:23 - and APIs we are going
to use, in order
00:25 - to implement user interactions
that run smooth as butter.
00:30 - From there, we can
look at transitions.
00:33 - Transitions as the easiest
way to animate components
00:36 - in React Native.
00:38 - And we're going to build a
component with two states.
00:40 - One state-- the cards are
overlaid on top of each other.
00:45 - Second state-- they
are nicely fanned out.
00:48 - And we are going to
declare a transition
00:51 - to animate nicely from
one state to the other.
00:56 - And then, we're going to build
the simple timing animation
01:00 - that we can loop, pause, resume,
pause, resume, using Bare Metal
01:08 - animation APIs.
01:09 - Getting to know
these low level APIs
01:12 - would be the key to
success for us to harness
01:15 - gestures and animations
in React Native.
01:19 - And then, it will be time to
add gestures into the mix.
01:23 - And we are going to build this
nice wallet user experience.
01:28 - So we can swipe
for cards nicely.
01:31 - And they animate very nicely
depending on their position.
01:39 - Finally, I would
like to show you
01:42 - what these gestures and
animations integrate very
01:46 - nicely with SVG, and
we're going to build
01:48 - this really cool circular
slider using gestures and SVG
01:55 - animations.
01:57 - This workshop will
only be scratching
02:00 - the surface of the exciting
wall of gestures and animation
02:04 - in React Native.
02:05 - And to conclude,
I would give you
02:07 - all the resources
that I know of,
02:08 - in case you are interested to
go further with this topic.
02:13 - In the video description, you
will find the GitHub repository
02:17 - with all the code examples as
well as the boilerplate files,
02:21 - in case you want to
code along in the video.
02:25 - And also available in
the video description
02:27 - are all the timestamps for
each of the different chapters
02:31 - of the workshop.
02:32 - So Free Code Campers,
are you ready to discover
02:35 - the powerful world of
declarative gestures
02:39 - and animations in React Native?
02:41 - Let's get started.
02:42 - [UPBEAT MUSIC]
02:49 - When building gestures and
animations, the key to success
02:54 - is to avoid frame drops.
02:56 - We want the user
interaction to run
02:58 - at 60 frames per second,
which means that we only
03:03 - have 16 milliseconds
to compute everything.
03:07 - And this is a very simple
diagram of the React
03:10 - Native architecture.
03:11 - We have the JavaScript Thread,
which runs the react code,
03:15 - and the UI Thread
which interacts
03:18 - with all the native components.
03:21 - And they talk to
each other using
03:23 - what we call the async bridge.
03:25 - They asynchronously send
each other JSON messages.
03:30 - So if your gesture or animation
relies on communication
03:35 - between these two
threads, it is very hard
03:38 - to guarantee that the
animation frame can
03:42 - be computed within
16 milliseconds,
03:45 - and you are likely
to draw up frame.
03:49 - There are a couple
of reasons for that.
03:51 - First, because of these
asynchronous messages
03:55 - that needs to be
passed and serialized,
03:57 - you might drop a frame
on the low end device,
04:01 - and the JavaScript Thread might
be busy doing something else.
04:05 - For instance, processing the
response of an HTTP request.
04:09 - So maybe you have a gesture.
04:13 - So the UI Thread says to
the JavaScript Thread,
04:17 - should I grant the gesture?
04:19 - And the JavaScript
Thread might be busy
04:22 - processing the response
of an HTTP request.
04:24 - So is not able to reply
within these 16 milliseconds.
04:29 - And you're going
to drop a frame,
04:31 - and the user experience is
not going to feel very smooth.
04:36 - So the way we are going
to circumvent this problem
04:39 - is by declaring all of our
gestures and animations
04:44 - before hand, which
means that there
04:48 - is no communication between the
JavaScript Thread and the UI
04:53 - Thread.
04:53 - So it doesn't matter if the
JavaScript Thread is busy
04:56 - doing something else,
because the UI Thread is
05:00 - going to be able to
do all the tasks he
05:03 - needs to do for each frame.
05:05 - And plus, because there is no
communication between the two
05:08 - Threads, we are sure that we are
able to compute the animation
05:12 - frame within these
16 milliseconds.
05:15 - And I would like to
show you an example
05:17 - of what this means concretely.
05:20 - So here I am dragging
around this component.
05:26 - And we implemented this example
using the default gesture
05:32 - and animation API
provided by React Native.
05:36 - I call it a vanilla
animation APIs.
05:40 - And as you can see here,
the gesture depends--
05:48 - relies on communication
between the JavaScript
05:52 - Thread and the UI Thread.
05:53 - So to grant as a gesture, we
need to execute some JavaScript
05:58 - Thread.
05:59 - When we move the
view around here,
06:06 - everything is done on the--
06:07 - because we use these
animated events,
06:09 - everything is done
on the UI Thread.
06:11 - So there is no communication
between the JavaScript
06:16 - and the Native side.
06:18 - And when we reduce
the gesture, we also
06:21 - rely on JavaScript code.
06:25 - And so because we have
this mix of imperative code
06:31 - and declarative code, if the
JavaScript Thread is busy,
06:36 - this user interaction is
not going to run smoothly.
06:40 - And in fact, what I can
do is to modify the code,
06:46 - so that we observe
JavaScript Thread--
06:51 - we make the JavaScript
Thread busy.
06:52 - So I'm going to loop
5,000 time and maybe
06:57 - like print something like
[? JS ?] Thread busy.
07:07 - And now, you see I cannot
move the ball around
07:11 - because the JavaScript
Thread is busy.
07:14 - And so we are not going
to use these APIs,
07:17 - because these APIs
rely on communication
07:19 - between the UI Thread and
the JavaScript Thread.
07:23 - And what we're
going to use instead
07:33 - is two libraries, React Native
Reanimated for animations
07:39 - and React Native Gesture
Handler for gestures.
07:44 - And what these libraries
do is that they
07:48 - enable you to implement all
of the gestures and animations
07:53 - declaratively on
the UI Thread, which
07:56 - means that when you have your
gesture and animation running,
08:00 - there is no communication
between the two Threads
08:03 - that is involved.
08:04 - So here, if I make the
JavaScript Thread busy,
08:08 - it doesn't matter
because there are
08:11 - no communications between the
UI Thread and the JavaScript
08:15 - Thread.
08:16 - So this is the
same implementation
08:21 - but using declarative
gestures and animations
08:24 - using React Native Gesture
Handler and React Native
08:27 - Reanimated.
08:29 - And now, so everything
is done declaratively.
08:33 - And now I can make the
JavaScript Thread busy.
08:46 - So [? JS ?] Thread busy.
08:53 - So now the loop is
running, but because I
08:56 - don't rely on the
JavaScript Thread,
08:58 - you see I can still move the
ball around the smoothly.
09:02 - And so this is the heart
of the matter declaring
09:05 - all the gestures and
animations before.
09:08 - And this will
guarantee us to build
09:11 - user experiences that will
run at 60 FPS even on low end
09:15 - devices.
09:16 - [UPBEAT MUSIC]
09:23 - In this example, I
would like to show
09:25 - you the power of
transitions in React Native.
09:28 - Transitions are the easiest
way to animate components
09:31 - in React Native,
and the way it works
09:33 - is that we can attach an
animation value to a change
09:36 - of state in a component.
09:39 - So here, I have a
very simple component
09:41 - with a very simple state,
toggled is true or false.
09:45 - If the toggle is
true, we apply here
09:50 - a rotation, which is
index minus 1 times alpha.
09:54 - So alpha is [? 30 ?] degrees.
09:56 - Pi is 180 degrees divided by 6.
09:59 - And here I do index minus
1, minus 1 times alpha.
10:04 - So if index is 0, 0 minus 1 is
minus 1 times [? 30 ?] degrees.
10:09 - So we'll have a minus
[? 30 ?] degrees.
10:11 - If index is 1, so the
count in the middle,
10:15 - we would have 1 minus 1, 0
times [? 30 ?] degrees, 0.
10:19 - So there won't be any rotation.
10:21 - If it's the [? third ?] card,
we will have index [? 2 ?]
10:25 - [? to ?] minus 1 is 1.
10:28 - So we'll have [? 30 ?] degrees.
10:30 - So we see here.
10:31 - Here we have the
cards constants,
10:33 - which contains six cards.
10:35 - We select 3.
10:36 - And we calculate the rotation.
10:39 - When pressing this button,
we toggle the state--
10:43 - so to its opposite value.
10:46 - And so if toggled is false,
we have a rotation of 0.
10:50 - And what we can
do here is to use
10:55 - a hook called useTransition.
10:58 - That will give us an animation
value that will go from 0 to 1
11:03 - when toggled changes.
11:05 - So if toggled is false, the
animation value will be 0.
11:08 - If toggled is 1, the
animation value will be 1.
11:12 - And the way the transition
from 0 to 1, 1 to 0 [? goes ?]
11:17 - can be a timing function,
can be a spring function,
11:20 - and can be any configuration
of the animation functions
11:24 - that you want.
11:26 - So let's get this
animation value.
11:29 - Here we're going to
call it transition.
11:32 - And we're going to use a
function called useTransition.
11:35 - useTransition comes
from a package
11:38 - called react-native-redash.
11:41 - So we are going to use
react-native-reanimated
11:44 - and React Native Gesture Handler
for the declarative gestures
11:48 - and animations.
11:49 - And I created an
open source package
11:51 - called react-native-redash.
11:53 - I see it as being the
[INAUDIBLE] of Reanimated that
11:56 - provides us with a lot
of utility functions,
12:00 - such as this useTransition hook.
12:03 - But you don't have to be
intimidated by [? it. ?]
12:06 - These are just helper
functions on top of Reanimated
12:10 - and Gesture Handler.
12:11 - You can look at the source
code of some of these functions
12:15 - to see how it works
behind the scene.
12:18 - But these are usually very
simple helper functions.
12:22 - So this function
takes two arguments.
12:24 - The first is the state
we want to transition on.
12:28 - And here it's toggled.
12:30 - And then we can pass an
animation configuration.
12:36 - So for instance, by
default, useTransition
12:38 - is using a timing function.
12:41 - And maybe I want the
duration to be [INAUDIBLE]..
12:43 - You can set some easing.
12:45 - You can have a spring
function instead.
12:48 - So here we have our transition.
12:50 - And what we want to do is
to interpolate the rotation
12:54 - based on the transition.
12:58 - So here, you see we
have the View component.
13:01 - Here we use Animated.View.
13:04 - Animated.View is an
animation wrapper around view
13:08 - so that in these
style properties
13:11 - we can use animation values.
13:13 - So here we pass a string, which
is a rotation value in radians.
13:19 - But now because we
use Animated.View,
13:22 - this style property can also
accept animation values.
13:27 - So here, rotate is going to
become an animation value.
13:32 - And we are going to interpolate
it using transition.
13:40 - So we can write it
using interpolate
13:47 - from react-native-reanimated.
13:49 - So the animation value
is [? a ?] transition.
13:51 - Input range is 0, 1.
13:55 - And output range is if toggled
is 0, the rotation is 0.
14:05 - If toggled is 1, the rotation
is index minus 1 times alpha.
14:14 - So I need to import interpolate.
14:17 - Let's have a look.
14:18 - So you see here it nicely
transitions from one state
14:23 - to the other.
14:24 - It looks very cool.
14:26 - Again, speaking of helper
functions in redash,
14:30 - we are going to have a lot
of these animation values
14:34 - that go from 0 to 1.
14:35 - And we're going to interpolate
always from 0 to 1.
14:37 - There is a helper function
called mix in redash.
14:42 - So here we import
mix from redash.
14:44 - And it's the same
implementation as mix
14:47 - in [? OpenGL. ?] So
we can pass directly
14:51 - the output range like this.
14:53 - So from 0 to index
minus 1 times alpha.
14:58 - So just a nice shortcut.
15:02 - And here it is.
15:04 - And the last thing we
can do is to change
15:09 - the transformation of origin.
15:10 - So here you see by default
is the center of the card.
15:15 - And the way we transform the
origin in react-native using
15:20 - the transform API is that we are
going to translate to where--
15:25 - so from the center of origin
to where we want the new origin
15:27 - to be, do the transformation.
15:29 - And translate back.
15:31 - So, here we want to translate
so the default origin is
15:35 - half of the width of the card,
half of the height of the card.
15:39 - We want to translate to minus
half of the width of the card.
15:43 - Do the transformation.
15:44 - Translate back to half
of the width of the card.
15:47 - So we're going to
write translate x is
15:51 - minus card width divided by 2.
15:54 - We do the transformation,
which is rotate.
15:56 - And translate back.
15:58 - So translate x is card
width divided by 2.
16:05 - And so here you see
it nicely changes
16:09 - the transformation of origin.
16:12 - And here again, we have a nice
utility function in Redash
16:17 - to perform such a
transformation of origin.
16:20 - And it's called
transform origin.
16:22 - And the first parameter is
the new transformation origin.
16:27 - So here we have x, which
is minus card divided by 2.
16:32 - Y is 0.
16:33 - We don't change it.
16:35 - And the transformation
is rotate.
16:41 - And so here it is.
16:45 - So transitions are a great
way to animate components
16:50 - in react-native with little
to zero knowledge of gestures
16:56 - and animations.
16:57 - So just a great way to animate
changes in your component
17:04 - states.
17:05 - [MUSIC PLAYING]
17:10 - In this example, we are going to
build a simple timing function
17:15 - using some bare metal
APIs from Reanimated,
17:19 - and getting to know
these low level APIs
17:23 - will enable us to build
incredible user experiences.
17:28 - So here, I have a
chat bubble component
17:30 - that takes a progress property,
which goes from 0 to 1.
17:35 - So this is the state at 0.
17:37 - We can look at the
state at 0.5, 1.
17:42 - And so we're going to
go from 0 to 1, 1 to 0.
17:47 - And there is a state play,
which is true or false.
17:51 - So we want this
looping timing function
17:53 - to be pausable and
resumable nicely.
18:00 - And in order to implement
this timing function,
18:03 - we are going to use
all the concepts
18:06 - that react-native-reanimated
has to offer, or almost all
18:11 - of the concepts.
18:13 - And one of these
concepts are clocks.
18:17 - So clocks are
animation values which
18:21 - update themselves across time.
18:24 - So by default, the
value of a clock is 0.
18:29 - You can invoke a function
called start clock on it.
18:33 - And every frame, the
clock animation value
18:37 - will update itself
with a timestamp.
18:40 - And this will enable us to
build animations across time.
18:45 - Then there is a stop clock
function to stop the clock.
18:49 - So the clock animation value
will stop updating itself.
18:54 - And there is a
function called clock
18:56 - running to check if the
clock is running or not.
19:00 - And so the way you can
create a clock is like this.
19:03 - So it's clock from Reanimated.
19:08 - We want here because we're going
to have many [? re-renders ?]
19:14 - when the state changes.
19:17 - We don't want to recreate
a new clock every time.
19:20 - We want the clock
identity to match
19:23 - the lifecycle of the component.
19:25 - So we want to always have the
same clock for every instance
19:31 - of our timing component.
19:33 - And so we can use a
helper function for that.
19:35 - Again, from Redash,
which is useClock.
19:41 - And here for progress we
can use an animation value.
19:44 - So you would do new value
[? is 0 ?] from again,
19:49 - React Native Reanimated.
19:51 - But we also want the identity
to be preserved across
19:55 - [? re-renders. ?] So we're going
to use useValue from Redash.
20:01 - And these are simple wrappers
using [? a lazy ?] [? useRef ?]
20:08 - to have--
20:09 - sorry.
20:09 - I need to import from Redash.
20:13 - So what we are going
to do is that we're
20:16 - going to use a hook
called useCode, which
20:19 - allows us to declare
animation nodes to be
20:24 - run for every frame
on the UI Thread.
20:27 - So the function signature--
the hook signature-- is very
20:31 - similar to use [? effect. ?]
20:33 - The first argument is a
callback that returns here
20:37 - an array of animation node.
20:38 - The second parameter
are the dependencies.
20:42 - Here we have none.
20:43 - We want these animation nodes
to have also the same lifecycle
20:50 - [INAUDIBLE] timing component.
20:53 - And so what we're going
to do is use the clock
20:57 - to control the animation.
20:59 - If the clock is not running,
the animation is paused.
21:02 - If the clock is running,
the animation is running.
21:05 - And so by default,
here, we're going
21:07 - to want the animation to run.
21:09 - So we're going to
use startClock.
21:12 - And what we're going to do is
assign to the progress value
21:18 - some timing function.
21:19 - So some function
that we are going
21:21 - to call runTiming and pass
the clock as parameter.
21:26 - So let's create it here.
21:27 - So runTiming is a function that
receives a clock as parameter.
21:34 - And we're going to return
some progress value.
21:39 - Execute also a bunch
of animation nodes.
21:42 - So you can use block
in order to do that.
21:45 - Takes an array of animation
nodes as parameter
21:50 - and will execute these
animation nodes sequentially.
21:54 - So maybe I return 0.
21:57 - So the last node in the array's
value [? that is ?] returned.
22:01 - And so you know--
you see here I'm
22:03 - not writing progress
equals runTiming.
22:11 - Because these are not
imperative instructions
22:15 - that are run on the
JavaScript Thread,
22:17 - but declarative
animation nodes to be
22:23 - executed on the UI Thread.
22:26 - So this is-- here it's not
a code that is executed,
22:30 - but it's a declaration
for code to be
22:33 - executed on the UI Thread.
22:35 - So we're not going to use the
if else syntax from JavaScript.
22:39 - We are going to use the
condition animation node.
22:43 - We're not going to use equal,
but set animation node.
22:46 - And so on.
22:48 - So Reanimated provides us
with all the animation nodes
22:53 - we need in order to declare
complex animation states
23:00 - and interactions
on the UI Thread.
23:04 - So lets write our
runTiming function.
23:10 - So I need to import this
one from Reanimated.
23:15 - So if we look at the
timing function from
23:19 - react-native-reanimated,
we see that it takes three
23:22 - parameters-- the clock, so
to you know, see where--
23:28 - how we evolved across
time, the animation state.
23:35 - So finished position.
23:37 - [INAUDIBLE] position will
be from 0 to 1, right?
23:40 - Time, and frame time.
[? So ?] [INAUDIBLE]
23:43 - last clock values for the
last evaluation and 0 to 1
23:49 - if the animation
is finished or not.
23:51 - And then the animation
configuration.
23:55 - So the target value
duration easing.
23:58 - So you see, if you are familiar
to the vanilla animated
24:02 - API from React Native, it's
a bit more complex to execute
24:05 - a simple timing function.
24:07 - But this-- so the barrier
to entry is higher,
24:10 - but this is way more
powerful functions.
24:14 - So this is why I really want us
to look at the low level of how
24:19 - these functions work.
24:21 - Because this will enable us,
down the road, to go much,
24:25 - much further.
24:26 - Because these functions
are incredibly powerful.
24:29 - So let me copy paste
here, the function.
24:36 - So timing from React
Native Reanimated.
24:41 - And so the clock we
get as parameter.
24:43 - Let's create the state.
24:47 - So I'm going to create it here.
24:49 - State.
24:52 - So I'm going to assign an
animation value for each state.
24:59 - Position, frame time, time.
25:03 - And we have the config.
25:11 - So toValue, we're
going to update it,
25:15 - depending-- toValue is
if the position is 0,
25:19 - the position is going to
be our starting value.
25:23 - If the starting value is 0,
the destination value is 1.
25:28 - And if the position is
1, the destination value
25:31 - is going to be 0.
25:32 - Duration, I don't know.
25:33 - Let's put 3 seconds.
25:36 - And easing we can put
whatever, I think.
25:41 - In, out.
25:46 - And it does not like
the configuration.
25:59 - So I have [? how ?] is
the syntax of the easing.
26:18 - Here I'm importing easing
from vanilla react-native.
26:22 - But I need to import
the one from Reanimated.
26:26 - So that should be good.
26:27 - This is where [INAUDIBLE]
[? script ?] is so useful.
26:31 - So here we execute the timing
function for every frame.
26:34 - And what we want to
return is the position.
26:37 - So state.position.
26:40 - So we see it animates
nicely from 0 to 1.
26:43 - At 1, nothing happens.
26:47 - So at 1, what we need to do--
26:49 - so if state.finish equals 1--
26:54 - so you see here, we are
not [? write-- ?] again,
26:56 - we are not writing if else,
because this is not just code
27:01 - that is executed imperatively.
27:04 - This is a declaration.
27:05 - So we use a condition
animation node.
27:10 - That is a declaration
to run on the UI Thread.
27:15 - So if the state of the
animation is finished,
27:19 - we want to reset these
animation values.
27:22 - Position we will leave.
27:24 - But we need to update
the [? toValue. ?]
27:27 - So let me reset the state.
27:29 - So is finished is 0.
27:31 - We want to loop.
27:33 - FrameTime time we reset as well.
27:36 - Because we are
restarting the animation.
27:41 - Position we keep.
27:42 - If it's 1, it's still 1.
27:43 - We want to continue
where we were.
27:46 - So state.time.
27:49 - But what we want to change
is the destination value.
27:52 - So config toValue is going to be
the opposite of state.position.
27:59 - If position is 0, the
[? toValue ?] is 1.
28:02 - If position is 1, the
[? toValue ?] is 0.
28:05 - So here I need to
import these nodes.
28:19 - So you see it loops nicely from
1 to 0 and now from 0 to 1.
28:26 - Now let's make the
animation interruptible.
28:31 - So you see here, you might
be under the impression
28:35 - that this is a lot
of boilerplate code
28:37 - to write a simple
looping animation.
28:39 - There are utility animation
functions in Redash
28:43 - that allows you to do these
in a few lines of code.
28:48 - Because all this boilerplate
can be done for you.
28:50 - But I find it to be extremely
important to understand
28:54 - how these clocks and
animation evaluation work.
29:00 - Because this can
really unlock the power
29:03 - of complex declarative
gestures and animations
29:07 - as we run at 60 FPS.
29:09 - So this is why here we are doing
all the boilerplate manually.
29:15 - So here we have the state play
which becomes true or false.
29:19 - And the first thing
I want to do is
29:20 - to have an animation value
that matches the state of play.
29:23 - So if play is true, I want
my animation value to be 1.
29:28 - If play is false, my
animation value to be 0.
29:31 - So here, we're going
to create an animation
29:34 - value called isPlaying.
29:37 - So default value is 0.
29:39 - [INAUDIBLE] default
state is false.
29:41 - So that's good.
29:42 - And we're going
to create a hook.
29:43 - Again, a useCode hook.
29:46 - That we set the
animation value isPlaying
29:50 - to match the state
of the play variable.
29:56 - And you see here, I could
write it here, in useCode.
30:00 - But I'm having different
dependencies now.
30:05 - So let me show you.
30:06 - So I do isPlaying.
30:08 - So if play is true it's 1.
30:10 - If not, 0.
30:11 - And here the
dependencies is play.
30:16 - So when play changes,
this instruction changes.
30:23 - Because it depends
on the play variable.
30:25 - And this is why I'm putting it
into a separate useCode block.
30:30 - Because I don't want to have a
dependency on the play variable
30:32 - here.
30:33 - What I'm going to write
the instructions--
30:36 - I'm going to declare here are
valid for the whole lifetime
30:40 - of the component.
30:41 - So I don't want to
recreate these animation
30:43 - nodes if the play variable
has changed, only isPlaying.
30:49 - So now, we should have the
isPlaying variable that matches
30:55 - the state of the component.
30:57 - And so we're going to
[INAUDIBLE] actually.
31:00 - So we're going to
write two conditions.
31:04 - So the first condition is if
the state of the animation
31:11 - is playing and the
clock is not running.
31:15 - So not clockRunning.
31:21 - And here you see you have
to count the parentheses.
31:23 - We want to start the clock.
31:25 - We want to start the animation.
31:28 - And the other way around.
31:30 - If the animation is not playing,
and the clock is running,
31:42 - we want to stop the clock.
31:50 - So I need to import
stopClock and [? the and. ?]
31:57 - Let's have a look.
32:03 - So [INAUDIBLE] play.
32:07 - And I can pause.
32:09 - Resume.
32:10 - And you see, it doesn't
resume at the proper state.
32:13 - But I can pause.
32:15 - And I can start the animation.
32:17 - But when I restart
the animation,
32:18 - the state of the animation is
screwed up, pardon my French.
32:27 - So here if the clock
is not running.
32:34 - So if we pause the
animation, we want
32:37 - to reset the time
variable of the state,
32:43 - so that when it resumes, it
resumes the animation properly.
32:49 - And if not, we run
the timing function.
32:57 - So let's pause.
33:01 - And now it resumes exactly where
it was [? paused. ?] Super.
33:06 - And it loops nicely.
33:10 - So a really cool timing function
[? that-- ?] so, very low
33:17 - level APIs, clocks and all
these complex animation states.
33:24 - But these are really--
33:28 - these low level primitives
are really worth it
33:30 - in order to build complex
user interactions.
33:33 - And we've seen how we don't
write imperative JavaScript
33:41 - code, but [INAUDIBLE]
animation nodes,
33:43 - which are declarations
on the UI Thread.
33:47 - And so all the primitives
we have in JavaScript, if,
33:52 - and, not--
33:55 - we can-- the semicolon to
have sequential instructions.
34:00 - So we have the block here.
34:03 - So we have an equivalent
for all the JavaScript
34:07 - constructs as animation nodes.
34:10 - And the only construct that is--
34:13 - so you can have variable
assignments, sequentials,
34:17 - executions, conditional nodes.
34:19 - The only primitive that is
not available are loops.
34:24 - But here-- but that's OK.
34:26 - Because here it's [? code ?] to
be evaluated for every frame.
34:32 - So I hope you
enjoyed this example.
34:35 - If this makes sense to
you, then you really
34:38 - have unlocked the power
of declarative gestures
34:41 - and animations.
34:42 - If you are able to switch
from the imperative mindset
34:48 - to the declarative
mindset, and understand
34:51 - how you can use clocks and
animation states in order
34:55 - to build different
user interactions,
34:58 - then the world of animations
and gestures in React Native
35:03 - is your oyster.
35:03 - I think you can really go very
far with these primitives.
35:08 - [MUSIC PLAYING]
35:14 - So we have looked at
transitions, animations.
35:18 - Now let us play
around with gestures.
35:21 - We have a bunch of cards here.
35:24 - And let's assign some gesture
handler to these cards.
35:28 - And play around,
see what we can do.
35:31 - And so here I am looping
over all my cards.
35:36 - And maybe what I
can do here is wrap
35:39 - a PanGestureHandler from
React Native Gesture Handler.
35:47 - So we can maybe move
these cards around.
35:51 - And we need to pass two
properties for the gesture
35:55 - handler to work.
35:57 - And we're going to
use again [INAUDIBLE]..
36:01 - So it's quite some boilerplate.
36:03 - There is a lot of
animation values
36:04 - to be created [? to ?]
properties to be
36:10 - assigned in PanGestureHandler.
36:11 - So we are going to use utility
function, again from Redash
36:16 - in order to have all this
boilerplate done for us.
36:19 - But you know, again,
don't be intimidated.
36:22 - You can look at the
Redash source code
36:25 - or at the react-native
gesture handler source code
36:27 - to see what kind of boilerplate
is required for these gesture
36:33 - handlers to work.
36:35 - But we're going to get the
gesture handler from a function
36:37 - called usePanGestureHandler.
36:42 - And it gives us a couple of
variables, a gesture handler
36:44 - that we can assign here.
36:47 - And the translation vector
of the card, the velocity.
36:54 - So when we release the gesture--
36:55 - [INAUDIBLE] velocity
of the gesture,
36:57 - and the state of the gesture.
36:58 - Is the gesture active?
37:00 - Is the gesture [INAUDIBLE] and--
37:06 - so here we assign the
PanGestureHandler.
37:08 - I probably need
to move key here.
37:10 - And the PanGestureHandler
takes a single [? children ?]
37:13 - which needs to be an
Animated.View from Reanimated.
37:19 - So here we use Animated.View
from react-native-reanimated.
37:25 - So we get the
translation vector here.
37:32 - I think we can assign it
to this transformation
37:36 - to see if we can
move the card around.
37:39 - So we're going to
use a transform.
37:42 - And there is a utility function
in Redash called translate
37:47 - where we can give it a vector.
37:52 - And it will apply
translate x, translate y.
37:54 - A simple shortcut.
37:56 - So here I can move
the cards around.
38:01 - But I should create
one PanGestureHandler
38:06 - for each gesture handler.
38:07 - So I'm just going
to move it here.
38:13 - Ah-ha.
38:15 - So you see I can move the card.
38:18 - But now if I start
the gesture again,
38:23 - it starts from the
original position.
38:26 - So we need to save the
position in an offset value
38:29 - when the gesture ends.
38:31 - And again in Redash, we have
a utility function for that.
38:37 - So I'm going to create
translate x equals withOffset.
38:42 - And the first parameter
is animation value.
38:47 - And the second parameter is
the state of the gesture.
38:49 - So that we know when
to save the offset.
38:52 - So translate x.
38:53 - We're going to do
the same for y.
38:59 - And here we're going
to apply the transform.
39:03 - So translate x.
39:07 - Translate y.
39:14 - It's translation.
39:20 - So here I can move
the card around.
39:22 - And it remembers its
position across time.
39:29 - And you see, when I stop the
gesture, it's kind of abrupt.
39:35 - There is no like
physical momentum.
39:38 - So what we can do here
instead of using withOffset,
39:42 - we can use withDecay, which
will add some nice decay.
39:46 - And this is where the
velocity comes into play.
39:49 - Because the decay is calculated
according to the velocity.
39:53 - So value is translation x.
39:57 - Velocity is velocity dot--
40:00 - oops.
40:01 - velocity.x.
40:04 - State is [? the ?] state.
40:08 - So same for y.
40:19 - So now you see you have
this nice momentum when
40:27 - moving the card.
40:29 - And you see it is
interruptable as well.
40:33 - So now let's have a nice wallet
animation using these concepts
40:40 - of PanGestureHandler and decay.
40:43 - So I'm going to move
this outside the loop.
40:50 - And we're going to move
the PanGestureHandler to be
40:54 - unique to [INAUDIBLE]
[? view. ?]
41:08 - And we want to translate
only on the x-axis, actually.
41:14 - So we just want to scroll.
41:17 - Oops.
41:18 - We just want to nicely
scroll [? our ?] cards.
41:24 - So something is not working.
41:30 - Because we forgot,
as I mentioned,
41:32 - the single child needs to
be an animated [INAUDIBLE]..
41:36 - But what I'm going
to do, because I
41:40 - want to keep this one, I think
I'm going to wrap it here.
41:51 - And put an Animated.View.
42:00 - Let's see how it looks.
42:03 - [LAUGHING] It's not
translate x, but translate y.
42:10 - OK.
42:18 - So it translates nicely.
42:20 - And we have the nice
momentum effect from decay.
42:24 - So now we want to
clamp the values.
42:28 - We're going to use a
function called diffClamp.
42:31 - So it clamps-- diffClamp
clamps of value with a min max.
42:35 - But we call it diffClamp,
meaning that, you know,
42:39 - if we go to minus
[? 100 ?] pixels,
42:41 - just a delta of one pixel
will be taken into account.
42:45 - So it's much more
responsive if you want--
42:50 - if you scrolled far back in
one of the lower or upper bound
42:54 - and want to go back
to one of the--
42:58 - within the bounds of the
[INAUDIBLE] clamping.
43:02 - So we're going to
add diffClamp here.
43:08 - And here there is a trick.
43:10 - So there's currently a bug in
the diffClamp implementation
43:15 - of Reanimated.
43:16 - So we're going to use
diffClamp from Redash.
43:20 - So in order to
not have this bug.
43:22 - So the maximum value is 0.
43:26 - Right.
43:26 - When we are at this state here.
43:34 - And the minimum value
is going to be so--
43:42 - the length-- so the
height of all these cards
43:47 - minus this height here.
43:51 - So this would be minus
cards.length times card height,
44:06 - which we have defined
here, perfect--
44:10 - minus the container
height, which
44:12 - we calculate using onLayout.
44:17 - So let's have a look.
44:19 - So here, so you see this is
where diffClamp comes in.
44:22 - If I use only
clamps, so here I'm
44:24 - scrolling, scrolling,
scrolling, scrolling, scrolling.
44:27 - Then if I want to
scroll back like this,
44:29 - I would have to do all the
opposite scrolling that I did.
44:32 - But even [INAUDIBLE] maybe
I'm like 500 pixels right now.
44:35 - I can just immediately
go back up.
44:38 - And this is what diffClamp does.
44:40 - I mean, I can show you
quickly with clamp.
44:44 - So I'm here I'm scrolling down,
scrolling down, scrolling down,
44:47 - scrolling down, scrolling down.
44:48 - If I want to scroll
up again, I need
44:49 - to scroll up, scroll up, scroll
up, scroll up, scroll up.
44:52 - And now it scrolls up.
44:53 - With diffClamps, it's
going to be automatic.
44:56 - Scroll down, scroll
down, scroll down.
44:58 - But you see
immediately scroll up.
45:01 - And let's look.
45:04 - So the lower bound
is not correct.
45:07 - It's plus container height.
45:09 - Sorry.
45:11 - So 0 and perfect.
45:16 - And very cool.
45:21 - So now let's animate our cards.
45:28 - So maybe we want to add--
45:36 - so we want, actually, now--
45:39 - we're going to clamp.
45:41 - So I'm going to call this y.
45:43 - So if the card has
reached the top,
45:45 - I don't want it to go above.
45:47 - I want to clamp its value.
45:51 - So translate y.
45:56 - We're going to interpolate
from the y animation value.
46:06 - So the input range goes from
0 and if we translate to--
46:18 - so for the card to be at
the top, if it's 0, it's 0.
46:21 - If it's-- minus card width,
so that would be minus card--
46:31 - so card height, sorry--
46:33 - times index.
46:35 - So this would be
our clamping value.
46:38 - So the output range
would be the same value.
46:44 - But we're going to use
extrapolate clamp, meaning--
46:49 - so this should be the maximum
value the card can go.
46:53 - So do not go outside the screen.
46:56 - And so by using--
46:57 - so here we use linear
interpolation. [? These ?]
46:59 - values match one to one.
47:01 - But when we have a
value, for instance,
47:05 - that is lower than minus
card height times index,
47:08 - we want to be at minus
card height times
47:12 - index, not a lower value.
47:14 - So we are going to
write extrapolate--
47:17 - extrapolate.clamp.
47:21 - Let's have a look.
47:23 - So we see the card moves
on top of each other.
47:31 - You can even add,
maybe, just, you know,
47:34 - if you want to build
some effects, here.
47:38 - Maybe it's minus
card height plus 16.
47:44 - Or minus 16, sorry.
47:48 - You [? see here-- ?]
24 [INAUDIBLE]..
47:51 - So you already have here
a nice wallet animation.
47:58 - So now we want to calculate
the position of each card.
48:06 - And so the position y is y plus
the index times card height.
48:24 - And we're going
to use this value
48:27 - to do a couple of
interpolations.
48:31 - So if the card is
disappearing, its position
48:42 - is at least minus height.
48:47 - So from minus 0 to minus height.
48:51 - Minus card height.
48:51 - Sorry.
48:53 - Right.
48:55 - So here, the card,
its position is 0.
49:03 - So if the card is on
top, its position is 0.
49:09 - If the card is at
the bottom here--
49:13 - so what is the
position on bottom?
49:19 - It's the number of visible
cards in the screen
49:27 - times the height of the card.
49:31 - So that would be visible
cards times card height.
49:38 - What are the number
of visible cards?
49:46 - So visible cards-- we do a
math floor of the container
49:53 - height divided by card height.
50:00 - And so this is the
number of visible cards.
50:05 - So this is-- so
minus 1 for the range
50:11 - and is appearing is the number
of visible cards times card
50:15 - height.
50:17 - So is bottom, is appearing.
50:31 - So now we can create some
scale transformation.
50:41 - So the scale of the card--
50:43 - so we interpolate
from position y.
50:49 - So the input range is
disappearing is on top,
50:58 - is on bottom, and is appearing.
51:08 - And the animation values are--
51:11 - so 0, 5, it's disappearing.
51:14 - 1, 1 if it's in
the visible range.
51:18 - And 0, 5, when it's appearing.
51:20 - Let's try that.
51:22 - So here you see it disappears
nicely in the background.
51:25 - And it appears nicely here.
51:29 - What we can do is
add some clamping.
51:37 - That looks good.
51:39 - Let's add some opacity.
51:42 - So same story for opacity.
51:49 - So I can just add it here.
51:55 - And here, 1-- oh,
actually, the same value.
52:04 - No.
52:10 - What we want to do here
is to not clamp, I think.
52:17 - So we see here it
disappears nicely.
52:24 - And so one thing we can fix is,
you see when the card appears,
52:32 - it's too far away
from the top card.
52:35 - It's not super smooth.
52:39 - So we can add some
extra translation here.
52:45 - So here we can add.
52:49 - So you see here,
we don't do a plus.
52:51 - Again, we use [INAUDIBLE]
[? add ?] animation node.
52:54 - So let's call it
extra translation y.
53:03 - So which we're going to
interpolate from position y.
53:08 - So actually let
me move these up.
53:12 - So we interpolate
from position y.
53:21 - Oops.
53:24 - So input range.
53:26 - So we go from isOnBottom
on bottom to isAppearing.
53:36 - Output range.
53:36 - So at bottom, the
translation is 0.
53:39 - At isAppearing, we know that
at isAppearing, the size is--
53:47 - scale 0, 5.
53:49 - So the height is card
height divided by 2.
53:52 - And we want to move it by
half of the card height.
53:56 - So it's going to be card
height divided by 4.
53:59 - And of course, here
we want to clamp.
54:01 - So we don't want to go
outside these values.
54:07 - Extrapolate clamp.
54:10 - Let's have a look.
54:13 - No.
54:13 - It's not.
54:14 - It's minus card
height divided by 4.
54:20 - And you see now it
looks very cool.
54:26 - And one thing we can
do here [INAUDIBLE]
54:31 - the scroll is not
completely over.
54:38 - So we don't want to
stop the scroll on--
54:41 - I'm being very picky here.
54:43 - But it doesn't feel
nice that the end scroll
54:46 - position is this.
54:48 - So the last card should be at
least as the full position.
54:57 - So here, maybe
instead of container,
55:07 - we can do visible cards.
55:12 - Now what do we need to do?
55:16 - So we container height.
55:22 - Let's try visible cards
times card height.
55:28 - Yes.
55:29 - So that looks good.
55:30 - So here our end scroll
position looks much nicer.
55:36 - So you see a pretty
cool user interaction
55:41 - using the PanGestureHandler from
react-native GestureHandler.
55:46 - But there of course are tons
of different user interactions
55:50 - you can build using these APIs.
55:54 - But I hope that this nice
[INAUDIBLE] user interactions
55:58 - really gave you some inspiration
on the kind of gestures
56:03 - and animations you can
build using these APIs.
56:06 - [MUSIC PLAYING]
56:12 - These gestures and
animations we just looked at
56:15 - integrate seamlessly
with react-native-svg.
56:19 - And this allows for
an interesting range
56:22 - of fun and creative user
experiences and components.
56:27 - And this is thanks to
an incredible community
56:31 - and open source work.
56:33 - Right?
56:33 - So we looked at react-native
gesture handler,
56:35 - react-native-reanimated,
which allows
56:38 - us to declare our
animations on the UI Thread.
56:42 - And then there has been
a tremendous amount
56:45 - of open source and
community work which
56:47 - has been spent in order
for these libraries
56:50 - to nicely integrate
with react-native-svg.
56:55 - And so I would like to show
you a simple example, which is
56:58 - going to be a circular slider.
57:02 - So here we have a svg circle.
57:06 - Here the circular progress.
57:08 - And so we have the
white one here.
57:13 - And we're going to animate
the stroke of this one
57:19 - to show some progress.
57:23 - And here we have a
cursor component,
57:27 - which we are going to
be able to move around.
57:31 - And its value will always
fit the bounds of the circle.
57:37 - So here we have a
theta animation value.
57:41 - And we are going to
move the cursor around
57:43 - to update this value.
57:44 - So theta goes from 0.
57:46 - This is the position at 0.
57:48 - Or actually, here we have a
rotate of minus 90 degrees.
57:52 - So 0 is going to be here.
57:55 - Let me remove this one for now.
57:57 - So we're going to have 0 here.
57:59 - We move pi minus pi 0.
58:05 - And so maybe here we're
going to normalize.
58:06 - Because this goes from
0 to pi minus pi 0.
58:12 - We're going to normalize
it to go from 0 to 2 pi.
58:15 - 360 degrees.
58:18 - And the way we're
going to do it--
58:22 - we are going to set--
58:24 - so we have a theta value, 0.
58:27 - This will set the position of
the cursor on to the circle.
58:31 - How are we going to do it?
58:33 - Well, we have three
coordinate systems
58:36 - to work with in react-native.
58:38 - There is a [INAUDIBLE]
coordinate system.
58:40 - So there is an x-axis which
goes from the left to right,
58:43 - and the y-axis, which
goes from top to bottom.
58:48 - This is [INAUDIBLE]
coordinate system.
58:50 - Then there is a Cartesian
coordinate system,
58:53 - where we have a center
of origin somewhere.
58:58 - Here our center is going to
be the middle of the circle.
59:02 - And the y-axis goes from
0 from bottom to top.
59:08 - So the opposite
of the [INAUDIBLE]
59:09 - axis, which goes
from top to bottom.
59:11 - And then we have the
x-axis, which is identical.
59:14 - It goes from left to right.
59:16 - This is our Cartesian
coordinate system.
59:19 - The third coordinate system
is a polar coordinate system.
59:23 - So here we also have an origin.
59:26 - And given an x and y value
in the Cartesian coordinate
59:33 - system, we are going to get
an angle in a theta value
59:38 - in radians and a radius.
59:41 - So we take the angle.
59:46 - We convert it to the-- so
we have a polar coordinate.
59:50 - So we have a radius
and an angle.
59:52 - We can convert it to a
[INAUDIBLE] coordinate,
59:56 - which would give us x and
y positions [INAUDIBLE]..
59:58 - So that will position the
cursor on to the circle.
60:01 - Then we move the circle around.
60:03 - So we have an x and
y-coordinate which
60:05 - we can transform to
a polar coordinate
60:07 - in order to know
the angle theta.
60:09 - And so we can assign
the theta value,
60:12 - which will drive the
animations of the stroke value.
60:19 - And also maybe we can animate
the color of the progress.
60:22 - So maybe you want green at
the beginning, red at the end.
60:26 - And so if you go on
my YouTube channel,
60:29 - I will put the links in
the video description.
60:32 - I have videos on how we can
convert from one coordinate
60:36 - system to the other.
60:37 - Here we're going to use again
utility functions from Redash
60:42 - to seamlessly go from
one to the other.
60:46 - So let's get started.
60:49 - So we are going to
start with our cursor.
60:52 - And once we have--
60:54 - so the cursor is going to
[? write ?] the data value.
60:58 - And once we have it working,
we will look into animate
61:02 - the circular progress
component that we have here.
61:06 - So let's look at the cursor.
61:08 - So the first thing
we're going to do
61:10 - is to wrap a PanGestureHandler
so we can move it around.
61:15 - So PanGestureHandler from
react-native gesture handler.
61:22 - And we need the gesture handler.
61:25 - We're going to use the
helper function from Redash.
61:29 - So we have gesture handler.
61:34 - usePanGestureHandler.
61:38 - And we're going to get
a translation vector
61:42 - and the state of the gesture.
61:47 - Oops.
61:48 - Some [? typo ?] here.
61:52 - And so here we're going
to add some translate.
62:01 - But what-- so what
we want to do--
62:05 - OK.
62:05 - Let's add some translate.
62:06 - So translate x,
we're going to use--
62:08 - so we want to
remember the position
62:10 - across different gestures.
62:12 - So we're going to
use withOffset.
62:15 - So translate x state
and translate y.
62:24 - Translate y.
62:27 - [INAUDIBLE] translation.
62:29 - Let me apply the transformation.
62:37 - Translate x.
62:40 - Translate y.
62:44 - So I can move the cursor around.
62:46 - Super.
62:46 - But now it needs
to be, you know,
62:48 - whatever is the position within
the bounds of the circle.
62:53 - So this is where we need
to convert these values
62:57 - into polar coordinates.
63:01 - So I'm going to create x, y.
63:08 - And we have a
center vector, which
63:12 - is the middle of the screen.
63:16 - So let me create a vector.
63:21 - So center is x is width
divided by 2. y is height
63:30 - divided by 2, which we need to
import from the dimensions API.
63:38 - So we have width, height
from dimension get window.
63:51 - So let's convert these
into polar coordinates.
63:57 - So we have polar equals--
63:59 - so these are Cartesian.
64:01 - So we're going to use
Cartesian to polar.
64:06 - The math behind this function
is super interesting.
64:08 - I have some videos
on this topic.
64:11 - So if you're
interested, I definitely
64:12 - recommend you check it out.
64:14 - The first argument is a point.
64:15 - So we have x, y.
64:18 - And we probably need
to [INAUDIBLE] polar--
64:25 - no, Cartesian to polar.
64:26 - That's correct.
64:29 - And so we get the theta
angle, which we can
64:35 - assign to this animation value.
64:38 - The radius-- here the
radius doesn't matter.
64:41 - What we need to do
is to set the radius
64:45 - to be the radius of our
circle and convert back
64:50 - these coordinates to
Cartesian coordinates.
64:56 - So we are going to have x
translate x, y translate y.
65:04 - So we are going to convert
polar to Cartesian.
65:12 - Theta is polar.theta.
65:15 - theta.
65:15 - No problem.
65:16 - But radius is not the
radius of our cursor,
65:26 - but the radius of the circle.
65:28 - So that will bound the cursor
to only move around the circle.
65:32 - And the second
parameter should be
65:38 - polar to coordinate
to Cartesian.
65:43 - It looks good.
65:47 - Is this radius--
radius [INAUDIBLE]..
65:51 - So you see we have an issue.
65:59 - So translate x with the center.
66:02 - The origin of-- so I think
I should set center here.
66:14 - Sorry.
66:14 - OK.
66:16 - It's not Cartesian to polar.
66:18 - But [INAUDIBLE] to polar.
66:19 - My mistake.
66:21 - So [INAUDIBLE] to polar.
66:24 - And we can set the center
[? of ?] origin here.
66:27 - So the center.
66:28 - And here it's convert
to polar to [INAUDIBLE]..
66:34 - I was confused
why it didn't need
66:37 - to use the center of origin--
66:41 - the origin-- that
didn't make any sense.
66:46 - So now still actually,
it doesn't work.
66:52 - We have a weird--
66:57 - so actually here, it's the
center because it's not--
67:09 - the container, so
it's not the window,
67:13 - but the content, which is the
size here of this container,
67:18 - of the circle [INAUDIBLE]
I put background color red.
67:24 - So you see our
center is not height
67:26 - of the screen divided by 2,
but radius and the radius.
67:32 - So let me update this.
67:38 - So center is radius.
67:50 - And so now it animates nicely.
68:03 - So now we need to
set the theta value.
68:07 - And so you could set the value
to be polar.theta directly.
68:12 - But polar.theta goes from 0
to pi and minus pi to minus 0.
68:20 - So here the value would
be minus pi divided by 2.
68:24 - And not 3/4 of 2 pi.
68:27 - So we want to normalize the
value to go from 0 to 2 pi.
68:32 - So we're going to
create useCode and we're
68:36 - going to assign
[INAUDIBLE] and we're
68:42 - going to assign theta
to be polar dot theta.
68:48 - But we need to normalize theta.
68:56 - So normalize theta.
69:00 - Or we take theta--
69:04 - so as an animated node.
69:07 - So if theta is less than 0,
so it's minus 0 minus pi,
69:19 - we need to add 2 pi.
69:21 - So theta is less than 0.
69:25 - It's theta plus 2 pi.
69:33 - If not, it's the theta value.
69:35 - So from 0 to pi theta is OK.
69:38 - And now if let's say we have
minus pi minus pi plus 2 pi,
69:47 - would be 2 pi 3/4 of 2 pi.
69:55 - So it's going to be 2
pi minus half of 1 pi.
69:59 - So this should give us
proper values for theta.
70:06 - And here, let's see.
70:08 - We're going to interpolate
the [? color ?] on theta
70:10 - to see what we get.
70:13 - So let's use interpolate.
70:15 - So colors are numbers.
70:18 - And we have a interpolate
color function in Redash.
70:21 - So we can interpolate on theta.
70:25 - And so input range--
70:27 - so theta goes from 0 to 2 pi.
70:31 - So we have 0.
70:32 - Let's say pi and 2 pi.
70:35 - We're going to use three colors.
70:37 - Output range-- we can use style
guide, palette, secondary,
70:51 - primary, and primary.
70:59 - And tertiary.
71:03 - Let's have a look.
71:06 - So we see here the
color updates nicely.
71:11 - So now let's animate
our svg circle.
71:18 - And we're going to use a
dash stroke array to animate
71:26 - the progress of the circle.
71:28 - So we want dash stroke array to
be circumference of the circle.
71:32 - So we want one empty stroke
to be the circumference
71:37 - of the circle.
71:38 - One full stroke to be the
circumference of the circle--
71:42 - so we can animate,
really, from 0
71:44 - completely empty to
1 completely full.
71:49 - So the circumference
of the circle
71:50 - is 2 pi times the radius.
71:57 - And the length of
the arc of circle
72:02 - is going to be radius
times the theta, right?
72:07 - And so this is going
to be the offset--
72:11 - the dash stroke offset.
72:13 - So let's-- so we need to
calculate the circumference.
72:22 - Which is going to be
2 pi times the radius.
72:32 - Which we get--
[INAUDIBLE] as property.
72:37 - So we can assign dash
stroke array to be--
72:46 - so circumference, circumference.
72:50 - And we can calculate the--
72:55 - so here, OK.
72:57 - So it's dash stroke offset.
72:59 - And here-- so
we're going to have
73:01 - a couple of animation values.
73:02 - It's not a circle, but
an animated circle.
73:06 - An animated circle.
73:09 - We use create
animated components
73:11 - in order to have the animated
wrapper that can accept
73:14 - animation values as property.
73:17 - So now we need to calculate
stroke dash offset.
73:24 - Which is actually the same
formula [INAUDIBLE] here.
73:27 - But instead of having the
full angle, which is 2 pi,
73:31 - we use theta.
73:33 - So it's going to be
multiply theta by radius.
73:39 - Let's have a look.
73:42 - Looks good.
73:43 - But also very strange.
73:48 - So the stroke color
appears to be good.
74:01 - Background color.
74:17 - We need to add stroke width.
74:25 - And now there is a
strange offset value here.
74:32 - So here it looks like
at 0, it's correct.
74:36 - And then there is-- you
see some offset value
74:39 - that goes further and further.
74:47 - And I think here I
wrote it down because I
74:49 - wrote radius is the radius minus
the stroke width divided by 2.
74:57 - That makes sense.
74:58 - Because we want the
center to be here.
75:01 - So I should probably
replace radius here.
75:06 - Yeah.
75:07 - Now that looks good.
75:12 - It's fun, isn't it?
75:15 - I could play with this
always [INAUDIBLE]..
75:18 - But really a nice example of
how gestures and animations
75:23 - seamlessly integrate
with each other.
75:28 - [MUSIC PLAYING]
75:34 - Free Code Campers, I hope
you enjoyed this workshop
75:37 - on declarative gestures and
animations in react-native.
75:40 - Let me know what you think
in the comments below.
75:43 - If you're interested to go
further with this topic,
75:46 - I will link to resources
in the video description.
75:49 - We discussed the
heart of the matter.
75:52 - Why is this topic so [INAUDIBLE]
in React Native and the APIs
75:56 - and strategies to use in order
to build these very smooth user
76:00 - experiences.
76:02 - We looked at transitions,
the easiest way
76:05 - to animate react-native
components.
76:07 - And then we implemented a
simple timing function using
76:11 - the bare metal reanimated API.
76:14 - And we've built this timing
function to be interruptable,
76:19 - so we can pause, resume.
76:20 - But also we can also loop
the function across time.
76:26 - Then we built our first gesture.
76:29 - So we had these cards and
we could move them around
76:31 - and swipe them.
76:32 - And we've used the gesture API
to build a nice wallet user
76:38 - interaction.
76:39 - And finally, we've
looked at how svg
76:42 - can be used to seamlessly
integrate with these gestures
76:47 - and animations.
76:48 - And that allows for a range of
really fun and creative user
76:54 - interactions to be built.
76:56 - If you go on my
YouTube channel, I
76:58 - have dozens of
videos on this topic.
77:02 - For instance, in the
case of the svg example,
77:04 - we used functions which leverage
trigonometry behind the scene,
77:08 - right, where we converted
from polar coordinate system
77:11 - to [INAUDIBLE] and vice versa.
77:13 - I have videos where
I really explain
77:16 - the math behind the scene.
77:18 - And trigonometry is very
important in animations,
77:21 - because as soon as
you have something
77:24 - that has some sort
of rotation, it's
77:26 - going to involve trigonometry.
77:27 - And I have quite some
videos about this topic.
77:31 - And I have also
more advanced videos
77:34 - on the topic of svg animation.
77:37 - For instance, you can
use svg animations
77:40 - to morph from one svg
path to the other.
77:44 - And there is also really
interesting examples
77:48 - with Bezier curves.
77:49 - That is really-- we only
scratched the surface.
77:52 - There is really
tons of great things
77:55 - you can build using
svg animations.
77:59 - We looked at the
PanGestureHandler.
78:01 - But there are, of
course, different kinds
78:03 - of gestures in React Native--
78:06 - the tap gesture handler,
the pinch gesture handler,
78:09 - the rotate gesture handler.
78:11 - And I also have videos
on these topics.
78:14 - I will link to these resources
in the video description.
78:19 - And we used the transform
API to move things around.
78:22 - And we even did
transformation of origin.
78:27 - The transform API
from react-native
78:30 - is incredibly powerful.
78:32 - And we've not even looked at
all the things it has to offer.
78:36 - And I also have
videos on this topic,
78:39 - on how to build advanced
2D transformations,
78:43 - how to save the state of
complex transformations
78:47 - across gestures.
78:48 - And I even have a video where
we go to the third dimension.
78:52 - So if you are interested, I
hope that you will check it out.
78:56 - So I'm really looking
forward to talk to you soon.
79:00 - And in the meantime,
happy hacking.