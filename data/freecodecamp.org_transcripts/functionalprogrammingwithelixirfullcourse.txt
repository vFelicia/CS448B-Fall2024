00:00 - welcome to this complete Elixir course
00:02 - this course created by octolium covers
00:05 - the fundamentals of Elixir and
00:07 - functional programming including
00:09 - recursion pattern matching and the actor
00:12 - model the course also covers data types
00:14 - flow control and advanced topics such as
00:17 - mixed projects and list operations by
00:20 - the end of this course you'll be able to
00:22 - build your own Elixir applications and
00:24 - confidently apply functional programming
00:26 - Concepts in your projects hi and welcome
00:30 - to this course functional programming
00:32 - with Elixir now this course is all about
00:35 - learning the fundamentals of functional
00:37 - programming and we are going to learn
00:40 - these Fundamentals by using the Elixir
00:43 - programming language now this course is
00:45 - for someone who has some basic knowledge
00:48 - of programming but you don't need to be
00:51 - an expert maybe you know a little bit of
00:53 - JavaScript python Java or C plus plus it
00:57 - doesn't matter but you do need to have
00:59 - some kind of programming experience now
01:02 - let us go through all of the topics that
01:04 - we would be covering inside this
01:06 - tutorial Series so the first thing as
01:08 - you can see that we are going to learn
01:10 - all of the basic fundamentals of
01:12 - functional programming and after that we
01:15 - are also going to learn all of the
01:16 - basics of Elixir you can see that we are
01:19 - going to cover all of the type system of
01:21 - Elixir as well then we will see how to
01:23 - create projects by using mix so this is
01:27 - the basic tutorial project that we are
01:29 - going to create and as a last Capstone
01:31 - project we are going to create an actual
01:34 - statistics Library well that's it for
01:37 - this video I hope you are excited to
01:39 - learn more about functional programming
01:41 - and elixir in general and I'll catch you
01:43 - in the next video
01:45 - so what exactly is elixir now Alexa is a
01:49 - functional programming language
01:51 - now why am I talking about elixir
01:54 - well let me answer this by asking you a
01:57 - question
01:58 - when was the last time you used WhatsApp
02:01 - or Discord
02:03 - well both of these applications there
02:06 - are on the same virtual machine
02:09 - now to be precise Discord is powered by
02:12 - Elixir and WhatsApp is powered by erlang
02:16 - you must be thinking what erlang has to
02:18 - do with Elixir well erlang is also a
02:21 - functional programming language and
02:23 - Alexa is built on the top of erlang and
02:27 - both of these languages they are
02:29 - compiled and they run on the airline
02:31 - virtual machine which is also called as
02:34 - the beam
02:35 - you can imagine this to be similar to
02:37 - your Java virtual machine
02:40 - you have so many languages such as Java
02:43 - kotlin closure and Scala all of these
02:46 - languages they compile and they run on
02:49 - the on the Java virtual machine the same
02:52 - thing happens with Elixir Elixir gets
02:55 - compiled and Resident on the beam
02:57 - virtual machine
02:59 - now you must be thinking why is all of
03:01 - these things important what's so great
03:03 - about about elixir well first it is
03:07 - functional second it supports
03:09 - immutability by default
03:11 - now why is immutability so very
03:13 - important well because of that we can
03:16 - have immense scalability You Must Be
03:19 - Wondering Why because since all of the
03:22 - data types is immutable that means there
03:25 - is no chances for the threads or some
03:27 - other objects or maybe some other
03:29 - functions to accurately change the
03:31 - values so the state is preserved and
03:34 - that's why the systems becomes much more
03:36 - scalable
03:37 - and the most powerful thing about Elixir
03:40 - is that it supports fault tolerance
03:43 - suppose NFL node goes down or any of our
03:45 - actors or processors goes down then
03:48 - automatically they can be revived and
03:50 - they can be revived with its own state
03:53 - so that's why you can create immensely
03:56 - distributed and fault all done systems
03:58 - by using elixir
04:00 - so if you're interested in learning
04:02 - Elixir then stay tuned and I will meet
04:04 - you in the next video bye so now we know
04:08 - a little bit more about Elixir but let
04:10 - us try and understand what do we mean by
04:12 - functional programming in simple terms
04:15 - it simply means that our entire program
04:18 - is composed of different functions
04:22 - so just imagine that this f of x is a
04:25 - kind of a function so let me highlight
04:28 - the background so this the green thing
04:30 - so this is a very simple function now
04:33 - this function it gets an input suppose
04:36 - that input is an X now this function is
04:39 - going to transform that data from X and
04:43 - that data would be transformed to
04:45 - something called as y
04:47 - so this is what your function is going
04:49 - to do your function will always accept
04:52 - some kind of an argument it will
04:55 - transform the data and it will always
04:57 - give you back some kind of data now this
05:00 - may look very simple but it's not so
05:02 - simple there are a lot of things that go
05:05 - behind creating your pure functions so
05:08 - let us try and understand what makes
05:10 - functional programming so unique the
05:13 - first thing is obviously we don't have
05:15 - any classes or objects inside functional
05:18 - programming
05:19 - the next one is all of the data type is
05:22 - immutable so it's just like working with
05:25 - constants throughout your program now
05:28 - you must be wondering why do we need
05:30 - immutable data types or constants
05:33 - the answer is since the data is not
05:36 - mutable that means the state Remains the
05:40 - Same and if the state Remains the Same
05:43 - that means that data can be copied and
05:46 - it can be distributed much more easily
05:49 - and since this data can be distributed
05:52 - that means we can create immensely
05:55 - scalable systems by using function
05:57 - programming now this brings me to the
06:00 - next point and I think that this point
06:02 - is going to shock a couple of us and
06:05 - that means we don't have any for loops
06:08 - now since the data is immutable that's
06:11 - why we don't have for loops just try and
06:14 - imagine your typical for Loop suppose
06:17 - you have your variable of I equal to 0 I
06:21 - Which is less than length and I plus
06:24 - plus now what's happening is for each
06:27 - iteration your variable of I is
06:30 - increasing that means the data is
06:32 - constantly mutating but we can't have
06:36 - that because we have immutable data
06:38 - types you must be thinking then what's
06:41 - the point how can we have iterations in
06:44 - Elixir but functional programming and
06:46 - elixir has a much better way of doing
06:49 - loops and that is by using recursion
06:53 - and I am going to talk more about
06:55 - recursion right in the next video so
06:58 - what do you mean by recursion and why is
07:01 - recursion so important
07:04 - let us try to answer these questions one
07:06 - by one
07:07 - first let us see what do you mean by
07:10 - recursion in simple terms whenever you
07:13 - perform the same task again and again
07:16 - you can say that you are performing a
07:19 - recursion that means you can see that we
07:21 - have one task and this task is calling
07:25 - itself again and again so you can say
07:28 - that we are in a state of recursion now
07:32 - if recursion is so simple then what's
07:36 - the big deal with recursion let me try
07:38 - and explain this by taking you through a
07:41 - journey in time
07:43 - you must have heard about the seven
07:45 - wonders of the world you have the Taj
07:48 - Mahal you have the Great Wall of China
07:50 - you have the Machu Picchu and so on but
07:54 - if we ask each one of us what do you
07:57 - consider as the wonder of the world
07:59 - the answer is going to vary let us see
08:02 - what's going to happen next so these are
08:05 - some of the most smartest guys on the
08:07 - planet so they are Warren Buffett and
08:10 - the great Charlie manga if you ask these
08:14 - guys what do you think is one of the
08:16 - wonders of the world then most possibly
08:18 - the answer would be compounding now let
08:21 - us see what's going to happen next so
08:24 - there is one more really smart guy and
08:27 - as you can imagine this is the great
08:29 - Isaac Newton if you ask Newton what
08:32 - would be one of the greatest wonders of
08:34 - the world
08:35 - most probably he is going to say that
08:38 - it's gravity so the point that I am
08:41 - trying to make is our perception changes
08:44 - from person to person
08:46 - now what happens if you ask this guy
08:49 - that's me
08:50 - photo I think about one of the greatest
08:53 - wonders of the world and as you can
08:55 - guess my answer would be recursion well
08:59 - that's not exactly true if you want a
09:02 - very honest answer from me then I think
09:05 - that recursion plus mutation that means
09:09 - recursive mutation is one of the
09:12 - greatest wonders of this world
09:14 - sounds confusing is it don't worry now
09:17 - it's time for some explanation
09:20 - just consider us human beings all of us
09:23 - have habits right and we tend to have
09:27 - the same habits over a long period of
09:29 - time so can we say that our mind is in a
09:33 - state of recursion because we keep on
09:35 - repeating the same habit each and every
09:38 - day you may argue that our habits can
09:41 - also change
09:42 - well yes they can change and that's what
09:46 - I mean by mutation but just try and
09:49 - consider your habits don't change
09:51 - drastically overnight
09:53 - your habits may change over a long
09:55 - period of time so you can also say that
09:58 - your change in habit is because of small
10:01 - mutations that take place each and every
10:04 - day
10:05 - so maybe you can say that all of us are
10:08 - in a state of recursive mutation
10:11 - let's try and go a little larger let us
10:15 - try and think about the Earth itself
10:17 - now the Earth takes around 24 hours to
10:21 - come to the exact same point
10:23 - so can you say that Earth is also in a
10:26 - state of recursion let us try and expand
10:29 - a little bit further now the Earth
10:31 - revolves around the Sun in an orbit now
10:34 - this as you know it takes around 12
10:36 - months time
10:37 - but what happens in every four years we
10:40 - have a leap year that means we have a
10:42 - day extra
10:43 - so can you say that even the Earth is in
10:46 - the state of recursive mutation now let
10:50 - us try and go even behind our solar
10:52 - system
10:53 - you must have also heard that the entire
10:57 - universe is in the state of expansion
11:01 - this go back 13.6 billion years ago when
11:04 - there was nothing the Big Bang happened
11:07 - and the Earth Stars sun and entire
11:12 - galaxies came into existence and we are
11:15 - still expanding how can this happen well
11:20 - I can explain this by using a function
11:22 - which is written recursively
11:25 - so this is our function for now you
11:28 - don't have to understand all of these
11:30 - things you will understand these things
11:32 - in the future when you learn a little
11:34 - bit more about Elixir right now let us
11:37 - try and see how the universe can expand
11:39 - from nothing
11:41 - so if I say universe and now this is the
11:45 - time for the Big Bang
11:47 - and big bank is a function which takes
11:50 - no argument
11:51 - now let us see what's going to happen
11:53 - Okay so the Big Bang happened
11:57 - after that you can see that the size of
11:59 - universe is 0 1 2 3 4 and the size is
12:03 - constantly expanding
12:06 - now let me stop this otherwise this will
12:08 - go for Infinity so what exactly happened
12:11 - you can see that I have a function
12:13 - called as expand and at the last the
12:16 - function is calling itself again but
12:19 - this time we are just mutating the state
12:22 - I have written State plus 1 but imagine
12:25 - that this is not plus one we are causing
12:28 - some kind of mutation and that is what
12:31 - this is supposed to symbolize
12:33 - now this brings me to the last point
12:36 - so as you can imagine the very nature of
12:39 - the universe is recursive that means all
12:42 - of the mathematics that we study for
12:44 - programming that 2 is recursive in
12:47 - nature
12:48 - and this concept of recursion comes
12:51 - naturally to functional programming
12:54 - so now we get it we had to take a really
12:57 - long journey in order to understand what
13:00 - is the recursion and what's the big deal
13:03 - with it now let's see how to install
13:05 - elixir
13:07 - so what you can do is you can just go to
13:09 - this website which is elixirlang.org and
13:12 - you can simply click on install
13:15 - and if you're using Windows you can
13:17 - click on windows so from here you can
13:19 - download the installer and as the
13:22 - instruction already says you have to
13:23 - Simply click on next next and finally
13:26 - finish and if you are on a Mac you can
13:29 - simply use Brew to install elixir
13:31 - so if you are on a Mac you can open up a
13:35 - terminal and you can type Brew install
13:37 - an elixir
13:38 - and once you have installed Elixir what
13:41 - I want you to do is uh just open up a
13:43 - terminal or if you are using Windows
13:45 - just open up the Powershell and here you
13:48 - can simply type Elixir and hyphen V so
13:51 - as you can see I'm currently running
13:53 - Elixir
13:54 - 1.14.1 and if you are watching this
13:57 - video in the future you may have some
13:59 - other version but don't worry all of the
14:01 - things which I teach you right now they
14:03 - are going to work in future versions as
14:05 - well the next thing for this video is
14:07 - let us open up our Visual Studio code
14:10 - and let us set up the Elixir plugin for
14:13 - this one so just open up your extensions
14:17 - and I want you to just search for elixir
14:21 - so this extension which is for Elixir LS
14:24 - so here you can see and currently it has
14:27 - like 339 000 downloads so just install
14:31 - this plugin and this is what you really
14:33 - need to start working with Elixir inside
14:35 - vs code the first time you open up any
14:38 - Elixir file inside vs code you will get
14:41 - a small pop-up right over here somewhere
14:44 - in the bottom right corner and that
14:46 - pop-up will be saying that Alexa is
14:49 - building the PLT so just let it happen
14:52 - it's going to take some time but let it
14:55 - run and after the Alexa PLT is built you
14:58 - can start working with your Elixir files
15:01 - inside vs code
15:03 - now that we have Alexa installed it's
15:05 - time to start learning more about elixir
15:08 - but first before learning we need to
15:11 - start unlearning because a lot of
15:14 - Concepts from the object oriented world
15:16 - does not exist in the functional world
15:20 - so that brings me to the very first
15:22 - statement if I say a is equal to 1 and
15:26 - if I ask you what do you think of it
15:29 - most probably you will say that a is a
15:31 - variable and the value of 1 is being
15:34 - assigned to the variable of a well you
15:37 - are right
15:38 - but that's not what is happening inside
15:41 - the functional world
15:43 - if I take you back to your high school
15:44 - days and just imagine that you are
15:47 - taking your very basic algebra classes
15:50 - in that class what we learned was
15:52 - a is equal to 1 that means a is your
15:56 - left hand side and one is your right
15:58 - hand side
16:00 - so what maths is trying to say is your
16:03 - left hand side is equal to your right
16:06 - hand side
16:07 - your basic algebra does not say that one
16:10 - is being assigned to a that concept does
16:13 - not exist
16:15 - now if we say that if the left hand side
16:17 - is equal to the right hand side that
16:21 - means the right hand side should also be
16:23 - equal to the left hand side
16:25 - so if I say that a is equal to 1 that
16:29 - means even this statement should hold
16:31 - true and that is what happens in the
16:34 - world of Elixir as well
16:36 - we will also have a demo of this shortly
16:39 - right now just keep in mind that equal
16:42 - to is not the assignment operator this
16:45 - is the match operator and what this
16:48 - operator does is that it simply matches
16:50 - your right hand side to your left hand
16:53 - side and you are going to see this
16:56 - pattern a lot inside Elixir this is also
16:59 - called as pattern matching and this is a
17:02 - very powerful thing inside elixir
17:04 - every time you see a statement like this
17:07 - always remember that we are simply
17:09 - trying to match the right hand side with
17:11 - the left hand side
17:13 - now for the demo let us open up our
17:16 - terminal
17:17 - Elixir actually ships with an
17:19 - interactive shell or an repel so let us
17:22 - see how we can open it up and start
17:24 - using elixir we can enter inside the
17:28 - intra to Shell by typing IEX
17:32 - you can clear the terminal by typing
17:34 - clear
17:35 - so here we can say that my a is equal to
17:39 - 1. now if we say that is my 1 is equal
17:43 - to my a and we get the output as true
17:47 - you can also type as 1 is equal to a and
17:51 - this simply gives back the value because
17:53 - 1 and a both hold the same value of 1.
17:58 - let me clear this up let us try with one
18:01 - more experiment suppose I say that my
18:04 - name is
18:06 - octallium
18:08 - so in this case if I say that is
18:12 - octallium
18:13 - equal to my name
18:15 - then we should get the answer of true
18:17 - and yes that's what it is so just keep
18:21 - in mind that this is equal to is not
18:23 - assignment we are simply trying to
18:25 - pattern match the right hand side to the
18:28 - left hand side let's try to learn a
18:30 - little bit more about pattern matching
18:32 - and let us have a look at this example
18:36 - now the square brackets means that this
18:38 - is a list and I will be covering more
18:41 - about list a little later in the series
18:44 - but for now let us just go with the flow
18:47 - for now I don't want you to concentrate
18:50 - on the syntax I want you to concentrate
18:53 - just on the right hand side and the left
18:57 - hand side
18:58 - can you see that the pattern on the
19:01 - right is the same as the pattern on the
19:03 - left we have two variables on the left
19:06 - hand side we have two values on the
19:08 - right hand side here you can say that
19:11 - the value of 1 is now bound to the
19:14 - variable of a
19:16 - now the next variable is also a and the
19:20 - value inside a is also 1 and that's what
19:23 - it is
19:24 - so this is going to be true inside
19:26 - elixir
19:27 - for a quick demo let me open up my
19:29 - terminal and I'm already inside IEX in
19:34 - case if you are for Photon how to go
19:35 - inside IEX let me show you once again
19:37 - for quitting IEX just press Ctrl C twice
19:42 - and you can put the IEX and again if you
19:45 - want to go inside just type as i e and X
19:49 - again let me clear it up
19:51 - so here I can say that my list has two
19:55 - variables a and a and
19:58 - the values are 1 and 1.
20:03 - so here it is it's a perfect match the
20:06 - right hand side is equal to the left
20:07 - hand side so we get the values back
20:10 - if I just say I want to see the value of
20:13 - a
20:14 - and here it is we get the value of a as
20:17 - 1. now let us go back
20:21 - now can you guess what is going to
20:23 - happen this time
20:25 - now this time you can see that we have
20:27 - the values of a and a and on the right
20:30 - we have the value of 1 and 2. well let
20:34 - us go to our IEX and see what's going to
20:37 - happen this time
20:38 - so we have this A and A and on the right
20:41 - we have 1 and 2. let us see what's going
20:45 - to happen
20:46 - o we get an error and if you watch
20:49 - closely we get an error saying that no
20:52 - match of the right hand side
20:55 - and yes it is not a match the reason is
20:58 - the value of 1 is bound to the variable
21:02 - of a
21:04 - and again the second value is a but this
21:07 - time the value inside a is 1 and on the
21:10 - right the value is 2 so 2 is not equal
21:13 - to 1 and that's why the right hand side
21:16 - and the left hand side are not a match
21:19 - and that's why we get an error let us go
21:22 - back
21:24 - now what happens if we write something
21:27 - like this if we switch the second value
21:29 - from a to a new variable of B
21:33 - can you guess what is going to happen
21:35 - well let us go back and let us see
21:37 - what's going to happen this time
21:40 - so here let me change the value from A
21:42 - to B
21:43 - and let us see well yes it's a perfect
21:47 - match
21:48 - so what's happening this time the value
21:50 - of 1 is bound to the variable of a and
21:54 - the value of 2 is bound to the variable
21:57 - of B
21:58 - we can check it out so if I say a then
22:02 - we get the value of 1 and if I say B we
22:06 - get the value of 2 and that is what it
22:10 - is right over here
22:11 - always try and think in terms of pattern
22:13 - matching that means we always want to
22:16 - have the right hand side equal to our
22:19 - left hand side
22:21 - so this is also called as pattern
22:23 - matching and as I have said earlier this
22:27 - is a very powerful pattern inside Elixir
22:29 - and we would be using this pattern
22:31 - matching throughout this entire tutorial
22:34 - series
22:35 - till now we have seen a little bit about
22:37 - pattern matching inside elixir
22:40 - and we have been using our terminal but
22:43 - we can do a much better job
22:45 - and allow me to introduce to you
22:47 - livebook so livebook is actually like
22:51 - the Jupiter notebooks for Elixir but
22:54 - before I can show you live book you must
22:56 - have noticed that I have a different
22:58 - prompt and I have a couple of more
23:00 - colors inside my terminal and this is
23:03 - because I'm using a little bit more
23:05 - fancier setup but that's about it now
23:08 - let me go to livebook
23:11 - so here it is you can simply navigate to
23:14 - this website livebook.dev and from here
23:17 - we can simply install livebook on our
23:19 - machine so just click on install
23:22 - and from here you can choose your Mac or
23:24 - Windows and download the setup and after
23:28 - you have downloaded the setup just
23:30 - install it as you would install any
23:32 - other program in your machine now I have
23:35 - already installed live book so let me
23:37 - just open it up here it is
23:40 - so this is how it is
23:42 - we can start a new notebook we can
23:45 - simply click over here new notebook and
23:48 - that's it we are good to go let us try
23:51 - the same code that we wrote inside our
23:53 - terminal so here I can see is my a comma
23:57 - a equal to my 1 comma 1 and simply you
24:02 - can click over here evaluate
24:04 - and now we have the output right over
24:07 - here let us try with some other examples
24:09 - so here I can say
24:13 - if my a is equal to 1 then is my
24:17 - 1 equal to a and let us try to evaluate
24:21 - in this cell and yes we get the output
24:26 - now what I have done just for a
24:27 - reference I have also included a couple
24:30 - of notebooks and you can find all of
24:33 - those right over here so this is the
24:36 - GitHub repo for this entire tutorial
24:38 - series which is octallium slash oops uh
24:43 - it's right over here
24:44 - you can go to octallium and slash
24:47 - functional programming with Elixir and
24:50 - inside notebooks you can see that I have
24:52 - a couple of notebooks now in the future
24:54 - I may add a couple of more notebooks to
24:57 - this one but at the time of recording we
24:59 - have three of those
25:01 - so let us see how we can open this
25:03 - notebooks inside our live book so let me
25:06 - go back to my live book
25:07 - and let me just click on this icon on
25:10 - the left
25:11 - and here I simply have to choose my path
25:14 - so I have to go inside my GitHub
25:16 - octalium functional programming with
25:19 - Elixir notebooks and let me choose the
25:23 - first one and let me simply click on
25:26 - open so this is the first live book that
25:28 - you can find inside the repository and
25:31 - as you can see I have included a couple
25:33 - of text and also a couple of code blocks
25:36 - for your reference
25:37 - so this is what we were trying to do
25:39 - last time
25:41 - and if you see right over here I have
25:43 - created some more examples so if my name
25:46 - is is equal to octallium then my
25:48 - octalium should also be equal to name
25:51 - and so on so what you can do maybe you
25:54 - can try to create a couple of more
25:56 - notebooks and you can try to open up the
25:59 - notebooks which I have included inside
26:01 - the repo and I'll catch you in the next
26:03 - video
26:04 - till now we have been trying to learn
26:06 - more about pattern matching and let us
26:08 - continue with the same thing in this
26:10 - video as well
26:11 - now let us go back to our terminal and
26:14 - let me coincide IEX
26:16 - so I can do that by simply typing IEX
26:18 - now again please let me remind you that
26:21 - my prompt is looking different and that
26:24 - is because I have customized the
26:26 - settings I just wanted to have the
26:28 - prompt to be same as my logo that's why
26:31 - I simply changed it but that's about it
26:34 - now let me clear up the terminal and
26:36 - here let us try to learn a little bit
26:38 - more about pattern matching so again let
26:41 - us create the same list a and a and for
26:45 - the right hand side let us say that we
26:47 - want to match with 1 and 2 and as you
26:50 - know we are going to get a match error
26:52 - and this is what we are getting
26:54 - so again let me try and refresh a memory
26:57 - what's happening so what's happening is
27:00 - the value or the variable of a is bound
27:03 - to the value of 1. and on the next time
27:07 - what's happening is here we have a but
27:10 - we are trying to match the value of 2
27:12 - with a and as you know a is bound to 1
27:16 - that's why we are getting match error
27:18 - now let's take a couple of minutes and
27:20 - let us try to understand why this is
27:22 - happening this is happening because all
27:25 - of the data types inside Elixir are
27:27 - immutable that means we can't randomly
27:31 - assign new values to an existing
27:34 - variable inside Elixir now you must be
27:36 - thinking that why does all of the types
27:39 - inside Elixir has to be immutable the
27:42 - short answer is because for scalability
27:44 - and we will come to this point in the
27:46 - next video but for now let us try to
27:48 - understand what's happening behind the
27:50 - scenes now let me try to clear up the
27:53 - screen one more time and this time let
27:55 - us say that we want our a and we want on
27:58 - the right to be 1. so this time what's
28:01 - happening is we have a match operator
28:03 - right over here and the value of 1 is
28:06 - bound to the variable of a but here
28:10 - comes a small caveat so if I say a is
28:13 - equal to 2 so this time we do not have
28:15 - an error but I just said that our data
28:18 - types are immutable inside Elixir so
28:21 - what's happening so whenever we have a
28:23 - variable on the left hand side of our
28:26 - match operator at that time Alexa thinks
28:29 - that we want to bound the new value to
28:32 - the variable on the left that's why we
28:34 - have the new value instead of a which is
28:37 - true but if you don't want this Behavior
28:39 - then we can use a pin operator so we can
28:42 - say the pin operator and a is equal to 3
28:45 - so this time as you can see we get a
28:48 - match error and the match error is
28:50 - saying that no match of right hand side
28:52 - value of 3 and this is because instead
28:56 - of a we have the value of 2 and on the
28:58 - left hand side we are trying to match a
29:00 - value of 3 that's why we get the match
29:03 - error now if we try to do this thing the
29:05 - other way around and if we say that 3 is
29:08 - equal to a so again this time we get an
29:11 - error saying that no match and the right
29:14 - hand side value is 2 so yes as you can
29:17 - see right over here the value which is
29:19 - bound to a is 2 and that's why 3 is not
29:22 - equal to 2 and we get a match error and
29:25 - on line number 4 we could rebound the
29:28 - new value of 2 to our variable of a just
29:31 - because this variable is on the left
29:34 - hand side of the match operator for now
29:36 - you don't have to worry too much about
29:37 - these things as we progress and as we
29:40 - saw a couple of more examples all of
29:42 - these things will get cleared very
29:44 - easily now coming to the next Point why
29:47 - do we need immutability inside Elixir
29:49 - and my short answer was scalability so
29:52 - let me try to explain why immutability
29:55 - helps in scalability
29:57 - since our data is not immutable that
30:01 - means the data can be easily copied
30:03 - across various processes and we don't
30:06 - have to worry if another resource
30:07 - another thread or another process is
30:09 - changing or trying to mutate our data
30:12 - this thing will get clear when we
30:14 - understand how code is executed inside
30:16 - Elixir and when we understand the actor
30:19 - model and that's what we are going to do
30:21 - right in the next video let us try to
30:24 - understand how all of the code inside
30:25 - Elixir gets executed now all of the code
30:29 - gets executed in something which is
30:31 - called as an actor
30:33 - so you can imagine your actor to be
30:36 - something like this box now this is an
30:39 - isolated box and what happens is this
30:42 - box or this actor receives some kind of
30:46 - messages now this messages could be data
30:49 - it could be instructions of what to do
30:51 - with the data and so on
30:53 - after receiving these messages your
30:55 - actor is going to process your messages
30:57 - and it is simply going to give you back
31:00 - some kind of a response so in simple
31:03 - terms you can imagine actor to be like
31:06 - an isolated competition unit it gets
31:09 - something it processes something and it
31:11 - gives back something now what happens is
31:14 - this act as they run inside something
31:16 - which is called as processes and at a
31:19 - given time we can have millions and
31:21 - millions of processes
31:23 - this is where the data immutability
31:26 - comes into picture we can have millions
31:29 - of copies of our data and they can be
31:31 - distributed across various actors not
31:34 - only on our local machine but we can
31:36 - have a global cluster of different
31:38 - servers and we can distribute our load
31:41 - horizontally across the globe
31:44 - so these processes are not your
31:46 - operating system processes you can
31:48 - imagine them to be like your virtual
31:50 - threads so let's try to understand these
31:52 - processes one step at a time we just saw
31:55 - the actor model and this actors they run
31:58 - inside your processes
32:01 - for each process we have a separate ID
32:03 - which is called as bid and I will show
32:05 - you the bid shortly in this video
32:08 - the next part is we can communicate
32:10 - between these processes by message
32:12 - passing
32:13 - and as we just said that since our data
32:16 - is immutable we can create multiple
32:18 - copies and this copies can be assigned
32:21 - to different processors
32:23 - and since each actor gets its own copy
32:26 - of data we don't have to worry if
32:28 - another is changing the state everything
32:30 - runs in isolation
32:32 - the next part is each process has its
32:36 - own stack and Heap allocation so if we
32:39 - come from a compiled programming
32:40 - language such as C or C plus plus
32:43 - we have different memory allocation
32:45 - models you can allocate your memory
32:47 - inside the stack or on the Heap
32:50 - and in case of Elixir each process gets
32:54 - its own stack and hip allocation so this
32:57 - way the garbage collection is very fast
32:59 - we have to just garbage collect for a
33:01 - single process and our application
33:03 - remains responsive at the same time next
33:07 - let us have a little bit more details
33:09 - about our actors every actor has its own
33:13 - mailbox so every message that you pass
33:16 - to an independent process they are
33:18 - collected inside this mailbox and after
33:21 - that they are executed in a sequential
33:24 - order and the Order of execution is
33:27 - first in and first out
33:29 - next this processes are very cheap to
33:32 - create they require less than 3 KB of
33:35 - memory so you can see it's very cheap
33:37 - and we can spawn millions of processors
33:40 - at a given time and the last part to
33:42 - remember is we always communicate with
33:45 - message passing now let us go back to
33:48 - our terminal and let us check our bid
33:51 - over there so pit stands for your
33:53 - process ID
33:54 - so the first thing is let us go inside
33:56 - our IEX let me clear up everything now
34:01 - this IEX is also running inside a
34:03 - separate process and we can check the
34:05 - process ID by using the built-in
34:07 - function called as self now the next
34:10 - thing about Elixir is the parentheses
34:12 - are not mandatory self is a function you
34:16 - can write the parentheses or you can
34:18 - leave them out but these days the
34:21 - general convention is whenever you are
34:23 - writing code inside the code editor at
34:25 - that time we prefer parentheses but on
34:28 - the terminal it's all up to you I am
34:30 - going to leave them out
34:32 - and here we get the output so the
34:34 - current process ID in which our IEX is
34:37 - running is right over here and this is
34:40 - the address
34:42 - 0.107.0 so that's it for this one and I
34:45 - will catch you in the next video
34:48 - I think now we know enough of Elixir and
34:51 - now it's time to write the all important
34:53 - hello world program so let us get
34:56 - started let me open up my terminal and
35:00 - here let me create a folder by the name
35:02 - of functional programming with Elixir
35:04 - now let me go inside of this folder
35:08 - and here let me create one more
35:10 - directory for Scripts
35:13 - let me go inside my scripts directory
35:15 - and here let me create one more file by
35:18 - the name of Hello dot EXs now Elixir has
35:23 - two file extensions this dot s that you
35:26 - can see right over here this means that
35:29 - we want to create a script file and
35:32 - whenever we want to create a compile
35:34 - file that time we simply write as dot EX
35:37 - we will see more about the dot ex
35:40 - extension when we create our first
35:42 - project by using the mix tool but right
35:45 - now just keep in mind that whenever we
35:48 - want to create a script at that time we
35:51 - simply add a s now there are a lot of
35:54 - times when you need extra files for
35:57 - example you need a file to just seed
35:59 - your database
36:00 - or if you want a file just for testing
36:03 - these files are not meant to go into
36:06 - production they are just meant for your
36:08 - development now let me go ahead and
36:10 - create this file and let us open up this
36:13 - file inside our code editor
36:15 - now my code editor is complaining that
36:18 - no mix file found so right now just
36:20 - ignore this and when we create a project
36:23 - by using mix it will go away let me
36:25 - collapse my sidebar so the first thing
36:28 - that you should keep in mind that all of
36:30 - the code inside Elixir stays inside its
36:33 - modules so let's create a module and for
36:36 - creating module we simply have to say
36:38 - that we want to define a module and let
36:42 - us name the model as hello and next for
36:46 - Elixir we don't have curly brackets
36:48 - instead we have the do and end blocks so
36:52 - what we have done till now is we have
36:54 - simply defined a module and all of the
36:57 - code will go inside this module as a
37:00 - general convention the module name and
37:03 - the file name should be same it's not
37:06 - required but just as in community
37:08 - convention they should be equal for
37:10 - example let me open up my sidebar here
37:13 - you can see that we have named the file
37:14 - as hello and we have also named the
37:17 - module as hello let me collapse my
37:20 - sidebar and inside of this module let us
37:23 - create our first function and you can
37:26 - create functions by using the keyword
37:28 - cordless Dev and let us call our
37:31 - function as world now this function will
37:34 - not accept anything so you can't keep
37:36 - your blank parentheses or you can leave
37:39 - them out completely that means this is a
37:42 - function which does not accept any
37:44 - parameter then again we need to create
37:47 - our do and end blocks and here we can
37:50 - say that from our input output we simply
37:53 - want to put something to our output and
37:56 - here we simply want to display the
37:58 - message of hello Elixir now always use
38:01 - the double quotes for defining your
38:04 - strings single codes are meant for
38:06 - characters but right now since we want a
38:08 - string that's why we have put double
38:11 - quotes now let us save this program and
38:14 - let us see how we can run this program
38:16 - let me adjust the screen we can run this
38:20 - file in a couple of different ways so
38:23 - let us see the first method here we can
38:25 - simply say that hey Elixir I simply want
38:28 - you to run the file which is called as
38:30 - hello.exs
38:33 - and you can see that Elixir actually ran
38:36 - our file but we don't have any output
38:38 - and we don't have an output because we
38:41 - have not called the function of word so
38:44 - let us do that right over here let me
38:46 - take my terminal slightly down and here
38:49 - what we can do is here we can say that
38:51 - from our model of hello I want to call
38:55 - the function of world let us save the
38:58 - file and now let us go to our terminal
39:00 - and let us try to run the same command
39:03 - one more time and this time we get the
39:05 - output of hello elixir so you can use
39:09 - this method whenever we want to run a
39:11 - script file but Elixir is actually a
39:14 - compiled language so let us see how we
39:17 - can actually compile this file now again
39:19 - please keep this in mind that whenever
39:22 - we want to have a compiled file that
39:24 - time the file extension should be dot ex
39:27 - but right now let me show you how we can
39:30 - compile and run this script so let me
39:33 - clear up my terminal and here instead of
39:36 - writing Elixir we can say that Elixir
39:38 - compiler by adding a c right over here
39:41 - so this stands for Elixir compiler so
39:43 - now Elixir is actually going to compile
39:45 - this file and then it will run for us so
39:49 - let me open up the sidebar here you can
39:51 - see that we have a single file hello.exs
39:54 - and this one is created by our virtual
39:56 - Studio code now let us compile the file
39:59 - and let us see what happens
40:01 - so as you can see in the sidebar Elixir
40:03 - actually compiled and we have a new file
40:06 - called as
40:08 - elixir.hello.beam now remember that
40:10 - Elixir runs on the beam virtual machine
40:13 - and this is the compiled file for our
40:15 - Elixir code but normally we don't
40:17 - compile and run the Elixir files like
40:20 - this we would use the mix tool and we
40:22 - will learn more about the mix tool as we
40:25 - progress in the tutorials but right now
40:27 - let us go with the flow now let me
40:29 - collapse my sidebar we can also run this
40:32 - file inside our interactive shell so let
40:35 - me show you how we can do that let us go
40:37 - inside our interact with shell and let
40:41 - me clear up everything now here we can
40:44 - say that we want to compile the file of
40:46 - hello.exs
40:49 - and that's it now we are getting a
40:52 - warning saying that redefining module
40:54 - hello and that's because just a couple
40:57 - of seconds back we actually compiled
40:59 - this file and that file is currently
41:01 - inside our memory but right now we can
41:04 - simply ignore all of these things next
41:06 - your IEX actually ran the file and here
41:09 - we can see we have the output of hello
41:11 - Elixir now let me clear up the screen
41:14 - one more time and let us see how we can
41:16 - also manually call the function
41:19 - so here we can say that I want you to go
41:21 - to the model of hello and from there I
41:24 - want you to go to the function of word
41:27 - now remember that parentheses are
41:29 - optional inside Elixir and since our
41:32 - function of world does not accept any
41:34 - parameters I can have my blank
41:37 - parentheses or I can simply leave them
41:39 - out
41:40 - and here you can see that we have an
41:42 - output of hello Elixir and after this we
41:45 - also have a message saying as okay now
41:48 - okay symbolizes a data type which is
41:51 - called as atom
41:52 - we will learn more about the data types
41:55 - in the next video but right now let us
41:58 - go with the flow now again let me close
42:01 - my terminal and this time let us make
42:04 - the function accept some kind of a
42:06 - parameter so here we can say that we
42:08 - want the function of world to accept a
42:10 - parameter and we want to name the
42:12 - parameter as name next we can use our
42:16 - string interpolation so here let me take
42:18 - out Elixir and here we need to put the
42:21 - hash sign and then we need to put the
42:23 - curly brackets and inside the curly
42:25 - brackets I can simply use our parameter
42:28 - of name and also let me take out this
42:31 - line This is not required so let us open
42:33 - up our terminal and we have our IEX
42:36 - running now since we changed the file
42:39 - let us recompile the module and we can
42:41 - do that by typing R now R stands for
42:44 - recompile and we simply want to
42:46 - recompile our model of hello and that's
42:49 - it we have redefined the module let me
42:52 - clear it up and here we can say that
42:55 - hello Dot world and now let us pass a
42:59 - parameter called as octallium and we
43:02 - have the output of hello octalium now
43:04 - remember that the parentheses are
43:06 - optional so we can also write something
43:08 - like this let me take out the
43:10 - parentheses and let me give a space
43:13 - right between over here so as we can see
43:15 - this code is also valid and we get the
43:18 - exact same output well that's it for
43:21 - this video and we will see the different
43:22 - data types in Elixir right from the next
43:25 - one let us try to learn more about the
43:28 - different data types in elixir the first
43:32 - thing which I wanted to remind you is
43:34 - all of the data types in Elixir are
43:36 - immutable in common terms what I mean to
43:39 - say is all of the data types inside
43:42 - Elixir are constants
43:44 - now with this concept in mind let us go
43:47 - ahead and let us try to study the first
43:49 - data type and the data type is called as
43:52 - an atom an atom in Elixir looks
43:55 - something like this so we have a colon
43:58 - symbol right over here and after the
44:00 - colon we have the name of the atom and
44:03 - in case there is some space inside the
44:05 - name of the atom then we can write an
44:08 - atom like this so again the syntax goes
44:10 - like this your item will always start
44:12 - with a colon and then we have the name
44:14 - of the item and in this case since we
44:17 - have a space inside the name of our item
44:20 - we are using double quotes and inside
44:23 - the double quotes we have the name of
44:25 - the atom now this was just the syntax of
44:29 - an atom but now let us go ahead and let
44:32 - us try to understand what's an item all
44:34 - about so let's consider this scenario so
44:37 - we have a symbol or a logo like this can
44:41 - you tell me what this logo symbolizes
44:43 - now this logo is of a very popular brand
44:46 - Android brand is Nike so what's
44:50 - happening in this case this symbol is
44:52 - synonymous with the name of Nike if I
44:55 - show you the symbol or if I show you the
44:57 - name both of this values point to the
45:00 - exact same thing so this is just a
45:03 - pseudo code and this is not a valid
45:05 - Elixir syntax but let us understand the
45:08 - concept of an atom so what's happening
45:10 - right over here is we have a variable
45:13 - and the name of the variable is Nike and
45:16 - the value assigned to this variable is
45:19 - also Nike so in short the value and the
45:23 - name are the same and this is what an
45:26 - item represents in an atom the name and
45:29 - the value is always same and we can
45:32 - represent this in terms of atom like
45:34 - this so we have an atom for Nike let us
45:38 - open up our IEX and we can start playing
45:41 - right over there so this is my terminal
45:43 - let me go inside my IEX and let me clear
45:47 - up the screen so let us create the same
45:50 - item for Nike so you can say Nike this
45:54 - is what an atom is all about suppose we
45:56 - had a very long name that had spaces in
45:59 - between so we can say something like
46:02 - this the and Nike
46:05 - so this is also a valid atom and you
46:08 - will notice that our atom always starts
46:10 - with a colon now what we can do is let
46:13 - us go to our live book and then we can
46:15 - create a couple of more examples of atom
46:20 - so this is our live book and let us
46:23 - create a new notebook
46:25 - let me give the title as data types and
46:30 - this section is all about our atom in
46:33 - Elixir you will see atoms everywhere
46:35 - atoms are very heavily used for pattern
46:38 - matching now suppose you are working on
46:41 - some kind of an application and you want
46:43 - to return an error message so that time
46:46 - what we can do is we can simply create
46:48 - an atom called as error so we can say
46:51 - something like this error and let us
46:54 - click on evaluate so here it is we have
46:56 - created an item which is called as error
46:59 - next let me show you a very practical
47:01 - use of this kind of an atom so let's
47:03 - take the exact same example suppose we
47:06 - are working on an application and we
47:08 - have an error where we are not able to
47:10 - find a file so at that time it's very
47:13 - common to return back a tuple and the
47:16 - Tuple is represented by this early
47:18 - strings now I will cover tuples a little
47:21 - later in the series but right now let's
47:22 - go with the flow and inside the Tuple we
47:25 - can say that the first element is an
47:28 - error so there is some error in that
47:30 - operation and then we can describe the
47:33 - reason for the error so we can say for
47:35 - example file not found and this kind of
47:38 - pattern is very common inside Elixir
47:41 - normally we will have a two element
47:43 - Tuple or a three element apple and
47:45 - regularly you will see that we simply
47:48 - pattern match on this Tuple so what we
47:50 - can do is on the left hand side we can
47:53 - again pattern match with this Tuple so
47:55 - let me create a new Tuple right over
47:57 - here and the first element is an error
47:59 - the second element we can call it as a
48:02 - reason now again what's happening over
48:04 - here is we are simply using our pattern
48:07 - matching I want you to go back to the
48:09 - concept of your left hand side is equal
48:11 - to your right hand side so on the right
48:15 - hand side we have a tuple and on the
48:18 - left hand side we have a tuple next what
48:20 - is happening is on the right we have a
48:22 - string called as file not found and on
48:26 - the left we have a variable oh let let
48:29 - me get the spelling right this has to be
48:30 - reason so what's happening is since we
48:33 - have a variable on the left hand side
48:35 - this value of file not found is being
48:38 - bound to our variable of reason so let
48:42 - us click on re-evaluate and let us see
48:44 - what's happening and we get our Tuple
48:46 - back error file not found let us split
48:49 - this into different code blocks so let
48:51 - me create a code block right over here
48:53 - and let me take this code or from here
48:55 - and let me paste it right over here
48:58 - again let me click on the evaluate and
49:00 - here also we can evaluate now what we
49:03 - can do is since we are using pattern
49:05 - matching we can extract the value of
49:08 - file not found and I just said that this
49:11 - value of file not found is bound to our
49:14 - variable of reason and we can check out
49:16 - the value by simply typing our reason
49:19 - and let us click on re-evaluate and here
49:22 - we get the value back file not found now
49:26 - this pattern is very very common in
49:28 - elixir
49:29 - so let us have a look at one more
49:31 - example and suppose this time we have a
49:34 - successful operation uh for example if
49:36 - we are working on some kind of an web
49:39 - application and we get back a status 200
49:41 - message so at that time what we can do
49:43 - is we can pattern match on OK and then
49:47 - we can have a message and here we can
49:49 - pass our OK and we can say status 200
49:54 - okay and then we can see the contents of
49:57 - our message now let us click on evaluate
50:00 - and as you can see we get the value of
50:02 - message back so again the same thing is
50:04 - happening over here we simply have to
50:06 - Pat and match the right hand side along
50:08 - with the left hand side OK is matching
50:11 - with the OK right over here and this
50:14 - string is being bound to our variable of
50:16 - message and that's what we are calling
50:18 - on the next line right over here well
50:21 - this was all about atoms and in the next
50:23 - video we'll start with strings inside
50:25 - elixir
50:26 - the next data type in our series is
50:29 - going to be the string and strings in
50:32 - Elixir are represented by double quotes
50:35 - So this is going to be a valid string
50:37 - for Elixir we have the double quotes and
50:40 - inside the double quotes we have the
50:42 - string now instead of the double quotes
50:45 - if you use a single code then that would
50:47 - mean a character list and a character
50:50 - list is different from a string inside
50:53 - Elixir now let us go and play a little
50:55 - bit with strings inside our IEX
50:58 - now let us go inside our IEX
51:01 - and let me clear up the screen and as I
51:05 - just said we can create a string by
51:06 - using our double quotes so let me write
51:09 - octalium so this is going to be a valid
51:12 - string inside Elixir now what happens
51:14 - the IEX also provides us with a lot of
51:18 - convenience functions for checking
51:20 - different data types and one such
51:22 - function for displaying the information
51:24 - is called as I so let us call I and let
51:28 - us pass the variable of octallium and
51:30 - let us see what kind of output we are
51:32 - getting
51:33 - so we can see that the term is octallium
51:37 - and the data type is a binary string so
51:41 - what happens inside Elixir is your
51:43 - strings are actually saved as a
51:45 - collection of bytes that's why it is
51:48 - saying that the data type is a binary
51:50 - string next the size of our string is 9
51:53 - bytes and the next thing that you can
51:56 - see is in Elixir a string is actually a
51:58 - UTF 8 encoded binary now I just said
52:02 - that your strings are saved as a
52:05 - collection of bytes and this is how it
52:07 - actually looks inside your memory and as
52:10 - you must have noticed it starts with
52:12 - double angle brackets and it also ends
52:15 - with the double angle brackets now
52:17 - inside of this collection you can see
52:19 - that we have the individual integer
52:22 - representation of each of the characters
52:24 - inside our string for example the
52:27 - integer of 79 denotes uh o 99 denotes a
52:32 - c and so on next we can also see a
52:35 - couple of protocols that are implemented
52:38 - for the type of a string now Protocols
52:41 - are a slightly Advanced topic and will
52:43 - not be covering protocols in this
52:45 - tutorial but for now let us go ahead and
52:47 - let us see what else we can do with the
52:49 - strings now let us have a look at a
52:52 - little bit of magic of pattern matching
52:54 - with our strings now strings is just a
52:57 - collection of our bytes and what we can
53:00 - do is we can use our pattern matching to
53:02 - extract individual code points from our
53:05 - string so let me clear up the screen and
53:09 - here what we can do is we can simply
53:11 - match for an O for octallium so we can
53:14 - say that our first character should be o
53:17 - and the next one we can collect in a
53:19 - different variable called as rest is
53:23 - equal to octallium and let us see what
53:25 - happens next now let us see the contents
53:28 - of the variable of rest and here we can
53:31 - see that the rest variable contains all
53:34 - of the alphabets after o so what's
53:37 - happening on this line right over here
53:39 - so again the same thing goes your left
53:41 - hand side should be equal to your right
53:44 - hand side on the right hand side we have
53:46 - a capital O and that is being pattern
53:49 - match right over here and next we have a
53:51 - string concatenation operator and we are
53:54 - saying that we want to collect all of
53:56 - the different code points after o inside
53:59 - a variable called as rest so what
54:02 - happens all of the other characters
54:03 - starting from C all the way to M these
54:07 - characters get bound to our variable of
54:09 - rest and that's what we are checking on
54:12 - line number six let us have a look at
54:14 - one more example suppose we again want
54:17 - to see the information for a new string
54:20 - called as ABC now again the parentheses
54:23 - are optional so even if I take out this
54:26 - parenthesis still the code should work
54:28 - and here we get the output and here we
54:31 - can see that the raw representation of a
54:33 - band C is right over here now what's
54:36 - happening is 97 simply denotes the code
54:39 - point for our character of a and we can
54:43 - check that out by using a different
54:44 - syntax so we can put a question mark
54:47 - followed by a so this gives us the code
54:50 - Point representation for a and here we
54:53 - can see that it's 97 and that's what we
54:56 - have right over here now suppose we want
54:58 - to see the code 0.4 B so B is going to
55:01 - be 98 and for C is going to be 99 and so
55:06 - on now with all of these points in our
55:08 - mind let us go back to our live book
55:11 - and let's start playing a little bit
55:13 - more with our strings
55:15 - so here let us create a new section so I
55:18 - want to go on block and create a new
55:20 - section and this section is all about
55:22 - your strings
55:25 - so let us create the same string right
55:28 - over here so we can say we want to
55:30 - create a variable called as name and let
55:33 - us assign the value of octalum to this
55:35 - one next let us just print out the value
55:38 - of name and let us see what output we
55:40 - are getting and as expected we are
55:43 - getting our string back next we can also
55:46 - check if the given data is of the type
55:48 - of string or not
55:51 - so for that we can use an inbuilt
55:53 - function called as is binary so remember
55:56 - your strings are represented as a
55:59 - collection of your raw code points or a
56:02 - collection of your bytes so we can use
56:05 - this function of s binary and let us
56:08 - pass the variable of name and let us try
56:11 - to evaluate and we get the answer as
56:13 - true so yes this is a binary that means
56:16 - this is a string next let us see how we
56:19 - can add two strings together
56:21 - so let me create a new code block and
56:24 - let us create a new variable called as
56:26 - message and here we can create a message
56:29 - saying that hello and for adding or for
56:33 - concatenating we have to use this double
56:35 - angle brackets and then let us pass our
56:38 - variable of name so again just to help
56:41 - you remember your we have the angle
56:43 - brackets and if you go back to our
56:46 - terminal and here we can see the raw
56:48 - representation here also we have the
56:51 - angle brackets the only difference is
56:53 - for the representation we use the double
56:55 - angle brackets
56:56 - and for string concatenation we use the
56:59 - single angle bracket so let us see the
57:01 - output of this one so let us try to
57:03 - evaluate and here we have the message of
57:05 - hello octarian next we can use our
57:08 - pattern matching and let us try to
57:10 - extract values from the string so let's
57:13 - create a new code block and here again
57:15 - we can pattern match so we can say that
57:17 - the first couple of characters should be
57:20 - hello and after hello I want to collect
57:23 - the remaining in a new variable called
57:25 - as name and on the right hand side we
57:28 - have to Simply pass the message so
57:30 - remember message is hello octallium so
57:33 - hello and this space right over here
57:35 - this is going to be pattern matching
57:37 - right over here and the name of octalum
57:40 - would be bound to our variable of name
57:43 - next we can also check out the contents
57:45 - of the variable of name so let us write
57:48 - it over here and let us try to evaluate
57:50 - and here we get the name back as
57:53 - octalium now there is one more way of
57:55 - pattern matching with our strings
57:57 - and this method is by pattern matching
58:00 - on the raw representations so let's see
58:03 - how we can do that so let us create a
58:04 - new code block now remember that the raw
58:07 - string representation is done by our
58:09 - double angle brackets and here let us
58:12 - try to pattern match so here we can say
58:15 - that we want to pattern match the first
58:17 - character or the first code point in a
58:20 - new variable and let us call that
58:22 - variable as head next what we want to do
58:25 - is we simply want to collect all of the
58:28 - remaining code points in the new
58:30 - variable and we can call that variable
58:32 - as rest now since we are using the raw
58:36 - string representation we also need to
58:38 - tell to elixir in which format do we
58:41 - want to collect all of the rest code
58:43 - points so here we can say that the type
58:46 - of rest would be binary and on the right
58:49 - hand side we simply have to pattern
58:51 - match with name and next let us see what
58:54 - is inside our variable of head and let
58:57 - us try to evaluate this cell so what's
59:00 - happening right now is instead of
59:02 - getting a string back we actually get
59:04 - the code point back and if we refer back
59:07 - to our terminal as we can see right over
59:09 - here so this 97 actually denotes our
59:13 - code point of a so that's what is
59:16 - happening right over here so in this
59:18 - case 79 actually denotes the code point
59:21 - for our o and we can check it out in a
59:25 - new blog so let us create a new block
59:27 - right over here and here we can say that
59:30 - is my head is equal to the code point of
59:34 - O and let us try to evaluate and see
59:36 - what answer we are getting so yes the
59:38 - answer is true so if you are feeling a
59:41 - little bit confused so let us go back to
59:43 - our terminal
59:44 - let me clear all of these things and let
59:47 - us check the code point for our
59:49 - character of O and we get the integer
59:52 - representation as 79 and that's what we
59:55 - are checking right over here so the
59:57 - value inside head is 79 and that's what
60:00 - we are checking in this line and since
60:02 - the character value of O is also 79
60:05 - that's why this expression is evaluating
60:07 - to a true so you can see that pattern
60:10 - matching is very powerful inside Elixir
60:13 - and we use pattern matching practically
60:15 - everywhere inside elixir let us take the
60:19 - same example so let me copy from here
60:22 - and let's create a new code block and
60:25 - let me paste it right over here and here
60:27 - instead of using this variable of head
60:29 - let us pattern match on o and let us see
60:33 - if we can get the rest back and let us
60:36 - try to evaluate this expression and we
60:38 - get the right answer back so we get all
60:40 - of the characters from C to M now it's
60:43 - not mandatory to just pattern match on a
60:45 - single character we can button match on
60:48 - multiple characters so let me copy this
60:51 - one let us create a new code block
60:54 - and let me paste it over here and this
60:57 - time we can use two characters so let us
60:59 - pattern match on O and C and next let us
61:02 - check the contents of rest and let us
61:04 - try to evaluate this cell and as you can
61:07 - see we get the right output so you can
61:10 - see that pattern matching is really very
61:12 - powerful inside Elixir next you can be
61:15 - also very specific while pattern
61:17 - matching with strings you can actually
61:19 - specify the number of strings that you
61:21 - want to collect so let me show you an
61:23 - example right here let us create a new
61:26 - code block and let me copy this thing
61:30 - right over here now instead of saying O
61:33 - and C what we can do is we can say that
61:35 - we want to create a variable called as
61:37 - head and inside this variable we want to
61:40 - collect the first two binaries so here
61:43 - we can say that we want to collect the
61:46 - binary and the binary size should be for
61:49 - two characters next let us check the
61:52 - output of our head and let us try to
61:56 - evaluate this one and as you can see we
61:58 - get the characters of onc back well this
62:02 - was all about strings inside Elixir now
62:04 - don't worry if you don't get this
62:06 - pattern matching with binaries and all
62:08 - of these things I just wanted to show
62:10 - you all of the different possibilities
62:11 - by using pattern matching inside elixir
62:15 - the next data type is our Char list or
62:19 - our character list and as I have already
62:21 - explained the character list is created
62:24 - by using single quotes so let us create
62:26 - a variable called as characters and let
62:29 - us assign the value of octalium now as
62:32 - you can see I'm using single quotes
62:33 - right over here
62:35 - and we get back the value of octallium
62:38 - now let us do one thing let me copy this
62:40 - and let us go to our terminal
62:43 - and inside my IEX I can check for the
62:46 - information so I can use the inbuilt
62:49 - function of I and let me paste the
62:52 - character string right over here and let
62:54 - us see what kind of output we are
62:55 - getting
62:56 - so this time if you see the data type is
62:59 - actually a list
63:01 - last time when we were studying about
63:03 - strings the data type was a binary
63:06 - string but this is a collection of
63:09 - characters inside a list and if you want
63:12 - to see the raw representation so here it
63:16 - is now please note that as this is a
63:18 - list we have square brackets at the
63:21 - start and also at the end and as you can
63:24 - see each of the characters are also
63:26 - represented by the integer values so
63:29 - again the same thing goes 79 represents
63:32 - o then the value for C is 99 then for T
63:38 - it is 116 and so on so let us go back to
63:41 - our live book
63:43 - next let us see how we can add two
63:46 - character lists together so let me add a
63:49 - new blog and here let me create a new
63:52 - character string and let me say hello
63:54 - and for adding or concatenating two
63:58 - lists together we have to use the double
64:00 - plus symbol and let me pass the
64:03 - character's value right over here and
64:04 - let us try to evaluate this cell and
64:07 - here we get the new value back as hello
64:09 - octallium just as a reminder for Strings
64:12 - we were using the angle brackets but
64:15 - since this is a list that's why we are
64:17 - using the double plus symbol next we can
64:20 - also use an inbuilt function to check if
64:23 - the given characters are indeed a
64:25 - character list or not so again let me
64:27 - add a code block and here we can use the
64:30 - inbuilt function of this list and let us
64:33 - pass our characters inside of this one
64:35 - and let us try to evaluate so yes we get
64:38 - the answer as true and the last point is
64:41 - we can always check the code point so we
64:43 - can and use a question mark and then we
64:46 - can use a character so the code point
64:48 - value of a would be 97 and if you check
64:52 - for o it would be 79 and so on so this
64:56 - was all about characters the next type
64:59 - that we are going to see is called as
65:01 - the process so let me take everything up
65:04 - and here let us add a block and we want
65:07 - to add a section for process and let us
65:11 - add a code block right over here now if
65:13 - you refer to my earlier videos so this
65:15 - was a video about processes in which I
65:18 - explained that all of the code is
65:20 - executed inside processes so these
65:23 - processes are also a valid type inside
65:25 - Elixir and we can check the current
65:27 - process in which our live book is
65:30 - running so let's create a variable
65:32 - called as my build so the pit stands for
65:35 - the process ID and we can use the
65:38 - inbuilt function of self and let us
65:41 - check the output of my paid after this
65:43 - one and let us see what kind of output
65:45 - we are getting so we get the output as
65:48 - bid is 144. now if you go back to our
65:51 - terminal and here let us check the
65:54 - process in which our IEX is running so
65:56 - let me call the function of self and
65:58 - this time we can see that we have a
66:00 - different bit number the process ID for
66:02 - our IEX is 107 but if we go back to our
66:06 - live book we can see that our live book
66:08 - is running inside the process number
66:11 - 144. now processes and concurrency in
66:14 - Elixir is a very huge topic and it
66:16 - requires its own dedicated tutorials but
66:19 - for this course let us go ahead and let
66:21 - us see the next type let us add a new
66:24 - section right over here so I want to add
66:26 - a new section and this section is all
66:29 - about our list let me take this thing a
66:31 - little up so the number one thing that
66:34 - you need to understand about list is
66:36 - that the list inside Elixir are actually
66:38 - linked list and they are not your
66:41 - regular list so if you try to do
66:43 - operations like in texting it is not
66:45 - going to work and just to be precise the
66:48 - list inside Elixir are actually singly
66:50 - linked list so let us see how we can
66:52 - work with list inside Elixir let us
66:55 - create a new code block right over here
66:56 - and let us create a list so this is our
66:59 - list and for a list we can see that we
67:02 - have the square brackets at the
67:03 - beginning and at the end and let us try
67:06 - to evaluate this cell and we get the
67:09 - list back
67:10 - now again let me try and repeat that
67:12 - this list is not your regular array or
67:15 - not your regular list this is a singly
67:18 - linked list let's do one small
67:20 - experiment and let us try indexing on
67:22 - this list so let us create a new code
67:24 - block and suppose if I try to see the
67:27 - element at the zeroth index now let us
67:30 - see what happens and as you can see we
67:32 - get an error and we get this error
67:35 - because this list is actually a linked
67:37 - list and not your regular list now the
67:40 - reason that we have linked list inside
67:42 - Elixir is because linked lists are
67:45 - recursive in nature your regular arrays
67:48 - or your regular list they are not
67:49 - recursive and they have to be saved
67:52 - continuous in your memory but then how
67:54 - do we work with listens at Elixir now
67:56 - there are a lot of mechanisms first and
67:59 - the obvious one is by using recursive
68:01 - functions or we can also use a lot of
68:03 - inbuilt modules so let me show you one
68:06 - module let me add a code block right
68:08 - over here and let us take everything up
68:11 - now we can use the model of enum and we
68:14 - can say that enum and we can use the
68:16 - inbuilt function add and let's pass our
68:19 - list and let us call the index as 0 and
68:23 - let us see what kind of output we are
68:25 - getting and here we can see that we get
68:27 - the output as a so what we are doing is
68:29 - enum is actually an inbuilt model inside
68:32 - Elixir and at is a function which is
68:35 - defined inside the enum module and here
68:38 - we are simply passing the arguments for
68:41 - the function let us go back to our IEX
68:44 - and let me clear up everything let me
68:47 - make some space from the top and here if
68:49 - I write enum Dot and if I press tab here
68:53 - we can see that we have a lot of inbuilt
68:55 - functions for the enum module and the
68:58 - function that we use is right over here
69:00 - add now this Slash 2 actually means the
69:03 - rity now arity is nothing it's just the
69:06 - number of arguments that your function
69:07 - can accept in Elixir we can actually
69:10 - overload our functions by using
69:12 - different parameters so for example you
69:15 - can see right over here we have a
69:17 - function called as any and for this
69:19 - function we have two types the first
69:21 - type is right over here so this function
69:23 - takes only one argument that's why the
69:25 - arity is one
69:27 - and here we have the same function any
69:30 - but this time it takes two arguments so
69:33 - that's why the arity is shown as two now
69:35 - let me clear up all of these things now
69:38 - let me show you one more helper function
69:40 - inside Elixir and the name of the
69:42 - function is H so H stands for your
69:45 - helper again if you want you can use the
69:47 - parentheses or you can leave them out
69:49 - and here we need to specify which model
69:52 - or which function do we want help for so
69:55 - what does helper function does is it
69:57 - simply prints out the documentation for
70:00 - that module or for that function so here
70:03 - we need to specify that we want to see
70:05 - the documentation for the model of enum
70:07 - and from enum we want to see the
70:09 - documentation of the function of ADD and
70:12 - here we get the documentation back the
70:14 - first line that you can see right over
70:16 - here this is all about your function
70:18 - definition and you can see that the
70:20 - first parameter is actually a
70:22 - innumerable the second one is the index
70:25 - and this function also accepts an
70:28 - optional argument by the name of default
70:30 - and the default value for this parameter
70:32 - is nil these two backslashes symbolize
70:36 - that this argument of default is an
70:39 - optional argument and in case if this
70:41 - argument is not specified then the
70:44 - default value would be simply nil next
70:47 - we can see that we have a couple of
70:49 - examples right over here so you can see
70:51 - that the helper function is very useful
70:53 - and I often use this function for
70:56 - reading the documentation inside my
70:58 - terminal now let us go back to our live
71:01 - book
71:02 - and here let us play a little bit more
71:04 - with pattern matching and with our list
71:06 - so let me create a new code block now if
71:09 - you refer our list so our list has three
71:12 - different elements and we can use
71:14 - pattern matching to extract all of these
71:17 - elements
71:18 - so let me show you how we can do that so
71:20 - here let me create a couple of different
71:22 - variables the first one should be called
71:25 - as first second third you can call this
71:28 - parameters anything that you want and on
71:30 - the right I simply want to pattern match
71:32 - on the list so what's going to happen is
71:35 - the same old thing the left hand side
71:37 - should be equal to the right hand side
71:39 - so the first thing is since this is a
71:42 - list on the left hand side we do have a
71:45 - list and we are simply trying to pattern
71:47 - match on the different elements so this
71:50 - a would be bound to our variable of
71:52 - first for the second your B would be
71:55 - bound and C would be bound to third let
71:59 - us check out the data inside
72:01 - second so let me call second right over
72:03 - here and let me take it up and also let
72:06 - us try to evaluate this cell and we get
72:09 - the value back as B now what happens if
72:12 - you don't want all of the variables and
72:14 - you simply want to ignore a couple of
72:16 - them at that time we can simply use an
72:19 - underscore to ignore the values so
72:22 - suppose I don't want the values of first
72:24 - and second then we can do like this so
72:27 - we can create a list since I want to
72:29 - ignore the first value I can use and
72:31 - underscore I also want to ignore the
72:34 - second value so let me put one more
72:36 - underscore the next I want to collect
72:38 - the third value so let me create a
72:40 - variable called as third and let us
72:43 - assign a list right over here so our
72:45 - list is a b and c now let us check the
72:50 - value inside third and let us try to
72:52 - evaluate and we get the value as C back
72:55 - so what happened is since we have an
72:58 - underscore that's why the value of a is
73:01 - simply ignored the same thing happens
73:03 - with BS as well and finally the value of
73:06 - C gets bound to our variable of third
73:09 - next let me show you a couple of
73:11 - convenience function for working with
73:13 - our list
73:14 - so the first function is also called as
73:16 - head so let me show you what I mean so
73:19 - the head function simply takes the first
73:21 - value and returns it back so if we call
73:24 - the inbuilt function of head and let us
73:27 - pass our list to it and let us try to
73:29 - evaluate and as you can see we get the
73:32 - value of a back now similar to head we
73:35 - also have another function which is
73:37 - called as tail so let me create a new
73:39 - code block and the function is called as
73:42 - tnl now what a tail function is going to
73:44 - do is it is simply going to ignore the
73:47 - head value and it will return back all
73:49 - of the remaining values so let me pass
73:52 - the variable of list to this one and let
73:55 - us try to evaluate the cell and we get
73:57 - back the values of B and C there is also
74:01 - a shortcut method for doing this so let
74:03 - me show you how we can do that and this
74:06 - time we can simply pattern match on our
74:08 - list so here let us create a list and I
74:12 - want to pattern match the first value
74:14 - inside a new variable called as head H
74:17 - for head and then let me use a cons
74:20 - operator and then I can say that I want
74:23 - to collect all of the remaining values
74:24 - in a new variable called as tail and let
74:27 - me assign the value of list to this one
74:30 - next let us check the value inside our
74:32 - head and let us try to evaluate this
74:35 - cell and as expected we get a back now
74:38 - this pipe operator is also known as cons
74:41 - operator for working with our linked
74:43 - list next let us also check the value
74:45 - inside e so let me create a new code
74:47 - block and let me call the variable of
74:49 - key and as you can see we simply get
74:52 - back the remaining values inside our
74:54 - list the next data type is the Tuple and
74:58 - we have already seen a couple of
75:00 - examples of Tuple but let me show you
75:02 - once again
75:04 - so the Tuple is created by using the
75:06 - curly brackets so you can say we want to
75:08 - create a two element Tuple and we can
75:12 - say that the values should be 1 and 2.
75:15 - so this curly brackets are used for
75:18 - creating an apple not tuples are very
75:21 - similar to your arrays and all of the
75:24 - data inside the Tuple is saved
75:26 - continuously inside the memory and it's
75:29 - very common to have two or three element
75:31 - kind of a double but if you want to save
75:34 - a large number of elements then it is
75:36 - recommended to go with the list now here
75:39 - also we can do a simple pattern match so
75:42 - on the left let's create one more Tuple
75:45 - we can say A and B and let us check the
75:48 - value of a and let us try to evaluate
75:50 - and we get the value back as 1 in this
75:54 - time let us create a three element Apple
75:56 - so in the future whenever you are
75:58 - learning about web development using
76:01 - Phoenix that time you will see that it's
76:03 - very common to have three elements or
76:05 - maximum four elementable and a very
76:08 - common pattern would be something like
76:10 - this so the first element would be a
76:12 - couple called as message the second
76:15 - element would be the actual message that
76:17 - you want to send back and the third
76:20 - element would normally be the state of
76:22 - your server and let us create a tuple on
76:25 - the right so the first element should be
76:27 - reply message could be a string or
76:30 - Italian phone and for the state we can
76:33 - pass a simple list of all of the friends
76:35 - of octallium so we can say octallium
76:38 - Lewis and Chico next let us try and
76:42 - print out the message and let us try to
76:44 - evaluate let's also check the state of
76:48 - our server so we can say State and let
76:51 - us try to re-evaluate and we get the
76:54 - right list back so as you can see tuples
76:57 - are very convenient data structure
76:59 - inside Elixir but normally don't use
77:02 - more than three or four element inside a
77:04 - tuple the next data type that we are
77:07 - going to see is also called as the
77:10 - keyword list so let me show you how a
77:13 - keyword list looks inside elixir
77:15 - so we can create a variable called as
77:18 - data now keyword list is actually a list
77:21 - but inside the list we have the key and
77:24 - the value pairs so we can say that a is
77:28 - 1 so a is a key one is a value and you
77:32 - can say B and 2 and let us try to
77:35 - evaluate and we get back our keyword
77:38 - list now what happens inside the keyword
77:40 - list is your key would normally be an
77:44 - atom but if you remember we write the
77:47 - item as colon first and then the name of
77:50 - the item and in fact this key value pair
77:53 - is actually saved as a tuple so let me
77:56 - show you how it is saved as a couple so
77:59 - here let me create a list and inside the
78:02 - first element that is the key is always
78:05 - saved as an atom so I can say a and the
78:09 - second element is the value so it would
78:11 - be 1 and let us try and pattern match on
78:15 - a very simple keyword list so we can say
78:18 - a and one so as you can see over here a
78:21 - and colon this is just a convenience
78:23 - feature but while saving inside the
78:26 - keyword list it is actually saved as an
78:28 - atom and this key value pair is
78:31 - converted into a tuple which we can see
78:34 - right over here now let us try to
78:36 - evaluate and we get the same answer back
78:39 - that means we have a match between the
78:41 - right hand side and the left hand side
78:43 - for accessing the different values
78:46 - inside the keyword list we can use the
78:48 - inbuilt module so let us go back to our
78:51 - terminal and let me write keyword Dot
78:55 - and let me press a tab and as you can
78:58 - see we have a lot of convenience
79:00 - features for working with our keywords
79:02 - let's go back to the live book and let
79:05 - me show you how to fetch the values from
79:07 - a given key so for example I can say
79:10 - that I want to access my keyword list of
79:12 - data and then I want to access the key
79:15 - of a and let us try to evaluate and we
79:19 - get back the data as one well that's it
79:22 - for this one and we'll learn more about
79:24 - maps and struck right in the next one
79:27 - the next data structure that we are
79:29 - going to study is called as a map
79:32 - so let me create a variable called as my
79:35 - map now in the last video we saw how to
79:38 - create a tuple and for creating a tuple
79:41 - we normally use the curly brackets and
79:43 - for creating a map we simply add a
79:46 - person symbol so maps are more like your
79:49 - dictionaries in your python these maps
79:52 - are also your key and value kind of a
79:55 - data structure but Maps offer a lot of
79:58 - features as compared to your Tuple or
80:01 - your keyword list inside Maps we can use
80:04 - different data types for our keys but
80:07 - right now let us see how we can use an
80:09 - atom for our key so we can simply say a
80:13 - colon and one then let us add one more
80:16 - element B and let us add one more C and
80:21 - three so this is how you can create a
80:23 - map and what happens is when you use a
80:27 - tuple for your key at that time you can
80:30 - use the dot notation I will show you
80:32 - shortly what I mean by the dot notation
80:34 - but right now let us see how the map
80:37 - looks like
80:38 - and we get the map back next we can use
80:41 - our pattern matching to extract values
80:44 - so here let me create a map and inside
80:46 - the map we can pattern match on the key
80:50 - of A and let us collect the value inside
80:52 - a variable cordless first next we can
80:56 - pattern match with b and let us collect
80:58 - the value inside second and for the last
81:01 - one we can use the variable of third
81:04 - and let us pattern match with the
81:06 - variable of my map
81:08 - and let us see the value inside the
81:11 - variable of first and let us try to
81:13 - evaluate and we get the right answer
81:16 - back will maps are very convenient data
81:19 - structure suppose if you want to extract
81:21 - only the second value you don't have to
81:24 - use the entire map instead we can do
81:27 - something like this
81:28 - so let me just show you let us create a
81:31 - map and let us say that we simply want
81:33 - to pattern match on the key of B and let
81:37 - us collect the value inside second
81:40 - and latest pattern match with our map of
81:43 - my map and let us see the value inside
81:46 - second and as you can see we get the
81:49 - right answer back so it's not mandatory
81:51 - to create the entire map to pattern
81:54 - match instead we can create a shorter
81:56 - map with just the required elements so
81:59 - here we are simply pattern matching on
82:01 - the key of B and we are collecting the
82:04 - value inside the variable of second the
82:07 - next thing is since we are using atoms
82:09 - for our keys we can use our DOT notation
82:12 - to access the values so let us create a
82:15 - code block and we can save my map dot a
82:18 - and it will try to evaluate and we get
82:20 - the answer back but if we have a
82:23 - different data type for example if we
82:25 - have a string for the key values then
82:28 - you can't use the dot notation
82:30 - let us create one more map and let me
82:33 - call it as map 2 and let us create a map
82:37 - right over here now if you plan to use a
82:40 - string as your key then we need to write
82:43 - them inside quotes because they are
82:45 - strings and since we are using a data
82:47 - type which is not an item for the key we
82:50 - need to use the arrow notation and here
82:52 - we can assign the value as 1 next let us
82:55 - create one more key for B again remember
82:58 - since the key is not an atom we are
83:01 - using the arrow brackets here we can
83:03 - assign the value of 2 and we can create
83:06 - the last one C and let us assign the
83:09 - value of 3 and let us evaluate the cell
83:12 - and we get our map back next we can use
83:16 - the same pattern matching techniques so
83:18 - for example if you want to extract the
83:21 - value of C then let us create a map and
83:24 - since this time the keys are strings let
83:27 - us pattern match right over here and
83:29 - let's say that we want to collect the
83:31 - value inside a variable called as C and
83:34 - let us pattern match with our map number
83:36 - two and let us see the value inside the
83:39 - variable of c and we get the right value
83:42 - back Elixir provides a lot of inbuilt
83:45 - features for working with our Maps so if
83:47 - we go back to our terminal and if I
83:50 - enter map and Dot the tab we can see
83:53 - that we have a lot of different features
83:55 - for example if you want to fetch
83:58 - something or if you want to create a new
84:00 - map or if you want to replace some
84:02 - values or if you want to update some
84:04 - values so we can do a lot of things with
84:07 - the map
84:08 - but for now let me show you a very easy
84:10 - method of updating up a map so let us
84:13 - create a new code block and suppose we
84:17 - want to update the value of C from 3 to
84:20 - 4 then we can say that we want to update
84:23 - the value of our map and the variable
84:26 - name is map 2 and then we can use the
84:29 - pipe operator and then we can say that
84:31 - we want to update the value of C from 3
84:35 - to 4 and let us bind the value of this
84:39 - back to our variable of map of 2 and let
84:43 - us try to evaluate and see what kind of
84:45 - output we are getting and as you can see
84:48 - we have updated the value of C now we
84:51 - are using this arrow notation because we
84:53 - have strings for our key values but in
84:57 - case if we have atoms then we can simply
84:59 - use the colons so let me show you
85:02 - so we have another map by the name of my
85:05 - map and then we can say that we want to
85:08 - update my map and this time we want to
85:11 - update the value of c and since C is
85:14 - just an atom we can use the regular
85:16 - notation and we can say that we want to
85:18 - update the value to 4 let us try to
85:21 - evaluate and we get the updated value
85:24 - back well that's it for this video this
85:27 - was a very short introduction to Max and
85:30 - we will learn much more how to work with
85:32 - maps as we progress in the tutorials the
85:34 - next video is all about struts in Elixir
85:37 - the next data type is the struct and if
85:41 - you come from a compiled programming
85:43 - language such as C or go you must have
85:45 - worked with structs and now let us see
85:48 - how we can create a structure inside
85:50 - Elixir now for creating a structure we
85:53 - need to create modules because by
85:55 - default the structure will take the name
85:57 - of the module suppose we want to define
86:00 - a structure for the user then we can
86:03 - create a module so we can say create
86:06 - module user and then inside the module
86:09 - we can use another macro and the name of
86:13 - the macro is called as depth struct now
86:16 - all of these things that you can see
86:18 - over your def module Dev structure these
86:21 - are all macros that means they create a
86:24 - code from a given code but right now we
86:27 - don't have to learn more about macros
86:29 - let us see how we can define a struct so
86:32 - what we have defined is we have created
86:33 - a model called as user and then we are
86:36 - using another macro called as Dev struct
86:40 - now here we need to specify the
86:42 - different fields for our struct and
86:45 - these fields have to be specified in the
86:47 - format of your key and value pairs now
86:50 - here again we can use the bracket
86:52 - notation if you want or if you don't
86:53 - want you can leave it out and here let
86:56 - us see how we can specify the fields so
86:58 - we can say that the first field should
87:01 - be username the second one should be an
87:05 - email now this is one way of specifying
87:07 - your Fields but if you want to
87:09 - initialize with some values at that time
87:12 - we can also pass the key and value pairs
87:15 - so for example if you want to say that
87:17 - while initializing we want the age to be
87:20 - nil and for the email we can say that we
87:24 - want to have a blank string and for the
87:27 - username also we can say that while
87:29 - initializing we simply want to have a
87:32 - blank string so what we have done is we
87:34 - have simply converted from a list of
87:37 - atoms to a list of key value Pairs and
87:40 - all of these parameters are going to
87:42 - become the fields for the user struct
87:45 - next let us see how we can create and
87:48 - initialize a struct so let me add a code
87:51 - block now working with struct is very
87:53 - similar to working with a map for
87:55 - creating a map we used to use our person
87:58 - symbol and the brackets and for the
88:01 - struct is very similar just that we have
88:03 - to use the name of the strap so this is
88:06 - how we Define a struct inside let us
88:08 - specify the different fields so we can
88:10 - say the value for the username would be
88:13 - octallium suppose my age is 14 years and
88:18 - my email can be Autobot at the
88:21 - redsample.com and let us try and
88:23 - evaluate
88:24 - so what we have done is we have
88:26 - essentially created a struct and this is
88:28 - how we can initialize a struct structs
88:31 - behave very similar to our maps and we
88:34 - can use the same pattern matching
88:36 - techniques on our struct as well so for
88:39 - example let us assign this one to a
88:41 - variable called as user1 and let us
88:45 - evaluate
88:46 - next let us create one more code block
88:49 - and suppose we want to extract the
88:51 - username then we can simply create your
88:54 - regular map and here we can say that the
88:57 - field name would be username and let us
89:00 - create a variable name and let us
89:03 - pattern match on the variable of user
89:06 - one next let us see the value inside
89:08 - username and let us try to evaluate the
89:12 - block and as you can see we are getting
89:14 - the right answer back so what we did was
89:16 - this user one this is a struct but
89:18 - structs behave very similar to maps and
89:21 - that's why we can use our map notation
89:23 - for pattern matching we can use the same
89:26 - technique for updating values inside a
89:29 - struct as well so for example if you
89:31 - want to update the age so you can say
89:34 - that the map of my user one and inside
89:37 - this I want to update the age to suppose
89:41 - 21 and let us rebind the value this back
89:44 - to user 1 and and let us try and
89:48 - evaluate and as we can see we get the
89:51 - updated age back well that's it for this
89:54 - one so what we have done is till now we
89:56 - just had a very short introduction to
89:58 - the different data types in Elixir but
90:01 - if you're not feeling confident don't
90:03 - worry as we progress and as you have
90:05 - more practice you will start feeling
90:07 - much more confident
90:09 - till now we have seen a couple of
90:11 - different data types inside Elixir now
90:15 - if you're not feeling confident don't
90:16 - worry we will have more practice as we
90:19 - progress with the tutorials but right
90:21 - now let us go with the flow I simply
90:24 - wanted to introduce you a couple of
90:26 - topics before we can dive much deeper
90:29 - into them
90:30 - the next topic is all about your flow
90:33 - control inside Elixir for creating Loops
90:36 - we would normally use recursion but
90:39 - other than the recursion we have a
90:41 - couple of different mechanisms for our
90:43 - flow control so let's have a look at the
90:46 - first flow control mechanism called as a
90:49 - case
90:50 - let us create a simple list so you can
90:53 - say that the list is going to be one two
90:56 - and three now what we can do is we can
90:59 - create a case statement so this case
91:02 - statement acts more like your switch
91:05 - statement so let me create a statement
91:07 - and then I can show you how it works
91:10 - so here we can say that we want to
91:12 - create a case and let me put the end
91:16 - block
91:17 - now here we can say that we simply want
91:20 - to fetch the second element from our
91:23 - list so remember the second element from
91:26 - our list would be 3 so this is at index
91:29 - number 0 1 and 2 so we can say that we
91:34 - want to fetch from the list the second
91:37 - element and after that depending on the
91:41 - result of this statement we can pattern
91:43 - match on a couple of different cases so
91:46 - let us create the first case inside of
91:49 - this one so here we can say that in case
91:52 - this statement evaluates to a one at
91:56 - that time we simply want to return back
91:58 - a string and string would be this one
92:01 - print
92:01 - next we can also create multiple cases
92:04 - so in case we get the answer is 3 back
92:08 - at that time we simply want to return 3
92:11 - is a match and the next one is a casual
92:13 - case and for that we can say that we
92:16 - want to use an underscore that means we
92:18 - are not interested in the value but in
92:21 - case we don't have a match for the
92:23 - return of this statement at that time we
92:26 - simply want to return a string called as
92:28 - catch all
92:30 - now let us try and evaluate this one and
92:33 - as you can see we get the answer as 3 is
92:36 - a match so let us try and reiterate what
92:39 - happened so we have created a key
92:41 - statement and we simply want to pattern
92:43 - match on the result of this expression
92:46 - right over here so this statement
92:48 - evaluates to a 3 and since we get a
92:52 - match that's why we get the written as 3
92:55 - is a match
92:56 - we can use this case statement to
92:58 - pattern match on almost anything so for
93:02 - example suppose we have a structure so
93:05 - let us create a module so we can say we
93:08 - want to create a model for post and
93:11 - inside this let us create a structure
93:13 - and let us create the different fields
93:16 - suppose we want to have a field for the
93:18 - ID and we want to initialize to nil and
93:22 - then we want one more field for the
93:24 - title let us initialize to a blank
93:26 - string the next one could be for the
93:29 - description and we can again assign it
93:31 - to a blank string the last one could be
93:34 - for an author again let us assign a
93:37 - blank string so we have created a struct
93:41 - next let us create a post so we can say
93:44 - that
93:45 - we want to create a post one and we want
93:50 - to have a post suppose the ID is one the
93:55 - title could be title number one the next
93:59 - we want the author suppose the author is
94:01 - Julius Caesar
94:04 - and let us try and evaluate the cell and
94:08 - as you must have noticed we are not
94:09 - giving the description inside this
94:11 - struct but while defining we have
94:14 - defined that in case we don't have the
94:17 - value of description at that time we
94:19 - simply want to initialize it to be a
94:21 - blank string and that's why we are
94:23 - getting a blank string right over here
94:26 - next we can use the case statement for
94:28 - our post and suppose we want to pattern
94:31 - match on the author so we can say that
94:34 - we want to have a case statement and we
94:37 - want to Pat and match for our post
94:39 - number one and here let us Define a
94:42 - couple of different scenarios now
94:44 - remember that since this is a struct we
94:46 - can also use the map notation for our
94:49 - pattern matching so here we can say that
94:52 - suppose we have an author and in case
94:55 - the author name is octallium then we
94:58 - simply want to return a string got a
95:01 - post from octallium let me copy and
95:04 - paste suppose the author name is anilo
95:07 - so we can say got post from Anil
95:11 - Kulkarni next we can also create a
95:15 - catch-all blog so we can use the
95:17 - underscore and this time we can create a
95:20 - string and we can see what a post from
95:23 - and we can use the string interpolation
95:26 - so we can say post one dot author and
95:30 - let us try and evaluate so this time we
95:33 - get the answer as got a post from Julius
95:36 - Caesar not just as a small reminder we
95:39 - can easily update the struct as you
95:41 - would update a map so in case we want to
95:43 - update the author field from Julius
95:46 - Caesar to my name so we can say that we
95:49 - want to update the author to become Anil
95:52 - Kulkarni and let us try to evaluate and
95:55 - this time we have the new author Anil
95:58 - Kulkarni now let me create a new code
96:00 - block and let me just copy and paste the
96:04 - key statement right over here and let us
96:07 - try to evaluate oh so this time we are
96:10 - still getting the answer as Julius
96:12 - Caesar and that's because we are not
96:14 - rebinding over here so we can say we
96:17 - want to rebind the variable of post
96:19 - number one to the updated value so let
96:23 - me re-evaluate and this also let us try
96:26 - to reevaluate and this time we get the
96:29 - right answer back similar to the case
96:31 - statement we have another flow control
96:33 - mechanism by the name of condition so
96:36 - let me create a new code block over here
96:38 - and this is going to be for the
96:40 - condition and here we can define a
96:43 - couple of different conditions to
96:45 - pattern match on now the condition
96:46 - statement does not take an expression
96:49 - right over here instead we can pattern
96:51 - match for the different conditions right
96:53 - over here so suppose the first condition
96:55 - that we want to match would be for the
96:59 - Post author and suppose if you want to
97:01 - say that in case the author is octallium
97:04 - at that time we simply want to return a
97:07 - string back saying that editing a post
97:09 - from octallium let me copy and paste
97:12 - this one and this time let us check for
97:15 - the condition of Anil hulkarni and this
97:18 - also becomes only full currently next
97:21 - let us also Define the catch all block
97:23 - for the condition now for defining the
97:26 - catch or block we simply pattern match
97:28 - on the true condition and we can say
97:31 - that in case we have a true condition
97:33 - then we simply want to return a string
97:36 - saying that this is a catch all now let
97:39 - us try to evaluate this cell and we get
97:42 - back the answer as editing a post from
97:45 - Anil equal kerning let us have a look at
97:48 - one more condition block so let me
97:50 - create a new block right over here we
97:53 - can also use this condition statement
97:55 - for more advanced pattern matching so
97:58 - example we have a list right over here
98:01 - and
98:03 - and suppose we want to pattern match on
98:06 - the first element so at that time what
98:08 - we can do is we can simply use the head
98:10 - function so we can say that we want to
98:13 - extract the head from our list and in
98:17 - case the head is 1 at that time we want
98:20 - to return a message saying that got a 1
98:23 - and let us Define the catch-all block so
98:27 - this time we can use a string
98:28 - interpolation and we can say add is and
98:32 - then we can put the head right over here
98:35 - so let us invoke the function of head on
98:38 - the list and let us try to evaluate this
98:40 - block and we get the answer as got a 1.
98:44 - so as you can see we can use all of the
98:46 - different pattern matching techniques
98:48 - for condition as well as case the last
98:51 - flow control mechanism is the if and
98:54 - else block but normally you will not
98:56 - have to work with the if and else block
98:59 - we would use recursion or pattern
99:01 - matching instead of using IF channels
99:04 - but let me show you how we can use the
99:06 - if and else blog if required so let me
99:09 - create a new section this section is for
99:12 - the if and else and let us create a new
99:15 - code block so the if and else condition
99:17 - is pretty much the same so we can say if
99:20 - true then we want to print out this will
99:24 - work else we want to print out else this
99:27 - will work and let us try to evaluate the
99:30 - cell and we get the answer as this will
99:32 - work well that's it for all of the
99:34 - different types of flow control
99:36 - mechanisms inside Elixir well till now
99:39 - we had a very short introduction to the
99:41 - different data types and flow control
99:43 - mechanisms inside Elixir from the next
99:46 - video we will start working with a mix
99:48 - project and at that time we will learn
99:51 - all of these Concepts in much more
99:53 - details I think by now we have learned
99:56 - enough to start with the basic concepts
99:58 - of functional programming so let us go
100:01 - ahead and let us start a new project now
100:04 - Alexa ships with a tool called as mix
100:07 - which stands for mixing Elixir so this
100:10 - mix is like your project management tool
100:13 - so let us see how we can use this to
100:15 - create our first project so let me go
100:18 - back to my terminal and I want to go
100:21 - inside my folder functional programming
100:23 - with Elixir so right now I have created
100:26 - only one folder which was for our
100:28 - Scripts now let me create a new folder
100:31 - and let me name it as code let me go
100:35 - inside code
100:36 - here we can create a new project by
100:39 - saying mix new and let me name the
100:42 - project as tutorials
100:45 - and that's it we have a new Elixir
100:48 - project let me go inside the folder of
100:51 - tutorials and let me open it up in my
100:54 - code editor
100:55 - so as you can see Elixir by default
100:58 - creates a bunch of different folders and
101:00 - files for us so inside the lib directory
101:03 - we can see that we have a model for the
101:06 - tutorials let me zoom in for you the
101:09 - first main topic that we are going to
101:11 - learn in our journey of functional
101:13 - programming is all about recursion and
101:16 - that's what we are going to start right
101:18 - in the next video
101:20 - now let's start with the most
101:21 - fundamental blocks of functional
101:23 - programming and that is recursion now
101:27 - don't worry if you have never worked
101:29 - with recursion or if you find recursion
101:31 - very confusing I will show you recursion
101:33 - step by step and line by line I will
101:36 - also include a lot of diagrams and small
101:38 - animations to help you understand how
101:40 - recursion works but for now let us get
101:43 - started
101:44 - so this is the mix project that we
101:46 - created in the last video now I don't
101:49 - need all of this code let me just take
101:51 - it out
101:52 - let me just save it now let's write a
101:55 - very simple recursive program to print
101:58 - the number of digits so suppose you have
102:00 - a function called as up to and if you
102:02 - pass 3 to it then we should print 0 to
102:05 - 3. so it's a very simple program but we
102:07 - will Implement a program recursively so
102:10 - inside the lib directory I want you to
102:12 - create a new folder by the name of
102:14 - recursion and inside this folder let us
102:17 - create a file and let us call it as
102:19 - print digits dot ex now this time please
102:24 - remember that the extension is dot ex
102:26 - because we want to compile this file and
102:30 - if you go to test here we can see that
102:32 - we have dot EXs so this are script files
102:36 - and they are not meant for your
102:37 - production code now let me get back to
102:39 - the print digits and let me collapse my
102:42 - sidebar now remember that all of the
102:44 - code inside Elixir stays inside its
102:47 - modules so the first thing is we need to
102:50 - define a model for this file so let's
102:52 - create a model by typing depth module
102:55 - and this is the name recursion dot print
102:58 - digits but the naming convention goes
103:01 - like this first we normally include the
103:04 - name of our project so we have to name
103:06 - our project as tutorials and let me open
103:08 - up my sidebar so inside our project of
103:11 - tutorials we have created a folder
103:13 - called as recursion and inside that
103:15 - recursion we have created a file called
103:18 - as print digits now remember that this
103:21 - is just a community convention and it is
103:23 - not required you can name this model
103:25 - anything that you want now with that in
103:27 - mind let me collapse my sidebar now
103:30 - inside of this module let us create a
103:32 - function called as up to so we can
103:35 - define a function by using the keyword
103:37 - of Def and then we can say up to now
103:40 - this function is going to accept one
103:42 - parameter and that would be for our
103:44 - numbers and then we can start with the
103:47 - do and end blocks now suppose the number
103:49 - is 3 then we simply want to print out
103:52 - something thing like this so we take the
103:54 - input as 3 and then we want to print
103:57 - digits from 0 to 3 so this is what we
104:00 - want to print but we need to do this
104:02 - thing recursively you must be thinking
104:05 - maybe we can just create a for Loop so
104:07 - we can create a for Loop for I is equal
104:10 - to 0 then we can say I less than a and
104:14 - equal to your number and then I plus
104:17 - plus and then we can simply print out I
104:20 - so if you're thinking we can do
104:22 - something like this then the answer is
104:24 - no because all of the data types inside
104:27 - Elixir are constants they are immutable
104:30 - and what's happening inside the for Loop
104:32 - is for each iteration we are changing
104:35 - the value of I which is right over here
104:38 - so we can't use this kind of for Loops
104:40 - inside Elixir then what can we use so
104:43 - the answer is by using recursion
104:46 - so let me take out the comments first
104:48 - let me write the code and then I will
104:50 - explain what's happening now let's think
104:52 - of a base case suppose the number itself
104:55 - is 0 then at that time we don't have to
104:59 - do anything so at that time we simply
105:01 - have to return back zero so we just
105:04 - write 0 over here now remember that the
105:07 - last line inside of function
105:08 - automatically returns so this is your
105:11 - automatic return statement and we don't
105:13 - have to use the keyword of return for
105:15 - the last line now remember that Elixir
105:18 - is a functional programming language so
105:20 - essentially we have to return some kind
105:23 - of a value for each function and in case
105:25 - the function is creating some kind of a
105:27 - side effect at that time by default an
105:30 - item of ok is returned but for now let
105:33 - us continue with this program and let me
105:35 - write the next base case so what we can
105:38 - do in Elixir is we can actually create
105:40 - multiple copies of the same function
105:43 - this is also called as function
105:45 - overloading and we can do this because
105:48 - Elixir supports pattern matching so what
105:51 - we did right over here is we created a
105:53 - function called as up to and we are
105:55 - pattern matching on zero so in case if
105:58 - the number is 0 then we simply want to
106:00 - return 0 and that's it now we can create
106:03 - one more copy of the same function so we
106:05 - can say Define up to this again accepts
106:09 - a parameter called as numbers and let's
106:12 - see what we can do this time so this
106:14 - time what we want to do is we simply
106:16 - want to print out so we can print out by
106:18 - using i o dot puts so let us print out
106:21 - the number but what we want to do is for
106:23 - each iteration we want to reduce the
106:26 - number by one so for example if the
106:29 - number was 3 then after we print out 3
106:32 - for the next iteration your number
106:34 - should become 2 then your number should
106:36 - become 1 and then your number should
106:38 - become zero and when your number becomes
106:41 - 0 at that time we go to this line number
106:44 - three where we simply return 0 back so
106:46 - the the next question is how can we
106:48 - reduce the value of number by 1 each
106:51 - time the answer is by using a recursive
106:54 - call to the same function so for each
106:56 - iteration we can call ourselves back but
106:59 - each time what we can do is we can say
107:01 - numbers minus of one so what we are
107:05 - doing is suppose this number is 3 so the
107:07 - next time when we call the same function
107:09 - we are passing 3 minus 1 that means we
107:13 - are passing 2 now don't worry if you
107:15 - find this logic a little bit confusing
107:17 - we will see how to trace this function
107:20 - and how we can create recursive trees so
107:23 - I will use a small diagram and small
107:25 - animation for it but first let us run
107:27 - this file and let us see if it is
107:29 - working or not so let me save the file
107:31 - and let me open up my terminal now till
107:34 - now we have been working with IEX but
107:37 - this time we have created a project by
107:40 - using our mix tool but fortunately we
107:42 - can use IEX along with our mix project
107:45 - as well so here we can you can see that
107:47 - hey IX I want you to start mix so we
107:50 - just use the flag of hyphen and S
107:52 - followed by the mix command
107:55 - so what happens in the background is IEX
107:57 - simply compiles your project and all of
108:00 - the modules are available to you inside
108:02 - our IEX so let me clear up everything
108:05 - and let us call this function of up to
108:08 - but remember that this function stays in
108:11 - this module so what we can do is we can
108:13 - say from the model of tutorials I want
108:17 - you to go to the model of recursion from
108:20 - Recreation I want you to go to the model
108:21 - of print digits and from here I want to
108:24 - use the function of up to and let us
108:27 - pass 3 right over here and let us see
108:29 - the output we are getting so here it is
108:31 - we are getting the output of 3 2 and 1
108:34 - so this 0 is not printing if you want we
108:37 - can print 0 right here at line number
108:40 - four so if you want we can replace this
108:42 - line by again io.puts and 0 but I think
108:46 - there is no point in printing 0 so we
108:48 - can take this one out or else we can
108:51 - also say that whenever we get a 0 we
108:53 - simply want to stop and we can return
108:55 - back an atom called as okay which
108:58 - symbolizes that our operation was
109:00 - successful now let me save the file now
109:03 - since we have saved the file we also
109:05 - need to recompile our project now here
109:08 - we have two choices either we can
109:10 - recompile the entire project or we can
109:13 - decompile just the model that we have
109:16 - changed but each time typing such a huge
109:19 - model name is a big pain in the ass so
109:22 - what we can do is we can create a small
109:24 - Alias so we can say that I want to
109:26 - create an alias for tutorials dot
109:29 - recursion dot print digits let me clear
109:32 - up the screen and now we can say that I
109:35 - simply want to recompile my model of
109:38 - print digits and here it is we have
109:40 - recompiled that module now let me clear
109:43 - it up one more time and this time again
109:47 - we can use the model of print digits and
109:50 - we can invoke the function of up to now
109:53 - again if you want you can use the
109:54 - parentheses or or you can leave them out
109:56 - so let me just pass three right over
109:58 - here and this time we get the output of
110:00 - 3 2 1 and okay so let us go back to our
110:03 - code editor and let us see what's
110:05 - happening so what's happening right over
110:07 - here is this is also called as your base
110:11 - case so let me put a comment right over
110:13 - here so this you can call this is your
110:15 - base case so that means that in case if
110:18 - we get an input which is 0 at that
110:21 - moment we simply want to return some
110:24 - kind of a value and we want to exit from
110:26 - our recursive function now since this
110:29 - function returns a single value we can
110:32 - use a much shorter syntax so let me take
110:34 - out and let me take out the written
110:37 - statement and after the function
110:39 - definition I have to put a comma after
110:42 - do I have to put a colon and let me take
110:45 - out the OK from here and let me paste it
110:48 - right over here and that's it so this is
110:51 - also a valid function definition so
110:53 - normally whenever we written a single
110:54 - value that time we use a single line
110:57 - definition now instead of returning okay
110:59 - let me go back to returning zero so
111:02 - what's happening is we have a base case
111:04 - whenever we are getting the input of 0
111:06 - at that time we are simply returning 0
111:09 - but we are not printing anything and in
111:12 - all other cases we are first printing
111:14 - that number and then we have a recursive
111:17 - call now let's see how we can trace this
111:20 - function so let me open up my browser
111:23 - and uh so this is our function for print
111:27 - digits so this print up to 0 and do 0
111:30 - this is our base case and this is our
111:33 - recursive function so this line number
111:35 - four is a place where actual printing is
111:38 - taking place and on line number five we
111:41 - have a recursive call to the same
111:43 - function now let's see how we can trace
111:46 - this function just imagine that the
111:48 - first argument we are passing to this
111:50 - function is 3 so for each iteration
111:53 - what's going to happen so Elixir is
111:55 - going to compare from top to the bottom
111:57 - is 3 and 0 equal no they are not so
112:01 - Elixir will jump to this function
112:03 - definition so let's see what's going to
112:05 - happen for this function definition the
112:07 - first thing is we are simply telling
112:09 - Elixir to print out the value of number
112:11 - so that's what is going to happen so the
112:14 - first call is to print and we get three
112:16 - back now what happens next so next is a
112:19 - recursive call to the same function but
112:21 - with the value of number minus 1 so
112:24 - let's see what's going to happen so next
112:26 - is we are calling the same function back
112:28 - but the value becomes 2 now is 2 equal
112:31 - to 0 no it's not equal to zero so again
112:34 - Elixir will jump to this function
112:36 - definition and again what happens the
112:39 - first line is we simply want to print
112:40 - out the number so we get the output of 2
112:43 - and what happens on the next line we are
112:46 - calling ourself back but this time again
112:49 - number minus 1 so the next call becomes
112:52 - up to and your argument becomes 1. again
112:55 - the same thing happens is 1 equal to 0
112:57 - no it's not so again Elixir will jump to
113:01 - this function definition the first line
113:03 - is to print the value so we get the
113:05 - value of 1 back now what happens over
113:08 - here again we have to call ourselves
113:10 - back so again we call the same function
113:13 - but this time the argument becomes 0
113:15 - remember 1 minus 0 that's why we get the
113:19 - argument here as 0. now again Elixir
113:23 - jumps to first Clause now remember
113:25 - Elixir scans your code from top to the
113:28 - bottom and the first definition is up to
113:31 - with a pattern match of zero and this
113:34 - time what's happening is we have a match
113:36 - since up 2 gets a parameter of 0 we
113:39 - simply want to return 0 back so what's
113:42 - going to happen over here
113:44 - so for this function we are simply going
113:46 - to return 0 back and that's it do we
113:49 - have any other calls left no so we
113:52 - simply exit and that's it we have the
113:54 - display of 3 to 1 in our console so let
113:57 - me open up my terminal one more time and
113:59 - here it is we have the exact same output
114:02 - of 3 2 and 1.
114:04 - so what we did right over here is we saw
114:07 - how we can trace our recursive program
114:09 - so always remember to plot this kind of
114:12 - trees and this will help you to
114:14 - understand recursive programming in a
114:16 - much better way now let us go back to
114:18 - the code
114:19 - and this time let me make a very small
114:21 - change now instead of printing the
114:24 - number first what happens if I print the
114:27 - number afterwards now let's see what
114:29 - happens this time let me open up my
114:31 - terminal one more time and let us
114:34 - recompile our model since we changed the
114:36 - code and let me clear it up and then let
114:40 - me again call the print digits up to and
114:43 - let us pass three so this time what
114:45 - happened so instead of getting the
114:47 - output of 3 2 and 1 we have the output
114:51 - of 1 2 and 3 so what happened we simply
114:54 - change one line right over here and our
114:57 - entire output got reversed so let us go
115:00 - back and try to trace this circus
115:02 - program as well
115:04 - so this was the earlier one and this is
115:07 - going to be the new one so remember we
115:10 - have the print statement afterwards but
115:13 - first we are calling the function
115:15 - recursively so let's see what's going to
115:17 - happen this time so again suppose that
115:20 - we are passing the argument of 3 so what
115:22 - happens is 3 equal to 0 No 3 is not
115:25 - equal to 0 then Elixir will jump to this
115:28 - function definition now what's happening
115:30 - in this definition first we are calling
115:33 - ourselves so what's going to happen we
115:35 - have a recursive call and the parameter
115:38 - becomes 3 minus 1 that means we have a
115:41 - parameter called as 2 but what happens
115:43 - to this call at line number five nothing
115:47 - that statement remains unexecuted
115:49 - because first we have to exhaust this
115:53 - function right over here so what's going
115:54 - to happen next time so let us see right
115:56 - over here so this call right over here
115:58 - this does not execute instead first we
116:01 - have to exhaust all of the parameters
116:03 - for this function now what's happening
116:06 - the parameter is 2 is 2 equal to 0 no
116:09 - it's not so we are going to go in this
116:12 - function definition so what's happening
116:13 - this time we again have a recursive call
116:17 - so let us call ourselves back but this
116:19 - time the argument becomes one and what
116:22 - happens to the print statement nothing
116:24 - that is kept on hold right over here now
116:27 - let us go back to this function right
116:29 - over here is 1 equal to 0 no so we go to
116:32 - this function again what happens we have
116:35 - to call ourselves back so let us call
116:38 - ourselves back but this time the
116:40 - argument becomes 0 and what happens to
116:43 - the print statement again that is kept
116:45 - pending now what's going to happen this
116:47 - time we are calling ourselves but the
116:50 - argument is zero so we have a pattern
116:53 - match right over here and whenever the
116:56 - argument is 0 we simply give back 0 and
117:00 - that's what happened right over here so
117:01 - this call right over here this resulted
117:04 - in a zero now the control will go back
117:07 - to the previous function now what is
117:10 - spending in the previous function this
117:12 - print statement is pending but what is
117:15 - the value of number so the value of
117:16 - number 1 that's why we get the output of
117:20 - 1 first now again we have exhausted this
117:23 - Clause the control will go back to this
117:25 - one again what's pending the print
117:28 - statement is pending but what is the
117:30 - value of Number the value of numbers 2
117:33 - that's why we get the output as 2. now
117:36 - again this function is exhausted so the
117:39 - control goes back to this function right
117:41 - over here again what's pending the print
117:44 - statement is pending but what is the
117:46 - value of number it's 3 that's why we get
117:48 - the value of 3 back and this is exactly
117:51 - happening right over here so we get the
117:53 - value of 1 2 and 3 so what's happening
117:57 - over here is we can say that our print
117:59 - statement is executing in the return
118:02 - stage but in the earlier example our
118:05 - print statement was executing in the
118:07 - ascending stage so we have a basic
118:10 - difference in the execution of our
118:13 - recursive functions let us try and
118:15 - summarize what we have learned till now
118:17 - so what we have done is we have created
118:20 - a simple program to print out the digits
118:22 - but we have implemented the logic in a
118:25 - recursive function now the only line of
118:28 - difference is right over here in the
118:30 - first time the recursive call is the
118:32 - last line inside this function now
118:35 - remember the last line is automatically
118:37 - returned we don't have to use the
118:39 - keyword of return and this is creating a
118:41 - loop for us now when do we exit we exit
118:45 - when we have a base case and what is the
118:48 - base case it's criteria whenever we get
118:51 - a 0 at that time we simply want to
118:53 - return 0 and this is the time when we
118:56 - exit from our recursive function so we
118:59 - have two different function definitions
119:00 - the first definition is for our base
119:03 - case the second definition is for our
119:05 - recursive case now what we did in the
119:08 - second time is we simply change our
119:10 - recursive call so in the second case
119:13 - first we have a recursive call and then
119:15 - we have the print statement and what
119:18 - happened this time the execution shifted
119:20 - from ascending stage to the written
119:22 - stage so if I have to summarize further
119:25 - here what's happening the printing is
119:27 - done in ascending stage and in the
119:30 - second case the printing is done in the
119:32 - return stage that means the work or the
119:35 - execution happened during the return and
119:38 - not during ascending stage so this kind
119:40 - of function is also called as yield
119:43 - recursion now remember in tailed
119:45 - Recreation we are calling the same
119:47 - function back but each time with a
119:50 - different argument and on the second
119:52 - case this recursion is called as head
119:55 - recursion because first we have the
119:57 - recursive call and then we have some
119:59 - kind of an execution left now you can
120:01 - see that we can create efficient Loops
120:04 - in Elixir by using recursion and that
120:07 - too avoiding all of the side effects by
120:09 - mutating our values well that's it for
120:12 - this one I hope you enjoyed the lecture
120:13 - on recursion and I will catch you in the
120:15 - next one so till now we saw how to print
120:18 - digits by using recursion and we sort
120:21 - two methods that was tail recursion and
120:24 - head recursion now let us get some more
120:27 - practice with recursion and this time
120:29 - instead of just printing the digits let
120:32 - us add all of the digits together
120:34 - so for example let us create a function
120:37 - called as up to and if you pass the
120:39 - argument of 3 at that time we want to
120:42 - get the sum of all of the digits so this
120:46 - function should return 3 plus 2 that is
120:48 - 5 5 plus 1 is 6 so this function should
120:52 - return as 6. so let us go ahead and let
120:55 - us create the file for this one so
120:58 - inside the directory of recursion let me
121:01 - create a new file and let me call it as
121:04 - sum of digits dot e x the first thing we
121:08 - want to define a module and as per the
121:12 - community convention let us write the
121:15 - application name first so the
121:17 - application name is tutorials and then
121:19 - the folder is recursion and then the
121:21 - file name is sum of our digits let me
121:25 - collapse my sidebar now here let me
121:28 - first write a very simple recursive
121:29 - function and then we will try and
121:32 - restart function so let us call a
121:35 - function by the name of up to and let us
121:38 - pass the argument for the numbers and
121:41 - let's see what we can do this time so
121:43 - this time we can use a very simple
121:45 - recursive function we can say that for
121:48 - each iteration I simply want to add the
121:50 - number and the next time I want to call
121:53 - the same function of up to but every
121:56 - time my argument should be number minus
121:59 - of 1 but this function will never end
122:02 - because we don't have a base condition
122:04 - the number will keep on going into
122:06 - negative values so we also need to
122:09 - define a base condition so on the top
122:12 - let us create the base condition so let
122:14 - me create a new function by the name of
122:16 - up to and this time let us pattern match
122:19 - on 0 suppose the number is 0 then at
122:23 - that time I simply want to return back
122:25 - 0. now remember if we have a single line
122:28 - of return then we can write it on the
122:31 - same line and in case if we have a
122:33 - regular function then the last line is
122:36 - automatically returned we don't have to
122:38 - use the keyword of return so let me save
122:41 - the file first let me run the file and
122:44 - then we will try and Trace the recursive
122:46 - function so let me open up my terminal
122:49 - and let us enter inside IEX so I can say
122:53 - IEX dot s that stands for start I want
122:57 - IEX to start my mix and let me clear all
123:01 - of these things let us create an alias
123:03 - so we can say I want to create an alias
123:06 - for tutorials dot recursion dot sum
123:10 - digits let me clear up the screen and
123:13 - now we can see from the model of some
123:16 - digits I want to use the function of up
123:18 - to and let me pass the argument of three
123:21 - so as expected we get the answer as 6 so
123:25 - what happened 3 plus 2 plus 1 is equal
123:27 - to 6 now let us see how we can trace
123:30 - this recursive function so this is our
123:33 - program for some digits and this is the
123:36 - functions that we wrote on line number
123:38 - one we have the base case and on line
123:41 - number three we have the recursive case
123:43 - now let us see what's going to happen
123:45 - let's take the same example and let us
123:47 - pass 3 to this function now is 3 equal
123:50 - to 0 No 3 is not equal to 0 so Elixir
123:53 - will go to the next function and here
123:56 - what's going to happen here we are
123:58 - saying that we want to add the number
124:00 - and after adding the number we simply
124:02 - want to call the function recursively so
124:05 - what's going to happen is we get 3 plus
124:08 - and again we call back the same function
124:11 - but this time the argument is number
124:14 - minus one that's why the next time we
124:16 - are calling the same function up to with
124:19 - an argument of 2. now what's going to
124:21 - happen is 2 equal to 0 no so elixir go
124:25 - to the next function now what happens
124:27 - again the same thing number plus the
124:30 - recursive call
124:31 - so what's going to happen is so this
124:33 - will evaluate 2 we get the number so the
124:36 - number in this case is 2 so 2 and plus
124:38 - and then we again get back the recursive
124:41 - function but this time the argument is 2
124:44 - minus of 1 that's why the argument
124:46 - becomes 1. now again let us go back to
124:49 - the same function is 1 equal to 0 no
124:52 - then we will go to the next function now
124:54 - here again the same thing repeats so
124:56 - this time again the number plus that
124:59 - means 1 plus and let us call the same
125:02 - function again but this time the
125:04 - argument becomes 0 so what's going to
125:07 - happen this time this time we have a
125:09 - base condition in place which is right
125:12 - over here we are saying that whenever
125:14 - the argument is 0 at that time we simply
125:17 - want to return back zero so this
125:19 - function right over here this will
125:21 - simply return back a 0. so now what has
125:24 - happened we have exhausted this call and
125:27 - now the control has to return back to
125:29 - the earlier functions so what what's
125:31 - going to happen so this entire
125:33 - expression 1 plus of this function this
125:36 - will be evaluated to 1 plus 0 is equal
125:39 - to 1 so this entire expression evaluated
125:42 - to a one now the control will go back to
125:45 - this function right over here but this
125:47 - time what's happening so this entire
125:50 - function call evaluated to a 1 so what's
125:53 - going to happen right over here this
125:55 - entire expression would be evaluated to
125:58 - 2 plus 1 is equal to 3. now again the
126:01 - control will go back to the earlier
126:02 - function call so this time what's
126:05 - happening the function call of up to and
126:07 - 2 has evaluated into a three so this
126:11 - entire expression gets evaluated to 3
126:14 - plus of 3 that means we get back a 6 and
126:18 - this is what is written from our
126:20 - function which you can see right over
126:22 - here now if you have a look at this
126:24 - function this function is neither head
126:26 - recursive neither it is still recursive
126:29 - it is just a recursive function but can
126:32 - we convert this function into a tail
126:34 - recursive function yes we can so let me
126:37 - show you how we can convert this
126:39 - function from a regular function to our
126:41 - tail recursive function so let us create
126:43 - a new function right over here and we
126:45 - can say that this time the up to
126:47 - function would be tail recursive now
126:51 - first let me write the function
126:52 - definition and then I will explain
126:54 - what's happening so this function is
126:57 - going to accept two different parameters
126:59 - the first parameter is the number as it
127:02 - is and I also want to accept one more
127:04 - parameter which I am going to call as
127:07 - accumulator so which stands for ACC for
127:10 - short next let us think of our base
127:12 - condition so as we just saw over here we
127:15 - have a base condition where the number
127:17 - is zero so let's try and replicate that
127:20 - same logic right over here so in case if
127:23 - I say that my number itself is 0 then at
127:26 - that time I simply want to return back
127:28 - my accumulator so I can say do ACC e so
127:32 - this is our base condition now let us
127:34 - see how we can Define our recursive
127:37 - condition so let me copy and paste right
127:39 - over here and this time we want to get a
127:42 - number and let us take the return
127:44 - statement in a different line so let me
127:46 - take it out now let's see what we can
127:49 - use as our recursive call now again
127:51 - please let me repeat first let me write
127:53 - the code and then when we see how to
127:55 - trace the recursive algorithm at that
127:58 - time the logic will get clear but right
128:00 - now what I want to do is I simply want
128:03 - to call the same function again but for
128:06 - each iteration I want to say that my
128:08 - number has to decrease by 1 and for each
128:12 - iteration I simply want to add my
128:15 - accumulator with the number and that's
128:17 - it we are done so let me save the file
128:19 - and let me open up the terminal and now
128:22 - I can recompile the model of some digits
128:25 - now let me clear up the screen and we
128:28 - can say that we want to use the tail
128:30 - recursive version and let me pass 3 to
128:33 - this one oh we have an error that's
128:35 - because we also need to pass the
128:37 - accumulator so this function the tail
128:40 - recursive requires two arguments and I
128:43 - pass only a single argument that's why
128:45 - we get an error so let me clear this up
128:48 - and we can say that the accumulator has
128:50 - to be 0 and this time we get the answer
128:54 - back as 6. now we can slightly improve
128:57 - our program each time instead of passing
129:00 - an accumulator what I can do is I can
129:02 - simply set the default values so let us
129:05 - go back to the code editor and let me
129:08 - copy and paste this line so what we are
129:11 - going to do is we are going to create a
129:13 - function definition and since we are
129:16 - just creating the function definition or
129:18 - you can say just the function header we
129:20 - don't need to specify the return
129:22 - statement so this has to go and here we
129:24 - can say that the default value of the
129:27 - accumulator is 0 so in case the
129:30 - accumulator is not specified at that
129:33 - time the accumulator would be set to 0
129:35 - and here instead of 0 we can say that
129:37 - the first argument can be any number so
129:40 - what we have done right over here is we
129:42 - have simply created a public function so
129:45 - as our code editor is helping us it's
129:47 - just a public function with a given name
129:50 - and body so normally these things they
129:52 - help you with the documentation of your
129:54 - code the first thing we again need to
129:57 - recompile our model of some digits let
130:00 - me clear up the screen and let us try to
130:02 - invoke the same function but this time
130:04 - since we have a default argument for the
130:06 - iPhone emulator I can simply leave it
130:09 - out and again we get the same answer
130:11 - back as 6. before we go ahead and trace
130:14 - this recursive function we can do one
130:17 - small thing now what happens this
130:19 - function is slightly expensive because
130:21 - it takes slightly more memory so what we
130:24 - can do over here is we can simply call
130:26 - the tail recursive function and pass the
130:29 - argument of number and that's it so now
130:31 - let us open up our terminal and let us
130:34 - again recompile let me clear up
130:37 - everything and this time if I do some
130:40 - digits dot up to and if I pass the
130:43 - argument of 3 so what's happening behind
130:46 - the scenes we are still invoking the
130:48 - tail recursive function and we are
130:49 - getting the same answer back as six so
130:52 - now let us go ahead and let us see how
130:54 - we can trace the tail recursive function
130:57 - so this was the last function now if we
131:00 - want to trace the tail recursive
131:02 - function on line number two we just have
131:04 - the function definition so this function
131:07 - accepts a number and for accumulator we
131:09 - have set the default value as 0 on line
131:12 - number three we have the base condition
131:14 - and we are saying that whenever we get
131:16 - the number as 0 at that time we simply
131:19 - want to return back the accumulator the
131:21 - next is our recursive call now let us
131:24 - pass the argument of 3 to this function
131:26 - and let us try to trace this recursive
131:29 - function so we have an initial call like
131:32 - this the value of number is 3 and by
131:35 - default the accumulator is set to 0. now
131:38 - let's see what's happening now is 3
131:40 - equal to 0 no it's not equal to 0 so
131:43 - Elixir will go to this function right
131:45 - over here now what's happening now we
131:47 - are calling the same function back okay
131:50 - so what we need to do we need to call
131:52 - the same function back but what happens
131:55 - to the argument so the first argument is
131:57 - we simply want to decrement the number
132:00 - by one so in this condition what is
132:03 - happening the number is 3 okay so we get
132:05 - 3 over here and for each call we simply
132:08 - want to subtract one from it so the
132:10 - answer here is 2 and the next parameter
132:12 - is right over here so we simply want to
132:14 - add the accumulator with the number
132:18 - so let's go right over here so what's
132:20 - the accumulator so as you can see
132:22 - initially the accumulator is zero so we
132:25 - get a zero right over here what's the
132:27 - number the number is 3 so 0 plus 3 we
132:31 - get a 3 right over here so this entire
132:33 - function would look something like this
132:35 - the new number is 2 and the new
132:37 - accumulator is a 3. now let's see what's
132:40 - going to happen is 2 equal to 0 no it's
132:43 - not so we will go inside this function
132:45 - again we have to recursively call the
132:48 - same function so let us see what's going
132:50 - to happen so again we call the same
132:52 - function but this time what happens the
132:55 - number is -1 so this 2 comes over here
132:58 - minus of 1 so what's the remainder it's
133:01 - one the next is accumulator plus the
133:04 - number so in this case what is the
133:06 - accumulator the accumulator is 3 which
133:09 - comes right over here what is the number
133:11 - number is 2 so 2 comes over here so 3
133:14 - plus 2 we have a five so this function
133:16 - gets evaluated 2 right over here up to
133:20 - the number becomes 1 and accumulator
133:22 - becomes 5. now again the same thing we
133:25 - have to call ourselves back again now is
133:28 - 1 equal to 0 no so we go to the next
133:30 - condition and again we call ourselves
133:33 - back so what's going to happen this time
133:35 - so this time number is 1 1 minus or 1 so
133:39 - that's why we get a 0 right over here
133:40 - the next is again the same thing
133:42 - accumulator plus the number so what's
133:45 - the accumulator the accumulator is 5
133:48 - that's why we get a 5 over here what's
133:50 - the number the number is 1 so we get a 1
133:53 - over here so 5 plus 1 we get a 6 that
133:56 - means we can say that this expression is
133:59 - evaluated something like this up to 0
134:01 - and 6 oh so this time the number becomes
134:05 - zero so what's going to happen so it's
134:08 - going to go right over here so is the
134:10 - number 0 yes the number is zero so what
134:13 - do we do we simply written back in the
134:16 - accumulator so that's what is going to
134:18 - happen right over here we simply have to
134:20 - return back the accumulator so what's
134:22 - the accumulator the accumulator is 6 and
134:25 - that is what we have written so now is
134:28 - anything left nothing nothing is left
134:30 - and that's it we get the answer back as
134:33 - six so as you can see this tail
134:36 - recursive functions are very special the
134:38 - first reason is they require less memory
134:41 - and why do they require less memory is
134:44 - because they are recursively calling
134:46 - themselves back again now if you come
134:48 - from some other compiled language like
134:50 - Java or maybe like python you must be
134:53 - thinking that for each of these calls V
134:55 - must be allocating different stack
134:57 - memory but no that does not happen in
135:00 - Elixir since Elixir is a functional
135:03 - programming language this function calls
135:05 - are highly optimized so what's happening
135:08 - we are simply reusing the same stack and
135:11 - hence there is no extra memory
135:13 - allocation so always whenever possible
135:15 - try and use skill recursive functions
135:17 - because they are more memory efficient
135:19 - in terms of speed it could be more it
135:22 - could be less you don't know but in
135:24 - terms of memory for sure they require
135:26 - much less memory well that's it for this
135:28 - video and I will catch you in the next
135:30 - one let's have some more practice with
135:33 - our recursion in the last video we wrote
135:36 - a very simple recursive program to
135:38 - calculate the sum of the different
135:40 - digits but for this video I want you to
135:43 - calculate the factorial of a number
135:45 - first let me get this back to the old
135:48 - code so the old code was number plus of
135:52 - up to and then we simply want to call
135:55 - number minus of one so this time what I
135:59 - wanted to do is I wanted to write a
136:01 - program for calculating factorial so for
136:04 - example if we have a number like 3 then
136:06 - the factorial would be like this 3 into
136:09 - 2 into 1 and the output would be 6. so I
136:14 - wanted to pause this video for movement
136:16 - and try it on your own so I hope you
136:19 - were able to do it if not let us do it
136:21 - together
136:22 - so first let me create a new file and
136:25 - let me call that file as
136:27 - factorial.ex and first let us create the
136:31 - module let us get the model name right
136:34 - this has to be tutorials dot recursion
136:37 - dot factorial and here let me create a
136:39 - function called as off so we can simply
136:42 - call factorial dot off so the first
136:45 - condition is in case if I get 1 at that
136:48 - time I simply want to return one back
136:51 - next let us write the recursive case so
136:54 - in case we get some other number so we
136:57 - can say number and this time let me show
137:00 - you how you can calculate by using a
137:02 - regular recursive program and after that
137:05 - I will also show you how to write this
137:06 - program by using TLD recursion but for
137:09 - now let us go with the flow so here we
137:11 - can say that for each iteration we want
137:14 - to multiply a number and we simply want
137:17 - to call ourselves back each time but
137:20 - each time we want to decrement the
137:22 - number by 1 so this is a very simple
137:25 - recursive case let us open up our
137:28 - terminal let me clear up everything and
137:31 - let us use our IX let me adjust my
137:34 - terminal as well here we can create an
137:37 - alias so we can say tutorials dot
137:40 - recursion dot factorial and let's call
137:44 - our function so we can say factoidal off
137:47 - and let us pass 3 so we get the answer
137:50 - as 6 let us try with 4 so we get the
137:53 - answer as 24 back now let us try and
137:56 - trace this recursive program and see
137:58 - what's happening so this is the first
138:01 - recursive program that we wrote so here
138:04 - we have the base condition Define off if
138:07 - we get one we simply want to return one
138:09 - otherwise we want to call this function
138:11 - so now let us try and Trace what's
138:14 - happening so suppose we invoke this
138:17 - function with an argument of 3 so at
138:19 - that time what's going to happen so is 3
138:22 - equal to one no so Elixir will go to
138:25 - this function and now what's going to
138:27 - happen we have to multiply the number
138:29 - and call the function itself again so
138:32 - here it goes we want to multiply 3 and
138:36 - we want to call the same function one
138:38 - more time but since we are decrementing
138:41 - the number by 1 so this time the
138:43 - argument becomes 2. now again is 2 equal
138:45 - to 1 no so we will jump to this function
138:48 - again the same thing will happen we
138:51 - first have to multiply the number and
138:53 - call the same function one more time so
138:56 - this time again we have 2 and this time
138:58 - 2 multiplied by the same function and
139:02 - the new argument is 1. so in the next
139:05 - iteration we have a match on the base
139:08 - case so since we have a match we simply
139:11 - have to return one so this function
139:13 - would be evaluated to a simple one now
139:17 - the control will go back to this
139:19 - statement right over here 2 multiplied
139:21 - by and this function so this would be
139:24 - evaluated to 2 and this one comes right
139:27 - over here so this entire expression
139:30 - would be evaluated to a 2. now the
139:33 - control will again flow back right over
139:35 - here so this one would be evaluated
139:38 - something like this 3 multiplied by 2
139:40 - and we have a 6. now there is nothing on
139:43 - the top we have exhausted dysfunction as
139:45 - well that's why we get the written value
139:48 - as 6 which is the factorial of 3. now
139:51 - let's go back to our program
139:53 - so this was a very simple recursive way
139:56 - of creating the factorial next is can
139:58 - you write the same program but by using
140:01 - tail regression so if you can just give
140:03 - it a pause and try it on your own
140:05 - otherwise I will show you how we can
140:07 - write the same program by using tail
140:09 - recursion so let me create a new
140:11 - function right over here and I can say
140:13 - off but this time it's going to be with
140:15 - real recursion this function is going to
140:18 - accept two arguments so the number one
140:20 - would be on number and for the tail
140:23 - recursive function first let us create
140:25 - the base case so here we can pattern
140:27 - match on the number so we can say that
140:30 - in case the number is 1 and the second
140:33 - argument is our accumulator so this time
140:36 - I simply want to return back my
140:39 - accumulator so don't worry if you don't
140:41 - understand we will trace this program as
140:43 - well next comes our recursive case so we
140:46 - can say of our tail recursive version so
140:50 - the first argument is our number the
140:52 - second argument is our accumulator so
140:55 - here I can say that for each iteration I
140:58 - simply want to call the same function
140:59 - again so off tail recursion but for each
141:03 - iteration I simply want to decrement my
141:06 - number by 1 and for each iteration I
141:10 - also want to multiply my accumulator
141:12 - with my number next we can do one slight
141:16 - Improvement for this program as well we
141:19 - can also have a default value for the
141:21 - accumulator so let us go ahead and let
141:23 - us create the function definition on the
141:25 - top so remember that the function
141:27 - definition always goes on the top so
141:30 - here we can say we want to Define of our
141:33 - tail recursive function the first
141:35 - argument is always going to become the
141:38 - number the second argument is our
141:40 - accumulator and for the accumulator we
141:42 - want to have the default value of 1 and
141:45 - since this is just a function definition
141:47 - we don't have to write the body of this
141:49 - function and let me open up my terminal
141:52 - and since we have changed the contents
141:55 - of the module first let us try and
141:57 - recompile this module now let me clear
141:59 - up everything now let's try and use the
142:02 - tail recursive version so we can say
142:04 - factorial of this time we want to use
142:07 - our Delta cluster function and let us
142:10 - pass the argument of three so we get the
142:12 - answer back as 6. let us try one more
142:15 - time with 5 and for 5 we get the answer
142:18 - as 120 so now let us go and try and
142:21 - trace this recursive program as well so
142:24 - this is our tail recursive version so as
142:27 - you can see for the first line we have
142:29 - the function definition the first
142:31 - argument is the number and we have the
142:34 - default value for the accumulator and
142:36 - the default value is 1 next we have the
142:39 - base case and here we simply want to
142:41 - pattern match on the number so we are
142:44 - saying that in case the number is 1 at
142:47 - that time I simply want to return back
142:49 - my accumulator next we have our
142:51 - recursive case so for each iteration we
142:55 - simply want to decrement the number by 1
142:57 - and we also want to multiply our
143:00 - accumulator with the number so now let
143:03 - us see what's going to happen with this
143:04 - one suppose we invoke the function with
143:07 - an argument of 3 and the default value
143:09 - for the accumulator is 1 so for the next
143:12 - iteration what's going to happen so is 3
143:15 - equal to 1 no so Elixir is going to jump
143:18 - right over here so what's going to
143:20 - happen this time we want to call
143:22 - ourselves back so this function will
143:25 - call itself back but this time the first
143:27 - argument is number minus 1 so 3 minus 1
143:31 - that's why we get a 2 right over here
143:33 - and for the next R command we simply
143:36 - want to multiply the accumulator with
143:38 - the number the accumulator is 1 the
143:41 - number is 3 so we get a 3 right over
143:43 - here so this function would look
143:45 - something like this so next again so is
143:47 - 2 equal to 1 no so we have to call
143:50 - ourselves one more time so again this
143:52 - time what's going happen is we want to
143:55 - decrement the number by one so this
143:57 - evaluates to a 1 and we also want to
144:00 - multiply the accumulator with the number
144:02 - so the accumulator is 3 and the number
144:06 - is 2 so we get a 6 right over here and
144:08 - this function would look something like
144:10 - this what's going to happen this time oh
144:13 - so this time we have a match on the
144:15 - number and we are pattern matching and
144:17 - saying that in case the number is 1 at
144:20 - that time we simply want to return the
144:22 - accumulator so this function would
144:24 - evaluate to something like this we
144:27 - simply have to return back the
144:28 - accumulator and the accumulator is 6 and
144:32 - that's your final answer and after this
144:34 - we simply exit because there is nothing
144:36 - else left to do so just as a small tip
144:39 - whenever you are feeling confused with
144:41 - recursion or if you don't know what's
144:43 - happening inside your recursive calls
144:45 - it's always a good idea to draw this
144:47 - kind of recursive trees and for sure
144:49 - they will help you to understand
144:50 - recursion in a much better way well
144:54 - that's it for this video and I will
144:55 - catch you in the next one let's have
144:58 - some more practice with our recursion
145:00 - and this time I wanted to write a
145:02 - program that will reverse the numbers so
145:05 - in case the number is one two three then
145:08 - the output should be 3 2 and 1. and what
145:11 - I've done is behind the scenes I've
145:13 - created a new file called as reverse
145:15 - number inside recursion and I have
145:18 - created a blank model for this one now
145:21 - here you can use your own logic to
145:23 - reverse the number or if you want some
145:25 - reference I have given a simple
145:27 - algorithm right over here but it's not
145:30 - required to follow my logic if you can
145:32 - do it in any other way you are welcome
145:34 - to do it so let's see what steps I have
145:37 - given right over here so for example the
145:39 - number is 123 then the output should be
145:43 - 321 so for this case suppose I want to
145:46 - write a tail recursive version at that
145:49 - time I want to have one more variable
145:50 - called as accumulator and I want to set
145:53 - at the default value of accumulator 0.
145:56 - now again it's not necessary for you to
145:58 - write a tail recursive version you can
146:00 - write any version that you seem fine but
146:03 - I am going to write a tail recursive
146:05 - version for this one that's why I have
146:07 - taken one more variable next what I am
146:10 - doing is I am creating a loop and for
146:13 - each iteration I want to create a new
146:15 - number and a new accumulator so let's
146:18 - see what's going to happen for the new
146:20 - number and for the new accumulator for
146:23 - each iteration of the loop I simply want
146:26 - to divide this number by 10 so that I
146:29 - get a new number each time so for the
146:31 - first time the number is 123 so 123
146:35 - divided by 10 so I get the answer as 12.
146:39 - now for the new accumulator there are
146:42 - two steps the first step is I simply
146:45 - want to multiply my existing accumulator
146:47 - by 10. now the existing accumulator is 0
146:51 - so 0 multiplied by 10 that's why I have
146:55 - a 0 right over here so this was the
146:57 - first part and the next part is I also
147:00 - want to take the remainder of this
147:02 - number so I'm using the mod operator so
147:05 - here what's going to happen is the
147:07 - remainder of 123 and 10 is 3 and the
147:11 - final step is 0 plus of 3 and we get a 3
147:15 - right over here the next thing is I want
147:18 - to continue with this Loop till the time
147:20 - my number becomes 0 but right now my
147:23 - number is 12 so this number changes from
147:27 - 123 to 12 and the new accumulator is 3
147:31 - that's why this 0 changes to a 3. now is
147:35 - my number equal to 0 no so we continue
147:37 - with the loop so for the next iteration
147:41 - our number is 12 so 12 divided by 10 we
147:45 - get a 1 right over here and for the new
147:48 - accumulator the value inside the
147:50 - accumulator is 3 so 3 multiplied by then
147:54 - we get a 30 right over here for the next
147:56 - part the number is 12 the remainder of
147:59 - 12 and 10 is 2 so here we have 30 plus
148:04 - of 2 that's why this will evaluate to
148:07 - 32. now again is my number equal to 0 no
148:10 - my new number is 1 and my do accumulator
148:14 - is 32 so we continue with the same Loop
148:18 - now this time my number is 1 so 1
148:21 - divided by 10 I get a 0 right over here
148:23 - then for the new accumulator my value
148:26 - inside the accumulator is 32 so as you
148:29 - can see right over here we have 32 so 32
148:32 - multiplied by 10 that's why we get 320
148:36 - right over here the next part is the
148:39 - number is 1 the remainder of 1 and 10
148:42 - becomes 1 so here we have 1 plus of 320
148:47 - so we get 3 2 and 1 right over here so
148:51 - what happens now your number number has
148:53 - become 0 and your accumulator has become
148:56 - 321 and since your number becomes 0 we
149:00 - simply want to return back the
149:02 - accumulator and the accumulator is 3 to
149:04 - 1 which is exactly the reverse of 123.
149:08 - now before you attempt this question let
149:10 - me show you one more thing in Elixir if
149:13 - you do something like this 123 divided
149:16 - by 10 here you can see that we get back
149:19 - a float value but if you want to get
149:22 - back an integer division then you can
149:24 - use the inbuilt function of div for for
149:28 - division so we can say we want to divide
149:30 - 123 by 10 and we get back in the integer
149:34 - value of 12. now for calculating the
149:37 - remainder we don't have the modulus
149:39 - operator instead you can use the inbuilt
149:42 - function of remainder so we can say that
149:45 - we want to get the remainder of 123 with
149:48 - 10 and we get back to the value of 3. so
149:51 - with these things in mind I want you to
149:53 - write this program now again let me
149:55 - repeat you can use your own logic and
149:57 - just pause this video for a moment and
149:59 - try it on your own otherwise we will do
150:01 - it together
150:02 - so I hope you were able to do it if not
150:05 - let us do it together I am going to
150:07 - write a tail recursive version for this
150:09 - program and the first thing which I want
150:11 - to do is I simply want to Define my base
150:14 - case and what is my base case my base
150:17 - case is right over here so if my number
150:19 - is 0 then I simply want to return the
150:23 - accumulator let me create a function
150:25 - called as off and this function is going
150:28 - to accept two parameters by number and
150:30 - my accumulator and my base case is
150:33 - something like this in case my number is
150:36 - 0 then I simply want to return back my
150:39 - accumulator so this is our base case now
150:42 - let us Define the recursive case so we
150:45 - can say that the function of off is
150:48 - going to accept one parameter for the
150:50 - number the second one for the
150:51 - accumulator and let us create the do and
150:54 - end blocks here we can say that my new
150:57 - number is going to be the integer
151:00 - division of my number with n n and also
151:04 - for each iteration I want to create a
151:06 - new accumulator so I can say that my new
151:08 - accumulator again let us use the logic
151:11 - that we have defined over here so the
151:13 - logic goes like this for each iteration
151:15 - I simply want to multiply the
151:17 - accumulator with n and for the next part
151:20 - we simply want to add the remainder of
151:23 - the number along with 10. now the only
151:26 - thing left to do is to Simply call the
151:28 - same function one more time but this
151:31 - time the argument is going to be our new
151:34 - number and here we have the new
151:36 - accumulator now here we also need to set
151:39 - the default value of accumulator to 0 so
151:42 - let me create a function definition on
151:44 - the top so we can say that function of
151:46 - off accepts one parameter by the name of
151:48 - number the second parameter is called as
151:51 - accumulator the default value is 0 now
151:55 - since this is just the function
151:56 - definition we don't have to create the
151:59 - body let me save this program let me
152:01 - open up my terminal null now since this
152:04 - time I have added a new file let us
152:07 - recompile the entire project so we can
152:09 - say that I want to decompile then let me
152:12 - create an alias for tutorials dot
152:15 - recursion dot reverse number oh sorry I
152:19 - spelled it wrong so it has to be
152:22 - alias
152:24 - let me clear up the screen and now let
152:27 - us try our newly defined function
152:29 - so we can say that reverse number off
152:33 - and let us pass the argument of 123 and
152:36 - we get the right answer back let us try
152:39 - with one two three four five and we get
152:41 - back the answer of 5 4 3 to 1. till now
152:45 - we have seen how to work with recursion
152:47 - inside our Elixir now it's time to see
152:50 - how we can combine list along with our
152:53 - Elixir and I can't emphasize more that
152:56 - the list inside Elixir are not your
152:59 - regular arrays or lists list inside
153:02 - Elixir are actually linked list so even
153:05 - if a list looks something like this it's
153:08 - not what it looks like so for those of
153:10 - you who don't know what is a linked list
153:12 - here it goes so here we have three
153:15 - different nodes and for the first node
153:18 - the data inside the head is one so as
153:21 - you can see the data inside the list
153:23 - this one this one actually looks
153:26 - something like this inside the memory so
153:28 - this enter bad thing this would be your
153:31 - node number one and the data inside your
153:34 - head would be one the darker portion
153:37 - that you can see over here so this is
153:39 - going to be your tail of your node
153:41 - number one and this tail is actually
153:44 - pointing to yet another node and the
153:47 - data inside this node is stored that you
153:49 - can see over here so this entire
153:52 - structure this is our node number two
153:54 - and the data inside the head is two now
153:57 - again this node also has a tail and this
154:00 - tail is pointing to yet another node the
154:03 - data inside the node is 3 and as you can
154:06 - see this is going to be our node number
154:08 - three The Head and the data inside the
154:11 - head is three now if you have a look at
154:14 - the list we don't have any other
154:15 - parameters left so the tail of your node
154:18 - number three this would actually point
154:21 - to something which is null that means it
154:23 - is not pointing to anything else so this
154:26 - is how a linked list would look inside
154:28 - the memory now just to refresh your
154:31 - memory let us go back to our terminal so
154:33 - we can say that we have a list and the
154:36 - elements are 1 2 and 3. now as we just
154:39 - saw we have three different nodes and if
154:42 - you want to see the head of the first
154:43 - element then either you can use the
154:46 - built-in function for the head or we can
154:48 - also use pattern matching and in case if
154:51 - you want to use the pattern matching
154:52 - then we can say that the first element
154:54 - should be head then we need our cons
154:58 - operator then we need one more variable
155:01 - for the tail and let us pattern match on
155:04 - list and here we can see that the head
155:07 - is 1 and the tail is 2 and 3. now
155:10 - suppose we have one more list let us
155:12 - call it as list number two and this has
155:15 - a single element of a inside of this
155:18 - list now what happens if I try to
155:20 - pattern match on this list so let us
155:23 - pattern match and see let us write the
155:25 - head and we also want the tail and this
155:28 - time we want to pattern match on list
155:30 - number two so as you can see the data
155:33 - inside our head is a but what happens to
155:36 - your tail let us check it out so as you
155:39 - can see the tail is blank that means we
155:42 - have exhausted this linked list and
155:44 - there are no more elements left so keep
155:46 - this pattern in your mind and we will
155:49 - see how to work with recursion and lists
155:51 - right from the next video
155:53 - so let us get started with linked list
155:55 - but before we can get started I wanted
155:58 - to show you a couple of things
156:00 - so let us go back to our terminal and I
156:02 - am inside my IEX
156:04 - now in case if I want to see the info
156:07 - for a list so let's create a list one
156:09 - two and three
156:11 - here we get back a couple of information
156:13 - parameters for our list and here we can
156:16 - see that we have a couple of implemented
156:19 - protocols and one of the most important
156:22 - protocol is this one so this stands for
156:24 - innumerable that means in short as enum
156:27 - and let us go to the official
156:30 - documentation and there I can explain
156:32 - all of these things
156:33 - so this is the official website for
156:35 - Elixir it's
156:37 - elixirland.org let us go to docs and
156:40 - here we want to see the documentation of
156:42 - the current stable version so this takes
156:45 - us to a new website and as you can see
156:47 - this website is called as hex docs.pm so
156:51 - hex is like the package registry for
156:54 - Elixir so in case if you go to this
156:56 - website hex dot pm and here we can
156:59 - search for different packages suppose
157:01 - you want to search for Phoenix then you
157:03 - can search for Phoenix right over here
157:05 - and this is going to list all of the
157:07 - packages so this is the official package
157:10 - for Phoenix and if you click on the
157:13 - online documentation it will take you to
157:15 - the docs page and this is the official
157:17 - documentation for Phoenix now let us go
157:20 - back to the documentation for Elixir and
157:23 - as you can see we have two tabs right
157:25 - over here so this tab is for the pages
157:27 - and this tab is for the modules now this
157:30 - model of Kernel is automatically
157:33 - imported for us we don't have to import
157:35 - this kernel the next model which I
157:38 - wanted to show you is for our list
157:40 - so let us scroll a little bit down and
157:44 - inside this section of Collections and
157:46 - enums we have our list right over here
157:49 - and here we can see that we have nice
157:52 - documentation in place and also we have
157:55 - a couple of functions that are
157:57 - implemented on the type of list so here
158:00 - we can see we have different functions
158:02 - and if you want to see documentation for
158:04 - any of the functions you have to just
158:06 - click on this one and this open UPS the
158:08 - documentation for the requested function
158:10 - now in the terminal we saw that list
158:13 - also implements the protocol for our
158:15 - enum so let us check out the
158:18 - documentation for enum let me collapse
158:20 - my list and let us go to the
158:23 - documentation for erum so enum basically
158:26 - helps you to iterate over your list or
158:28 - any of the collections and most of the
158:31 - functions for your it labels are inside
158:33 - enum and some of them could be in lists
158:36 - or Maps or hash map but enum would be
158:39 - your most frequently used module and as
158:42 - you can see in the documentation the
158:43 - first example itself uses a list the
158:47 - second example also takes a list and and
158:49 - simply gives back the sum of the list so
158:52 - what we can do is let us try and
158:54 - replicate this functionality by using
158:56 - our list and recursion
158:59 - so now let us go back to our code editor
159:02 - now here let us create a new folder so
159:05 - inside my directory of flip let us
159:08 - create a folder by the name of list and
159:10 - inside this folder let us create a new
159:13 - file by the name of list dot ex and let
159:18 - us first Define the module so this has
159:21 - to be dot tutorials
159:23 - and this naming conversion doesn't make
159:26 - any sense so right now let me just take
159:28 - out this list and let us name the module
159:31 - as tutorials dot list so let me Define a
159:35 - function called as sum and this is going
159:37 - to take a list of our numbers now first
159:40 - let us think of a base case suppose we
159:43 - get an empty list so at that time we can
159:46 - simply return back a zero
159:48 - so let me Define a base case on the top
159:51 - so I can say Define my sum and let us
159:54 - pattern match on an empty list so we can
159:57 - just write empties right over here so in
159:59 - case we get an empty list we simply want
160:01 - to return back a zero so now let us see
160:04 - how we can write the recursive case now
160:07 - what we can do is this parameter of
160:09 - numbers this is actually a list so we
160:12 - can pattern match right over here so
160:14 - what I can do is let me take out this
160:16 - parameter and let us pattern match
160:18 - inside the function definition let us
160:21 - collect the head inside a variable
160:23 - called as H and let us collect the tail
160:26 - inside a variable called as T now let us
160:29 - see what we want to do for each
160:31 - iteration we simply want to add the head
160:34 - along with the sum and each time we
160:37 - simply want to pass the tail and that's
160:39 - it we have a recursive function for
160:41 - adding all of the elements inside the
160:43 - list now as you can see that this is not
160:46 - a tail recursive version so what we can
160:49 - do is let us try and rename this file so
160:52 - instead of calling this as sum let us
160:54 - rename this function from sum to some
160:57 - simple and here what we can do is since
161:01 - this is just one single line of return
161:03 - let me take it to a single line let me
161:06 - put the codes and we don't need the end
161:09 - block and let us open up our terminal
161:11 - and see if this is working or not so let
161:14 - me go inside my IEX and let me clear up
161:17 - my terminal and here we can say that
161:20 - from the model of tutorials I want to go
161:22 - to the model of list then I want to
161:25 - invoke the function of some simple and
161:28 - let us pass the list of 1 2 and 3 and as
161:32 - expected we get back the answer as 6.
161:35 - now what we can do is we can also write
161:38 - this function by using tail recursion so
161:41 - let us see how we can create the tail
161:43 - recursive function so we can call that
161:45 - function as sum and tail recursive and
161:50 - let us think of different parameters
161:51 - that we can pass for our tail recursive
161:54 - version this function will accept two
161:56 - parameters the first is obviously our
161:58 - list of numbers and we also need an
162:01 - accumulator and what we can do is let us
162:04 - Define the function definition right
162:06 - over here so we can say that the default
162:08 - value for our accumulator has to be zero
162:12 - and now since we have just created the
162:14 - function definition or the function
162:16 - header we don't need to create a body
162:18 - for this one next let us write the
162:20 - actual implementation so let me just
162:22 - copy and paste so here we don't need the
162:25 - default argument and first let us think
162:28 - of the base case so in case the numbers
162:31 - is just an empty list so at that time we
162:34 - simply want to return back our
162:36 - accumulator the next is our recursive
162:39 - case so let me again copy and paste now
162:42 - this time again we can pattern match on
162:44 - the head and on the tail so we can say
162:46 - that we want to collect the head and we
162:49 - also want to collect the tail and for
162:52 - each iteration we simply want to call
162:54 - the same function back but now for each
162:57 - iteration we simply want to pass the
162:59 - tail we don't need to pass the head for
163:01 - each iteration and our accumulator
163:04 - becomes our accumulator plus of our head
163:07 - and that's it we have a tail recursive
163:10 - function as well now let us do one
163:12 - simple thing let me go at the top and
163:15 - here let me create a function which is
163:17 - called as sum and this accepts our
163:20 - numbers and here let us simply call the
163:23 - tail recursive version so we can say
163:25 - that I want to call my real recursive
163:27 - version and let me pass numbers to it so
163:30 - now we have a much smaller name and this
163:33 - makes our life much more easy
163:35 - so let us go back to our terminal let us
163:39 - recompile tutorials dot list let me
163:42 - clear up the screen and let us invoke
163:45 - the same function but this time the name
163:47 - of the function is just sum and as
163:50 - expected we get back in the answer as 6
163:52 - and this time for calculating the sum we
163:55 - are using the tail recursive version now
163:58 - going forward I am not going to draw the
164:00 - recursive trees but if you are not
164:02 - feeling confident or if you are feeling
164:04 - confused then I highly motivate you to
164:06 - draw the recursive trees
164:08 - now before ending this video I wanted to
164:11 - show you a couple of things the first
164:13 - thing is let us see how we can document
164:15 - all of our code the first thing is we
164:18 - can use something which is called as
164:19 - module attributes so on the top we can
164:22 - say that we want to create documentation
164:24 - for the entire module so let's document
164:27 - what we are going to do for this model
164:29 - of list we are going to implement a
164:32 - couple of functions that can be used on
164:34 - the list so I can create a heading for
164:37 - our function summary and the first one
164:39 - that we have implemented is for our sum
164:42 - so this is how you write the module
164:45 - level documentation next let me show you
164:47 - how we can write the documentation for
164:49 - our function so for this we can use the
164:52 - model attribute of just Doc and inside
164:55 - the quotation marks let us write the
164:57 - documentation
164:58 - saying that this function Returns the
165:00 - sum of the numbers inside a list so now
165:03 - if you hover over the definition of sum
165:05 - we can see that the code editor is
165:07 - showing us the documentation and the
165:10 - last thing which I wanted to show you in
165:11 - this video is how we can Define the type
165:14 - specifications or the type hints so here
165:17 - we can use another module attribute by
165:20 - the name of spec so this stands for the
165:22 - function specifications so here we want
165:25 - to define the specifications for our
165:27 - function of sums and here we can Define
165:30 - the type of this parameter so in our
165:34 - case sums is actually a list and the
165:37 - list contains different numbers so this
165:40 - is how we can Define the type of numbers
165:42 - the next comes the return type so here
165:45 - we can put double quotes and we can say
165:48 - that the return type is also going to be
165:50 - a number so what we have done is we have
165:52 - also added the documentation and we have
165:55 - also add the specifications so in the
165:57 - future whenever we you are using tools
165:59 - like dialyzer it will help you to catch
166:01 - bugs inside your code next let us write
166:04 - the specifications for our other
166:06 - functions as well so let me copy this
166:08 - one and let me paste it right over here
166:11 - this function is going to be our sum of
166:14 - simple next let us also write the
166:17 - specification for our tail recursive
166:19 - function so here I can say that this
166:22 - function name is actually my sum of tail
166:25 - recursive now this function accepts two
166:27 - parameter the first parameter is a list
166:29 - of numbers the second one is simply an
166:32 - integer so we can say that the second
166:34 - parameter is an integer and the return
166:37 - type is number and if you want to read
166:39 - more about the type specifications then
166:42 - we can go to the official documentation
166:44 - and we can go to the tab of pages and
166:48 - here we can see that we have the
166:50 - documentation for our type
166:51 - specifications right now don't worry too
166:54 - much about type specifications I will
166:56 - show you how we can write the
166:57 - specifications for from here on well
167:00 - that brings us to the end of this video
167:02 - and I will catch you in the next one
167:04 - now let us see how we can reverse a list
167:06 - inside Elixir so for example we have a
167:09 - list and this list has two elements two
167:12 - and three so this list would look
167:14 - something like this inside your memory
167:16 - so we have two nodes so this node is for
167:18 - two and this node is for three now here
167:22 - goes my question suppose we have two
167:24 - more nodes on the left here we can see
167:26 - that we have one node and on the right
167:28 - here we can see that we have one more
167:30 - node so now the question is would adding
167:34 - this node to our list of 2 and 3 would
167:36 - be faster or adding 4 to our list of 2
167:40 - and 3 would be faster so what do you
167:42 - think this operation would be faster or
167:45 - this operation would be faster so the
167:47 - answer is adding this node would be
167:49 - faster and this happens in constant time
167:53 - and the reason is we don't have to
167:55 - Traverse throughout this entire list we
167:58 - simply take a node and we simply point
168:00 - the tail to an existing list and that's
168:02 - it but what happens if we want to add a
168:06 - node at the last at that time it is not
168:09 - efficient because it is going to take a
168:11 - linear time and adding this node x a
168:14 - linear time because we have to Traverse
168:16 - through the entire linked list so in
168:19 - this case we have to go from this node
168:21 - to this node and after that we can point
168:23 - the tail of this node to our last node
168:27 - so it takes linear time so just keep
168:30 - this thing in mind that adding a node to
168:32 - the head would be always faster and
168:34 - adding a node at the last would take
168:36 - linear time with this logic in place let
168:39 - us see how we can reverse a list so for
168:42 - example we have a list right over here
168:44 - and we have elements of one two and
168:46 - three so at that time we will take one
168:48 - more accumulator list and for each
168:51 - iteration we will take the head of this
168:54 - one and we will insert that head inside
168:56 - our accumulator list so what happens for
168:59 - the first iteration is we simply take
169:01 - out the head and we insert the head
169:03 - inside our accumulator now here since we
169:06 - are inserting at the head this operation
169:09 - takes constant time and for the next
169:11 - iteration what happens since we have
169:13 - taken out 1 your list now becomes 2 and
169:16 - 3. so for the next iteration we simply
169:19 - take out 2 and we added 2 to the head of
169:22 - our existing list now again since we are
169:24 - adding to the Head this operation also
169:26 - happens in linear time now going to our
169:29 - original list since we have taken out 2
169:32 - we have just one element left and the
169:34 - same thing happens we simply take the
169:36 - three out and we add 3 to the head of
169:38 - our accumulator list and that's it we
169:41 - have reversed a linked list or rather we
169:43 - have simply reversed a list inside
169:45 - Elixir so let us write the code for this
169:48 - one and let us see these things in
169:49 - action so here let me put up a command
169:52 - this is going to be our function of
169:54 - reverse here let us Define a function
169:57 - called as reverse now this function
170:00 - accepts two parameters the first one is
170:03 - for our elements the second one is for
170:05 - the accumulator and let us Define the
170:07 - function signature right over here so in
170:10 - case the accumulator is not given at
170:12 - that time we simply want to set the
170:14 - accumulator to be a blank list the next
170:17 - comes our base case so let me copy and
170:19 - paste and here we can pattern match and
170:22 - we can say that in case we have a blank
170:25 - list right over here at that time we
170:27 - simply want to return back our
170:29 - accumulator so here I can say do and my
170:32 - accumulator the next comes our recursive
170:35 - case so again let me copy and paste now
170:38 - here what we can do is we can simply
170:39 - pattern match for the list so we can
170:41 - take the head and we can also take the
170:44 - tail and for each iteration we have to
170:47 - call the same function back now let us
170:49 - see how we can pass the arguments for
170:51 - our tail recursive function first let us
170:54 - write the r argument for our accumulator
170:57 - so if we go back to our diagram so here
171:00 - what we want to do is we want to take
171:02 - the head and we want to insert the head
171:04 - inside our accumulator
171:07 - so that's what we can do over here so we
171:09 - simply won't take the head and we want
171:12 - to add the head to our accumulator now
171:15 - let us again go back to the diagram now
171:17 - since we have taken out one our list for
171:20 - the next iteration should be 2 and 3 and
171:23 - we can very easily do that
171:25 - so for the next iteration we simply have
171:28 - to pass the tail back and that's it we
171:31 - have a very nice pale recursive program
171:33 - to reverse our list so let us try this
171:35 - program inside our IEX so let me open up
171:38 - my terminal let me go inside my IEX
171:41 - now here let me clear up my screen and I
171:44 - can say that I want to go from my model
171:46 - of tutorials to my list and I want to
171:49 - reverse and let us pass the argument of
171:52 - one two and three and as expected we get
171:55 - back the answer as 3 2 and 1. now the
171:59 - last thing inside this video is let us
172:01 - also write the specifications for this
172:04 - function here we can use the module
172:06 - attribute for our specifications and we
172:09 - can say that our function of reverse now
172:12 - here we can say that elements is
172:14 - actually going to be a list and since we
172:17 - don't know what type of elements would
172:19 - be there inside the list we can say that
172:21 - they can be of any type and the same
172:23 - thing goes for our accumulator as well
172:25 - here let me show you one more alternate
172:28 - syntax so instead of writing list we can
172:30 - simply write a list like this and inside
172:33 - the list we can specify that this list
172:35 - can hold any kind of elements and again
172:38 - for the return type we can say that the
172:40 - return type is also list and this list
172:43 - can hold anything so we can specify any
172:46 - right over here and just for the sake of
172:48 - consistency let me convert this as well
172:50 - so let me put square brackets we don't
172:53 - need this and that's it for this video
172:55 - I'll catch you in the next one
172:58 - next let us see how we can implement the
173:00 - map function but first let me show you
173:03 - what do I mean to say
173:05 - so here let us see the documentation so
173:08 - I want to go to my model of enum and I
173:12 - want to see the documentation of map
173:15 - so as you can see over here so this map
173:18 - function this takes a list of elements
173:21 - and it also takes a function and what
173:24 - does it do for each iteration it simply
173:28 - applies this function to the element so
173:31 - for example we can see that the first
173:33 - element is 1 and this function is taking
173:36 - one and it is giving back 1 multiplied
173:39 - by two that's why we have the answer of
173:42 - 2 over here now we move to the next
173:44 - element the next element is 2 so 2
173:47 - multiplied by 2 we get a 4 the next one
173:50 - is three three multiplied by 2 so we get
173:53 - a 6 right over here and we have one more
173:55 - example right over here so in this case
173:58 - this is a keyword list and what this
174:01 - function is doing it is pattern matching
174:03 - on the key envelope Paris and it is
174:05 - simply changing the value from a
174:07 - positive to a negative number so for the
174:10 - first iteration your key is the item of
174:13 - a and the value is is 1 and what this
174:16 - function is doing it is returning back a
174:19 - negative value so we have minus 1 right
174:22 - over here for the next iteration the key
174:24 - is the item of B and the value is 2 and
174:28 - here we are simply flipping the sign so
174:30 - that's why we get minus 2 right over
174:33 - here so let us see how we can implement
174:35 - this function by using our list so let
174:37 - us go back to our code editor and here
174:40 - let us create a new function called as
174:43 - map and let us see how we can implement
174:45 - this functionality so this function is
174:48 - going to accept three parameters the
174:51 - first is for our elements the second one
174:53 - is for the function and the third one is
174:57 - obviously our accumulator and also let
174:59 - us set the accumulator to be a blank
175:01 - list
175:02 - now before we can go ahead I wanted to
175:05 - show you one more thing all of these
175:07 - functions that we are defining inside
175:09 - the module so this function of sum of
175:12 - some simple sum of tail recursive
175:14 - reverse all of these functions are
175:17 - called as named functions and they're
175:20 - called name functions because all of
175:22 - these functions belong to a module and
175:25 - in our case the model is called as
175:27 - tutorials.list but in case for this
175:30 - function of map we are passing an
175:33 - anonymous function so this function does
175:36 - not belong to any module so let us see
175:38 - how we can work with our Anonymous
175:40 - functions as well so what we can do is
175:42 - either we can create an anonymous
175:44 - function right where we require or we
175:47 - can Define it separately as well so
175:49 - suppose we Define a function called as
175:51 - double and we can say that this is going
175:54 - to be a Anonymous function and this
175:57 - function accepts some element and it
176:00 - simply returns that element multiplied
176:02 - by 2
176:03 - now remember the syntax the opening is
176:06 - by FN that stands for your function the
176:09 - end happens with your end block right
176:11 - over here now in order to use this
176:13 - function we have to use a DOT notation
176:15 - so in order to invoke this function we
176:18 - can say that we want to invoke the
176:20 - anonymous function of double but if we
176:23 - want to pass the value of 2 and as you
176:25 - can see we have to use the dot notation
176:28 - since this is an anonymous function so
176:31 - keeping this thing in mind let us go
176:32 - back to our code editor so let me scroll
176:35 - down to our functional definition and
176:37 - here it is so as usual first let us
176:40 - think about the base case so let me just
176:42 - copy and paste so the base case would be
176:45 - in case the elements are blank that
176:48 - means it's just a blank list at that
176:50 - time we simply want to return back the
176:52 - accumulator so we can say do and our
176:55 - accumulator now here what happens is we
176:57 - don't need this argument and we can do
176:59 - one more thing since we are not using
177:01 - the function we can ignore it by using
177:04 - an underscore so what this underscore
177:06 - means is we simply want to ignore the
177:08 - value of function in our base case next
177:12 - let us have a look at our recursive case
177:14 - so let me again copy and paste here as
177:17 - usual let me pattern match on our head
177:19 - and our tail the next is our function
177:22 - and since this is a tail recursive
177:25 - function we have to call ourselves back
177:27 - each time so first let me ignore the
177:29 - first value I will come to this a little
177:31 - later now the next argument is for the
177:33 - function in and for each iteration we
177:36 - simply have to pass the function as it
177:38 - is we don't have to do anything with it
177:39 - now the third is where we collect our
177:42 - accumulator now inside the accumulator
177:44 - what do we want to do is we simply want
177:47 - to take this function and we want to
177:49 - apply this function on our head now
177:52 - remember that since this is an anonymous
177:54 - function we can use the dot syntax so we
177:57 - can say here first we want to take the
177:59 - function and use the dots and tags and
178:01 - we want to apply this function on our
178:03 - head and we simply want to append our
178:06 - accumulator at the back now let us come
178:08 - to the first argument now since we have
178:11 - used the head the only thing left is to
178:13 - pass the pail and that's it let me save
178:16 - the file and let us open up our IEX let
178:19 - us go inside our IX and let me clear up
178:22 - everything and let us try it out so we
178:24 - can see tutorials dot list dot map and
178:28 - we can say that our map is 1 2 and 3 and
178:31 - the function that phone to pass is the
178:34 - same one let us take the element and for
178:37 - each element let us simply multiply by 2
178:39 - don't forget the end and that's it and
178:43 - we get the answer back but as you can
178:46 - see the order is not right what has
178:49 - happened is we have reverse the list as
178:51 - well so this 3 is right over here so 3
178:53 - multiplied by 2 it should be 6 but in
178:56 - our case 6 is the first element and 2
178:59 - into 2 we have 4 over here and for the
179:01 - first element is one into two and we
179:04 - have 2 right over here but as you can
179:06 - see that this is not the right answer we
179:09 - have reversed the order of our elements
179:11 - as well so what we can do is first we
179:14 - can call our tutorials.list DOT reverse
179:18 - and inside this let us pass our map
179:21 - function let me just copy and paste it
179:24 - over here and now we can see that we
179:26 - have the right answer 2 4 and 6 but as
179:30 - you can see that this syntax can be
179:32 - confusing so let me introduce shows you
179:34 - the pipeline operator so let us paste
179:37 - the map function over here and we can
179:39 - see that we simply want to take the
179:41 - output of this map function and we want
179:45 - to pipe that output inside the new
179:47 - function and the new function is our
179:49 - tutorials dot list dot reverse now here
179:53 - we don't need to specify the arguments
179:55 - what happens is the pipeline operator
179:58 - since it takes the output of the
180:01 - previous statement and it simply passes
180:03 - that output inside our function as the
180:06 - first argument so let us press enter and
180:09 - let us see what's happening so as
180:11 - expected we get the right answer back 2
180:14 - 4 and 6. let me clear it up let us do
180:17 - some more so for example if you want to
180:19 - reverse the same list so we can invoke
180:22 - tutorials.list dot reverse and suppose
180:25 - in our case the list is one two three
180:27 - and four now instead of using this
180:31 - syntax what we can do is we can first
180:33 - take our our elements here we can use
180:36 - the pipe operator so we can say that I
180:39 - want you to take all of these elements
180:40 - and I want you to pass them to my
180:42 - tutorials dot list dot reverse so what
180:46 - happens is we can use this pipeline
180:48 - operator in case if we have multiple
180:51 - Transformations so let us use the same
180:53 - example one more time here let us create
180:57 - an anonymous function called as double
180:59 - and what we want to do is we simply want
181:02 - to take the element and we want to
181:04 - return that element multiplied by 2 and
181:07 - now let us see how we can use the
181:09 - pipeline operator so for example we have
181:11 - a list like this one two three and four
181:14 - and what we can do is we can take this
181:17 - elements and we can pipe this elements
181:19 - to our function of tutorials dot list
181:22 - dot map now remember that the function
181:25 - of map accepts two parameters elements
181:28 - and the function now here what happens
181:31 - is since we are using the pipeline
181:33 - operator this elements are passed
181:36 - automatically to the function of map and
181:39 - the pipeline operator always passes
181:41 - these elements as the first argument so
181:44 - since we have the first argument we
181:46 - simply have to pass the second argument
181:48 - so here we can say that we want to pass
181:50 - the anonymous function called as double
181:53 - and for the accumulator we don't have to
181:55 - pass any value because the default value
181:57 - for the accumulator is an empty list so
182:00 - let us see the output of this one so we
182:03 - get the output of 8 6 4 and 2. now what
182:06 - we can do is we can take the exact same
182:08 - expression and we can find the output of
182:11 - the map function to our reverse function
182:13 - so we can use
182:15 - tutorials.list dot reverse and this time
182:18 - we get the expected answer as 2 4 6 and
182:21 - 8. now instead of using the list dot
182:23 - reverse in fact we can use the inbuilt
182:26 - module so if we go to the model of enum
182:29 - so here we can say that we want to pipe
182:31 - the output into enum Dot reverse and we
182:35 - get the exact same answer back so
182:38 - instead of using our defined function we
182:40 - can use the inbuilt function as well so
182:43 - as you can see that this pipeline
182:45 - operator is very handy whenever we want
182:47 - to do multiple Transformations so let us
182:50 - go back to our function of map and what
182:53 - we want to do is this accumulator has to
182:56 - be piped to our function of reverse and
182:59 - that's it now if we open up our terminal
183:01 - let us recompile
183:03 - tutorials.list let us clear up
183:06 - everything and this time if I have a
183:09 - list of one two three and four and if I
183:12 - just type this list to tutorials.list
183:15 - dot map and let us pass an anonymous
183:19 - function so we can say let us take that
183:21 - element and let us multiply that element
183:23 - by 3 this time and that's it we get the
183:27 - right output back now again coming back
183:29 - to our code editor either you can use
183:32 - this pipeline operator or you can use
183:34 - the conversion syntax so you can simply
183:36 - call the function of remote first pass
183:38 - the element of accumulator and let me
183:41 - take out this one let us also see how to
183:43 - write the specifications for this
183:45 - function so let us use the model
183:47 - attribute of specifications for the
183:50 - function of map now the first parameter
183:53 - elements is going to be a list and the
183:56 - type can be of anything so anything goes
183:59 - over here the next is a function now in
184:02 - order to denote that this is a function
184:04 - we can use brackets over here and here
184:06 - we can say that this function accepts an
184:09 - input the input can be of any type then
184:12 - it transforms that value and it also
184:15 - gives back some kind of a value back so
184:18 - this is how we can Define the function
184:20 - type the next one is for the accumulator
184:22 - and again accumulator is going to be a
184:24 - list of any now the return type is also
184:27 - going to be our list of any well that's
184:30 - it for this one and I will catch you in
184:32 - the next video now let us see how we can
184:35 - concat or how we can add two lists
184:37 - together the
184:38 - so first let me show you inside the
184:41 - terminal so suppose we have one list
184:44 - like this one two and three and we want
184:47 - to add one more list now in order to add
184:50 - our concat we have to use the double
184:52 - plus and the next list would be 4 5 and
184:56 - 6.
184:58 - and here we get the combined list back
185:00 - so let us see how we can write a concat
185:03 - function to do exactly this now in order
185:06 - to add or concat we have two lists so
185:09 - for example the first list is one two
185:11 - and three and we have one more list four
185:15 - five and six so essentially what we want
185:18 - to do is we want to take the last
185:20 - element and we want to insert that last
185:23 - element at the head of the next list but
185:26 - taking the last element is not efficient
185:29 - because we have to Traverse through the
185:31 - entire list and then go to the last
185:33 - element so what we can do is we can
185:35 - simply reverse the first list so the
185:38 - first list becomes something like this 3
185:40 - 2 and 1 and for each iteration we simply
185:44 - have to take out the head and insert it
185:47 - at the head position for our list number
185:49 - two as well so for the first iteration
185:51 - we insert three for the next iteration
185:54 - we insert two and for the last one we
185:56 - insert one and and by the time we insert
185:59 - one this list becomes an empty list so
186:02 - this is how we are going to implement
186:04 - our concat function so let's define the
186:07 - function right over here so we can say
186:09 - Define concat now this function accepts
186:12 - two arguments we can call the first list
186:14 - as our source the second list can be our
186:17 - destination now for this function we
186:20 - don't need an accumulator the second
186:22 - list itself acts like an accumulator so
186:26 - here what I'm going to do is I am going
186:28 - to write an auxiliary function so first
186:30 - let us write the function and then we
186:32 - can Define it so we can simply call the
186:34 - auxiliary function as concat underscore
186:37 - function now remember as I just said a
186:40 - couple of minutes back first we have to
186:42 - reverse this list and we can do that
186:44 - right inside our function definition so
186:47 - here we can say that let us take the
186:49 - source list and we simply want to pipe
186:52 - it to our function of reverse the next
186:55 - is our destination list and we want our
186:58 - destination list as it is so now we can
187:01 - go ahead and Define this auxiliary
187:02 - function so here we can say that we want
187:05 - to create a function called as concat
187:07 - func this accepts two parameter the
187:10 - first list called as Source the second
187:12 - list called as destination now here as
187:16 - our base case we can simply pattern
187:18 - match on our source so in case the
187:21 - source is blank at that time we simply
187:23 - want to return back our destination the
187:27 - next let us see how we can Define the
187:29 - recursive case so we can say we want to
187:31 - Define concat one more time and here we
187:35 - can simply pattern match on the first
187:36 - list so for the first list we can
187:39 - pattern match on the head and for the
187:42 - tail the second parameter is for our
187:44 - destination list and let us see how we
187:47 - can Define the logic for this one now
187:49 - for each iteration we want to call
187:51 - ourselves back right here first let us
187:55 - Define the second parameter so for each
187:58 - relation what we want to do is we simply
188:00 - want to take the head and we want to
188:03 - append our destination list to this one
188:06 - now the last thing to do is we simply
188:08 - have to pass the tail for our first
188:10 - argument so let me open up my terminal
188:13 - let me go inside my IEX and let me clear
188:17 - up everything now here we can see that
188:19 - we want to go to tutorials dot list dot
188:23 - concat now the first list would be one
188:26 - two and three the second list would be 4
188:29 - 5 and 6 and that's it we get back in the
188:33 - desired output the last thing to do is
188:35 - we simply want to add our type
188:37 - specification so let me take out the
188:40 - command I don't need the comment and
188:42 - here we can use the model attribute of
188:44 - specifications for our function of
188:46 - concat the first parameter is a list and
188:50 - the elements are any the next parameter
188:53 - is also list and the elements are of any
188:56 - type and this gives back a list and the
188:59 - types are any next coming to our helper
189:03 - function of concat underscore func now
189:06 - this function is intended only for
189:08 - internal use so what we can do is we can
189:11 - Define the auxiliary function to be
189:13 - private so here instead of just writing
189:15 - def we can write Def and P that means
189:18 - that this is going to be a private
189:20 - function and that's it let's have a look
189:23 - at the last function inside our list and
189:25 - this function is called as flat map now
189:28 - to be frank I was slightly confused
189:30 - should I include this function in this
189:32 - series or not then I thought okay why
189:34 - not let me add this one and let us see
189:37 - how it goes so first let me show you
189:39 - what do I mean by a flat map so let us
189:41 - go back to our terminal and here let us
189:44 - see the documentation for our inner
189:46 - module and the flat map function so what
189:49 - this function does is it accepts an enum
189:52 - and it also accepts one function now
189:55 - flat map is all about the combination of
189:58 - your two functions that is it's a
190:00 - combination of your map and concat and
190:03 - here we have one more example as well so
190:05 - we get an input as a list so during the
190:08 - first iteration we get an item of a and
190:11 - we give back list of a and a but if you
190:14 - see right over here we don't have a list
190:16 - of a we don't have a separate list for B
190:18 - and we don't have a separate list of c
190:21 - and that's because we have flat and the
190:23 - entire list so let us see how we can do
190:26 - this by using our recursive functions
190:28 - now you must be thinking why are we
190:30 - implementing so many functions which are
190:32 - already there inside the standard
190:34 - Library so the answer is I want you to
190:36 - really get comfortable with the
190:37 - recursion and from the next video we
190:39 - will see how we can use all of the
190:41 - inbuilt modules but for this last one
190:44 - let us see how we can implement this
190:46 - functionality by using our tail
190:48 - recursive function so let us go back to
190:51 - our code editor and here let us create a
190:54 - function called as flat map so we can
190:57 - say Define my flat map so this function
191:00 - accepts two parameters so if you go back
191:02 - to the documentation we can see that
191:04 - this accepts two parameters the first
191:06 - argument is for the elements the second
191:08 - argument is for the function so let us
191:11 - do the same thing here we can say that
191:13 - the first argument is for the elements
191:16 - the second argument is for a function
191:18 - now we also need one more argument for
191:21 - our accumulator
191:22 - because what we want to do is we want to
191:25 - collect the output inside our
191:26 - accumulator
191:28 - so here we can say that we also want to
191:30 - have an accumulator and we want to have
191:32 - the default value of an empty list as
191:35 - well now let me copy and paste now let
191:38 - us think of our base case so the base
191:40 - case is very simple in case the elements
191:43 - is a bank list at that time we don't
191:46 - need this function so either you can put
191:48 - an underscore over here or you can
191:50 - simply replace the entire function with
191:52 - just an underscore both of them are
191:54 - valid syntax and in this case we simply
191:57 - want to return back the accumulator as
192:00 - it is now let us copy and paste one more
192:02 - time and this is going to be our
192:04 - recursive case now in this case we need
192:07 - our function as well and for the first
192:09 - argument let us pattern match on our
192:11 - head and our tail and for each iteration
192:15 - we want to call ourselves back so let us
192:17 - call the flat map back now as you know
192:20 - the first argument should be our tail
192:21 - because for each iteration we want to
192:24 - take out the head so the first argument
192:25 - becomes the tail the second argument is
192:28 - we want to pass the function as it is we
192:30 - don't want to change the function now
192:32 - let us see what we can pass as our third
192:35 - argument now if you go back to our
192:37 - documentation it is clearly saying that
192:39 - this is a combination of our map and
192:42 - concat so let's not use our brain and
192:45 - let's follow exactly what these guys are
192:47 - seeing
192:48 - so here what we want to do is we simply
192:50 - want to concat and the first argument
192:53 - for our contact function is going to be
192:55 - our accumulator and for the second
192:57 - function we want to apply this Anonymous
193:01 - function on the head now remember since
193:04 - function is an anonymous function we can
193:06 - invoke it by using the dot operator so
193:09 - we can say function Dot and let us pass
193:12 - head to this one and that's it we have
193:15 - implemented the flat map function now
193:17 - let me open up my terminal let us
193:20 - recompile the model of tutorials dot
193:22 - list let me clear up the screen and
193:25 - let's do one thing let us go over here
193:27 - and let me copy all of these things
193:30 - now here inside our terminal we can say
193:32 - that from tutorials dot list dot flat
193:36 - map and it has passed arguments and now
193:39 - let us try and compare the output so
193:41 - here we have the output which is exactly
193:44 - the same as right over here so that
193:47 - brings us to the end of this section for
193:49 - the list now what we have done for this
193:51 - section is we have implemented a lot of
193:53 - functions from the standard Library by
193:55 - using field recursion from the next
193:58 - video instead of writing all of these
194:00 - functions by hand we will try and use
194:02 - the functions from the standard library
194:04 - but for now that's it and I will catch
194:06 - you in the next one hi and
194:08 - congratulations for making it so far so
194:11 - till now we have seen a lot of recursion
194:13 - specifically we have seen a lot of tail
194:16 - regression now the whole idea of showing
194:19 - you so much of Education was I wanted
194:21 - you to get used to the idea of recursion
194:24 - and how we can use functional
194:25 - programming but moving forward instead
194:28 - of writing all of the functions
194:29 - ourselves we will use the functions from
194:32 - the standard library now Alexa ships
194:35 - with a lot of inbuilt functions and you
194:38 - can find these functions inside modules
194:40 - such as enum then we have separate model
194:42 - for your list and keyword list and so on
194:45 - so that's what we will see so the next
194:48 - section is all about your data
194:50 - Transformations how we can use all of
194:51 - these functions and how we can browse
194:54 - some data to get our desired outputs so
194:57 - I will catch you right in the next video
194:58 - till then bye now let us see how we can
195:01 - start working with our struts and the
195:04 - inbuilt modules so the first thing which
195:06 - I want to do is let us create a new
195:08 - folder inside our lib and we can call
195:11 - that folder as structs and inside of
195:14 - this folder let me create one more file
195:17 - by the name of Seven Wonders let me
195:20 - collapse my sidebar and let us see what
195:22 - we can do with this struct the first
195:24 - thing as usual we need to Define our
195:26 - module so this would be our tutorials
195:29 - Dot
195:31 - structs.7 vendors so let us create a
195:34 - struct by using the keyword of Dev
195:36 - struct here we need to specify the
195:38 - fields for our struct so we can say that
195:40 - the first field would be the name of the
195:43 - Seven Wonders and the second field would
195:45 - be the country of that seven Wonder now
195:49 - we can do one slight Improvement we can
195:51 - also initialize the values right over
195:53 - here and instead of just passing a
195:56 - normal list we can pass a keyword list
195:58 - so here we can say that the default
196:01 - value of name should be a blank string
196:05 - and the same thing happens for the
196:07 - country as well so in case the argument
196:09 - is not given we want to initialize the
196:12 - country to be a blank string now let us
196:15 - see how we can also Define the type
196:17 - specifications for our struct now for
196:19 - defining the type of our struct we have
196:21 - to use the keyword of type so let's
196:24 - define a typewrite over here and let us
196:27 - call type as T so this is more like your
196:29 - community attention your T stands just
196:32 - for your type and here we can specify
196:34 - that we want to specify that 5 for our
196:37 - tutorials dot structs dot Seven Wonders
196:42 - now remember that this track always
196:44 - takes the name of the module and in this
196:47 - case the name of our module is
196:50 - tutorials.structs.7 vendors so by
196:52 - default that's going to be the name of
196:54 - our struct and since this is a struct
196:56 - let us use the right syntax so we need
196:58 - to put our percent symbol over here and
197:00 - our curly brackets so now we have a
197:03 - struct now what we can do is typing such
197:05 - a long name can be boring so we can
197:08 - simply Alias this so let's create an
197:10 - alias at the top so we can say we simply
197:13 - want to create an alias and here we can
197:16 - simply take out all of these things now
197:19 - inside the curly brackets let us Define
197:20 - the pipes for the various Fields so the
197:24 - first field inside our struct of 7
197:25 - Wonders is for the name and here we can
197:28 - Define the type to be of string so we
197:31 - can say string dot P so the type of
197:35 - string the next one we have for the
197:37 - country and again the country is going
197:39 - to be of the type of string so this is
197:42 - how you define the type specifications
197:44 - for your struct next let us do one more
197:47 - thing Let Us create a list of all of the
197:50 - seven vendors so for this let us create
197:52 - a simple function called let's all so
197:55 - this function does not take anything and
197:57 - this returns your list now inside this
198:01 - list let us initialize all of the Seven
198:03 - Wonders so we can say that the first
198:05 - seven Wonder would be Taj Mahal so since
198:09 - I am from India the first one has to be
198:11 - Taj Mahal and we can say the country is
198:13 - going to be India and let me just copy
198:15 - and paste all of the remaining six
198:17 - wonders so now we have a nice list of
198:20 - all of the Seven Wonders of the World
198:22 - next let us see how we can also write
198:24 - the type specifications for this new
198:26 - function so here we can use the model
198:28 - attribute of our specification things
198:31 - and we want to define the specifications
198:32 - for the function of all now since this
198:35 - function does not accept any parameters
198:37 - you can use the brackets or you can skip
198:39 - them and here we can also Define the
198:42 - return type now the return type is a
198:44 - list and the elements are of the type of
198:47 - P so right over here we have defined the
198:49 - type of T and we have specified the
198:51 - different parameters for our struct and
198:53 - that's what we are referencing right
198:55 - over here let me put a separator line
198:57 - over here let's scroll a little bit down
199:00 - and let us see how we can start working
199:03 - with our Seven Wonders so here let us do
199:05 - one thing let us Define a function
199:07 - called as print names so what this
199:10 - function will do is it will accept all
199:12 - of the vendors and it will simply print
199:15 - out the names of the vendors so for
199:17 - example if we see we have different
199:19 - names so we have the Taj Mahal Petra
199:21 - price the Redeemer and so on so what I
199:24 - want you to do for this function is so
199:26 - this function is going to accept this
199:28 - list right over here and for the output
199:30 - which just want to see the names and
199:32 - that's it so let us see how we can
199:34 - implement this function now this time
199:37 - instead of writing functions of a self
199:39 - let us see how we can use the standard
199:41 - Library
199:42 - so let me open up my terminal and here
199:45 - the first model that you would like to
199:47 - check is the model of enum so what I can
199:50 - do is let us call help and let us see
199:53 - what are the different functions inside
199:55 - the module of enum so if I put a dot and
199:58 - if I press Tab and we can see that this
200:01 - inbuilt module has a lot of inbuilt
200:04 - functions now I want to see the
200:06 - documentation of a very specific
200:08 - function and that is this one for each
200:11 - so here let me call the help on enum.h
200:15 - so this function of each accepts two
200:17 - parameters the first parameter is for an
200:20 - enum and the second one is for the
200:23 - function and we also have a sample
200:25 - implementation so here we can see that
200:27 - the first parameter is a list and we
200:31 - have a simple function so what's
200:33 - happening is for each iteration this
200:36 - function receives an element from the
200:38 - list so for the first iteration your X
200:41 - is the string of sum and what this
200:44 - function is doing it is simply printing
200:46 - it out that's why we have the output of
200:48 - sum for the second iteration your X
200:51 - becomes example and that is what is
200:54 - being printed out right over here so let
200:56 - us see how we can use this inbuilt
200:58 - function for printing out all of the
201:00 - names for our Seven Wonders so let us go
201:03 - back to our code editor and here what we
201:05 - can do is we can use the same function
201:07 - we can say enum dot each now our enum is
201:11 - going to be our list of our wonders next
201:14 - let us Define our function and for the
201:17 - function for each iteration we are going
201:19 - to receive one Wonder from our list of
201:22 - vendors so for each iteration what's
201:25 - going to happen is we are going to
201:27 - receive a wonder and we have to do
201:29 - something with the Wonder and this is
201:31 - the end block for our function now since
201:33 - we just want to print the name of our
201:36 - Wonder we can actually pattern match
201:38 - right over here now we know that this
201:41 - vendor is going to be thus extract of
201:43 - Seven Wonders and we can easily patent
201:46 - match on our structs by using our map
201:48 - syntax so let's do the pattern match
201:51 - right over here so here we can say that
201:53 - for each iteration we want to pattern
201:55 - match and we want to pattern match on
201:57 - the parameter of name and we want to
202:00 - collect the name inside a variable
202:01 - called as name and for each iteration we
202:05 - simply want to print it out and let us
202:08 - put the variable of name right here and
202:10 - that's it let us open up our terminal
202:13 - let me go inside my IX now let me create
202:16 - an alias for our tutorials not structs
202:20 - DOT 7 vendors let me clear up everything
202:23 - and here we can say that the list of all
202:27 - our vendors is our Seven Wonders and
202:31 - remember we have defined a function of
202:33 - all so now we have all of the vendors
202:35 - let me clear up one more time and next
202:38 - what we can do is we can again use the
202:40 - same model of seven vendors and let us
202:43 - print out the names so this function
202:45 - takes one argument and that is the list
202:48 - of all our wonders and that's it now we
202:51 - can see that we have the right output
202:53 - and we get back just the names of all of
202:56 - our seven vendors let us go back to the
202:58 - code editor and let us also Define the
203:00 - type specification for this function so
203:03 - here we can say that the specifications
203:05 - for our function of print names so the
203:08 - first argument is the list of all of our
203:11 - vendors so we can say that this is a
203:13 - list and the type is the type of key
203:16 - that we have defined now since this
203:18 - function is not returning anything we
203:20 - can say that this simply returns an item
203:22 - of okay also if you want you can also
203:25 - use the pipeline operator so what I can
203:28 - do let me take this one out let me put
203:31 - it on this line and on the next line let
203:33 - me use the pipeline operator so by
203:36 - default our list of vendors is being
203:38 - passed as the first argument for the
203:40 - function of enum dot each let me save
203:43 - this one let me open up my terminal let
203:46 - me again recompile everything let us try
203:49 - to run the same function one more time
203:52 - and as expected we get the right answer
203:54 - back next let us see how we can filter a
203:57 - single seven vendor from our list so
204:00 - here let us create a new function and
204:02 - let me name the function as filter by
204:04 - country now this function will accept
204:07 - two parameters the first parameter is
204:09 - obviously the list of all our vendors
204:11 - and the second one is the name of our
204:14 - country for which we want to filter for
204:16 - so for example if the country is India
204:19 - then we should get back this single
204:22 - seven Wonder so let us see how we can
204:24 - implement this filter function here let
204:27 - me add my do and end blocks and let me
204:29 - take this a little up so again let us go
204:32 - back to our terminal and let us see if
204:34 - we can find a filter function inside our
204:36 - standard Library so again let me call
204:39 - the helper documentation from our model
204:41 - of enum and let us see if this model has
204:44 - a function of filter or not so here it
204:47 - is we have a function of filter so let
204:50 - us see the documentation of this
204:52 - function so this function of filter this
204:55 - accepts two different parameters the
204:57 - first is obviously our enum and second
204:59 - parameter is going to be a function and
205:01 - here we have a sample implementation
205:04 - so as we can see the first element is a
205:07 - list and the second argument is going to
205:09 - be a function now if we read the
205:11 - documentation it is saying that this
205:13 - function returns only those elements for
205:16 - which your function returns a truth
205:19 - value so let's see what's happening
205:21 - inside this example so here they have a
205:24 - condition and whenever this condition
205:26 - evaluates to True only that value is
205:29 - returned so here we have a list of 1 2
205:31 - and 3 and this condition is only
205:34 - satisfied for the element of 2 and
205:37 - that's why we get back a list along with
205:39 - a single element of 2. so let's see how
205:41 - we can use this inbuilt function for
205:43 - filtering by the name of our country so
205:46 - here we can take the list of our vendors
205:48 - and then we can pipe this argument to
205:52 - our enum dot filter now again by default
205:55 - the first argument of Wonders would be
205:57 - passed and we simply need to pass the
205:59 - second argument for our function this
206:02 - function receives a wonderful each
206:05 - iteration so this is how it's going to
206:07 - look like and here we need to specify a
206:09 - condition that will evaluate toward true
206:11 - so here what we can do is we can again
206:14 - pattern match on this struct of seven
206:16 - vendors so let's do that thing and this
206:19 - time we simply want to extract the name
206:21 - of the country so let us pattern match
206:24 - on the field of country and let us
206:26 - collect the data inside a variable
206:28 - called as country name now next coming
206:31 - to our truth condition here we can say
206:34 - that we want to filter it out only when
206:37 - the country name is equal to the name of
206:40 - the country so this parameter country is
206:42 - what is being passed to our function
206:45 - right over here and this parameter of
206:47 - country name is what we are extracting
206:49 - by using our pattern match right over
206:51 - here so let me save the file let us open
206:54 - up our terminal and let us recompile the
206:57 - model of Seven Wonders
207:00 - next what we can do is we can say we
207:02 - want to use Seven Wonders dot filter by
207:05 - country let us pass all of the Wonders
207:08 - and next let us pass India and let us
207:11 - see what output we are getting and as
207:13 - expected we can see that we are getting
207:15 - the right answer back let us try one
207:18 - more time and let us try with Mexico and
207:21 - again we are getting the right answer
207:23 - back so again let us go back right over
207:25 - here and let us write the type
207:27 - specifications so the specifications for
207:30 - our filter by country the first argument
207:33 - is the list of the type of seven vendors
207:36 - the second argument is of the type of
207:39 - string and the return type is the list
207:43 - and this contains a single type well
207:46 - that's it for this video in the next
207:48 - video we will continue with the
207:50 - different functions on our structs so
207:52 - let us continue with our structs and
207:55 - behind the scenes what I've done is I
207:56 - have added a couple of functions and let
207:58 - us see how we can Implement all of these
208:01 - functions
208:02 - so the first function that you can see
208:04 - over here so this function is also about
208:06 - filtering and we simply want to filter
208:09 - out the seven wonders for which the
208:12 - countries start with I so let us see how
208:14 - we can do this one let me copy this one
208:17 - and let me paste it right over here let
208:21 - me take all of these things a little up
208:23 - so in this case our truth function will
208:26 - change and we simply want to compare the
208:28 - values and check if the name of the
208:30 - country starts with I or not so let me
208:33 - take this one out and this time we can
208:35 - rename the variable from country name to
208:38 - just country and let us see how we can
208:40 - compare the first alphabet of our string
208:43 - with i for this let us use another
208:45 - module and the name of the module is
208:48 - going to be string and this model has a
208:51 - very convenient function of starts with
208:54 - now if I hover over the function
208:55 - definition we can see that this function
208:58 - accepts two different parameters so they
209:00 - have one example over here Alexa and Eli
209:03 - so in this case Elixir starts with Eli
209:06 - that's why we get the answer as true so
209:09 - the first argument would be our country
209:11 - and the second argument would be I so
209:15 - let me open up the terminal again let me
209:18 - recompile our model of Seven Wonders let
209:21 - me clear up everything now let's invoke
209:24 - the function so we can say Seven Wonders
209:26 - dot countries which start with i and let
209:29 - us pass all of the Wonders to this one
209:32 - and as expected we get two wonders back
209:35 - so the first one is Made in India the
209:37 - second one is made in Italy the next
209:40 - function is sort by country length oh
209:43 - before moving on let us also add in the
209:45 - type specifications for this one so the
209:48 - specifications are pretty simple
209:50 - this one does is the list of our type of
209:53 - T and this also returns a list of type
209:58 - of T all right so now let us go to this
210:01 - sort function so this time what we want
210:03 - to do is we simply want to sort all of
210:05 - the Wonders by the length of the country
210:08 - name so let us see how we can do this
210:11 - one so if I go back to my terminal and
210:14 - let's check out for enum dot sort so we
210:18 - have a convenient function of sort
210:20 - inside the model of enum and as you can
210:22 - see it has a lot of documentation but I
210:25 - wanted to show you a couple of key
210:27 - parameters so this is the function of
210:29 - sort and this function accepts to
210:31 - parameter the first is the enum and the
210:34 - second one is unsorter now this sorter
210:38 - argument can be of multiple types so let
210:41 - us refer to the official specifications
210:43 - for this function and let us try and
210:45 - figure it out so the first is obviously
210:47 - your elements and now for the second
210:50 - argument of sort we can see that we can
210:52 - pass a multiple of arguments so what
210:55 - this specification is saying that either
210:57 - we can pass a function and this function
210:59 - receives two elements and this function
211:02 - has to written back a Boolean value or
211:05 - you can choose to pass this arguments as
211:07 - well now let us see how we can work with
211:09 - this one so this is a pretty simple
211:11 - function that we can pass to our enum
211:14 - dot sort so let us go back to our code
211:16 - editor
211:18 - let us again use the arguments of Wonder
211:20 - and let us pipe this one to our enum dot
211:24 - sort now here let us see how we can
211:26 - Define the sorter function so this is
211:29 - going to be your regular function now
211:31 - for each iteration this function is
211:33 - going to receive two different vendors
211:35 - so we can call them as X and Y and next
211:39 - for the body of the function we can
211:40 - simply say that we want to check for the
211:44 - length of the string for the first one
211:46 - and let's compare if this length is less
211:49 - than the length of the next Wonder so
211:53 - again we can use the same function
211:54 - string dot length and let us pass the
211:57 - variable of Y this time so what we have
211:59 - done is we have defined a function and
212:01 - for each iteration this function
212:03 - receives two different vendors and we
212:06 - are simply trying to compare the length
212:08 - of this wonders and that's it so let me
212:10 - save the file let me open up my terminal
212:12 - and let me again recompile the module
212:16 - let's try to Inver this function Seven
212:19 - Wonders dot sort by country length and
212:23 - let us pass all of our vendors
212:26 - oh we are getting an error and that's
212:28 - because here we are trying to find the
212:30 - length of the entire struct I forgot to
212:33 - specify the parameter that we want to
212:35 - check for the length of the name of the
212:37 - country the same thing goes for this
212:40 - struct as well so we want to check for
212:42 - the length of this country now let me
212:44 - save the file open up my terminal let me
212:48 - recompile one more time clear up the
212:51 - screen and let us try to invoke this
212:53 - function one more time so this time as
212:56 - you can see we have a nice sorted list
212:58 - so as you can see now the list is sorted
213:00 - according to the length of the country
213:02 - name so Peru this is four characters
213:05 - long so this is the first one next is
213:08 - China this is five characters again then
213:10 - we have Italy and India then we have
213:12 - Brazil and so on so as you can see we
213:16 - have a nicely sorted list so now let us
213:18 - go back and let us see what we want to
213:20 - do for the next one so for the next
213:22 - function of name country list so this
213:25 - function accepts our vendors and I want
213:28 - an output like this so the output has to
213:30 - be the list and inside the list we want
213:33 - another list the first element has to be
213:36 - the name of the seven wonder and the
213:38 - second name has to be the country so let
213:41 - us see how we can do this one so let me
213:43 - take out the comment I don't need the
213:45 - comments and before I show this one let
213:48 - me take you back to my terminal and let
213:51 - me clear up all of these things
213:53 - and this time let us check out the
213:55 - documentation for enum dot reduce now
213:58 - this function of reduce this is a very
214:00 - powerful function and in fact you can
214:03 - Implement all of the function inside the
214:05 - model of enum by just using this simple
214:08 - function so first let us see the
214:10 - function signature so this function of
214:13 - reduce accepts three parameters the
214:16 - first argument is for your enum the
214:18 - second argument is for accumulator and
214:21 - the third argument is for your function
214:23 - and we have one sample example right
214:26 - over here so the first argument is a
214:29 - list the second argument is for the
214:31 - accumulator and the third argument that
214:33 - you can see over here this is for a
214:35 - function now this function receives an
214:38 - element for each iteration and this
214:41 - function also receives the accumulator
214:43 - so for the first iteration since the
214:46 - accumulator is 0 this would be 0 and for
214:49 - the first iteration our X would be 1.
214:52 - now what happens with this function is
214:54 - that the result is passed as the
214:57 - accumulator for the next iteration
214:59 - so you can read the documentation over
215:01 - here so this is what is happening so for
215:04 - the second iteration whatever this
215:05 - evaluates to so this value will become
215:08 - your new accumulator so let us see this
215:11 - reduce function in action so let us go
215:13 - back to our code editor now let us see
215:16 - how we can work with our reduce function
215:18 - so we can say enum dot reduce the first
215:21 - argument is for our vendors the second
215:24 - argument is going to be our accumulator
215:26 - so as our initial accumulator let us
215:28 - just pass an empty list and the third
215:31 - one is going to be a function now let me
215:34 - do one thing let me take this one out
215:37 - and let us pipe into our enum dot reduce
215:41 - now for each iteration this function is
215:43 - going to receive two parameters the
215:46 - first parameter is going to be our
215:47 - vendor and the second parameter is going
215:50 - to be our accumulator so initially the
215:52 - accumulator is going to be a blank list
215:54 - and for each iteration what we want to
215:57 - do we simply want to create a list
215:59 - inside this list we need another list
216:02 - and inside this inner list the first
216:04 - argument would be the name of the vendor
216:07 - and second one would be the country of
216:09 - the Wonder so here we can say that from
216:11 - Wonder I simply want you to take the
216:14 - name and the second argument is going to
216:16 - be the country for this one and after
216:19 - this we simply want to append our
216:21 - accumulator back and that's it let me
216:24 - save my file let me open up my terminal
216:27 - let me recompile the module and let me
216:31 - clear up the screen let us invoke this
216:33 - function so we can say Seven Wonders dot
216:36 - name country list and let us pass all of
216:39 - the Wonders and as expected we get the
216:42 - answer back so here we can see the first
216:45 - argument is going to be the name of the
216:46 - Wonder followed by the name of the
216:49 - country now just to give you some more
216:52 - practice let us try and use this reduce
216:54 - function one more time so for this
216:57 - function right we are country name
216:58 - keyword list so this is what I want you
217:00 - to do so this function is going to
217:02 - accept our vendors and this is the
217:05 - output that I'm expecting so we want to
217:08 - have a list and inside the list we want
217:10 - to create our keyword list so as you can
217:13 - see this is going to be an atom and this
217:16 - is going to be the value so let me just
217:18 - copy all of these things let me copy
217:20 - this one and let me paste it right over
217:24 - here I don't need the comment let me
217:27 - take it out and let us see how we can
217:29 - work with this function now here what I
217:31 - want to do is we don't want an inner
217:34 - list instead what we want is a tuple so
217:37 - let me change this from a list to a
217:40 - tuple so let me explain why do I want a
217:43 - tuple so let me open up my terminal so
217:46 - for example if we have a keyword list
217:48 - like this a and one so this keyword list
217:52 - is actually saved as a list of our
217:54 - tuples so in case if I have to pattern
217:57 - match so on the left hand side let us
217:59 - create one more list and here if I
218:01 - create a tuple the first element is
218:04 - going to be the item of a the second
218:05 - element is going to be the value of 1.
218:08 - so let us see if this is a pattern match
218:10 - or not so yes this is a pattern match so
218:13 - what's happening is this keyword list is
218:16 - saved in this format I think I have
218:18 - covered this while explaining keyword
218:20 - list as well so this is a small recap
218:22 - for you so this is the same logic that
218:25 - we are using over here so that's why we
218:27 - want to have a tuple and not an inner
218:29 - list now the first element has to be an
218:32 - atom so what I can do is let me grab
218:35 - this inside and we can convert this
218:37 - string to an atom by using our string
218:40 - dot to atom and that's it now let me
218:44 - open up my terminal again let us
218:46 - recompile our module and let me clear up
218:49 - the screen and let us try to invoke this
218:52 - functions Seven Wonders dot country name
218:55 - keyword list and let us pass the
218:58 - arguments of all vendors so the system
219:00 - as you can see that the first argument
219:02 - is going to be our atom and the value is
219:05 - going to be the name of the country now
219:08 - before going to the last function I
219:10 - wanted to show you a couple of things so
219:12 - again let me open up my terminal
219:14 - let me clear up all of those things so
219:17 - in case if you want to make a list of
219:19 - just the names of the Wonders we can use
219:22 - multiple modules so let me show you one
219:24 - more alternate method so we can say enum
219:27 - dot map and the first argument is going
219:30 - to be our argument of all of our vendors
219:33 - and what we can do is we can simply
219:36 - invoke a function so this function
219:38 - receives a Wonder each time and what we
219:41 - want to do is we simply want to return
219:42 - the name of the Wonder and we get back a
219:46 - list of all of the names now what we can
219:48 - do is Alexa actually offers a shorthand
219:51 - syntax so what we can do is we can
219:54 - change this function to a short and
219:56 - syntax so we can say that we want to
219:59 - send a reference to an anonymous
220:01 - function and this function is going to
220:03 - receive a parameter so we can say for
220:05 - the first parameter we simply want to
220:08 - return the name back and that's it so
220:10 - this is the shorthand syntax and we get
220:13 - the exact same answer attack so if you
220:16 - are comfortable you can use the short
220:17 - and syntax or else you can use the
220:20 - regular syntax now for the last part of
220:22 - this video I wanted to show you the four
220:24 - comprehensions inside Elixir we can get
220:27 - the exact same output by using the four
220:30 - comprehensions so we can say four and
220:32 - here we can say that for each iteration
220:35 - we simply want to pattern match and we
220:38 - want to extract the name inside the
220:40 - variable of name and we want to extract
220:42 - this from our list of all of the vendors
220:45 - and for each iteration I simply want to
220:48 - return back the name of the Wonder and
220:51 - that's it we get back the exact same
220:53 - result now this syntax is slightly weird
220:57 - so what we are trying to do is we are
220:59 - trying to say that for each element out
221:02 - of this enum we want to pattern match
221:04 - and we want to pattern match on name and
221:07 - for each iteration we simply want to
221:09 - return the name back so you can use any
221:12 - of the syntax with which you feel more
221:14 - comfortable now let me just copy this
221:17 - one and let me go back to my code editor
221:20 - so for this one let us use the for
221:22 - comprehension let me paste it right over
221:25 - here we also need to pass an argument to
221:28 - the function so this argument becomes
221:30 - for our vendors and this also has to
221:33 - change to wonders now let me open up my
221:36 - terminal let me recompile the module and
221:40 - let me clear up this one and let us try
221:42 - to run this one so Seven Wonders dot all
221:45 - names oh I forgot to pass the arguments
221:49 - so all names and the argument is all
221:52 - wonders and we get back the exact same
221:56 - answer well that's it for this video and
221:58 - I will catch you in the next one
222:00 - let us have some more practice with our
222:02 - struts so what I've done is behind the
222:05 - scenes I've created a new file called as
222:07 - expense and let us get started with this
222:10 - one so first as usual let us create our
222:13 - module and let me call this module as
222:17 - tutorials.structs dot expense
222:20 - now just imagine that we are creating an
222:23 - application to manage our expenses so
222:26 - let us Define a struct to hold our
222:28 - expenses so we can say that we want to
222:31 - define a struct and since this struct is
222:34 - going to have multiple Fields let me
222:36 - take them on different lines so the
222:39 - first field would be for the title of
222:41 - our expense and we can initialize the
222:43 - title to be a blank string the second
222:46 - one would be the date of our expense
222:48 - initially we can keep it as nil the next
222:52 - one would be the amount of our expense
222:54 - and let us initialize the amount to be 0
222:57 - the next one can be the store from which
223:00 - we did the purchase and let us
223:01 - initialize the store to be also a blank
223:04 - string now let us also Define the types
223:07 - for our struct so first let me create an
223:10 - alias so I want to create an alias for
223:13 - my tutorials dot structs dot expense and
223:18 - here let us Define the type for this one
223:21 - so we can say that type of t for our
223:25 - struct of our expense
223:28 - the first field for title so this is
223:30 - going to be of the type of string the
223:34 - second one is date for this we can
223:37 - specify that the type is going to be of
223:40 - the type of date or it can also be nil
223:44 - the next one is for our amount so this
223:47 - is going to be a number and next one is
223:50 - for the store this is going to be of the
223:53 - type of string
223:55 - so now we have the type specification in
223:58 - place
223:59 - now let us see how we can work with our
224:01 - expense struct first let me create a
224:04 - couple of sample expenses so let me
224:06 - Define so let me Define a function
224:08 - called as sample so this function will
224:11 - simply return a couple of our expenses
224:14 - let us create an expense right over here
224:16 - so we can say that we want to create an
224:18 - expense now for the title we can say
224:21 - that we got some grocery
224:24 - the next field is for the date now the
224:28 - type of this has to be a date so for
224:31 - this let me go to my terminal and here
224:33 - let me show you how we can create a date
224:35 - so Elixir has a model for date so we can
224:39 - use that module so let me show you so
224:41 - let us check the documentation for that
224:43 - module so we can say we want to see the
224:46 - helper documentation of date dot new
224:50 - so as you can see this function of new
224:52 - this accepts a year month and day so let
224:56 - us try this one
224:57 - so let me clear up everything so here we
225:01 - can create a new date so we can say date
225:03 - dot new the first argument was for the
225:07 - year so we can say 2023 the next
225:09 - argument was for the month so we can say
225:12 - for April and for the day we can say the
225:16 - 1st of April
225:18 - and that's it we get back a date but as
225:21 - you can see we get back a couple back so
225:24 - let us pattern match and let us extract
225:26 - the date so what we can do is just on
225:29 - the left hand side let me pattern match
225:31 - so the first element would be the item
225:33 - of okay and let us create a variable for
225:36 - the date
225:37 - and let us just check out the contents
225:40 - update
225:41 - so that's it we have a new date
225:43 - now the syntax that you can see over
225:45 - here this Sigel and D this also denotes
225:48 - a date and in fact we can use this
225:50 - syntax to create a new date we don't
225:52 - have to always invoke the function of
225:54 - date dot new so what we can do is we can
225:57 - create a Sigil so this is the sign for
225:59 - sigil and let us create a schedule for
226:01 - our date and here we can say that the
226:04 - year has to be 2023 the month can be
226:07 - March and the date can be 31st of March
226:11 - and that's it we have a new date in
226:13 - place so now let us go back to the
226:15 - struct and let us create a date right
226:17 - over here so let me use the sigil over
226:19 - here so I can say I want to create a
226:21 - date and suppose my year is 2023 my
226:26 - month can be September and suppose the
226:28 - date is 12th of September next is the
226:31 - amount suppose the amount is 18.99 and
226:35 - let's say the store is going to be
226:37 - Metro so now we have created an expense
226:40 - now let me just copy and paste a bunch
226:42 - of more expenses so that's it let me
226:45 - open up my terminal and let me clear up
226:48 - all of these things let us go inside the
226:50 - IEX and let me create an alias for of my
226:54 - tutorials dot structs dot expense and
226:58 - let me clear this one more time let us
227:01 - create a variable for our sample
227:02 - expenses so we can say that my sample
227:04 - expenses is equal to my expenses dot the
227:08 - function of sample so now we have a
227:10 - bunch of samples so now let us go back
227:12 - to the code editor and let us see what
227:15 - we can do with our expenses oh before
227:18 - that let us add the type specifications
227:20 - for this one so here we can specify that
227:24 - the specifications for our sample so
227:27 - this does not accept anything and this
227:29 - returns a list of the type of T that we
227:32 - have just defined next let us write a
227:34 - function to get the total amount that we
227:37 - have spent so we can say that the
227:39 - function is going to be our total and
227:42 - this function accepts our expenses and
227:45 - let's define the body of this function
227:47 - so this expenses would be the list of
227:49 - all our expenses for example if we get
227:52 - this expenses then we simply want to add
227:54 - all of the amounts together and we want
227:57 - to give back the total amount so let us
227:59 - see how we can do this one let me take
228:01 - all of these things a little up now you
228:03 - can solve this by using multiple methods
228:05 - but I'm going to use the enum dot reduce
228:08 - so first let me take the expenses and
228:11 - let me pipe the expenses into enum dot
228:14 - reduce now for this function of reduce
228:16 - let us Define an accumulator so let's
228:19 - say that my initial accumulator is 0 the
228:21 - next one comes the function now for each
228:24 - iteration this function receives two
228:27 - parameter the first is going to be the
228:29 - expense the second is going to be the
228:31 - accumulator and for each iteration I
228:34 - simply want to go to my expense take the
228:37 - amount and add add that amount to my
228:39 - accumulator so that's it now let us go
228:41 - back to our terminal let us recompile
228:43 - our expense let me clear up everything
228:46 - and now let us invoke this function so
228:49 - we can say expense dot let us get the
228:52 - total for our sample and that's it we
228:55 - get the answer as
228:57 - 1025.62 let us go back and let us also
229:00 - write the type specifications for this
229:02 - one so this function of total this
229:05 - accepts a list of the type of T and this
229:08 - returns a number so if you hover our
229:11 - number you can see that your number can
229:13 - either be an integer or a float next let
229:16 - us write a function to sort our expenses
229:18 - by the date so we can say that we want
229:21 - to define a function and this function
229:23 - accepts our list of expenses and now let
229:27 - us see how we can sort our list so in
229:30 - the last video we have seen how to sort
229:31 - a list but this time we want to sort by
229:34 - date so let me take you back to my
229:37 - terminal so let us see the documentation
229:39 - for our enum dot sort so last time we
229:43 - had used sort but we have one more
229:45 - function by the name of salt and buy now
229:48 - let us see the documentation for this
229:50 - one let me slightly scroll up and here
229:52 - they have an example in which they are
229:54 - using date so for example they have a
229:57 - list of different maps and each of the
229:59 - map has a field for the date and this is
230:02 - how they are sorting the date so the
230:04 - first argument is obviously your enum
230:06 - for the second argument they are using a
230:09 - shortened syntax you can use your
230:10 - regular function and what they are
230:12 - trying to say is for each iteration they
230:15 - want to sort by the birthday so let us
230:18 - use this shorthand syntax and let us see
230:20 - how we can sort our date
230:22 - so here we can say that first let me
230:24 - take all of my expenses then let me pipe
230:27 - all of these things into my enum dot
230:29 - sort by and let us use the shorthand
230:32 - syntax so we can say I want to give a
230:34 - reference to an anonymous function and
230:36 - for each iteration I want to sort by the
230:40 - date let us open up our terminal let us
230:43 - recompile our expense let me clear out
230:46 - the screen and here we can say dot
230:48 - expense dot sort by date and let us pass
230:51 - the list of our samples and let us see
230:53 - what's happening so here you can see
230:55 - that the dates are sorted the last one
230:58 - is for 30th of October the earlier one
231:01 - is 18th of October so this one is for
231:04 - September and this one is for July so we
231:08 - have a nicely sorted list in ascending
231:10 - order in case if you want to change the
231:12 - order you can refer the documentation so
231:14 - yeah they are saying that in case if you
231:16 - want descending then you can add this
231:19 - parameters as well let us go back let us
231:21 - write this specifications for this one
231:24 - so sort by date so this accepts the list
231:28 - of the type of p and this also Returns
231:31 - the same list of the type of t next let
231:34 - us see how we can add an expense to our
231:37 - list of expenses so let's define a
231:39 - function called as ADD expense so this
231:41 - accepts one single expense and let us
231:44 - write the body of our function
231:47 - now this is going to be a very simple
231:49 - function so we simply have to take the
231:52 - expense and we simply want to append
231:54 - this expense to our existing list of
231:57 - samples now for this one I wanted to
231:59 - show you one small trick so in case if
232:02 - you want to enforce that this expense
232:04 - has to be of the type of the struct of
232:07 - expense then what we can do is we can
232:09 - simply use a pattern match right over
232:11 - here so here we can say that we want to
232:13 - have a pattern match for our struct of
232:16 - expense so essentially what we are doing
232:19 - is we want to enforce that the type of
232:21 - this parameter has to be of the type of
232:24 - our struct let us also add the
232:26 - specifications for this one so we can
232:28 - say that our ad expense this accepts the
232:32 - type of T and this Returns the list and
232:36 - the list has of the type of t as well
232:39 - now let me open up my terminal let us
232:41 - also recompile the model for our expense
232:44 - let me clear up everything now first let
232:47 - me create an expense so let us create a
232:49 - variable for our expense and let us
232:51 - initialize our struct so here we want to
232:54 - say that our expense suppose we want to
232:56 - buy some coffee and let's say the date
233:00 - would be for the first of April so we
233:03 - can use the sigil and we can say we want
233:05 - to schedule for the date and the date is
233:07 - going to be 2023 the month is April the
233:10 - date is the 1st of April let's say the
233:13 - amount for this one is going to be 10
233:15 - and let's say we buy this from Metro so
233:20 - now we have one expense with us now let
233:22 - us try adding this expense so we can say
233:24 - expense dot add our expense and let us
233:27 - pass the newly created expense
233:30 - and we get back an answer so let us see
233:32 - if we have coffee in this list or not
233:36 - so yes as we can see the first item is
233:39 - the coffee so we have added our expense
233:42 - inside the list so let us go back and
233:44 - let us see what else we can do next let
233:46 - us see how we can update a single entry
233:48 - inside our list of expenses so for
233:51 - example let's see how we can update an
233:53 - amount for a particular expense so let
233:56 - us create a function and let us call the
233:58 - function as update amount now this
234:00 - function will take two parameters the
234:02 - first parameter is the title for our
234:05 - expense and the second can be the amount
234:07 - so the updated amount and let us see how
234:09 - we can write the body for this one so
234:12 - for example what I want to do is
234:14 - suppose we are buying Grocery and we
234:17 - want to update the amount from 18.99 to
234:19 - say 20 dollars so let's see how we can
234:22 - do that
234:23 - so for updating the amount we have to do
234:26 - a couple of things so the first thing is
234:28 - we need to filter out the expense that
234:31 - we want to update the second step is we
234:33 - want to create a new expense with the
234:35 - updated amount because remember all of
234:37 - the data types in Elixir are immutable
234:39 - the third is we simply want to add this
234:42 - expense to our samples and we want to
234:44 - take out the old entry so let us see how
234:47 - we can do these things so the first step
234:49 - is to filter the exact expense with the
234:52 - given title so we can say we want to use
234:55 - enum.filter the first argument would be
234:57 - for our sample expenses so we can just
235:00 - pass the function of sample over here
235:01 - next we have to define a function right
235:03 - over here so let me use the function and
235:06 - end and for each iteration this function
235:09 - receives one single expense so let us
235:12 - pattern match on the expense title so
235:14 - here we can say that we want to extract
235:16 - the title and we want to capture the
235:19 - title in a new variable and let us name
235:22 - the variable as expand title and for
235:25 - each iteration we simply have to check
235:27 - if the expense title is equal to the
235:30 - given title so this title comes from the
235:33 - functional definition which is right
235:35 - over here and we also need to capture
235:37 - this expense so if you just hover on
235:39 - filter so here we can see that the
235:41 - result is a list so let us pattern match
235:44 - and let us extract that expense so on
235:47 - the left let us pattern match over here
235:49 - and let us create a new list and let us
235:52 - create a variable called as item so this
235:54 - item will hold the expense that we have
235:57 - just filtered the next step is to create
235:59 - a new expense so we can say that we want
236:01 - to create a variable for the new item
236:04 - and let us create a new expense by
236:06 - updating this item so we can say for my
236:09 - struct of item I want to update the
236:12 - amount by the new amount so this amount
236:15 - comes from the function definition right
236:17 - over here so now we have the new amount
236:19 - the last thing is we simply have to
236:21 - append the new item to our list of
236:23 - samples but before we can append we also
236:27 - need to remove the old item from our
236:29 - list of samples but we can do all of
236:31 - these things in one place in a single
236:33 - statement so let me show you how we can
236:35 - do this so here we can say that we want
236:38 - to append the new item to our list of
236:41 - our samples but before we can append we
236:44 - also need to remove the old entry so
236:46 - what we can do is we can simply take the
236:48 - output of sample and pipe this into a
236:51 - new function and we can say list dot
236:54 - delete and let me pass the old item to
236:56 - this function and that's it so what's
236:59 - going to happen is first we are going to
237:01 - remove the entry from the list of
237:02 - samples and after that the new item is
237:05 - going to be appended now let me open up
237:07 - the terminal and as usual let us again
237:10 - recompile our expense let me clear up
237:13 - the screen and let us try to invoke this
237:16 - function expense dot update amount now
237:19 - for example we want to update the amount
237:21 - of our grocery from 18.9 99 to say
237:24 - thirty dollars and let us check if we
237:27 - have updated the amount or not so yes so
237:29 - this is the entry for grocery and the
237:32 - new amount is 30. so let us go back so
237:35 - till now we have seen a lot of different
237:37 - ways in which we can work with our
237:39 - structs we have seen how to work with
237:40 - recursion and we have also seen how to
237:42 - work with the inbuilt modules now for
237:45 - the last thing in this video I wanted to
237:47 - show you the with statements so for
237:50 - example what happens we may have to deal
237:52 - with multiple conditions so for example
237:55 - you are writing a web application and
237:57 - you want to have the function ID for
237:59 - login now in order to login a user we
238:02 - have to satisfy a multiple of different
238:04 - conditions for example first we need to
238:06 - authenticate and then we also need to
238:08 - verify the password and so on so
238:11 - basically what we want to do is in order
238:13 - to log in we have to satisfy multiple of
238:16 - conditions and you can satisfy multiple
238:19 - conditions by using the with syntax so
238:22 - let me show you first and it will be
238:24 - easy for you to understand so the first
238:26 - thing is let us create a dummy database
238:28 - for our users and we can do that by
238:31 - writing our own custom model attributes
238:34 - so here we can say that we want to
238:36 - define a model attribute by the name of
238:38 - users and let us assign a list of
238:41 - different users so what we have done is
238:43 - so this is a model attribute and we have
238:45 - assigned a list of different uses for
238:48 - this model attribute so what happens is
238:50 - we can use this users as a constant
238:52 - throughout our module next let us write
238:55 - some dummy functions to authenticate and
238:57 - verify password so here I can say that I
238:59 - want to define a function to
239:01 - authenticate and this function will
239:03 - accept a user and here what we can do is
239:05 - we can use something which is called as
239:07 - a function guard so here we can say that
239:10 - when the user is in my list of our users
239:14 - only at that time I want to return a
239:17 - tuple and the first element would be ok
239:19 - and the message would be authorized so
239:21 - this syntax that you can see over here
239:23 - the is called as guards so in Elixir we
239:26 - can use different kinds of guards so you
239:29 - will understand guards as and when you
239:30 - learn more of Elixir but for now let us
239:33 - just go with the flow next let us create
239:35 - one more functional definition for our
239:37 - authenticate so in case we don't have
239:39 - the user inside our database so at that
239:42 - time we want to return a tuple the first
239:45 - element would be error and we can send
239:47 - back a message called as unauthorized
239:49 - next let us create some dummy functions
239:51 - for verify password as well so you can
239:53 - say we want to Define verify password
239:56 - now this function will accept two
239:58 - parameters the first is going to be the
240:00 - user and the second is going to be the
240:02 - password and here also we can use the
240:05 - function guard so we can say in case the
240:07 - user is inside our database of users
240:10 - only at that time I want to return back
240:13 - at Apple the first element is going to
240:15 - be okay and then we can pass the message
240:17 - as password verified now in case the
240:20 - username and the password does not match
240:22 - so for this one let us create one more
240:25 - Clause so this I don't need a guard for
240:27 - this one and this has to be error and
240:31 - let us pass the message as wrong
240:33 - password and this case since we're not
240:35 - doing anything with the password let me
240:37 - use an underscore and here also we are
240:39 - not doing anything with the user and the
240:41 - password okay so now we have the basic
240:44 - framework in place now let us create a
240:46 - function for login so we can say Define
240:49 - login now this function accepts the user
240:52 - and also a password now let me take all
240:55 - of these things a little up now in order
240:57 - to log in a user we have to satisfy a
241:00 - couple of different conditions the first
241:02 - condition is first we have to
241:03 - authenticate and then we also have to
241:05 - verify the password so let us see how we
241:08 - can use the with syntax so first let me
241:10 - write the width block over here so with
241:12 - do and we can also write the else block
241:15 - over here now let's see how we can
241:16 - Define the body of our width so in order
241:19 - to log in first we need to authenticate
241:21 - and we also need to verify at the same
241:23 - time now here let us call the function
241:26 - of authenticate and let us pass the user
241:29 - now we have to say that we have to
241:31 - satisfy this condition and we can
241:33 - specify that by using an arrow syntax
241:35 - over here and we can specify that in
241:38 - case we get a specific output only then
241:40 - the user can be authenticated and here
241:43 - we can specify that in case the first
241:45 - element is the atom of ok and then we
241:48 - get some kind of a message back only in
241:50 - that case the user would be
241:52 - authenticated now this is the first case
241:54 - of authenticate but we also need to
241:56 - check if we can verify the password or
241:58 - not so here let us call the function of
242:00 - verify password let us pass the user and
242:03 - let us also pass the password now we can
242:06 - say that this function of verify
242:08 - password also has to satisfy a couple of
242:10 - different conditions so let me just copy
242:13 - this one from here and let me paste it
242:15 - right over here so in case this function
242:17 - also succeeds and we get back at Apple
242:19 - with OK and suppose the second one is
242:22 - for the message message let me put an
242:25 - underscore over here since we are not
242:26 - doing anything with the variable so now
242:28 - what we are trying to do is we are
242:29 - trying to check for two different
242:31 - conditions authenticate and verify and
242:33 - in case we satisfy both of these
242:35 - functions then we can say that we want
242:38 - to return back a message so the first
242:40 - would be the item of ok and then let's
242:43 - create a string so we can say the user
242:45 - logged in successfully but in case the
242:48 - function of authenticate or verify
242:50 - password fails so in that case we'll go
242:53 - to the else block now here we can
242:55 - pattern match on multiple conditions in
242:57 - case we get a tuple back and the first
242:59 - element is the item of error the second
243:02 - could be some kind of a message so at
243:05 - that time we simply want to return back
243:06 - the same thing so we want to return back
243:08 - the Tuple of error and the message back
243:11 - but in case we get some other error so
243:14 - we can specify that by using the
243:16 - underscore so in all other cases we
243:18 - simply want to return back and atom
243:20 - saying that this is an unauthorized
243:22 - operation or I forgot to put a comma
243:24 - over here so this is how your width
243:27 - block looks like so let me open up my
243:29 - terminal and let us see this thing in
243:30 - action so let me recompile my model of
243:33 - expense let me clear the screen and here
243:36 - we can say that from expense Dot Login
243:40 - and first let us pass a user which is
243:42 - there inside our database for example we
243:45 - have the user of Lewis inside our
243:46 - database so let us pause the argument of
243:49 - Lewis and for the password it does not
243:52 - matter because we are not doing anything
243:54 - with the password and let us see what
243:56 - kind of output we are getting so yes we
243:58 - get back the message saying that Lewis
244:00 - logged in successfully let's try this
244:03 - one more time with the user who does not
244:05 - exist so let me change the spelling and
244:07 - this time we get back the message as
244:09 - error unauthorized so this was all about
244:12 - using the width syntax with our Elixir
244:14 - well that's it for this video and I will
244:16 - catch you in the next one
244:18 - hi and welcome to the last section of
244:21 - our entire series now this last part or
244:24 - the last section is all all about
244:26 - building a statistics library in elixir
244:28 - now don't worry about the word or
244:30 - statistics there is nothing big about
244:32 - statistics as long as you know your
244:34 - basic mathematics like addition
244:36 - subtraction Division and so on you would
244:39 - be absolutely fine you don't have to
244:41 - worry now I also wanted to discuss about
244:44 - a couple of things regarding functional
244:46 - programming my first question is do you
244:49 - have a hard time understanding
244:51 - functional programming if your answer is
244:54 - yes then don't worry you are on the
244:56 - right track
244:57 - now what I mean to say is our brains are
245:01 - so much used to the the object oriented
245:03 - programming paradigms or the imperative
245:05 - programming paradigms that it takes some
245:08 - time for you to understand about your
245:10 - data immutability and recursion so don't
245:13 - worry the only thing that you need is
245:15 - more practice and the intent behind
245:18 - creating one more project is to give you
245:21 - more practice isn't it so don't worry
245:24 - and this is going to be a very nice
245:26 - project I will show you how we can
245:28 - slightly architect our code in a much
245:31 - better way how we can create a different
245:33 - public API how we can separate our in
245:36 - our internal implementation from the
245:39 - public API and so on so overall this is
245:42 - going to be a very nice project so hang
245:44 - on with me and I will catch you right in
245:46 - the next video till then bye so let's
245:49 - get started with our statistics project
245:51 - but before that I would like you to meet
245:54 - my friend Luis now Lewis stays in
245:57 - Toronto and he owns a Candies store and
246:01 - Lewis is going to help us to learn more
246:03 - about statistics
246:05 - the first topic that we want to learn is
246:08 - called as central tendency so central
246:10 - tendency is like a big chapter but don't
246:12 - worry I will make it very simple for you
246:15 - the first thing that we want to study is
246:17 - how we can calculate a mean now mean is
246:21 - nothing it's just a glorified word for
246:23 - average so let us try and study a little
246:25 - bit more about this Concepts
246:28 - now since Lewis stays in Toronto Lewis
246:31 - wants to count the number of cars in
246:34 - Toronto so this kind of data is called
246:36 - as your population data now this kind of
246:40 - data is called as population because our
246:43 - entire scope of data is just Toronto
246:47 - right we only want to count the number
246:50 - of cars which are there in Toronto so
246:53 - this number of cars is going to be a
246:56 - finite number and our scope or our range
246:59 - of data is limited just to Toronto
247:03 - that's why this kind of data is called
247:06 - as your population data now let us see
247:09 - next what's going to happen
247:11 - so next Lewis wants to count the number
247:14 - of cars in Toronto but this time the
247:18 - data is different Lewis wants to count
247:20 - the number of cars in Toronto out of all
247:24 - of the cars in Canada so this time what
247:27 - is happening is the number of cars in
247:30 - Toronto becomes your sample data now the
247:34 - reason why this data becomes sample data
247:36 - is we are taking a small subset of cars
247:40 - in Toronto from a bigger set of data
247:43 - which is all of the cars in Canada
247:46 - so all of the cars in Canada is your
247:49 - population and since we are taking a
247:52 - small subset of cars just in Toronto
247:54 - that's why this kind of data becomes
247:57 - your sample data so let us have a look
248:00 - at one more example
248:03 - for example Lewis wants to calculate the
248:06 - average height of people in his house
248:09 - so for example if there are four people
248:11 - staying in his house then that data
248:14 - becomes the population data now what's
248:17 - happening in this case is the number of
248:20 - people are just limited to the house of
248:23 - Lewis and that's why the data is your
248:27 - population data and we are trying to
248:29 - calculate the average height that's why
248:32 - we simply have to calculate the
248:34 - population mean for this kind of data
248:37 - the next is Lewis wants to calculate the
248:41 - average height of people in Toronto out
248:44 - of all of the people in Canada now
248:47 - what's happening in this case all of the
248:50 - people in Canada this data is your
248:53 - population data and what we are
248:55 - targeting is we are targeting just the
248:58 - people who stay in Toronto
249:01 - so this data is your sample data that's
249:05 - why this average is going to be your
249:08 - sample mean right let's have a look at
249:11 - one more example
249:12 - now Lewis owns a candy store in Toronto
249:16 - and Lois wants to calculate the average
249:19 - number of candies sold in three hours
249:22 - now what kind of a data would this be
249:24 - would this be a population data or would
249:27 - this be a sample data the answer is this
249:31 - is going to be a population data because
249:34 - our scope is just limited to three hours
249:37 - and since this is a population data we
249:40 - would be calculating the population mean
249:43 - so for example this other different
249:46 - candies which are sold by Lewis in the
249:49 - first hour Lewis could sell 10 candies
249:52 - for the second hour Lewis sold 20
249:54 - candies and for the third hour Lewis
249:57 - sold 30 candies
249:59 - so let us see how we can calculate the
250:01 - mean for this kind of data so we have to
250:04 - just add all of the candies together so
250:07 - that's what we are doing right over here
250:09 - and then we simply have to divide by
250:11 - three so we get the answer as 20 candies
250:14 - for an hour that means Lewis was able to
250:18 - sell on an average 20 candidates per
250:21 - hour for the first three hours
250:24 - now let us have a look at one more
250:26 - example now this time Lewis wants to
250:29 - calculate the average candidates sold in
250:32 - the first three hours out of the entire
250:35 - day now in this case the full day would
250:38 - be your population data and since we are
250:42 - just limited to the first three hours
250:43 - out of the full day that means this is
250:47 - going to be our sample data which means
250:50 - we have to calculate the sample mean now
250:54 - these are the different candies which
250:56 - are sold by Lewis throughout eight hours
250:58 - in the day so for the first hour he sold
251:01 - 10 candies for the second hour 20
251:03 - candies for the third hour 30 candies
251:06 - and so on so let us see how we can
251:08 - calculate the mean in this case
251:11 - so again everything Remains the Same for
251:14 - the first three hours we have the same
251:16 - figures so 10 candies for the first hour
251:19 - 20 for the second 30 for the next so
251:22 - that's why we have 10 plus 20 plus 30
251:24 - and the number of hours for which we are
251:27 - calculating is three that's why we have
251:29 - three over here and again this evaluates
251:31 - to 20 that means for the first three
251:34 - hours in the entire day Lewis was able
251:37 - to sell 20 candies in an hour so you can
251:41 - see that the formula for the mean
251:43 - Remains the Same so what's the
251:45 - difference the difference is in
251:47 - perspective
251:48 - sample data is different and population
251:51 - data is different so keep this
251:53 - perspective in your mind and let us see
251:55 - how we can code this population and
251:58 - Sample mean right in the next video
252:00 - let us get started with our statistics
252:03 - project
252:04 - so let me open up my terminal and let's
252:06 - create a new mix project
252:09 - so let me go inside my folder of
252:11 - functional programming with Elixir and
252:14 - then let me go inside my folder of code
252:16 - and right over here I want to create a
252:19 - new project so I can say mix
252:22 - new stats and let me open up the folder
252:26 - in a new window so this is going to be
252:29 - our new statistics project so let us see
252:32 - how we can Implement our population and
252:35 - Sample mean functionality so the first
252:38 - thing is inside the folder of lib let me
252:40 - create a new folder and let me call that
252:44 - folder as central tendency now inside
252:47 - this folder let us create another file
252:50 - so let me create a file and this is
252:53 - going to be for calculating our
252:54 - population and Sample mean let me
252:57 - collapse my sidebar and first let us
253:00 - Define a module so this is going to be
253:03 - stats dot central tendency dot mean so
253:08 - here first let us see how we can
253:09 - calculate our population mean now the
253:12 - formula for calculating the population
253:14 - mean is very simple we simply have to
253:17 - take the sum and we have to divide that
253:20 - sum with our count now in terms of
253:23 - statistics this sum is also called as
253:26 - Sigma so let us see how we can calculate
253:28 - our population mean first so let's
253:31 - define a function called as population
253:34 - mean this function accepts a list of our
253:37 - numbers so we can call the argument as
253:40 - numbers and let us see how we can Define
253:42 - the body for this function but before we
253:45 - can Define the body here we need to do a
253:48 - lot of validation the first validation
253:50 - that we need to do is we need to check
253:53 - if this numbers is actually a list or
253:56 - not so for this we are going to use a
253:59 - guard so let us go to the official
254:01 - documentation and let us try and see if
254:03 - we can find the Right Guard or not so
254:06 - inside the model of Kernel we have a
254:09 - section for guards so let us check if we
254:11 - can find the guard for list or not so if
254:15 - I scroll a little bit down here we have
254:17 - one God and this guard is right over
254:20 - here is list so let us see how you can
254:23 - use this guard in our function
254:25 - so here what we can say that we want to
254:28 - have a guard saying that is list and let
254:32 - us pass the variable of numbers so
254:34 - basically what we want to do is we want
254:36 - to run this function only when this
254:39 - numbers is a list now we have validated
254:42 - that this numbers is a list but what
254:44 - happens if this numbers is not a list or
254:47 - in case the numbers is an empty list so
254:50 - let's define one more function overload
254:52 - on the top so here we can Define that we
254:55 - want to define the same function
254:57 - population mean and in case if we get a
255:01 - blank list then at that time written
255:03 - back a blank list now we can either
255:06 - written back a blank list or we can also
255:08 - written some kind of an error so for
255:11 - example if you want to return some kind
255:13 - of an error so we can return back at
255:15 - Apple and we can say that this is going
255:17 - to be an error and we can also return
255:19 - back a message saying that invalid data
255:23 - type so it's up to you if you want you
255:25 - can get return back a blank list or you
255:27 - can return back an error table so this
255:29 - is just for your reference so now let us
255:31 - see how we can Define the actual body
255:34 - for our population mean so here we need
255:36 - to do two things first we need to find
255:38 - out the sum or the sigma and then we
255:41 - have to divide by the count but before
255:44 - we do all of these things we need to do
255:46 - one more validation so till now what we
255:49 - have validated is that this numbers is
255:52 - just a list but we also need to validate
255:55 - that this is a list of numbers so let us
255:58 - see how we can validate this one so here
256:01 - let us create a pipeline so here we can
256:03 - say that first I want you to take the
256:06 - numbers and then I want you to pipe
256:08 - these numbers inside a function and we
256:10 - can call that function as validate our
256:13 - number list so we have not defined this
256:16 - function but let's define it right over
256:18 - here so let me just copy this one and
256:21 - let us Define a function right over here
256:22 - so validate our numbers list this X
256:25 - accept our list of numbers and let us
256:27 - see how we can Define the body for this
256:29 - one now for this function Let Us return
256:32 - back a tuple the first condition would
256:34 - be either true or false the second
256:36 - condition would be the numbers so in
256:39 - case if this list is not a list of
256:42 - numbers we will send back false but in
256:45 - case this is a valid list of numbers
256:47 - then we will send back a true right over
256:49 - here so let us see how we can do this
256:51 - thing unfortunately it's very simple so
256:54 - here let us use the inbuilt module of
256:57 - enum and I want to use the function of
256:59 - all now this all takes two arguments the
257:03 - first is going to be our enum so let us
257:05 - pass the enum of our numbers and this
257:08 - also takes a function so let us Define a
257:10 - function right over here now what
257:12 - happens for each iteration we are going
257:15 - to receive an element from our list of
257:17 - numbers and we simply have to check if
257:20 - that element is a number or not so here
257:22 - we can use an inbuilt function called as
257:25 - is number and let us pass the element to
257:29 - this one and that's it we have defined a
257:31 - function to validate all our numbers as
257:33 - well let us also write the type
257:35 - specification for this function so here
257:37 - we can say that the specs for validate
257:40 - number lists so this receives a list of
257:43 - our numbers and this function returns a
257:47 - tuple the first is going to be our
257:49 - Boolean the second element is our list
257:52 - of numbers let us go back to our
257:54 - function of population mean so now we
257:57 - have all of the validation in place now
257:59 - this function returns back a tuple so
258:02 - what we can do is we can simply take
258:04 - that Tuple and we can pipe the output in
258:07 - here another functions so let us call
258:09 - the new function as calculate population
258:12 - mean so we have not yet defined this
258:14 - function but let's define it right over
258:17 - here so here we can say that Define
258:19 - calculate population mean and let us
258:22 - write the do and end blocks now this
258:24 - function of calculate population mean
258:27 - receives a tuple right the first is our
258:30 - condition the second one is our list of
258:33 - numbers now this condition can either be
258:36 - true or it can be false so suppose we
258:39 - have a true condition then we can have a
258:41 - pattern match right over here but in
258:44 - case if it is false then we can create
258:46 - yet another Clause so let me just copy
258:48 - and paste this one so here I can say
258:50 - that in case the argument is false and
258:53 - we don't have to do anything with
258:54 - numbers so let me replace numbers with
258:57 - my underscore in case the first argument
258:59 - is false that means the validation has
259:03 - failed so here we can again send the
259:05 - same Tuple error so let me copy this one
259:08 - and let me paste it right over here now
259:10 - let us see how we can calculate the
259:12 - population mean in case the first
259:14 - argument is true now here the formula is
259:17 - very simple first we have to take the
259:19 - numbers next we have to calculate the
259:22 - sum and we can calculate the sum by
259:24 - using an inbuilt function so we can say
259:26 - enum dot sum the next one is we simply
259:30 - have to divide the sum with the count so
259:33 - for this let us Define one more function
259:35 - and let us call that function as mean so
259:38 - this function is going to receive two
259:40 - arguments the first argument would be
259:42 - for the sigma which comes from this one
259:44 - the second argument would be for the
259:46 - count and we can pass the second
259:48 - argument right over here so we can say
259:50 - enum dot count and let us pass the list
259:53 - of numbers now let us create this
259:56 - function right over here so we can say
259:57 - Define mean the first argument is for
260:01 - the sigma the second argument is for the
260:03 - count and for this one the
260:05 - implementation is very easy we simply
260:07 - have to divide the sigma with the count
260:10 - and that's it we have implemented
260:11 - population mean but we can do a lot of
260:14 - improvements so as you can see we have
260:16 - some repetition we have this couple of
260:18 - error here as well as on the top as well
260:21 - let me also put some separator lines for
260:24 - our convenience so this is going to be a
260:26 - separate thing and calculation for the
260:29 - population mean is going to be a
260:31 - separate section and one for this one as
260:34 - well so now let us go to the top and let
260:36 - us see how we can improve our code so
260:39 - now the first thing is we have this
260:41 - error Tuple twice so let's create a
260:43 - separate model for errors so let me open
260:46 - up my sidebar and inside the directory
260:48 - of lib let me create a new model called
260:51 - as errors and let us Define the module
260:54 - as stats dot errors let us Define a
260:57 - function over here so we can say Define
260:59 - invalid data types and we simply want to
261:02 - return back the Tuple so let me go back
261:05 - to the file of mean and let me just copy
261:08 - this line let us go back to our errors
261:11 - file and let me paste it right over here
261:14 - now let us go back to this file let me
261:16 - collapse my sidebar and now what we can
261:18 - do is we can create an alias on the top
261:21 - so we can say that let us create an
261:23 - aliens for our star ads dot errors and
261:27 - we can replace this line with errors dot
261:30 - invalid data type and we can do the same
261:33 - thing right over here so let me take out
261:35 - this line and we can say that errors dot
261:38 - invalid data type now I want to do one
261:40 - more thing I want to take out this
261:43 - function of validate into yet another
261:45 - module and this is because I simply know
261:48 - that we would require this validation
261:49 - function for our future implementation
261:52 - as well so inside lip let us create one
261:55 - more file for validators again let us
261:58 - Define the module and the model name has
262:01 - to be stats dot validators let us go
262:04 - back to this file I simply want to cut
262:06 - everything out so let me take it out and
262:08 - let us go to our file of validators and
262:11 - let me paste it right over here now for
262:14 - this one we can do one slide validation
262:16 - since we have taken this file inside
262:18 - another module so here we can do one
262:20 - small validation as well so let's define
262:23 - a guard over here so when is list for
262:26 - our numbers and in case if this
262:29 - validation fails then let us create one
262:31 - more Clause right over here so here we
262:33 - can simply ignore the argument and we
262:35 - can simply return back an error so let
262:38 - me again create an alias for the error
262:40 - right over here so let's create an alias
262:42 - for our Stacks dot errors and let us
262:46 - return an error right over here so here
262:48 - we can say that errors dot invalid data
262:51 - type now the specification for this one
262:53 - is going to change so this function of
262:55 - invalid data type this returns a tuple
262:58 - let us Define a specification for this
263:01 - one as well so let us go to errors and
263:03 - here we can say that the specification
263:05 - for our function of invalid data type so
263:09 - this function does not accept anything
263:10 - and this simply written backs an atom
263:13 - and the next argument is of the type of
263:16 - string so let me copy all of these
263:19 - things let us go back to our file of
263:21 - validators so now what's happening is in
263:24 - case if this number but is a list of
263:26 - numbers we send back a tuple but in case
263:29 - the validation fails then we simply send
263:32 - back an error and the format for the
263:34 - error is we have an atom and we also
263:36 - have a message right the next thing is
263:39 - since we have taken this function in a
263:41 - different module let us go back to our
263:43 - model of mean and let us create an alias
263:46 - on the top so here we can say that we
263:48 - want to Alias yet another module so we
263:50 - can say that we want to Alias stats dot
263:54 - validators now what we are doing is we
263:56 - are importing errors and validators from
263:58 - the same model of stats so we can create
264:01 - an alias on the same line let me show
264:03 - you how so we just have to wrap this
264:05 - inside our curly brackets and we can say
264:08 - that we also want to create an alias for
264:10 - validators as well now right over here
264:13 - on line number 10 this function is
264:16 - inside our model of validators so
264:18 - validators dot validate numbers list let
264:21 - me take out this lines let me open up my
264:24 - terminal and we can go inside our IEX
264:26 - let us create an alias for stats dot
264:31 - central tendency dot mean let me clear
264:33 - up everything and let us call our
264:36 - population mean so we can say population
264:38 - mean and let us pass 10 20 and 30 and as
264:43 - expected we get back the answer as 20.
264:46 - now let us pass an empty list and see
264:49 - what's happening so in this case we are
264:51 - getting back an error saying that error
264:53 - invalid data type now watch what happens
264:56 - if we pass some other argument for
264:58 - example if we pass a b and c so in this
265:01 - case we get an error saying that no
265:03 - function Clause matching and this is
265:06 - because we have not defined a catch all
265:08 - clause for this function of population
265:10 - mean so let us Define one Clause right
265:12 - over here so here we can say that define
265:15 - population mean and in this case we
265:18 - simply want to ignore the argument and
265:20 - we simply want to return back our errors
265:23 - dot invalid data type let me open up the
265:26 - terminal and let us recompile our model
265:29 - of mean let me clear up everything and
265:32 - let us try the same statement one more
265:34 - time so this time we get a nice error
265:36 - saying that error invalid data type so
265:39 - this is how we can create population
265:41 - mean but we are not yet done we also
265:44 - need to implement the sample mean but
265:46 - luckily the formula for sample mean and
265:49 - population mean is the same so let us
265:51 - very quickly Implement our sample mean
265:53 - as well let me take out all of the
265:55 - comments I don't need the comments let
265:58 - me paste the separator line on top now
266:01 - here let me again copy this separator
266:02 - line and let us create one more function
266:05 - for sample mean right over here so here
266:07 - we can say that we want to define a
266:09 - function for our sample mean now this
266:11 - function accepts a list of numbers and
266:14 - we simply have to call our population
266:16 - mean and pass our list of numbers so
266:20 - that's it now we have the function for
266:22 - sample mean and population mean as well
266:24 - let us also Define find the
266:25 - specifications for this function so here
266:28 - we can say that the specifications for
266:30 - our population mean now this function
266:32 - receives a list of numbers and this
266:35 - function is going to return back a
266:38 - number or it is going to return back an
266:40 - error now the type of our error is like
266:43 - this the first element is the atom and
266:46 - the second element is of the type of
266:48 - string let me copy this specification
266:50 - for our sample mean as well let me paste
266:54 - it right here and let me change the name
266:56 - from population to sample next we can do
267:00 - a couple of more implements for our code
267:02 - now if you see this function of
267:04 - calculate population mean and this
267:07 - function of mean so this functions are
267:09 - just our private functions so let us
267:11 - declare them as private so this becomes
267:14 - our F of p and this also becomes our
267:17 - private function the same thing happens
267:19 - for our mean as well this also becomes
267:21 - our private function now let me open up
267:24 - the terminal let us try and recompile
267:26 - this one more time let me clear up
267:28 - everything and let us try to invoke the
267:31 - same function one more time let us pass
267:33 - the list of 10 20 and 30 so this is for
267:38 - the population mean and let us try the
267:40 - same thing for our sample mean as well
267:42 - so let me replace this with sample mean
267:45 - and we get the same answer back now
267:47 - what's happening is every time we have
267:49 - to create an alias but instead what we
267:52 - can do is we can separate our public API
267:54 - from our private API so if I open up my
267:58 - sidebar we have a model for stats.ex and
268:02 - as you can see that this file is not
268:04 - doing anything so what we want to do is
268:06 - we want to make this stats file as our
268:09 - public API so what I mean to say is the
268:13 - end users can just reference this single
268:15 - file to use all of the functionality so
268:18 - let me show you how we can do this let
268:20 - me take out all of these things these
268:22 - are not required let me collapse the
268:24 - sidebar and let let us Define a function
268:26 - for our population mean right over here
268:28 - now this function receives the list of
268:30 - our numbers and from here we can simply
268:33 - call our function of population mean so
268:35 - we can say that we want to create an
268:37 - alias for our stats dot central tendency
268:40 - dot mean and for this function we can
268:43 - simply delegate it to mean dot
268:45 - population mean and let us pass the
268:48 - argument of numbers so now we have
268:50 - simplified our API quite a lot now let
268:53 - me open up the terminal let us recompile
268:55 - the model of stacks let me clear up
268:58 - everything now what we can do is we can
269:00 - simply call stats dot population mean
269:03 - and let us pass the argument of 10 20
269:06 - and 30 and we get back the right answer
269:10 - now let us go back to our code and we
269:13 - can do one slide Improvement for this
269:15 - one now instead of just calling this
269:18 - function we can use something which is
269:19 - called as def delegate so first let me
269:23 - show you and then I can explain it to
269:24 - you so here we can use the new keyword
269:27 - called as def delegate the first
269:29 - argument is the name of our function so
269:32 - the name of our function is population
269:34 - mean so let me paste it right over here
269:36 - now this function also accepts one
269:38 - argument and the argument is for the
269:41 - list of our numbers and now what we want
269:43 - to do is we simply want to delegate this
269:46 - function to our model of mean and that's
269:49 - it line number four and line number five
269:52 - does the exact same thing so let me
269:55 - comment on this line This is not
269:57 - required let me open up my terminal let
269:59 - us recompile the model of stats let me
270:02 - clear up everything and let me call the
270:04 - same function one more time and as
270:07 - expected this is working just fine let
270:09 - us create one word of Delegate for the
270:12 - sample mean so here we simply have to
270:14 - change the name from population mean to
270:16 - sample mean so whenever we call stats
270:19 - dot sample mean this function would be
270:22 - delegated to main dot sample mean let me
270:25 - open up my terminal let us recompile the
270:28 - same module let me clear up everything
270:30 - and here I can say that stats dot this
270:34 - time I want to calculate the sample mean
270:36 - and let me pass the argument of three
270:38 - four five six and seven and this time we
270:41 - get the answer as 5 well that's it for
270:43 - this video and I will catch you in the
270:45 - next one let us get started with our
270:47 - statistics project
270:49 - so let me open up my terminal and let's
270:52 - create a new mix project
270:54 - so let me go inside my folder of
270:56 - functional programming with Elixir and
270:59 - then let me go inside my folder of code
271:02 - and right over here I want to create a
271:04 - new project so I can say mix
271:07 - new stats and let me open up the folder
271:11 - in a new window so this is going to be
271:15 - our new statistics project so let us see
271:18 - how we can Implement our population and
271:20 - Sample mean functionality so the first
271:23 - thing is inside the folder of flip let
271:26 - me create a new folder and let me call
271:29 - that folder as central tendency now
271:32 - inside this folder let us create another
271:35 - file so let me create a file and this is
271:38 - going to be for calculating our
271:40 - population and Sample mean let me
271:43 - collapse my sidebar and first let us
271:45 - Define a module so this is going to be
271:48 - stats dot central tendency dot mean so
271:53 - here first let us see how we can
271:55 - calculate our population mean now the
271:58 - formula for calculating the population
272:00 - mean is very simple we simply have to
272:03 - take the sum and we have to divide that
272:05 - sum with our count now in terms of
272:08 - statistics this sum is also called as
272:11 - Sigma so let us see how we can calculate
272:13 - our population mean first so let's
272:16 - define a function called as population
272:19 - mean this function accepts a list of our
272:23 - numbers so we can call the argument as
272:25 - numbers and let us see how we can Define
272:27 - the body for this function but before we
272:30 - can Define the body here we need to do a
272:33 - lot of validation the first validation
272:35 - that we need to do is we need to check
272:38 - if this numbers is actually a list or
272:41 - not so for this we are going to use a
272:44 - guard so let us go to the official
272:46 - documentation and let us try and see if
272:49 - we can find the Right Guard or not so
272:51 - inside the model of Kernel we have a
272:54 - section for guards so let us check if we
272:57 - can find the guard for list or not so if
273:00 - I scroll a little bit down here we have
273:03 - one God and this guard is right over
273:05 - here is list so let us see how you can
273:08 - use this guard in our function
273:10 - so here what we can say that we want to
273:13 - have a guard saying that is list and let
273:17 - us pass the variable of numbers so
273:19 - basically what we want to do is we want
273:22 - to run this function only when this
273:24 - numbers is a list now we have validated
273:27 - that this numbers is a list but what
273:30 - happens if this numbers is not a list or
273:32 - in case the numbers is an empty list so
273:35 - let's define one more function overload
273:37 - on the top so here we can Define that we
273:40 - want to define the same function
273:43 - population mean and in case if we get a
273:46 - blank list then at that time written
273:49 - back a blank list now we can either
273:51 - written back a blank list or we can also
273:53 - written some kind of an error so for
273:56 - example if you want to return some kind
273:58 - of an error so we can written back at
274:00 - Apple and we can say that this is going
274:02 - to be an error and we can also return
274:05 - back a message saying that invalid data
274:08 - like so it's up to you if you want you
274:10 - can get return back a blank list or you
274:12 - can return back an erratable so this is
274:15 - just for your reference so now let us
274:17 - see how we can Define the actual body
274:19 - for our population mean so here we need
274:22 - to do two things first we need to find
274:24 - out the sum or the sigma and then we
274:27 - have to divide by the count but before
274:29 - we do all of these things we need to do
274:32 - one more validation so till now what we
274:34 - have validated is that this numbers is
274:37 - just a list but we also need to validate
274:40 - that this is a list of numbers so let us
274:44 - see how we can validate this one so here
274:46 - let us create a pipeline so here we can
274:49 - say that first I want you to take the
274:51 - numbers and then I want you to pipe
274:54 - these numbers inside a function and we
274:56 - can call that function as validate our
274:58 - number list so we have not defined this
275:01 - function but let's define it right over
275:04 - here so let me just copy this one and
275:06 - let us Define a function right over here
275:08 - so validate our numbers list this X
275:10 - accept our list of numbers and let us
275:13 - see how we can Define the body for this
275:15 - one now for this function Let Us return
275:17 - back a tuple the first condition would
275:19 - be either true or false the second
275:22 - condition would be the numbers so in
275:24 - case if this list is not a list of
275:27 - numbers we will send back false but in
275:30 - case this is a valid list of numbers
275:32 - then we will send back a true right over
275:35 - here so let us see how we can do this
275:37 - thing unfortunately it's very simple so
275:40 - here let us use the inbuilt module of
275:42 - enum and I want to use the function of
275:45 - all now this all takes two arguments the
275:48 - first is going to be our enum so let us
275:50 - pass the enum of our numbers and this
275:53 - also takes a function so let us Define a
275:56 - function right over here now what
275:58 - happens for each iteration we are going
276:00 - to receive an element from our list of
276:02 - numbers and we simply have to check if
276:05 - that element is a number or not so here
276:08 - we can use an inbuilt function called as
276:10 - is number and let us pass the element to
276:14 - this one and that's it we have defined a
276:16 - function to validate all our numbers as
276:18 - well let us also write the type
276:20 - specification for this function so here
276:23 - we can say that the specs for validate
276:26 - number lists so this receives a list of
276:29 - our numbers and this function returns at
276:32 - Apple the first is going to be our
276:34 - Boolean the second element is our list
276:37 - of numbers let us go back to our
276:39 - function of population mean so now we
276:42 - have all of the validation in place now
276:44 - this function returns back a tuple so
276:47 - what we can do is we can simply take
276:49 - that Tuple and we can pipe the output in
276:52 - here another function so let us call the
276:55 - new function as calculate population
276:57 - mean so we have not yet defined this
276:59 - function but let's define it right over
277:02 - here so here we can say that Define
277:04 - calculate population mean and let us
277:07 - write the do and end blocks now this
277:10 - function of calculate population mean
277:12 - receives a tuple right the first is our
277:16 - condition the second one is our list of
277:19 - numbers now this condition can either be
277:21 - true or it can be false so suppose we
277:24 - have a true condition then we can have a
277:27 - pattern match right over here but in
277:29 - case if it is false then we can create
277:31 - yet another Clause so let me just copy
277:33 - and paste this one so here I can say
277:35 - that in case the argument is false and
277:38 - we don't have to do anything with
277:40 - numbers so let me replace numbers with
277:42 - my underscore in case the first argument
277:45 - is false that means the validation has
277:48 - failed so here we can again send the
277:51 - same Apple error so let me copy this one
277:53 - and let me paste it right over here now
277:55 - let us see how we can calculate the
277:57 - population mean in case the first
277:59 - argument is true now here the formula is
278:03 - very simple first we have to take the
278:05 - numbers next we have to calculate the
278:07 - sum and we can calculate the sum by
278:09 - using an inbuilt function so we can say
278:12 - enum dot sum the next one is we simply
278:15 - have to divide the sum with the count so
278:18 - for this let us Define one more function
278:20 - and let us call that function as mean so
278:23 - this function is going to receive two
278:25 - arguments the first argument would be
278:27 - for the sigma which comes from this one
278:29 - the second argument would be for the
278:32 - count and we can pass the second
278:33 - argument right over here so we can say
278:35 - enum dot count and let us pass the list
278:38 - of numbers now let us create this
278:41 - function right over here so we can say
278:43 - Define mean the first argument is for
278:46 - the sigma the second argument is for the
278:48 - count and for this one the
278:50 - implementation is very easy we simply
278:52 - have to divide the sigma with the count
278:55 - and that's it we have implemented
278:57 - population mean but we can do a lot of
278:59 - improvements so as you can see we have
279:01 - some repetition we have this couple of
279:04 - error here as well as on the top as well
279:06 - let me also put some separator lines for
279:09 - our convenience so this is going to be a
279:12 - separate thing and calculation for the
279:14 - population mean is going to be a
279:16 - separate section and one for this one as
279:19 - well so now let us go to the top and let
279:22 - us see how we can improve our code so
279:24 - now the first thing is we have this
279:26 - error Tuple twice so let's create a
279:28 - separate model for errors so let me open
279:31 - up my sidebar and inside the directory
279:34 - of lib let me create a new model called
279:36 - as errors and let us Define the module
279:39 - as stats dot errors let us Define a
279:42 - function over here so we can say Define
279:44 - invalid data types and we simply want to
279:48 - return back the Tuple so let me go back
279:50 - to the file of mean and let me just copy
279:54 - this line let us go back to our errors
279:56 - file and let me paste it right over here
279:59 - now let us go back to this file let me
280:01 - collapse my sidebar and now what we can
280:04 - do is we can create an alias on the top
280:06 - so we can say that let us create an
280:08 - aliens for our star ads dot errors and
280:12 - we can replace this line with errors dot
280:15 - invalid data type and we can do the same
280:18 - thing right over here so let me take out
280:20 - this line and we can say that errors dot
280:23 - invalid data type now I want to do one
280:26 - more thing I want to take out this
280:28 - function of validate into yet another
280:30 - module and this is because I simply know
280:33 - that we would require this validation
280:35 - function for our future implementation
280:37 - as well so inside lip let us create one
280:40 - more file for validators again let us
280:43 - Define the module and the model name has
280:46 - to be stats dot validators let us go
280:49 - back to this file I simply want to cut
280:51 - everything out so let me take it out and
280:54 - let us go to our file of validators and
280:57 - let me paste it right over here now for
280:59 - this one we can do one slide validation
281:01 - since we have taken this file inside
281:03 - another module so here we can do one
281:06 - small validation as well so let's define
281:08 - a guard over here so when is list for
281:12 - our numbers and in case if this
281:14 - validation fails then let us create one
281:16 - more Clause right over here so here we
281:18 - can simply ignore the argument and we
281:21 - can simply return back an error so let
281:23 - me again create an alias for the error
281:25 - right over here so let's create an alias
281:27 - for our Stacks dot errors and let us
281:31 - return an error right over here so here
281:33 - we can say that errors dot invalid data
281:36 - type now the specification for this one
281:38 - is going to change so this function of
281:41 - invalid data type this returns a tuple
281:44 - let us Define a specification for this
281:46 - one as well so let us go to errors and
281:48 - here we can say that the specification
281:51 - for our function of invalid data type so
281:54 - this function does not accept anything
281:56 - and this simply written backs an atom
281:59 - and the next argument is of the type of
282:02 - string so let me copy all of these
282:04 - things let us go back to our file of
282:07 - validators so now what's happening is in
282:09 - case if this number is a list of numbers
282:12 - we send back a tuple but in case the
282:15 - validation fails then we simply send
282:17 - back an error and the format for the
282:20 - error is we have an atom and we also
282:22 - have a message right the next thing is
282:24 - since we have taken this function in a
282:26 - different module let us go back to our
282:28 - model of mean and let us create an alias
282:31 - on the top so here we can say that we
282:33 - want to Alias yet another module so we
282:36 - can say that we want to Alias stats dot
282:39 - validators now what we are doing is we
282:41 - are importing errors and validators from
282:44 - the same model of stats so we can create
282:46 - an alias on the same line let me show
282:49 - you how so we just have to wrap this
282:51 - inside our curly brackets and we can say
282:53 - that we also want to create an alias for
282:55 - validators as well now right over here
282:58 - on line number 10 this function is
283:01 - inside our model of validators so
283:03 - validators dot validate numbers list let
283:06 - me take out this lines let me open up my
283:09 - terminal and we can go inside our IEX
283:12 - let us create an alias for stats dot
283:16 - central tendency dot mean let me clear
283:19 - up everything and let us call our
283:21 - population mean so we can say population
283:23 - mean and let us pass 10 20 and 30 and as
283:29 - expected we get back the answer as 20.
283:32 - now let us pass an empty list and see
283:34 - what's happening so in this case we are
283:36 - getting back an error saying that error
283:38 - invalid data type now watch what happens
283:41 - if we pass some other argument for
283:43 - example if we pass a b and c so in this
283:46 - case we get an error saying that no
283:49 - function Clause matching and this is
283:51 - because we have not defined a catch all
283:53 - clause for this function of population
283:55 - mean so let us Define one Clause right
283:58 - over here so here we can say that define
284:00 - population mean and in this case we
284:03 - simply want to ignore the argument and
284:05 - we simply want to return back our errors
284:08 - dot invalid data type let me open up the
284:12 - terminal and let us recompile our model
284:15 - of mean let me clear up everything and
284:17 - let us try the same statement one more
284:20 - time so this time we get a nice error
284:22 - saying that error invalid data type so
284:24 - this is how we can create population
284:26 - mean but we are not yet done we also
284:29 - need to implement the sample mean but
284:32 - luckily the formula for sample mean and
284:34 - population mean is the same so let us
284:37 - very quickly Implement our sample mean
284:39 - as well let me take out all of the
284:41 - comments I don't need the comments let
284:43 - me paste the separator line on top now
284:46 - here let me again copy this separator
284:48 - line and let us create one more function
284:50 - for sample mean right over here so here
284:52 - we can say that we want to define a
284:54 - function for our sample mean now this
284:56 - function accepts a list of numbers and
284:59 - we simply have to call our population
285:01 - mean and pass our list of numbers so
285:05 - that's it now we have the function for
285:07 - sample mean and population mean as well
285:09 - let us also Define find the
285:11 - specifications for this function so here
285:13 - we can say that the specifications for
285:15 - our population mean now this function
285:18 - receives a list of numbers and this
285:21 - function is going to return back a
285:23 - number or it is going to return back an
285:25 - error now the type of our error is like
285:28 - this the first element is the atom and
285:31 - the second element is of the type of
285:33 - string let me copy this specification
285:36 - for our sample mean as well let me paste
285:39 - it right here and let me change the name
285:41 - from population to sample next we can do
285:45 - a couple of more implements for our code
285:47 - now if you see this function of
285:49 - calculate population mean and this
285:52 - function of mean so this functions are
285:54 - just our private functions so let us
285:56 - declare them as private so this becomes
285:59 - our F of p and this also becomes our
286:02 - private function the same thing happens
286:04 - for our mean as well this also becomes
286:06 - our private function now let me open up
286:09 - the terminal let us try and recompile
286:11 - this one more time let me clear up
286:14 - everything and let us try to invoke the
286:16 - same function one more time let us pass
286:19 - the list of 10 20 and 30 so this is for
286:23 - the population mean and let us try the
286:25 - same thing for our sample mean as well
286:27 - so let me replace this with sample mean
286:30 - and we get the same answer back now
286:33 - what's happening is every time we have
286:34 - to create an alias but instead what we
286:37 - can do is we can separate our public API
286:40 - from our private API so if I open up my
286:43 - sidebar we have a model for stats.ex and
286:47 - as you can see that this file is not
286:49 - doing anything so what we want to do is
286:52 - we want to make this stats file as our
286:55 - public API so what I mean to say is the
286:58 - end users can just reference this single
287:00 - file to use all of the functionality so
287:03 - let me show you how we can do this let
287:05 - me take out all of these things these
287:07 - are not required let me collapse the
287:09 - sidebar and let let us Define a function
287:11 - for our population mean right over here
287:13 - now this function receives the list of
287:16 - our numbers and from here we can simply
287:18 - call our function of population mean so
287:20 - we can say that we want to create an
287:22 - alias for our stats dot central tendency
287:25 - dot mean and for this function we can
287:28 - simply delegate it to mean dot
287:31 - population mean and let us pass the
287:33 - argument of numbers so now we have
287:35 - simplified our API quite a lot now let
287:38 - me open up the terminal let us recompile
287:41 - the model of stacks let me clear up
287:43 - everything now what we can do is we can
287:46 - simply call stats dot population mean
287:48 - and let us pass the argument of 10 20
287:51 - and 30 and we get back the right answer
287:55 - now let us go back to our code and we
287:58 - can do one slide Improvement for this
288:01 - one now instead of just calling this
288:03 - function we can use something which is
288:05 - called as def delegate so first let me
288:08 - show you and then I can explain it to
288:10 - you so here we can use the new keyword
288:12 - called as def delegate the first
288:14 - argument is the name of our function so
288:17 - the name of our function is population
288:19 - mean so let me paste it right over here
288:21 - now this function also accepts one
288:24 - argument and the argument is for the
288:26 - list of our numbers and now what we want
288:28 - to do is we simply want to delegate this
288:31 - function to our model of mean and that's
288:34 - it line number four and line number five
288:37 - does the exact same thing so let me
288:40 - comment on this line This is not
288:42 - required let me open up my terminal let
288:45 - us recompile the model of stats let me
288:47 - clear up everything and let me call the
288:50 - same function one more time and as
288:52 - expected this is working just fine let
288:55 - us create one word of Delegate for the
288:57 - sample mean so here we simply have to
288:59 - change the name from population mean to
289:02 - sample mean so whenever we call stats
289:05 - dot sample mean this function would be
289:07 - delegated to main dot sample mean let me
289:10 - open up my terminal let us recompile the
289:13 - same module let me clear up everything
289:15 - and here I can say that Stacks dot this
289:19 - time I want to calculate the sample mean
289:21 - and let me pass the argument of three
289:23 - four five six and seven and this time we
289:26 - get the answer as 5 well that's it for
289:29 - this video and I will catch you in the
289:30 - next one now let us move on to the next
289:33 - part and let us see how we can calculate
289:35 - something which is called as a median
289:38 - now what I've done is behind the scenes
289:41 - I have created a new file called as
289:43 - median and I have also defined the model
289:46 - for this one
289:47 - and to make things simple I have added a
289:50 - lot of documentation so let us see what
289:53 - do we exactly mean by the median so let
289:56 - us have a look at this scenario right
289:59 - over here
289:59 - so suppose Lewis is selling candies for
290:03 - 9 hours and these are the sales of the
290:07 - candies for each respect to hour for the
290:10 - first hour Lewis could sell 10 candies
290:13 - for the second hour Lewis sold 40
290:15 - candies for the third he sold 20 and so
290:18 - on so these are the number of candies
290:21 - that Lewis sold each hour throughout
290:24 - nine hours of his shift now let us see
290:27 - what do you exactly mean by median so
290:30 - median is nothing it is just a central
290:32 - value or it's just the value that
290:35 - divides the measurement into two equal
290:38 - parts
290:39 - so what we want to achieve is we want to
290:42 - find a value that will divide our
290:44 - measurements in the first 50 percent and
290:47 - the next 50 percent and it's very easy
290:49 - to calculate median as well so this is
290:52 - going to be a very simple algorithm for
290:54 - calculating the median the first step in
290:57 - our algorithm is sorting our list so
291:00 - here we can see we have a sorted list of
291:03 - all of the sales of candies for the
291:06 - first nine hours
291:07 - for the second part of our algorithm is
291:10 - we need to count the number of elements
291:13 - inside our list
291:14 - and now here there can be two things
291:16 - first if our account is odd and the
291:20 - second one is if the count is even now
291:24 - if the count is odd then the things are
291:27 - very simple we simply take the middle
291:29 - value and that value becomes our median
291:32 - so for example in this case 50 is right
291:36 - at the center we have four values to the
291:39 - left and we have four values to the
291:41 - right so 50 becomes our median
291:45 - the next scenario is what happens if the
291:48 - count is even at that time what we do is
291:51 - we take two values from the center so in
291:55 - this case 40 and 50 are two values now
291:58 - just have a look at this list this list
292:01 - contains only eight values I have taken
292:03 - out the last value of 90 from this list
292:05 - now since this is an even list we simply
292:09 - take two values from the center
292:11 - so we have 40 and 50 as the center so as
292:14 - you can see there are three values to
292:16 - the left and we have three values to the
292:18 - right and then we simply average them
292:20 - out so 40 plus 50 divided by 2 and we
292:24 - get the answer as 45 and 45 becomes your
292:28 - median value
292:29 - so this is how we are going to implement
292:31 - our algorithm for calculating the median
292:35 - so let us see how we can translate all
292:37 - of these things into code so let me go
292:39 - to the top and here we can see that I
292:42 - have defined a model by the name of
292:43 - stats dot central tendency dot median
292:46 - and now let's get started with this one
292:50 - let us Define the very first function
292:52 - and let us call the function as median
292:54 - this function is going to accept a list
292:57 - of our numbers so we can call the
292:59 - argument as numbers list and let us also
293:02 - use the guard right over here so we can
293:04 - say when is a list and it has passed the
293:08 - argument of our number list
293:11 - so this is one scenario and the next
293:13 - scenario could be we don't get a proper
293:16 - list over here so for handling that case
293:18 - let us Define
293:19 - one more version so we can say median we
293:22 - simply want to ignore the input and we
293:25 - simply want to throw an error but first
293:28 - we need to create an aliens so it's very
293:31 - easy for us to use those modules
293:34 - so let me create an alias for our stats
293:38 - dot errors
293:40 - and here we can say that we simply want
293:43 - to return our errors dot invalid data
293:47 - type now let us go back to this function
293:49 - and let us see how we can implement this
293:52 - one
293:53 - so the first thing is we need to
293:55 - validate our list of numbers so again
293:58 - let me create one more areas at the top
294:00 - so here I can say that
294:02 - we want to create yet another Alias and
294:05 - this time it's for stats dot our
294:07 - validators and now let us go down right
294:10 - over here so here what we can do is we
294:13 - can simply take the list of our numbers
294:15 - and then we can pipe this list of
294:17 - numbers inside our validators DOT
294:21 - validate numbers list
294:23 - and after we validate our numbers list
294:25 - then we can pipe the output into yet
294:28 - another function by the name of
294:30 - calculated median now we don't have that
294:33 - function as of now but we will create it
294:35 - shortly let me put a separator line over
294:38 - here and here let us Define the function
294:41 - of calculate median now let me scroll
294:44 - slightly up so that everything is
294:46 - visible
294:47 - now let us see what this function is
294:50 - going to receive
294:51 - so the output of this function validate
294:53 - numbers list is going to be pipe into
294:56 - the function of calculate median
294:59 - and as you can see this function either
295:01 - returns a Boolean and our numbers list
295:04 - or it Returns the atom along with the
295:07 - error message
295:09 - so let us pattern match on various
295:11 - scenarios and let us see how we can
295:12 - handle different cases the first and the
295:15 - most easiest one is just to handle the
295:17 - error so in case we get an input like
295:20 - this we get an error and the second
295:23 - argument is a message at that time we
295:26 - can simply return back the Tuple of
295:29 - error
295:30 - and the message as it is or what we can
295:33 - do is we can simply use the errors
295:36 - module so either you can do this or we
295:38 - can simply call errors dot invalid data
295:42 - types now let us see what more we can do
295:45 - with this function
295:46 - now the function of validate numbers
295:48 - list can also give us a tuple where the
295:52 - first argument is a Boolean and the
295:55 - second argument is the list of numbers
295:57 - so let us pattern match on this scenario
295:59 - and let us see how we can work with this
296:01 - one so let me Define yet another
296:03 - function oh one more thing what we can
296:06 - do is we can simply mark this function
296:08 - to be private now since this is going to
296:10 - be our helper function we don't want to
296:12 - expose the functionality outside
296:15 - so I am simply marking this function as
296:17 - a private function now let us have one
296:19 - more pattern match right over here
296:22 - now what happens if the first argument
296:24 - is false
296:26 - so at that time we can simply ignore the
296:28 - second argument we don't want the second
296:30 - argument so in this case also since the
296:34 - validation has failed let us again send
296:37 - back the error so we can say errors dot
296:39 - invalid data type now let us Define the
296:43 - third scenario as well so again let us
296:45 - Define the private function calculate
296:48 - median and this time it receives a tuple
296:52 - where the first argument is true and the
296:55 - second argument is our list of numbers
296:57 - here let us see how we can Define the
297:00 - body for this calculated median function
297:03 - let us go slightly up and let us have a
297:06 - look at our algorithm so for the
297:08 - algorithm we need to do two things we
297:11 - need to sort and we also need to count
297:14 - now let us Implement those steps in this
297:17 - function right over here calculate
297:18 - median so here what we can do is we can
297:21 - take the numbers list
297:23 - and we can sort it out by using the
297:26 - inbuilt model of enum so we can say enum
297:29 - dot sort so now we have a sorted list of
297:33 - our elements now the second thing is we
297:36 - need to count if the number of elements
297:39 - are even or odd and depending on that
297:42 - scenario we have to handle two different
297:44 - scenarios so the first scenario was how
297:47 - to calculate the median when the count
297:50 - is odd and the second scenario was how
297:53 - to calculate the median when the length
297:55 - is even
297:57 - so for this we would need to create yet
297:59 - another helper function
298:01 - so what we can do is we can take the
298:03 - output of NM dot sort
298:06 - and let us pipe that output in one more
298:09 - function by the name of get median now
298:12 - we don't have this function but we will
298:14 - create it shortly now this function of
298:16 - get median is going to receive three
298:19 - different parameters the first parameter
298:21 - is obviously the sorted list the second
298:24 - parameter is going to be a Boolean value
298:26 - so we will check if the number is odd or
298:29 - even and the third argument would be the
298:32 - count itself
298:33 - so let us pass the argument for this
298:36 - function now the second argument is
298:38 - going to be a Boolean value and we can
298:40 - check if the count is odd or even by
298:43 - using yet another inbuilt model by the
298:46 - name of integer so we can call the
298:48 - inbuilt model of integer and here we can
298:51 - use the inbuilt function of is even and
298:55 - let us pass the count
298:57 - now for calculating the count what we
298:59 - can do is we can say numbers list and we
299:03 - can pipe this one into another function
299:05 - called as enum dot count the next
299:08 - argument for the function of get median
299:11 - is going to be the count itself so here
299:13 - again what we can do is we can say
299:15 - numbers list and we can pipe the output
299:18 - into enum dot count now as you can see
299:22 - we have little bit of repetition so what
299:25 - we can do is we can take this one out
299:28 - from here and let me create a variable
299:30 - called as count
299:34 - let me put it right over here and we can
299:37 - simply replace this by the variable of
299:39 - count
299:40 - and this also gets replaced by the
299:43 - variable of count now the last thing to
299:45 - do is we simply have to define the
299:47 - function of get median
299:50 - so let me use the separator right over
299:52 - here and let me create the function of
299:55 - get median now this function receives
299:59 - three parameters the first parameter is
300:02 - our list of numbers the second parameter
300:05 - is actually going to be a Boolean value
300:07 - so let me write in Bool for now and the
300:10 - third parameter is going to be count now
300:13 - let us see what we can do with this
300:14 - function now for this function we again
300:17 - have two scenarios right so if we go
300:19 - back to the algorithm
300:21 - so the first scenario is odd and the
300:23 - second scenario is even so what we can
300:26 - do is we can simply use pattern match
300:28 - right over here so this integer dot even
300:31 - is going to give us a Boolean in the
300:34 - terms of true and false so here what we
300:36 - can do is let us pattern match on false
300:40 - so that means this list is not even that
300:44 - means this list is going to be odd and
300:47 - since this list is going to be odd we
300:49 - simply have to take the element at the
300:52 - center and return it back and
300:54 - fortunately it's very easy again for
300:56 - this we are going to use the inbuilt
300:58 - model of enum and there is an inbuilt
301:02 - function called as at so this function
301:04 - accepts two different parameters the
301:07 - first is obviously going to be our list
301:09 - of numbers
301:10 - and the second parameter is going to be
301:12 - the index so for the index what we can
301:15 - do is we can simply take the count and
301:18 - we can divide that count by 2.
301:21 - now there is one small issue over here
301:24 - so this count divided by 2 this actually
301:27 - returns back a float and the index value
301:30 - cannot be flowed so suppose if this
301:33 - value returns an integer such as 4.5 so
301:37 - in that case we don't have any values or
301:40 - rather we don't have any index called as
301:42 - 4.5
301:44 - so what we need to do is we need to have
301:46 - an integer Division and not a float
301:49 - division over here so in order to ensure
301:52 - that we get back an integer we can use
301:55 - the inbuilt function of division
301:57 - so the first argument is going to be the
302:00 - count and the second argument is going
302:02 - to be the number now again this function
302:05 - has to be private so let me put it as
302:08 - Def and P so this is the first scenario
302:11 - where the list is odd the second
302:14 - scenario is what happens when the list
302:16 - is even
302:18 - so let me just copy all of this and let
302:21 - me paste it right over here now for the
302:24 - second scenario is the list is even so
302:27 - we get a true right over here
302:29 - and let us see what we are supposed to
302:31 - do in this case
302:33 - so if you go back to the algorithm
302:35 - so in this case we have to take two
302:38 - values from the center and then we
302:41 - simply have to divide them by 2 and
302:43 - return back the value so let us do
302:46 - exactly those things right over here
302:48 - now what we can do is let us create two
302:50 - variables to hold the values from the
302:53 - center so we can say that the first
302:56 - variable is a and let me copy this
302:59 - function right from here now in this
303:01 - case we have to take one previous value
303:04 - right so if I go back over here we want
303:07 - to take the value which is right over
303:09 - here
303:10 - so what we can do is we can say count
303:13 - minus of 1
303:15 - and let me again copy and paste for the
303:18 - next value we don't need minus 1 and let
303:21 - us call that variable as B
303:23 - so now we have both the values from the
303:26 - center and we simply have to add a plus
303:30 - of B and we just want to divide them by
303:34 - 2. and that's it now as soon as I saved
303:37 - my file we can see that we are getting a
303:40 - small error right over here so what is
303:42 - this saying that you must require
303:45 - integer before invoking the macro so
303:48 - what's happening is elixir is actually
303:50 - using a macro
303:52 - so macro is a kind of a code that
303:54 - generates yet another code but for now
303:58 - we don't have to go into the specifics
304:00 - we just have to do whatever this error
304:02 - message is telling us so if you just
304:04 - refer the message it is saying that we
304:07 - simply have to require integer so let's
304:10 - do exactly the same thing so let me go
304:13 - to the top and here I can say that I
304:16 - want to require the model of integer
304:20 - and that's it now the error should be
304:22 - gone
304:23 - yes now all of the errors are sorted out
304:26 - the last thing is let us go to our
304:29 - public API let us go to lib and under
304:32 - lip let us go to the model of stacks and
304:36 - let us create a depth delegate right
304:38 - over here as well
304:40 - let us use the macro of Def delegate and
304:43 - we can say that we want to define the
304:45 - function of median now this function
304:48 - accepts the list of our numbers
304:51 - and we simply want to delegate this
304:53 - function to the module of median but
304:57 - before let us create an alias right on
304:59 - the top so what we can do is we can
305:01 - import different modules on the same
305:03 - line
305:04 - so we can say that I also want to import
305:06 - median right over here
305:08 - now here on line number nine we simply
305:11 - want to delegate the execution to the
305:14 - model of median so now let me open up my
305:17 - terminal and let me go inside IEX
305:21 - and let me clear up everything so here
305:24 - let us try and invote that function so
305:26 - we can say stats dot median
305:29 - and let us create a list right over here
305:32 - and let me pass the values so as we can
305:35 - see we are getting the value as 50. now
305:38 - what I have done is this is a list of
305:40 - our odd numbers next let me pass one
305:43 - more list which has even numbers
305:46 - so let me take out 90 I don't need 90
305:49 - from here and in this case we are
305:51 - getting the value as 45. well that's it
305:55 - for this video and I will catch you
305:56 - right in the next one
305:58 - hello and welcome to the last video of
306:00 - the series so the last video is all
306:03 - about learning something which is called
306:05 - as mode
306:07 - now what exactly is a mode so let me try
306:09 - and explain but before that what I've
306:12 - done is behind the scenes I've created
306:13 - this file mode.ex inside central
306:16 - tendency and let us see now how we can
306:20 - find the mode of our elements so what
306:23 - exactly do we mean by mode
306:26 - so mode is basically the element which
306:29 - repeats most often
306:32 - so for example if we have this array of
306:35 - values then the mode of this values
306:37 - would be the values that are repeating
306:40 - the most now in this example the most
306:42 - repeating values are 4 and 8 that's why
306:45 - the mode of this is 4 and 8. now you
306:49 - must be thinking what is the use of mode
306:51 - so let me try and help you why mode is
306:54 - very important now suppose this values
306:56 - actually stand for the product ID of the
307:00 - candies which Lewis is selling so for
307:03 - example one could be the product ID for
307:06 - the red candies
307:07 - two could be the product ID for the
307:09 - yellow one three could be for the green
307:12 - one so by finding out the mode we can
307:15 - understand which candies Lewis was able
307:18 - to sell the most so in this example we
307:21 - can say that the candy with the idea of
307:24 - 4 and the candy with the idea of 8 where
307:27 - the most popular and is inside the store
307:30 - so let us see how we can find out more
307:33 - so I have given the steps over here so
307:35 - it's basically a three-step process the
307:38 - first is we have to find the number of
307:40 - occurrences or the frequencies next we
307:43 - have to find the maximum number of
307:45 - occurrences and finally we have to group
307:48 - The Elements which have the maximum
307:51 - occurrences now instead of directly
307:53 - writing the code this time let me show
307:55 - you inside the IEX how you can find the
307:57 - solution for this one
307:59 - so let me just copy this one and let me
308:03 - open up my terminal so let me go inside
308:05 - my IEX and let me clear up the screen
308:09 - now if we refer to the steps the first
308:12 - step is we have to find the occurrences
308:14 - or the frequencies
308:16 - so let me paste the values right over
308:18 - here and we can find out the frequencies
308:21 - by using the inbuilt function so we can
308:24 - pipe these values
308:25 - to enum dot frequencies and here it is
308:30 - so now we have all of the values and
308:32 - their frequencies as well
308:34 - so what I would like to do is I would
308:36 - like to Simply Save this in a variable
308:38 - called as ranked map
308:41 - so now we have a ranked map
308:43 - the next step is we have to find the
308:46 - maximum number of occurrences
308:48 - so let us see how we can do that let me
308:51 - clear up my screen so now we have the
308:53 - ranked map
308:55 - for finding out the maximum number of
308:57 - occurrences what we can do is we can
309:00 - take the ranked map and from this map
309:02 - let us simply take the values so we can
309:05 - say map dot values and let us see how it
309:08 - looks like
309:09 - so these are just the values the next is
309:12 - we simply have to find the maximum value
309:15 - out of this map
309:16 - so what we can do is we can type this
309:18 - one into yet another function called as
309:21 - enum dot Max
309:24 - and here it is so the maximum number any
309:27 - value is repeating is Thrice and if you
309:30 - refer to our map we can see that 4 is
309:33 - repeating price and 8 is also repeating
309:36 - Thrice
309:37 - now there is a small caveat for finding
309:39 - out the mode in case the elements are
309:42 - not repeating more than once in that
309:45 - case we can't find out the mode but if
309:48 - we have Elements which are repeating
309:49 - more than once only in that case we can
309:52 - find a valid mode
309:54 - so now let me do one thing let me copy
309:57 - this one and let me save this into yet
310:00 - another variable called as Max let me
310:03 - clear up all of these things so now we
310:05 - have the ranked map and we also have the
310:08 - maximum count the next step is we simply
310:11 - have to filter this react map for the
310:14 - maximum number of occurrences so in this
310:17 - case we saw that 4 is repeating Thrice
310:19 - and 8 is also repeating Thrice so we
310:22 - simply want to filter it out so let us
310:24 - see how we can do this so for this what
310:27 - we can do is we can take the ranked map
310:29 - and then we can use the function called
310:31 - as map dot filter now this function
310:34 - accepts two parameters the first is your
310:37 - map and the second is your Anonymous
310:40 - function so let us write a function
310:42 - right over here now for each iteration
310:45 - this function is going to receive the
310:47 - key and also the value pairs from our
310:50 - map and for each iteration we simply
310:53 - want to filter out for the values where
310:56 - the value is equal to our maximum count
310:59 - so now we have a filtered map the next
311:02 - step is we simply have to take out the
311:04 - keys and that's it so let us see how we
311:07 - can do that so we can take this exact
311:10 - same expression and then we can say that
311:12 - we just want to take the keys from our
311:15 - map and that's it we have our final
311:17 - answer
311:19 - so let us go back to the code editor and
311:21 - let us see how we can do all of these
311:22 - things right over here
311:24 - now for this example I am not going to
311:26 - do all of the validation and error
311:28 - reporting because I suppose you know how
311:30 - to do all of those things
311:32 - so let us directly go inside and see how
311:34 - to write the functions for our mode
311:37 - so let me take all of these things up
311:39 - and here let us Define a function and
311:42 - here we can say that we want to define a
311:44 - function called as mode
311:46 - now this function receives a parameter
311:49 - which is the list of numbers so I can
311:51 - simply add a card over here so is list
311:54 - for my numbers now if you want you can
311:57 - do all of the extra validation but for
311:59 - this video I am not going to do the
312:01 - validation so the first step was finding
312:03 - the frequencies
312:05 - so let me create a variable called as
312:07 - ranked map and here what we can do is we
312:10 - can simply take the numbers
312:12 - and let us pipe those numbers to enum
312:15 - dot frequencies next what we can do is
312:18 - let us try and find the maximum number
312:21 - of occurrences
312:22 - so for that what we can do is we can
312:24 - take the ranked map we can pipe this
312:27 - function into map dot value so now we
312:31 - have all of the values with us next let
312:33 - us find out the maximum number of
312:35 - occurrences so we can pipe this into yet
312:38 - another function
312:39 - enum dot Max
312:42 - so now we have the ranked map and we
312:44 - also have the maximum number of
312:46 - occurrences now the last thing to do is
312:48 - we simply have to filter out our ranked
312:51 - map and for that let us create a helper
312:54 - function
312:55 - so here let us pipe this into yet
312:58 - another helper function by the name of
313:00 - mode func now this function is going to
313:03 - accept two parameters the first
313:04 - parameter would be for the maximum
313:06 - number of occurrences and the second
313:09 - parameter would be for the rank map
313:11 - itself
313:12 - so let me Define a private function mode
313:15 - of func now this function accepts two
313:18 - parameters the first parameter is for
313:21 - the maximum number of occurrences the
313:23 - second parameter is for our rank of map
313:26 - now here we need to take care of one
313:29 - more condition and that is we can find
313:31 - more only if the number of occurrences
313:34 - are more than one so for this function
313:37 - definition let us have a pattern match
313:39 - right over here
313:41 - so we can see that in case the maximum
313:44 - number of occurrences are 1
313:46 - in that case we simply have to ignore
313:49 - the rank map because we can't find out
313:51 - the mode and let us simply written back
313:54 - nil but in case we have the occurrences
313:56 - which are more than one
313:58 - so to handle that situation let us
314:00 - Define one more function overload right
314:02 - over here
314:03 - so we can say mode of func and the first
314:07 - parameter was for the maximum value the
314:09 - second parameter was for our ranked map
314:12 - so let's take the ranked map and next we
314:15 - simply have to filter it out so we can
314:17 - say map dot filter and here let us
314:20 - Define the anonymous function so we can
314:23 - say function now for each iteration this
314:26 - is going to receive the key and also the
314:28 - value and what we need to do is we
314:31 - simply want to filter it out when the
314:33 - value
314:34 - is equal to our Max and the last thing
314:38 - is we simply have to take out the keys
314:40 - from this one so we can say map
314:43 - dot keys now the last thing to do is let
314:47 - us go to our stats.ex and let us create
314:50 - a def delegate right over here so you
314:53 - can say depth delegate let us create a
314:56 - function for the mode this also accepts
314:59 - our numbers list
315:01 - and we simply want to delegate this to
315:04 - the model of more but first let us
315:06 - import it right over here
315:08 - so we can say we also want to import
315:10 - more
315:11 - and this one we simply want to delegate
315:13 - to more now let me collapse my sidebar
315:16 - and let me open up my terminal now let
315:19 - us recompile this one more time and let
315:22 - me clear up everything so now we can
315:25 - call stats dot mode and let me pass the
315:28 - values right over here
315:30 - and as expected we get back the answer
315:32 - as 4 and 8. well this brings us to the
315:36 - end of this course but before I can see
315:38 - my final words I wanted to show you a
315:41 - couple of things now if you refer to the
315:43 - code from my GitHub repository so which
315:46 - is this one now inside my official
315:48 - GitHub repository what I have done is I
315:51 - have implemented two more functionality
315:53 - which are under the folder of
315:55 - variability
315:56 - the first one is about variance the
315:59 - second one is all about your standard
316:02 - deviation now I am not going to cover
316:04 - these parts inside this tutorial series
316:06 - because I think they are more towards
316:09 - your mathematical modeling and
316:10 - statistics while this course was
316:13 - designed to give you a fair idea about
316:15 - functional programming in Elixir but I
316:18 - have kept them for a reference you can
316:20 - refer them and you can see how I am able
316:22 - to model variance and standard deviation
316:24 - for statistics
316:26 - well that's it from me and I will catch
316:29 - you in the next one
316:30 - hi I hope you really had fun learning
316:33 - functional programming along with me now
316:35 - this course was designed to teach you
316:36 - all of the basic constructs of the
316:39 - functional programming language but
316:41 - Elixir has a lot more to it the next
316:44 - things that you would want to learn is
316:45 - all about the concurrency and the OTP
316:48 - framework and after you learn the
316:50 - concurrency framework then you can go
316:52 - ahead and you can learn the awesome
316:53 - Phoenix framework as well
316:55 - now coming back to this course if you
316:58 - are finding functional programming to be
317:00 - little difficult it's not your fault it
317:03 - takes some time patience and practice
317:05 - before you can understand functional
317:07 - programming language but after you get
317:09 - the hang of functional programming
317:11 - language believe me you would never want
317:13 - to go back to your object oriented
317:15 - programming or your imperative
317:16 - programming Paradigm as well
317:19 - so let me conclude this course and let
317:22 - me conclude this video
317:23 - and do let me know in the comments uh
317:26 - how would you find this course and you
317:28 - can also connect with me on my website
317:30 - it's um octylium.com and also on Twitter
317:33 - my handle is at the rate of earlier and
317:35 - if you're feeling generous you can all
317:37 - you can buy me a coffee it's buy me a
317:39 - coffee.com slash octallium and also do
317:42 - let me know if you want to learn some
317:44 - more Concepts from me if you would like
317:46 - to learn OTP framework the Phoenix
317:48 - framework or if you would like to learn
317:50 - mathematics and statistical modeling
317:52 - from me or any other topic that you
317:55 - would like to learn from me as well
317:57 - so that's it from me and I will catch
317:59 - you in the next one bye