00:00 - This is an amazing beginner's Angular course, 
Slobodan is a very experienced developer.  
00:05 - And he teaches the basics of Angular, using 
diagrams, animations, and of course code. Today,  
00:13 - I'm starting with a new video series about 
Angular framework. And in this series,  
00:17 - you will learn all the things you need to master 
Angular framework. I'll start with basic stuff  
00:23 - like components and pipes, and slowly progress, 
the most complex features of this framework.  
00:28 - So let's start. In this section, I'm going 
to explain what Angular is give some brief  
00:33 - overview of its features and explain why 
you should use it. But before we start,  
00:39 - make sure to check my channel for more videos, 
and tutorials about front end development. Now,  
00:44 - let's start. Angular is opinionated UI framework 
for building mobile and desktop applications.  
00:51 - And it's built using TypeScript by Google. 
You've probably heard about that one.  
00:56 - Also, it is an open source and helps us 
build dynamic and single page applications.  
01:02 - It is completely based on components. It consists 
of several components, which forms a tree  
01:08 - structure with parent and child components. Angles 
versions beyond two plus are generally known is  
01:15 - angular only. The very first version of Angular 
is known as Angular JS. So why Angular? Well,  
01:24 - because it's supported on various platforms, 
web, mobile, desktop native, it's powerful,  
01:30 - modern, has nice ecosystem. And it's just cool 
that the mist, let me give you some facts.  
01:37 - Angular presents you not only the tools, but 
also design patterns to build your project in  
01:42 - a maintainable way. In an Angular application is 
crafted properly, you don't end up with a tangle  
01:49 - of classes and methods that are hard to modify, 
and even harder to test. The code is structured  
01:55 - conveniently, and you won't need to spend much 
time in order to understand what is going on.  
02:01 - It's JavaScript, but better. Angular is built with 
TypeScript, which in turn relies on GS ESX. You  
02:09 - don't need to learn a totally new language, but 
you still receive features like static typing,  
02:15 - interfaces, classes, namespaces, decorators, etc. 
No need to reinvent the bicycle. with Angular,  
02:23 - you already have lots of tools to start crafting 
application. Right away. You have directives to  
02:29 - give HTML elements dynamic behavior, you can power 
up the forms using form control and introduce  
02:35 - various validation rules. You may easily send 
a synchronous HTTP requests various types, you  
02:42 - can set up routing with little hassle, and there 
are many more goodies that Angular can offer us.  
02:49 - components are decoupled, angular strive to remove 
the tight coupling between various components of  
02:55 - the application. injection happens no j style, 
and you may replace various component VDS. All  
03:02 - DOM manipulation happens, where it should happen. 
with Angular euren, tightly coupled presentation  
03:09 - and application logic, making your markup much 
cleaner and simpler. Testing is at the heart.  
03:16 - Angular is meant to be thoroughly tested, and 
it supports both unit and end to end testing.  
03:23 - Angular is mobile and desktop ready, meaning 
you have one framework for multiple platforms.  
03:29 - Angular is actively maintained, and 
has a large community and ecosystem.  
03:34 - You can find lots of materials on this framework, 
as well as many useful third party tools.  
03:41 - The architecture diagram indentifies, the eight 
main building blocks of an Angular application.  
03:47 - Angular apps are modular, and an 
Angular has its own modularity system,  
03:52 - called Angular modules, or enshi. modules. Every 
Angular app has at least one Angular module class,  
03:59 - the root module, conveniently named app module. 
While the root module may be the only module  
04:06 - in a small application, most apps have many 
more feature modules. Each a cohesive block  
04:13 - of code dedicated to an application domain, or 
workflow are closely related set of capabilities.  
04:19 - in Angular module, whether a route or a feature 
is a class with an NGO module decorator.  
04:27 - Angular templates are dynamic. When 
Angular renders them it transforms the DOM  
04:33 - according to the instructions given by directives. 
Metadata tells Angular how to process a class.  
04:41 - Service is a broad category encompassing any value 
function or feature that your application needs.  
04:48 - Almost anything can be a service. A 
service is typically a class with a narrow,  
04:53 - well defined purpose. It should do something 
specific and do it well. Examples include  
04:59 - logging Service data service message bus 
tax calculator application configuration.  
05:07 - There is nothing specifically about Angular 
services. Angular has no definition of a  
05:13 - service. There is no service base class and 
no place to register a service. Yet, services  
05:19 - are fundamental to any Angular application. 
components are big consumers of services.  
05:27 - Now let's talk more about components in detail. 
components are the main building block of Angular  
05:33 - application. Each component consists of an HTML 
template that declares what renders on the page,  
05:40 - a TypeScript class that defines behavior, the 
CSS selector that defines how the component  
05:46 - is used in our template, and optionally, 
CSS styles applied to the component.  
05:51 - A component must belong to an NGO module in order 
for it to be available to another component.  
05:58 - Why do we use components? There are many reasons 
but the main ones are, you're able to reuse our  
06:04 - code so we don't duplicate simplify component 
based architecture, easy to do error handling,  
06:11 - and breaking down the complexity into smaller 
pieces. prerequisites for these sections are  
06:18 - install the angular COI, and create an Angular 
workspace with the initial application.  
06:24 - If you don't have a project, you can create one 
using mg new project name, where project name is  
06:30 - the name of your application. Although the angular 
satellite is the easiest way to create an Angular  
06:37 - component, In this tutorial, we will create our 
component manually. To create a new component.  
06:43 - Navigate to your Angular project directory. 
Create a new file hello world component Ts file.  
06:50 - At the top of the file, add 
the following import statement.  
06:56 - After the import statement, add a component 
decorator decorator marks a class is an  
07:01 - Angular component in provides metadata that 
decides how the component is use at runtime.  
07:08 - Choose CSS selector for the component. This is a 
tag which you will be using in your template files  
07:14 - to render your component defined the HTML template 
that the component uses to display information.  
07:21 - In most cases, this template is a separate HTML 
file, but I'll use it within this file. To define  
07:28 - a template as external file. Add a template 
URL property to the component decorator.  
07:34 - For a template within the same 
file, use template property.  
07:39 - Select the styles for the components template. 
In most cases, you will define the styles for a  
07:44 - components template in a separate file. Again, I 
will use it within the file to declare the styles  
07:51 - for a component in a separate pile, or the style 
URLs property to the Add Component decorator.  
07:57 - But for the styles within the 
component, add styles property,  
08:01 - add a class statement that includes the code for 
the component. Here we can define properties,  
08:07 - methods, catch component lifecycle events, 
and do dependency injection. But I'll talk  
08:13 - more about these in the next video. Now, all the 
public properties that are defined in the class  
08:19 - are accessible in the HTML template. And 
this is one of the most powerful things here,  
08:24 - I'll create a title property, and 
I will include it in the HTML.  
08:33 - import that new file in the 
module where you want to use it,  
08:36 - to make it available for the whole app imported 
in the root module. In order to see our component,  
08:44 - we can use our CSS selector inside of our app 
component or any other component. And this is  
08:50 - your first component. Very simple though, you 
can reuse across your area. In this section,  
08:56 - we are talking about lifecycle hooks. There are 
special functionality in Angular that allows us to  
09:02 - hook into and run code. And a specific lifecycle 
event of a component or director can look at them  
09:09 - as pages of component life. Like every living 
being cast, they get born, they change, they grow,  
09:15 - and eventually they die. With lifecycle hooks, 
you can gain better control of our application  
09:21 - when we want to use them. For example, if you want 
to fetch some data in this page in your component,  
09:27 - you will do that inside of MG on in its lifecycle 
when a component gets initialized, or if you  
09:33 - need to clean up your component remove some 
subscriptions, you might have to prevent memory  
09:38 - leaks, you will do that inside of NGO ondestroy 
lifecycle just before component gets destroyed.  
09:45 - This is the list of all hooks in exact order how 
they get initialized, but most use ones are on it  
09:51 - on changes and ondestroy. let's implement the NGO 
on it, hook it up. We'll be using this hook the  
09:58 - most first in input on an interface from Angular 
core. Next, we want to implement this interface  
10:05 - inside of our class. To implement any hook, you 
just need to add an energy to the interface name,  
10:11 - and you will get the method needed for 
implementation. So in this case, it's mg on in it,  
10:18 - we will create a simple function for logging 
some values to the console. Now, I will create  
10:23 - a property they will save that function so that 
we can clean it up at the end. In the NGO on init  
10:29 - method, let's create a simple set interval method 
which will make a console log on every second.  
10:39 - If you leave our component like this, when the 
component gets destroyed, our interval method  
10:43 - will continue to log to console. To fix this side 
effect, we need to use the NGO on destroy hook.  
10:51 - Import on destroy interface 
in place the next on in it.  
10:58 - Now create the NGO ondestroy method and in this 
method, you need to clean up this interval.  
11:04 - Simply use a clear interval method with 
our property passed as an argument.  
11:11 - And now our component has been cleaned up. 
Using lifecycle hooks, we're going to fine tune  
11:15 - the behavior of our components during creation, 
update and destruction. Next, text interpolation.  
11:24 - Text interpolation in Angular is a one way data 
binding technique that is used to transfer data  
11:30 - from a TypeScript code to an HTML template. It 
uses the template expression in double curly  
11:36 - braces, also known as a mustache syntax to display 
the data from the component to the view. When do  
11:42 - we need a text interpolation? Every time we want 
to make something dynamic in our HTML template.  
11:48 - To illustrate how interpolation works, let's 
create a new variable in our Ts class. You  
11:55 - can use interpolation to display the value of 
this variable in the corresponding component  
12:00 - template. Angular replaces title with the string 
value of the corresponding component property.  
12:06 - In this case, the values hello world. Now let's 
talk about template expressions. A template  
12:13 - expression produces a value and appears within 
double curly braces. Let me show you an example.  
12:20 - Angular resolves the expression and assigns 
it to a property of a binding target. template  
12:25 - expressions are similar to JavaScript, except you 
can't use assignments. Also operators such as new  
12:32 - type of or ease to solve. You can't use chaining 
expressions decrement, or increment operators and  
12:39 - some of the ies 2015 plus operators. expressions 
can also invoke methods. So let's create one  
12:49 - name of our method that will be get made. 
And in this method, we are returning value  
12:55 - for displaying it in our template. In 
this case, it will be a minimum value.  
13:01 - Couple of things I want to mention, you should 
keep application logic in the component as much  
13:06 - as possible, where it is easier to develop and 
test. Also, expressions should finish quickly  
13:13 - to keep the user experience as efficient as 
possible, especially on slower devices. And  
13:20 - template expression should not change any 
application state other than the value of  
13:24 - the target property. Reading a component value 
should not change some other displayed values.  
13:33 - Now let's learn how to communicate 
between the components.  
13:39 - in Angular application usually consists of 
many separate components. And in order to make  
13:44 - them work together, we need communication 
between them. You can think of components  
13:50 - as family members. And if communication between 
the parents and kids is fluid and efficient,  
13:56 - your home will be a happy place. There are four 
ways to communicate between the angular components  
14:03 - binding using input and output reference by using 
view child and content provider using services  
14:10 - and templates outlined. In this tutorial, 
I'm going to cover the first two ways  
14:15 - as we haven't covered services yet. And a 
template out that is a little bit of that.  
14:21 - First use case is when we want to send data from 
parent to child using input decorator. Input  
14:27 - decorator takes the value passed from parent 
and stores that value in the child property.  
14:33 - Let me create two components using Angular CLA.  
14:37 - I will run the following commands and G generate 
component parent and angiogenic component child.  
14:50 - In our child component, I 
will import input decorator.  
14:54 - In name our input is child message of type string  
15:02 - In a template of the same component, I will 
display this property which is going to be  
15:07 - passed from a parent. Now, inside of our parent 
component in the template, we want to place our  
15:17 - child component and to pass the value to the input 
property we just created. The name of the property  
15:28 - is the one we defined in the child component, 
and the value is going to be a Hello message.  
15:37 - Next, we want to place our parent 
component inside of our root component.  
15:45 - And if we preview it, we can see their message 
from parent has been displayed in our child  
15:49 - component. Second use case is when we 
want to send data from child to parent  
15:56 - using output decorator. Output decorator marks 
a property in a child component is a doorway  
16:02 - through which data can travel from the child 
to the parent. This approach is ideal when you  
16:07 - want to share data this occurs on things like 
button quick form entries in other user events.  
16:14 - To raise it an event, an output must have the type 
of event emitter, which is a class in the angular  
16:20 - core that used to emit custom events. In the child 
component input output decorator an event emitter.  
16:31 - We declare a message event variable with the 
output decorator and set it to equal to a new  
16:37 - event emitter. And then we create a function 
named send message that calls a method on this  
16:46 - event with the message we want to send. Lastly, 
we create a button to trigger this function.  
17:00 - In the parent, I will create a function to receive  
17:02 - the message and I will just simply alert 
this message for demonstration purposes.  
17:10 - Now in the parent template, call our function 
once the event from the child component occurs.  
17:17 - And the name of that event is the one 
that we defined with output decorator.  
17:24 - Very simple and effective. Compared with 
all other approaches for communication,  
17:30 - binding is the cleanest and the simplest one, it 
is the most maintainable wait for passing data,  
17:36 - as binding is always the most preferable way 
that Angular developers should consider first.  
17:43 - Third use case is when we want to send data 
from child to parent using view child view child  
17:49 - allows the child component to be injected into a 
parent component. It will give the parent access  
17:55 - to its properties and functions. Each child 
won't be available to give access until the  
18:01 - viewer has been initialized. This means we need 
to implement the after view init lifecycle hook  
18:07 - to receive the data from the child. First create 
a message property in our child component.  
18:16 - Import view child in after view init. 
From Angular core in our child component.  
18:28 - For our view, child decorator, pass our child 
component as an argument in named as child.  
18:36 - Next, implement after view init lifecycle hook. 
By the way to learn more about Angular hooks,  
18:42 - check the part two of this video series inside 
the MG after view init method just alert the  
18:48 - message property of our child so that you 
can see that we have access to it. And if we  
18:54 - start our application, you can see that we are 
displaying a message from the child component.  
19:03 - Next, we are discussing component styles. Being 
able to style your app is very important because  
19:11 - it allows you to make your app unique and 
attractive. In a way it's like a beauty salon.  
19:16 - World Without CSS would be an ugly place. css 
gives us the opportunity to play with a page  
19:23 - layout, adjust colors and fonts, add effects 
images, and so on how to add styles to Angular  
19:30 - components. There are three ways you can apply 
style by setting style or style URLs metadata,  
19:38 - in light the template HTML, and three with CSS 
imports. I created one blank component with only  
19:46 - h2 tag in the view to demonstrate all different 
ways we can style it. You can add a styles array  
19:54 - property to the component decorator, each string 
in the array define some CSS for This component  
20:03 - can load styles from external CSS files by adding 
a styles URL property to a components decorator.  
20:14 - And now styles from external 
file are being applied. Next,  
20:21 - you can embed CSS styles directly into the HTML 
template by putting them inside of style tags.  
20:32 - You can also write the link tags 
into the components HTML template.  
20:44 - One note here is to be sure 
to include the link styles  
20:48 - file among the assets to be copied 
to the server when building.  
20:56 - You can also import CSS files into the CSS 
files using the standard CSS import rule.  
21:07 - I usually use this approach to import variables.  
21:14 - Reminder, these styles apply only to this 
component. So if you held h1 tag in a child  
21:21 - or parent component, it won't be applied there. 
By default view encapsulation is said to emulated  
21:28 - and emulates the behavior of the Shadow DOM 
by pre processing and renaming CSS code to  
21:34 - effectively scope the CSS to the components view. 
We can remove these additional CSS selectors by  
21:42 - setting encapsulation to none. And now our styles 
are being applied globally. Global styles are by  
21:51 - default defined in the style CSS file, and you can 
find more global styles in the angular JSON file.  
21:59 - Another thing is that if you're building with 
the COI, you can write style files in sass,  
22:04 - less or stylus, and specify those files in the 
component style URLs metadata, be the appropriate  
22:11 - extension as in the following example. Now 
let's talk about special selectors. Use the host  
22:18 - pseudo class selector to target styles in the 
element that hosts the component is opposite to  
22:24 - target elements inside the components template. 
For example, we can write the following code.  
22:33 - We can style host styles with the given selector 
by using the function form as the following.  
22:44 - And if you add active class to host component, 
you can see that styles are being applied.  
22:54 - Now let's talk about host context. Sometimes it's 
useful to apply styles based on some condition  
23:01 - outside of the components view. For example, a 
CSS theme class can be applied to the document  
23:07 - body element. And you want to change 
how your component looks based on that.  
23:13 - The following example applies 
a background color style to all  
23:16 - h2 elements inside of the component. Only if 
ancestor element has the CSS class theme light.  
23:25 - Now if you go to root element, add theme 
like class, you can see those styles.  
23:34 - And that's it. Now let's see what is mg content. 
Anti content uses the content projection to take  
23:46 - HTML of another component and to displayed inside 
itself. To me, it's similar to a film projector,  
23:53 - where you have a slot to insert your content, 
which is going to be displayed on the screen.  
23:59 - It's a very powerful tool when you're 
building components intended for reuse.  
24:04 - I see it used extensively in frameworks such 
as NGO material. When do you want to use energy  
24:11 - content? anytime you want to inject any kind of 
HTML into a component, you can do so mg content.  
24:20 - I have two components child and root component 
to demonstrate this feature inside the child  
24:26 - component, I will create some static content. 
So I'll add an h2 title. And below that title,  
24:33 - I want to show that dynamic content. So 
I will create an mg content tag. With the  
24:41 - MG content element in place. Users of this 
component can now project their own message  
24:47 - into the component. To do that, let me 
insert a child inside of our root component  
24:59 - and I will pass paragraph in a message.  
25:07 - As you can see, the energy content element 
is a placeholder that does not create a  
25:12 - real DOM element. Now, except single 
a component can have a multiple slots.  
25:19 - Each slot can specify a CSS selector that 
determines which content goes into that slot.  
25:26 - This pattern is referred to as 
multi slot content projection.  
25:31 - You can accomplish this task by using the Select 
attribute of Andry content inside of our child  
25:37 - component. add one more Angie content add, we 
can make our component to be like a question and  
25:44 - answer card. So in the first entry content, add 
question selector and put a second edgy content  
25:52 - add answer selector. Now, we can use the selectors 
to send different content. In our route component,  
26:01 - I will create a stream title request 
selector, and I will type this question text.  
26:07 - Below, I will create a paragraph get an answer 
selector, and I will type an answer text.  
26:16 - Also, there are a couple other ways to create 
multi slot content projection. But we haven't  
26:21 - covered conditionals yet. As you can see, it's 
really easy to create reusable dynamic components.  
26:27 - This approach can be used for much more complex 
user interfaces. But I showed you this simple  
26:32 - example to understand the concept. Next, let's 
discuss template statements. A template statement  
26:39 - is something that responds to an event raised by 
a target like an element component or directive.  
26:46 - So it's the same thing as if someone 
is calling you, which is an event  
26:50 - and you're answering that phone call, 
which is the response and in our example,  
26:55 - template statement. It commits side effects as 
it changes the fields in the component. Now,  
27:01 - I will show you how to update class 
properties. Using a template statement.  
27:07 - I have a blank component and in our template, 
I will create a Boolean property named show  
27:12 - text in a value of false. Below that, I 
will create a method named toggle text,  
27:19 - it's not going to return anything at this point. 
All we are going to do here is to toggle our show  
27:24 - tax value on every method call. Usually, we would 
use this kind of property to toggle the state  
27:30 - in the view, but we haven't covered 
conditionals yet. So in the template,  
27:36 - I'm going to create a button which will respond on 
a click event and it will call this toggle method.  
27:46 - Below that I will adjust the 
state or show tax property.  
27:52 - And now when I click the button, you can see 
that it toggles the its value using template  
27:56 - statement. And in this example, toggle text is 
template statement. This statement context may  
28:03 - also refer to properties of the templates 
own context. In the following example,  
28:08 - toggle text takes the templates own event 
object as an argument. If you log that object,  
28:15 - you can see that it contains various information 
about a target and the event that occurred.  
28:22 - Passing arguments can be very useful when you're 
submitting the forms or looping through arrays,  
28:27 - and you need to access a specific element.  
28:31 - One odd here is that the context of a template 
statement can be the component class instance, or  
28:37 - the template. Because of this, template statements 
cannot refer to anything the global namespace,  
28:44 - such as window or document. For example, template 
statement can call console log or math max.  
28:53 - pipes. pipes are simply functions you can use 
in your templates to accept any input value  
28:59 - and return a formatted value. In this case, 
you can see your data is untouched clay,  
29:05 - which is ready to be mold. At the beginning, it's 
not very nice or clear what it's for. But with a  
29:11 - little bit of crafting and molding, you can get 
the end result that you want. Angular provides  
29:17 - building pipes for typical data transformation 
like bait pipe, uppercase pipe, currency pipe,  
29:24 - percent pipe, and similar. In my app component, I 
will define a property with a value of new date.  
29:37 - If we just display our date object in our 
template, you can see what kind of format we  
29:42 - get. It's not very user friendly. Now let's make 
it nicer. To apply a pipe use the pipe operator  
29:51 - within a template expression along with the name 
of the pipe, which is the date for the built in  
29:57 - date pipe now this is my more readable. One out 
here, date pipe is executed only when it detects  
30:05 - a pure change to the input value. A pure change 
is either a change a primitive input value such as  
30:12 - string, number, Boolean or symbol, or a change 
object reference, such as date, array function,  
30:18 - or object. If you still don't like the 
output format of your data, you can fine  
30:23 - tune it by using optional parameters. There are 
predefined options like short or long, and others  
30:36 - or you can customize it completely. For 
example, Allbright for ease for a day in a week  
30:43 - for EMS for a month, one lowercase D for an 
A in a month and one lowercase y for a year.  
30:51 - You can also change multiple pipes as well, you 
just add another pipe operator in a pipe name.  
31:00 - Now, we can create custom pipes as well. Let's 
create a simple greetings by that will concatenate  
31:06 - hello to pass name. I'll use Angular Seelye to 
generate this file for me. So type mg generate  
31:14 - pipe and the name is reading's pipe. In our 
pipe, we have boilerplate code generated.  
31:22 - You can see that pipe decorator has been imported 
with a name property, which we can use to call  
31:28 - our pipe in our templates. Also, there is a pipe 
transform interface which needs to be implemented.  
31:35 - This interface requires the transform 
method to be implemented. And this method  
31:40 - receives a value passed from a template. In our 
case it will be a string. And the second parameter  
31:46 - is for optional params. From pipe itself. 
return type in our case is going to be a string.  
31:53 - Now all we're going to do here is to concatenate 
Hello wonder pastoring and return that.  
32:00 - Now in our template, we can call our custom pipe 
with the greetings pipe name that we defined,  
32:06 - and I will pass world is our string. Now that's 
how you create a custom pipes. Angular pipes are  
32:14 - very simple, but useful functionality provided 
by Angular, and you will use them a lot. Once  
32:20 - again for a detailed list of all pipes check 
the documentation link from the description.  
32:26 - Now let's discuss property binding. Property 
binding moves a value in one direction. So you  
32:32 - can see is one way street. You can go the other 
way. It goes from class property to target element  
32:39 - property. Property binding in Angular helps 
you set values or properties of HTML elements  
32:45 - or directives. With property binding, you can 
do things as toggle button functionality set  
32:51 - paths programmatically, and share values between 
components. To bind the source property of an  
32:57 - image element to a components property plays a 
target source in the square brackets followed by  
33:03 - an equal sign, and then the property. 
The property here is item image URL.  
33:11 - Declare the item image URL property in 
the class, in this case, app component.  
33:21 - A common point of confusion is between the 
attribute call span and the property call span.  
33:27 - Notice that these two names 
differ by only a single letter.  
33:35 - If you wrote something like this, you'll get the 
template parse our interpolation and property  
33:41 - binding can set only properties, not attributes. 
Instead, you'd use property binding and write it  
33:48 - like this. Another example is disabling a button 
when the component says that it's unchanged.  
34:01 - To disable advanced functionality depending on a  
34:04 - boolean value, binding down disabled property to 
a property in the class. That's true or false.  
34:14 - Because the value of the property is unchanged,  
34:16 - it's true in the app component 
Angular disables the button.  
34:23 - Often interpolation in property 
binding can achieve the same result.  
34:30 - The following binding pairs do the same thing.  
34:37 - One odd evaluation of a template expression should 
have no visible side effects. You shouldn't be  
34:44 - assigning anything in the template expression 
or using increment or decrement operators.  
34:51 - If you had an expression that changed the value 
of something else that you were binding to,  
34:56 - the change of value would be a side effect.  
35:01 - Now let's see but our attribute, class and style 
bindings. Using these bindings, you can improve  
35:07 - accessibility dynamically style your application 
in update classes on the fly. First, let's talk  
35:13 - about attribute binding. Attribute binding in 
your your helps you set values or attributes  
35:19 - directly. It is recommended that you set an 
element property with a property binding whenever  
35:25 - possible. However, sometimes you don't have an 
element property to bind. In those situations,  
35:31 - you can use attribute binding attribute binding 
syntax resembles property binding, but instead of  
35:37 - an element property between brackets, you proceed 
the name of the attribute with prefix ATR followed  
35:44 - by a dot. Then you set the attribute value 
with an expression that resolves to a string.  
35:54 - Another common use case for attribute binding 
is with the call span attribute in tables.  
35:59 - Mining the call span attribute helps you keep your 
tables programmatically dynamic. Depending on the  
36:05 - amount of data that your application populates 
a table with the number of columns their row  
36:10 - span could change. To use attribute binding 
with the TD attribute coursepack specify the  
36:17 - call span attribute by using this syntax set 
attribute called span equal to an expression.  
36:25 - In this example, we bind the call span 
attribute to the expression one plus one.  
36:30 - This binding causes the table row to span two 
columns. Sometimes there are differences between  
36:36 - the name of property and an attribute. Call span 
is an attribute of table row, while call span with  
36:42 - the capital S is a property when using attribute 
binding, use call span with a lowercase s.  
36:49 - For more information on how to bind to the cost 
and property, check out the video about the  
36:54 - property binding. Now let's move to class binding. 
You can use class binding to add and remove CSS  
37:01 - class names from an elements class attribute. To 
create a single class binding use the prefix class  
37:08 - followed by a dot and the name of the CSS class. 
Angular adds the class when the bound expression  
37:15 - on sale is truthy. And it removes the 
class when the expression is faulty.  
37:26 - With the exception of undefined. To bind the 
multiple classes use class set to an expression.  
37:36 - The expression can be one of a space 
delimited string of class names.  
37:45 - An object class names as the keys and 
30 old policy expressions as the values  
37:55 - an array of class names. With the object format, 
angular adds a class only if its associated value  
38:03 - is truthy. And finally, let's talk about style 
binding. You can use style binding to set styles  
38:11 - dynamically. To create a single style binding. 
Use the prefix style followed by a.in the name  
38:17 - of the CSS style property, angular sets the 
property to the value of the bound expression,  
38:24 - which is usually a string. Optionally, you can 
add a unit extension like M or a percentage, which  
38:31 - requires a number type. You can write a style 
property name in either dash case, or camel case.  
38:42 - To toggle multiple styles, bind to the 
style attribute the style expression  
38:50 - the style expression can be one 
of a string list of styles. Or  
39:00 - an object with style names is the 
keys in style values as the values  
39:09 - and note that binding in the 
rate to style is not supported.  
39:19 - This time I'm talking about event binding. 
Event binding allows you to listen for and  
39:24 - respond to user actions such as keystrokes, 
mouse movements, clicks and touches.  
39:30 - It's similar to float fishing as you're waiting 
for a fish to take your bite. And once it drips  
39:36 - off, you respond quickly and strike. To bind an 
event you use the angular event binding syntax.  
39:43 - The syntax consists of an event name within 
parentheses to the left of an equal sign in  
39:49 - a template statement to the right. In this 
example, the event name is click and the  
39:54 - template statement is unsaved. We can now 
define the unsaved method. In RTS class.  
40:05 - And once we click our button, that event has been 
bound and our method is executed. We can also bind  
40:13 - to custom events. To demonstrate that I'll create 
an item details component. In this component, I'll  
40:26 - create an event emitter with output decorator, 
which exposes our property to parent components.  
40:41 - Then I'll create a delete dummy method, which 
will just emit our property once we call it.  
40:51 - Now, I'll define a button and 
bind this method to a click event.  
41:05 - Next, I'll place our item details 
component in our app component. And  
41:10 - I will bind to the Delete request 
custom event that we just created.  
41:18 - I'm calling the lead item method. And I'll 
use the event parameter to catch the string  
41:23 - sent with this event. And now I'll 
define the Delete item method narrow  
41:29 - class and just log what we got. And 
that's how you bind to custom event.  
41:40 - Now let's see two way binding connection. 
Two Way binding is the concept of sharing  
41:45 - and giving. What you give is what you can expect 
from others. Why to a binding to a binding gives  
41:51 - components in your application a way to share 
data, use two way binding to listen for events  
41:57 - and update values simultaneously between parent 
and child components. Angular is two way binding  
42:02 - syntax is a combination of square brackets in 
parentheses. This syntax combines the brackets  
42:09 - of the property binding with the parentheses of 
event binding. I'll create a sizer component.  
42:22 - In our component, I will define a size 
value property in a size change event.  
42:30 - The size property is an input, so data can flow 
into the size or component. The size change event  
42:38 - is an output, which allows data to flow out of 
the size or component to the parent component.  
42:46 - Next, there are two methods that decrease the font 
size and ink to increase the font size. These two  
42:58 - methods use Resize to change the value of the 
size property within min max value constraints.  
43:11 - And to emit an event that 
conveys the new size value.  
43:18 - In the sizer component template, I'll create two 
buttons that each bind the click event to the  
43:23 - ink and deck methods. When the user clicks 
one of the buttons the sizer components,  
43:29 - called the corresponding method. Both methods ink 
and deck called the resize method with a plus one  
43:36 - or minus one, which in turn raises the site change 
event with the new size value. And below them,  
43:43 - I'll add a label which displays the size 
property in dynamically a bit its own font size.  
43:53 - In our root app component, I'll 
include an app sizer component,  
43:57 - and I will use two way binding to bind font 
size PX property to the size or component.  
44:07 - And below that, I'll add a div which will 
utilize this property to adjust its text size.  
44:18 - In the app component, one size PX establishes 
the initial size or component size value  
44:24 - by setting the value to 16. Clicking the 
button at this the app component font size px,  
44:30 - the revised font size PX value updates style 
binding, which makes the display text bigger or  
44:37 - smaller. The two way binding syntax is shorthand 
for a combination of property binding and event  
44:43 - binding. The sizer component binding a separate 
property binding. An event binding is as follows.  
44:54 - The event variable contains the data of the size 
or component size change event. Angular assigns  
45:00 - the event value to app component font size 
PX when the user clicks the buttons. To use  
45:07 - two way binding with Purim elements, we need mg 
model which I will cover in the forum section.  
45:15 - Next ones are template variables. template 
variables helps you to use data from one part of  
45:21 - a template. In another part of a template. It's 
a variable that is created in an indentifies a  
45:28 - component or element within the template itself. 
So it's like a phone number of a component,  
45:34 - which you can use to call in case you need 
something from it. With template variables, you  
45:39 - can perform tasks such as respond to user input, 
or finally tune your applications for syntax.  
45:47 - In the template, you use the hash 
symbol to declare a template variable.  
45:52 - The following template variable phone declares 
a form variable when an input element,  
45:58 - you can refer to a template variable 
anywhere in the components template.  
46:05 - Here a button further down the template 
refers to the form variable. Now we can  
46:14 - define the call form method and log the past 
value, which is the actual value of the input.  
46:29 - So what is the template variable scope, you can 
refer to a template variable anywhere within its  
46:35 - surrounding template. Structural directives such 
as Angie and Angie for which we'll cover in the  
46:41 - later videos, or Angie template, act as a template 
boundary, you cannot access template variables  
46:47 - outside of these boundaries. So can we 
access variables in a nested template,  
46:53 - an inner template that can access template 
variables that the outer template defines.  
47:00 - In the following example, changing the 
text in the input changes the value in  
47:05 - the span because Angular immediately updates 
changes to the template variable ref one.  
47:17 - In this case, there's an implied Angie 
template around a span and a definition  
47:22 - of the variable is outside of it. So is the 
same thing as binding explicitly like this.  
47:36 - However, accessing that template variable 
from outside the parent template doesn't work  
47:45 - is the same as writing the following.  
47:55 - And that's all for template variables.  
48:01 - Now, let's discuss directives is the same as if 
you are a CEO of the company. And you are giving  
48:07 - directives to your employees how to behave in what 
to do in certain situations. What are directives.  
48:16 - directives are classes that add additional 
behavior to elements in your Angular application.  
48:21 - with Angular built in directives, you can 
manage forms, lists, styles, and what users see.  
48:28 - The different types of Angular directives are as 
follows. Components directives with a template  
48:35 - this type of directive is the most common 
directive type attribute directives. directives  
48:42 - that change the appearance or behavior of 
an element component or another directive.  
48:48 - Structural directives, directives that 
change the DOM layout by adding and removing  
48:55 - DOM elements. Today, we are talking about 
built in attribute directives. Attribute  
49:01 - directive listens to and modify the behavior 
of other HTML elements, attributes, properties,  
49:08 - and components. Many angii modules such as 
router module and forms module, they find  
49:13 - their own attribute directives. The most common 
attribute directives are as follows. mg class  
49:20 - adds and removes a set of CSS classes and G style 
adds and removes its set of HTML styles. And model  
49:30 - adds two way data binding to an HTML form element. 
How to add and remove classes with NGO class.  
49:37 - You can add or remove multiple CSS classes 
simultaneously with mg class. To add or  
49:44 - remove a single class use class mining rather than 
entry class. When the element you'd like to style,  
49:52 - add Angie class and set it equal to an expression. 
In our class. Let's define you special as true  
50:01 - Because is special is true and reclass 
applies the class of special to the diff.  
50:14 - To use NGO class with a method 
add method to the component class.  
50:20 - In the following example, set current classes sets 
the property current classes with an object that  
50:27 - adds or removes three classes based on the true or 
false state of three other component properties.  
50:34 - Each key of the object is a CSS class name. If a 
key is a true and your class as the class if a key  
50:43 - is false, and re class removes the class. Boolean 
values are hard coded just for demonstration.  
50:53 - In the template, added the N g class property 
binding to current class to set the elements  
50:59 - classes. And now we can preview our classes. Now 
let's talk about mg style. You can use mg style  
51:08 - to set multiple inline styles simultaneously based 
on the state of the component. To use edgy style  
51:15 - and the method to component class. Add empty 
object current style. In the following example,  
51:23 - set current style says the property current 
styles with an object that defines three styles  
51:30 - to set elements styles, and an energy style 
property binding the current styles. For this  
51:37 - use case, angular applies the styles upon initial 
annotations. And in case of changes. To do this,  
51:44 - the full example called set current 
styles initially with NGOs in it.  
51:52 - And the last one in today's video is NGO 
model, you can use the NGO model directive  
51:57 - to display a data property and update 
that property. When the user make changes.  
52:03 - Input forms module and add it 
to NGO modules import list.  
52:12 - I'll create a label and an input for this example.  
52:24 - Add an mg model binding of an HTML 
form element and set it equal to the  
52:29 - property here its name. Now, if you define 
property inside of our component class,  
52:35 - you can see how mg model directive 
adds two way data binding to our input.  
52:41 - This mg model syntax can only set a data bound 
property. When you write an Angular component,  
52:47 - you don't need a value accessor or mg 
model if your name, the value and even  
52:51 - properties according to Angular to a binding 
syntax. And that's all for this section.  
52:58 - In this section, we are continuing with Angular 
directives. Let's build attribute directive. Let's  
53:04 - create a file highlight that directive.ts which 
is the convention that you always should follow.  
53:15 - Next, import directive decorator from core and 
implement that decorator with selector property.  
53:24 - For me, it's going to be app highlight.  
53:33 - Next, we want to export our class. And the last  
53:42 - thing we want is to import that in 
our declarations array in app module.  
53:52 - That's our directive boilerplate code, which can 
also get with the command mg generate directive  
53:58 - highlight. Import element ref from Angular core. 
Element ref grants direct access to the host DOM  
54:06 - element through its native element property. 
And element ref in the directive constructor  
54:13 - to inject a reference to host DOM element, the 
element to which you apply app highlight. Add  
54:20 - logic to the highlight directive class that sets 
the background to yellow. To use the highlight  
54:26 - directive add a paragraph element to the HTML 
template with the directive as an attribute.  
54:34 - Angular creates an instance of highlight directive 
class and inject in the reference to the paragraph  
54:40 - element into directive constructor, which has 
the P elements background style to yellow.  
54:46 - Now, let's see how to detect when a user 
mouse's into or out of the element and to  
54:51 - respond by setting or clearing the highlight 
color. Import host listener from Angular core  
55:01 - Add it to event handlers that respond 
when the mouse enters or leaves,  
55:06 - each with a host listener decorator. With the host 
listener decorator, you can subscribe to events of  
55:14 - the DOM element that hosts an attribute 
directive. The paragraph in this case,  
55:22 - the handlers delegate to a helper method highlight 
that says the color on the host DOM element L.  
55:34 - The background color appears when the 
pointer hovers over the paragraph element  
55:38 - and disappears as the pointer moves 
out. Now, let's see how we can make  
55:42 - the directive dynamic to be able to use it 
at different places with different colors.  
55:48 - In highlight directive Ts File, Import input from 
Angular core, add an app highlight input property.  
55:57 - The input decorator adds metadata to 
the class that makes the directive app  
56:02 - highlight property available for binding. 
In app component Ts add a color property  
56:08 - to the app component. To simultaneously applied 
the directive and the color. Use the property  
56:15 - binding with the app highlight directive selector 
setting to equal to color. The app highlight  
56:22 - attribute binding performs two tasks applies the 
highlighting directive to the paragraph element  
56:28 - and sets directive highlight color with the 
property binding. And that's all for this one.  
56:37 - This is the last section about directives. 
So let's see what are structural directives.  
56:43 - Structural directives are responsible for HTML 
layout. They shape or reshape the dome structure,  
56:49 - typically by adding removing and 
manipulating the host elements  
56:54 - to which they're attached. This section introduces 
the most common built in structure directives.  
57:01 - mg conditionally creates or disposes of sub 
views from the template and you for repeat a  
57:09 - note for each item in a list. And you switch a set 
of directives that switch among alternative views.  
57:18 - You can add or remove an element by applying an mg 
if directive to a host element. When Ngf is false,  
57:26 - angular removes an element and 
its descendants from the DOM.  
57:31 - Angular then disposes of their components, 
which frees up memory in resources to add or  
57:37 - remove an element by the engine if they condition 
expression such as is active in this example.  
57:46 - vendor is active expression returns a 
true value Ngf as the div to the DOM.  
57:53 - When the expression is false, he Ngf removes 
the dim from the DOM. That's simpler right.  
58:00 - Now let's talk about mg four. You can use the 
NG g4 directive to present a list of items.  
58:08 - Let's create an array of objects 
with the name property in it.  
58:19 - Define a block of HTML that determines how Angular 
renders a single item. to list your items assigned  
58:27 - the shorthand lead item of items to energy for 
the string lead item of items instructs Angular  
58:40 - to do the following. Store each item in the 
items array in the local item looping variable,  
58:47 - make each item available to the template HTML for 
each iteration. Translate lead item of items into  
58:56 - energy template around the host element. Repeat 
the energy template for each item in the list. By  
59:05 - the way, you can get the index of energy for in a 
template input variable in use it in the template  
59:12 - in the NG g4, add a semicolon and let 
i equals to index to the shorthand.  
59:20 - The following example guys the index in a variable 
named I in these days it within the item name.  
59:29 - And the less directive which 
we are going to talk about  
59:32 - is switch like the JavaScript switch 
statement. And just switch displays  
59:37 - one element from among several possible 
elements based on a switch condition.  
59:43 - Angular puts only the selected element into the 
DOM. And g switch is a set of three directives.  
59:51 - And you switch an attribute directive that 
changes the behavior of its companion directives  
59:57 - and j switch case structure directive that adds 
its element to the DOM. When it's bound value  
60:04 - equals to switch value and removes 
its bound value when it doesn't equal  
60:09 - the switch value. Andrey switch default structural 
directive that adds its element to the DOM.  
60:16 - When there is no selected energy switch case, I'll 
modify the items array to be just a single item.  
60:27 - On an element such as I do, add Angie switch  
60:30 - bound to an expression that returns 
the switch value such as a name.  
60:39 - Though the name value in this example is a 
string, the switch value can be of any type  
60:49 - bind to mg speech case and mg speech 
to default on the LMS for the cases.  
61:01 - And now depending on the value of the 
item name rendering on the page changes.  
61:06 - If it didn't provide a case for the 
name value, default will be executed.  
61:16 - Next, we are discussing dependency injection. 
dependencies are services or objects that a class  
61:24 - needs to perform its function. dependency 
injection, or di is a design pattern in which  
61:29 - a class request dependencies from external sources 
rather than creating them. You can look at it as  
61:36 - if you're adding an extension to your browser, 
or adding an app to a phone. Once you add it,  
61:42 - you provide yourself with the new functionalities 
and features nice extension. Let's create a  
61:48 - service which we can inject in our components. 
Create a new file with the name log.service.ts.  
61:57 - Import injectable decorator from Angular core. 
And then for provided in metadata add root value,  
62:11 - which means that we are going to provide 
the service in the root of the application  
62:15 - and that is visible throughout the application. 
export our log service class and inside of this  
62:22 - service, we want to add our log message 
method, which will just log past messages.  
62:33 - For clarity in meeting ability, it is recommended 
that you define components and services  
62:39 - in separate files now inject our log service into 
the app module file in providers array. injecting  
62:47 - service results in making them visible to a 
component. to inject a dependency in components  
62:53 - constructor supply a constructor argument 
with dependency type. The following example  
62:58 - specifies the lock service, the app component 
constructor to type of log service is log service.  
63:08 - Now we can reference our log service in 
our component and call our method from it  
63:19 - should pass our message and as you can 
see it's being executed. As expected.  
63:25 - We can use this approach to inject third party 
libraries in other modules that are available  
63:30 - in the angular framework. So let's inject render 
to module which is used for custom rendering  
63:35 - and updating the DOM. Import render to from 
Angular core and injected inside the constructor.  
63:43 - Also, we will need element ref, which we 
can use for referencing our DOM elements,  
63:48 - or the host component in our case. 
Now inside the NG on init lifecycle,  
63:54 - call the set style method of the renderer and 
set the color of host native element to red.  
64:03 - This method changes the color of our components 
tax. And as you can see, with the dependency  
64:08 - injection, we get access to more features 
and methods. That's all there is to it.  
64:18 - Next is very important topic. routing. The 
angular router is a core part of Angular platform.  
64:25 - It enables developers to build single page 
applications with multiple views. In the  
64:30 - navigation between these views. We can compare 
routing of our obligations with navigating  
64:35 - a plane. Pilot says the flight 
coordinates in our case route path,  
64:40 - and the plane lands on the desired location 
or desire page in our app. Oftentimes,  
64:47 - planes carries goods or cargo and routes 
carry params info in data. And unfortunately,  
64:54 - some things do get crashed or lost. 
And for route sometimes we get 404  
65:00 - To use the angular router, an application needs 
to have at least two components so that it can  
65:06 - navigate from one to the other. To create a 
component using the COI, enter the following  
65:12 - at the command line, where first is the name of 
your component, and G generate component. First,  
65:19 - repeat this step for a second component or give 
it a different name. Here the new name is second.  
65:27 - This guide works with a CI 
generated Angular application.  
65:32 - If you're working manually, make sure that 
you have base href would slash in the head  
65:38 - of your index HTML file. This assumes that 
the app folder is the application route  
65:44 - and that uses slash create a new module for 
routing named app dash routing dot module.  
66:03 - We find const routes which is type of routes. 
Here we will define our paths and components.  
66:13 - Inside NGO module imports array add router 
module in call for route module it routes passed  
66:20 - as argument, then export the router module 
so it can be imported into the route module.  
66:27 - At the end, define the app routing module class  
66:34 - imported app routing module into app 
module and add it to the imports array.  
66:42 - Now define your routes in your routes array. Each 
route in this array is a JavaScript object that  
66:49 - contains two properties. The first property bath 
defines the URL path for the route. The second  
66:56 - property component defines the component that 
Angular should use for the corresponding path.  
67:04 - Now that you have defined your routes, 
you can add them to your application.  
67:11 - First, add links to the two components.  
67:21 - assigned an anchor tag that you want to 
add the rod to the router link attribute.  
67:34 - Set the value of the attribute to the component 
to show when a user clicks on each link.  
67:51 - Next, update your component template 
to include router outlet. This element  
67:57 - informs Angular to update the application view 
with the component for the selected route.  
68:03 - You can add router link active activity if you 
want to style active link. One Note the order  
68:11 - of routes is important because the router uses a 
first match wins strategy when matching routes.  
68:18 - So more specific routes should be placed about 
less specific routes. Often is a user navigator  
68:25 - application, you want to pass information from 
one component to another. To do so you use the  
68:31 - activated route interface. First input router 
activated route in para map to your component.  
68:42 - inject an instance of activated route by 
adding it to your applications constructor.  
68:49 - Update the NGO own init method to access the 
activator route and track the ID parameter.  
68:56 - Now we need to adjust our routes 
to pass the ID params as well.  
69:01 - In that add semi colon and name of your parameter. 
And then we can add ID values to our links.  
69:15 - That's how you pass in retrieve 
data from one component to another.  
69:27 - A well functioning application should gracefully 
handle when user attempts to navigate to a part of  
69:33 - your application that doesn't exist. To add this 
functionality to your application. You set up a  
69:38 - wildcard route. The angular route selects this 
route anytime the requested URL doesn't match  
69:45 - any router paths. To set up a wildcard route, 
add the following code to your routes definition.  
69:53 - For the component property, you can 
define any component in your application.  
69:58 - Common choices include an application 
specific page not found component.  
70:02 - But here I'm just redirecting 
to the first component.  
70:06 - And now if you navigate to any random path, 
it will always give us first component.  
70:20 - As your application grows more complex, you 
may want to create routes that are relative  
70:24 - to the component other than your route 
component. These types of nested routes  
70:30 - are called child routes. This means 
you're adding a second router outlet to  
70:35 - app because it is in addition to the router 
outlet in app component. In this example,  
70:41 - there are two additional child components child 
a and child b. here first component has its own  
70:48 - nav, and a second router outlet in 
addition to the one in app component.  
70:55 - Also, I'm going to create two child routes 
with the router links of child a child B  
71:06 - and give it a second router link.  
71:13 - Now I'll create two additional component with 
Angular ccli in named their child a component  
71:22 - and child B component.  
71:33 - Each other route is like any other route, in 
that it needs both a path and a component.  
71:42 - The one difference is that you place child routes 
in a children array within the parent route.  
71:53 - Now if you navigate to any of child routes, 
we get the corresponding child component.  
72:02 - Use route guards to prevent users from navigating 
to parts of an application without authorization.  
72:08 - The following route guards are available in 
Angular can activate connect to a child can  
72:15 - deactivate, resold and can load create a service 
for your guard. mg generate guard your guard.  
72:33 - In your guard class implement the guard you 
want to use the following example users can  
72:39 - activate to guard the route. Now depending 
on your logic, it can return true or false.  
72:45 - Usually it's checks if the user is logged in, 
or does he have privileges to access the page  
72:52 - in your routing module, use the appropriate 
property in your routes configuration here  
72:58 - can activate tells the router to mediate 
navigation to this particular route.  
73:03 - Now, if you set the guard too fast, we 
can't access the route. Otherwise, we can.  
73:12 - And that's all for routing for this section. 
After this one, we're covering one even more  
73:20 - important concept, and that is angular forms. 
Let's start off with template driven forms. I  
73:28 - know it sounds impossible, but there were times 
when there was no internet or even computer.  
73:33 - So in those times, we had to fill out good old 
paper forms when we wanted to visit a doctor or  
73:39 - to apply for various personal documents. So web 
forms are nothing different except their digital.  
73:46 - NGO supports two design approaches for interactive 
forms. template driven forms are suitable for  
73:53 - small or simpler forms. While reactive forms are 
more scalable and suitable for complex forms. This  
74:01 - tutorial shows you how to build a form from 
scratch. First, import forms module in your  
74:08 - app root module. Let's first build our bad class 
which defines a data model reflected in our form.  
74:24 - High will have three properties ID name is PC.  
74:36 - Now let's import our class in the app component.  
74:46 - Define a species in species array. Now create a 
model from the battle. Last in pass the values  
75:02 - for our path. Here we're using 
dummy data. But in your real app,  
75:06 - you would use a service to get the data from the 
API and to save it. Also, let's add submitted  
75:14 - property, which will change depending on 
the state of the form and on submit method.  
75:23 - Next in our HTML file, we will create 
a form that reflects our data model.  
75:30 - Create a form and inside two 
divs for two fields. First,  
75:36 - we'll be naming input. And I'm adding a 
label and required attribute to our input.  
75:46 - And the second one will be a cell Act,  
75:49 - which will loop through an array of species 
to show all the values from the array.  
75:58 - Same as for input, I'm adding a label for our 
select. And also I'll add the required attribute.  
76:09 - Then I will use mg for tillow to 
do all the values and display them.  
76:24 - If you run the application right now, 
you'll see the list of species in the  
76:28 - selection control. The input elements are not 
yet bound to data values or events. So they are  
76:34 - still blank and have no behavior. The next 
step is to bind the input controls to the  
76:42 - corresponding bad properties with two way 
data binding so that they respond to the user  
76:48 - input by updating the data model, and also 
respond to programmatic changes in the data  
76:54 - by updating the display. The NGO model directive 
declared in the forms module, lets you bind  
77:01 - controls in your template driven form to 
properties in your data model. Add the energy  
77:07 - model directive using two way data binding syntax 
for the name use model dot name. And for species  
77:16 - use model dot species value. When you use 
Angie model on element, you must define  
77:23 - a name attribute for that element. Angular uses 
the assigned name to register the element with  
77:29 - the energy form directive attached to the parent 
form element. So in order to register our form,  
77:36 - add a template reference variable use the value 
of MG form. The platform template variable  
77:42 - is now a reference to the NG g form directive 
instance that governs the form as a whole.  
77:51 - In order to test our application plays the 
model object in our template with a JSON pipe.  
77:58 - Now if you update your foreign films, 
you will see that model is being updated.  
78:10 - Now the user should be able to submit this form 
after filling it, create a submit button on the  
78:15 - bottom. the submit button at the bottom of the 
form does nothing on its own, but it does trigger  
78:22 - us form submit event because of its type Submit. 
To respond to this event. Take the following  
78:28 - steps. bind the forms mg submit event property 
to the platform component. on submit method.  
78:41 - Use the template reference variable bedform. 
To access the form that contains the submit  
78:46 - button and create an event binding. You 
will bind the form property that indicates  
78:52 - its overall validity to the Submit buttons 
disabled property. run the application now.  
79:00 - Notice that the button is enabled. Although 
it doesn't do anything useful yet. Delete the  
79:06 - name value. This file is the required rule so 
disable the submit button. The show I response  
79:14 - to form submission you can hide the data entry 
area in this place something else in its place.  
79:20 - Wrap the entire form in a deal in bind it's hidden 
property to the app component submitted property.  
79:32 - The main form is visible from the start 
because the submitted property is false  
79:36 - until you submit the form as this fragment 
from the app component chose to show something  
79:43 - else while the form is in submitted state add 
the following HTML below the new div wrapper  
79:56 - add the properties that you 
updated in the edit button.  
79:59 - If the user wants to update the fields again.  
80:12 - And now let's preview how it works. 
That's all about template driven forms.  
80:25 - Now in the next section, we're going to see 
how we can take more control of our forms  
80:30 - and how to create reactive forms.  
80:34 - Reactive forms provide a model driven approach 
to handling form inputs, whose values change over  
80:40 - time. Each change to the form state returns 
a new state, which maintains the integrity  
80:46 - of the model between changes. Let's add basic form 
control. To use reactive form controls, import  
80:54 - reactive forms module from Angular forms package 
and added to your NGO modules import array.  
81:06 - To register a single form control, import a form 
control class and create a new instance of form  
81:13 - control to save as a class property. Use the 
constructor of form control to set its initial  
81:19 - value, which in this case is an empty string. By 
creating these controls in your component class,  
81:25 - you get immediate access to listen for update 
and validate the state of the form input.  
81:33 - After you create a control in the component class, 
you must associate it with a form control element  
81:38 - in the template Are they the template with a 
form control using the form control binding  
81:44 - provided by form control directive, which is 
also included in the reactive forms module.  
81:51 - Using the template binding syntax, 
the form control is now registered to  
81:56 - the name input element in the template, you 
can display the value in the following ways  
82:02 - through the value changes observable very can 
listen for changes in the form of value in the  
82:07 - template using async pipe or in the component 
class using the subscribe method or with the  
82:14 - value property, which gives you a snapshot of the 
current value. The following example shows you how  
82:21 - to display the current value using interpolation. 
In the template. The displayed value changes as  
82:27 - you update the form control element. Reactive 
forms have methods to change it controls value  
82:34 - programmatically, which gives you the flexibility 
to update the value without user interaction.  
82:40 - The following example as a method to the component 
class to update the value of the control to Nancy  
82:46 - using the set value method. Update the template 
button button to simulate a name update.  
82:56 - When you click the Update name button, the value 
entered in the form control element is reflected  
83:02 - as its current value. The form model is the source 
of truth for the control. So when you click the  
83:09 - button, the value of the input is change within 
the component class, overriding its current value.  
83:19 - Form stabilty contains several related 
controls. Reactive forms provide two ways  
83:23 - of grouping multiple related controls into 
a single input form. First way of form group  
83:30 - defines a form with a fixed set of controls 
that you can manage together. And second way  
83:36 - of form array defines a dynamic form where 
you can add and remove controls at runtime.  
83:44 - import the form group and form control classes 
from the angular forms package. Create a property  
83:50 - in the component class name profile form, and 
set the property to a new form group instance.  
83:58 - to initialize the form group provide a 
constructor with an object of named keys  
84:03 - mapped to their control. For the profile form 
add to form control instances with the names  
84:10 - first name and last theme. The individual 
form controls are not collected within a  
84:16 - group. After you define a model, you must update 
the template to reflect the model in the view.  
84:33 - I'm adding two inputs and two labels that 
match our model. The form control name input  
84:39 - provided by the form control name directive binds 
each individual input to the form control defined  
84:46 - in the form group. The forum comm directive 
lessons for the Submit event, immediate buy  
85:04 - the form element and emits an mg submit event 
that you can bind to a callback function.  
85:11 - Add an mg submit event listener to the form 
tag with the on submit callback method.  
85:20 - The onsubmit method captures the 
current value of profile form.  
85:28 - Here, you will just log the form value.  
85:38 - The submit event is emitted by the form tag 
using the native Dom event, you trigger the  
85:44 - event by clicking a button in submit type. This 
allows the user to press the Enter key to submit  
85:50 - the completed form. Add a button to the bottom 
of the form to trigger the form submission.  
85:59 - And that's all for reactive forms. In the next 
section, we're going to see how we can improve  
86:04 - our forms. So in this section, 
we're covering form validation.  
86:13 - This tutorial will show you how to validate 
user input from the UI and display useful  
86:18 - validation messages in both reactive and template 
driven forms. Anything that you want to store to  
86:25 - your database needs to have multiple levels 
of validation and AC validation the same as  
86:30 - if you're at an audition, or job interview 
something or whether someone is presenting  
86:36 - to you and you decide will he pass or not. 
To add validation to a template driven form,  
86:43 - you add the same validation attributes as you 
would with native HTML form validation. Angular  
86:50 - uses directives to match these attributes with 
validator functions in the framework. Every  
86:56 - time the value of a form control changes, anger 
runs validation, and generates either a list of  
87:02 - validation errors that results in an invalid 
status or not. It results in a valid status.  
87:11 - I'll create a name string field 
inside of our component class.  
87:19 - Then in our HTML file, I'll add an input text 
field with required attribute me length of four.  
87:35 - I'm binding name input property to energy model,  
87:38 - and I'm exporting energy model 
to a local variable called main  
87:48 - engine model mirrors many of the properties 
of its underlying form control instance.  
87:54 - So can use this template to check for 
control states such as valid and dirty.  
88:00 - The mgf of the div element reveals 
a set of nested messages they have,  
88:05 - but only if the name is invalid, and 
the control is either dirty or touched.  
88:16 - Each nested they have can present a custom 
message for one of the possible validation errors.  
88:26 - These are messages for acquired admin lead.  
88:39 - Now if we type something and leave the field 
empty, we will get the validation error message.  
88:44 - And the same goes if we enter value 
less than four characters long.  
88:51 - In a reactive form, the source 
of truth is a component class.  
88:56 - Instead of adding validators 
through attributes in the template,  
89:00 - you add validator function directly to the 
form control model in the component class.  
89:10 - The same built in validators that are 
available as he was in template driven forms,  
89:16 - such as required and min length are all available 
to use as functions from the validator class.  
89:26 - To update the validation form to be a reactive 
form, use some of the same built in validators.  
89:33 - In this example, the name control 
sets up to a built in validators  
89:37 - validators required in validators min length.  
89:44 - These validators are synchronous, so 
they are passed as the second argument.  
89:48 - Notice that you can support multiple 
validators by passing the functions  
89:52 - in as an array. This example also adds 
a getter method. In a reactive form,  
89:59 - you can always access any form control 
through the get method on its parent  
90:04 - group. But sometimes it's useful to define 
and getters. It's shorthand for the template.  
90:14 - In our template, add form group to our form.  
90:25 - And now, only thing that we need to 
change in our template to make it reactive  
90:30 - is to remove Angie Murrell and to bide 
our name control to form control name.  
90:36 - This forum differs from the template driven 
version in that delong exports any directives.  
90:42 - Instead, it uses the name gatter 
defined in the component class,  
90:46 - known as the required attribute 
is still present in the template.  
90:50 - Although it's not necessary for validation, it 
should be retained for accessibility purpose.  
90:58 - We finally came to the end of this long tutorial, 
and we're going to cover communication using HTTP  
91:03 - client. Imagine that you're running a TV 
station or a newspaper. And what if you  
91:08 - lose communication to reporters, you would end 
up with a blank newspaper or no news broadcasts  
91:15 - is the same thing with web apps. Without backend 
communication, our apps will be bad without  
91:20 - informations or instructions on the back end. 
Most front end applications need to communicate  
91:26 - with a server over HTTP protocol to download or 
upload data and access other backend services.  
91:33 - Before we can use HTTP client, you need 
to import Angular HTTP client module.  
91:43 - Most apps do so in the root app module.  
91:51 - Let's create data service. Most common use 
case is to inject HTTP client into service.  
91:57 - In use it throughout the application, you can 
then inject HTTP client service as a dependency  
92:01 - of an application class, as shown in this example. 
Now let's see how we can fetch data from a server.  
92:08 - To do that, we're going to use HTTP client get 
method. First inject HTTP client into our service.  
92:21 - Then create get data method and inside 
of this method will fetch our data.  
92:29 - the get method takes two arguments the endpoint 
URL from which to fetch and an options object  
92:34 - that you use to configure the request to add 
things like parameters to your request. For this  
92:40 - tutorial, I found a free cocktail API service. 
The link will be in the description box below,  
92:46 - enter the URL, and no additional 
parameters are required in this case.  
92:51 - Now in our app component, we inject 
the data service in the constructor  
92:57 - inside of MG on init method, let's call our 
get data method. Because the service method  
93:05 - returns an observable, the component 
subscribes to the methods return value.  
93:13 - I'm just gonna console log in. And 
that's how you get data from the server.  
93:23 - In an ideal world, everything works as a magic. 
But we don't live in an ideal world, fortunately,  
93:29 - and we lose connection with API sometimes. So we 
need to handle errors when they come up. If the  
93:36 - request fails on the server, HTTP client returns 
an error object instead of a successful response.  
93:44 - Let's add a pipe on our get method 
and use cash error to catch it.  
93:52 - I'm going to log the error for development purpose 
and return throw error with some message. They  
93:58 - should be used in your obligation to show the user 
that his request has failed. Without notification,  
94:03 - they wouldn't know what's happening. And 
don't forget to import missing packages.  
94:12 - Now we can change the URL to break the request. 
And to see the error, we usually don't want to  
94:17 - see this view in our obligations. But we 
need to be ready for that when it happens.  
94:22 - HTTP client besides get also has a POST method for 
submitting data to server. For example, if you are  
94:29 - submitting a form, we have delete requests 
for deleting data from database obviously,  
94:35 - a pull request which replaces a resource with 
updated data. Now, most of the API's require an  
94:42 - authentication key with their requests. So let's 
see how we can add that I found this Lord of Rings  
94:48 - database which requires an auth key. Let's create 
HTTP options object with the headers property.  
94:57 - This property will be a new HD We had this 
object, and we will pass two properties.  
95:05 - Content Type is application JSON, which means that 
we're using JSON as content and authorization,  
95:15 - where we enter our API key barrier is 
type of authorization, and follow by key.  
95:21 - In order to get your personal key you need to 
register link is in the description box below.  
95:28 - Now, are they the API endpoint. And if you try 
to call it without passing the HTTP options,  
95:36 - you can see that we get an error. What if we 
add authorization the request is successful.  
95:48 - Congratulations, you watch all the way through the 
end. This was very long tutorial and I hope you  
95:53 - learned a lot of new things. Also, don't forget 
to subscribe to Free Code Camp. And if you want  
95:59 - to see more tutorials like this, don't forget 
to check out my channel. My name is Slobodan,  
96:04 - and I'll see you guys in one of the next 
videos or tutorials. Take care. Until then.