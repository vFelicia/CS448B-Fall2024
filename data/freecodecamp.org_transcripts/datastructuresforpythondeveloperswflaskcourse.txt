00:00 - people often learn about data structures
00:02 - out of context
00:03 - but in this course you will learn
00:04 - foundational concepts by building a real
00:07 - world api
00:08 - with python and flask giorgio is the
00:11 - instructor
00:11 - and he has a knack for helping people
00:13 - understand data structures in a
00:14 - practical way
00:16 - hey what's up everybody my name is
00:17 - giorgio and in this video we're going to
00:19 - learn about what i consider to be the
00:21 - most foundational data structure
00:22 - concepts by building an api using flask
00:25 - and python
00:26 - this video is directed towards both
00:27 - beginners and experienced programmers
00:30 - the only prerequisite for this tutorial
00:32 - is a basic understanding of python
00:34 - we'll start with installing python in
00:36 - flask and setting up our virtual
00:37 - environment
00:38 - and then we'll move into configuring our
00:40 - database and
00:41 - coding up our api skeleton from there
00:44 - we'll add the routes to our api by
00:46 - making use of data structures such as
00:48 - linked lists hash tables binary search
00:51 - trees and stacks and queues
00:52 - and of course if you're interested in
00:54 - more from me be sure to subscribe to my
00:56 - youtube channel
00:57 - essie like a pro for more content like
00:59 - this and without further ado
01:00 - let's get started to begin we'll need to
01:03 - install both python and flask
01:05 - the installation process for python
01:07 - starts at python's website here
01:09 - which i will also link in the
01:10 - description so to start
01:12 - you'll just want to go to this downloads
01:14 - tab and then download python 3 for your
01:16 - operating system
01:19 - after the download is complete you'll be
01:21 - able to access the installer which is
01:23 - self-explanatory
01:24 - once you've completed the python 3
01:26 - installation process you should be able
01:28 - to check that the installation was
01:29 - successful by typing in
01:31 - python 3
01:34 - dash dash version at the command line
01:37 - most likely my python version will be
01:39 - different from yours i have an older
01:41 - version but as long as you have the most
01:43 - updated version you'll be okay for this
01:44 - series
01:45 - now that we have python installed we can
01:47 - move on to installing flask
01:49 - the flask installation documentation can
01:51 - be found here
01:52 - which i will also link in the
01:53 - description the flask installation is
01:55 - pretty straightforward
01:56 - the documentation will go over the
01:58 - benefits of using a virtual environment
02:00 - and will also instruct us on how to set
02:02 - up our virtual environment now a virtual
02:04 - environment
02:05 - essentially just compartmentalizes our
02:07 - project and its dependencies so that
02:09 - there won't be any clashes with
02:11 - additional projects that we might make
02:12 - in the future so within this virtual
02:14 - environment that we create
02:15 - all of the libraries and the version of
02:17 - python that we use at the time of the
02:19 - initiation of the virtual environment
02:21 - will be
02:22 - preserved and contained within that
02:23 - environment and if in the future
02:25 - you set up another python project you
02:27 - would then initiate another virtual
02:29 - environment for that project
02:30 - specifically so to create a virtual
02:32 - environment we'll first need to create a
02:34 - directory that will contain our project
02:36 - and then we'll cd into that directory
02:38 - and we'll use this python command
02:39 - to call the virtual environment module
02:42 - and this here will be the directory that
02:43 - the environment will be allocated to
02:47 - so i'm just going to call our project
02:49 - directory flask api
02:55 - and then change directory into that
02:56 - folder
02:59 - so once we're in our project folder we
03:01 - can create our virtual environment by
03:03 - running the command from the flask
03:04 - documentation
03:09 - and once this command has completed its
03:11 - execution you'll be able to see the
03:13 - environment folder
03:14 - by typing ls to list the contents
03:17 - of your current directory and if you
03:19 - change directory into this environment
03:21 - bolder
03:21 - and ls again you'll see the contents
03:24 - contain
03:24 - more subfolders but you don't actually
03:26 - need to worry about what all of these
03:28 - are
03:28 - currently just know that whenever we
03:30 - install a new library
03:32 - it's going to be contained within this
03:33 - folder and also our current version of
03:35 - python that we use to initialize this
03:38 - environment will be also contained
03:40 - within this folder and we can double
03:41 - check that if we ls this bin folder
03:44 - and within this folder we can see our
03:46 - python binaries as well as our pip
03:48 - binaries
03:49 - and pip is just going to be used to
03:51 - install additional libraries
03:53 - so we can see the back one directory
03:57 - and now we're back in our project
03:58 - directory so now that we've installed
04:00 - our virtual environment we now need to
04:02 - activate our virtual environment because
04:04 - currently although we've installed the
04:05 - environment we haven't yet activated it
04:07 - so to activate it as we see in the
04:09 - documentation here we can use this
04:11 - command to activate our virtual
04:12 - environment so we can just
04:14 - paste that command in here and now our
04:16 - virtual environment should be activated
04:18 - and for most of you you'll be able to
04:20 - see that the environment is activated
04:21 - because you'll see
04:22 - in parentheses here it'll say
04:24 - environment but for me my shell is
04:26 - configured in a way that doesn't allow
04:27 - the display of the environment but you
04:29 - can know for sure that your environment
04:30 - is activated if you type in this command
04:33 - so you'll type in environment and then
04:35 - you'll pipe it into grep
04:37 - and then you're going to grab virtual
04:40 - environment
04:42 - and if you type in this command you
04:44 - should see an environment variable
04:46 - called virtual environment that contains
04:48 - the path to your virtual environment
04:50 - and again the path is going to be this
04:52 - venv folder that's within our project
04:54 - directory
04:55 - so now that we've activated our virtual
04:57 - environment we can move on with
04:58 - installing flask
05:00 - so to install flask we just need to use
05:02 - pip and run this command
05:03 - pip install flask so we can just copy
05:06 - and paste that and then with our
05:07 - virtual environment running we can just
05:09 - run pip install flask
05:12 - and if you get this warning down here
05:13 - that says that your version of pip
05:15 - needs to be upgraded you can go ahead
05:17 - and run this command
05:22 - here
05:25 - so once we've installed flask and we've
05:28 - updated pip if necessary we can kind of
05:30 - get an idea of how this virtual
05:31 - environment is working
05:32 - if we ls our virtual environment folder
05:34 - once again
05:35 - and then ls this bin folder which
05:38 - contains the binaries
05:39 - that we can use within this virtual
05:41 - environment
05:42 - and now you'll see that within this bin
05:44 - folder we'll have a flask binary
05:46 - so now whenever we're running this this
05:48 - flask command within our virtual
05:50 - environment it's going to be using
05:52 - this flask binary to run the command as
05:54 - opposed to any global installation of
05:56 - flask that you might have on your system
05:58 - so everything that we install for this
06:00 - project is going to be contained within
06:02 - this
06:02 - environment within this environment
06:04 - folder it should be noted that in a real
06:07 - production application the structure of
06:08 - your code will likely be different
06:10 - depending on the size of the application
06:12 - for the purposes of this tutorial and to
06:14 - reduce the level of complexity of the
06:16 - application structure in order to focus
06:18 - on learning the targeted concepts
06:20 - we'll write the entirety of our api with
06:22 - the exception of our data structures in
06:23 - one dot pi file
06:25 - if you would like to later extend this
06:26 - api you can easily reorganize the
06:28 - structure of the application by
06:30 - splitting the single dot pi
06:31 - files and moving the resulting parts
06:33 - around according to your needs
06:34 - so we'll create our main file for our
06:36 - api and we'll call it server.pi
06:39 - and just a quick note throughout this
06:41 - tutorial i'll be using vim as my text
06:43 - editor but feel free to use whatever
06:45 - ide or text editor that you feel
06:47 - comfortable with it's only important
06:49 - that you create a server.pi
06:50 - file in our project directory to start
06:53 - we'll want to import flask request in
07:00 - jsonify
07:04 - and we'll want to create an app variable
07:06 - that points to a flask instance
07:12 - and if we take a look at what this flask
07:14 - object is actually doing
07:16 - we'll see that this flask object
07:18 - implements a whiskey application and
07:19 - acts as the central object
07:21 - it is passed the name of the module or
07:22 - package of the application once it is
07:24 - created it will act as a central
07:26 - registry for the view functions the url
07:28 - rules template configuration and much
07:30 - more
07:30 - you don't really need to know what's
07:31 - happening behind the scenes here just
07:33 - know that
07:34 - this whiskey application is a middleware
07:37 - that sits between
07:38 - our python application in the server and
07:40 - it's what's going to make the
07:41 - implementation of our api possible
07:45 - so we can go ahead and add comment here
07:47 - that just says app
07:48 - next we'll want to set up the database
07:50 - configuration to our application
07:52 - so we can add configurations to this app
07:54 - that we just created
07:55 - by adding them to this configuration
07:57 - dictionary that's already a part of our
07:59 - app
08:00 - instance so if we go to the definition
08:03 - here we can just see that the
08:04 - configuration dictionary
08:06 - behaves exactly like a regular
08:07 - dictionary which means that
08:10 - if we wanted to add a key for our
08:12 - database
08:20 - we could do it like we would add a value
08:21 - to any other dictionary
08:24 - and for the sake of simplicity for this
08:26 - project we'll just be using an sqlite
08:28 - database
08:28 - which will essentially just be a local
08:30 - file that will contain the data for our
08:32 - database
08:36 - and we can just name this file sqlite
08:39 - db.file and we'll also want to create
08:42 - another configuration
08:50 - which we will just assign the value 0.
08:52 - and we don't need to bother ourselves
08:54 - with what this configuration is for
08:56 - just know that if we don't add this
08:57 - configuration we'll get errors
08:59 - and that's about all of the
09:00 - configuration that we're going to need
09:02 - to use a local file as our database
09:04 - we'll also need to make some additional
09:06 - imports
09:18 - now that we have our local database file
09:20 - configured we'll need a way to access
09:22 - and query that database within our
09:24 - python application
09:25 - and we'll do that by using this flask
09:27 - sql alchemy extension
09:29 - now if we access this link and go to the
09:32 - home page
09:33 - you can see that sql alchemy is an
09:36 - object relational mapper
09:37 - that gives application developers the
09:39 - full power and flexibility of sql
09:42 - essentially what an object relational
09:43 - mapper or an orm does
09:45 - is it allows you to interact with an sql
09:48 - database in an object-oriented
09:50 - way behind the scenes it's converting
09:52 - your object-oriented code into
09:54 - sql statements and queries so flask sql
09:58 - alchemy
09:58 - just makes sql alchemy more compatible
10:01 - with flask applications
10:03 - and the way this essentially is going to
10:04 - work is we're going to create classes
10:07 - that represent the tables in our
10:08 - database so for example if we have a
10:11 - table
10:11 - for users with an orm we're going to
10:15 - create models for each table and a user
10:18 - table in class form would look something
10:20 - like this
11:10 - and each of these are going to be
11:13 - columns within this user table
11:15 - and for each column we'll have the data
11:16 - type for the value and in the case of
11:18 - strings we'll have the maximum number of
11:20 - characters
11:21 - and this last one here posts is going to
11:24 - be a relationship to another table that
11:26 - we're going to create called blog
11:28 - posts because this api is going to be an
11:31 - api for a blog website so now that we
11:33 - understand what an object relational
11:35 - mapper is and we understand what
11:37 - sql alchemy is we can move back up to
11:40 - our necessary imports and configuring
11:42 - sql alchemy to work with our api
11:45 - so we're going to need to import
11:48 - sql alchemy
11:58 - and i'll go over what these imports are
12:00 - going to be used for in a second
12:09 - and we're going to need to add one more
12:11 - configuration because
12:13 - by default sqlite doesn't enforce
12:15 - foreign key constraints
12:16 - so we're going to need to add an
12:18 - additional section here
12:20 - to configure sqlite3
12:23 - to enforce foreign key
12:36 - constraints
13:27 - and you don't need to worry yourself too
13:29 - much about what this code means
13:30 - it's essentially just allowing us to
13:32 - configure the db connection
13:34 - to enforce foreign key constraints via
13:36 - this line here
13:38 - and from here we can create an instance
13:41 - of our database
13:44 - by passing our app into this
13:47 - sql alchemy class and if we go to the
13:50 - definition of this class we'll see that
13:52 - this class is used to control the sql
13:54 - alchemy integration to one or more flask
13:56 - applications
13:57 - so it's just connecting our orm with our
14:00 - flask application and we'll also just
14:02 - define a now variable
14:04 - for date values when updating tables in
14:08 - the future
14:12 - so now that we've got our configuration
14:13 - set up we can go ahead and save this
14:15 - file
14:16 - and we're going to need to install some
14:18 - of the imports that we added to our
14:20 - server.pi file
14:21 - so first let's check to see if our
14:23 - virtual environment is running by
14:25 - running this command
14:26 - and if you see that this virtual
14:29 - environment environment variable
14:31 - has the path to our projects v e and v
14:34 - folder then we are good to go
14:35 - so for those of you that are using mac
14:38 - sqlite is already going to be
14:40 - pre-installed on your system
14:41 - but if you're using something like linux
14:43 - then depending on your disk drill you
14:45 - can install sqlite by running
14:47 - apt-get install sqlite3 or
14:50 - uninstall sqlite3 but again you're going
14:54 - to have to
14:55 - look into installing sqlite for your
14:57 - particular system so we can go ahead and
14:58 - do python server.buy
15:00 - and we'll get errors so here it says
15:03 - that no module named sql alchemy
15:05 - of course because we didn't install it
15:06 - yet so on really quick
15:08 - let me just clarify something really
15:10 - quick so if we go back into our
15:12 - server.pi file
15:13 - you'll see that we're importing from sql
15:16 - alchemy
15:17 - and we're also importing from flask sql
15:20 - alchemy
15:20 - so the only reason we're importing from
15:23 - sql alchemy
15:24 - as opposed to flask sql alchemy here
15:27 - is because we need to configure sqlite
15:31 - to enforce foreign key constraints
15:33 - and we need to use this event and this
15:36 - engine from sql alchemy to actually
15:40 - make this configuration work but other
15:42 - than for
15:43 - this code here to enforce foreign key
15:45 - constraints throughout this application
15:47 - we'll be using flask sql alchemy
15:50 - so to install sql alchemy we can just
15:52 - run pip install
15:54 - sql alchemy and if we
15:57 - attempt to run our server again
16:00 - we no longer get the error for no module
16:03 - named sql alchemy but now we get the
16:05 - error for
16:06 - no module named flask sql alchemy in
16:09 - which case we'll do
16:10 - the exact same thing pip install
16:14 - flask sql alchemy
16:17 - now if we do the same thing and for some
16:20 - reason
16:21 - we're getting the error that i was
16:22 - telling you about when we added that
16:24 - additional configuration to our
16:27 - application
16:28 - so we set this sql alchemy track
16:30 - modifications to
16:31 - zero for false and it's telling us to
16:35 - explicitly set it to true or false to
16:37 - suppress this warning which i thought we
16:38 - did but let's go ahead and have a look
16:42 - and let's go ahead and see
16:47 - what it's saying see if we have the
16:50 - right
16:51 - name for the configuration variable
16:56 - and that's what i did wrong i had
16:59 - sql track modifications instead of sql
17:02 - alchemy track modification
17:04 - so we'll go ahead and save that we'll
17:06 - exit this
17:07 - and let's try this again and
17:11 - there we go all of our dependencies have
17:13 - been successfully installed
17:15 - so let's go back into our server.pi
17:18 - file and from here we can move on to
17:21 - creating
17:22 - our additional database model so this
17:24 - api
17:25 - is going to be a blog api so
17:28 - the two database models that we're going
17:30 - to need is this
17:31 - user model that we have here so we're
17:33 - going to create a user table
17:35 - and we're going to create a blog post
17:37 - model which is going to be
17:39 - a table for blog posts and we'll do that
17:42 - by
17:43 - doing class blog post
17:49 - and it's going to take in db.model
17:52 - and this db.model is coming from if we
17:55 - go to the definition of db
17:57 - we see that dv is an instance of this
17:59 - sql alchemy class
18:01 - so whenever we create a class for a
18:03 - table we need to take in this db model
18:06 - and we'll continue with adding a table
18:09 - name
18:10 - for this class and we're going to call
18:13 - the table
18:14 - blog post
18:17 - and this table is going to have an id
18:19 - column
18:26 - which is going to contain integer values
18:29 - and this is going to be
18:32 - a primary key
18:37 - and then we're going to have a title for
18:39 - the blog post
18:42 - and this is going to be a string with a
18:45 - maximum of 50 characters
18:49 - and finally we'll have the body and the
18:52 - body
18:53 - can be a maximum of 200 characters the
18:56 - body of the blog post
18:58 - and we'll take a date which is going
19:02 - to be db.date and last but not least
19:05 - we'll have a user id
19:07 - column which will tell us which user
19:09 - this blog post belongs to
19:11 - it's going to be
19:15 - an integer and it's going to be a
19:19 - foreign key
19:22 - from the user table id column
19:26 - and it's not going to be nullable
19:30 - so here you see that this user id in our
19:33 - blog post table
19:34 - is is going to have to be an id from our
19:37 - user table
19:38 - and it's not going to be able to be null
19:40 - and this is the reason that we have to
19:42 - enforce uh foreign key constraints here
19:45 - because if we wouldn't have implemented
19:46 - this portion
19:47 - of the configuration sqlite would just
19:50 - allow us
19:51 - to add blog posts that don't contain
19:53 - valid users
19:54 - but now that we enforce foreign key
19:56 - constraints the user ids that are passed
19:59 - to our blog post
20:00 - are going to have to be user ids that
20:02 - exist within this user table
20:04 - so now that we've added the classes for
20:06 - our database schema
20:07 - let's go ahead and generate and have a
20:09 - look at what our database looks like
20:11 - instead of using the command line tool
20:12 - for sqlite3 to view our schema and
20:15 - tables
20:16 - let's download a dv browser for sqlite
20:18 - which will allow us to view
20:20 - our database via a graphical user
20:22 - interface the db browser that we'll use
20:24 - can be found here
20:26 - at sqlitebrowser.org i'll add a link to
20:28 - the description of this video
20:30 - and once you've accessed this link
20:32 - depending on your operating system
20:34 - you'll download this db browser using
20:36 - one of the links listed below
20:37 - so in my case i'm using mac os so i
20:40 - would use this link here
20:43 - and once we've downloaded our db browser
20:45 - we can actually
20:46 - generate our database we can do this by
20:48 - running the python shell from the
20:50 - command line
20:51 - and creating our database tables based
20:53 - on the models that we've created
20:55 - so we can go ahead and save this file
20:56 - and exit and let's clear this
20:59 - and to run the python shell all we have
21:01 - to do is type in
21:02 - python and to generate our database we
21:04 - want to
21:05 - import the sql alchemy instance which we
21:08 - assigned to the variable database
21:14 - and here server is just the name of our
21:16 - dot pi file which is the name of our
21:18 - module and then
21:19 - db is the variable that we assigned to
21:21 - the instance of the sql alchemy database
21:24 - so once we have that imported we can now
21:26 - access the methods of this db instance
21:29 - and we can just type in db.create
21:32 - all which will create our database by
21:35 - creating the
21:36 - tables based on the classes that we've
21:38 - created in our server file
21:41 - and then we can exit the python shell
21:43 - and if we ls
21:44 - we'll see that our sqlite database file
21:48 - has been created and if we go back into
21:51 - our server.pi
21:52 - file we'll see that in our app
21:54 - configuration
21:55 - for sql alchemy database uri we set the
21:58 - uri
21:59 - to the file sqlitedb.file
22:04 - which is the file that was created when
22:06 - we generated the database
22:08 - so our entire db is going to be
22:10 - contained within this file
22:12 - if we delete this file we're also
22:14 - deleting our database
22:15 - and we can view our database by opening
22:17 - this file using the db browser that we
22:19 - just created
22:20 - so you can start by executing the db
22:22 - browser that we installed for sqlite
22:26 - and once we've opened the db browser the
22:29 - interface will look like this
22:31 - and we can just click this open database
22:35 - and from there we can make our way to
22:37 - our project directory
22:39 - flask api and we'll see our sqlitedb
22:42 - file here and we can just select it and
22:44 - click open
22:45 - and now you'll be able to see both of
22:47 - our tables
22:48 - and if we expand this we'll see all of
22:51 - the columns for
22:52 - our table and if we browse the table
22:58 - we can expand these
23:05 - and this is what our table for our blog
23:08 - post looks like
23:09 - which contains an id column a title
23:11 - column a body column
23:13 - a date column and a user id column
23:17 - and as we can see if we go back into our
23:19 - server.pi
23:20 - file and we go down to our blog post
23:24 - table
23:25 - we can see that this corresponds exactly
23:27 - with the class that we created
23:30 - so we have an id column we have a title
23:33 - column
23:34 - we have a body column and we have a date
23:36 - column and a user id column and this is
23:38 - what i meant when i said that an
23:40 - object relational mapper allows you to
23:43 - interact with the database
23:44 - in an object-oriented way we're creating
23:47 - a class
23:48 - that's representative of a table in an
23:51 - actual sql database
23:53 - so now that we've gotten everything set
23:54 - up for our database we can start
23:56 - creating the routes
23:57 - for the api
24:01 - so we can just say routes so the way
24:03 - that flask works is
24:04 - in order to create a function that
24:06 - corresponds to a route
24:07 - we need to use this app.route decorator
24:12 - and within this decorator we need to
24:14 - pass the rule
24:18 - and the methods
24:21 - and this first one will be a post and in
24:23 - this route we're going to define a
24:25 - function to create
24:26 - a new user and for now
24:30 - we'll just pass because we're just
24:32 - setting up the skeleton for the
24:33 - application
24:35 - so if we go to the definition of route
24:37 - we see that
24:38 - route is a decorator that is used to
24:40 - register a view function for a given url
24:43 - rule
24:44 - so basically what that means is the url
24:46 - rule
24:47 - in this case is going to be this forward
24:50 - slash user
24:51 - so whenever this forward slash user is
24:53 - appended to our
24:54 - url the request is going to be routed to
24:57 - this particular function for create user
25:00 - if it is a post request so what we're
25:03 - going to do is we're going to
25:05 - create a couple of these routes
25:09 - and they're all going to serve their own
25:11 - individual purpose
25:12 - and we're going to create the route
25:14 - function for each of these individual
25:16 - routes
25:16 - in future videos so for now let's just
25:19 - create the skeleton of the api so this
25:22 - rule
25:23 - is going to be sending id
25:26 - and right now you don't need to bother
25:27 - yourself too much with what each of
25:29 - these
25:29 - individual routes and their functions
25:31 - are going to do
25:32 - because we're going to get to them in
25:34 - future videos for now we're just
25:35 - creating the skeleton of the application
25:38 - and this one's going to use the kit
25:40 - method
25:42 - and the function's going to be called
25:44 - get
25:45 - all users descending
25:50 - and again for now we're going to pass
25:53 - and we can do the same thing
25:58 - and change this to ascending
26:01 - id and it will also be a get method
26:05 - and we'll change this to sending
26:11 - and again right now don't bother
26:13 - yourself with
26:14 - what each individual route is going to
26:16 - be used for right now
26:22 - so this here where we're adding in this
26:24 - user id this is just going to
26:26 - allow us to pass a user id to our path
26:30 - and then we'll then be able to use this
26:31 - user id variable
26:33 - within this function
26:38 - because we'll be able to pass it in here
26:40 - so we'll be taking
26:42 - this user id and passing it into this
26:45 - function
26:45 - get one user and the user id is just
26:48 - going to be
26:49 - whatever id we append to this url
26:52 - and let's continue
26:58 - this one will be a delete
27:02 - and we'll change this to delete user
27:14 - and here we're going to
27:17 - create a blog post for a specific user
27:20 - id
27:22 - so we're still going to pass user id to
27:24 - the function
27:25 - and we'll change the name of this
27:26 - function to create
27:28 - blog post
27:38 - this will be a git and we'll change this
27:41 - to
27:42 - user and this will be get
27:45 - all blog posts
28:15 - finally this will be a delete
28:22 - delete blog post
28:26 - and that'll be it for our routes and
28:29 - lastly if
28:30 - name equals
28:34 - main
28:38 - app.run and we want to set
28:41 - debug equal to true and all this is
28:45 - saying is
28:45 - if we're running this server.pi file as
28:48 - our main application
28:50 - then we're going to start our api with
28:53 - debug equal to true
28:54 - and what do i mean by if we're running
28:56 - this server.pi file as our main
28:59 - application
29:00 - all i mean is if we're running it as our
29:02 - main application
29:04 - on the command line we would type python
29:07 - and then server.pi
29:08 - so we're running this server.pi
29:12 - file as our main application then this
29:14 - internal
29:15 - variable is going to be set to equal
29:18 - main because that means that this is our
29:21 - main application
29:22 - because we're running this file directly
29:24 - as our main application
29:26 - when we pass it to this python command
29:31 - so now let's save this
29:35 - and let's go ahead and run this and see
29:37 - if we get any errors
29:39 - and as you can see our server is now
29:41 - running
29:42 - and debug mode is set to on and our
29:44 - server is running on local host port
29:52 - 5000.
29:56 - before we get into linked lists let's
29:58 - start by adding the functionality to our
29:59 - create user route
30:02 - so we can start by removing this pass
30:04 - and this first route is going to be
30:06 - relatively simple
30:07 - but it's going to tell us most of what
30:09 - we need to know about how
30:10 - we'll interact with the orm or the
30:12 - object relational mapper which we
30:14 - discussed in the previous video
30:16 - so we can start by creating a variable
30:18 - to store our request data
30:22 - and although it might seem like this
30:24 - request object is coming out of nowhere
30:26 - it's actually
30:26 - provided by flask and we don't really
30:28 - need to know much about the underlying
30:30 - implementation
30:31 - just know that when we're working with
30:33 - our routes we'll have available to us
30:35 - this request object
30:36 - and what this git json method is going
30:38 - to do is
30:39 - it's just going to parse our request
30:42 - payload as json
30:43 - allowing us to access the parameters via
30:46 - their key values
30:47 - for example if the request contains a
30:49 - payload that looks like this
30:55 - we'll be able to access this bill value
30:58 - the same way that we would access a
30:59 - dictionary value based on its key
31:01 - so in our case this payload is going to
31:03 - be data
31:04 - so we'd be able to access it by doing
31:07 - data
31:08 - name
31:12 - which is exactly what we're going to do
31:13 - so we're also going to create
31:15 - a new user variable and it's going to be
31:18 - an instance of our user class that we
31:20 - created above
31:22 - here
31:25 - so whenever we create a new user we're
31:27 - going to have to
31:28 - do it by creating an instance of the
31:30 - class user so in our case
31:33 - the user has a name which is just going
31:35 - to be data
31:37 - name and an email address and a phone
31:40 - number
31:41 - so
31:44 - just copy these
31:58 - address
32:01 - and with this instance of our user class
32:03 - adding this
32:04 - new user to our database is as simple as
32:07 - doing
32:07 - dv.session dot add and then the name
32:11 - of the instance followed by
32:15 - db.session.commit
32:17 - and this is all we'll need to do to
32:18 - create a new user and once
32:20 - all of this is completed successfully we
32:23 - can just return
32:24 - a response and we'll just do
32:27 - jsonify
32:34 - user created
32:38 - as well as 200 and this 200 is just
32:41 - going to be
32:42 - the status code for our response and the
32:44 - 200 status just means that the request
32:46 - was successful
32:47 - so we can save this and we can run our
32:50 - server again and see if we get any
32:52 - errors
32:54 - and we do not now the server is running
32:56 - and now we can actually test the route
32:57 - and see if it works
32:59 - and to do that we're going to install an
33:00 - app called postman to send requests to
33:02 - our server
33:03 - so to install postman what you want to
33:05 - do is go to postman.com
33:08 - forward slash downloads and i will put a
33:10 - link in the description of this video
33:13 - and you're simply going to want to click
33:15 - this download the app
33:17 - if you want you can use the browser
33:19 - version but i recommend using
33:20 - the actual application version and to
33:23 - download it
33:24 - it's pretty straightforward you're just
33:25 - going to click this
33:27 - and you're going to save this file and
33:29 - you'll simply unzip this file and you'll
33:31 - have the application available to you
33:32 - then
33:33 - and if you're using a mac you might want
33:34 - to move the application that's extracted
33:36 - from this zip file to the application
33:38 - folder
33:39 - once you have postman you can go ahead
33:40 - and run the application
33:43 - and once you have postman open you can
33:45 - just go here and click
33:46 - new and then you can create a new
33:48 - collection and you can just name this
33:50 - collection
33:51 - flask api or whatever you like you don't
33:54 - really need to do a description
33:56 - i'll just hit create and after you've
33:58 - created your collection you should see
33:59 - it here
34:00 - and then you can just expand this and
34:02 - hit add request
34:04 - and here we'll just name the request
34:06 - create user and again we don't need to
34:08 - do a description and we can just
34:10 - save to flask api collection and then
34:13 - you'll have a request within this
34:14 - collection called create user and you
34:16 - can just click that
34:18 - and you'll be presented with a tab that
34:20 - says create user that looks something
34:22 - like this
34:23 - and here it says enter request url and
34:26 - then now it says that we're running our
34:27 - server on
34:28 - localhost port 5000 which is our request
34:31 - url so we can just copy this
34:34 - and then paste it into this request url
34:37 - section
34:39 - and for this create user request we're
34:42 - going to be
34:43 - calling our create user route let me
34:45 - just open
34:46 - another tab here and let's just change
34:49 - directory to
34:52 - flask api and we can just go back into
34:55 - our server.buy again
34:58 - and let's go down so the route that
35:01 - we're working with
35:02 - is this route here and as you can see
35:05 - our rule is forward slash user so we're
35:08 - going to need to append this forward
35:10 - slash user to
35:12 - our url and it's going to be a post
35:15 - request
35:16 - so back in postman we can just put user
35:18 - here
35:19 - so now we have our forward slash user
35:21 - rule
35:22 - and we can change this get method to
35:25 - post and then what we need to do is we
35:28 - need to go down to this body tab
35:31 - and we're going to use raw and we're
35:34 - going to change this from text
35:36 - to json and now we can input our
35:39 - request payload it's going to be named
35:44 - bill it doesn't really matter email
35:49 - test email.com
35:54 - address just a random address
35:58 - 281 street and just a random number
36:02 - for the zip code and then lastly
36:05 - phone and let's just put some random
36:08 - numbers in there
36:09 - so this is going to be our payload and
36:12 - our
36:12 - server is running in this tab we can see
36:15 - that our server is still running
36:17 - so now we can go ahead and try and send
36:19 - our request by hitting this send button
36:21 - here
36:23 - and once we send the request we can see
36:25 - the results
36:26 - some of you guys might have this result
36:28 - section hidden so we can just expand
36:30 - this down here
36:32 - to see the results and as you can see we
36:35 - have a status
36:36 - 200 which is a success response which is
36:39 - okay
36:40 - and it even says here standard response
36:41 - for successful http requests
36:44 - which is helpful and we also have our
36:46 - message here that we return after we've
36:48 - successfully created a new user which is
36:50 - just message user created
36:51 - in json format so since we were able to
36:54 - successfully create this new user
36:56 - we should be able to see the record for
36:58 - this new user in our database
37:00 - so let's go ahead and open up the db
37:02 - browser that we downloaded and make sure
37:04 - everything is working as expected so
37:06 - let's just start the db browser
37:07 - application
37:11 - and once we've started the application
37:13 - we can just go up here
37:14 - and select open database
37:17 - and from here we'll want to traverse to
37:19 - the path of our database file which is
37:22 - flask api which is our application
37:24 - directory
37:25 - and within our application directory you
37:28 - should have this
37:29 - sqlitedb.file which is our database file
37:32 - this file contains the entirety of our
37:34 - database
37:35 - and we can just select this and click
37:37 - open and from here we can go to our user
37:40 - table and we can right click it
37:42 - and then just select browse table and
37:45 - you should see a row for the user that
37:47 - we just sent to request to create
37:49 - so this means that everything is working
37:51 - as expected with our user route
37:53 - so now that we've set up postman and
37:55 - we've created this initial route to
37:57 - create
37:57 - users we can go ahead and move on to the
38:00 - next route
38:01 - which is this route to get all
38:04 - users in descending order and this route
38:07 - is where we're going to make use of
38:08 - linked lists so we're going to come back
38:10 - to the code for this function here
38:12 - after we write the code for our linked
38:14 - list so let's go ahead and save this
38:16 - file and quit and if we ls here
38:19 - we'll see that we have our server.pi
38:21 - file in our database file here
38:23 - as well as our virtual environment and
38:25 - you don't really have to worry about
38:26 - this pi
38:27 - cache and throughout this series for our
38:29 - data structures to separate concerns
38:32 - we're going to create the data
38:33 - structures in separate files
38:34 - so we can just create another file in
38:37 - our directory and we can call it linked
38:39 - lists dot pi and again you don't have to
38:43 - use vim to create the file you can
38:44 - create the file
38:45 - in any way that you choose just make
38:47 - sure that it's in our project directory
38:49 - the same directory as our server.pi file
38:52 - now when we cut up these data structures
38:54 - i'm going to both
38:55 - write out the code for the data
38:56 - structures as well as try to explain how
38:58 - you can visualize the data structures by
39:00 - using blackboard so
39:02 - i'm going to switch between two
39:04 - different methods of teaching to kind of
39:05 - attempt to give you guys a better
39:07 - understanding of what's happening here
39:09 - so if you don't understand what
39:10 - something is after i write out the code
39:12 - for it just try to stick with me
39:14 - i will go into more detail throughout
39:16 - these portions of the tutorial
39:17 - so to start we're going to create a
39:19 - class called node which will initialize
39:21 - with three parameters self
39:23 - data and next node
39:27 - and we'll set data in next node's
39:29 - defaults to none
39:36 - and self.data will equal data which will
39:39 - either default to none or equal the
39:41 - argument passed for data at the time of
39:43 - instantiation and the same
39:45 - for next node it's going to equal next
39:48 - node which again will either be none
39:50 - or the argument passed for next node at
39:52 - the time of instantiation
39:54 - so what do i mean by at the time of
39:55 - instantiation so if we were to create a
39:57 - new instance of node like so
40:00 - we'll just call it node one which is a
40:02 - new instance of node
40:04 - this is us instantiating the node class
40:08 - so in other words we're setting this
40:09 - node 1 variable equal to a new instance
40:11 - of node so this node 1 variable will be
40:14 - bound to a node object
40:15 - in memory and if we instantiate this
40:17 - node without passing any arguments to it
40:19 - we're going to default both data and
40:21 - next node to none but if we were to pass
40:23 - in
40:24 - arguments for data and next node let's
40:26 - say for example we have another node and
40:28 - we can just call this one node two
40:30 - and we wanted this node to be the next
40:32 - node from node one
40:34 - we could instantiate this first node
40:35 - with some data and for our next node we
40:38 - could use the argument node2
40:40 - and in this case both our next node and
40:42 - our data will no longer default to none
40:44 - self.data will be set equal to the data
40:47 - that we passed
40:48 - and the same for self.nextnode it will
40:50 - be set to the next note that we
40:52 - passed at the time of instantiation
40:53 - which brings us to the meaning of self
40:55 - here
40:56 - if you're new to python self just
40:58 - represents a specific
41:00 - instance of a class so whenever we
41:02 - instantiate this node class we're
41:04 - essentially making a copy of a node
41:06 - object in memory so that means when we
41:08 - set this node one
41:09 - equal to an instance of the node class
41:11 - we're creating one node object in memory
41:13 - which can be referenced by using
41:15 - this node one variable and then we set
41:18 - this node two variable equal to an
41:20 - instance of the node class we're
41:22 - creating another copy of a node object
41:24 - in memory which can be referenced by
41:25 - using this node2 variable
41:27 - so at this point we have two copies of
41:29 - the node object in memory
41:30 - each which can be accessed by using
41:32 - their corresponding variable names node
41:34 - 1 and node 2.
41:35 - so when we initialize with this self
41:37 - parameter it's basically representative
41:40 - of
41:40 - a particular instance of this node class
41:43 - so when we set self.data equal to data
41:46 - it's setting the data value for
41:48 - that copy or object in memory equal to
41:51 - the data that we pass when instantiating
41:53 - and also actually we wouldn't be able to
41:55 - reference this node 2 here
41:58 - without first instantiating it so let's
42:00 - move this here
42:01 - so now we create an instance called node
42:03 - 2 and then we create an instance called
42:05 - node 1
42:06 - which has a next node that is equal to
42:08 - node 2.
42:09 - so after we create our node class we'll
42:11 - create a wrapper class which we'll just
42:13 - call linked list
42:16 - which will initialize with self only
42:23 - and for this class we'll have a head
42:26 - which we'll set equal to none
42:27 - and we'll have last node we'll set equal
42:31 - to none as well
42:32 - so let's try to visualize what's
42:33 - happening here so if we visualize a
42:36 - linked list it looks something like this
42:38 - and each of these rectangles within this
42:41 - linked list
42:42 - are nodes within the length list and
42:45 - each node has two separate compartments
42:47 - we have this left compartment here which
42:49 - contains the data
42:50 - and which in this case is going to be a
42:52 - string a
42:53 - and then we have this compartment here
42:55 - which contains the pointer that points
42:57 - to the next node
42:58 - and if you look at our linked list class
43:00 - you see that we also have this
43:02 - data compartment here and we have this
43:05 - next
43:06 - node pointer here as well but it should
43:08 - be noted that in python
43:09 - variables are just names bound to
43:11 - objects so this next node variable isn't
43:14 - actually a pointer
43:15 - when this next node variable is
43:16 - initialized it will be bound to the
43:18 - object
43:19 - that it's set equal to so when we create
43:22 - a new instance of node
43:23 - and we pass a next node to it this
43:26 - next node variable is going to be bound
43:29 - to the next node that we passed to it
43:31 - but for our purposes it's okay to think
43:33 - of this next node as a pointer because
43:35 - it will actually help you visualize
43:36 - things better when you think of this
43:37 - next node as a pointer
43:39 - for example let's say that we create an
43:41 - instance of our node class and we'll
43:43 - just call it node 1
43:45 - and we'll set it equal to a new instance
43:47 - of node
43:49 - and we'll pass a string that just
43:51 - contains the word data as our data
43:54 - and we'll pass none as our next node
43:57 - so what this is going to look like is
44:00 - we'll have
44:01 - node 1 which is this rectangle
44:06 - and we'll have this compartment that
44:07 - contains the string data
44:09 - as our data and then we'll have this
44:12 - compartment which contains our pointer
44:15 - to none
44:18 - and if we were to go ahead and create
44:21 - another
44:21 - instance of node and we'll just call
44:23 - this one node two
44:26 - and it would just be an instance of our
44:28 - node class
44:29 - and we would pass data to this one as
44:31 - well but this time
44:33 - as our next node we would pass in node
44:36 - 1 which would look like this we would
44:40 - get
44:40 - another rectangle here and then this one
44:43 - will also just contain a string that
44:45 - says data
44:47 - but then this one's pointer is going to
44:49 - be pointing to
44:51 - our node one and we can continue to do
44:54 - this to build
44:55 - a linked list that can look something
44:57 - like this but what is this length list
44:59 - wrapper actually for well this linked
45:01 - list wrapper is actually going to help
45:03 - us keep track of the head of our linked
45:05 - list
45:05 - so if you look at this length list image
45:07 - here you see that
45:09 - this first note of the linked list is
45:11 - the head
45:12 - so the first node within a linked list
45:14 - is going to be the head of the linked
45:15 - list
45:16 - and here if we were to just continue to
45:18 - instantiate
45:19 - node objects just randomly throughout an
45:22 - application it'd be quite difficult for
45:23 - us to keep track of
45:24 - which one of these nodes that we
45:26 - instantiate is the head
45:27 - because the only way to check which one
45:29 - of these instances is the head of the
45:31 - linked list is to actually go through
45:33 - each instantiation and then check
45:35 - which nodes are being passed as next
45:37 - node eventually
45:39 - after lots of unnecessary stress we can
45:41 - kind of figure out what the head of the
45:43 - linked list is but we can solve this
45:45 - problem by just
45:46 - creating this linked list wrapper which
45:48 - keeps track of the head of our linked
45:50 - list
45:51 - so whenever we want to add to our linked
45:54 - list we can either add to the beginning
45:56 - of the linked list or the end of the
45:58 - linked list
45:59 - and within this linked list class we
46:01 - would create a method for both adding to
46:04 - the end of the linked list
46:05 - and the head of the linked list so for
46:08 - example
46:08 - if we were to define a method here
46:12 - called insert
46:16 - beginning
46:20 - and it took in self
46:24 - and data we'd basically be able to do
46:27 - something similar to
46:28 - saying node is equal to a new instance
46:32 - of node
46:34 - then we pass in the data
46:38 - and then we can say our next node is
46:40 - whatever
46:41 - our current head is so self
46:44 - dot head
46:47 - and what that would do is say for
46:49 - example this is
46:51 - our current head and we want to add a
46:54 - note to the beginning here
46:57 - this node is going to contain
47:00 - data and it's pointing to
47:05 - our current head so in that case this
47:07 - node would no longer be
47:08 - our head this node would now be our head
47:10 - because we set this node's next node
47:13 - to self.head which is the current head
47:15 - which is this one but once we've done
47:17 - this
47:17 - we need to make sure that we keep our
47:19 - head variable updated
47:21 - so we would then set self.head equal to
47:24 - this node so we'll go self
47:28 - dot head equals
47:31 - node and this is just pseudo code we're
47:33 - actually going to write this out within
47:35 - the application but this is just so you
47:37 - guys can get a grasp of what's happening
47:39 - here when we add to the beginning
47:40 - of the linked list and adding to the end
47:43 - would actually be a different story
47:44 - because we're going to have to
47:45 - keep checking the next node next node
47:48 - next node until we reach a node whose
47:50 - next node is null or
47:52 - none and we'll get to that in a little
47:53 - bit it's one of the reasons why we're
47:55 - going to be keeping track of the last
47:56 - node as well
47:57 - but for now it's only important that you
47:59 - understand how this node is working
48:01 - as well as why we're wrapping it in this
48:03 - linked list class
48:07 - okay so now that we have a general
48:09 - understanding of how our
48:10 - node and linked list classes work let's
48:12 - create a print method within our linked
48:14 - list class so that we can keep track of
48:16 - what's going on
48:18 - so we can just add a new method
48:22 - we can just call it print linked list
48:25 - and we'll start by just initializing a
48:26 - variable
48:27 - to hold the string that will print at
48:29 - the end of the function which we'll call
48:31 - ll string which we'll set equal to an
48:33 - empty string
48:34 - so we'll start by setting node equal to
48:38 - self.head which is going to be the head
48:40 - of our linked list
48:42 - and if node is none that means that this
48:46 - linked list is empty
48:47 - because the head of the linked list is
48:48 - none so if that's the case we're just
48:50 - going to print none
48:52 - otherwise we'll use a while loop to
48:54 - traverse the linked list so we'll just
48:56 - do while node
48:57 - which just means that while node is not
48:59 - equal to none we're going to
49:01 - append to our string ll string
49:04 - plus equals and we'll use an f string
49:07 - because we need to add in
49:08 - node.data and we'll cast this to a
49:11 - string
49:12 - just in case the data isn't already a
49:15 - string and to help us visualize we'll
49:17 - add a visual representation of a pointer
49:22 - and here if our next node
49:25 - is none then we'll just append that next
49:29 - note to the
49:30 - string because the while loop will never
49:32 - get to a note that's equal to none
49:35 - and once this is finished we move on to
49:37 - the next node so we'll set note equal to
49:39 - node.nextnode and after this while loop
49:43 - is complete then we'll just print
49:44 - ll string so let's take a couple of
49:47 - seconds to go over what's happening here
49:49 - so
49:49 - while node isn't equal to none we're
49:52 - going to perform
49:52 - this code and what this code is doing is
49:56 - it's just going to append the data for
49:57 - each node
49:58 - to this string that we're going to print
50:00 - after the while loop is complete
50:01 - and the string is going to look like a
50:03 - visual representation of a linked list
50:05 - actually to make things less complicated
50:07 - we can just remove this and we can take
50:09 - this
50:09 - and we can just put it before the print
50:11 - statement after the while loop
50:14 - and if we do that then once we've
50:17 - appended all the nodes with data to our
50:19 - string
50:20 - we'll always append none to the end of
50:23 - the string
50:24 - because there's always going to be an
50:26 - empty node at the end of the linked list
50:28 - and then we'll just go ahead and print
50:29 - our string so let's see if this is
50:31 - working as expected
50:33 - we'll just create an instance of linked
50:35 - list
50:37 - and then we'll just create some nodes
50:45 - and let's see
50:48 - have one more so this node one here is
50:52 - going to be the head of our linked list
50:54 - so we need to
50:55 - change this to node to point to node two
50:59 - and we need to change this one to point
51:01 - to node three
51:04 - and this one we need to change it to
51:06 - point to node four
51:09 - and this node four is going to be the
51:11 - last node of our linked list so its next
51:13 - node is going to be none
51:15 - and then once we've done that we can set
51:16 - our linked list head
51:18 - equal to node one and then we can just
51:22 - do
51:22 - ll print ll
51:28 - and let's see what happens type in
51:30 - python linked list dot pi
51:32 - and we get our linked lists it looks
51:35 - kind of strange because the data is the
51:36 - same for every single node
51:38 - so let's go in here and let's just add
51:41 - in
51:42 - their corresponding numbers
51:47 - so now you see that we have data 1 data
51:50 - 2 data 3 data 4 and then none
51:52 - so this is our visual representation of
51:54 - the linked list
51:55 - that's being printed using the print
51:57 - method that we just created
51:59 - so now that we have a way to print our
52:01 - linked lists
52:02 - instead of manually creating the nodes
52:05 - and connecting them
52:06 - like we just did we need to add in
52:09 - methods for
52:09 - inserting at the beginning of the linked
52:11 - list and inserting at the end of the
52:13 - linked list
52:14 - so first we'll start with insert
52:18 - beginning
52:22 - and it will take data and this word is
52:25 - wrong
52:27 - insert so to insert at the beginning
52:29 - we're going to do something similar to
52:31 - what we did
52:32 - on the blackboard with the pseudocode
52:34 - we're going to create
52:35 - a new node and it's going to contain the
52:39 - data that we passed
52:40 - and its next node is going to be our
52:42 - current head and then we're going to set
52:44 - our new head equal to this new node so
52:47 - self.head is now going to be equal to
52:50 - new node so let's just go ahead and test
52:53 - that out
52:54 - we'll create another linked list
52:59 - and we'll do ll dot insert at beginning
53:02 - and then we'll put in some data then
53:05 - we'll do ll.print
53:10 - and then let's see what happens and we
53:12 - get our linked list with data inserted
53:14 - at the beginning so
53:15 - let's go back in here and see if we can
53:18 - add to the beginning so before
53:21 - our beginning contain data then we'll
53:24 - have not data
53:26 - so this not data should be the new
53:28 - beginning
53:30 - let's do python and then yeah we have
53:32 - not data and then data and then none
53:34 - so we can continue to insert at the
53:38 - beginning
53:39 - and it's always going to push the
53:42 - current beginning towards the end so
53:45 - we'll just change this to
53:46 - just something random
53:51 - and now we have cow not data data none
53:54 - so our print function and our insert at
53:57 - beginning functions are working as
53:59 - expected
54:01 - so now we need to create a method for
54:04 - insert
54:04 - at the end so let's go ahead and add
54:06 - that
54:07 - and insert at end
54:13 - so when inserting at the end we just
54:14 - want to make sure the linked list is not
54:16 - empty first
54:17 - and actually if the linked list is empty
54:20 - we'll just call the
54:20 - insert at beginning function to make
54:22 - things simple so to check to see if the
54:24 - linked list is empty we'll just do if
54:26 - self.head
54:27 - is none if it is we'll just do self dot
54:31 - insert at beginning and we'll pass to it
54:34 - data which we
54:36 - need to add here as well sorry about
54:37 - that now that that's out of the way
54:39 - so to add to the end of a linked list
54:41 - it's actually going to take
54:42 - oven time because we're going to need to
54:45 - traverse through each node
54:46 - and check if the next node is equal to
54:48 - none and that's how we'll know that
54:50 - we've reached the end of our linked list
54:51 - but for our class in particular
54:54 - we're going to keep track of the last
54:55 - node so that we can reduce the time that
54:58 - it takes to insert a node at the end
55:00 - in the future but if we haven't yet
55:01 - started keeping track of the last node
55:03 - then we're still going to have to use a
55:05 - while loop to traverse through the
55:07 - linked list
55:07 - so we'll do if self.lastnode is none
55:11 - then we'll do our while loop so we'll do
55:13 - node is equal to self.head
55:15 - and we just need to do while
55:17 - node.nextnode
55:19 - node equals node.nextnode
55:22 - and this is going to take us all the way
55:24 - to the end until
55:25 - node.nextnode is equal to none because
55:27 - we're only going to go through this
55:28 - while loop while node.nextnode is not
55:31 - equal to none
55:31 - and for each iteration of this while
55:33 - loop we're going to set node equal to
55:34 - next node so once we get to the last
55:36 - node of this linked list this while loop
55:39 - is going to terminate
55:40 - and then node is going to be set equal
55:42 - to the last node of the linked list so
55:44 - now we want to set the next node of our
55:46 - current last node to
55:48 - the data so node.nextnode
55:51 - equals node and then our data
55:54 - and then none because this is going to
55:56 - be our new last node so the next node of
55:58 - this node is going to be none
55:59 - and now that we know what our last node
56:00 - is we can set self.lastnode
56:03 - equal to the node that we just created
56:06 - which is node.nextnote so now we have a
56:08 - last node so now if we wanted to
56:10 - insert at the end of this instance of
56:12 - our linked list
56:13 - it's going to first check to see if
56:15 - self.lastnote is none
56:16 - but for this instance self.lastnode is
56:19 - set to
56:20 - our currentlastnode so now we can add
56:22 - the code for if we do have self.lastnode
56:25 - set
56:26 - so if we do have self.lastnode we just
56:28 - need to set self.lastnode.nextnode
56:32 - equal to a new node
56:36 - and we no longer have to take oven time
56:38 - to traverse through the linked list
56:40 - to get to the end and insert at the end
56:42 - and we can't forget to set our
56:44 - new last node as well which is again
56:46 - going to be the node that we just
56:47 - created which is self.lastnode.nextnode
56:52 - so with the current way that we're doing
56:53 - things we're only ever going to need to
56:56 - iterate through this while loop the
56:58 - first time we call this
56:59 - insert at end method so for example
57:01 - let's say
57:02 - we go down here and we create a linked
57:04 - list
57:09 - and we do ll insert at beginning
57:13 - and we just insert some data
57:16 - and we do this a couple of times
57:20 - and then we do ll insert at end
57:24 - and then we'll say end when we get to
57:26 - this insert at
57:27 - end we're going to have to iterate
57:29 - through all of these
57:31 - inserts that we did and we can see what
57:33 - this looks like
57:34 - by just going to this while loop and
57:38 - printing say editor
57:40 - node.data then we can just save this
57:44 - and then we can go python linkedlist.pi
57:46 - and you'll see that when we get to the
57:48 - call to insert at end it has to
57:50 - iterate through every node that we
57:52 - called that
57:53 - insert at beginning function on but if
57:55 - we go back in here
57:58 - and we add another insert at end for
58:01 - this next one we're not going to have to
58:03 - iterate through those anymore because
58:05 - after calling insert at in this first
58:07 - time we started keeping track of the end
58:09 - of our linked list
58:11 - so you'll see when we call this again
58:13 - it's still only going to iterate through
58:15 - all of these nodes the one
58:16 - time and if we go ahead and print the
58:19 - linked list
58:25 - we can see that we are indeed having our
58:28 - end
58:28 - and our n2 added to the end so with that
58:31 - in mind
58:32 - this actually means that we can make the
58:35 - efficiency of
58:36 - our linked list even better because to
58:39 - avoid traversing this while loop all we
58:41 - have to do is
58:42 - keep track of our end whenever we insert
58:45 - into the length list
58:46 - and currently we keep track of the end
58:48 - when we insert at the end
58:50 - but we can also keep track of the end
58:52 - when we insert at the beginning
58:54 - because the first time we insert into
58:56 - the linked list our linked list will be
58:58 - empty and when we
58:59 - insert one node into an empty linked
59:01 - list at that moment
59:02 - the end and the beginning of the linked
59:04 - list is the same because
59:06 - there's only one node in the linked list
59:08 - so at that moment
59:09 - we have a linked list that looks like
59:11 - this and when we insert data at the
59:13 - beginning we end up with a linked list
59:14 - that looks like this
59:16 - and when we have a linked list that
59:17 - looks like this the end of our linked
59:19 - list
59:19 - is the head of our linked list as well
59:21 - so what we can do is
59:23 - we can say itself.head is
59:27 - none that means our linked list is empty
59:30 - and if that's the case we can just set
59:32 - self.head
59:33 - equal to a new node that will just
59:36 - contain data and then
59:38 - none for its next and we can also set
59:40 - self.lastnode
59:42 - equal to self.head so this means that
59:45 - from the very beginning whenever we add
59:47 - to our linked list we're going to start
59:49 - off by keeping track of the last node of
59:51 - the linked list
59:52 - therefore we will actually never need to
59:54 - use this
59:55 - while loop so this means that we should
59:57 - never get to this
59:58 - if statement so if we print here last
60:01 - node
60:02 - is none
60:06 - and we save and we run this again you'll
60:09 - see that we never get to that print
60:10 - statement that says last node is none
60:12 - and we're not doing anything different
60:14 - here we're still inserting all of this
60:16 - data at the beginning
60:18 - and then we're still inserting that in
60:20 - for this first time and then the second
60:22 - time
60:23 - and before when we insert it for this
60:25 - first time we have to start keeping
60:26 - track of the last node when we insert
60:28 - data for the first time
60:30 - we automatically start keeping track of
60:31 - the last node therefore we never even
60:33 - have to use the while loop
60:35 - so we'll actually never even get to this
60:37 - code here so we can just remove it so
60:39 - we'll just comment it out for now
60:42 - and we can comment out this as well and
60:46 - let's just do this and save
60:49 - and try this again and we still have no
60:52 - errors
60:55 - so let's take some time to visualize
60:57 - what's happening here so before adding
60:59 - this code here
61:00 - if we were to start with a linked list
61:02 - where the head was none
61:05 - so an empty linked list we would just
61:07 - create a new node
61:14 - with some data and we'd set
61:17 - the next node of that new node to our
61:20 - head
61:23 - which would in turn add a linked list to
61:26 - the beginning here
61:28 - because this new node has its next node
61:32 - pointing to our current head which is
61:33 - none
61:35 - and then the data would be in here and
61:37 - then our head we would set it
61:39 - to our new node
61:43 - so this would no longer be our head our
61:45 - head would now be here
61:46 - so that's what we were doing before we
61:48 - added this code we weren't keeping track
61:50 - of last note at all we were only keeping
61:52 - track of our head so in that case when
61:54 - we went to insert at the end of a length
61:56 - list
61:56 - let's erase this
62:02 - and let's say for example we did insert
62:08 - beginning
62:15 - a couple of times
62:22 - and remember this is prior to
62:24 - implementing this portion of the code so
62:26 - that would leave us with a linked list
62:28 - that looked something like this
62:37 - with this data being here
62:40 - and this data being here and if after
62:44 - that we went on to insert at the end
62:46 - let's say insert at end
62:55 - in that case we would skip this portion
62:57 - of the code because our linked list
62:59 - isn't empty and we're still imagining
63:00 - that we haven't implemented
63:02 - this so therefore we haven't commented
63:04 - out this yet as well so we would end up
63:06 - here
63:06 - if self.lastnode is none and since
63:09 - before implementing this we weren't
63:11 - keeping track of the last node it would
63:13 - be none and then that's when we would
63:14 - have to go through our while loop
63:16 - so we would set node equal to
63:19 - our head and we would just say while
63:22 - our node has a next node that's not
63:25 - equal to none
63:35 - so while our node has a next node that's
63:37 - not equal to none
63:38 - we would just set our node
63:41 - equal to node.nextnode
63:48 - so we would start at our head which is
63:50 - here
63:53 - so this is our head and this is our
63:54 - head's next node
63:56 - and this next node isn't equal to none
63:58 - so our node would then be equal
64:00 - to this node and then this is our next
64:02 - node and it is equal to none
64:03 - so at that point this while loop would
64:05 - terminate and this node value
64:08 - this node value let's do a different
64:11 - color
64:11 - this node value is now this node and its
64:14 - next node is this node
64:16 - so now we set this node's next node
64:21 - equal to this data that we want to
64:24 - insert
64:25 - so we would do node
64:28 - then data and then none
64:33 - so that would make this data replace
64:36 - this
64:36 - none so we would add a node here
64:39 - and then this one would now point to
64:41 - none
64:42 - and that's how we were inserting that in
64:44 - before and as you can see we have to
64:46 - traverse through each node so we have to
64:50 - go from this node to this node all the
64:52 - way until the next node is none then we
64:53 - can add it there
64:54 - because we don't know what the last node
64:55 - is and at that point that's when we are
64:58 - getting our last node
65:02 - and setting it equal to this node
65:05 - dot next node
65:09 - this node.nextnode that we just created
65:13 - and at that point we started keeping
65:15 - track of our last node
65:17 - so now let's erase this
65:20 - and let's say our linked list
65:23 - is still the same length list
65:36 - so at this point if we want to insert
65:38 - and now we know that this is
65:40 - our last node
65:43 - and this is our head
65:47 - so now if we want to insert
65:51 - at end
65:56 - all we need to do is insert at this
65:59 - node's next
66:00 - node so all we would have to do is last
66:03 - node
66:06 - dot next node
66:10 - equals a new instance of node
66:14 - plus our data and then none
66:18 - and we no longer have to traverse
66:21 - through
66:21 - each node to find out what our last node
66:23 - is because we already know what our last
66:24 - node is
66:25 - and this was all prior to us adding this
66:28 - to insert at beginning and prior to us
66:31 - commenting
66:32 - out this while loop section but let's go
66:34 - over what changed once we added this
66:37 - code
66:37 - and commented out this code let's erase
66:40 - this again
66:43 - so in this case if we insert at
66:45 - beginning
66:52 - just say data we'd end up at this here
66:55 - and currently we just have an empty
66:56 - linked list that looks like this it just
66:58 - has none and this none
67:01 - is our head so we end up here if
67:04 - self.head is none
67:05 - which it is self.head equals our new
67:08 - node and our new node's next node is
67:10 - just going to be none
67:11 - so that just means our new node would go
67:13 - here and its next node would be none
67:15 - and this would no longer be our head our
67:18 - head would now be our new node
67:19 - and this is the data so we've updated
67:22 - the head but now
67:23 - as you can see in a length list that
67:25 - only has one node
67:26 - and its next node is none the head and
67:28 - the tail are both going to be the same
67:31 - node because
67:32 - there's no other node after this head
67:34 - node so this would be our head
67:35 - and our tail so that's why we're setting
67:38 - self.last node equal to self.head
67:40 - because we're making the head as well as
67:42 - our last node
67:44 - equal to this node so now whenever we go
67:47 - to this insert at end code
67:58 - we can just add it straight here and
68:01 - then just point this to none
68:03 - this new node that we create we just
68:04 - point it to none so this data
68:07 - will just go right here and then we'd
68:10 - set last node
68:14 - equal to this new node that we just
68:16 - created
68:19 - so this is no longer our last node this
68:21 - is now our last node
68:24 - and even if we come in and insert at
68:27 - beginning
68:36 - we'd still just be adding a new node
68:38 - here and setting its
68:39 - next pointer to the current head then
68:42 - this data
68:43 - would be this data then this would no
68:45 - longer be our head
68:46 - because we're setting self.head to the
68:48 - new node
68:50 - so this would be our new head and at
68:52 - this point we still have our head that
68:53 - we're keeping track of and we still have
68:55 - our last node that we're keeping track
68:57 - of
68:57 - which is why we'll never have to use
68:59 - this code
69:01 - okay so now that we understand why we no
69:04 - longer need this while loop we can go
69:06 - ahead and just remove this portion of
69:07 - the code here and we can also get rid of
69:10 - this
69:10 - so now our insert at in function is a
69:12 - lot cleaner and
69:14 - inserting at the end will also now only
69:16 - take constant time
69:18 - so both our insert at beginning and
69:20 - insert at in methods are of one
69:22 - so we can just save this and let's just
69:25 - ls our current directory
69:26 - what we're going to want to do is we're
69:28 - going to want to open our server.pi file
69:31 - and we're going to want to import
69:32 - our list.pi file and to do that we can
69:36 - just do
69:36 - import linked list so linked list is the
69:40 - name of our file which is the name of
69:42 - our module for linked lists
69:43 - and now we can go down back to this
69:46 - route that we're trying to implement
69:48 - and what we want to do in this route is
69:50 - we want to get all of our users
69:52 - in descending order and to get our users
69:54 - in descending order we're going to start
69:56 - by querying
69:57 - our database to get all of our users
70:00 - and to do that we're just going to
70:02 - create this users variable
70:04 - and we're going to use user.query.all
70:08 - and again this user here is just the
70:10 - user model that we created before
70:12 - so once we get all of our users we can
70:14 - create an instance of a linked list
70:19 - from our module and then our linked list
70:22 - and then we're just going to iterate
70:24 - through our users
70:25 - from the database and for each user
70:31 - we're going to insert at the beginning
70:34 - a dictionary that contains our user data
70:59 - and then we're going to need to return
71:01 - this linked list and to return it we're
71:03 - actually going to need to convert the
71:04 - linked list into an array
71:08 - so we're going to return jsonify
71:12 - all users ll.2
71:15 - array and we haven't yet added this to
71:18 - array method to our linked list class so
71:21 - let's go ahead and do that
71:23 - so you guys are going to need to
71:25 - traverse to your linked list file again
71:29 - and we're going to add a new method
71:31 - which we'll call
71:32 - to array and it's going to take self
71:36 - and we'll just set array equal to an
71:38 - empty array and if our linked list is
71:40 - empty
71:41 - we're just going to return the empty
71:42 - array
71:48 - and if it's not empty we're going to
71:50 - traverse through our linked lists
71:52 - using a while loop which you all should
71:54 - be familiar with because it's what we've
71:56 - been doing
71:57 - so we'll set node equal to self.head and
72:00 - then while
72:00 - node we'll do array.pinned
72:03 - node.data then node equals node.nextnode
72:09 - and after that while loop is finished
72:11 - our array will contain
72:12 - all of our node data so we can return
72:15 - array
72:16 - and we can save this and now when we're
72:18 - back in this file
72:19 - this return json file all users ll2
72:23 - array should work
72:25 - and i just realized we probably
72:26 - shouldn't call this array because this
72:28 - is python
72:29 - so we'll just call it to list and here
72:32 - we'll do the same thing
72:34 - and we'll just call this l
72:39 - l and same thing here
72:45 - and also we're going to want to return a
72:47 - 200 here as well
72:49 - the same as the way that we did it when
72:50 - we created a new user we returned a 200
72:53 - which is a success response and the
72:55 - reason this code
72:56 - is going to return all of our users with
72:58 - their ids in
72:59 - descending order is because this code
73:02 - here this query all gives us the users
73:05 - in ascending order by id and for each
73:07 - user in this ascending ordered list
73:09 - we're going to insert it at the
73:11 - beginning of our linked list
73:12 - so every time we add a user it's going
73:15 - to push back
73:16 - the previous user that we added so that
73:18 - means that if our first user id is one
73:21 - and we insert it at beginning and then
73:23 - our next user id is two
73:25 - and then we insert that at beginning
73:26 - that one gets pushed back and it's going
73:28 - to keep doing that
73:29 - all the way until we get to let's say we
73:32 - have
73:32 - 200 users so in this linked list the
73:35 - user with id 200
73:36 - is going to be inserted at the beginning
73:38 - last so that means that
73:40 - the user with id 200 is going to be the
73:42 - head of our linked list
73:44 - and the first user user 1 is going to be
73:47 - the tail of our linked list and that's
73:49 - how we're creating a list of users in
73:50 - descending order by using this linked
73:52 - list
73:53 - i hope that makes sense and before we
73:54 - move forward i noticed that there was an
73:56 - error
73:57 - in one of the methods of our linked list
73:59 - so let's go ahead and have a look at
74:01 - that
74:09 - so this should be changed to l
74:15 - okay so now that we have everything
74:16 - situated we can
74:18 - move forward with testing our route and
74:20 - to do that we're going to need to
74:22 - add some dummy data to our database so
74:25 - what we can do is create a new file
74:27 - called
74:27 - generate dummy data
74:35 - and i've already written the script to
74:37 - generate this dummy data because i
74:39 - didn't want it to detract from the
74:41 - concepts that we're trying
74:42 - to learn so what you can do is you can
74:44 - go to this github repository
74:47 - by accessing this url which i will link
74:49 - in the description
74:51 - and here you can just select raw and you
74:54 - can just copy this code
74:58 - and paste it into the file that we just
75:00 - created
75:03 - and then we can save this file and now
75:06 - we have our file to generate dummy data
75:09 - so let's have one quick look at our
75:11 - database before we generate the data
75:13 - so you can once again open this db
75:15 - browser for sqlite
75:18 - and you can select open database and
75:20 - navigate to the directory of our project
75:23 - and within that directory you select the
75:25 - sqlitedb file
75:26 - and open it and we can just browse our
75:29 - table
75:30 - for our blog posts and as you can see we
75:32 - have no rows
75:35 - and the same thing for our users we only
75:37 - have this one user that we added when we
75:39 - were testing
75:40 - our create user endpoint and let's just
75:42 - check to make sure our virtual
75:44 - environment is still running by typing
75:46 - in environment graph
75:47 - virtual environment and as you can see
75:50 - my virtual environment is still running
75:52 - and yours should still be running as
75:53 - well so you should have a virtual
75:55 - environment environment variable that
75:57 - points to the path of our project
76:00 - and its venv folder and once that's done
76:04 - we should be able to type in python
76:06 - generate dummydata.pi and there's no
76:09 - need to panic when we run this
76:11 - we're going to get some errors because
76:13 - there's some dependencies that we still
76:15 - need to install to run this script
76:17 - but we're going to run it just so we can
76:19 - see what we need to install
76:20 - so we'll type in python generate
76:22 - dummydata.pi
76:24 - and it says that there's no module named
76:26 - faker so we can do pip
76:28 - install baker
76:33 - and then we can try this again
76:36 - and this time we get no errors and if we
76:39 - go and check our database now
76:41 - and we check browse table for our user
76:43 - table
76:45 - you'll see that we have a bunch of new
76:47 - users that have been added
76:52 - and if we go back to database structure
76:54 - and we go to our blog post and we select
76:56 - browse table
76:58 - we get the same thing so each blog post
77:01 - has a body
77:02 - and a title and it also contains
77:05 - user ids that exist within our user
77:08 - table
77:09 - so now that we have our dummy data set
77:11 - up we can finally test the route that we
77:14 - created
77:14 - to get users in descending order so to
77:18 - do that we're going to need to run our
77:20 - server
77:22 - and once our server is up and running we
77:24 - need to go back to
77:25 - using postman to send a request so you
77:28 - can select your postman app
77:30 - and what we're going to want to do is
77:31 - we're going to want to create a new
77:33 - request
77:33 - so this is our create user request so we
77:35 - don't want to do anything to change this
77:37 - we want to expand this flask api and
77:41 - hit this view more actions and then hit
77:43 - add request
77:46 - and this request will be called get
77:48 - users
77:49 - descending and of course we don't need a
77:52 - description
77:53 - and it's already going to be saved to
77:55 - our flask api
77:57 - folder so we can just hit save to flask
77:59 - api and now we can open a tab for this
78:01 - request
78:01 - and once again we will copy this url
78:04 - here
78:05 - and paste it here and we need to add our
78:08 - rule here as well
78:10 - so open another tab
78:25 - and then we can go into our server.pi
78:27 - file and the rule for this route is
78:29 - going to be
78:30 - forward slash user and then forward
78:32 - slash descending id
78:34 - so we can just copy this and paste it
78:36 - here and this is going to be a git
78:38 - request so we can leave this method the
78:39 - same and for this request
78:41 - we don't need a body so we can just hit
78:44 - syn to send this request
78:48 - and we got an error and it's a 500
78:50 - internal server error so that means that
78:52 - there's
78:53 - an issue with our code somewhere so if
78:55 - we go back to our server
78:57 - and looking at our stack trace we can
78:59 - see that at the bottom here
79:01 - in our server.pi file on line 73
79:04 - in the function get all users descending
79:07 - we have a line that says address
79:09 - is user.address and we're missing an s
79:12 - here in this address
79:13 - and the error is user object has no
79:14 - attribute address because we spelled
79:16 - address wrong
79:17 - so what we can do is we can control c we
79:20 - can go back into our server.pi
79:22 - file and we can go to line 73
79:25 - and we'll see right here that address is
79:28 - spelled wrong
79:29 - so we just want this to be spelled
79:31 - correctly and then we can save that
79:33 - and then we can run our server again
79:37 - and let's try sending this request again
79:41 - and this time we get a success response
79:44 - a 200 status
79:45 - and as you can see we have our users
79:48 - in descending order by id so descending
79:51 - meaning that
79:52 - the users will be ordered from largest
79:55 - id
79:56 - to smallest id so we have id 200 here
79:59 - and if we keep going down all the way
80:02 - down eventually we get to the last user
80:05 - which is id
80:06 - 1. so now that we know that that
80:08 - endpoint is working we can go back into
80:10 - our server.pi file
80:11 - and we can start on the code for our get
80:14 - all users ascending route so this route
80:16 - is going to be very similar to the above
80:18 - route
80:18 - and since these routes are so similar we
80:20 - can just go ahead
80:21 - and copy this
80:27 - and paste it here and the only thing
80:30 - we're going to need to change is
80:32 - this to insert at end and the reason
80:36 - this is going to work is
80:37 - if this returns all of our users in
80:40 - ascending order and we iterate through
80:42 - our users in ascending order and we
80:44 - insert them at the end of our linked
80:46 - list
80:46 - we're basically just going to be
80:48 - retaining the order of this
80:50 - when we add it to our linked list so
80:52 - actually using a linked list for this
80:54 - route is redundant but the purpose of
80:56 - using it is to help you understand the
80:58 - differences between inserting at the end
81:00 - of a linked list and inserting at the
81:02 - beginning of a linked list so now we can
81:04 - take our rule here
81:06 - and in postman we want to create another
81:10 - request
81:12 - and this one's going to be get users
81:15 - ascending and we'll open another tab
81:19 - and this one's also going to be a get
81:21 - request
81:23 - and we'll go ahead and add in our rule
81:26 - and let's just take our url from here
81:35 - and back in our file here we can just
81:37 - save this and once the file is saved
81:40 - our server should already detect the
81:42 - change in the file
81:44 - so it will actually reload our server so
81:46 - we don't have to restart our server we
81:48 - can just
81:49 - leave it as it is and back in postman we
81:52 - can go ahead
81:52 - and send this request and as you can see
81:56 - we get a success response a 200 status
81:59 - and we have our users here in ascending
82:02 - order starting with the lowest id
82:04 - and ending with the highest id
82:09 - so we can go back into our file and move
82:12 - on to our next route
82:14 - okay so the next route that we're going
82:16 - to be creating is the route to get one
82:18 - user
82:19 - and the way that we're going to do that
82:21 - is we're going to
82:22 - go ahead and create another linked list
82:26 - users equals user.query.all
82:31 - and we'll do all users ll equals
82:35 - linkedlist. linked list
82:40 - and we can just take this
82:45 - paste it here and change this
82:48 - to insert at beginning and we can just
82:52 - go
82:53 - user equals all users
82:56 - ll dot get
82:59 - user by id
83:02 - and we'll pass in user id and we can
83:05 - just
83:06 - return jsonify
83:09 - user with the status 200.
83:12 - okay so we haven't yet created this git
83:14 - user by id
83:16 - so we're going to need to go back into
83:19 - our linked list
83:20 - file and create this method and what
83:22 - we're passing to this method
83:23 - is the user id which is going to come
83:26 - from
83:26 - our url here so we're going to have this
83:29 - rule appended to our url
83:31 - which is going to contain this user id
83:34 - so whenever we append an id to the end
83:36 - of
83:36 - our url when using this rule and we use
83:39 - a get request
83:40 - it's going to know to route that request
83:43 - to
83:43 - get one user and that user id that we
83:46 - append to the url is going
83:48 - to be passed to our function our get one
83:50 - user function
83:51 - which we'll have access to within this
83:53 - function which is what we're going to
83:54 - pass
83:55 - to this method that we are going to
83:57 - implement on our linked list
83:59 - so we can save this file and we can go
84:01 - back into
84:02 - our linked list file and within
84:05 - this linked list class we can go and
84:08 - create the method
84:09 - we'll just define a new method here and
84:11 - we're going to call it get
84:12 - user by id and it's going to take in
84:16 - self and user id and this method's going
84:19 - to be quite simple we're just going to
84:21 - use a while loop to
84:22 - traverse our length list until we find
84:25 - the node that contains the id
84:27 - that we're looking for within its data
84:29 - so we can just set a node variable equal
84:31 - to self.head
84:32 - and then as usual while node if
84:35 - node.data
84:36 - and then within that data there should
84:39 - be an id
84:40 - because if you remember from the route
84:42 - function the data that we added to this
84:43 - linked list
84:44 - is a dictionary and if that's not clear
84:46 - let's go back into that file
84:50 - so here we're creating an instance of a
84:52 - linked list
84:54 - and then in this for loop here we're
84:57 - going to
84:58 - iterate through every user from here
85:01 - and then we're going to insert the user
85:03 - into our linked list by using the insert
85:05 - beginning method
85:06 - and the data that we're inserting is
85:08 - this dictionary here and within this
85:10 - dictionary we have
85:11 - an id key a name key an email key an
85:14 - address key and a phone key
85:15 - and we're checking to see if the user id
85:18 - is equal to the user id that we're
85:20 - searching for
85:21 - when we're using our get user by id
85:23 - method so if we go back to this method
85:26 - we're going to check if the node's data
85:28 - which is a dictionary that contains the
85:30 - key id
85:31 - if that id is equal to this id that
85:33 - we're passing to the method
85:35 - so if that id is user id
85:39 - then we're going to return node.data so
85:42 - we're going to return
85:43 - the dictionary that's stored as the data
85:46 - in this node
85:47 - and if not we're going to keep looking
85:48 - so we're just going to set node equal to
85:51 - node.nextnode and if
85:54 - after the while loop completes we never
85:56 - return
85:57 - node.data it means that the user id was
86:00 - never found within our linked lists
86:02 - so we would just return none and then we
86:05 - can just save this
86:07 - and go back into our server file and go
86:10 - back down
86:10 - to our get one user function and as you
86:14 - can see
86:14 - in this get user by id method we're
86:17 - going to
86:18 - return the user dictionary and that's
86:20 - going to be stored in this user variable
86:23 - and then we're going to return the user
86:25 - variable convert it to json
86:27 - so let's go ahead and test this out so
86:29 - to test it out once again we're going to
86:31 - need to copy our rule here
86:33 - and in postman we can add another
86:35 - request
86:37 - and we'll call this one get one user
86:41 - and save then we can just go to this get
86:43 - one user tab
86:44 - and we can add in our rule so first
86:49 - let's add in the rest of this
86:57 - and this user id needs to change to the
86:59 - id that we want to find
87:01 - so maybe we want to get user with id15
87:04 - and we have the method set to git and we
87:06 - can just send
87:07 - oh and i stopped my server so let's go
87:10 - ahead and start the server again first
87:12 - so
87:12 - python server.pi the server is now
87:15 - running
87:15 - and then here i can hit send again and
87:18 - in the response i got null so it's
87:20 - saying that
87:21 - the user with id 15 doesn't exist
87:24 - try it with one okay so clearly there's
87:28 - an issue with the code so let's go see
87:30 - what's happening
87:31 - so we can go to the get user by id
87:33 - method
87:34 - and maybe the issue is that we need to
87:37 - convert this into an int
87:41 - and let's save and the server should
87:43 - automatically detect the change in
87:45 - update and then we can
87:46 - send again and now we get the user for
87:49 - id one and let's try it again with 15
87:54 - and we also get the user with id15 so
87:57 - now we can go back into our server.pi
87:59 - file so now that we can get one user we
88:02 - can quickly
88:03 - add the functionality here to delete a
88:06 - user
88:06 - and for this function we're not going to
88:08 - use the linked list we're just going to
88:10 - query the database to delete the user so
88:12 - we can remove this path
88:14 - and we can just do user equals
88:16 - user.query
88:17 - and now we're going to use the method
88:19 - filter by
88:22 - and we're going to filter by the id
88:23 - equal to user
88:25 - id and we want to get the first record
88:27 - that we find with that id
88:29 - and once we do that we can delete it by
88:31 - just doing db
88:33 - session dot delete and pass in the user
88:37 - and then we can just do db session dot
88:40 - commit
88:41 - and once it's deleted we can just return
88:43 - jsonify
88:45 - and we'll just do an empty dictionary
88:48 - and 200 and we can save and in flask api
88:52 - we can just go
88:53 - add request once again and this one
88:55 - we'll call delete user
88:59 - and save then we can just open a tab for
89:02 - delete user
89:04 - we can take this one and copy the whole
89:08 - thing
89:11 - because it's actually going to be the
89:12 - same url but we're just going to change
89:14 - this from git
89:16 - to delete and let's say we want to
89:18 - delete user one
89:20 - so if we go back into our database and
89:23 - we browse
89:23 - table we see that we have user here with
89:26 - id1
89:27 - bill his name is bill and we can go
89:29 - ahead and send this request to delete
89:32 - oops and we got an error so let's see
89:35 - and the issue here is that we're trying
89:37 - to delete a user
89:39 - that has blog posts in the blog post
89:41 - table
89:42 - and what that means is if we go check
89:44 - our blog post table within our database
89:47 - you can see that we have records for
89:49 - blog posts that belong to the user that
89:51 - we're trying
89:52 - to delete user id 1 and since we've
89:54 - added a foreign key constraint
89:56 - to the user id column of the blog post
89:58 - table
89:59 - it means that values within the user id
90:01 - column cannot be values that do not
90:03 - actually exist within the user table
90:05 - this is why we're being blocked from
90:07 - deleting the user
90:08 - because we need to cascade the deletion
90:10 - down to the tables that reference this
90:12 - user's
90:13 - id when deleting which just means that
90:15 - when we delete a user
90:16 - any table that references that user
90:19 - should have the rows that reference that
90:21 - user deleted as well
90:22 - and this is actually very simple we just
90:24 - need to go back into our server.pi file
90:32 - and here where we create the
90:34 - relationship to blog post
90:36 - we can just add cascade equals
90:39 - all delete which just means that
90:43 - whenever we delete a user
90:44 - any item in this blog post table that
90:46 - references that user will also be
90:48 - deleted
90:49 - so we can just save this and just to
90:51 - recap we have
90:53 - records within our blog post table that
90:55 - reference user id 1
90:58 - and we also have user id 1 within our
91:01 - user table
91:02 - so let's try sending this request to
91:04 - delete user id 1 again
91:08 - and now as you can see we get the
91:10 - expected response
91:11 - and if we go back into our database
91:13 - viewer and we refresh this page
91:16 - you'll see that we're now starting from
91:18 - user id 2
91:19 - and user id 1 bill no longer exists
91:22 - within this table
91:24 - and also if we go to blog post you'll
91:26 - see that
91:27 - the user id column no longer has
91:29 - references to user id 1
91:31 - because those were also deleted
91:39 - so to start within our project directory
91:41 - we want to create a file called
91:43 - hashtable.pi
91:48 - and within this file similarly to linked
91:50 - lists we're going to create a node class
91:54 - which will initialize with self data and
91:56 - nextnode
92:18 - and this time when we create an instance
92:19 - of node the data that we pass to the
92:21 - instance
92:22 - is also going to be derived from its own
92:25 - class which we'll call
92:26 - data
92:30 - and the data class we'll initialize with
92:32 - self key and value
92:46 - and lastly we will need to create a hash
92:49 - table class
92:51 - which will initialize with self and
92:54 - table size
93:06 - and within our hash table class we'll
93:08 - also implement
93:09 - an attribute called hash table which is
93:12 - essentially
93:13 - a fixed length list
93:17 - and since there's no real way to declare
93:19 - a fixed length list or array in python
93:21 - we can use our table size variable to
93:24 - create a list of none values
93:26 - of the length specified by our table
93:28 - size
93:31 - and i'm going to explain in more detail
93:33 - how all of this is working in just a
93:34 - second just try to
93:36 - follow along with me for now so the next
93:38 - thing that we need to do
93:39 - is we need to define a method within our
93:41 - hash table class
93:43 - which is going to generate a hash value
93:45 - for us
93:46 - which essentially just converts a key
93:48 - into an index in our
93:50 - hash table list this way we can access
93:52 - the value for a key
93:54 - in constant time because accessing an
93:56 - index within a list takes all of one or
93:59 - constant time
94:00 - and again if this isn't making any sense
94:01 - to you just bear with me
94:03 - i will go into more detail in just a
94:05 - second
94:06 - so for this we're going to define a
94:08 - method called custom hash
94:11 - which will take in self and key and
94:15 - initially our hash
94:16 - value will start off as zero and for
94:19 - each character
94:20 - in our key
94:23 - we're going to add to our hash value
94:26 - the integer representation of this
94:28 - unicode character
94:29 - for example the character a's integer
94:32 - value and unicode
94:33 - would be 65 and this 65
94:37 - is defined by the unicode standard so
94:39 - the character a's
94:40 - integer value will always equal 65. and
94:43 - in python to make that conversion we can
94:45 - use this
94:46 - ord function and just pass in our
94:49 - character
94:50 - so we're adding to this hash value the
94:52 - integer value for
94:54 - each character in our key and the goal
94:56 - is to make this hash value
94:58 - as unique as possible and with only
95:01 - adding
95:01 - the integer values for each character
95:03 - together to create our hash value
95:05 - you can see how different keys can
95:07 - easily add up to the same value
95:09 - resulting in the same hash value for two
95:11 - separate keys so we want to try to
95:13 - reduce that
95:14 - possibility by adding some additional
95:16 - randomness to the
95:17 - creation of our hash value so we can
95:20 - also do hash value
95:22 - equals our current hash value
95:25 - multiplied by the integer representation
95:28 - of our unicode character
95:31 - modulo our table size
95:34 - and at this point we can return our hash
95:37 - value
95:38 - and now that we have our custom hash
95:40 - method we can add a method to
95:42 - add a key value pair to our hash table
95:46 - which will take in self key and value
95:50 - and to add a key value pair to our hash
95:52 - table first we need to create our hashed
95:54 - key
95:56 - by using the method that we just created
95:58 - to convert our key
95:59 - into a hash value and if the index of
96:03 - our hashed key is none
96:10 - we're going to add a new node to that
96:12 - index of our hash table
96:17 - by creating an instance of our node
96:18 - class which takes in an instance of our
96:21 - data class
96:22 - as well as next node and our data class
96:24 - will contain the key
96:25 - and the value that we pass to our add
96:28 - key value method
96:29 - and we're going to get to this else soon
96:32 - but first let's go over
96:33 - everything that we have so far okay so
96:36 - let's take some time to try and
96:38 - visualize what we have so far
96:40 - so we're already familiar with a way to
96:42 - visualize this node here
96:44 - from a previous video's explanation of
96:47 - linked lists
96:47 - so a node will be represented by a
96:50 - rectangle
96:51 - which contains the data and then the
96:53 - pointer to
96:54 - our next node and our data class here
96:57 - is going to be what is passed to our
97:00 - node so with both of these combined
97:02 - we'll essentially end up with something
97:04 - that looks like this
97:06 - we'll have a rectangle for our node
97:10 - and we'll have our pointer to next node
97:12 - and for data we'll have a
97:14 - key and a value so when we create an
97:17 - instance of this node class we're just
97:19 - creating
97:20 - a node that looks like this and when we
97:21 - create an instance of data
97:23 - we're just creating the data within the
97:25 - node which contains a key and a value
97:28 - which can be seen here self.key and
97:30 - self.value
97:31 - now for our hash table when we create an
97:34 - instance of a hash table
97:36 - we're going to initialize it with the
97:37 - size and the reason we're going to
97:40 - need to initialize it with the size is
97:42 - because when we call this custom hash
97:44 - function
97:44 - we want the hash that's created to stay
97:47 - within the bounds of this hash table
97:49 - list that we create
97:50 - for example if we create a list that
97:52 - only contains three items like so
98:03 - this list will only have indexes zero
98:06 - through two
98:06 - so zero one two and if when we create
98:09 - this custom hash
98:11 - it exceeds the indexes of the list that
98:13 - we have and we won't be able to
98:15 - add the value at this hash if it doesn't
98:18 - exist within our list
98:20 - so say for example our custom hash
98:23 - converts this key
98:24 - into index 5. index 5 would be somewhere
98:28 - out here which would not be within the
98:30 - bounds of our list
98:31 - so this would result in an error but
98:33 - when we initialize our hash table with
98:35 - the table
98:36 - size when we calculate our hash value we
98:39 - can be sure to use the module
98:41 - operator to ensure that our hash value
98:43 - doesn't exceed the table size
98:45 - and the reason why this module operator
98:47 - works to make sure that the hash value
98:50 - never exceeds the size of the table is
98:52 - because this modulo operator gives us
98:54 - the remainder
98:55 - of dividing this value by this value and
98:58 - our remainder can never be larger than
99:00 - the number that we're dividing by
99:02 - because if our remainder is equal to or
99:06 - greater than the number that we're
99:07 - dividing by that means that we can
99:08 - divide the number again
99:10 - for example if we have a hash value that
99:13 - is 63 and we divide it by a table size
99:17 - of 10
99:18 - 10 can go into 63 six times and we'll be
99:21 - left with three
99:23 - and if we did the same thing for 69
99:27 - 10 would go into 69 six times and we'd
99:30 - be left with nine
99:32 - but once we get to 70 and we divided by
99:35 - 10
99:37 - 10 now goes into 70 seven times and
99:39 - we're left with nothing
99:40 - so as you can see the remainder is never
99:43 - larger than
99:44 - the number that we're dividing by so
99:46 - coming back to the initialization of our
99:48 - hash table
99:49 - if we were to create an instance of hash
99:51 - table we would pass in
99:53 - the size of the table that we want as
99:55 - the table size
99:56 - and then our hash table would be created
99:59 - by multiplying a list that contains
100:01 - one element none by the table size and
100:04 - this here
100:05 - is just going to produce something that
100:06 - looks like this
100:08 - it's going to be a list that contains
100:11 - five none values
100:25 - and then when we create our hash value
100:27 - this portion of the code
100:28 - makes sure that our hash value never
100:31 - exceeds
100:32 - the table size which ensures that our
100:35 - hash value
100:36 - never equals an index that doesn't exist
100:38 - within our table
100:40 - and also for those that don't understand
100:42 - what this ord function is doing
100:44 - we can use this table here to give you a
100:46 - general understanding of what's
100:48 - happening
100:48 - so in general terms this table gives us
100:51 - the decimal value
100:52 - for each character so for example the
100:55 - character a
100:55 - here its decimal value is 65
100:59 - so the character a is always going to be
101:01 - 65. so
101:02 - if our i is the character a in uppercase
101:06 - a
101:06 - because as you can see a lowercase a has
101:09 - a different value of 97. but if our
101:11 - character i
101:12 - is in uppercase a then this order is
101:15 - going to return
101:16 - the integer 65 so here 65 is going to be
101:20 - added to our hash value so in this case
101:23 - if our key is apple
101:27 - here we're going to iterate through
101:29 - every character
101:31 - in the key apple and we're going to add
101:34 - to this hash value
101:35 - starting with 97 and then 112
101:39 - and then 112 again and so on and so
101:41 - forth
101:42 - and that's basically what's happening
101:43 - when we're using this ord function here
101:45 - so what's happening when we're adding a
101:47 - key value to our hash table
101:49 - so it'll be easier to visualize this if
101:52 - we change the way that we write this
101:54 - list out so let's say that we create a
101:57 - hash table
102:02 - with a table size of four and we'll
102:05 - write our list out from top to bottom
102:09 - so we'll have none none
102:15 - none
102:18 - and none and let's just move this
102:23 - so this is our list and the indexes for
102:26 - our list are
102:27 - 0 1 2 and 3.
102:31 - so first of all let's assign a variable
102:33 - to this hash table instantiation
102:35 - and we can just call it ht equals hash
102:39 - table
102:40 - and if we were to do add key value we
102:42 - would do
102:43 - ht dot add
102:47 - key value
102:51 - and we would pass in our key and we'll
102:55 - just say our key
102:56 - is hi and then we would pass in our
102:59 - value
103:00 - and we can just say our value is there
103:05 - so what's going to happen is we're going
103:07 - to create a custom hash
103:08 - out of the key high so our hash value
103:11 - will start off as zero
103:12 - and for every character in the string
103:15 - high
103:15 - we're going to use this ord function on
103:17 - the first
103:18 - character in the string high which is h
103:20 - and as we can see here
103:22 - h maps to the decimal 104
103:27 - and i maps to 105. so what that means is
103:30 - this ord is going to
103:32 - return 104 for h and 104 is going to be
103:36 - added to our hash value which
103:38 - is zero so our hash value is then going
103:40 - to be 104
103:41 - and then we're going to set our hash
103:43 - value equal to our hash value multiplied
103:46 - by
103:46 - what ord returns for h which is 104.
103:50 - so it's going to be 104 multiplied by
103:52 - 104
103:53 - which is going to be 10 1816
103:58 - and then we're going to use the module
104:00 - operator and we're going to get
104:02 - the remainder of dividing 10816
104:06 - by the table size in our table size is
104:08 - four
104:09 - so 10 816 divided by four
104:13 - it's just going to come out to 2704 and
104:16 - there will be no remainder
104:18 - so that means this code here is going to
104:21 - become
104:22 - zero so our hash value is going to
104:24 - become zero once again
104:26 - because since when we divide this number
104:28 - by our table size
104:30 - there's no remainder the result of this
104:32 - expression will be zero
104:34 - so our hash value is zero again and then
104:36 - we go to the next character within our
104:38 - key which is i
104:39 - and we can erase this and we know that
104:42 - ord
104:43 - for the letter i is going to return 105
104:46 - so we're going to add 105 to 0 and
104:49 - that's going to be our new hash value
104:51 - and then our hash value is going to be
104:52 - set equal to our current hash value
104:54 - multiplied by 105 because or it's going
104:57 - to return 105 for the character i
104:59 - remember so we're going to end up with
105:01 - 105
105:02 - multiplied by 105 which is going to come
105:05 - out to
105:07 - 11025 which we will divide by
105:10 - our table size which is going to come
105:13 - out to
105:14 - 2 2756.25
105:18 - so our remainder here is going to be one
105:21 - so that means our hash value is going to
105:23 - be one
105:24 - after this for loop finishes so we're
105:26 - going to return
105:27 - one as our hash value so this key value
105:30 - pair
105:31 - is going to be added to index 1 because
105:34 - now
105:35 - our hash key this custom hash is
105:37 - returning 1
105:38 - as our hash key so our hash key is 1
105:42 - and if our hashed key index of our hash
105:45 - table
105:46 - is none which it is it's currently none
105:48 - we're just going to
105:49 - set that index of our hash table equal
105:52 - to a new node containing this data
105:54 - which will look like this we can remove
105:57 - this none
105:58 - and remember we're at index one because
106:00 - this list here
106:02 - is our hash table and our index is one
106:04 - so we're at index one
106:06 - and we're going to create a new node
106:08 - which of course
106:09 - is going to be our rectangle
106:13 - in our pointer to the next node
106:16 - and our next node is none because this
106:19 - is going to be the first node
106:21 - that we add to this index so our data is
106:24 - going to contain a key and a value
106:26 - so our data will be high there
106:32 - our key and our value for our data
106:35 - and our next node is going to be none
106:40 - because this is the first node that
106:41 - we're adding to this index and the
106:43 - reason we're using a node here
106:45 - which is essentially the head of a
106:46 - linked list is because there's still a
106:48 - chance that
106:49 - two different keys result in the same
106:51 - hash which we would call a collision
106:54 - so say for example we have this high key
106:57 - which hashes to index one and we have
106:59 - another key that hashes to the same
107:01 - index one
107:02 - so if that collision happens what we're
107:04 - going to do is
107:05 - we're going to go to this else here so
107:08 - this if
107:08 - is if the index is none then we can just
107:11 - add the node right because there's
107:12 - nothing there
107:13 - but if there's something there that's
107:15 - when we get to this else
107:16 - and if there's something there we're
107:18 - going to have to traverse the linked
107:20 - list
107:20 - until the next node is none and we're
107:22 - going to have to add that node to where
107:24 - none is
107:25 - and point that node to none and in this
107:27 - particular case
107:29 - when we do have to traverse the linked
107:31 - list
107:32 - within our hash table our insertion is
107:34 - no longer constant
107:36 - so the idea here is to reduce the
107:38 - possibility of having collisions
107:40 - so that most of the time when we do an
107:43 - insertion
107:43 - it's at an index that contains none but
107:46 - with our hash function
107:47 - in particular there's a pretty high
107:49 - probability that we will have collisions
107:52 - so this isn't a very performant hash
107:54 - table implementation
107:55 - but for our purposes to learn how hash
107:58 - tables actually work
107:59 - and how they're implemented it doesn't
108:01 - actually matter as long as you
108:03 - understand
108:03 - the concept then i think that we're fine
108:06 - so next we'll move on to coding what
108:08 - happens
108:08 - in this else block okay so now it's time
108:11 - to move on to
108:12 - what we'll do if the index specified by
108:15 - our hashed key
108:17 - is not none so if it's not none that
108:20 - means that there's already a node in
108:22 - that location
108:23 - so therefore we have a collision and
108:25 - we're going to need to
108:26 - use a length list at that particular
108:29 - index to store
108:30 - additional values so to do that we're
108:32 - going to start with the head of the
108:33 - linked list
108:34 - which is the first node at the specified
108:36 - index so we're going to just set node
108:38 - equal to
108:40 - self.hash table and then our hashed key
108:44 - so this is essentially acting as the
108:47 - head of our linked list
108:49 - and then we'll traverse the linked list
108:50 - by using while loop as usual
108:52 - so while node.nextnode
108:56 - so as long as there's a next node for
108:58 - our current node we're going to set node
108:59 - equal to node.nextnode
109:04 - and we'll just keep doing this until we
109:06 - get to the last
109:07 - node of the linked list so this while
109:09 - loop will stop
109:11 - when the next node is none and that
109:13 - means that our current node is the last
109:15 - node of the linked list so we don't need
109:17 - to do anything else to
109:18 - traverse to the end of this linked list
109:21 - so once the while loop is complete
109:23 - we can then set node.nextnode which in
109:26 - this case when the while loop is
109:27 - complete the next node to our current
109:29 - node will be none
109:30 - so we'll set that empty space to a new
109:32 - node which will contain our data
109:37 - and its next node will become none so
109:39 - now that we're able to add a key value
109:41 - pair to our hash table
109:43 - we want to define a method to get the
109:45 - value for a specified key
109:49 - and we can just call this one git value
109:52 - it'll take in self
109:54 - and the key and again we're going to
109:57 - need to get our hash
109:58 - key by using our custom hash method
110:01 - and passing in our key and i'm not sure
110:05 - if i clarified this before but
110:07 - this custom hash method it will always
110:09 - return the same hash for a given key
110:11 - and that's very important for our
110:13 - implementation to work
110:14 - the same key should always produce the
110:16 - same hash if there's a chance that the
110:18 - hash
110:19 - produced from the same key could be
110:21 - different then
110:22 - this wouldn't work at all because in
110:24 - instances where we need to
110:26 - actually retrieve the value that we
110:27 - stored in the hash table
110:29 - we'd need a way to convert the actual
110:32 - key back into the hash
110:33 - to be able to locate the data that we
110:35 - stored in the first place
110:37 - and then we're going to check to see if
110:39 - that key exists within our hash table
110:41 - so we can do self dot
110:45 - hash table
110:49 - hashed key is not none
110:53 - then we can set our node equal to self
110:56 - dot
110:56 - hash table hash key
111:01 - and then we want to see if this
111:03 - particular node has data in its next
111:06 - node because if it does that means that
111:08 - there's more than one
111:09 - node stored at this particular index of
111:11 - our hash table and if that's the case
111:13 - we need to check to see which one is the
111:16 - actual key that we're searching for
111:18 - so if node.nextnode
111:21 - is none then that means that there's
111:24 - only one node stored at this index
111:26 - so we can just return the data for the
111:27 - current node
111:32 - but if that's not the case then we're
111:33 - going to have to traverse the linked
111:35 - list at the index
111:40 - so if the key passed to the method is
111:42 - equal to the key within our data
111:46 - we'll return the value for that key
111:50 - but if not we will continue to traverse
111:53 - our linked list
111:55 - and since this while loop will only
111:57 - iterate as long as note dot next node is
112:00 - not equal to none
112:02 - for the final node we will need to check
112:04 - to see if key is equal to
112:07 - node.data.key and if it is we'll return
112:12 - node.data.value but if it's not that
112:14 - means that
112:15 - the key passed to our method doesn't
112:17 - exist within our hash table
112:19 - so at that point we can return and just
112:22 - so we can see that everything is working
112:24 - as expected
112:25 - we can create our own print table method
112:29 - let's just try to make this look
112:42 - intuitive
113:57 - and let's go ahead and see what this
113:58 - looks like
114:00 - so we'll create an instance of our hash
114:02 - table
114:04 - and we'll pass it 4 for the table size
114:07 - and then we'll do ht
114:08 - dot add key value and
114:12 - let's just do hi there
114:15 - then let's do ht print table
114:19 - and let's save and see what happens
114:23 - and as expected we have a table size of
114:25 - 4 and
114:26 - at index 1 we have our key and our value
114:30 - let's go back in here and add
114:34 - a couple more values so actually
114:37 - let's just leave them like that
114:40 - and as you can see since the key high
114:42 - always hashes to index one
114:44 - if we add multiple sets of data with the
114:46 - key high to
114:48 - our hash table it will all get stored in
114:50 - a linked list
114:51 - at the same index
114:56 - so we can go back in here and try with a
114:58 - different key
115:01 - and save and run we see that the key dog
115:05 - gets hashed to index zero so yeah that
115:08 - is a general
115:09 - overview of how to implement a hash
115:11 - table in python
115:12 - again you should keep in mind that this
115:14 - implementation isn't very efficient but
115:16 - the point is to gain a general
115:18 - understanding of how hash tables work
115:19 - and how they're implemented
115:21 - so for starters we're going to need to
115:23 - import our hash table module by going
115:25 - back to the top of our file
115:28 - and doing the same thing that we did for
115:29 - our linked list but instead we're going
115:31 - to use the name of the hash table file
115:35 - so once we've imported our hash table
115:37 - module we can head down to
115:39 - our create blog post route and start
115:41 - adding the code for this create blog
115:44 - post
115:44 - function so we can remove this path and
115:46 - once again we're going to need to get
115:48 - the data from the request by using this
115:50 - request.getjson method
115:53 - and after we retrieve that data the
115:54 - first thing that we're going to want to
115:56 - do is we're going to want to make sure
115:58 - our user
115:59 - is it actually a valid user that exists
116:01 - within our database
116:03 - because if you remember if we go back up
116:05 - to our user model
116:07 - we can see that our user id column
116:10 - requires that user id
116:11 - come from our user table and if this is
116:14 - not the case we'll get a foreign key
116:15 - constraint error so in order to check if
116:17 - our user exists we're just going to
116:19 - query the database for the user that's
116:21 - passed
116:22 - in the request so we can just set id
116:25 - equal to user id and if you remember our
116:28 - user id
116:29 - is passed to our create blog post
116:31 - function via our url
116:33 - rule so we want to query the first user
116:36 - with this user id
116:37 - so we're going to need to add here first
116:40 - and then we just need to do if not
116:42 - user and then we'll just return jsonify
116:49 - message user does not exist
116:56 - we'll also want to return 400 and a 400
116:59 - response just means that the client's
117:01 - into bad requests
117:02 - so in that case the client would need to
117:04 - send another request with a user that
117:06 - actually exists
117:07 - and once we've made sure our user exists
117:09 - within our database
117:10 - we can now start to create a blog post
117:12 - for that particular user
117:14 - so we'll start by creating our hash
117:16 - table and it's just going to be an
117:18 - instance of hash table from our hash
117:20 - table module
117:24 - and we'll just use the size of tin and
117:26 - we can start adding the values to our
117:28 - hash table
117:31 - by using our add key value method that
117:33 - we created in the last video
117:34 - so we're going to want to add all of the
117:36 - parameters to create
117:38 - a blog post so we're going to need a
117:40 - title and we're going to get that from
117:42 - the request
117:42 - data we'll do the same thing for our
117:45 - body our date
117:46 - and our user id
117:56 - and the date actually won't come from
117:58 - the requests we're going to
118:00 - get the date by using this now variable
118:03 - and if you're unsure of where this comes
118:04 - from
118:04 - if you remember from i think the first
118:06 - video we created this
118:08 - now variable which is just date time dot
118:11 - now
118:12 - and this date time comes from this
118:14 - import here
118:15 - where we imported from date time import
118:17 - date time
118:19 - and our user id is going to be from the
118:22 - user id in our url
118:24 - so now that we've created our hash table
118:26 - containing our data
118:27 - let's go ahead and print this hash table
118:29 - to see what it looks like using
118:30 - our print table method that we created
118:34 - in the last video and we can go ahead
118:36 - and save this
118:38 - and start up our server
118:43 - and now that we've started up our server
118:45 - we need to go to
118:46 - postman and create a request to create a
118:50 - blog post
118:50 - so once you have flask opened up you can
118:53 - go back to our flask folder
118:55 - and you can open it and you'll see all
118:57 - of our previous requests
118:58 - and we want to create a new post request
119:01 - for creating a blog post
119:03 - so we'll just duplicate this one
119:07 - and we'll just rename it create blog
119:10 - post
119:14 - and our rule is going to be blog post
119:17 - and our user id that we want to create
119:19 - the blog post for
119:20 - so we'll just do user id one and then we
119:24 - need to go to
119:24 - our body and since we duplicated
119:27 - the create user post request we still
119:30 - have this
119:31 - json data here for our request body so
119:34 - we can just change the keys and values
119:36 - within this request payload
119:38 - and all we need for this payload is the
119:40 - title of the blog post
119:44 - and we can just call this post one
119:48 - and then we need the body of the blog
119:50 - post
119:51 - and we can just change this to this is a
119:54 - blog post or something like that and we
119:57 - can remove these two
120:00 - and we also want to remove that and then
120:03 - we can try to send this
120:05 - and we get user does not exist and i
120:08 - think that's actually because
120:09 - in one of the previous videos we deleted
120:12 - user id 1.
120:13 - so let's check our database to make sure
120:16 - so once again you want to open the db
120:18 - browser for sqlite
120:20 - and then open database and then navigate
120:22 - to our
120:23 - project folder and then once you're in
120:25 - our project folder
120:26 - you can open this sqlite db file and
120:29 - let's
120:30 - browse our user table and yes we don't
120:33 - have user one
120:34 - it starts at user two so let's just use
120:37 - user two
120:38 - and also let's have a look at our blog
120:39 - post table as well
120:41 - and if we go all the way to the bottom
120:42 - here
120:44 - and we'll see that our latest blog post
120:46 - is this blog post here
120:48 - so when we add a new blog post there
120:50 - should be another blog post following
120:52 - this one with
120:53 - id 201 so let's change this to user 2
120:57 - user id 2 and then send the request
120:59 - again
121:01 - and we get an error here but it's
121:02 - expected because we haven't yet finished
121:04 - the code for the route we just wanted to
121:06 - print our hash table to see what it
121:08 - looks like
121:10 - so we sent a request to the route to
121:12 - execute the function
121:13 - so if we go here you see that we have
121:15 - our error and it says that the view
121:16 - function did not return a valid response
121:19 - and that just means that the function
121:21 - for our route
121:22 - is supposed to return a response but we
121:24 - didn't return anything yet so that's why
121:25 - we're getting this error
121:26 - but also before the error we were still
121:29 - able to print out
121:30 - our hash table and as you can see
121:33 - we have a body a date and a title
121:37 - and actually we have title twice so
121:39 - there's something
121:40 - wrong here so let's go back into our
121:43 - server.pi file
121:44 - and see what's happening
121:52 - so here the key for user id is still
121:55 - title
121:55 - so that's my bad
122:00 - change this to user id then save
122:03 - then run our server again and send the
122:06 - request again
122:07 - and now we can go back up to our hash
122:09 - table and we see that we have
122:11 - user id at index 0 and it's 2.
122:14 - then we have our body and our date are
122:17 - being hashed to the same index
122:20 - so we have a linked list here containing
122:22 - two nodes
122:24 - and then last but not least our title
122:26 - got hash to
122:27 - index three so as you can see with our
122:29 - hash function for our hash table there's
122:32 - a high probability that
122:33 - keys will be hashed to the same index so
122:36 - this is why
122:37 - this hash table in particular isn't very
122:39 - performant because the hash function
122:41 - isn't very efficient but it's actually
122:43 - good that we're getting the opportunity
122:45 - to work with an inefficient hash table
122:47 - implementation because it really helps
122:49 - you to understand
122:51 - the most important things that need to
122:52 - be taken into consideration
122:54 - when creating your hash table
122:56 - implementation because whenever we have
122:58 - keys that get hashed to the same index
123:00 - in this list
123:01 - that means that whenever we need to
123:03 - access a key that's in a linked list at
123:05 - any given index
123:06 - we're going to have to traverse in nodes
123:09 - within being the number of keys added to
123:11 - that particular index
123:13 - so when we retrieve data that's
123:14 - contained within these linked lists
123:16 - it's still oven as opposed to when we
123:19 - retrieve data for these indexes that
123:21 - only contain
123:22 - one node which takes constant time so as
123:25 - you can see
123:26 - the more we can avoid this the more
123:29 - performant our hash table will be
123:31 - so ideally we want a hash function and a
123:33 - table size
123:34 - that makes instances like this very rare
123:37 - but i really hope this is helping you
123:39 - guys to understand
123:40 - the core concepts of what's happening
123:42 - behind the scenes with hash tables so
123:44 - let's go back into
123:45 - our server.pi file and finish our
123:48 - function
123:51 - so we no longer need to print our table
123:53 - and actually let's go ahead and test
123:55 - this out with
123:56 - printing the individual keys within our
123:58 - hash tables so we can do
124:00 - ht.getvalue and we can pass in the key
124:03 - that we want to get the value for
124:05 - and we can do this for all of our keys
124:10 - so we'll do body date
124:15 - user id let's go ahead and save this
124:19 - and run our server again and then we can
124:21 - just send this request again
124:22 - we're going to get an error and as you
124:24 - can see it printed out our title
124:26 - post one it printed out our body which
124:29 - is this is a blog post it printed out
124:31 - our date time
124:33 - and it printed out our user id so now
124:36 - that we know that that's working as
124:37 - expected we can go ahead and go back
124:39 - into our server.pi
124:41 - file and we no longer need this and now
124:44 - we can just
124:45 - move forward with creating our blog post
124:47 - now creating a blog post
124:48 - is actually pretty straightforward we
124:50 - can just create a variable called new
124:52 - blog post
124:54 - and we have to instantiate a blog post
125:05 - and again we're using our get value
125:07 - method to
125:08 - actually return the values
125:24 - and then we could just do db.session.add
125:28 - and then the new blog post instance that
125:30 - we just created and then we can just
125:31 - commit the session
125:34 - and sorry this should be session and
125:37 - then once that is done we can return
125:38 - jsonify
125:40 - we'll do message
125:44 - new blog post created
125:49 - and this is going to be a success
125:51 - response so we'll
125:52 - return 200 and let's save this and see
125:56 - if it works
125:58 - python server.buy servers running and
126:01 - let's
126:02 - send this request and we get a success
126:05 - response new blog post created
126:07 - and now let's check our database to see
126:09 - if our blog post is actually stored
126:11 - within the database
126:13 - so in the blog post table we can refresh
126:16 - and we can go back to the bottom of the
126:18 - table
126:21 - and you'll see here that we have a new
126:23 - blog post with id 201
126:25 - with our title post one and our body
126:28 - this is blog post
126:30 - and our date and our user id
126:38 - now to start in our project directory we
126:41 - want to create a file
126:42 - called binarysearchtree.pi
126:46 - and within that file similar to our
126:49 - linked lists
126:50 - and hashtable implementations we want to
126:52 - create a node class
126:58 - and the initialization parameters for
127:00 - this class are going to just be
127:02 - self and data
127:06 - and we'll set self.data equal to data
127:10 - and within a tree structure
127:11 - instead of the node only pointing to a
127:13 - next node
127:14 - it's actually going to point to a left
127:17 - and a right node
127:18 - and don't worry if you're having a hard
127:19 - time visualizing this we'll take some
127:21 - time to go over what this looks like in
127:23 - just a second
127:24 - but for now just know that an individual
127:26 - node will point to both a left node and
127:28 - a right node
127:34 - and we're also going to want to create a
127:36 - wrapper class for our binary search tree
127:45 - and this class will just be initialize
127:47 - with self
127:50 - and our tree structure will need a root
127:53 - node which is
127:54 - the top node of the tree so our root
127:56 - node will have no parent nodes
127:58 - and again we're going to go over what
128:00 - this would look like in a visualization
128:02 - soon
128:03 - and next and most importantly we're
128:05 - going to want to define our methods for
128:08 - our insertion and for our insertion
128:10 - methods we're going to need to write
128:12 - some recursive code
128:13 - so if you're relatively unfamiliar with
128:16 - the way that recursion works
128:17 - i have some videos that can help you to
128:20 - visualize recursion which can be
128:22 - accessed by clicking the link currently
128:24 - displayed on your screen
128:26 - so to start we can just define our
128:28 - insert method
128:30 - which is going to take in self and the
128:32 - value that we want to
128:33 - insert and the first thing we'll want to
128:35 - do is check if
128:37 - our route is none
128:42 - and if this is the case this just means
128:44 - that our top node or the first node
128:47 - within our tree structure is none which
128:49 - means our tree
128:50 - is empty and if that's the case we'll
128:52 - just set our root
128:53 - equal to a new node containing our value
128:57 - and if we go back to our node we see
128:59 - that when we create a new node and we
129:01 - pass in the data
129:03 - the left node and the right node are
129:05 - both set to none
129:08 - so when we add this first node to our
129:10 - tree structure
129:11 - it's only going to contain a root node
129:13 - and the root node's going to point to
129:16 - none for both its left node and its
129:17 - right node so it will be
129:19 - a tree structure that only contains one
129:21 - node so far
129:22 - and that's if we're inserting a value
129:24 - into an empty tree structure
129:26 - else if our tree is not empty we will
129:30 - need to
129:30 - use a recursive function to insert into
129:33 - our tree and this is because we'll
129:35 - essentially need to find an empty node
129:37 - to insert our value into
129:39 - so we haven't yet created this method
129:41 - but let's just write it out we'll just
129:42 - call it
129:43 - insert recursive and the reason
129:46 - we're starting this method with an
129:48 - underscore is because this method should
129:50 - only be used by our
129:51 - insert method so basically this insert
129:54 - recursive method
129:55 - is a private method that belongs to
129:59 - our insert method
130:02 - we're going to pass in the value and the
130:05 - current root
130:07 - so now we can go ahead and write the
130:08 - code for this method
130:17 - and the way that a binary search tree
130:19 - works is the node's left subtree
130:22 - so that is the tree that expands from
130:24 - the node's left node
130:25 - should only contain values that are less
130:28 - than the node's value
130:29 - and the tree's right subtree which is
130:32 - the tree that expands from the node's
130:34 - right node
130:35 - should only contain values greater than
130:37 - the node's value
130:38 - which results in the nodes left and
130:41 - right
130:42 - subtrees also being binary search trees
130:44 - and i know that this is quite difficult
130:46 - to understand with just me describing
130:48 - the way that a binary search tree should
130:50 - look but just bear with me we're going
130:52 - to
130:53 - go into more details soon but with that
130:55 - in mind
130:56 - if the value passed to our insert
130:58 - recursive method
131:00 - is less than the past nodes data we're
131:02 - going to
131:03 - insert that value in the past node's
131:06 - left subtree
131:07 - so if value is less than node.data
131:11 - we're going to insert value into node's
131:14 - left subtree and if node.left is none
131:16 - then that means we can just insert the
131:19 - value into node.left
131:21 - so if node.left is none
131:24 - and node.left will just equal a new node
131:28 - containing our value else if node.left
131:32 - is not none
131:33 - then that means that node.left contains
131:35 - a node with a value
131:37 - and that node can also have a left
131:40 - and a right node so we're going to need
131:41 - to call our recursive function again
131:44 - because we would want to do the same
131:46 - exact thing for the left node we would
131:48 - want to
131:49 - make sure our insertion goes into
131:52 - the left subtree of the left node if
131:54 - it's less than the left node or the
131:56 - right subtree
131:57 - of the left node if it's greater than
131:59 - the left node so we'll just do
132:01 - self.insert recursive
132:04 - and again we'll pass in the value and
132:06 - this time we would pass in node.left
132:09 - and that's what we would do if value is
132:12 - less than node.data but if value is
132:14 - greater than node.data
132:16 - we would do the same thing but this time
132:18 - we would do it on
132:20 - node.write so we can do l if value is
132:23 - greater
132:24 - than node.data we'll check if node.write
132:27 - is none
132:30 - and if it is we'll just set node.right
132:32 - equal to
132:33 - a new node containing our value
132:37 - else once again we would call our
132:41 - insert recursive function passing in our
132:43 - value and node.right
132:46 - and last but not least else we would
132:49 - just
132:49 - return and this is because if the value
132:52 - isn't less than node.data and the value
132:55 - isn't
132:56 - greater than node.data then that means
132:58 - the value is equal to
133:00 - node.data so our else would be if the
133:02 - value is equal to node.data
133:04 - and if the value is equal to node.data
133:07 - that means that the value is already
133:09 - contained within our tree
133:10 - and a binary search tree shouldn't have
133:12 - duplicates so if that is the case we're
133:14 - going to do nothing here
133:16 - so now let's take some time to try and
133:18 - visualize what's happening here
133:20 - okay so let's start by visualizing what
133:22 - would happen if we create an instance of
133:24 - our node class
133:26 - so we can imagine that we create a
133:28 - variable
133:29 - node and that variable is going to be
133:33 - an instance of a node and we'll pass
133:37 - in some random data so let's just say
133:39 - the number 15.
133:40 - and this instantiation is going to look
133:43 - something like
133:44 - this we'll have a node here and it will
133:46 - contain
133:47 - 15 and then we'll have a left and a
133:49 - right
133:51 - left right and these will also be nodes
133:56 - which will contain none
134:01 - so as you can see here self.left is
134:04 - going to be none
134:05 - and self.write is going to be none as
134:07 - well and then our data
134:09 - our actual node is going to be 15. so
134:11 - this is how we can visualize an instance
134:13 - of a node
134:14 - so let's go ahead and erase this and see
134:18 - what it would look like
134:19 - if we create an instance of an actual
134:21 - binary search tree
134:23 - so let's say we call our binary search
134:25 - tree bst
134:27 - and we set it equal to an instance of
134:29 - binary search tree
134:36 - this is going to give us an empty binary
134:38 - search tree with the
134:40 - root set equal to none and the root is
134:43 - just
134:43 - the first node within the tree so a tree
134:46 - might look something like this
134:53 - this here is our root node
134:56 - and in our binary search tree if this
134:58 - root node is empty
134:59 - then that means that the entire tree is
135:02 - empty
135:06 - let's just draw this again so now that
135:09 - we've created an
135:10 - instance of binary search tree we have
135:12 - an empty
135:13 - binary search tree here now let's say we
135:15 - want to call our
135:17 - insert method
135:20 - and pass in the value 20. we're going to
135:23 - end up here at insert and the value is
135:26 - going to be 20.
135:27 - and if self.root is none which it is
135:29 - it's empty
135:30 - then self.root's going to become a new
135:33 - node with that value
135:34 - 20. so this is going to become 20 and
135:37 - this new nodes left
135:38 - and right are both none so the left is
135:41 - pointing to none
135:42 - and the right is pointing to 9 as well
135:45 - and for none we just won't put
135:46 - anything into the node and here's our
135:49 - root
135:50 - left right
135:53 - now let's say we insert another value
135:59 - and this time we'll insert one so what's
136:01 - going to happen is we're going to end up
136:03 - here again
136:04 - and this time our root is not none so
136:05 - we're going to move on to this recursive
136:08 - insert so we'll end up here with our
136:10 - value
136:11 - being 1 and we're going to pass in the
136:13 - root so
136:14 - our node here is going to be our root
136:16 - which is 20. and we're
136:18 - going to check if our value 1
136:21 - is less than our node which is our root
136:24 - 20. and if it is it means that it needs
136:27 - to go into
136:28 - our node's left node because as
136:31 - explained before
136:32 - in a binary search tree a node's left
136:35 - node has to be less than the node
136:37 - and the node's right node has to be
136:39 - greater than the node
136:41 - so if value is less than node.data
136:44 - so if 1 is less than 20 and if
136:48 - node.leftnode is none
136:50 - which it is then we're just going to
136:52 - insert that one
136:53 - into the left node and then we'll
136:56 - continue with another
136:58 - insert
137:01 - and this time we'll insert two and we're
137:04 - going to end up here
137:05 - and root is not none so we're going to
137:07 - call the recursive function again
137:09 - passing in the root and our value 2 and
137:12 - this time we'll end up here
137:14 - with our node being root and our value
137:17 - being 2
137:18 - and our value is less than our root
137:21 - which is 20. so 2 is less than 20
137:25 - but this time our left node of our root
137:28 - is not none
137:29 - it's one so now we need to call the
137:32 - recursive function again
137:33 - this time passing in our two and our
137:36 - left node which is one
137:38 - so we end up back up here with our value
137:41 - being
137:41 - 2 and our node being our left node now
137:45 - which is 1. so now 2 is not less than
137:49 - 1. 2 is actually greater than 1.
137:52 - so that's going to bring us here 2
137:55 - is greater than 1 our left node is 1.
137:59 - and this node's right node is none
138:02 - so we'll just add our 2 there
138:07 - so here we're just going to add our 2.
138:09 - and let's do another
138:11 - vst insert
138:14 - and let's do 30. so now we'll end up
138:17 - here
138:18 - our roots not none so once again we pass
138:20 - to the recursive
138:22 - function our value being 30
138:25 - and then our root so we'll end up here
138:27 - again
138:28 - now our value is 30 and our node is our
138:30 - root node which is 20
138:32 - and 30 is not less than 20. 30 is
138:36 - greater than 20.
138:37 - so we'll end up here and our right node
138:41 - of our root node is none right now so we
138:44 - can just
138:44 - add this 30 here
138:48 - and this would just go on and on and our
138:50 - root nodes
138:51 - write node will always contain a value
138:53 - that's greater than our root node and
138:55 - our root node's
138:56 - left node will always contain a value
138:58 - that's less than
139:00 - our root node and the same thing for
139:03 - these
139:03 - child nodes this left node's right node
139:07 - will always contain a value that's
139:09 - greater than our left node
139:11 - and this left node's left node will
139:14 - always contain a value
139:15 - that's less than our left node
139:19 - and it would just keep going that way
139:23 - so for example the value here would have
139:25 - to be less than 1
139:26 - and the same for here the value here
139:28 - would have to be less than 30 and the
139:30 - value here would have to be greater than
139:32 - 30.
139:32 - and you're going to see why this is
139:34 - necessary when we're actually
139:35 - implementing
139:36 - our binary search method now really
139:38 - quickly i want to go over something that
139:40 - is important for you all to understand
139:43 - that is that the order in which we make
139:45 - insertions into the binary search tree
139:48 - matters and it will impact the
139:50 - performance of our tree
139:52 - currently if we were to try to search
139:54 - this tree for the node containing the
139:56 - value
139:56 - 30 we'd be able to leverage our root
139:59 - node as a midpoint
140:02 - and we'd be able to completely avoid
140:04 - traversing
140:05 - any node to the left of our root because
140:07 - we know that any node to the left of our
140:09 - root
140:10 - or within this left subtree will be less
140:13 - than
140:13 - the value 20 our root value which will
140:16 - therefore
140:17 - be less than the value 30 which would
140:20 - leave us with the right subtree to
140:22 - traverse
140:23 - to find the value 30 without ever
140:25 - needing to traverse the left subtree
140:28 - now if this is confusing to you i
140:30 - suggest you watch my video on how binary
140:32 - search works which you can
140:34 - access by clicking the link currently
140:35 - displayed on your screen
140:37 - but continuing with my point the reason
140:39 - that the order in which we make
140:40 - insertions into the binary search tree
140:42 - matters is because the order of
140:45 - insertion impacts the structure of the
140:47 - tree
140:48 - so currently with the order in which
140:50 - we've made our insertions
140:52 - we have a balanced binary search tree
140:54 - because the height of our roots left
140:56 - subtree
140:57 - which is 2 1 2 differs from
141:00 - the height of our roots right sub tree
141:03 - which is 1
141:04 - only by 1. so that is the height of our
141:07 - left subtree
141:08 - is 2 and the height of our right subtree
141:11 - is 1
141:12 - and 2 minus 1 is 1 so
141:15 - the difference between our two subtrees
141:18 - is only one which makes this binary
141:21 - search tree balanced
141:23 - and it's not within the scope of this
141:25 - series
141:26 - but it is something that you will need
141:28 - to become familiar with as you go deeper
141:30 - into working with binary search trees
141:32 - but continuing with my point the reason
141:34 - that the order in which we make
141:36 - insertions into the binary search tree
141:38 - matters is because the order of
141:39 - insertion impacts the structure of the
141:41 - tree so with this
141:43 - insertion order that we currently have
141:45 - we are left with
141:46 - a balanced binary search tree but if we
141:48 - were to change the order of insertion
141:50 - we could be left with a completely
141:52 - different tree structure to demonstrate
141:54 - that
141:55 - let's insert these same values into our
141:57 - tree but this time in order from
141:59 - smallest to largest
142:00 - so we can start by just erasing this
142:03 - current tree structure
142:05 - and we'll leave this here for your
142:07 - reference but this is no longer
142:09 - the insertion that we're using to create
142:11 - our tree so let's create our new
142:13 - insertion
142:14 - here so we'll do bst
142:18 - dot insert
142:22 - and this time we'll start with one and
142:25 - what's going to happen is
142:26 - our tree is null so one is going to
142:28 - become our root
142:29 - so we'll just have one as our root node
142:32 - and then we'll do
142:33 - bst dot insert
142:38 - and this time we'll insert 2 and we'll
142:41 - end up here
142:41 - and then we'll go down to our recursive
142:44 - and we'll pass
142:44 - in the value 2 and our root which is 1
142:47 - and then we'll end up here
142:49 - our value two is greater than our root
142:52 - which is one
142:53 - and our roots right node is none so we
142:54 - would just add to our roots right node
142:57 - the value two
143:01 - then we insert again
143:07 - and this time we'd insert 20 and again
143:10 - we'd end up
143:11 - here insert recursive value 20
143:14 - root 1 and our value 20 is greater than
143:17 - our root but our right node
143:19 - already contains a value so we would
143:22 - insert again this time passing our right
143:25 - node
143:25 - and our value 20 and we'd end up back at
143:28 - the top here
143:28 - and now our right node is the node and
143:31 - our
143:32 - value is 20 and our value 20 is greater
143:34 - than our right node
143:36 - which is only two and this node's right
143:38 - value
143:39 - is none so we would just insert that 20
143:42 - here
143:42 - so we'd end up like this and then
143:46 - last but not least we'd insert
143:51 - our 30 and we do the same thing we'd end
143:54 - up here
143:55 - eventually leading us to adding our 30
143:58 - here
143:58 - now as you can see this tree structure
144:01 - here is very similar to a linked list
144:03 - that is to find 30 we would need to
144:06 - traverse through
144:06 - every node so we would have to go to
144:08 - this node's right node this node's right
144:10 - node this node's right node
144:12 - and finally arrive at 30 which would
144:14 - make searching this structure
144:16 - in particular take linear or o of n time
144:19 - so with this example you can see how
144:21 - insertion order can have a substantial
144:23 - impact on the performance of our binary
144:25 - search tree now we won't be getting into
144:27 - it in this tutorial
144:28 - but this is something that we can manage
144:30 - by coding our binary search tree in such
144:32 - a way that it is self-balancing
144:35 - which would therefore make it an avl
144:37 - tree or a self-balancing binary search
144:39 - tree but this is out of the scope of
144:41 - this series
144:41 - for now it's only important that you
144:43 - understand that the tree structure will
144:45 - differ depending on the order in which
144:47 - we make insertions and that in turn will
144:49 - affect the performance of our tree so
144:51 - let's move forward with adding the rest
144:53 - of the methods to our binary search tree
144:55 - class
144:57 - okay so before we add our search methods
145:00 - into our binary search tree class
145:02 - let's go back into our server file
145:06 - and set up our route and actually this
145:09 - rule
145:10 - should be blog post
145:13 - and then blog post id
145:16 - so this route is going to be used to
145:19 - retrieve one blog post based on its id
145:23 - and we'll change this also to blog post
145:25 - id
145:26 - and we'll go ahead and remove this pass
145:28 - and the first thing we're going to do is
145:30 - we're going to
145:31 - query all of our blog posts by doing
145:35 - blog post dot
145:39 - and what this is going to do is it's
145:41 - going to return to us
145:43 - a list of blog posts in ascending order
145:46 - and we're going to
145:47 - insert those blog posts into our binary
145:49 - search tree
145:50 - and we're going to use the search method
145:52 - on our binary search tree to search for
145:54 - and retrieve a specific blog post and
145:57 - our binary search tree search and insert
145:59 - methods are going to be
146:01 - based on our blog posts id so if you
146:04 - remember
146:04 - nodes within our binary search tree have
146:07 - to be inserted in a particular way
146:09 - such that a node's left node can't be
146:11 - larger than the node
146:13 - and the node's right node must be larger
146:15 - than the node and the value that we're
146:16 - going to use to determine this
146:18 - is our blog post id and if you remember
146:20 - if we
146:21 - insert into our binary tree in ascending
146:25 - order we're essentially going to get a
146:26 - tree structure similar to a list
146:28 - and there are actually only a couple of
146:30 - ways for that particular
146:32 - linear tree structure to be produced and
146:34 - that is if we insert nodes in ascending
146:37 - order and if we insert them
146:38 - in descending order because as shown in
146:40 - our example
146:41 - when you insert nodes in order from
146:44 - smallest to greatest
146:45 - we're just going to keep adding nodes to
146:48 - the previous node's write node which
146:50 - will result in a list like structure and
146:52 - the same thing would happen if we
146:54 - insert nodes from largest to smallest
146:57 - but in that case
146:58 - the list like structure would be in the
147:01 - other direction
147:02 - but it would still be a list like
147:03 - structure so our way to solve this
147:05 - is we're going to attempt to create a
147:08 - more balanced tree structure by
147:10 - randomizing our inserts
147:11 - so basically we're going to take this
147:13 - ascending order by id
147:15 - blog post list and we're just going to
147:17 - shuffle it using this random module
147:24 - and we need to import that random module
147:26 - so let's go here
147:27 - and do import random
147:32 - so now our blog post list will no longer
147:34 - be in ascending order it'll be in a
147:36 - completely random order
147:37 - and when we iterate through it and add
147:39 - it to our binary search tree
147:41 - our tree structure will also be
147:43 - randomized
147:44 - and with this random tree structure we
147:46 - have a better chance of getting a
147:48 - balanced binary search tree which in
147:50 - turn will increase the overall
147:51 - performance of our tree
147:53 - so now we also need to import our binary
147:55 - search tree module so we can go back up
147:57 - here
147:58 - and similar to our hash table we can
148:01 - just do binary search tree
148:06 - and we can create a binary search tree
148:10 - instance
148:12 - and we can insert into our tree by doing
148:14 - for post
148:15 - in blog posts bst.insert
148:23 - and we're actually going to insert
148:24 - dictionaries as our individual blog
148:26 - posts
148:27 - so we're actually going to need to go
148:29 - back into our
148:30 - binary search tree insert method and
148:33 - make some changes
148:34 - so we will do id and that's going to be
148:38 - post.id
148:40 - and we need title body and user so let's
148:43 - change this to title
148:46 - and same here
148:58 - and once we've generated our binary
149:00 - search tree we can create a post by
149:02 - just doing vst.search which we have not
149:05 - yet
149:06 - implemented but we will and search is
149:08 - going to return
149:09 - the blog post of the past blog post id
149:12 - and the idea is for our binary search
149:14 - tree to be a balanced tree so that our
149:17 - search takes logarithmic time and lastly
149:20 - we're going to do if not post
149:22 - because our search method is going to
149:24 - return false
149:26 - if the blog post for the corresponding
149:28 - id is not found
149:30 - and if that's the case we're going to
149:31 - return jsonify
149:37 - post not found
149:41 - and if the post is found we'll just
149:43 - return jsonify
149:45 - post
149:49 - so let's go ahead and save this and go
149:51 - back into our binarysearchtree.5 file
149:54 - and here we're going to need to make
149:56 - changes to our
149:57 - insert recursive so we're going to be
149:59 - changing this value
150:01 - to data because we're no longer
150:04 - inserting just a single value we're
150:06 - inserting a dictionary
150:07 - and when we do these comparisons we're
150:10 - going to
150:11 - be comparing the ids within the
150:13 - dictionary so this would be changed to
150:14 - data
150:15 - id and this would be id as well
150:20 - so now we're comparing the past data's
150:23 - id
150:23 - to the nodes data's id
150:27 - here data same for here
150:37 - and also for this insert method we're
150:40 - going to do the same thing
150:42 - data data
150:45 - data so let's go ahead and see if this
150:47 - works
150:48 - so we'll save here we'll run our server
150:54 - and then we'll go and add another
150:56 - request to postman to get a single blog
150:58 - post based on its id so once you have
151:00 - postman open once again we can go to
151:02 - our flask api folder and hit add request
151:07 - and we'll just call it get blog post
151:11 - and save to flask api
151:14 - and we'll go to get blog post then our
151:17 - url
151:19 - and this is just going to be blog post
151:21 - and an
151:22 - id so let's just do five and let's go
151:25 - ahead and send this request
151:28 - and we get an error binary search tree
151:30 - has no attribute search
151:31 - because we haven't yet implemented our
151:33 - search method so let's go ahead and do
151:35 - that before we move forward
151:38 - so binary search tree
151:41 - so our search method is going to be
151:43 - fairly similar to our insert method in
151:46 - that it's going to be
151:47 - a recursive method
151:50 - so we'll define search
151:53 - and we'll take self and blog post
151:58 - id and let's change this
152:02 - and the blog post id that we get from
152:04 - the url is going to be a string
152:06 - so we're going to want to convert it
152:08 - into int
152:11 - because when we're comparing it to the
152:13 - blog post
152:14 - id within our data it's going to be
152:16 - compared to and
152:18 - we'll do blog post id as an int is our
152:21 - new blog post id
152:23 - and then self dot root is none
152:27 - we're just going to return false because
152:29 - if that's the case it means our binary
152:31 - search tree is empty
152:32 - so of course a blog post cannot exist
152:35 - within it
152:36 - but otherwise we're going to return
152:40 - self.underscore search
152:42 - recursive similar to the way we did our
152:45 - insert this search recursive method is
152:48 - going to be
152:49 - a private method that belongs to our
152:51 - search method
152:52 - and we're going to pass in the blog post
152:54 - id and self.root
152:57 - so now let's add this search recursive
153:04 - method
153:08 - it's going to take blog post id and node
153:12 - and since this is a recursive function
153:14 - we need a base case and our base case is
153:16 - going to be
153:17 - if the node passed in left node and
153:20 - right node is none then we're going to
153:22 - return
153:22 - false
153:33 - and first we'll check if our blog post
153:35 - id is equal to
153:37 - the current node's data's id and if
153:39 - that's the case then we'll just return
153:41 - the current node because that means that
153:42 - we found our node
153:44 - so if blog post id is equal to node.data
153:49 - id and just return
153:53 - node.data but if we're not so lucky
153:56 - we'll need to traverse the tree so
153:58 - if blog post id is less than node.data
154:06 - then we'll check to see if the blog post
154:08 - id is equal to
154:10 - our node's left node's data id so if
154:13 - blog post id is equal to node.left.data
154:19 - id if that's the case we can just return
154:24 - node.left.data
154:27 - but if it's not the case we're going to
154:30 - return
154:31 - self dot search cursive
154:34 - our blog post id and this time our left
154:37 - node
154:38 - so again this is similar to our insert
154:42 - and we're going to do the same thing if
154:44 - blog post id
154:45 - is greater than node.data
154:50 - id and if blog post id is greater than
154:53 - our node data's id then that means we're
154:56 - going to search the write subtree
154:58 - so if blog post id is equal to
155:03 - node.write.data id
155:10 - and we'll just return node.right.data
155:14 - but if not we'll recurse down our
155:17 - write subtree by passing in the blog
155:22 - id and node.write node
155:27 - so let's take a couple of seconds to go
155:29 - over what's happening here
155:31 - so if we can't find our blog post id
155:34 - within our binary search tree
155:37 - we will reach this base case which will
155:39 - just return false
155:40 - meaning that we couldn't find it and if
155:43 - our root node is in fact the data that
155:45 - we're searching for
155:46 - then we'll just return that root node
155:49 - but if our blog post id
155:50 - is less than our root note then we're
155:52 - going to traverse
155:54 - the left subtree because the right
155:56 - subtree will only contain
155:58 - values that are greater than our blog
156:00 - post id
156:01 - and then we check to see if the top node
156:03 - of our left sub
156:04 - tree is the data that we're searching
156:06 - for and if it is we'll just return that
156:08 - node
156:09 - but if not we're going to recurse down
156:11 - that left subtree
156:13 - and the same goes for if our blog post
156:15 - id is greater than our root node's data
156:17 - if that's the case then we're going to
156:19 - traverse our right subtree
156:21 - because the left subtree will only
156:23 - contain values that are less than
156:25 - our midpoint which is our root node so
156:28 - if the top node
156:29 - of our right subtree is the data that
156:31 - we're searching for
156:32 - then we can just return that but if not
156:35 - we'll need to recurse down
156:37 - our write subtree and that's going to be
156:39 - our search method so let's go ahead and
156:41 - save this
156:42 - and let's try running our server again
156:44 - and in postman
156:45 - let's try sending our requests to get
156:47 - blog post with id5 once again
156:50 - and we get post not found so let's check
156:53 - our database and see if we have a blog
156:55 - post with the id5
156:56 - so again you want to open your db
156:58 - browser and go to open database
157:00 - and then open your db file and let's go
157:03 - to blog post browse table
157:05 - and we do in fact have a blog post with
157:07 - the id5 so there's something wrong with
157:10 - our code
157:11 - so let's go back into our server.fi
157:15 - file and let's see what's happening here
157:21 - okay let's go into our search method and
157:23 - have a look
157:26 - ah i see so unreachable code because
157:28 - this returned we didn't
157:30 - add the proper indentation so this
157:32 - should be here
157:38 - and now let's go ahead and save and
157:41 - let's run our server again
157:45 - and back in postman let's go ahead and
157:47 - send the request for blog post with id5
157:50 - again
157:52 - and we get our blog post and we get our
157:55 - body
157:58 - our id our title and our user id
158:03 - let's try it with another blog post
158:06 - let's do 199
158:10 - and we get a blog post for id 199
158:14 - and now let's try it for a blog post
158:17 - that we know
158:17 - does not exist so we can just put in
158:20 - some random numbers here
158:24 - and we get another error so let's see
158:26 - what's happening
158:28 - let's close our server and let's go into
158:34 - binarysearchtree.pie
158:40 - sorry about that so this was a pretty
158:42 - big oversight on my part
158:44 - so we're going to remove this here
158:48 - and we're going to add to this portion
158:51 - and node.left
158:55 - is not none
159:01 - and we'll do the same thing here but
159:03 - we'll do
159:04 - if node.right is not none
159:09 - and then we need to return false here
159:12 - so what was happening was we were trying
159:14 - to compare the blog post id
159:16 - to node.data of a left node
159:20 - or a write node which was actually equal
159:23 - to none
159:24 - so there was no way to access the data
159:26 - of none so now let's save this
159:28 - and run our server again and in postman
159:31 - we can try to
159:32 - send a request to retrieve this blog
159:35 - post with this
159:36 - random id that we know doesn't exist
159:37 - once again
159:40 - and this time we'll get post not found
159:43 - and if we put an id that does exist
159:46 - let's say 200
159:48 - we'll get the blog post and let's take
159:50 - this a step further
159:52 - and just put a really random long number
159:56 - and send it and we get post not found
159:59 - and
159:59 - now we've created our route to retrieve
160:02 - a blog post for a particular blog id
160:05 - and we've made use of our binary search
160:07 - tree to search for
160:09 - and retrieve that particular blog post
160:16 - and just really quick let's go into our
160:18 - server.pi file
160:20 - and here where we did our last route
160:23 - which made use of our binary search tree
160:25 - the definition of this function get all
160:28 - blog posts
160:28 - is actually wrong so let's go ahead and
160:31 - change this to
160:33 - get one blog post
160:36 - and we can save this and now we're going
160:39 - to create
160:40 - a new file for our queue implementation
160:43 - and we'll call it custom queue.pi
160:47 - and to start off our queue we're going
160:49 - to create a class for
160:50 - a node and this is going to be the same
160:53 - node class that we use for a linked list
160:55 - and actually our queue is basically just
160:58 - going to be
160:58 - a linked list where inserts and removals
161:01 - are done in a first
161:02 - in first out order and we'll go deeper
161:05 - into what that means in just a second so
161:07 - let's just
161:08 - go ahead and define our node
161:23 - so if you've been watching up to this
161:25 - point you should be familiar with this
161:26 - node class
161:28 - next we'll add a class for our cue
161:38 - and for our cue class we want to keep
161:40 - track of the head
161:43 - and the tail
161:47 - and the head is just going to be the
161:49 - head of our linked list
161:50 - of course and the tail is going to be
161:53 - the last
161:53 - node of our linked list and to
161:57 - insert data into the queue we're going
161:59 - to define
162:00 - enqueue
162:06 - sorry and enqueue will only ever add
162:09 - nodes
162:09 - to the end or the tail of our linked
162:12 - list
162:12 - so you can just think of it as a line of
162:14 - customers at starbucks or something
162:16 - like if you get in line like new
162:18 - customers can't just go to the front of
162:20 - the line
162:21 - just like a new node can't just be added
162:23 - to the head of this linked list
162:25 - a new customer would have to go to the
162:27 - end of the line which is what this
162:28 - enqueue method is going to do it's going
162:30 - to add a new node to the end of our
162:32 - linked list
162:33 - and to do that first if our queue is
162:35 - empty both
162:36 - self.tail and self.head are going to be
162:39 - none
162:39 - so if self.tail is none
162:43 - and self.head is none and if that's the
162:46 - case the node that we're inserting is
162:48 - going to be both
162:49 - our tail and our head because there will
162:51 - only be
162:52 - one node in our list so it'll be
162:54 - self.tail
162:56 - equals self.head which equals a new node
162:59 - containing our data and it's going to
163:02 - point to none
163:03 - and then we'll just return so this is
163:05 - what we'll do if our queue is empty
163:08 - but if the queue isn't empty we want to
163:10 - add our new node
163:12 - to the last node's next node so
163:15 - self.tail.nextnode
163:16 - is going to be equal to a new node which
163:19 - will contain our data
163:21 - and it will point to none because this
163:23 - will be our new tail
163:25 - so it will be set to our new tail so
163:27 - self.tail
163:28 - is going to equal self.tail.nextnode
163:32 - which is the one that we just created
163:34 - here and then we'll just return
163:39 - now that's how we're going to add to our
163:42 - queue
163:42 - now we need to remove from our queue as
163:45 - well so we need to create the method to
163:46 - remove from our queue so this is going
163:48 - to be called dq
163:49 - so define dq
163:52 - self and dq is only going to remove from
163:55 - the head of our linked list
163:57 - so keeping with the starbucks example
163:59 - the front of the line the person that's
164:01 - at the register
164:02 - making their order that's going to be
164:04 - the first person removed from the line
164:06 - and it's going to be the same with this
164:08 - queue notes can only be removed from the
164:10 - queue
164:11 - from the head of the linked list or
164:13 - front of the line so that means
164:15 - if self.head is none
164:18 - then that means that our queue is empty
164:19 - so we'll just return none and if our
164:21 - queue is not empty
164:22 - when we dequeue we're going to want to
164:24 - return the node so we'll just store it
164:27 - in this removed
164:28 - variable so our self.head our current
164:31 - head is going to be
164:32 - set to our remove variable and then
164:35 - we'll set our new head
164:37 - self.head is equal to our current head
164:40 - self.head dot next node
164:43 - and that's how we're removing from the
164:44 - queue we don't need to worry about
164:46 - allocating memory or anything like that
164:48 - because
164:48 - python has garbage collection so all we
164:50 - need to do is
164:51 - change what node our head is pointing to
164:54 - and next itself.head is none
164:58 - which means that if when we
165:01 - change where our head is pointing to it
165:04 - ends up pointing to
165:06 - a next node that is none that means that
165:08 - the head of our
165:09 - q was also the tail of our q which means
165:12 - that if we dequeue that last node then
165:15 - our length list or
165:16 - our q is now empty because the only node
165:18 - in this linked list that will have a
165:20 - next node pointing to none is going to
165:22 - be the tail right
165:23 - so if after completing this our head is
165:26 - none then that means that
165:27 - our linked list is now empty so we need
165:29 - to update our tail
165:31 - as well to point to none so we'll just
165:33 - do self.dale
165:34 - equals none and then lastly we want to
165:37 - return
165:39 - the node that we removed from the queue
165:41 - so we'll return
165:42 - removed and it's as simple as that a
165:45 - queue is just a linked list where we
165:46 - control
165:47 - insertions and removals in such a way
165:50 - that inserting and removing from the
165:51 - linked lists
165:52 - happens in first in first out order so
165:55 - let's take a couple of minutes to try
165:56 - and visualize what's happening here
165:58 - okay so let's take some time to try and
166:00 - visualize our cue
166:01 - so let's do a quick refresher on how we
166:04 - visualize our node
166:06 - we're going to visualize our node like
166:08 - this
166:11 - our data and our pointer to next node
166:14 - and of course this node can point to
166:16 - another node which can point to another
166:18 - node
166:18 - essentially creating a linked list and
166:21 - that's one thing that you should
166:22 - understand about a queue a queue is
166:24 - essentially just a linked list
166:25 - it's a linked list with certain
166:27 - specifications for how we insert
166:29 - and how we remove nodes from the linked
166:32 - list
166:32 - so let's just go over a quick example of
166:35 - adding nodes to
166:36 - our queue and then removing them so
166:39 - let's erase this
166:40 - and let's go ahead and create an
166:42 - instance of a queue which we'll just
166:43 - call
166:43 - q and
166:47 - it's always weird spelling the word q
166:49 - and then once we have an instance of the
166:50 - q
166:51 - we can do q dot
166:55 - n q
166:59 - some data and what that's going to look
167:01 - like is we're going to end up here
167:03 - and if self.tail is none and self.head
167:06 - is none
167:07 - then self.tail equals self.head
167:10 - equals our node which means that we're
167:12 - going to
167:13 - add a node here with our data
167:19 - it's going to point to none because as
167:21 - you can see it's a new node
167:23 - and it's going to point to none and this
167:24 - node is going to become both
167:27 - our head
167:31 - and our tail
167:34 - and i apologize for this so then we can
167:37 - come in and do
167:38 - q dot in q once again
167:42 - this one will do data two and what's
167:45 - going to happen is we're going to end up
167:47 - here again
167:48 - and we're not going to have to go
167:49 - through this because we don't have an
167:51 - empty queue
167:52 - so we're going to end up here
167:55 - self.tail.nextnote is going to equal
167:57 - our new node so in a queue we're always
168:00 - just going to
168:00 - add to the back of the queue it's just
168:04 - like a line at starbucks
168:05 - you can't just jump to the front of the
168:07 - line and buy your fancy coffee you have
168:09 - to wait
168:10 - in the line full of other starbucks
168:12 - coffeeers
168:14 - or whatever so what we're going to do is
168:17 - we're just going to do
168:18 - self.tail.nextnode equals a new node
168:21 - so this is our tail right so the tails
168:23 - next node is just going to be this new
168:25 - node with data
168:28 - 2. and it's going to point to none and
168:31 - let's add another one maybe somebody
168:32 - else wants to get some coffee
168:36 - we'll call this one data3 of course and
168:39 - we'll end up here again and we're just
168:41 - going to add it to the back of the line
168:43 - simple right oh and i'm sorry i forgot
168:45 - so this tail
168:46 - no longer points to this one because
168:49 - after we added it to the back of the
168:50 - line we set self.tail equal to
168:53 - self.tail.nextnode so
168:56 - self.tail.next is this node so this
168:59 - tail is now going to point here
169:02 - i hope that didn't confuse you because
169:05 - that was
169:05 - before doing this okay so now we're back
169:08 - to
169:09 - doing this and we'll end up here and
169:11 - we're going to
169:12 - do self.tail.nextnote equal to a new
169:15 - node so our tails
169:17 - next node is going to be equal to a new
169:19 - node
169:21 - and that one's going to be data 3
169:25 - and it's gonna point to none
169:29 - this is none again sorry about that all
169:31 - right so now that we've
169:33 - created our starbucks line oh sorry once
169:36 - again i forgot to
169:38 - change the tail so now our tail
169:41 - is going to point to here
169:44 - so this is our last person in line and
169:46 - this is the person in the middle and
169:48 - this is the person at the front of the
169:49 - line the head
169:49 - okay so now what we want to do is see
169:52 - how dq works so dq
169:54 - works like this we're just going to do q
169:56 - dot
169:57 - dq
170:02 - and of course we're not going to pass
170:03 - anything to dq because we have no
170:05 - control over what gets removed from dq
170:07 - because it's always going to remove the
170:09 - head of our list
170:11 - so dq we're going to end up here if
170:13 - self.head is none we're going to return
170:15 - none of course because that means that
170:16 - there is no
170:17 - line there is no queue and we're going
170:19 - to store our head
170:20 - in the removed so we can return it and
170:23 - then our self.head is just going to be
170:24 - equal to self.head.nextnode
170:27 - so all we're going to do is we're just
170:29 - going to
170:30 - move this from pointing to that head to
170:33 - pointing here
170:34 - and we're just going to leave this here
170:36 - and eventually this will be garbage
170:38 - collected
170:38 - so our new head is this and here let's
170:42 - let's actually let's let's step through
170:44 - so we can get to this portion so you can
170:45 - see what's actually happening here
170:47 - so let's do q dot dq
170:50 - again really bad at spelling
170:55 - q and when we dequeue again
170:58 - we're going to set our head
171:01 - to this one because once again we do
171:03 - self.head as equal self.head.nextnode so
171:06 - it's going to be equal to this one
171:08 - so now our head and our tail are both
171:10 - the same node
171:11 - and let's just pretend our garbage
171:13 - collector came along
171:14 - and garbage collected these
171:18 - so now this is what we're left with our
171:21 - head and our tail are both the same node
171:23 - now at this point
171:24 - if we dq again q dot dq
171:30 - if we see here our next note is none and
171:32 - we're going to set our self.head
171:33 - to our next node which is none so let's
171:36 - erase this
171:38 - and let's change it to 0.2
171:41 - this none so now our head is set to none
171:44 - but our tail is still pointing to this
171:47 - node here
171:48 - even though this guy was actually
171:51 - removed from the queue
171:52 - and as long as this tail is pointing to
171:54 - this node here
171:55 - this node will never be garbage
171:57 - collected either so what we need to do
171:59 - is once our head gets set to none
172:01 - if self.head is none so if if we moved
172:04 - our head to be set to none
172:05 - like we just did self.head is going to
172:08 - equal none right
172:09 - our head equals none if that's the case
172:11 - we need to set our tail to none as well
172:13 - because this tail pointing to this is no
172:16 - longer accurate our tail is now none as
172:18 - well
172:18 - because there's no longer anything left
172:20 - in the queue so at this point
172:22 - we're going to move this to point to
172:25 - none
172:26 - and then this guy is going to get
172:27 - garbage collected
172:30 - he's going to the trash so now both our
172:33 - head
172:33 - and our tail are pointing to none which
172:36 - means that our q
172:37 - is empty and that's how we can visualize
172:40 - how
172:41 - nodes are added and removed from our
172:43 - queue
172:44 - and how we can visualize our queue in
172:45 - general okay so now that we understand
172:48 - how we can visualize our queue
172:49 - let's go back into our server.pi file
172:52 - and make use of it for one of our
172:54 - endpoints
173:00 - and we're going to change this rule
173:03 - to blog post forward slash
173:06 - numeric body we're going to change this
173:10 - to get numeric
173:13 - post bodies and what this route is
173:16 - essentially going to do is it's going to
173:19 - convert our blog post bodies to
173:22 - a numeric value containing the total of
173:25 - each individual
173:26 - character within the body's ascii
173:29 - decimal equivalent
173:30 - so it sounds complicated but basically
173:32 - all it's going to do is it's going to
173:35 - iterate through each character within
173:37 - our body
173:38 - and it's going to add all the characters
173:40 - within our body up by their decimal
173:43 - value
173:43 - so our body is just going to be
173:44 - converted into one integer
173:48 - and we're no longer going to need to
173:50 - access that blog post variable
173:52 - and we're going to get our blog posts
173:54 - from our database by doing
173:57 - blogpost.query.all
174:02 - then we're going to create a queue which
174:04 - we'll just call
174:05 - q and it's going to be from custom q
174:09 - and instance of q and we have to import
174:12 - our custom q module
174:15 - we'll go here
174:18 - change that to custom cue
174:22 - and now we want to add every post from
174:25 - our
174:25 - blog post to our queue so for post
174:29 - in blog posts we want to do
174:33 - q dot enqueue
174:36 - and pass in our post as the data and
174:38 - we're going to return a list
174:40 - so let's create a return list which is
174:43 - just going to be an empty list for now
174:47 - so at this point our queue contains all
174:49 - of the posts from this blog post query
174:54 - and what we want to do is we want to
174:56 - dequeue and process
174:58 - each post until our queue no longer
175:00 - contains any more posts
175:02 - so to do that we're just going to loop
175:04 - through the length
175:08 - of our blog posts because the length of
175:10 - our blog posts
175:11 - is the number of posts that we have in
175:13 - our queue as well
175:15 - so we can just use that number for our
175:17 - loop
175:18 - to dequeue each item within our queue so
175:21 - we'll do post
175:22 - equals q dot dq
175:25 - and if you remember dq is going to
175:28 - return
175:29 - the value that's removed and that's
175:32 - going to be
175:33 - passed to our post variable then we want
175:36 - to create a
175:36 - variable for numeric body we'll just
175:39 - start it off as 0
175:40 - and now we want to loop through every
175:42 - character in our post body
175:44 - and convert it into its integer
175:46 - equivalent from our ascii table
175:49 - and then we want to add that to our
175:50 - numeric body
175:52 - so for char and post data dot
175:56 - body numeric body plus equals
176:00 - then ord and then char
176:03 - and this ord function is just a built-in
176:06 - function
176:06 - that will convert our character into its
176:10 - integer ascii equivalent and now our
176:12 - post.data.body
176:14 - is going to be set equal to the numeric
176:16 - body instead of the actual
176:18 - blog post body and then
176:21 - our return list we're going to append
176:30 - our blog post dictionary containing the
176:32 - new body
176:46 - so this body is now going to just be a
176:48 - numeric value
176:50 - or an integer
177:00 - and lastly outside of our for loop we
177:02 - want to return
177:04 - jsonify our return list
177:10 - so let's take a second to go over what
177:12 - this is doing
177:13 - so at this line here we're just creating
177:15 - an empty queue
177:16 - an instance of our queue and if we go to
177:19 - our queue
177:20 - we should remember that we have two
177:22 - methods on our queue
177:23 - in queue and dq and we should also
177:26 - remember that a queue does
177:27 - insertion and removal in first in first
177:30 - out order so whenever we enqueue we're
177:32 - adding to the
177:32 - end of our linked list or the end of our
177:34 - queue or the back of the line
177:36 - if that's easier for you to visualize
177:38 - and whenever we dequeue
177:40 - we're removing from the head of our
177:42 - linked list or the front of our line
177:46 - so here for each blog post the blog
177:48 - posts are in ascending order
177:50 - and we're adding them to our queue in
177:52 - ascending order as well because we're
177:54 - iterating through them
177:55 - in its ending order so for example if we
177:57 - have blog post id one
177:59 - two and three when we enqueue the first
178:01 - one one
178:02 - it's going to become the first and last
178:04 - node of our queue
178:06 - then when we enqueue the second one two
178:08 - it's going to
178:09 - get added to the end of our queue so
178:11 - it's gonna get added after one and then
178:13 - the same for three it's going to get
178:14 - added after two
178:16 - then here when we dequeue it we're
178:17 - dequeuing it in ascending order first we
178:19 - dequeue
178:20 - id1 then we dq id2 and then we dq id3
178:24 - and so on and so forth so essentially
178:26 - these posts
178:27 - are waiting in line to have their
178:29 - characters converted into integers
178:32 - so once one node has its body's
178:33 - characters converted into integers
178:35 - it gets appended to our return list and
178:37 - then we go on to the next item in the
178:39 - queue and eventually we get to a point
178:41 - where our queue is empty
178:42 - and at that point we'll just return the
178:44 - entire list
178:46 - so let's go ahead and test this out so
178:48 - let's start our server python server.pi
178:52 - and back in postman we'll create a new
178:55 - request
178:56 - and we'll just call it git numeric body
178:59 - and we'll save it to flask api open it
179:01 - up
179:03 - let's go into this blog post
179:07 - and take this
179:13 - and our rule is blog post forward slash
179:16 - numeric
179:17 - body and let's go ahead and send this
179:19 - and see what happens
179:22 - and as you can see we get our blog post
179:25 - back
179:25 - and the bodies are now converted into a
179:28 - single
179:29 - integer okay so now to implement our
179:32 - stack
179:32 - we can create a file called stack.pi
179:36 - and again we'll start with creating a
179:38 - class called node
179:48 - which will have the same structure as
179:50 - our linked list node as well
179:59 - and this is because a stack is also
180:02 - essentially just a linked list
180:04 - and just like our queue the only
180:06 - difference between a normal linked list
180:08 - and a stack
180:09 - is a stack does insertions and removals
180:12 - in last
180:12 - in first out order so let's go over what
180:15 - that means
180:16 - by creating our class for stack
180:25 - so for our stack we only need to keep
180:27 - track of the top
180:29 - and the top is essentially the same as
180:31 - the head of our linked list
180:32 - we're just going to call it top because
180:34 - when we visualize it top is going to
180:35 - actually make more sense
180:37 - and you'll see what i mean when we go to
180:39 - the blackboard explanation
180:40 - so self dot top equals
180:44 - none for now and we can just define a
180:47 - method called peak
180:49 - to just see what our current top is and
180:52 - all this is going to do
180:53 - is return self.top and we'll define
180:56 - another method
180:58 - called push and this is how we're going
181:00 - to
181:01 - insert nodes onto our stack
181:06 - and all we're going to do with our push
181:07 - is we're going to replace our current
181:09 - head with the new node
181:11 - and then make our current head the next
181:13 - node so we're basically just
181:15 - placing this node on top of our current
181:17 - head and then
181:18 - that node becomes our new head so we'll
181:21 - create a next node variable to store
181:23 - our current top and i'm sorry if i'm
181:26 - saying top and head interchangeably
181:29 - that's because they're the same thing
181:30 - so don't get confused and then our new
181:33 - top
181:34 - is going to be a new node which contains
181:37 - our data
181:38 - and next node and our next node is going
181:41 - to be our current top
181:42 - or head and then we set our new top
181:45 - equal to
181:47 - our new top and this is the only way
181:49 - that we can add to the stack
181:50 - we only can add it to the head of our
181:52 - stack or the top of our stack
181:54 - or the head of our linked list i hope
181:56 - this isn't getting too confusing it's
181:57 - actually very simple
181:59 - and i'll show you soon and for removing
182:02 - from our stack it's also very simple
182:04 - we'll define a method called pop
182:08 - and all pop is going to do is remove the
182:11 - head or remove the top and whichever
182:13 - node is next from the head
182:14 - is going to become our new top that's it
182:16 - so if self.top
182:18 - is none that means that we have an empty
182:22 - stack so we'll just return none and
182:24 - again we want to keep track
182:25 - of the removed node because we want to
182:28 - return it
182:30 - and we'll set our new top equal to
182:33 - self.top.nextnode
182:35 - very simple then we'll just return
182:38 - removed
182:39 - and that's going to be it for our stack
182:41 - implementation
182:42 - so let's go ahead and take some time to
182:45 - see what
182:46 - this code is actually doing as well and
182:48 - you'll find that it's very similar to
182:49 - the queue which is very similar to
182:51 - our linked lists because they're all
182:53 - essentially the same thing
182:54 - okay so let's take some time to try to
182:57 - visualize
182:58 - a stack so we're already familiar with
183:00 - how to visualize a node
183:01 - but when we visualize it in the context
183:04 - of a stack
183:04 - we're going to flip our node so what i
183:07 - mean by that
183:08 - is with linked list we visualize our
183:10 - node this way
183:12 - with our data being here and then our
183:15 - pointer to next node being here
183:18 - and then this would be our head
183:22 - and then there would be other nodes
183:23 - right and that would be a linked list
183:25 - well for a stack we're just going to
183:26 - look at it this way we're going to
183:28 - have it like this we'll have our data
183:31 - here
183:34 - and we'll have our pointer to the next
183:36 - node like this
183:38 - and instead of calling this head we'll
183:40 - call it the top
183:41 - of the stack and if we were to have
183:43 - another item in the stack it would look
183:45 - like this
183:46 - as well
183:49 - okay so let's erase this
183:56 - and let's go ahead and create an
183:58 - instance of the stack we'll just call it
184:00 - st
184:01 - equals a new stack
184:04 - instance and let's do
184:07 - dot push and we'll push
184:11 - some data and what that's going to look
184:14 - like is we're going to end up here
184:15 - and our next node is going to equal
184:18 - self.top and currently our self.top is
184:20 - none
184:21 - so our next node's going to be none and
184:23 - then our new top
184:25 - is going to be a new node with our data
184:27 - and this
184:28 - new node's next node is going to be this
184:31 - next node that we created which is none
184:33 - and then we'll set our self.top equal to
184:35 - that new top so what will that look like
184:37 - that's going to look like this
184:39 - so we're going to add a node
184:42 - with our data and it's going to be
184:46 - pointing to
184:48 - none and then this is going to be
184:51 - our self dot top
184:54 - and now let's go here and add another
184:56 - one push
185:00 - say data 2 and we're going to end up
185:04 - here again
185:04 - and now our next node is going to be our
185:06 - self.top
185:07 - so our next node is going to be this
185:09 - node and our new top is going to be a
185:11 - new node
185:12 - with its next node being this next node
185:15 - which is this one so all we need to do
185:17 - is we just need to create
185:19 - a new one data 2
185:24 - and its next node remember its next node
185:26 - is going to be the current top
185:28 - so its next node is just going to be
185:31 - this node
185:32 - see our new top is a new node with our
185:34 - next node being this node
185:36 - and then self.top is now going to be
185:38 - equal to our new top which is this one
185:40 - so this will no longer be our top this
185:43 - will now be our top and we would do the
185:46 - same thing
185:47 - if we added another item we would add it
185:50 - here
185:50 - and this new node's next node would be
185:52 - our current top and then we would change
185:54 - the top
185:55 - to this new node and so on and so forth
185:58 - so what happens when we do pop so pop it
186:01 - will only ever remove the head
186:03 - it'll never remove anything below the
186:04 - head so if self.top is none
186:07 - we're just going to return none because
186:09 - if top is none that means that our stack
186:11 - is empty right but in our case it's not
186:13 - none
186:14 - so we're going to store our current top
186:16 - which is this one
186:18 - in a removed variable so we're going to
186:20 - store this
186:21 - in our remove variable and then our
186:24 - current top
186:25 - we're going to set it equal to
186:28 - self.top.nextnode
186:30 - so we're going to set it equal to our
186:32 - top's next
186:33 - node so all we're doing is we're just
186:36 - changing this to point to this one
186:38 - and we're just removing this point here
186:41 - and then we're just returning the
186:42 - removed
186:43 - so we're returning the removed which is
186:45 - this one so it's getting popped off and
186:47 - returned and it's this one and this is
186:49 - going to just sit here we don't need to
186:50 - do anything with this because it'll be
186:52 - garbage collected so eventually
186:53 - something's going to come along and
186:55 - clean this up
186:57 - and we're going to be left with just
186:59 - this top and if we push on to the stack
187:01 - again we're always going to push on to
187:03 - the top and when we remove from the
187:05 - stack
187:06 - we're always going to remove from the
187:08 - top
187:09 - and that is how we can visualize a stack
187:13 - okay so now that we can visualize our
187:15 - stack let's go back into
187:16 - our server.pi file
187:20 - and first and foremost let's just import
187:23 - our stack
187:32 - and for our very last route we're going
187:34 - to use
187:35 - our stack to delete the last 10 blog
187:38 - posts
187:39 - within our database so we'll
187:42 - change this to delete last
187:46 - 10 and we can also
187:49 - change this to delete last in
187:53 - and again we don't need that blog post
187:55 - to be passed in
187:56 - and here once again we're going to do
187:59 - blog posts
188:00 - equals blog post dot query dot all
188:10 - and we'll call our stack instantiation s
188:12 - and we'll just do stack dot
188:14 - stack to create a new instance of stack
188:17 - and
188:17 - similar to our blog post we're going to
188:19 - iterate through our blog post
188:22 - and then we're going to push them onto
188:24 - our stack
188:26 - so now what we want to do is we want to
188:28 - loop through pops of our stack so
188:31 - we could do four in range
188:34 - 10 and then we're going to do post to
188:38 - delete equals stop pop
188:42 - and if you remember pop is going to
188:45 - return
188:45 - the node that we're popping off of our
188:47 - stack
188:49 - and once we have that node we can
188:50 - actually delete it by doing db.session
188:53 - dot delete and putting in our post to
188:57 - delete
188:59 - and then this is session not sessions
189:02 - and then dv.session.commit
189:07 - and if it's successful we're going to
189:08 - return jsonify
189:15 - and we'll just say success
189:20 - now if you're wondering why this deletes
189:22 - the last 10 blog posts
189:24 - it's because if you remember how a stack
189:26 - works insertions
189:27 - and removals are done in last in first
189:30 - out order
189:32 - so if we go to our push method we'll see
189:34 - that whenever we push
189:36 - a node onto our stack it gets pushed to
189:38 - the top of our stack
189:39 - or to the head of our linked list
189:43 - and this blog posts query is a list of
189:46 - blog posts
189:47 - in ascending order so if we're pushing
189:50 - onto our stack blog posts in ascending
189:52 - order
189:52 - the blog post with id 1 is going to get
189:55 - pushed on
189:56 - first and then every blog post following
189:58 - blog post with id 1
190:00 - is going to get put on top of blog post
190:03 - 1
190:03 - eventually resulting in the top of our
190:06 - stack
190:06 - being the last blog post in our database
190:09 - so if the last blog post in our database
190:11 - is 200
190:12 - the top of our stack is going to be blog
190:14 - post with id 200 and the bottom of our
190:16 - stack is going to be blog post with id1
190:19 - so when we loop through 10 times we're
190:22 - looping through
190:23 - and we're popping off the stack the top
190:25 - node for each iteration
190:26 - we're just popping off 200 then 199
190:30 - then 198 then 197 and so on and so forth
190:33 - until we pop off tin and for each one
190:36 - that we pop off the stack we're going to
190:37 - delete it from the database
190:38 - so it results in us removing the last 10
190:41 - items in the database
190:43 - every time we run this loop so let's go
190:46 - ahead and test this out
190:47 - we can run our server again
190:50 - and we're going to want to open our
190:52 - database to see our data to make sure
190:54 - that the right blog posts are being
190:55 - removed so we want to open our database
191:01 - then we can browse table for our blog
191:03 - post and we can go all the way to the
191:05 - bottom
191:06 - and we'll see that our last blog post id
191:09 - is 201 so if we were to remove
191:12 - 10 blog posts from here if we refresh
191:14 - this after calling that endpoint we
191:16 - should only be left with up to id 191
191:18 - so let's go into postman and create a
191:21 - new
191:22 - request so add request
191:26 - delete last tin
191:42 - blog post delete last
191:45 - 10 and it's going to be
191:50 - method delete and let's go ahead and
191:53 - send this and see what happens
191:56 - and we got an error so let's go see what
191:57 - happened
192:00 - so let's go into our server.pi file
192:03 - and the issue is i didn't add data
192:06 - to this post to delete because if we
192:10 - remember
192:10 - our pop returns a node and a node
192:14 - contains data as our data so we need to
192:17 - access the data
192:18 - by extending this data attribute so
192:21 - let's go ahead and save
192:22 - run our server again and let's go try
192:25 - this again
192:25 - so we'll send the request and this time
192:28 - we get success so now let's go and check
192:30 - our database and see if the proper blog
192:32 - posts have been removed
192:33 - so within our database we can go ahead
192:36 - and refresh
192:38 - and go down to the bottom once again and
192:40 - as you can see we only have blog posts
192:42 - up until id 191 so it's working as
192:45 - expected
192:48 - and that's going to be it for this
192:49 - tutorial congratulations for making it
192:51 - to the end
192:52 - if you enjoyed this video be sure to
192:54 - subscribe to my youtube channel
192:56 - and follow me on instagram and twitter
192:58 - at essie like a pro
193:00 - i make content like this every week so
193:02 - if this is something that you're
193:03 - interested in
193:03 - be sure to drop on by and of course if
193:06 - you haven't already
193:07 - please like this video and subscribe to
193:09 - free code camp for more exceptional
193:11 - content
193:11 - anyways i hope that you all have enjoyed
193:13 - this video and i hope that you've
193:15 - learned something
193:16 - and it's been a pleasure i'll see you in
193:18 - the next one