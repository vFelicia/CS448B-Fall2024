00:00 - are you ready to Ace your next technical
00:02 - programming interview in this video
00:04 - Keith Galley conducts a mock full-length
00:07 - real-world coding technical interview
00:09 - with Kylie Ying for a software
00:12 - engineering role learn how to use object
00:14 - oriented programming and dynamic
00:16 - programming to solve questions and get
00:19 - the job you want
00:21 - most people will probably agree that one
00:23 - of the worst Parts about finding a job
00:25 - as a software engineer is the technical
00:28 - interview during these programming
00:30 - related interviews the interviewer will
00:33 - expect you to work to a solution
00:35 - optimize it and write code or pseudocode
00:39 - on the spot the reasoning Behind these
00:40 - interviews is that they will help the
00:42 - interviewer understand your ability to
00:45 - understand the problem ask questions go
00:48 - deeper and optimize the solution how
00:51 - much do you understand data structures
00:53 - and algorithms and ultimately what is
00:57 - your coding level and what is your
00:59 - coding ability today I paired up with a
01:01 - good friend of mine Keith Galley who has
01:03 - a data science focused YouTube channel
01:05 - and he is going to be mock interviewing
01:08 - me so this interview might look like
01:10 - what a real software engineering
01:12 - interview looks like I don't know what
01:15 - question he's going to ask so it's going
01:16 - to be as much of a surprise to me as it
01:18 - is to you and I will be coating on the
01:22 - spot so
01:24 - here we go
01:29 - welcome
01:31 - to the interview how are you doing today
01:33 - I'm good how are you I'm doing pretty
01:36 - well
01:38 - um we're gonna probably just jump right
01:39 - into this interview I'm just curious are
01:41 - you familiar with coderpad because
01:43 - that's what we're going to be using
01:44 - throughout I think it might be easiest
01:45 - to kind of share code
01:47 - yeah
01:49 - cool all right so we're going to kind of
01:52 - just jump right into the the problem so
01:55 - for the purpose of this problem and let
01:57 - me share I just want to make sure you
01:59 - can access this coder link so I'm going
02:01 - to share this and I recommend maybe
02:04 - sharing your screen or I guess we also
02:07 - can just work off of this so I should be
02:09 - able to see here what you typed in
02:11 - I open the chat I can click on this link
02:14 - and it'll take me to the coder pad my
02:18 - name is Kylie and I will enter and so I
02:21 - can see that you're in this coder PAD as
02:24 - well and then here I am yeah and just to
02:27 - make sure that you're comfortable here
02:28 - you want to just run like a couple
02:30 - simple lines of code you can try just
02:32 - running this print hello world
02:34 - if you want yeah so if I run this
02:37 - it'll say that I ran a line of python it
02:40 - prints out hello world so
02:42 - I think it works perfect okay so let's
02:45 - uh kind of jump into the problem so just
02:48 - to give you some context we're going to
02:49 - start with about 20 minutes of design
02:53 - object-oriented design however you want
02:55 - to design this code and then we'll spend
02:56 - probably the last 20 minutes working on
02:59 - more of an algorithms question so that
03:01 - gives you just a little bit of a scope
03:03 - uh you don't necessarily have to
03:05 - accomplish everything you know I know
03:07 - that we have limited time
03:09 - but to kind of give you the context of
03:11 - the problem
03:13 - imagine that where
03:15 - designing a book system so an online
03:19 - Cloud reading application
03:22 - and you can pretty much imagine that
03:23 - we're building a product that is similar
03:26 - to an Amazon Kindle
03:29 - but specifically for short stories so
03:32 - we're kind of in our own Niche they
03:34 - might be Indie stories they might not be
03:36 - you know found anywhere else people
03:37 - could add their own stories
03:41 - um and basically what we want to do to
03:43 - start this problem off is that we need
03:45 - help designing the actual
03:47 - application we needed help designing the
03:50 - code that could Implement an online
03:52 - Cloud reading application and there's a
03:54 - couple things that we're looking for and
03:56 - this is very open-ended you can
03:58 - implement this how you want but a few
04:00 - things and I'll paste these into the
04:01 - coder pad that we're looking for
04:10 - I'll just paste it below
04:12 - um oh yeah okay
04:14 - you can fix this up
04:16 - and I'll delete that Top Line
04:19 - okay so a few things that you're looking
04:20 - for users have a library of books that
04:23 - they can add to or remove from users can
04:26 - set a book from their Library as active
04:30 - um the reading application remembers
04:32 - where a user left off in a given book
04:34 - and the reading application only
04:36 - displays a page of text at a time in the
04:39 - app in the active book
04:41 - exactly
04:43 - awesome
04:45 - um so
04:47 - so let's see
04:51 - essentially what we want to do is create
04:54 - a library where users can interact with
04:57 - this Library they can look at a book and
05:00 - set it as active and then
05:02 - this application will also just remember
05:04 - where they left off and display whatever
05:09 - page that they're currently looking at
05:11 - in the active book
05:13 - is that correct correct correct
05:16 - okay and then more specifically do you
05:19 - want me to kind of give like a high
05:21 - level implementation or
05:24 - um how do you want me to start this
05:26 - so I really want to just think about you
05:28 - know what components would be important
05:30 - this is I would say an object-oriented
05:32 - design question so I'm just thinking
05:34 - about how you would think about
05:36 - structuring uh I guess the base of a
05:39 - program like this so obviously we're not
05:41 - going to build this full application but
05:43 - I'm really curious about how you're
05:44 - structuring that kind of that core
05:46 - structure that core um
05:48 - Foundation
05:50 - right so let me make this uh smaller
05:54 - over on this end so people can see all
05:56 - this
05:57 - and let's type up some more notes so uh
06:01 - the things that jump out to me are that
06:04 - you need to be able to remember all
06:07 - books so if I type this
06:12 - we need to have all books in the library
06:13 - and we need to
06:16 - um remember active book and then we want
06:21 - to remember page
06:24 - uh
06:26 - remember page I guess last pages in all
06:29 - books
06:31 - and then
06:33 - we want to
06:35 - display
06:37 - a page in active book Okay so
06:43 - um by this all books in the library is
06:45 - that more so
06:48 - I guess how are we representing these
06:50 - books are we are they just like strings
06:52 - do they have a page number and then the
06:55 - string of text how is that formatted is
06:58 - it like HTML I think it's up to you how
07:00 - you want to
07:02 - um store the books within like this
07:04 - programming structure so you can kind of
07:06 - decide what makes sense
07:08 - for that
07:10 - I think the important things is the
07:12 - actual text of the book as well as the
07:14 - title of the book
07:16 - okay okay and and you can implement the
07:20 - uh the details of like the pages and all
07:22 - of that yeah
07:23 - yeah okay so I think that there's two
07:27 - things that jump out to me here right
07:29 - it's we need one class
07:33 - we want one class representing
07:36 - a book and then we want another class
07:39 - perhaps representing a library so a
07:42 - collection of books and so in this uh
07:45 - book specifically you just mentioned
07:47 - that we want the title as well as the
07:51 - like pages in the book yep
07:54 - or like I could rename that the content
07:56 - yep exactly um in the book and then for
07:59 - the library we have a collection of
08:02 - books and then I would also argue that
08:05 - this page uh or sorry that whatever the
08:09 - active book is would would be at the
08:11 - library level because
08:14 - um because we just want to toggle which
08:16 - one is active amongst this entire group
08:18 - right yeah and then actually so this
08:21 - last page in the book what I want I
08:24 - think I'm gonna put that under the book
08:26 - because it's book specific so I think it
08:28 - would make sense for every single book
08:31 - to just remember the last page so
08:34 - um
08:37 - user looked at
08:39 - okay so I like how this is represented
08:42 - and then I think uh kind of diving more
08:45 - so into the implementation I think for
08:47 - the title A String would make sense here
08:49 - because
08:51 - I mean a title is just a string yeah
08:54 - um the pages and the content in the book
08:56 - so the things here are the pages are
08:58 - ordered right when you go through a book
09:00 - They're ordered and there's a specific
09:02 - amount of content per page and so I
09:05 - think something that would make sense
09:06 - for this is just a list because I think
09:10 - a list is ordered it's a collection of
09:13 - items and
09:15 - um
09:16 - and we can't I mean I think like a set
09:19 - you would lose the ordering a dictionary
09:21 - you would lose the ordering and you
09:22 - would also over complicate things a
09:25 - little bit you could have the page
09:27 - numbers as the keys but then
09:29 - um but then a list would also do the
09:31 - same thing but kind of in a more elegant
09:33 - manner
09:34 - and then finally
09:37 - uh a tuple okay you could also have a
09:40 - tuple but
09:41 - um I don't think there's a reason to use
09:43 - like a tuple over a list in this
09:44 - specific example yep or like vice versa
09:47 - like I I think that you could choose
09:49 - from either one
09:51 - so I think here I'm just gonna use a
09:54 - list of
09:55 - um
09:57 - I guess strings
09:59 - which represent per page
10:02 - so like each string represents
10:05 - whatever's on an entire page
10:07 - and then the last page that the user
10:10 - looked at this would just be some
10:11 - integer and this would be an index into
10:13 - this list of strings so
10:15 - I would have to remember that this you
10:18 - know
10:20 - there might be an off by one error here
10:24 - um because in Python we start at zero
10:26 - but like naturally when we're reading a
10:28 - book we might start at one yep
10:30 - now for this library for this collection
10:33 - of books okay well so for this active
10:36 - book
10:37 - um I you could either use a Boolean
10:41 - where you set one book to active and the
10:43 - rest to inactive but I think that that
10:46 - would be kind of excessive because every
10:48 - single time we toggle a book as active
10:51 - we have to toggle everything else as
10:52 - inactive right
10:54 - you can't have two active books yeah
10:56 - yeah okay yeah that makes sense okay so
11:01 - then I think in that case instead what I
11:03 - would rather do is have some sort of
11:07 - um
11:09 - a string or some sort of like an ID
11:11 - matching system where we have like one
11:17 - um variable that's set to the active
11:19 - book and that might be the title or the
11:21 - ID of a certain book in the library so
11:24 - maybe maybe we can just add ID here
11:28 - um and maybe I can make that also a
11:31 - string or an integer or something yep
11:34 - and I'm going to add a question mark to
11:36 - kind of just say like maybe we could
11:38 - Implement that but I'm not sure if we'd
11:40 - want to right now
11:41 - um
11:42 - so this would correspond
11:46 - to ID
11:48 - so uh
11:52 - this would just be some variable
11:56 - and then this collection of books
11:59 - so
12:00 - I guess like when we display this page
12:05 - in an active book
12:07 - um
12:10 - I actually so I think that this week
12:13 - this might have an advantage being like
12:15 - some sort of a lookup table because we
12:18 - have
12:19 - a certain sense of an ID right and I
12:22 - think what could make sense here is
12:24 - having the ID correspond to the book
12:26 - object that we Define up here so yeah
12:30 - this could be a book object right and so
12:34 - um we don't really need this idea I
12:35 - think that if all the titles are unique
12:37 - then then we don't need this ID we can
12:40 - just we can just use the titles as the
12:43 - IDS uh but in some cases in the real
12:46 - world not all titles are unique and so
12:49 - that's what an ID might might come in
12:51 - handy
12:53 - um and so I'll leave that like
12:56 - what are our assumptions here can we
12:58 - assume that the titles are unique or
13:00 - should I be using this ID structure I
13:02 - think I like the ID structure because
13:04 - yeah we're not necessarily going to know
13:06 - that everything's unique so I think this
13:07 - is a little bit more robust
13:10 - okay awesome so I think
13:13 - um this representation looks good to me
13:15 - so I'm just going to go through uh the
13:18 - requirements again just to make sure
13:20 - that I've covered all my bases so here I
13:22 - want all books
13:23 - um
13:24 - okay so I want a library books that I
13:27 - can add to or remove from and so here I
13:29 - have a library and anytime I want to add
13:31 - to this Library I can just add an ID I
13:34 - can add the book If I want to remove
13:37 - um from the from the library then I can
13:40 - just simply delete the key item pair
13:43 - or the key whatever pair
13:46 - key value pair
13:48 - um I can set a book from their Library
13:51 - as active and so here I have this active
13:53 - book and we could always say like if
13:56 - there is no active book then we set this
13:58 - To None or something like that
14:01 - um the reading application remembers
14:02 - where a user left off so we have that
14:05 - here right the last page that the user
14:07 - looked at and not just in the active
14:09 - book
14:10 - and then
14:12 - um displaying one page of text at a time
14:14 - in the active book so we have the active
14:17 - book we can get the book object from
14:19 - that and then we can go to the page that
14:22 - the user last looked at by indexing this
14:26 - value into this list so I think we've
14:29 - covered all the bases here cool
14:32 - um let's do a couple things
14:35 - I guess I think as a starting point and
14:38 - this doesn't have to get too crazy but I
14:40 - would love to just see some you know
14:41 - python pseudocode or even some python
14:43 - kind of code just to like maybe flesh
14:45 - out one of these classes I just want to
14:46 - yeah uh you know look at that a little
14:48 - bit and how you would actually start
14:50 - writing this code
14:52 - yeah sure so so for example here I let's
14:56 - start with the book
14:58 - um and when we define a class let's
15:02 - initialize this
15:05 - so when we initialize a book we
15:08 - definitely should pass in the title and
15:11 - then
15:12 - um the content right I'm assuming that
15:14 - when we add a book these things have to
15:15 - be given to us and then
15:20 - I'm assuming that when we add a book we
15:22 - don't have a last page that the user has
15:24 - looked at is that an okay assumption
15:26 - yeah I like that assumption
15:27 - okay
15:29 - so we can set the title of this book
15:31 - just equal to whatever the title is
15:33 - uh the content of this book and I'm
15:37 - going to assume that these are given to
15:40 - us in the formatting that we want so the
15:42 - title is a string and the content is a
15:44 - list of strings that correspond to the
15:45 - pages
15:47 - um
15:47 - and I'm gonna create a variable last
15:49 - page and I'm going to set that equal to
15:52 - just zero
15:54 - I could also probably set it equal to
15:56 - negative one or something but I think
15:57 - zero makes sense because that would be
15:59 - the beginning right yep and
16:03 - um and then we need to come up with some
16:05 - sort of an ID so
16:08 - typically maybe we would have some sort
16:10 - of function that takes in the title and
16:13 - the content or maybe the author or
16:15 - something and like returns a unique ID
16:18 - um
16:18 - but I think maybe something that we can
16:22 - do here just very simply is uh have some
16:25 - sort of counter in the library and then
16:27 - every single time we like at add a new
16:31 - book we can just associate that counter
16:34 - with that book and so then we know that
16:35 - they're all unique and
16:38 - um
16:39 - and they all have their own IDs would
16:41 - that make sense yeah that that makes
16:43 - sense
16:44 - okay so then I would have to pass in the
16:46 - ID
16:48 - um
16:49 - yeah and so what I'm actually going to
16:52 - do is self.id equals ID
16:55 - uh and then
17:00 - yeah and so then uh for example we might
17:02 - want like a display page
17:05 - right in this book and so
17:08 - for that then we just want to return
17:13 - um whatever is at the last page of the
17:14 - content
17:18 - and I guess let's build on this a little
17:19 - bit another useful function you know
17:22 - obviously you want to start at the the
17:23 - last page but let's say we're starting
17:25 - to turn the page what might that look
17:27 - like
17:29 - right and so if we're turning the page
17:35 - then all we want to do is increment the
17:38 - last page right and so we might do
17:41 - self.last page
17:43 - and we just increment that by one
17:46 - um and then we could call display page
17:48 - after that
17:50 - uh if we assume that
17:54 - like we could if if we assume that these
17:57 - two go together so if we assume that
17:59 - when we turn the page we want to display
18:00 - that page then I would just return
18:02 - display page
18:05 - yep
18:06 - like that
18:08 - um
18:11 - and then actually I'm just going to go
18:13 - ahead and code up this Library as well
18:15 - so
18:20 - this Library we have this collection of
18:22 - books and then also the active book so
18:26 - rather than initializing a library with
18:29 - books I think let's just add them
18:32 - um to this so initially
18:37 - this collection might just be an empty
18:39 - dictionary and then
18:41 - the active book might be none right so
18:45 - then
18:46 - um when we
18:47 - want to add stuff so add to collection
18:55 - a book
19:00 - what I'm going to do so
19:04 - there's
19:05 - either the user could
19:08 - like or our API could like return a book
19:11 - with the uh with the title and the
19:14 - content
19:15 - Etc but since we're we said that we
19:18 - would pass the ID through like the
19:19 - library because we might have like a
19:21 - counter
19:23 - like some sort of ID counter I mean this
19:25 - is not the best way to do it but I think
19:27 - this is like a a fine hack for right now
19:30 - um
19:31 - just to make all the ideas unique what
19:34 - we can do here is
19:36 - um
19:37 - we can also when we want to add a book
19:40 - just pass in the title and the content
19:43 - and so then our new book
19:46 - is going to be a book as we've defined
19:49 - above with the ID
19:53 - and
19:55 - um the title and the count or the
19:57 - content
19:59 - and then after we create this new book
20:01 - we want to
20:03 - increment the ID counter
20:06 - uh and then we also want to add this new
20:08 - book Into The Collection right so I'm
20:10 - going to add self.collection
20:15 - um and
20:17 - I'm going to make the ID whatever the ID
20:21 - of the book is so actually I'm just
20:23 - going to call new book dot ID because I
20:25 - think that's a bit cleaner and this is
20:27 - going to be the new book
20:29 - and then we increment the counter by one
20:31 - so this is us adding to the collection
20:34 - um
20:36 - so of course we want to remove from the
20:39 - collection
20:40 - and so we want we said that we wanted to
20:42 - remove based on the ID so all we have to
20:45 - do is I think
20:49 - there's this
20:50 - delete in Python
20:53 - I'm not sure do you know keys
20:57 - okay
20:59 - is there a remove
21:02 - I think that there's I mean it should
21:04 - auto complete here in the coder pad oh
21:07 - isn't it Dell isn't there a Dell
21:11 - um
21:11 - I mean I think the biggest thing is is
21:13 - it going to be happening in place or is
21:15 - it going to be happening and creating a
21:17 - copy
21:18 - um I I understand yeah so we want it in
21:21 - place from The Collection I understand
21:22 - what you're trying to do so the exact
21:24 - details is is not super super important
21:27 - to me
21:28 - okay yeah so anyways this is removing
21:31 - from The Collection
21:33 - um and when we set active book
21:37 - again we want to do this based on the ID
21:39 - so I'm going to make self.active book
21:44 - equal to whatever that ID is
21:47 - uh and
21:52 - let's see so the user has a library of
21:55 - books they can add or remove from we did
21:57 - that sending a book as active Okay and
22:00 - then remembering where user left off so
22:03 - we've actually taken care of that
22:04 - already implicitly in our um book
22:07 - uh class and then the reading
22:09 - application only displays a page of text
22:11 - at a time all right so then here we can
22:14 - say Define display page
22:18 - and actually we don't even need the the
22:21 - ID of the book because we already have
22:23 - the active book ID right and so what I'm
22:26 - going to do is I'm going to go into my
22:28 - collection
22:30 - um and I'm gonna get the active book
22:34 - like this so
22:38 - yep
22:39 - blah blah and I'm going to click or I'm
22:42 - going to do dot display okay
22:48 - and then of course we also have this
22:49 - turn page that I could
22:52 - um
22:53 - to put up as well
22:58 - yep
23:00 - so you get the idea but
23:07 - so we wanted oops
23:09 - turn that page
23:11 - um I do think that some like drawbacks
23:14 - here are that
23:16 - uh okay so one thing that we could have
23:19 - done is instead of this active book
23:22 - instead of saving the ID we could have
23:24 - saved the book itself and I think from a
23:27 - pythonic standpoint that might make
23:28 - sense but then in the future if we're
23:30 - using some sort of database or something
23:31 - an ID would make more sense because
23:34 - that's easier to store in like a table
23:36 - um
23:37 - and
23:39 - if uh and okay also for this display
23:42 - page you might see that we've called
23:44 - this display page and turn page up here
23:47 - in the book and the reason why I did
23:50 - that rather than
23:52 - um rather than just call like
23:55 - self.book.content last page like book
23:57 - dot last page or something
23:59 - was because I think that like for
24:03 - example this should be independent of
24:05 - how we implement the book right so we
24:08 - want to keep those as kind of block like
24:11 - separate blocks as possible
24:14 - and so here what this allows me to do is
24:17 - when I go back to my book like if I
24:19 - decide to scrap this implementation
24:21 - Implement something else
24:22 - I know that I would just have to
24:24 - implement the methods display page and
24:26 - turn page for that to work
24:28 - um
24:29 - and like these functions should work
24:32 - this this looks good to me I like the
24:33 - start I think that this uh definitely
24:36 - lays out the foundation of what I was
24:38 - looking for with the requirements of
24:40 - this application so nice work with this
24:43 - couple quick follow-up questions before
24:45 - we kind of Branch into more of an
24:47 - algorithms uh
24:49 - type question as the follow-up here one
24:53 - question is you know let's say you have
24:55 - an older reader and their vision isn't
24:57 - as great so they need to make this the
25:00 - size of the font bigger so kind of
25:03 - keeping that in mind that you might have
25:04 - this variable font size how might you I
25:07 - guess refactor or change or modify your
25:10 - current structure and you don't have to
25:12 - actually write code here let's just
25:13 - discuss this to account for
25:17 - um that increase in size
25:20 - yeah
25:21 - yeah so I so when we increase something
25:25 - in size like I'm just thinking about
25:27 - intuitively on our like phone screens or
25:29 - something
25:30 - um that type that tends to shift the
25:31 - content right so like some page that
25:34 - might hold a hundred words or a hundred
25:37 - characters at you know
25:39 - um a small font size might only hold 50
25:42 - if when you double that font size
25:44 - so uh for the book instead of having
25:49 - this list what I might do is I might
25:52 - just save the entire book as a string
25:54 - and
25:56 - um and based so I would let me just edit
26:00 - this in here because I think it's easier
26:01 - to visualize what I'm saying but so I
26:04 - would might I might have like a font
26:06 - size equal to
26:09 - um
26:12 - I guess we could just use like the
26:13 - traditional like 12.5 or like yeah
26:15 - whatever uh but
26:18 - when we have this font size we could
26:20 - come up with some sort of
26:23 - um characters per page calculation
26:26 - right and so that would be based off the
26:28 - font size so calculate so this is going
26:31 - to be pseudocode now this calculate
26:33 - doesn't actually exist but calculate uh
26:36 - based on that font size
26:40 - um
26:41 - and I'm commenting it out so it doesn't
26:44 - have any errors but then uh when we do
26:47 - calculate that then what we can do in
26:49 - order to get our
26:52 - um in order to get this display page
26:54 - thing would be instead of indexing into
26:56 - this content which is now
26:58 - just a long string of characters
27:04 - what we can do here is we can return
27:09 - um we would have to do some sort of
27:10 - calculation right so we would need to we
27:13 - have this characters per page and we can
27:17 - multiply that by whatever the last page
27:21 - is
27:22 - and
27:25 - um so this would give us like kind of
27:26 - the starting index of this long string
27:28 - of characters to start uh
27:31 - the content of that page
27:34 - start index would be this
27:37 - and then what we would want to do
27:40 - is
27:41 - um
27:44 - what we want to do is then return the
27:47 - self doc content from that start index
27:50 - until the start index plus the number of
27:53 - characters on that page
27:57 - so that would be our end index so
27:58 - actually let me just write that out to
28:00 - make things a little bit more clear
28:07 - so now essentially what I've done is we
28:10 - have this variable font size which we
28:12 - can calculate characters per page
28:14 - depending on that font size so that
28:17 - might be more characters or less
28:18 - characters depending on how big the font
28:20 - size is and then our content instead of
28:23 - a list of strings is now just a really
28:25 - long string of characters and I guess
28:27 - some assumptions that I'm making here
28:29 - are that uh this would just be
28:31 - approximate so for example if we had a
28:35 - backslash n which is like a line break
28:37 - right that might just end up counting as
28:39 - a character or two characters but the
28:41 - assumption is that
28:43 - um
28:44 - that would be approximate per page or
28:46 - maybe that we're using sort of some sort
28:48 - of like mono spaced font or something
28:50 - like that
28:52 - um but essentially now that we have the
28:55 - characters per page and then just a long
28:56 - stream of characters that represents the
28:58 - content we can index into that content
29:01 - depending on like based on the last page
29:04 - that we know and so what's really cool
29:07 - here is that when we do Turn the Page uh
29:10 - we can just end up calling this so this
29:12 - is kind of that granularity that I was
29:13 - talking about yeah that that makes a lot
29:16 - of sense to me and definitely you see
29:17 - the advantage of having that function
29:20 - that you can change by having to
29:22 - implement something different uh one
29:24 - last quick I guess follow-up and then
29:26 - we'll we'll move on to the algorithms
29:27 - portion of this interview
29:30 - um I'm just trying to think you know at
29:32 - a high level let's say that we wanted we
29:34 - had multiple users in this system and
29:36 - they all
29:37 - shared books so like you know they might
29:40 - all share the Harry Potter books or
29:42 - something like that like books are
29:43 - common among all of them how might you
29:45 - modify this yeah uh given that you know
29:48 - some of these qualities of a book might
29:50 - be shared between users because they're
29:51 - all trying to access that same book
29:54 - does that make sense
29:56 - yeah so
29:58 - um yeah yeah for sure so I I think that
30:00 - when we start to you know have like
30:03 - multiple people
30:05 - um involved like this this these books
30:08 - might get stored somewhere for example
30:10 - in like a sequel table right and so then
30:13 - when that happens we would still want to
30:16 - maybe store like the ID the title the
30:18 - content in that table now the only
30:20 - changes would be that the these sort of
30:23 - customizations are
30:26 - um are per user but the book and the
30:29 - content those are for this entire group
30:32 - of people and what we can do I think is
30:36 - um
30:37 - is
30:38 - instead of this ID counter being like
30:41 - Library specific we can start
30:43 - identifying books by their IDs on a more
30:47 - like uh global scale right and so you
30:51 - know this was kind of just a hack to
30:53 - make this ID thing work and be
30:55 - independent and be like unique but for
30:58 - example when you put something into a
30:59 - SQL table you can also have an ID
31:01 - associated with those entries and so
31:03 - maybe when we add to the collection if
31:05 - we see that the title and the content is
31:07 - already in the table then we instead
31:10 - just return the book that's already in
31:12 - that table or something like that yeah
31:14 - okay I think that makes sense to me uh
31:17 - cool I I'm yeah happy with this
31:19 - discussion I think that we can move on
31:20 - to the second portion I guess do you
31:22 - have any I guess last questions on this
31:24 - before I move on or last things you want
31:26 - to say
31:30 - um
31:31 - yeah so no last questions I think that
31:33 - the last thing I want to say is also
31:34 - like it would really depend on like how
31:36 - you implement this like group of people
31:38 - right like so my immediate thought was
31:41 - like a SQL table but that doesn't have
31:44 - to be the only way
31:46 - um
31:47 - so yeah I think
31:52 - okay cool I think it would depend on
31:53 - that
31:54 - um all right awesome uh let's yeah
31:56 - switch gears and
31:58 - I'm probably going to just comment this
32:00 - out in case you do want to run some code
32:03 - and there's any errors or issues in this
32:04 - so I'm just going to comment this out
32:06 - but I'm going to leave it here just so
32:07 - we have it
32:08 - to look back at and I'm going to just
32:11 - indent this a bunch and we're going to
32:13 - just start at the top of the screen
32:15 - so don't mind all the stuff at the
32:17 - bottom all right so another important
32:20 - component of our book reading system
32:23 - and this is completely independent you
32:24 - don't have to reference any of your past
32:26 - code is
32:29 - I mentioned this is for short stories
32:31 - and you could have independent Indie
32:34 - authors you know adding these short
32:35 - stories so they're not going to be you
32:37 - know the classics not going to be those
32:38 - types of titles they're probably smaller
32:40 - authors so one thing that we want to
32:42 - avoid in this system is plagiarism
32:46 - so my task for you is to design an
32:48 - algorithm that would be able to detect
32:52 - the two most likely books that would
32:54 - have plagiarism in them
32:56 - it's like that the the two most likely
32:58 - books that pop up as a match for
33:01 - potential plagiarism uh in this in a
33:04 - library
33:05 - and we can Define as we can Define most
33:09 - likely as meaning they have the longest
33:13 - shared common section of text
33:16 - so we're looking we have a library of
33:18 - books and we're looking for the two that
33:20 - have the longest shared common section
33:23 - of text and we specifically might want
33:25 - to know how many characters that
33:27 - section of text is so you can imagine if
33:31 - it's sharing a single word obviously not
33:32 - an issue but if it's sharing six
33:35 - paragraphs that's going to be a problem
33:36 - so does that make sense
33:39 - right so just to clarify some things
33:41 - what Keith really means here by
33:43 - substring is that for example if I have
33:45 - a string such as learn
33:52 - what are substrings of this well one
33:55 - possible substring is learn
34:01 - another possible is earn
34:04 - because these are strings that are using
34:06 - characters that belong to this string
34:09 - learning
34:11 - another possible one is earning
34:15 - oops
34:18 - now you might say Okay Kylie all of
34:21 - these are consecutive in terms of the
34:24 - characters so here all of these
34:26 - correspond as characters that are next
34:29 - to each other but in this specific
34:31 - example Keith is not actually asking
34:33 - okay it has to be a consecutive
34:35 - substring instead what Keith is asking
34:37 - is just any substring which means that
34:39 - as long as the letters are in the
34:42 - correct sequence you can skip characters
34:44 - if you want to so for example here
34:49 - leg would actually also be a substring
34:53 - or
34:55 - an so for example right here we have
34:58 - earn as a substring of consecutive
34:59 - characters but down here
35:02 - I could rewrite it as a substring where
35:06 - there's actually a gap of two characters
35:08 - in the middle but this would still be a
35:10 - valid substring so it doesn't have to be
35:13 - consecutive we just need all the
35:15 - characters to be in order from left to
35:19 - right
35:20 - let's see let's start off with kind of a
35:22 - naive solution
35:24 - for that
35:26 - um
35:27 - well
35:28 - one thing that you could do is literally
35:31 - come up with every single
35:34 - combination of like substrings for both
35:39 - of these
35:40 - uh and then compare those and see which
35:42 - two substrings are the longest right
35:47 - um
35:49 - but there's a lot of different
35:50 - combinations for substrings and so I
35:53 - think that we should come up with a more
35:55 - elegant solution
35:57 - um
35:59 - let's see so
36:03 - one thing
36:04 - that I'm thinking is we should have
36:07 - pointers that start at the beginning of
36:09 - both yep strings and kind of move along
36:15 - until one of them detects
36:18 - a shared character
36:21 - so
36:23 - or like when until one of them takes
36:25 - like the first shared character so here
36:27 - actually like I would say the first
36:28 - shared character is H right
36:32 - um and so here we would have like
36:36 - like the two pointers kind of be
36:41 - this uh
36:45 - maybe I'll go from the bottom
36:49 - but here and
36:52 - here
36:53 - right and so we look at the next
36:56 - character
36:58 - and we realize okay they're not the same
36:59 - so then we want to keep going
37:02 - um but one
37:05 - downside of this is that
37:07 - well okay what if I want to start
37:09 - comparing from here and here
37:12 - right
37:13 - okay and then I move it over and like
37:15 - these two have like two shared
37:17 - characters so I think that there's still
37:19 - this question of there's a lot of
37:20 - different combinations here
37:23 - um
37:26 - so
37:31 - I think you're on the right track though
37:32 - I like I like this and then okay so far
37:34 - yeah
37:37 - okay
37:39 - um yeah so I know that here I want kind
37:43 - of these pointers that are moving and
37:44 - then I just want to be able to align
37:46 - them right I think that's the that's the
37:48 - key here is this alignment
37:51 - and so now I think we just have to
37:53 - figure out how to make that alignment
37:55 - work
37:57 - um
37:58 - I'm kind of thinking like
38:01 - like one thing that
38:03 - we could do is kind of have more of a
38:08 - base sentence and then one where when we
38:13 - have
38:14 - like
38:16 - so for example if I
38:20 - if I made this my base
38:23 - sentence
38:25 - then in the other sentence I would want
38:28 - to search this sentence uh
38:31 - for each character so
38:34 - if I have the I here then like my first
38:36 - I would start looking from here and then
38:40 - maybe I would start to look from here
38:43 - right but I think that that
38:48 - would end up
38:50 - also being kind of long because for
38:52 - every single character in here you would
38:54 - have to iterate through this entire
38:55 - thing and do the whole matching process
38:58 - um
39:00 - and so I'm
39:03 - does that make sense why that's like
39:05 - maybe not the most optimal yeah that
39:07 - makes sense
39:08 - and I guess what would be the runtime of
39:11 - that
39:12 - uh it would be o of N squared because
39:14 - well I guess if we have one sentence o
39:17 - of N and one sentence o of M it would be
39:19 - o of n m because for every single
39:22 - character we'd have to run through the
39:23 - other string
39:26 - um M times and actually
39:28 - okay so like if my base sentence is like
39:31 - like what is the worst thing that can
39:33 - happen is like a base sentence like this
39:36 - right and then you're searching the
39:40 - worst case example would be like
39:42 - something like this right
39:45 - where like if I have an i okay well I
39:47 - have to go through each of these
39:49 - and
39:52 - so yeah I guess we would have to go
39:54 - through until like they don't match
39:55 - anymore but then that would just be the
39:58 - very end of this
40:01 - so like maybe I can add like an a at the
40:03 - end of that
40:04 - so then I would actually okay so that I
40:07 - would say it would
40:10 - it might be o of N squared M where n is
40:15 - e yeah I think that makes sense to me I
40:17 - think that we should come up with a
40:19 - different solution I'm trying to think
40:21 - of how dynamic programming word work
40:23 - because I do think that this this might
40:26 - be a dynamic programming problem
40:30 - um
40:31 - I'm not sure
40:33 - of how to formulate it yes let's um I
40:37 - think that you're on to something here
40:39 - I think
40:42 - I'm trying to think of a good ways to
40:44 - kind of kick you off here
40:46 - um
40:47 - I mean I would say let's just lay out
40:49 - let's assume that this is dynamic
40:51 - programming uh I think as a good
40:54 - starting point maybe we
40:57 - can talk about sub problems here
40:59 - and try to Define that and maybe that
41:01 - will help us get to our solution or also
41:03 - maybe just to find a base case and maybe
41:05 - that will help us get to the solution so
41:06 - I think
41:08 - let's assume that dynamic programming
41:09 - can be used here let's maybe just start
41:11 - trying to figure out sub problems and
41:13 - maybe a base case
41:16 - yeah
41:17 - yeah so I definitely think that the base
41:20 - case would be pretty simple and it would
41:22 - just be if there is a match right
41:24 - between the two like if the two
41:26 - sentences equal another that would be or
41:28 - okay let's think about all the possible
41:30 - base cases so
41:32 - it'd be if there's a match
41:34 - um or maybe we've iterated through
41:36 - everything that we can and we're
41:40 - comparing like an empty string to
41:43 - non-empty or even empty to empty which
41:45 - is when we would know that we're at the
41:47 - very end right
41:49 - yeah so for example with this match I
41:52 - mean by like
41:54 - um read to read like that would be an
41:58 - exact match
42:00 - so I I think the difficulty of this
42:02 - problem is that
42:05 - is that we can start anywhere in the
42:07 - texts right
42:09 - and
42:13 - I guess if we were trying to recurse
42:15 - through this
42:17 - um
42:23 - or if we if we were trying to go through
42:25 - this with dynamic programming
42:28 - what I would kind of want to do is
42:32 - say
42:33 - okay either like
42:39 - like s is the start of some substring in
42:42 - this sentence or it's not
42:45 - right and if it's not then we want to
42:46 - move over and we want to say okay well
42:48 - then is like H is
42:51 - um
42:52 - a substring or the start of a substring
42:55 - from this other sentence or it's not
42:58 - and we want to kind of continue that
43:00 - process
43:02 - um and so if for example H is a
43:05 - substring then we would want to figure
43:08 - out what the longest
43:10 - substring
43:12 - longest matching one is and then that
43:14 - would essentially like skip us over a
43:16 - few yep a few uh blocks
43:20 - and so I think another way to kind of
43:23 - formulate this might actually be
43:27 - like how many
43:31 - how many characters can kind of almost
43:33 - subtract
43:35 - from the two
43:38 - um
43:40 - and I might uh I might jump in here just
43:43 - I think you're on the right track but I
43:45 - might provide a little bit maybe more of
43:47 - a launching point just because I want to
43:48 - be considerate of our our time here
43:51 - um I think you're on the right track
43:53 - I think that let's maybe try to Define
43:56 - this like with a single line expression
43:59 - like a single line recurrence type
44:01 - expression
44:04 - um because I think that if we can build
44:06 - up to a you know build up sub problems
44:08 - to that final state that will help us
44:11 - so
44:12 - let's say we have sections of text a
44:16 - and I'll put this in uh CR with a is one
44:19 - of our sections of text
44:22 - and b is another one of our sections of
44:25 - text
44:27 - um
44:28 - and basically that could be
44:31 - uh hello world or something you know in
44:34 - world
44:36 - uh
44:38 - just world or something like that
44:40 - um we can assume that yeah basically
44:44 - what we could start doing here is we can
44:46 - imagine that we wanted to find the
44:49 - longest match between a and b
44:52 - and you could Define that as from
44:55 - character index 0 to character index
44:59 - 0 here so like the longest common
45:03 - subsequence here or substring of a b 0 0
45:09 - would be our
45:12 - kind of goal State because we would want
45:14 - to find if we're working backwards let's
45:17 - say we want to find all the way
45:19 - to the beginning
45:22 - but to help us get there
45:24 - you know we could probably see if uh you
45:27 - know what is the longest substring at
45:30 - different indexes so if you know maybe
45:32 - index three
45:33 - index five so like this would be the I
45:36 - guess last character five would be like
45:38 - the last character of B
45:39 - and I I guess keeping this in mind can
45:42 - we Define this in such a way where we
45:43 - maybe we can uh define an equation that
45:46 - would help us work up to that final goal
45:49 - which would be the entire
45:52 - sequence
45:55 - okay so if we're using kind of these a b
45:58 - strings as example
46:00 - um
46:02 - let's define some like
46:05 - like find
46:07 - uh largest
46:10 - substring or something
46:13 - um
46:13 - and we might have string a string B
46:19 - right so
46:21 - and you're saying okay let's do index a
46:24 - and index b as well and start those off
46:27 - with zero that would be our recurrence
46:29 - relation and so
46:31 - I guess what we'd want to do is find the
46:34 - longest substring between
46:37 - yep these
46:40 - um and we want to increment yep one or
46:44 - the other
46:47 - yep
46:49 - right
46:51 - so like that
46:54 - uh
46:57 - or
47:01 - or if
47:03 - string a equals string B then what we'd
47:07 - want to do is find the longest substring
47:13 - um
47:15 - um
47:17 - we want to increment both of these
47:19 - indices apparently oops sorry so I meant
47:21 - string a at
47:23 - index a and string B at index B like
47:28 - this so then we'd want to increment both
47:30 - of the indices and we want to add one
47:35 - right because this means that we've
47:38 - found a starting match
47:43 - um
47:45 - and what we'd want to do is actually
47:47 - take the so here
47:52 - um
47:54 - and if you want to just write pseudocode
47:55 - here it's fine too for me possibility
47:59 - okay that makes sense to me
48:04 - yeah so let's just do all these
48:06 - possibilities and so then if the two
48:08 - then we have this like third possibility
48:11 - right
48:12 - and what I would want to do is uh take
48:16 - kind of the minimum
48:17 - why is this giving me an error
48:20 - oh so then I would want I would want to
48:23 - return the max of
48:26 - possibility one possibility two okay
48:29 - let's write pseudo code
48:33 - possibility one possibility to and then
48:35 - possibility three only if it makes sense
48:38 - to me if applicable
48:43 - and
48:45 - and then with our base case we said that
48:48 - it would be if one of them is at the end
48:50 - so let me add that in here
48:53 - so maybe like if uh idx a is equal to
48:57 - the length of string a then we want to
49:01 - return zero
49:03 - or or here or idxb is equal to the
49:07 - length of string B
49:11 - um
49:12 - yeah so then for our longest substring
49:15 - this makes sense now because
49:17 - with each index we have the possibility
49:20 - of Shifting it over one and trying to
49:23 - compare this sentence with this entire
49:26 - one
49:27 - uh or
49:31 - Shifting the other one over one
49:33 - comparing those two
49:36 - yep indices or those two substrings
49:39 - from there on
49:41 - or if they are a match then we also have
49:43 - the third option of moving both of them
49:45 - over so actually I should go from here
49:48 - and then because uh this fine longest
49:52 - substring repeats all that on the next
49:55 - character for those two then we repeat
49:57 - that process again and we add one every
49:59 - single time to that
50:02 - um
50:04 - so I think logically this makes sense
50:07 - now
50:09 - one thing might also be that we start to
50:11 - kind of uh recurse a lot on the same
50:15 - indices right because we're trying all
50:17 - these different combinations and if we
50:18 - move them both over by one then
50:21 - um
50:22 - then we kind of are iterating overthrew
50:25 - them a lot
50:27 - so I think that one thing that we could
50:28 - also do is Implement some sort of
50:30 - memoization
50:33 - so here
50:36 - like maybe
50:38 - hold on I lost the oh here we go okay so
50:43 - then
50:44 - like
50:48 - if I
50:52 - so if
50:53 - the memorization is is none then we
50:58 - might want to start this with some sort
51:00 - of
51:02 - uh it could be addiction I think that
51:04 - also what could make sense is like a
51:07 - list of lists
51:09 - right
51:11 - so like maybe negative one because
51:12 - there's no such thing as a negative
51:15 - one-length substring
51:17 - um
51:18 - and I'm gonna multiply that by the
51:20 - length of like string a for example yep
51:23 - and then this whole thing by the length
51:25 - of string B
51:27 - and so essentially I have this table of
51:29 - [Music]
51:33 - of
51:35 - yeah
51:38 - I always get confused with the direction
51:40 - of these things but I understand the
51:42 - goal of this length string a and length
51:44 - string they basically create a table
51:45 - that stores some of these values
51:48 - yeah
51:49 - exactly yeah yeah and then in order to
51:52 - store that here then we would want to
51:55 - create like the index a
51:58 - index B I might be these might be
52:01 - backwards but we would want to store
52:03 - that essentially and so
52:06 - um then we'd want to add a case of like
52:09 - if
52:10 - uh
52:14 - if like this memo yeah
52:17 - at index a index B these might be
52:22 - backwards again if that's negative one
52:24 - then we want to return or sorry if
52:28 - that's not negative one then that means
52:30 - that we've already found the answer so
52:32 - then we just want to return whatever
52:35 - memorize there
52:40 - um and so at the very end we'd want to
52:43 - just return memo
52:47 - like that and
52:49 - let me just think about these indices
52:51 - quickly so uh the first one is string B
52:56 - so actually if I just swap these two
52:57 - that should make it work
53:00 - uh because first we'd index in 2A and
53:02 - then we'd index into B yep so yeah yeah
53:05 - if I just swap those two that would work
53:06 - cool um uh yeah this makes sense to me I
53:09 - guess my last question I think that this
53:11 - is the approach that I was uh uh kind of
53:14 - thinking about as far as dynamic
53:15 - programming goes my last question is
53:17 - what would be the run time of this
53:21 - um you know memoized uh dynamic
53:23 - programming solution
53:30 - um
53:31 - okay so here we are going through all of
53:35 - index a or all all string a and all of
53:38 - string B right by incrementing these
53:40 - indices until we hit a base case
53:43 - so
53:46 - so there's no way to avoid going through
53:50 - both of them
53:53 - um and and incrementing one but not the
53:56 - other and so we essentially have to fill
53:57 - out this entire memoization table in
53:59 - order to figure out our answer right yep
54:01 - which means that it would be a benefit
54:03 - and then my last question I know we're
54:04 - running right up on time is I guess
54:08 - given the context of the original
54:09 - problem was you might have a library of
54:11 - books how would you leverage this find
54:13 - commas longest substring to I guess find
54:17 - the two most uh like the highest
54:19 - probability matches in the entire uh
54:22 - library of books
54:28 - um I think that so here now that we have
54:31 - this find the longest substring with
54:33 - string a string B and we have all we
54:36 - have so we let's suppose that we changed
54:38 - uh
54:39 - the implementation of this book to be
54:42 - this like long string of characters for
54:44 - the content then that means that what we
54:48 - can do for this fine longest substring
54:49 - is just pass in like
54:51 - book a DOT content and book b dot
54:54 - content and figure out the longest
54:56 - substring between the two of them and we
54:58 - can do that for all the combinations of
55:00 - books
55:01 - um unique combinations of books and
55:04 - if we find for example
55:07 - okay well so the prompt is to detect the
55:09 - two most likely books that have
55:11 - plagiarism so we would just return the
55:13 - two books with the longest substring
55:15 - but you know maybe we want to say like
55:19 - any any books where more than 30 of the
55:24 - care you know more than 30 of the book
55:26 - is uh or maybe even like ten percent
55:30 - um shares the same substrate and like we
55:32 - might call that majorism uh that's all I
55:35 - have thank you uh
55:37 - for your time I guess quickly if you
55:39 - have any questions I guess for me or any
55:41 - questions about these prompts before I
55:43 - uh head off
55:46 - okay so note to the audience that in a
55:50 - normal interview this would be a time
55:53 - when I would dive deeper and ask
55:54 - questions about
55:56 - um you know Keith's work or what you
56:00 - know he enjoys about the company
56:02 - um and if I
56:04 - you'll find something in one of his
56:06 - answers that I'm really interested in
56:07 - I'll dive into that a little bit more
56:10 - but because this is just a fake
56:12 - interview and I don't really have any
56:14 - questions about Keith's company because
56:15 - the company doesn't exist
56:18 - um yep that makes sense to me and I I
56:19 - did not give you any context really to
56:21 - work with here so we don't have to
56:23 - repeat what we did with uh the video
56:25 - that posted on my channel but cool
56:27 - that's where we can interview uh switch
56:31 - gears
56:32 - yeah all right so now let's switch over
56:34 - to the feedback section uh session
56:37 - um do you want to go through your notes
56:38 - and kind of just share what was good
56:41 - yeah it was bad your overall impression
56:43 - I think this was an interesting session
56:44 - because
56:45 - I like wanted to squeeze as much as
56:47 - possible into this like oftentimes you
56:49 - might see like a smaller fully
56:51 - object-oriented design or a smaller uh
56:54 - only algorithms but I kind of wanted to
56:56 - get both because ultimately from my
56:58 - perspective as an interviewer like I
57:00 - feel like having both Concepts is how I
57:02 - actually evaluate your programming
57:04 - skills because a single algorithm
57:06 - doesn't tell me that much as far as
57:09 - um your your actual talents and like if
57:12 - you'd be a productive member of our team
57:13 - and also the object-oriented design
57:15 - might not say everything either so I
57:17 - like the combination but it was a bit
57:19 - like it is a lot of information so
57:22 - feedback wise let's start with object
57:23 - oriented design I think solid overall I
57:28 - think that you hit like the key points
57:30 - um
57:31 - I think some of the things that I I'm
57:33 - thinking about with regards to your
57:35 - solution is
57:38 - you hit all of like the key things that
57:40 - I was looking for so like all books in
57:42 - library remember active book remember
57:44 - last page in all books display a page in
57:46 - action book I think you did a good job
57:48 - with like the basic class structure to
57:50 - capture all of that I think what I would
57:52 - have liked to see if I was to be like
57:54 - nitpicky and and looking for even better
57:57 - Solutions is I might look for even
57:59 - further breakdown of classes so like I
58:03 - think
58:04 - um there was some things that could have
58:06 - been broken down further where I think
58:08 - maybe you could have a display class
58:09 - even that could kind of separate the the
58:13 - details like you have the book class
58:15 - that has the title the content but then
58:17 - the display class can handle like the
58:19 - font sizes the characters per page all
58:21 - that and just isolate that functionality
58:25 - um yeah so that was like one thing that
58:27 - I picked up on is just I think that it's
58:29 - tricky in an interview setting but I
58:31 - think that to isolate different
58:33 - components and make it easier to fit all
58:35 - together I think further breakdown of
58:37 - these classes could have been beneficial
58:40 - um and then my other kind of like
58:42 - nitpicky comment in criticism would be
58:44 - like I think
58:46 - the the way that the IDS were structured
58:49 - wasn't
58:51 - um
58:53 - necessarily like the the most easy to
58:56 - understand
58:57 - uh so I guess providing some more
58:59 - details on
59:01 - I guess adding robustness to these IDs I
59:04 - think like one thing that would have
59:05 - been interesting I guess it didn't ask
59:07 - about this specifically but
59:10 - um
59:12 - the concept of like okay how could you
59:14 - then maybe if you only had a title in
59:16 - the the book contents how could you
59:19 - maybe grab that ID retroactively or like
59:22 - would you want to do that so like maybe
59:24 - some more robustness in how the IDS were
59:26 - set up
59:27 - so that
59:28 - uh you didn't have to have know the
59:30 - system to necessarily get an ID
59:33 - um does that make sense
59:39 - yeah yeah for sure I definitely think
59:41 - that the ID part was
59:43 - one thing where it was yeah
59:46 - like I would have rather just used the
59:48 - title of the book or like some
59:49 - combination of like the title and author
59:51 - and I think like for example
59:54 - um
59:55 - at like an actual Library they have like
59:57 - their code or whatever and they have
59:59 - their system for you know if it's
60:01 - fiction or whatever genre it is and then
60:03 - like uh some combination of I think
60:06 - author that
60:08 - I don't really remember
60:10 - um that they use to ID books and I think
60:12 - that that probably would have been like
60:14 - a better solution is if we had like the
60:16 - title and author and yeah it is tricky
60:18 - because you don't have access to that
60:19 - nice Library I think the key thing that
60:21 - you did well with the IDS is that you
60:23 - knew that had to be unique you didn't
60:25 - want to have collisions and by
60:27 - mentioning like titles might have
60:29 - collisions that's super important
60:30 - because that would cause all sorts of
60:32 - headaches for us
60:34 - um let me see what else I wrote down I
60:38 - mean again like I'll reiterate like this
60:39 - was a good solution this was a solid
60:41 - solution this would be like something
60:42 - I'm looking for so like my feedback is
60:45 - more nitpicky and like how could things
60:46 - be improved further I think another way
60:49 - and this is kind of similar to breaking
60:50 - things out from you know a book class
60:54 - and then a display class to actually put
60:56 - that onto our Kindle Cloud Reader but I
60:59 - think another way you could have maybe
61:00 - broke this down in a logical manner was
61:02 - when I asked that last follow-up
61:03 - question which was basically
61:05 - you know you might have many users in
61:07 - this and now we need to be able to each
61:11 - user needs to have their own like last
61:13 - page for each book and all that
61:15 - I think that your answer could have been
61:16 - a bit more
61:19 - nuanced there
61:21 - I think one thing that you could have
61:23 - maybe mentioned is
61:25 - we could have potentially used like
61:26 - super classic subclassing to maybe have
61:28 - like you know a base book class but
61:31 - maybe there was like a user book class
61:32 - that built off of
61:34 - that class book that you know everyone
61:36 - shared ID everyone shared title everyone
61:38 - shared content but all those user
61:40 - specific things could have reused some
61:42 - of that previous code but built off of
61:44 - it so that would have been an
61:45 - interesting idea too
61:48 - yeah yeah
61:50 - that's all I have for the yeah object
61:53 - oriented
61:55 - um portion uh any I guess other comments
61:58 - on that section
62:03 - cool and then I think for algorithm
62:05 - solution
62:07 - um I think throughout the interview you
62:09 - did a good job of explaining your
62:11 - thoughts super super important to anyone
62:13 - listening to this uh don't just write
62:15 - something down
62:16 - talk through what you're writing down as
62:19 - you're writing it that helps me make
62:21 - sure that I know what you're talking
62:23 - about that makes sure that I know that
62:25 - you're on the right track or off track
62:26 - so you did a good job both in the
62:28 - object-oriented design as well as the
62:31 - algorithm just explaining what you are
62:33 - thinking and the pros and cons so like
62:36 - one thing I liked in the algorithm
62:37 - section is
62:39 - you know coming up with a very naive
62:41 - solution to start I like seeing that
62:44 - kind of iterative approach see that
62:46 - you're kind of working towards more
62:47 - Optimal Solutions so I liked the idea of
62:50 - using like every single substring and
62:51 - these two but then realizing this is not
62:53 - optimal I liked then you're kind of
62:57 - building and taking that and being like
62:58 - okay maybe that's not the best approach
63:00 - but let's take a base sentence and a you
63:02 - know a new sentence
63:03 - and
63:05 - uh you know start going character by
63:08 - character in the base sentence and
63:09 - compare it to the you know comparison
63:11 - sentence I think that that was you know
63:13 - a you know you're working towards a
63:15 - better solution it's going to be better
63:16 - than that every substring approach but
63:19 - still not quite optimal and kind of
63:20 - realizing that there was more
63:22 - improvements that could be made there
63:24 - was a challenge in how to get to the
63:26 - dynamic programming solution I think we
63:27 - maybe lost some of those details you
63:29 - would normally have included on like the
63:31 - Nuance of this and how you might
63:33 - improve it so like I would have also
63:35 - liked to hear mention not only of herb
63:37 - tense but also like punctuation if we
63:39 - have to you know keep that in mind so if
63:41 - someone changed periods exclamation
63:42 - points should those still match or
63:44 - should they not match
63:46 - all of that
63:48 - um and then just kind of getting to the
63:50 - dynamic programming uh I think this was
63:53 - definitely like a challenge trying to
63:54 - figure out how to formulate this so I
63:56 - definitely had to help a bit more I
63:58 - think in an optimal like perfect run
64:00 - through uh you would have had
64:02 - you've gotten a little bit further
64:04 - without me having to prod but I think
64:06 - the nature of dynamic programming is
64:08 - unless you're reviewing it and like
64:09 - really like studying it and staying on
64:11 - top of it like in the real world you
64:13 - don't have to know this type of stuff uh
64:16 - you're not coming up and like designing
64:18 - from scratch dynamic programming you're
64:20 - usually looking at notes and all that so
64:22 - like I was you know I'm okay in an
64:23 - interview setting having to prod a bit
64:25 - uh but you know that's I guess the
64:27 - difference between a good interview and
64:29 - a perfect interview is like the nature
64:31 - is I had to provide a decent amount of
64:33 - details and kind of help you get to a
64:34 - recurrence and then once I gave you that
64:37 - starting point the launching point of
64:39 - the recurrence uh you did a great job
64:41 - running with it that was definitely like
64:42 - the optimal longest common subsequence
64:45 - or substring type solution with
64:48 - recursion and memoization to help get us
64:52 - to the optimal so it was nice to see
64:54 - that once you had an idea of what we
64:56 - needed to do
64:57 - that your Rams will run with it and knew
64:58 - exactly you know where you could
65:00 - Implement an optimal solution
65:03 - I think that's all I have I'm rambling
65:05 - on a bit but hopefully those notes make
65:08 - sense and I think we can further discuss
65:12 - yeah I definitely think think that this
65:14 - longest substring was a slightly more
65:17 - challenging problem based on like
65:20 - um you know the problems I've done on
65:22 - the code or like the ones that I faced
65:24 - in like actual coding interviews
65:26 - um but that's not to say that it's not
65:28 - like
65:29 - a good problem right I think it's a
65:31 - really good problem to ask and to kind
65:33 - of figure out
65:35 - um you know what are my strengths and
65:37 - weaknesses and I think that one thing
65:40 - that
65:42 - you know you've probably learned from
65:43 - this is that okay you know maybe I have
65:46 - certain ideas that are there and I like
65:48 - needed a little push in trying to
65:50 - formulate it properly but then once you
65:54 - gave me just like a structure to
65:56 - formulate it then I was able to take
65:58 - that and be able to uh run with it right
66:02 - which I think that
66:04 - you know from an interviewer's
66:05 - standpoint like when you're interviewing
66:08 - it's not just about can they do it or
66:11 - not it's also about how would they you
66:12 - know how would what would an interaction
66:14 - with this person look like right and so
66:17 - actually one thing that I really liked
66:18 - about this was that it it seemed to be
66:20 - pretty collaborative and it seemed to be
66:22 - very casual rather than like me taking a
66:25 - test
66:27 - um and so
66:29 - you know what that tells me as somebody
66:32 - interviewing is oh yeah like if I do get
66:35 - stuck like this person would be able to
66:37 - give me a hint and then I would be able
66:39 - to take that hint and do the rest of the
66:42 - problem
66:44 - um
66:45 - so yeah I mean I do wish that I was able
66:47 - to just get that in formulated but I
66:50 - think that also dynamic programming is
66:52 - typically tricky like that and it takes
66:54 - a lot of it just takes practice kind of
66:57 - to yeah and I think that you make a good
66:59 - point where it's like this was
67:01 - definitely the dynamic programming
67:03 - question was a hard question uh and I
67:07 - think sometimes once you feel like
67:09 - you're off track and an interviewer like
67:11 - oh shoot I don't know the answer to this
67:12 - like I'm screwed I think realize that
67:14 - you might be purposely given a hard
67:16 - question because then you can identify a
67:19 - larger range of candidates so like you
67:21 - know maybe the tippy top is like it's
67:24 - it's instinctual for them to like
67:25 - realize how to solve this with dynamic
67:28 - programming but I'd say like the strong
67:30 - half of this they won't know it right
67:33 - away but they'll be able to work
67:34 - themselves to it so like don't get too
67:37 - flustered this is not to you this is to
67:39 - a general comment to anyone listening
67:41 - don't get too flustered by like getting
67:43 - stuck you're oftentimes expected to get
67:45 - stuck uh you're human so you're going to
67:49 - get stuck it's how you rebound it and I
67:51 - think you did a good job mentioning you
67:52 - know you rebounded well and and that's
67:55 - what's important still like a very
67:57 - strong interview because you were able
68:00 - to work to the solution and it was a
68:01 - hard problem
68:03 - yeah I will also mention I think one
68:06 - other thing that a lot of interviewers
68:07 - do tend to look for is probably testing
68:09 - so I do think that
68:12 - um yeah you know it's a good it's a good
68:15 - signal you know we were running out of
68:16 - time but I think
68:18 - um
68:18 - for both the for the interviewer it's a
68:21 - good signal if the interviewee brings up
68:23 - testing and says oh like you know I like
68:26 - the solution but in order to verify my
68:28 - answer I would like to test it or I'd
68:29 - like to run it or something like that
68:32 - um and I think with in terms of
68:35 - what the interviewer is looking for is
68:38 - that they want you they want to see that
68:41 - you're going to be a good software
68:42 - engineer right and I think testing is a
68:44 - big part of that equation and so I think
68:47 - that
68:48 - um
68:49 - I think that just mentioning maybe hey
68:51 - like these are a few cases that I would
68:53 - have ran through if I had extra time or
68:56 - you know here are some of the edge cases
68:58 - like I think this might work for most
69:00 - cases but there might be some sort of
69:02 - edge case here and there that I should
69:03 - have like gone through
69:05 - um I think those would be yeah that's a
69:07 - great that that should also be a
69:09 - component that
69:11 - testing is super important so seeing
69:14 - that and it is challenging because we
69:16 - did kind of run out of time so like I
69:17 - feel like you didn't hit some of those
69:18 - things that you probably would have hit
69:19 - if we had all the time in the world one
69:21 - thing that's interesting I saw this on
69:24 - Twitter or LinkedIn as an idea I don't
69:27 - know what your thoughts are on it I
69:28 - think that it's a pretty solid idea I
69:30 - would kind of be impressed if a
69:31 - candidate did this
69:32 - but I could see it going either way is
69:34 - the someone mentioned they were like a a
69:38 - um data analyst at Google
69:40 - and in the interview process like they
69:42 - screwed up I think a couple queries a
69:44 - SQL queries and after the interview they
69:47 - like
69:48 - you know calm down like they collected
69:50 - their thoughts and they like emailed the
69:52 - interview interviewee interviewer like
69:55 - the solutions like oh like I goofed up
69:57 - there this is how I would have solved it
69:59 - if I you know had a little bit more time
70:00 - they followed up with like some
70:02 - solutions so it'd be interesting I don't
70:04 - know if you think it would be a good
70:05 - idea or a bad idea I could see it going
70:07 - over either way but to like follow up
70:10 - and be like oh I didn't get a mention
70:13 - these testing cases this is what I would
70:15 - have done uh I think it's probably
70:18 - situation specific because
70:20 - it could be kind of weird too I don't
70:23 - know I'm just throwing that out there as
70:24 - an interesting Avenue if you feel like
70:26 - you
70:27 - wanted to redeem a bad interview or
70:29 - something like that and like have some
70:31 - Saving Grace
70:33 - yeah well I definitely I definitely do
70:36 - think that that is
70:39 - like I don't think it's necessarily I
70:41 - don't think it would be a bad idea under
70:43 - any circumstance I think that okay maybe
70:46 - your interviewer would never see that
70:48 - and they find it a little bit strange or
70:49 - maybe they've already submitted there
70:50 - whatever but I don't think it can hurt
70:54 - um and if anything I think it shows
70:57 - dedication and it shows that you know
71:00 - you couldn't solve this problem
71:03 - but you took time and you thought about
71:05 - it some more and you didn't give up and
71:08 - then you did come up with the right
71:09 - solution and you followed up and
71:11 - communicated that yeah
71:13 - I think it yeah it's situation depended
71:15 - if I feel like my interview went great I
71:18 - probably wouldn't need feel like the
71:19 - need to do that but if I feel like oh
71:21 - shoot that was like I was I'm so much
71:23 - better than that
71:24 - at that point it can't hurt to do
71:25 - something like that and just keep it
71:27 - casual keep it like yeah hey I thought
71:29 - of this thanks again for your time yeah
71:31 - uh take care like uh
71:34 - okay so now after the interview I just
71:36 - wanted to follow up with you guys that
71:39 - interview if I walked away from it I
71:40 - would have been like all right well
71:41 - there are certain aspects that you know
71:44 - just like Keith said there are certain
71:45 - aspects that
71:47 - signaled you know I was probably a
71:49 - strong candidate but I personally would
71:52 - have walked away from that being like
71:53 - dang there are some parts that I
71:55 - probably could have done better on like
71:57 - I needed his help a little bit I
71:59 - probably could have you know eventually
72:01 - gotten if I just had a bit more time to
72:02 - think or maybe today was just not my day
72:05 - and that's just sometimes how these
72:07 - interviews go you can't do perfectly on
72:09 - all of them now a few notes about my
72:11 - implementation specifically I use
72:13 - pseudocode because Keith the interviewer
72:16 - specifically said it was okay too and in
72:19 - this specific problem I really wanted to
72:21 - focus on the algorithm and not really
72:22 - kind of get
72:24 - uh you know get into the syntax of
72:27 - things and so for me uh python is almost
72:30 - basically pseudocode so most of it was
72:32 - very pythonic
72:34 - um but I come to doll out because I was
72:37 - too lazy to get that Max part working
72:39 - because I wrote like possibility three
72:41 - if applicable and I was just a little
72:44 - bit too lazy to like actually
72:46 - yeah Implement that and then also there
72:49 - was some underlining that just wouldn't
72:51 - go away and that was really bothering me
72:52 - so that's why I also just turned it to
72:54 - uh an entire comment
72:57 - now some things to remember about
72:59 - interviewing in general so don't be
73:02 - scared to ask questions turn the
73:04 - interview more into a conversation
73:05 - because that also gives the interviewer
73:07 - a signal of this is what I'm like as a
73:09 - teammate this is what it's going to feel
73:11 - like when you're working with me
73:13 - now during the interview I would always
73:17 - recommend repeating the question to the
73:19 - interviewer just so that uh you can
73:22 - check if you actually understood the
73:24 - question and then from there maybe even
73:25 - ask clarifying questions
73:28 - um and I typically start with something
73:30 - known as the naive solution which is
73:33 - this this is the first thing that I
73:35 - thought of and this solution would work
73:37 - but it's kind of this uh very Brute
73:41 - Force solution where it might take a lot
73:44 - of time and it might not work you know
73:46 - in my time out for these super long
73:48 - strings or these super long data files
73:51 - or this very large array or something
73:54 - like that so it's very very unoptimal
73:57 - but you know it is a solution
74:01 - and then from there that's when I start
74:03 - brainstorming okay well this sucks in
74:05 - terms of timing so let's figure out how
74:08 - we can optimize it so that we can make
74:10 - it run faster and from there if you can
74:12 - find the optimal solution then you
74:15 - implement it the best way and you are
74:18 - good to go
74:19 - all right thank you guys for watching
74:21 - today uh best of luck if any of you have
74:23 - software interviews coming up you know
74:25 - be confident