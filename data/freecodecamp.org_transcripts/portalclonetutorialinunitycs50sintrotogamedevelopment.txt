00:00 - [Music]
00:16 - all right welcome to
00:18 - gd50 this is lecture 10. today we'll be
00:21 - talking about portal so uh portal's a
00:23 - very iconic game i think most of us have
00:25 - probably seen it before the gist is you
00:27 - have a portal gun a gun that shoots
00:29 - just these elliptical portals
00:32 - if you look through one you can
00:34 - effectively see what's sort of coming
00:35 - out the other one which is pretty cool
00:36 - and vice versa and then if you walk in
00:38 - between the portals you'll actually be
00:40 - teleported to the other side and so they
00:42 - achieve a lot of really interesting
00:43 - effects with some pretty cool um tricks
00:46 - and stuff and actually valve themselves
00:48 - will be coming to
00:49 - give a talk on a lot of the technology
00:51 - that they used um on the second so we
00:53 - can get a glimpse into their version of
00:55 - portal my version of portal is a bit
00:57 - simpler
00:58 - but we'll look at a lot of the same sort
01:00 - of principles and see how i accomplished
01:02 - a lot of the same things
01:03 - so this is also the last lecture of the
01:06 - semester and we've covered a lot of
01:07 - ground i have a few screenshots here to
01:09 - show some of the games that we've talked
01:11 - about you know the very first game was
01:14 - pong and we've come sort of a long way
01:15 - we've gone through um very simple sort
01:18 - of arcadey atari-like games like this
01:20 - and you know have gone and created
01:21 - worlds effectively and you know now
01:23 - we're in 3d we're doing all kinds of
01:25 - awesome stuff but these this is where we
01:26 - started the course um and it's kind of
01:29 - fun to look back and see where we've
01:30 - come so you know here we talked about
01:32 - scoring and just effectively drawing
01:34 - shapes onto the screen then we
01:35 - transitioned to flappy bird or 50 bird
01:37 - and you know we had sprites and
01:39 - characters and we talked about scrolling
01:41 - and infinite level procedural generation
01:44 - type algorithms and that was fun
01:46 - um we took things a step higher than
01:48 - that with breakout where we had the same
01:50 - sort of procedural ideas in the context
01:52 - of a very famous arcade game we talked
01:55 - about particle systems and um some
01:57 - arcade style physics and high scores
01:59 - then we went into puzzle games we talked
02:01 - about match three and how to actually
02:02 - calculate what goes on uh uh to
02:05 - determine whether we've gotten a match
02:06 - and how to clear blocks and how to tween
02:08 - things do operations over time so this
02:11 - asynchronicity
02:13 - um then we went into probably what is my
02:15 - favorite lecture which was super mario
02:16 - brothers and we talked about how to
02:17 - create procedural worlds that all look
02:20 - very different with some very simple
02:21 - algorithms and then we had triggers and
02:24 - um events sort of happening then legend
02:26 - of zelda came and we had this infinite
02:28 - dungeon algorithm and we had enemies
02:30 - walking around that we could use a sword
02:32 - on so it felt more like an actual action
02:34 - game action rpg
02:36 - then we took a look a brief look at
02:38 - physics in the context of box 2d with
02:40 - angry birds and i still remember the
02:42 - like ball pit example was probably my
02:43 - favorite part of that
02:45 - and then um probably the most
02:46 - complicated example of the semester was
02:48 - pokemon where we actually had a full a
02:50 - semi-full turn-based battle system and
02:54 - random encounters and like a little
02:56 - world where there's actually two main
02:58 - stages to our world where there was the
03:00 - field and the battle scene which is a
03:02 - very common thing to have in rpgs
03:05 - following pokemon which was the most
03:07 - complicated code base we went into unity
03:09 - which was our first foray into 3d and
03:11 - even though we were just exploring 2.5 d
03:14 - we still got a chance to look at you
03:15 - know how does the unity engine work and
03:17 - how do we get actual 3d models onto the
03:18 - screen and we put together a very simple
03:21 - flappy bird-esque game so that we can
03:23 - sort of recycle prior ideas
03:25 - last week we looked at dread50 which was
03:27 - sort of a dread halls horror inspired
03:29 - game where we got to look at lighting
03:31 - and how to actually transition between
03:33 - scenes and use some basic ui in unity
03:36 - and today we'll be talking about how to
03:38 - use how to create a game similar to this
03:41 - although much simpler today is mostly
03:43 - just a tech demo more than anything else
03:44 - but this is a screenshot of the actual
03:46 - game portal and as you can see they do a
03:48 - lot of really cool fancy things they
03:50 - have a portal on sort of a slope they
03:52 - have another portal coming out of the
03:53 - front wall or back there different
03:55 - colors so you can differentiate between
03:57 - left and right orange and blue
03:59 - they have
04:00 - sort of this object here on the side and
04:02 - i believe that's to shoot
04:04 - cubes out which this here is a cube
04:06 - which you can then grab with your gun
04:07 - and then shoot it through portals and
04:09 - see it come in and out of portals which
04:10 - is pretty cool
04:12 - and we'll talk today about how to create
04:14 - sort of a simple version of this
04:16 - primarily just the aspect of how do i
04:18 - create a portal that looks out of
04:19 - another scene and see it updating in
04:21 - real time um and how do i teleport and
04:24 - get back back and forth between the
04:25 - portals and carry a weapon and then
04:27 - shoot a ray that'll actually place a
04:29 - portal where i want to in the game world
04:31 - so today some of the topics we'll talk
04:32 - about so one holding a weapon so we've
04:35 - had we've used a first person controller
04:36 - and this is a very easy and simple thing
04:38 - to do but it helps illustrate what
04:40 - parenting is and so we'll talk about
04:41 - that ray casting is the actual shooting
04:43 - out of ray from your object's z
04:45 - direction forward so you have an x and a
04:48 - y which are sort of the angle at which
04:49 - you're moving around but then you have z
04:51 - which is always
04:52 - if you're using vector of using the
04:54 - forward vector from your character it's
04:57 - going to be forward from the in the z
04:58 - axis wherever you're looking effectively
05:00 - and so that allows us to um we can cast
05:03 - a ray in that in that sense which just
05:05 - means you know shoot a straight line an
05:06 - invisible straight line from that point
05:08 - and wherever that point intersects with
05:10 - an object we can get some information
05:11 - about that and then do whatever work we
05:13 - need to do in this case take a portal
05:15 - prefab and just like affix it to the
05:17 - wall basically rotate it from its
05:19 - default position and then just like put
05:20 - it flat up against a wall
05:22 - texture mask masking is uh sort of how
05:26 - we're going to achieve this portal
05:28 - effect right because when we when we
05:30 - create what's called a render texture in
05:32 - unity which here's the third bullet a
05:34 - render texture just means a texture that
05:36 - we are rendering to with a camera so
05:39 - rather than have a texture be an asset
05:40 - in your game in your hierarchy with
05:42 - something that you've made in photoshop
05:44 - you can actually dynamically create it
05:45 - at runtime with a camera
05:47 - what the camera is seeing and unity
05:49 - gives this to you for free very easily
05:50 - with what's called a render texture
05:52 - which is just another asset type
05:54 - and then texture masking is effectively
05:56 - sort of kind of the same thing as
05:57 - stenciling where we can choose certain
06:00 - pixels of an object to delete in this
06:03 - case we create a texture that's white in
06:05 - the center and then black around the
06:07 - edges in a sort of elliptical shape and
06:10 - what that allows us to do is tell it
06:11 - with a simple shader
06:13 - don't render these pixels when you
06:15 - actually render the render texture just
06:17 - render the ones in the middle and so
06:18 - that's how we achieve an ellipse just by
06:20 - effectively discarding the pixels on the
06:22 - outer rim
06:23 - decals uh are is an idea in 3d games
06:27 - where a decal is just something that you
06:28 - have fixed a texture or some object that
06:30 - you fixed to a surface in this case
06:32 - we'll be using decals um to act as our
06:34 - portal so our portals are actually just
06:36 - going to be decals they're just meshes
06:37 - with a render texture affixed to them
06:39 - and then all we need to do is just sort
06:41 - of slap them onto a wall whenever we
06:43 - shoot it and we get a ray that
06:44 - intersects with the wall and that'll
06:46 - have the effect of um actually making it
06:50 - look like we're putting a portal on a
06:51 - wall when in reality we're just taking a
06:52 - mesh and we're just kind of like
06:53 - slapping it onto a wall some other
06:55 - examples of decals that you've probably
06:57 - seen in other games are for example
06:59 - bullet holes which use the same
07:00 - principle
07:02 - teleporting is very easy although the
07:03 - fps controller sort of complicates
07:05 - things a little bit so we'll talk about
07:06 - how i went about sort of solving it sort
07:09 - of solving the problem of teleporting in
07:11 - a way that makes sense
07:13 - it's usually just as simple as a change
07:15 - on the you know setting something's
07:17 - transform's position to another
07:18 - transforms position setting the rotation
07:20 - to the transform's rotation um but the
07:23 - fps controller caches its rotation data
07:26 - so in order to do that teleport cleanly
07:27 - you sort of have to override some
07:28 - default behavior and lastly we'll take a
07:30 - look at some new tools that unity has
07:32 - introduced with 2018.1 pro builder and
07:35 - pro grids which allow you to actually
07:36 - model geometry in the scene and this is
07:39 - what the assignment is going to be
07:40 - focused on um because going forward it's
07:43 - probably i foresee it being a major part
07:45 - of sort of modern unity development and
07:48 - or prototyping
07:49 - the ability to model your scene in unity
07:52 - without needing a third party program
07:54 - heavily optimizes the actual creation
07:56 - process and allows you to do easy what's
07:59 - called gray boxing meaning create a
08:01 - level for like you know to create a
08:03 - level in your game engine and then
08:04 - prototype it test it make sure that it's
08:06 - actually game playable right off the bat
08:08 - that's called grey boxing
08:10 - but first let's get a demo so does
08:11 - anybody want to come up here and play my
08:13 - implementation of portal
08:21 - mr james is landlocked
08:25 - all right james you're not landlocked
08:26 - let's go
08:31 - all right so i'm going to go ahead and
08:33 - set that up
08:37 - and so disclaimer there's actually a bug
08:39 - in this as well so i'm curious to see if
08:40 - you can spot what the bug is
08:43 - go ahead and hit play as soon as you're
08:44 - ready
08:46 - and then the mouse on the right will be
08:48 - your sort of angle of your portal
08:50 - so we see here i have a
08:52 - character with a portal gun created so
08:54 - if james if you shoot a wall with the
08:56 - left mouse that'll create a portal and
08:58 - then they've used the right mouse so
09:01 - that's one other bug
09:04 - so let's go ahead and restart the
09:05 - program actually um
09:09 - so that's one bug
09:12 - and so
09:14 - um if we avoid stepping into a portal
09:16 - that's there and this this could be
09:18 - fixed in a couple of ways
09:21 - so now you have a so okay so now you
09:22 - have two portals basically created
09:25 - do you see what's wrong with the the
09:27 - portal as it is here
09:29 - are both of these portals actually
09:35 - oh actually no i'm sorry these portals
09:36 - are actually completely right but walk
09:38 - through them
09:39 - and i will show you
09:41 - okay so you can see it works it works
09:42 - pretty well right you you can not only
09:44 - see your character rendering completely
09:46 - or moving in real time when the other
09:48 - texture
09:50 - but you can you can jump through them or
09:52 - walk through them you can jump with
09:53 - space bar if you want and that will
09:54 - teleport you out the other end so you
09:56 - see from the perspective of the other
09:57 - portal but if we try shooting one of the
09:59 - other walls for instance like the one of
10:01 - these white walls
10:03 - you can see something weird happens with
10:05 - this particular wall anything strike you
10:08 - as odd about that portal
10:10 - anybody it's upside down
10:12 - and so if you walk through it though
10:16 - it works perfectly fine now the reason
10:18 - that it's upside down um i spent
10:20 - probably like 10 15 hours trying to
10:22 - debug why this is it's in a state of
10:23 - what's called gimbal lock so this prefab
10:27 - right here there's three axes of
10:28 - rotation in 3d space and if you perform
10:31 - a rotation in some odd way
10:34 - um
10:35 - there are these things called euler
10:36 - angles which are your angles of rotation
10:39 - about the x y and z axis and you can
10:41 - sort of think of it think of them as
10:43 - sort of being able to rotate and
10:44 - interdependently but
10:47 - there is a situation in which you can
10:49 - for some reason unity's internal
10:51 - representation of a rotation can get
10:53 - messed up by manipulating these angles
10:55 - and so you can actually lock two axes
10:57 - together such that um
11:00 - rotating like for example in this case
11:01 - it's z and y they both rotate each other
11:04 - and so you're unable to get in this
11:06 - particular case the um portal to rotate
11:09 - about the axis that lets it like
11:12 - look like it's right side up based on
11:13 - the walls surface normal and so
11:16 - um
11:17 - had i maybe another week it probably
11:18 - could have debugged it but i had to
11:19 - leave it in unfortunately i ran out of
11:21 - time but
11:23 - if you don't
11:24 - the interesting thing is if you do shoot
11:26 - that same wall so try and shoot that
11:27 - wall the other wall with the like put
11:30 - both
11:30 - put one portal on the on the buggy wall
11:32 - so the right wall it's only that wall by
11:34 - the way for some reason so um that wall
11:37 - is a bit so notice that now it's right
11:39 - side up so if you shoot both portals on
11:41 - the same wall that buggy wall they do
11:43 - get right side up and i for the life of
11:45 - me couldn't ascertain exactly as to why
11:47 - i know it's gimbal lock
11:49 - unfortunately i was unable to debug it
11:51 - quite in time but every other wall
11:53 - including the ceiling and the floor will
11:54 - work if you shoot a portal up on them so
11:56 - you can create one up there and then you
11:58 - can jump through it see how it's looking
11:59 - down and it'll sort of put you at the
12:02 - top
12:03 - and
12:04 - all together minus the weird single wall
12:07 - that gimbal locks the portal we have a
12:09 - pretty functional implementation of a
12:11 - very basic portal game right we have a
12:14 - this model here is parented to the
12:16 - camera so it's always going to look in
12:18 - the exact same direction as the camera
12:19 - we shoot a ray from
12:21 - the tip of the gun
12:23 - and then whenever that ray intersects
12:25 - with a plane in this case any of these
12:26 - walls we get the information about the
12:28 - intersection and we flip the
12:31 - decal the
12:33 - portal decal such that it's
12:35 - the same angle as the wall rotation
12:38 - and then what happens when we actually
12:40 - collide with one of the portals just in
12:43 - code if we were to think about how to
12:44 - implement like the behavior that goes on
12:46 - here
12:48 - it's transporting the player and it's
12:49 - doing effectively setting the player's
12:52 - transform position to the same transform
12:54 - position as
12:55 - the portal
12:56 - now if we do the same thing on the
12:58 - rotation
12:59 - the player ends up getting a bits the
13:02 - fps controller's rotation gets a bit
13:03 - skewed if you mess with its x and z
13:06 - rotation the default controller
13:09 - so all we do for now is we just
13:11 - we keep those values the x and y
13:13 - rotation but we just change the y
13:14 - rotation y rotation is this position in
13:18 - space like this effectively so that
13:20 - allows us to get when we jump out of the
13:21 - wall we notice that he's you know sort
13:23 - of like flat from it but if we jump
13:25 - through any of the wall portals so if
13:26 - you like create a portal on the wall
13:28 - here and then jump through it
13:31 - you'll notice that you sort of get a you
13:33 - know you're sort of angled at the right
13:34 - um
13:36 - and the reason that it's skewed is
13:37 - because this one's upside down and so it
13:39 - flips it's flipping the camera that's
13:41 - rendering the texture and it's looking a
13:43 - little bit weird but when you jump
13:44 - through
13:45 - um
13:46 - it
13:47 - basically keeps your x and z but rotates
13:49 - your y position such that you come out
13:51 - looking as if you went straight through
13:52 - the portal rather than um by default it
13:55 - has you look like a look back at the
13:57 - portal that you came out of which is a
13:58 - bit weird or whatever direction you were
14:00 - walking through it when you went through
14:01 - the portal
14:03 - um
14:07 - that's just default so it's rendering a
14:09 - it's a render texture so there's a
14:11 - camera actually behind each of these
14:14 - portals so the prefab is a mesh with a
14:16 - render texture and then behind it
14:17 - there's a camera and so the camera is
14:20 - rendering in real time what's in front
14:21 - of the portal basically from behind it
14:23 - and so it's seeing your model
14:26 - from both of these
14:27 - portals both cameras are seeing your
14:29 - model and so it shows up in the render
14:31 - texture on the other on the other um
14:33 - on the other portal so it's effectively
14:35 - like looking at two video cameras
14:38 - instead of a portal
14:39 - it's a sort of a trick and this is a
14:42 - very crude implementation of portal the
14:43 - actual game uses a much more
14:45 - sophisticated algorithm for
14:46 - um and it also uh tracks your position
14:50 - with the camera so that like based on
14:52 - your angle of rotation you'll actually
14:53 - see something different on the on the
14:55 - texture there
14:56 - but it's a lot more complicated to put
14:57 - something like that together i have some
14:59 - resources that i've included um in the
15:01 - lecture and the assignment that'll show
15:02 - you actually how to do that
15:04 - um but
15:05 - it would take many many more hours than
15:08 - i had to uh put this demo together
15:12 - yeah it's fixed so if you actually look
15:13 - at it from the side you'll notice that
15:14 - it's like just a flat texture um there's
15:17 - no perspective ultimately it's
15:18 - perspective and um there's an awesome
15:21 - video that i'm going to show later in
15:22 - the slides by a youtuber named brackies
15:25 - where he actually implements a
15:27 - perspective correct shader that allows
15:30 - you to
15:31 - see and with with camera tracking of the
15:33 - player like both cameras will track the
15:35 - position of the player as well as
15:37 - render a texture and the result of that
15:40 - is because the cameras are changing
15:41 - their position it's sort of like
15:43 - changing the angle at which the scene is
15:45 - being rendered onto the portal mesh
15:48 - but also the way that's being drawn is a
15:50 - little bit different and so he has a
15:51 - really cool shader that does that and
15:52 - then valve when they present they'll
15:54 - actually show how they went about doing
15:55 - it which is even more
15:56 - complex but looks really good and is a
15:58 - lot more you know technically
16:00 - interesting
16:02 - but yeah that's my um sort of
16:04 - implementation bare bones implementation
16:06 - of what makes portal work
16:08 - so and it's somewhat it's somewhat fun
16:10 - to like walk through these um you know
16:12 - walk through these portals and just sort
16:14 - of play around with it now um the reason
16:17 - that if you just walk into a blue portal
16:20 - it doesn't work is because the portals
16:22 - are actually stored off-screen until you
16:24 - use them
16:25 - and so a way in which so i'll open up
16:28 - the scene here oh by the way thanks
16:29 - james for coming up to demo i appreciate
16:31 - it so the portals are over here
16:35 - right both of them are right here
16:37 - and so what allow what that
16:39 - does is when you only shoot one of them
16:41 - the other one is still out here so when
16:43 - you walk through it you end up just
16:44 - teleporting outside the level and in
16:46 - order to not have that happen what you
16:48 - really need to do is have a flag on both
16:50 - of them that just says
16:51 - don't teleport unless they've been shot
16:53 - once right and that'll prevent that'll
16:55 - prevent that sort of behavior from
16:56 - happening simple fix um but an
16:58 - entertaining one to take a look at
17:01 - and that is
17:03 - my crude implementation of portal it's
17:05 - uh far from being anywhere near as
17:07 - polished as the actual game um and there
17:11 - is the slight weird wall that gimbal
17:13 - locks the portal um which i would like
17:15 - to figure out why exactly that is but
17:18 - everything else is sort of in here now
17:21 - it doesn't include something like
17:23 - shooting blocks through it but the same
17:25 - sort of principles would apply because
17:27 - all we're effectively doing on the
17:28 - portal is saying
17:30 - it's it's basically a trigger right it's
17:32 - got a box collider on it and it says if
17:34 - i collide with something in this case
17:36 - the player um i want to teleport that
17:38 - collider to the other portal which means
17:41 - that the portals sort of have to link to
17:42 - each other right one portal has to have
17:44 - a reference to the other portal so that
17:45 - it can say teleport to the linked portal
17:48 - and vice versa the link portal should
17:49 - have a
17:50 - reference to the other portals i can say
17:52 - teleport back if you collide with this
17:54 - and so if we have another object let's
17:56 - say we shoot a cube into the portal it
17:58 - would also get teleported to the other
18:01 - portal right and now the other
18:03 - consideration for that is like if it's a
18:05 - rigid body and it has physics applied to
18:07 - it for example let's say it's it's going
18:09 - like 10 on the x and it teleports to a
18:12 - portal that's like perpendicular to it
18:14 - and it's still going 10 to the x then as
18:16 - soon as it shoots out of the portal it's
18:17 - going to go straight left which isn't
18:19 - the behavior we want we want it to go
18:20 - forward so
18:22 - it's like um
18:24 - linear velocity needs to be calibrated
18:27 - to go in a different direction didn't
18:29 - have enough time to put a full demo of
18:30 - that together but if you're curious in a
18:32 - nutshell that's sort of like what you
18:34 - would need to do in order to implement
18:35 - like some basic physics with uh
18:38 - portal
18:40 - so holding a weapon based on the
18:42 - screenshot can anybody tell me how they
18:43 - think i got i went from just a plain fps
18:45 - controller to an fps controller holding
18:48 - a gun
18:50 - did you stick a gun
18:54 - i don't know what do they call
18:59 - yeah there's not really a notion
19:01 - necessarily of pixels um in 3d space
19:04 - because that changes depending on your
19:05 - resolution but yes unity units so um
19:09 - it's effectively equivalent to a meter
19:12 - and you can change what it represents in
19:14 - unity settings
19:16 - um but yeah i mean it's not it doesn't
19:18 - necessarily have to be one unit it can
19:19 - be an arbitrary amount and what it
19:21 - really was was me going into here with
19:23 - this model by the way got this model on
19:26 - the asset store for free so the asset
19:27 - store is an awesome place if you're
19:28 - looking to just quickly prototype your
19:30 - game they didn't have any like obvious
19:32 - portal guns portable lookalikes that
19:34 - looked really good so i was just like oh
19:35 - this gun's got like the same kind of
19:37 - color i'll just choose this like a
19:38 - sci-fi kind of gun
19:40 - but as you can see
19:42 - there's a hierarchy here now
19:46 - how
19:47 - are we keeping the
19:49 - gun
19:50 - like affixed to where the camera is
19:52 - looking do we know
19:54 - you do the same thing as you do with the
19:56 - first
19:57 - the first person shooter
19:59 - code is you have the camera follow
20:01 - the uh
20:03 - sorry you have the camera
20:07 - yeah the camera followed the gun do we
20:08 - know do you have any guesses as to how
20:09 - we're doing that it's actually a really
20:11 - really simple
20:18 - thing so
20:20 - all we're doing oh stephen
20:23 - you said the cameras like transform like
20:26 - as
20:29 - like you really
20:31 - transform
20:32 - um
20:33 - cut into their guns transform like with
20:35 - an offset in like the same direction but
20:37 - like just some position
20:39 - yeah kind of so set the guns transformed
20:41 - to the cameras transform but just with
20:43 - an offset and that is effectively what
20:45 - we're doing um and in order to
20:46 - accomplish that it's really as simple as
20:49 - just making it a child of that thing
20:52 - so this is the first person character
20:55 - controller it's got a camera attached to
20:56 - it anything that you parent to something
20:58 - or you make a child of something else
21:01 - it's going to have the same transform
21:03 - like changes applied to it including
21:06 - rotation
21:07 - so by making the gun just a child of the
21:09 - first person character which is where
21:11 - the camera is here first person
21:13 - character by the way is just a
21:14 - subcomponent of the fps controller
21:15 - whichever you named the portalgun fps
21:17 - controller here
21:19 - the portal gun anytime this first person
21:21 - character is rotated which is the camera
21:22 - so anytime the camera is rotated it
21:24 - applies that rotation to the portal gun
21:26 - gun here this gun mesh and so that gives
21:29 - you the effect so what you do is you
21:31 - start it off by you know you figure out
21:33 - okay where's the you start off in 3d
21:35 - space like this you're looking at your
21:37 - game scene and you have your character
21:39 - and then you move your gun object around
21:41 - in this case i could go let's go to
21:44 - layouts 2x3
21:45 - so we can see in real time see this is
21:47 - the game view this is what's going to
21:48 - look like on startup
21:49 - i'm going to go over to my game
21:53 - my editor view here
21:55 - and i'm just going to
21:58 - grab the actual gun component here the
22:00 - gun object i should say go and position
22:03 - it and i can just move it right
22:05 - and so this is how you can like change
22:07 - where your gun is relative to the camera
22:10 - and this is going to affect sort of how
22:11 - it feels right like i could put it here
22:13 - and it's kind of a little lower i could
22:14 - put it here it feels a little weird
22:16 - obviously because it doesn't have a hand
22:17 - on it so it's kind of almost looks like
22:18 - a vr game and that's kind of like what
22:20 - vr games do is they take your hand
22:22 - positions and then they like
22:24 - the gun transform is locked to the
22:26 - basically where your hand controllers
22:27 - are
22:28 - um
22:29 - in this case all i did was i just
22:30 - positioned it i said i like how it looks
22:31 - right here so i'm just going to do that
22:33 - and as soon as i make it a child of the
22:35 - first person character which is the
22:36 - camera it's just going to get all the
22:38 - rotations applied to it so anytime we
22:41 - make any rotations
22:43 - to the camera which i'm doing here it
22:45 - stays exactly aligned with the with the
22:48 - camera this applies to any operation
22:51 - that you do in unity when you make any
22:52 - sort of transform position scale changes
22:55 - they
22:56 - all get propagated down the chain all
22:59 - the objects that are children of an
23:00 - object that get transform operations
23:02 - applied to them will have the same
23:04 - transform operations applied to them
23:05 - sort of like this recursive kind of
23:06 - effect yeah so if you import the
23:09 - first-person controller
23:11 - right that automatically has to jump and
23:13 - move left and right
23:14 - and then you just move your asset your
23:16 - gun
23:18 - to be underneath
23:20 - that controller it'll
23:22 - correct so if you have if you just
23:23 - import the vanilla fps controller and
23:25 - then just make the gun specifically the
23:27 - gun needs to be a child of this the
23:29 - first person character bit because that
23:31 - has the camera and recall the camera is
23:33 - what's driving our rotation right
23:34 - because we're moving the camera's
23:36 - rotation with our mouse that is
23:37 - ultimately going to determine how the
23:39 - transform gets applied to the gun but
23:40 - yes
23:42 - and so just whenever you're doing
23:43 - anything in unity and you'll do a lot of
23:45 - things where like one thing's movement
23:47 - or scale or rotation should apply to
23:49 - another thing just remember that it's
23:50 - usually just as easy as making it a
23:52 - child of something else
23:54 - so any other questions as to how we've
23:56 - gone about
23:57 - implementing the weapon
24:00 - all right
24:01 - so ray casting so raycasting is a nice
24:03 - feature that unity gives you for free
24:06 - it's part of the physics sort of
24:08 - namespace in unity part of the scripting
24:10 - api
24:11 - and what it allows you to do is
24:13 - effectively
24:15 - look at from whatever transform you're
24:17 - operating at or whatever opera transform
24:19 - you give it as a the source so whatever
24:21 - point you give it as the source
24:23 - you can tell a direction give it a
24:25 - vector as a direction
24:27 - and in this case what we're doing is
24:28 - we're saying
24:29 - transform.forward and transform.forward
24:32 - just means
24:33 - basically wherever we're looking x and y
24:35 - and then straight in the z direction so
24:37 - if you're doing it on a camera it's
24:38 - always going to be exactly what you're
24:40 - looking at it's always going to be
24:41 - exactly forward on the like
24:43 - transform.forward on a camera is always
24:45 - going to be like center of the screen
24:47 - wherever you're looking at and so if we
24:49 - cast a ray
24:50 - from the point of our character or
24:52 - actually we're doing it from the point
24:53 - of our gun
24:54 - to
24:55 - the transform dot forward like a line
24:57 - going from our player to transform its
24:59 - uh the forward vector of its uh
25:02 - character the
25:04 - forward vector of our camera it's going
25:06 - to have the effect of
25:07 - um
25:08 - we can shoot something
25:10 - right we can we can
25:12 - create a raycast and it's like a fix
25:13 - something wherever that ray intersects
25:16 - and it'll be the exact center of our
25:17 - camera view does that make sense
25:20 - so shoot a line from the z your z axis
25:23 - which is your forward vector and then
25:25 - based on how you've rotated the camera x
25:27 - and y are the x and y part of that and z
25:29 - is always forward that'll let you shoot
25:31 - things or cast rays directly in front of
25:33 - you and you can cast rays between any
25:35 - object and from any source point with
25:37 - any sort of direction you want
25:39 - but it's particularly pertinent in the
25:41 - context of
25:43 - how we've shot it from our gun and so
25:45 - here's a screenshot actually what that
25:46 - looks like and so the nice thing about
25:48 - unity actually is it has a function
25:51 - called debug ray or debug.drawray
25:54 - which i'll show you here
25:58 - i implemented it in a function called
26:00 - the
26:01 - a component rather called debug ray so
26:03 - that you can actually
26:06 - see
26:07 - where array is being cast in your scene
26:10 - and eliminate any ambiguity there so you
26:11 - can see draw array transform.position
26:14 - and then we just say
26:16 - transform.transformdirection
26:18 - vector3.forward
26:20 - and then times a thousand just means a
26:22 - thousand units you know from that point
26:25 - and then color.red
26:28 - and so what that'll do is only in the
26:29 - only in the editor view so this doesn't
26:31 - apply in the in the actual game this is
26:33 - just a debug
26:35 - call
26:36 - debug.drawray and so it'll render in the
26:39 - this scene up here just not down here so
26:42 - if we hit play i actually have all the
26:44 - portals rendering a debug gray from
26:45 - their forward transform and from my gun
26:47 - so you can see it there i'm just doing a
26:49 - debug.drawarray with just
26:51 - transform.forward and
26:54 - um using my transform.position as the
26:56 - source point
26:57 - and forward is always going to be notice
26:59 - that the the z arrow it's always
27:01 - always falling the same direction right
27:03 - x and y are sort of changing you know
27:05 - the back planes or like how that's
27:06 - rotated but z is always forward right
27:11 - and so that's the that's the ray coming
27:13 - from our gun and if we shoot a portal
27:15 - there and there i have those also set to
27:19 - um let me pause it so i can rotate the
27:20 - view a little bit i have those also set
27:22 - to draw array from their forward
27:24 - position so those are also drawing array
27:26 - from what's there vector3 dot or their
27:29 - transform dot forward their directional
27:31 - vector um but yeah raycasting it's
27:35 - pretty it's pretty easy just to get um
27:38 - some pretty simple
27:39 - collision tests this way with guns with
27:42 - um a lot of different things but
27:44 - primarily you'll see this used for like
27:46 - calculating whether something is
27:47 - blocking something else like if a car is
27:49 - moving and it detects maybe if it
27:51 - detects another car like in grand theft
27:53 - auto for example and your car is driving
27:55 - down the center of the road or something
27:56 - and it wants to know whether there's a
27:58 - car
27:59 - two units in front of it or something it
28:00 - just cast a ray and see if there's any
28:02 - geometry there from its forward vector
28:04 - right transform.position card opposition
28:06 - and then get its forward vector which
28:08 - will be its z direction and then um it
28:11 - depends on whether maybe your game's top
28:12 - down maybe it's not your forward vector
28:14 - maybe it's your y vector in that case
28:16 - but that'll effectively give you not
28:19 - only that you've got a collision but
28:20 - also tell you where the collision is too
28:22 - which is nice
28:23 - and we do that in the
28:25 - portal
28:27 - gun script
28:31 - where we call
28:32 - physics.raycast so this this is the
28:34 - function by the way to actually do the
28:35 - raycast
28:36 - the interesting thing about raycasting
28:38 - in unity is that it returns a struct
28:40 - object and so
28:42 - you need to declare this hit object
28:45 - which will tell you all the information
28:46 - about the hit so like where it was
28:48 - whether there was a hit to begin with um
28:50 - and what the like the normal was on the
28:52 - surface that it it collided with so the
28:54 - angle at which that
28:57 - sort of plane was projecting out
29:00 - and then you call physics.raycast with a
29:03 - position and a
29:04 - transform direction
29:06 - and then
29:07 - you pass in out hit
29:09 - so out is interesting
29:11 - because out is sort of c-sharp's way of
29:14 - allowing you to return multiple values
29:16 - to something so out is going to be an
29:18 - object a in this case it's going to be
29:20 - our raycast hit that we declared up here
29:22 - right which is a struct which recall is
29:25 - just a collection of
29:26 - variables like in c or c plus um
29:30 - and out hit just means that normally we
29:33 - pass in these values to the function
29:34 - they don't get manipulated right but we
29:37 - pass in this
29:38 - variable as out
29:40 - which will allow this function to
29:41 - actually change the data inside this
29:44 - this hit variable
29:45 - and so the result of that is hit from
29:48 - this point forward contains all of the
29:49 - information about the raycast
29:51 - that we that we
29:53 - that we just triggered and when we call
29:55 - math f dot infinity that just means um
29:58 - ray cast to infinity which is until you
30:01 - know forever and ever and unity
30:02 - obviously doesn't check infinitely
30:04 - whether something's collided with
30:05 - something
30:05 - it optimizes the right way
30:08 - but you can use that just if you don't
30:10 - want to necessarily specify
30:13 - i want to check two units or five units
30:15 - or a thousand units in front of me i
30:16 - want to just check forever and see if it
30:18 - collides with something in your scene
30:19 - right
30:21 - um and then as you can see here once
30:23 - that once we have detected a collision
30:25 - we play a portal sound we get the right
30:27 - portal and then we set the portal's
30:28 - transform and rotation based upon the
30:31 - hits point and rotation and that's
30:33 - pretty much all that's involved in
30:35 - shooting the gun and you can take a look
30:36 - through here if you want to get a sense
30:39 - of how it works and maybe explore also
30:40 - the raycast the physics.raycast
30:43 - section of the api just to understand
30:45 - what exactly it returns and what you can
30:47 - do with it but in this case this is how
30:49 - we're using it to detect whether we've
30:51 - intersected with the wall so it'll
30:53 - intersect with any sort of mesh and then
30:56 - when it does it'll tell you exactly how
30:58 - it did so
31:00 - that is what ray casting is raycasting
31:02 - has another name for like old school
31:05 - games like wolfenstein the method of
31:07 - rendering was called ray casting where
31:08 - you generate one sort of uh
31:12 - you would generate a ray from every
31:14 - pixel of the screen effectively although
31:16 - it was mostly just every line of the
31:18 - screen and you would just look up and
31:20 - down for everywhere intersected in the
31:22 - scene and then just create draw like a
31:23 - texture there and so that would generate
31:25 - a world that was that looked 3d but you
31:28 - couldn't move up and down because it was
31:30 - always generating all arrays completely
31:32 - forward and so you were locked onto two
31:34 - axes
31:36 - but ray casting is different in unity
31:38 - raycasting is just literally casting a
31:40 - rate in 3d space versus the sort of
31:43 - 2d space that it was casting in games
31:46 - like wolfenstein there's another
31:47 - screenshot of uh
31:51 - normals from our portals casting out
31:54 - rays and i i want to look up and see if
31:56 - i can just find a picture of what
31:58 - wolfenstein look like
32:02 - i'm pretty sure
32:05 - most folks are probably familiar with
32:06 - not the new one
32:08 - yeah wolfenstein 3d so this was this is
32:12 - wolfenstein so old school but this sort
32:16 - of ray casting was different it would go
32:19 - over it would basically shoot rays from
32:21 - every single line of the screen up and
32:23 - down and it would detect based on the
32:25 - level geometry which was very simple
32:27 - level geometry was just basically
32:29 - whether there was a wall there or not
32:30 - true or false kind of like a 2d image
32:33 - and it would draw based on how far away
32:36 - it was that particular point of the
32:37 - geometry it would just draw like pixels
32:40 - from a texture a specific texture
32:42 - at a specific point and they had to
32:44 - interpolate where on the texture it was
32:46 - it was a little more complicated but
32:48 - in case you see wolfenstein or in case
32:49 - you see raycasting used in those two
32:52 - different senses in the case of old
32:53 - school
32:54 - game engines in the case of
32:56 - um
32:58 - uh
32:59 - modern unity sort of raycasting that is
33:03 - what is um
33:05 - involved in that
33:07 - so any questions as to how
33:09 - sort of in a nutshell the raycasting
33:11 - works in the context of our game here
33:18 - so
33:20 - unfortunately no the
33:22 - oculus does not work on mac they do not
33:24 - have mac support and so uh we were
33:27 - unable to get a sort of
33:29 - version of it working we don't have the
33:31 - means to necessarily transport um given
33:33 - how much time we had now getting vr
33:36 - working in unity is actually very easy
33:39 - if i recall correctly i have to just
33:41 - remember the exact
33:42 - menu i had sort of anticipated
33:46 - talking about this before
33:48 - i think it's player xr settings yeah
33:51 - that's how that's what it is so in order
33:53 - to get so it's incredibly easy if you
33:55 - want to do a game in vr in unity and you
33:56 - have a pc out of the box it's very easy
33:59 - just to get it working all you need to
34:00 - go do is go to edit project settings
34:03 - and then go to player and then in the xr
34:07 - settings so unity has like deemed all of
34:09 - its vr ar stuff as xr
34:13 - and you click virtual reality supported
34:15 - here and you have your oculus rift or
34:17 - vive or whatever plugged in it'll just
34:19 - work with the camera like right off the
34:21 - bat right out the gate so it's pretty
34:22 - easy you may have to install drivers on
34:24 - your computer such that your computer
34:26 - knows that you have an oculus plugged in
34:27 - but assuming that's all set up your
34:29 - project will is as easy as just clicking
34:31 - this checkbox
34:36 - hololens
34:37 - um
34:38 - oculus rift and i'm pretty sure the vibe
34:41 - like 90 show the vive
34:43 - i'm not a hundred percent we can we can
34:45 - google it though let's see
34:47 - unity
34:56 - it looks like it does it looks like it
34:58 - definitely does yeah and of course if
35:00 - you already windows pc is very
35:02 - i apologize i thought i totally thought
35:04 - going into the course that unity
35:06 - that oculus worked on a mac um but as of
35:09 - even october they were like it's not
35:11 - going to work on any macbook ever
35:12 - released so only on a pc unfortunately
35:15 - um
35:17 - that said
35:18 - if you do have a pc super easy to get
35:20 - working and it looks like this is
35:21 - actually pretty cool tutorial i haven't
35:22 - looked at this but
35:24 - i tend to like ray i don't know if his
35:26 - name is van der lisch or wenderlich but
35:28 - he makes really good game programming
35:30 - tutorials in general so just you know
35:33 - because we're coincidentally here if you
35:35 - guys are curious i really like this uh
35:38 - website for basic tutorial stuff
35:44 - we have vive um and vive as far as i
35:47 - well vive the thing about vive is you
35:48 - need to install like wall like ceiling
35:50 - mounted cameras in order for it to work
35:52 - so that's kind of out of the equation we
35:54 - have the gear vr but you would need it
35:56 - we would need to export it to mobile and
35:58 - test it and just didn't have i didn't
36:00 - anticipate it not working for mac and so
36:02 - it kind of came up a bit late and so
36:04 - it's on me i apologize but if you are
36:06 - doing a pc game
36:08 - in oculus and you want some assistance
36:09 - i'm happy to like help out it looks like
36:11 - it's very easy just to get working with
36:12 - the default fps controller camera so
36:16 - definitely reach out if you're
36:18 - developing oculus and need some
36:19 - assistance
36:22 - [Music]
36:24 - maybe for the next iteration of our next
36:26 - unity course we can have a
36:28 - a big sort of vr
36:31 - day where we bring in all the guns
36:33 - um
36:35 - but yeah back to sort of raycasting and
36:38 - what we were just talking about um
36:41 - shooting array on your z axis based on
36:44 - your rotation
36:45 - um get information from it
36:47 - and then
36:48 - sort of what we do is we flip the portal
36:50 - based on the hit dot rotation of the
36:53 - surface that we collided with and that's
36:55 - effectively all the raycasting that we
36:58 - need to worry about for
36:59 - portal
37:01 - um but the actual making a portal is
37:03 - probably the most interesting part of
37:05 - this whole project and so let's go ahead
37:07 - and go back into present mode
37:10 - so a render texture is the means is a
37:13 - very is a basic
37:15 - it's not a basic means it is the the
37:17 - fundamental way at which we go about
37:18 - doing it and there are
37:20 - various ways to accomplish doing it some
37:22 - that are more technically challenging
37:24 - and look a lot nicer than others i did a
37:27 - sort of simple version of it
37:29 - just to get a sort of proof of concept
37:31 - out of the gate but unity makes it
37:33 - really easy just to get a simple render
37:34 - texture up and running so a render
37:36 - texture is recall
37:39 - just a texture
37:41 - in unity so it's an asset it's an unity
37:42 - asset that you can create the difference
37:45 - between a render texture and a
37:47 - texture that you might have imported
37:49 - from like photoshop or is that a
37:51 - render texture can be rendered to and
37:53 - typically this is used for things like
37:55 - cameras being rendered to it although
37:58 - from what i understand you can render
37:59 - anything to it so you can create
38:00 - procedural textures this way as well but
38:03 - in this example here we're creating a
38:06 - we're essentially creating a screen into
38:09 - which we're looking at the viewpoint of
38:11 - our other portal right from from its
38:14 - forward direction so we can see what
38:15 - what it will look like once we walk out
38:17 - of the portal and go into the next area
38:20 - and so a render texture so i have some
38:22 - for in the slides if you want to
38:23 - download the slides they're here
38:25 - you can see exactly how to create a
38:27 - render texture so literally just create
38:28 - and then render texture that creates a
38:30 - render texture these are the settings
38:31 - that i used
38:33 - for the actual render texture so
38:36 - what will happen do we think if we use
38:38 - like a low res render texture
38:40 - just logically
38:45 - hey let's see what if my render texture
38:46 - was like 200 pixels by 200 pixels
38:50 - and our resolution of our game is
38:52 - like 1080p
38:59 - it won't be blown up because what we're
39:00 - doing is we're taking a mesh and we're
39:02 - affixing the texture to it so it'll just
39:04 - scale to fill the mesh
39:07 - but what'll it look like when it's
39:09 - rendered
39:11 - because it's rendering a 200 pixel
39:12 - texture
39:16 - it'll pixelate it it'll look really like
39:18 - nasty
39:19 - and so in order to fix that problem
39:21 - typically what you'll do a smart way to
39:23 - do it would be to dynamically figure out
39:25 - at run time what's what's the resolution
39:27 - of your game right if it's going to be
39:28 - rendered in various resolutions
39:30 - up to 4k maybe down to 720p
39:34 - and then create a render texture that is
39:36 - the size of your game
39:38 - and then by doing that it'll ensure that
39:40 - no matter what your resolution is it'll
39:41 - always be one to one pixel ratio even if
39:43 - you're right up close to it right it'll
39:45 - fill up your whole screen
39:47 - in this case we went for a simpler
39:49 - method so we didn't have to do any
39:51 - dynamic instantiation of the render
39:52 - texture which you can absolutely do and
39:54 - it is the more robust way to do it but
39:56 - in this case i just chose 1024 by 1024
39:59 - figuring that that was going to be good
40:01 - enough for demonstration purposes and
40:03 - most of these other settings i believe
40:05 - actually all these other settings are
40:06 - completely default render texture
40:08 - settings the only ones that changed
40:09 - where this is 256 by 256 by default and
40:11 - it just looks really pixelated and nasty
40:14 - especially when you're right up close to
40:15 - it
40:16 - um
40:18 - and then
40:19 - all we need to do so
40:21 - once we've created a render texture
40:22 - right in our in our scene in our assets
40:25 - so here i'm going to go to textures this
40:28 - is where i'm storing all my textures
40:30 - whether they render textures or not i
40:32 - have these two render textures here
40:34 - and so these are by default they're not
40:36 - going to be mapped to anything because
40:37 - they're just there's empty render
40:38 - textures we've effectively allocated
40:39 - them and said something will be
40:41 - rendering to these later but for now
40:43 - they're just empty there's placeholders
40:44 - right they're like blank screens but
40:46 - that tv hasn't been turned on yet
40:49 - in order to actually render to them
40:53 - we go into our first person character
40:56 - sorry not our first person character we
40:57 - go into whatever camera we want to
40:59 - render it to render to the render
41:01 - texture because we're we're effectively
41:03 - taking these render textures and we're
41:05 - rendering a camera view onto them right
41:07 - each of the portals has a camera behind
41:09 - it looking out from it and so we want to
41:11 - take that camera's view
41:13 - and we want to render that onto the
41:14 - other portal's face
41:16 - the other portal's render texture the
41:18 - texture that we're going to put onto it
41:21 - and so
41:22 - all we need to do
41:24 - is say here is my orange portal i have
41:26 - my camera here
41:28 - every camera has a target texture just
41:30 - right out the gate
41:32 - so you can just say okay i'm going to
41:34 - take my orange portal texture my render
41:35 - texture that i've instantiated so it
41:37 - knows that it's going to be able to
41:38 - receive an input source
41:40 - and i'm going to just click and drag it
41:42 - there and it's that simple now whenever
41:43 - you run the game
41:45 - you'll notice that your render texture
41:46 - updates i'm not sure if it updates in
41:48 - real time in the inspector but it
41:50 - renders if you're if you're showing it
41:52 - onto a
41:54 - yeah it doesn't render in the inspector
41:55 - but it will update if you've affixed it
41:58 - to any other surface
41:59 - and so what we're doing is we're fixing
42:01 - it to the meshes that are associated
42:04 - with each portal james did you have a
42:05 - question
42:09 - oh sure the render texture so i just
42:11 - right click and then i go to create and
42:13 - then a render texture right here
42:16 - and that will give you most of the
42:17 - settings that you need to get up and
42:18 - running with it and you can assign it to
42:20 - a camera but the important thing is do
42:22 - consider your resolution for your render
42:24 - texture make sure that it's high enough
42:25 - such that your game won't look pixelated
42:27 - when you're looking at it like pretty
42:29 - close up
42:32 - yep yep and so that'll do is create a
42:36 - link between the two such that anything
42:38 - the camera sees it's no longer going to
42:40 - be rendering to the scene or anything
42:42 - like that it's going to render to the
42:43 - texture and actually i think you can
42:44 - render to the scene and the texture but
42:46 - these aren't rendering um to the scene
42:48 - at all they're the only one rendering to
42:50 - the scene is the first person character
42:52 - because it's the default camera
42:54 - main camera
43:03 - um if it's a high too high of a
43:05 - resolution it's just going to like
43:07 - compress to fit the the mesh whatever
43:09 - it's affixed to and you'll probably run
43:10 - into performance problems but it's not
43:12 - going to break
43:13 - yeah because you're not affixing it to
43:15 - any because your resolution it doesn't
43:17 - really have an effect necessarily on
43:18 - whatever's in your game world and like
43:20 - that doesn't cause any issues um it gets
43:22 - it gets interpolated like unity will
43:24 - just like calculate how to render it to
43:26 - the screen right
43:27 - yeah
43:30 - like game textures
43:32 - generally are very high resolution like
43:35 - four thousand by two 4k textures are
43:37 - often used
43:38 - even if you're running your game in
43:39 - 1080p and now game engine will probably
43:41 - optimize it and like down sample the
43:43 - texture so that it is like actually a
43:45 - 1080p texture and you don't like you're
43:47 - not trying to calculate more draw more
43:49 - than you need to
43:50 - um
43:51 - but
43:52 - unity we'll figure that out for you you
43:53 - don't have to worry about that
43:56 - um
43:57 - but yeah that's that's what a render
43:59 - texture is and that's that's how we are
44:01 - creating this illusion remember
44:03 - everything in the game is an illusion um
44:06 - in this case we're not actually and it's
44:08 - it's obvious in this example because
44:10 - we're not actually because the the
44:12 - textures are flat and there's no
44:13 - perspective correction you can see that
44:15 - it's a texture even if it is slightly
44:17 - convincing from far away like from far
44:19 - away it actually kind of looks
44:21 - i mean i don't know if it necessarily
44:23 - looks real
44:24 - um i mean it kind of does right like you
44:26 - from here it's hard to tell and from
44:27 - here it kind of looks like we're going
44:28 - into another room right i go like that
44:31 - that's the broken wall they go like that
44:33 - right there's a portal there and it kind
44:35 - of looks like it's a real room that
44:37 - we're walking into it's just a
44:38 - resolution but all we're doing is we're
44:39 - just drawing a camera's view onto that
44:41 - texture in real time and
44:44 - if you notice you can see our gun that's
44:45 - kind of hard to see actually
44:47 - um
44:52 - see if i can do it from
44:54 - from there maybe
44:57 - yeah there we i see a little bit better
44:59 - there when we move we can see the gun so
45:01 - we it's we can see that it's rendering
45:02 - in real time and that's the power of a
45:04 - render texture and this allows you to do
45:06 - all kinds of things you can have like
45:08 - you know tv screens in your game that
45:09 - are rendering another part of your scene
45:13 - obviously an example like this where you
45:15 - have a portal looking into another area
45:16 - now if you apply a perspective
45:18 - correction to this whereby your camera
45:20 - actually tracks where your player's
45:21 - position is relative to the portal you
45:22 - can accomplish a much more believable
45:24 - look and you can actually make it seem
45:26 - as if you're looking into another area
45:28 - because the camera is literally moving
45:30 - with your player so the cameras like the
45:32 - the stuff that it's capturing is going
45:34 - to be changing in real time not only
45:35 - just your character's model right the
45:37 - actual angle is going to change and
45:39 - therefore be perspective correct
45:41 - and there's a awesome tutorial that i'm
45:43 - going to link to in the slides that will
45:45 - show you how to go about doing that it's
45:47 - really awesome and so this is what it
45:48 - ends up looking like this is actually
45:49 - before i changed one of the portals had
45:51 - a slightly offset camera angle so you
45:54 - can see here this is like a little bit
45:55 - higher than this one is they even though
45:57 - they should be exactly the same
45:58 - but it's fixed now so
46:01 - so texture masking oh any questions
46:03 - about any of that process before we talk
46:05 - about texture masking
46:09 - okay
46:10 - so texture masking is
46:13 - basically the process so here's a
46:15 - if we just take a plane and we put a
46:17 - render texture onto it that's what it
46:18 - looks like it just looks like it's just
46:20 - a square and this could work fine if you
46:23 - want a sort of a square portal look you
46:26 - don't have to do any extra work but if
46:28 - you want a circle
46:30 - right you can't really create like a
46:32 - circle shaped plane object that doesn't
46:34 - really exist and if and even it did it
46:36 - wouldn't be efficient especially if you
46:37 - want a very smooth
46:40 - plane because everything is triangles
46:42 - and polygons right so if you're if you
46:44 - have a circle it's going to be a bunch
46:45 - of these sort of fanned out polygons
46:47 - especially a very high res circle like
46:49 - one of these that's a very high-res
46:50 - circle making a polygon that looks like
46:53 - that is not
46:55 - it's not an optimal way to go about
46:56 - solving that problem right
46:58 - a much more optimal way to go about
46:59 - solving that problem would be to say to
47:01 - designate certain pixels of the t of
47:04 - some texture as being pixels that we
47:06 - want to read and then certain other
47:08 - pixels being not pixels that we want to
47:10 - read and um and therefore produce a the
47:13 - final image that gets put onto a
47:16 - geometry right
47:19 - um and so what we end up doing is
47:21 - creating an image first so it's this
47:23 - image
47:25 - um which is kind of hard to see
47:27 - but
47:28 - it's just a simple sort of can you see
47:31 - you guys see from the akin so it's just
47:32 - a simple oval right it's the exact shape
47:34 - that we want our portal to look like
47:36 - um and the pixels that are white are the
47:39 - pixels that we're going to render and
47:40 - the pixels that are black are the pixels
47:42 - that we don't want to render we want to
47:43 - consider those as black pure zero alpha
47:45 - effectively
47:48 - and using a awesome shader that you can
47:51 - get for free just easily on the unity
47:53 - webpage this is just a masking shader
47:56 - and i'm not great at writing shaders
47:58 - but what this does is turns lighting off
48:01 - first of all
48:02 - what happens if we have lighting applied
48:03 - to our
48:06 - portals
48:13 - it's going to look a little weird right
48:14 - you're going to get like shadows cast
48:16 - onto your portals and that doesn't make
48:17 - sense right because we're effectively
48:18 - supposed to be looking into another
48:20 - another place another area so we have
48:22 - shadows that are being cast onto our
48:24 - thing we're effectively like almost
48:26 - seeing like a glass door on our portal
48:28 - right
48:29 - it sort of breaks the illusion
48:30 - so
48:31 - lighting should be off
48:33 - a lot of these things i'm not 100 on
48:35 - because i'm not great at writing shaders
48:36 - but it's a very simple easy shader that
48:38 - you can grab off of the
48:40 - unity web page and the
48:42 - i think i
48:44 - clipped the url here at the very bottom
48:48 - but i grabbed that off of the unity web
48:49 - page and all it does is it adds onto
48:52 - your material
48:55 - this second image here and it gets blown
48:57 - up a little bit because unity makes any
48:59 - texture that you apply to
49:04 - basically any texture you put into like
49:05 - an image selector will get made into a
49:07 - square shape and our image is not square
49:09 - shaped but what this does is when you
49:11 - pass in this image which is called a
49:13 - culling mask
49:15 - it will
49:16 - basically combine the two images and
49:18 - then cancel out any of the pixels that
49:20 - are black
49:22 - on the
49:24 - on this it'll effectively add
49:26 - the black and white to the alpha of the
49:30 - of the
49:32 - texture pixels right so you can actually
49:34 - make some of these gray and then it'll
49:35 - have the effect of sort of making it
49:36 - half transparent but in this case i only
49:39 - went with full transparent and full hard
49:42 - 255 alpha so we get sort of a crisp
49:45 - outline for our portals
49:48 - and that's what the that's how you end
49:49 - up putting together a um
49:53 - a
49:54 - basic
49:55 - sort of oval shape on something that is
49:57 - just a flat mesh and you can do this
49:59 - with anything
50:01 - anytime you need to sort of take away
50:03 - detail that would make making a mesh
50:06 - extremely difficult or doing really cool
50:08 - effects
50:09 - it's often just a lot easier to create a
50:11 - mask for it and then create use the
50:13 - right shader that's meant to have that
50:14 - mask and then just
50:17 - manipulate that however you need to
50:19 - um
50:21 - and again the link here for the shader
50:23 - is here and then you can use this for
50:24 - pretty much anything you want
50:27 - and result of that
50:29 - is we go from having a square portal to
50:31 - a elliptical portal so pretty nice
50:36 - i didn't have to use a plane but it
50:39 - doesn't really make sense
50:40 - to use anything else
50:42 - um
50:43 - because using a i mean using a cube
50:46 - it would it would create depth we don't
50:48 - want the portal to have any depth really
50:50 - right it should be a flat surface
50:53 - and then when we go through it it's just
50:54 - teleport us to the other surface to make
50:56 - it look
50:57 - sort of seamless
50:58 - i don't think there's any other
51:00 - i don't think there's another choice of
51:02 - geometry that makes sense for this use
51:04 - case
51:11 - no i probably wouldn't um you'd
51:14 - make a cylinder flat
51:16 - and project it and have no depth on it
51:18 - the
51:20 - you would be able to still see the rings
51:22 - on it
51:23 - and also texturing that
51:26 - is a little bit more complicated because
51:28 - then it's going to it's going to you'd
51:29 - have to uv map your
51:31 - both your
51:33 - sort of
51:34 - mask and your regular texture onto that
51:36 - because by default it's going to wrap it
51:38 - weird just because
51:40 - this is just a plain so whatever you
51:41 - texture map onto it's going to be
51:42 - completely flat but a cylinder is going
51:44 - to wrap it around all sides and it's
51:46 - going to look a little bit it's going to
51:47 - look a little bit funky
51:49 - i suppose in theory you could use a
51:50 - cylinder for it but i think it'd be a
51:51 - tremendous amount of work i don't think
51:53 - it would be
51:54 - anywhere near as easy as getting it to
51:55 - work with just a flat plane or a mesh
51:59 - interesting idea though
52:01 - i guess you could theoretically create a
52:03 - cylinder
52:04 - that has if you wanted to like a bridge
52:06 - between two worlds and have one end be
52:09 - one
52:10 - portal and one envy another portal and
52:11 - then be able to walk between them that's
52:13 - a cool idea maybe you can make that work
52:15 - but i think for this the the plane is
52:17 - the right way to go
52:20 - any more questions as to sort of how
52:23 - that works
52:27 - all right
52:28 - so we'll talk about teleporting now so
52:30 - teleporting is pretty easy
52:32 - all we really need to do right is just
52:35 - create a
52:38 - mesh collider on the portal mesh the
52:40 - orange portal in the blue portal and
52:42 - then when that mesh collider if that
52:43 - mesh collider is a trigger right and it
52:46 - collides it detects a collision with
52:47 - something else it's going to we can just
52:49 - define on trigger enter
52:51 - and then with that
52:53 - we can teleport the
52:55 - collider other
52:57 - to the other portal's location so every
53:00 - portal this is the portal component
53:02 - it has a links portal right because we
53:04 - need to know where to teleport the
53:06 - player to the other portal
53:07 - so we need to get no have a reference to
53:09 - its transform
53:11 - whether it's active right because if we
53:14 - allow ourselves to
53:16 - teleport to another portal
53:19 - and another portal like back and forth
53:20 - just without any restraints what do you
53:22 - think is going to happen
53:26 - infinite loop we just get an infinite
53:27 - sort of weird flickering effect um so
53:30 - you need to effectively have like a
53:31 - toggle switch on both portals and say
53:34 - um as soon as i enter a portal i should
53:37 - not be able to teleport back into it
53:39 - right and as soon as i teleport to
53:41 - another portal i should not be able to
53:42 - teleport into it either but once you
53:44 - exit a portal you should be able to
53:46 - teleport back into it
53:48 - and so what that effectively does is we
53:50 - enter a portal
53:52 - it gets flagged as not teleportable
53:55 - right we get teleported to the other
53:57 - portal as soon as that happens this
53:58 - portal can now be teleported into
54:01 - this portal that we're standing in
54:03 - is now flagged as not teleportable and
54:06 - then we walk out of it and we're allowed
54:08 - to teleport back into that one and the
54:10 - other one so it's effectively an on off
54:12 - operation that you have to balance
54:13 - appropriately
54:15 - the actual portal game is a little more
54:17 - complicated because they allow you to
54:19 - walk in between portals
54:22 - this does not go into that level of
54:23 - detail and it's a more complicated
54:25 - problem to solve
54:26 - this example just assumes that you walk
54:28 - into a portal you get teleported out the
54:30 - other end and there's no sort of
54:31 - in-between state
54:33 - and actually if you're in between two
54:35 - portals there's a replication of
54:36 - geometry which valve will talk about in
54:38 - their talk as well which i think will be
54:40 - very interesting because if you look
54:42 - into another portal while you're in the
54:43 - middle of a portal right you want to be
54:45 - able to see
54:46 - yourself you know in that portal right
54:49 - halfway in and out of that portal so
54:51 - there's a
54:52 - lot of interesting considerations for
54:55 - getting very believable portal systems
54:56 - but ours is a very simple illustration
55:00 - and so this toggle function is all that
55:02 - i have to toggle the function's on and
55:04 - off capability and all it is is just
55:06 - portal active is not portal active and
55:08 - that just flips that flag super easy
55:12 - on trigger enter we
55:15 - effectively cache our position x on the
55:18 - x and z axis so we don't rotate it
55:19 - because when we rotate our x and z on
55:21 - the first person controller by default
55:24 - it causes some really weird buggy
55:26 - behavior based on the way that the fps
55:28 - controller works so all i do is i just
55:30 - cache i cache those positions and then
55:32 - make a rotation on the y-axis and
55:34 - that'll save us that weird um
55:37 - sort of
55:38 - going topsy-turvy effect that you'll get
55:40 - if you use the fps controller by default
55:42 - and you do perform rotations on it
55:44 - you'll notice this so
55:46 - i haven't had the time to dig in depth
55:48 - as to how to fix it um but this is the
55:50 - way that i was able to fix it for this
55:51 - example at least is only only allow
55:54 - yourself to rotate on the y direction
55:56 - which is where you're looking in sort of
55:58 - like the ground relative to the ground
55:59 - plane and that'll allow us to rotate
56:02 - based on where we're exiting the portal
56:04 - um at least on the sort of walls that
56:07 - are going up and down and then have that
56:10 - sort of believable effect it doesn't
56:11 - allow us to like jump down into a portal
56:13 - from up above and see us coming down
56:15 - from the other portal
56:16 - which is a cool effect um unfortunately
56:19 - but it does allow us you know sort of to
56:21 - get most of the way there
56:23 - um
56:24 - and so we set our position to the other
56:26 - portals position and our rotation but
56:28 - only the y we get the y and then we set
56:31 - it here using euler angles on our
56:34 - player's transform
56:36 - and then um there's a function that i
56:38 - called that i created called mouse reset
56:40 - which effectively uh just calls init
56:43 - again on the fps controller's um
56:47 - rotation on the the camera and the
56:49 - player and then um that's sort of like
56:51 - the hack that you need in order to
56:54 - so the reason that a lot of the
56:55 - weirdness exists is because the player
56:57 - controller caches its rotation
56:59 - information and so if you perform a
57:01 - rotation on a on your fps controller by
57:04 - hand as opposed to allowing it to happen
57:06 - with the mouse it will
57:08 - immediately reset it back to its prior
57:10 - position and rotation which has the
57:12 - effect of when we teleport from one
57:14 - portal to another
57:15 - um even though we set our direction of
57:18 - rotation to be like outside going in the
57:20 - direction of where the portal is facing
57:22 - we end up having the same position the
57:24 - rotation that we did entering the portal
57:26 - so we end up coming out of portals often
57:27 - just backwards and so
57:30 - that's some that's just a limitation of
57:32 - the first person controller but you can
57:33 - fix that by calling mouse reset which is
57:35 - a function that essentially just calls
57:37 - init again
57:39 - which init is part of the fps
57:41 - controller's
57:43 - mouse look object i won't go too much
57:45 - into detail about it just because it's a
57:46 - little bit arcane and
57:49 - the the source code's in there if you
57:50 - want to take a look and dabble with it
57:52 - but
57:53 - effectively preventing it from caching
57:55 - its uh rotation information and just
57:57 - hard setting it and then
57:59 - recalling the mouse look init function
58:02 - which does the actual setting of the
58:03 - rotation on the camera and the and the
58:06 - player
58:07 - a little bit a little bit weird but
58:09 - that's
58:10 - unity's fps controller and
58:12 - that's how other people are saying to
58:14 - fix it so you could roll your own you
58:16 - could create your own fps controller and
58:17 - probably
58:18 - prevent this from happening but if you
58:19 - want to use the regular fps controller
58:21 - that's sort of the
58:22 - limitation there but it's mostly working
58:24 - and it looks
58:25 - pretty good
58:28 - some more time on end we could probably
58:29 - make it look even better but
58:32 - for now i think it's good
58:34 - so that's teleporting
58:36 - say your position and then set your y
58:38 - rotation override the fps controller's
58:40 - default rotation caching and um we can
58:43 - walk in this portal and then instantly
58:45 - walk out this portal that's what we see
58:47 - so any questions as to how sort of this
58:50 - works in a nutshell
58:52 - or any of the maybe any of the code here
58:55 - in our
58:56 - portal
59:00 - all right
59:03 - so a much better version of the
59:06 - portal at least from the rendering side
59:08 - is this video here so it's bracky's so
59:11 - uh he's a very good
59:13 - he he explains things very well he's got
59:15 - very
59:16 - high quality to his videos uh he creates
59:19 - a bunch of unity tutorials and in this
59:22 - case he created a portal that used a
59:24 - sort of shader and an interesting shader
59:27 - that will only render everything but
59:29 - geometry and also
59:31 - um onto a plane in which case this plane
59:34 - and um does the camera interpolation of
59:37 - the player that i alluded to before
59:39 - which allows us to
59:40 - actually have two so these are two
59:42 - separate worlds
59:43 - in tandem right now so there's this red
59:45 - world here and then this camera is
59:47 - looking at a completely different green
59:49 - world that's completely like set off
59:50 - onto the in the distance that's the
59:52 - exact same geometry but completely
59:54 - colored green as opposed to red and if
59:57 - you look through here it's just
59:58 - completely seamless and the walkthrough
59:59 - is completely seamless and he goes into
60:01 - detail as to how he accomplished all of
60:02 - this if you're curious and he provides
60:04 - you the shader that you can use for free
60:05 - so definitely check that out if that's
60:07 - of interest there's a link there in the
60:09 - video and here's a link to his youtube
60:10 - series if you want to i put some of
60:12 - these in the slack because somebody
60:14 - requested some ai videos and so he has a
60:17 - bunch of different ai videos and a bunch
60:19 - of other really cool series so you can
60:20 - take a look at that if curious
60:23 - and
60:24 - the
60:25 - best version sort of of portal obviously
60:27 - is the portal itself and dave kersher
60:30 - and tajiev kohli are
60:31 - employees at valve who worked on portal
60:33 - and they'll be here on may 2nd to give a
60:36 - talk as to all of the technical sort of
60:38 - things that went behind the scenes and
60:40 - related to rendering and physics and
60:44 - just getting a believable and good and
60:45 - good feeling experience with portal
60:49 - for the actual polished final game that
60:52 - we're talking about so definitely come
60:54 - to that talk if you're curious we're
60:55 - going to take a break and then as soon
60:56 - as we come back we're going to talk a
60:58 - little bit about some new tools that
60:59 - unity has released called pro builder
61:01 - and pro grids um
61:03 - and we'll talk about the assignment and
61:05 - that'll be it for gd50
61:07 - all right welcome back this is lecture
61:09 - 10. so we talked about portal before the
61:11 - break we talked about ray casting we
61:13 - talked about render textures sort of
61:15 - what those are how easy it is to make
61:17 - those in unity we talked about how to
61:19 - give our first person controller a gun
61:22 - so that we could actually look around
61:23 - and look as if we're holding a weapon
61:25 - we talked about the portals themselves
61:27 - how we're masking out the texture the
61:28 - render texture as applied to a plane and
61:31 - how each of those has a camera behind it
61:32 - so that it can render what is going out
61:35 - from the portal in the direction that
61:36 - it's facing
61:37 - we're going to deviate from portal now
61:40 - and talk about pro builder and pro grids
61:43 - which are two tools that are part of the
61:44 - new unity 2018.1 which will allow us to
61:48 - actually model geometry per the
61:50 - screenshot this is actually a level that
61:52 - i created and that is in the
61:55 - distro it allow us to create geometry in
61:58 - the actual scene view without needing to
62:00 - go into a third party program like
62:02 - blender or maya and have to sort of
62:04 - alternate between the two and import and
62:06 - export you know incessantly
62:09 - not only that but as soon as you model
62:10 - something like this in unity in the
62:12 - scene view you can immediately test it
62:14 - for gameplay and make sure that it
62:15 - actually fits
62:16 - what you want and you don't have to
62:17 - worry about scale issues when you're
62:19 - importing and sort of making it work and
62:21 - figuring out ultimately that oh i don't
62:22 - like the way this mesh this level is let
62:25 - me go and tweak it and redo it
62:27 - it just allows you a ton of ease and
62:29 - flexibility and i made i previously
62:31 - mentioned brackie's before but he's got
62:33 - a couple of awesome tutorials here
62:35 - on pro builder and pro grizz to
62:36 - supplement sort of what we'll talk about
62:38 - today in lecture but if you want sort of
62:40 - more of a showcase of all the features
62:41 - of both then you can look at these
62:43 - videos here and get a sense of how they
62:45 - work so we're going to go ahead and just
62:47 - mess around with pro builder a little
62:49 - bit here in the scene view so that we
62:52 - can see what it looks like i'm going to
62:53 - open up my other scene so i have the
62:55 - portal scene if you're in the distro
62:57 - this is where all the stuff that we've
62:58 - been looking at exists just the portal
63:00 - game
63:01 - there's a pro builder scene as well
63:02 - which i'm going to not save that
63:05 - and so this
63:07 - pro builder scene
63:09 - is the level geometry that i created
63:11 - earlier now it looks pretty horrendous
63:13 - because i didn't spend a terrible amount
63:15 - of time on it and i'm not a particularly
63:17 - talented
63:19 - visual designer by any stretch let me go
63:20 - ahead and make it a little bit larger so
63:22 - we can see it a little better
63:25 - but it showcases some of the interesting
63:27 - features so we see you know we have
63:31 - obviously
63:32 - sort of polygonal square shaped
63:34 - rectangular geometry
63:36 - we can see that some faces are textured
63:38 - and some aren't so we can see this face
63:39 - here for example is just white
63:43 - the default material we can see that all
63:45 - of these sort of have this uh brick
63:47 - texture which i got off a procedural
63:49 - generator sorry website that allows you
63:51 - to choose a template for your texture
63:53 - and then you know specify colors and
63:55 - stuff like that i did the same thing for
63:57 - this texture this is another uh
63:58 - procedural texture which is kind of like
64:00 - a blue marbley type texture
64:04 - the cool thing about it is at least for
64:06 - texturing you can just choose arbitrary
64:07 - faces that you want to texture rather
64:09 - than have to texture the whole thing
64:11 - like you would do if you were to just
64:12 - give a mesh a default material it'll
64:15 - apply it to the whole mesh in this case
64:18 - it's just applying it to whatever faces
64:19 - we select in pro builder
64:21 - another interesting thing which i really
64:23 - like is pro builder gives you a lot of
64:24 - tools for creating
64:27 - special kinds of geometry very quickly
64:28 - and efficiently in this case this is a
64:30 - staircase which all i had to do was with
64:34 - pro builder select build staircase and
64:36 - then you can choose a lot of different
64:37 - parameters we'll take a look at how to
64:38 - do that in a second i did the same thing
64:40 - here so notice this this staircase has
64:42 - kind of a spiral to it and then this
64:44 - staircase is really tall but has no
64:46 - spiral and then we have another
64:48 - staircase here which is kind of shorter
64:49 - and doesn't have a spiral and then it
64:51 - ends up coming up here to this point and
64:53 - then if this were the assignment maybe
64:56 - this spot here would be where you put
64:58 - your collider that says oh this is the
65:01 - finished you know this is the levels
65:02 - conclusion you've beaten the level so
65:04 - the assignment is with pro builder so to
65:06 - make a level you know it doesn't have to
65:08 - be anything terribly fancy like i'm not
65:09 - a great designer but it should have at
65:12 - least one section where you're required
65:13 - to jump so some sort of jump puzzle just
65:16 - so that you can you know think about the
65:17 - design of your level a little bit
65:19 - and it should be you know meaningfully
65:21 - large not like it doesn't have to be
65:22 - gargantuan and it shouldn't be small it
65:25 - shouldn't be like 10 meters or you know
65:27 - not maybe not 10 meters but it shouldn't
65:29 - be like you know 10 5 meters large
65:32 - obviously that's very small it should be
65:34 - something that you would consider you
65:35 - know a somewhat sizable level using
65:38 - something of this size is is a fair
65:41 - affair metric
65:42 - so pro builder if you've installed pro
65:45 - builder so by default pro builder is not
65:47 - installed in your project you have to go
65:49 - to the asset store i don't know it's
65:51 - assessor's been a little bit slow last
65:53 - couple of days we'll see if it works
65:54 - quickly looks like it is
65:56 - so if we go to the asset store open this
65:58 - connecting again again being slow
66:01 - okay so if you search for assets and you
66:04 - look just type pro builder it will pop
66:06 - up here and notice that it says unity
66:08 - technologies anything basically that
66:09 - says unity technologies will be a free
66:12 - sort of supplement to unity that you can
66:14 - easily just import from the asset store
66:16 - now it's a little bit cramped the window
66:18 - here
66:19 - but
66:20 - and because i'm in a 720p monitor but
66:22 - you just have to click download and then
66:23 - import in order to import it into your
66:25 - project
66:27 - the distro for portal for assignment 10
66:29 - already has a pro builder and pro grids
66:31 - installed pro grids would be the exact
66:33 - same process just pro grids right here
66:36 - and when you import both of those into
66:39 - your project you'll immediately have the
66:41 - ability to go up to tools and you'll see
66:44 - pro builder and pro grids here and all
66:46 - you need to do is click on the whoops
66:48 - pro builder and then pro builder window
66:51 - and you can see here this nice little
66:53 - widget filled window pops up and you can
66:54 - also dock it here if you want to i
66:56 - actually did on accident but unity makes
66:58 - it pretty nice so you can dock your
67:01 - stuff wherever you want it to
67:03 - and there's a few different things so
67:04 - you can do new shape and a new poly
67:06 - shape
67:08 - the new shape actually gives you like
67:09 - shape templates so here i've chosen just
67:12 - cube by default and it allows you to do
67:15 - stairs prisms cylinder so i just do a
67:17 - stair for example and then we
67:19 - immediately see this like stair mesh
67:20 - here right i can generate the number of
67:23 - steps that i want just by changing the
67:24 - slider i can change the curvature if i
67:26 - want so that it's a rotating staircase
67:28 - and then i can also change how wide and
67:30 - how tall the stairs are
67:33 - and also this inner radius is like how
67:35 - deep the steps are if that makes sense
67:38 - and then
67:39 - all of these together once you finished
67:41 - you just hit build stair and it's done
67:43 - now you have a stair mesh that you can
67:44 - just put anywhere in your level and it's
67:46 - that easy to make stairs
67:50 - before i get into more of the sort of
67:52 - what makes pro builder work i'm going to
67:53 - go ahead and enable pro grids so pro
67:56 - grids is a cool feature
67:59 - it's a cool sorry add-on which will
68:01 - actually lock everything in your scene
68:03 - to a specific grid which you can
68:05 - designate based on how fine or coarse
68:08 - you want the grid to be and what that'll
68:10 - allow us to do is when i move notice
68:13 - that it's moving on the grid right it's
68:14 - not moving in continuous con like sort
68:17 - of a
68:18 - continuous motion it's actually discrete
68:20 - steps
68:21 - and the advantage of doing things this
68:23 - way is that when you're modeling your
68:25 - level or whatnot you know let's say you
68:28 - have a maybe a
68:29 - can or a
68:31 - sort of a diagram or a drawing that
68:32 - you've created you slap it on a texture
68:35 - then a flat mesh in your scene and then
68:37 - you just sort of draw your level on top
68:38 - of it everything will sort of just like
68:40 - map up nice and cleanly when you're
68:42 - creating all your your geometry and you
68:44 - can snap things together and align all
68:46 - in the same axis and it makes
68:48 - creating levels like this just a lot
68:50 - easier you don't have to worry about
68:51 - things being slightly off and then like
68:53 - missing vertices and everything sort of
68:55 - be
68:56 - looking a little bit unclean this
68:58 - ensures that everything is very clean so
69:01 - again just notice the discrete steps
69:02 - that it's moving these are all locked to
69:05 - the grid here
69:07 - and so you can change
69:09 - all the settings here as to like how
69:11 - large it is
69:12 - uh if i create a
69:15 - cube so i'm going to go ahead and create
69:17 - a new cube i'm gonna build it
69:21 - notice up here
69:23 - these four buttons are sort of like the
69:26 - modes with which we can interact with
69:27 - our cube
69:28 - and this is very similar to what you get
69:30 - in 3d software like blender maya or
69:32 - whatnot you choose vertices with the
69:35 - left mouse and you can hit shift to
69:37 - select multiple and then you can just
69:38 - move it and since i'm using pro grids
69:40 - it's snapping it to the to the grid
69:43 - right
69:44 - so if i turn off pro
69:46 - grids should just be continuous like
69:49 - that and so you can get whatever sort of
69:51 - angles you want
69:53 - um
69:55 - depending on what your your use case is
69:57 - so i'm going to hit command z
69:59 - if i click on the face mode and i click
70:01 - this face and i shift click it'll
70:03 - actually extrude it and make a new face
70:06 - and i can keep doing this uh
70:08 - sort of over and over again about to
70:09 - zoom out a little bit so i can see a
70:11 - little bit better and i extrude that
70:14 - and then i extrude that
70:17 - right starting to build up something
70:19 - right it's not beautiful but
70:22 - it's something i can extrude that again
70:26 - right
70:27 - i believe i can scale as well
70:31 - so you can build it out like that
70:34 - you can and i haven't spent a ton of
70:36 - time mastering how to use the tool and
70:37 - all the ins and outs of it but it is
70:39 - very
70:40 - i think useful
70:42 - if you're looking to get into sort of
70:44 - level design and you want to
70:46 - avoid the overhead of you know dealing
70:49 - with third-party software like blender
70:50 - or maya and having model files that
70:53 - you're sort of importing and exporting
70:55 - it can be kind of a pain
70:56 - however
70:57 - if you want to export models
71:01 - you can definitely do that so there is a
71:03 - method here forget which one it is
71:05 - offhand i think it's this one
71:08 - no it's one of these allows you to save
71:10 - the model i don't remember exactly which
71:12 - one it is
71:13 - is it this one
71:18 - the menu is a little bit cramped here so
71:20 - i'm gonna actually blow it up
71:24 - yeah yeah offhand i can't recall which
71:27 - of these allows you to actually export i
71:28 - don't have the icons memorized yet
71:30 - because it's a fairly new tool but one
71:32 - of these will allow you to actually
71:33 - export the object as fbx or obj whatever
71:37 - your software is that you end up wanting
71:39 - to
71:41 - uh
71:42 - so you can just go also go up here to
71:44 - the export
71:45 - menu which is a lot easier to see
71:47 - everything by name and you can choose
71:49 - how you want to export you can also
71:50 - export assets too for your for your game
71:52 - so you can have objects in your scene
71:54 - that pro builder will generate for you
71:55 - so you can create prefabs that way
71:58 - but then here's like obj so that you can
71:59 - export it to your
72:02 - 3d renderer 3d software of choice
72:05 - this is relevant for situations where
72:07 - for example you want to like rig and
72:09 - model and animate a mesh
72:12 - you can't do any sort of rigging in pro
72:14 - builder but you can do that in through
72:16 - other 3d software so it makes sense to
72:19 - export it that way you can also create
72:21 - the model here export it rig it and then
72:23 - re-import it if you want to
72:25 - and that's relevant
72:28 - this is a usable scene as is right now
72:29 - the lighting gets a little bit messed up
72:31 - notice here when you mess with stuff but
72:33 - that gets fixed
72:34 - there's a little sort of meter here
72:36 - where it does some calculating and by
72:38 - default it'll actually bake lighting on
72:40 - all of your objects but as is this will
72:43 - perfectly collide with with um
72:46 - with any characters that you have so i
72:47 - have a fps character i'm gonna bring
72:49 - this guy up let's go ahead and set the
72:51 - transform
72:52 - up here
72:55 - just put him in the right position
72:57 - and pro grids is like attaching that
72:59 - like sort of making that grid visible
73:01 - next to where i am and you can set the
73:02 - access for that
73:05 - currently i have it actually disabled so
73:07 - if i enable it now
73:09 - this will actually move in increments
73:11 - see
73:12 - and it will snap it to the grid
73:13 - perfectly
73:15 - but
73:16 - now this as soon as i hit play i'm
73:18 - actually going to close this
73:21 - i should just be on this mesh up here
73:24 - yep
73:26 - and so this is just part of the scene
73:27 - now like as if you had made it in
73:29 - blender or maya or whatever i should
73:31 - jump down to my actual level
73:33 - and then explore it a little bit this is
73:35 - all just
73:36 - haphazardly
73:38 - created you know oops stairs and
73:42 - other meshes and stuff
73:45 - and so you know make it all the way to
73:46 - the top oh i fell down
73:49 - i'm also horrible at playing games but
73:51 - this is the you know the beauty of it is
73:54 - you can just play it instantly right
73:56 - um
73:57 - right out the gate
73:58 - now another cool thing uh that i'd like
74:01 - to showcase is
74:02 - we talked about gray boxing earlier um
74:05 - for making interior levels gray boxing
74:07 - is the purpose of making levels and
74:08 - testing for playability um the cool
74:10 - thing about pro builder is that it has a
74:14 - an invert normals feature which i think
74:16 - is just
74:18 - general in like generally accessible in
74:20 - 3d software
74:23 - i don't know off hand which menu it's in
74:27 - actions geometry
74:31 - do you have the right things selected
74:32 - all right i'm going to open up the pro
74:33 - tool pro builder
74:35 - window
74:36 - and then one of these is invert
74:42 - uh
74:43 - invert selection
74:45 - uh sorry wait
74:49 - flip normals there we go
74:51 - and so what this does is now this is an
74:53 - interior level
74:55 - so all we did before was you we made a
74:57 - sort of like
74:59 - polygonal
75:00 - creation
75:01 - of arbitrary
75:03 - you know size and shape if you invert
75:05 - the normal so recall every like 3d
75:07 - polygon 3d surface as a normal and
75:09 - whatever direction that's facing
75:11 - going the opposite way going towards
75:13 - that normal is what gets rendered but
75:15 - behind it if you're going in the
75:16 - opposite direction of the surface normal
75:18 - it's invisible
75:19 - and so the effect of that is if we flip
75:22 - all the normals of something that is
75:23 - convex
75:24 - we get an interior scene and if we're
75:26 - looking at it from the outside it looks
75:28 - a little bit weird right like we can see
75:29 - into it
75:31 - right and this is something that you
75:32 - might see like in minecraft for example
75:34 - when you're looking in part of the
75:35 - geometry that you shouldn't be able to
75:36 - see you can you can clip through the
75:38 - world and see all the other like
75:40 - interior parts of the world
75:42 - um because you've basically gone beyond
75:45 - the surface normal of that polygon and
75:47 - uh you're only seeing the the from that
75:50 - perspective all the the surface normals
75:53 - of polygons that are facing in your
75:54 - direction in that way but often you'll
75:57 - allow you to look straight through all
75:58 - of the other sort of uh cubes that are
76:01 - along the way because you're looking at
76:02 - all the rear of their the inverse of
76:05 - their surface normal you're looking in
76:06 - that direction
76:07 - and so again only one direction can a
76:10 - polygon be lit at once and even if we
76:13 - look at it from the top you can see that
76:14 - as well we're looking at it from the top
76:16 - flip the normals
76:18 - it becomes a sort of concave or a convex
76:22 - 3d object flip them now it's an interior
76:24 - level right so i'm actually going to go
76:28 - into this
76:29 - and i'm going to flip the normals again
76:30 - i'm going to click on this
76:33 - uh oh i would have to click on a lot of
76:35 - these actually because it
76:37 - split up the mesh
76:39 - but it's gonna be easy enough i'm
76:41 - clicking all the top surfaces of this
76:43 - and making sure i didn't get any on the
76:44 - other side on accident i did not
76:46 - i'm going to extrude this
76:50 - and then i'm going to flip all the
76:51 - normals
76:52 - and then i'm going to take my fps
76:54 - controller
76:55 - which is here and actually i think it's
76:57 - already inside which it is i'm going to
76:59 - hit play
77:00 - the lighting i'm not sure if it'll be
77:02 - messed up
77:04 - it is messed up because in the middle of
77:06 - calculating a bunch of stuff but now
77:07 - i've created an interior level right
77:09 - with the weird mesh that i had before
77:11 - and so if you make your if you sort of
77:13 - make the building of your level sort of
77:16 - you know this concave thing
77:18 - and then you flip all the normals you
77:20 - can create an interior scene very easily
77:22 - with ceiling and everything else
77:23 - normally otherwise it would be kind of a
77:25 - pain in the butt but makes it super easy
77:27 - to do with pro builder and there's a lot
77:30 - of other features
77:32 - a material editor for one so with the
77:34 - material editor you can actually
77:36 - designate specific materials so in this
77:38 - case i've created a couple of materials
77:39 - a brick texture here and a marble
77:42 - texture which is just i took some
77:43 - textures created material
77:45 - made the albedo component of those
77:47 - materials that texture
77:49 - and what that allows me to do is i can
77:51 - select an arbitrary face so in this case
77:53 - i'm going to choose these faces
77:55 - and i can just click on this brick
77:57 - texture
77:58 - and now these are textured as that brick
78:01 - right it's not applying it to the entire
78:03 - mesh it's just applying it to whatever
78:04 - specific face that we want to and
78:07 - there's a uv editor which will allow you
78:08 - to actually take the mesh of your model
78:12 - in this case this is this is our entire
78:14 - mesh here just remember as we talked
78:16 - about it last week everything gets cut
78:18 - out and made flat so you can sort of see
78:21 - if you remember the shape of what we're
78:22 - dealing with all the polygons that we
78:24 - were
78:28 - that comprised our sort of weird large
78:31 - object they're all now splayed out for
78:33 - us so we can just very easily
78:36 - take a texture and just like put it
78:38 - wherever we want
78:39 - on here now i don't have a
78:43 - ton of
78:44 - experience using this so i'm not 100
78:47 - confident my ability to uv map something
78:49 - right now in front of you but
78:51 - uh
78:52 - the documentation on the pro builder
78:54 - website goes into detail as to how to
78:56 - use this so if you wanted say
78:58 - a specific texture to be like in part of
79:00 - the mesh and then maybe another texture
79:02 - to be on another part of it in a
79:04 - specific like welded way that's not like
79:06 - just splat onto it
79:08 - the uv editor will help you with that
79:10 - for example a face on a character model
79:12 - or something else
79:15 - but yeah or maybe like a sign on a door
79:17 - somewhere or something like that you can
79:19 - do that all here just click and drag all
79:22 - the faces the faces are actually
79:23 - interdependent like dependent from one
79:25 - another so that you can lay them out in
79:27 - a way that fits the texture that you are
79:29 - trying to map everything to
79:32 - that is um
79:34 - pro builder in a nutshell there's a lot
79:36 - of features um we don't have time to
79:38 - cover
79:39 - all of them and i mean frankly i don't
79:42 - know all of them super well yet um just
79:44 - because the technology is so new but
79:46 - it's
79:47 - i think this is going to be a huge part
79:49 - of like unity's future and like making
79:50 - it accessible for people that would
79:52 - otherwise have maybe been turned off by
79:54 - the idea of modeling their level
79:56 - geometry or their object geometry um i
79:58 - mean certainly for me now this this just
80:00 - makes me want to make a game in unity
80:02 - like right now just because i know i can
80:04 - instantly just like start creating my
80:05 - levels right like it's just nice and
80:07 - easy and convenient and pro grids you
80:09 - should use definitely use pro grids in
80:11 - tandem with pro builders so that you can
80:13 - optimally rearrange things in a way such
80:16 - that they're all like evenly lined up
80:18 - with each other
80:20 - otherwise you're going to end up with
80:22 - issues in like manipulating their
80:24 - position in a very specific way and like
80:26 - coming up here and setting their values
80:27 - manually and that's just kind of a pain
80:29 - so much easier just to snap everything
80:31 - to the grid the pro pro grids
80:33 - and
80:34 - deal with it that way and so the
80:37 - assignment is yeah largely just going to
80:40 - be
80:40 - take the
80:44 - pro take pro builder and pro grades and
80:45 - just like make a level with it and then
80:47 - just like take the principles that we've
80:48 - learned create a controller create a
80:51 - collider and just make a very simple
80:53 - scene
80:53 - um
80:55 - and otherwise probably spend your time
80:57 - focused on your final project
81:00 - so any questions as to pro builder how
81:02 - it works how to get it set up
81:13 - uh no it'll actually it'll it should
81:15 - flip through it um
81:17 - let me
81:19 - go ahead and put this up here it
81:21 - actually actually it might not i think
81:23 - it does still trigger collision but
81:25 - you'll still you'll just be able to walk
81:26 - you'll just be able to see through the
81:28 - um
81:30 - through the
81:32 - yeah just a visual it's just a visual
81:34 - bug it's a lighting bug the physics
81:36 - should still apply i'm going to go ahead
81:37 - and set the
81:39 - model up here
81:44 - okay hit play
81:50 - uh no actually look like it went through
81:52 - it so i think it so it also inverts the
81:56 - collision the collision box yeah
81:59 - i've seen some games where you can
82:02 - clip through something and still collide
82:04 - with it
82:05 - so i think it depends on ultimately the
82:07 - engine or the implementation that you're
82:08 - using but in this case
82:11 - when you flip the surface normals here
82:13 - of this mesh it also flips the box
82:15 - collider the mesh colliders normals yeah
82:27 - precisely yeah if you wanted you could
82:29 - have a you could make a copy of the
82:31 - um interior make it you'd have to make
82:33 - it you make it the same size i suppose
82:36 - um and then flip it's and not flip its
82:38 - normals such that you have a shell and
82:40 - an interior yeah absolutely
82:43 - um yeah generally i don't think you
82:45 - would i mean yeah it depends if a lot of
82:47 - interior levels you'll never ever be
82:49 - outside of their boundaries and so you
82:51 - don't often see that happening but it's
82:54 - very much the case that you could have
82:55 - that happening and if you have like a
82:56 - house model for example then yeah you'll
82:58 - often you'll actually see house models
83:00 - are modeled with walls that are two
83:02 - planes so there's a bit of thickness
83:05 - it's actually a rectangular
83:07 - shape so it allows you to have a
83:10 - collision on one side and another side
83:13 - because both there's two planes of
83:17 - the collider rather than just the single
83:19 - plane which is the direction of the
83:21 - surface normal
83:23 - any further questions on pro builder
83:25 - yeah
83:31 - because the bottom surface normal is
83:32 - pointed upwards so this this right here
83:34 - is pointed upwards but notice that here
83:37 - the surface normal is actually pointed
83:38 - down
83:40 - so you can only collide with the
83:41 - direction of the surface normal that's
83:43 - facing
83:44 - you
83:45 - if that makes sense you can walk you can
83:47 - walk through
83:48 - you can walk towards the direction of
83:50 - the surface normal but not
83:51 - like against the surface normal if that
83:53 - makes sense that's the way that unity
83:55 - calculates its mesh renderer component
84:05 - you could go through from this direction
84:08 - but you could not go through this
84:09 - direction
84:11 - because this direction the surface
84:12 - normal is pointed this way right
84:15 - so if we try to walk against it we'll be
84:16 - walking against the normal and so we
84:18 - won't be able to uh we won't we'll we
84:20 - will trigger a collision but if you're
84:22 - walking through it and such that you're
84:23 - going the same direction as the surface
84:25 - normal so if you're coming from this
84:27 - direction
84:28 - then it won't detect a collision
84:30 - does that make sense yeah
84:32 - yeah
84:33 - what tawny suggested which was to make a
84:35 - shell around it would solve that problem
84:37 - so if we created this this exact mesh
84:39 - duplicated it and then inverted it then
84:42 - we would have two of the same object but
84:44 - with normals going one direction and
84:46 - normal's going the other direction such
84:47 - that the mesh renderers
84:49 - account for both potential movement
84:51 - directions
84:53 - cool
84:54 - all right any further questions on
84:57 - pro builder again not to meant to be a
84:58 - comprehensive tutorial there's videos
85:01 - um
85:02 - and documentation that i've linked to in
85:04 - the slides but more just to illustrate
85:07 - how awesome this tool is really and that
85:09 - this is probably going to save some
85:11 - people doing unity projects sometime if
85:13 - you're doing any unity
85:15 - like if you're doing any asset modeling
85:17 - i should say or level modeling
85:20 - another thing that
85:23 - we didn't i didn't make a slide for but
85:25 - which i talked about in class
85:27 - was shader graph and so what shader
85:29 - graph is is another
85:32 - 2018.1 feature which allows
85:35 - rather than having to write shaders in
85:38 - shader lab which is unity's shader
85:40 - language
85:41 - which can be quite
85:43 - quite an experience quite intimidating
85:46 - you can actually create them now with
85:48 - this node-based programming language not
85:51 - really programming language but this
85:52 - node-based programming environment i
85:54 - should say
85:55 - which will allow you to choose all these
85:57 - preset nodes that influence the shader's
85:59 - behavior
86:01 - and there's a lot of different kinds
86:03 - and have the result of that
86:06 - be you can see your shader every step of
86:08 - the way so the shader is just a series
86:10 - of transformations going from left to
86:12 - right
86:13 - in one direction
86:15 - all of these sort of transformations you
86:17 - can see how they end up accumulating to
86:20 - produce this final effect in which case
86:22 - here
86:23 - if it may be kind of hard
86:24 - hard to discern is a sort of marine guy
86:28 - with these blue holes that are actually
86:30 - like masking his mesh and we talked
86:32 - about masking earlier this shader itself
86:34 - looks like it's applying a mask with
86:36 - this
86:38 - noise that it's generating and it comes
86:40 - with noise generation functions
86:42 - generation nodes which will allow you to
86:44 - feed those into sort of like the mass
86:46 - component of your shader and then
86:47 - produce some very interesting cool
86:48 - effects otherwise this would be
86:51 - kind of uh
86:52 - unless you're like a shader expert which
86:54 - i am not it would be um
86:57 - pretty complicated and non-trivial to
86:58 - implement something like this with just
87:00 - code but this generates code for you
87:02 - such that you don't have to actually
87:06 - write any code at all but you can still
87:07 - see the produced shader that gets
87:08 - created for you from shader lab or
87:10 - shader graph
87:12 - i
87:13 - believe that it's just a
87:15 - asset now i'm not 100 sure i didn't test
87:17 - this going in um
87:25 - hopefully i'm not just missing it
87:28 - supposedly you should be able to just
87:29 - import it
87:30 - i'm not 100 let's see how you actually
87:32 - is it this article maybe uses it
87:36 - via the package manager
87:39 - package manager i think this is a new
87:41 - window package manager so we go to
87:43 - window and then package manager
87:51 - and then
87:52 - all
87:56 - and then shader graph yep so right here
87:58 - so window and then package manager and
88:00 - then shader graph and that will allow
88:02 - you to
88:04 - import
88:05 - the
88:06 - means to which by which to create these
88:09 - sort of graph layouts
88:11 - if you're using 2018.1 which the course
88:13 - is using but if you're at home and
88:15 - you're using 2017.4
88:18 - then
88:20 - update to 2018.1 and you should see this
88:22 - in your package manager
88:24 - and then once you do that you can create
88:25 - a you can actually create a new shader
88:27 - graph object and then you'll see it as a
88:29 - new window that pops up in your scene
88:31 - and then you can start adding nodes
88:33 - i don't have any material prepared for
88:35 - it and i didn't anticipate talking about
88:37 - it necessarily but it's
88:39 - something that seems to be very game
88:41 - changing and something unreal has had
88:43 - for a long time that sort of
88:44 - differentiated it from unity in my
88:45 - opinion
88:46 - and it's i think a very valuable thing
88:49 - that they've added
88:50 - that shows a lot of awesome progress for
88:53 - 2018.
88:55 - so again a link to brackie's if you want
88:58 - details on how to use not only pro
89:01 - builders and pro
89:02 - pro builder and pro grids but a lot of
89:03 - other awesome features of unity and to
89:05 - do a lot of cool stuff he makes some
89:07 - really cool videos
89:08 - um assignment 10
89:10 - so assignment 10 is going to be creating
89:12 - a level with pro builder just to get
89:14 - your hands wet with it um
89:16 - the level should be
89:17 - pretty complex so not like i said
89:19 - earlier not like
89:21 - a finished game level like i'm not
89:24 - expecting you to do awesome amazing
89:26 - incredible things but a level that has
89:28 - maybe you know a few pieces of
89:30 - interesting geometry maybe generate some
89:32 - stairs generate some it has some pipes
89:34 - you can generate and some other things
89:36 - um have a jumping puzzle in there so
89:40 - this this says there should be one
89:41 - jumping puzzle for the player the
89:42 - assignment doesn't officially say it yet
89:44 - but i'm going to make the change to make
89:46 - it say that there should be a jumping
89:47 - puzzle you can interpret this however
89:48 - you want
89:49 - just a couple platforms is fine but
89:52 - honestly whatever whatever you would
89:53 - like
89:55 - um and have two different textures or
89:57 - materials so you can create just an easy
90:00 - pers like just import whatever texture
90:01 - you want or you can go to a website that
90:03 - allows you to procedurally create a
90:05 - texture and
90:07 - you can assign it to a material put it
90:08 - in the material editor of pro builder
90:10 - and then use that to assign it to a face
90:12 - or to the whole object if you want to
90:15 - but it should be at least two not the
90:17 - default so to make it a little
90:18 - interesting use many more if you want to
90:20 - but only two required
90:22 - um
90:23 - so there this should be kind of like a
90:25 - complete scene so
90:27 - uh make a new scene separate from the
90:29 - pro builder scene separate from the
90:30 - portal scene
90:31 - include an fps controller so that we can
90:34 - move around the scene immediately after
90:36 - creating the mesh right
90:39 - but that's it you can just use the
90:40 - default controller you don't need to do
90:41 - anything fancy and then at the very end
90:44 - you should have a trigger on a collider
90:46 - somewhere which should probably it can
90:47 - be invisible it doesn't have to be
90:48 - invisible you can make this whatever you
90:50 - want you can make like an arch or
90:52 - i don't know your imagination is uh
90:55 - you're free to use your imagination as
90:56 - much as you want but there needs to be
90:58 - some collider
90:59 - whether it's invisible or not at the
91:01 - very end and a trigger it needs to be a
91:03 - trigger and then when you collide with
91:05 - it it should say level complete on the
91:07 - screen so just take a text object from
91:09 - unity2d part of the canvas and just drag
91:12 - it if you just add a ui text in the
91:15 - scene it'll automatically add a canvas
91:16 - and an event system for you
91:19 - create the label and then just set it to
91:21 - on or off depending on whether or not
91:23 - you've collided with the trigger there's
91:24 - code for this in the helicopter game in
91:27 - the game over text script you can see
91:30 - exactly how this is done um all it
91:32 - effectively is is setting the color of
91:34 - the text to zero zero zero zero versus
91:36 - zero zero zero one or whatever color you
91:38 - want to effectively just to change on
91:40 - the alpha component of the text color um
91:43 - and then once that's done then you have
91:45 - a complete assignment and then you can
91:46 - spend more energy hopefully this should
91:48 - only take maybe an hour maybe less
91:51 - you can spend more energy on your final
91:53 - project which will be due on the 11th
91:57 - but all together it's been an awesome
91:58 - pleasure teaching this course and i'm i
92:01 - hope that a lot of you were able to
92:02 - learn a lot of interesting things and
92:03 - hopefully we're inspired to create some
92:05 - of your own projects and we'll continue
92:07 - to create some of your own projects in
92:08 - the future um
92:10 - i certainly enjoyed making a lot of the
92:12 - stuff and i especially super mario
92:13 - brothers i think that was my favorite um
92:15 - but this was
92:17 - gd 50. so thank you so much