00:06 - everyone my name is pavel and welcome to
00:09 - the talk about
00:10 - how to design a good api what to look
00:13 - into specific
00:15 - so
00:16 - few words about me i'm a programmer
00:18 - since more or less nine years
00:20 - commercially i was working at
00:23 - well first telecom then logistics
00:25 - industry then i think banking car
00:27 - factory and currently in a polish
00:29 - software house previous software
00:32 - and indirectly say in a travel industry
00:35 - for a client
00:37 - so the agenda of this talk will look
00:39 - more or less like an rpg party who of
00:42 - you likes roleplaying games
00:45 - there are some people okay cool
00:47 - so first
00:48 - we'll look at things from
00:50 - let's say distant perspective to looks
00:53 - look what's what's going on in general
00:56 - and then we will be looking from the
00:58 - perspective of three wizards from the
01:00 - ivory tower so just a little bit theory
01:02 - to to give you some insights
01:04 - and some bases
01:06 - then we'll get to business so there will
01:08 - be this this dwarf who is hacking orcs
01:11 - and goblins and doing the action is
01:13 - doing the actual business job
01:15 - uh what we get money from and behind
01:18 - this
01:19 - dwarf there is usually the cleric who is
01:21 - buffing him and hitting him and
01:24 - there will be talking about things that
01:25 - are that are kind kind of orthogonal to
01:28 - this business perspective but
01:30 - nevertheless important
01:32 - so let's begin
01:33 - there was a guy in the marketing by the
01:35 - name of simon sinek and he wrote a book
01:38 - start with why and indeed when we are
01:40 - going on some kind of business or
01:42 - otherwise adventure we need to think
01:44 - about three questions
01:47 - why are we doing something what are we
01:49 - actually doing and how to do this so the
01:51 - most important question is why so let's
01:53 - look into that
01:55 - why the answer is of course simple for
01:57 - money
01:58 - so basically how how do we earn money on
02:01 - web applications there was usually in
02:03 - the past there was some kind of front
02:05 - end
02:05 - business logic probably database users
02:08 - were clicking doing some stuff they need
02:10 - to and we earn on that
02:13 - as time passes user
02:16 - needs of users grow so they require
02:18 - additional features and it didn't really
02:20 - make sense to do all those features in
02:23 - our system for example if you are
02:25 - it's a travel company and you want to
02:27 - display a map it's not the best idea to
02:29 - just jump into the car start driving
02:31 - around the city and doing pictures of
02:35 - of stuff so that people can see this on
02:37 - our website it's better idea to connect
02:39 - to some api for example google maps
02:42 - so
02:43 - as time passes further our system grew
02:46 - larger
02:47 - more valuable especially our data were
02:49 - more precious so it's good idea to open
02:51 - an additional revenue stream and create
02:54 - an external api so that someone else can
02:57 - connect to us use our data and pay us
02:59 - for that
03:01 - so that's what we'll be more or less
03:03 - talking about today so an external web
03:05 - api what is this well it's kind of
03:07 - simple it's just a set of end points
03:10 - with which we can
03:11 - talk using a specified set of messages
03:14 - requests and responses
03:17 - and how to do this well that would be
03:19 - the objective of the talk but uh in
03:21 - general there is an observation that
03:24 - although we are talking about machine
03:26 - talking to the machine
03:27 - there are people behind those machines
03:29 - of developers programmers
03:31 - and web api is kind of like
03:33 - graphical user interface to the
03:35 - programmer it's like user interface to
03:38 - the programmer similarly as graphical
03:40 - user interface is to regular people who
03:42 - just click stuff on the web
03:44 - so there was
03:45 - a lot of
03:46 - things were said uh in the realm of how
03:48 - to design a good graphical user
03:50 - interface and we can actually leverage
03:53 - some of that knowledge in designing web
03:55 - api
03:57 - so the
03:58 - two
03:59 - important traits of people is let's say
04:02 - laziness and intuition so we are all
04:04 - lazy we want to do stuff
04:06 - as easy as possible and as fast as
04:08 - possible and we have intuition so we
04:10 - have some
04:11 - idea how stuff works some standards so
04:14 - experiences
04:15 - and if we confront to that
04:17 - well it's it will be good for us in
04:19 - general
04:21 - so that was a quick introduction then
04:24 - free wizards
04:26 - so just a little bit of theory
04:28 - uh who recognizes peter morviel
04:32 - nobody
04:33 - oh there is one person cool so
04:36 - the guy from design basically and he
04:38 - wrote an article
04:39 - 10 years ago or so maybe even a bit more
04:43 - where he pointed out the six important
04:45 - traits of good product design
04:48 - so those traits are in general that
04:50 - product should be useful so we should be
04:52 - able to do the the business stuff that
04:53 - we want to to do
04:55 - the reason for for which we bought the
04:57 - product in the first place
04:59 - it should be usable so it should be easy
05:01 - to do this it should be intuitive
05:04 - it should be desirable so
05:06 - you are happy with the product for
05:07 - example if you are developers acting on
05:09 - an api the api has a nice documentation
05:11 - and always works and
05:14 - well
05:16 - we desire this let's say
05:18 - it should be findable so
05:20 - it should be easy to find the stuff that
05:21 - we want to do for example api is not
05:23 - buried under some
05:25 - a lot of slashes and long urls it's
05:28 - somewhere close to the top domain of of
05:30 - the
05:31 - of the company its own slot
05:33 - uh it should be
05:35 - accessible originally in the article it
05:38 - was about the products used by people
05:40 - with some kind of disability for example
05:42 - let's say blind people it's nice
05:44 - is a product then talks to them or it's
05:46 - possible to
05:48 - touch the product and for example read
05:50 - braille characters uh in case of api an
05:53 - example would be
05:55 - we are disabled because we are sitting
05:57 - behind a proxy that only grants
05:59 - only oppresses the
06:01 - get requests and we want to do a post
06:04 - request or put request and how to deal
06:06 - with that i will be talking about this
06:07 - later
06:08 - and
06:10 - and it should be credible meaning well
06:12 - every product should be credible it
06:14 - shouldn't break but if it breaks
06:16 - the
06:18 - the producer of the product shouldn't
06:20 - leave us alone with that so in case of
06:22 - api you know of course sometimes stuff
06:24 - breaks we get 500 from the server but
06:26 - it's also nice if if the
06:29 - api provider gives us more information
06:31 - about how to deal with this problem and
06:34 - that would be another chapter in our
06:35 - story
06:37 - the second wizard roy fielding anyone
06:40 - familiar with roy fielding
06:43 - okay there are some people
06:46 - anyone actually read the fielding phd
06:48 - dissertation
06:50 - okay oh nice
06:52 - uh so refuelling this is a guy who's
06:55 - who's involved in the
06:58 - i'd say
06:59 - standardization of http and uri
07:02 - and in 2000 he wrote a ph.d 13 defended
07:06 - phd dissertations
07:08 - where he defined the rest architecture
07:10 - so basically
07:12 - if someone asks you what is actually
07:14 - rest because we heard this a lot of time
07:16 - but
07:17 - if we
07:18 - think a bit deeper about what it is so
07:20 - it's not a protocol it's not technology
07:22 - it's not not really a standard it's an
07:25 - architectural style
07:27 - and it was
07:29 - basically the thesis is about
07:31 - properties how we can assess web
07:33 - architectures there are several web
07:35 - architectures in the assessment and then
07:37 - there is this rest so representational
07:39 - state transfer
07:41 - and what's the idea
07:43 - there are those
07:44 - six principles
07:46 - first client server so we have separate
07:49 - client and server originally it was more
07:51 - of a
07:52 - front end and back end but it's not
07:53 - really the case anymore so we can
07:55 - develop them independently
07:58 - we have statelessness so
07:59 - basically each request has enough
08:01 - information to be processed without
08:03 - storing some kind of inside state
08:05 - because if the machine dies then we lose
08:08 - the state we can send the request to
08:10 - another machine and if we have
08:11 - everything with the request that we need
08:13 - to do we are good
08:16 - but there comes a problem we need to
08:18 - send more data so there is a principle
08:20 - of cachability so every response and
08:22 - from the server
08:24 - basically tell us on what condition we
08:26 - can store it and to use later
08:28 - so then we can save a bit on bandwidth
08:31 - and computing power on both sides
08:32 - basically
08:33 - uh layered system is about
08:35 - that we can in let's say inject some
08:38 - kind of layer between client and server
08:40 - and it should be basically
08:43 - transparent to the client
08:46 - inform interfaces
08:47 - more or less about that
08:49 - our addresses our naming schemes should
08:52 - be consistent and we should use http
08:54 - semantics so
08:56 - methods
08:57 - status codes and standard headers
09:00 - and code of demand is that's an optional
09:03 - requirement but the idea is that we can
09:05 - from the server we can send some
09:06 - executable code that can be invoked by
09:08 - the client and those extend
09:11 - its capabilities
09:12 - so that's briefly about rest
09:16 - learner t-shirts on anyone
09:19 - yep
09:21 - so just quickly oh no richardson i
09:23 - created
09:24 - i think 20 or 10 years ago or so on the
09:26 - qcon talk he defined the levels of how
09:29 - restful the architecture is and just the
09:31 - results of model
09:33 - you might have heard and the idea is
09:35 - that well at the level zero
09:38 - we have this swamp of plain old xml so
09:41 - we have and one endpoint to which we
09:43 - sent on xml file which basically says
09:45 - what has to be done
09:46 - then the level two is resources so
09:48 - entities in our system
09:50 - have different endpoints and
09:53 - if we have people cars groups or
09:56 - whatever they have separate endpoints
09:58 - and we can work on that
10:00 - the next level is usage of http verbs so
10:03 - no longer we have to wonder
10:05 - should i invoke delete cars or maybe
10:08 - remove cars i don't know we just go to
10:10 - cars and use the delete method
10:13 - and the last level is hyper media
10:15 - control
10:16 - also known as haitos this beautiful
10:18 - acronym in our
10:20 - i.t
10:21 - so basically we add links to our
10:23 - responses that can lead us to related
10:26 - resources
10:28 - okay those were
10:30 - those those was a bit of theory now
10:32 - practice so
10:34 - the business stuff
10:35 - about we talk about resources naming
10:38 - relations between resources
10:40 - the behavior of particular http methods
10:44 - depending whether we have collection or
10:46 - single objects
10:48 - about functions because you know rest is
10:50 - about nouns so how to deal with
10:52 - functions then
10:53 - how to parameterize requests so that we
10:55 - can operate efficiently on collections
10:57 - and how to handle status and as it
11:00 - sometimes happens errors
11:03 - so quickly resources the centric focus
11:06 - point of rest nouns plural forms so that
11:09 - we have cars which is a collection of
11:11 - cars and we can have cars slash id which
11:14 - is a particular car
11:16 - uh
11:17 - it's good to remember about not sharing
11:19 - technical details in url so for example
11:22 - if you have apache server that's great
11:23 - but do not put it in the url just keep
11:26 - it clean and simple as possible
11:28 - about naming
11:29 - there was this ancient war between camel
11:32 - case and snake case
11:34 - and actually now we have
11:35 - a
11:37 - kind of a bit popular new style hyphen
11:40 - case also known as kebab case because
11:42 - you have like this piece of meat on the
11:43 - stick then you have wars with high pens
11:46 - and basically the old war was between
11:48 - commerce and snake you know camel people
11:50 - from javascript say hey we have json we
11:53 - like json so json is javascript so camel
11:56 - case makes sense on the other hand hand
11:58 - snake case well they say it's a bit more
12:00 - readable because words are a bit far
12:03 - apart from each other looks better
12:05 - hyphen case actually there's one problem
12:07 - with hyphen case because if you
12:09 - run this through some automatic
12:11 - automating frameworks that matches the
12:13 - name of property with the objects or the
12:17 - the object itself then you can run to
12:18 - the problem that there is a minus sign
12:20 - basically and that's a operator in
12:22 - programming language so it looks cool
12:25 - in a content that is consumable by
12:27 - people like you have a blog you have new
12:30 - article there's a few words in the title
12:32 - so your wordpress generates a nice link
12:34 - with hyphens in between and it looks
12:36 - good but in api
12:38 - maybe not the best idea
12:40 - personally i think i prefer camo case
12:42 - because i'm from java but yeah anyway
12:44 - whichever you choose just try to stay
12:46 - consistent not like
12:48 - some standard libraries for some
12:50 - languages that makes cases
12:53 - not the best idea so we have resources
12:55 - now we have relations between those
12:56 - resources
12:58 - so how to model that
12:59 - basically if the resource resources are
13:01 - independent they can exist
13:03 - independently for example we have people
13:06 - and we have groups well people can live
13:08 - without groups groups can formally be
13:11 - without people
13:12 - then group membership is another
13:13 - resource so basically it can be created
13:16 - deleted or manipulated
13:18 - on the other hand if we have resource
13:20 - that depends on another
13:22 - say we have a building and room in a
13:24 - building if the building collapses then
13:26 - the room is probably not too good either
13:29 - in this case we can model that
13:31 - in this character that first is building
13:33 - an id of the building
13:35 - then there's rooms and
13:37 - id of the room
13:39 - behavior of http methods so what to do
13:42 - when we get http verb depending on
13:44 - whether that's a collection or object
13:47 - so basically we've got it's kind of
13:49 - simple
13:49 - you just return the collection or the
13:51 - object of course if the collection is
13:52 - big
13:53 - we need to somehow
13:55 - limit that
13:57 - with post it's kind of tricky
14:00 - if you post on a collection that means
14:02 - hey there's an object i want to put it
14:04 - in the collection i don't know the idea
14:05 - of that so just figure it out and let me
14:08 - know
14:08 - uh if you do a post on an object it used
14:11 - to be a partially modification of the
14:13 - objects but then we have this new method
14:16 - not that new anymore patch in http so
14:19 - it's basically no longer
14:20 - used i think in that context
14:23 - we've put
14:24 - logic would dictate that if you put a
14:26 - collection you just replace the existing
14:28 - collection but it's again not usually
14:30 - the case we want we probably want to
14:33 - just append the collection it's good to
14:35 - market documentation somehow
14:38 - and if we do a put
14:40 - a single object we are replacing it and
14:42 - here's the question what to do if the
14:44 - object doesn't exist yet well we can
14:47 - allow to
14:48 - put new objects with a given id so doing
14:51 - put on an object it doesn't exist say
14:54 - says hey there's an object please put it
14:56 - under this id i'm providing you
14:58 - it's a bit tricky because if you let
15:00 - somebody outside of your system
15:02 - create ids for your entities you might
15:04 - be in trouble unless you have some kind
15:06 - of good validation or just allow
15:09 - this to be done from internal services
15:12 - so we have to be careful with that
15:14 - and delete
15:15 - pretty simple these entire collection of
15:18 - course that is
15:19 - risky so should be controlled
15:22 - in appropriate manner
15:23 - and deleting single item this is the
15:25 - item
15:26 - and like the newest method patch patch
15:28 - eye collection
15:30 - i think doesn't really makes a lot of
15:31 - sense
15:32 - but part on a single object
15:36 - changes a small
15:38 - say part of it
15:41 - okay we have behavior now let's move to
15:43 - function so
15:45 - we have this noun centric system and
15:48 - what to do if something a piece appears
15:50 - to be a function
15:52 - well
15:53 - first we can treat it as
15:56 - patching some other resource for example
15:58 - there is let's say we bought a ticket
16:00 - for a train and now we want to cancel it
16:02 - how to do this where we can patch the
16:04 - state of the ticket and change its state
16:07 - to cancel or something but it might not
16:08 - be always the best idea
16:10 - uh sometimes invoking a function
16:13 - is kind of related with creating a
16:15 - resource so we can here think okay i've
16:17 - created a constellation object which
16:19 - also can
16:20 - have some additional data to it
16:23 - otherwise
16:24 - or if you don't have really good idea
16:26 - how to do this we can just bend the
16:27 - rules and if it makes sense go with that
16:30 - don't be too dogmatic all the time
16:33 - okay
16:34 - parameters so just quickly reminder on
16:36 - how to
16:37 - how can you parameterize requests
16:39 - you can put something in a path it's not
16:41 - really exactly a parameter because if we
16:43 - say cars slash id it's not a parameter
16:46 - it's just a name of this particular car
16:49 - if we operate on collection as well
16:51 - usually we go with queries of everything
16:53 - after the question mark
16:54 - that is optional
16:57 - if you want to separate ourselves from
16:59 - the let's say business services api we
17:01 - can go with headers or even deepen with
17:03 - custom headers
17:05 - and sometimes it makes sense to send
17:07 - data in just in the body of the request
17:09 - one quick note
17:12 - i encountered the idea that if you if
17:14 - you use some parameters that are kind of
17:17 - meta or platform related or very general
17:21 - they might be
17:22 - named with underscore at the beginning
17:24 - and it says be careful with that
17:27 - so that's something that we can also use
17:30 - so collections search in a collection
17:34 - the simplest idea is just
17:36 - use equal operators so you want people
17:38 - that are of age 27 so h equals 27 simple
17:42 - what about if you want someone older or
17:44 - younger well we can have operator for
17:46 - that so for example less than greater
17:49 - than than some kind of delimiter and the
17:51 - value we are comparing against
17:53 - we can combine the
17:55 - property we are comparing against with
17:57 - with the operator in one single name so
18:00 - if we are looking for an arnold
18:02 - we can use name like sword
18:04 - for example
18:06 - and okay we found
18:09 - objects so now how to look into those
18:11 - objects maybe we are interesting only in
18:14 - a subset of fields so we can list the
18:15 - subset of fields on the other hand maybe
18:18 - object has just one big fit we are not
18:20 - yet interesting in maybe there is an
18:22 - outer with large biography and just few
18:25 - other short fields
18:27 - then we can just exclude some things and
18:29 - we can define
18:30 - several styles of object like small
18:33 - medium full something like that and let
18:35 - users deal with that
18:38 - we found something now it's a good idea
18:40 - to sort what we found
18:43 - so we can just specify one property by
18:46 - which we are sorting with some default
18:47 - order we can add a prefix or suffix that
18:51 - determines the order of the searching
18:53 - of the sorting then we can list
18:56 - properties then list properties that
18:59 - should be ascending and those that
19:00 - should be descending
19:02 - or we can just for each property we have
19:04 - a mirror property that selects a
19:07 - direction of the sort personally i like
19:09 - this short version with just simple one
19:12 - character to determine the order of the
19:14 - sword
19:16 - next operation on collections
19:18 - pagination so
19:20 - normally we use offset and limit for
19:22 - that number of the page but there's a
19:25 - problem if someone inserts something or
19:27 - deletes something while we are iterating
19:28 - on some
19:29 - parts of the collection so we can define
19:31 - cursor that we just point to to one item
19:34 - and work on that it's not perfect but
19:37 - it's
19:39 - somehow
19:40 - protects us from from getting item twice
19:43 - or not at all
19:45 - in case of concurrent changes
19:49 - there's something between pagination and
19:51 - sorting that is
19:53 - defining of some sort parameters uh
19:56 - search parameter for example let's say
19:57 - we have ticket system
19:59 - uh we can define that there is a page
20:01 - recently clause which has some
20:03 - kind of sorting in that searching in
20:06 - that already
20:08 - another idea besides parameters is using
20:11 - headers if you want to again
20:13 - separate yourself from the business
20:14 - surface of the api
20:16 - and it's always nice to to include some
20:18 - links to the next page in the collection
20:21 - previous page last
20:23 - or the first
20:26 - okay status so what happened with with
20:29 - our request hopefully it was okay but if
20:32 - not
20:33 - we can do something with that so first
20:35 - http codes generally whatever happening
20:37 - happens on server whether it was
20:38 - successful or not it should return the
20:40 - status
20:42 - the question is how many statuses should
20:44 - i use
20:45 - it's a difficult question i believe in
20:47 - http 1.1 there's around 70 statuses or
20:51 - so
20:53 - usually in apis i found between 1 and
20:56 - 20 that's maybe there is a reasonable
20:58 - maximum
21:00 - for example facebook always returns
21:02 - status 200 and then
21:04 - in the body of the response
21:06 - actually informs what happened and so do
21:10 - national railways of switzerland but
21:12 - they are not the best example of api
21:14 - design
21:15 - [Music]
21:17 - anyway aside from that i think that more
21:20 - or less 15 codes is to 15 is the
21:22 - reasonable number of codes we should use
21:24 - there
21:26 - what else if something goes wrong
21:28 - then it's a good idea to say exactly
21:30 - what happened so first some kind of enum
21:33 - that says which situation took place it
21:35 - could be either some name like
21:37 - payment fraud or something that says
21:39 - something
21:40 - or i found an idea of extending http
21:43 - code so we are adding an additional
21:45 - digit or two to http code
21:49 - uh second thing
21:51 - message so just say what happens for
21:53 - example if you have
21:54 - if your clients are developers from
21:55 - china or some other country maybe then
21:58 - they don't like english very much you
22:00 - can for example
22:06 - i can display this message in different
22:08 - language forgot the word
22:10 - and the last but not least what you can
22:13 - include in such objects is a link to
22:15 - some kind of faq or documentation
22:17 - chapter which
22:19 - explains exactly what happened
22:23 - and again don't expose internals unless
22:26 - you are open source of course but
22:29 - returning stack traces in responses is
22:31 - not exactly a good idea usually
22:34 - so briefly on http codes
22:36 - 200
22:37 - yeah success
22:39 - 201 is used when we create an object
22:42 - at 202 when we start some kind of
22:45 - asynchronous processing
22:47 - and the response is not ready but
22:50 - we notified that okay we got the
22:52 - requests we are on it 204 when it when
22:55 - we delete an object
22:58 - then we return this
23:00 - and when we return just a part of the
23:02 - response and there will be more 206
23:06 - okay 300 directions kind of tricky 300
23:09 - is not that not that often used because
23:12 - there is no really a good standard on
23:14 - how to handle that it says that there
23:15 - are multiple choices
23:17 - 301
23:19 - something was moved per numently so
23:20 - don't try again on this address
23:23 - 302
23:24 - it's kind of deprecated because it was
23:26 - meant as 307 but instead implemented in
23:29 - the early days as 303 so what are those
23:32 - 307 temporary direct means
23:35 - the others change temporary and please
23:37 - use the same method that you did before
23:39 - so i do a
23:41 - i post on the server
23:43 - and if i got 307 it means
23:46 - redirect and use post again i did
23:48 - nothing for you on the other hand 300 or
23:50 - free means
23:52 - go to another place but use get to
23:54 - retrieve results so basically i got the
23:56 - request
23:58 - i got some processing and i have results
24:00 - for you and they are somewhere else but
24:02 - use get to retrieve that
24:05 - 400 i think the most calls are in this
24:08 - category
24:10 - unauthorized really means
24:12 - unauthenticated i don't know who you are
24:15 - forbidden me three authorized but the
24:17 - name was already taken it means i know
24:19 - who you are but you can do this
24:22 - uh 404 yeah we know that one
24:25 - row five means the object is there but
24:27 - the method is not allowed because maybe
24:29 - it's immutable or for some other reasons
24:32 - conflict
24:33 - well the thing that you are trying to do
24:34 - in the request is in a conflict state
24:36 - with the server so for example aws s3
24:40 - would return that if you try to delete a
24:42 - bucket that has still some files in it
24:45 - there's a conflict in their definition
24:47 - gone means that there was a resource but
24:49 - it is not anymore in in its permanent
24:51 - situation
24:53 - and 422
24:55 - and possible entity is basically kind of
24:57 - bad request but on a higher
25:00 - level of abstraction so you would return
25:02 - but request when the json is for example
25:04 - my form it lacks one parenthesis
25:07 - but if you do a request to book a ticket
25:09 - and
25:10 - say arrival date is before the departure
25:12 - date that's a good situation to return
25:15 - 422 so it says that as a business
25:18 - situation and we can process it
25:21 - although we understood the request
25:24 - and server errors so 500 generic error
25:28 - we don't know what happened we don't
25:30 - like that
25:32 - 501 is kind of a way saying of saying
25:35 - that
25:36 - it's kind of under construction it will
25:39 - be there try again maybe later in like
25:41 - in two weeks or something
25:43 - um
25:44 - but gateway and gate gateway timeout are
25:47 - somehow similar and it's saying that
25:49 - when we were acting as a gateway
25:51 - something bad happened with someone else
25:53 - so either another service screwed
25:56 - screwed the response or didn't respond
25:58 - at all sorry there is nothing i could do
26:00 - and it's okay if we are talking internal
26:02 - apis and microservices then we just go
26:05 - to another team and ask hey what's going
26:07 - on but on the other hand if if i'm an
26:09 - external client i don't really care
26:11 - which one service screw up something
26:15 - i'm interested i'm interested in what
26:18 - happened basically so
26:20 - it's not very recommended to to use as
26:23 - status code in external api i think
26:26 - and service on available is a way of
26:28 - saying that hey we are down but there is
26:30 - some maintenance everything will be okay
26:33 - instead of just 500 it's not working
26:36 - so that's the main let's say
26:39 - business part now let's go to this
26:41 - quickly to the supporting thing
26:43 - uh so
26:44 - a few words about security about
26:46 - versioning cash and performance
26:48 - throttling
26:50 - haters and then some
26:53 - less technical things but also some
26:54 - miscellaneous if you don't know where to
26:56 - put something you can always put it in
26:57 - miscellaneous category
27:00 - security
27:01 - well
27:02 - 2019 you should use tsl whenever
27:04 - possible and https
27:07 - if someone goes to our endpoint without
27:09 - https we shouldn't redirect them to
27:12 - https just return errors so that
27:14 - situation is clear
27:16 - cryptography is difficult so
27:18 - even if you have phd in cryptography and
27:21 - 10 years of experience is probably not
27:23 - the best idea to invent our own ciphers
27:26 - and
27:26 - cryptographic schemes especially
27:28 - security by obscurity is a bad idea
27:32 - instead of
27:33 - passwords and username is good to use
27:35 - api cases
27:37 - keys as they have
27:39 - they are more secure it's difficult to
27:41 - guess them
27:42 - and there is probably
27:44 - everyone
27:45 - or almost everyone knows the old wsap
27:49 - opponent application security projects
27:51 - but if you don't just check this out dot
27:53 - org it's a list of 10 most important
27:56 - threats in web application and it's
27:57 - always always
27:58 - good to see what is
28:00 - currently on top there
28:02 - okay
28:03 - versioning so our api changes and how to
28:05 - deal with that
28:07 - the most popular and usual solution is
28:09 - just to embed version in the url
28:11 - so we say photo is api version two
28:15 - of our one or without anything is
28:16 - version one on the other hand we can go
28:19 - a bit deeper
28:20 - and use parameter for that so that way
28:23 - for example if someone does not include
28:25 - this parameter so it's optional you can
28:27 - assume that we are returning the newest
28:29 - version of the api
28:31 - again if we want to
28:34 - go away from the business surface of the
28:36 - api we can use headers either accept
28:38 - header for that or we can use our own
28:41 - headers
28:42 - and
28:43 - api versioning and resource versioning
28:45 - are two different things so we can have
28:47 - new api all the api
28:48 - and return new version of resource and
28:51 - old version of resource
28:53 - you shouldn't be confused
28:55 - cache control
28:56 - cache is difficult but in general what
28:59 - we can do about this
29:01 - we have this
29:03 - values of cache control headers
29:05 - basically public and private is about
29:07 - whether the information is
29:09 - meant for single use just single users
29:12 - or is publicly available so if there is
29:14 - a logo of the web page
29:16 - it can be marked as public if there is
29:18 - some particular data for the user it
29:20 - probably should be private
29:22 - those should be public and this will be
29:23 - private
29:25 - um if we can allow resource to be stale
29:28 - we don't care about
29:29 - it's to be very fresh then we specify
29:32 - some kind of max save so how stale it
29:34 - should be
29:35 - no cache doesn't really mean that we
29:37 - don't have any benefits from caching it
29:39 - just means that
29:40 - the resource should be always fresh so
29:42 - whatever
29:43 - the client checks for the resource in
29:45 - proxy we need to check on the server and
29:48 - if the results didn't change well we are
29:51 - in luck we can just return the value
29:52 - from the proxy if not we need to refresh
29:54 - that
29:55 - on the other hand no store
29:58 - says that we can't use caching at all
30:00 - basically it's about sensitive data like
30:03 - medical records or anything related with
30:05 - money usually
30:07 - and we don't want to store even of on
30:09 - the device of the user or maybe
30:11 - especially on the device of the user
30:14 - so how to
30:15 - uh how to deal with all those values
30:17 - there are actually like 15 or so more
30:20 - basically we need to think if the data
30:22 - is private or public if it can be if it
30:25 - can be stale or not and if it is
30:27 - sensitive and then we can
30:29 - set some effective caching strategy so
30:32 - that we save both
30:34 - on bandwidth and performance and
30:36 - computing power of our systems and
30:38 - clients
30:41 - throttling so how to deal with
30:44 - many requests
30:45 - basically you can just return 500 server
30:48 - kaput
30:49 - but we can do better
30:51 - for example
30:53 - there are three headers not standard but
30:56 - commonly used that say that
30:58 - there's a limit in time window
31:01 - how many requests are left in current
31:04 - time window and when the time new time
31:06 - window starts
31:08 - and if the client is in no luck and
31:10 - there is no more requests in the time
31:12 - window then you can return 400 429 to my
31:16 - request and the information that let's
31:18 - say hey
31:19 - there will be new opening in seven
31:22 - seconds so just try again then and not
31:24 - try every second because it won't work
31:26 - anyway and again we save on both on our
31:29 - site and client side
31:32 - hey toast
31:33 - who of you did play diablo 2
31:37 - yeah lots of guys
31:40 - so it's lord of hate mephisto it kind of
31:43 - went well with this slide haters so
31:44 - hyper media as the engine of application
31:46 - states the most beautiful
31:48 - acronym for in our industry the idea is
31:52 - that we
31:53 - with the response we return links to
31:55 - related resources and what we can do
31:57 - about this resource
31:59 - around this resource so that way
32:02 - a client doesn't have to remember all
32:04 - those links and follow the versioning
32:06 - you can just take the link that we
32:08 - return and and follow that
32:10 - and there are several there's no really
32:11 - one standard of how to do this there are
32:14 - several personally i used hull it worked
32:17 - pretty well for me there is also
32:19 - collection plus json which is kind of
32:21 - originating in collections but
32:24 - works pretty well with links too
32:26 - there is json link document which is
32:28 - kind of good if you don't want to break
32:30 - backward compatibility so like
32:32 - encapsulate the requests in another
32:34 - object and there is siren which is i
32:36 - think quite powerful but not that
32:38 - popular
32:42 - documentation so
32:45 - moving a bit away from the technical
32:47 - side
32:49 - um documentation should be
32:51 - easy to find and ideally public so i
32:54 - don't have to mail the support and wait
32:57 - two weeks to get the documentation there
32:59 - are
33:00 - three tiers of kinds of documentation
33:02 - there is like this address book which is
33:05 - exhaustive reference
33:07 - everything we can do with the api but
33:09 - really boring
33:10 - then there is
33:12 - engaging tutorial which is kind of a
33:14 - business story we start with something
33:16 - we do some other requests we complete
33:18 - something
33:22 - and we can follow that and there is an
33:24 - engaging
33:26 - that was engaging so how does console
33:27 - quickstart there's something that we put
33:29 - on the front page of our product so the
33:31 - developer can just take it
33:33 - and start from that
33:35 - and move efficiently
33:38 - miscellaneous
33:40 - so as i said about those
33:43 - six principles of good product design
33:45 - and
33:46 - people with disabilities so if i'm a
33:48 - person with disability and i can't do a
33:50 - post request because of my proxy then i
33:52 - can use a header for that x http method
33:55 - override
33:57 - and just specify the value of the method
33:59 - i really want to use while i'm using get
34:00 - method
34:02 - it's kind of maybe obsolete because most
34:05 - modern
34:06 - web browsers do this but we can add a
34:08 - parameter to pretty pin json so
34:10 - automatically insert indentation and new
34:12 - lines so it's more readable
34:15 - in process that do not support this for
34:17 - encoding we have standard header so
34:19 - let's invent our
34:22 - own solutions
34:23 - uh it's just ued
34:25 - when we are creating new resources it's
34:27 - not the best idea to just
34:29 - go with consecutive numbers one two
34:32 - three and four because then
34:34 - somebody can just ask for all the all
34:36 - the numbers and get all the data from
34:38 - our database and aside from losing data
34:41 - we are losing quite a lot of performance
34:43 - here so it's
34:44 - it's good to use some longer and random
34:47 - id so it's difficult to guess them
34:49 - and somewhat similar request uids
34:53 - sometimes called correlation ids
34:56 - if you start
34:57 - let's say the processing flow on the
34:59 - boundary of our system then some calls
35:01 - are fired to microservices maybe there
35:03 - are quite a lot of them we can add a
35:05 - parameter with this id of the request
35:07 - and then it's easy to find this
35:09 - in logs and debug the situation
35:13 - um
35:15 - rest clients
35:16 - and browsers there are some api vendors
35:19 - who have an idea that if somebody access
35:22 - api from
35:23 - web browser it means we want to return
35:25 - html instead of json it's generally a
35:28 - bad idea we have content negotiation for
35:30 - that
35:31 - we have standards for time so let's not
35:33 - invent our own standards for that
35:36 - [Music]
35:38 - health endpoints it's more about
35:40 - internal apis not external
35:42 - but aside from the health endpoint that
35:44 - we need for for example our kubernetes
35:46 - or some other automation to to see if
35:48 - our service is okay
35:50 - so it's a good idea to add more
35:52 - information for developer for example
35:54 - the git version from which the service
35:56 - was built or the values of some
35:58 - important properties
36:00 - or some other stuff
36:02 - so we can it can be a bit enriched
36:06 - and
36:07 - last but not least external apis
36:10 - there are often product projects in the
36:12 - company which has this b2c business to
36:14 - client model and many front-end to add
36:17 - an external api and connect with big
36:19 - business and it usually sounds quite
36:22 - good and easy you just make some kind of
36:24 - gateway separate service do some
36:26 - configuration and security a few other
36:28 - things it will be nice but in practice
36:30 - it turns out that those projects are
36:33 - actually just a bit about new technology
36:36 - and in
36:37 - quite
36:38 - large part in dealing with
36:41 - uh
36:42 - existing problems in our systems meaning
36:44 - if we if if we if you want to create
36:46 - external api we have to think
36:49 - what should be exposing that because
36:51 - often internal apis we expose a lot of
36:53 - things
36:54 - that are not very secure to expose so
36:57 - now we have to limit that
37:00 - often there is a situation where a
37:01 - business flow of our system is not
37:04 - really
37:05 - prepared for b2b for example you have a
37:07 - flaws to pay with credit cards or
37:10 - braintree paypal or whatever but you
37:12 - don't have an option to issue an invoice
37:14 - and you have to add that to make it work
37:17 - or on the other hand
37:19 - it's often common that you have to do a
37:22 - little small modifications in many parts
37:25 - of the system for example remember last
37:27 - time when i was taking part in
37:29 - similar project
37:31 - i think it was the moment when i checked
37:33 - out the
37:35 - um the largest number of git
37:36 - repositories in this company because we
37:38 - had to add a small field partner id in
37:41 - very many places
37:44 - so when you hear that there is an
37:46 - external api
37:48 - under construction beware it might
37:51 - it might mean that there is a lot of
37:52 - dirty work to be done but on the other
37:54 - hand
37:55 - that's an opportunity to get to know the
37:58 - system better because you work on many
37:59 - places and like get this
38:02 - good overview so how how the client
38:04 - would see it from the outside
38:07 - and
38:08 - another aspect is that often there is no
38:10 - good consensus of the naming of part of
38:12 - the system for example when we did this
38:14 - api for travel it turns out that one
38:16 - micro service returns something by the
38:18 - name of segment another service calls
38:21 - this itinerary
38:22 - another service calls this lag and now
38:25 - we suddenly have to somehow unify that
38:26 - and
38:28 - and it should make sense from the
38:29 - business point of view
38:32 - to sum up
38:34 - good api takes a lot of effort a lot of
38:37 - things we need to think about
38:39 - especially some of them are not that
38:40 - visible from the
38:42 - from the business side
38:45 - api is percy's a product for developers
38:49 - thinking as a developer might be kind of
38:51 - tricky for business people
38:54 - but
38:55 - api to developer is more like
38:57 - graphical user interface is to regular
39:00 - user
39:01 - so we need to keep that in mind
39:03 - if you are going with rest because it's
39:05 - not the only way for example you can
39:07 - choose graphql
39:08 - yesterday there was a nice talk about
39:10 - graphql literally one attempt maybe yeah
39:14 - there are many many alternatives there
39:16 - are binary protocols
39:18 - but the if you are talking about rest
39:21 - verbs are the
39:23 - center of rest
39:24 - uh we need to take advantage of http
39:27 - semantics so methods
39:29 - headers status all that good stuff
39:32 - and look at those principles but do not
39:34 - follow it blindly because something
39:36 - sometimes something doesn't really fit
39:38 - into the
39:40 - into into the picture but it's
39:43 - i mean doesn't fit into the rest picture
39:45 - but still makes sense and we can just
39:47 - bend the rules if we know what we are
39:49 - doing
39:50 - okay if you fall asleep or just come
39:53 - later to this lecture
39:55 - most of what i said and quite a lot more
39:58 - is in i think six or seven currently
40:00 - articles on my blog
40:02 - it's how to train your java just like
40:04 - the movie but with java instead of
40:06 - dragon
40:07 - so welcome to drop by
40:11 - okay
40:12 - questions
40:14 - yes
40:37 - i'm not sure actually
40:39 - but
40:43 - uh i think this is one of the common
40:45 - functionalities that is actually
40:46 - implemented but by api management
40:48 - platforms like
40:49 - apg or however it is now called because
40:51 - it was about bought by google wso2
40:54 - or
40:56 - aws gateway
40:57 - i think in all of them i saw
41:01 - the point about frotlink so i suppose
41:04 - they do
41:07 - any other questions
41:09 - yeah
41:10 - you didn't mention anything about
41:13 - parameters inside the body
41:17 - that we are using it that we are
41:18 - actually picking in external rp
41:22 - i'm often seeing that people
41:26 - use a trade to use request response as a
41:30 - part of naming and to me it's
41:40 - [Music]
41:41 - well i saw the problem that somebody
41:44 - needed to request
41:45 - a long
41:47 - list of
41:51 - and the question basically about
41:52 - parameters in eureka's body
41:56 - if they are good or not
41:58 - the problem was that somebody
42:00 - has a situation that he wanted to
42:02 - request a very very very long list of
42:05 - resources and the list was particularly
42:07 - that long that it may not fit the the
42:09 - length of the url
42:11 - and
42:12 - he was wondering that maybe then it is a
42:14 - good idea to put it in a body
42:17 - actually i mean
42:19 - when i'm looking for a sweater yes i'm
42:22 - often seeing
42:24 - the description of posts
42:27 - that
42:28 - people describing elements yes
42:32 - as for example
42:36 - peoples yes and they
42:38 - hold the request people request and
42:42 - define the body and responds people
42:44 - respond
42:46 - and defines the body of response
42:50 - it's not looking like resource-oriented
42:53 - style
42:54 - but very often
42:56 - i see the style of defining
42:58 - documentation
43:00 - and i didn't find any
43:02 - good place describing
43:04 - how
43:06 - this app should like and how we should
43:09 - describe this requested response
43:12 - [Music]
43:14 - i'm not very
43:15 - sure how to answer that
43:29 - i don't gotta think about it
43:31 - uh another questions
43:33 - i don't want to stand between you and
43:35 - beer for too long so maybe if there are
43:37 - other questions just catch me later
43:38 - today or tomorrow and that will be all
43:41 - thank you