00:03 - Hey, what's up guys, it's Pedro here from 
New cutter calm. And in this tutorial,  
00:09 - we're gonna learn how to install Node j s, as well 
as learn how to actually run code using node j s.  
00:15 - So to get started, we're going to actually have 
to download node j s. So if you go to Google and  
00:21 - type node j s download, you should get a web page 
similar to this. And I will be leaving a link in  
00:29 - the description in case you can't find it. So go 
ahead and download eight, point three lt s. Now  
00:36 - once you download that, run it, install it enjoy 
all that good stuff. And within these tutorials,  
00:43 - I'm going to be using Visual Studio code. And 
if you don't know what Visual Studio code is,  
00:49 - it's an editor. Now, you can use whatever editor 
you want. But the reason I'm using Visual Studio  
00:55 - code is because it has an integrated command 
prompt. So once you download these two things,  
01:02 - I'm just going to head over to my desktop. 
And let's create a new folder. And I'm just  
01:09 - going to say no JS tutorial. And now I'm just 
going to head over to Visual Studio code. And  
01:17 - you should have a welcome screen like this, go to 
File, Open Folder. And we are going to open the  
01:26 - folder that we just created. So I'm just going 
to select this. And now I'm just going to hit  
01:33 - Ctrl N control and is going to create a new file, 
I'm going to hit Ctrl S. And we are going to save  
01:40 - this file. And I'm just going to say app dot j s. 
And this is going to be a very, very simplistic  
01:47 - JavaScript file. And we are just going to run it. 
And this is just a test to see if you installed  
01:54 - node j s correctly. So if I hit console dot log 
hello world, from node j s. Now if I save this,  
02:07 - and I'm actually going to exit out of this, but 
you saw that this just popped up on my screen,  
02:13 - if I go to terminal, here is our command prompt. 
So I'm just going to exit this to show you how you  
02:21 - can bring this up whenever you want to run code 
using the terminal. So I'm just going to close  
02:27 - this. I'm going to hit Ctrl B, I am going to go 
to View, I'm going to go to integrated terminal.  
02:38 - Now by default, Visual Studio code has it on 
PowerShell. So if I go up here, you can notice  
02:49 - that mine says cmd. So if I hit Ctrl, Shift P and 
type default, I can say select default shell. Now  
03:01 - I have three terminals installed on my computer, 
you probably have PowerShell, and you probably  
03:06 - have command prompt. And I also have get, go ahead 
and click command prompt. hit this plus button,  
03:14 - this is going to bring up a new terminal. So if 
I was to hit this or bring up another CMD, and  
03:19 - this should say cmd. So I'm just going to remove 
for me, I'm going to remove one, since I already  
03:26 - have one open. And now all I'm going to do is type 
node, and then the name of the file. So the name  
03:34 - of the file that we just created was called app 
dot j s. And here we go, we get an output of hello  
03:42 - world from node j s. Now let's say that you're 
not using Visual Studio code for whatever reason  
03:50 - you have your own editor of choice, what you can 
do is you hit the start menu, type cmd and then  
04:00 - go to command prompt. And then you can see that 
we get something very similar to the integrated  
04:06 - command prompt, but we're in a different location. 
So if I go to my desktop, open this folder. Let's  
04:17 - copy the path that this folder is located. So I'm 
just going to hit Ctrl C to copy, head over to my  
04:25 - command prompt. I'm just going to type C the CDs 
stands for change directory. All that means is hey  
04:33 - change folder. So right now I am in a folder 
called users Pedram makhado. I need to be in  
04:40 - this folder. So now I'm just gonna click this. Go 
down to edit, click paste. And that's our path. So  
04:51 - now if I hit Enter, you can see that our path has 
changed. And now if I type node app.js You can see  
05:01 - that we get a Hello World from node. So either way 
is fine. If you want to use Visual Studio code and  
05:08 - its integrated terminal, you're more than welcome 
to, if you're using a different editor and it  
05:14 - doesn't have its own integrated terminal, you're 
more than welcome to use the command prompt.  
05:24 - In this tutorial, we're going to be talking about 
node modules, or a node module is is basically  
05:31 - a JavaScript file. It's a way to separate 
concerns for our application. So for example,  
05:37 - let's say that I have an app.js file. And in 
this app.js file, I have maff, a bunch of API  
05:46 - requests and database calls. Instead of putting 
them all on one file, what we can do is separate  
05:52 - each of those concerns into their own files. So 
to get started, I'm just going to hit Ctrl. B,  
05:58 - I'm going to say Ctrl N. So we're going to create 
a new file. And I'm just going to say Ctrl S and  
06:06 - we're going to save it as the tutorial, dot j s. 
Let's save that Ctrl B. And now we could focus on  
06:14 - this new file or this new module called tutorial 
dot j s. So to get started, let's actually give  
06:22 - our tutorial module something. So I'm going to 
give it a function. So I'm going to say const,  
06:28 - some, and it's going to have two parameters, and 
all it's going to do is add and return them. So  
06:35 - number one plus number two. Next, what I want to 
end up doing is I want to expose this function  
06:44 - to the outside world. Because right now, if I hit 
Ctrl S, and if I was to try to use this function,  
06:53 - so I'm just going to delete this. So if I was 
just to say sum, one plus one. And if we were  
07:03 - to actually run this, you can see that we get 
an error, some is not defined. So you might be  
07:09 - saying, why is some not defined, I just defined it 
here. Well, I need to expose this function for the  
07:18 - outside world to use. So I need to let know know 
that this sum function within my tutorial module  
07:25 - is available to be used. So in order to do that, 
or I need to do is type module exports, and pass  
07:33 - it in some like so. Now that this is available to 
be used, I need to tell my app.js file where this  
07:44 - sum function is located. So what I can do here 
is declare a variable. So I'm just going to say  
07:51 - Kant's. tutorial. And now I'm just going to use 
the word require. And then we're going to give  
07:59 - it a path. Now the path is dot forward slash. 
So where did I get dot forward slash from? dot  
08:06 - forward slash means that it's within the same 
exact path that this file is currently in where  
08:14 - app dot j s. So if I was to hit Ctrl, B, you 
can see that I that j s is on the same level  
08:22 - as the tutorial dot j s, and that they're in the 
same folder called Node JS tutorial. So if I hit  
08:30 - Control V, again, get rid of that. And then I 
pass in the name of the file, which is obviously  
08:35 - tutorial dot j s. Now you do not need to pass in 
the extension, all you need to do is pass in the  
08:42 - name of the file, Node. js automatically assumes 
that it is a JavaScript file. And now, if I was to  
08:51 - print out tutorial, two, let's see what's inside 
it. And now let's get rid of our son call. We're  
08:59 - gonna call some a little bit later, I just want to 
show you what the variable tutorial has. So if I  
09:05 - was to save this, and let's scroll down, I'm going 
to type CLS, hit enter. That's going to clear  
09:12 - the terminal. And now I'm just going to run node 
app. And you can see that the tutorial now holds  
09:19 - a function called sum from our tutorial module. So 
now if I want to actually use that function, I can  
09:28 - say tutorial and pass in one plus one. And let's 
actually print out the results. I'm just gonna say  
09:36 - console dot log it. Let's save it, execute it 
again. And you can see that we get our desired  
09:48 - output of too and that we are indeed importing 
from our tutorial module, the sum function. So now  
09:56 - that we know how to do that, how will we import 
ml To pull stuff from modules. So for example, if  
10:03 - we head back to our tutorial module, let's say I 
have multiple functions or multiple variables, or  
10:10 - even a class, how do I export more than one thing? 
Well, what you can do is I can say, and just for  
10:19 - the sake of example, let's add more stuff. So I 
could say Kant's. Hi, and just gonna set this the  
10:25 - 3.14. And let's create a class. And I'm gonna say 
some math object. Let's give it a constructor. And  
10:37 - I'm just gonna say object created. Okay, so now 
I have some pi and some math object. Now, I want  
10:50 - all three of these to be exposed to the outside 
world. So that app.js, for example, can require  
10:58 - them and then use it. So how do I do that? Well, 
one way to do that is to add properties to the  
11:05 - module dot exports object. So for example, I could 
say dot sum. And I'm just going to copy this. So  
11:16 - now experts, that sum is going to have the sum 
function exports.pi is going to hold the value  
11:26 - of 3.14. So I just set it equal to pi. And some 
math object, it's going to be madrona exports dot  
11:38 - some math object is going to be equal to some math 
object. Now if I was to save this, head over to  
11:46 - app, and let's just remove this for now, I want to 
print out what tutorial is holding once we require  
11:55 - from our tutorial module. So if I save this, and 
now let's execute this, you can see that we're  
12:05 - getting an object back tutorial is now an object. 
And now this object has the properties of sun. And  
12:12 - it tells you that it's a function, pi, the value 
of pi, and some math object. And you can see that  
12:19 - it's our class. And now if I want to execute this, 
it will be like accessing a normal object. So for  
12:26 - example, we have tutorial. And let's say we want 
to use the sum function. So just saying tutorial,  
12:34 - and I'm passing the two numbers, I could say 
tutorial, sum, and pass in the two numbers. And  
12:40 - I'm just going to copy this. Let's paste this 
two more times. And now if I want to print pi,  
12:48 - package, say tutorial, pi. And within here, the 
same thing for the object, I can say new tutorial,  
13:00 - dot some math object. And that's going to create 
a new instance of our some math object. And now  
13:11 - if I was to save this, and run it, you can see 
that it executes as expected. So tutorial sum,  
13:21 - gives us to pi has the value of 3.14. And you 
can see that our constructor gets executed  
13:28 - object created. One more thing to show you before 
I wrap this up, if this is an ugly syntax for you,  
13:37 - for example, saying module dot exports, that sum 
equals this module.exports.pi is a bit repetitive,  
13:45 - what we can do is, instead of exporting each of 
these individually, I'm going to let's remove two  
13:55 - of them. And instead, what we can do is export 
an object literal and tag along the properties.  
14:08 - So I could say sum is going to be some pie. 
This is going to be pi. And then some math  
14:21 - object is going to be some math object. And 
if I'm to save this, and now execute it, we  
14:30 - should get the same exact result. So let's execute 
that. You can see that it's working beautifully.  
14:42 - And this tutorial, we're going to be talking 
about the events module, particularly the event  
14:48 - emitter class within the events module. Now all 
the events module allows us to do is basically  
14:55 - bring Event Driven Programming to node j s. So 
to get started, we're going to actually have to  
15:02 - require the events module. Now the events module 
is actually built into node j s. So I'm just  
15:08 - going to say Kant's. Event emitter. Now this is 
going to be the class that we get from requiring,  
15:17 - from the events module, I was just gonna 
say equals require event. Now from here,  
15:26 - we're going to have to create a new instance of 
the event emitter. So I'm just going to say const,  
15:33 - event emitter, I say, new event emitter. 
So from here, we're going to start getting  
15:43 - into Event Driven Programming. Now that I have 
my event emitter object, let's actually attach  
15:49 - a listener to it. So I'm just going to say event 
emitter. And I'm going to call the method on now,  
15:57 - this method takes on two arguments. One is the 
listener that you want to attach to this object.  
16:04 - So I'm just going to call it tutorial for this 
example. And the second argument is going to be  
16:11 - the function that you want to execute. When does 
the tutorial event occurs. So let's just pass in  
16:19 - this function. And I'm going to say is console dot 
log tutorial event has occurred. So now if I save  
16:34 - this and run it, so I'm just gonna hit Ctrl S to 
save. And I'm just gonna say node app, you can see  
16:42 - that nothing happens within our terminal. Now, why 
is that? Well, I have this object. I've attached a  
16:49 - listener call tutorial. But I haven't emitted 
a tutorial event. Remember, this code here,  
16:57 - is only going to be executed when a tutorial event 
occurs. So now let's emit a tutorial event. So I'm  
17:06 - just going to say event emitter. And now I'm just 
going to pass in tutorial as the first argument.  
17:15 - And that's it. So now, if I was to hit Ctrl, 
S to save, and now execute this one more time,  
17:24 - you can see that our tutorial event gets triggered 
whenever we call the emit method. So now what  
17:34 - happens when we actually want this function to 
have parameters? Well, I could give a parameter  
17:41 - so I could say num, one, num, two. And just for 
argument's sake, so just to show on the console,  
17:49 - we're going to print out the sum of number one and 
number two. So now how would I call it down here  
17:56 - with the emit method? Well, I'll just pass it in 
an argument. So I could pass in one, and two. So  
18:05 - if I save this now, and now go to node app, you 
can see that we get the value of three. So you  
18:14 - just pass in the argument. Now, this is all fine 
and dandy. But how would I create a custom object  
18:21 - which takes advantage of using events? Well, I 
could just inherit from the event emitter class.  
18:27 - So for example, let's say that I want to create a 
person class. So I say class person. And I could  
18:35 - just extend from the event emitter class. And 
now from here, let's give it a constructor. Now  
18:46 - let's call our super function. So I'm just going 
to say super. And this is going to allow us to  
18:53 - use that this property within our class. And now 
I'm just going to say this, that underscore name  
18:59 - is going to be assigned value name. And now let's 
actually pass in name to our constructor. And now  
19:06 - let's give this person class a getter. So I'm just 
going to say get name. And all this is gonna do is  
19:14 - just return this dot underscore name. So now that 
we have our person class defined, let's actually  
19:24 - create a new instance of it. So I'm just going to 
go down here. And I'm just going to say, let Pedro  
19:32 - equals new person. And let's pass in Pedro. And 
now here remember, when I say new person, person  
19:44 - extends the event emitter class, which means that 
Pedro is also an instance of the event emitter  
19:52 - class. So now I can add a listener to the page 
or object so I could just say pedro.on and And  
19:59 - I'm just going to call it name. And we're going 
to pass in our function. And I'm just going to  
20:06 - print out my name is so and so. So I'm just gonna 
say console. dot log, my name is. And we're just  
20:17 - going to say Pedro dot name. So now that we've 
attached our listener, obviously, we're going  
20:25 - to have to call the emit method. So we're gonna 
emit the event has occurred. So I'm just gonna say  
20:31 - Pedro dot emit, and we're gonna pass in name. And 
now if I was to save this, and now execute this,  
20:40 - you can see that we get the desired output 
of my name is Pedro. So that's how you would  
20:48 - extend using the event emitters class. And for our 
final example, let's say that we have more than  
20:56 - one person object, so I'm just going to create a 
new person, I'm just going to call let's make it  
21:03 - a girl, I'm just going to call her Christina. I'm 
going to say new person. And we're going to pass  
21:10 - in Christina. Now let's add a listener to the 
Christina object. So I'm just gonna say Christina,  
21:17 - that on name. And you could use a loop for this. 
But since I'm only creating two person objects,  
21:26 - that doesn't make sense for this example, but you 
can use a loop to do this on one shot. And we are  
21:34 - just going to copy this. paste this in here, I'm 
just gonna say, Christina, that name. Alright,  
21:45 - so why did I go there to bother are showing 
you that we create it to person objects,  
21:50 - and attach listeners to it? Well, what I want to 
show you is that when you emit an event to occur,  
22:01 - the event gets executed synchronously. So for 
example, if I say, Pedro, and I say, Christina,  
22:08 - and now if I was to save this, and now execute it, 
you can see that these get executed synchronously.  
22:18 - So because Pedro emitted first, Pedro gets 
executed first and then our Christina object,  
22:24 - so they get executed in the order that they 
admitted in so they execute synchronously.  
22:35 - In this tutorial, we're going to be talking about 
the read line module. Now, what the read line  
22:40 - module allows us to do is prompt the user as well 
as get user input. So to get started, we're going  
22:47 - to have to require the module. So I'm just going 
to say const. reline is equal to require read  
22:55 - line, and this is going to bring in our relying 
module. Next, we're going to have to create an  
23:01 - instance of the read line interface by using the 
Create interface method. So I'm just going to say  
23:07 - read line dot create interface. And within here is 
going to take an object. Now we're going to give  
23:15 - this object two properties. And this is basically 
our configuration file. So the first property I'm  
23:23 - going to give it is input. And then we're going 
to give it an object. Now this object is called  
23:29 - process not process is a global object. So you 
don't have to require it. It's already given to  
23:36 - us by node. And here we're going to say STD. And 
now input is going to be the STD in input stream.  
23:47 - And then here, we obviously need an output. So 
I'm just gonna say output, and we're going to  
23:54 - give it process that STD out. And that's going to 
stand for output stream. Now, when this method is  
24:02 - executed, is going to return our read line or the 
face object. So let's save it inside a variable  
24:09 - so we can use it. So I'm just gonna say const RL 
is equal to this. Now let's say I want to ask the  
24:16 - user what two numbers added together are equal to. 
So for this example, I'm just going to generate  
24:23 - two random numbers between one and 10. So I'm just 
going to say let num one equal math floor math dot  
24:37 - random. And we're going to times this by 10. And 
we're going to shift that over by one. So this is  
24:46 - going to give us a random number between one and 
10. It's copied us twice. Paste that, too. And we  
24:58 - need the answer. So I'm just gonna say less Answer 
equal number one plus number two. All right. So  
25:04 - now that we have this, we're ready to ask the 
user what these two numbers are equal to. Now in  
25:10 - order to do that, I'm going to use our read line 
interface. And our relying interface has a method  
25:17 - called question. So I'm going to say RL question. 
Now, the first argument is going to be a string,  
25:24 - the second argument is going to be a function. And 
basically, the first argument is going to be the  
25:31 - question we would like to ask the user. So I'm 
just gonna say back tick, what is not one plus  
25:40 - num two? Question mark. And I'm just going to 
hit enter here, because I want you guys to see  
25:54 - this on one line. And we're going to include our 
callback. Now, this function is going to get the  
26:02 - user input as a parameter. So I'm just gonna say 
user input. And for now, I'm just going to print  
26:10 - out user input onto the console, just so you guys 
can see that it's actually working. So now if  
26:17 - I was to save this, head over to my console type 
node app, it's going to say what is four plus two,  
26:26 - I'm going to say banana. And there you go, it 
prints out the user input. It's important to  
26:34 - note that if you take a look at our console, 
the application is still running. So I'm just  
26:39 - going to hit Ctrl. C to break out of it. And what 
we need to do is actually close the read line  
26:45 - interface when we're done using it. So in order 
to do that, let's actually add a couple of things.  
26:52 - First thing, I want a new line, right after this 
question mark here. So I'm just gonna say forward  
26:59 - slash n. So when I prompt the user, the users 
input instead of lining up right next to it,  
27:06 - like so there's gonna be underneath. Alright, so 
I fixed that problem. Next thing I want to do is  
27:14 - actually test the user input to see if he actually 
got the answer. Correct. So in order to do that,  
27:20 - I'm just going to say, if user input. And it's 
always important to trim the users input, if you  
27:29 - ever accept anything from a user, just to get rid 
of the trailing whitespace. And we're just going  
27:35 - to say if the user's input is equal to answer. 
So if they answer the math question correctly,  
27:43 - I want to close the application. So I could say, 
RL dot close. And here, and now if I was to save  
27:52 - this, and now execute the program, so I'm just 
going to write node app. And it's going to say,  
27:58 - What is 10 plus four, and I'm going to answer with 
14. And you can see that we answered it correctly,  
28:06 - and therefore our application closed. Now, what I 
want to do is actually add a listener to the close  
28:13 - event. Now, the read line interface is actually 
an instance of the event emitter class. So what we  
28:22 - can do is actually scroll down here. And I'll add 
it towards the end. And I want to say our own.on.  
28:32 - And basically, I'm going to say, hey, I want you 
to listen for an event to occur, I'm going to say  
28:40 - close. And we're going to give it a callback. 
And this function is only going to execute when  
28:47 - we close the reline interface. So now I'm just 
going to say console dot log. And basically,  
28:53 - I just want to let the user know that Hey, you got 
the correct answer. So I'm just gonna say correct.  
29:01 - So now if I was to save this, and now execute 
it, node app, what is six plus three, I'm just  
29:09 - gonna write nine. You can see that correct, gets 
printed out onto the console. Now correct gets  
29:17 - printed out onto the console. Because when we 
use the method close, it emits the close event.  
29:23 - And since we're listening for a close event, this 
callback function gets executed. And on that note,  
29:31 - I better add a semicolon on there. And let's see 
that. So now that we handled what happens when the  
29:38 - user inputs correctly, what happens if the user 
gets the wrong answer? So in order to do that,  
29:45 - let's create an else statement within our 
question method here. So I'm just going to  
29:51 - say else. And what I want to do basically is re 
prompt the user. So I'm just going to say rl.com.  
30:00 - That set prop. And set prompt is basically going 
to take an argument of string. And it's going to  
30:09 - ask the user, basically what you want to know. So 
I'm going to say to the user, incorrect response,  
30:18 - please try again. And let's add a new line here. 
And now in order to use the Prop, I actually have  
30:32 - to call it. So the first method is to set the 
prop. The second method is going to be to call on  
30:39 - discussing our prompt. So now, I'm just gonna hit 
Ctrl. S to save. And now I'm just going to execute  
30:50 - this node app. And he's gonna say what is one plus 
five, and I'm going to say banana. And it's gonna  
31:00 - say incorrect response, please try again. Now, 
I actually haven't told it what to do once the  
31:07 - user inputs. So let's actually write the code for 
that. Now, what I'm going to do is actually add a  
31:14 - listener to our read line interface. So I'm going 
to listen for the users input. And the event for  
31:22 - that is rl.on. Mine. And then we're going to pass 
it in our callback. Now this callback is going to  
31:33 - have the user's input. And now we're going to 
decide what to do once we get the user's input.  
31:42 - So obviously, what we want to do is check if the 
user's input is correct. And if it is correct, we  
31:54 - are going to close the application. And now what 
happens if it isn't correct, we're gonna say else.  
32:02 - And then I'm going to reset the prompt. So I'm 
just gonna say R dot set prop. And I'm gonna say,  
32:12 - let's actually make this more informative. So I'm 
just gonna say your answer. And then we're just  
32:20 - going to print out what they wrote. user input, 
is and correct. And we're going to build a forward  
32:31 - slash. And before that, I'm just going to say, try 
again. So now let's enter. And now remember, once  
32:43 - we set the Prop, we actually have to call it. So 
now I'm just going to say RL dot prop. And now if  
32:54 - we just take a look at what we have so far, this 
is basically going to give us a loop. So we set  
33:01 - a line event listener. Now when the user enters 
input that's going to trigger this line input,  
33:09 - we're going to test to see if what he gave us is 
correct. And if it is, we're just going to close  
33:15 - that but patient. And if we close the application 
this on close method is going to execute,  
33:24 - it's going to say, correct. So now let's see what 
happens if we give it the wrong value. Is it going  
33:32 - to execute the else statement? And it's going 
to set the prompt your answer have so and so  
33:36 - is wrong. And that is going to prompt the user 
again. And basically, this line event is going to  
33:43 - keep executing until the user enters the correct 
input. So let's actually take a look at this in  
33:50 - action. So I'm just going to clear the terminal. 
And before I execute, let me just say, intro as to  
33:57 - say, oops, Ctrl S to save. And now I'm just going 
to hit node app. And it's gonna say what is one  
34:06 - plus four, I'm going to say banana. Incorrect 
response, please try again, I'm going to type  
34:13 - banana again, your answer banana is not correct. 
And you can see that this will go on indefinitely.  
34:20 - Now, if I go back up, and let's actually see 
what it was, what is one plus four, I'm just  
34:27 - going to type in five. And you can see we get the 
output of correct and then exit the application.  
34:38 - And this tutorial, we're going to be talking about 
the file system module. Now what the file system  
34:45 - module allows us to do is work with the file 
system. And what I mean by that is that it allows  
34:51 - us to create files, read files, delete files, 
create folders, stuff like that. So to get started  
34:59 - We're going to have to require the file module 
into our project. So I'm just gonna say const Fs  
35:05 - is equal to require Fs. So now that we have the 
file system module within our node application,  
35:15 - let's actually use it. Now. If I hit Ctrl, B, 
you can see that all I have is my app.js file  
35:23 - within my Node JS tutorial folder. So let's 
actually create a file. So this one's gonna  
35:30 - create a file. And we're going to say Fs dot 
write file. Now, the first argument is going  
35:40 - to be the name of the file. So I'm just going 
to say example, dot txt. The second argument is  
35:48 - what you want to write to the file. So I'm just 
going to say, this is an example. And the third  
35:56 - argument is going to be a callback, and this 
callback is going to have a parameter of error,  
36:01 - in case anything goes wrong. So I'm just gonna 
say error. There we go. So let's actually finish  
36:12 - writing this. So I could say, if error, we're 
just going to print out the error. Otherwise,  
36:20 - we can say, file successfully created. So I'm 
just gonna write file successfully created. So  
36:31 - now if I was to save this, and let's run this node 
app, you can see that we get file successfully  
36:42 - created. And now if I hit Ctrl, V. good not to be 
in the console. And when I do that, Ctrl B. Now,  
36:51 - you can see that we have a newly created file 
called example, dot txt. And if we look in it,  
36:59 - we see the data that we wrote to the file. Now 
that we created this file, let's actually read it,  
37:06 - let's open up and read it. So if I was to say Ctrl 
V again, and I'm just going to go to App dot j, s,  
37:13 - and within this else statement, let's put all 
this code within here. And now I'm going to say  
37:22 - Fs dot read file. And within here, the first 
argument, much like the right file method, is  
37:34 - going to be the name of the file that you want to 
read. So I'm just going to say example, dot txt,  
37:40 - the second argument is going to be the encoding 
type. Now I'm going to leave this blank because  
37:46 - I want to show you guys what happens when you 
don't leave an encoding type. And then the third  
37:52 - argument is going to take a callback function. 
And this callback function has two parameters,  
37:58 - it has error, and it has the file that you 
actually want to read. Now in here, I actually  
38:08 - want to show you guys what the file looks like. 
So we're going to do the same thing that we did  
38:13 - and the right file method, I'm going to check if 
there's any errors. And if there are no errors,  
38:24 - I just want to print the file itself. So now if 
I was to save this, go to node app. Now you'll  
38:38 - see that the file was successfully created. And 
then you see that when we print out the file,  
38:45 - we get this buffer stream. And then we get this 
bunch of numbers following it. Now the buffer  
38:52 - stream stores data and binary. Okay. So what we 
need to do is specify the encoding type that we  
39:02 - want it to be displayed as. So up here, we're 
going to go up here. And I'm just going to pass  
39:09 - in you TF a. So that's the encoding that I want. 
And now if I was to save this, go to node app. You  
39:24 - can see that file was successfully created. And 
we're successfully reading the contents within the  
39:31 - file. Alright, so now that we know how to create 
and read files, let's actually cover a few more  
39:37 - methods. So what I want to do is start with a 
fresh examples. I'm just gonna comment this all  
39:43 - out. I'm just going to highlight everything Ctrl 
backslash, and that's going to comment everything  
39:50 - out for me. Now what I want to do is let's say 
that when I created this example dot txt file,  
39:58 - that I really didn't mean to call example dot 
txt, let's say I wanted to call it example to,  
40:06 - for instance, well, I could use the Rename method. 
So I could do something like this, I can say Fs  
40:14 - dot rename, and rename is going to take in three 
arguments. The first argument is going to be  
40:20 - example, dot txt. And that's going to be the name 
of the file that we want to rename. The second  
40:27 - argument is going to be what we want to rename the 
file to. So I'm just going to say example two, dot  
40:34 - txt. And the third argument is going to be their 
callback function, which has a parameter called  
40:42 - error. And we're going to do the same thing, as 
we've been doing for all these asynchronous calls,  
40:50 - we're just going to say, if error, we're just 
going to print that out to the console. If there's  
40:58 - no error, and everything went fine, we're gonna 
say successfully rename the file. So I'm just  
41:06 - gonna say successfully rename the file. So now, 
if I hit Ctrl, S to save, and now let's run this,  
41:17 - you'll see successfully renamed the file. 
And it says the leader from this, and that's  
41:25 - probably because it hasn't updated yet. So if I 
close this, and I'm just gonna hit Ctrl, B. And  
41:31 - you can see that within our package explorer, 
that our file has been renamed to example two,  
41:38 - dot txt. And if I open this as the same exact 
file that re created, couple more methods that  
41:46 - I want to go over. So I'm just going to hit Ctrl. 
B. And let's say that, once I comment this out,  
41:53 - let's say that when I was creating the file that 
I forgot to add something towards the end of the  
42:01 - file, so what do you want to do, I want to append 
data to the file. So I'm just going to say Fs that  
42:13 - a pen file is going to take in three arguments, 
it's going to take in the name of the file, I'm  
42:18 - just going to say example, two dot txt, the second 
argument is going to be the data that you want  
42:26 - to append to the file. So I'm just going to say 
some data being upended. And the third argument  
42:36 - is going to be the callback function. And this 
is going to have an error as a parameter passes  
42:45 - and, and we're gonna say if error printed out to 
the console. Otherwise, we're gonna print out that  
42:55 - we successfully appended data to the file. So I've 
successfully appended data to file. I'm just gonna  
43:10 - move this over so you can see. And now if I save 
this, and execute this, so node app, you'll see  
43:19 - successfully appended data to the file. So let's 
actually take a look at our file. And you can see  
43:27 - that our file has been changed. So before we had 
this as an example, and then we appended on data  
43:34 - to the end of the file. And the last method that 
I want to cover within this tutorial is how do  
43:40 - I delete a file. So for example, we did all this 
and let's say that I've had enough with this file,  
43:47 - I just want it gone. So let's just comment this 
out. And this is going to be the final method that  
43:55 - I go over. So we're just gonna say Fs dot unlink. 
And the first argument is, obviously, you guys  
44:03 - should get this by now. It's going to be example, 
two. Example two dot txt. And the second argument  
44:14 - is going to be a callback function and have the 
parameter of error. And within here, if ever  
44:22 - printed out to the console, if there's nowhere 
where we're just going to say successfully deleted  
44:31 - the file successfully. So now if I was to save 
this, and now execute it, you can see successfully  
44:48 - deleted the file status up here deleted from 
this. So if I close this, and if I was to  
44:55 - hit Ctrl B to bring up the package explorer, 
you can see that the file I no longer exist.  
45:07 - And this tutorial is going to be part two of 
my file system modules tutorial. Now in the  
45:14 - previous tutorial, we went over using the file 
system module to work with files. And this I  
45:20 - want to go over how to work with folders. So to 
get started, we're going to have to require the  
45:25 - file system module. So I'm just going to say 
const, Fs equals require, and then Fs here.  
45:33 - Alright, and now what I want to do is I'm going 
to say fs.mk Dir. And what MK dir stands for is  
45:42 - make directory. And our directory is is a folder. 
So now here, it's going to take in two arguments,  
45:50 - one is going to be the folder name that you want. 
So I'm going to give it the value of tutorial. And  
45:56 - then we're going to pass in the callback with 
an error. And we're just going to say if error,  
46:02 - console dot log error, oh, we successfully created 
the folder so on so say, console, log folder  
46:15 - successfully created. So now if I was to 
save this, and now before actually run this,  
46:24 - I'm just going to hit Ctrl. b. So you don't see 
that there's any magic happening. So all I have  
46:30 - is my Node JS tutorial folder, and app.js file. So 
now, if I go here, type node app, you can see that  
46:41 - we get the output a folder successfully created 
and that our tutorials folder has been created.  
46:47 - Now let's say that I actually want to delete this 
folder. So I'm just gonna hit Ctrl V again. And  
46:54 - this is actually going to give us an error, but 
I'm just going to show you what the error is,  
47:00 - is basically going to complain that this folder 
really exists. So I'm just going to say Fs that  
47:07 - are m, and r M stands for remove, and then dir and 
that stands for remove folder. Now I'm going to  
47:16 - give the folder name, so we call it tutorial. 
And this is also going to take a callback,  
47:21 - which gets an error. So now if I say if error, 
console dot log the error, oh, we're gonna say  
47:34 - successfully deleted the folder successfully 
deleted the folder. So now if I was to save this,  
47:46 - and now execute it, you see that we get an error 
file already exists. And that's because the  
47:56 - tutorials folder already exists. And we're trying 
to create another folder named the same thing. So  
48:02 - I'm just going to hit Ctrl V. Again, delete that 
tutorial folder, I'm just going to hit delete,  
48:07 - confirm that Ctrl V again, let's execute this. 
And you can see that we successfully deleted the  
48:19 - folder. So if I go up here, hit control B, you'll 
see that it doesn't exist. So first thing we do is  
48:27 - we create a folder called tutorial. And then if 
this is successful, then we're going to delete  
48:34 - the folder called tutorial. And you can see by 
output that we successfully deleted the folder.  
48:40 - Now this is too fast. And that's why you wouldn't 
be able to see it if we had the package manager  
48:46 - open. So now that we know how to create and delete 
a folder, what I want to do now is create a folder  
48:54 - and then create a file within that folder. So I'm 
just going to hit control B. And we can leave this  
49:02 - make directory. So we're going to make a folder 
called tutorial. And if it's successful, it's  
49:08 - going to execute this else block. So let's remove 
this. And then within here, we're going to create  
49:18 - our new file. So to do that, I'm just going to 
say Fs dot write file. Now write file is going  
49:26 - to take in three arguments. It's going to take and 
the name of the file, but in this case, we've got  
49:32 - to give it the full path. So I'm going to say dot 
four slash. And what dot forward slash means is I  
49:40 - want you to start relative to App dot j s. And 
then I want you to go inside the folder called  
49:49 - tutorial. So I'm just going to hit Ctrl B just to 
show you. So app dot j s start here. There's going  
49:56 - to be a folder called tutorials. I'm going to go 
in inside that folder, tutorial. And now I want  
50:04 - to you to create the file called example, dot txt. 
So if I hit Control V again, and then the second  
50:14 - argument is going to be what the data that you 
want, I'm just going to write 123 doesn't matter  
50:20 - for this example. And then the third argument is 
it going to be a callback function which gets an  
50:26 - error. And then within here, I'm going to write if 
error, console dot log the error onto the console.  
50:36 - Oh, we're gonna write successfully created, file, 
successfully created file. So now let's save this.  
50:49 - So I'm just gonna hit Ctrl. S, down here, node 
app. And you can see that it says successfully  
50:58 - created file down here. So now if I hit control B, 
and I'm going to go up here and then hit control  
51:06 - B, you can see that we have our newly created 
tutorial folder. And within here, we have our  
51:13 - example dot txt. So if we go in here, you can see 
it has the data of one, two, and three. Now, what  
51:22 - I want to show you is, how would I delete a folder 
that has a file within it. So you might be saying,  
51:29 - if I just go back here, hit Ctrl B, that can't 
I just use Fs dot remove directory in order to  
51:37 - do this. Well, I am actually just going to comment 
all this out. And what will end up happening if I  
51:48 - use the Remove directory function is that is that 
I'll get an error. And the reason for that is,  
51:59 - because if I use the Remove directory function, 
it has to be used on a directory or folder that  
52:07 - is empty. So just to show illustrate this, 
that's going on right this quick remove  
52:14 - directory function. And if there's an error print 
it else, we're just gonna print deleted folder. So  
52:27 - I'm just going to hit Ctrl S to save. And I'm 
just going to type CLS to clear the terminal  
52:33 - node app. And you can see that we get an error 
directory not empty, that we're trying to remove  
52:40 - a directory that has a file within it. So in order 
to fix that, let's delete the file first. So I'm  
52:49 - just going to say Fs dot unlink. And the first 
argument is going to be the file. So remember,  
52:57 - dot forward slash, and then we have to go into 
the tutorials folder. And then I named the file  
53:05 - example dot txt. Next argument is going to 
be a callback function which has an error,  
53:14 - I'm just going to say if error, print that out. 
If there's no error, then what I want to do well,  
53:25 - if there's no error, that means that I 
successfully deleted the file, which means  
53:32 - I can now successfully remove the file. So I'm 
just going to copy this. And I'm going to put this  
53:40 - within the else block here. Add some semi colons. 
And now if I was to save this, and now execute it,  
53:53 - you can see that we have deleted folder. And you 
can see up here deleted from this. So if I go  
54:01 - hit control B, you can see that the folders been 
successfully deleted. So what did we do? First,  
54:08 - we deleted the file that was within the folder. 
And then if that was successful, then I wanted  
54:15 - to delete the folder itself. Last example that I 
want to do is what happens when there are multiple  
54:22 - files within a folder, and you want to delete all 
those files. So I'm going to cheat a little bit,  
54:29 - and we're just going to create it within our 
package explorer. So I'm just gonna say new  
54:35 - folder, and we're gonna call it example. And I'm 
just gonna give it two files. I'm just gonna say a  
54:42 - dot txt. And the second file is going to be b dot 
txt. All right, so now I have my folder and I have  
54:53 - my two files. So how would I go about doing this? 
Well, there's a method called Read directory. And  
55:02 - what read directory does is it gives you back the 
list of files that you have within that folder. So  
55:09 - let's actually call it so I'm just gonna comment 
on this out. comment this out. And then I'm just  
55:18 - going to type Fs dot read directory. Now the 
first argument is going to be obviously the  
55:25 - name of the directory. And in this case, we call 
it example. And then the second argument is going  
55:31 - to be a callback function. first parameter is 
going to be error. And then second parameter  
55:38 - is going to have files now files is going to 
be an array with the name of the file. So now,  
55:48 - we can test if there's an error, all we're gonna 
do is print out the error, there is no error,  
55:56 - we're gonna print out files, I'm just gonna print 
out files just to show you what files contains.  
56:03 - So if I save this, run this and the console, 
you can see that we have our two files stored  
56:11 - within an array, a dot txt, and B dot txt. So now 
let's actually loop through this array and delete  
56:20 - everything. So now I'm just going to say for let 
file of files. And then within here, we can start  
56:32 - deleting each file individually. So I could say 
Fs dot unlink. And then we're going to give it  
56:39 - the file name. So it's going to be dot forward 
slash, example, then it's going to be the name  
56:48 - of the file. After that is going to take in an 
argument callback for an error. And if there  
56:57 - was a problem deleting that file, it's going to 
print it out to the console. If there wasn't,  
57:04 - we're just going to say, successfully deleted 
file. So and So So, so successfully. deleted  
57:14 - file. So now if I was to save this, and now 
execute this, you can see successfully deleted  
57:25 - file once twice. And if I hit Ctrl, B, you can 
see that we have an empty folder called example.  
57:38 - In this tutorial, we're going to be talking about 
the readable and writable screens. Now what these  
57:44 - screens allow us to do is basically be able to 
read and write data more efficiently. And the  
57:50 - way that they accomplish this is by reading and 
writing data, and chunks as opposed to reading and  
57:56 - writing the data all at once. So to get started, 
we're going to have to require the FS module or  
58:03 - the file system module. So I'm just going to say 
const. fs is equal to require Fs. Now that we have  
58:12 - our file system module included, we're going to 
create a readable stream. And there's a method  
58:17 - called Fs dot create reach screen. And now I need 
to give it the path. So if I just hit Ctrl, B,  
58:25 - you can see that I have an example dot txt file 
here, and it has a bunch of texts that we're  
58:33 - going to be reading in. So if I head back to App 
dot j, s, hit Ctrl V, again, we're just going to  
58:39 - give it the path of dot forward slash, example 
dot txt. And then that's it. Now this is going  
58:48 - to return to us a readable stream. So I'm just 
gonna save it within a variable. I'm just gonna  
58:54 - say cons reach stream is equal to Fs dot read 
stream. And then here, what we can do is listen  
59:05 - for an event. Now the return object inherits 
from the event emitter class. So that means we  
59:11 - could listen for events to occur. And one event 
that we want to listen for is the data event. So  
59:18 - I'm just going to say read stream.on data. And 
then this is going to take a callback function.  
59:26 - And now we're going to get a chunk of data and 
return. So every time we read a piece of data,  
59:35 - this event data is going to be invoked. So this 
callback function is going to be called every  
59:42 - time we get a piece of data. So now I'm just going 
to print out the data onto the console. And you're  
59:52 - going to see why I call it a chunk and not the 
full file in a second. So now if I save this,  
59:57 - go to node And you can see that we read this data 
within two chunks. So we have to print out here,  
60:08 - we have a buffer here, and a buffer here. So 
let's actually set the encoding type. So it's  
60:15 - a lot easier to what the sources, and we're just 
going to set it to UTF, eight, and save this. And  
60:23 - now let's rerun this application. And there you 
go, you see that we read our text file. So what  
60:30 - are the benefits are reading this in a chunk, as 
opposed to loading the whole file? Well, for one,  
60:37 - when I get this chunk, I could immediately start 
manipulating that chunk. So I don't have to wait  
60:45 - for the whole file to load in order to manipulate 
it. Or let's say that I don't want to manipulate  
60:52 - this chunk of data that I got already, I want 
to send it to a new file, well, I could start  
60:58 - sending that data to a new file, while I'm reading 
in the data itself. So let's actually send it to a  
61:06 - new file. And for that, we're gonna have to create 
a writable stream. So I'm just going to go here.  
61:11 - And I'm going to say const. Right stream is equal 
to Fs dot create, write stream. And within here is  
61:25 - going to be the name of the file that I want to 
write to. So I'm just going to call it example  
61:30 - two dot txt. And now within here, what I can do 
is, instead of waiting to get the whole data,  
61:39 - I can start writing chunks to the new file. 
So within here, instead of just printing out  
61:46 - console dot log, chunk, I can say, right stream 
dot, right. And I could write this data to a new  
61:56 - file as I'm reading it. And so I could say chunk 
here. And let's say that. And now if I run this  
62:04 - application node app. So now if I hit Ctrl, B, you 
guys see our newly created file. And if I go here,  
62:15 - you can see that we wrote onto a new file. So 
basically, what's happening here is I'm able to  
62:23 - write chunk by chunk, and our example two chunks, 
in order to get the full file, I'm able to start  
62:32 - writing before the file is fully loaded. And 
that's pretty much the power of using a stream.  
62:43 - This tutorial, I'm going to show you guys why you 
should be using streams by trying to read a very,  
62:49 - very large text file. So to get started, I'm just 
going to show you how big the file is. So I'm just  
62:55 - going to hit Ctrl. B, we have our large file dot 
txt file here. And if I click review and explorer,  
63:02 - right click Properties, you can see that the size 
it's about 2.7 gigs. So let's actually take a look  
63:12 - at what would happen if we were to use the read 
file method from the file system module. So now,  
63:21 - if I was to execute this and type node app, you 
see that we get an error and the error says file  
63:29 - size is greater than the possible buffer. Now, 
what does that mean? Well, the read file uses a  
63:36 - buffer, but it uses a full buffer. Now what that 
means is that I need at least 2.7 gigs in memory,  
63:46 - in order to load this file, because this file has 
to be loaded, because this file has to fit within  
63:55 - the buffer. And it's saying, Hey, your buffer 
size is just too small for this file. Now, I'm  
64:01 - just going to comment this out. And now what we're 
going to use is a readable stream. So I'm just  
64:06 - going to comment this out. And then we're going to 
uncomment this. And by the way, I have tutorials  
64:13 - on both readable streams and using the read file 
method. So now I have the stream will look what  
64:21 - happens when I execute the code now. So if I was 
to save this, and now execute it, you can see  
64:29 - that are readable stream has absolutely no problem 
reading this file. So I'm just going to hit Ctrl C  
64:37 - to cancel this, because I don't want it to finish, 
you know loading the entire thing. But why can  
64:44 - this be accomplished with streams but not using 
this read file method? Well, one, a stream uses a  
64:52 - buffer awesome, but it doesn't use a full buffer. 
It uses a very, very small buffer and what That  
65:00 - allows us to do is basically what's happening is 
that you're ending out reading the file in chunks,  
65:07 - you're not reading the entire file at once. So 
basically, every time a data event occurs, I am  
65:14 - getting a chunk of the file, I'm not attempting 
to read the entire file at once. And therefore,  
65:20 - the buffer size could be a lot smaller, as opposed 
to a read file method, which uses a full buffer,  
65:27 - which needs to be big enough to load the entire 
file at once. And then server streams allow for  
65:34 - smaller buffer size, which is memory efficient. 
And for data to be read and written and chunks.  
65:44 - And this tutorial, we're going to be going 
over pipes. Now what a pipe allows us to  
65:49 - do is basically take a source stream, which is 
just a readable stream, and send it over to his  
65:54 - destination, which is just a writable stream. 
So in the last tutorial, we went over readable  
66:01 - streams and writable streams. And basically what 
we did was create a read stream. And then from  
66:07 - there, we create a write stream. And then we 
attached an event listener to the reach stream.  
66:12 - And every time we got a data event emitted, we 
read a piece of the chunk from the read stream,  
66:19 - and then rewrote out that chunk to where we 
wanted to send it. So there's actually a much  
66:25 - more simpler way. And the much more simpler way 
is just to get rid of this. And all we're going to  
66:31 - do is say restream dot pipe. Now pipe is going to 
take what restream gives us and it's going to pipe  
66:42 - it into our right stream. So now if I was to bring 
up the terminal, and just type node app, and hit  
66:54 - Ctrl V, you can see we have our example Tex. And 
then we created our example two dot txt. So the  
67:04 - pipe method is basically a shorthand version for 
all that stuff that we wrote in the last tutorial.  
67:11 - So all we need to remember is, in order to use 
a pipe, we need two streams, we need a source  
67:18 - stream. And we also need a destination stream. 
In our case, the reach stream is our source,  
67:24 - this is the file that we want to read in, then 
we call the pipe method on the retrieve. And then  
67:30 - this is going to take the destination where do we 
want to send this data to, and that's to the right  
67:36 - stream. So now I want to talk about pipe chaining. 
So let's give a more complicated example. And for  
67:44 - that, I'm going to bring in another module. And 
I'm going to bring in Kant's z lib. Now z lib  
67:51 - is a module that is for basically compression, 
compressing files, I'm just going to say require  
67:58 - z lib. Now what we're going to do is create a 
transform stream. Now, what a transform stream is  
68:09 - basically is what it does is it takes the input. 
So for example from our read stream, and then when  
68:16 - it receives that data, it manipulates that data 
into something else. And in this case, what it's  
68:22 - gonna do is compress the data. So I'm just going 
to create a transform stream. So I'm just gonna  
68:29 - say cons. Gs is equal to z lib dot create jesup 
call that method. Now this is going to return  
68:41 - our transform screen. And now within here, a set 
of saying reach dream, what I can do is send that  
68:50 - data that reach stream is giving us and I could 
pipe it into our Gs. Now what GS is going to do  
69:06 - is take the chunks of data that is reading at a 
time, and it's going to manipulate it and compress  
69:13 - it basically. So you're going to get a compressed 
version of the read stream. And then from here,  
69:20 - we're going to pipe it out to our destination, 
which is our right stream. So now if I was to  
69:27 - run this, let's save it. Now I'm just going to hit 
Ctrl B. And if we go here to example, two dot txt,  
69:39 - you can see that we accidentally did not change 
the type and that's my fault. So the type that  
69:46 - we're creating create write stream should not be 
a txt file. It should be a.gz file and that's the  
69:55 - compression type. So I'm just going to save this 
and let's run this application. Again. Now I'm  
70:02 - going to hit Ctrl B. And you can see that we get 
an example two.txt.gz file. Now, if I clicked it,  
70:11 - it's going to say that Visual Studio Code cannot 
open this. So I'm just going to right click it,  
70:17 - reveal an explorer. And you can see that zip 
file is basically a compressed file. And I'm  
70:25 - going to double click it. And you can see that 
our example two dot txt files here and with our  
70:33 - tax. So now let's give just one more example just 
to get the hang of it, chaining pipes and using  
70:42 - a transform stream. So we saw what happens when 
we compress the file and then write it. So let's  
70:48 - go and reverse, we're going to take our source, 
which is compressed, we're going to uncompress it,  
70:54 - and then we're going to write it. So from here, 
let's just go back to Visual Studio code. Let's  
71:01 - go back to App dot j s Ctrl V. And instead 
of saying create jesup, what we want to do  
71:09 - is create unzip. So I'm just going to go here and 
say create g unzip. And we're going to change this  
71:17 - variable to unzip. And now this is going to be our 
transform stream. So I'm just going to copy this,  
71:23 - paste that here. And now what happened, well, 
read stream has changed, right, so now I want  
71:31 - the compressed version of it. So let's go over 
here, we're going to get rid of the encoding  
71:37 - type. The compressed file is called example 
two dot txt Gz. So I'm just going to copy this,  
71:44 - I'm going to paste this in here. Now this input, 
this reach stream is going to be piped to G unzip,  
71:53 - which is going to basically uncompress the 
file, and then it's going to send it off to our  
71:59 - destination. So what do we want our destination to 
be called, we could pretty much name this anything  
72:06 - you want. So I'm just gonna say uncompressed dot 
txt. So now if I was to go ahead and save this  
72:14 - type node app, execute it, we hit Ctrl B. And 
you can see that we have our uncompressed txt  
72:25 - file. So if I click this, you can see our example 
Texas here, and that is successfully uncompressed.  
72:38 - In this tutorial, we're going to go over the HTTP 
module. Now what the HTTP module allows us to do  
72:46 - is basically create a web server with node j s. 
So to get started, we're gonna have to require  
72:53 - the HTTP module. So I'm just gonna say const. 
HTTP is equal to require HTTP. Now from here,  
73:05 - we can call method called create server. And this 
is going to give us a HTTP server object. So I'm  
73:13 - just going to say const server is equal to http 
dot create server. Now, this method is going to  
73:22 - take a callback and this callback is going to give 
us a request object as well as a response object.  
73:31 - So let's just do that. Now, the request object is 
what the client requests from us. So for example,  
73:40 - if I am on Google Chrome, and I type in 
www.google.com, I am requesting something  
73:49 - from Google. Now Google server is going to 
take that request, and it's going to send me  
73:55 - a response back. So the most simplistic example 
that I could give you is I could send a basic  
74:02 - text back to the client. So I could say rez, and 
that's going to be my response, I'm going to say,  
74:09 - right, and I'm just going to pass in a string. So 
I'm just going to say, Hello world, from node j,  
74:17 - s. Now within here, I haven't actually sent the 
response back, I just told it what it is. So in  
74:24 - order to send the response, I'm going to say 
res dot. And now this is going to take care of  
74:31 - our HTTP dot create server method. Now there's one 
more thing that we have to do to get the server up  
74:39 - and running. And that's the total node j s. What 
port that I want to listen for requests that song  
74:46 - is going to say server dot listen. And we're gonna 
listen on port 3000. So now if I was to save this,  
74:58 - and now go down, Here type of node app, you can 
see that our server is up and running. Now I'm  
75:06 - going to go to Chrome. And within here, I'm going 
to type local host, colon, and then the port,  
75:17 - which we assigned was 3000. So that's where 
we're listening for requests that if I hit Enter,  
75:24 - you can see that we get a response back 
from the server, hello world, from node j,  
75:31 - s. So now from here, what we can do is actually 
listen to requests, different routes. So let's  
75:41 - actually take a look at a property of the request 
object. And one of the properties is called URL.  
75:48 - So instead of just saying, hello world, from node 
j, s, I only want to say hello world from node j.  
75:54 - s, if it is the root domain, so I'm just gonna 
say request dot URL is equal to forward slash,  
76:05 - then I'm gonna say res dot write Hello, world 
from Node JS. And then don't forget that we  
76:16 - have to send the response back to the client. 
So we're going to call resident and and now if  
76:24 - I was to save this, and we're going to is going 
to hit Ctrl. C to kick us out of the server. And  
76:30 - then we're going to start the server back 
up again. So we get our updated changes,  
76:36 - we're going to go back to Chrome, hit Enter. And 
you can see that it works exactly the same. If we  
76:44 - were to add an else statement here. So let's 
say they are not using the root domain, aka,  
76:51 - say rez dot write using some other domain, and 
then we're going to send that out to the user. And  
77:02 - that's actually Ctrl. C this to stop the server. 
And before we start up the server, I have to save  
77:11 - so I'm just gonna say Ctrl. S to save node app. 
And now here, instead of localhost colon 3000.  
77:22 - I'm going to say local hosts, banana. And let's 
see what response we get. And the response we get  
77:30 - back is using some other domain. Now this response 
is going to be for anything we type because we  
77:36 - put it in the else block. So if I type that, I'm 
going to get the same response. And then if I go  
77:43 - back and just have the forward slash, you can see 
that we get the Hello World from node j s output.  
77:55 - And this tutorial, we're going to be going over 
how we can serve static files, using the HTTP  
78:02 - and file system module. So to get started, I'm 
just going to hit Ctrl. B to bring up the package  
78:09 - explorer. And you can see that we have a static 
folder. And we have three static files. Now, these  
78:18 - files is a JSON file, an image, a PNG file, and an 
index dot HTML file. So what I want to do is make  
78:27 - a request to the server and have the server send 
these files back to me. So I'm just going to hit  
78:33 - Ctrl B to get rid of that. And the first thing 
we're going to do is actually required modules  
78:39 - on this gonna say const, HTTP equal require HTTP. 
And then our second module is going to be the file  
78:47 - system modules, I'm just gonna say require Fs. 
Now, first step to do this is to actually create  
78:55 - the server. So I'm just gonna say HTTP dot create 
server. And this is going to take a callback,  
79:03 - and we're gonna have a request object and a 
response object. Now I'm going to call a method on  
79:10 - that server object. So I'm just going to say that 
listen, and we're going to listen on port 3000.  
79:17 - Now, let's say that I want to read in a HTML file, 
for instance. So let's go up here. And what I can  
79:27 - do is create a readable stream. So I'm just going 
to say can't reach dream, it's going to be equal  
79:33 - to Fs. dot create, reach dream. And then within 
here, we're going to pass in the path. So I'm  
79:42 - going to say dot forward slash, because it's going 
to be relative to App dot j s. Now I need to go  
79:48 - inside the static folder. And then the name of the 
file that I want read in is called index dot HTML.  
79:56 - Now what I want to do is actually write a header 
for my response. Now what a header is responsible  
80:06 - for is the let the client know what kind of data 
that I am expecting. So I'm just gonna say rez,  
80:14 - that right head. And then within here, we're 
going to pass in the HTTP status code. So  
80:23 - I'm going to pass in 200. Now 200 means that 
everything went okay with your request. And  
80:30 - then the second argument is going to be what the 
content type, so I'm just going to hit content  
80:35 - type. And then we're gonna pass in text slash 
HTML. All right, so now that we've written our  
80:46 - header, I'm just going to take you guys to Google 
Chrome real quick just to look up the status  
80:51 - codes. Now you can see that HTTP 200 means that 
the request has been successfully completed. So  
81:01 - whatever the user requested from the server, that 
means everything went fine, as I said, and there's  
81:07 - a bunch of HTTP status code. So let's look at 
another one. So another common one is four, four.  
81:15 - So you're going on a website, and you accidentally 
Miss type the URL and they give you a not found  
81:22 - error. So that would be a 404 error. Now, let's go 
back to our Visual Studio code. And let's complete  
81:31 - this, I'm just going to go down here. And within 
here, I'm just going to pipe the reach stream into  
81:37 - where I want to send it. So I'm just going 
to say reach stream dot pipe. And where do I  
81:43 - want to send this file, I want to send it to the 
user. So I'm going to pass in rez, now read the  
81:49 - response object is also a writable stream. So I'm 
piping it to the response object. So now I'm just  
81:57 - going to save this. Let's go back to Chrome. I'm 
going to go here, Google, and I'm going to type  
82:04 - localhost 3000. And I should probably be noted 
that you should start up your node applications,  
82:16 - I'm just gonna type node app. Now let's go back to 
Google Chrome, hit refresh. And you can see that  
82:25 - our HTML file has been successfully sent. So let's 
actually try to send the other static files. And  
82:32 - this was pretty much straightforward. So all we 
have is if I hit Ctrl, B is an image and a JSON  
82:42 - file. So I'm just going to hit Ctrl V, again, 
now all we need to do is obviously change the  
82:50 - file that we're reading in. So instead of index 
dot HTML, let's do example dot JSON. Now I'm the  
82:59 - content type is obviously not a text slash HTML 
file. So we're gonna have to pass in application  
83:08 - slash JSON. And now, if I was to save this, hit 
Ctrl C, so we're going to restart the server, I'm  
83:20 - just going to clear out the terminal node app. Now 
let's hit refresh. And you can see that our JSON  
83:30 - file gets loaded and sent to the client. Now let's 
load up that image. So now the same exact thing,  
83:38 - I'm just going to hit Ctrl B, because I forgot 
when I named the image, I named it example dot  
83:44 - png. So I'm just gonna change this to P and G. And 
instead of application dot JSON, we're gonna just  
83:54 - gonna remove this. And we're just going to go here 
and type image slash PNG. So now if I was to save  
84:04 - this, now, we got to restart the server Ctrl C to 
cancel that out, no app. Now, if I go to Chrome,  
84:12 - hit refresh, you can see that my image has been 
loaded. So that's basically the ins and outs  
84:20 - of how you would serve a static file using the 
HTTP module, as well as the file system module.  
84:33 - In this tutorial, we're going to be going over 
how we can create our package dot JSON file.  
84:38 - Now what the package dot JSON file is responsible 
for is basically holding all our metadata for our  
84:47 - project, metadata being the name of the project, 
the version number, etc. So to get started,  
84:54 - what we're going to use is called the node package 
manager. So I'm just going to type NPM And then  
85:00 - I'm going to type in net, which means initialize, 
I hit Enter. And you'll see that we get a bunch of  
85:08 - jargon. So what do we want to name, the package, 
by default is going to be called the name of the  
85:15 - folder that you're currently in. So up here, you 
can see no GS underscore tutorial. And it says the  
85:22 - default will be no GS slash tutorial. So I could 
just hit enter, that's fine with me the version  
85:29 - number 1.0 dot zero, that's okay. Description. 
So what is this package about? What is your  
85:36 - project about? And we're just gonna say tutorial, 
because that's what we're using it for. And then  
85:43 - the entry point is pretty important. And it lets 
us know which file should be used to start our  
85:49 - node application. So for example, if I was making 
a website and uploaded to a server, it will let  
85:56 - the server know that that was our entry point 
to our application. Test command. Let's ignore  
86:03 - that for now. Enter, and Git repository is pretty 
self explanatory. Is it going to be your Git URL,  
86:10 - hit enter keywords, we're gonna leave that blank 
as well. Author, go ahead and write down your  
86:18 - name. license is C as defined by me, then it's 
gonna say Is this okay? And we're just gonna say,  
86:28 - yeah, that's fine. So you might think that 
nothing has happened. But if I hit Ctrl, B,  
86:35 - you can see that we have our package dot JSON 
file created. And if I take a look at this,  
86:42 - open it up, you can see that package dot JSON is 
just a JSON file. And it has our configuration  
86:50 - setting. So the name, the version description of 
our application, the entry point, scripts, author,  
87:00 - and license. And basically, in the next tutorial, 
what we're going to end up doing is actually  
87:09 - going out and installing external packages 
and including them within our own project.  
87:20 - This tutorial, we're going to be going over to 
node package manager in order to install packages.  
87:26 - Now our package is is basically reusable code that 
we can include within our own application, it's a  
87:35 - folder with one or more modules within it. So to 
get started, we're actually gonna head over to  
87:40 - Chrome real quick. And there's actually a website 
called NPM, J s.com. Now NPM, J s.com is where  
87:49 - we can actually look and discover new packages 
that we can include within our application. So  
87:56 - I'm just going to pick out a package, and we're 
going to install it and then use it. So I'm just  
88:01 - going to scroll down. And you could use the search 
up here. Or, let's just pick a popular package.  
88:10 - So you can see packages that a lot of people are 
installing. and scroll down more. And let's pick  
88:18 - lower das. And then here, we're given a bunch of 
instructions. So it says in order to install this  
88:27 - package, I just have to type in this command NPM 
i i in shorthand for install, and then the name of  
88:35 - the package. So in this case, the packages name is 
lodash. So if I head back to Visual Studio code,  
88:42 - and I type NPM, install lodash. You can see that 
it goes out, and it downloads the package for me  
88:56 - automatically. And now if I head back to my 
package dot JSON file, the JSON file that we  
89:02 - created in the previous tutorial, you'll notice 
that we have an extra property. And within this  
89:09 - property is called dependencies. And then it 
gives us the name of the package we installed,  
89:15 - as well as the package version that we installed. 
So now if I was just to hit Ctrl, B, you would see  
89:24 - that we have a extra folder and this extra folder 
is called node modules. So if I opened this up,  
89:30 - you can see that our lodash installation is 
stored here within this folder. So now this  
89:39 - is all fine and dandy, but how would I now 
use lodash within my own personal project,  
89:45 - so I'm just going to hit Ctrl B. And we're going 
to close out our package dot JSON file. And we're  
89:53 - going to go to App dot j s and basically what 
we're going to do is require it so I'm just  
89:59 - gonna say cool. underscore is equal to require 
lodash. And now from here, let's actually use  
90:10 - it to prove that this is working. So I'm just 
going to say underscore dot fill. And fill is  
90:17 - basically going to take an array. So I'm just 
going to pass in an array 12345. And the second  
90:25 - argument is going to take an A value, what do you 
want to replace these numbers were, so I'm just  
90:31 - going to say banana. And the third argument is 
going to be the start index. So what I want to  
90:37 - do is start at index one. And the last argument is 
going to be the end index. And since we have five  
90:45 - elements within our array, the last index would 
be four. So let's actually store this within a  
90:53 - variable. So I'm just going to say let example is 
equal to that. And we're just going to print out  
91:02 - this onto the console. So I'm just going to hit 
Ctrl S to save when I go to node. And you'll see  
91:13 - that we require lodash into our application. And 
we've tested that one of the methods within lodash  
91:20 - is actually working. So we get a new array, and 
we filled in index 123 with the value of banana.  
91:31 - And let's say that for whatever instance that you 
installed the wrong module, or you want to get rid  
91:44 - of a module, so if I hit control B, and we're just 
going to bring up the package dot JSON file and  
91:53 - hit Ctrl V again, what I can do is I can say 
NPM, uninstaller, and then the package name,  
92:00 - which is going to be lodash. And you can see 
that lodash is removed from our dependencies.  
92:09 - And if I hit Ctrl V, you can see that our node 
underscore modules folder no longer exists.  
92:16 - And that's because we have no dependencies 
that our application is using currently.  
92:25 - In this tutorial, we're going to be talking about 
semantic versioning. Now, what semantic versioning  
92:31 - is, is basically just a standard that a lot of 
Node JS packages follow and allows for us to  
92:39 - know what kind of changes have occurred, and the 
updated version of the package. So to get started,  
92:45 - you can see that I have my package dot JSON 
file open. And I have a dependency install  
92:52 - called lodash. Now within here, you see the 
version of the package that I installed with  
92:59 - the carrot sign. And we'll talk about the carrot 
sign within this tutorial as well. But for now,  
93:04 - I want you to focus on these three numbers. The 
first number four is going to represent the major  
93:11 - version of this package, the second number is 
going to represent the minor version. And the  
93:18 - third number is going to represent the patch 
version. Now the major minor and patch numbers  
93:25 - all have different meanings. So for example, right 
now, the latest version is four point 17 dot 11.  
93:33 - If I wake up tomorrow, and lodash is updated, and 
it says the latest version is four point 17 dot  
93:41 - 12. That means that that was a patch update. Now 
all I patch update means is that they implemented  
93:49 - some bug fixes. Now likewise, same thing happens, 
I go to sleep, they update lodash tomorrow,  
93:56 - and instead of four point 17 dot 11 is four point 
18 dot 11. So that means that there was a minor  
94:05 - update. Now when a minor update does is it adds 
new functionality. And it might deprecate some of  
94:13 - the old functionality, but you could still use it. 
So it's a non breaking change update. And finally,  
94:21 - if I was to go to sleep tomorrow and wake up new 
version of lodash is updated. And this time we  
94:28 - get version 5.0 dot zero. So what does that mean? 
That means that there was a major update pushed  
94:35 - out to lodash. And what a major update indicates 
is that there was a breaking change. So that means  
94:42 - version 5.0 dot zero is not compatible with the 
code four point 17 dot 11 or any version of four.  
94:52 - So now let's talk about this carrot character. And 
this carrot character was put there automatically  
95:00 - When we type NPM, install lodash. Now what this 
carrot character symbolizes the following. So the  
95:09 - following rules, if you will. So this means 
that whenever I use the carrot character,  
95:14 - that I do not want you to make any major 
updates. So that means right now I'm on  
95:22 - version four as the major. But if there is a 
minor update, or a patch update, go ahead and  
95:31 - download those new packages. Now, there's another 
symbol called the tada symbol and total symbol is  
95:39 - right next to the number one on your keypad. 
And that means that you want the following to  
95:46 - occur. That means you only want patch updates. 
So let's say I'm on four point 17. Right now,  
95:55 - that means I only want you to change the last 
number. So for example, if for Part 18 comes out,  
96:03 - this total symbol will say, hey, do not update 
to that package. And last but not least, let's  
96:11 - say that you don't want the tilde or the carrot 
sign up here. So for example, you don't want the  
96:18 - carrot sign to update the minor or the patch. And 
you don't want the Tilda to just update the patch,  
96:26 - what you can do is remove the carrot or the 
tilde a sign. And this guarantees that the  
96:33 - only version of lodash that you will ever have 
within your package will be four point 17 dot 11.  
96:44 - In this tutorial, we're going to set up our first 
Express server. Now all Express is is basically  
96:52 - a web framework for node j s. So in the previous 
tutorials, we use the HTTP and file system module,  
97:00 - in order to serve static files. With Express, 
however, you can see that we can accomplish  
97:06 - that and much more with much less code. So to get 
started, I'm just going to go over to Chrome. And  
97:14 - here is Express jSs official website. So you 
can see up here that they have guides for you,  
97:21 - you could reference the API. And basically, this 
is just the documentation for Express. And you can  
97:29 - see that they give install instructions here. Now, 
if you didn't go to the official website, or you  
97:36 - didn't know that they had an official website, 
he probably would have went to NPM j s calm,  
97:42 - that Express is a publicly available package for 
you to download and install. And you would have  
97:49 - just typed Express within the search bar here. 
So I'm just going to head back to Visual Studio  
97:55 - code. And the first thing that we need to do is 
actually create our package dot JSON. So I'm just  
98:04 - gonna say NPM and net, and I'm going to pass in 
the flag, yes. Now, when you pass in the flag,  
98:12 - yes, you basically skip all these configuration 
questions that they ask you when you type NPM. And  
98:20 - net. So now that we have our package, JSON, we can 
actually install express itself. So I'm just going  
98:27 - to type npm install, express, you can see that 
it's downloading right now. And now from here,  
98:37 - let's actually require Express JS into our 
project. So I'm just gonna say const. Express  
98:43 - is equal to require Express. Now, when I require 
this module, this Express module, what I'm getting  
98:52 - back is a function. So I'm just gonna call that 
function. So I'm just gonna say Express. And this  
98:59 - function is going to return an object and this 
object is going to have a bunch of methods that  
99:05 - we can use within our application. So let's store 
this object within a variable. And by convention,  
99:12 - we will call that variable app. So I'm just going 
to say app is equal to express. Now from here,  
99:20 - what I can do is call a method called get. Now the 
first argument of get is going to take the route.  
99:27 - So we're just going to say forward slash. And then 
the second argument is going to be the callback  
99:33 - function. And it's going to be request and 
response. And then all we're going to do is say  
99:40 - res dot send. Hello, world. So this is going to be 
our first application using Express. So when the  
99:50 - user visits the route forward slash, what we're 
going to do is Sunday response of hello world  
99:56 - and that with a semi colon And then the last step 
that we need to do is actually give it a port to  
100:04 - listen to. So I'm just gonna say app dot listen. 
And we're just going to listen on port 3000. So  
100:12 - now if I was to save this type no app. And that's 
going to run the server, head over to Chrome. Now,  
100:23 - I'm just going to open a new tab. And I'm just 
going to type local host 3000. And there you  
100:32 - go. This is our first Express JS application. 
And you can see that we got a response of hello  
100:39 - world. And in the upcoming tutorials, we're going 
to dive deeper into the Express web framework.  
100:50 - In this tutorial, we're going to work more with 
the HTTP GET requests. And we're going to be  
100:56 - talking about Curie string and route parameters. 
So to get started, we created a basic Express  
101:03 - application from the previous tutorial. And we 
gave it one route, which is basically the index  
101:09 - route, or you could refer to it as the homepage. 
And we just said, Hello world. So if I was just  
101:16 - to run this node app, go to Chrome. Go to local 
host. And we're going to put 3000, because that's  
101:28 - the port, and you see our basic route. So this 
is the forward slash route. So now let's give  
101:34 - it a another route. So I'm just gonna go here, I'm 
just gonna say app get. And we're going to give  
101:41 - it another route. And I'm just gonna say example. 
And within here, we're gonna pass in a call back.  
101:48 - And now we're just going to say rez, that send 
heading example, route. So now if I save this, I'm  
102:03 - just going to hit Ctrl. C to kick us out, we're 
going to restart the server, so that it starts  
102:09 - with our newly saved file, head over to Chrome, 
hit refresh, you see that our index page is still  
102:18 - working. And if I go here and type example, you 
can see that we create another route, and that  
102:26 - it's hitting the example route now, as opposed 
to the index route. So now let's go back here,  
102:33 - this is all fine and dandy. Now I want to talk 
about Curie strings and route parameters. So I  
102:39 - want to start off with route parameters. And we're 
going to create another route. So I'm just gonna  
102:45 - say app dot get. And I'm gonna say example. And 
within here, I'm going to give it these colon, and  
102:55 - I'm just gonna say name. And that's going to be 
the name of that route. And I'm just gonna say,  
103:01 - ah, and then the same exact thing. So I'm just 
going to pass in a callback, I forget to add.  
103:15 - And then this time, what I want to do is access 
from the request object. And I'm just going to say  
103:23 - params. And what we want to do is actually print 
this out onto the console. Let's see what we get.  
103:30 - And the idea is that I want to get the value of 
name. And ah, so we're just gonna say res dot  
103:40 - send. And we're just gonna say hitting, actually, 
let's say example, with route params. So we're  
103:52 - just gonna save this, hit Ctrl C, I'm just going 
to say CLS, no app, head over to Chrome. We're  
104:03 - going to hit refresh. So our examples working, 
but now, we're going to pass information in so I'm  
104:11 - just going to pass in name. So Pedro and an age, 
I'm going to put 99. So I'm going to hit Enter.  
104:18 - And you can see example with rope params has been 
executed. So now if I take a look back at Visual  
104:26 - Studio code, you can see that when we hit this 
route here, and we print out what's within our  
104:35 - request dot params, we get an object. And this 
object contains the properties name and age,  
104:41 - and the values of Pedro and 99. So let's give a 
more detailed example. Instead of just giving a  
104:49 - generic answer. I'm just gonna print send the 
user back his name. So I say name plus Here,  
105:01 - I'm just going to say ah, and don't forget that 
this name, property and age is within our requests  
105:11 - that params. And all request dot params is, is an 
object. So I could say request dot params dot name  
105:21 - to access the name value. And I could say request 
dot params dot age to access the age property.  
105:29 - So now if I save this, and we're going to reset 
the server, CLS to clear the terminal node app,  
105:38 - head over to Chrome, hit refresh. And you can 
see that we're sending back to the user Pedro in  
105:48 - 99. And that we get the same output because we're 
still printing it. So that's how we would get data  
105:56 - from the user using route parameters. But there's 
also another type of data that you could send  
106:04 - back. And that's called Curie string parameters. 
So what is that? Well, if I go back here,  
106:11 - and actually, let me just type this up, I'm going 
to say console dot log. And again, we're going to  
106:17 - use the request object because the request object 
is basically what the client is sending us. So I'm  
106:24 - just gonna say, request that Curie. And here in 
Google Chrome, let's actually cancel this server.  
106:34 - I'm going to save this file, restart the server, 
head over to Chrome. Just going to go up here,  
106:46 - hit refresh. Go back to Visual Studio code. And 
you can see that we get an empty object. Now this  
106:56 - empty object is going to be our request, Curie. 
So it's just a Curie string parameter. And the  
107:02 - reason it's an empty object is because we haven't 
actually passed anything into it. So in order to  
107:08 - do that, there's going to go up here, we're going 
to use a question mark. And then it's going to be  
107:16 - the name of the property that you want. So 
I'm just going to make it up right now. I'm  
107:21 - going to give it a name of tutorial, and then 
followed by an equal sign, and then the value  
107:29 - you want to assign it. So I'm just going to say 
params. tutorial. And now if I hit Enter Here, you  
107:39 - can see that's pretty much the same thing that's 
happening. But if I go back to Visual Studio code,  
107:47 - you can see that our request, Curie object is 
no longer empty. We have a property of tutorial,  
107:57 - and we have params tutorial as a value. So now 
let's say that I want to pass more than just  
108:04 - the tutorial. So how would I pass multiple query 
string parameters. And if we head back to Chrome,  
108:11 - all we have to do is remember to start off with 
a question mark, the name of the query string,  
108:18 - and then the value. So if you want to pass in a 
second, curious string, what you can do is use  
108:25 - the Add sign or the app or stamp, whatever you 
want to call it. And I'm just going to give it  
108:31 - sort. And then I'm just going to say equal. And 
I'm going to give it the value of by age. And if  
108:41 - I hit Enter, head over to Visual Studio code. And 
you can see now that when we print out our Curie  
108:50 - string, you can see that we get an object that 
has tutorial. And it also has the property of  
108:56 - sort. So now you might be asking yourself, when 
should I use a route parameter versus a query  
109:04 - string parameter, you should use route parameters 
when you must have that data. So for example,  
109:11 - let's say name was an absolute must, I cannot have 
a blank name. And I cannot have a blank age. So I  
109:20 - would use a route parameter. And let's say that I 
want to give some optional settings. In that case,  
109:26 - I would use a query string parameter. 
So for example, when we pass then sort,  
109:32 - we could be sorting the data by age, 
and that would be an optional setting,  
109:37 - but I would need the name and the age to begin 
with, so I would use a route parameter for that.  
109:44 - And if the user wants to sort the data, then 
I will use a query string parameter for that.  
109:55 - In this tutorial, we're going to be talking 
about serving static files using Express Now  
110:00 - what do I mean by a static file, I mean, your 
HTML files, CSS, client side JavaScript, images,  
110:08 - videos, stuff like that. So to get started, 
we're just going to require a path module,  
110:14 - and is basically a utility module that deals 
with pass, just to make our lives a little bit  
110:21 - easier. And we're finished here, if I go 
down here, I can say app not use now use,  
110:30 - whenever you see app use, it means that I'm using 
middleware, the first argument is going to be the  
110:39 - alias for our static folder. So for example, if 
I was to hit control B, you can see that I have  
110:48 - a static folder here. And what I want to do is 
give this static folder, an alias, I don't want  
110:54 - people outside of my server to know that this 
folder is called static. But let's take a look  
111:02 - inside of it. We have an index dot HTML, we have 
example that j s. And we have a main dot CSS file,  
111:11 - just for an example. So now if I close that Ctrl 
B, I'm going to call it public. That's going to  
111:21 - be the alias for my static folder. The second 
argument is going to be a middleware function.  
111:28 - So I'm going to use a convenient method that 
express provides us so I could say Express dot  
111:36 - static. And then I'm going to say path dot join. 
Say dirname. R stands for directory name. Now,  
111:49 - dur name is a string. And this is going to give 
us where app that j s is. So if we take a look,  
111:58 - by pressing Control B, is going to give us where 
app dot j s is located. Now I want to go inside  
112:07 - to the static folder, because this is where all my 
static assets are. So if I hit Control V, again,  
112:14 - we'll pass in as a second argument, the name 
of the folder static. So I'm just going to end  
112:22 - this call in there says there's some error, 
and I'm missing a parentheses. So now here,  
112:32 - instead of just saying hello world, let's actually 
send a file. So I'm just going to remove this,  
112:39 - say res dot send a file. And we're going to use 
our path module. Again, to make things easier.  
112:48 - I'm going to say path dot join, we're going to 
give it the directory name that we're currently  
112:54 - in. We're going to go inside the static folder. 
And then I want to serve the HTML file. So the  
113:03 - HTML file is called index dot HTML. So now, if 
I was to save this, go down here, type node app.  
113:16 - Let's go over to Chrome. Now we're going to go 
up here, type localhost 3000. And there you go,  
113:26 - you can see our static HTML file has been served. 
If I type f 12. Let's take a look at the source  
113:34 - real quick. I can actually see it. And you can 
see within our HTML file that we're using public.  
113:45 - Now remember, we don't actually have a folder 
called public, we have a folder called static,  
113:50 - but to the client side is called public. And this 
main dot CSS file. Now this main dot CSS file is  
114:00 - working, because you can see that our h1 tag is 
red. And now if we go back down here, you can  
114:08 - see public j s and our example dot j s. And if 
I go to console, you can see that I printed out  
114:19 - onto the console testing client side. So that's 
basically the basics of serving static files  
114:26 - using Express. Now you can use this to use images 
and videos, and it'll be the same exact process.  
114:39 - In this tutorial, we're going to be talking about 
handling an HTTP POST request using Express. Now  
114:46 - an HTTP POST request is typically used when 
working with forms. So I have my form set up  
114:54 - right here. I have an email address field and 
a password field and if I was the hit submit,  
115:01 - that would be an example of a POST request. Now, 
obviously, we're getting an error from node cannot  
115:09 - post to this route. And that's because we haven't 
actually coded anything yet. So if we take a look  
115:16 - at Visual Studio code, you can see our form that I 
set up, action is going to be the route that we're  
115:24 - going to code. So I just put forward slash, the 
HTTP method is going to be a POST method. Here,  
115:33 - we see that we have our email field, and our 
password field, and our button of type Submit.  
115:42 - So now I'm just going to head over to App j, 
s. And I actually want to code the app dot POST  
115:48 - method. So if we take a look at our application of 
this, it's currently All I have is an app dot get.  
115:55 - This is the route and I want doing is serving the 
HTML file to the user. So in order to remedy this,  
116:04 - we're going to use a module that's going to parse 
the form data for us. And that module is called  
116:12 - the body parser module. And that module is called 
the body parser module. So to get started, we're  
116:19 - actually going to have to install this module. 
So I'm just going to come down here, cancel our  
116:24 - server, I'm going to say NPM, install body parser. 
So let that install. And now from here, what we're  
116:35 - going to do is require it into our application. 
So I'm just going to say Kant's. Body parser is  
116:42 - equal to require body parser. And now from here, 
what we're going to do is use middleware. So every  
116:54 - time we use middleware, we're going to call app 
dot use. So here, I'm just gonna say app dot use,  
117:02 - then I'm gonna say body parser dot URL encoded. 
And then within here, we're gonna pass in an  
117:11 - option called extended. And we're gonna set that 
to false. So and that was the semi colon. And all  
117:19 - this is doing is allowing us to parse URL encoded 
forms, it parses the data for us and attaches  
117:26 - it to the request body, the extended option is 
set to false because we aren't dealing with any  
117:32 - complicated objects. All we want is an email and 
password, which are both strings. So now that we  
117:40 - have that set up, let's actually code or app that 
post HTTP requests. So we have our get here. And  
117:48 - now I'm just going to go down here. And instead of 
saying app dot get, I'm going to say app dot post,  
117:54 - the first argument is going to be the route. 
And as you saw on the HTML file, the action  
118:01 - route is the forward slash. The second argument is 
going to be a callback function with the request  
118:09 - and rez object. And now from here, remember what 
the body parser does, it parses the data for us,  
118:19 - and then attaches it to the body of the request 
object. So now what I can do here is I could say  
118:26 - console dot log request dot body. And this is 
going to give us an object with the properties  
118:35 - of email and password. And now from here, usually, 
when you post something to the server, you usually  
118:44 - use whatever the user inputted, and you do some 
database work. So I'm just gonna say database  
118:51 - work, here. And once that database work is done, 
you assign a response or user. So I'm just gonna  
118:59 - say res dot send successfully, post that data. 
Now, I'm just going to hit Ctrl S to save,  
119:09 - go down here, I'm going to type in Node app, 
start up my server. Let's head over to Chrome.  
119:16 - And now if I hit refresh, just to reload it, 
let's type some random email. Random password,  
119:26 - hit submit. So now what happened here was I filled 
in my email and password I posted to the server,  
119:36 - I got a response back from the server saying 
everything was posted successfully. So if I go  
119:43 - back to Visual Studio code, you can see that our 
console dot log is working. We're printing out  
119:49 - the request dot body, and you can see that our 
form data has been successfully parsed. So if we  
119:55 - take a look down here on to the console, you'll 
see that we have an object With the property,  
120:00 - email and its value, and you also have property 
of password and its value. So that's pretty much  
120:08 - how you would make an HTTP POST request 
using Express and the body parser module.  
120:20 - In this tutorial, we're going to be talking about 
how we can handle JSON data using Express and the  
120:26 - body parser module. So in the previous tutorial, 
we talked about using the body parser module,  
120:32 - in order to handle URL encoded data. So what 
we're going to do is take this form from the last  
120:39 - tutorial, and convert it to post JSON data. So to 
get started, I'm just going to head over to Visual  
120:46 - Studio code. And right here, I have my 
index dot HTML file and our form pulled up,  
120:53 - what I'm going to do is add an attribute to 
the forum. So I'm just going to give it an ID,  
120:57 - and I'm going to call it form. And the reason for 
that is I want to prevent the default submission,  
121:04 - I want to post data using jQuery Ajax. So that's 
how we're going to post JSON data to our server.  
121:11 - So now that I have my ID, scroll down, and I 
already put our jQuery CDN here, just to make  
121:21 - the tutorial a little bit quicker. And we're just 
going to go here, and we're going to include our  
121:26 - script. So I'm just gonna say script. Now from 
here, we're just gonna say document dot ready.  
121:35 - And the first thing that we want to do is get 
our form. So I'm just say dollar sign, pound  
121:48 - sign form. And we're going to attach a submit 
handler to our form. And this submit handler is  
121:58 - going to take a callback function, which has an 
event as a parameter. So now, what I want to do  
122:07 - is prevent the default Submit. So we're just going 
to take the event that we get, and we're going to  
122:13 - call prevent default. And from here, we're going 
to use Ajax to actually make the POST requests.  
122:21 - And what we're going to do is post JSON data 
back to the server. So I'm just going to say,  
122:29 - dollar sign, Ajax. And this is going to take a 
bunch of configuration. So one of the properties  
122:37 - that we can use is called URL, and this is going 
to be the endpoint that we're gonna have at our  
122:43 - server. So I'm just going to say forward slash, 
second property is going to be type. And this is  
122:50 - going to be what kind of HTTP requests that we 
want to make. And we're gonna post JSON to the  
122:57 - server. So I'm just gonna say post. third argument 
is going to be the content type. And the content  
123:04 - type is obviously going to be JSON. So I'm just 
gonna say application, slash JSON. Next property  
123:14 - that we're going to use is called data. And this 
is going to be the actual form data that we want  
123:19 - to pass in. So how do we get the form data? Well, 
I'm just going to say, get our form. And then I'm  
123:30 - going to serialize it using the serialize array. 
And basically, this is going to take our form  
123:37 - data, so our email field and our password field 
serialize it within an array. And this is going to  
123:45 - be a JavaScript array object. But remember, we're 
posting JSON back to the server, because that's  
123:53 - the content type that we want. So we're just going 
to say JSON that string of phi and pass in this  
124:02 - data as an argument. So this is going to take 
the serialized array, and it's going to convert  
124:08 - it into JSON for us. Next, we're going to say 
success. And success is going to be invoked when  
124:17 - we have successful response back from the server. 
So I'm just going to say response. And we're just  
124:26 - going to print onto the console successfully. 
Got response. And we're also going to print out  
124:34 - the response that we actually got from the server. 
So once all this is done, let's scroll down a bit.  
124:39 - Everything looks good to me. So I'm just going to 
save our index dot HTML file. We're going to head  
124:48 - back to app.js. So this is our server. And 
down here, remember that we told our Express  
124:55 - application how to handle URL encoded data Now 
what we need to do is just say app dot use body  
125:04 - parser. And this has a method called JSON. Now 
this method is obviously going to parse JSON. And  
125:12 - it's going to attach it to our request dot body. 
So now if I just put a semicolon there, and when  
125:21 - we scroll back down, you can see our original post 
request is handled here. And what I'm going to do  
125:28 - is, instead of saying just plain text, we're gonna 
respond back to the client using JSON. So I'm just  
125:35 - going to say, res dot JSON. And we're going to 
pass an object. And we're just going to say that  
125:42 - it's been successfully posted. So now obviously, 
what res dot Jason does is takes a JavaScript  
125:49 - object and converts it into JSON for us. So now 
if I was to save this, and I'm just going to go  
125:55 - to terminal new terminal, and I'm going to say 
node app to run the server, go back to Chrome,  
126:04 - when I type localhost. And now to test this 
out, let's give it a dummy email and password,  
126:14 - click Submit. And now if I hit F 12, you can see 
form serial array is not a function. So let's take  
126:25 - a look at this. And we're getting an error. Let's 
actually take a look at that part of the code. And  
126:32 - that's because we did not include the dollar sign. 
So let's include that now. Let's save it. Go over  
126:42 - to Chrome. Now we're going to hit refresh. And 
type whatever we want. hit submit, go to console  
126:54 - and see that we successfully host that JSON to the 
server. A server responded by posting this object  
127:03 - back to us. If I go back to Visual Studio code, 
you can see that we have our serialized form data,  
127:11 - you can see that we have our serialized form 
data. And that it's not JSON, that this is just an  
127:24 - array. And the reason why you're not getting back 
JSON. And it's because our body parser module sees  
127:31 - that it's JSON and automatically converts it to 
a JavaScript object. In this case, it's an array.  
127:43 - In this tutorial, we're going to be talking about 
validating user input using joy. So what we're  
127:49 - going to do is validate the data coming in from 
this form. Now, the reason you would validate user  
127:54 - input server side is because you can never trust 
the data that you're receiving from the user. So  
128:01 - to get started, let's actually head over to Visual 
Studio code. And I'm just going to cancel out our  
128:07 - server. And I'm going to type NPM, install joy. 
And this is going to install the joy module. Now  
128:15 - from here, what we're going to do is actually 
require it into our application. So I'm going  
128:20 - to go up here, I'm going to type const, Joy is 
equal to require joy. So now that we have joy  
128:29 - in our application, let's actually go down to 
our request. So we have our GET request, which  
128:35 - basically serves the form to our user. And we have 
our post request, which is going to get the data  
128:41 - from our user. So from here, what we want to do 
is actually validate the data that we get within  
128:48 - our request body. And in order to do that, what 
we're going to do is create a schema. So what's  
128:56 - a schema, a schema is basically a blueprint, 
a set of rules that we want our data to have.  
129:03 - So we have an email field, and we have a password 
field. So what I want to do is make sure that the  
129:10 - email that the user gives me as a valid email, and 
likewise with the password field. So what we can  
129:17 - do here is I can come down here, and we can create 
a schema. Now remember, this is just a blueprint,  
129:26 - I'm going to say joy dot object. Now this is going 
to give us a joy object. Next thing we need to do  
129:35 - is call a method called keys. Now keys is going to 
work the same way that a regular JavaScript file  
129:43 - would work. You will have your key value pairs, 
and we're going to pass in the options. Now within  
129:50 - here, what we want to do is set the rules that the 
data that we're receiving must follow. So we have  
129:58 - a field called email. And within here, I'm gonna 
say joy, I'm going to say string. So what I'm  
130:06 - saying is, the email field must be a string value, 
I'm going to trim that data that I'm receiving,  
130:15 - I'm going to call a method called email. This is 
going to check to see whether or not this is a  
130:23 - valid email. And I'm going to call one more method 
called required. Now required does is if the user  
130:32 - sends me a no email, in other words, the user 
doesn't fill out an email, I'm going to get an  
130:38 - error because this field is required. So let's 
go back to our another property. And the next  
130:45 - property we have is password. So from here, I'm 
going to do the same thing, joy, I need it to be  
130:53 - of type string. And let's change it up for the 
password field. So let's say that I need the  
131:01 - password to be at least five characters. So I'm 
going to call the min method and pass in five,  
131:08 - I'm going to call the max method. And I'm going to 
pass in 10. So right now, this password must be a  
131:17 - minimum of five characters long, and a maximum 
of 10 characters. So between five and 10. And  
131:23 - the last method I'm going to call is required. 
And now let's end this with a semicolon. So now  
131:29 - that we have our blueprint, let's actually 
use it. So we're going to call a method  
131:34 - called validate. So I'm just going to say joy dot 
validate. And it's going to take three arguments,  
131:42 - the first argument is the object that you want to 
validate. In this case, remember, we use the body  
131:47 - parser to parse the form data and attach it to the 
body of the request object. So this is going to be  
131:55 - our first argument. The second argument is going 
to be our blueprint, which we just created, it's  
132:02 - called schema. And our third argument is going to 
be the callback function, that's going to take two  
132:09 - parameters. First one is going to be error, second 
one is going to be result. And what we can do is  
132:17 - find out our result. So if I say if error, this is 
going to execute true, if there's something wrong  
132:24 - with the data, so error is not know then this 
code will be executed. So if error is executed,  
132:32 - we know something went wrong. So I'm just gonna 
say res dot send, an error has occurred. But if  
132:45 - there is no error, what we can do is we could just 
say res dot send. And I can say, successfully,  
132:55 - post that data. Now just for the sake of this 
tutorial, I'm going to print out result, just so  
133:04 - you can see what the result is. Now, the result is 
basically just going to be the data that we passed  
133:10 - in. So it's just going to be the request body. And 
I'm going to go up here, and I'm going to print  
133:15 - out the error object. So now that I have these 
two out, what we can do is get rid of our old  
133:24 - code from the last tutorial. I'm actually going to 
save this, we're going to type in Node app. Let's  
133:37 - head over to Chrome. And from here, I'm just going 
to type in, actually, let's just refresh the page  
133:44 - real quick. Let's type in an email. And let's 
type in a password. And then if I hit submit,  
133:52 - you can see successfully posted data. So if I go 
back to Visual Studio code, you can see that our  
134:00 - email is right here. And it probably hit Submit 
twice because I probably clicked it twice. And  
134:06 - you can see that our result that's getting printed 
out is just the request that body is whatever the  
134:13 - user posted. And you would do all your database 
manipulation and calls here. So now let's actually  
134:20 - go back to Chrome. And this time, we're going to 
type localhost again. And stead of giving valid  
134:28 - data. Let's see what happens when we post invalid 
data. So I'm going to post valid data for email.  
134:34 - And for the password. Remember, we have to give 
it between five and 10 characters long. So I'm  
134:41 - just going to give it two characters long and 
let's see what happens. I'm going to hit submit.  
134:46 - And you can see the response we get an error has 
occurred. So let's actually take a look at this  
134:52 - in Visual Studio code. You can see this big long 
mess of mumbo jumbo So I'm just going to go back  
135:00 - up. And you can see the error that we're getting. 
It says validation error child password fails,  
135:11 - because password must be at least five 
characters long. So you can see our validation  
135:17 - is working. And this is pretty much the ins 
and outs of validating user input using joy.  
135:27 - This is going to be part two of my joy 
validation tutorial. So in this tutorial,  
135:32 - we're going to be covering how we can validate 
a nested object, as well as how we can validate  
135:37 - an array. So to get started, I pretty much 
stripped out all the Express stuff. And we're  
135:43 - going to simulate a user's requests. So for this 
example, we have this user input, and it has a  
135:50 - nested object. And it has a property of personal 
info with the properties of street address, city  
135:56 - and state. And we have preferences, which is going 
to be our array, and you can see what values their  
136:03 - array contains here. So the first values that 
we're going to start off with are string values,  
136:08 - and then we're going to move on to objects. So 
the way that I'm going to tackle this problem is,  
136:13 - I'm going to look at our user input, and I'm going 
to break it down into sections. So for example,  
136:20 - I'm going to develop a schema for personal 
info, and then I'm going to develop a schema  
136:26 - for preferences. So to get started, we're going 
to develop the personal info schema, first, I'm  
136:33 - just going to copy this, I'm going to come down 
here. Now I'm gonna say Kant's, personal info,  
136:41 - and then I'm just gonna add schema. Next, I'm 
going to create a joy object schema. So I'm just  
136:48 - gonna say joy dot object. Keys, we're gonna hit 
enter a semi colon down here, we're going to go  
136:58 - up copy street address, would just develop a 
schema like we normally would. So I'm just gonna  
137:04 - paste that street address is going to be joy dot 
string, dot trim, I'm going to make this required,  
137:14 - we're going to do the same thing with the other 
properties, go to city, copy this, go down here,  
137:22 - paste, and street address and city, we're going to 
make the same exact thing. And last but not least,  
137:31 - we're going to take the state. And it's going to 
be the same exact joy schema, except that we're  
137:39 - going to add that it has to be of length of two. 
So I'm just going to copy this, paste this here.  
137:46 - And we're going to use the dot length method 
and set that to two. So we're going for state  
137:55 - abbreviations. So now that we have our personal 
info schema out of the way, let's develop a schema  
138:03 - for preferences. So I'm going to copy this, we're 
going to go down here, I'm going to say Kant's,  
138:09 - preferences, schema. And this time, instead of 
using joy dot object dot keys, we're going to say  
138:19 - joy dot array. And this is going to give us an 
array schema. And we're going to use a helper  
138:27 - method called items. Now what items is going to 
take in as an argument is basically any schema you  
138:36 - want. In this case, what we want is an array of 
strings. So I'm just going to pass in the schema,  
138:42 - Joy dot string. So this is going to make sure 
that all the items that within their array are  
138:49 - off strings. Last but not least, let's actually 
combine these two to form one schema, I'm gonna  
138:55 - say Kant's schema. And I'm gonna say joy dot 
object, dot keys, pass in this object. And this  
139:09 - time, we're going to say personal info. And that's 
going to be equal to the schema we just created up  
139:16 - here. So we have our personal info schema. So I'm 
just going to copy this, paste this here. And now  
139:24 - if I go back to my array, we call it preferences. 
Copy that has this here. Preferences schema. Next,  
139:41 - let's actually call this so I'm going to go 
down here, I'm going to say joy that validate  
139:46 - the first argument is going to be the same as last 
tutorials. So we're just going to say user input.  
139:54 - second argument is the schema. So we're going 
to use the built in schema Now that we made,  
140:00 - which consists of the two different schemas 
that we created separately, last argument is  
140:08 - going to be the callback function. So I'll just 
say error result. I'm going to say if error,  
140:16 - we're just going to print out what the error is. 
Else, just print out the result. And the result is  
140:26 - just going to be the user input. So I'm just gonna 
save this, let's actually add a semicolon here,  
140:33 - save this, we're gonna type in Node app. And you 
can see that our data is validating. So the basic  
140:42 - premise is, if you're given a complicated 
object, break them up into their individual  
140:49 - schemas. And then you could combine them like 
so. Now I want to talk about, let's say that I  
140:56 - want an array of objects as opposed to an array 
of strings. So we're just going to go up here,  
141:02 - we're going to change preferences to reference 
array of objects. And then we have an example  
141:08 - object here. So this is a very simplistic example, 
we just have a property of code example. And it  
141:16 - has the value of a string. So example, one, two, 
and three. So we're just going to change this  
141:22 - through an array of objects. Let's go down here. 
And instead of specifying joy dot string here,  
141:29 - because we're not looking for strings anymore. 
We can say joy dot object, that keys and then  
141:41 - we just build our schema, like we did before. 
So in this case, we only have one property,  
141:47 - it's called example. And we're gonna 
give it the value of joy dot string,  
141:53 - dot required. So this was a very simplistic 
example, if you had a more complicated object,  
142:04 - you would do the same thing like we've been doing. 
So I'm just going to save this. And let's actually  
142:11 - execute this code, see if it's working node app. 
And you can see that it validates, and we didn't  
142:19 - get any errors. So that's basically how you can 
develop a schema for nested object, and how we  
142:27 - can develop schemas for arrays, and even create 
our own custom schema objects for those arrays.  
142:37 - In this tutorial, we're going to be talking about 
e j, s. Now what ej S is is a template language.  
142:44 - And that's going to allow us to write more dynamic 
web pages. So to get started, what we have here is  
142:51 - a static HTML file, you can see that we have dummy 
data here. So when it says you searched for stuff,  
142:59 - and we have search results of dummy data, now 
what we want to do is use this HTML file as  
143:07 - a template that we can use for serving dynamic 
data. So one way to do that is if we go back to  
143:15 - Visual Studio code, we can set the view of our 
Express application. And in order to do that,  
143:22 - we would go here, and we could say, app 
dot set is going to take into arguments,  
143:29 - we're going to specify the view engine, a second 
argument is going to be the template that you  
143:35 - want to use. So we're just going to say e 
j, s. Once we set the view engine to ej s,  
143:41 - we're going to have to hit Ctrl B. And we're going 
to have to create a folder called views. And this  
143:50 - is going to store our E j s templates. So I'm just 
going to go down here, right click New Folder,  
143:56 - and we're gonna call this views. Now Express is 
going to automatically know that our templates  
144:03 - are located in the views folder, because that's 
the default folder that looks for. So now if I  
144:09 - create my views folder, if I right click new file, 
and instead of saying index dot HTML, I specify  
144:18 - index dot e j s. So now that I have my index.js 
file, I'm just going to go to my index dot HTML.  
144:25 - I'm going to copy all this. And I'm just going to 
paste the code within my index dot e j s. So now  
144:35 - I'm just going to save this. I'm going to go to 
App dot j s. And what we do with templates is that  
144:42 - we've rendered on to the user. So I'm just going 
to hit Ctrl B and get rid of the package explorer.  
144:47 - And instead of sending a static file, this is 
going to remove this and now we're going to say  
144:58 - res dot render And then followed by the name of 
the file that you run to render index. Now, you  
145:08 - do not need the specified a dot e j s on the side. 
And that's because we already told express that we  
145:14 - are using ej s as the template. So now if I was 
to save this, just gonna hit Ctrl C, node app,  
145:23 - head over to Chrome, we're going to hit refresh. 
And you can see that we get the same exact output.  
145:32 - So what happened here? Well, when we render this 
index.js file, what's happening is the server is  
145:40 - going to look at this E js file for e. js code, 
it's going to execute it and then send back to the  
145:46 - client an HTML file. So now let's actually send 
data to sun back to our E js file. So from here,  
145:54 - I'm just going to give us a route parameter, 
I'm just going to say user query. And here we're  
146:02 - going to pass in an object. And this is going 
to be the data that we want to display within  
146:07 - our index.js template. So now I'm just going 
to give it a property. First, I'll say data,  
146:14 - then I'll give it a property of user query. And 
then we're going to pass in request dot params dot  
146:26 - user query. So now if I save this, I'm just going 
to hit Ctrl. C, just to exit out of our server.  
146:36 - Now we're going to go to our E js file. We're 
gonna go here to our template. And now from here,  
146:46 - we're going to specify less than or sent sign 
equal. What this means is I want you to output  
146:56 - onto the HTML file. Next, what we're going to do 
is access the data that we just passed in. So how  
147:03 - did we do that? Well, we gave it the property 
data, then we said, dot user query, afterwards,  
147:13 - we end it with percent sign, and then that. So now 
this is gonna look at our app dot j s, it's gonna  
147:21 - say, Okay, I want to render the Index page. And 
this is the data that I'm receiving. So we went to  
147:27 - data dot user query. So now if I was to save this 
index.js template, let's start back to server,  
147:36 - no to app. Let's go to Chrome. Hit refresh. And 
you'll see that we get cannot get forward slash.  
147:47 - And that's because we added a route parameter. 
So let's say the user searched for books,  
147:53 - for example. Then it says, Hey, you search for 
books. So imagine if this was a real website,  
148:02 - and we were on Amazon or eBay, you would do 
a search. So then on top of that web page,  
148:08 - you would get Hey, you searched for books, you 
searched for PCs, you search for whatever. So  
148:16 - that means I could use this ej s template for 
all the items within my website. So now, let's  
148:23 - actually add some dummy data. So if I go back to 
Visual Studio code, and what we're going to do  
148:30 - is instead of having hard coded stuff here, 
when the user types in, we searched for books,  
148:37 - we're gonna display a bunch of books. So I'm just 
going to go to App dot j s, we're going to pass  
148:44 - in more dummy data. So we have data user query, 
we're gonna pass in another thing. And I'm just  
148:51 - going to give it a Enter key to make it fit on 
one line. And we're going to pass in an array,  
148:58 - and this is going to be the search results. 
search results. Pass in an array, and we're  
149:07 - just going to say, book one, book, two, and Book 
Three. So now if I save this, go into my index,  
149:22 - e js file. Instead of saying dummy data, what we 
can do is, we could go to data, because that's the  
149:31 - object that we're passing in. We're gonna say 
search results. And then since it's an array,  
149:40 - we can access index zero. And this is going 
to give us our first position. And remember,  
149:46 - since we this is an E JS template, we're going 
to have to wrap this up within the following.  
149:53 - And now if I was to save this, let's go SQL Server 
restarted up, go to Chrome, hit refresh. And you  
150:07 - can see that now we're dynamically populating the 
web page. So now let's head back to Visual Studio  
150:15 - code. And what I want to do is, instead of just 
outputting data that search results that index  
150:25 - zero data that search results index one, what we 
can do is use a for each loop. So for example,  
150:32 - let's get rid of all this. And I started 
with that, we're going to pass in less than  
150:39 - percent sign, we're going to get our array. So 
what's our array at data, that search results, dot  
150:50 - for each, we get our result. And remember, we're 
going to end this with a percent sign less than,  
151:02 - and the reason why we don't have an equal sign 
here is because we are not outputting this onto  
151:09 - the HTML file. So for example, if I want to output 
this equal sign, if you don't want to output it,  
151:16 - no equal sign. Next, within here, what we're 
going to do is, we're going to display what  
151:25 - we want to output. So now what we're going 
to do is use less than percent sign equal,  
151:31 - because we actually want this to output to 
the HTML file. So I'm just gonna say, oh, II  
151:41 - result. And let's close our Li tag. So now we 
have to end this. So we're just going to end  
151:53 - it with percent sign, we're not going to use the 
equal sign because we do not want to output this  
152:00 - to the user. So now, if I was to save this, we can 
go down here Ctrl C, node app, go to Chrome, hit  
152:14 - refresh. And you can see that our search results 
gets dynamically added. So if we search for books,  
152:23 - and there was a million books, this code will work 
for a million books. If we searched for iPhones,  
152:30 - and there was only three types of iPhones, this 
code would work for three iPhones. So now let's  
152:36 - do an example involving conditionals. 
So we're just going to give a simple if  
152:40 - statement. If the user is logged in, we want you 
to display this, if the user is not logged in,  
152:47 - then we're not going to display anything extra. 
So now if I go back to Visual Studio code,  
152:52 - let's write an if statement underneath our 
h1 tag. So I'm just going to go here. I'm  
153:00 - gonna say this. If data logged in, and this is 
going to be a Boolean containing true or false,  
153:13 - but and this here, and now the meat of our if 
statement is going to be the HTML output that we  
153:24 - want to do. So now I'm just going to say h2. You 
are logged and as data dot username and sent sign,  
153:40 - and then let's close our h2 tag. Now we have 
to wrap up our if statement. So let's close  
153:50 - our if statement. And all we're going to do is 
do the following ecgs. close our if statement.  
153:58 - And remember, we're not using the equal sign 
because we're not wanting to output this. And  
154:05 - we're not using the equal sign up here because 
we don't want to output this if statement. So  
154:10 - now if I was to save our index.js file, let's go 
to App dot j s. And we're going to pass in those  
154:19 - properties that we added to our index.js file. 
So we passed in logged in. And for this example,  
154:29 - we're just going to set true and the username is 
going to be this. So I'm just going to go to index  
154:40 - that ETS just to see if we matched up properly. 
Otherwise, we're going to get an error. logged in  
154:48 - username here. Make sure everything matches up. 
Let's save this Ctrl C, node app. Head over to  
155:01 - Chrome, hit refresh. And you can see that since 
we are logged in, we're displaying our h2 tag,  
155:08 - you are logged in as so. And so if we set that 
to false, our h2 tag wouldn't appear. So that's  
155:15 - basically the ins and outs of how you can 
use ej s within your Express application.  
155:24 - In this tutorial, we're going to be talking about 
what middleware is, and how we can create our own  
155:30 - custom middleware. So middleware is basically the 
code that gets executed between the user request  
155:37 - and the server itself. Now, in the previous 
tutorials, we already used a middleware, and  
155:42 - that middleware was within the body parser module. 
So if we take a look at our Express application,  
155:49 - on line five, we say app dot use, and then as 
an argument, we pass an A function. And this  
155:57 - function is a middleware function, that when the 
user makes a request, this function will take the  
156:04 - user's request and process it. In this case, the 
body parser dot JSON function checks to see if  
156:11 - the user have sent any JSON data, processes that 
and then attaches it to the request dot body. And  
156:19 - then it calls a function called next, to let the 
server know that, hey, we're done processing this  
156:26 - request, you can send a nother request. So to 
get started, we're just going to go down here,  
156:31 - I'm going to say app use. And then we're 
going to pass in our own middleware function,  
156:38 - that's going to get executed whenever the user 
makes a request. So this should be very familiar,  
156:44 - we're going to pass in the first parameter is 
going to be the request object, their response.  
156:49 - And then the final parameter is going to be the 
next method. So now we already are familiar with  
156:59 - the request object and the response object. So 
what is this next method, this next method must be  
157:07 - invoked whenever you create a custom middleware. 
So what the next method is responsible for,  
157:13 - is to let Express know that, hey, I'm finished 
processing this request. If you do not call the  
157:20 - next method, what's going to end up happening 
is you're going to timeout the server, because  
157:25 - it has no idea whether or not you're finished 
processing that request or not. So right now,  
157:30 - I'm just going to say next, and we're just going 
to call it. And to make things a little bit more  
157:35 - interesting. let's actually go up here. And 
I am going to print out the request, that URL  
157:45 - and the request dot method. So now, if I was to 
save this, let's actually restart the server,  
157:57 - I'm just gonna hit Ctrl. C, node app, we're going 
to go to Chrome. I'm going to hit refresh. Now  
158:06 - when I hit refresh, what I did was make a get 
request to the server. So let's actually take a  
158:12 - look at Visual Studio code to see what happened. 
And you can see that our middleware is running.  
158:19 - So we made a request, it gives us the URL, it 
gives us the method of the request. So we made a  
158:26 - get request when we hit refresh. And then we said 
next, which let Express know that, hey, he's done  
158:33 - processing this. And then it got to this point 
where we just sent res dot send middleware onto  
158:43 - the user. So that's why you see that we got this. 
Now let's change this up. So instead of saying,  
158:52 - forward slash, because we got to get route there, 
let's just make something up. Now, if I hit Enter,  
159:00 - you can see Can I get whatever this route is, 
but that's okay, because we're not interested  
159:07 - in that. We're only interested in the middleware 
for this tutorial. And you can see once again,  
159:13 - that our middleware is running fine. So 
whenever there's a request made from the user,  
159:19 - this middleware function is going to get executed. 
And you can see that our route was printed out.  
159:27 - And the type of request was also printed out onto 
the console. Now, this is all fine and dandy. But  
159:35 - as we have it right now, whenever we use App dot 
use, and we have our middleware, any user request  
159:42 - is going to get processed by this middleware. 
Let's say that I only want this middleware to  
159:48 - execute when a certain route gets requested. So 
right here, I'm just gonna go here, and I'm just  
159:57 - gonna say example. This is gonna be our route. 
And now, whenever we call this example, route,  
160:08 - it could be any type of request, that could be 
a get request, post request, put, elite, doesn't  
160:14 - matter, this middleware is going to execute. But 
if it doesn't match this example route, then it's  
160:21 - not going to execute. So let's save this. And I'm 
just gonna hit Ctrl, C, node app, start this up  
160:30 - again. And now I'm just gonna hit refresh. Go back 
to Visual Studio code. And you can see that our  
160:39 - middleware is not executing. But if I go up here, 
type example. Go back to Visual Studio code. And  
160:51 - you can see that our middleware is executing just 
fine. And the last thing that you should note that  
160:57 - middleware functions can do is modify the request 
object and the response object. So going back to  
161:04 - our body parser example, it parses the user's 
request and searches for JSON, and then attaches  
161:11 - it to the request dot body. So to give a trivial 
example, I can say take the user's request,  
161:19 - and I can add a property called banana. And I 
could assign it the value of banana. And for the  
161:29 - sake of simplicity, since we already have this 
route here, we're just going to get rid of all  
161:35 - this. And within our get route, we're just gonna 
say, console dot log requests that been then. So  
161:50 - let's end that with a semicolon. Let's double 
check everything. And this looks good. So I'm  
161:57 - just going to save this. And we're going to 
restart the server. Now, the app, we're going to  
162:03 - go to Chrome. And we're going to hit our root. And 
there we go. If we go back to Visual Studio code,  
162:12 - you can see what's going on here, we made a 
request to the server, the server did some  
162:19 - processing the same thing that body parser did, 
and then adds to the request object. And in this  
162:27 - case, we just added banana, gave it a value of 
banana. And then here, when we got the request,  
162:34 - from our get route, you can see that we get the 
output of banana. So that's pretty much the ins  
162:41 - and outs of how you can create your own custom 
middleware, and how middleware works in general.  
162:51 - In this tutorial, we're going to be talking about 
the Express router. Now what the Express router  
162:57 - allows us to do is separate our routes into 
different files. This makes our code a lot more  
163:03 - manageable, as opposed to just sticking our routes 
within the app dot j. s file. So to get started,  
163:11 - I'm just going to hit Ctrl B to bring up our 
Explorer, I'm going to create a new folder to  
163:16 - store our routes. So I'm just going to right click 
here, new folder. Let's call that routes. And  
163:23 - we're going to create a new file called people. 
So this is where we're going to store our our  
163:30 - people routes. So I'm just going to hit Ctrl B 
again. And since we're using the Express router,  
163:37 - we're obviously going to need to include the 
Express module. So I'm just going to say const.  
163:43 - Express is equal to require Express. Next, we're 
going to call Express dot router, which is a  
163:54 - method that's going to return to us a instance of 
the router. So we're just going to say that within  
163:59 - a variable. So I'm just going to say Kant's route 
is equal to express dot router. So now that we  
164:09 - have our router instance, what we can do is setup 
our route. So we already know how to do that. So  
164:15 - I could say route back get. And we're just going 
to give it the path. And we're going to give it  
164:21 - the callback. So the request object response. And 
we're just going to say res dot send forward slash  
164:31 - being hit. Now let's just create a another row. 
So I'm just gonna copy this. For example, and I'm  
164:42 - gonna call this example. And let's say example, 
being hit. Now, we're not done yet. So right now  
164:52 - we have this route here. But how do we expose this 
route so that our app.js file can access Well,  
165:00 - in order to do that, we're going to have to use 
module dot exports. So I could go down here,  
165:06 - type module dot exports. And then we're just going 
to export this route that we created. So now I'm  
165:14 - going to save this, we're going to head back to 
our app.js file. And now down here, we're going  
165:22 - to have to actually require the people route. So 
how do we do that? Well, I'm going to create a  
165:27 - variable called people. And we're just going to 
require the file. So I'm just going to say dot  
165:34 - forward slash, I'm going to go inside the routes 
folder. And then I'm going to include our people  
165:41 - file. But we're not done yet. Remember, on line 
three, we created an express application. So now  
165:49 - we need to tell our Express application that 
we want to use this people were out. So let's  
165:55 - go down here. I'm going to say app dot use. And 
we're going to give it the base URL. So I'm just  
166:03 - going to say for slash people, and then we're 
going to pass in the people route as the second  
166:10 - argument. So it's going to pass on people. So 
now if I was to save this, head over down here,  
166:17 - node app, let's go to Chrome. And I type localhost 
Port 3000. And that's because we do not have a  
166:30 - base URL. Remember, we gave it people. So this is 
our base URL for this peoples row. So right now,  
166:42 - this forward slash would be accessed if I just 
typed people at the end of localhost. So I'm  
166:48 - just gonna add that people. And now you can see 
our four slashes being hit. And if I add another  
166:58 - forward slash, and do example, you can see our 
example route is being hit. So now what happens  
167:07 - if you want to add middleware to these routes, so 
I'm just going to go back to Visual Studio code,  
167:11 - we're going to go to our people route. And within 
here, I could say route.us, and then pass in our  
167:23 - function, our middleware function that we want 
to execute. So I could pass in my request object,  
167:29 - my rez, and next. And now I'm just gonna say, 
console dot log middleware being used. Now when  
167:46 - I use route that use, all requests is going 
to go through this middleware. So remember to  
167:52 - always call next, if you ever creating your own 
custom middleware. And now if I was to save this,  
167:59 - let's hit Ctrl C, node app. When I go to 
Chrome, hit refresh. And you can see that  
168:12 - our middleware is being used here. Now, this 
middleware is only going to be used within our  
168:18 - people out. If we had another route here. Let's 
say instead of people we had an animal route,  
168:25 - this middleware is obviously not going to 
get executed because this middleware is  
168:31 - only specified to work with our people route. 
So that's pretty much the ins and outs of how  
168:36 - you can use the Express router to actually 
separate your routes from the app.js file.