00:00 - In this lesson, we will talk about one of the 
most famous and fundamental algorithms in computer  
00:06 - science binary search, we find the application of 
binary search in a large number of problems in a  
00:13 - large variety of problems in computer science. But 
here, let's try to learn it in its simplest form.  
00:20 - And to do so, we will define a problem first, 
the problem is given a sorted array of integers,  
00:28 - a sorted array means that the elements in the 
array are arranged either in increasing order  
00:33 - or in decreasing order like in this array, here 
the elements are arranged in increasing order,  
00:38 - let's say the name of this array is a the size 
of this array is nine. So we have index starting  
00:46 - zero till eight. Now given such an 
array and a number or an integer x,  
00:53 - we want to find out whether x exists in this 
array or not. And if x exists in this array,  
00:59 - then we want to find out the position at 
which x exists in this array. So for example,  
01:06 - if x is at one does it even exist in the 
array? Yes, it even exists in the array and  
01:13 - it exists at index seven, does 25 exists in 
the array no 25 does not exist in the array  
01:21 - does 21 exist in the array? Yes, 21 exists in 
the array at position three at index three.  
01:28 - Now, what would be the logic to find out whether x 
exists in this array or not? One simplest approach  
01:35 - can be that we can scan the whole array to find 
out the desired number. So we start at index zero,  
01:43 - and compare this element with x. If it is equal 
to x, then we are done with our search we are we  
01:48 - have found the element in the array. If not, we 
go to the next element. And we keep on comparing  
01:54 - with the next element until either we are finished 
with the array, or we find the number. So let's  
02:00 - say if we wanted to find 63 in this array, then 
our search will be over when we teach index six,  
02:08 - we start at index zero and our search will be over 
at index six. If we wanted to find a 25 our search  
02:15 - will be over at index eight with the 
conclusion that 25 does not exist in the array.  
02:20 - This approach will work irrespective 
of whether the array is sorted or not.  
02:25 - And if I have to write the code for this, 
it will be pretty straightforward. Let's say  
02:29 - I want to write a method search that takes an 
array A its size N and the element sorry number  
02:38 - x to be searched for and the code would be we 
will run a loop starting zero till n minus one.  
02:46 - So for I starting zero to n minus one, 
if the element at index i is equal to x,  
02:54 - then we return I which means returning the 
position at which we have found element x and  
03:00 - our search will be over. And if we cannot find 
any such AI then we return minus one, let's say  
03:06 - returning minus one means that we could not find 
the element we could not find x in the array.  
03:13 - Now with this algorithm, if we are lucky, we 
will find x at first position itself. So in  
03:19 - the best case, we will make only one comparison 
and we will we will be able to find the result  
03:25 - in the worst case when x would not even be 
present in the array we will scan the whole  
03:32 - array we will make n comparisons with all the 
elements in the array and then we will be able to  
03:37 - give back a result that hey x does not exist 
in the array. So the time taken in the worst  
03:42 - case is definitely proportional to the input 
size of the array, sorry, size of the array.  
03:48 - Or in other words, we say that this would 
be big O of n in terms of time complexity,  
03:55 - it's always good to analyze the running time 
of an algorithm in the worst case and find out  
04:00 - the upper bound of the time taken. Now, in this 
case, the time taken grows as a linear function of  
04:06 - n. So, we also call this search linear search. And 
once again, if we are using linear search, we are  
04:14 - not using any property like the array sorted or 
not whether that is sorted or not this will work.  
04:20 - Now, let us try to improve this algorithm 
using the extra property of the array  
04:25 - that it is sorted and I will make some space here 
first. Let us say we want to find out whether 13  
04:33 - number 13 exists in the array. So x is 13. And we 
want to find out whether x exists in the array.  
04:44 - Now we will use a different approach this time 
instead of instead of comparing x with the first  
04:49 - element, as we do in the case of linear search, 
we will compare it with the middle element in  
04:54 - the array. Now the size of this array is nine so 
the middle element will be at index four Now there  
05:01 - can be three cases here. case one can be that x is 
equal to the middle element. If x is equal to the  
05:10 - middle element, we have already found 
x in the array. case two can be when x  
05:18 - is less than the middle element, and case three 
can be that x is greater than the middle element.  
05:28 - Clearly, if x is equal to the 
middle element our search is over.  
05:33 - Because we have found x in the array, if x 
is less than the middle element, then because  
05:38 - the array is sorted, it lies before the middle 
element. And we can discard the middle elements,  
05:46 - middle element and all the elements after middle 
element. Similarly, if x is greater than the  
05:51 - middle element, it lies after the middle elements. 
So we can discard all the elements before the  
05:57 - middle element, and of course, the middle 
element as well. So in case two, and three,  
06:02 - we discard half the elements from our search space 
and reduce our search space. So in this example,  
06:09 - when x is 13, initially, our search space is the 
whole array, X can exist anywhere in the array.  
06:15 - Now we compare it with the middle element, which 
is 36. Now x is less than 36. So it exists,  
06:21 - it should exist somewhere before 36. So we 
discard all the elements after 36 and 36, as well.  
06:33 - So now the problem gets redefined, we need 
to search x only between index zero to  
06:39 - three. So how do we keep track of the search 
space, we keep track of the search space using  
06:46 - two indices start and end. So initially, 
the start would be zero, and n would be  
06:55 - the last element in the array, in this case, 
the index eight because initially the whole  
07:00 - array is our search space. And we calculate 
made as start plus n upon too. Now once we  
07:08 - find out our reduced search space, we adjust 
Start and End accordingly. So in this case,  
07:14 - after comparing 13 with 36, and discarding half 
of the array, our end now becomes index three,  
07:22 - which is nothing but one less than the middle 
element. Now we again find out the middle  
07:27 - element in this reduced search space. So here the 
middle element will be three plus zero by two,  
07:33 - if we take only the integral part three plus 
zero by two would be 1.5. And if we take the  
07:38 - integral part the middle element will be 
index one once again is it equal to x?  
07:45 - No six is not equal to 13 is x less than the 
middle element? Is it case two? No, it is not x  
07:52 - is greater than the middle element. So this time, 
we discard the middle element and all the elements  
07:57 - towards its left and this time we shift start to 
mark our new search space. Now, the new search  
08:04 - space is starting at index two and ending at index 
three. Now, what is the middle element three plus  
08:11 - two is five five by two is 2.5 and the integral 
part is two. So this is our middle element.  
08:19 - So x is not equal to middle element we have found 
our element. So we are done with our search.  
08:27 - This kind of search where we reduce the search 
space into half at each comparison is called  
08:33 - binary search. Once again we are able to reduce 
the search space by two or in other words,  
08:39 - we are able to reduce the search space into 
half only because the array is sorted array  
08:44 - being sorted is a precondition for binary search. 
Okay, so let us now write code for this algorithm.  
08:51 - I will write a method binary search 
that we'll take as argument and array A,  
08:58 - its size N and a number x to be searched for in 
the array and I will initialize two variables  
09:06 - start to zero and end to n minus one. So start 
and end define our search space initially the  
09:14 - whole area is the search space. Now, 
I will write a condition here while  
09:19 - start is less than or equal to and I'll come 
back to why I am writing this condition. So  
09:26 - while this is true start is less than or 
equal to and we will find out the middle  
09:33 - index of the search space as start plus end upon 
two. And now we will write three cases. If the  
09:41 - middle element is equal to x, then our search is 
over. We return the index stored in the variable  
09:48 - made and exit from the function. If x is less than 
the middle element, then we need to discard all  
09:56 - the elements having index greater than or equal 
made. So our end of the search space now becomes  
10:03 - mid minus one. And in the third condition, 
which will be x greater than the middle element,  
10:12 - which will be the default condition after these 
two if and else if we need to discard all the  
10:17 - elements with index less than or equal to 
mid, so, our start becomes mid plus one.  
10:28 - And if we exit this while loop 
without returning anything,  
10:32 - then we return minus one, which will mean that we 
were not able to find the element x in the array.  
10:40 - Now, why this wild statement here with a 
condition start less than or equal to end,  
10:46 - what we are basically doing in our algorithm is 
that we are reducing our search space recursively  
10:51 - by adjusting the start and the end pointer. Now, 
there must be an exit condition to our recursion,  
10:58 - the exit condition can be either we find the 
element in the array, so, we return and exit  
11:03 - or we exhaust the whole search space when start 
is equal to end or start is less than E and then  
11:11 - we still have such space, when start is equal to n 
then our space has only one element. So, when this  
11:18 - condition becomes false, we have exhausted 
our search space, we need to exit the loop  
11:22 - and we need to return minus one to tell that the 
element the number x does not exist in the array.  
11:30 - Now, once again in this case in the best case, 
we can find the element x in just one comparison,  
11:36 - when the first middle element itself will be the 
element x in the worst case, we will keep reducing  
11:42 - the search space till the search space becomes 
one element. So, from n we reduce to n by to  
11:49 - and from n by two we reduce to n by four and we 
go on till our search space becomes one. Now, how  
11:55 - many steps does it take? Let's do some math here. 
Let's say it takes k steps to reduce n to one  
12:04 - by keep by dividing by two at each step. 
So, n by two upon K will be equal to one  
12:11 - and if you solve this, then k will be equal to log 
of n the base will be two. So, in the worst case,  
12:19 - binary search will take log n comparisons and 
so, the time taken also in the worst case is  
12:24 - proportional to log in or in other words, it 
is big O of log n in terms of time complexity  
12:31 - and big O of log n is a lot lot lot more efficient 
than o n algorithm. So this was binary search,  
12:38 - we will take more problems on binary search 
in the coming lessons. Thanks for watching.  
12:48 - In the previous lesson, we learned about binary 
search as an efficient algorithm to find or search  
12:55 - element in a sorted data in a sorted collection. 
In this lesson, in some real code, we will see how  
13:02 - to implement binary search. And we will also 
see what are the common errors that happen  
13:08 - while implementing binary search. But before that, 
a quick recap, let's say we have a sorted array of  
13:15 - integers something like this, the elements are 
arranged in increasing order and the size of  
13:21 - the array is six. So the indices are from zero 
to five. Now, let us say we want to find out  
13:26 - whether the number 10 exists in this array or 
not programmatically using binary search. Now,  
13:32 - in binary search, what we do is we take two 
pointers to variables that point to that initially  
13:39 - point to the first and the last element in the 
array, we may call them start and end pointers,  
13:47 - we may call this variable start and end or we 
may also call this low and high to mark the lower  
13:53 - index and the higher index. Now start and end 
these two variables at any stage in our algorithm  
14:01 - give us the range in which the element can 
the element may exist. So this at the start  
14:07 - of the algorithm, the element may exist anywhere 
within the array. So that's why Start and End are  
14:14 - pointing to the first and the last element. Now we 
calculate middle point using the equation middle  
14:20 - is equal to low plus high upon two or start plus 
end upon two and we take only the integral part.  
14:26 - So here five plus 0.2 would be 2.5. And taking 
the integral part will give us this index two  
14:32 - as the middle index. So we are searching for 10 
number 10. And initially we are in a state where  
14:38 - lower index is zero, higher index is five and so 
mid index is two. Now we see that the element at  
14:47 - the middle index is the desired element. If it 
is the desired element our search is over. So  
14:52 - the element at the middle index is six is six 
equal to 10. No it is not. Now we see whether  
14:57 - this element is greater than The target element 
or less than the target element, now six is less  
15:04 - than the target element which is 10. So we 
discard six and all the elements before six,  
15:10 - because they are also less than 10. And we 
shift start to point at index three. So we go to  
15:17 - this state lower index three higher index five 
and now we search for our number in this part  
15:23 - of the array only. Now if we calculate mid and 
mid is equal to four five plus three upon two,  
15:29 - is it equal to the target element 10? Yes, it is 
equal to so we have found found our element on our  
15:35 - search is over, we found 10 at index four. Okay, 
what if we were we were searching for the number  
15:41 - nine in the array, if we were searching for nine 
till this tape, it would have been the same thing.  
15:47 - Now at this step, the middle element is 10 we 
compare it with nine and I'll also modify it  
15:52 - here now 10 is greater than nine. So definitely 
nine can only exist before 10 we need to discard  
15:58 - this part of the array and we need to go to 
a state where our search space is defined  
16:03 - by low equal three and high equal to three now 
three is both low and high and mid element of  
16:08 - this range would also be three only. Now, this 
middle element is also not equal to our desired  
16:14 - number nine is not equal to eight. Now, once we 
have only one element in our search space and  
16:19 - we have still not found our desired element our 
search is over and we could not find the element.  
16:28 - Let us now implement binary search 
and I will write a C program now.  
16:33 - Okay. So, what I will do here 
is I will first write a method  
16:37 - named binary search that will take an integer 
array its size, let's say the size of the array is  
16:46 - n and let's say the element to be searched for 
is x and this method returns an integer which  
16:54 - will be the L index of x if it is found in the 
array. Now, we will declare two variables low  
17:01 - and high and initialize them to zero and n minus 
one respectively low and high at at any point  
17:10 - give us the segment within which x may lie okay. 
So, now we declare another variable made that  
17:17 - is calculated as low plus high upon two. Now, we 
compare x to the element at index made and there  
17:26 - can be three conditions here first condition 
will be when x is equal to the middle element  
17:34 - the element at index made and in this case our 
search is over we will simply return the index  
17:40 - made and when we return from our method we exit 
it now the second case can be when x is less than  
17:48 - a made now, because x is less than the 
middle element it will lie before made.  
17:54 - So, now we redefine our segment by shifting end 
to shifting the higher index to mid minus one  
18:04 - and the should be as f okay and the third and 
the last condition which will be the default  
18:10 - condition here when x will be greater 
than the middle element in this case,  
18:14 - we will redefine the segment by adjusting the 
start are the lower index and lower index will  
18:21 - be equal to mid plus one. Now, we need to keep 
repeating these three steps again and again.  
18:28 - So, how do we do that, so, we will definitely need 
a loop. So we will put a while loop here. Now,  
18:34 - when do we stop executing these steps we 
stop either when we find elements. So,  
18:40 - either when we return or when we are done 
looking at all the elements. So I will put  
18:44 - a condition here while low is less than or equal 
to high, when low becomes greater than high then  
18:51 - the segment defined by low and high will not 
be a valid segment, Melo is equal to hi then  
18:58 - we will have only one element in the segment. 
Now if we exit this while loop without returning  
19:06 - anything, then we can say that the element x is 
not in the array let's say we return minus one to  
19:12 - say that x does not exist in the array okay. So 
this is the binary search method. And and let  
19:19 - us now write the main method and try to use this 
function. In the main method, I will first declare  
19:27 - and initialize an array let's say the name of the 
array is a and we fill some elements into this  
19:35 - array in sorted order. Remember, the array being 
sorted is a precondition for binary search. Okay,  
19:42 - so this is an array of size eight. Now let's ask 
the user to enter a number that we will search in  
19:48 - array. So we will write a printf statement here 
and now let us in a take input of this number.  
19:55 - Now I will call binary search to search 
whether this Number exists in the array or not  
20:02 - size of the res eight and we want to find out 
x Okay I will rather name this as x, because  
20:11 - we have been naming the target element 
as x throughout okay. So, now if  
20:18 - index which is the return from the method binary 
search is not equal to minus one then we have  
20:24 - found the element x in a. So, at this stage we 
will print something like number x is at index  
20:32 - index index is the variable name as well else we 
will print that we could not find x in the array.  
20:40 - Let us now run this program and see what happens.  
20:44 - So, we are asked to enter a number let's say 
we want to search for number 15 in the array  
20:50 - okay. So, this says that number 15 is at index 
six and let us now try to search a number that  
20:56 - does not exist in the array let's say we want to 
search for 18 and output is number 18 not found  
21:05 - there are some common errors that happen in 
binary search implementation resetting these  
21:11 - indexes low and high should be done correctly 
and we should always be careful about this  
21:18 - exit condition from the loop. One more common 
error is when people do not put this bracket here  
21:27 - now, what will happen here is that the 
precedence of division operator is more  
21:34 - so, high by two will be calculated first and 
then it will be added to low so, this bracket  
21:38 - is important we need to put this bracket here 
and some people also calculate mid as instead  
21:45 - of calculating it as low plus high upon two we 
also calculated sometimes as low plus high minus  
21:52 - low upon two and this is a better way of doing 
it because sometimes low plus high can exceed  
21:59 - the maximum value that an integer can store. So, 
like a 32 bit integer or 32 bit signed integer  
22:08 - can store maximum value of two to the power 
31. Now, if both low and high are pretty high,  
22:13 - then high plus low will exceed two to the power 
31 and cause issues in our program execution  
22:21 - it should be pretty evident that this expression 
evaluates to high plus low upon two only. The only  
22:27 - difference is that we are avoiding overflow by 
not calculating high plus low in this expression.  
22:34 - Okay. So, this was binary search implementation. 
And in this implementation we have used loop so we  
22:41 - have written a an iterative implementation, you 
can write binary search using recursion also,  
22:46 - I would recommend that you try that on your 
own. In the coming lessons, we will see more  
22:52 - variations of binary search and its application 
in other scenarios. So thanks for watching.  
23:02 - In our previous lesson, we learned about binary 
search and we also implemented binary search,  
23:09 - but we implemented an iterative version of binary 
search in which we used loop to write our program.  
23:16 - Now in this lesson, we will write binary 
search using recursion. Let us first quickly  
23:22 - write an iterative version of binary search. So, 
I will write a method binary search that will take  
23:28 - as argument a sorted array the size of the array 
n and an element x that is to be searched for,  
23:36 - then we initialize two variables low and 
high low to zero and high to n minus one.  
23:44 - And we say that while low is less than or 
equal to high, calculate middle index as  
23:49 - low plus high upon two. It's a better practice to 
calculate mid as low plus high minus low upon two,  
23:58 - which is the same thing except that we are not 
calculating low plus high sometimes low and high  
24:04 - individually are within the limit of within the 
range of an integer variable but high plus low  
24:10 - overflows the range or limit of an integer 
variable. Now there are three conditions if  
24:17 - x is equal to the middle element we have found x 
in the array so our search is over we return the  
24:22 - index made and exit else if x is less than the 
mid element, we are just high to mid minus one  
24:31 - two to say that we discard anything which 
is on or after made, because x is less than  
24:38 - the middle element and that is sorted as if x is 
greater than a made which should be implicit here.  
24:45 - For the third condition. As the third condition 
in this case we said low as made plus one.  
24:52 - And if we come out of this while 
loop without finding anything,  
24:56 - we will return minus one to say that x does not 
exist. In the array, what we are essentially doing  
25:02 - here is that if we have an array in which elements 
are in increasing order, then we first compare  
25:08 - x with the middle element. And if x is equal to 
the middle element, it's fine. If x is less than  
25:14 - the middle element, it must exist before 
this element in this highlighted section,  
25:20 - and if x is greater, it must exist after 
the middle element in this particular  
25:24 - highlighted section. And we keep on retied 
repeating this process in the new segment.  
25:32 - until either we find x or we cannot divide the 
search space any further at low equal high our  
25:39 - search space becomes or rather reduces to size one 
reduces to only one element. After that we cannot  
25:46 - divide it any further. Binary search is a typical 
example of a divide and conquer algorithm in which  
25:52 - at each step we are dividing the problem into 
half. Let us now write recursive implementation.  
25:59 - So once again, I will write a method binary search 
that will take a sorted array A and this time the  
26:07 - arguments will change a little we will take two 
arguments low and high to mark the segment of  
26:12 - the array in which x may lie at any stage x is the 
element to be searched for. And the logic would be  
26:19 - something like once again, we will calculate the 
mid index. And then we will have three conditions.  
26:26 - If we find x, that's good, we return the index at 
which we have found it. If x is less than a made,  
26:33 - we call binary search recursively on the range 
low. And I'm running short of space here. So  
26:40 - I'll create some space here. And we will run 
the we will call binary search recursively for  
26:48 - index low to mid minus one. So x is now to be 
searched between index low to mid minus one  
26:55 - else if x is greater than a mid, which 
will be the third condition anyway,  
27:01 - we will return binary search from mid plus 
one to high so we make a recursive call to  
27:07 - search eggs from index made plus one 
tail Hi, when we write recursion,  
27:12 - we should always look for a base case a base 
condition where we would stop our recursion  
27:18 - in this case, we will stop our recursion if we 
find the element. So, this case will return an  
27:22 - exit and we will not make any further recursive 
call, but what if we do not find the element  
27:28 - what what if we do not find x in the array we 
have another base condition for that where we  
27:33 - need to exit if low is greater than high then we 
do not have a valid segment in the array. And in  
27:40 - this case, we can say that we have exhausted our 
search space. So we return minus one to say that  
27:46 - x does not exist in the am short of space here. So 
I'm writing these two statements in the same line.  
27:53 - So, these two are our base conditions that 
would cause the recursion to stop or exit  
28:00 - and this condition low greater than highs the 
same condition which we are checking here to  
28:04 - stop the loop. Let us now quickly simulate this 
recursion using an example. Let's say we have  
28:10 - this array A a sorted array of size nine and 
we want to search for number 63 in this array.  
28:17 - So we make a call to the function binary search 
and I will write b s here a shortcut for binary  
28:24 - search okay we pass to the function the array and 
lower index should be zero and higher index should  
28:30 - be able to say that initially the number can exist 
anywhere in the array from index zero to eight  
28:37 - and the number to be searched for is 63 now we 
go inside the function is low greater than high  
28:42 - No. So we go ahead and calculate mid mid would 
be calculated as for the element at index made  
28:50 - index four is 36 and 63 is greater than 36. So, 
we come to this else condition the third condition  
28:57 - and we make a recursive call to search for 63 
within range mid plus one would be five to eight.  
29:06 - Now once again for this function low greater than 
high is not true. So we calculate mid mid would be  
29:13 - six if we take only the integral part and element 
at index six is 63. So we have found this element  
29:22 - we will return made so we return six here and this 
method finishes and this method also returns six  
29:30 - to its color maybe the main method. Let us 
now say that we want to search for number 25  
29:36 - so we make this call to binary search from the 
main method. Now once again we calculate the  
29:41 - made now element at index 436 is greater than 25. 
So we make a recursive call to search for 25 from  
29:52 - index zero to three. Okay now is low 
greater than high is zero greater than  
29:57 - three no so we go ahead and calculate made 
Made would be one element at index one is 625  
30:04 - is greater than six. So we make a recursive call 
to search for 25 between indices two and three,  
30:10 - now made would be two, and this time, we will 
make a recursive call to find 25 in the range  
30:16 - three to three, it's still a valid range low 
is not greater than high, mid would be three.  
30:22 - And now 25 is greater than 21. So we make a 
recursive call using the third condition to  
30:28 - mid plus one would be four and lower high would 
be three still, and this time low is greater than  
30:34 - high. So we come to this condition, where this 
method simply returns minus one and finishes.  
30:40 - Now this method also returns minus one 
and this gets propagated all the way up.  
30:44 - And finally, this method returns minus one to its 
color the main method while writing recursion,  
30:50 - we must be very careful about the base conditions, 
like we have these two base conditions here.  
30:58 - If we do not get our base conditions, right, 
our recursion may go on endlessly causing the  
31:03 - program's memory to overflow and causing it to 
crash. The time complexity of this algorithm  
31:10 - is big O of log n, the time taken is proportional 
to login. And this comes from the fact that if we  
31:17 - keep dividing the size of the array by two at each 
step, then it will take us log n steps to reach  
31:25 - array size equal to one. Now one obvious question 
which one is better the recursive implementation  
31:31 - or recursive implementation or an iterative 
implementation? Well, anything that we can write  
31:36 - using recursion, we can write it using iteration 
and anything we can write using iteration, we can  
31:41 - write it using recursion, iteration is a slightly 
more performant. It's better in performance,  
31:48 - because we do not have to store all these states 
of all these functions, the extra functions in  
31:54 - the memory. But writing recursion may sometimes 
be very intuitive and easy to write. For most  
32:00 - practical reasons, you may choose any of these 
according to your comfort. So that's not an issue.  
32:06 - Okay, so this was recursive implementation of 
binary search for you. Thanks for watching.  
32:16 - In the previous lesson, we saw the implementation 
of binary search in its basic form, we solved a  
32:24 - problem in which if we have a sorted array of 
integers, something like this, and if we want  
32:31 - to find out whether a number exists in this array 
or not. So let's say we want to find out whether  
32:37 - number 10 exists in this array or not, then our 
algorithm returns us that 10 exists at index  
32:44 - three. And if we want to search for a number that 
does not exist in the array, then our algorithm  
32:50 - returns us that the number that we're looking 
for does not exist in an array. So if we want  
32:54 - to search for 11 in this array, then our algorithm 
says that 11 does not exist in the array. Okay, so  
33:01 - now, I will modify this array. Now, this array is 
still sorted, but the only difference is that we  
33:08 - have three occurrences of number 10 in the array. 
Now, let's say we want to search for the number 10  
33:14 - using binary search, then what will be the index 
of 10 that will return we could return to also  
33:20 - index to also we could return index three also. Or 
we could return index four also, the normal binary  
33:26 - search implementation that we saw previously 
exits as soon as it finds out any occurrence of  
33:32 - a number in the array, so there is no guarantee 
that we will find the first occurrence or the  
33:38 - last occurrence. Now in this lesson, we will see 
two different variations of binary search, one  
33:44 - variation will always give us the first occurrence 
of a number in the array. And another variation  
33:50 - will always give us the last occurrence of the 
number that we are searching for in the array.  
33:57 - Okay, so let us first write the basic 
implementation that we had written previously.  
34:02 - I'll quickly write a method binary search 
that takes three arguments array, its size N,  
34:07 - and the element to be searched for x. And we 
will initialize two variables low and high  
34:13 - to zero and n minus one to mark the segment of the 
array in which x is probable to lie. And while low  
34:20 - is less than or equal to high, we calculate 
the middle index as low plus high upon two,  
34:26 - and then we compare x with the middle element. 
And if x is equal to the middle element,  
34:31 - then we have found exe and our search is over. We 
exit from the method by returning this index made.  
34:38 - So we are exiting as soon as we found as soon 
as we find any occurrence occurrence of x, not  
34:43 - necessarily the first or the last occurrence, but 
any occurrence. If x is less than the mid element,  
34:49 - we add just high to mid minus one to say that 
x will now x is now probable to lie before the  
34:57 - mid element and the third and default condition. 
When x is greater than the mid element, so, in  
35:01 - this case we had just low to mid plus one. And if 
we come out of this while loop without finding x,  
35:09 - then we return minus one to say that we could not 
find x in the array. Okay, let us see a simulation  
35:15 - of this for this particular example simulation 
of this algorithm for this particular example,  
35:20 - I will draw three columns here, low, high and mid. 
And let's say the number to be searched for is  
35:27 - 10. So x is 10, size of the array 
six, So, initially low is zero,  
35:32 - so the size of the array is seven. So, initially 
low is zero high is six. Now, we have started to  
35:36 - execute this while loop we calculate made as low 
plus high upon two, so mid would be three. Let's  
35:43 - also drag column A made, okay, this looks better. 
Now, a three is 10. So is x equal to A made?  
35:51 - Yes, it is. So we return three, we return three. 
And we will say that game over because we have  
35:59 - found an injury and we return immediately we do 
not care that there is another 10 at index two.  
36:06 - Now, if we want to find out, if we wanted to 
find out the first occurrence of 10 in the array,  
36:11 - we should not have said gameover we should have 
said that Okay, I have found 110 at index three,  
36:17 - let me go and see towards the left, if there is 
another 10 at any lower index. And if it is there,  
36:23 - I will return that one. So I will modify this 
algorithm slightly here. At the beginning,  
36:30 - let's say we take a variable result, and 
initialize it to minus one. I'll come back to why  
36:37 - I'm initializing it to minus one. And I'm short of 
space here. So I'm writing two statements in the  
36:42 - same line with a comma. Now, when the condition 
is that x is equal to the middle element,  
36:47 - instead of returning and exiting the execution 
of the function, we modify result to x.  
36:56 - Sorry, we modify result to made the index at 
which x lies and we adjust high to mid minus one.  
37:03 - Once again, I'm short of space here, so I'm 
writing two statements in the same line. So,  
37:07 - these two statements will execute for this 
condition if x is equal to the middle element.  
37:11 - Now, what do I really mean here, what I mean is 
that if we found x in the array, then we have  
37:17 - stored the index in the variable result at which 
we found x and then we modify our segment we do  
37:23 - not stop our search and we modify our search 
space by adjusting high to mid minus one. So,  
37:29 - we keep on searching for x before this mid 
element. So, if we see the simulation now,  
37:34 - then we do not stop here we make highest two 
and continue our search now mid would be one  
37:42 - a mid would be for I will also write the value 
of result at any state. So far our result is  
37:47 - so far we have found 10 at index three. So, our 
result is three now for this case low zero high  
37:54 - two and mid one we will go to the condition this 
one when x is greater than the middle element,  
38:00 - so low becomes mid plus one so low becomes 
too high is already too now made would also  
38:05 - be to a mid would be 10 Now we come to this 
condition, we again came to x equal to the  
38:13 - middle element of the segment. So we now modify 
result to the new index at which will have found  
38:19 - x so results will be now two and high becomes mid 
minus one which will be one low is two now this  
38:25 - condition lower less than or equal to high fails. 
So we exit y loop here okay there should be one  
38:31 - more modification to my code, I will return result 
here okay. So, we are seeing here that found 10  
38:37 - at index two. So, this way, we have found the 
first occurrence of the element 10 in the array  
38:45 - we are returning result here once we complete the 
while loop and we are not returning result inside  
38:50 - the loop, the result is initially minus one. So 
if we do not find any x it is never modified. And  
38:56 - we return minus one to say that we could not find 
x in the array. And if we find any x in the array  
39:02 - and I'll quote put braces here to mark that these 
two statements execute for this if condition,  
39:07 - we stored that index in this variable 
kind of saying that so far, this is the  
39:12 - leftmost result that I have. And then we go 
on searching towards the left by left a means  
39:17 - towards the lower indexes. So we modify high to 
mid minus one if we find another x, then this x  
39:23 - is left of the previous index. So we discard the 
previous result and modify our result okay. So,  
39:31 - this is binary search to find out the occurrence 
of first element in the array. If we want to find  
39:36 - out the last occurrence in the array, then there 
will be only a slight modification to this code.  
39:42 - When we find x we do not stop the search like we 
are doing here. And we go on searching towards the  
39:48 - right towards the higher indices by modifying our 
window window or the segment or the search space  
39:54 - by adjusting lower to mid plus one by adjusting 
lower index to mid plus one And this is the  
40:00 - only change that we need to do to find out last 
occurrence in the array okay. So, let us quickly  
40:05 - see simulation for this implementation also. 
So, once again we start with low zero high six  
40:12 - and we also start with the result minus one minus 
one means that we have not found x in the array  
40:18 - so far now made would be three and the mid element 
would be 10 we are executing the while loop here,  
40:25 - now, we come to this condition x is equal to a mid 
So, first we modify our result we found an x at  
40:32 - index three and then we modify low to mid plus one 
which would be four. So, earlier our window was  
40:40 - the whole array. Now, our vendor spaces this and 
we already have information about the right most  
40:47 - 10 that has occurred so far Okay, so, now mid 
would be five a mid would be 18 now, we go to  
40:55 - this condition x is less than a made so, now 
high becomes mid minus one So, we have this range  
41:01 - our window or search space is now this and 
so far we have found 110 at index three  
41:07 - now mid would be five plus four upon two and 
if we take only integral part then it is for  
41:12 - a mid would be 10. So, once again we come to the 
come to the condition when x is equal to image so  
41:17 - we modify the result to the new index four and we 
modify lower to mid plus one So, low becomes five  
41:26 - high becomes five. So, far the highest 
index of 10 that we have found is four and  
41:30 - our search window is now only index five. So, 
mid would also be five and a mid would be 18.  
41:38 - Now 80 is greater than 10. So, we will again 
once again go to this particular condition.  
41:44 - So low is still five and high becomes four 
now. Now this is not a valid search space,  
41:52 - this is not a valid segment low less than or equal 
to high condition fails, so we will exit the loop,  
41:59 - exit the while loop and our game is over we 
deserve we return whatever we have in the result.  
42:07 - So we will kind of say that found 10 at index 
four. So this is binary search to find out the  
42:16 - last occurrence of an element in the array 
in a sorted array. The time complexity of  
42:22 - this algorithm is big O of log n. Or in other 
words, we can say that the time taken is kind of  
42:28 - proportional to log of n. In the coming lessons, 
we will see more variations of binary search,  
42:34 - we will see other scenarios in which binary 
search is applied. So thanks for watching.  
42:45 - In this lesson, we will solve a very 
famous programming interview question.  
42:50 - And the question is that, given a sorted 
list of integers, we want to find out  
42:57 - how many times a particular 
element occurs in this list.  
43:01 - So let's say we are given a list in the form 
of an array. Here we have an array of size 12.  
43:09 - And the elements are in increasing order. Now how 
many times does number five occur in this array,  
43:16 - five occurs five times and how many times 
does number two occur in this array,  
43:21 - two does not occur in the array. So we will be 
given any such sorted array and a number x. And  
43:29 - we have to find out how many times this number x 
exists in this array. Now we want to solve this  
43:37 - problem programmatically. So let us think through 
the different approaches that we may want to  
43:43 - follow. The simplest approach is that we can scan 
the whole array and count the occurrences of x  
43:50 - in the array. So if I have to write a function 
find count that will take as arguments array, its  
43:57 - size N, and the element x to be searched for the 
element x for which we want to find out the count.  
44:04 - So the logic would be pretty straightforward, 
we will take a variable initially,  
44:08 - let's say the name of the variable is count and 
we initialize it to zero. And then we run a loop  
44:15 - starting zero till n minus one. And if a I or the 
element at index i is equal to the element x, we  
44:24 - increment count. So count becomes count plus one 
and finally when we count come out of this loop,  
44:29 - we return count. So we are performing a 
linear search where we are scanning the whole  
44:36 - array to search for element x. We could optimize 
this algorithm a little bit, something like this,  
44:43 - because the array is sorted once we reach a 
stage, when AI becomes greater than x, we can stop  
44:50 - counting. But still in the worst case, this loop 
will run n times. When all the elements in the  
44:58 - array are same then This loop will run n times. 
So in the worst case, this algorithm, the running  
45:04 - time of this algorithm is proportional to n. In 
other words, the time complexity is big O of n.  
45:12 - This is a very simple solution for this problem. 
And if you give this solution in a programming  
45:17 - interview, the interviewer would be like, I 
do not like this, give me something better.  
45:23 - So, how do we find out a better solution? 
Whenever in a problem, we are given a sorted  
45:29 - data or a sorted collection, we should try to 
think about applying one very famous algorithm  
45:36 - that makes the best use of this property that data 
is sorted. And this algorithm is binary search.  
45:44 - So, can we make use of binary search in 
this problem, one thing that we can do is  
45:49 - that using binary search, we can find out any 
occurrence of the number x in the array. So,  
45:55 - let's say in this example, we want to find out 
count of number five. So we let's say we find out  
46:01 - using binary search in big O of log n time, that 
number five exists at index six. Now, because the  
46:09 - array is sorted, all occurrences of five will be 
adjusting to this. So, we can go towards higher  
46:15 - indices starting this index, and look for all the 
five and then we can go towards the lower indices,  
46:22 - and look for all occurrences of five. But once 
again, if the whole array is number five, only,  
46:28 - all elements being same still is a sorted 
array, then we will scan all the elements,  
46:34 - we will access all the elements in the array, and 
eventually the time complexity will be big O of n,  
46:41 - only the time taken will be proportional to N 
only in the worst case. So, using binary search  
46:46 - kind of does not give us much advantage if we 
use binary search in its basic form, big O of  
46:54 - n because to perform binary search, we will take 
big O of log n time. And then to find out all the  
47:00 - adjacent occurrences of x, we will take big O of 
n in the worst case. So, for higher values of n,  
47:08 - log n is negligible in comparison to. 
And so this is eventually big O of n,  
47:14 - we are not writing writing pseudocode for this 
approach, we'll leave that as an exercise for  
47:19 - you. With these two approaches, we are still 
big O of n in the worst case. So what do we do?  
47:26 - Well, if you remember from our previous 
lessons on binary search, we can write a  
47:33 - binary search to find out the first occurrence 
of an element in an array. And similarly,  
47:38 - we can write a variation of binary search to find 
out the last occurrence of an element in an array.  
47:44 - And this forms the basis of our third approach. 
And I'll clear some of this and make some space.  
47:51 - Okay, so we can use one variant of binary search 
to find out the first occurrence of an element in  
47:57 - an array. And we can use another variation of 
binary search to find out the last occurrence.  
48:02 - And if we know the last and the first 
index at which the element occurs,  
48:07 - then we also know the count of it in the array. 
So once again, we will write a method find count  
48:13 - that will take an array its size N and element 
x. And let's say we find the first occurrence  
48:20 - of the element in the array using a method find 
first, which is a variation of binary search.  
48:28 - And we will use another method called to another 
variant of binary search, that will give us the  
48:35 - last occurrence of the element in the array, then 
we can return count as last index minus first  
48:43 - index plus one. And I'm not handling the case 
here when the element is not present in the array.  
48:48 - Let's say we will handle it well in our actual 
implementation. Okay, so the first method call  
48:55 - if we are using binary search will work in big O 
of log n and the second method call to find out  
49:00 - the last occurrence will also work in big O of 
login. So overall, the time complexity to find out  
49:07 - the count of an element in the array would 
be big O of log n. And that's really great.  
49:13 - We have described how to find out the first or 
last occurrence of an element in a sorted array  
49:19 - using binary search. We had written pseudocode for 
the algorithm in our previous lesson and there is  
49:26 - a link to the previous lesson in the description 
of this lesson. But let us now go and write some  
49:33 - real code. To solve this problem. I will write a C 
program. Let us first write a simple normal binary  
49:40 - search and then we will modify it to find the 
first or the last occurrence. Let's say we have  
49:44 - a method binary search that gives me the index of 
element x in the array. in binary search we first  
49:50 - define two indices low and high, two variables low 
and high initially set to zero and n minus one,  
49:56 - respectively. And then we find the mid element 
and as low plus the mid index as low plus high  
50:03 - upon two, and then we compare the middle 
element with the number x. And if we,  
50:10 - if middle element is equal to x, we have found our 
element. So we simply return the index mid else,  
50:17 - if x is less than the middle element because the 
array is sorted, remember array being sorted is  
50:23 - a precondition of binary search, we set high 
as mid minus one kind of saying that search  
50:28 - in the segment left to the middle element. And if 
x is greater than the middle element, we adjust  
50:34 - lower to mid plus one. And we keep repeating 
this process again and again till the time  
50:41 - we have a valid segment and a valid segment is 
till the time low is less than or equal to high.  
50:49 - And if we come out of this loop without finding 
anything, then we return minus one to say that  
50:54 - x does not exist in the array. problem with 
this implementation is that as soon as we find  
51:01 - any x, we return. So there is no guarantee that 
we will find the first index or the last index,  
51:08 - if there are duplicates in the duplicates of x 
in the array. So what we do is we will, what we  
51:15 - will do is we will modify the algorithm slightly, 
we will have another variable, initialize it to  
51:20 - minus one. And now when we find x, then we do not 
return an exit, we update the result variable to  
51:29 - kind of say that, okay, this is the lowest index 
of x so far, and then we continue the search.  
51:36 - So if we want to find out the first occurrence, 
then we adjust high to mid minus one. So we  
51:42 - update result and go on searching towards lower 
indices lower segment. And finally, if when we  
51:47 - come out of this loop, then we return result. So 
if we do not find anything, any occurrence of x,  
51:53 - we simply return minus one, because this was 
initialized to minus one. Now this implementation  
51:58 - will give us the first occurrence of x in the 
array. And what if we wanted the last occurrence,  
52:04 - the only difference would be that we will go on 
searching towards the right or higher indices,  
52:09 - so we will say that low is equal to eight plus one 
now go on searching towards the higher indices.  
52:17 - Now I want two different functions for 
finding out the first or the last occurrence.  
52:22 - But if you see there is difference in only 
one line in these two implementations. So  
52:28 - what I'll do is I'll use the same function 
to retrieve both first and the last index  
52:35 - based upon another argument of flag. So let's 
say we have a flag as a Boolean parameter.  
52:42 - Search First, if it is true, we want to search 
for the first occurrence and if it is false,  
52:46 - then we want to search for the last occurrence. 
So if we want to search for the first occurrence,  
52:50 - then we want to, in the case, when a mid is equal 
to x, we want to adjust high to mid minus one  
52:57 - else we want to adjust low to mid plus one.  
53:00 - Okay, let us know write the main method. What 
I'll do is I'll first initialize an array.  
53:08 - And I'll ask the user to input a number 
x. Now we want to find out the count of x.  
53:16 - So we will first make a call to binary search 
method to find out the first index in the array.  
53:22 - So we will pass the array, the number of elements 
in the array, which is 12. And we will also  
53:28 - calculate the number of elements using this 
particular equation size of a upon size of  
53:34 - a zero size of the number of bytes in the 
whole array upon the number of bytes in each  
53:40 - in teaser in each element. And we want to search 
for x and we'll pass true because in our method  
53:46 - declaration, if this flag is passed as true, then 
we search for the first index, else we search for  
53:52 - the last index. Now if first index is returned as 
minus one, then the element is not in the array.  
53:59 - So no need to find the last index, we can 
simply print that the count is zero. Else,  
54:05 - we find out the last index and this time we 
make the call to the same function binary search  
54:13 - with only difference that this time we will pass 
the flag as false. So we will say that, hey,  
54:17 - give me the last index. And we will print count 
as last index minus first index plus one. So this  
54:26 - is our code. This is our method binary search. 
And we have made call to binary search twice  
54:31 - to find out the first and the last index and we 
decide first or last index using this flag. Let  
54:36 - us now run this code and see what happens. Let's 
say we want to find out the count of number three,  
54:42 - then this gives us that three 
occurs twice which is right.  
54:45 - Let's now try number five and count of five is 
five. And let's give x is equal to two two is not  
54:53 - present in the array so the count will be zero. 
So this is an optimized algorithm to find out  
54:59 - Count of an element in a sorted array. This 
is a classic implementation of binary search.  
55:05 - In the coming lessons, we will see more problems 
on binary search. So thanks for watching.  
55:13 - In this lesson, we will solve another 
programming interview question.  
55:17 - And the question is that we are given a sorted 
array that has been rotated. So let's say we have  
55:25 - been given a sorted array with these elements, 
the size of the array is six, so we have indices  
55:32 - from zero to five. And let's say we want to 
rotate this array anti clockwise rotate this  
55:38 - array towards the right. So, each element will 
shift by one towards the right except the last  
55:47 - element which will shift to the first position in 
the array and the resulting array would be this  
55:55 - and this is rotated once and if we rotate the 
array twice, the resulting array would be this  
56:03 - and this is of course, rotated twice. And such 
an array is often also called circularly sorted  
56:11 - array. So we have been given such a circularly 
sorted array and there is one more condition there  
56:18 - are no duplicates in the array, all the elements 
in the array are distinct. So given such an array,  
56:24 - we have to find out how many times the array has 
been rotated. So how do we solve this problem?  
56:31 - One thing that should be pretty evident is that if 
we know the first element or the minimum element  
56:37 - of the sorted sequence in the array, then we 
know how many times the array has been rotated.  
56:44 - And when we say the number of times 30 has been 
rotated, for this problem, we mean rotation in  
56:50 - anti clockwise direction or rotation towards the 
right, the number of rotations of the array would  
56:56 - be the number of elements before the smallest 
element or the minimum element in the array.  
57:01 - So in this case, there is only one element before 
two which is the minimum. So clearly this array  
57:06 - is rotated once here we have two elements before 
the minimum element. So this is rotated twice.  
57:12 - In fact, if we see then the number of rotations 
is equal to the index of the minimum element.  
57:18 - So our problem is basically finding 
out the minimum element in the array,  
57:22 - the index of the minimum element in the array. 
And we are done. We know that how many times  
57:26 - the array has been rotated. So how do we 
find out the index of the minimum element,  
57:32 - the simplest approach would be to scan the whole 
array perform what we also call linear search.  
57:40 - And the pseudocode will be something like we 
will have two variables, one to store the minimum  
57:45 - element and another to store the minimum index. 
Let's say Initially, the first element is the  
57:51 - minimum element and then we run a loop from one 
till n minus one where n is the size of the array.  
57:58 - And if the element at if index is less than the 
minimum, we update the minimum and the minimum  
58:04 - index. And finally, when we come out of this loop, 
we will have the index of the minimum element  
58:09 - Clearly, the running time of this algorithm 
would be big O of n the running time will  
58:15 - be proportional to n. Now, this will give us the 
correct answer, this is a correct solution. But in  
58:21 - this solution, we did not make use of the property 
of the array that it is circularly sorted,  
58:26 - can we use this property of the array and improve 
this algorithm improve the time complexity of this  
58:31 - algorithm? Well, let us see. Now, we will make use 
of the property that array is circularly sorted,  
58:40 - and we will use a variation or modification of 
binary search algorithm to solve this problem.  
58:48 - Now, what do we do in a normal binary search 
algorithm? Let's say we have a sorted array like  
58:54 - this, we first find out the middle element in the 
index in the array. And then we see whether this  
59:01 - is the element we are looking for or not. If 
it is not the element that we are looking for,  
59:05 - we either go searching towards the left, or 
we go searching towards the right based upon  
59:14 - whether the element that we're looking for is 
greater than or less than the middle element.  
59:19 - So at each step, we divide the problem 
into searching something in half the array.  
59:25 - at each step, we discard half of the elements, 
we discard half of the search space, and we  
59:31 - keep on going until we find the element. 
Now in a circularly sorted list like this,  
59:38 - our problem is to find out the first 
element of the sorted sequence.  
59:43 - This particular element is kind of the pivot 
or the junction in the circularly sorted array.  
59:50 - So now we will use a variation of binary search 
to find out this pivot element which is also the  
59:55 - minimum element in the array. What we essentially 
do in a binary search Is redefine a search space  
60:02 - or segment within which our desired element is 
probable to live by two variables low and high,  
60:10 - the lower index and the higher index and at each 
step, we either find an element or we reduce the  
60:17 - search space by half by discarding half of 
the elements in the segment and creating a  
60:23 - new segment. And now, we look at the new 
segment we kind of divide the problem  
60:28 - at each step into half. Now, in this problem for 
each segment, we will look at couple of things,  
60:34 - there can be a case when the lower the element 
at lower index is less than or equal to the  
60:42 - element at higher index. Now, this will be 
possible only if the segment is already sorted,  
60:48 - if the segment is already sorted 
the minimum element in the segment  
60:52 - and that's what we are finding out the minimum 
element in the array and if we can find out  
60:58 - the minimum element in the segment that will 
be the minimum element in the array as well.  
61:02 - So, we will return simply return the index 
low because the array is already sorted. So,  
61:07 - the element at lower index is the minimum if the 
segment is not sorted, we calculate the middle  
61:14 - index. And now, we try to see if our middle index 
is the pivot or not. Now, how do we find out the  
61:21 - pivot if you see there is a special property of 
the pivot or the minimum element in the array  
61:26 - if we see the next and the previous elements 
of the pivot element in a circular manner. So,  
61:33 - if it is the last element, the next element will 
be the first element, then for the pivot element  
61:38 - both next and previous element in the array are 
greater than it like here 18 and five are both  
61:46 - greater than two. No other elements in the array 
will have this property except the pivot element.  
61:52 - Let's define this property as pivot property. 
So, here we calculate next as MIT plus one  
62:01 - modulo n modulo n because if mid is the 
last index in the array, we need to go  
62:07 - to the first element. So, modular operation 
does that and previous would be mid minus one  
62:13 - modulo n and we will also add n here so, that mid 
minus one does not become a negative number. So,  
62:20 - our case too is that a made is less than or equal 
to a next and it's also less than and equal to  
62:32 - less than or equal to the previous element in the 
circular array in the circularly sorted array.  
62:39 - If this is the case, once again we have the 
pivot or the minimum element in the array. So,  
62:45 - we will return the index made. So, far in these 
two cases, we have found our element straight off  
62:51 - and we have not felt the need to divide 
the array divide the search space segment.  
62:57 - If the middle element is not the pivot, then can 
we use a property where we can say that we can  
63:03 - discard the right half or we can discard the left 
half and we can go to one of the halves to search  
63:09 - for the pivot element. Well, yes, it is possible 
to do so, if the middle element the element at  
63:16 - mid index is less than or equal to 
the highest element at high index high  
63:24 - then the segment starting the mid index and 
extending right towards till the high index,  
63:30 - this whole segment is sorted and the pivot cannot 
exist in the right segment. So, in this case,  
63:37 - we will say that we need to search for the 
pivot in the left half. So, we will adjust  
63:42 - high to mid minus one and case four would be 
when the mid element is greater than or equal to  
63:52 - the element at lowest index. Now, in this case, it 
is not possible that the pivot is in the left. So,  
63:59 - we will go and search in the right so, 
we will adjust lower to mid plus one.  
64:05 - So, we keep reducing our segments at each 
step and try to find out the answer. Now,  
64:10 - let us simulate this approach this algorithm for 
this particular example. So, for this example,  
64:16 - case one obviously is not true initially. So, 
we find out the middle index. Now, the pivot  
64:21 - property is not true for the middle index. So, we 
look at case three, when we look at case three we  
64:27 - basically are looking whether this whole part of 
the sequences sorted or not including 18 and the  
64:33 - whole elements towards the right. So, 18 is not 
less than or equal to eight. Now, we look look for  
64:39 - case four. And when we look for case four, we 
mean to check whether this complete sequence  
64:45 - is sorted or not. Well, this is sorted. In 
fact, if the array is not sorted, then one  
64:51 - of these two sequences will always be sorted. You 
can pick up some of examples, some examples and  
64:58 - try to see and this is what forms the basis 
of our divide and conquer approach. This  
65:03 - is what forms the forms the basis upon 
which we discard half of the elements.  
65:08 - So now we need to adjust low to mid plus one. So 
we have discarded these elements from our search  
65:14 - space are not new search spaces starting at two. 
Now this array is sorted. case one is true for  
65:21 - this segment, sorry, this segment is sorted. So 
we simply return the index of two which is 0123,  
65:27 - and four, so, we return four here and our searches 
over now, we have found the pivot element. So,  
65:34 - we know that the array is rotated four times 
equal to the index of the pivot element  
65:41 - of things about this algorithm, this algorithm 
will work only if there are no duplicates in  
65:46 - the array. And that was our initial condition 
also in the problem, if there are duplicates  
65:51 - this reduction of search space into half is 
not possible. And let us now write code for  
65:56 - this algorithm and see whether it works or not. 
So, I will write a method find rotation count,  
66:02 - that will give me how many times a circularly 
sorted array A is rotated, and is the number of  
66:10 - elements in the array. So, we first define low and 
high. And then while our search space is valid, we  
66:18 - first see whether the segment is already sorted. 
If it is sorted, we return the lower index.  
66:23 - So, this is our case one else we calculate mid as 
low plus high upon two and then we also calculate  
66:30 - the next and previous have met. And if made 
satisfies the pivot property we return made.  
66:36 - Else if the middle element is less than or equal 
to the higher element, then we discard the right  
66:42 - half, and we adjust higher index to mid minus one 
else, if a made is greater than or equal to a low,  
66:51 - then we discard the first half the left half. 
If the array is not sorted, one of these two  
66:56 - conditions will always be true. And only one 
of these conditions will be true, not the both  
67:01 - of them. Let's say if we are not able to return 
anything, if we are not able to return anything  
67:06 - within the while loop, then we return minus one 
it will be minus one will be returned only for  
67:11 - an invalid scenario when maybe the array is not 
circularly sorted, its properties are not true.  
67:18 - Now, in the main method, I have 
initialized an array of size 11.  
67:22 - And I have called this function find rotation 
count. And I'm trying to print the count.  
67:27 - Let us see what happens if I run the program. 
This says that the array is rotated six times,  
67:33 - which seems to be correct. Let's now modify 
this array. Let's run this for a test case when  
67:40 - the elements are already sorted. Okay, this also 
looks fine. So we are good. Now I have used four  
67:46 - cases to solve this problem. There are a couple of 
different other implementation approaches as well,  
67:53 - the underlying idea would be the same to use 
binary search. But we can implement using some  
67:59 - different conditions. I encourage you to try them 
out on your own, or quickly Google search for  
68:05 - code snippets. So this was one interesting 
problem using solve using binary search in  
68:10 - the coming lessons, we will see more such 
interesting problems. Thanks for watching.  
68:19 - lesson we will solve yet another very famous 
programming interview question. And the question  
68:25 - is that we are given a circularly sorted array, 
which means that a sorted array has been rotated.  
68:32 - And in the previous lesson, we had also solved a 
problem where we wanted to find out the number of  
68:37 - rotations in a circularly sorted array. This 
is an example of a circularly sorted array,  
68:43 - the first element in the sorted 
sequence is at index four,  
68:47 - and then we go towards the right. And then after 
the last element, we go to the first element.  
68:56 - So this is the start of the sorted sequence. 
And this is the end of the sorted sequence.  
69:02 - Each element in the sorted sequence has been 
shifted four positions ahead, the array is  
69:07 - rotated four times in anti clockwise direction 
or towards the right. Now given such an array,  
69:12 - we have to find out whether a number x exists 
in this array or not. So how do we solve this  
69:19 - problem? The simplest approach would be to perform 
a linear search, where we scan the whole array  
69:27 - to look for x. But in this approach, we will not 
make use of the property of the array that it  
69:33 - is circularly sorted. And the time complexity for 
this approach would be big O of n, where n is the  
69:42 - number of elements in the array. So what else 
can we do? Whenever we have a sorted data,  
69:48 - and we have to search for something, we 
should always think about binary search ads  
69:53 - as one of the possible approaches. Binary search 
as we know executes in big O of n log n. At most,  
70:01 - we make log n comparisons to find out our element 
in the array. And big O of log n is the best time  
70:08 - complexity to have for a solution. So let's see 
if we can apply binary search in some form. To  
70:15 - solve this problem, let us pick up this circularly 
sorted array, the example that we have in the left  
70:23 - and now we will use a variation of binary 
search to find out an element x in the array  
70:30 - like we do in the normal binary search, we 
will first define two indices low and high  
70:35 - initially to the first and the last element in the 
array respectively. And then we find out the mid  
70:42 - element as low plus high upon to the mid index. 
So far the logic is the same. Now, the first case  
70:49 - would be that the element at mid index a made is 
equal to x. As we do in a normal binary search,  
70:58 - we will compare the middle element with the 
number that we are looking for x and if this  
71:03 - is equal to x, our search is over we will return 
made telling that x exists at index mid, if a mid  
71:14 - is not equal to x, then if the array was a normal 
sorted array, then we would have either gone to  
71:20 - the left half or the right half depending upon 
whether x is greater than or less than the middle  
71:26 - element. But we cannot apply this straightforward 
logic to discard one of the half's in this case,  
71:34 - but there is a property that we can explore 
it and discard half of the elements.  
71:39 - If you see then, the elements in 
the array are always increasing  
71:44 - except only at this particular point, which 
is the junction point or the pivot point,  
71:52 - where we have the first element or the 
minimum element in the sorted sequence.  
71:56 - Now, if we pick any segment or any sub array, 
then if it does not contain this pivot point,  
72:05 - if it does not contain these two 
elements, which form the boundary,  
72:09 - the break point, then all the elements in this 
segment will be sorted. And if the segment  
72:14 - contains these two elements that form the breaking 
point, then the segment will not be sorted. Now,  
72:22 - the mid element divides the segment into two 
halves and this breakpoint or the pivot point  
72:29 - will lie only in one of these halves. So, at 
least one of these halves will always be sorted,  
72:35 - we will make use of this property and 
we will discard half of the array at  
72:40 - half of the search space at each iteration of 
the binary search. So, our case two will be  
72:48 - if a made is less than or equal to a high 
basically we are looking at this particular  
72:54 - part of the array, we include the mid element 
and look for the segment extending till the  
72:59 - highest element. If this condition is true, then 
this whole segment is sorted. In this example,  
73:05 - this segment is not sorted. But if the segment 
was sorted, the right segment was sorted,  
73:12 - then there would be two conditions let's 
say these conditions are to a and to B,  
73:17 - we know that x is not equal to A made 
but if x is greater than a made and  
73:24 - x is less than or equal to a high then 
it definitely lies in this sorted half.  
73:31 - So, we adjust lower to mid plus one to say 
that go ahead and search in the right half  
73:39 - as if it is not so, we will have a condition when 
we will say go go search in the left half in the  
73:46 - unsorted half okay this will be the case when the 
right half of the array sorted case three would be  
73:54 - when a low or the first element in the sequence 
is less than or equal to the middle element less  
74:02 - than or equal to a mid. Now in this case, we are 
looking whether this particular segment starting  
74:09 - low index all the way till mid index is sorted or 
not. Now, once again we will have to condition to  
74:15 - conditions when we know that this half is sorted, 
it is very easy to verify whether x is probable  
74:21 - to lie within this segment or not within this 
sub segment or not here if x is greater than  
74:28 - or equal to a low and x is less than a made x 
cannot be equal to the mid element because then we  
74:36 - will not reach the case three then x is probable 
to lie in the left half for this condition.  
74:41 - So in this condition, we will adjust high to mid 
minus one else we will search in the unsorted half  
74:50 - by adjusting low to mid plus one. So this is our 
divide and conquer strategy for binary search.  
74:57 - Let us now write code for this And see if 
it works, I will write a function circular  
75:03 - array search that will search for a number x in an 
array of size n, and it will return the index of x  
75:11 - if it is found in the array. So like we do in a 
normal binary search, we will first define two  
75:17 - variables low to zero and high to n minus one. 
And while low is less than or equal to high,  
75:25 - while our search space is valid, while our segment 
is valid, a valid segment segment will have at  
75:32 - least one element when low will be equal to high, 
we calculate the mid index as low plus high upon  
75:39 - two. Now, if x is equal to the middle element, 
then we have found x we return the index mid ELLs,  
75:49 - we need to decide whether to go in 
the left half or the right half,  
75:54 - whether to go searching towards the higher indices 
or the lower indices. And we do so by first  
76:01 - finding out which part of the array is which 
part of the search space is sorted. If a made  
76:08 - is less than or equal to a high, the element 
at index high, then the right half is sorted.  
76:18 - the right half is sorted, then we can easily 
check whether x is probable to live within this  
76:23 - sorted half or not. So if x is greater than the 
middle element, and x is less than or equal to  
76:29 - the element at index high, we go searching 
to the right sorted half by adjusting  
76:36 - low to mid plus one. Else, we know that the 
element is not in the right half, so it is  
76:43 - definitely in the left half. So we will adjust 
high to mid minus one to go to the left half.  
76:49 - Now, right half is sorted for sure we know 
that but left half, it could either be sorted  
76:54 - or unsorted, it doesn't matter. For some special 
case, when the segment itself is sorted, the left  
77:00 - half could also be sorted. But irrespective 
of that, using these two conditions, we are  
77:06 - discarding one of the halves and we are going to 
one of the we're choosing one of the sub segments.  
77:12 - Okay, so now if the right half is not sorted, 
then the left half definitely will be sorted.  
77:20 - So either we write this condition A 
made greater than or equal to a low.  
77:26 - Or maybe I should write a low less than or equal 
to emit as we had written previously. So this is  
77:32 - case three, even if we do not write this condition 
and simply write an else we are fine because  
77:36 - this will be true anyway, at this point. So now 
the left half is sorted. So we can see whether  
77:43 - our x is probable to lie in left half. Now if if 
x is between a low and a mid less than or equal to  
77:51 - greater than or equal to a low and less than 
a mid, then it's probable to lie in this half.  
77:56 - So we will adjust high to mid minus one. Else 
if x is not probable to lie in the left half,  
78:04 - then we go searching towards the right 
by adjusting low to mid plus one.  
78:11 - And finally, if we come out of this while loop 
without finding x, without returning anything,  
78:16 - we return minus one to say that we could not find 
x in the array. Let us now write the main method,  
78:22 - we will first initialize an array and this is the 
same array. The elements are the same as we have  
78:29 - used in our examples throughout. Now let's ask 
the user to input a number x from the console.  
78:38 - And now we call the method to search for x, the 
size of the array is eight. So we pass eight as  
78:43 - the second argument. Now if this method returns 
minus one, we will say that we could not find the  
78:47 - element in the array, the number in the array. 
And if it is not minus one, we print the index.  
78:54 - So this is our C program. And now 
let's run this and see what happens.  
79:01 - Let's search for the number eight in the array. 
And this seems to be correct. The element eight is  
79:07 - at index six. Let's run this again and search for 
number 12 in the array. And this also is correct.  
79:16 - And this seems to be working 
for other cases as well.  
79:19 - And let's modify this array. Let's say we want to 
pick up an array in which the elements are already  
79:25 - sorted. Let's pick up eight elements again. 
Let's search for element four in this array,  
79:31 - okay, this is also fine. So we 
seem to be good for all test cases.  
79:36 - Well actually no we are not good for all test 
cases. If we have an array with duplicates,  
79:44 - like this, this array is still circularly sorted. 
This is the first element in the sorted sequence  
79:50 - zero. But if we have duplicates in the circularly 
sorted array, it will not be possible to  
79:56 - decide whether left half is sorted or right half 
is sorted. Using the conditions above that we have  
80:02 - used using these this condition. So the array has 
to be strictly increasing in a circular manner,  
80:10 - and all the elements need to be distinct. If we 
run this, let's say we want to search for a number  
80:15 - zero, then this is zero not found in the array 
which is not correct. If there are duplicates,  
80:21 - we cannot do any better than big O of n, we 
will have to perform linear search only if  
80:26 - the elements are distinct, we can perform binary 
search. Okay, so this was searching an element  
80:33 - in a circularly sorted array with no duplicates 
using binary search. Thanks for watching.