00:00 - hello and welcome to this course on
00:02 - regular expressions
00:04 - regular expressions or regex define a
00:08 - search pattern that can be used to
00:10 - search for things in a string
00:13 - now this course focuses on using regular
00:16 - expressions in javascript however almost
00:19 - everything you learn about regular
00:20 - expressions in this course can also
00:23 - apply if you're using regular
00:25 - expressions in another programming
00:27 - language my name is beau carnes i will
00:29 - be teaching this course i'm with
00:31 - freecodecamp.org
00:33 - in fact this whole course is based on
00:36 - the free curriculum at
00:38 - freecodcamp.org
00:40 - it's not required to go through that
00:42 - curriculum to also do this course but it
00:45 - could be helpful however this course is
00:47 - designed to be standalone but if you
00:49 - want to go through the curriculum on
00:51 - freecodcamp.org as well you can look in
00:54 - this picture where it has the arrow
00:55 - right to the regular expressions part of
00:58 - the curriculum so you can see where
01:00 - that's at
01:01 - well let's get started
01:06 - regular expressions are used in
01:08 - programming languages to match parts of
01:10 - strings you create patterns to help you
01:14 - do that matching
01:15 - so for instance if you have the sentence
01:17 - the dog chased the cat
01:19 - and you want to match the word the you
01:22 - can use this regex here you can see that
01:25 - there's a slash then the word the in
01:27 - another slash you will also notice that
01:29 - quote marks are not required within the
01:31 - regular expression so javascript has
01:34 - multiple ways to use regexes
01:36 - one way is to test the rejects is to use
01:39 - the test method the test method takes
01:42 - the regex applies it to a string and
01:45 - then returns true or false if the
01:47 - pattern matches something so in this
01:49 - example we have the string hello world
01:51 - we have this regex and we have my regex
01:55 - i'm going to do dot test and then inside
01:58 - the parentheses i'm going to put my
02:00 - string
02:01 - so we are going to see if my string
02:04 - contains this regex which is hello and
02:07 - then we'll put it into the result
02:09 - in this case it will be true because
02:11 - hello world does contain the string
02:13 - hello
02:18 - here we want to match the word waldo we
02:20 - have this sentence somewhere waldo is
02:23 - hiding in this text so i'm going to
02:25 - change this regex instead of search it's
02:28 - going to be waldo
02:31 - now one thing i want to point out is
02:33 - that this is case sensitive so if i had
02:36 - a lowercase w then this would not match
02:39 - but since this starts with an uppercase
02:41 - w i have to make the regex start with an
02:43 - uppercase w also so this result the
02:47 - waldo regex.test while waldo is hiding
02:51 - it's going to return true because it
02:53 - found waldo in this sentence
03:00 - regex has an or operator which is a
03:03 - single pipe character so in this example
03:06 - let's say we want to try to match for
03:09 - multiple words instead of just a single
03:12 - word let's say we want to match dog cat
03:15 - bird or fish
03:16 - so what i would do here is i'm going to
03:19 - change this i'll do dog and then i'll
03:21 - put pipe
03:22 - which is just a straight line up and
03:24 - down
03:25 - and then i'll do cat
03:28 - pipe bird
03:30 - type fish
03:32 - so this is going to match any of these
03:35 - four words dog or cat or bird or fish
03:38 - and since
03:40 - one of these words is in the sentence
03:42 - this test is going to return true
03:49 - so far all the regexes we looked at
03:52 - matched literal strings so the case
03:55 - mattered if it was a capital letter
03:58 - that's completely different from a
03:59 - lowercase letter you can match both
04:02 - cases using what is called a flag
04:05 - so
04:06 - there's the i flag that ignores case so
04:10 - let me show you how you would do that
04:12 - let's say we have free
04:14 - code camp
04:16 - and we'll see it's all lower case in
04:18 - here but we want to match it no matter
04:20 - what the case so we want this to also
04:22 - match this where there's a capital c and
04:25 - another capital c so just after the last
04:29 - slash i'm just going to put an i so this
04:32 - is the flag this means ignore case so
04:35 - now when it tests the string free
04:38 - codecamp for the regex which is free
04:40 - codecamp all lowercase the result will
04:43 - be yes because they will match
04:49 - so far we have just checked if a pattern
04:51 - exists or not within a string
04:54 - but we can also extract the actual
04:56 - matches that we found with the match
04:58 - method
04:59 - so let's see how to extract the word
05:02 - coding from this string so we'll just
05:04 - change this to coding
05:07 - and then
05:08 - here we'll use the dot match method
05:10 - match
05:11 - and then in the parentheses we'll pass
05:12 - in coding
05:14 - regex
05:17 - and then
05:18 - if we just
05:20 - run this we'll see in the console
05:22 - coding because it's logging out the
05:24 - result see the result extracted this
05:27 - word coding out of the sentence and into
05:29 - the result variable and it got logged
05:35 - so far we've only extracted search
05:38 - patterns one time but it is also
05:40 - possible to search or extract a pattern
05:43 - more than once using the g flag let me
05:46 - show you what i mean we have this test
05:48 - string up here repeat repeat repeat now
05:52 - we're going to search for repeat
05:55 - and the way it is now when it matches
05:58 - this it's only going to return the first
06:00 - repeat just this one
06:02 - but if we add the g flag after the slash
06:05 - here
06:06 - it's going to find every single
06:08 - occurrence of the word repeat so it's
06:10 - going to return
06:12 - an array
06:13 - with three elements and each element is
06:15 - going to be the word repeat
06:17 - let's see it again down here where it
06:19 - says twinkle twinkle little star i want
06:21 - to match the word twinkle so i'll type
06:24 - in twinkle right here
06:26 - and you'll see that the first twinkle is
06:29 - capitalized the second one is not so i'm
06:31 - going to have to use a flag i'll have to
06:33 - use the i flag which makes it
06:36 - insensitive to case so it's case
06:38 - insensitive i'm also going to add the g
06:41 - flag that's going to match every single
06:43 - time twinkle appears
06:46 - so you can use two flags at once on the
06:49 - same regex now here for the result it's
06:52 - gonna be twinklestar.match
06:55 - and then i'm going to pass in the star
06:57 - regex
07:00 - okay now we'll log this and see what
07:03 - happens you can see twinkle twinkle the
07:06 - first twinkle in the console is the
07:08 - capital t and the second is the
07:10 - lowercase because it matched the first
07:12 - one and the second one and return them
07:14 - both
07:19 - in regex a period is a wild card
07:22 - character it can stand for anything so
07:25 - let me show you an example we have these
07:27 - two strings up here
07:29 - and the first one has the word hum the
07:32 - second one has the word hug you'll
07:34 - notice that these two words start with
07:36 - the same two letters h u and then the
07:39 - third letter is different so look at
07:41 - this regex here h u period this will
07:45 - match any word that starts with the
07:47 - characters hu and then then has a final
07:50 - character which could be any character
07:53 - so if we look down here we are going to
07:55 - take the first string
07:57 - alhamsong and match it to our regex it's
08:00 - going to return hum
08:02 - and then when we take our second string
08:04 - bear hug and match it to our regex it's
08:07 - going to return hug
08:09 - so let's try that with another sentence
08:12 - we have this sentence here let's have
08:15 - some fun with regular expressions
08:18 - so i want to match the word fun but i
08:21 - also want this regex to be able to match
08:23 - the word run sun pawn none or bun
08:26 - basically any word that ends with you in
08:30 - and starts with another letter so i'll
08:32 - change this regex to dot u n
08:36 - so when we run our regex and search this
08:40 - sentence for something that ends with
08:43 - you in it should find fun
08:45 - so let's load that and look in the
08:47 - console and it says true because it
08:50 - matched the word fun in that sentence
08:56 - we talked about the wild card character
08:59 - which matches basically anything
09:01 - but you can also match from a predefined
09:05 - group of characters if we look at this
09:07 - right here it we have the b and then we
09:10 - have these brackets
09:12 - and inside the brackets we're saying
09:14 - that the second letter that's going to
09:16 - match has to be one of these three
09:18 - letters so we know the first letter is
09:20 - going to be b the last letter is going
09:22 - to be g
09:23 - and the middle letter is going to be a i
09:26 - or u so this would match bag big and bug
09:30 - so down here what we want to do is
09:32 - change this so we match every single
09:34 - vowel in this quote sample here so what
09:38 - i'm going to do is put open and close
09:40 - brackets and inside i'm going to put the
09:42 - vowels a e i o u
09:45 - and then to make sure i match every
09:47 - single vowel and i match uppercase or
09:50 - lowercase vowels i'm going to use flags
09:53 - i'll use the i flag and the g flag
09:56 - now down here i'm going to have to do
09:59 - quote
10:02 - sample.match and then i just pass in the
10:05 - valve regex here
10:08 - if i run this in the console you'll see
10:11 - all the vowels from that quote sample
10:17 - you can also match a range of letters
10:20 - so let me show you how to do that right
10:22 - here i'm going to try to match every
10:24 - single letter so i'm going to put the
10:27 - open and close brackets and instead of
10:30 - typing a b c d e f g and writing every
10:33 - letter i can just put a through z so
10:36 - it's going to match every letter between
10:38 - a and z
10:40 - and then to make sure it matches
10:42 - every uppercase and lowercase letter
10:44 - i'll do i and then g to make sure it
10:46 - matches every letter in the whole string
10:49 - so now i can just do quote
10:52 - sample
10:54 - match
10:55 - and then i just pass in the alphabet
10:57 - regex here
10:59 - and if i run that we see in the console
11:01 - it has every letter in that string
11:07 - just like you can use a regex to match a
11:10 - range of letters you can also match a
11:12 - range of numbers so if i want to match
11:15 - range of numbers it will be like this
11:17 - i'll have the brackets here the opening
11:19 - and closing brackets and this time i'm
11:21 - just going to match the numbers 2
11:23 - through 6. so i'll just put 2-6 so that
11:26 - will match 2 3 4 5 6.
11:29 - also in the same regex i can match a
11:33 - range of numbers and a range of letters
11:36 - so if i want to add some letters i can
11:37 - put h through s
11:39 - so now we can see this is going to match
11:42 - a range of numbers 2 through 6 and also
11:44 - a range of letters h through s
11:47 - so i can do an i to make it case
11:49 - insensitive and a g to match every
11:52 - occurrence in the whole string
11:54 - so i'm going to put that into my results
11:56 - so i'll do quote
11:58 - sample dot match
12:01 - to match this regex
12:04 - and here it's going to console.log the
12:07 - result so let's see what happens and we
12:10 - have every letter and number between
12:13 - those ranges
12:18 - we've talked about how to match for
12:20 - specific characters but what if you want
12:22 - to create a set of characters that you
12:24 - do not want to match
12:26 - these are called negated character sets
12:29 - and you can create them with the carrot
12:32 - character so let me show you how to do
12:34 - that
12:35 - this we want to make a regex that will
12:39 - match everything except
12:41 - all numbers and all vowels so we are
12:46 - going to put a opening closed bracket
12:48 - and i'm going to put a carrot character
12:50 - that's right underneath the six on a
12:52 - keyboard and i'll put zero through nine
12:55 - so we are not going to match all digits
12:57 - zero through nine and we are not going
12:59 - to match a e i o u
13:02 - and then i will put my flags here i g so
13:05 - this will match everything except zero
13:07 - through nine and a e i o u so to finish
13:10 - this up i'm going to put quote
13:13 - sample dot match
13:16 - and then i'll pass in the regex here and
13:20 - now i'll just run this and you can see
13:23 - we've returned everything except the
13:25 - vowels and the numbers it includes the
13:28 - spaces and periods and punctuation also
13:35 - sometimes you want to match if a
13:36 - character occurs one or more times if
13:40 - you want to do that you can use the plus
13:42 - character so let me show you how to do
13:44 - that in this case we are going to try to
13:47 - match in the word mississippi whenever
13:50 - an s occurs one or more times so i'm
13:53 - just going to put s
13:55 - plus
13:56 - and i'm going to put a g to match it
13:59 - every time it occurs
14:00 - and if i run this you'll see we've
14:03 - matched the first ss and then the second
14:06 - ss
14:07 - if there just happened to be another s
14:09 - in here we would then match three times
14:12 - and you can see the third time only
14:14 - matches the single s because there's
14:16 - only one s in a row
14:21 - there is an option to match characters
14:24 - that occur zero or more times that's
14:27 - with this star character here so this
14:29 - regex means match a g
14:32 - and then match an o zero or more times
14:35 - so with this word gold it's going to
14:39 - return
14:40 - g o and then every o after it
14:43 - and then here gut feeling there's a g
14:45 - with no o's after it and since it's
14:48 - matching zero or more times it's going
14:51 - to match that and just return g
14:53 - now this one has no it has an o's but it
14:56 - doesn't have a g so it's going to return
14:58 - null it's not going to match at all
15:00 - so down here we are going to do some
15:02 - coding and match a zero or one time so
15:06 - i'm going to change the change word here
15:09 - and we always want to get the capital a
15:13 - and then for the lower case a
15:15 - we are going to do it a
15:17 - asterisk so it can match this whole
15:20 - thing of a's here so if i just do a
15:22 - console.log here
15:25 - and do a result
15:27 - it should match all of the a's
15:31 - it worked
15:35 - i am going to talk to you about greedy
15:37 - and lazy matches a greedy match finds
15:41 - the longest possible part of the string
15:43 - that fits the regex pattern and returns
15:45 - it as a match
15:47 - a lazy match finds the smallest possible
15:50 - part of the string and returns that
15:53 - regex patterns default to greedy let me
15:57 - show you what i mean let's look at this
15:59 - string here titanic and we'll look at
16:02 - this regex to find something in the
16:05 - string titanic
16:06 - first we're looking for the letter t
16:09 - and then this part means after the
16:11 - letter t we want zero or more of any
16:14 - letter so remember this means any letter
16:17 - a through z the asterisk or star means
16:20 - zero or more occurrences of this a
16:22 - through z
16:23 - and then finally we're looking for a
16:26 - letter i at the end
16:28 - so when we run this match here it's
16:31 - going to do a greedy match and find this
16:34 - t i t-i-t-a-n-i
16:37 - so it's going to start with a t it's
16:38 - going to have zero or more letters and
16:41 - in with an i
16:42 - however if we put a question mark here
16:46 - it's going to be a lazy match so it's
16:50 - going to start with the t and then
16:52 - remember this is zero or more
16:54 - occurrences so instead of having all
16:57 - these letters we're gonna go to the zero
16:59 - occurrence and not have any letters and
17:01 - then end with this i here so it's just
17:04 - going to be t i
17:06 - so a greedy match would be t i t a and i
17:10 - a
17:11 - lazy match would just be t i
17:14 - so let's do the same thing down here we
17:17 - have this string here which is a bit of
17:19 - html with an h1 tag some text winter is
17:22 - coming and a closing h1 tag
17:25 - if i run this now you'll see in the
17:28 - console it's going to return the whole
17:30 - thing so we're going to start with the
17:32 - more than sign here and then we have the
17:35 - dot which is a wild card character so
17:38 - this means any letter or character and
17:41 - then the star or asterisk means zero or
17:44 - more occurrences so this means zero or
17:46 - more occurrences of anything and then we
17:49 - end with the
17:51 - greater than sign so we're going to
17:53 - start with the less than sign right here
17:55 - this is to open an html tag and then we
17:58 - have the dot which is a wild card the
18:01 - asterick or star which means zero or
18:03 - more occurrences so when you have a dot
18:05 - asterisk that means zero or more of
18:08 - occurrences of any character and then
18:11 - end with the more than sign or that the
18:13 - closing tag here so it's going to go
18:15 - from here and then it's going to have
18:18 - zero or more occurrences of any
18:19 - character all the way to this final uh
18:23 - character here this greater than sign so
18:26 - what we're going to do is change this so
18:29 - instead of just get instead of getting
18:31 - this whole thing which was which is
18:33 - greedy we want to do a lazy match where
18:36 - it starts here and just ends at the
18:38 - first occurrence of this greater than
18:40 - sign so all i have to do for that is to
18:44 - add a question mark so if i run this now
18:48 - you'll see in the console it just has
18:50 - the opening h1 tag
18:57 - this is a basic regex challenge so here
19:00 - is the scenario a group of criminals
19:03 - escaped from jail and ran away but you
19:06 - don't know how many however you do know
19:08 - that they stay close together when
19:10 - they're around other people you are
19:12 - responsible for finding all the
19:14 - criminals at once so
19:17 - the criminals are represented by a c
19:21 - so you can see here we have these three
19:23 - c's together these are all the criminals
19:26 - so we need to write a regex function
19:30 - that's going to match any times there's
19:33 - there is one or more c's
19:35 - in the string that's passed in so this
19:38 - is how you would do it
19:39 - it's actually pretty simple we're just
19:42 - going to put a c
19:44 - and a plus so it's going to match one or
19:48 - more
19:49 - c's
19:50 - and if we load that you'll see that it
19:52 - matches the ccc
19:54 - and we solve the challenge
20:01 - you can match patterns that are only at
20:04 - the beginning of the string previously
20:07 - we talked about how the carrot character
20:09 - inside a character set
20:11 - is used to create a negated character
20:14 - set well if you're not in a character
20:17 - set if you're not in brackets you can
20:19 - use the carrot character that looks like
20:22 - this
20:23 - to only match at the beginning of a
20:26 - string so here i'm just going to match
20:29 - the word cow
20:30 - if it's at the beginning of a string
20:33 - so if i load this you can see true
20:36 - because it is the cal is at the
20:38 - beginning of the string however if i
20:40 - take the word cal off here and put it in
20:43 - the middle here
20:44 - and i reload that again it's going to
20:46 - say false because it does not match it
20:49 - anymore since cal is not at the
20:51 - beginning of the string
20:56 - a carrot matches a beginning string
20:59 - pattern
21:00 - a dollar sign matches an ending string
21:03 - pattern so if we want to match the word
21:06 - caboose at the end of the string here
21:08 - we'll type in into the regex we'll type
21:11 - in caboose
21:12 - and then i'll put a dollar sign
21:15 - if you remember when we were matching a
21:16 - beginning string pattern we put the care
21:19 - at the beginning but when we're matching
21:20 - an ending string pattern we put the
21:22 - dollar sign at the end so if i run this
21:25 - we'll see true because it's at the end
21:27 - of the string now if i actually move
21:30 - this over here
21:32 - and i run this we'll see false it's no
21:34 - longer at the end of the string so it no
21:36 - longer matches caboose
21:42 - earlier i showed you that this with the
21:45 - brackets in a through z in it would
21:47 - match any letter a through z
21:50 - there's something called a shorthand
21:52 - character class that's used to
21:55 - match a a wide range of things and
21:58 - there's one called slash w that you can
22:02 - use to match the alphabet so if i put
22:06 - slash w here
22:08 - that's going to match capital a through
22:10 - z lowercase a through z
22:14 - the digits zero through nine and
22:16 - underscore
22:18 - so just doing slash w is just a
22:20 - shorthand way of pretty much matching
22:23 - any letter or number plus underscore if
22:26 - i put a g after this that will make it
22:29 - match every occurrence so if i load this
22:32 - up you'll see that it returns 31 because
22:34 - we're getting the length the length of
22:37 - this whole string
22:39 - excluding the spaces in the period is
22:42 - 31. there are 31 letters in this string
22:51 - slash w matches all letters or numbers
22:55 - but sometimes you want the opposite
22:57 - sometimes you want to match everything
22:59 - that's not a letter or number so in this
23:02 - code we want to just match everything
23:04 - that's not a letter or number which are
23:07 - the spaces and the period in this string
23:10 - here so instead of a slash lowercase w
23:13 - we're going to use a slash uppercase w
23:17 - and then i will put a g
23:20 - to match every single occurrence
23:23 - and we're gonna get the length here so
23:25 - if i run that we get a length of six
23:28 - there are six characters that's those
23:30 - are the spaces and the period that are
23:32 - not letters numbers or underscores
23:38 - there is a shorthand character class to
23:40 - only match numbers or digits and it's
23:44 - slash d so if i put slash d here it's
23:48 - going to match the digits here which is
23:50 - the five the zero and the zero to match
23:53 - every single one i'm going to put a g at
23:56 - the end for global and then now the
23:58 - length should be three so if i run that
24:01 - we'll see three in the console
24:07 - sometimes you want to match all non
24:09 - numbers
24:10 - if you remember this slash d
24:13 - a lowercase d would match all numbers
24:16 - and the g made it match every occurrence
24:18 - of a number
24:19 - so if we change this to an uppercase d
24:23 - this is going to match all non-numbers
24:26 - so that's going to be every single
24:28 - character in this whole string except
24:31 - the five the zero and the zero so
24:35 - we'll run this to get the length of that
24:37 - and we get 24.
24:42 - we're going to create a regex that can
24:44 - be used as a username validator
24:48 - in this case there are three
24:50 - requirements for the username
24:53 - so here's the first requirement if there
24:55 - are numbers they must be at the end
24:58 - second requirement letters can be
25:00 - lowercase and uppercase and then the
25:03 - third requirement is that it must be at
25:05 - least two letters long
25:07 - two letter names can't have numbers uh
25:10 - which is kind of a fourth requirement
25:12 - so let's create the regex here so first
25:16 - we are going to do the requirement that
25:17 - the number should be at the end so if
25:20 - the numbers should be at the end then
25:22 - letters should be at the beginning so to
25:24 - specify what's at the beginning we are
25:26 - going to use the carrot sign
25:28 - and then we're going to specify the
25:30 - letters that can be at the beginning
25:32 - which are lowercase and uppercase
25:33 - letters so i'll do a through z uppercase
25:37 - and then 8th
25:38 - a through z
25:40 - lowercase
25:42 - so now it shows that at the beginning is
25:44 - going to be
25:45 - a through z uppercase or a through z
25:48 - lowercase
25:49 - and to specify the number of letters
25:52 - that are going to be at the beginning
25:53 - we're going to use the following i'm
25:55 - going to put a curly brace
25:58 - 2 comma
26:00 - in curly brace the curly braces indicate
26:03 - the number of times the previous thing
26:06 - can match so the previous thing are
26:08 - these letters and these can match
26:12 - anywhere between two
26:14 - and infinite number of times so
26:17 - the number before the comma is the
26:19 - minimum number of matches and the number
26:22 - after the comma is the maximum number of
26:25 - matches so we know that every username
26:29 - is going to start with at least two
26:31 - letters and since there's no number
26:34 - after the comma it can have an infinite
26:37 - number of letters in the username
26:40 - if we wanted it to have at max eight
26:43 - letters then we could put the number
26:44 - eight after the comma but since we don't
26:47 - care about the max we're gonna leave it
26:49 - as nothing after the comma so
26:52 - next we want to show that the numbers
26:56 - must be at the end and you can have any
26:58 - number of numbers so i'll put slash d
27:02 - and that represents all numbers i'll put
27:06 - a star so this star or asterisk means
27:10 - that there should be zero or more so
27:13 - this means zero or more numbers and now
27:15 - to show that the zero or more numbers
27:17 - are at the end i will put a dollar sign
27:21 - we can now run this regex to make sure a
27:24 - username meets all of these requirements
27:31 - we can match white space characters with
27:35 - slash s
27:36 - so slash s is going to match a space a
27:39 - carriage return a tab a form feed and a
27:42 - new line character
27:44 - so if i add a g for global and run that
27:48 - we will see an array of all the spaces
27:50 - in that sentence the white space is
27:52 - important in separating words sentence
27:59 - now i'll show you how to match all
28:01 - non-white space characters
28:04 - first make a guess
28:06 - so remember this is how you match
28:09 - white space characters and if you've
28:11 - been noticing the pattern so far you'll
28:13 - realize to match non-white space
28:16 - characters is just a capital s
28:19 - so if we run that you'll see an array of
28:22 - every character that's not a space
28:28 - you can specify the lower and upper
28:30 - number of pattern matches with quantity
28:33 - specifiers
28:35 - quantity specifiers are used with curly
28:37 - brackets
28:38 - i actually talked about these a little
28:40 - bit before
28:42 - you put two numbers between the curly
28:44 - brackets for the lower and upper number
28:46 - of patterns so let's say i want to match
28:50 - anything any oh no
28:53 - where the number of h's is between three
28:56 - and six h's so what i'll do is type o no
29:01 - but after the h i'm gonna put these
29:04 - curly brackets and put three comma six
29:08 - so this means we're gonna always match
29:10 - the letter o and then we're gonna match
29:12 - the letter h but we only match if there
29:15 - is in between three and six h's and then
29:20 - we'll also match this space in o
29:23 - if we had not had a number here and we
29:25 - just had three comma and the nothing in
29:28 - the in curly brace then it would match
29:31 - for an infinite number of occurrences so
29:33 - it would be three h's through an
29:35 - infinite number of h's but we'll just
29:37 - leave it at six
29:42 - here's another example with quantity
29:44 - specifiers where we're going to match
29:47 - four or more of the letter z
29:49 - so i'll put the letter z
29:52 - and then the curly brackets i'll put
29:54 - four comma and then there will be
29:56 - nothing after the comma because like i
29:58 - said before when you have nothing after
30:00 - the comma there's an infinite number
30:03 - that it could go to so it has to be at
30:05 - least four and then it can be an
30:07 - infinite number of z's
30:12 - we can use quantity specifiers to
30:14 - specify an exact number of matches
30:17 - instead of just a lower and upper bound
30:20 - so if we want to search for the word
30:22 - timber with exactly four m's you can do
30:26 - it like this p-i-m
30:28 - and then i'll do the curly braces and
30:30 - then just put the number four and then
30:33 - b-e-r so remember before we had the up
30:37 - the lower bound then comma upper bound
30:40 - but if we know we want exactly four m's
30:42 - we can just put the number four in the
30:44 - curly braces
30:49 - you can specify the possible existence
30:52 - of an element with a question mark
30:54 - this checks for zero or one of the
30:58 - preceding element
31:00 - it's kind of like saying that the
31:01 - previous element is optional for example
31:04 - there are slight differences in american
31:06 - and british english so the word favorite
31:09 - can be spelled with just an o or with an
31:13 - o u with british english so let's create
31:16 - a regex that that searches
31:19 - that can match both forms of the word
31:21 - favorite so do favor and i'll put a u
31:25 - with the question mark r-i-t-e
31:28 - so this is this is saying that it may
31:31 - have a u or it may not have a u but all
31:34 - the other letters have to be the same
31:40 - lookaheads are patterns that tell
31:42 - javascript to look ahead in your string
31:45 - to check for patterns further along
31:48 - this can be useful when you want to
31:50 - search for multiple patterns over the
31:52 - same string
31:54 - there are positive look-aheads and
31:56 - negative look-aheads
31:58 - so let me show you how they work
32:01 - so this right here is a positive
32:05 - lookahead so we have parentheses and
32:09 - then we have a question mark so the
32:12 - look-aheads always start with a question
32:13 - mark and then it's going to be equals
32:16 - for a positive look ahead or an
32:18 - exclamation point for a negative look
32:21 - ahead so let's look back at the positive
32:23 - look ahead so
32:25 - question mark equals means a positive
32:27 - look head and u so it's first going to
32:31 - check for the q
32:32 - and it's going to look ahead to make
32:35 - sure there is a u
32:37 - later in the string and if there is a u
32:40 - later in the string will return just the
32:43 - q
32:44 - so when we run this regex on the quit
32:47 - string it's going to return q because it
32:50 - finds the u later in the string but it
32:53 - doesn't return that u
32:55 - a negative look ahead it's going to make
32:58 - sure that something is not later in the
33:00 - string so here it's going to search for
33:02 - a queue and make sure there's not a u
33:05 - later in the string and if there is not
33:08 - a u later in the string it's going to
33:10 - return this so when we run this look
33:14 - ahead on the no quit screen string it's
33:17 - going to find the queue and it's going
33:19 - to look ahead and find out there is no u
33:23 - since there is no u it's just going to
33:25 - return the q because that's what we have
33:27 - before the parentheses and it's going to
33:29 - return the q here a more practical use
33:32 - of lookaheads is to check two or more
33:35 - patterns in one string
33:37 - so down here in this example
33:40 - we are going to use lookaheads in the pw
33:44 - regex to match passwords that are
33:47 - greater than five characters long and
33:49 - have two consecutive digits so for a
33:53 - greater than five characters
33:56 - we'll do parentheses and then it's
33:58 - always gonna start with the question
34:00 - mark equals if it's a positive lookahead
34:03 - and i want greater than five characters
34:05 - so slash w would be all
34:09 - numbers and letter characters and we
34:12 - want there to be
34:14 - five characters at least five characters
34:18 - and then we also want two consecutive
34:20 - digits so i'm going to make another look
34:23 - ahead question mark equals
34:26 - and we're going to say there can be
34:28 - any number
34:30 - of characters that are not digits this
34:33 - capital d the slash capital d is
34:36 - a character that's not a digits and the
34:38 - asterisk means there's zero or more
34:40 - characters that are not a digit but we
34:43 - also want to make sure that there are
34:46 - two or more digits so
34:50 - we have the slash d
34:52 - to say that there are going to be digits
34:55 - and then we have two so it's going to be
34:57 - two or more digits so
35:00 - this is going to match for
35:03 - five or more characters and then two or
35:06 - more digits
35:12 - you can group things you are searching
35:14 - for in a regex with parentheses
35:16 - so here we have
35:18 - parentheses around here so we are
35:21 - searching for
35:22 - any number of characters and then after
35:26 - that there's going to be a space
35:29 - you can also use these parentheses to
35:32 - repeat sub strings so this is called a
35:35 - capture group
35:37 - and
35:38 - you can repeat this group any number of
35:40 - times so in this regex we have this
35:44 - first group in parentheses and we can re
35:47 - we can repeat that first group with a
35:49 - slash one
35:51 - if we had a no another group with
35:54 - parentheses we could repeat that second
35:57 - group with slash two
36:00 - so
36:01 - in this case we are searching for any
36:04 - group of any number of letters followed
36:08 - by a space
36:09 - followed by any number of letters that
36:12 - are the same letters as before because
36:14 - we're doing slash one if we test
36:18 - this regex against this string it's
36:20 - going to return true because it has any
36:23 - number of letters
36:24 - it has a space and then it repeats any
36:27 - number of letters the same letters from
36:29 - before so that's any number of letters
36:31 - the space and then we're repeating the
36:33 - same no letters as before
36:36 - now here where we did slash one we could
36:39 - have just
36:41 - put this whole thing again the
36:43 - parentheses with the slash w i'm gonna
36:45 - copy and paste here so this would have
36:47 - been the same thing
36:49 - uh but instead of repeating this twice
36:52 - we can just put slash one to save space
36:56 - so we don't have to repeat if we want to
36:59 - repeat the same
37:00 - search over and over again in a in a
37:03 - regex so if we look down here
37:06 - for the match at first this may seem
37:09 - confusing what it's returning
37:11 - but what it's returning the first
37:14 - element in the array is the full match
37:17 - so that's the
37:19 - the any number of characters plus a
37:21 - space plus any number of the same
37:23 - characters so the full match is this
37:26 - and then the second element in the array
37:29 - is just whatever is in the capture group
37:32 - this is the capture group and we and
37:34 - what's in the capture group is just
37:36 - regex that's why we have regex regex
37:39 - which is the full
37:40 - regex
37:42 - and then the second element of the array
37:43 - is just regex which is just the capture
37:46 - group the thing in the parentheses here
37:48 - so down here we are going to attempt to
37:51 - use capture groups to match numbers that
37:54 - are repeated only three times in a
37:56 - string each separated by a space
37:59 - we want this regex to match something
38:01 - like this 42 space 42 space 42 we would
38:05 - also want it to match something like
38:07 - 136 space 136 base 136 it doesn't matter
38:12 - what the number is
38:13 - and we only want to match a group of
38:16 - three so we don't want to match four
38:18 - numbers five numbers six numbers just a
38:19 - group of three numbers separated by
38:21 - spaces so let's see how to do that
38:24 - we are going to use a capture group so
38:27 - i'm going to put a parenthesis slash
38:30 - d plus that means any number of digits
38:34 - and that's going to be the end of our
38:36 - capture group
38:37 - and then it's going to have a space
38:40 - and then i'm going to put slash one
38:43 - which just is a shorthand way of
38:45 - repeating the first thing in parentheses
38:48 - which is this
38:49 - and then we'll have another
38:52 - space
38:54 - and another slash one
38:56 - so this is going to look for any number
39:00 - and a space
39:01 - any number
39:02 - and a space any number so it's a number
39:05 - three times
39:07 - we're not quite done yet though because
39:09 - remember i say said we want to match
39:12 - only three numbers so
39:15 - this regex would also match
39:18 - this if the number was in there four
39:20 - times because it would find 42 42 42 and
39:25 - then stop and it would say oh we found
39:27 - it but we don't want to match it if
39:29 - there's 4 42s in a row we only want to
39:32 - match it we only want this to return
39:34 - truth there's three 42s in a row so
39:37 - that's simple to fix we just have to
39:40 - have a
39:41 - bracket or i mean a carrot at the
39:43 - beginning
39:44 - and a
39:46 - dollar sign at the end
39:49 - so remember a carrot means that we want
39:53 - this at the beginning of the string
39:56 - and then a dollar sign means we want
39:58 - this at the end of the string so adding
40:01 - the care and the dollar sign just means
40:03 - we want exactly this we don't want
40:06 - anything before this we don't want
40:08 - anything after this so now
40:10 - this will return true for any group of
40:13 - three numbers not a group of four
40:15 - numbers not a group of five numbers
40:21 - you can search and replace text in a
40:23 - string using the replace function on a
40:26 - string
40:27 - the inputs for replace is first the
40:29 - regex pattern you want to search for and
40:31 - the second parameter is the string to
40:33 - replace the match or a function to do
40:35 - something so let's look at this example
40:38 - we have this text the sky is silver
40:41 - we're going to search for silver this is
40:43 - our regex pattern so we're going to do a
40:46 - replace here we've got the wrong text
40:48 - dot replace we're going to pass in the
40:51 - regex the silver regex which is
40:53 - searching for the word silver and it's
40:55 - going to replace it with the word blue
40:58 - so this is going to return the sky is
41:00 - blue
41:02 - now you can also access capture groups
41:05 - in the replacement string with dollar
41:08 - signs
41:09 - let me show you what i mean down here so
41:11 - here we have a string
41:13 - code camp and we're going to call the
41:15 - replace function on that string now look
41:18 - at the regex so up here we just use the
41:20 - variable silver regex which was set to
41:23 - this regex here we're putting them in
41:26 - the regex directly into the function
41:28 - instead of using a variable so look at
41:30 - this regex we have this capture group
41:34 - which just means any number of letters
41:37 - then we have a space
41:38 - and then we have this other capture
41:40 - group which just means any number of
41:42 - letters
41:44 - so that's going to find this code space
41:47 - camp any number of letters space any
41:49 - number of letters
41:50 - so let's look here so up here we just
41:55 - put in the word we want to replace with
41:58 - but here we do something different it
42:00 - says dollar two
42:02 - dollar sign one so
42:04 - dollar sign two means the second capture
42:08 - group the second parentheses in the
42:10 - regex so the second capture group is
42:13 - this which has matched to the word camp
42:17 - so we're putting camp at the beginning
42:20 - and then a space and then dollar sign
42:22 - one means the first capture group which
42:25 - is this section which matched the word
42:28 - code so this is a way so you can see it
42:31 - returns camp code so we pass in the text
42:35 - code camp
42:36 - and it returns
42:38 - camp code so that's another cool thing
42:40 - you can do with capture groups
42:43 - when you're doing a replace
42:46 - so let's get back to the easier one up
42:48 - here we're going to actually
42:50 - make some changes down here that follows
42:52 - this pattern up here so
42:55 - this sandwich is good well we are going
42:59 - to find the word good here
43:02 - and we're going to replace it with the
43:05 - word
43:06 - okie dokie
43:08 - so here it's going to find the fix regex
43:11 - which is good and it's going to replace
43:14 - it with the replace text which is okie
43:16 - dokie
43:20 - this is a regex coding challenge the
43:24 - challenge is to write a regex and use
43:26 - the appropriate string methods to remove
43:29 - white space at the beginning and end of
43:32 - this string here
43:34 - now the trim method would work here but
43:36 - the challenge is to do it with just
43:38 - using regular expressions
43:41 - so we are going to do a replace
43:45 - but we have to write a regular
43:46 - expression that's going to figure out
43:48 - what we're going to replace
43:50 - well let's write a regular expression
43:52 - that finds all the space at the
43:54 - beginning and all the space at the end
43:58 - so this is how we'll do this
44:00 - to find everything at the beginning it's
44:02 - going to start it with a carrot which
44:05 - finds something at the beginning of a
44:07 - string and we'll put slash
44:10 - s which is all the white space and the
44:13 - any number of white space characters
44:15 - i'll do a plus
44:16 - now we also want to find all the space
44:18 - at the end so i'll do a pipe character
44:20 - which means or so all the space at the
44:23 - beginning or all the space at the end
44:26 - for all the space at the end we'll do
44:27 - slash s
44:29 - plus and then a
44:31 - dollar sign which means this has to be
44:34 - at the end and so
44:37 - we find both the space of beginning and
44:39 - the spaces at the end i'm going to add
44:42 - the flag g here
44:44 - so now we've found all the spaces we
44:48 - just have to finish this replace here so
44:51 - hello
44:52 - dot replace
44:55 - and then in parenthesis first the regex
44:58 - w
44:59 - s
44:59 - regex
45:01 - and then we are going to replace
45:04 - all the spaces that it's going to find
45:07 - with just an empty string
45:11 - so this will effectively remove the
45:13 - spaces from that string
45:15 - uh oh i need a parenthesis here
45:19 - and let's test this out you can see in
45:21 - the console hello world with no spaces
45:24 - at the beginning or the end
45:29 - congratulations on finishing this
45:31 - regular expressions course
45:34 - well keep learning and thanks for
45:36 - watching