00:00 - laser is a single page application
00:01 - framework created by microsoft with
00:04 - blader you write c sharp to generate
00:06 - dynamic content
00:08 - and with blader you can become a full
00:11 - stack developer with c sharp on both
00:13 - front end and back end my name is frank
00:16 - liu i'll be talking about the
00:18 - architecture and how it works for the
00:20 - first three modules
00:21 - then we'll get into every aspect of
00:24 - laser in-depth towards the end we will
00:26 - be creating a reusable data grid
00:28 - component using the knowledge that we
00:30 - are going to learn without further ado
00:33 - let's get started
00:41 - blazer is for web development
00:43 - so to talk about laser architecture i
00:46 - want to talk about two typical web
00:48 - development architecture first the first
00:50 - one is the
00:52 - very typical request and response model
00:56 - where you have a
00:57 - browser
00:58 - and you have your user interact with the
01:02 - browser and whenever the user wants to
01:04 - see something
01:06 - the browser
01:08 - sends
01:09 - a
01:10 - http
01:11 - request
01:13 - to the server side server
01:15 - and the server
01:17 - process the request
01:19 - here and
01:20 - returns
01:22 - a rest http
01:24 - response
01:25 - and what's in the http response is html
01:29 - and then the http
01:32 - the html will be rendered on the screen
01:34 - and the user sees it and the user is
01:36 - happy
01:37 - so this is the first
01:40 - architecture
01:42 - and
01:43 - a lot of the development technology
01:45 - actually uses this for example the
01:48 - original
01:49 - from microsoft's original classic asp
01:53 - right so asb
01:55 - and then you have jsp
01:57 - and then you have
02:00 - the microsoft asp.net web forms
02:05 - you have
02:06 - asp.net mvc
02:09 - and
02:11 - the asp.net core mvc
02:13 - yeah a lot of them are using this
02:16 - architecture
02:17 - with some help wizard without some help
02:19 - of javascript
02:21 - and the second architecture is
02:25 - it's more interactive
02:28 - that's when the um
02:31 - the web development world notice that
02:35 - that this first architecture
02:37 - it's good
02:39 - but
02:41 - the performance wise it's it's not great
02:44 - and
02:45 - when the development world notice that
02:47 - the
02:48 - the browser actually
02:50 - it runs it's its desktop application it
02:53 - runs on the computer
02:55 - and has its own powerful
02:58 - um compute computing power
03:02 - and
03:03 - as the
03:04 - client computer is getting more and more
03:06 - powerful
03:09 - the smartphone also gets very very
03:12 - powerful
03:13 - the browser has a
03:15 - very powerful computing power
03:18 - the storage is getting bigger and bigger
03:20 - as well
03:22 - so then
03:23 - why don't we
03:24 - take advantage of this
03:27 - computing power
03:29 - so that
03:31 - introduced the second
03:34 - architecture
03:35 - where we actually
03:37 - use this
03:38 - javascript
03:40 - running directly on the browser
03:42 - and renders
03:44 - the result to the dome
03:48 - right and here
03:50 - let's start from the user side so the
03:52 - user interacts with
03:54 - the browser
03:56 - and then um
03:58 - the browser
03:59 - the dom actually uh
04:02 - sends events
04:03 - like the user clicks on button
04:05 - so you have a on click event
04:08 - right and then
04:10 - some other controls may trigger on
04:11 - change event
04:15 - so on key down on key up those kind of
04:18 - events are handled in the javascript
04:21 - and then the javascript
04:23 - since
04:25 - calls the web api running on the server
04:28 - nowadays you have more options but uh
04:30 - let's just use web api
04:32 - for uh for example
04:34 - right
04:35 - so
04:36 - it sends a
04:37 - web api
04:39 - so this is a http request
04:42 - and then the web api
04:44 - actually uh
04:46 - communicates
04:47 - typically communicates with a database
04:50 - to get the data
04:52 - so here in this example i was just uh
04:56 - i didn't talk about the
04:58 - details here
05:00 - but in the second architecture i have to
05:02 - so javascript calls the http uh
05:06 - the the web api or just let's call it
05:10 - the rest api
05:11 - and then
05:13 - it returns a
05:15 - http
05:16 - response
05:19 - typically in the format of
05:23 - json
05:25 - and then
05:28 - the data
05:29 - is
05:30 - consumed here in the javascript
05:33 - right that is consumed here in the
05:35 - javascript
05:36 - and html is created
05:40 - or updated
05:42 - and sends
05:43 - to the renders to the dome
05:45 - the user sees it
05:48 - so that
05:50 - leads stood blazer
05:53 - so um we have javascript frameworks the
05:56 - friend and frameworks um so we have uh
05:59 - jquery
06:03 - so jquery is probably a library so we
06:05 - have front-end frameworks and front-end
06:08 - libraries like jquery
06:10 - react
06:11 - angular vue.js
06:14 - all of these
06:16 - right so we're asking
06:18 - a question that i react is from facebook
06:22 - and uh angular is from google
06:24 - so then where is microsoft
06:26 - everybody's uh kind of expecting that
06:29 - um
06:30 - but
06:31 - just recently
06:33 - we have been waiting for a long time
06:34 - just recently
06:36 - microsoft came
06:38 - with
06:39 - a new technology that's called blazer
06:43 - and
06:44 - the blader architecture is actually
06:46 - other two actually two kinds of
06:48 - architecture from blazer
06:50 - one is the client side one is the server
06:52 - side
06:54 - and the client side is actually very
06:55 - very similar
06:57 - to
06:58 - the second type of architecture
07:00 - so if i can copy this
07:03 - i can copy this
07:06 - so
07:07 - laser is very very similar to the first
07:11 - architecture so the only thing that is
07:13 - different here is instead of using
07:14 - javascript we're having c-sharp here it
07:17 - means that we can use c-sharp on the
07:19 - server-side as well as on the client
07:22 - side that opens a lot of doors for us
07:25 - javascript is nice it's good
07:28 - but then it's actually evolves in a very
07:30 - dangerous speed
07:33 - so let's also talk about the server side
07:35 - so blazer
07:36 - has a hosting model
07:38 - that is
07:40 - blindside as well server side
07:42 - and let's start with the on the browser
07:46 - so we also have the stone here
07:49 - and instead of having the c sharp code
07:52 - basically the
07:53 - service hosting model we pull the c
07:56 - sharp code from the client side
07:59 - to the server side
08:01 - okay so here instead of c sharp we're
08:04 - having
08:05 - blazer
08:06 - it's a javascript file i forgot the name
08:09 - but
08:10 - once we go to the computer i'm going to
08:13 - show you where the file is
08:15 - so we're having the c trap library
08:17 - pulled over
08:19 - to
08:20 - the
08:21 - server side and that's why they call it
08:23 - hosting model so we have the laser the
08:26 - blazer applications can call the service
08:29 - layer and then the service layer can
08:31 - call the repository layer and the
08:33 - repository can work with contacts db
08:36 - contacts if we are using
08:38 - entity framework
08:43 - but how the server side communicate with
08:45 - the client side that's
08:48 - where we have the websocket
08:51 - wrapped around by signing our right so
08:54 - this is dedicated communication channel
08:56 - it means that we are using
08:58 - instead of http request response we're
09:00 - sending messages back and forth
09:02 - and um
09:03 - so this channel is maintained constantly
09:07 - and that's uh this very smart way
09:10 - and this blazer dot js this this this
09:13 - file is used to communicate
09:16 - with the
09:17 - um
09:18 - laser application this rc short code
09:20 - there and the performance is also pretty
09:22 - amazing and this uh
09:24 - so the architecture that
09:27 - we're comparing the architecture between
09:30 - laser client-side and blazer server-side
09:33 - is that
09:36 - if we are
09:37 - with this client-side application
09:39 - actually um
09:42 - we can
09:43 - create microservices
09:46 - uh by creating different web apis or
09:49 - yeah
09:50 - and
09:51 - but server side we can also do that um
09:54 - if we do that then the we cannot call
09:56 - the service layer and posture layer or
09:58 - to context to be contacts directly in
10:01 - the same machine
10:02 - because this is monolithic so we if
10:05 - we're trying to do the monolithic
10:07 - architecture on the server side then we
10:09 - cannot
10:10 - um
10:12 - uh
10:13 - yeah it's not gonna
10:16 - be very efficient
10:18 - and if we want to still support
10:21 - microservices then we have to pull the
10:24 - service layer and postulator outside to
10:27 - a different machine to different hosting
10:29 - environment
10:31 - the request response
10:33 - architecture is stateless
10:35 - the second
10:36 - the front-end frameworks um
10:39 - architecture we maintaining state on the
10:42 - client side
10:43 - but this part is also stateless right
10:46 - the communication part with the backend
10:48 - api
10:49 - and
10:50 - with the laser client side we're
10:51 - maintaining the state also in the client
10:53 - side
10:54 - um
10:55 - and with the server
10:57 - see the problem is that we're
10:58 - maintaining the state on the server so
11:01 - if we are having
11:04 - we're having a lot of users on the
11:06 - client side
11:07 - that means we're going to host a lot of
11:09 - state
11:10 - and that really
11:12 - we're going to host the state on the
11:13 - server side for you know many many times
11:17 - and that's really costing a lot of
11:18 - resources
11:21 - and that's going to be a
11:24 - issue that we need to consider
11:28 - whether or not we are having the service
11:31 - layer hosted somewhere else as apis
11:34 - this is something we need to consider
11:37 - uh in in the next video i'm going to
11:39 - take a deeper look at the
11:42 - architecture the blazer architecture
11:44 - to explain why we can
11:47 - host c-sharp
11:49 - directly in the browser how microsoft
11:53 - does this
11:54 - and then
11:56 - how it actually works
12:04 - let's take a deeper look at the blazer
12:08 - architecture have a browser here
12:12 - and again
12:14 - i'll draw the dome here
12:16 - and
12:18 - we need to be able to
12:20 - run the code on the browser
12:23 - and how do we do that there is this
12:25 - thing
12:26 - that's called webassembly
12:28 - and if you go to the web apps assembly
12:31 - the website
12:33 - they say that web assembly is a compiler
12:36 - target
12:38 - so then what is
12:39 - a compiler target
12:42 - we have a compiler here
12:44 - there's this compiler source
12:47 - and then
12:48 - there's this compiler target
12:51 - so compiler source
12:53 - is the source language
12:56 - and compiler target
12:58 - is just the
13:00 - target language
13:02 - so compiler is basically when it
13:05 - compiles convert the stress language to
13:08 - the target language so for example
13:11 - c-sharp
13:13 - after compilation
13:15 - it turns into
13:18 - right it turns into intermediate
13:20 - language
13:22 - and
13:23 - how does an intermediate language runs
13:25 - on us on a computer
13:27 - so if we have a computer here
13:29 - the immediate language is not a
13:33 - machine language that can run directly
13:36 - on this on the computer
13:37 - so what it does is that
13:40 - it has we have a
13:43 - net
13:44 - runtime
13:46 - right and the intermediate language
13:48 - actually
13:50 - runs within the context of dynamic
13:52 - runtime
13:53 - so if we come back
13:55 - to this later topic
13:58 - so websimply
14:00 - is
14:00 - a let's say it's a language
14:04 - that can run directly in the browser
14:08 - and how can that be possible
14:11 - that's because
14:13 - most of the
14:14 - vendors like chrome
14:18 - google chrome
14:22 - microsoft edge
14:23 - internet explorer
14:26 - firefox most of the vendors
14:28 - they agreed on this web assembly
14:31 - standard
14:33 - and
14:34 - most of them most of the products
14:37 - they are able to support
14:39 - this
14:40 - web apps only standard so as long as
14:44 - your code is written in this web
14:46 - assembly language
14:48 - then
14:49 - there's
14:50 - browser supported and there is actually
14:52 - a kind of like natively dress really
14:54 - fast
14:56 - performance is amazing so
14:58 - how can the c sharp run
15:00 - inside the browser
15:02 - the answer is it runs as a web assembly
15:05 - that's not entirely true
15:07 - in terms of
15:09 - how blazer runs on the browser blazer
15:13 - actually
15:16 - does not we do not actually turn
15:19 - the c-sharp codes into web assembly
15:23 - what it does is that there is this thing
15:25 - that is called mono
15:29 - web assembly and the mono web assembly
15:31 - is a runtime
15:33 - mono web assembly itself
15:36 - is
15:37 - a
15:39 - web web assembly
15:40 - so it runs on the browser so if i draw
15:45 - if i draw another
15:48 - square here
15:49 - and if we call this
15:51 - mono
15:52 - web
15:53 - assembly
15:55 - so this is the um
15:58 - when the server runs
16:01 - so if we have server here
16:03 - and if we have our uh
16:07 - blazer application hosted
16:10 - in the
16:11 - server
16:12 - and
16:14 - when the user sends a http request
16:18 - through the browser
16:19 - the server actually first it pushes
16:23 - the
16:24 - mono
16:26 - web assembly to the browser
16:29 - all right and
16:31 - it it is actually a run time
16:34 - it works like a runtime so after that
16:37 - our
16:39 - blazer applications the blazer framework
16:42 - as well as dotnet standard
16:44 - libraries
16:46 - all of the dependencies of our
16:49 - blazer applications will be downloaded
16:51 - to the server
16:52 - so
16:54 - the next layer would be
16:57 - would be our um
16:59 - done at runtime so
17:01 - oh sorry not the
17:03 - the dyna standard done standard
17:06 - and the next layer
17:08 - so this
17:09 - would be also downloaded and
17:12 - all right so we have our
17:16 - blazer framework here
17:18 - and within the blazer framework
17:21 - our blazer application actually runs
17:23 - here
17:24 - so lastly
17:25 - our replacer app runs here
17:28 - and
17:29 - how does the blazer app actually
17:31 - produces the
17:32 - html
17:34 - as we know that
17:36 - blazer actually uses a
17:39 - component-based
17:41 - architecture which means
17:43 - our developers actually created a lot of
17:45 - components
17:48 - we create components
17:50 - inside the blazer applications
17:53 - so and we call it the component tree so
17:56 - for example if we have
17:58 - a computer if we have a
18:02 - ui design that looks like
18:05 - this so we have a menu items and then we
18:08 - have
18:09 - we have uh some area
18:12 - that looks like that
18:14 - and within this area
18:16 - we have uh
18:20 - two like kind of like two panels
18:23 - and
18:25 - something is displayed here and then
18:26 - some things will play here and then
18:29 - a picture
18:31 - maybe
18:32 - displayed here
18:35 - then
18:36 - here we actually have
18:38 - a
18:40 - component tree here right so we have our
18:42 - root component which is this one right
18:45 - the biggest one so we have a root
18:47 - component and then we have
18:50 - two components on the second level
18:53 - and then we
18:54 - have in here we have
18:57 - three components
19:00 - right so it's component tree
19:03 - so this component tree
19:08 - constantly changes when user interacts
19:11 - with the use with the interface
19:13 - right
19:14 - so the user clicks somewhere or press
19:17 - keys changes the data so the data would
19:20 - be changing the components would be
19:22 - reloading
19:27 - right sometimes it may switch to a
19:29 - completely different
19:32 - set of components
19:35 - so this component tree is actually being
19:38 - tracked by the blazer application
19:41 - so we would have two
19:45 - so this is the previous component three
19:49 - the previous tree
19:51 - and
19:53 - this is the current tree
19:57 - currently
19:58 - so
20:01 - whenever user makes some changes
20:07 - it generates the current tree
20:09 - and then it compares with the previous
20:12 - tree
20:14 - right so here it makes a comparison
20:18 - between this two
20:20 - uh the previous tree and the current
20:22 - tree and then it creates a div
20:24 - it calculates a
20:27 - component tree div
20:29 - and this component tree def
20:31 - will be sent
20:35 - to the dome and used to update the dom
20:39 - and then the user would be able to see
20:42 - the changes
20:44 - so
20:45 - this is the the client side blazer
20:48 - right
20:50 - this is how it works
20:55 - so to summarize a little bit
20:58 - the blazer application
20:59 - they are actually so all of these are c
21:02 - sharp
21:03 - dlls right c sharp d allows
21:06 - c sharp dll
21:09 - and um
21:10 - and this is mono
21:12 - uh webassembly this is actually a web
21:16 - assembly
21:18 - so this is the client side
21:20 - so the server set
21:22 - let's cover server side here the server
21:25 - side blazer
21:27 - works very similarly just like
21:30 - in our previous video
21:32 - we covered
21:36 - but
21:37 - all these things actually happens on the
21:39 - server side that's why it's called
21:41 - server side so
21:43 - if i try to cover that again here
21:46 - so we have a browser here
21:48 - right and then we have our dom here
21:53 - and in here
21:57 - we have the
21:59 - blazer
22:02 - now i remember the name
22:03 - blades are server
22:06 - dot js
22:08 - and then on the server i have to draw a
22:10 - bigger
22:12 - rectangle here to represent the server
22:15 - so in here
22:17 - of course we're going to have our
22:20 - dotnet
22:21 - if i follow the same way of drawing
22:23 - we're going to have our
22:25 - dotnet framework
22:27 - so we're not limited
22:29 - we can use the fold on our framework
22:31 - here it doesn't have to be using
22:33 - that.net standard
22:35 - we can have our.net framework
22:38 - and then within that you can run our
22:40 - blazer
22:41 - please a framework
22:43 - and within it we have our laser app
22:47 - and then we have our
22:49 - previous tree and current tree
22:52 - and uh
22:55 - so our bridger
22:58 - applications also
23:00 - communicates where's the where
23:03 - uh through the signal error channel
23:06 - right
23:07 - signal our
23:08 - websocket channel
23:11 - so
23:13 - then what happens is that the um the
23:15 - user sends requests
23:19 - and then
23:20 - the message is sent over to the blazer
23:22 - application
23:23 - and the components gets updated the data
23:26 - gets refreshed
23:28 - and
23:29 - the comparison happens here
23:32 - and then this christie
23:34 - ui
23:35 - dev
23:37 - all right so this ui div
23:39 - is sent over
23:41 - to the
23:42 - browser through the blader server dot js
23:45 - file
23:46 - and then
23:48 - gets
23:49 - the actual
23:50 - dom is updated
23:53 - that the user sees the results
23:57 - so that's how blazer
24:00 - works in detail
24:08 - when it comes to the pros obviously pros
24:11 - with the web assembly model is that you
24:14 - fully utilize the client-side resources
24:17 - and all flows the burden of the server
24:20 - right because everything
24:22 - that is needed is already on the
24:25 - client-side
24:26 - browser but the cause of the
24:29 - webassembly hosting model is that
24:32 - because
24:33 - it
24:34 - it downloads everything so the initial
24:36 - load is low
24:37 - and that's
24:39 - those are the main pros and cons of
24:41 - webassembly everything else is pretty
24:43 - minor so i'm not going to mention
24:46 - for the server side
24:48 - the server side
24:51 - there's also pros and cons
24:53 - and obviously
24:55 - the pros
24:56 - of one hosting model is going to be the
24:59 - cost of of the other one
25:02 - and the cost of the
25:04 - one wholesome model will be the pros
25:06 - with the other model right so for the
25:08 - pros of the blazer server
25:11 - the the first one is you have a very
25:14 - fast initial load because everything is
25:17 - actually
25:18 - within the server side and
25:21 - there's there's not much
25:22 - that you you need to uh to be sent to
25:25 - the server right the only thing is this
25:28 - ui difference and it's
25:30 - it's it's very minimum because it's only
25:33 - the difference between the two
25:35 - uh
25:36 - the previous
25:38 - render tree and the current render tree
25:41 - plus this ui difference is in a battery
25:44 - format all right so it's very compact
25:47 - so you you have a fast initial load
25:50 - that's obvious for the first server
25:52 - setup laser
25:54 - and also
25:55 - for developers
25:57 - because everything is hosted on the
25:59 - server side
26:00 - so we can directly call the service
26:03 - layers repository layers without going
26:05 - through
26:06 - apis for example rest api right
26:10 - so
26:11 - all of the concerns related to calling
26:14 - rest apis
26:15 - are
26:17 - you don't have to consider it
26:19 - if you choose to not incorporating the
26:22 - rest apis right so for example
26:25 - you don't have to worry about security
26:27 - concerns you don't have to worry about
26:29 - the api
26:31 - mapping from the json results to objects
26:34 - and all of those things right so you
26:36 - have a much faster development speed so
26:39 - it's good for prototyping so um but what
26:42 - what are the columns of the the server
26:44 - side hosting model because everything is
26:47 - hosted on the server side
26:49 - let's say you're going to have a
26:50 - variable that stores
26:53 - thousands of hundreds of rows of data
26:56 - and that data has to be rendered
26:59 - to
27:00 - the render tree and you have two render
27:02 - trees and because you have you already
27:04 - in the variable you already have
27:08 - thousands of
27:09 - rows
27:11 - okay
27:12 - and then those rows has to be reflected
27:14 - within those two render trees one is for
27:17 - the previous previous version one is for
27:20 - the current version
27:23 - so you actually
27:25 - keep a large amount of data on the
27:28 - server side and that's just
27:30 - for for one user and if you have many
27:32 - users imagine you have used a large
27:35 - amount of memory for for just one user
27:37 - session and you have many users like
27:40 - this right
27:43 - you have like
27:45 - 1 000 users
27:48 - so
27:50 - you gotta do like a thousand times
27:53 - uh
27:54 - three because you have basically
27:57 - three copies of that data one is in the
27:59 - variable one is in the previous render
28:03 - tree and one is in the current render
28:05 - tree and then that amount
28:08 - of memory you use for each
28:11 - for that variable right and if you you
28:13 - have
28:14 - 10 000 records
28:16 - in that variable 10 000 rows and each
28:19 - row
28:20 - takes
28:21 - a lot of a lot of a large amount of data
28:25 - then
28:26 - this is going to be huge amount of data
28:28 - for for all of the users to use and all
28:31 - of that comes from just one server right
28:34 - your server side this one
28:36 - whereas if you use a client-side hosting
28:39 - model
28:40 - then
28:42 - all of this
28:43 - well you're not gonna first of all
28:45 - you're not gonna have this 1000
28:47 - right you're gonna have three copies
28:49 - you're gonna have a variable but but
28:52 - this is gonna be on the client side it's
28:56 - gonna be within the browser
28:58 - so as long as you have a very good
29:01 - client
29:03 - a slide is not a very thin client
29:05 - then it is going to work
29:07 - but whereas if you do this on the server
29:10 - side it's not going to work
29:12 - so
29:14 - so let's let's list out the pros and
29:17 - cons for each so for the
29:20 - for the client side we have uh
29:25 - what is the pros
29:27 - for the web assembly right so fully
29:32 - utilize
29:34 - the
29:36 - power
29:38 - of the
29:41 - client
29:44 - right
29:44 - and uh
29:46 - what are the cons
29:47 - so the cost is
29:51 - slow
29:53 - initial load
29:54 - because there are so many files to load
29:57 - like this this part so many files
30:01 - uh and then
30:03 - this is
30:04 - this is the web assembly right and the
30:07 - server side
30:08 - the pros
30:10 - fast
30:12 - first
30:14 - initial
30:15 - load and then we have
30:17 - fast
30:19 - development
30:21 - right and what are the cost
30:23 - the burden
30:24 - on the server
30:26 - and
30:27 - last one i forgot to cover is
30:29 - because of the signal
30:31 - r channel here what if the
30:33 - channel the signal
30:36 - signal r
30:37 - gets
30:39 - disconnected
30:41 - right
30:43 - so
30:44 - i think i personally think that if you
30:47 - want to create a small application
30:50 - then the server side is a very good
30:53 - choice
30:55 - and
30:56 - and
30:57 - you also
30:58 - need to be
30:59 - if you were to use the server side
31:01 - blazer to create a
31:03 - midsize or big size application you
31:05 - really need to pay attention to
31:08 - to how you load the data do not load
31:11 - large amount of data always
31:15 - always load the data that you want to
31:18 - display and then use paging or something
31:21 - like that to to get the next
31:24 - screen of data
31:26 - to
31:27 - to the browser
31:29 - do not load
31:30 - everything that will really slow down
31:33 - the process
31:34 - uh
31:35 - and uh for the problem problem with the
31:38 - signal arterial disconnection
31:41 - just always make sure that you save
31:44 - your data often
31:46 - and
31:47 - so when there is a disconnection
31:50 - and you have to do a screen refresh
31:53 - to to reconnect the signal or channel
31:55 - then
31:56 - then you only lose
31:58 - the limited amount of data
32:01 - all right so overall i do think that a
32:04 - better choice is to use the web assembly
32:07 - hosting model
32:08 - instead of the server-side hosting model
32:11 - but
32:12 - um
32:14 - but with very careful design
32:17 - you do
32:18 - you can use the server-side model
32:20 - for
32:21 - for a large project
32:29 - i want to talk about the project
32:31 - structure of both the web assembly
32:34 - blazer as well as the blazer server side
32:37 - so
32:38 - first i want to create a project
32:40 - and it's going to be
32:43 - blazer
32:49 - and
32:50 - i'll call this blob blazer
32:53 - web
32:54 - assembly
33:02 - and i'll choose the
33:04 - web assembly template
33:07 - all right that's pretty simple
33:11 - and uh let's run this right away before
33:14 - so before we go into the uh
33:17 - project structure i wanted to
33:20 - show you guys something else
33:22 - for both the wipe assembly blazer as
33:24 - well as the server side blazer so
33:27 - if i run it
33:28 - let's see it's loading and then we can
33:31 - see the the pages
33:33 - the user interface
33:36 - so what i wanted to show you guys is if
33:38 - i use the developer tool
33:41 - and i go to network tab
33:44 - i have to do a refresh
33:47 - you can see all these things are being
33:49 - downloaded
33:52 - you see the loading
33:53 - it takes a long time
33:55 - and then all these are downloaded so
33:57 - let's take a look at what are actually
33:59 - downloaded
34:01 - so at the beginning
34:03 - we have this blader webassembly.js file
34:07 - that is downloaded
34:09 - and then this file initializes the
34:12 - download of the other things
34:16 - this is the mono web assembly which is
34:20 - the
34:21 - the only web assembly this is the uh the
34:24 - context so all of the other ones run
34:26 - within this context
34:28 - as i've covered in the second video
34:33 - so we can see that we have the blazer
34:36 - framework and we have
34:39 - the
34:40 - net
34:41 - assemblies
34:43 - all the dependencies we have uh also our
34:47 - uh
34:48 - application as well
34:50 - so this because i call it blazer
34:53 - webassembly this is the project
34:56 - this is the project so this is our
34:58 - application dll and
35:01 - our debug information is also
35:04 - downloaded here
35:09 - so that's what i wanted to show you on
35:11 - the
35:12 - client-side
35:14 - map assembly blazer
35:17 - so if i stop this for now
35:19 - okay let's open another video studio
35:22 - instance and create another
35:24 - project which is the blazer server side
35:31 - it's the same process
35:34 - but this time i call it laser server
35:37 - side
35:39 - okay
35:45 - and
35:46 - i choose the server
35:48 - side app
35:50 - all right so
35:52 - again before i go into the structure
35:56 - i want to run the app
36:00 - all right
36:01 - same drill
36:04 - we're going to
36:06 - look at the
36:07 - developer tool
36:09 - uh we'll clear it
36:12 - refresh
36:14 - and this time let's take a look at
36:16 - what's our downloaded
36:18 - so
36:20 - we only have this js file that is
36:22 - downloaded
36:23 - and then we have this
36:28 - and then we have this uh
36:30 - the websocket which is the signalguard
36:32 - signalr channel
36:34 - so we can see that
36:36 - we clear this
36:38 - so each time
36:40 - if i do anything
36:42 - clear again click on this
36:45 - see
36:46 - each time i do anything with the
36:48 - components the channel there is it's
36:51 - being used to pass message back and
36:53 - forth because all of our components and
36:56 - the state of the components
36:58 - are actually being
37:00 - capped on the server side and we're
37:03 - using the signalr channel to send back
37:06 - and forth the message and
37:09 - yeah that's
37:10 - that's also this the thing that i want
37:12 - to cover before we go into
37:15 - the structure
37:16 - so on the left hand side is our
37:19 - web assembly the server client side
37:22 - blazer
37:23 - on the right hand side is our
37:27 - server-side blazer
37:31 - so we can see that they look pretty very
37:34 - very similar and uh
37:36 - and it's all based on asp.net core so
37:39 - the entry point is always the program
37:42 - files and they're pretty similar too
37:46 - i also covered the asp.net lifecycle
37:50 - that
37:51 - includes the
37:52 - configuration as well as the
37:55 - middleware pipeline in one of my other
37:58 - videos
37:59 - so this program actually this program
38:02 - file
38:03 - has a main method this is the entry
38:05 - point of the whole application same as
38:08 - the server side and
38:10 - this basically builds the hosting
38:12 - environment of the web application
38:15 - and
38:16 - the startup files are the actual uh
38:19 - configuration file that we can use to
38:22 - configure the uh the application
38:24 - so let's actually um focus on our client
38:27 - side for now so we have our program
38:30 - files which calls our startup files to
38:34 - configure our applications
38:36 - by default there's nothing in the
38:38 - configure services which handles the
38:41 - dependency injection
38:42 - and
38:44 - there's only this adding one components
38:46 - which is the root components of our
38:48 - application
38:50 - if we look at the
38:53 - this folder it has the www root folder
38:56 - we have index.html file
38:58 - which
38:59 - has
39:01 - the basic html structure
39:03 - and the most important thing the two
39:06 - important thing here one is this app
39:09 - loading
39:10 - thing then this is the the root
39:12 - component
39:13 - and also
39:15 - this
39:16 - blazer web assembly that i have showed
39:19 - you
39:20 - that this this one downloads the all of
39:23 - the dlls and initialize the
39:26 - runtime to start running our application
39:29 - so then when this page gets loaded
39:32 - uh
39:33 - the
39:34 - app component which is root component is
39:37 - being used and the root component
39:40 - set up the router for the client-side
39:43 - routing
39:44 - all right and then
39:47 - it uses the layout file
39:50 - which is under
39:52 - the shared folder the layout file
39:55 - and it provides
39:56 - a layout for our application
40:01 - and the most important part here in the
40:03 - layout file is this body placeholder
40:07 - which is a placeholder of all of the
40:09 - relatable components so the rob rotable
40:12 - components are the component that has
40:14 - the
40:16 - for example here
40:18 - has the page
40:19 - add page directive
40:22 - which tells the blazer framework
40:26 - or toster
40:27 - tells the water
40:29 - that this
40:31 - component is a rotable component and in
40:33 - order to get to the component we can use
40:36 - this rod
40:38 - right we can use this path and when we
40:41 - use this path what's happening is that
40:45 - this
40:46 - component will
40:49 - will be displayed at the place where the
40:51 - add body placeholder is which is inside
40:55 - the main layout
40:56 - so in this add body layout
40:59 - sorry this is main layout
41:02 - we have this add body placeholder
41:06 - and if we go to slash
41:09 - counter
41:10 - this placeholder will be
41:12 - replaced with
41:16 - with
41:18 - with the information here this is the
41:20 - client side
41:22 - structure and if we focus on the
41:25 - server side
41:26 - structure for now it's very very similar
41:30 - the only thing
41:31 - that is different is
41:33 - in this startup file it has
41:36 - more information here
41:40 - it
41:41 - configures the
41:44 - default route here which is
41:47 - our host file this is the entry
41:50 - well that's the entry point is still the
41:52 - program dot cs file but on the front end
41:55 - this page is gets loaded first which has
41:58 - all of the html structure just like the
42:01 - index.html
42:03 - in the client side
42:05 - and we also have this blader server.js
42:10 - js file
42:12 - which
42:13 - kind of
42:14 - handles the
42:15 - signalr communication channel
42:18 - and some other tasks as well and we also
42:20 - have this app component placeholder here
42:23 - that
42:25 - loads our root component
42:27 - right and the root component basically
42:29 - from this point on everything is
42:33 - almost the same
42:36 - if it's not exactly the same
42:38 - so we goes to the main layer
42:41 - we load the main layout
42:45 - so
42:47 - so the app component here also
42:49 - configures the router
42:51 - and then it loads the main layout and
42:53 - the main layout also
42:57 - within the shared folder we have the
42:59 - main layout here and
43:01 - it also has the body
43:03 - placeholder it's the same mechanism that
43:06 - allows
43:07 - the
43:08 - routable component within it
43:10 - so the opposite of wrong component is
43:14 - is unboundable which means that a
43:17 - component that does not have that page
43:20 - does not have this add page directive
43:24 - so those components are basically kind
43:26 - of like controls that can be
43:28 - used in
43:30 - um
43:31 - in components in other components
43:33 - so i also wanted to
43:36 - draw this
43:37 - project structure on whiteboard i think
43:40 - it
43:41 - is going to be more help
43:43 - so we have this
43:45 - program entry point
43:52 - program.cs file entry point
43:55 - um
43:56 - and above that we have the startup
44:00 - startup class
44:04 - um
44:05 - that
44:06 - does the um
44:08 - dependency injection
44:10 - and
44:11 - also
44:13 - middleware pipeline setup
44:18 - and about that
44:20 - we have our
44:23 - either is the host file or the index
44:28 - the html
44:30 - the host file
44:32 - is for
44:34 - the server side blazer and index.html is
44:39 - for the client side
44:42 - and
44:43 - above that we have our root component
44:47 - which
44:49 - set up the
44:51 - the rotting the client side running
44:55 - and
44:59 - last but not least
45:01 - is our
45:04 - our main layout
45:08 - component
45:09 - and within the main layout the most
45:12 - important part is the
45:14 - uh
45:16 - the body
45:17 - placeholder
45:19 - which uh which is the placeholder for
45:22 - all of the other wallable components
45:25 - so
45:26 - we have
45:27 - c1 c2
45:30 - etc
45:32 - cn
45:34 - and all of these are actually
45:36 - will be eventually loaded into the
45:40 - um
45:41 - the body
45:43 - placeholder one by one and
45:45 - will be displayed to the to the user
45:48 - and of course we also have our
45:52 - unboundable components
45:56 - which will be used within
45:59 - the
46:01 - the rotable components
46:03 - and they also can be used
46:06 - within each other
46:09 - so that's the product structure of the
46:12 - um
46:14 - the both the server-side
46:17 - uh
46:18 - blazer as well as the web assembly
46:21 - blazer
46:22 - and
46:24 - since we have seen that the product
46:27 - structure is very very similar so
46:30 - you can actually switch between
46:34 - the
46:35 - web assembly blazer and server side
46:37 - blazer so if you
46:40 - want to start with the server side
46:42 - blazer because
46:43 - it's production ready and the web
46:45 - assembly blazer is not production ready
46:48 - as of today um
46:49 - april 8 2020
46:52 - then you can start with the server sub
46:54 - laser and until
46:56 - these the clients have laser come out
46:58 - and then you can easily
47:00 - switch to client step laser if that's
47:03 - what you want to do
47:04 - if that makes sense for for the
47:06 - application and for the business if you
47:08 - want to switch i think the only thing
47:10 - that you
47:12 - um other than changing a few lines of
47:14 - code and configure the program's startup
47:17 - classes a little bit differently
47:19 - the only thing that you need to pay
47:21 - attention is to keep your components
47:23 - very very thin and encapsulate the other
47:26 - logic
47:27 - in
47:29 - in a different layer maybe in the
47:31 - service layer
47:33 - so
47:34 - also i forgot to cover the import
47:39 - dot razer file on this file
47:42 - it has all of the name spaces so it uses
47:46 - using
47:50 - directive to import the namespaces
47:54 - so it has a
47:56 - a lot of these so you don't have to use
47:58 - the using inside each component you can
48:01 - just put it under the inside the imports
48:06 - imports.razer and this will import
48:10 - all of the namespaces for you and then
48:13 - you can use
48:16 - use the classes inside the
48:20 - namespace within the components that you
48:23 - want to use you don't have to use the
48:25 - using in each component
48:28 - so so it keeps the code very clean
48:36 - data binding for blazer
48:38 - so for any software that that has a ui
48:43 - the software needs to do
48:45 - two things
48:47 - the first thing is to display
48:49 - information the second thing
48:52 - is
48:53 - to
48:53 - manipulate
48:55 - the information
48:57 - and we look at the data flow
49:00 - okay for the first one
49:02 - for this display information
49:05 - we have a ui and we have data i'm just
49:09 - using a database
49:10 - symbol to represent data
49:13 - so
49:14 - it flows from the database
49:17 - to
49:18 - the
49:19 - ui
49:21 - okay so this is ui
49:24 - this is ui and this is data and the
49:26 - second one is data manipulation
49:30 - right so we have
49:31 - ui and we have data and data flows into
49:35 - the ui when you
49:37 - do your data manipulation
49:38 - on the ui you always want to save the
49:41 - data back to the data source
49:43 - so from this
49:45 - we know that there are two kinds of ways
49:47 - for data flow one is this one weight
49:50 - and this is
49:52 - second is the two way
49:54 - for data binding this are these are the
49:57 - two ways of data binding
49:59 - we have one-way data binding and two-way
50:02 - data bindings but why do we even need
50:04 - data binding
50:05 - why can we just
50:07 - program without it
50:08 - yes we can
50:10 - we always
50:11 - need
50:12 - a ui we always have a ui regardless
50:15 - whether we have data binding or not we
50:18 - always have a ui and we also
50:21 - have
50:22 - a
50:23 - variable that represents the data
50:28 - right
50:29 - we have a variable
50:31 - and
50:32 - we need a variable to be displayed on
50:35 - the ui
50:37 - right so we load the data from the data
50:39 - source to the variable and we need to
50:41 - need to display the variable on the ui
50:45 - right without data binding
50:48 - we can manually
50:50 - find the element on the ui
50:53 - and
50:54 - set the variable
50:56 - value of the variable
50:58 - into the element
50:59 - so we can manually
51:01 - populate the data onto the element and
51:04 - once we modify we manipulate the data
51:06 - within the element on the screen we can
51:09 - save the data
51:11 - directly back to the data source without
51:14 - even going through the variable
51:16 - right and if we want to load the data we
51:18 - can load the data to the
51:21 - to the variable
51:22 - and then
51:23 - again
51:25 - display directly onto the element
51:28 - so this is one way we can do it but that
51:31 - um
51:32 - you know this is a process we wanted to
51:35 - to avoid
51:36 - so that's why we have this thing that is
51:39 - called data binding right
51:41 - where we actually binds
51:44 - we actually find the
51:46 - the ui
51:47 - element
51:49 - or element
51:52 - to
51:54 - the data
51:56 - so variable actually the variables
52:01 - as if they are one right and there's two
52:05 - two kind of
52:06 - uh two type of data binding with one is
52:09 - one-way data binding will only bind the
52:13 - data
52:14 - to the ui element the other is two-way
52:16 - data binding obviously
52:20 - we not only bind the variable to the
52:22 - element but we also bind the ui elements
52:24 - to the variables
52:26 - so that way
52:28 - whenever we look at the variables they
52:30 - always
52:31 - represents
52:33 - the ui elements on the screen
52:37 - all right so having said all of that
52:39 - let's
52:40 - jump into the computer and look at the
52:43 - uh the codes so i created a server side
52:48 - blazer project
52:49 - and uh
52:52 - this is the index page
52:54 - i in this region under this region i
52:56 - have a view model
52:58 - that is a for a sales person this is the
53:00 - amount
53:02 - um well maybe it's a target amount or
53:04 - something like that and then whether the
53:06 - salesperson is active
53:08 - and under which locations the sales
53:11 - person is uh is active
53:14 - and first of all let's uh
53:20 - initialize the data
53:22 - first of all let's initial data we need
53:24 - to overwrite
53:26 - our initialized method and in here we
53:29 - are going to create a new person
53:33 - new um
53:37 - well
53:40 - yeah yeah that's right
53:43 - indexed view model
53:45 - and then i will have the sales person
53:49 - give it a name
53:54 - and
53:55 - amount
53:57 - locations some default locations
54:00 - all right so i have the data initialized
54:03 - and uh for uh
54:06 - for one-way data binding we can do
54:10 - very simple thing
54:12 - to display the
54:15 - the salesperson's name
54:17 - right so it's as simple as you know
54:20 - doing
54:22 - this
54:23 - it's a add sign and then
54:26 - you just
54:28 - put the variable here
54:29 - so that's why we did a binding
54:32 - right and let's display a few things
54:39 - um
54:40 - name an amount maybe
54:42 - and you can of
54:44 - format the data like this
54:47 - so this is one-way data binding
54:50 - and if you run this code run this code
54:52 - we can see
54:53 - the name alex
54:56 - let's have a line break here
54:59 - then we save it so um so if we use ctrl
55:03 - f5
55:05 - to run the project instead of just uh
55:07 - just a 5
55:09 - then you will have
55:11 - this page
55:13 - once you make any changes
55:15 - uh the page will detect the change from
55:17 - the signal
55:19 - signalr channel
55:21 - and then you just do a refresh you will
55:23 - see your changes reflects
55:26 - reflected
55:28 - so i added a
55:32 - a line break which
55:35 - for whatever reason wasn't displayed so
55:37 - i uh i'm trying to add another one yeah
55:39 - now we can see the line brick here
55:42 - and uh we have this formatting here
55:44 - these two are the one-way data binding
55:46 - just to bind the
55:50 - variable
55:51 - the variables to the front end
55:53 - so to implement the two-way data binding
55:57 - we need to
55:59 - use the bind attribute
56:03 - so for example
56:06 - of course if we want to manipulate data
56:10 - right
56:11 - we want to
56:13 - let's say i want to manipulate the
56:15 - amount
56:19 - then we need to
56:21 - bind we need to bind not only from the
56:24 - variable to the
56:26 - to the element to the input element but
56:29 - also
56:31 - we need to bind the element
56:33 - to
56:34 - the variable and for that we can use the
56:36 - bind command
56:38 - the band
56:39 - the bind attribute so
56:42 - we have bind value and what do we want
56:44 - to bind which value do we don't bind we
56:46 - want to bind the amount
56:48 - right we want to do this
56:50 - and then
56:53 - and then here
56:57 - if we do this
57:00 - and we save
57:01 - come over here and refresh the page
57:04 - we'll see
57:05 - the amount here
57:07 - 15 000
57:09 - okay so we have this 15 000 here and if
57:12 - we make a change
57:14 - okay and we tab out from the text box
57:17 - notice
57:18 - this amount
57:20 - is also is also changed accordingly
57:23 - so if we change this number to 100
57:27 - and tab out from the text box this
57:30 - number is also changed this means what
57:32 - this means that
57:34 - uh
57:35 - when we're changing this and type out
57:37 - our change event
57:38 - the uh value is
57:42 - passed to the variable and then the
57:44 - variable because the variable is is also
57:47 - bound to this uh this place so this this
57:51 - value is displayed here so this is
57:53 - one-way one-way data binding this is a
57:55 - two-way in the case that we want to
57:59 - so in the case if when i want to uh
58:02 - change the underlining variable while
58:04 - i'm typing directly in
58:06 - the input box
58:10 - in that case i need to add another
58:17 - another
58:18 - vector build which is the bind value
58:21 - event so
58:23 - that that's trying to tell the blazer
58:24 - framework
58:26 - of what event or what happens
58:29 - the value is
58:31 - passed back to the variable and here we
58:34 - want to say on input so while we are
58:37 - inputting into the text box
58:40 - the variables gets updated
58:43 - that's what we're trying to say to the
58:45 - laser framework
58:47 - so once we refresh
58:51 - we can see
58:52 - while we're typing
58:54 - the amount is passed to the underlying
58:56 - variables
58:57 - so here i want to say a little bit more
59:00 - so if you wanted to use bind
59:02 - in this case you have to use bind event
59:06 - all right so if you wanted to use bind
59:08 - value then in this case you have to use
59:10 - bind value otherwise they're going to be
59:12 - exception
59:14 - so um
59:16 - the next i wanted to demonstrate
59:18 - checkbox checkbox
59:21 - is a type equals checkbox
59:25 - and here we want to bind value
59:32 - don't have space
59:34 - so here
59:35 - bind value to percent is active i also
59:39 - wanted to display
59:41 - the person active
59:43 - directly here
59:45 - just so that we can see the changes
59:48 - okay so we have this checkbox but we
59:49 - don't know what it is
59:51 - so we're gonna have a label
59:56 - and
60:01 - and here we say
60:05 - is active
60:09 - give us space here
60:14 - refresh
60:16 - all right
60:17 - so we can see that it's active is false
60:20 - and but when i check it you know it's
60:22 - directly changed to true immediately
60:25 - uncheck false so you can see the two-way
60:28 - data binding for checkbox
60:30 - next one we want to i want to go to
60:34 - i want to go to radio buttons
60:37 - for for radio buttons
60:40 - it will be a little bit different
60:41 - there's no
60:43 - direct
60:44 - uh
60:46 - there's no direct
60:48 - two-way binding for radio buttons we
60:50 - have to kind of
60:51 - you know
60:53 - create our own
60:54 - so the name variable is
60:57 - is
60:58 - is the group
61:01 - indicates the group
61:04 - so in here um
61:09 - we would have
61:11 - you know so we have
61:13 - radio button one
61:17 - and uh
61:18 - radio button two
61:23 - okay so we have this
61:24 - i can see it works like
61:27 - uh exclusive
61:28 - selection it's within one group but we
61:32 - need to add a binding to it
61:34 - for that i wanted to um
61:37 - perhaps just add another
61:39 - variable here
61:43 - i call it selected
61:46 - selected group
61:49 - all right
61:50 - and at the beginning
61:53 - nothing is selected so i changed to zero
61:57 - so we'll put zero here
61:59 - and uh because we don't want to select
62:02 - any
62:04 - checkbox uh when the screen is loaded
62:09 - so we need to bind that value
62:12 - to the
62:14 - radio buttons and to do that we need to
62:16 - use the check
62:18 - checked attribute here
62:21 - we can use the expression here and say
62:24 - that
62:26 - if the selected group
62:28 - equals 1
62:31 - then
62:32 - we check this
62:33 - and here if
62:35 - the
62:36 - selected group
62:38 - equals two then we select this one
62:41 - all right so
62:43 - so in this case
62:46 - we're not selecting anyone so
62:49 - after a refresher screen i expect to see
62:51 - that the radio buttons are not selected
62:54 - right now selected by default but if i
62:56 - change this to number one and i save and
63:00 - refresh the screen
63:02 - refresh the page i see that
63:05 - i'm expecting number one to be selected
63:07 - which is exactly what happened
63:09 - so
63:10 - next
63:11 - we want to make changes to this radio
63:14 - buttons
63:15 - and we want this change to be
63:18 - reflected in the variable selected group
63:22 - how do we do that
63:23 - so we can use the on
63:26 - click event
63:27 - so in here we can say on click
63:31 - okay
63:32 - and again
63:34 - with
63:35 - assigned and parenthesis
63:37 - here we can add a arrow function
63:43 - we can say that when this event happens
63:46 - we call this selected group function
63:49 - same thing here
63:51 - equals two
63:54 - when i click on number one
63:57 - i want the selected group to change to
64:00 - number one
64:01 - and when i click on number two
64:04 - i want the circuit group to change to
64:05 - number two
64:07 - right and here
64:10 - maybe here i'll display
64:13 - the selected group
64:18 - refresh the screen at the beginning i'm
64:20 - expecting number one being written there
64:26 - yeah and change to number two
64:28 - immediately
64:30 - we see the change
64:32 - perfect
64:33 - so we cover checkbox radio buttons and
64:36 - what else do we need to cover perhaps a
64:38 - drop down list right so the drop down
64:41 - list is simpler
64:42 - simpler than radio buttons radio buttons
64:44 - probably the
64:47 - most difficult one
64:49 - here let's bind
64:51 - to a selected location right so which i
64:54 - don't have a
64:56 - variable here so here we're going to
64:58 - create a selected location variable and
65:00 - we can see that our location has an id
65:04 - and we're going to bind that to id
65:07 - so i'll create a selected
65:10 - location id equals um 0
65:16 - indicating that we're not binding to
65:18 - anything at the beginning
65:19 - so i have this here and then um
65:24 - that's the select and for options
65:27 - we want to have a for each loop
65:32 - where we you know location
65:34 - in person
65:36 - let's give it better name so i call
65:39 - location
65:41 - under the person locations
65:45 - variable
65:46 - we have
65:49 - we want to create an option element
65:53 - the value is log dot id
65:58 - all right
65:59 - and
66:00 - the
66:01 - here we want to display let's display
66:03 - the city
66:06 - the thought is messy so after that we'll
66:08 - have a list of cities but about the
66:09 - beginning we wanted to be
66:14 - you know
66:16 - empty
66:17 - yeah empty
66:19 - after that it's fine
66:21 - so
66:22 - and we wanted to show
66:25 - i wanted to show
66:27 - the selected location
66:30 - id here okay
66:33 - so let's refresh the screen
66:35 - all right so the beginning select
66:37 - location is zero which is an empty
66:40 - item
66:42 - and i have toronto montreal
66:45 - all right so i'm going to select you can
66:47 - see the id changes which is pretty cool
66:50 - that's basically it for drop down list
66:52 - we're binding to the selected location
66:54 - id
66:55 - and uh the list of locations is kind of
66:58 - a one-way binding to
67:01 - the
67:02 - drop-down list and then another way
67:05 - binding back is to a different variable
67:08 - select the location id
67:13 - and next perhaps we want to do a list
67:15 - right i want to show a list
67:18 - so we would have an ordered list
67:22 - and
67:24 - we're doing basically it's very similar
67:26 - to the down list
67:28 - we want to display the location in
67:31 - persons
67:33 - locations
67:35 - we want to have a
67:38 - list and we want to show
67:40 - the city
67:44 - all right and we want to show
67:48 - the province state and we want to show
67:51 - the country
67:55 - all right so we have that
67:58 - now come over here and refresh
68:06 - yep we have a list
68:09 - so what about a table
68:12 - table will be pretty similar
68:16 - but i'll demonstrate more than that
68:18 - so i have a table and
68:21 - we want to be
68:23 - using the
68:26 - bootstrap
68:27 - and for here we have a list of rows
68:30 - and that we have for each
68:33 - again we use this in
68:37 - dot locations
68:40 - a person.locations
68:44 - and we have
68:48 - we have as many rows as locations
68:51 - and i want to show
68:53 - everything
68:56 - for the table
68:57 - well and if i
68:59 - save it and refresh
69:01 - i've i've lost
69:03 - a table
69:05 - and that's a list of countries in the
69:07 - table
69:08 - but what if we wanted to create a table
69:10 - that
69:11 - it actually updates the underlining data
69:14 - for that what do we do
69:16 - so of course we can change this to an
69:18 - input
69:21 - let's use this a city for example
69:24 - we change to input
69:26 - and then the type is text
69:29 - right
69:30 - and
69:32 - um
69:35 - if we do
69:37 - bind
69:38 - to
69:40 - bind value
69:41 - if we say
69:43 - bind to what
69:45 - i bind to
69:47 - uh
69:48 - location.city
69:52 - let's see what happens if we do this
69:55 - refresh
70:04 - as you can see
70:11 - it's working
70:15 - right and
70:17 - if we want we can change the bind event
70:21 - to
70:22 - oh
70:24 - input
70:33 - and
70:36 - yep
70:37 - so we have it
70:39 - only in here as well pretty cool
70:42 - right so if we change copy all of this
70:46 - to actually uh let's give it a class
70:50 - to be a
70:52 - form control
71:00 - that looks pretty good
71:04 - and let's
71:06 - copy this
71:08 - to replace
71:10 - post this
71:13 - and the country
71:15 - and then
71:16 - we just need to change this to
71:18 - profs state
71:20 - changes to country
71:26 - and
71:28 - all right there we have it
71:31 - so we can change this to some other city
71:33 - right
71:34 - new york
71:38 - and
71:39 - new york
71:41 - usa
71:43 - so you can see that
71:45 - it's updated here also in the drop a
71:47 - drop down list
71:49 - so
71:50 - and if we have a submit button
71:52 - right
71:53 - then once we submit
71:55 - we can handle the submit event
71:59 - and
72:00 - we can look at the locations and we have
72:02 - all of the changes in that variable so
72:04 - this is the beauty of data binding
72:08 - we don't need to manually go into each
72:10 - one of them
72:12 - to grab the data
72:14 - we have the data already
72:17 - when we're handling
72:19 - the click event of a submit button
72:27 - in blazer random programming is
72:30 - component based
72:31 - which is in line with
72:33 - other frontend framework or libraries
72:36 - like angular react
72:38 - vue.js
72:40 - a web page consists many components like
72:43 - header
72:45 - sidebar page component
72:47 - or maybe some reusable components inside
72:50 - the page component
72:54 - and footer as well
72:56 - traditionally websites consist of pages
73:00 - and reusable areas within pages are
73:03 - called controls
73:05 - a name that
73:06 - comes from the desktop application
73:08 - programming realm
73:10 - later simplifies things
73:12 - and use components represents both
73:15 - pages
73:16 - and controls
73:19 - to distinguish the two
73:21 - let's call them page components and then
73:24 - page components
73:27 - so if you create a
73:30 - blazer application
73:33 - the default application that comes from
73:35 - the visual studio templates it looks
73:38 - like this i added a sales component here
73:41 - but if we go through this
73:44 - we have
73:45 - four pages here
73:48 - the home counter fast data and sales the
73:51 - sales one is the one that i added
73:54 - so
73:56 - um
73:57 - we'll go to home page
73:59 - right we can see this highlighted area
74:02 - is a page component
74:04 - counter
74:05 - this
74:06 - highlighted area is also a page
74:08 - component
74:10 - same as this
74:12 - and the sales component that i added
74:16 - so which part is a reusable num page
74:19 - component it is
74:21 - the area that highlighted in blue so
74:23 - let's jump into the computer visual
74:25 - studio
74:26 - and
74:27 - take a look at
74:29 - some
74:30 - demo about page component
74:33 - as well as
74:35 - numpage component
74:53 - so
74:54 - let's add a page component first we can
74:57 - see that a page can
74:59 - there is a page folder already so these
75:01 - components are page components except
75:03 - this
75:04 - uh
75:06 - this entry point file right so to add a
75:10 - page component we'll go to page right
75:11 - click on page footer
75:13 - and we click on
75:15 - click on new adam
75:20 - select reader component
75:22 - and then
75:24 - give it a name
75:26 - remember to make sure that
75:28 - the first letter is capitalized
75:30 - let's call it
75:33 - sales component
75:35 - i always want to append component
75:38 - this word
75:39 - at the end of the the name
75:42 - just to to make sure
75:44 - when you later create classes for
75:46 - example if you want to create sales
75:48 - it does not cause a namespace conflict
75:53 - so
75:54 - so we have sales
75:56 - component
76:00 - all right so we have sales component
76:01 - here because the sales component is a
76:03 - page component so we have to be able to
76:06 - navigate to the sales component
76:08 - so in order to
76:11 - be able to never get to the sales
76:13 - component we use the page directive
76:16 - and actually before we do this we can
76:18 - take a look at the other ones right so
76:21 - fetch data we have the the page
76:23 - directive
76:24 - and slash fascida which means that when
76:28 - we um
76:30 - have the url that that says
76:32 - domain name slash fetch data it will go
76:35 - to this uh fetch data component same as
76:38 - the counter component
76:40 - when you say slash counter it will go to
76:43 - the counter component so when you want
76:45 - to go to our sales component i want to
76:49 - i want the
76:50 - url to be slash sales
76:53 - okay so in this component i will do
76:55 - nothing
76:56 - and then uh let's navig let's make
77:00 - ourselves navigate to the sales
77:02 - component through the manual
77:13 - and let's call this this is the the url
77:17 - this is the routing path
77:19 - right so we have the fetch data sales
77:22 - counter
77:24 - so this basically means when we click on
77:27 - this navigation link it goes to
77:30 - the counter component
77:32 - here when you click on this link go to
77:34 - the fast data component and we can click
77:36 - on sales it goes to the
77:39 - the sales component
77:44 - so if you
77:45 - watched my video about the product
77:47 - structure i've covered uh the project
77:51 - structure there
77:52 - uh if this is a little bit confusing
77:54 - about
77:55 - the navigation link and how
77:57 - all of the files work together you can
77:59 - go back to
78:00 - one of the previous episodes about
78:02 - project structure where i covered that
78:05 - part
78:06 - so here
78:08 - i have added the
78:10 - navigation link here
78:12 - uh and i've added the component
78:18 - it's the sales component and make sure
78:20 - that the
78:21 - uh the routing path is sales
78:25 - right so
78:27 - then
78:30 - in the
78:32 - the body part
78:36 - when we
78:37 - when we input in the url slash
78:40 - sales
78:42 - the body placeholder will display our
78:45 - sales component
78:47 - okay let's give it a try right it's
78:50 - right here so we click on sales
78:53 - sales component
78:55 - right
78:57 - and if we are not sure whether that's
78:58 - our component
79:00 - we can add some
79:02 - thing here
79:04 - okay so this is
79:11 - save
79:14 - else here refresh
79:16 - so we get this this is the sales
79:18 - component
79:19 - so this is our component a page
79:21 - component
79:22 - is also
79:23 - called a writable component
79:26 - which is highlighting the fact that
79:29 - we're able to rot
79:30 - to the component by using the
79:33 - the rotting path
79:34 - here i also want to cover
79:37 - rotting for a page component a page
79:39 - component must be audible meaning that
79:42 - you have to be able to access the page
79:44 - component
79:45 - by following a url right so we already
79:48 - talked about this a little bit
79:51 - uh
79:52 - but i also wanted to point out that you
79:55 - can have multiple one page component you
79:58 - can have multiple
80:00 - uh
80:02 - rot
80:04 - right so if i added this and go to our
80:07 - page and refresh
80:10 - by the way what i did is i did ctrl f5
80:14 - right so that way after you add it you
80:16 - can do you can refresh your page and
80:18 - then
80:19 - all of the changes will be picked up
80:22 - so we have salesperson and add another
80:24 - route
80:26 - which is
80:26 - salesperson
80:28 - right so we can use both sales and
80:32 - and sales person
80:34 - to go to the same page component
80:36 - however
80:38 - uh it's only a one-to-many relationship
80:41 - from
80:43 - page to routes
80:45 - it's not the other way around
80:47 - meaning that if you want to use the same
80:51 - um
80:53 - the same rod
80:54 - in a different page
80:56 - it's going to give you an error for
80:58 - example
80:59 - if i copy the sales person
81:03 - rod and put it under counter
81:05 - inside counter
81:07 - and
81:09 - if i refresh here see it's going to tell
81:12 - me that
81:14 - the following rods
81:17 - are duplicate we have two pages that
81:20 - have the same
81:21 - bots
81:22 - and those two page components are sales
81:24 - component and counter component
81:27 - so the error message is actually very
81:29 - informative
81:31 - and the moment you remove this is going
81:33 - to work again fresh all right so that's
81:36 - working again
81:38 - so i want to just cover a little bit
81:40 - about how the page how the routing works
81:44 - when we put when we use the page
81:46 - directive
81:47 - for each page component
81:50 - and provide a path to the page component
81:53 - we are basically applying a rod
81:56 - attribute
81:58 - to
81:59 - the page class
82:01 - so if you have used
82:04 - if you have created web api
82:07 - or
82:08 - mvc
82:09 - in asp.net or asp.net core
82:12 - you know that
82:15 - you can use
82:16 - a
82:17 - rod attribute
82:20 - for a class you can you can decorate a
82:22 - class
82:23 - with a
82:25 - rod attribute when these components are
82:27 - compiled
82:29 - they are turned into
82:32 - c-sharp classes
82:34 - and they would basically look something
82:36 - like this
82:38 - right so you would have your whole
82:39 - component
82:42 - the raw facet is
82:44 - root
82:45 - root fast right and you counter
82:47 - with this rod you fast shade it with
82:50 - this rod and the sales component we just
82:52 - created was this rod
82:54 - so
82:56 - when the
82:57 - laser framework
83:00 - is
83:00 - loaded
83:01 - it actually loads all of your component
83:05 - sort of another list
83:06 - right it doesn't create a component yet
83:09 - but it lowers the metadata of these
83:11 - components into a list
83:14 - it knows that you have these components
83:17 - it knows that which component has which
83:20 - rod
83:23 - and then when you are
83:25 - using
83:27 - different urls
83:29 - by inputting them into the broader
83:32 - address bar or you're navigating
83:35 - inside
83:36 - by using the nav link
83:38 - it's going to go through that list
83:40 - and look for a component that has that
83:42 - rot
83:43 - and then it will initialize that
83:45 - component
83:47 - and if it cannot find it
83:49 - see the app component actually says
83:52 - uh
83:53 - router and if it's not found it's going
83:56 - to say sorry there's nothing
83:58 - at this address
84:00 - and if it sees that there are two
84:02 - components
84:03 - that are the same
84:05 - rod it's gonna spit out an error so for
84:08 - a none page component a numpage
84:11 - component the purpose of having a
84:12 - numpage component
84:14 - is to encapsulate some
84:18 - functionalities whether the component is
84:21 - reusable or not
84:23 - right we don't want to write component
84:26 - with thousands of lines of code
84:29 - we want to be able to encapsulate
84:33 - certain functionality within different
84:36 - components
84:37 - so that it's easier to manage
84:39 - and if they are reusable then it's even
84:43 - better so in this case let's create a
84:46 - component
84:47 - that tells us time so to do that i like
84:51 - to call the reusable component controls
84:54 - right
84:56 - but i i just put them into a controls
85:00 - folder
85:03 - although i still call them component
85:39 - and then we're gonna display it
85:43 - right here
85:46 - and we're gonna
85:49 - display
85:58 - in this format
86:04 - okay so
86:06 - we have this and we know the namespace
86:09 - is
86:10 - the
86:12 - the root namespace
86:15 - plus control plus the folders so we want
86:18 - to
86:19 - add that namespace here so we're going
86:22 - to say
86:24 - laser
86:26 - demo
86:27 - dot controls
86:30 - and to use that
86:32 - let's say we want to use that
86:35 - in our
86:36 - newly created sales component
86:40 - to reference to
86:42 - to use the page numpage component
86:45 - we can just declare them as
86:48 - by using html element syntax
86:50 - so we're pretending
86:53 - the
86:56 - the component that we have
87:00 - is a
87:02 - html element
87:05 - and so here
87:08 - and that's all we need to do
87:10 - so
87:11 - i would add a
87:15 - two of them
87:18 - then we go to our
87:20 - share do a refresh all right so we have
87:23 - our
87:24 - daytime here today is may 3rd
87:27 - sunday
87:29 - toronto ontario canada all right so we
87:32 - covered page component we covered none
87:34 - page component
87:36 - uh
87:37 - as you have noticed
87:39 - that our numpage component does not
87:41 - require
87:43 - a page directive
87:45 - right
87:46 - another thing i want to also mention is
87:48 - that
87:49 - you can also use a page component
87:52 - as
87:53 - uh
87:55 - as a reusable numpage component for
87:57 - example i want to show the counter
88:00 - right inside the sales component so what
88:03 - do i do
88:06 - i just declare it here it's very easy
88:09 - i just say
88:13 - counter
88:14 - right that's it
88:17 - and let's go to here
88:20 - and refresh
88:22 - all right so we have so
88:23 - as you can see if i go to counter i see
88:25 - the counter component if we go to sales
88:28 - i also see the counter component
88:30 - and it works
88:32 - okay now let's cover component structure
88:35 - a component
88:37 - has basically
88:39 - two areas
88:41 - one is the
88:42 - the html markup
88:44 - and the other part is the c-sharp code
88:47 - blocks
88:49 - right you can have more than one of this
88:51 - you can have you know
88:53 - two still works
88:55 - right so you can separate them so this
88:57 - part covers some functionality and this
89:00 - part can cover different functionality
89:02 - you can use this to do it
89:05 - so the html markups obviously
89:08 - it defines the look and view
89:12 - and the c sharp code blocks
89:15 - it
89:17 - contains ui logic
89:23 - so let's take alex i have no logic here
89:26 - uh let's take a look at the
89:30 - counters
89:31 - right so
89:34 - here this place some
89:37 - some dynamic information this is the
89:39 - title so these are all for look and view
89:42 - right and here defines a button and then
89:45 - when the button is clicked
89:47 - we uh we increment
89:49 - the
89:50 - the variable
89:51 - so
89:52 - so when we combine the c sharp code
89:55 - blocks along with the html markup
89:58 - together
89:59 - they
90:01 - dynamically render the component now
90:04 - let's talk about component inheritance
90:06 - so let's say that all of our components
90:08 - have a common property and let's just
90:11 - say that property is called date right
90:14 - because all of our components want to be
90:16 - able to display data so in that case
90:18 - what do we do do we declare a date
90:20 - variable
90:21 - inside all of our components
90:24 - so that would be um
90:26 - code duplications and we don't
90:28 - want that
90:30 - so what we can do is
90:32 - of course yeah we did this part did this
90:34 - way
90:35 - but if we want to use that date
90:38 - uh variable
90:40 - not only for display but also for some
90:42 - other
90:42 - logic process
90:45 - then we have to be able to reference
90:48 - that variable inside each one of the
90:50 - components
90:52 - so how do we do that
90:54 - we don't want to create a variable
90:56 - inside each component we want to be able
90:58 - to inherit it from
91:00 - a base component blader supports
91:03 - inheritance
91:05 - so let's create a base component
91:13 - it's basically a c-sharp class maybe
91:15 - let's call it the time
91:21 - based component
91:29 - and what do we have here
91:31 - is a basically a property
91:34 - that is a date time
91:37 - and uh
91:39 - let's call it
91:40 - daytime
91:42 - so another thing that we need to make
91:44 - sure that
91:45 - our component
91:47 - needs to
91:48 - be based on
91:50 - need to derive from component base and
91:52 - if i do ctrl dot
91:55 - it will generate that
91:57 - using statement there
92:00 - now let's use this
92:02 - uh
92:03 - base component
92:04 - let's go to our sales component and
92:08 - in here
92:10 - we want this page
92:13 - to derive this page component to to
92:15 - derive
92:17 - from
92:18 - our
92:19 - uh daytime
92:22 - based component
92:23 - which we have to actually do the
92:27 - uh
92:28 - using statement here we can
92:30 - we don't have to do it in the
92:32 - imports.reader
92:35 - we can do it directly in here but
92:37 - because i did it
92:39 - so we can access the class name directly
92:42 - here
92:43 - so we are inheriting from
92:46 - uh
92:47 - we make the sales component inherit from
92:50 - the datetimebase component
92:52 - and let's delete these confusing lines
92:56 - and let's just use the uh
93:00 - let's just display
93:02 - the datetime
93:05 - variable right here
93:07 - right and
93:08 - in order to make sure
93:12 - that we have it
93:15 - i put the date label here
93:22 - all right so as we can see
93:25 - we have this
93:27 - right here well it doesn't have it's uh
93:29 - the value was not initialized so it
93:31 - would be the minimum
93:32 - date time here
93:40 - laser programming is component based
93:43 - as was covered in the previous episode
93:46 - and you would have page components and
93:49 - non-page components
93:50 - right
93:51 - so for example you would have
93:54 - page one
93:56 - page two
93:59 - page three
94:04 - page and
94:07 - each page may deserve to have sub
94:10 - components
94:11 - and those components are non-page
94:13 - components
94:14 - for example this page
94:17 - one has two sub components
94:20 - and page two does not have any sub
94:23 - components or none page components and
94:26 - page three is even more complicated
94:29 - and has
94:31 - you know
94:32 - a component tree like this
94:34 - and
94:37 - page a may have something like that
94:40 - so
94:41 - now the interesting happens
94:44 - interesting thing happens
94:49 - so now when we have a complicated
94:53 - structure like this
94:55 - what needs to happen is a communication
94:57 - between these components
95:00 - and
95:02 - the communications between the page
95:04 - components
95:07 - this kind of communications
95:09 - are done
95:12 - by passing rotting parameters
95:15 - rotting parameters
95:17 - and the communications between
95:19 - the parents
95:21 - and child
95:23 - this is done
95:24 - by
95:25 - parameters regular parameters
95:28 - rotting
95:30 - parameters
95:32 - rotting
95:34 - parameters
95:36 - and this is also rotting
95:40 - parameters
95:42 - but these ones are regular parameters
95:46 - all right so this is also
95:48 - and this is also
95:51 - right
95:52 - so these are
95:53 - regular parameters
95:55 - so we have
95:56 - rotting parameters
95:58 - and we have regular parameters
96:02 - and the third type of parameters
96:04 - are
96:05 - cascading valid parameters
96:09 - so in that case uh we have a
96:12 - a deeper
96:14 - tree
96:15 - structure like
96:16 - page three
96:18 - and sometimes we want to pass the value
96:21 - down from
96:22 - the parent from the page component all
96:24 - the way to the leaf
96:26 - right
96:27 - all the way to all of them
96:30 - and we can do that by using the regular
96:33 - parameters
96:34 - right all of that
96:38 - can be done
96:39 - but
96:40 - laser
96:41 - has a better way to do that it's called
96:43 - cascading parameters i'm not sure
96:46 - whether i'm spelling correctly or not so
96:48 - another type of communication is that
96:51 - when the child
96:52 - when the child when the children are
96:54 - trying to tell the parents
96:57 - about something some interesting that
96:59 - happens
97:00 - right for example your child
97:03 - calls you from university about
97:05 - something
97:06 - right and you would have to react to it
97:09 - so that kind of
97:11 - is called event callback that kind of
97:14 - communication so this
97:17 - is event callback
97:19 - right these blue ones are event
97:21 - callbacks
97:23 - and another type of communication is
97:26 - when you want to tell your child about
97:28 - something right when you call your child
97:30 - about something happen something
97:31 - interesting happen
97:33 - and you ask your child to do something
97:35 - and that kind of communication
97:39 - is
97:41 - um
97:43 - is when the parents
97:45 - calls the child this type of
97:48 - thing we reference
97:52 - you know we reference the child
97:53 - component
97:55 - and then we can call a method on that
97:58 - child component directly
98:04 - what you're looking at is a standard
98:08 - visual studio template for blazer
98:10 - server-side application and i added a
98:14 - few components but today we're going to
98:17 - look at the sales component which is
98:20 - empty
98:21 - and the order entry
98:24 - component
98:26 - which is currently also empty
98:30 - in order to see them they're both page
98:32 - components and as you can see i give
98:34 - them different
98:35 - roth and the page the order entry
98:38 - uh
98:39 - component uses the order
98:42 - slash order rot and the sales
98:47 - component uses slash sales block
98:50 - and in order to see them
98:53 - we are going to add the navigation
98:56 - links copy
98:59 - two of them
99:01 - and then
99:03 - this i'm going to call it sales
99:06 - and this
99:07 - we call it order entry
99:10 - and i'm going to change the route
99:14 - to sales and this is going to be order
99:17 - and we if we go back here and refresh
99:20 - we're going to see
99:22 - sales
99:23 - and order entry
99:24 - and what these two represent
99:27 - are
99:28 - the sales represents sales department
99:31 - and the order entry
99:32 - uh represents the order entry depend
99:35 - department both of them are page
99:37 - components
99:40 - so um as you can see if you have many
99:43 - department
99:44 - you might want to consider
99:47 - having this title part as a component by
99:49 - itself
99:51 - right so let's do that
99:53 - let's create a
99:56 - numpage component and as you know i have
100:01 - a habit of calling it controls
100:05 - but you don't have to call it controls
100:09 - and i'm going to create a new
100:12 - component razer component and call it
100:15 - a
100:16 - title component
100:18 - and this is none page component so it
100:20 - doesn't have a rot
100:23 - but what we're gonna put here is
100:27 - we're going to go to the page component
100:29 - and copy one of them
100:31 - uh it's basically this
100:33 - right and we're going to come over here
100:36 - and then we'll say
100:38 - welcome to the
100:40 - and we're going to change this part
100:41 - dynamically
100:43 - right so we're going to give it um
100:48 - we're going to give it a a variable here
100:52 - in order to
100:53 - populate that but it's not just any
100:56 - variable cannot be private a variable
100:57 - because this variable has to be
100:59 - available to the to the parent
101:02 - component so it has to be public
101:05 - in order
101:07 - to
101:08 - allow the parent component to access
101:10 - this variable it has to be a special
101:13 - variable and
101:15 - it has to be a property
101:17 - and it has to be a public property and
101:19 - we call it
101:21 - uh we can call it
101:23 - department
101:26 - right and here we have to use a
101:30 - parameter attribute
101:32 - to let later know that this property
101:36 - department
101:37 - is a
101:38 - public parameter that can be accessed
101:42 - from
101:43 - the consumer which is the parent
101:45 - component
101:47 - right and then we can use this
101:50 - over here
101:54 - or actually over here and we can say
101:57 - department
102:00 - right and then when we use that
102:03 - component in the parent component
102:06 - we can do
102:08 - this
102:10 - as i have shown in the previous episode
102:13 - we can use the child component as
102:17 - actually
102:18 - in order to do that i'm going to
102:20 - import
102:22 - the
102:25 - namespace
102:27 - and then i'm going to come over here
102:29 - and
102:31 - i'm going to type in
102:32 - title component which
102:35 - is right here
102:37 - and as you can see
102:38 - the parameter is right here okay and
102:42 - then in this case it is sales
102:45 - okay i'm gonna copy this code
102:48 - and i'm gonna go over to order energy
102:50 - department and
102:52 - i'm gonna call it
102:54 - order entry
102:59 - this way
103:00 - when we go to our code and hit refresh
103:03 - we're going to have the sales
103:06 - and water entry department represented
103:09 - by our one
103:12 - component our title component
103:14 - and the good thing about that is if you
103:16 - want to change
103:17 - the wording
103:18 - or the style or the theme or whatever
103:22 - um
103:24 - of the title
103:26 - you can change it from one place right
103:29 - so we can go to our title component
103:31 - and um
103:34 - if we want to add
103:36 - for example you want to want to be
103:41 - in the scored
103:45 - we can have this and then we go back
103:49 - refresh as you can see the underscore is
103:52 - right there
103:53 - right if we want to change the font
103:55 - color
103:56 - to
103:58 - actually change change to uh
104:01 - header
104:05 - we wanted to
104:07 - change the
104:09 - fun color
104:10 - to
104:12 - blue
104:14 - dark blue
104:16 - then we can change it to dark blue like
104:18 - this and then we go back
104:20 - and we refresh there we have it
104:25 - changing in one place passing in
104:28 - parameters
104:29 - so to
104:30 - some to sum up
104:33 - in order to pass a parameter from the
104:36 - parent component to the child component
104:38 - we need to create a pro public property
104:42 - and decorate it with parameter attribute
104:46 - and then we use our component child
104:50 - component in the parent
104:52 - by declaration
104:56 - and
104:57 - populate the parameter
104:58 - with the value that you want to use
105:09 - so the rod parameters are used to help
105:12 - us communicate between page components
105:15 - as well as
105:16 - between
105:18 - none page component and page component
105:20 - to demonstrate
105:21 - i created
105:23 - teams component and
105:26 - team component
105:27 - right the teams component the list of
105:30 - teams and the team component is detail
105:33 - of that team and also showing the member
105:35 - of that team
105:38 - and uh
105:39 - in order to display them because
105:41 - currently we don't see it on the menu so
105:44 - in order to display them um i am going
105:47 - to
105:48 - also added the navigation menu
105:51 - uh just like last time
105:55 - but
106:02 - make sure we have proper route when we
106:04 - come to the navigation menu we clean up
106:07 - this a little bit we change this to
106:09 - teams
106:11 - and we change this to teams as once we
106:14 - refresh the page we can go to our teams
106:17 - and
106:18 - we see a list of teams and for now
106:22 - let's take a look at the codes that i
106:23 - have so
106:28 - so i basically have a teams variable
106:30 - here and i initialize the variable and
106:33 - popular hard-coded some values here
106:37 - and i created this uh team class here
106:40 - usually
106:42 - all of these
106:43 - should be
106:44 - created separately as models and
106:48 - dependency injection into the razor
106:51 - components but
106:53 - since i haven't covered dependency
106:55 - injection
106:57 - so i'm hardcoding these over here
106:59 - what my expected behavior is
107:03 - is that when we click on
107:06 - any of these teams we go to the team
107:09 - component the team page component and
107:11 - display the detailed information about
107:13 - that particular team that you clicked on
107:16 - our code here
107:18 - our markups html markups we can see that
107:22 - i used for each loop and created the uh
107:25 - the rows within the tables and it's
107:27 - displaying team and team
107:30 - team region and also i have a
107:34 - anchor
107:35 - element here
107:36 - going to the the team page component
107:39 - so when i click on it it goes to team
107:41 - component unfortunately
107:43 - uh every single one of them got a team
107:45 - one team component is empty right so
107:48 - let's go to our team component
107:50 - over here
107:52 - and uh it has pre-populated some codes
107:54 - but it does nothing
107:56 - as i said that these should be created
107:59 - as models and dependency injection into
108:02 - the razer components but i'm just hard
108:04 - coding it right right now so don't worry
108:06 - too much about them
108:08 - so
108:10 - i want to display the detailed
108:11 - information about the team as well as
108:13 - the members so i have these
108:16 - data here to kind of represent the
108:18 - member
108:19 - database table
108:21 - right so you have a list of members and
108:24 - you know um
108:27 - you know
108:28 - uh
108:29 - the
108:30 - you know the ids of them
108:32 - and you also
108:34 - should have
108:37 - a
108:38 - the team team id
108:41 - right
108:42 - to indicate which team the member belong
108:45 - to
108:46 - so for that i'm going to create a
108:51 - team id
108:53 - property and then i'm going to go over
108:56 - here and
108:57 - populate that property team id equals
109:00 - one
109:01 - and i'm going to
109:06 - let them
109:08 - to become different teams
109:14 - all right
109:16 - so
109:17 - but the thing is how do we pass that
109:21 - uh
109:22 - information about which team we have
109:25 - selected
109:27 - that's
109:28 - where the rod parameters come into the
109:31 - picture
109:32 - so in order to do that so here
109:36 - we can say that
109:44 - basically here we can say slash team
109:51 - and then we give the team dot
109:55 - the id
109:58 - slash
110:00 - all right so that gives the proper rod
110:03 - parameter here
110:05 - so
110:06 - if we go back here
110:08 - we can see that
110:11 - at the bottom left corner
110:13 - you can see each one of them
110:16 - has a
110:19 - team id appended
110:21 - at the url
110:23 - right
110:24 - but the thing is when you click on it
110:26 - it's going to say
110:28 - it's
110:31 - you know there's nothing at this address
110:33 - right so
110:35 - we have to change our team component to
110:37 - accept that parameter and to do that
110:40 - it's actually pretty easy we come over
110:42 - here and we say
110:43 - you know
110:44 - this is i'm not expecting a id parameter
110:48 - uh and then we come over here and we
110:50 - create a corresponding property and we
110:53 - call it id
110:54 - right and
110:56 - within here you can say parameter
111:00 - and uh
111:02 - and this corresponds to the id right
111:08 - and let's see what happens when we do
111:11 - this
111:13 - all right
111:16 - refresh click on it
111:19 - all right so we have received a uh
111:22 - exception and
111:25 - so what is happening
111:26 - let's um take a look at the
111:30 - uh developer tool
111:32 - so it's complaining that unable to set
111:35 - property id on the object of
111:38 - team component the error was unable to
111:40 - cast object type
111:42 - string to integer okay so
111:46 - that is telling us that it's considered
111:48 - as a string but we are expecting an
111:51 - integer so what do we do in that case we
111:54 - set up a constraint
111:56 - here we're saying okay i'm expecting
111:59 - integer
112:00 - right so if another way to do it is that
112:03 - we can change this to
112:05 - integer
112:06 - sorry change this from
112:08 - uh integer to string so let's do that
112:12 - and then we refresh all right so now
112:15 - we're going to team
112:18 - to the team component but we're not
112:20 - loading any data yet
112:22 - at least we're passing that property
112:25 - right
112:26 - we can say
112:28 - you know we can say over here we
112:30 - pass in that id
112:33 - let's display that id
112:36 - refresh the page okay
112:40 - it will properly pass it in the id
112:42 - from uh the teams page to the team page
112:46 - so that's the communication between
112:48 - different pages
112:50 - right so in order to properly properly
112:53 - display the page uh
112:55 - we we can come over here and we can say
112:57 - that
112:58 - you know uh
113:00 - i'm
113:01 - searching through
113:02 - the uh
113:06 - you can use link to query the teams
113:09 - variable that i have it here
113:12 - we can say that
113:16 - if the id equals
113:19 - uh this dot id which is our
113:23 - parameter block parameter
113:25 - then that's the theme that we are
113:27 - looking for
113:28 - right
113:32 - and
113:33 - it gives an error here right because uh
113:35 - this is a string and
113:37 - this by itself is integer
113:40 - right this is integer so it doesn't want
113:43 - to do that so let's change it to integer
113:45 - and then we will add the parameter
113:48 - constraint
113:50 - and we're telling that we're telling
113:52 - blazer that this parameter is an integer
113:55 - right so so now this is fine so we will
113:58 - have our team so once we have our team
114:01 - we come over here and we say that the uh
114:04 - you know the name is
114:09 - team dot
114:12 - dot name
114:14 - intellisense is
114:16 - not great yet
114:19 - it seems that it's a little bit slow
114:21 - so here we can have
114:24 - a region
114:25 - right and let's see whether that works
114:28 - or not so i saved and then i refresh
114:31 - okay let's go to red team so we have
114:32 - right team here properly the parameters
114:35 - properly passed in and our link query
114:39 - is also working
114:43 - okay cool um
114:45 - all right next is that we we're trying
114:47 - to display the members right and we're
114:49 - going to create another
114:53 - place here and then we are going to find
114:57 - our members first
114:59 - which is uh we have it here and we need
115:03 - to find
115:04 - all of the members
115:06 - so the members are
115:08 - from the members i want to find
115:12 - the members who
115:14 - belong to
115:15 - the team so team id equals
115:19 - this dot id
115:22 - which this id again is the parameter
115:24 - value the raw parameter value so then we
115:27 - would have all of the members right so
115:29 - we'll have our members here and then
115:31 - we'll come over here and say for each
115:33 - sorry um
115:35 - actually
115:36 - so here we want to uh display it in the
115:39 - list
115:40 - to save some time instead of displaying
115:42 - a table and here we're going to have for
115:44 - each
115:46 - and we're going to have variable member
115:49 - in the staff members
115:51 - and
115:53 - here we're going to say our i
115:56 - and we're going to say number dot name
116:00 - well um
116:03 - pipeline
116:05 - member dot
116:08 - uh
116:09 - h
116:12 - intellisense
116:18 - what else do we have yeah name and age
116:20 - and that's good
116:22 - and then let's see
116:23 - when we refresh our page
116:26 - so go to our right team
116:28 - we have
116:30 - team name is rad region is region one
116:33 - and john's h is 20 mike's age is 25.
116:37 - going back two teams got a blue team and
116:40 - we have joe 26 ross21
116:43 - and yellow we have ryan 23 and fox 22.
116:47 - so
116:48 - there we go we have uh parameters
116:51 - passing as raw parameters and going to
116:54 - the different page from parent
116:57 - from teams page to team page and we are
117:00 - successfully load data and display data
117:02 - based on the passing raw parameters
117:10 - let's talk about cascading parameter uh
117:12 - so
117:13 - if we have a
117:15 - component three like this
117:17 - where i have the page component that
117:19 - contains several levels of component
117:23 - so these component
117:26 - these components
117:27 - make the tree a little bit
117:30 - complicated
117:31 - so in this case
117:33 - if we want to pass the parameter value
117:35 - from the first level from the page level
117:38 - down
117:41 - to the leaf
117:44 - if we want to use the regular parameter
117:47 - we have the passive parameters as many
117:49 - times as
117:50 - the number of levels
117:52 - that the component tree has so one way
117:54 - that microsoft has came up with to solve
117:57 - this problem is
117:58 - they created something that is called
118:00 - cascading parameter it's something that
118:02 - you can use
118:03 - to cascade a value from whichever level
118:06 - downward
118:08 - to the lower level components
118:11 - you don't have to cascade one by one
118:15 - okay let's jump to the computer and see
118:18 - how it's implemented all right
118:21 - and this is a standard template
118:24 - blazer template it comes from microsoft
118:28 - and we go to the counter page you can
118:30 - see when we click on it
118:32 - the current column increases so we're
118:34 - going to modify this
118:36 - to
118:37 - mimic a scenario where we have many
118:40 - levels of components we're going to
118:42 - create another two level so all together
118:45 - we have three levels so this is the
118:47 - counter component let's
118:49 - uh create two more components
118:53 - let's create two more components
118:55 - let's call it component one
119:00 - and component 2.
119:10 - and in order to distinguish them i'm
119:12 - going to add some
119:14 - css cell
119:16 - so
119:19 - we're gonna add some margin
119:21 - um
119:22 - to component one
119:28 - and then we're to add another margin
119:31 - to
119:37 - component 2
119:42 - which will cause some indentation so
119:45 - that we can see the different levels so
119:48 - with this we are instead of displaying
119:51 - the current count
119:53 - inside the counter component
119:55 - we are going to remove this
119:57 - and we are going to display the counter
119:59 - con in the component number two
120:02 - right but before we do that um
120:05 - we are going to
120:08 - add the
120:10 - components in
120:12 - we have component one
120:14 - and then
120:15 - within component one
120:17 - we add
120:19 - component
120:20 - two
120:22 - right so component one contains
120:25 - contaminant two
120:27 - and
120:28 - counter component
120:30 - contains component one
120:33 - right
120:34 - so if we
120:36 - uh refresh our page
120:38 - right so we're gonna see
120:40 - component one component two like this
120:43 - was the margin indicating the different
120:45 - levels of components so uh
120:48 - now i wanna display the uh
120:51 - counter value inside component
120:54 - 2 right how do we do that
120:56 - we need to wrap our components
120:59 - with a cascading
121:03 - value
121:04 - element
121:05 - and we're going to tell
121:08 - that
121:09 - i'm going to tell blazer that this value
121:12 - is called counter and the value itself
121:16 - comes from the current
121:18 - the current count
121:24 - and we wrap this component one with it
121:28 - so current count is here so what happens
121:31 - is that when we click
121:33 - on the button it calls this event
121:36 - handler and it increases the count and
121:39 - this current count is passed into
121:42 - the component tree
121:44 - no matter how deep the tree is
121:47 - how many how many levels the tree has
121:50 - you can access
121:52 - this
121:53 - count value from within the components
121:56 - so
121:57 - let's say you want to access from
121:59 - component two you can actually access it
122:01 - from component one or component two or
122:04 - both right so
122:06 - uh in this video let's directly go to
122:09 - component two and we're trying to
122:11 - display the count here
122:13 - right so let's say
122:17 - i want um tell
122:19 - that the count
122:20 - as
122:23 - the count
122:25 - is
122:30 - is the the corner value
122:33 - right and to do that we need to
122:37 - declare a
122:39 - parameter and that is the same type
122:42 - um
122:43 - and the name can be any name let's call
122:45 - it contour
122:46 - value
122:48 - but
122:49 - the
122:51 - we have to
122:53 - decorate it with this cascading
122:55 - parameter and we call it
122:57 - sorry the talent
122:59 - name of this custom parameter is counter
123:02 - right that's the same name that we give
123:05 - it
123:06 - here
123:09 - right so
123:11 - you can name your
123:14 - cascading parameter
123:16 - with
123:18 - anything
123:19 - but then as long as you declare that the
123:22 - in the attribute part that you make sure
123:25 - that this counter value name is the same
123:28 - with the name that you declared
123:30 - inside the cascading value element
123:34 - all right so now with this setup you
123:37 - would be able to rate this counter value
123:41 - directly from
123:42 - the contour component the parent
123:44 - component
123:45 - uh the ancestor component
123:47 - okay
123:48 - it will contain this value so let's see
123:51 - whether we'll get it
123:52 - to get the correct value so we're gonna
123:54 - display this value right here
123:57 - counter
123:58 - value
123:59 - and then we're going to go back and
124:01 - refresh our page
124:03 - right so now it shows counter value 0
124:07 - and we need to increase
124:09 - when we increases
124:11 - it goes up okay so we have successfully
124:14 - passed down the counter value so this
124:17 - helps us a lot
124:19 - when we want to pass values around
124:22 - component 3
124:24 - it's very convenient one of the
124:26 - disadvantages of this
124:28 - is that
124:30 - when you have
124:32 - when you need to pass the values around
124:34 - all of the components in the component
124:36 - tree the blazer framework would have to
124:39 - monitor all of the components you use
124:42 - just one cascading
124:44 - value that you want to cascade
124:46 - then
124:47 - the blazer would have to monitor all of
124:50 - the components if you want to pass the
124:51 - value to all the components for example
124:54 - uh about a theme a theme of your
124:57 - application once you set it
124:59 - it has to be accessed by all the
125:01 - components
125:02 - and the component
125:03 - each one of the components will monitor
125:06 - monitor the change of that
125:08 - uh theme once it changes
125:10 - then
125:11 - each every one of the component will
125:13 - change
125:14 - so this kind of
125:16 - makes the um laser framework have too
125:18 - much to handle right if you have just
125:22 - one variable to cascade
125:24 - it adds a lot of work
125:27 - and then you have two
125:29 - then it has more work
125:31 - that's three then has even more work
125:34 - so by the way let's see how um we want
125:37 - to cascade
125:39 - multiple parameters how do we do that
125:41 - okay so let's do that first and then
125:44 - we'll come back to the drawback to the
125:46 - um
125:48 - to one of the problem was this and how
125:50 - we can fix this and how we can fix this
125:53 - um kind of a performance issue
125:56 - right because
125:58 - when blazer has too much to monitor it
126:00 - takes too much resources and it costs
126:03 - performance issues especially with
126:04 - blazer server side
126:06 - that the uh it monitors
126:09 - each user has its own session
126:11 - and uh it holds the session state and
126:14 - everything so that's um if you give it
126:16 - more work was uh with the cascading's
126:19 - parameters it's gonna create more
126:21 - performance issues so we're gonna go
126:24 - come back in in the film
126:26 - in a minute
126:27 - let's
126:28 - see how we can implement multiple
126:30 - cascading parameters so let's go to
126:32 - counter
126:33 - and uh
126:36 - let's
126:37 - just uh cascade
126:40 - let's say we want to change
126:42 - the the color
126:44 - of that
126:46 - so
126:46 - we would add another level of cascading
126:49 - parameter and we call it
126:51 - you know we call it
126:53 - uh let's say um
126:56 - color and value is
127:00 - i'm going to directly
127:02 - give it a value
127:04 - right here
127:06 - let's say the
127:08 - value is
127:11 - is blue
127:16 - okay
127:17 - and now we can go to our
127:21 - component
127:23 - child component
127:25 - we can just color declare another
127:30 - cascading parameter
127:32 - and making sure that the title matches
127:35 - and here it doesn't matter you just call
127:38 - it color
127:39 - and then
127:40 - we are going to modify the
127:45 - the color
127:48 - right we call it
127:51 - we call this color
127:56 - value here
127:58 - and
127:59 - if we refresh we're expecting the level
128:02 - 2 component i mean component 2 becomes
128:04 - blue refreshing
128:06 - it's not blue and why is that
128:12 - title counter
128:20 - title color
128:23 - oh
128:26 - tito
128:27 - color
128:28 - all right so it's blue
128:30 - all right so we're
128:32 - now we're actually cascading multiple
128:35 - uh levels sorry multiple cascading
128:37 - parameters multiple values
128:42 - so
128:43 - let's go back to the point that i was
128:45 - trying to make about the performance
128:46 - issue
128:47 - so um
128:50 - and this is actually a good example that
128:52 - we are cascading
128:54 - a color
128:55 - to down to the component too
128:58 - right
129:00 - but
129:01 - it's static
129:05 - means that it's not changing like the
129:07 - counter
129:09 - the count value
129:10 - it increases or decreases
129:12 - uh it's static
129:14 - it's fixed
129:16 - so
129:17 - but even though it's fixed because we
129:20 - have
129:22 - we have the clarity that's getting
129:24 - parameter here laser framework will
129:26 - still try to monitor this and and try to
129:28 - see whether this color will change but
129:30 - it's actually not going to change
129:32 - but this is actually a text resource
129:35 - from
129:36 - uh from the laser framework
129:39 - right
129:41 - so it will actually impact the
129:43 - performance
129:44 - so one way we can avoid this is to come
129:46 - over here and say
129:49 - you know
129:50 - uh this is a fixed
129:53 - this is the fixed
129:56 - value
129:57 - so when we go back and refresh it's not
130:00 - gonna affect it it's gonna still work
130:02 - you're gonna not you're gonna you're not
130:04 - gonna see any differences
130:06 - but
130:07 - um
130:08 - but it's gonna avoid the performance
130:10 - impact
130:11 - so this is what you need to do when you
130:14 - need to cascade a fixed parameter for
130:17 - example if you have different
130:19 - departments right you have water
130:21 - department your sales department you
130:22 - have different departments and
130:25 - if
130:26 - each department has its own page
130:28 - component and each page component has
130:32 - its own complicated complicated
130:36 - component tree
130:37 - but
130:38 - inside those inside the two component
130:41 - trees you you want those child
130:43 - components to know about which page
130:46 - component you're in i'm in the order
130:48 - department
130:49 - componentry or i'm in the
130:52 - sales department componentry i want to
130:54 - know the department right so this type
130:56 - of value
130:57 - although it changes when you click on
131:01 - you will never get to the the page
131:03 - component but it will once you are there
131:05 - it never changes
131:07 - so in this case you should
131:10 - use the is fixed equals to 2
131:13 - to top laser framework that the value
131:17 - of the cascading parameter will never
131:19 - change
131:20 - so this will
131:22 - will not impact the performance will not
131:24 - affect the performance so that's
131:26 - something we need to pay attention to
131:28 - another thing we need to know about is
131:31 - that
131:32 - cascading parameter it can only you can
131:34 - only casting it down you cannot pass the
131:36 - value upward
131:38 - so one way to resolve that issue is to
131:41 - add some event callback or add a
131:46 - delegate parameter
131:49 - basically a regular
131:50 - component parameter
131:52 - that is declared as a delegate and then
131:56 - from the parent
131:58 - we register to the delegate
132:01 - and
132:02 - when you click on the button you
132:05 - trigger that alligator basically you
132:06 - trigger that function inside a parent
132:08 - component and then your parent component
132:11 - react to that
132:14 - handles that delegate and increases the
132:17 - counter
132:18 - increases the variable in the defined in
132:21 - the parent component so that's one way
132:23 - to do it but um
132:25 - if you have many levels you have to pass
132:28 - you have to declare that delegate
132:31 - parameter for many levels up to the top
132:34 - components right and that's uh that's a
132:37 - pretty
132:39 - in my opinion that's not a very good way
132:41 - to do it uh if we go down that rod i
132:44 - would uh suggest to use a uh centralized
132:48 - state management which i'm going to
132:50 - cover in later
132:52 - episodes
132:55 - so that's the other thing i want to
132:57 - the other point that i want to make
132:59 - which is that we cannot pass
133:02 - parameters
133:04 - up the component tree
133:07 - of another thing that we really need to
133:08 - pay attention when we use cascading
133:10 - parameter is that it can quickly become
133:12 - pretty messy right so when you have a
133:18 - when you have a complicated uh
133:22 - component tree like this
133:24 - you can have
133:26 - the cascade you can just declare that
133:28 - consequent parameter
133:29 - cascading value element on any levels
133:32 - and then
133:33 - on any lower levels you can receive that
133:36 - with different names and if you can if
133:38 - you
133:39 - you come over here for example you click
133:41 - on this
133:42 - and you say okay i want to i want to
133:44 - know where does value come from
133:47 - right so you can't right click and go
133:49 - definition because it will not go
133:50 - anywhere right this is defined right
133:53 - here
133:54 - you click on it
133:55 - you know it's it's you can follow it you
133:58 - don't know where it's defined
134:00 - right so when you have many many levels
134:01 - so this is not as many levels as this is
134:04 - not too complicated but when you have
134:06 - many levels um when you have very big
134:08 - trees you don't even know where it's
134:10 - defined
134:11 - right and you have to use search
134:14 - uh in in your ide to find it in your
134:17 - visual studio to find it which is not as
134:19 - pleasant it can quickly become pretty
134:21 - messy
134:22 - so um again
134:25 - in in those cases where you want to
134:28 - uh use um
134:30 - when you have what you find yourself
134:33 - that you declare you find yourself
134:34 - declaring a lot of
134:36 - cascading parameter values
134:38 - cascading parameters
134:40 - that's probably a sign to tell you that
134:44 - you should use a centralized
134:47 - state management
134:49 - system instead of using the cascading
134:51 - map
134:52 - parameters so we should really use the
134:55 - cascading parameters
134:57 - sparingly
135:03 - event callbacks
135:05 - are for communication between parent and
135:07 - child component
135:09 - and it's when the child component has
135:11 - something interesting happens
135:14 - then it basically calls
135:16 - their parents and say
135:19 - hey parent i have something interesting
135:21 - happen please react to it let's take the
135:24 - contour component as example let's run
135:28 - the default application
135:30 - uh go to common components click on
135:33 - click me then it increa increases the
135:36 - value
135:37 - and
135:39 - if we change it a little bit
135:41 - uh so that the counter component because
135:44 - becomes a sub component
135:46 - then we can demonstrate the event
135:48 - callback so
135:50 - let's create another component
135:53 - let's call it
135:55 - a
135:58 - parent component
136:01 - and lab disk parent component
136:05 - to use the same
136:08 - route
136:09 - of course we have to remove this route
136:12 - so we can
136:13 - make the counter component itself
136:15 - becomes a sub component because it
136:17 - becomes a
136:19 - child component of this parent component
136:21 - and
136:23 - we use it like this
136:26 - and if we run this code
136:29 - refresh right here it's basically going
136:33 - to do the same thing except you're going
136:34 - to see a title here it's
136:37 - parent component because
136:38 - now the common component becomes a sub
136:41 - component because becomes a child
136:43 - component and it work the same way
136:47 - but what if we want this current count
136:50 - to be displayed
136:51 - um
136:52 - inside the parent component instead of
136:54 - under the counter component itself
136:57 - uh so
136:59 - for that we can remove this
137:02 - we remove this
137:05 - and then we come over to
137:08 - the parent component and
137:11 - we declare
137:12 - a variable here
137:15 - and we call it
137:19 - private
137:21 - integer
137:24 - count
137:28 - okay
137:30 - so and then go back to counter component
137:33 - and
137:36 - and then here we declare a
137:40 - public property
137:44 - okay and
137:45 - we have to make sure
137:47 - that the
137:50 - it
137:51 - it's the event callback
137:53 - okay
137:54 - and
137:55 - with a parameter and the parameter value
137:58 - is
137:59 - uh parameter type is integer and we call
138:02 - this
138:03 - set
138:05 - current
138:07 - count
138:08 - and this has to be a parameter
138:13 - and then we are going to
138:15 - invoke
138:18 - this set current count
138:20 - under the event handler of the increment
138:23 - count
138:24 - right so basically we're gonna say
138:28 - invoke async
138:32 - and
138:33 - it's current count
138:36 - then we're going to come over here and
138:38 - refresh the screen and then
138:40 - of course we didn't do we didn't hook it
138:42 - up yet but let's try that
138:46 - okay
138:49 - and we are not seeing any exceptions
138:51 - so keep that in mind then we'll come
138:53 - back and talk about that
138:55 - so in order to implement this we need to
138:58 - go back to the parent component
139:01 - and then
139:02 - we're basically come over here and set d
139:05 - parameter the side current count
139:08 - as a
139:09 - basically you can just say
139:12 - second account
139:13 - and then in here
139:15 - we're gonna have this stack current
139:18 - count
139:19 - with integer
139:21 - value and then
139:23 - we are going to say
139:26 - current count equals value
139:28 - and what we're going to do is we're
139:30 - going to display
139:33 - i'm going to display this
139:35 - current count right here
139:43 - current count
139:44 - current count
139:46 - then we're going back over here
139:48 - refresh all right so current column
139:50 - initial is zero neutral value is zero
139:53 - and then we click on it
139:56 - now it works
139:58 - all right so coming back and just to
140:01 - summarize that
140:03 - so first of all you need to do is that
140:06 - you need to create a
140:09 - parameter
140:10 - that has a special return value
140:13 - which is a event callback
140:18 - this type is event callback
140:21 - there's two versions of this this first
140:24 - version is without the
140:26 - generic type
140:28 - the second version is with a generic
140:30 - type depends on whether you want to pass
140:33 - a parameter to it or not so this is
140:35 - basically the parameter type of this
140:38 - set current count
140:40 - right so when you invoke it
140:42 - this current count parameter has to be
140:44 - this type integer type in this case
140:47 - the second step so once you declare the
140:50 - parameter like this then you go to your
140:53 - parent account
140:54 - and then you basically set the parameter
140:57 - just as any other
140:59 - parameters except that this is a
141:02 - function name instead of just a value it
141:05 - corresponds to this you can call it
141:08 - any
141:09 - function
141:12 - it doesn't matter doesn't have to be the
141:13 - same as the parameter name
141:16 - and uh
141:17 - if we refresh the screen you're going to
141:19 - see it's going to work
141:21 - anyways doesn't have to be
141:23 - exactly the same
141:26 - right so those are the two things uh
141:29 - it's two basic things we need to know
141:31 - about it
141:32 - uh and then we just dig a little bit
141:34 - deeper into this event
141:36 - callback so the event callback is not
141:39 - just any parameter
141:41 - it has a special type and this
141:44 - makes us kind of think that it's similar
141:46 - to a
141:47 - delegate in c sharp
141:49 - right but it is very similar
141:52 - uh to
141:55 - delegate but it's not exactly the same
141:57 - as a delegate for example you don't have
141:59 - to when you invoke it you don't have to
142:02 - test whether it's
142:05 - uh empty or not
142:09 - right it's not going to throw an
142:11 - exception
142:12 - if it's
142:13 - empty right we have seen that so let's
142:16 - try that again if we remove this which
142:19 - means that we are not actually
142:22 - providing any registration to that
142:24 - delegate
142:25 - if we call it delegate
142:27 - it's not even a delegate but
142:30 - when we rush this it's not throwing any
142:33 - exceptions right it just doesn't work
142:34 - anymore
142:35 - right so let's put that back
142:39 - so coming back over here so it's not a
142:42 - delegate that you have to
142:44 - check the whether it's registered or not
142:46 - you can just directly invoke it and it's
142:49 - going to work
142:50 - secondly
142:52 - it's different from a delegate because
142:55 - we can actually
142:57 - declare a delegate right now
142:59 - right so we can declare a delegate
143:02 - like
143:03 - this
143:04 - and uh
143:07 - basically we can do the same thing let's
143:09 - simulate this
143:11 - uh
143:12 - with
143:14 - you know set count let's call it sitcom
143:16 - and then over here we can declare this
143:19 - as a parameter as well
143:21 - and then when we go to the parent
143:23 - component
143:25 - we can
143:27 - we can give that
143:30 - delegate
143:34 - assigned to the same function
143:37 - right
143:38 - and then if we remove this
143:43 - and then we'll go to the counter
143:44 - component and instead of calling this
143:47 - we just call
143:49 - setcount
143:51 - dot invoke
143:54 - we're passing the
143:56 - current count
143:58 - right
143:59 - let's see how whether it works or not
144:02 - okay
144:04 - if it works then there's no difference
144:06 - between a delegate and event callback
144:09 - you see there's it doesn't work
144:12 - i'm clicking on the click me button but
144:14 - it doesn't work
144:15 - why
144:16 - because
144:18 - your parent component you're basically
144:20 - triggering this event
144:22 - from a child component
144:25 - and expecting your parent component to
144:27 - truly render
144:29 - right but it doesn't re-render
144:32 - the value is set but it doesn't
144:33 - re-render re-render
144:36 - and the reason is that
144:38 - your component does not render
144:41 - if the event is triggered from from
144:44 - other components
144:45 - learn as you specifically say that you
144:47 - want to re-render it but if we are using
144:50 - a event callback
144:52 - then
144:53 - the
144:54 - whoever whichever function
144:57 - that is connected
144:59 - or assigned to that event callback
145:02 - your parent component is going to watch
145:04 - that and once that function is called
145:08 - it's going to re-render the component
145:10 - but in order to make this
145:12 - work
145:14 - we have to
145:16 - say hey state has changed
145:19 - right
145:20 - because this function is currently
145:22 - assigned to the set count delegate
145:25 - and the second delicate when the set
145:28 - delicate invokes
145:30 - this function is not going to trigger a
145:34 - render and unless we are
145:37 - specifically saying that
145:39 - we know the status changed and go ahead
145:42 - to rerender and now let's see what
145:44 - what happens right
145:46 - so now it works
145:48 - so
145:49 - that's why it's different
145:52 - and another thing that we can try is
145:54 - that if we remove this
145:58 - and see what happens
146:00 - if we remove this
146:02 - and then we click on it immediately with
146:04 - a c
146:05 - and handout exception has occurred see
146:07 - the broader dap tools for details
146:09 - why
146:10 - let's see that bother
146:12 - the browser tools and then at the bottom
146:15 - the console actually let's look at the
146:16 - console here
146:18 - it says no reference why let's go back
146:20 - and take a look at our
146:23 - child component
146:24 - where we
146:25 - invoking the delegate
146:28 - without having the delegate assigned to
146:31 - a actual
146:32 - function right so there's no
146:36 - there's no registration
146:37 - to that delegate
146:39 - so we can just invoke like this but
146:43 - for event callback we're okay we can
146:45 - just call it whether there is a
146:49 - whether there is a
146:51 - registration to this event callback or
146:53 - not
146:55 - all right
146:56 - so going back here
146:59 - and
147:00 - set current count it pulls
147:03 - well if we don't set anything
147:07 - refresh again
147:09 - but it doesn't work but it doesn't cause
147:11 - any problems
147:12 - so that's uh that's the difference
147:21 - sometimes from the parent component we
147:23 - want to directly invoke the methods or
147:26 - properties
147:27 - of the
147:28 - child components outside of the
147:30 - declaration
147:32 - so
147:33 - for example some event happened you want
147:35 - to
147:36 - trigger some other things
147:39 - under the
147:40 - under your child component
147:42 - let's take example uh very quickly let's
147:45 - create a
147:49 - let's create a chart component
147:53 - uh actually it's going to be a control
147:58 - so
148:00 - let's create a folder and call it
148:02 - and chose and then under here let's
148:05 - create a
148:08 - new razer component just call it child
148:10 - component
148:12 - we are going to be displaying the child
148:15 - component under the counter component
148:18 - and
148:20 - let's have a line break here and then
148:22 - let's call it
148:24 - let's call the chalk component right
148:26 - here
148:27 - uh
148:28 - right here well let's
148:30 - that's ugly let's
148:33 - import our name space right here
148:36 - um
148:37 - let's play the three dot controls
148:42 - so
148:43 - then we go back and delete this and we
148:45 - call it
148:47 - child component
148:50 - and
148:51 - now if we refresh the screen
148:55 - we'll see our child component right
148:56 - there and
148:57 - under under here and uh uh what we want
149:00 - to do is that we want to we only want to
149:03 - display the child component when we
149:05 - click on the button
149:08 - all right so uh
149:11 - extra line break
149:12 - and then uh we're gonna have a
149:15 - button
149:16 - and
149:17 - we're gonna have
149:20 - and now we want to when we click on the
149:24 - button we want to display it so uh
149:27 - basically means that we are not going to
149:29 - display
149:30 - whatever markup that we have
149:32 - uh
149:33 - at the beginning so we're going to
149:35 - declare a
149:36 - number here that says it's a boolean and
149:40 - we're going to say and call it display
149:42 - and we are only going to display
149:45 - this
149:46 - if it's true
149:48 - right so we're going to put this
149:51 - right here
149:52 - and then we go back
149:54 - and uh
149:57 - this button
149:59 - would complete that button later
150:01 - so if we refresh then we don't see that
150:05 - we see this empty button here but that's
150:07 - okay
150:08 - so the important thing is that we're not
150:11 - seeing that child component anymore so
150:13 - we want to click on the button
150:15 - and
150:16 - uh to show the
150:19 - the child component
150:22 - and over here we're going to say unclick
150:28 - and what we want to do
150:29 - is we want to
150:34 - display
150:36 - the child component we are going to say
150:39 - here we're going to how do we set the
150:40 - display variable under the child
150:42 - component
150:45 - that's where the uh
150:46 - referencing child components come into
150:49 - place so how to do that is that we do
150:52 - we say reference and we say
150:55 - you know child
150:56 - and then over here we create a attribute
151:00 - and we say
151:02 - child component
151:04 - and
151:04 - child so this name
151:06 - and this
151:07 - they have to be the same
151:10 - and then we can use this to reference
151:12 - the child component so we can inside
151:14 - here
151:15 - right we can say child dot
151:18 - uh something right so what do we do we
151:21 - go to the child component
151:23 - and
151:24 - we create a public
151:26 - method you say show
151:29 - and then just say you know display
151:32 - equals
151:37 - then going back to the counter component
151:39 - and then we say child
151:41 - so when we click that button
151:43 - we reference the child we say
151:46 - show yourself
151:47 - my child
151:49 - okay so go back
151:52 - and refresh
151:54 - now we're gonna see that button
151:56 - this button is using bulma so i do have
152:02 - vomit here
152:03 - and this
152:05 - button is
152:06 - controlled by bulma
152:08 - it's using the bulma class but i haven't
152:11 - referenced the bulma and they're the
152:13 - host you can see that
152:15 - i have
152:17 - this
152:18 - but i don't have bulma
152:21 - right
152:22 - so as soon as i
152:24 - reference boma
152:27 - then it's going to be
152:29 - displayed
152:31 - uh
152:33 - yeah we're gonna take effect
152:36 - refresh again all right that's boma
152:38 - style and i like boma much better so in
152:42 - future demos i'm going to use boma for
152:45 - developing components
152:48 - actually today as well
152:50 - so
152:51 - now you can see that we are not seeing
152:53 - that child component but if i click on
152:55 - it it's going to
152:56 - trigger that child component show method
152:59 - and uh set it to true so
153:02 - the child component is going to show
153:04 - itself okay so the reason why the child
153:07 - component is not showing
153:09 - again we talked about this in the last
153:11 - in the previous episode it's that's
153:13 - because the component will only render
153:16 - itself
153:17 - in four under four different conditions
153:20 - first is when the component is created
153:23 - it's just created
153:25 - secondly
153:26 - is when parameter changes parameter
153:28 - value changes
153:30 - thirdly
153:31 - when there's event uh handlers for
153:35 - example you click on that button and
153:37 - then under that event handler you change
153:39 - the state of the
153:42 - component and that component is gonna
153:44 - gonna re-render itself
153:45 - and force
153:47 - fourthly uh
153:49 - that's when the developer want to
153:52 - re-render the component
153:55 - by
153:55 - calling the state has changed method
153:58 - so
154:00 - because we didn't call the status change
154:02 - method and because we are calling the
154:04 - show method from outside of the
154:05 - component or within the component
154:08 - right
154:08 - uh if you had a button right in the
154:11 - child component and then you triggered a
154:13 - show method and then you change the
154:15 - property you change the state of the
154:18 - child component
154:20 - then the child component will
154:23 - will be re-rendered
154:24 - but in this case we have to specifically
154:27 - as a developer we have to specifically
154:29 - call the status change
154:31 - and then
154:34 - it will render itself
154:36 - so let's refresh
154:39 - you see when i click on it shall
154:41 - component shows
154:42 - right so go back
154:45 - uh
154:47 - every time we we never get to a
154:50 - component
154:51 - it recreated it's recreated
154:54 - so now you don't see the child component
154:56 - but when i click on it now it's jokes
154:59 - all right so let's have even um a better
155:02 - example let's
155:04 - let's create a
155:05 - dialogue with with boma style and then
155:08 - we
155:10 - we kind of toggle it right so let's go
155:12 - to bulma
155:14 - and uh let's go to
155:16 - yeah bowman model dialog and let's go to
155:20 - model and what i want is this model card
155:23 - and it looks like this and it's pretty
155:26 - clean and uh
155:28 - in order to show
155:30 - the model dialog
155:32 - you can see that in order to so to
155:35 - activate the model just add this active
155:37 - modifier to the model container right
155:41 - so
155:42 - we're going to copy this
155:45 - and then we are going to create another
155:48 - component we're going to call it
155:54 - gonna call it uh
155:56 - dialog
155:59 - component
156:01 - right and then over here we're gonna
156:02 - remove this and have this over here
156:05 - we're gonna actually add this is
156:09 - active active
156:12 - right there and but
156:15 - we are not gonna change the class
156:17 - what we're gonna do is we're gonna have
156:20 - again the same same sort of thing
156:23 - i'm gonna have this and uh
156:26 - uh we're gonna initialize it was false
156:30 - and
156:31 - and get over here and say hey if
156:34 - you display is true then
156:38 - then we display otherwise
156:40 - we are not going to display anything
156:43 - right
156:46 - so
156:47 - go
156:48 - over to counter and
156:51 - remove child component
156:54 - we are going to say
156:57 - uh we are going to reference
156:59 - we are going to add the dialogue
157:01 - component
157:02 - right here
157:04 - and
157:06 - we want to reference the dialog
157:08 - component by
157:10 - using the name dialog and
157:13 - over here we're going to say dialog
157:16 - component
157:17 - dialogue
157:20 - and
157:22 - we're going to trigger this right here
157:24 - but it doesn't have the show method yet
157:27 - let's go to our dialog and create a
157:29 - short method
157:31 - public void
157:32 - show
157:34 - this
157:35 - display it goes to
157:38 - and
157:40 - we can also have our
157:42 - close method right over here and call us
157:45 - display
157:46 - false
157:47 - and another thing is that here's a
157:50 - button
157:51 - you see this button it's a close uh it's
157:53 - a close button and we also need to
157:56 - make sure that we close this as well and
158:00 - we're going to call
158:02 - on click
158:04 - right and
158:06 - again
158:08 - we're going to have
158:09 - our
158:12 - uh
158:14 - i'm going to call this and
158:20 - we're going to say
158:21 - close i'm going to call the close method
158:23 - that we just created
158:24 - and
158:26 - and we know that this is not going to
158:27 - work
158:28 - because we have to say state
158:31 - has changed
158:34 - all right and we get over here and call
158:37 - this as well
158:38 - now
158:39 - we go to
158:41 - the
158:42 - counter component we refresh it
158:46 - um
158:48 - actually we should change the name to
158:49 - show dialog
158:54 - go to counter
158:56 - and we change the name to
158:59 - show
159:03 - dialog
159:05 - and come back refresh again
159:08 - and then click on it
159:10 - we see the dialog
159:12 - right
159:14 - well it's not doing anything but we
159:15 - click on this button yes it closed
159:18 - so
159:19 - going back to dialog component and get
159:22 - over here and we also call this um
159:27 - uh let's just
159:29 - to make it simple we just call
159:32 - closed like this
159:36 - right and
159:40 - of course on these
159:42 - event handlers we should actually do
159:44 - more than just closing but for today's
159:46 - demo we just only call the close my
159:50 - third and that's everything we do
159:53 - for today
159:55 - let's go back and refresh the screen
160:00 - all right so we have this and these
160:03 - buttons work as well as well as the
160:05 - close button
160:11 - this is the documentation from microsoft
160:14 - regarding the templated component and
160:16 - there are three key factors within a
160:18 - templated component
160:20 - the first one is
160:22 - render fragment
160:24 - right this type of parameter the second
160:27 - one is a parameter that is a generic
160:30 - type list
160:31 - and the third one is a render fragment
160:34 - with a generic type
160:36 - with the same generic type so the three
160:39 - of them they don't need to exist in the
160:42 - templated component in order to make it
160:44 - work
160:45 - so
160:47 - today i'm going to only talk about the
160:48 - render fragment
160:51 - and then future videos are going to
160:53 - cover
160:54 - the other two this is the
160:57 - visual studio server side template from
160:59 - visual studio
161:02 - it's just nothing new and let's build it
161:05 - and run it and as you can see
161:08 - it's just the default
161:11 - template
161:13 - of laser server side and
161:16 - let's
161:17 - uh
161:18 - talk about what is the purpose of having
161:21 - a templated com in my opinion
161:24 - template component gives the developers
161:28 - the ability to provide
161:30 - some sort of template to the component
161:32 - itself and the component also provides
161:36 - some sort of layout
161:38 - right so this is more on the ui
161:41 - side the functionality
161:44 - is
161:45 - mostly
161:46 - on the consumer
161:47 - side right so the consumer of the
161:49 - component which is the parent of the
161:51 - component are going to provide more
161:53 - functionality
161:54 - and
161:56 - the
161:57 - components of provides more layout
162:01 - right so let's take a example that uses
162:04 - the render fragment right so
162:06 - uh the render frame fragment itself
162:10 - is
162:11 - uh a
162:12 - it's used as a as a type
162:15 - of a parameter
162:17 - right
162:18 - and
162:19 - this parameter
162:20 - is
162:21 - basically
162:23 - a
162:24 - when when you use it it's going to be a
162:26 - wrapper
162:27 - of
162:28 - some html let's have an example so that
162:32 - it's easier to explain to
162:34 - it's easier to explain
162:37 - so let's take a look look at boma right
162:40 - so for beaumont to have this field
162:43 - what it needs to do is to have this this
162:46 - much him up so if i copy this and paste
162:50 - it over to our
162:52 - let's create a
162:55 - component
162:56 - actually let's just use it
162:59 - on the counter
163:00 - actually use it on the index right and
163:02 - delete this
163:04 - survey
163:05 - control
163:09 - and paste it over here
163:11 - we need our
163:14 - boma css
163:16 - which is not in here
163:19 - so
163:22 - i'm going to copy this
163:25 - over
163:26 - to
163:29 - laser four
163:37 - and then
163:39 - we're going to go to our host
163:42 - and
163:43 - copy this
163:52 - and that's it
163:54 - all right so we have our obama
163:56 - in here
163:58 - and this is going to work i believe
164:02 - all right so let's go to this uh blazer
164:04 - 4 and refresh uh it's the home control
164:07 - right so you see this right but
164:09 - if we go back and we look at this
164:13 - well
164:14 - yeah so this is
164:16 - it looks pretty good right looks pretty
164:17 - neat the style is whatever what we like
164:20 - but then what's what's gonna happen when
164:22 - you have many views
164:24 - on the form
164:25 - so you you have to sorry you have to
164:28 - kind of copy paste and this whole thing
164:30 - right so suppose we have name is over
164:33 - here so we have name
164:36 - uh we have title
164:39 - and we have
164:41 - department
164:43 - right
164:44 - so for only three fields
164:46 - we're coming the lines of html from line
164:48 - number nine
164:50 - to line number
164:53 - 44 so it's it's getting crowded with
164:55 - just
164:57 - three filled
164:58 - right so what what can we do to make
165:01 - this uh the number of lines of uh
165:05 - html shorter
165:08 - more compact
165:09 - so we can actually make a component by
165:12 - utilizing the render fragment
165:15 - right
165:16 - so let's let's do that let's create a
165:21 - component and
165:24 - i want to create controls folder and
165:26 - create a component under the control
165:28 - folder so let's go over here and go to
165:31 - component
165:32 - and then let's call this
165:34 - build component
165:38 - right
165:39 - so
165:40 - and then what we need
165:42 - is this let's copy and paste it over
165:44 - here and see how we can make it easier
165:48 - so
165:48 - we need to provide a name of the label
165:51 - right so that means
165:54 - we need a parameter
165:56 - and
165:58 - a public property with a string type and
166:01 - that's
166:02 - um
166:03 - let's call that
166:05 - label name
166:09 - or let's just call it label okay
166:12 - and uh
166:13 - we also need input
166:16 - to be somehow in there but this input it
166:19 - cannot be inside the field component
166:21 - because it may not be just an input
166:24 - control it can be maybe a radio button
166:26 - right so you don't know the type it's
166:28 - better to be provided from outside and
166:31 - here
166:32 - is why we need to use a render fragment
166:36 - right so we can take this out
166:39 - and then we create a special parameter
166:42 - we call it
166:44 - uh
166:47 - we call it uh
166:49 - so it's going to be also a property and
166:52 - this has to be render fragment
166:55 - okay and today we are not going to cover
166:57 - the one with the generic type
167:00 - um
167:01 - so and
167:02 - here it's going to be called let's call
167:06 - it control
167:08 - okay
167:09 - and what we can do here is
167:12 - is that we render this
167:14 - render fragment right over here
167:17 - right when we do this laser framework
167:20 - we'll recognize that this control is a
167:23 - render fragment
167:24 - therefore it's going to render
167:27 - the html
167:29 - that the consumer or the parent control
167:32 - provides to the child control
167:36 - okay
167:37 - so with this
167:40 - right what we can do instead of having
167:43 - uh
167:45 - these number lines of code we can have
167:47 - it way shorter
167:49 - oops sorry
167:52 - uh we can go over here and we can
167:56 - use our
167:57 - field
167:59 - actually let's import that namespace
168:05 - so that you can see it
168:08 - get over here and then if we enter again
168:11 - you can see
168:12 - we have that and then we provide a label
168:15 - and
168:16 - we call a name right we do the three
168:18 - fields
168:20 - and then uh what we can do here is
168:24 - is supposed to be
168:27 - okay so it's the intellisense is not
168:29 - working very well
168:31 - so
168:33 - here
168:36 - we have this right
168:38 - and control
168:40 - inside here we can have this
168:43 - input
168:46 - right and placeholder
168:52 - and then
168:53 - we copy this
168:57 - three times
168:58 - and this is gonna be
169:01 - title
169:04 - right title
169:06 - and this is the part
169:12 - right and look
169:14 - we completed the three fields
169:17 - with only
169:18 - about a little more than 10 lines of
169:20 - html okay so let's delete all of these
169:24 - we don't need them anymore
169:28 - and
169:30 - let's
169:31 - go back
169:34 - oh
169:35 - all right so we forgot to change
169:41 - oh we forgot to add the type label here
169:45 - so
169:45 - uh
169:46 - let's
169:48 - label
169:49 - all right going back
169:51 - refresh
169:53 - okay cool so we have this all right so
169:55 - we just learned how to use the render
169:57 - fragment
169:59 - by creating a filled component
170:02 - right and this field component can be
170:04 - used everywhere else
170:07 - whenever you want to create a field and
170:10 - let's just summarize what we need to do
170:12 - in order to
170:15 - use the render fragment so that the
170:17 - developer can provide a template
170:21 - for your component to use
170:24 - right so it's actually pretty easy you
170:25 - create a component
170:27 - right
170:29 - and you create a special parameter that
170:32 - the the type of the parameter is render
170:34 - fragment
170:35 - and then use this
170:38 - in the html markup place where you want
170:41 - to render that template
170:43 - and then when you use it
170:45 - as a child component from a parent
170:48 - component
170:49 - you just
170:51 - declare it as html and then use that
170:55 - render fragment parameter
170:59 - as a
171:00 - html
171:03 - instead of use it as a parameter like
171:05 - label you use it as html
171:08 - right and then within that wrapper
171:12 - with the render fragment provide you
171:14 - actual html
171:16 - then blazer is going to
171:20 - render this
171:21 - html
171:24 - inside
171:26 - here to replace
171:28 - the render for recommended parameter
171:36 - i want to cover the second key factor of
171:38 - the templated component which is the
171:41 - generic
171:42 - typed list of items
171:44 - the purpose of this items is to provide
171:48 - a list of items
171:50 - for the
171:52 - generic type render fragment to use
171:55 - but is that the only purpose can it be
171:57 - used
171:58 - for any other purposes
172:00 - today we're going to talk about
172:03 - using the generic typed items
172:07 - by itself
172:09 - uh we're going to learn that by creating
172:11 - a
172:12 - automatic rendered grid let's call it
172:16 - auto grid the way i do it is that i'm
172:20 - not going to have the render fragment
172:23 - i'm only going to have this items and
172:25 - then i'm going to use reflection to
172:28 - create a automatically generated grade
172:31 - okay let's jump into the
172:34 - all right so let's create a
172:38 - control
172:43 - uh component
172:46 - let's call it
172:51 - grade
172:52 - automatic automatic grid
172:59 - all right so
173:01 - we don't need the title first we need a
173:04 - parameter
173:06 - let's create this type param
173:09 - right this is the type of the this is
173:12 - the generic generic type
173:14 - of this
173:16 - this list
173:18 - right and this we would call it items
173:22 - so instead of
173:24 - uh using the render fragment
173:26 - with those items
173:28 - we can
173:30 - use this item by itself so how do we do
173:33 - that
173:34 - right so we need to use reflection
173:36 - in c sharp we need to see all of the
173:38 - properties of this item itself before
173:42 - the
173:43 - component is rendered
173:45 - and
173:46 - there is a event in the event lifecycle
173:50 - that is called on parameter set
173:52 - and
173:54 - that function that method is called
173:57 - when the parameters are set and before
173:59 - the
174:01 - components rendered so let's override
174:10 - event
174:12 - if
174:13 - the items is not now
174:17 - and items can't is greater than zero
174:22 - then this is the place where we use
174:25 - reflection
174:28 - okay
174:28 - type of item
174:30 - is a reflection to
174:32 - analyze what kind of parameters what
174:35 - kind of properties
174:37 - the item has
174:39 - right and
174:42 - the type of
174:44 - the type has
174:46 - a members method
174:50 - which
174:52 - is gonna give us some information
174:55 - about
174:58 - our
175:02 - all right so this member info we need to
175:05 - include we need to use the uh
175:08 - system.reflection name
175:10 - space
175:12 - roof
175:17 - and
175:18 - okay so now we have this we've got the
175:20 - member info and we can do this
175:24 - all right so this member info has um the
175:29 - information about of all of the members
175:31 - gloating like constructors methods
175:34 - properties
175:35 - and other stuff
175:37 - right so and then we can use this to
175:39 - uh in our markup so in our markup we
175:42 - want to render we want to render a table
175:46 - right so the grid is like a table right
175:48 - so
175:48 - um this is like we only render the table
175:52 - if the member information has inform has
175:55 - value
175:56 - uh
176:01 - like this
176:03 - and we're gonna render a table and we're
176:06 - gonna call it um
176:08 - uh
176:10 - i'm gonna use the table
176:13 - class
176:15 - and let's first render the header
176:18 - right
176:19 - and uh it's gonna have a list of columns
176:22 - and that list of columns corresponds to
176:24 - the 2d properties we're going to loop
176:27 - through
176:30 - the list of numbers
176:33 - right
176:36 - you know this member has a member type
176:39 - property and this in indicates whether
176:42 - it's a constructor or it's a property or
176:45 - it's a method
176:46 - so we will only
176:49 - create a column for
176:51 - the members that are properties
176:53 - so if
176:55 - if number dot number type
176:57 - equals remember type stock
177:00 - see we have property field method
177:03 - unless it's type and all this stuff
177:04 - constructor
177:06 - event so uh we will only render
177:10 - if it's property
177:13 - right
177:13 - and
177:14 - then in this case we render
177:17 - number dot
177:20 - name
177:21 - and we're going to use it in our index
177:24 - the home page here we need to create
177:27 - some data to it
177:29 - all right
177:30 - so
177:32 - i have prepared some data so we have
177:36 - this first we declare a class it can be
177:38 - any class and then um
177:41 - i'm going to override
177:43 - the
177:44 - uninitialized
177:49 - event circle
177:51 - and
177:54 - weather
177:59 - and in here we're going to initialize
178:01 - that
178:03 - actually we're gonna have a
178:05 - uh
178:07 - list
178:08 - right
178:14 - and then in here we're gonna create a
178:16 - list of employees
178:22 - let's just call it employees okay
178:25 - initialize this list employees so we
178:28 - have this list of employees
178:31 - and we want to provide this
178:34 - to the great component
178:36 - okay because we already have this items
178:39 - in
178:40 - others parameter inside the grid
178:42 - component so now
178:44 - we are going to call the grid auto
178:46 - component and we know that there is a
178:48 - parameter that is items
178:50 - and we are going to provide employees
178:56 - list to it
178:57 - and let's see when we run it
179:01 - what it looks like
179:04 - okay so we see this id name title
179:06 - department right
179:08 - and uh
179:10 - now we go back
179:11 - to our grid component and complete the
179:13 - rest of the markup so in the in the body
179:17 - we're gonna get the value of of each
179:19 - each property
179:22 - right so in here
179:24 - we are gonna say you know uh for each
179:29 - item in stock items
179:34 - okay so it's gonna have as many rows as
179:36 - the number of items
179:39 - um
179:41 - so we're going to create a row under
179:43 - here
179:44 - and then we're going to loop through
179:46 - the
179:46 - basically the same thing we're going to
179:48 - loop through
179:50 - the properties
179:52 - and then we got the
179:53 - value of each property
179:56 - right so in here instead of
179:59 - th it's going to be td
180:02 - and
180:03 - we are going to call
180:05 - item.type
180:08 - got property
180:12 - and then
180:13 - which property is this property
180:15 - providing the name of that property and
180:16 - then there is a
180:18 - uh there is another
180:20 - gap
180:20 - value
180:22 - and um
180:25 - so it's for this item
180:27 - uh oh
180:28 - so and i believe this is it and let's go
180:33 - back and refresh
180:36 - all right so we have our automatic uh
180:38 - grid so this is great but i don't want
180:40 - to show the id
180:42 - right i don't want to show certain
180:44 - columns so
180:45 - what do i do
180:47 - okay so we can create some
180:50 - create another
180:51 - property here
180:53 - parameter here and let's call it
180:59 - let's call it
181:04 - you know
181:05 - columns
181:07 - to
181:07 - exclude
181:09 - and it's going to be a csv
181:12 - and
181:14 - how do we use this
181:15 - so if this contains
181:19 - so i guess
181:21 - it's going to be in here and then i'm
181:23 - going to say that
181:26 - if it's a property
181:28 - and
181:29 - if the name
181:35 - uh
181:36 - sorry no it's not it's the other way
181:38 - around
181:40 - and
181:41 - if
181:42 - the columns
181:44 - contains if it doesn't contain
181:50 - and it's going to be
181:53 - case insensitive
181:56 - and
181:57 - negation
181:59 - so if it doesn't contain
182:02 - the
182:04 - columns to exclude
182:06 - then
182:07 - we're going to render it right so the
182:10 - same logic
182:12 - would be
182:13 - also
182:14 - applied to here
182:19 - right
182:20 - and
182:21 - going back to our
182:24 - place
182:25 - then we can provide that extra parameter
182:27 - that columns
182:29 - to exclude and and call it id
182:34 - right
182:35 - and in this case i think it's going to
182:39 - work let's refresh all right so we don't
182:41 - have the id column
182:42 - and if we don't want the name column
182:45 - uh well that's probably not a good idea
182:47 - let's see we don't want the department
182:48 - column
182:49 - we can add the department column and
182:51 - then we refresh you notice the
182:53 - department column is going to be gone
182:55 - all right cool
182:58 - and i like the department column so
183:00 - let's put it back another thing is that
183:02 - uh we are using boma
183:05 - right and for bulma table it has
183:07 - different kinds of uh
183:10 - classes to modify the
183:12 - uh the appearance
183:15 - so let's do a search
183:17 - bulma
183:18 - table
183:20 - and
183:21 - go to boma
183:22 - and you can see that it has different
183:26 - modifiers right so
183:29 - it's bordered is striped so how do we
183:31 - giving the developer the ability to add
183:34 - these modifiers
183:35 - so that's an easy job we go to here and
183:40 - actually we're going to have another
183:42 - parameter
183:44 - and
183:46 - let's call it
183:48 - it's going to be string type and let's
183:50 - call it css
183:51 - plus
183:53 - right and
183:56 - we are going to come over here
183:58 - and i'm going to modify this to
184:00 - dynamically create the classes here
184:02 - so
184:03 - um
184:04 - so css
184:06 - plus actually
184:09 - let's use this
184:11 - uh it's going to be
184:13 - a table right so that's the basic thing
184:16 - and then we are going to have
184:19 - a
184:20 - desktop
184:23 - okay okay
184:26 - it's gonna be like this
184:29 - and css plus
184:31 - if we don't provide anything uh i hope
184:34 - it's still work all right so we're not
184:36 - providing anything it still works so
184:38 - let's make it
184:40 - uh strapped
184:42 - let's go over here
184:44 - and then we add another
184:49 - let's call it cs
184:51 - class and we add the is
184:54 - strap
184:56 - over here and see whether that works
184:58 - refresh the screen again right so as the
185:01 - uh
185:03 - the modifiers to it all right what else
185:05 - we can add we can add is bordered right
185:08 - it's narrow
185:09 - uh it's horrible that's this is
185:12 - interesting
185:13 - let's add this
185:14 - and
185:16 - you know add this over here and
185:19 - go back and refresh
185:21 - cool see i'm hovering my mouse over
185:24 - the rose and it's highlighting it we
185:27 - have learned
185:28 - one of the purpose of having
185:31 - the generic typed
185:33 - uh list of items
185:36 - right we can use reflection
185:38 - to
185:40 - create a
185:42 - grade automatically
185:44 - and uh if yeah i think you can
185:49 - i would i would see myself
185:51 - use this kind of grade uh
185:54 - pretty often
185:55 - uh in those cases that i don't care
185:57 - about providing some specific control
186:00 - over
186:01 - the look and feel of each
186:04 - column
186:05 - and if you care about that then
186:07 - in my next video we're going to create a
186:11 - another
186:12 - grade that is not automatic
186:15 - and allows the developer to provide a
186:18 - template for each column if you just
186:21 - need to simply display the list of
186:23 - information in a
186:25 - grade like this so you can basically
186:27 - have this automatic generated great
186:30 - component and use it in a lot of
186:32 - different places
186:34 - you can even provide another parameter
186:38 - for the developer to use to provide the
186:41 - list of names of the columns because
186:43 - sometimes you don't want to use the
186:45 - variable name um
186:48 - yeah so that's uh that's it for today
186:51 - that we learned
186:53 - how to one of the ways to use the
186:55 - generic typed list items by creating a
186:59 - automatic generated grid
187:07 - the most common usage of this
187:10 - is to use this
187:13 - templated component as a repeater and
187:17 - there's actually another way to use it
187:19 - i'm going to cover both ways and let's
187:22 - start with the repeater concept so let's
187:27 - imagine you have a list of customers
187:33 - you want to render this list of camera
187:35 - customers
187:36 - repeatedly following a custom template
187:41 - and if we try to write a kind of element
187:45 - out it may look like this
187:48 - so
187:50 - you want to feed the customers to the
187:52 - repeater component
187:56 - like this
188:00 - and then
188:04 - within this you want to repeatedly
188:07 - render each customer and you want to
188:09 - provide a template for each customer and
188:13 - that template can look in your own way
188:15 - so let's say you want the customers
188:20 - company name first
188:22 - and then with the indentation
188:25 - you want the customer
188:28 - contact name
188:31 - and after that you want to see the
188:32 - customers phone number
188:36 - and obviously this is a template
188:38 - and
188:39 - this
188:40 - template is going to be repeatedly
188:42 - rendered as many times as the number of
188:45 - the customers
188:46 - in the list
188:49 - so
188:50 - um
188:51 - laser templated component
188:54 - provide us a convenient way to do this
188:57 - and let's jump into video studio and
188:59 - look at how we would render
189:01 - this kind of how we would create this
189:03 - kind of component
189:04 - in laser so i have
189:08 - a
189:10 - so this project i just created
189:12 - it's uh a web assembly
189:15 - project
189:16 - it would be very similar to create the
189:18 - same thing
189:19 - in bleeder server side but this time
189:22 - let's try web assembly
189:27 - let's create a new folder let's call it
189:30 - controls
189:31 - as url
189:33 - i like to call components controls the
189:35 - none page component controls
189:38 - and let's create a
189:41 - component and just call it repeater
189:48 - first the generic type to temporary
189:50 - components it needs to
189:53 - have a parameter that holds the data
189:58 - so let's create a parameter first
190:02 - to host the data
190:04 - and that data is of a generic type and
190:08 - it's a list right so it is a generic
190:11 - type and let's
190:14 - and let's call this t item
190:19 - and
190:21 - that
190:23 - we call it
190:24 - items
190:25 - and this you see it's giving an error
190:28 - because we need to
190:29 - actually
190:30 - say typo parameter
190:33 - is
190:34 - t item and this will make the error go
190:37 - away
190:38 - it's a generic type meaning that you can
190:40 - pass in whatever type you want
190:43 - so
190:44 - generic in c-sharp is actually a
190:46 - convenient way to
190:48 - use type as a parameter so we want to
190:51 - render the items
190:53 - one by one so we need to do a loop
190:56 - okay
190:57 - so we'll say
190:59 - item in the items
191:04 - and
191:05 - here we want to render the template that
191:08 - the user provided so we need to provide
191:10 - a template parameter
191:12 - so create a parameter again
191:14 - and then here is a render fragment but
191:17 - it's not this
191:18 - render fragment without the
191:21 - the type so it has to be this one was
191:23 - the generic type and
191:25 - it's what's the generic type t item that
191:28 - we used just now and then here
191:31 - we give it a name so let's call this the
191:36 - the row
191:39 - right because we are rendering the
191:42 - one by one as we're running rows of of
191:45 - uh
191:47 - of something
191:48 - so here
191:50 - we can say
191:52 - sorry at
191:54 - row
191:55 - but
191:56 - we can't just do this it's not going to
191:59 - render the item we have to use it sort
192:02 - of like a function and we provide
192:05 - the item here
192:07 - we feed the item here we're telling the
192:10 - uh the row template
192:12 - that this is the item that we're dealing
192:14 - with right now
192:17 - and then at the moment we use it
192:20 - let's say i want to use it here
192:24 - we are going to import the namespace
192:26 - first
192:31 - controls
192:34 - so once we have it
192:35 - uh we go into the index
192:38 - component and let's delete this
192:41 - add some
192:43 - line bricks
192:44 - and then
192:46 - here we're going to use the repeater
192:49 - component
192:50 - and
192:51 - notice that it has a items
192:54 - parameter here
192:56 - but
192:57 - we are going to create
193:01 - uh
193:02 - some data here so i have prepared
193:05 - something let's so we have the customer
193:07 - here
193:08 - and then let's initialize it from uh
193:11 - from the i initialized
193:13 - let's override the initialize method and
193:16 - then so now we have a list of customers
193:19 - and we populated the values of the
193:21 - customers
193:22 - and we can provide the items here
193:26 - so
193:27 - then we need to provide the row template
193:31 - so when we go over here we can say
193:35 - row
193:38 - and uh
193:42 - like we just did
193:44 - and
193:47 - in here
193:48 - we wanted to
193:50 - use customer company name customer
193:53 - contact name custom phone number and the
193:55 - way to do it is to say hey we are
193:58 - in the context of the current customer
194:02 - right so we give it a contact name
194:05 - and then
194:06 - here we are going to implement exactly
194:09 - the same thing as
194:11 - as we
194:13 - planned we want to have
194:15 - the company name and then some
194:17 - indentations and with the contact name
194:20 - and phone number like this
194:25 - but we want an indentation and uh we are
194:28 - using the default template comes with
194:30 - bootstrap css
194:33 - so we can add the
194:35 - left margin so it's margin left is let's
194:39 - add
194:40 - five
194:41 - make a little bit bigger
194:43 - so that it's noticeable
194:45 - and um
194:47 - yeah so we have phone number contact
194:49 - name phone number company and that's i
194:52 - believe that's what we planned
194:54 - and
194:55 - let's
194:56 - build this project
194:59 - the the web assembly you have to build
195:02 - it
195:03 - i don't see a way to just refresh
195:07 - as in server side later
195:10 - so let's refresh
195:12 - and then let's go here and you see the
195:16 - companies are
195:17 - sorry the customers are rendered like we
195:20 - planned and let's give it a little bit
195:22 - uh clearer uh formatting
195:25 - so let's have a line break between each
195:28 - customer and let's
195:31 - highlight the name of the company so
195:33 - that we can see a
195:36 - better
195:37 - format
195:39 - and
195:40 - you see if i just refresh it would not
195:42 - pick up the changes
195:44 - and if i build it
195:48 - it will so this is the difference one of
195:50 - the differences between
195:52 - uh blader side server side blazer and uh
195:55 - client-side blazer so now i pick up all
195:57 - of the changes that i have
196:00 - this is the the first weight is the main
196:02 - way to use a generic type the
196:04 - templated component
196:07 - and usually a repeater also comes with a
196:09 - header and a footer right and uh i would
196:13 - implement that as well
196:14 - so that
196:18 - we would have a render fragment without
196:21 - the
196:23 - generic type
196:24 - and we'll call it header
196:28 - and i would have another one here let me
196:31 - call the footer
196:32 - and if you want to put something
196:35 - as a header or footer you can use it
196:38 - and in our case let's
196:40 - use the header
196:42 - today
196:43 - um
196:45 - and in the header i just want to let's
196:47 - say we just give it a title this h2 and
196:51 - let's say
196:52 - this is customers
196:54 - and render this
196:56 - right over here
196:59 - you see because
197:01 - we are giving the user
197:04 - the control of the template so
197:07 - we don't want to add a div
197:10 - anything around this header or in
197:12 - between because that will interfere with
197:16 - the user's
197:18 - control
197:20 - so now i have the customer right here
197:22 - and have all of this
197:24 - and if you want we can add some margin
197:26 - over here as well but in this case i'm
197:28 - going to skip that so the second way
197:30 - using the uh generic type parameter is
197:34 - uh it's actually it's actually pretty
197:36 - interesting that if you look at the
197:38 - documentation from microsoft
197:40 - right here it only talks about a way how
197:43 - to use it as a repeater
197:45 - right you basically repeatedly render
197:48 - the
197:49 - item in the item list
197:52 - but there is a way to to render a form
197:56 - use it by using the generic type
197:58 - parameter uh today i'm going to show
198:01 - how to
198:02 - uh use that to create a kind of an added
198:06 - form template
198:09 - to edit each one of these
198:12 - uh customer and to do that
198:15 - let's
198:16 - create another parameter
198:25 - and that parameter is a t item you see
198:28 - this becomes interesting because the
198:30 - documentation doesn't mention anything
198:33 - if you use the t item it has to be a
198:35 - list right but
198:37 - we are
198:38 - going to come to this interesting part
198:41 - of it
198:42 - by declaring a parameter without a list
198:45 - so we have a t item here and then we're
198:47 - going to say
198:49 - an item to edit so this is the item for
198:53 - editing only and then we're going to
198:55 - provide another
198:57 - render fragment
198:59 - that that we can use this item to add it
199:03 - um that is going to be
199:06 - a render fragment
199:08 - it was a generic type and yes it is the
199:11 - same generic type
199:14 - so and let's call this edit
199:19 - template
199:21 - and
199:23 - you can
199:26 - usually we display a edit
199:28 - form in a
199:30 - uh in a dialog
199:32 - like a model dialog
199:34 - but in this case i'm just going to
199:35 - display right under the uh the feature
199:39 - because we have a footer i forgot a
199:40 - runner and filter so let's display a
199:43 - right and there we'll have a line break
199:44 - so display this form right under here so
199:47 - we're going to say edit
199:49 - template
199:51 - right but then again because it's a
199:53 - generic type you have to use it as a
199:56 - method and
199:58 - so what are we going to provide here so
200:00 - we have to declare we sorry we already
200:03 - declared this so i'm going to provide
200:04 - this as a parameter here
200:07 - so basically we tell them later that we
200:09 - are rendering this
200:12 - we are rendering this um
200:15 - edit template sorry this this render
200:18 - fragment right over here
200:20 - and the data we're gonna use
200:23 - is the item to edit
200:25 - right
200:26 - and then when we use it basically we
200:29 - have to provide this item to edit
200:33 - with the item that we want to edit in
200:36 - our case of the customer that we want to
200:38 - add it
200:39 - so
200:40 - to do that we want to change our temp to
200:42 - provide a um an edit button and that
200:46 - will go
200:48 - under the first step
200:50 - and we're going to provide we're going
200:52 - to write a space here
200:54 - and then
200:56 - button
200:59 - and uh since we're using
201:04 - we are using uh
201:08 - we'll just call it a button
201:12 - we're using the stripe so using the
201:14 - strip class
201:15 - and then um
201:18 - and then we call it edit
201:21 - okay
201:22 - and
201:24 - the event handler of editing
201:26 - we are going to say add we're going to
201:29 - say
201:30 - edit with a parameter
201:37 - and that
201:38 - i'm going to say add it
201:40 - um
201:42 - and what edit the um
201:48 - add in the customer
201:49 - right because we have the contacts here
201:51 - so we are editing this current customer
201:54 - right um
201:56 - let's just call it a customer and then
201:59 - we're gonna
202:00 - we're gonna create this
202:01 - method right here
202:04 - private
202:11 - so this is the customer we over here we
202:14 - have to pass this customer to
202:16 - the repeaters added to
202:19 - item to add edit so in order to do that
202:22 - we have to reference our component so we
202:24 - create a reference right here it's a
202:26 - reference and we just call it repeater
202:29 - simple and clear
202:31 - and
202:33 - declare that right over here as well
202:36 - repeater
202:38 - and this is our customer we're going
202:40 - with this customer right so provide this
202:43 - and repeater
202:44 - and
202:46 - we call the repeater right over here we
202:49 - say when we add it we want the item to
202:52 - edit
202:53 - um
202:55 - to be the current customer we are trying
202:57 - to add it
202:59 - and then i
203:00 - believe we're going to see an error here
203:02 - yes
203:04 - why because
203:05 - it says component parameter
203:07 - should not be set outside its component
203:10 - right so what we have to do is we have
203:12 - to remove this
203:14 - attribute right so um we are
203:19 - having this over here and we are having
203:21 - this over here we don't want to display
203:24 - the template unless we
203:26 - uh we're trying to add it right we're in
203:28 - the add-in mode so we have just have a
203:30 - logic here we're going to say this dot
203:33 - item to edit
203:35 - only when it's
203:37 - not
203:38 - now
203:39 - do we
203:41 - do we display this added template plate
203:44 - implemented edit template like this
203:47 - and uh we are going to display
203:52 - we're going to have
203:53 - let's say
203:56 - name i'll make it simple and i just use
204:00 - an input
204:02 - whereas a class so it's bootstrap is
204:06 - form control
204:09 - okay and uh we're going to bind it to
204:14 - uh yeah we're going to specify a context
204:16 - right here so the context is
204:19 - the current
204:21 - customer
204:23 - and then
204:25 - i'm going to call it the current
204:27 - call the current customer and then
204:30 - specify the property to bind to
204:34 - and uh
204:38 - and come over here
204:40 - and make sure this is
204:42 - assigned correctly
204:45 - and then we build it
204:47 - and let's refresh
204:49 - all right so let's click on
204:52 - first customer yep this time we see the
204:54 - um company name
204:58 - so
204:59 - so uh in the future one of the future
205:01 - videos i'm going to talk about lifecycle
205:03 - and uh
205:05 - here
205:06 - we are seeing that
205:08 - we are actually triggering the event
205:09 - from um the parent component and usually
205:13 - um
205:14 - it and also
205:16 - we notice that this item to edit was
205:19 - defined
205:22 - was defined not as a parameter so
205:24 - usually changing the public property
205:28 - that is not a parameter outside of the
205:30 - component will not actually trigger a
205:33 - rerender but in this case it did and the
205:35 - reason
205:36 - being is that one of the reasons one of
205:39 - the ways to trigger a rerender of a
205:41 - component is is a event right handling
205:45 - event
205:46 - although this event is handled outside
205:48 - of that component
205:50 - right the repeater component
205:53 - but
205:53 - because
205:55 - you see this advantage triggered right
205:57 - here right right over here on click
206:00 - event and this button
206:02 - this button also is it's defined outside
206:04 - of the repeater component but because
206:06 - it's provided as a template
206:08 - so that is considered that is actually
206:11 - rendered by the repeater component and
206:14 - so any event handling
206:16 - for this
206:18 - button is also um
206:21 - considered as a
206:24 - um
206:25 - like its own event handling that's the
206:28 - repeater components on event handling
206:30 - therefore when you uh trigger this event
206:33 - it automatically render the repeater
206:35 - component
206:38 - so i'm going to talk about more about
206:39 - that um about the lifecycle in future
206:42 - reviews
206:43 - so yeah so let's let's take a look at
206:46 - this
206:46 - and uh we have a form and if we have a
206:49 - dialog then we can display this in a
206:50 - dialog and any changes
206:53 - uh is actually applied right there right
206:55 - so we can change the name you can change
206:57 - a phone
206:58 - number right there and
207:02 - you know
207:04 - and
207:05 - and it actually works and then you can
207:07 - you can click on different things so the
207:09 - company and everything changes and if
207:11 - you come back you see the changes
207:12 - actually retained
207:15 - so yeah this is very interesting way to
207:18 - use the template component
207:20 - if you're more creative
207:23 - then you can actually take advantage of
207:25 - this very well
207:33 - so the second way using the
207:36 - generic type parameter is
207:38 - is actually it's actually pretty
207:40 - interesting that if you look at the
207:42 - documentation from microsoft right here
207:45 - it only talks about the way how to use
207:47 - it as a repeater
207:49 - right you basically repeatedly render
207:52 - the
207:53 - item in the item list
207:56 - but there is a way to to render a form
207:59 - use it by using the generic type
208:02 - parameter uh today i'm going to show
208:05 - how to
208:06 - uh use that to create a kind of added
208:10 - form
208:12 - template
208:13 - to edit each one of these
208:16 - uh customer and to do that
208:19 - let's
208:20 - create another parameter
208:29 - and that parameter is a t item you see
208:32 - this becomes interesting because the
208:34 - documentation doesn't mention anything
208:36 - if you use the t item it has to be a
208:39 - list
208:40 - right but we are
208:42 - going to come to this interesting part
208:45 - of it
208:46 - by declaring a parameter without a list
208:49 - so we have a t item here and then we're
208:51 - going to say
208:53 - item to edit so this is the item for
208:57 - editing only and then we're going to
208:59 - provide another
209:01 - render fragment
209:03 - that that we can use this item to add it
209:07 - um that is going to be
209:10 - a render fragment
209:12 - with a generic type and yes it is the
209:15 - same generic type
209:17 - um
209:18 - so and uh let's call this
209:21 - added
209:23 - template
209:25 - and um
209:27 - you can
209:30 - usually we display a edit
209:32 - form in a uh in a dialog
209:36 - like a model dialog
209:38 - but in this case i'm just going to
209:39 - display right under the uh the feature
209:43 - because we have a footer i forgot a
209:44 - runner and filter so let's display right
209:47 - and we'll have a line break so display
209:49 - this form right under here so we're
209:51 - going to say edit
209:53 - template
209:54 - right but then again because it's a
209:57 - generic type you have to use it as a
210:00 - method and so what are we going to
210:03 - provide here so we have to declare we
210:06 - sorry we already declared this so i'm
210:08 - going to provide this as a parameter
210:10 - here
210:10 - so basically we tell them later that we
210:13 - are rendering this
210:16 - we are rendering this
210:19 - edit template sorry this this render
210:22 - fragment right over here
210:24 - and the data we're going to use
210:27 - is the item to
210:28 - edit right
210:30 - and then when we use it basically we
210:33 - have to provide this item to edit
210:37 - with the item that we want to edit in
210:40 - our case the customer that we want to
210:42 - add it
210:43 - so to do that we want to change our
210:45 - template to provide a
210:47 - um an edit button and that
210:50 - will go
210:52 - under the first step
210:54 - and we're going to provide we're going
210:56 - to write a space here
210:58 - and then
211:00 - button
211:03 - and
211:04 - since we're using
211:08 - we are using
211:12 - or we'll just call it a button
211:16 - we're using the stripe so using the
211:18 - strip class
211:19 - and then um
211:22 - and then we call it edit
211:25 - okay and
211:27 - the event handler of editing
211:30 - we are going to say add we're going to
211:32 - say
211:34 - edit with a parameter
211:40 - all right
211:40 - and that
211:42 - i'm going to say add it
211:44 - um
211:46 - and then what edit the um
211:52 - add in the customer right because we
211:54 - have the contacts here so we are editing
211:56 - this current customer
211:58 - right um
212:00 - let's just call it a customer and then
212:03 - we're gonna
212:04 - we're gonna create this
212:05 - method right here
212:08 - private
212:10 - void
212:11 - and then we're editing what we're adding
212:14 - a customer
212:15 - so this is the customer we over here we
212:17 - have to pass this customer
212:19 - to the repeaters added to
212:23 - item to add edit so in order to do that
212:26 - we have to reference our component so we
212:28 - create a reference right here as a
212:30 - reference and we just call it repeater
212:33 - simple and clear and um
212:37 - declare that right over here as well
212:40 - repeater
212:42 - and this is our customer we don't know
212:44 - this customer right so provide this
212:47 - and repeater
212:48 - and we call the repeater
212:52 - right over here we say when we add it we
212:55 - want the item to edit
212:59 - to be the current customer we are trying
213:01 - to add it
213:03 - and then i
213:04 - believe we're going to see an error here
213:06 - yes
213:08 - why because it says component parameter
213:11 - should not be set outside its component
213:14 - right so what we have to do is we have
213:16 - to remove this
213:18 - attribute right so um we are
213:23 - having this over here and we are having
213:25 - this over here we don't want to display
213:27 - the template unless we
213:30 - uh we're trying to add it right we're in
213:32 - the edit mode so we have just have a
213:34 - logic here we're going to say let's
213:37 - start item to edit
213:39 - only when it's
213:41 - not
213:42 - now
213:43 - do we
213:45 - do we display this added template plate
213:48 - implemented edit template like this
213:51 - and uh we are going to display
213:55 - and we're going to have
213:57 - let's say
214:13 - okay and uh
214:15 - we're going to bind it to
214:18 - uh yeah i'm going to specify a context
214:20 - right here so the context is
214:23 - the current
214:25 - customer
214:26 - and then
214:29 - i'm going to call it the current
214:31 - call the current customer and then
214:34 - specify the property to bind to
214:38 - and
214:42 - and come over here and make sure this is
214:46 - assigned correctly
214:48 - and then we build it
214:51 - and let's refresh
214:53 - all right so let's click on first
214:56 - customer yep this time we see the
214:58 - um company name
215:01 - so
215:03 - so uh in the future one of the future
215:05 - videos i'm going to talk about lifecycle
215:07 - and uh
215:09 - here we are seeing that
215:12 - we are actually triggering the event
215:13 - from um the parent component and usually
215:17 - um
215:18 - it and also
215:20 - we noticed that this item to edit was
215:23 - defined
215:26 - was defined not as a parameter so
215:28 - usually changing the public property
215:32 - that is not a parameter outside of the
215:34 - component will not actually trigger a
215:36 - rerender but in this case it did and the
215:39 - reason being is that one of the reasons
215:42 - one of the ways to trigger a rerender of
215:44 - a component is is a event right handling
215:49 - event
215:50 - although this event is handled outside
215:52 - of that component
215:54 - right the repeater component
215:57 - but
215:57 - because
215:59 - you see this advantage trigger right
216:01 - here right right over here on click
216:04 - event and this button this button also
216:06 - is it's defined outside of the repeater
216:09 - component but because it's provided as a
216:11 - template
216:12 - so that is considered that is actually
216:15 - rendered
216:16 - by the repeater component and so any
216:18 - event handling
216:20 - for this
216:22 - button is also um
216:25 - considered as a
216:28 - um
216:29 - like its own event handling that's the
216:32 - repeater components on event handling
216:34 - therefore when you
216:36 - trigger this event it automatically
216:38 - render the repeater component
216:42 - so we're going to talk about more about
216:43 - that
216:44 - about the lifecycle in future reviews
216:47 - so yeah so let's let's take a look at
216:49 - this
216:50 - and uh we have a form and if we have a
216:53 - dialog then we can display this in a
216:54 - dialog and any changes
216:57 - uh is actually applied right there right
216:59 - so you can change the name can change a
217:01 - phone number
217:04 - right there and
217:05 - you know
217:08 - and uh
217:09 - and it actually works and then you can
217:10 - you can click on different things that's
217:13 - company and everything changes and if
217:15 - you come back you see the changes
217:16 - actually retained
217:19 - so yeah this is very interesting way to
217:22 - use the template component
217:24 - if you're more creative
217:27 - then you can actually take advantage of
217:29 - this very well
217:36 - blazer components are stateful component
217:39 - and if we don't have a good
217:41 - understanding of the components
217:44 - lifecycle as developers of our mind can
217:46 - be confused
217:47 - and we don't know where to put the logic
217:49 - that we want to implement
217:51 - today i want to cover one of the core
217:54 - concept of component lifecycle which is
217:57 - uh you know when do a components render
218:00 - components actually render under four
218:02 - conditions components render
218:04 - when components are just created
218:07 - or when components events are triggered
218:10 - or when components parameter values are
218:12 - changed
218:14 - or when developers manually
218:16 - trigger the rendering of the components
218:20 - so let's cover uh them one by one first
218:24 - one is when components are just created
218:27 - all right so so let's uh let's take a
218:29 - look at video studio so this is uh this
218:32 - is the project that i just created with
218:34 - uh with blazer web assembly
218:38 - and uh let's see the first one is
218:41 - uh the components renders when it's just
218:44 - created
218:46 - right so it's this one is easy right the
218:48 - reason
218:49 - uh it's obvious that when a component is
218:52 - created you want to render the component
218:54 - otherwise like what's the what's it's a
218:56 - ui component right so it needs to be
218:57 - displayed
218:58 - so but when
219:00 - um when is component actually created
219:03 - right so the components are created when
219:05 - you
219:06 - uh just load the component for the first
219:08 - time
219:09 - or when you
219:11 - navigate away
219:12 - and it'll get back
219:14 - right or you try to refresh the page and
219:16 - the components are recreated
219:18 - so let's um let's see whether that's uh
219:22 - those three things that i said it's true
219:24 - or not so let's uh let's take a look at
219:26 - the counter component okay um let's see
219:30 - if we override
219:31 - after
219:32 - render method
219:34 - and
219:35 - if we
219:36 - run this
219:37 - so we pressed alt shift d
219:40 - and so this is this is page as
219:43 - we see
219:45 - right
219:46 - and we're using chrome so we just copy
219:48 - this
219:51 - all right ctrl c
219:52 - and then we
219:54 - we use uh windows r see it's writing
219:57 - right here
219:58 - so windows r
220:00 - and
220:02 - paste that in and then click on ok
220:04 - so we'll open another browser so this is
220:06 - actually the browser that we need to use
220:08 - to in order to debug
220:10 - so from here we do ctrl shift
220:13 - d again
220:14 - and this is the window that is launched
220:17 - so from here we can actually set
220:19 - breakpoint so go to the files folder
220:22 - and then
220:24 - we can see all of the even the program
220:26 - files right
220:28 - so we can
220:29 - go to our counter component and see
220:31 - whether this is rendered um
220:34 - but debugging this is pretty tricky so
220:36 - if we just uh refresh this counter page
220:40 - you can see that
220:42 - uh the
220:44 - it's the trick the
220:48 - the breakpoint is not actually triggered
220:50 - so yeah it doesn't actually trigger the
220:53 - breakpoint for the first time when the
220:55 - components just created
220:57 - so in order to debug go to our code and
221:01 - then we can just write console
221:04 - dot
221:05 - red line
221:07 - and this is uh this is very similar to
221:09 - console.log in javascript
221:12 - and then
221:13 - we save it and we we build it so once we
221:16 - build it we come back to this
221:18 - uh
221:19 - developer
221:21 - tool
221:22 - and
221:22 - we
221:23 - go over here refresh it and come back to
221:26 - the developer tool if we look at the
221:28 - file
221:30 - uh the file is actually changed as you
221:32 - can see let's refresh again
221:35 - and then we go to the console and you
221:38 - can see that on counter component on
221:40 - developer render is rendered at this
221:42 - time
221:43 - so now we know that the
221:46 - when the component is just created the
221:48 - component is rendered
221:50 - right because this event is wrongly
221:52 - triggered after it renders so this kind
221:54 - of proves that the event is just uh
221:56 - it's just rendered another possibility
221:58 - is that if we never get away
222:01 - okay
222:02 - and we never never get back
222:05 - then
222:06 - see the breakpoint is also triggered and
222:08 - uh it's first render is true meaning
222:11 - that it's just rendered
222:13 - uh it's just created therefore it's
222:15 - rendered
222:16 - right so those three conditions
222:19 - first one is when you just come to the
222:21 - page
222:22 - second one is when you refresh the page
222:25 - third one is when you navigate away from
222:27 - the component or from the page and come
222:29 - back to that page that contains a
222:31 - component then the components are
222:33 - created therefore it's rendered
222:35 - the second one is the component renders
222:38 - when the components events are triggered
222:40 - so for example in this counter component
222:43 - some people think that this current
222:45 - count only when the current account
222:46 - changes do the components actually does
222:49 - the component re-render but that's not
222:51 - actually true so let's actually
222:53 - comment out this line and then rebuild
222:56 - the
222:57 - application
223:00 - and
223:01 - once that's done let's go back to here
223:03 - and uh let's
223:08 - refresh the page
223:09 - right
223:10 - once we refresh the page
223:13 - we can actually go to the source code
223:15 - and we can see that the counter
223:17 - component
223:18 - actually
223:19 - doesn't have that
223:21 - see this is the color component so this
223:23 - is already common out right so this line
223:25 - will not actually run
223:28 - at all
223:29 - so
223:30 - what we can do here is that if we click
223:33 - on it see these uh i'll render
223:36 - after render event is also
223:38 - triggered
223:39 - so this proves that
223:41 - as long as there is an event
223:44 - that is triggered
223:46 - then the component is re-rendered
223:51 - right and you can see that this
223:52 - parameter is false meaning that this is
223:55 - not the first time this is not the
223:57 - components just created this component
224:00 - already created and we clicked on a
224:02 - button and that button does nothing but
224:05 - the component is still re-rendered so
224:07 - that's the first point i want to um
224:11 - i want to emphasize here
224:14 - the second point is that
224:16 - the
224:17 - when events are triggered that's true
224:19 - but it's not every single type of event
224:22 - it has to be
224:23 - uh it has to be a ui event like clicking
224:26 - a button change your drop down list that
224:28 - sort of thing has to be a ui event
224:31 - so let's do a demonstration
224:34 - uh that what if we are increasing the
224:37 - account the counter count by a timer
224:41 - right so if we come to the application
224:44 - and we
224:45 - if we
224:48 - add a timer here
225:02 - so basically we create a timer that runs
225:04 - every two seconds
225:07 - right 2000 millisecond and then it
225:09 - triggers the increment count function to
225:13 - increment the
225:14 - current card value
225:17 - and
225:19 - let's run it and see what happens so
225:21 - let's refresh the page
225:23 - so it picks up that and uh you can see
225:27 - that the current card is not actually
225:29 - increasing
225:30 - but if we go to the page here
225:33 - we go to the console we can see that the
225:35 - counter value is being actually being
225:38 - increased every two seconds
225:40 - right
225:41 - but
225:42 - this event is not a ui event therefore
225:46 - it's not
225:48 - rendering the
225:49 - re-rendering the component
225:51 - even though the variables value is
225:53 - actually being changed and if we click
225:56 - on it you can see it's 18. why it's 18
225:58 - because it's 18 right here
226:00 - right it's 18 right here that's when it
226:03 - rendered because we clicked on that and
226:05 - that's a ui event that's why it has this
226:09 - so that's that one
226:10 - as long as not a ui event it cannot for
226:13 - example if if you have an event in a
226:16 - child component or in a parent component
226:18 - and you're implementing
226:20 - um
226:22 - a matter that uh
226:25 - registered to that event and when the
226:27 - event is fired uh from the parent of the
226:30 - child components
226:33 - and and
226:34 - you you have a function within this
226:36 - component to be called
226:39 - and uh even when there's values there's
226:42 - variables that are being changed
226:44 - and that even when that variable is
226:46 - actually being used on the ui
226:51 - your component will not be rendered
226:53 - re-rendered just because not a ui event
226:57 - right so similar to the
227:00 - timer event
227:03 - so another point i want to emphasize
227:07 - when the component ui events are
227:08 - triggered uh the
227:11 - components re-render that's usually the
227:13 - case but that ui event has to happen
227:17 - within the component
227:19 - right it cannot happen outside the
227:21 - component and hype outside the component
227:24 - that's um it's not going to be rendered
227:27 - so for example if you have a parent
227:29 - component the parent component has a
227:31 - button and if you click a button click
227:33 - on that button in the parent component
227:35 - the child component will not be
227:37 - re-rendered right and if you have a
227:39 - child component that has a button you
227:41 - click on that button the parent
227:42 - component cannot be rendered will not be
227:45 - rendered
227:48 - and we can do a demonstration
227:51 - but let's let's stop this timer so i
227:54 - want to create a component right here
228:16 - okay we can see the component is
228:18 - rendered
228:20 - and if you go to the other developer
228:22 - tool you can see that the conjugate
228:23 - component render and the child component
228:25 - also rendered the child component
228:27 - rendered after the the color component
228:29 - render after the parent component render
228:32 - but if we come over here and click on
228:34 - the
228:34 - click me button
228:36 - and we go over here you can see the
228:38 - counter component is rendered again
228:41 - right but it's not actually triggering a
228:43 - re-rendering of the child component the
228:45 - child component is not being rendered so
228:47 - if i'm going to click on this a few more
228:49 - times
228:50 - right i can see it's all about the
228:53 - counter component the child component is
228:55 - not rendered
228:56 - right
228:58 - and uh the same thing will happen again
229:01 - if we try if you try it if you put a
229:02 - button under the compo under the child
229:05 - component
229:06 - and uh
229:07 - you're gonna see that the child
229:09 - component renders let's actually do that
229:12 - let's go to the con
229:14 - the child component
229:16 - and let's put a
229:18 - button right here
229:20 - and
229:22 - let's have a method
229:31 - all right
229:33 - and we refresh
229:34 - and we come to the
229:36 - window clean it up click on click me
229:39 - you will see the child component
229:41 - actually rendered
229:44 - i also click on a few times
229:47 - three more times you can see
229:49 - so the important thing to notice here is
229:52 - that
229:53 - you although the event handler here is
229:56 - not doing anything you have to have a
229:58 - event handler in order for the component
230:00 - to re-render
230:02 - right although it doesn't do anything
230:07 - and also another thing you notice that
230:09 - they the
230:11 - uh rendering is only the component the
230:14 - child component renders the parent
230:16 - component actually does not render
230:18 - right
230:19 - so
230:20 - and uh but there's only one exception so
230:24 - this this is the point that i want to
230:25 - emphasize that the event has to uh
230:28 - trigger from inside the component only
230:31 - when the event that is triggered inside
230:33 - the component that's that same component
230:36 - gets re-rendered
230:38 - so um but there's only one exception
230:41 - when you use a templated component
230:44 - right so let's say that
230:47 - we have a
230:49 - template
230:58 - so i have covered the
231:00 - templated components a couple of videos
231:03 - couple of episodes ago
231:06 - so if you are not familiar with template
231:08 - components please go back and and look
231:10 - at my previous videos
231:30 - and refresh
231:32 - we see this click body template and
231:35 - let's clear the uh
231:37 - console and we click on the
231:40 - body template
231:43 - i click on once and we see that
231:46 - the color component that's render and
231:49 - child component also gets rendered
231:53 - right
231:53 - so if i click on two more times one two
231:58 - go here you can see that both counter
232:00 - component and child component gets
232:02 - rendered
232:04 - get rendered
232:07 - so why is that uh well the reason is
232:10 - that the
232:12 - the body template
232:14 - is kind of special that when you
232:17 - have buttons
232:18 - uh or html elements within the uh body
232:22 - template or template within a template
232:27 - it's also considered part of
232:30 - the child component
232:31 - right it's considered so this
232:33 - button is considered part of this
232:35 - component so when you click on the
232:37 - button it's as if you're clicking a
232:40 - button within that child component right
232:42 - it's actually part of that
232:44 - it's actually within it but because the
232:46 - fact that it is also part of the
232:49 - it's also defined right in the parent
232:51 - component
232:53 - so that's why the parent component is
232:54 - also rendered
232:57 - okay okay so that's the second uh bigger
233:01 - topic here
233:03 - you know
233:04 - the components re-render when the
233:06 - components events are triggered so i
233:08 - covered
233:09 - uh the three important thing i want to
233:11 - emphasize again so events
233:14 - uh
233:15 - we don't need
233:17 - variables to be changed as long as you
233:19 - have an event handler
233:21 - for event
233:22 - even the event handler you do nothing
233:24 - about it the components also gets
233:26 - re-rendered right the second important
233:28 - point is that the ui it has to be the
233:32 - event has to be a ui event
233:35 - any other events like a timer time
233:37 - defense or a uh
233:40 - event delegate you register to a to
233:42 - event delegate within some other
233:44 - components and that the events get
233:46 - triggered within this component this
233:48 - component will not be re-rendered when
233:50 - the event happens
233:52 - the third thing that i wanted to
233:53 - emphasize is that the event has to be
233:56 - triggered from outside sorry from inside
233:58 - the component
234:01 - not outside the component
234:03 - except
234:05 - for one case that if you have templated
234:07 - components then that template
234:10 - the but the the event happens within the
234:12 - template triggers both the parent and
234:15 - the child component
234:18 - so okay so now let's uh move on to the
234:21 - third thing which is the
234:23 - uh component parameter values changed
234:25 - but this this is a simple one uh
234:28 - if we go over here and uh
234:32 - we got a component
234:33 - and if we
234:36 - create another parameter
234:40 - and that parameter would be
234:42 - the counter
234:44 - if we just display the contour value
234:48 - right here
234:51 - so
234:52 - let's encounter
234:55 - and
234:55 - from the parent component if we feed
234:57 - that
235:00 - counter value right here with the
235:03 - current
235:04 - account
235:06 - then every time you um
235:10 - every time you click on the uh the
235:12 - button
235:14 - every time you click on
235:17 - this button
235:18 - the click need button
235:20 - um your child component also gets gets
235:23 - re-rendered
235:25 - right so without
235:27 - so let's delete everything that is
235:29 - distracting
235:39 - and we don't need this
235:43 - either
235:48 - i
235:49 - don't need the template component
235:54 - we don't have this and uh
235:57 - we don't need this
236:08 - rebuild it so uh here if i click on it
236:14 - you can see that
236:15 - the color value does not change so weird
236:17 - because we are not passing it and
236:19 - and uh if i click on it again you can
236:22 - see that the only thing that changes
236:25 - because we render is the
236:27 - component which is the parent component
236:29 - but if we can go to here go to the
236:32 - parent component and if we pass that
236:34 - parameter
236:35 - right over here to be the current
236:38 - account and if we build this
236:42 - we refresh the page
236:45 - and
236:47 - well we click on it we can see that
236:50 - all of them
236:51 - suppose
236:53 - both the parent component and the child
236:55 - components get re-rendered every time we
236:57 - click on it right
236:59 - so you can see
237:01 - both are
237:03 - re-rendered
237:04 - so that's the third and the fourth
237:06 - condition is when developers manually
237:08 - trigger the rendering so again if we
237:10 - remove this and if we just come over
237:12 - here and even we remove this
237:15 - and
237:17 - if um
237:20 - from here if we reference the child
237:22 - component
237:24 - let's say child
237:25 - and then
237:27 - over here say private
237:30 - component
237:32 - um
237:34 - child
237:38 - all right so this is that component and
237:40 - uh if we just uh every time
237:43 - we do this we say child that will
237:45 - contour
237:47 - current account
237:51 - if we do this
237:53 - let's see what happens
237:58 - so basically we are increasing
238:00 - the counter value
238:03 - of this property
238:05 - right it's not a parameter
238:08 - but
238:09 - we're not expecting that this value
238:12 - would change so
238:14 - you can see that it's not changing right
238:17 - although the value is gets uh increased
238:21 - the only reason why it's not changing is
238:23 - because the child components not render
238:25 - rendering that's because none of our
238:28 - four conditions are
238:29 - right we're not doing any of these so
238:32 - the child components is not being
238:33 - re-rendered
238:35 - um so in order to re-run it
238:38 - we have to as developer we can manually
238:40 - trigger that rewriter
238:43 - we can have a public
238:45 - uh
238:47 - method callery render
238:49 - this stage refresh
238:51 - and we call it
238:52 - we call it and then when we come over
238:54 - here we can call child
238:56 - dot refresh and that will trigger
239:00 - the re-rendering of the cal component
239:03 - and let's go over here
239:05 - refresh the page to pay to pick up the
239:07 - change and let's do this you can see
239:10 - that
239:11 - both the
239:13 - counter component and the component and
239:15 - the child component pick up the change
239:17 - and if we go over here we can see that
239:20 - the uh
239:22 - we can see both
239:23 - are re-rendering
239:24 - okay so that's everything i uh
239:27 - want to cover today remember there are
239:29 - only four conditions that the components
239:31 - get re-rendered
239:33 - first is that when components are
239:35 - created first second one is when
239:37 - components events are triggered third
239:39 - one is when components parameter values
239:41 - are changed third one is when developers
239:43 - manually trigger the re-rendering
239:51 - so i'm going to cover the
239:53 - sequence of each one of the lifecycle
239:55 - event
239:57 - in terms of in what sequence they are
239:59 - being triggered so i'm going to cover
240:01 - both the server-side laser as well as
240:03 - the webassembly blazer i'm going to
240:06 - divide this into two categories the
240:08 - first one is the first time rendering
240:11 - right and the second one is
240:14 - after the first time
240:16 - so the first time rendering is when the
240:18 - page is just loaded
240:20 - or when you navigate to the component to
240:23 - this page component let's first cover
240:25 - the first category
240:27 - with server side laser
240:30 - so i have server type laser default
240:32 - template
240:33 - i have all of the
240:35 - events
240:36 - written down and i break break points
240:39 - same with the shot component i have all
240:41 - of the events i have the breakpoints for
240:43 - each one of them and i have the child
240:45 - component
240:47 - used by the parent component so i'm
240:50 - going to run debug
240:52 - and let's pay attention to
240:54 - uh
240:55 - in which sequence these events are
240:57 - triggered again this is a server side
240:59 - blazer right so the set parameter is
241:01 - async in the parent component it's
241:03 - trigger first
241:04 - and then
241:06 - i'm going to hit continue
241:08 - and on initialized second
241:10 - on parameter third
241:12 - and when i press
241:14 - continue again
241:15 - now i'm expected to go to the child
241:17 - component
241:19 - instead of carrying off
241:21 - so
241:22 - i
241:23 - have five
241:24 - and the side parameter is async in the
241:27 - child components ahead
241:29 - and secondly the
241:31 - initialize the trigger and the child
241:33 - component
241:34 - followed by our parameter set
241:38 - so if i press continue again it's
241:40 - actually not going to
241:42 - go to the shoot render or after render
241:46 - same with
241:47 - in the parent component these two events
241:49 - are not triggered so let's go over here
241:52 - this is where our breakpoint is
241:53 - currently at so i'm going to hit
241:55 - continue again
241:57 - now
241:59 - we're jumping back to the parent
242:01 - component
242:02 - and again the same parameters async is
242:05 - rendered and our initialize and then
242:09 - so i'll initialize and then press
242:11 - continue again on parameter set and then
242:14 - actually when i
242:16 - when i come when i click on continue
242:18 - it's going to jump
242:20 - over here again
242:22 - and then on the slide and then practice
242:24 - that
242:25 - so
242:27 - why are they
242:28 - rendered
242:29 - uh
242:30 - twice
242:31 - these three events are rendered twice
242:34 - that's because if you look at the
242:36 - diagram
242:39 - we look at the diagram we have the
242:40 - browser and we have the server side
242:44 - the first request sent by the user and
242:47 - then the first rendering is
242:49 - so this is ser again this is server side
242:51 - blazer okay server server type
242:55 - the browser sends requests first and
242:57 - then renders for the first time
243:01 - including the
243:03 - the javascript
243:05 - for server type laser and that's
243:07 - javascript establish a signal r
243:11 - connection and then server set renders
243:14 - the component again
243:16 - that's why i render twice
243:18 - that's why those three
243:20 - events are called
243:22 - twice right so after this watch what
243:26 - happens if i continue from here so i
243:29 - jump back to the parent component and
243:31 - cause the um on
243:33 - after render
243:35 - skipping they should render because this
243:37 - is the first time and it has to render
243:39 - it doesn't make any sense to allow the
243:42 - developer to to control whether to
243:44 - render the component or not it has to
243:46 - render the component and then i continue
243:48 - jumping to the
243:50 - uh child component calling the on after
243:53 - render
243:54 - event handler again
243:56 - and if i continue now the page is
243:58 - rendered
243:59 - uh i when i first asked that the
244:02 - the double rendering only happens when
244:04 - the application when the component is
244:06 - loaded for the very first time
244:09 - so if you never get away
244:12 - from the component and then navigate
244:14 - back because the signal r channel is
244:16 - already established
244:17 - so
244:19 - those three events that are
244:21 - called twice
244:23 - will not be cut twice again so let's
244:26 - demonstrate that so let me
244:28 - so let me refresh the page
244:30 - okay so we notice that we're on the
244:34 - parent component
244:35 - three events
244:38 - child component these three events going
244:40 - back to the first
244:41 - parent page these three events
244:44 - and secondly
244:47 - on the child component
244:49 - so we notice so far
244:52 - these three events are called twice both
244:54 - the parent component and the child
244:56 - component that's because i refresh the
244:59 - page
245:00 - by refreshing the page the signal arc
245:02 - connection is re-established that's why
245:05 - these three events are being called
245:06 - twice and then we're going to the on
245:08 - after
245:09 - render
245:10 - on parent page
245:12 - parent component and uh unlock to render
245:14 - our child component
245:16 - right so if i'm not doing that if i
245:19 - never get away from the
245:21 - uh
245:22 - from the home component from the index
245:24 - component
245:25 - navigate back to the
245:27 - index component watch what happens now
245:30 - okay these three events
245:33 - and then truck component these three
245:35 - events happen again but then
245:37 - those three events are not going to be
245:39 - called a
245:41 - cut twice so we're actually moving on to
245:43 - unlock surrender from the parent
245:45 - component and then i'll have to render
245:48 - for the shot component okay let's
245:50 - summarize so the one sequence that we
245:52 - are experiencing in server type later in
245:54 - the first category which is the first
245:56 - time rendering is that the
245:59 - these three
246:00 - events are being called
246:03 - uh one by one in the parent
246:06 - component
246:07 - and then the same
246:08 - set of events are being called in the
246:11 - same sequence in the child component
246:14 - and then after that the same thing
246:15 - happens again right
246:18 - for the parent and for the child and
246:20 - only after that
246:22 - the parent component after and there is
246:25 - called and child component after ender
246:27 - is called seeing this
246:30 - any initialization code that you put
246:32 - inside these three methods
246:35 - uh on server type laser is gonna be
246:39 - called twice
246:41 - so
246:42 - when you're initializing your
246:45 - data
246:46 - you have to really pay attention to
246:49 - where you put unilateral initialization
246:53 - there is a on after render
246:56 - async
246:59 - with a parameter that indicates whether
247:01 - it's the first time or not so for server
247:04 - type laser i recommend that you use that
247:06 - to initialize your data
247:09 - in the on after render depends on
247:12 - whether you are
247:14 - going to use that data to render on the
247:18 - screen or not
247:20 - if yes then you need to call this state
247:23 - exchange method to re-render the
247:27 - page again now let's look at the same
247:29 - thing in laser
247:31 - web assembly because it does not
247:33 - actually trigger the breakpoint
247:35 - uh so you can either debug it
247:38 - through the browser
247:40 - uh which i have demonstrated in the
247:42 - uh
247:43 - previous episodes so today i'm going to
247:45 - actually use console.write that is
247:48 - similar to
247:49 - the
247:50 - console.log in javascript so you can
247:53 - just do this and then expect to see
247:58 - expect to see the the log is written in
248:01 - the console window in the developer tool
248:04 - so i'm just going to do that all right
248:06 - let's go to blazer let's go to developer
248:08 - tool and we can see that uh it's
248:11 - actually the same sequence right parent
248:13 - component called this three uh three
248:16 - events
248:17 - trial components again this is three
248:19 - events and then parent components called
248:22 - unlock to render child component calls
248:24 - unlock to render
248:25 - the only difference is that
248:28 - the only difference is that the parent
248:31 - component
248:32 - these
248:34 - three methods are only caught once
248:37 - because this is web assembly
248:40 - thus
248:43 - the second rendering is no longer needed
248:45 - because there's no signalr channel that
248:47 - is
248:48 - this is that is established
248:50 - now let's moving on to the second
248:51 - category
248:52 - which means re-rendering
248:55 - right and from the previous episode that
248:57 - we know there are four different
249:00 - cases that would trigger a real render
249:02 - let's
249:03 - use a button
249:06 - i have a button here
249:08 - and i have invite handler here so this
249:10 - is server type later so i have a
249:12 - breakpoint up right here and let's run
249:15 - it and see what happens if i click on
249:17 - the click me button here the first event
249:19 - that is called is actually the event
249:21 - handler of this button
249:23 - right
249:24 - and then after that so we are on the
249:26 - parent page the button is only on the
249:28 - parent page current component so click
249:31 - on the continue button
249:34 - we're calling the shoot render and then
249:37 - if i click on it again
249:39 - we're calling on the i'll
249:41 - unlock to render and notice that we're
249:43 - still on the parent component and you
249:44 - see that the
249:47 - child component re-rendering is not
249:49 - called if you watched my previous
249:51 - episode that you know the reason why the
249:53 - child component is not re-rendered right
249:56 - so those none of those four conditions
249:58 - satisfy so the child component are
250:01 - not going to be re-rendered whereas for
250:03 - the second category which is the
250:05 - re-render category
250:06 - uh this let's summarize that it actually
250:10 - looks like this right so first you have
250:13 - your parent component
250:15 - and if there's no condition for the
250:17 - child component to render
250:18 - what you're going to see is something
250:21 - like this
250:23 - right you have your parent component
250:25 - shoot render and then your parent
250:26 - component after render
250:28 - and if there's parameter change or any
250:31 - other condition that triggered the
250:32 - render of the truck component what
250:34 - you're going to see is something like
250:35 - this you're going to have your parent
250:37 - component should render and then these
250:39 - three events and then parent component
250:41 - after enter and then child component
250:42 - afterwards something that is interesting
250:45 - i want to uh point out is the true
250:47 - should render okay so let's do a
250:52 - let's change this to return
250:56 - false
250:58 - now let's see what happens so i'm going
251:00 - to click on the queen
251:01 - button and then the event handler of the
251:03 - buttons are called first
251:05 - going to shoot render
251:08 - and then
251:09 - you see that the count is now changed
251:12 - and
251:13 - so that means the child component is not
251:14 - re-rendered and the parent components
251:16 - are actually not re-rendered we did not
251:18 - go
251:19 - normal over here didn't see the
251:20 - breakpoint of this
251:22 - render and it's called so it wasn't
251:24 - rather so for the the second category
251:26 - which is a great render scenario uh the
251:28 - server side and
251:30 - the
251:32 - the up later like the web something
251:34 - blazer are exactly the same so i'm not
251:36 - actually going to run the demo again
251:44 - i want to go over a pitfall in data
251:47 - initialization in blazer components
251:50 - so i have a parent component which is
251:52 - index component and an employee detail
251:55 - component right here right the parent
251:57 - component is
251:59 - using the
252:00 - employee detail component to display the
252:03 - details of the
252:05 - employee and the employee is initialized
252:10 - or loaded in the parent component and
252:13 - i'm hardcoding the employee here to
252:15 - mimic the situation that we're loading
252:17 - this con this
252:19 - employee
252:20 - and each employee
252:23 - actually has a bunch of records to be
252:25 - loaded uh
252:27 - once we go into the
252:30 - employee detail component this
252:33 - employee is the records of the employee
252:36 - is loaded
252:39 - so
252:40 - we look at this code we have
252:42 - uninitialized here in the child
252:43 - component and also all initialized here
252:46 - in the parent component and we run this
252:48 - there's going to be no problem
252:51 - right
252:52 - so let's demonstrate that as you can see
252:54 - the homepage just loaded was the
252:56 - employee detail there's no problem
252:58 - nothing is wrong with this
253:01 - but it actually has a potential issue
253:04 - what if this
253:05 - employee is loaded
253:07 - slowly
253:08 - there's some kind of network slowness or
253:12 - a lot of data needs to be loaded
253:15 - so let's use the sleep method to
253:18 - mimic that
253:20 - scenario
253:21 - so let's go back and refresh the page
253:23 - okay still no problem when we never get
253:25 - away and then we get back
253:27 - uh it takes five seconds right four
253:30 - five
253:31 - right so five five seconds to load it
253:34 - but there's no problem
253:36 - okay but but the potential problem is
253:39 - that sometimes you you have to load
253:41 - these in asynchronous version of the
253:44 - initialization or
253:46 - in some other
253:48 - lifecycle events right so instead of
253:50 - using the
253:52 - um
253:53 - the synchronous version you may have to
253:55 - use the asynchronous version so let's
253:57 - demonstrate that so
253:58 - instead of using this if i use this kind
254:01 - of code here
254:03 - right
254:05 - and then if we use this asynchronous
254:08 - version here as well
254:11 - then
254:13 - let's
254:14 - refresh the page all right there's no
254:16 - problem if we
254:17 - never get back still no problem right
254:19 - that's because this is actually called
254:21 - first right and then they all initialize
254:23 - methods in the child component called
254:25 - secondly afterwards so what if we add
254:29 - that
254:30 - sleep
254:31 - uh thread back right so what if we have
254:34 - a method like this
254:38 - in our parent component we're using
254:40 - we're using awaytask.1 to mimic a
254:44 - asynchronous call and then
254:47 - we use the sleep five for five seconds
254:50 - to make a long running process here
254:54 - and let's refresh the page and see what
254:56 - happens in this case right so
254:59 - it's throwing suction complaining about
255:01 - the object references now which happens
255:04 - in this place
255:05 - the employee is now when the low records
255:08 - is being called so that's through the
255:10 - exception how should we deal with this
255:12 - kind of situation
255:14 - right i would suggest that
255:17 - that we first uh
255:19 - we need to call
255:22 - we always check whether the object that
255:24 - we're trying to do with is null or not
255:26 - now we need to do the null check now
255:29 - reference check and then also
255:32 - instead of using our initialize we
255:34 - should use i suggest that we use on-prem
255:36 - intercept because it's always called
255:38 - when parameters change
255:41 - and then inside here we have to check
255:44 - the reference as well because we don't
255:46 - want to load the records over and over
255:48 - again right whenever there is a change
255:51 - unless that's something that you intend
255:54 - to do
255:54 - so in this case we will see that
255:58 - if we refresh the page then it's going
256:00 - to be fine except that it takes five
256:02 - seconds one
256:03 - two
256:04 - three
256:05 - four
256:06 - five
256:08 - right let me get away and then we go
256:10 - back
256:11 - two
256:12 - three
256:13 - four five
256:20 - traditionally we're using this regular
256:22 - forms for user to input data
256:24 - and if we look at the contents of this
256:27 - we have a formal element and then we
256:29 - have input field and then a submit
256:31 - button
256:32 - so when user clicks on the submit button
256:36 - the forms will be posted back to the
256:38 - backend
256:40 - to this location but application written
256:42 - with blader is a single page application
256:45 - which means only the first
256:48 - page load
256:49 - goes through the http request and
256:52 - response pipeline
256:54 - the subsequent actions will not be posed
256:57 - back to the back end
256:59 - in order to still perform
257:01 - forum submissions microsoft came up with
257:04 - a set of components
257:06 - to perform the task so instead of using
257:09 - regular forms in blazer we should use
257:11 - the edit form component
257:14 - instead of using the regular input we
257:17 - should use
257:18 - input text input number input date input
257:21 - select etc don't worry about the
257:25 - error here i'll fix this error later
257:28 - when the
257:30 - submit button is clicked event handler
257:32 - specified which is valid form submitted
257:36 - and if you want to handle
257:39 - invalid form submitted
257:41 - so then you would do on invalid form
257:44 - submitted and
257:46 - connect it to a function
257:51 - right so here's
257:53 - two things we need to know
257:54 - first we need to use a added form
257:57 - instead of a regular form and then we
258:00 - use
258:00 - input first differently
258:03 - another thing we need to know is in
258:05 - order to handle the submission
258:08 - we specify the method
258:11 - the next thing we need to know is that
258:14 - the edit form has to be bound to a model
258:16 - i declared a lot of class here person
258:21 - and then i slide the person right here
258:24 - and then
258:25 - in other form
258:28 - there is a parameter
258:30 - that is called modem and i provide that
258:32 - person model
258:34 - instance to this model
258:37 - and
258:38 - next
258:40 - i need to use bind value to the data
258:42 - binding
258:43 - and i'm associating
258:46 - each
258:47 - properties
258:48 - inside the person class
258:50 - to the input
258:52 - elements the next thing we need to know
258:54 - is validations in order to
258:58 - validate the model we can use
259:00 - data annotations we need to first
259:04 - use that name space
259:06 - and then we can
259:08 - annotate
259:09 - the properties
259:10 - which
259:12 - the annotation attributes like required
259:16 - string lengths
259:17 - max lens
259:19 - range
259:20 - we can specify the data type like email
259:22 - address
259:24 - etc
259:25 - in order to trigger the validation and
259:28 - display the validation messages at the
259:30 - top we need to use
259:32 - the data animation
259:34 - validator
259:35 - component
259:37 - and also
259:38 - we need to put validation summary here
259:40 - and that's all we need to do
259:43 - for a basic validation scenario
259:46 - okay so let's run this form
259:50 - and see what happens right so if i don't
259:52 - do anything
259:53 - i click on submit button
259:55 - it will give me the required error
259:56 - messages
260:02 - if i put -1 here
260:04 - and click on this it would give me the
260:07 - range error message
260:09 - and emails is also still required
260:12 - if i put
260:15 - abc dot abc
260:18 - so let's put this
260:20 - then it will directly say that email
260:22 - address is invalid
260:24 - so if i provide a
260:26 - correct email address format
260:29 - then this becomes green
260:31 - and if i give it a correct number
260:35 - then all everything is green
260:37 - okay and the submission will trigger
260:41 - the
260:43 - uh um
260:46 - will trigger the unviolent summat event
260:50 - and this event handler will be triggered
260:54 - okay so that's the basic of validation
260:57 - uh i just wanted to before i finish this
261:00 - episode i wanted to
261:02 - mention
261:03 - a couple of things notice that this v is
261:06 - a capital v
261:07 - so
261:08 - usually when you use
261:10 - a data binding outside of
261:14 - added form
261:15 - you would use a lowercase v
261:18 - and if you keep using the lowercase v
261:22 - you will encounter very weird errors
261:25 - so remember to use capital b here
261:29 - another thing is that if you put buttons
261:32 - here
261:34 - like this
261:37 - the button's default type is going to be
261:40 - a submit button
261:41 - okay so if you put buttons here
261:43 - expecting it behaving like a regular
261:46 - button
261:47 - it's not going to happen it's going to
261:50 - work like a submit button
261:53 - so if you want extra buttons
261:57 - to work just like a button then you have
261:59 - to specify it as a button
262:07 - first i will quickly go over what
262:09 - dependency injection is so it will have
262:11 - two modules or two classes
262:14 - one is higher the other is lower and
262:16 - higher one depends on the lower class
262:19 - for example the customer service class
262:22 - needs to use the functionality of the
262:24 - customer
262:26 - data access class
262:28 - right
262:29 - in order to get
262:31 - data from database
262:33 - then we say that customer service has a
262:35 - dependency
262:37 - upon customer and data access in order
262:40 - for the higher
262:42 - module to use the functionality of the
262:44 - lower model you know we have different
262:46 - ways to do it
262:47 - right the first obvious way
262:50 - is to
262:52 - have an instance
262:54 - of this customer class
262:56 - right over here
262:58 - right
263:00 - and then we'll just call it customer da
263:05 - right and then in our
263:07 - constructor
263:08 - say custom da equals new
263:11 - customer
263:14 - that access
263:15 - you know with a problem with the
263:17 - connection stream
263:18 - from somewhere
263:22 - right
263:23 - and then you can use it
263:25 - to
263:26 - for example get a customer
263:29 - get customers
263:32 - right and then
263:35 - here
263:36 - we can just say customer
263:39 - return customer dot got customers
263:43 - and that's
263:45 - actually you'll have a
263:49 - numeral
263:53 - right so we get a list of customers like
263:56 - this
263:57 - so this is uh one way to
264:00 - make the
264:01 - uh
264:02 - to make use of the functionality of the
264:04 - our module
264:06 - but as you can see that
264:08 - the customer services uh is uh tightly
264:11 - coupled with customer data access it is
264:14 - aware of the definition of this class
264:16 - and
264:17 - there are many different
264:19 - problem problems with this for example
264:22 - if you want to have different teams work
264:24 - on higher level optic
264:26 - one team work on higher level module the
264:28 - other team work on lower level module
264:31 - because this um
264:32 - tight coupling
264:34 - it's very it's very difficult to work in
264:37 - parallel
264:38 - right and also
264:40 - if we were to change this
264:42 - the name of this class then you have to
264:44 - go to change
264:46 - uh
264:47 - all of the codes over here right you got
264:49 - to change you're going to change this
264:50 - you're going to change this so uh and
264:53 - you you need to
264:54 - recompile the higher modules in order to
264:57 - do that change right so the
264:58 - maintainability is is not good right and
265:01 - later and
265:03 - if we
265:04 - want to uh so if this dead access layer
265:07 - is going against a file system
265:10 - right and later you want to create
265:12 - another class
265:15 - all right
265:16 - that's going
265:17 - against
265:20 - uh going as a database right single
265:22 - database
265:23 - for example like this
265:26 - right then
265:29 - you would have you would have to
265:31 - go inside and change to change the code
265:34 - right so that's extendability is also
265:37 - not good so there's many different uh
265:40 - this is a disadvantage of doing this
265:43 - kind of tight coupling
265:45 - so
265:46 - there's this uh dependency inversion
265:48 - principle which says higher level
265:50 - modules should not be dependent on the
265:53 - lower level models
265:54 - both should be dependent on abstraction
265:56 - so what is the abstraction abstraction
265:58 - is
266:00 - because the dependency there is the
266:02 - dependency between the service class and
266:04 - the data access class right so
266:07 - that dependence cannot be removed
266:09 - instead what we need to do is to
266:11 - abstract that dependency and that
266:13 - dependency is the functionality right so
266:16 - dependency is the functionality and we
266:17 - need to abstract that functionality and
266:19 - in c sharp the way to access uh to
266:23 - abstract that functionality is to use
266:25 - interface so we can create an interface
266:27 - like this
266:29 - and then we can say i customer data
266:32 - access
266:34 - and
266:35 - in there we can just say
266:38 - you know
266:39 - all we want to do is to have
266:42 - a
266:44 - is to get a list of customers this is
266:46 - the abstraction right so basically it
266:49 - just says i have a way
266:52 - to
266:53 - get customers
266:55 - then whoever implements this interface
266:57 - we'll have to implement notice that this
266:59 - method doesn't have a body right it
267:01 - doesn't have an implementation so
267:03 - whoever actually implements this
267:04 - interface
267:05 - okay they need to
267:08 - they need to have this uh this thing
267:10 - implemented
267:13 - so
267:13 - right here we need to implement this
267:17 - in the concrete class
267:20 - right i'm not going to implement
267:22 - anything i'm just going to do this
267:24 - right so
267:25 - uh in this way
267:26 - we are not actually using
267:29 - the concrete class here we're just doing
267:30 - this and that um takes the dependency
267:34 - away but again it's still having the
267:36 - same problem we're actually creating
267:38 - this instance of this concrete class
267:41 - right here means that the higher level
267:43 - object
267:44 - is still
267:45 - aware of the lower level object so how
267:48 - do we do that we have to
267:50 - take this responsibility away
267:52 - from from the customer service and this
267:56 - responsibility is is the instantiation
267:58 - responsibility and we need to take that
268:00 - away and this is called inversion of
268:02 - control right but don't worry about that
268:04 - and how do we do that
268:07 - we need to um create it from outside
268:10 - right the simplest way is just to you
268:13 - know just to create it from outside
268:15 - like this the a let's use a different
268:18 - variable name
268:21 - right and again you can just do it this
268:23 - way and then um
268:25 - when this
268:28 - class is instantiated
268:30 - or we can just uh
268:33 - just do it like this
268:39 - then
268:40 - we're going to say da because da and
268:43 - that's it right so our
268:45 - private instance has this and then when
268:48 - from outside we can when we instantiate
268:52 - this class
268:53 - then
268:55 - then we can
268:57 - just say
268:58 - you know
268:59 - pass this
269:01 - into it
269:02 - so that's these are the main two steps
269:05 - first we need to use the abstraction
269:07 - which is the interface in c sharp right
269:10 - secondly instead of
269:12 - directly instantiating the
269:15 - concrete implementation of the interface
269:19 - we use constructor
269:21 - and then
269:23 - pass that instance from outside into
269:25 - here so this is the dependency injection
269:29 - in c-sharp and it's the same concept in
269:31 - every other languages
269:33 - of course there are different ways to do
269:35 - it this is through this instructor you
269:37 - can also create a property
269:39 - of that and then
269:42 - just
269:43 - just say
269:45 - if we were to create a property instead
269:46 - of
269:48 - doing like this we can just say
269:54 - have our constructor stay right here
269:57 - and then we can just say
269:58 - you
270:00 - public
270:05 - i so in that case we don't need this
270:08 - all right we can say i customer data
270:10 - access and then we can say
270:12 - your customer data
270:15 - data access equals
270:19 - uh
270:21 - well let's use this name because it is
270:27 - set so this is the property in c sharp
270:30 - and then when you
270:31 - use it like this you can just say
270:37 - instead of
270:39 - doing like
270:40 - this you can just screen this and then
270:43 - from here cust
270:45 - service and then you can say
270:49 - custom data access
270:52 - close
270:55 - data access
270:56 - and then and then you can use it in
270:58 - other methods
271:00 - so that's dependency injection in
271:01 - general and then next let's go
271:04 - into video studio and see how dependency
271:07 - really works in blazer components
271:10 - let's see how dependency is injected
271:13 - into laser components
271:16 - first let's look at servers app laser
271:26 - let's
271:27 - create a
271:29 - class let's call it customer service
271:32 - this customer service will have a
271:35 - public method
271:37 - that returns
271:39 - a customer
271:41 - and for that let's first create a
271:43 - customer class as well and that's it
271:45 - let's keep it simple
271:49 - and
271:50 - in here
271:52 - we will return the customer
271:54 - will say get customer
271:57 - by id
271:59 - and the parameter
272:01 - is an integer which is the id
272:04 - okay
272:07 - so create a
272:09 - constructor
272:11 - and this constructor let's initialize a
272:13 - list of customers
272:27 - and then in here
272:36 - okay so we have this service
272:38 - and uh
272:40 - we want to inject it into blazer
272:43 - components
272:44 - and let's inject into the index
272:46 - component which is a page component
272:49 - that has
272:50 - a routing path here right let's delete
272:53 - this
272:54 - survey prompt
272:56 - and
272:59 - let's display let's use this in our gold
273:03 - okay
273:04 - so one way to do it
273:06 - is to
273:08 - declare
273:09 - a
273:10 - customer service
273:12 - and then
273:14 - we'll just say customer
273:16 - service
273:18 - equals new customer service
273:21 - okay so this is not this is this has
273:24 - this dependency problem that is that
273:26 - that is making the index component
273:29 - tightly coupled with
273:32 - the customer service
273:34 - class but that's not we that's not what
273:37 - we want to do right so we have learned
273:40 - what dependency injection really is the
273:43 - two main steps first is that we need to
273:48 - use interface
273:50 - so that our index component is dependent
273:53 - on interface so we need to do is to
273:56 - create an interface okay
274:04 - give it an interface
274:06 - because i customer service
274:09 - right um there's only one behavior
274:13 - right here which is
274:15 - getting the customer buy id right so we
274:17 - copy that
274:18 - and paste it over here
274:20 - and that's it
274:22 - that's the
274:26 - uh once again must declare a body oh
274:29 - okay
274:30 - yep
274:31 - so this is abstraction
274:33 - so it doesn't need a body
274:35 - and then go over here we just use our
274:38 - customer service
274:40 - right so we have already implemented
274:44 - the
274:45 - abstraction
274:46 - and uh
274:48 - the second step is to inject
274:50 - right so first we need to register into
274:52 - the container which
274:54 - blazer is based on asp.net core and
274:57 - asp.net core there's uh
274:59 - to in order to
275:02 - register the
275:04 - services classes service classes
275:06 - into
275:08 - the container we can use configure
275:10 - services
275:11 - okay so we can
275:13 - we can register right here but there are
275:17 - actually three different
275:20 - lifetime scopes right
275:22 - um
275:23 - there's
275:24 - singleton there's scoped
275:26 - and there's also transit
275:29 - okay so first let's examine transient
275:32 - giving the pair of the interface as well
275:34 - as the implementation
275:38 - all right
275:39 - and then when we ask for it
275:42 - we go to our component
275:45 - where we want to use the customer
275:46 - service and we just say
275:49 - right inject customer service
275:53 - right and then right over here
275:56 - um
275:57 - we can just uh we can just declare a
276:02 - private
276:04 - customer
276:08 - customer this is our model class so it's
276:11 - okay to be dependent on our model class
276:14 - right
276:15 - so and then
276:17 - in the
276:18 - override let's overwrite
276:54 - all right i just just want to set a
276:56 - breakpoint
276:57 - just so that
276:59 - i can show you
277:01 - when this component is disposed
277:03 - okay so i'm going to debug so if i move
277:06 - away
277:08 - you can see
277:09 - when i move away
277:11 - it actually
277:14 - just poses
277:15 - right when we move back
277:18 - it creates again
277:24 - we move away
277:26 - it is poses
277:28 - and it will move back it grades okay
277:31 - and if you pay attention to these
277:33 - numbers right seven six seven when i
277:36 - move away
277:38 - let's
277:39 - remove the breakpoints
277:42 - and move back
277:43 - number changed from seven seven six
277:46 - seven to one b7
277:48 - right
277:49 - you can see every time i do this
277:54 - the number changes and the reason every
277:56 - time i move away you can see the
277:58 - disposed method
278:00 - and never get away from the index
278:02 - component
278:04 - you can see the disposed method that's
278:07 - called because the index component
278:09 - corresponds to this home page
278:12 - right
278:12 - so
278:13 - uh this dispo dispose method gets called
278:16 - which means that every time i move move
278:18 - away this component is actually
278:20 - destroyed
278:22 - right and when i come back this
278:24 - component is created whenever it's
278:26 - created this dependency injection
278:29 - injects the method sorry injects the
278:32 - class to our component
278:34 - then we can use it here
278:37 - right so this is and every time it
278:39 - changes and this is the behavioral
278:41 - transit transit says that
278:43 - i register a service to a container and
278:46 - every time i ask for an instance
278:49 - the container will
278:51 - create a new instance of that class and
278:53 - inject that into our component
278:56 - right into where we want to use it
278:58 - so that's
279:00 - what we call transit and if we want to
279:03 - see what scope means
279:07 - let's actually see what singleton is
279:09 - first
279:10 - all right so let's
279:13 - change this
279:17 - singleton
279:18 - and this time i'm actually going to use
279:20 - control f5
279:22 - to debug it
279:24 - also
279:25 - so that i can run it without debugging
279:27 - actually i'm not debugging it
279:29 - all right so you can see that we have
279:31 - this number here
279:33 - and if i move away and move back you see
279:35 - the number does not change
279:38 - so that's singleton singleton means
279:40 - there's only one single
279:42 - instance of the object
279:44 - the custom survey object
279:46 - in the container
279:48 - throughout the lifetime of the this
279:50 - application
279:51 - right
279:52 - even when you refresh
279:55 - which actually resets the connection
280:01 - you can see
280:02 - the number does not change and that's
280:04 - the behavior of singleton singleton
280:05 - there's only one instance and if we want
280:07 - to look at how
280:09 - sculpt means
280:11 - how scope works
280:13 - let's change this to
280:15 - scoped
280:22 - all right and then
280:24 - let's come over here refresh this screen
280:26 - because we used control five so this
280:29 - hot reload works
280:33 - so let's refresh it and see the number
280:36 - change right and then
280:37 - but if we never get away and never get
280:40 - back you can see the
280:43 - number still the same
280:46 - it doesn't
280:48 - change
280:49 - so it seems like it's a single 10 but
280:51 - it's not
280:52 - so if i refresh which
280:54 - uh by refreshing this it disconnects the
280:56 - connection and re-establish the signalr
280:59 - connection
281:01 - right because this is a blazer
281:03 - server-side
281:05 - so
281:06 - so then
281:08 - the connection is broken and
281:09 - reestablished
281:11 - so you can see
281:12 - this time the number changed after i've
281:14 - refreshed
281:18 - and that tells us that
281:20 - the scoped
281:22 - lifetime configuration
281:24 - makes the service
281:26 - live as long as
281:28 - the connection
281:30 - okay so as soon as
281:32 - as long as the connection does not
281:35 - get disconnected you will always have
281:38 - one instance you have to choose the the
281:41 - best suitable
281:44 - lifetime configuration
281:46 - for your services class
281:48 - right because some of them you want to
281:50 - use trends and some of them you want to
281:51 - use scoped
281:54 - for better performance or for whatever
281:55 - reason
281:57 - and sometimes you want to use singleton
281:59 - right
282:01 - for example
282:02 - you don't if you want to use some
282:05 - classes to contain some data and
282:09 - try to use uh
282:12 - try to implement
282:14 - state management that way
282:17 - and
282:19 - you don't want to use singleton because
282:21 - that way you are
282:24 - sharing the data across all of the users
282:29 - even users from different browser
282:31 - sessions from different part of the
282:32 - world are going to see the same data
282:35 - unless that's your purpose
282:38 - so
282:40 - for state management that's very
282:42 - specific to particular user
282:44 - you can use scoped and that's
282:48 - that's related to that one particular
282:50 - connection which cannot be shared
282:51 - between different browsers
282:54 - right but for very light services you
282:57 - want to probably use transient
282:59 - right for uh
283:01 - services that is not threat safe
283:04 - which means concurrency doesn't work for
283:07 - example
283:09 - the db context from entity framework
283:12 - you don't want to use
283:14 - singleton you don't want to use scope
283:16 - even for transient it's created every
283:18 - single time
283:20 - it may still have problems so you really
283:22 - want to consider the different
283:25 - services
283:26 - and different scenarios
283:28 - so this is blazer server side so next
283:32 - let's look at laser
283:35 - laser web assembly
283:38 - we're going to have another instance of
283:43 - register 2019 and then we'll click on
283:45 - placer app
283:47 - this time
283:48 - we don't see that startup file that's uh
283:50 - this is webassembly so it doesn't
283:52 - actually have it and you can see that
283:55 - they are registered right here so we can
283:57 - do a similar thing and we can say
284:00 - builder
284:03 - dot services dot app transit
284:07 - so
284:08 - we're gonna say customer
284:10 - service okay so we don't have this
284:12 - namespace as well
284:29 - so we have our
284:32 - customer eye customer service
284:36 - providers
284:38 - to it
284:40 - so basically we're just saying that
284:42 - uh for this interface this class
284:45 - implements the interface
284:47 - and then we ask for instance of this
284:50 - interface
284:51 - uh the container the built-in container
284:53 - is actually going to create an instance
284:56 - for us
284:58 - by instantiating this customer service
285:01 - right
285:02 - and what we want to do here is uh
285:06 - same thing we're going to do
285:09 - do it within here
285:11 - where we will
285:14 - inject
285:16 - our
285:18 - customer service
285:21 - over here
285:24 - then
285:25 - we are
285:27 - adding this we're actually going to copy
285:29 - this code from
285:31 - uh right over here
285:33 - here we register trending
285:35 - all right so let's run it
285:37 - ctrl 5 again so we have this running
285:41 - and you can see
285:43 - the number is ce2d and when we move away
285:47 - number change go away number changed
285:50 - again if we refresh number change
285:53 - all right refresh again
285:56 - never change it again
285:58 - all right
285:59 - so
286:00 - uh so this is trended right so basically
286:03 - it's the same thing as later server side
286:07 - where
286:08 - every time the component's class is
286:09 - substantiated
286:11 - a new instance is substantiated and
286:14 - injected into the component okay so
286:16 - that's that one and then singleton
286:19 - actually basically works the same way
286:22 - okay which is
286:25 - also you know every time you ask for it
286:27 - you're gonna have the same instance
286:30 - all right so refreshing
286:33 - downloading that again so you can see
286:35 - that it's c97 and if i move away move
286:38 - back c97 when i refresh
286:42 - see that this works differently now
286:46 - the refresh actually changes uh changes
286:49 - changes the number
286:52 - see every time i refresh i get a
286:53 - different number so i explain this a
286:56 - little bit uh
286:58 - later
287:00 - but we just take a look at the
287:05 - scope
287:10 - and
287:12 - i build again
287:14 - and then come over here and refresh
287:17 - downloading the whole thing nine four
287:19 - nine
287:20 - when the movie move back
287:22 - is the same
287:26 - right it's the same number but when i
287:28 - refresh
287:30 - it also changes
287:32 - so it looks like the singleton
287:34 - and the scope
287:35 - are working exactly the same way
287:38 - right only trending works differently
287:42 - and the reason for that this because
287:44 - this is web assembly so the whole
287:48 - server set code is actually downloaded
287:51 - all of the dlls are downloaded to
287:54 - the
287:56 - client side in the inside the browser
287:58 - and inside there we have this um
288:01 - webassembly context and all of them are
288:04 - actually hosted within that context
288:07 - right
288:07 - so which basically means that's program
288:12 - this console application here
288:15 - this console application here is
288:17 - actually running
288:18 - uh inside the browser that's why when
288:20 - every time you refresh it
288:22 - it creates a new instance of this
288:24 - program
288:25 - right because this program
288:27 - is the cost application is basically
288:29 - destroyed
288:30 - and then this it's recreated
288:33 - and the main method is run again and
288:36 - that's why you see
288:38 - the even with singleton
288:40 - it's
288:41 - it gets different number different ids
288:45 - every time you refresh the browser
288:47 - right and the scoped
288:49 - because there's no connection and
288:51 - there's no requests
288:54 - so
288:55 - a blazer
288:56 - webassembly doesn't actually have a
288:58 - scoped
289:00 - uh lifetime management configuration
289:02 - it's
289:02 - if your scope is gonna work the same way
289:05 - as singleton
289:06 - all right so that's um
289:08 - everything i want to cover for today
289:10 - uh there's a one last piece about uh
289:14 - dependence injection blazer which is uh
289:16 - which is about uh configuring owning
289:19 - components
289:21 - and that one is
289:23 - probably
289:25 - not so you don't use it so often so i'm
289:27 - not going to cover
289:29 - in this video
289:31 - you can
289:32 - go ahead and read the documentation
289:40 - the components in blazer are stateful
289:43 - and with stateful components on the
289:46 - front end you will very soon run into
289:49 - problems
289:50 - with uh state management and that's why
289:54 - uh they're different architectures from
289:55 - managing this state and one of them is
289:58 - flux
289:59 - from facebook
290:01 - today we're going to look at what flux
290:03 - is
290:04 - and how we can implement it in c sharp
290:07 - and using in our laser components
290:11 - all right so let's get started
290:14 - so with a component whether it's a laser
290:17 - component or angular or
290:19 - ugs or react
290:21 - it does not matter
290:23 - what's the component
290:25 - uh
290:26 - there's always gonna be a view
290:29 - right
290:30 - and then you know the user will interact
290:33 - with the view
290:34 - and then
290:36 - uh
290:37 - that interaction triggers some events
290:39 - and events are handled events are
290:41 - handled
290:43 - and then
290:44 - handling the events will mutate
290:47 - the state
290:49 - and then when the state is mutated
290:51 - the view is updated
290:53 - so you're in this in this
290:56 - triangle
290:57 - but the problem is if we only have one
291:00 - component
291:02 - a very simple project
291:04 - and we're maintaining the state
291:07 - in components themselves within
291:09 - components themselves that's not a
291:11 - problem
291:12 - but once you start writing more
291:14 - complicated code
291:16 - um
291:17 - doing more complicated projects
291:19 - you may run into situations where you
291:21 - have to share the state within different
291:23 - components
291:25 - that's where we need to
291:27 - extract that com state outside of the
291:30 - component put it somewhere else in what
291:32 - we call a state store and it's more look
291:35 - like this
291:37 - so we have a state store
291:39 - where
291:40 - the state is
291:42 - stored
291:44 - and then we have different components
291:46 - okay and will be the same kind of
291:48 - triangle
291:50 - right
291:51 - because the the user will interact with
291:53 - the views it will trigger some events
291:55 - events are high note and mutate the
291:56 - state
291:58 - right and then the view is notified and
292:00 - updated but in this case it's slightly
292:04 - slightly different in style
292:07 - when the status muted file is mutated
292:11 - uh
292:12 - the notification
292:14 - is not only sent
292:15 - to
292:16 - one component
292:18 - it will be sent to multiple
292:21 - components in this case you can see that
292:22 - notification is sent to
292:24 - this component one as well as component
292:27 - two so the same thing will happen if the
292:29 - user interacts with component two
292:32 - then
292:33 - events are handled and
292:35 - state unified and then notification sent
292:39 - to both components and update both
292:43 - right so this is all good and this is uh
292:46 - this is actually what we call a observer
292:49 - pattern
292:50 - okay so observer pattern you have you
292:53 - have subject
292:54 - and then you have observers
292:57 - right
292:58 - so the subject in this case is going to
292:59 - be our
293:01 - store stick store
293:03 - and the observers in this case are our
293:05 - components the observers actually listen
293:08 - to this to the subject of interest
293:10 - to the store
293:12 - and then as soon as there's anything
293:15 - changed in the subject
293:17 - the
293:18 - observers
293:20 - will get notified it's more like a you
293:23 - know push notification
293:25 - um on your cell phone
293:27 - cell phone apps and whenever there's a
293:29 - change you receive a push notification
293:32 - right but you have a choice to to react
293:35 - to it so this is all good and works
293:38 - pretty well but
293:39 - when your project get more complicated
293:42 - you will run into situations where one
293:44 - user interaction was the component we'll
293:47 - need to
293:48 - mutate space in multiple stores that's
293:51 - where
293:52 - the dispatcher comes into play right for
293:55 - example
293:56 - you you're building this
293:58 - messenger app you have you have a whole
294:00 - bunch of friends on your left
294:03 - right and then you have your uh user
294:07 - you have your user
294:09 - component so this is going to be your
294:11 - friend's component on the left your user
294:13 - component on the top and then your
294:15 - message components in the middle
294:18 - but what's happening here is that what
294:21 - if
294:22 - i log out
294:23 - right so i log out and that
294:28 - that message has to be sent to most
294:31 - components
294:32 - right so you would have a
294:34 - user
294:36 - store here
294:37 - and then
294:38 - a fret store here
294:40 - and then your message store here three
294:43 - different state stores but when you want
294:45 - to log out
294:46 - right that message is to be sent to to
294:49 - both of these stores actually all of the
294:51 - stores right so you would want to
294:57 - sent to all of these stores
294:59 - so that's when
295:01 - we need a dispatcher right that's when
295:03 - the dispatcher come into play
295:06 - so dispatcher
295:08 - works like this so same
295:10 - workflow the user interacts with the
295:13 - view to view trigger some events events
295:15 - are handled and some actions are
295:17 - dispatched are sent to the dispatcher
295:20 - dispatcher is
295:22 - is going to dispatch the actions to
295:24 - different stores right and then the
295:26 - stores will mutate the states and the
295:30 - states will update the component again
295:33 - right update the view if you compare
295:35 - this with the original store with only
295:38 - one store
295:39 - this is nothing more than a two level
295:41 - observer pattern so you would have your
295:44 - store as a subject
295:47 - and
295:48 - your components as observers
295:50 - the second level of
295:52 - observer pattern is your store
295:55 - as observers and your dispatcher
295:59 - has subject
296:00 - stores observes
296:03 - dispatcher as well
296:06 - and you may notice that there are
296:08 - actions being passed around those are
296:10 - messages right and the reason why we
296:13 - need
296:14 - is because
296:16 - a dispatcher
296:17 - dispatches
296:19 - all kinds of different messages and we
296:21 - need to distinguish the differences
296:24 - between the messages
296:26 - right
296:27 - because
296:28 - they may maybe for different purposes
296:31 - so that's why we have this action
296:33 - message object here being passed around
296:38 - another thing to notice that these
296:39 - actions are like messages right and
296:42 - these actions
296:45 - when the dispatcher dispatches the
296:47 - actions
296:48 - to all the stores that are registered to
296:52 - the dispatcher the stores can make
296:54 - decisions to ignore it or not just like
296:57 - you can ignore your post your push
297:00 - notifications on your cell phone so to
297:02 - simplify this architecture the flux
297:05 - architecture flow actually looks like
297:07 - this where the user
297:08 - interacts with component the component
297:11 - send a notification action to the
297:13 - dispatcher the dispatcher dispatches the
297:16 - action to the store the store handles
297:19 - the action and mutate the state
297:22 - and and then send a notification
297:25 - to notify the component that the state
297:28 - has changed
297:29 - then the view is updated
297:33 - so
297:33 - normally
297:35 - the facebook team presents the
297:39 - flux architecture flow like this
297:43 - and i think the reason why they put
297:45 - action here is that they actually put
297:47 - methods within action instead of using
297:50 - it
297:51 - as a pure
297:53 - model as a pure message
297:57 - and that's confuses me a lot so i i
298:00 - change it so that the action is
298:03 - only
298:04 - working as a
298:07 - message
298:08 - and so when i implement it i implement
298:10 - as a pure model
298:11 - so
298:13 - let's jump into video studio and try to
298:15 - implement it
298:19 - first let's create a blazer app
298:24 - doesn't matter doesn't matter which one
298:26 - we should create
298:28 - let's use player server app
298:32 - all right
298:34 - so we have this
298:36 - later server app created
298:39 - and
298:43 - if we run this ctrl f5
298:46 - we see the default
298:48 - default blader app
298:51 - has this contour we're going to change
298:52 - this counter page
298:54 - to use a
298:58 - a store instead of a local state
299:03 - so if you look at the counter page right
299:05 - now the counter component
299:07 - it has a
299:08 - it has a local state
299:11 - right and this local state is referenced
299:13 - in here in the markup here
299:16 - and uh
299:18 - the
299:19 - increment
299:21 - the click click me button calls this
299:23 - increment method
299:25 - to increment
299:26 - the count and then it's displayed here
299:29 - so
299:31 - what if we want this display not only in
299:34 - this place
299:37 - what what if we want to display the
299:38 - counts not only in this um
299:41 - in this place but we also want to
299:43 - display right here
299:45 - right
299:46 - so
299:47 - we need the state to be centralized
299:51 - somewhere
299:52 - and that's
299:53 - when we want to introduce the store
299:57 - so we have we may have multiple stores
300:00 - so let's create a
300:02 - store
300:05 - folder
300:09 - let's call it stores
300:11 - so that you know it may have multiple
300:13 - stores
300:15 - and uh let's
300:17 - create a
300:19 - another folder
300:20 - do we need another folder
300:23 - yeah
300:24 - because we may have different actions
300:26 - right so let's create a
300:28 - counter store
300:30 - folder
300:33 - and
300:35 - for now let's just create a
300:38 - class
300:42 - and let's call it calendar store
300:46 - and that counter store it needs to have
300:49 - a state
300:51 - okay so let's implement a class
300:55 - that
300:57 - represents that state
301:00 - let's call it counter state
301:03 - and then in here we just need a variable
301:06 - that has a
301:08 - integer type
301:09 - right so
301:12 - uh
301:14 - so
301:16 - we want to so we would want to have
301:19 - integer type
301:21 - count
301:23 - and
301:24 - i don't want it to have a setter
301:26 - so let's initialize this in a
301:28 - constructor instructor
301:32 - right that's it so we have this that
301:35 - only has a scatter
301:36 - so that our state is immutable
301:41 - which is which is better than mutable
301:46 - this is we're actually
301:47 - using that in the central place
301:50 - and
301:51 - in our store
301:53 - we'll have to use the counter state
301:56 - right
301:57 - so we'll
301:59 - um
302:00 - use our encounter state
302:05 - like this
302:11 - well let's just call it state doesn't
302:13 - matter
302:14 - what state it is
302:16 - so our counter state here and then
302:20 - we'll expose a
302:23 - gas state method
302:25 - all right so
302:26 - we'll get the counter state
302:30 - expose this method
302:33 - so we return this state
302:37 - and
302:38 - here comes the
302:41 - um
302:42 - the observer pattern we have to
302:43 - implement that you know we have we have
302:46 - to have a listener so i'm going to put
302:49 - this kind of
302:50 - you know code right here right
302:53 - underneath here so we'll have a private
302:55 - member
302:57 - which is a listener right
303:00 - listeners right we have this action that
303:04 - kind of like an event handler but
303:06 - we use action so that it doesn't have
303:08 - actual parameters
303:10 - uh so i have this private action
303:12 - listeners
303:13 - and then i need to implement a
303:16 - ad
303:17 - like
303:19 - register the listeners right so
303:23 - we're actually
303:24 - you know
303:26 - we call it a state change listener
303:29 - right because
303:31 - it's listening to the store for stick
303:33 - change
303:33 - okay so let's call it this way
303:36 - and
303:37 - we're adding the listener
303:40 - and uh what we do is that we just say
303:45 - listener
303:50 - then
303:51 - we have another method for removing
303:54 - the listener
303:57 - and that's when we do this
304:01 - um
304:02 - and then whenever it started to change
304:04 - in this state our store will block us
304:07 - that change
304:08 - okay so we need a method to broadcast
304:10 - that change
304:26 - we come over here
304:28 - yeah so instead of using this local
304:30 - state
304:31 - into dependency in jack the connor store
304:34 - right so if we go to our
304:37 - startup class computer services
304:41 - and
304:42 - just add scoped
304:45 - okay so
304:46 - because we don't want to share the state
304:50 - with all of the users
304:51 - scoped is scope to the connection
304:54 - right so we can have our store
304:59 - uh connoisseur
305:00 - it's called corner store
305:03 - right here
305:07 - we're not implementing interface
305:10 - just yet
305:11 - so
305:12 - adding this one instance
305:15 - associated with that connection so as
305:18 - long as the connection is not broken it
305:20 - will be the same instance
305:22 - of this kind of store
305:24 - and that's good enough
305:26 - so in here we just say
305:30 - inject
305:32 - counter store
305:35 - oh
305:36 - let's actually
305:39 - import this
305:41 - so we don't want to see
305:46 - right there so i've got namespace
305:49 - imported
305:51 - and then just
305:53 - leave this
305:55 - so we'll have this counter store
305:57 - on the store
306:02 - so this corner store um
306:06 - right here so we can delete this
306:10 - and then
306:14 - you can go over here and say
306:16 - current store
306:18 - dot state
306:20 - dot gas state
306:22 - dot
306:22 - count
306:24 - right
306:25 - and then
306:26 - uh our kind of store will also
306:31 - also so let's actually use a region here
306:34 - because this is
306:35 - boilerplate code i want to see it all
306:37 - the time
306:38 - so this is
306:42 - listeners
306:44 - well actually let's call it observer
306:46 - pattern
306:48 - observer
306:55 - okay so
306:56 - let's close this
306:59 - and
307:02 - we're going to implement increment
307:18 - okay and then
307:20 - increment the count
307:22 - and then we'll create another
307:24 - current state
307:27 - all right because it's uh immutable so i
307:30 - had to create a new one
307:31 - and then we'll call
307:33 - broadcast
307:36 - we call broadcast change
307:38 - the same thing will be
307:40 - same kind of implementation for
307:42 - decrement
307:43 - um
307:47 - and then all the differences right here
307:50 - okay
307:52 - so then
307:53 - um
307:55 - increment count here we'll say
307:58 - you know on her
308:00 - store dot
308:03 - increment
308:06 - this broadcast thing i wanted to be now
308:10 - i
308:11 - wanted to be proud
308:14 - so uh increment
308:17 - and
308:18 - then we have to register
308:22 - our
308:23 - component to listen to the store right
308:25 - so for that we'll override
308:27 - initializer
308:30 - just
308:33 - automatically formatting things in a
308:35 - weird way
308:43 - so
308:45 - over here we would say
308:47 - we're going to store
308:51 - counter
308:54 - store
308:56 - dot register um
308:58 - add
308:59 - stay change listeners
309:02 - and
309:03 - you know we would just
309:05 - add an inline
309:07 - arrow function
309:09 - um
309:11 - i just say you know whenever there's a
309:13 - change i want to call this stage changed
309:17 - in the third
309:20 - right
309:22 - so we have an increment and then we
309:23 - station that's it
309:25 - i'm not going to implement
309:27 - the i dispose
309:30 - interface and to dispose that
309:33 - so
309:34 - just because i'm doing this for
309:36 - demonstration purpose
309:38 - and because we want to also display that
309:42 - in the menu so go to the shared folder
309:44 - to find the menu navigation menu where
309:46 - there is a counter right so in here we
309:50 - also want to inject
310:06 - and
310:08 - we all let's copy over this
310:12 - code from here so
310:15 - i'm going to the manual and
310:22 - okay so we have this
310:26 - and
310:27 - so we'll listen to the change
310:29 - right so we register this and
310:32 - we add a listener
310:35 - so that
310:36 - the
310:38 - nap menu component will become another
310:40 - observer
310:41 - to observe the state changing the
310:44 - counter store
310:45 - and
310:46 - right over here we'll add a colon and
310:49 - then
310:50 - we'll say
310:53 - under
310:55 - store.gastate.com
311:02 - okay and let's go ahead and look at our
311:05 - page
311:06 - refresh our page
311:09 - no reference
311:15 - okay so the problem is right here we
311:17 - forgot to initialize the state and to do
311:20 - that
311:21 - we will come over here and say
311:24 - okay the constructor and then
311:28 - we'll say
311:29 - state
311:32 - counter
311:33 - state
311:35 - and
311:36 - zero
311:37 - right so the initial value is zero
311:40 - and then
311:41 - control five
311:42 - all right so we have our counter number
311:45 - displayed right here and here and if i
311:47 - click on it it increases both places
311:50 - right so our observer pattern works
311:53 - so that's the first step
311:55 - what if we want to
311:57 - do some change and in fact multiple
311:59 - stores that's when we want to use
312:01 - dispatcher right so we don't have to use
312:03 - this pattern
312:05 - um in simpler situations like this
312:09 - you know it's it's okay to just use the
312:11 - store observer pattern right there right
312:14 - but if we do want to use
312:16 - the dispatcher then we can implement the
312:18 - dispatcher we have implemented the conor
312:21 - store
312:22 - with the observer pattern and that works
312:24 - pretty well
312:25 - and next i'm going to implement the
312:28 - dispatcher so that we have the two two
312:30 - level
312:32 - observer pattern to implement flux
312:35 - the flax architecture is nothing
312:38 - but just two level of observer pattern
312:42 - okay i've implemented the
312:44 - at the first level which is this one
312:46 - okay and i'm going to implement the
312:48 - second level of the observer pattern
312:51 - all right let's jump into video studio
312:53 - and work on implementation of this pack
312:55 - last time i have implemented this
312:57 - contour store which contains a
313:00 - counter state
313:02 - this conor store allow the components to
313:05 - mutate the states in two different ways
313:07 - one
313:08 - one is increment the count the other one
313:11 - is decrement account
313:13 - okay so there's two methods that
313:14 - corresponds to that
313:16 - and also it allows the counters allows
313:20 - the components to register
313:23 - and the register
313:26 - from the store right so basically listen
313:28 - to this store or remove the listener
313:31 - right so add listener and remove
313:33 - listener
313:34 - and uh
313:35 - if we go to our counter component this
313:39 - is
313:40 - from the initialize method
313:43 - we are
313:45 - adding the listeners
313:46 - right and then we're using
313:51 - the magazine injection inject the comma
313:53 - store
313:54 - into our
313:56 - component and we're using counter store
313:58 - gas state
314:00 - dot com to display the code and from our
314:03 - navigation menu
314:05 - navigation manual we're also dependency
314:07 - injected kind of store and display in
314:09 - that store and when we we are
314:11 - incrementing decrement we can see the
314:13 - color change
314:15 - uh and changes in two different places
314:17 - one is
314:18 - on the navigation menu right here the
314:21 - other one is in the counter component
314:23 - right and that works very well so today
314:26 - i'm going to continue implementing the
314:28 - dispatcher
314:29 - okay so let's go back to
314:32 - our store
314:34 - and before i continue to implement the
314:37 - dispatcher i want to point out one thing
314:39 - sorry let's go to our counter component
314:42 - i want to point one thing before i
314:44 - continue working on the dispatcher which
314:46 - is this uh
314:48 - ad listener
314:50 - i have to remove state change listeners
314:52 - there but i didn't use it and um
314:56 - and in my previous video i said this is
314:58 - i said that this is a demo so i'm not
315:00 - going to implement that but i want to
315:03 - emphasize that this is very very
315:04 - important because the connor store is
315:07 - a dependency independence injected into
315:10 - our components and connor store is added
315:13 - as a scope
315:14 - right uh
315:16 - a scope which is scoped to the
315:18 - connection right this is blazer this is
315:21 - a server-side laser so a scope is a
315:24 - scope to the connection so if you don't
315:27 - refresh your page the kind of store
315:30 - what will live as long as the connection
315:35 - so unless you click on the refresh
315:37 - button
315:38 - then that's you know this is recreated
315:41 - so that means that because
315:44 - we
315:46 - registered to the counter store
315:48 - essentially we make the component has
315:50 - the same lifespan as the store which is
315:52 - a scope
315:53 - right as long as the connection so when
315:55 - you navigate away
315:58 - later's framework's supposed to dispose
316:01 - it but it cannot dispose it because the
316:03 - store holds a reference to the component
316:06 - so it cannot
316:08 - dispose it and when you
316:10 - when you come back to the counter
316:12 - component it will recreate and create
316:14 - another instance of this so because it
316:16 - cannot dispose it
316:18 - when you never get away and never get
316:20 - back and never get away but it will
316:21 - create multiple instances with the same
316:24 - component
316:25 - right it will never
316:26 - uh
316:27 - release that will never cl recollect
316:30 - that so this is a memory leak that we
316:32 - have to do with so in order to do that i
316:35 - want to emphasize that that we have to
316:37 - do with that and the way to do that is
316:40 - we need to implement
316:43 - the i disposable
316:45 - interface and then
316:48 - inside of our code block we need to
316:51 - implement the dispose
316:52 - method where we have to say your counter
316:55 - store
316:57 - remove
316:59 - remove what so instead of using the
317:02 - inline arrow function
317:03 - so
317:04 - if we use
317:06 - private void update do right
317:10 - and in here we're going to call this
317:13 - state change
317:14 - okay and then
317:17 - instead of doing this we just
317:20 - just put update view here and
317:23 - when we remove
317:24 - we also remove the view
317:27 - so
317:28 - so this is it this
317:30 - when the component is disposed this
317:33 - dispose method will be called and then
317:36 - it will deregister the listener right so
317:39 - detach the content from the counter
317:41 - store
317:43 - which in turn allows garbage collector
317:45 - to collect the
317:47 - the instance of the counter
317:49 - counter component all right so let's get
317:52 - started with implementing this pattern
317:55 - so in order to implement a dispatcher we
317:58 - first we need to you know this pattern
318:01 - dispatches the actions so we first have
318:03 - to implement the actions
318:05 - so the actions um that's
318:08 - the different kind of actions right so
318:10 - first will be increase
318:13 - like increment action
318:16 - so add a class
318:21 - command
318:23 - action
318:27 - all right and
318:28 - in there
318:32 - we can
318:33 - declare a
318:37 - constant
318:38 - which
318:41 - we can call it
318:43 - increment
318:47 - or
318:49 - let's just call it increment
318:51 - all right and then
318:53 - create a moment
318:56 - uh
318:57 - but remember that we're going to have a
319:00 - decrement actually we have all kinds of
319:02 - different actions
319:03 - but this pattern should be able to
319:05 - dispatch all kinds of different actions
319:07 - so for that we need to use poly
319:09 - polymorphism and
319:13 - we can use interface so we're going to
319:16 - have a i action
319:18 - interface
319:20 - and
319:23 - and for that we will
319:26 - go outside here
319:28 - we'll add another uh interface here we
319:30 - say called i action
319:33 - and the action has to be able to
319:35 - identify itself
319:37 - about you know what kind of action it is
319:40 - so that our store is able to
319:42 - distinguish what kind of actions is in
319:44 - decide whether the store will handle the
319:47 - action or not right so for that we need
319:49 - to
319:50 - um
319:51 - uh
319:52 - we need to have a read only property
319:56 - just to get the
319:58 - name
320:00 - of that
320:03 - the action
320:04 - so we can have that
320:06 - have it like this and so
320:08 - so um
320:11 - we're going to implement the interface
320:14 - right so
320:16 - we have this and then
320:19 - we're going to say is we just
320:22 - we just return increment and that's it
320:27 - all right so and and we're going to copy
320:29 - this
320:31 - and change the strip decrement because
320:33 - we are going to demonstrate two actions
320:36 - right um increment and decrement
320:40 - action
320:41 - and then come over here we call it
320:44 - uh
320:46 - decrement action and then here
320:57 - again i want to mention that the reason
320:59 - why we use classes
321:01 - as actions instead of just use a string
321:04 - or constant or enumeration
321:07 - is that sometimes
321:09 - action will not only carry the
321:11 - information about the name of that
321:13 - action to identify what type of action
321:15 - it is but also carry some
321:19 - useful information like functional
321:21 - information in it for example
321:24 - if we were to allow our user to set the
321:27 - count of the counter directly instead of
321:31 - just incremental decrement we need to
321:33 - allow the user to input a number
321:36 - right and when we
321:39 - create a
321:40 - set number action
321:43 - that actually need to contain that
321:45 - number the user input
321:47 - in that case having a class like this
321:50 - right and then input a
321:53 - sorry implement a
321:56 - no property
321:57 - like this
321:59 - well it's going to be a number right
322:03 - like this
322:04 - will help us to
322:07 - transfer that information from
322:09 - the component to the dispatcher and from
322:12 - dispatcher dispatch to different
322:15 - components that subscribe to this
322:16 - spectrum so that's the reason why we
322:19 - need classes
322:21 - and another thing about the good thing
322:23 - about classes is that you can see all of
322:26 - the actions
322:27 - that the
322:29 - particular store
322:30 - has to handle
322:32 - so so now we have two actions and let's
322:35 - go ahead and implement this pattern okay
322:38 - this pattern should be outside of the
322:39 - store so i'm gonna add a class right
322:41 - here and
322:44 - let's call it
322:46 - action dispatcher
322:50 - action dispatcher
322:53 - so action dispatcher
322:55 - will will allow
322:57 - different stores to subscribe to it
322:59 - right so
323:01 - remember this is a publish subscribe
323:02 - pattern which is also called observer
323:04 - pattern right so first we need
323:08 - a
323:09 - you know we need action
323:12 - and
323:14 - we just call it
323:17 - registered
323:19 - action handlers
323:24 - right and then we're going to have a
323:27 - public
323:28 - method register
323:30 - right we register basically
323:33 - or maybe you should call it subscribe
323:36 - okay
323:37 - um
323:40 - subscribe
323:42 - so we're passing an action which is
323:44 - delegate right um
323:46 - passing the
323:48 - action handler
323:52 - and
323:54 - we're gonna
323:55 - call register action handlers
323:58 - we do
323:59 - we attach the handler
324:02 - and that's it and
324:04 - and another one will be the
324:10 - and
324:11 - action handler as well and only thing
324:13 - that is different is
324:16 - doing this
324:17 - and of course we need our it's actually
324:20 - very simple
324:21 - we need our dispatch method
324:24 - which will be called
324:26 - by our component dispatch different
324:28 - actions
324:29 - so
324:30 - we'll just do this and then here we're
324:32 - just saying already store if it exists
324:36 - then
324:37 - we invoke and pass in the action all
324:39 - right to simplify this
324:41 - we can
324:42 - include this
324:44 - magic wand
324:46 - symmetric one thing and this expression
324:48 - body right and we do the same thing here
324:52 - it will make it look
324:55 - way simpler same thing will make look
324:58 - simpler but remember this dispatcher
325:00 - right it has to be called by all kinds
325:03 - of components so we need to do
325:06 - dependency injection in order to do the
325:08 - dependency injection we need to have a
325:10 - interface
325:11 - and we don't have to do it line by line
325:15 - so we can just
325:16 - go to edit and then go to refactor and
325:20 - then
325:21 - select extract interface right
325:24 - right here we can also just do ctrl r
325:28 - i
325:29 - right ctrl r ctrl i so this will so i
325:31 - action dispatcher
325:34 - and we're going to create a new file
325:36 - and
325:37 - we are going to have
325:40 - uh all three methods to be included
325:44 - all right so let me implement that and
325:47 - the i action dispatcher is right here
325:48 - and that's exactly what we need
325:52 - okay now we need to go to startup
325:55 - and
325:57 - right over here and we don't want to do
325:58 - a single 10 right here because if we do
326:01 - a singleton then
326:03 - the action will be dispatched to
326:05 - different users
326:06 - we want to be scoped to the
326:10 - the connection so we call it you can
326:14 - still use scoped and then we are going
326:17 - to use i
326:18 - action
326:20 - dispatcher
326:22 - okay and
326:23 - associate that with
326:26 - the concrete implementation
326:29 - and that's it
326:31 - for uh dependence injection
326:34 - configuration
326:36 - so now we have the action dispatcher we
326:39 - have implemented the the action the
326:42 - actions which are the increment and
326:44 - decrement action
326:46 - now what we need to do is
326:48 - we need to use it
326:50 - in our store because our store
326:53 - need to be able to handle those actions
326:55 - right
326:59 - so
327:00 - we will
327:03 - depend is inject
327:07 - first we need to dependency inject
327:10 - dispatcher
327:12 - with dispatcher and
327:15 - control
327:16 - dot
327:18 - will select the
327:22 - second one
327:25 - okay so i have this that actually
327:27 - dispatcher action dispatcher
327:30 - so this is
327:32 - right here and it put it right inside
327:35 - our observer pattern here and i don't
327:37 - want it to be here
327:39 - so
327:41 - i will put it
327:43 - up here
327:44 - actually i'll put it up there
327:47 - and then
327:49 - so i have a dispatcher and what we need
327:52 - to do is that we need to
327:54 - register
327:55 - to the dispatcher so what we can do is
327:58 - actually dispatcher dot register
328:01 - actually subscribe
328:02 - right
328:03 - and
328:05 - we need to subscribe we can put in our
328:06 - action handler and where is our extra
328:08 - action android we don't have it yet
328:10 - so
328:12 - so
328:14 - right under done under here we can
328:16 - create the action
328:18 - uh
328:19 - the handler
328:20 - which
328:22 - can be a
328:25 - uh
328:26 - private
328:27 - method and no actions and
328:32 - we need to be able to pass in different
328:35 - kinds of actions
328:39 - right that's why we need action
328:43 - and
328:45 - and
328:46 - then we can subscribe we can pass into
328:48 - this
328:49 - so this is the um
328:51 - action handler right
328:54 - in here
328:56 - so in here we're also facing the same
329:00 - question are we going to call and
329:01 - subscribe here
329:03 - okay so are we going to implement the
329:08 - destructor
329:09 - right the finalizer
329:11 - that
329:15 - so i'm sorry
329:17 - are we gonna do this
329:19 - counter store and uh
329:22 - i'm gonna say
329:25 - desktop action dispatcher
329:28 - dot unsubscribe
329:31 - window
329:32 - actions
329:34 - are we gonna do this uh i would say we
329:37 - don't need to because
329:38 - they both scope to the same
329:41 - actual same connection right
329:43 - so they have the same lifespan
329:47 - so when one is collected the other one
329:50 - is also gone
329:52 - so
329:53 - in order to simplify our goals i'm not
329:55 - going to implement that
330:01 - so here
330:02 - we are going to handle different kinds
330:05 - of actions and we have a choice to not
330:07 - handle every
330:08 - not handle every action because
330:10 - dispatcher is going to dispatch all
330:12 - kinds of actions to all kinds of
330:14 - components that are
330:16 - subscribed to the dispatcher right so
330:20 - all
330:21 - components the subscriptive dispatcher
330:23 - will need to determine whether the
330:26 - action is something that
330:29 - that they want to handle so
330:31 - because every action has a name
330:34 - right so we can use that so in here we
330:38 - can say
330:39 - increment action remember it has a
330:41 - constant so we can do this
330:44 - and then decrement
330:46 - if it's a decrement action
330:48 - decrement
330:50 - action then it also has
330:53 - has its name
330:56 - action dot name
331:00 - so
331:01 - we can
331:02 - uh
331:03 - in here what we need to do is that we're
331:05 - gonna call the increment account
331:10 - that we implemented last time right and
331:12 - then
331:13 - here we're going to call decrement
331:18 - and
331:18 - this can become private
331:25 - so
331:27 - so we registered
331:29 - right we subscribed here and then we're
331:31 - handling the actions right here
331:34 - and now we need to go to our counter
331:36 - because you're going to see problems
331:38 - here that this is private
331:41 - so
331:42 - in order to fix this problem so we are
331:45 - not actually
331:46 - directly calling this method anymore
331:49 - we are going to
331:52 - independently project
331:55 - our
331:56 - eyes pattern
331:58 - action dispatcher
332:01 - so
332:02 - we call it action
332:06 - actually this
332:07 - patchy
332:11 - and then in this increment here we're
332:14 - going to dispatch
332:16 - a action and what that action is it's
332:19 - going to be the increment action
332:23 - and that's it
332:24 - so
332:25 - this
332:27 - uh because this is
332:28 - um
332:30 - in the memory it's centralized and this
332:32 - will publish this action to all the
332:35 - stores in the store well currently we
332:37 - only have one store to deal with this
332:39 - uh 12 stores and the store will
332:42 - will determine that we're going to
332:44 - handle it or not in our counter store
332:47 - yes we're handling both the increment
332:49 - and decrement okay so this right here we
332:52 - will still keep it right here because
332:55 - uh this remember we are two level of
332:59 - we have two levels of observer patterns
333:02 - so this
333:03 - is to
333:05 - attach listeners to the store in order
333:07 - to get notified when the state changes
333:11 - so this we have to keep right here the
333:13 - only thing we need to change is this
333:15 - action dispatcher thing so instead of
333:17 - calling the store directly we're
333:19 - dispatching this action
333:22 - through the action dispatcher
333:24 - and to
333:25 - that will actually publish the actions
333:27 - to all of the stores that subscribe to
333:30 - the action dispatcher
333:32 - right
333:33 - so
333:34 - let's give that a try so i'm gonna do
333:37 - control f5 running the application right
333:40 - here yeah that works
333:44 - okay so this is
333:46 - uh how i implemented the dispatcher you
333:50 - can implement in different ways
333:52 - another thing you can do is
333:55 - you can have this
333:57 - action dispatcher action interface and i
334:00 - action dispatcher you can extract this
334:02 - into a class library and use it in
334:05 - different kinds of projects
334:07 - and
334:08 - you can even
334:10 - implement a store
334:12 - state store base
334:15 - and in there
334:16 - you kind of subscribe to the action
334:19 - dispatcher
334:21 - and when you implement a stage store you
334:24 - can just
334:25 - inherit from state store base
334:28 - so that you don't have to do this
334:30 - subscription
334:32 - all the time
334:37 - in this section we're going to talk
334:39 - about authentication in server-side
334:41 - laser first let's have an overview of a
334:44 - typical authentication system and see
334:46 - what are the components in a typical
334:48 - authentication system so that we know
334:51 - what we are going to configure
334:53 - because to configure authentication for
334:56 - sp.net core there's many
334:58 - components
335:00 - so
335:01 - having a
335:02 - big picture
335:03 - will help us to understand what we are
335:06 - actually configuring
335:08 - right so there's three basically there
335:10 - are three different layers
335:12 - of any authentication system so we'll
335:14 - have the ui layer which will interact
335:16 - with the users to register
335:19 - login recover password
335:21 - manage user profile etc
335:26 - and then we'll have the
335:27 - core functionality for authentication
335:29 - which is to authenticate and to
335:31 - authorize
335:33 - right so this is where we
335:36 - receive the user information and
335:39 - we authenticate the user information or
335:42 - authorizing from information right so we
335:45 - will have a
335:47 - ticket either ticket or token to deal
335:49 - with
335:50 - and then we verify the ticket and see
335:52 - whether it's valid that's the
335:54 - authentication and then we'll see
335:56 - whether the user has
335:57 - sufficient permission to
335:59 - access the resources the user is trying
336:02 - to access so that's the authorization so
336:05 - it fails for authentication then it will
336:07 - return http 401 which is unauthorized
336:12 - right and if it
336:14 - fails to
336:15 - offer fails on authorization then it
336:17 - will um return http 4 3 which is
336:21 - forbidden
336:22 - and last but not least
336:24 - this is the db or the rm or the db and
336:28 - rm
336:29 - combination
336:31 - that's where the
336:32 - user information the rows information
336:35 - and everything else the claims are
336:37 - stored
336:38 - and
336:39 - the data is
336:41 - and operated
336:43 - right like saved or updated
336:47 - or deleted
336:48 - so those are the main
336:51 - parts of a typical authentication system
336:54 - so now let's look at
336:57 - how we gonna configure them
336:59 - first let's create a server setup blazer
337:03 - application
337:14 - and let's select later server site and
337:17 - let's change authentication to
337:19 - individual user accounts and store it
337:23 - under user accounts in app
337:25 - right we're now going to
337:27 - cover the cloud scenario and then let's
337:30 - click on create so
337:32 - then let's first take a look at the
337:34 - project file
337:37 - so remember we have three parts the ui
337:40 - the functionality as far as the database
337:43 - okay so for
337:45 - database
337:46 - this is the package okay this is the new
337:48 - get package that we're using which is
337:51 - the rm
337:53 - which in this case is led framework core
337:56 - okay
337:57 - and uh
337:58 - for
337:59 - functionality
338:01 - we're using identity framework
338:03 - right so this is the identity for led
338:06 - framework core
338:07 - so this handles the authentication and
338:10 - authorization
338:11 - and for the ui so this is the package
338:14 - that contains all of the default user
338:17 - interfaces
338:18 - that handles login logout register
338:23 - and all those other
338:25 - user interfaces
338:27 - okay and then let's look at the startup
338:30 - file and see how these
338:32 - different packages are configured
338:34 - right how those three different layers
338:36 - are configured
338:41 - so we have configure services and
338:43 - configure so configure services
338:45 - are configuring those basically the
338:47 - packages right and the configure
338:50 - method is actually configuring for
338:52 - office configuring the
338:54 - middleware
338:55 - right so again
338:58 - we're going to look at our you know
339:00 - database or rm configuration which
339:03 - happens right here on the top
339:05 - right so this configures
339:07 - our
339:08 - entity framework
339:10 - and it's
339:12 - it uses this connection stream which
339:14 - comes from
339:17 - this app settings
339:19 - right so this is
339:23 - our connection stream
339:25 - this is our database and then
339:28 - uh the second one this is configuring
339:30 - the functionality this is configuring
339:32 - our
339:34 - identity framework
339:36 - right
339:36 - and
339:38 - also
339:40 - providing a identity user model this
339:43 - model corresponds to the spdat user
339:46 - table in our database
339:49 - okay so basically this
339:52 - configures the identity framework also
339:55 - connects
339:56 - from here
339:57 - back to the database here right and this
340:00 - is providing that model that corresponds
340:03 - to that and this is the the database
340:05 - context which corresponds to the
340:08 - database and then so basically this
340:10 - configures the database this configures
340:12 - the functionality so which part is
340:14 - configured in the uh the ui so
340:17 - there is a the ui is actually inside
340:20 - the solution uh but
340:23 - this authentication state provider
340:26 - this is
340:28 - when the ui needs information of the
340:30 - current login user
340:32 - that's uh
340:34 - that's what this is for
340:35 - all right so this gives us the user
340:38 - information
340:39 - then let's look at the configure method
340:42 - and the configure method
340:44 - uh it configures the middleware for
340:46 - authentication
340:47 - okay so
340:49 - this
340:50 - user authentication and use
340:51 - authorization there are two middlewares
340:53 - that handles the
340:54 - authentication authorization
340:57 - when these middlewares are being used it
341:00 - look looks for
341:02 - specific concrete implementations of
341:05 - certain
341:07 - interfaces like eye authentication
341:09 - handler right and those interfaces are
341:12 - actually implemented inside
341:15 - the identity framework which we have
341:17 - dependency injected by using these
341:20 - these calls
341:22 - so then
341:23 - you're for authentication authorization
341:26 - it will use
341:27 - these injected classes
341:30 - to to finish those works
341:33 - and then last but not least
341:35 - this map controllers can configures the
341:38 - routing for our
341:40 - default user interfaces because
341:43 - we're going to see
341:46 - that the
341:47 - user interfaces are
341:50 - not laser components right not reader
341:52 - components
341:54 - but
341:54 - reader pages so those razer pages
341:58 - need
341:58 - a default routing
342:01 - which is the default attribute rotting
342:04 - and also
342:05 - this map controllers
342:07 - uh set up the
342:08 - default reader page rotting which is
342:12 - actually
342:13 - according to the the page structures
342:17 - and that's uh
342:20 - now let's run this
342:23 - so first we need to register user we can
342:26 - use any
342:27 - email doesn't matter
342:30 - right and then
342:32 - we're gonna give it a password
342:37 - and then we register
342:43 - this comes up because there isn't a
342:45 - database right so we need to apply our
342:48 - migration to create that data because if
342:50 - we look at our data folder we can see
342:52 - this migration here that actually create
342:56 - all these tables the rows the users and
343:00 - all of the the other ones right the role
343:02 - claims
343:03 - the user claims everything else right
343:07 - so these tables are only
343:10 - for now
343:11 - models in
343:13 - our c sharp code so those c sharp codes
343:16 - has to be mapped to the database and
343:17 - that database has to be created first by
343:20 - clicking on apply
343:22 - migrations
343:23 - it's going to run this
343:25 - these mega research migrations and the
343:27 - database will be created so that's um
343:31 - that's entity framework
343:33 - so i'm gonna click click on apply
343:35 - migrations
343:40 - right okay so register confirmation so
343:43 - we click here to confirm our account so
343:45 - normally this is going to send an email
343:47 - but here it's just a dummy one
343:49 - and then
343:50 - because we have already
344:00 - register so we are going to
344:05 - login
344:07 - okay so we logged in
344:09 - right now
344:10 - we can access
344:12 - all of these
344:14 - what if we log out
344:15 - can we still access all of them yeah we
344:17 - can still access all of them so then how
344:20 - do we secure our blazer components
344:24 - okay to see you secure a specific
344:26 - component for example if we want to
344:28 - secure our
344:30 - counter and both counter and fast data
344:33 - pages then we go to the component we go
344:36 - under pages go to counter
344:38 - and we use
344:40 - we give it attribute right so
344:43 - which is um
344:45 - if you're familiar with sp on an mvc or
344:48 - a speedometer coordinate c or
344:51 - so this is a
344:54 - attribute sorry uh
344:57 - the authorized attribute that you you
345:00 - usually use for your controllers
345:03 - so we use this here and then we copy it
345:06 - to fetch data as well
345:09 - so now
345:10 - uh
345:11 - we go back to our component refresh go
345:14 - back to our
345:16 - page and refresh
345:17 - that's good so both counter component
345:20 - and fetch data component
345:23 - says not authorized so this is how we
345:26 - secure our individual components
345:28 - another thing we can
345:30 - use is the authorized
345:32 - view component
345:34 - which we can the authorized view
345:36 - component is a templated component
345:39 - so
345:43 - we can use that
345:48 - to
345:49 - so it has two templates which first one
345:52 - is authorized
345:54 - right and
345:56 - second one is
345:58 - not authorized
346:00 - okay so these are the two templates and
346:02 - if we copy all of these
346:09 - actually
346:10 - let's
346:12 - leave the title outside
346:14 - to make it more realistic
346:16 - because we are not going to hide our
346:18 - title
346:20 - but
346:21 - we are going to hide everything else
346:23 - to be inside the authorized view
346:27 - and then
346:28 - you say you are
346:30 - not
346:32 - authorized
346:37 - please
346:38 - contact
346:40 - admin
346:42 - then here we can remove this
346:45 - and come over here and refresh the data
346:47 - refresh the page
346:49 - going over here you can see you are now
346:51 - authorized please contact with me go to
346:53 - counter you see not authorized okay
346:57 - and
346:59 - so this is the this is so removing that
347:03 - authorized that's important so don't use
347:05 - that authorized attribute because when
347:08 - you use this
347:09 - it's not controlled by the authorized
347:12 - view
347:13 - component
347:15 - right it's controlled by something else
347:18 - so this using authorized view and the
347:22 - authorized template as well as not
347:24 - authorized template
347:26 - we have covered this so if we revert
347:29 - let's revert all of these
347:35 - okay
347:36 - and we use this so how do we provide a
347:40 - global authorized view that's under the
347:44 - app component so here you can see that
347:48 - we have this authorized walk view which
347:50 - is also a
347:54 - a template component
347:57 - right so here
347:59 - we can give a global
348:05 - information about not authorized in here
348:08 - it's say you are
348:13 - or you don't
348:16 - have her
348:18 - permission to
348:19 - access the page please
348:23 - contact
348:24 - admin okay so if we do this
348:27 - you can see that you don't have
348:29 - permission to access the page please
348:30 - contact me and if you go to fetch data
348:33 - you see the same thing so both of these
348:36 - are seeing this uh same message so this
348:40 - is how you
348:42 - provide
348:43 - the not authorized message globally
348:47 - but if you want to provide an individual
348:49 - message message you can use the
348:50 - authorized view like what i've just
348:52 - showed
348:54 - another thing
348:55 - that
348:56 - you typically want to do is to
348:59 - utilize the user state or the user
349:02 - information inside your logic so for
349:05 - example under the home page if we want
349:07 - to display some user information here
349:10 - right so we're going to go to our uh
349:14 - index component which is the home page
349:16 - so i'm going to do this survey thing
349:18 - and then
349:19 - give some line break
349:22 - and here if our logic requires
349:25 - user it requires us to provide some uh
349:30 - to
349:31 - to utilize the user information that
349:34 - comes from the authentication state so
349:38 - if we go to our app component on the
349:40 - root component again we can see this
349:43 - cascading authentication state and this
349:45 - is similar to the this is similar to
349:47 - cascading value we're actually cascading
349:50 - the
349:51 - authentication state down to the
349:53 - component tree
349:55 - right so in order to use that cascading
349:58 - parameter we need to declare a cascading
350:02 - parameter here
350:04 - so first we have this
350:06 - code block
350:07 - and then
350:08 - we're going to declare a cascading
350:12 - parameter
350:13 - and
350:14 - that parameter is going to be because by
350:18 - default cascading parameter are mapped
350:20 - to the
350:22 - parent level
350:24 - the root level by type right so here is
350:28 - authentication state so this is the type
350:31 - of
350:32 - state
350:33 - we're going to keep this as a product
350:36 - parameter it doesn't need anywhere else
350:39 - so we can use this
350:40 - and then
350:42 - certainly we can use this as a
350:46 - in
350:47 - user actions for specific logic
350:50 - but
350:51 - what i would do for the demonstration is
350:54 - i'm going to
350:56 - override the uh initialized
350:59 - async and then in here
351:04 - we're going to say this off state we're
351:08 - going to actually await
351:10 - this off state
351:14 - right
351:16 - okay let's change this to
351:18 - underscore all state
351:20 - and then here we're gonna
351:23 - say
351:26 - state
351:28 - and
351:29 - we are going to
351:32 - use this
351:34 - and what we're going to do is
351:36 - i'm going to say if
351:38 - our state
351:40 - is not
351:42 - it's not now
351:44 - then we're going to display some uh
351:47 - some information about the user
351:50 - right so
351:51 - let's say the username is
351:56 - uh
351:57 - state dot
351:59 - user.identity.name
352:03 - over here we're gonna flip through all
352:05 - of the claims
352:20 - okay let's all of that please
352:26 - and we're gonna display
352:37 - type
352:42 - okay and i'm gonna display
352:44 - um
352:56 - value
353:04 - all right so this is so this is how we
353:07 - are going to get the
353:09 - authentication state which is basically
353:12 - we're using the login user information
353:17 - so let's test this
353:18 - we'll refresh the page we don't see
353:20 - anything because we didn't log in so
353:22 - let's login
353:24 - uh
353:27 - my password
353:32 - and we don't see anything
353:35 - oh okay okay
353:36 - so
353:37 - that's because of this
353:43 - refresh
353:44 - all right so we have this
353:46 - username it's just basically the email
353:48 - address and then we have all of these
353:51 - claim type and claim
353:53 - claim values
353:56 - not very useful
353:58 - in this case but
354:01 - it could be useful in
354:02 - if we ask some more meaningful claims at
354:05 - least this uh
354:07 - this name and the value this is more
354:11 - meaningful
354:13 - all right so that's how we use the
354:16 - authentication state inside our
354:18 - component
354:19 - next one is if we were to
354:21 - customize our identity
354:24 - uh framework model let's first look look
354:28 - at our database
354:30 - okay so this is the database we're
354:32 - connecting to our
354:34 - local
354:36 - local db right so
354:38 - let's
354:40 - go to server explorer
354:46 - so this is going to be our database and
354:49 - testing connection everything is fine
354:52 - click on ok c is
354:54 - the tables so we have the esp9 users
354:57 - table
354:58 - right
355:00 - it has all these information what if we
355:02 - need something else inside here let's
355:04 - say we're designing a
355:07 - you know a education system
355:10 - or a learning system and we need a
355:13 - school
355:15 - information for each user
355:18 - right we need to be able to store in
355:20 - here so then how do we customize the
355:22 - model so in order to customize the model
355:26 - under here we can create a
355:34 - a class i would call it sp
355:37 - net
355:38 - uses
355:40 - users
355:41 - right
355:45 - and uh currently
355:48 - if we look at our iterations and their
355:51 - which we have seen it's using the
355:53 - identity user right
355:55 - so what we will do is we're gonna
355:59 - inherit from
356:01 - the identity user
356:04 - okay
356:08 - here's our
356:09 - identity name space
356:11 - and uh
356:13 - so because we're inheriting from the
356:16 - identity user so we will have all of the
356:17 - existing columns
356:19 - but what we need is a
356:22 - new column that is called
356:24 - school
356:25 - right
356:26 - which has a string type
356:30 - so that
356:32 - we next we're going to go to our
356:34 - application
356:36 - uh
356:37 - db context in here we need to provide
356:40 - our specific user type
356:43 - right the user
356:44 - model the corresponds to that asp.net
356:47 - users database okay so we actually have
356:50 - this
356:51 - just created here
356:53 - right so
356:54 - just to be sure
356:56 - f12 goes to the class that we just
356:58 - created
357:00 - right and next thing we need to do is
357:02 - inside the startup uh instead of use the
357:06 - default identity we can just uh we can
357:09 - change it to use identity and change
357:12 - this to
357:13 - sp not users right
357:17 - and then
357:21 - the second parameter
357:23 - identity row
357:25 - and then we would add a migration
357:29 - so in order to do that we're going to go
357:32 - go to our
357:34 - tools
357:36 - new git package manager console i'm
357:38 - going to say add
357:40 - dash
357:42 - my migration
357:45 - uh we say
357:48 - extended
357:51 - asp
357:53 - net
357:54 - users
357:55 - all right so build succeeded generated
357:58 - the migration second version
358:01 - uh in the up method we can see it added
358:05 - school column we go back to the
358:07 - console here
358:09 - and
358:10 - we're going to say
358:11 - update
358:12 - update database
358:14 - build succeeded okay start
358:17 - let's look at our server explorer and
358:20 - whether the whether we ever
358:22 - refresh it
358:24 - do we see school yes we see school
358:27 - right so we added this
358:29 - so that's how we customize our model so
358:32 - now let's talk about how we can
358:33 - customize our user interface so if we
358:36 - look at the
358:37 - project structure here we can see in
358:39 - areas
358:41 - the errors folder which contains some
358:44 - pages under account we have a logout
358:46 - page
358:47 - right then we have a login partial what
358:50 - if we
358:51 - want to customize the register page
358:54 - right where do we do it how do we do it
358:56 - we go to right click on the project
358:58 - click on add and then here there is a
359:01 - new stuff scaffolded item click on this
359:05 - we choose identity select identity here
359:07 - click on add now it says scaffolding
359:10 - right it's trying to find inside that
359:13 - you get packaged wood are actually
359:15 - included inside that new gap pack here
359:18 - we can see all of the user interfaces
359:20 - that we can customize
359:23 - so we are going to customize the
359:25 - register
359:29 - user interface and
359:33 - so this scuffle is going to connect from
359:36 - ui all the way to the database that's
359:37 - why it needs to select a database
359:39 - contact data context class right which
359:42 - is this one that we have and then we
359:44 - click on that
359:48 - and then it says it's scaffolding all
359:50 - right so under the areas we are going to
359:54 - see a register
359:56 - reader page here
359:59 - right so we have this freezer page here
360:02 - what if we want
360:04 - a
360:06 - uh
360:07 - what if we want to add the school
360:08 - information here
360:11 - right so we're going to
360:13 - go over here and if we look at our
360:17 - input model which is here
360:20 - email password
360:22 - right confirm password what if we
360:27 - need school
360:30 - information here so
360:32 - we're going to say
360:36 - school
360:38 - and
360:39 - this is
360:40 - school
360:42 - right and on post
360:44 - on post we're going to say
360:46 - school
360:48 - equals
360:49 - input.school
360:51 - so this is the information that will be
360:53 - will be used later and to persist the
360:57 - data into the database
361:00 - so our our logout page are still using
361:02 - identity user
361:04 - in fact we can just search
361:06 - in the whole solution
361:08 - to see where our identity user stu are
361:12 - and then we'll replace
361:14 - all of them so inside here we have
361:17 - identity user so we're gonna have to use
361:20 - our identity user
361:29 - okay to solve that problem uh we can
361:32 - come over here
361:33 - and uh
361:35 - we can say
361:38 - add default
361:40 - ui
361:42 - to go to default behavior and then
361:45 - add default token providers as well
361:49 - okay that should fix the problem and now
361:53 - let's run
361:54 - the application again
361:56 - and if we register
362:00 - okay so we're missing the school
362:03 - field let's go to our register
362:06 - raiser component let's copy this
362:10 - all right so it's going to be here and
362:13 - then
362:16 - school
362:18 - copy and paste
362:21 - and that should do it let's
362:25 - build
362:26 - the solution again
362:31 - and come over here refresh the page
362:33 - we will see
362:35 - so school field and let's do our tester
362:39 - at
362:40 - gmail.com that's tester2
362:45 - okay and password is going to be our
362:48 - password
362:52 - and school is let's call it my school
362:55 - and then click on register
362:59 - okay so
363:01 - i'm going over here and then
363:07 - all right so we have our
363:11 - uh
363:12 - page
363:14 - and
363:16 - we're able to access all of these
363:18 - um so now let's take a look at our
363:23 - espy.net user table to see whether that
363:25 - email is there let's run a query new
363:29 - query
363:32 - i don't know why the screen is flashing
363:34 - like this
363:35 - so let's select star as net users
363:39 - and then let's run a query like this
363:44 - and we have
363:46 - test her too and the school is my school
363:54 - right okay so we have successfully
363:57 - customized our user interface to include
364:00 - our new field which is the school field
364:03 - and we also successfully customize the
364:07 - asp.net users table
364:12 - by going through the led models and add
364:15 - migrations update database
364:21 - i want to create a data grid component
364:24 - i want my datagrid component to be very
364:27 - similar to
364:29 - device devexpress or dive stream data
364:32 - great component at least i will have
364:34 - some column configurations
364:37 - i will
364:39 - have the functionality of sorting and
364:41 - paging and perhaps something else as
364:43 - well
364:44 - so in this video i'm going to cover the
364:47 - column configurations
364:50 - so let's get started this is a
364:52 - server-side laser
364:54 - default template from visual studio so
364:56 - let's create the datagrid component
365:03 - under the controls folder
365:08 - razer component
365:14 - so in order to have
365:16 - the data passed in
365:18 - i needed to be
365:23 - to have a
365:24 - generic type
365:28 - and then
365:28 - from there
365:31 - i need to use the generic type
365:33 - to have a
365:34 - list of items
365:42 - and let's call up data items after that
365:46 - i need to define like to configure the
365:48 - columns
365:50 - and for that i need my columns to have
365:54 - to indicate what kind of data field
365:57 - within the t item
365:59 - that
366:01 - that we're going to use for the column
366:03 - and we'll come caption
366:05 - uh data type and format and alignment
366:08 - as well
366:10 - so let's have a
366:13 - configuration folder
366:16 - okay and let's create a column
366:19 - definition class
366:26 - so have this and what i need is
366:29 - data fill
366:32 - and i would need the caption as well
366:37 - right because
366:38 - the name of the column we know can
366:41 - may be different from the caption
366:44 - of that column
366:46 - and then i would need the data type
366:50 - so for that i would need a data type
366:53 - class
367:00 - right it has
367:03 - nut set string number date date time
367:06 - boolean currency
367:09 - and
367:11 - i would use it here as a data type
367:16 - and after that i will have a
367:20 - format and this format is i plan it to
367:23 - be a free format that's why it's a
367:25 - stream
367:27 - and then i would have alignment as well
367:30 - and for that i will create alignment
367:33 - class
367:37 - and that i will create here
367:44 - and it's going to be an enumeration as
367:47 - well
367:48 - and it has not set
367:50 - left center right
367:57 - okay so with the column definitions
368:02 - i want to have a
368:04 - constructor
368:06 - of this and i want to initialize
368:09 - the data type
368:10 - to be
368:13 - set
368:16 - now everything is not sad at the
368:17 - beginning right
368:22 - alignment not set
368:24 - okay
368:27 - and then let's go back to our component
368:31 - and from the component
368:33 - and from the component we will have a
368:36 - list of columns
368:39 - as parameters
368:43 - so that we can define our column
368:45 - and uh i need the controls
368:49 - to be in here
368:54 - in the import file
368:56 - so the namespace is here
368:59 - so i have column definition
369:02 - i'll call it columns
369:05 - okay
369:07 - and with this i should be able to
369:11 - render
369:12 - a
369:13 - and i'm going to use the boma
369:17 - all right so i imported my bulma css
369:20 - file
369:21 - and uh
369:24 - so with that we start uh we're gonna
369:27 - start creating the html here
369:31 - and for that
369:32 - we will use a table because it's a great
369:35 - and uh
369:37 - class will be
369:39 - uh full west
369:43 - okay so it's a former
369:45 - plus
369:47 - and let's create the header first
369:50 - okay uh so we'll have um
369:53 - a row of header
369:55 - and
369:57 - if we don't have the columns
370:00 - that's where we're gonna use a
370:02 - reflection
370:03 - to
370:07 - you know
370:08 - to deal with
370:21 - here
370:22 - we'll just uh
370:25 - we will need to loop through
370:35 - and here we need to create the uh th
370:39 - element
370:40 - right so it's going to be
370:44 - um
370:44 - ph
370:46 - and then the column are captured
370:49 - so
370:51 - let's
370:52 - let's test this
370:54 - um let's use the
370:57 - index component
371:01 - and uh let's import i think we import
371:04 - that already so we will have our data
371:07 - grid while we don't
371:09 - and that's because yeah we don't have it
371:12 - yet
371:13 - we have this let's import this namespace
371:16 - controls
371:17 - and then we go back to here
371:21 - we can have our data grade
371:24 - and i don't know why it's still
371:26 - complaining that
371:28 - uh
371:30 - so
371:32 - controls
371:34 - and let's go back to here
371:36 - and we'll data grade
371:39 - degree component
371:41 - and we have our
371:45 - data items column definition and
371:47 - everything right so let's just use it
371:49 - just for now it's going to complain but
371:51 - let's add this
371:52 - code here
371:54 - then we need to initialize the
371:56 - definition and stuff okay with that um
372:02 - we have i have some definitions created
372:05 - for um
372:08 - i have some data created
372:10 - from previous videos
372:12 - uh and i have extended that
372:15 - so let's just copy that over
372:17 - so i have an employee
372:20 - class specified here
372:24 - right and i need to
372:26 - define a list of employees
372:29 - um
372:30 - in here
372:32 - and initially i need to initialize that
372:35 - i also need a column definition
372:41 - right
372:42 - and that's
372:43 - that is here
372:44 - and
372:46 - i have my initialization
372:48 - method created already
372:52 - so let's copy and paste that over here
372:54 - and let's take a look
372:56 - what it's trying to do is it's trying to
372:58 - initialize
373:00 - if it's null then we create a new
373:02 - definition and that of definition has
373:05 - name title department employee
373:07 - employment date and salary and captions
373:10 - are named title department employment
373:13 - date with the space
373:14 - salary is
373:16 - annual salary
373:18 - right and then we have our employee list
373:22 - hardcoded over here
373:24 - just for testing the data component data
373:27 - great component
373:29 - so
373:30 - with this
373:31 - we can specify the tm
373:34 - t item to be employee
373:38 - right and then we can specify
373:41 - our data items to use the list employees
373:47 - and then we can use
373:49 - we can assign the column definition to
373:51 - columns
373:54 - okay so with this i expect that the
373:57 - component starts showing
374:03 - i expect the components start showing
374:05 - something
374:06 - okay so we have nothing here
374:12 - we have nothing here and that's
374:15 - because we are not calling the
374:17 - initialize method yet
374:19 - so
374:20 - we're going to overwrite it and we're
374:22 - going to call the uninitialized
374:26 - lifecycle event
374:29 - so that our
374:30 - list employees
374:33 - sorry so that we can initialize
374:39 - this
374:40 - right here
374:42 - right so both have column definitions
374:45 - both have both
374:47 - we're checking whether it's now or not
374:50 - on both
374:51 - attributes
374:52 - so
374:53 - uh
374:54 - so we're using so it's okay to use it in
374:57 - the uninitialized
374:58 - lifecycle event because the
375:00 - uninitialized left circuit un is
375:02 - actually being called twice if you have
375:04 - watched my previous episodes
375:07 - you know this
375:10 - it's going to cut twice on the first
375:12 - first
375:13 - page load
375:15 - so
375:15 - um
375:17 - and
375:17 - we made a change and go back and refresh
375:20 - the screen all right so we have our name
375:22 - title department implemented in annual
375:24 - salary
375:26 - so that's pretty cool and we noticed
375:28 - that we have a space here and a space
375:32 - here
375:33 - so it's actually picking up the um
375:37 - the caption and that's that's pretty
375:39 - good uh so the next thing we are going
375:41 - to work on is uh
375:44 - we're going to display the data right
375:46 - so for that since we have already
375:49 - initialized data
375:51 - let's go back to our data grid component
375:54 - and let's
375:57 - add the t-body
376:00 - body element and from here
376:03 - what we need to do is just simply loop
376:07 - through the data items
376:10 - right
376:11 - and in here we have the rows
376:15 - and we just need to
376:17 - you know
376:19 - go
376:23 - also loop through the columns
376:25 - and uh
376:27 - provide so
376:29 - inside the double loop
376:30 - we use
376:32 - um
376:33 - reflection
376:35 - t item
376:37 - and then we just got property
376:40 - got what property and that's where the
376:43 - data field
376:45 - you know the data field is being
376:48 - used here right because if we go back to
376:51 - column definition we can see the data
376:53 - field here and if we go back to our
376:56 - initialization data initialization
377:00 - we can see that the
377:02 - data data field
377:04 - you know it corresponds to each one of
377:06 - the properties in the employee class
377:09 - right
377:09 - so
377:10 - here
377:12 - so we use the reflection and provide the
377:15 - data field as the name of that property
377:17 - and that's that will get our
377:19 - corresponding property from the employee
377:22 - class
377:23 - right and here we just need to get value
377:25 - and get value of what value of the
377:27 - current
377:30 - current item
377:33 - right and that should provide us with
377:35 - the data and let's go
377:37 - refresh the page and see whether we have
377:40 - all of the
377:41 - uh
377:42 - data displayed here all right cool so we
377:45 - have the data here
377:46 - and uh we noticed something
377:49 - that you know
377:51 - we want to have some formatting
377:54 - uh the salary is not showing dollar sign
377:58 - like it's not being displayed as
378:00 - currency an alignment for numbers should
378:02 - be aligned to the right i want to see it
378:04 - to align to the right uh i want the
378:06 - employment date to only display the date
378:09 - part so we have some formatting to do so
378:11 - let's first
378:12 - go with alignment
378:16 - do with alignment and for that we
378:19 - we already have the alignment in the uh
378:22 - in the definition and for alignment we
378:24 - have not set left center and right
378:27 - and uh to use alignment we need to
378:31 - do something with um
378:33 - header and as well as data so let's deal
378:36 - with the data since we just finished
378:37 - data here
378:38 - so
378:41 - so inside here i think
378:45 - what we need to do is um
378:48 - if
378:50 - if column
378:52 - dot alignment
378:54 - is not
378:56 - not
378:59 - otherwise if
379:00 - there is a definition for alignment
379:04 - then
379:06 - well let's implement the else because
379:12 - it's simply just this okay and if there
379:15 - is a alignment
379:17 - then we need to
379:19 - have
379:20 - um
379:21 - we have need to have it here
379:23 - so just say column dot
379:27 - um
379:28 - alignment
379:32 - yeah alignment uh i don't know
379:36 - maybe you guys can tell me why
379:38 - whenever i type
379:40 - uh whenever i use the intellisense the
379:43 - dot goes to the
379:45 - to the end of that line instead of
379:48 - instead of at the at the
379:50 - right place
379:52 - i don't know i don't know how to resolve
379:54 - that problem
379:55 - i tried space i tried
379:57 - uh enter i tried tap it has that problem
380:01 - sometimes it has that problem
380:03 - so then i go over here and i do two
380:06 - string
380:07 - um
380:08 - and then i can do i need to make sure
380:11 - it's
380:12 - lower and lower case
380:14 - right because
380:15 - it's it's left
380:18 - it's left center and right and that
380:20 - corresponds to css style so i can just
380:23 - use a tostring here
380:25 - and
380:27 - i think
380:28 - that's it for alignment at least for the
380:31 - data part right and let's go back and
380:34 - refresh and see what happens i'm
380:36 - expecting
380:37 - um
380:39 - the alignment to be to be right because
380:41 - um
380:42 - if we go back to our
380:44 - definitions here you can see that i have
380:48 - um
380:50 - alignment to the right for salary
380:54 - the salary column
380:55 - right so yeah so it's working right uh
380:59 - then we need to have the
381:01 - um
381:02 - the header to be also aligned to the to
381:06 - the right
381:07 - i need to go to uh the header part and
381:10 - then
381:11 - let's see whether
381:13 - we can do the same thing um
381:17 - we just
381:19 - copy this
381:23 - and get it over here
381:26 - and
381:27 - instead of
381:28 - using that complicated stuff for data
381:42 - yeah just remove
381:44 - this say column
381:48 - dot
381:49 - caption
381:50 - and remove this part
381:53 - and let's see whether we can get the
381:55 - alignment right okay so i got the
381:57 - alignment right but then it changed the
382:01 - changes style
382:03 - right
382:04 - so
382:06 - i think it's uh it got rid of the um
382:10 - something related to the th
382:14 - because the alignment that we assigned
382:16 - here
382:17 - oh okay so it's td
382:20 - we use td so let's go over here
382:23 - and refresh again i change to th now
382:27 - ah okay
382:29 - so
382:30 - let's inspect and see what happens
382:34 - so i have it on the other window and uh
382:37 - moving it over here
382:39 - who has the we have the alignment to the
382:41 - right but something is overriding
382:45 - uh
382:46 - this and that
382:49 - should have something to do with the th
382:50 - here
382:52 - and that's
382:59 - and what is that
383:03 - okay so inherits
383:05 - it inherits from something
383:08 - okay so if i
383:11 - yeah if i add it back
383:14 - then
383:16 - yeah then
383:23 - if i remove the
383:25 - inherit
383:28 - then it works
383:30 - so i may have to add another
383:32 - class
383:33 - and that's when that's where i usually
383:36 - in
383:37 - bootstrap or oma i create a override
383:40 - class
383:42 - and let's
383:43 - take a look at the
383:45 - and let's just create a
383:48 - override style
383:51 - stylesheet
383:54 - so stylesheet
383:56 - style
383:59 - uh stylesheet and i'll just create a
384:04 - let's call
384:16 - okay
384:17 - and uh
384:22 - in here i will have uh
384:27 - i want to create
384:28 - a
384:29 - alignment
384:30 - my
384:32 - style is also targeting th
384:35 - and
384:36 - i wanted to align to the right okay
384:39 - and that would have uh
384:41 - text aligned to the right and since i'm
384:46 - trying to override so i'm gonna use
384:48 - import important
384:50 - and
384:51 - since i'm doing this i'm gonna create
384:56 - for left center
385:00 - as well as
385:02 - right
385:06 - center
385:11 - okay
385:12 - so
385:13 - and i have that and if i go back and i
385:18 - just um
385:20 - alignment right so here i have to do
385:23 - switch statement
385:25 - switch um
385:28 - dot alignment
385:31 - right case
385:33 - column dot
385:35 - alignment dot
385:37 - uh
385:38 - sorry
385:39 - case
385:40 - alignment dot
385:42 - left right
385:45 - and case alignment dot
385:48 - center
385:50 - case alignment dot
385:53 - right
385:56 - and uh another case
386:02 - just do nothing in other case
386:04 - fix this typo
386:06 - and
386:07 - i think the formatting is weird so let's
386:10 - format it
386:12 - okay
386:13 - coming back up
386:18 - and
386:19 - so
386:21 - so instead of using it right here let's
386:23 - put it
386:25 - inside
386:27 - and
386:28 - we need to use the class that we just
386:30 - created
386:32 - so we have class
386:34 - and i will call a line
386:38 - left
386:51 - over here and if it's
386:55 - if it's alignment
386:58 - or if it's default
387:00 - then we
387:07 - and use should be okay
387:10 - let's see what happens if we refresh our
387:13 - uh
387:14 - still not working
387:16 - and why is that
387:30 - inspecting
387:35 - okay
387:36 - and
387:38 - we have our class here's our class
387:43 - we have the align right class right
387:46 - but it's not loaded
387:56 - perhaps um let's go to
387:59 - i think
388:00 - perhaps we need to
388:03 - the style sheet here
388:06 - so
388:07 - we have this already here
388:09 - and i need my phone to be here
388:16 - and
388:17 - i also need
388:20 - my uh
388:23 - override
388:25 - to be here as well
388:27 - and let's see whether
388:28 - this would fix that
388:30 - problem okay
388:32 - very cool so we have our
388:35 - class correctly
388:37 - applied here
388:38 - next thing is
388:40 - i want to have the formatting as well
388:43 - and uh and for that i uh
388:47 - planning to do something simple
388:50 - uh if we have if we go back to our
388:54 - here
388:55 - um
388:56 - where we define our columns if we have
388:59 - our format
389:02 - if we have our format see i have this
389:07 - data type
389:08 - as currency i have this format as well
389:11 - um
389:15 - and i have the format here as well so if
389:17 - there is a format then
389:20 - then i want to format it otherwise i'll
389:22 - just leave it alone right so going back
389:24 - to the data grade component and
389:28 - we need to add some formatting
389:30 - in the
389:34 - in the tea body area
389:36 - right
389:37 - and that's where we will have
389:40 - some kind of if statement right
389:43 - so
389:44 - let's say
389:45 - if
389:46 - the format is not empty
389:49 - right or null
389:51 - if column dot
389:54 - format is not empty or null
389:56 - and uh
389:58 - f column dot data type
390:01 - we also because the format is kind of
390:03 - dependent on the data type
390:06 - so i also want to say
390:08 - if it's
390:12 - if it's not
390:13 - if it's
390:14 - set already
390:16 - then i would actually
390:19 - format it
390:21 - and in here i also need to do some
390:24 - switch statement
390:25 - according to you know different data
390:28 - type
390:29 - i would format it differently
390:32 - so if it's
390:33 - date
390:37 - um
390:39 - let's state
390:41 - constant date
390:43 - you know
390:44 - state
390:46 - or if it's
390:48 - a um
390:54 - date time
390:58 - then
391:00 - i would
391:02 - you know what i'll create a
391:05 - string here
391:10 - and this is the value and if it's a date
391:12 - or the type of value would be
391:15 - in time dot
391:18 - parse
391:19 - the
391:21 - because this value is basically
391:25 - an object
391:27 - so i would have this and then i would
391:30 - call
391:31 - tostring oops
391:39 - oh okay so
391:42 - to
391:43 - stream
391:46 - and then
391:48 - i have
391:50 - you know i have this and then i just to
391:53 - string because this is a daytime and
391:55 - then i use what i use the
391:57 - column
391:59 - dot
392:00 - format
392:03 - right
392:04 - and that should do it so that's for
392:08 - uh day two or day time
392:11 - and if it's a boolean
392:17 - if it's a boolean
392:19 - then
392:20 - we're going to do it a little bit
392:21 - differently right
392:24 - we're going to say value
392:26 - sorry value equals
392:33 - again it would be similar to the daytime
392:35 - thing
392:39 - we just instead of daytime we use this
392:43 - we're gonna parse it and then
392:46 - we're gonna
392:52 - we'll just say two string
392:54 - and this should give us whether it's
392:56 - true or false
392:58 - and
393:01 - and then
393:02 - if it's currency
393:09 - currency
393:25 - uh why there is a problem here
393:29 - i don't know why okay there's no problem
393:32 - so as a currency
393:33 - um
393:36 - i also wanna just
393:37 - copy this over here and
393:41 - so
393:42 - i'm going to use
393:44 - you know it's double
393:46 - and i want to parse that value
393:49 - and
393:51 - this would give us
393:54 - uh currency i just uh you know what i'll
393:57 - just
393:58 - i'll just use this
394:01 - and i also want to
394:05 - run it
394:07 - i will use mascara and
394:10 - i'll provide
394:13 - this
394:16 - okay
394:17 - okay so i run it first and then i
394:19 - convert it to currency format
394:22 - so then i have the format here
394:25 - and so i have sorry i have the value
394:27 - here
394:28 - and
394:32 - so i have the volume value here and this
394:34 - here there is the alignment
394:36 - and i just need to put the value
394:39 - so instead of
394:41 - this i just need to use the value i
394:44 - think
394:45 - all right and that will be like this
394:49 - and
394:52 - yeah same thing as
394:53 - here
394:54 - i'll just put the value here
394:58 - um what's the complaint does not exist
395:02 - well it's right here okay
395:04 - that value
395:06 - is supposed to be
395:09 - inside
395:11 - here
395:12 - all right so that's when it has format
395:15 - and if it does not have format
395:18 - oh yeah it should use the original which
395:21 - i got rid of
395:22 - um
395:25 - yeah so let's revert
395:29 - i'll copy this first
395:32 - and
395:32 - i'll revert
395:39 - okay that's good and then i have it
395:41 - right here
395:45 - and else so this if statement is if
395:49 - there is a format
395:51 - right so
395:52 - we're dealing with otherwise here
395:54 - otherwise we just use the original one
395:57 - which doesn't go with any format
396:01 - okay so i think we're good and going
396:03 - back and refresh the screen all right so
396:06 - cool we have our um employment date
396:08 - format we have our annual salary as well
396:12 - so that's
396:13 - i think that's what i want to cover for
396:14 - today i covered um column definitions
396:18 - column configurations i covered
396:21 - uh
396:23 - formatting and i covered
396:26 - alignment
396:32 - let's implement page for a paging
396:35 - under the configuration folder i will
396:37 - need a
396:38 - paging configuration
396:41 - class
396:43 - to be able to configure paging
396:45 - so create a class
396:49 - and i'll call it paging config and i
396:52 - think
396:54 - i would
396:55 - yeah let's make it simple
396:57 - so i would have
397:01 - enabled property
397:05 - and
397:06 - page size
397:13 - and i would also have
397:15 - let's have just
397:17 - these two for now
397:20 - so yeah in theory
397:22 - if given a page number we need to go to
397:26 - that page
397:27 - right and we can do that with link query
397:30 - so with was link
397:34 - right in c sharp
397:35 - uh given a
397:38 - number of let's say we have we're
397:40 - working with data items right so we can
397:43 - use link query like this data items dot
397:46 - skip
397:48 - so if we are on page one then we skip
397:51 - zero number of records
397:53 - and then we take
397:55 - take how much we take the page size
397:58 - right
397:59 - let's let's say each page size is
398:02 - has 10 items each page has 10 items then
398:05 - i would say skip 0 take take 10
398:08 - right and uh if we want to go to the
398:11 - second page then i would skip
398:14 - 10
398:16 - right and
398:18 - take 10.
398:19 - knowing this
398:21 - what we can do is we can implement
398:25 - some of these functionality here
398:28 - so for example
398:30 - i want to know how many items to skip
398:33 - right so i would implement a
398:36 - function here
398:38 - i want to know the number of
398:41 - items
398:42 - to
398:43 - skip
398:45 - and
398:47 - i need to
398:48 - provide the current page
398:51 - number
398:52 - right
398:54 - and
398:57 - if
399:00 - enabled right so if paging is enabled
399:04 - then we would apparently it would be the
399:08 - current page number
399:09 - minus one
399:11 - and times the page
399:14 - size right because for example if it's
399:18 - we want to go to page one number of
399:21 - items to skip well let's call it page
399:23 - number not current page number
399:26 - it's the page
399:28 - number that we want to go to
399:33 - and
399:34 - let's say we want to go to page one
399:37 - then
399:39 - this would be zero so number of items to
399:42 - return to skip is zero
399:44 - otherwise it's not enabled
399:47 - okay then we would return
399:50 - uh
399:51 - zero
399:53 - simply zero right so we're not skipping
399:55 - any items
399:56 - so if this is page two
399:59 - uh we want to go to page two then number
400:02 - of items to skip is the same of the page
400:04 - size
400:06 - right so if it's 10 then we skip the
400:08 - first 10 items so on and so forth
400:11 - so the next one uh is
400:14 - you know number of items that we want to
400:17 - take
400:19 - right so i want to implement that two
400:22 - number of items
400:24 - to
400:25 - to take
400:27 - right um
400:30 - and again if
400:32 - you know enabled
400:39 - but if it's not enabled
400:42 - number of items to take is basically
400:46 - the total number of items
400:49 - so
400:50 - so
400:51 - i need to
400:54 - provide a total items count and we are
400:58 - returning this total items count
401:00 - by the way i got a silent keyboard it's
401:02 - not that silent it's not silent
401:05 - but i think it's hopefully it's quite
401:07 - enough and won't be so distracting
401:10 - um
401:11 - so if it's enabled
401:13 - then we're basically returning the page
401:16 - size
401:17 - right so if we only have let's say we if
401:20 - the page size is 10 and we only have two
401:22 - items in the list
401:24 - i think by returning
401:27 - page size 10
401:29 - uh
401:30 - and we were executing link query take 10
401:33 - i think it will not throw an error let's
401:36 - see
401:38 - let's see what it does
401:42 - so we have the number of items to skip
401:44 - we have number of items to take
401:49 - next one is that
401:51 - we basically want to go to a specific
401:55 - page
401:59 - page right
402:00 - so if we know a page then we can just
402:02 - use these two functions to go to that to
402:05 - um
402:06 - to know
402:07 - along with the link query to go to that
402:09 - page
402:10 - um but
402:13 - what if we just want to go to the
402:14 - previous page number
402:16 - or the next page number knowing the
402:18 - current page number so i'm going to
402:20 - create those functions first
402:23 - okay so
402:24 - um
402:25 - let's
402:26 - do the previous page
402:29 - number
402:30 - given the current page
402:32 - number
402:34 - okay so that's uh that's that's easy i
402:37 - think if it's enabled
402:40 - oh well no
402:42 - if we want to go to the has been enabled
402:44 - right so
402:49 - if the current page number is greater
402:52 - than zero
402:54 - then obviously we're returning the
402:56 - current page number sorry greater than
402:59 - one
403:00 - then
403:01 - we're returning current page number
403:03 - minus one
403:04 - right otherwise if it's
403:08 - not then we're just returning the first
403:10 - page okay so this is the the edge case
403:13 - scenario
403:15 - so
403:17 - we don't want to return minus like
403:20 - negative number
403:21 - um the next one
403:24 - also like the next page also has a edge
403:27 - case scenario
403:29 - where when it bridge
403:31 - when it reaches the
403:33 - launch pad
403:34 - the the last page
403:36 - so for that i want to
403:39 - pass in the total items called
403:41 - because i want to i don't want to exceed
403:43 - that
403:45 - so that condition um we should say that
403:48 - if
403:49 - you know the current page number is
403:52 - smaller than
403:54 - the maximum page number
403:57 - right
403:58 - well we don't have that let's say let's
404:02 - just put this here
404:04 - so that we in our mind is clear so if
404:06 - it's
404:07 - if it's smaller than that then yeah we
404:10 - can just
404:11 - return the current page number plus one
404:13 - because we want to go to the next page
404:16 - if it's
404:17 - not smaller meaning that we're already
404:19 - on the last page
404:21 - then we just simply return the current
404:24 - page number
404:25 - right so how do we know the maximum
404:27 - number a page number it has something to
404:30 - do with the total items count so i'm
404:32 - going to create a
404:36 - i'm actually going to create another
404:38 - function here
404:40 - and that
404:42 - i will call it
404:44 - max
404:46 - page number and providing
404:49 - the
404:49 - total
404:51 - number of items
404:54 - right and here
404:57 - i'm going to say
404:59 - um
405:01 - and you don't know
405:02 - the total number of pages
405:05 - obviously right
405:07 - so that is
405:10 - um i think it's
405:12 - yeah so it's number of pages equals
405:17 - total
405:18 - total items count divided by
405:21 - the page size
405:24 - but these are integers so to receive a
405:28 - double i want to force a conversion here
405:36 - and knowing the number of pages
405:39 - then we just need to do some
405:44 - so if it's
405:46 - the same as the floor
405:50 - number of pages
405:54 - right then the maximum number of
405:57 - uh maximum page number so we're
405:59 - basically returning this
406:01 - which you can say next page number
406:08 - so next stage
406:10 - number equals
406:12 - the number of pages
406:16 - and uh it's complaining yeah this is
406:19 - double so just force it to integer
406:23 - otherwise
406:25 - if it if it's
406:27 - if the number of pages is
406:32 - it's not a integer then it's
406:36 - reader so the maximum page number must
406:39 - be equal to
406:42 - number
406:44 - number of pages plus one
406:47 - right
406:49 - so
406:51 - then here i just return the maximum page
406:54 - number
406:56 - okay so we have the maximum page number
406:58 - here
406:59 - and i can use this
407:01 - here and pass in the total items count
407:05 - and
407:07 - that we will get the next page number
407:10 - previous page number next page number
407:11 - and i think we're good now now let's
407:15 - jump back to the component
407:18 - what we want to do here is
407:20 - um
407:23 - we want to display so we have this
407:26 - currently it's going through all of them
407:30 - all of the data items that we have and
407:32 - it's played all of them and this case
407:35 - there's no paging
407:36 - but
407:38 - if paging is enabled
407:43 - right
407:45 - um
407:47 - because in our page page and config we
407:49 - actually
407:50 - use the enabled in these two functions
407:53 - we're checking whether they're enabled
407:55 - or not so we can just use that directly
407:58 - so in here we would say we're looking
408:01 - through items but it's filtered right we
408:03 - want to skip
408:04 - we want to skip
408:07 - we haven't declared that paging
408:12 - here yet so let's define that declare
408:15 - the
408:16 - paging parameter
408:18 - which can be passed
408:20 - through the parent component
408:22 - basically the developer provide that
408:24 - information
408:25 - and that's um
408:27 - paging convey
408:29 - class that we have just defined
408:32 - and
408:33 - let's call it
408:35 - and
408:37 - let's go back and
408:39 - say
408:40 - if the paging dot
408:42 - skip not if
408:45 - we know that paging and we're skipping
408:47 - the number of items to skip
408:51 - number of items to skip
408:54 - right and it's a function that we need
408:56 - to provide the current page number
408:59 - so
409:00 - um
409:02 - the current page number
409:05 - has to be
409:07 - let's make it a parameter initialize
409:11 - that to the zero
409:13 - because you see the print page number
409:16 - may be used by the developer
409:21 - yeah so let's let's do that for um
409:26 - so in the case that the developer i'm
409:28 - going to provide a custom pager
409:30 - in that case um that current
409:34 - page number
409:37 - needs to be exposed
409:39 - to the developer
409:40 - right so and we can
409:44 - yeah we can we can initialize that to
409:47 - zero
409:49 - and current page number is uh
409:53 - is going to be skipped over here
409:58 - right and then we want to take
410:01 - sorry
410:02 - um
410:03 - that i think you know it's good and then
410:06 - we take
410:07 - and how much we want to take how many
410:10 - items we want to take
410:12 - which we can just get from the
410:16 - so number of items to take which
410:18 - i need to provide
410:20 - so this part
410:22 - um
410:24 - we have defined and we want to
410:28 - it takes the total items count number of
410:31 - items to take
410:34 - let's think about whether this function
410:35 - is right or wrong number of items to
410:37 - take we provide the total
410:40 - items count and if paging is enabled
410:43 - then we return
410:45 - the page size otherwise we return the
410:47 - whole thing
410:48 - yeah i think that's right
410:50 - so
410:53 - so here we need to provide that total
410:57 - number of items
410:59 - right and that's
411:01 - count
411:02 - like this okay
411:04 - so we change this part
411:07 - and that should render our
411:10 - data items correctly
411:12 - now we need to
411:15 - provide the page we need to yeah we need
411:17 - to provide that pager
411:18 - so let me search for uh data great pager
411:22 - images let's see so it's on the other
411:24 - one
411:25 - so
411:27 - good images i think i want to do a
411:29 - simple style i don't want to display all
411:32 - these numbers here i think i want to use
411:35 - something like this
411:37 - um
411:39 - okay
411:41 - so let's
411:42 - implement the pager here
411:44 - again i prefer to use
411:47 - the beaumont style which we can just use
411:51 - level
411:52 - okay so if you haven't used level
411:55 - you can go to bulma website and we can
411:57 - use bulma
411:59 - it's actually pretty simple right so in
412:03 - order to
412:05 - i want the page to be on the right hand
412:07 - side right which is similar to
412:10 - data grade in
412:12 - that extreme
412:15 - and under level i can just say level to
412:18 - the right
412:20 - all right and
412:22 - within it i haven't i need to provide
412:24 - another one which is level item
412:28 - and here i can just
412:30 - define
412:32 - so here i would say if paging
412:35 - is provided
412:38 - and
412:39 - paging the enable is true
412:42 - in that case i would render the pager
412:45 - and this is pretty plain pager
412:47 - and i want to also be able to
412:50 - give the developer the option to provide
412:53 - custom pager
412:54 - so
412:55 - i going back to the paging config i want
412:57 - to add another property here
412:59 - i want to say bowling and
413:03 - um
413:04 - custom
413:05 - pager
413:06 - right so if it's a custom pager then
413:09 - we render the custom pager so
413:13 - if
413:14 - paging
413:16 - dot custom pager
413:19 - then we render the custom pager
413:21 - um
413:23 - which we can provide
413:26 - a
413:27 - render fragment here as a parameter
413:32 - so
413:33 - which i also covered in one of my
413:35 - previous episode
413:36 - if you haven't used render fragment
413:39 - and this is going to be a simple render
413:41 - fragment with dot generic type surrender
413:44 - for recommend custom
413:46 - pager
413:48 - so um and it's pretty simple to use
413:51 - going back over here to say if the
413:53 - custom pager is enabled
413:56 - i mean if we want to use custom pager
413:58 - then just use custom page
414:00 - that simple and then
414:02 - otherwise we use our predefined
414:05 - uh pager here and the predefined pager
414:08 - for now i just want to use buttons
414:11 - i wanted to have
414:15 - yeah we use button for now and then
414:17 - we'll change to to better style so
414:19 - button
414:21 - and
414:24 - in bulma it's simply called button
414:26 - um and then um
414:30 - yeah and this is called previous right
414:33 - and then we'll have a next
414:35 - button as well
414:38 - we just want to make it work for now
414:41 - and um
414:44 - obviously when the button is clicked
414:50 - we want to
414:52 - go to free
414:55 - prep page
414:57 - okay
414:59 - and again
415:01 - when it's next button is clicked
415:04 - we want to go
415:06 - to
415:09 - next page
415:11 - all right so let's implement these two
415:14 - yeah i think these two should be public
415:18 - uh because
415:19 - for custom pager it's just me public
415:22 - right so go
415:24 - to
415:25 - previous page
415:29 - and then
415:30 - go
415:33 - to
415:34 - next page
415:37 - and
415:39 - was
415:40 - that we can use the paging
415:44 - functionality to say
415:47 - you know current page number we
415:49 - basically reset the current page number
415:52 - right and then that current page number
415:54 - can be just used
415:56 - in here
415:59 - right and
416:01 - so that we know how many
416:02 - how many items to skip
416:06 - yeah and then we use take to display
416:09 - so current page number should be equal
416:11 - to what should be we have that paging
416:14 - next page
416:16 - number which we only need to provide the
416:19 - current page number
416:21 - right and the total item code is just
416:24 - data items.com
416:30 - and what if the data atoms is now do we
416:34 - have a
416:38 - columns it's not create a header
416:40 - reflection the columns is now
416:43 - what if the columns are no okay so
416:46 - that's
416:47 - that wasn't handled properly yet
416:52 - all right so this has to be handled uh
416:54 - to see whether otherwise you're gonna
416:56 - throw exception but i'm gonna assume
416:57 - that the developer will take the
416:58 - responsibility to populate the data
417:00 - items
417:01 - right so
417:03 - um data items shouldn't be now let's
417:05 - consume that
417:06 - and uh
417:10 - and if you want to extend my code you
417:11 - can go to my github
417:14 - and to extend that
417:16 - so next page number is this right so
417:20 - and this one is also
417:22 - the same paging
417:25 - dot
417:26 - wait this is previous so this is wrong
417:32 - sorry about that
417:37 - so this is previous
417:39 - for this page number and i should only
417:42 - take the current page number
417:46 - as a parameter
417:47 - so we have the premiums we have next
417:50 - what else do we need
417:52 - we probably don't need anything else
417:55 - and let's give it a test by providing
417:58 - the
417:59 - configuration
418:02 - um
418:04 - let's go to the index page and
418:08 - we need to provide
418:10 - the page
418:12 - the paging definition here
418:15 - and we could just use the line
418:17 - let's say
418:18 - that paging configuration here
418:21 - and
418:23 - what do we have we have enabled so i
418:25 - want to enable
418:27 - right and
418:29 - what else do we have
418:31 - here just say
418:34 - custom pager
418:36 - false uh page size let's use how many
418:41 - items did we provide last time
418:44 - i think it was 10 items
418:46 - okay so let's say we have three
418:49 - page size
418:50 - and we can test the scenario
418:52 - that the last page should be only have
418:56 - should only have one item
418:58 - let's see whether that caused any
419:00 - problem
419:01 - so
419:03 - so yeah so
419:04 - this should be working let's say let's
419:08 - see whether it works or not
419:10 - so i'm going to just run control f5
419:14 - so that
419:16 - enables the heart reload
419:18 - okay so we have the previous next button
419:22 - unfortunately i want it to be on the
419:24 - right
419:25 - but it's on the left
419:26 - so let's see what went wrong here
419:29 - um
419:32 - so going back to the degree component
419:37 - i have
419:38 - level level level level level
419:42 - maybe i need a level left
419:57 - ready to go
419:59 - okay so i put a level
420:00 - i put a level
420:02 - i'm putting a level left here
420:04 - and then we go back and refresh the
420:06 - screen and see
420:08 - whether that works or not
420:10 - okay yeah then empty level left
420:13 - solve the problem and i see three items
420:16 - right hopefully that's
420:18 - i'm gonna click on
420:20 - next page i'm gonna see something magic
420:24 - happens oh
420:25 - boy it works
420:28 - okay
420:29 - it did work
420:32 - one
420:33 - two
420:36 - so this is on the third page right
420:38 - because i clicked twice and the last one
420:40 - should have only one item which is great
420:42 - so it's working so that take
420:44 - functionality um
420:47 - i'm saying take
420:48 - three but there's only one item left
420:51 - which is fine right it didn't cause any
420:53 - problems so we're going back
420:55 - and i'm clicking uh yeah this is on the
420:58 - first page so no matter how many times
421:00 - you click on it it's not gonna go
421:02 - because we always return zero
421:04 - uh
421:05 - yeah number of items through to skip is
421:07 - always zero
421:10 - and then we take the
421:12 - we take three from there
421:14 - right so let's
421:16 - let's see if i what happens if we change
421:19 - that to
421:21 - two
421:23 - all right so to two we're gonna have uh
421:26 - five five pages okay
421:28 - so
421:29 - first page it's weird though i can't
421:32 - click like the first click did not work
421:34 - and then the second one started working
421:37 - so this is the second page and then the
421:39 - third page the fourth page and the fifth
421:41 - page which is right so it all go all the
421:44 - way to the first one and then if i click
421:45 - on the next it's working but then
421:48 - something is wrong
421:50 - if i
421:51 - refresh the page and click on the next
421:53 - button for the first time it's not
421:56 - responding and let's check what's
421:58 - happening
422:00 - uh yeah let's check what's happening
422:03 - so i have this
422:06 - oh so this is index page so i have this
422:09 - next button
422:11 - divide handler
422:15 - and the current page number was set to
422:18 - be zero
422:19 - at the beginning
422:20 - right oh no the current page number
422:23 - cannot be zero
422:24 - i'm surprised that
422:27 - it's skipping correctly
422:32 - so if i provide zero here what's going
422:35 - to happen
422:37 - if it's enabled so if it's enabled
422:41 - 0
422:43 - oh it's going to return minus
422:46 - -2
422:49 - oh so skipping minus two
422:52 - all right so that's that's something
422:53 - around there so yeah i think the
422:55 - initialization is wrong
422:57 - uh
422:57 - which i have to fix
423:01 - in here so the first page number should
423:03 - be one
423:06 - and let's go back and refresh the page
423:09 - and see whether that fix a problem or
423:11 - not
423:12 - all right so i'm clicking on next button
423:14 - that works that's not the problem okay
423:17 - last last one
423:18 - first one let's play with some other
423:21 - numbers here just to make sure all of
423:24 - the edge cases are covered
423:26 - so index component
423:29 - and
423:31 - what if i use four
423:34 - uh then i would see three pages the last
423:37 - page should only have two items right
423:40 - so click on refresh
423:42 - all right so four items first page four
423:45 - items second page two items last page
423:49 - and that's working
423:50 - very well for me
423:52 - okay cool so i need this these buttons
423:55 - to become i don't like the huge fat
423:58 - buttons to be here i want to be um a
424:01 - little bit prettier than that which
424:03 - i will do
424:05 - going back to data grid and replace the
424:08 - buttons with uh
424:10 - um
424:11 - actually before doing that i want to
424:14 - show
424:14 - which page we are on first right so i
424:17 - want to have a span here
424:20 - and then i want to show a number of
424:24 - pages
424:26 - page uh current page number
424:31 - red page
424:33 - page number of the total number of pages
424:37 - right so we do have a maximum number of
424:43 - maximum page number here
424:47 - again this
424:48 - problem
424:50 - happened
424:52 - so i need to provide
424:55 - the total
424:56 - count right so data
424:59 - items dot
425:04 - that should be good
425:08 - takes long time for this to disappear
425:10 - i don't think i did anything wrong okay
425:13 - good
425:14 - all right going back
425:16 - and we'll see whether that's
425:18 - better or not
425:19 - all right so page one well you need some
425:22 - spacing there
425:23 - at least it's showing the correct result
425:27 - okay so we need some spacing
425:30 - i need some spacing here
425:33 - and bsp
425:35 - i
425:36 - need i'll put two over here and two at
425:40 - the end
425:42 - and that should be
425:45 - pretty good
425:47 - all right that's good
425:50 - okay let's replace these uh big buttons
425:54 - to uh just just expand
425:57 - and uh
425:58 - what should we do with this band i want
426:01 - it to be
426:04 - bold
426:05 - and i want to just use
426:09 - the
426:11 - yeah just use this
426:14 - right so for previous just use the less
426:17 - than less than sign
426:19 - and then
426:21 - this would be greater than sine
426:25 - greater than sine
426:27 - right and
426:29 - yeah so both greater than sine
426:33 - and that should
426:35 - be
426:37 - well
426:38 - i should have just changed the button
426:41 - but
426:49 - okay next page
426:53 - so that's fine
426:59 - all right so
427:01 - let's see whether that looks okay or not
427:07 - okay cool
427:08 - so we have these um
427:12 - i think this is wrong
427:15 - it should be the other way um
427:18 - so
427:19 - i think it's
427:25 - should be this side
427:27 - and then
427:29 - any other thing i want to change
427:31 - i think i want this to be smaller and
427:33 - then i want to have
427:35 - a cursor
427:37 - uh
427:39 - pointer cursor
427:41 - right so i'm going to use inline style
427:47 - font
427:48 - size yeah i want it to be bigger
427:51 - let's use 14
427:54 - and then the cursor
427:58 - going to be
428:00 - pointer
428:02 - right and i'm going to use the same
428:05 - style
428:06 - here
428:09 - and i want these to be smaller size
428:14 - and definitely not cursor
428:18 - oops
428:21 - so i want this to be smaller
428:23 - and
428:24 - i want to be not as
428:27 - prominent as the
428:29 - buttons so i want to change this to
428:32 - yeah great
428:34 - all right
428:37 - so
428:38 - let's see what happens okay i like this
428:41 - look if you have the time you can kind
428:43 - of disable make this look like disabled
428:47 - when um
428:49 - we are currently on the previous
428:52 - sorry on the first page right and then
428:54 - make this look like disabled when we're
428:56 - on the last page which i will not
428:59 - do
429:00 - uh
429:02 - during the video so
429:04 - yeah so i i think we have done pretty
429:07 - good job and i just want to perhaps
429:10 - cover the custom pager
429:13 - right what if we want to want the
429:16 - developer to provide a pager so which
429:18 - have partially implemented this custom
429:20 - pager here so what if we
429:24 - go to here and then we enable this
429:31 - oh sorry it should be true
429:34 - all right custom painter you go true
429:37 - and
429:40 - and we go back
429:41 - i expect this pager to be gone right
429:44 - this is pretty fine pager
429:46 - like we just defined the picture yeah so
429:48 - that's gone so
429:50 - the
429:52 - developer need to come here and provide
429:54 - that pager
429:55 - right so
429:57 - we have that custom pager here
429:59 - and what should we do here
430:02 - we should have
430:06 - maybe we should just use buttons
430:09 - or
430:10 - yeah let's use you know let's use some
430:12 - buttons right and instead of use
430:15 - so let's let's make it look a little bit
430:17 - different let's use um
430:19 - bootstrap
430:21 - right so btn primary
430:24 - yeah so you see that blue button which i
430:26 - don't like but just make them a little
430:29 - bit different right so how previous next
430:32 - and uh
430:33 - and what should we do so the previous
430:35 - button when we click we need to call
430:40 - a function like this
430:52 - oh this is
430:53 - previous
430:55 - all right and this is
430:57 - next page
431:00 - well
431:02 - for uh
431:04 - to make it clear so let's use a
431:06 - different
431:08 - function name than the one before
431:10 - and i'm gonna call it priv prep and next
431:13 - here
431:14 - and then
431:16 - at the
431:17 - bottom here i'm going to use
431:21 - a
431:22 - private function
431:26 - page
431:31 - and i'm going to call the great dot
431:35 - go to next
431:38 - go to previous page
431:42 - and then
431:45 - avoid
431:47 - next page
431:51 - great dot
431:53 - go to next page
431:57 - okay all right so we have our previous
431:59 - and next button
432:01 - let's see whether they work or not click
432:03 - on next well it's doing its job
432:07 - right
432:08 - i like it this thing is top previous one
432:10 - is not working
432:12 - previous is not working
432:15 - oh and there's a typo and it doesn't
432:17 - even give me an error
432:19 - that's very weird
432:22 - all right okay so ctrl f5 again next
432:26 - previous okay everything works
432:28 - um
432:29 - so what if i want to provide that number
432:31 - of pages per page
432:34 - uh per page number off page number so
432:36 - i'm going to go over here and copy this
432:45 - where is it where is it here
432:46 - okay
432:47 - so we have this over here
432:50 - but what i want to do is instead of
432:54 - provide this just as a
432:59 - um
432:59 - this is a label for
433:02 - read only i want to
433:05 - i actually want to implement
433:07 - a uh
433:08 - input control here
433:11 - right
433:13 - and that's
433:15 - number
433:17 - right
433:18 - and i think there is maximum
433:23 - and
433:24 - that maximum number is supposed to be
433:29 - i don't know whether when i call great
433:30 - it's going to give you any problems
433:36 - maximum number
433:40 - oh it's not returning the maximum number
433:44 - so
433:45 - we're going to go back and return that
433:47 - maximum number
433:51 - so that's going to be a property
433:54 - of maximum number
433:56 - maximum page number
434:01 - all right and it's going to be read only
434:07 - and i believe it's going to be
434:12 - paging that
434:18 - why
434:22 - not supposed to be
434:24 - i just say paging dot
434:26 - yeah okay so maximum page number do i
434:29 - need to provide the total what can i do
434:32 - so data item stop
434:39 - so going back
434:42 - and gonna say maximum page number all
434:45 - right maximum page number is a property
434:49 - um
434:50 - and the minimum is
434:55 - is one
435:00 - right so
435:03 - we want to bind this
435:06 - to
435:10 - um current page
435:15 - did we display that i think we did the
435:18 - current page
435:20 - number is a parameter
435:23 - right
435:24 - i don't know whether we can just do this
435:29 - parent page number
435:31 - let's see whether this works or not
435:34 - so
435:38 - so we just use this i'm going back and
435:41 - refresh the screen okay it worked
435:44 - see i have this input box yeah
435:48 - so
435:49 - will it work click on the next very cool
435:53 - right so f
435:55 - three
435:57 - whatever i type four
436:02 - zero
436:03 - nothing
436:04 - twenty five times minus one
436:06 - the first page great
436:08 - so i'm now going to demonstrate how to
436:10 - control these numbers
436:12 - um
436:14 - yeah not supposed to go under one if we
436:16 - use these buttons it's actually doing
436:18 - that
436:20 - control but we can actually type in any
436:22 - number we want
436:23 - but it's not actually
436:25 - creating any issues like any exceptions
436:28 - so yeah we definitely gotta control this
436:30 - number so it doesn't if we type in eight
436:33 - the moment you leave this like the uh
436:36 - the focus the moment the focus leaves
436:39 - this input box it should revert back to
436:42 - the
436:43 - i believe it's three right the maximum
436:45 - page number
436:51 - i want to add the sorting functionality
436:53 - and first thing i want to do is to find
436:55 - the arrows to indicate
436:57 - a sorting functionality and on dave
437:00 - extreme or devexpress the sorting
437:03 - functionality actually
437:05 - has
437:06 - they support both single column and
437:08 - multiple columns sorting uh i only want
437:11 - to implement
437:12 - single column sorting and first i want
437:14 - to find the arrows so it's gonna be css
437:18 - arrow
437:19 - and uh
437:21 - usually i'm pretty happy with the
437:23 - w3schools
437:25 - uh css and i think i like this up and
437:29 - down arrow so i'm going to
437:34 - use
437:35 - this
437:37 - styles and
437:39 - so i'm going to go into my css folder
437:43 - and create a data grade class
437:47 - style style sheet
437:50 - and that's going to be
437:53 - data grade
437:57 - and in here i'm just going to paste this
437:59 - here
438:00 - and uh
438:02 - so this is the the base one i want to
438:04 - change to store instead of arrow and i
438:07 - don't need right i don't need left and
438:09 - up and down
438:11 - so that's pretty
438:12 - good the next thing i want to do is go
438:15 - to my
438:18 - component
438:21 - and i want to
438:24 - go to my component and find a place to
438:26 - apply this style
438:29 - that's going to be my header under my
438:31 - header which is somewhere
438:34 - here
438:36 - yeah it's going to be
438:37 - somewhere here eh
438:40 - alright and i think i'm going to add a
438:42 - span here
438:48 - right and that's going to be
438:56 - i'm going to flow to the right
438:58 - just like
439:00 - uh
439:01 - in dive extreme and the class um
439:06 - i want to call
439:08 - a method that's called
439:10 - class sort class and uh i want to
439:13 - provide the current column
439:15 - right of course we
439:17 - don't have this method yet
439:20 - so let's go here and create one
439:24 - it's gonna be private method and we're
439:26 - gonna have store class
439:28 - and here we're gonna have our column
439:33 - definition
439:36 - and our column here and
439:39 - that's going to be
439:41 - the logic would be
439:43 - something related to the star direction
439:45 - and we haven't created this redirection
439:47 - configuration yet
439:49 - right so we have to add a class here and
439:51 - let's call it sort direction
439:57 - and it's not going to be a class it's
439:58 - going to be enumeration and that's going
440:01 - to have not set
440:03 - right
440:05 - ascending and descending
440:07 - and
440:08 - that
440:09 - short direction has to be also added to
440:12 - the column definition
440:14 - and from here we're going to say prop
440:16 - tap tap
440:17 - and use the sword direction right in
440:20 - here
440:21 - and uh call it uh sort
440:24 - direction
440:26 - and we initialize that sword direction
440:29 - to not set short direction dot not
440:32 - set okay
440:35 - that's good and then in here we're gonna
440:38 - have a logic we need to check whether
440:41 - the sort of direction is
440:47 - so um story direction is
440:50 - sad or not set if it's
440:53 - set already
440:56 - okay if it's set already then we are
440:59 - going to
441:00 - return
441:02 - because we go to this uh class so we'll
441:05 - see that how they're the how they are
441:06 - using it they're using they put the
441:08 - arrow and then the direction right in
441:11 - our cloud in our case
441:13 - uh
441:14 - we are going to use um
441:18 - sort because we change it to sort
441:20 - instead of arrow and then this direction
441:23 - is going to be
441:25 - um
441:28 - column.sworddirection.com to string
441:31 - and two lower
441:33 - this is very similar to alignment
441:36 - we can use that
441:39 - the enumeration
441:41 - to string
441:43 - and if it's
441:46 - sat already
441:47 - so
441:49 - of course here this has to be a string
441:52 - right and if it's set already then we
441:54 - return
441:58 - we return something let's call it no
442:00 - sword and we are going to add this no
442:02 - sort thing
442:04 - in uh you know
442:05 - cess did it great here and we're going
442:08 - to say no
442:10 - short
442:11 - and because we are using it on a spend
442:13 - so
442:14 - in the only thing we want here is to say
442:18 - display it goes none which we're trying
442:20 - to hide that span when when there is uh
442:23 - there's no direction
442:26 - right so i'm pretty happy with this
442:28 - going back to the header place
442:30 - um
442:32 - this span will need store class yeah so
442:35 - it's already coded here that's pretty
442:37 - good and we will actually need this on
442:40 - all of that
442:41 - um
442:44 - um
442:45 - all of okay so it's gonna be this part
442:48 - well actually i'm just going to copy
442:50 - this over
442:51 - to here and this code should be cleaned
442:54 - up
442:55 - i'm just using this
442:57 - just so that it's
442:59 - clear what we are trying to do
443:02 - but
443:04 - we should use some sort of function to
443:06 - clean up this uh this whole thing here
443:12 - so we have our direction
443:15 - yeah we have our direction and
443:18 - so we can test this
443:20 - by initialize our data
443:24 - so we're going to
443:26 - go in here and then
443:28 - let's say i want to
443:31 - i want to sort with name
443:34 - okay so sword direction
443:37 - equals
443:38 - uh sword direction
443:40 - sending
443:42 - and then we're gonna go to our
443:48 - application refresh the page okay so
443:50 - it's not being displayed i wonder why so
443:53 - i'm gonna inspect
443:55 - okay
443:59 - so in here
444:01 - i do have my span
444:04 - oh i see because i included that css but
444:08 - i didn't uh
444:10 - reference it in the whole stop
444:14 - ch chm cs html so
444:18 - of course in here i need to include my
444:22 - new class
444:24 - which is
444:26 - i'll use this
444:28 - obviously i'm going to copy both of this
444:30 - to be included later then
444:34 - at the last place
444:36 - so in here uh it's going to be data
444:39 - great right
444:42 - okay
444:43 - and then we just need to refresh again
444:47 - i'm going to do a control high five all
444:48 - right so this doesn't look like it's the
444:51 - right direction to die
444:56 - this is a weird direction
444:58 - um
445:01 - let's go back to our css and see what
445:04 - actually happened
445:06 - so
445:09 - direction is
445:13 - oh okay okay so i forgot to change this
445:16 - because it's gonna be ascending or
445:18 - descending
445:19 - okay which
445:20 - corresponds to our direction
445:23 - uh in the enumeration
445:25 - which is uh
445:28 - where is it
445:30 - yeah in this enumeration we have
445:33 - ascending and descending and in our
445:38 - component
445:39 - sort class
445:41 - we are using this to string
445:44 - so
445:45 - it's going to be either asc
445:48 - or
445:49 - um or not set or desc right so in here
445:53 - just change that
445:55 - to corresponds to the enumeration and
445:57 - then
445:58 - if i just refresh this again then it's
446:01 - good
446:02 - so
446:02 - we have
446:04 - uh well data we haven't sorted yet right
446:08 - but
446:11 - we have already initialized
446:13 - our data to be ascending sorry yeah in
446:16 - here to be ascending
446:20 - right we have this to be ascending and
446:22 - then it's showing a up arrow which is
446:25 - correct except the alignment is a little
446:27 - bit off and see what we can do to adjust
446:30 - this
446:31 - so we have this here
446:33 - and then so let's see whether we can do
446:36 - something about so um this is a sending
446:40 - class in the data great and we want to
446:42 - do something here
446:43 - and uh
446:45 - i wonder whether i can
446:48 - add some kind of you can
446:50 - see this using padding
446:52 - in the sort let's see whether i if i add
446:54 - some padding here
446:56 - wouldn't happen
446:58 - in the ascending place if i add
447:02 - three pixel
447:05 - what happened
447:10 - three pixel of padding
447:13 - uh didn't do anything right did it do
447:16 - anything if i change it okay padding
447:19 - just make it
447:20 - make the size change
447:22 - so what if i add some marvin
447:25 - and
447:26 - three picks of margin
447:28 - um
447:30 - actually okay so it's actually
447:33 - seemed pretty good so if i use
447:36 - margin 8
447:39 - then that would be probably okay
447:42 - so
447:43 - let's
447:45 - go to
447:47 - my component and then
447:49 - go here and
447:51 - so if i do margin
447:53 - a pixel
447:56 - that's going to be probably okay and the
447:57 - next one we're going to test is
448:00 - to
448:01 - let's make this descending and see what
448:04 - happens so for now we're not sorting the
448:07 - data yet
448:08 - uh we're dealing with the arrow
448:11 - the indicator of the sort direction okay
448:13 - so we also have this problem and we want
448:15 - to add this uh
448:18 - as well and
448:19 - we added margin last time let's see what
448:22 - happens if we
448:23 - use three at three pixels if we
448:27 - i think six is pretty
448:29 - good
448:31 - maybe five yeah let's use five
448:34 - so let's go to our data grade and under
448:37 - here we would say margin
448:40 - six
448:41 - pixel so when you say five okay five
448:44 - pixel
448:45 - all right so we're happy with our
448:48 - direction the indicator of the sword
448:50 - direction and the next one is we need to
448:53 - sort our data and to sort our data let's
448:55 - go back to the data grade component and
448:58 - in here
449:00 - whenever we click on the header
449:02 - we want to
449:06 - unclick
449:08 - okay we want to sort data
449:11 - and uh we also want to provide this
449:14 - in here and you
449:17 - need to
449:18 - to do it to call it uh that way we
449:24 - uh
449:25 - yeah it's gonna complain
449:27 - so we use our
449:29 - proper syntax here
449:32 - um
449:33 - to provide that
449:35 - and let's define this sword data
449:39 - function
449:42 - and
449:43 - that's going to be
449:46 - stored data here
449:48 - and again it's passing in the column
449:51 - definition
449:52 - um right
449:54 - and
449:56 - column right
449:58 - and
449:59 - in here
450:01 - what we want to do is
450:03 - because we only support single column
450:07 - because we only want to support a single
450:08 - column
450:10 - sorting
450:11 - then
450:13 - first of all
450:16 - so what is this column this is going to
450:18 - be the column that you click on right so
450:20 - it's going to be a sort by column let's
450:23 - name it meaningfully
450:25 - and uh
450:27 - what we are trying to do here is
450:30 - because you may click on one column and
450:33 - then you click on some other columns so
450:35 - first of all we need to clean
450:37 - clean up the sort direction
450:40 - of other columns because we only want to
450:42 - support one sword direction
450:46 - we only want to support sword direction
450:47 - on one column so first of all i want to
450:54 - run through all of the columns
450:56 - right
450:58 - and then
451:00 - if
451:01 - our column.data field
451:06 - doesn't equal to
451:09 - short direction
451:11 - the sort by column data field if it's
451:14 - not the same data field
451:16 - then
451:17 - we will set this
451:19 - uh
451:20 - column
451:21 - to
451:22 - store direction.not set right
451:26 - so then let's reset
451:28 - any other columns that have a
451:30 - a star direction already
451:32 - and then we're going to switch we're
451:34 - going to see
451:35 - what direction we are on currently for
451:37 - this column that we're clicking on
451:40 - okay so if it's
451:42 - if it's not set
451:48 - right so if it's um
451:50 - if the current column is not set
451:54 - then
451:55 - we are going to set it to
451:58 - async ascending
452:03 - if the current column is already set um
452:08 - and if it's already set to
452:12 - ascending then we want to change it to
452:14 - descending
452:16 - right
452:18 - and
452:21 - if it's set to as descending already
452:24 - then we change it to ascending
452:33 - and if it's default
452:36 - then that should not since theory happen
452:39 - but if that happens
452:42 - we just
452:44 - set it to
452:45 - setting again
452:46 - right so that changes the
452:49 - uh
452:51 - i think
452:52 - typo here to change the direction that
452:55 - set the correct direction right
452:58 - and then we're going to look at our
452:59 - direction that we just set
453:02 - right so if it's
453:04 - ascending
453:05 - then we need to order our data
453:09 - so
453:10 - we need to order our data by using the
453:13 - sort method and that has a
453:16 - overload
453:18 - and we just need to
453:22 - provide the
453:23 - comparison
453:25 - uh delegate
453:28 - and uh
453:30 - i think
453:31 - what we should do is to
453:36 - basically we're just uh
453:39 - we are um
453:42 - we can
453:43 - so at the x is t item right which is our
453:47 - in this case is our employee
453:49 - i think
453:53 - in this case it's our employee right
453:56 - but it's t items so we have to use
453:58 - reflection here and then we just need to
454:00 - get the
454:01 - uh data of that
454:04 - of x and then data from the y and then
454:06 - convert it to string and then we compare
454:08 - them
454:09 - all right so we've got to use um
454:13 - reflection again so we're going to say t
454:17 - type of t item then we got property
454:20 - right and then
454:22 - uh
454:23 - we get this data field
454:25 - from the sort direction a sort by column
454:28 - and then we can get value
454:31 - get a value
454:33 - of the x and then we change to stream
454:37 - right and then
454:38 - because string has to compare two
454:41 - so we can then use compare two
454:43 - compared to what compared to y so it's
454:46 - going to be the same same thing here
454:52 - but then we change this to y
454:55 - right and that's
454:57 - that's all we want to
454:59 - do did i close this
455:01 - this is correctly right
455:03 - uh let's complain okay so no complaints
455:06 - good
455:07 - and then if it's the other way
455:10 - then
455:12 - we just copy this
455:13 - and then
455:14 - instead of using x here we change this
455:17 - to y
455:18 - and then we change this to x
455:22 - okay that should do
455:25 - and uh
455:27 - and then this should be called
455:30 - in here did we implement that this
455:33 - should be called in here
455:35 - providing the column that is being
455:37 - sorted
455:39 - and uh also we want to make sure the
455:43 - same thing is
455:46 - being called in all of this
455:49 - column again this
455:51 - should be cleaned up
455:54 - but i'm not going to do that here i
455:57 - think in my github
456:00 - i have already cleaned up the
456:02 - markup
456:07 - so
456:08 - let's go to
456:10 - our
456:11 - code
456:12 - here
456:13 - and
456:14 - close this and refresh
456:17 - all right so we have our
456:19 - uh okay we have our header and this used
456:23 - to be descending
456:25 - and this definitely wasn't sorted yet
456:28 - right so we're missing something here so
456:30 - the initialization is not working
456:32 - uh
456:33 - so we
456:34 - what we should do here is that we should
456:37 - call our
456:38 - we should call our sort data
456:42 - um
456:44 - method when
456:47 - we shoot our sort data method when we
456:49 - are initializing the telegraph component
456:53 - and that should be
456:57 - that should that sure let's implement
457:00 - let's override the unparameter set on
457:02 - parameter set
457:04 - and then
457:05 - oops
457:07 - and then
457:09 - in here we need to call these sort data
457:11 - but which column are we which column are
457:14 - we i think
457:15 - we need to modify this method to make
457:18 - this a
457:19 - default
457:22 - as a default value which is now
457:24 - and then we need to check
457:26 - if this column is
457:29 - now
457:30 - that means we already had a
457:33 - um sort direction
457:35 - configured in the initialization in our
457:38 - case in this case it's the first column
457:41 - name column
457:43 - right
457:44 - so
457:45 - in this case if it's null then we need
457:48 - to
457:49 - find
457:51 - we need to say sort by column equals
457:55 - to the columns definition so there's got
457:57 - to be a
458:00 - column that already has a
458:03 - short direction
458:04 - so i need to find a column that already
458:06 - had a short direction which means
458:09 - not that and then if we we cannot sorry
458:12 - we cannot find it which means if this
458:14 - redirection
458:16 - is no
458:19 - then we're not doing anything
458:21 - okay
458:22 - so
458:24 - do we call it properly double check
458:27 - so we call it here here here here
458:30 - here and then here on on parameter site
458:33 - okay so let's go back and see whether
458:36 - it works um
458:38 - everything is sorted but i'm wondering
458:41 - why it changed to ac
458:43 - ascending and if i click on it
458:46 - it does work
458:48 - but why is it changed to ascending
458:51 - did we quote it correctly
458:57 - so if it's
459:00 - not set
459:02 - okay if it's a set then we find it when
459:04 - we find it
459:06 - we get it
459:08 - and then we clean up here
459:10 - and then
459:12 - if it's not sad
459:15 - since ascending oh okay okay
459:19 - okay yeah so this will change it
459:23 - that's
459:24 - making the behavior that we're clicking
459:26 - on the column but
459:28 - we're not clicking on the column in the
459:31 - uh
459:32 - here so we have to say that if sort
459:35 - direction
459:36 - if sort column um
459:41 - so we're going to have a
459:45 - in here is because
459:47 - it's called
459:48 - initial
459:51 - initial
459:52 - because
459:54 - false
459:56 - issue because um
459:59 - sort by column
460:02 - so if it's not in this initial is going
460:04 - to be true otherwise it's going to be
460:05 - false so
460:07 - this has to be false if it's not the
460:10 - initial method then we're going to
460:11 - change direction otherwise we're not
460:13 - changing direction so hopefully this
460:15 - will fix it
460:18 - okay
460:20 - let's refresh all right so yeah this
460:22 - this looks right okay
460:25 - this looks right uh let's change this uh
460:29 - let's add a cursor here right so which
460:32 - is going to be part of our data grid
460:36 - class
460:36 - and that's going to be it doesn't matter
460:39 - whether it's ascending descending
460:41 - on it has to be added here so it's going
460:44 - to be cursor
460:46 - it's going to be pointer
460:47 - and then
460:49 - let's refresh and that should do it
460:52 - that should do
460:56 - why it didn't work
460:59 - did i save it oh okay okay okay we are
461:02 - this is not the right place
461:05 - this is the span
461:08 - um
461:09 - i think we need to add
461:14 - here
461:17 - going to add this cursor thing here
461:21 - that should do it
461:28 - okay yeah it's
461:29 - it's working and then we click on this
461:33 - okay this is working and i like the
461:36 - alignment as well
461:42 - okay
461:43 - yep sorting works pretty well
461:48 - okay so now let's see
461:52 - whether the sorting works with the
461:54 - paging
461:55 - i hope i don't need to make any changes
461:58 - so i need to go over here and then i
462:01 - need to
462:03 - really
462:04 - re-enable the
462:06 - the paging thing editing is uh
462:12 - is enabled in
462:16 - here
462:20 - okay
462:22 - and refresh
462:23 - okay so we have our paging enabled
462:26 - and looks like the sorting is just
462:28 - working fine with picking
462:30 - so j k l
462:32 - r t
462:34 - and then uh we test with uh
462:40 - if we test with the number here that's
462:42 - also working correctly
462:45 - all right so
462:48 - all right cool so we implement our
462:50 - sorting functionality this is the end of
462:52 - the course i hope you have learned
462:53 - something and if you enjoy this kind of
462:55 - content feel free to come to my youtube
462:57 - channel at youtube.com franklyu software
463:01 - thank you so much for watching