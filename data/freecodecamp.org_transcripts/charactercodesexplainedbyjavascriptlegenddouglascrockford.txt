00:03 - it really is great to be back I used to
00:08 - live about a mile from here just on the
00:09 - other side of the freeway there used to
00:12 - be a computer industry in Orange County
00:14 - that actually built Hardware built of
00:16 - many computers it's all gone now I guess
00:21 - but you're still here so it's really
00:23 - great to see all of you thank you
00:25 - everybody for helping to set this up and
00:27 - to provide us of this place and thank
00:29 - all of you so much for coming out
00:31 - tonight so I want to do for you tonight
00:34 - a brand new talk I have never done this
00:36 - one before I think it's a really
00:38 - important topic it's a really
00:40 - interesting topic it turns out the way
00:42 - our character codes work has a
00:45 - tremendous impact on how we think about
00:48 - programming and and how this whole
00:51 - professional operates a lot of stuff is
00:54 - implied by the way we handle characters
00:56 - computers are machines that manipulate
00:59 - numbers that's all computers can do
01:01 - that's literally all we can do but by
01:05 - assigning numbers to characters we can
01:09 - do text processing and all this
01:11 - information stuff happens and I'm gonna
01:15 - talk about where this stuff came from I
01:17 - think this is gonna be an interesting
01:19 - talk it's certainly interesting to me I
01:22 - love this stuff and we're gonna be
01:24 - talking a lot about the history of this
01:25 - stuff but I have not been able to figure
01:29 - out how to end this talk and I've done
01:33 - this before I've gone out and I've had a
01:35 - talk and I really like this talk and I
01:37 - go out and I don't know how to end it so
01:39 - I just go to the end and say thank you
01:41 - goodnight knowing that I you know it
01:45 - deserved a WoW finish but I didn't give
01:47 - it one because during the UA or B in the
01:51 - QA I'll get questions and some of the
01:54 - questions will will indicate that I
01:57 - completely failed and trying to describe
01:59 - what this is because the question just
02:01 - completely missed it
02:02 - but sometimes the question will focus me
02:06 - on what the whole thing was about and go
02:08 - yes thank you
02:09 - this is the moral of this story so I'm
02:12 - hoping that will happen tonight
02:13 - so you know I'm counting on you okay you
02:17 - have a part to play
02:19 - so character codes don't start with
02:22 - computer systems they start first with
02:26 - data communications or communications in
02:30 - general just human communication and
02:33 - then data processing and eventually
02:36 - communication and data processing come
02:38 - together in computing so we're gonna
02:41 - start at the very beginning the first
02:43 - character set the morse code designed by
02:47 - a samuel morris an american portrait
02:50 - painter he also had a hobby in
02:54 - electricity and he worked with some
02:58 - partners to develop a telegraph and
03:00 - Morse put together the code that
03:03 - transmitted words across their Telegraph
03:07 - and it's a very very simple code because
03:10 - they're telegraph all I could do was
03:12 - transmitted to States it was either on
03:15 - or it was off so Morris figured out a
03:19 - way to turn that into a communication
03:20 - channel so he has a language that's made
03:25 - up of two symbols dot and dash and we
03:29 - can represent these in binary so a dot
03:32 - is a single one and a dash is three ones
03:37 - and then in order to tell the difference
03:40 - between the dots and the dashes he need
03:42 - to put some zeroes in between them so
03:44 - he's got zero for the particle space
03:47 - that's the small separator between a
03:50 - zero and one and then there's a letter
03:52 - space which will be the space between
03:55 - the letters and then a word space which
03:58 - goes between the words if you're a
04:01 - musician it's easier to think about this
04:04 - musically so you can think of a dot as
04:07 - an eighth note and a dash is a dotted
04:11 - quarter note and then an eighth rest is
04:15 - the particle space a dotted quarter rest
04:19 - is a letter space and approximately a
04:21 - whole rest is the word space so here's
04:26 - an exam
04:27 - four letters representing the Morse code
04:30 - so the letter T is a dash letter eyes
04:33 - two dots letter M is two dashes and an
04:36 - EE is a dot
04:37 - so horse took a look at the frequency of
04:41 - letters in English and chose the most
04:44 - popular letters they have the shortest
04:46 - codes so this is not only a
04:48 - communication code it's also a data
04:51 - compression code it's the first data
04:53 - compression code and it it's a code that
04:56 - works in time most of our codes work in
04:59 - space you know you can think of a word
05:01 - containing some number of bits or even a
05:03 - packet containing some number bits but
05:05 - this is a because it's musical it's all
05:08 - happening in time so remembering the
05:11 - word time will help you to remember
05:13 - these symbols that the consonants are
05:15 - dashes the vowels are dots and the most
05:20 - frequent frequent things like the e will
05:22 - get the shortest code okay so you now
05:24 - know four of the letters in the Morse
05:27 - code in fact I'm going to teach you all
05:30 - 26 letters of the Morse code because you
05:33 - might need it someday you might be
05:35 - trapped in a mine or on a disabled
05:38 - submarine and you're gonna need to be
05:41 - able to get a message out and all you're
05:43 - gonna be able to do is tap on the hole
05:44 - with a rock or something but you'll be
05:47 - able to do it because you're going to
05:48 - know the Morse code okay the fifth
05:51 - symbol is the V which we can get from
05:56 - the V for victory Beethoven's fifth so
06:00 - you all remember Beethoven's fifth
06:02 - symphony begins
06:03 - dah-dah-dah-dah dot dot dot dash okay
06:07 - that's the letter V okay V for five you
06:13 - all know the SOS of the International
06:16 - distress signal its dot dot dot dot dot
06:18 - dot if we break it down into letters the
06:24 - S is three dots and the O is three
06:27 - dashes this is the opposite of the dash
06:33 - is being consonants but you know we got
06:36 - a couple exceptions so you can remember
06:37 - that right so dot dot dot is s dash
06:40 - - - is Oh a chisel of tricky to remember
06:45 - it's for dots so I recommend you think
06:50 - of the 4-h club and and the advisor to
06:54 - the 4-h club mr. 4-h himself Harry
06:57 - Herbert Hoover Hever okay for the rest
07:04 - of the letters okay so you now know six
07:06 - letters right for the for the next
07:08 - twenty we're gonna have some mnemonics
07:10 - and this is helping em onyx are gonna
07:12 - work so I'll give you a letter and I'll
07:15 - show you the the Morse code for that
07:17 - letter and then I'll have an English
07:20 - word which contains that letter in which
07:23 - the dot corresponds to a vowel and the -
07:27 - corresponds to a continent consonant so
07:30 - a is for M everybody got that
07:34 - and everybody understanding a okay let's
07:40 - move on
07:42 - B is for bow B my bow it's it's
07:49 - beautiful isn't it not my friend
07:51 - c is for Coco everybody loves Coco right
07:56 - you love Coco that's why you can
07:58 - remember that c is for Coco this next
08:01 - one is going to be really shocking and
08:03 - upsetting
08:03 - D is for die but because it's so
08:08 - shocking you're gonna remember this one
08:10 - the D is for die e you've already seen
08:14 - he is one of the the time things it's
08:17 - one dot and F is for Fe that's right
08:23 - Luffy everybody say you fee
08:27 - okay so AM Boko code ie goofy everybody
08:31 - with me so far we're learning the Morse
08:33 - code G is for ganoub for programmers
08:38 - that should be a really easy one G canoe
08:41 - G canoe is that outfit that gave us a
08:45 - failed UNIX clone and a software license
08:49 - in which free is not free right
08:50 - everybody knows that one
08:53 - we've already seen h the 4-h club Harry
08:56 - Herbert Hoover Hever I we've already
09:00 - seen i-i-i write two dots and I J hey J
09:09 - what do you say hi JJJ you what I JJJ
09:19 - k is for a kit right that's easy kit
09:23 - okay get up maybe yeah K and L is for
09:30 - soothing aloe you can't forget that L 4
09:33 - L oh of course
09:34 - so canoe 4-h III ajjj kit and aloe
09:41 - everybody still with me let's learn some
09:44 - more M we already saw is one of the time
09:48 - letters it and it's good
09:51 - mmm good that's the letter M is good and
09:57 - oh no got it okay we already saw Oh from
10:05 - the SOS P is for Expo you might imagine
10:11 - next year there's going to be a big Expo
10:14 - in which they're going to announce a
10:16 - better mnemonic for the letter P so
10:18 - we're all looking forward to that Q is a
10:22 - bit tricky cuz it's hard to make words
10:24 - out of Q so whenever you have a Q you're
10:27 - likely to have a you after it so we got
10:29 - that pair and we're gonna wrap it in
10:31 - quotes but we don't have quotes so we'll
10:34 - use the letter Q for the quotes because
10:36 - Q is for quote and so we get Q qu q okay
10:42 - got it
10:44 - r is for era this is the era of Morse
10:48 - code are ya okay s we already saw in the
10:54 - SOS and the distress signal
10:56 - we already saw T in the time letters you
11:03 - out o UT out
11:07 - okay we already saw a V Beethoven's
11:12 - fifth I thought but the W is for the
11:16 - wise old owl that's easy to remember
11:19 - w and the owl because he's so wise X X
11:25 - is another hard one but fortunately X
11:27 - rarely happens in English so we're safe
11:30 - but you know it's XO o X you're not
11:33 - gonna remember that but you'll probably
11:35 - be okay
11:37 - then why yuck
11:41 - so you know if there any little kids
11:45 - here I don't see any little kids if
11:46 - there were any little kids the two
11:48 - symbols they're gonna remember tonight
11:49 - are goofy and yuck that's for sure and
11:53 - then finally at the end of everything is
11:56 - Z of course so what comes after zu z zu
12:01 - right that's the end right z zu is the
12:04 - last so you now know Morse code you're
12:09 - not good enough to get an operator's
12:10 - license but you could probably recall
12:13 - this and make a list and then you can
12:15 - tap it out you know you might be on that
12:17 - disabled spaceship and you need to alert
12:19 - the fleet you're gonna be able to do it
12:22 - someone's gonna say my god that's Morse
12:24 - code and we'll be saved
12:28 - okay so moving on the next
12:32 - communications code was the Bedok code
12:35 - which was invented by emil Bedok it was
12:38 - a French calligrapher he wanted to
12:43 - improve on the Telegraph so instead of
12:46 - the operators having to be entering a
12:49 - stream of bits that instead you would
12:53 - have a keyboard that would look like a
12:55 - musical keyboard with five keys on it
12:58 - and you would chord in the letters that
13:01 - you want so you would have to memorize
13:03 - the letters in order to get them in and
13:06 - this keyboard would be attached to a
13:09 - paper tape punch which would produce a
13:12 - string of paper tape with the holes in
13:14 - it and then that could be transmitted
13:17 - there was another guy who came on
13:20 - so if ever heard of baud rates which is
13:24 - yeah the couple the old-timers going out
13:27 - I remember baud rates bada is usually
13:30 - bit well it actually means bits per
13:33 - second but yeah it's slow is also
13:35 - another meaning so it was named after
13:38 - this guy so Donald Murray who is a news
13:43 - New Zealander
13:44 - improved on the DOE system he came up
13:48 - with a much better keyboard so it had a
13:50 - button for each of the letters and so
13:52 - the operator didn't have to memorize the
13:53 - binary code so you just go punch punch
13:55 - punch punch and he could have picked any
13:57 - keyboard and unfortunately he picked the
14:01 - QWERTY typewriter keyboard the QWERTY
14:04 - typewriter a keyboard is terrible by
14:07 - design in order to try to prevent the
14:10 - jamming of the mechanical keys you know
14:13 - it wasn't completely successful in doing
14:15 - that but that's why it's got that
14:17 - bizarre layout and Murray could have
14:20 - said well we don't need to do that
14:23 - because you know when you push a button
14:26 - we're closing a circuit which is gonna
14:27 - drive some pins through some paper tape
14:29 - so it doesn't matter what order we put
14:32 - the keys in he could have done something
14:33 - rational but he didn't and so we're
14:36 - still stuck with the QWERTY keyboard
14:37 - everywhere this is the first time QWERTY
14:40 - is used in electronic communication and
14:44 - and it's still being used in electronic
14:47 - communication so this is a refinement of
14:51 - the code that those two guys worked on
14:53 - and it became a standard one of the
14:56 - first telegraphy standards this is
14:58 - International Telegraph alphabet number
15:00 - two it was a 5-bit code which allows
15:04 - them to encode all of the letters Murray
15:07 - scrambled the codes around in order to
15:10 - reduce wear on the machinery so that
15:13 - instead of optimizing for time he was
15:15 - optimizing for bits where each bit would
15:19 - cause a needle to drive a hole into a
15:24 - piece of paper and those pins would wear
15:30 - out and so in order to reduce wear on
15:32 - the machinery he
15:34 - have the most common codes have the
15:36 - smallest number of bits so for example e
15:41 - is a very popular letter it only has one
15:45 - bit and T is also a very popular letter
15:47 - it only has one bit and since the
15:50 - operators didn't see the codes it didn't
15:52 - matter that they were kind of random
15:54 - then there's a code for space carriage
15:58 - return and line feed two separate codes
16:00 - because that's how his printer worked
16:04 - the most interesting thing that bodo did
16:07 - was he added a couple of shift keys so
16:12 - there's the figure shift and the letter
16:13 - shift so when you're in letter mode you
16:16 - get these codes and when you're in
16:17 - Figure mode you get these codes so that
16:19 - gets you the digits and the special
16:21 - characters which was a really clever
16:25 - idea so they managed to get you know 60
16:28 - or so characters in just 5 bits and they
16:32 - decided to have 2 codes instead of 1
16:34 - they could have just had a toggle shift
16:36 - but there was a concern that the
16:40 - telegraph lines were very noisy and if
16:42 - there was a line hit then a shift code
16:45 - get get garbled and that means
16:47 - everything after that is going to look
16:49 - wildly wrong so to make the system a
16:52 - little bit more resilient they have two
16:54 - independent shift codes so the next step
16:58 - happens a bit later the Hollerith code
17:01 - so Herman Hollerith developed a data
17:05 - processing system using punch cards for
17:08 - the 19 or for the 1890 census the US
17:12 - Constitution requires that every 10
17:14 - years we have a count of everybody so we
17:17 - can figure out how to staff the House of
17:24 - Representatives and it was taking too
17:28 - long to do with pen and paper so
17:30 - Hollerith figured out a way to do a lot
17:32 - of that work mechanically and that
17:35 - turned out to be a big business a number
17:37 - of companies were formed and after a
17:40 - series of acquisitions and mergers in
17:44 - event tolerance company eventually
17:46 - becomes international business
17:48 - machines or IBM and in 1928 IBM wanted
17:53 - to figure out a way to get more
17:54 - information onto the cards because with
17:57 - Hollerith little circular punches they
18:00 - can only get so many characters and they
18:02 - wanted to get more so they came up with
18:04 - a system in which they could get 80
18:07 - columns on a card each card had 80
18:11 - columns and twelve rows in which you
18:15 - could punch holes and at the top there
18:17 - was a blank space where you could print
18:19 - stuff with ink so that humans looking at
18:22 - the card could figure out what it said
18:24 - although people who were skilled with
18:26 - this code could actually look at the
18:28 - punches and tell you what it said so
18:32 - they came up with a very straightforward
18:36 - way of encoding the characters so first
18:40 - if in the top line it's called the
18:44 - twelve row or the 12 punch or the X
18:47 - punch or the plus so if there's a punch
18:53 - there then you get a plus sign the next
18:55 - row you get a minus sign and then 0 1 2
18:59 - 3 4 and so on to 9 ok pretty
19:02 - straightforward and they wanted to be
19:04 - able to do letters too so letters are
19:07 - slightly more complicated each letter
19:09 - requires two punches because we've used
19:11 - up all the one punch codes so we use the
19:18 - the plus Rho and the digits one through
19:23 - nine and that gets us the letters A
19:26 - through I and then we do a similar thing
19:29 - with the minus row and the digits 1
19:32 - through 9 and that gets us J through R
19:35 - and we do a similar thing with the zero
19:37 - row but this time going 2 to 9 to get S
19:41 - through Z this pattern should give you
19:45 - 27 letters but we only need 26 so they
19:49 - needed to drop one of the codes and the
19:51 - code they decided to drop was 0 1 and
19:54 - the reason was that you had two holes
19:58 - with just a tiny little piece of paper
20:00 - between them and there
20:01 - a concern that given the crude machines
20:04 - of the time that they were using metal
20:07 - wire brushes to sense the holes in the
20:10 - cards that it could rip the card which
20:14 - could cause the machine to jam or cause
20:16 - bits of little pieces of paper to
20:20 - accumulate in the machine and eventually
20:22 - catch fire so to avoid that hazard they
20:25 - skipped that code but then you could
20:28 - have three-letter codes or different
20:31 - combinations of two whole codes to do
20:34 - the special characters and unfortunately
20:37 - that never got standardized very well so
20:39 - different machines would have different
20:42 - codes so taking a deck of cards and
20:45 - moving it from one system to another
20:46 - could get really complicated because all
20:49 - the special characters could get
20:50 - misinterpreted so now we finally move
20:54 - into computing when computing starts in
20:57 - the late 40s the first computers have
20:59 - six bit character sets these machines
21:02 - were mostly concerned with computation
21:05 - mathematical computation and so six bit
21:08 - character sets were were fine so this is
21:12 - one that was used at IBM their character
21:16 - set was based on a praetor that they
21:19 - were using with their punch card
21:21 - equipment which they modified in order
21:25 - to work with some of their early
21:26 - computers and so their printer only
21:31 - could print 48 different characters and
21:33 - so they left a lot of these codes blank
21:36 - and they had a few weird characters like
21:39 - like that so what is that I don't I
21:43 - don't know what it is oh it's called a
21:45 - square lozenge I don't know what it
21:47 - means but it was on their punch card
21:49 - equipment and so people would use it
21:51 - because there weren't very many
21:52 - characters available so that meant
21:55 - whatever you really wanted it to be you
21:57 - would use that because that's that's all
22:00 - it is you know they didn't put a plus
22:02 - sign in it which is like I don't
22:05 - understand as so the next step forward
22:10 - is Fortran Fortran is the first really
22:14 - successful programming
22:15 - which kind of changes the world it was
22:17 - also developed at IBM and it gets poured
22:21 - into all of the IBM machines and then
22:23 - everybody else makes their own Fortran
22:25 - systems as well it's the first big
22:28 - programming language and the guys who
22:31 - were designing Fortran couldn't figure
22:35 - out a way to make a programming language
22:36 - out of that so they said we need these
22:41 - additional characters and so they just
22:43 - said if you're going to have Fortran
22:45 - you're gonna have to neat have to get
22:47 - these characters somehow and so IBM said
22:50 - okay we'll try to figure out how in our
22:52 - next printer we can we can add those so
22:55 - in a later version of the there be CDI C
22:59 - code they've added more characters so
23:04 - something that's weird about this you
23:06 - look at the arrangements of a and J ass
23:11 - what they did was they just took the
23:13 - Hollerith code and pushed it into the
23:16 - characters head okay so we have an
23:18 - expectation that each letter is going to
23:21 - be one away from the next one but that's
23:24 - not the case here you know
23:26 - I plus one is question mark not J okay
23:30 - so it's gonna be a little challenging
23:32 - you know write a sort routine for this
23:34 - character set okay and they got some
23:38 - weird characters like these guys so they
23:46 - they created a magnetic tape system to
23:48 - work with this computer and they
23:51 - reserved these four codes has special
23:53 - marks on the tape and they recommended
23:57 - that you never use these codes in your
23:59 - programs because if you try to write
24:00 - those codes to the tape it's going to
24:02 - screw everything up so they picked
24:05 - characters that they thought no one
24:06 - would ever want to use then they had a
24:11 - problem they started selling stuff in
24:13 - Europe and found that this isn't enough
24:15 - letters that you know like in
24:18 - Scandinavia they need three more letters
24:20 - and so they decided well you can take
24:23 - those letters and/or those characters
24:26 - and replace them with letters in
24:27 - whatever country you're in
24:29 - so this kind of begins the I 18n problem
24:32 - that this is where it starts and it took
24:35 - a long long time to fix it now turned
24:39 - out every company had their own
24:41 - character set so for example control
24:43 - data started with the IBM set but kind
24:47 - of changed a little bit because they
24:49 - were more into scientific computing and
24:51 - so they added some characters that they
24:52 - thought people who are programming about
24:56 - numbers we care about things like not
24:58 - equal less than or greater than angle
25:02 - brackets or less than or greater than
25:04 - that's good stuff right another company
25:09 - that was doing brilliant work the
25:11 - Burroughs 5000 series is maybe one of
25:14 - the most interesting architectures ever
25:16 - designed and they're still doing the IBM
25:20 - thing except that kind of straightened
25:22 - it out a little bit at least a comes
25:24 - before s now so that's good and I really
25:28 - like that they put zeros at the top row
25:30 - that means the character code for 0 is 0
25:34 - does that make sense that absolutely
25:36 - makes sense that's brilliant as a
25:38 - programmer I love Burroughs I that makes
25:41 - so much sense to me and are pretty good
25:43 - my set oh and they got an arrow which is
25:47 - what we should have had for the
25:48 - assignment operator Fortran didn't have
25:50 - this because they just didn't dare to
25:53 - ask for another character and so they
25:56 - were forced to use the equal sign for
25:58 - assignment because they had no other
26:00 - options and we're still doing it it just
26:03 - doesn't make any sense we should be
26:05 - using that re that that makes sense so
26:09 - the US Army is buying lots of computers
26:12 - and you know each of its computers comes
26:16 - from a different company and they all
26:17 - have different character sets and trying
26:19 - to exchange information between all
26:21 - these machines was really really hard so
26:23 - they decided to fix the problem being
26:26 - the government so they created a
26:28 - character set of their own called field
26:30 - data and field data was a 7-bit
26:34 - character set which was intended to run
26:37 - on all army computers and that would let
26:40 - them communicate
26:42 - but because it was a and there's some
26:45 - pretty reasonable stuff so they finally
26:46 - fix the alphabet right so it it's all
26:49 - continuous so I like that a lot and it
26:53 - still got some of these weird IBM
26:54 - characters in it but you know that's
26:57 - okay and some of these could be replaced
26:59 - by other characters for and for some
27:04 - reason they they moved all of these
27:06 - characters up to the top half of the
27:08 - seven bit character set and they leaved
27:10 - the left the bottom half of the seven
27:12 - bit character set undefined so there
27:16 - were a number of projects in the army
27:17 - that started working with this character
27:20 - set and they liked it it worked well and
27:22 - they hadn't need for lots of extra
27:24 - characters and there was all this you
27:26 - know 64 characters that weren't being
27:28 - used so they just started using them
27:30 - which was fine for them until the army
27:33 - wanted to make all of these programs
27:35 - work together and they didn't because
27:37 - everybody saw that there was a hard
27:41 - lesson there that you really have to
27:43 - nail stuff down in a standard if you
27:45 - leave too much stuff free then
27:49 - programmers will abuse it as a result
27:51 - you'll lose interoperability or quality
27:54 - or whatever it is you're trying to get
27:56 - so the next big step forward is ASCII
27:59 - anyone heard of ASCII yeah ASCII is a
28:02 - big deal the American Standard Code for
28:04 - information interchange work started in
28:07 - 1963 and ASCII was a joint project
28:15 - between AT&T and IBM and a whole bunch
28:20 - of other parties it was not intended to
28:23 - be a computer character set it was
28:25 - intended to be a network character set
28:29 - or a communication character set but
28:32 - will not only have teletypes on the line
28:35 - but will also have computers on the line
28:36 - using the same code so this is a big
28:39 - step forward
28:41 - initially ASCII was going to be a six
28:44 - bit character code basically they're
28:46 - going to take the bardo idea but add one
28:48 - more bit to double its capacity and they
28:52 - wanted to be able to represent uppercase
28:54 - and lowercase
28:56 - and the way they were gonna do it which
28:57 - i think was completely reasonable was
29:00 - they were gonna borrow the shift idea
29:01 - that was in the Bedok code so they would
29:03 - have shift uppercase and shift lowercase
29:06 - and that would have been brilliant
29:09 - because the way we would deal with case
29:13 - today would be exactly the way we deal
29:15 - with color or underline or italics or
29:19 - anything else small caps it'd just be
29:22 - you know you have a code which
29:24 - represents a letter and will have some
29:26 - other means of saying what glyph we want
29:29 - for that letter but they didn't do that
29:31 - and the reason they didn't do that was
29:34 - again the line noise problem in the
29:36 - telegraph lines that the lines were
29:39 - really noisy we didn't have the error
29:40 - correcting codes that we have now our
29:42 - air correction systems are so good we're
29:44 - not even aware of them anymore but when
29:47 - this was designed line errors were a
29:50 - really big problem and their concern was
29:52 - that if one of these shift characters
29:54 - gets mangled in transmission then the
29:56 - rest of the document is going to look
29:58 - stupid when it's printed out and to deal
30:02 - with that they decided let's change it
30:05 - into a seven bit character set and give
30:08 - each of the letters a separate code
30:10 - which I think was a terrible decision
30:13 - that the reason they did that stopped
30:16 - being necessary a long long time ago but
30:19 - we are still stuck with the consequences
30:20 - so this is the code that they came up
30:24 - with 32 transmission control codes at
30:28 - the top anybody have any idea what those
30:31 - are you might recognize one or two of
30:33 - them most of them are a complete mystery
30:35 - to you but there is still in the code
30:38 - then we've got the digits are lined out
30:42 - pretty nicely it's actually a pretty
30:44 - nice thing they considered interleaving
30:47 - the upper and lowercase characters so
30:49 - you'd have uppercase a lowercase a
30:51 - uppercase B lowercase B so that most
30:53 - things would kind of sort right but they
30:57 - decided it doesn't sort perfectly and
30:59 - rather than try to figure out how you
31:01 - might fix that where you might fix it
31:03 - would be to go back to the 6 bit code
31:05 - they decided let's make it really wrong
31:08 - and
31:09 - you know we'll separate them by 32 so so
31:16 - you're probably curious about what those
31:18 - control codes are tonight for the first
31:21 - time I'm going to tell you what those
31:23 - control codes mean so AT&T insisted on
31:31 - two codes null and del delete so these
31:39 - were for punched paper tape applications
31:41 - so on the punch paper tape zero means
31:46 - there's nothing punched on the tape and
31:48 - one one means there is a punch on the
31:51 - tape so they wanted blank tape to be to
31:57 - have a code that you could recognize and
31:59 - reject so you'd have a liter of blank
32:03 - tape and you'd run that through your
32:05 - tape reader and you'd send it to the
32:08 - other side and the other side would see
32:09 - oh that's just a zero I'm going to
32:11 - ignore it which sounds bizarre in our
32:14 - modern system you know the internet
32:15 - doesn't work that way but that's the
32:18 - world that this code was designed for
32:20 - and then so offline you're editing a
32:24 - paper tape and you make a mistake and
32:27 - you go oops so what you do is you back
32:30 - up the tape and hit the delete button
32:33 - which goes junk and punches out all of
32:36 - the holes and then you can punch the
32:39 - character after it so punching out all
32:42 - the holes means this is a non character
32:45 - ignore this non character so it means
32:48 - the same thing as null but it just
32:51 - happens to have a different code because
32:52 - that's how paper tape works so then
32:59 - there was also a backspace code the the
33:03 - BS code but it did not mean erase the
33:07 - previous character it was not designed
33:10 - for user experience because there were
33:12 - no users there was no experience this
33:14 - was just designed for machines talking
33:17 - to each other so backspace meant moved
33:20 - the print head back one space which
33:22 - meet that's a completely different
33:24 - meaning later programmers said oh look
33:28 - there's a backspace key oh there's a
33:30 - delete key let's figure out what to do
33:32 - with those and the things we do with
33:34 - those now are completely different than
33:36 - what they were intended to be
33:39 - yeah we're in complete violation of the
33:41 - ASCII code in the way we use backspace
33:44 - and delete there are some codes added
33:48 - for operators for teletype operators
33:50 - there was the enquire code which when
33:52 - you sent it to another terminal would
33:54 - cause that terminal to send back a
33:56 - string which would identify the
33:58 - terminals so you know here connected to
34:00 - which sounds bizarre today how could you
34:03 - connect to something without an
34:04 - expectation of who you're talking to and
34:06 - then there's the Bell code which will
34:08 - ring the bell so you go ctrl G and on
34:13 - the other terminal go ding you know so
34:17 - you know adding a meaning now wake up
34:19 - think there was space and there was tab
34:24 - space was necessary because you need the
34:26 - inter word gap a tab was borrowed from
34:29 - manual typewriters manual typewriters
34:32 - had a tab key you press it and it would
34:34 - release the carriage until it was
34:36 - stopped by the next mechanical tab stop
34:38 - unfortunately they didn't indicate any
34:41 - way of specifying how to set a tab stop
34:45 - and they didn't specify what the default
34:48 - tab stops are it just said if you're
34:51 - going to tab this is the code and and
34:56 - they never anticipated what we're doing
34:58 - with this stuff and unfortunately this
35:01 - is a source of conflict we're still
35:03 - arguing should we use tabs should we use
35:06 - spaces it's a colossal waste of time and
35:12 - the debate goes on it will never stop
35:15 - because there is not a clear answer
35:17 - neither side can prove that they're more
35:21 - right than the other side and lacking
35:24 - any way of resolving the conflict it
35:26 - just goes on and the cost continues to
35:29 - grow and grow and grow the value of
35:32 - having these two characters zero we get
35:35 - no value
35:36 - from having two ways of doing this thing
35:38 - at least compared to the cost that it
35:41 - causes so I recommend a different way of
35:44 - resolving this problem which one can we
35:48 - get rid of we can get rid of that one
35:51 - yeah so we should get rid of tab it's
35:55 - not a question of which one is better
35:56 - it's which one can we get rid of that
35:59 - the tab character is an anachronism that
36:02 - should have died with the typewriter all
36:06 - right
36:07 - we've finally settled that okay we have
36:14 - carriage return in line feed again these
36:16 - are because of the way that the
36:18 - teleprinters worked carriage return
36:21 - would move the printhead back to the
36:23 - margin and line feed would roll the
36:24 - paper up one line and they liked having
36:27 - the two codes because the carriage
36:30 - return function was kind of slow because
36:32 - it you have to move a thing down and
36:35 - having the line feed happened just after
36:38 - it gave it a little bit more time to
36:40 - have that because if you then have to
36:42 - print another character before the
36:43 - carriage return gets back you can be
36:45 - printing ghost characters in the middle
36:47 - of the page and that looks stupid so we
36:51 - don't care about that anymore that's not
36:52 - how printers work now but we still have
36:55 - these two codes and there's still an
36:57 - argument about which one should you use
36:59 - people who think about this in terms of
37:01 - user experience will usually say it
37:03 - should be the carriage return because
37:04 - the Enter key used to say return and so
37:07 - you know that's how users think of this
37:10 - the hardware oriented people say line
37:13 - feed is really the way printers want to
37:15 - work they want to advance to the next
37:17 - thing and so you know how do you decide
37:21 - which one to do well there was a
37:23 - committee in the early days of the
37:25 - internet trying to decide which one
37:28 - should we use and they couldn't decide
37:30 - so they came up with the mutually
37:32 - disagreeable compromise which is we'll
37:35 - use both of them which doesn't make any
37:38 - sense that using both of them went out
37:40 - with mechanical teletypes but we're
37:43 - still doing that if you look at the
37:45 - internet standards look at HTTP it still
37:48 - says you have to use both
37:50 - it doesn't both at the same time it just
37:54 - doesn't make any sense we also have form
37:59 - feed which told the printer to eject the
38:02 - current page and put the next page into
38:05 - the printer so you can start printing
38:06 - and a companion vertical tab which is
38:09 - the vertical version of the horizontal
38:12 - tab but again they didn't specify any
38:15 - way of setting a vertical tab stop so it
38:19 - today it doesn't make any sense
38:21 - JavaScript still lets you say backslash
38:24 - of e representing this it doesn't mean
38:27 - anything and just it's pointless there
38:32 - were four device codes in ASCII so that
38:35 - you can control devices and generally
38:38 - that meant controlling the paper tape
38:40 - reader and the paper tape punch so
38:42 - you're telling a per tape reader on it
38:45 - and if the computer wants to start
38:47 - reading it it can send you can turn the
38:50 - reader on and then it'll start
38:52 - automatically sending characters to the
38:54 - computer and if the computer starts
38:56 - getting overwhelmed oh there's too much
38:58 - input they can then tell it to stop and
38:59 - the computer could also turn on the
39:02 - punch so you can start punching your
39:04 - paper tape those codes are still in
39:06 - ASCII then there are codes for dealing
39:10 - with protocols because they imagine that
39:12 - instead of just sending streams that we
39:15 - might actually be sending higher-level
39:17 - stuff and so this was really new stuff
39:20 - that they were kind of inventing so they
39:23 - imagined that we'd have protocols in
39:25 - which we'll have a start of header and a
39:28 - start of text code and an end of text
39:31 - and an end of block and we'll use those
39:33 - to make packets packets were still a
39:35 - really new idea and then in support of
39:40 - that we have AK the acknowledge code so
39:43 - if you successfully read a packet you'll
39:45 - send it back ACK
39:46 - and if for some reason you couldn't read
39:48 - the whole packet you'll send back nak
39:50 - and there's also the synchronous Idol
39:53 - they anticipated asynchronous mode in
39:56 - which well in a in a circus note mode
39:58 - there's a start bit and a stop bit on
40:02 - each character
40:03 - and that's so you've got an empty stream
40:07 - and then you see a start bit and you go
40:08 - Oh wake up there's a character and you
40:11 - keep getting bits until you get the stop
40:12 - and then you can go back to sleep but
40:16 - there's also a synchronous mode in which
40:17 - the characters go one after another no
40:20 - start bit no stop bit and the problem is
40:23 - how do you know where the character
40:25 - boundaries are because it's just ones
40:27 - and zeros and so they have asynchronous
40:29 - idle so when there's nothing being sent
40:32 - you send this code and on the other side
40:36 - they'll be looking for a pattern of
40:38 - those zeros and ones when they see them
40:40 - they go off that's a character and then
40:42 - they can deal with the rest of it so a
40:46 - packet might look like this you might
40:48 - have a start of text and then the body
40:50 - of the message and then the end of text
40:54 - or you could put a header on it
40:57 - the header might contain an address or
40:59 - some other information which helps you
41:01 - to deal with the packet and using the
41:06 - end of text block you could have really
41:08 - long things and you can get an ACK after
41:12 - each one because it might be too
41:13 - dangerous to try to send something
41:16 - really long because it's guaranteed
41:18 - you're gonna get an ACK so if you send
41:20 - it in smaller chunks then you might get
41:22 - stuff through there are two end codes
41:26 - one was end of transmission so at the
41:29 - end of the session
41:30 - you'd go control D yeah that's the end
41:33 - then we can hang up and and we're
41:35 - finished and there is also end of medium
41:38 - this is something you might put on a
41:40 - tape so you write a tape and at the end
41:42 - you'll write and then to medium code and
41:45 - that means that's the end of the tape
41:48 - then there are a couple of oops codes
41:51 - there's the substitute code that means
41:54 - that if you have a character and you
41:57 - don't know what it is you send the
41:59 - substitute code instead again today the
42:03 - way we think about data communications
42:05 - that doesn't make any sense how can you
42:06 - not know what a character is and still
42:09 - want to send it but you could do that
42:11 - also there's a cancel code if something
42:14 - is coming or if you're sending something
42:17 - side i never mind I'm not going to send
42:19 - the rest of it you can just send the
42:21 - cancel code and and you're done
42:26 - there's escape escape was not what we
42:29 - use it for now
42:30 - escape was for extending the character
42:32 - set they anticipated that the hundred
42:36 - twenty-eight characters in ascii might
42:38 - not be enough so escape would allow some
42:42 - way of extending the character set so
42:44 - when you see the escape code that means
42:46 - the stuff that comes after it is going
42:47 - to be interpreted differently one
42:50 - interpretation that was popular for a
42:52 - while was add an eighth bit to the
42:55 - character so that would get you up into
42:58 - the latin one set but so there is an
43:03 - escape key on the teletypes for that
43:05 - purpose but very quickly people realized
43:10 - we're in a program and we want to make
43:11 - the program stop how do we do that you
43:13 - know I've got this escape key let's
43:16 - let's hook that up and we're still using
43:19 - it right escape gets us out of a mode or
43:20 - cancels the dialog or something like
43:22 - that it was never intended for that is
43:25 - intended for enhancing the ASCII set we
43:29 - have data link escape which does a
43:31 - similar thing sometimes it's used for
43:34 - making a control code literal so if
43:38 - you've got some binary data and you want
43:40 - to be sending an end of transmission
43:41 - mark but you don't want to hang up you
43:43 - want it to be treated as data you might
43:45 - put in DLE in front of it but it could
43:47 - also be used to introduce new control
43:49 - codes because they were concerned that
43:51 - 32 control codes were not enough they
43:53 - thought they might want a lot lot more
43:55 - then I told you about the shift codes
43:59 - for uppercase and lowercase they decided
44:01 - not to use them for that but they still
44:03 - put them in the code and so you could
44:08 - shift out meaning it could shift into
44:10 - another character set and then shift
44:11 - back into ASCII another way of growing
44:15 - the code they provided information
44:19 - separators so there's the file separator
44:22 - the group separator the record separator
44:25 - and the unit separator so they did not
44:29 - intend for or
44:31 - I've heard people say that tab-separated
44:34 - data is the way asking intended us to
44:38 - format data and it's not this is how
44:41 - ASCII intended us to format data you
44:47 - have files made up of records made up of
44:49 - groups made up of units of data
44:52 - unfortunately this isn't really how data
44:55 - ended up that sometimes you have records
44:57 - that really want to contain other
44:59 - records you know so this this doesn't
45:01 - work so I should have told them about
45:05 - Jason right because that's what they
45:09 - really should have been doing but I
45:11 - didn't and my excuse is that I was eight
45:15 - at the time and I was doing other things
45:20 - it's just too busy
45:22 - ah yeah so so that's the ASCII set so
45:29 - again they did not intend this to be a
45:31 - computer character set this is just
45:34 - something that computers would use to
45:36 - communicate with each other but a number
45:38 - of manufacturers thought well let's just
45:40 - try to use this as is because then we
45:44 - don't have to translate from our set
45:46 - into their set for one very common use
45:50 - was something that I called half ASCII
45:52 - [Laughter]
45:54 - where you just take 64 characters of it
45:57 - you said you cut out the control codes
45:59 - and the lower case you just subtract 32
46:02 - from everything and that gets you a nice
46:04 - little six bit character set and there
46:06 - are a number of manufacturers that we're
46:08 - doing stuff like this it it all changed
46:12 - with the microprocessors but we'll get
46:17 - to that in a bit so the next step
46:19 - forward is Unicode Unicode starts in
46:22 - 1991 some very very smart people from
46:25 - Xerox and Apple and other places who
46:28 - have been really struggling trying to
46:30 - make products that worked all over the
46:31 - world and realize we need to figure out
46:34 - what figure out a way to unify the
46:37 - character set so we can just have one
46:38 - product that goes everywhere and so
46:41 - their goal was to make a
46:45 - after set that would serve all of the
46:47 - living languages in the world in 16bits
46:50 - and they came really close to pulling it
46:52 - off but in order to do that they had to
46:54 - do something called Han unification
46:56 - which meant taking or observing that
47:00 - Chinese was the route also of Korean
47:04 - writing and Japanese writing and taking
47:09 - all of all three of those languages
47:11 - putting them into one character said
47:12 - it's too big doesn't fit in 16-bit
47:14 - character sets but if you look at how
47:17 - common those languages still are at
47:19 - least in their orthography then we can
47:23 - squeeze it down into sixteen bits and
47:25 - they tried really hard to do that
47:28 - unfortunately they really pissed off the
47:30 - Japanese but they we're not happy about
47:34 - the way that happened so that brings us
47:36 - five years later tina code two and
47:38 - unicode two now has a much more
47:43 - expansive mission they have grown the
47:47 - character set to 21 bits and they now
47:49 - want to encode all languages even dead
47:52 - languages you know so Egyptian
47:54 - hieroglyph hieroglyphics become part of
47:57 - Unicode which is something I like a lot
47:59 - so I like that
48:02 - unfortunately in 2010 we get unicode six
48:07 - and emoji for a while there was a hope
48:12 - that some day we could finish unicode
48:15 - right we'll find all of the languages
48:18 - that have ever existed we'll write them
48:20 - all down and we'll give all the
48:21 - characters codes and we'll be done
48:23 - unicode will never be done there's no
48:26 - way for ever get in front out of emojis
48:28 - so ASCII lives on in unicode the first
48:35 - hundred twenty-eight characters of the
48:37 - unicode set are at the ASCII set even
48:40 - though ASCII was not intended to be a
48:42 - character set in unicode was intended to
48:44 - be a character set in computers ASCII is
48:49 - in there including the 32 control codes
48:51 - which you now know are mostly
48:53 - meaningless and completely ridiculous
48:56 - right they they don't serve us anymore
49:00 - and the way this stuff works is really
49:03 - important for example in the C language
49:07 - we use the null character to represent
49:09 - the end of string which is not what
49:12 - ASCII said but that's what C says which
49:15 - means that C would have broken on any of
49:19 - the earlier 6 bit character sets because
49:22 - they did not have a null code they all
49:24 - used 0 for a real code so ASCII changed
49:29 - the way we think about programming of
49:33 - letters and words but there was an even
49:36 - bigger influence than that under the
49:40 - influence of 6 bit character sets there
49:44 - are lots of different hardware
49:46 - architectures with lots of different
49:48 - word sizes but they all seem to have a
49:51 - factor of 3 in them so I saw I worked on
49:55 - carat on machines that had 12 bit
49:58 - characters 18 bit characters 24 I'm
50:01 - sorry
50:01 - 12 bit words 18 bit words 24 bit words
50:05 - 36 bit words 48 bit words 60 bit words
50:09 - the thing all of these machines had in
50:12 - common was 6 bit characters and the
50:16 - reason that worked was because that's
50:19 - what the character sets were and so you
50:22 - could pack some number of characters
50:23 - into a word and it all fit and it was
50:25 - really good and these were great
50:27 - machines and and then it all changed so
50:37 - 7-bit ascii cause the ascendance of
50:40 - computer architecture based on eight so
50:44 - IBM took ascii and weirdly mutated it
50:50 - they combined it with their terrible BCD
50:52 - IC code and came up with something a
50:54 - really awful thing called ipsa dick and
50:57 - used that as the character set for the
51:00 - 360 series so that system is based on
51:03 - eight sixteen thirty-two and all of her
51:07 - machines pretty much since then
51:09 - are based on that the the big change I
51:13 - think happened because of Intel so Intel
51:17 - built a machine called the 8008
51:20 - which was the design was brought to them
51:24 - by a company in San Antonio called data
51:28 - point they made intelligent terminals
51:30 - and they were making them out of
51:31 - discrete logic and they were difficult
51:34 - to build and they came up with a design
51:36 - for a simple CPU which would have
51:38 - greatly simplified their terminals and
51:40 - they asked Intel if they would build
51:43 - that chip for them which they did so the
51:47 - initial design of that chip was an 8-bit
51:51 - machine and the reason it was a bit was
51:54 - so that it could process ASCII that was
51:56 - the intended purpose of the 8008 but
52:00 - that 8008 grows into the 8080 and the
52:05 - 8086 and the pentium and all the crap
52:09 - that comes after and so it's all 64 bits
52:12 - now so if the ascii committee had
52:17 - successfully completed as a 6-bit
52:21 - character said 36 bit architecture would
52:25 - have survived and so I think the first
52:29 - microprocessors would have been 12 bit
52:31 - machines not 8-bit machines and that
52:34 - would have completely changed the
52:36 - evolution of stuff that the next step up
52:38 - would have been 24 and so a lot of the
52:45 - memory limitation issues that we felt on
52:47 - PCs we could have avoided those four
52:50 - years and then taking the next step up
52:52 - to 32 and today we would be running in
52:55 - 72 bit architecture which I think would
52:58 - be brilliant you know it would have
53:01 - completely changed the way we do
53:03 - internationalization Europe would have
53:05 - moved immediately to 12 bit character
53:07 - sets because 6 didn't work in exactly
53:09 - the same way that Asia moved immediately
53:13 - to 16-bit character sets because 8
53:16 - didn't work
53:17 - and by doing that we would have avoided
53:20 - all of those internationalization
53:22 - problems and
53:25 - then ultimately the world would adopt an
53:28 - 18-bit character set which would be the
53:31 - unicode set which would serve everybody
53:33 - and seventy two-bit CPUs would be the
53:37 - standard today so that's the end so I'm
53:53 - really looking forward to some excellent
53:55 - questions which will help me figure out
53:56 - what the WoW finish is to this thing so
54:00 - any questions
54:25 - are we learning from our mistakes in
54:27 - this field
54:28 - no now we generally don't do that we
54:34 - will adopt something because it seemed
54:37 - like a good idea at the time
54:38 - and we tend to never revisit it again
54:41 - and so you know as you look down into
54:45 - the history of what we've done and why
54:47 - choices were made and then see where
54:51 - they ended up you know it just you know
54:54 - if we had known where it was going to go
54:55 - we wouldn't have done that but somehow
54:57 - we're still here where we are and we
55:00 - don't recognize that we're still doing
55:02 - that that's just the way we do things
55:05 - yeah
55:26 - yeah what's the path going forward
55:28 - that's a really hard problem I mean I
55:31 - commend with the ASCII committee for
55:35 - doing as well as they did they got a lot
55:37 - of stuff right
55:39 - they were very thoughtful in the way
55:41 - that they approached the problem and
55:42 - they did the best they could where it
55:47 - went wrong I think was not in the ASCII
55:49 - committee it was after again they didn't
55:52 - intend intend for it to be a computer
55:55 - character set the intended to be a
55:57 - transmission code but there were people
56:01 - particularly in the 8-bit world who
56:05 - wanted to save the cost of a character
56:08 - translation table you know they wanted
56:11 - to save you know under 28 bytes and if
56:14 - we make that our character set we saved
56:16 - hundred 28 bytes and at the time that
56:18 - seemed like a really good trade-off but
56:22 - it was only a really good trade-off for
56:24 - a few years eventually Moore's law
56:26 - changes the economics of memory
56:28 - conservation and that it becomes a
56:30 - really bad idea
56:32 - but again once we lock something into a
56:35 - standard or a standard practice it gets
56:38 - it's virtually impossible to roll it
56:40 - back yeah
56:59 - yeah that's a really good question so
57:07 - you would think so that's a really good
57:14 - thoughtful question I'm afraid I don't
57:15 - have an adequate answer for it but thank
57:19 - you for that question
57:20 - yeah yeah so are there any alternatives
57:32 - to Unicode being considered I don't
57:35 - think so I think Unicode Unicode is
57:39 - likely to be the last character set not
57:43 - you know it's just gonna be the way it
57:45 - is and there are some things about
57:48 - Unicode that I think are extremely
57:49 - commendable that they've done some
57:51 - brilliant stuff and there's other stuff
57:53 - in Unicode where you go you know this is
57:56 - awful
57:57 - like I showed you that substitution code
58:00 - in ASCII the one that says the letter
58:03 - you're looking for it's not here or the
58:05 - code you're looking for it's not here
58:07 - not only is that code now in Unicode
58:10 - Unicode added another one so Unicode has
58:14 - its own substitution code saying when
58:16 - it's not here which go we need zero of
58:23 - those codes right and we've got two of
58:25 - those codes one of the things that was
58:28 - liberating about ASCII was because
58:30 - they've got so many characters they
58:34 - didn't have to be nearly as cautious as
58:36 - ASCII was asking when they were picking
58:39 - the characters to go in that set they
58:41 - made really really hard choices and if
58:44 - we put that one in we can't put that one
58:45 - in you know they didn't put the arrow in
58:47 - because they just couldn't make it fit
58:49 - which was it was actually in there for a
58:51 - while and then it got taken out and
58:53 - replaced I think with the underbar you
58:59 - know so you know this stuff stuff I
59:01 - could anticipate I could think of one
59:04 - thing that might propel the world to
59:06 - consider doing a new character set and
59:08 - that would be something that would try
59:10 - to solve the sorting problem
59:12 - so unicode sorts correctly for virtually
59:16 - no languages right well or at least four
59:20 - languages using the latin set that none
59:23 - of the languages sort correctly we could
59:27 - try to and there is no ordering of the
59:30 - letters that will sort correctly for all
59:32 - languages but we could come up with a
59:34 - sorting which would work for most
59:36 - languages so we could design a character
59:39 - set in which we have a followed by a
59:42 - accent followed by a umlaut and so on
59:45 - we'll just batch them all up you know
59:47 - after i comes i J and then J and then K
59:51 - and so on will just take try to take as
59:54 - many of the European characters as we
59:57 - can and put them into one linear
59:58 - sequence and maybe that becomes a good
60:02 - enough idea that we can say this becomes
60:04 - the basis of a new character set I can't
60:07 - imagine anything else you know I think
60:10 - that would be a problem that would be
60:12 - worth solving and that might get us a
60:16 - new character set but I'm really
60:17 - doubtful I don't think we could pull it
60:19 - off there is so much inertia behind
60:21 - Unicode now I think it's going to be the
60:24 - end yeah
60:30 - is there any way to work in three
60:32 - dimensions and character cells or you
60:38 - can stack them up and that's essentially
60:40 - what Unicode does so in Unicode you've
60:43 - got it stacks them in a couple of
60:46 - dimensions one is you've got planes so
60:49 - you've got the basic plane then you've
60:50 - got sixteen additional planes which are
60:53 - all in the same 16-bit set and within
60:55 - the 16-bit set you could see that is
60:57 - broken into stacks of 8-bit sets so
61:02 - that's a three dimensional character set
61:05 - yeah
61:20 - yeah that's the problem because there
61:24 - are definitely costs but all of those
61:28 - costs have already been accepted so in
61:31 - changing to something better it's really
61:35 - hard because it's obvious that there's
61:39 - going to be new costs in moving to the
61:41 - better system and it may not be
61:43 - immediately apparent to what the
61:44 - benefits are whereas we don't properly
61:48 - account for the costs in the old system
61:50 - so the new system is going to be at a
61:52 - huge disadvantage yeah could there be
62:01 - advantages to compression by altering
62:03 - the character set maybe although some of
62:08 - our our compression codes are our smart
62:13 - codes that learn in our adaptive so they
62:17 - seem to be doing pretty well I don't
62:18 - think we could get much improvement by
62:22 - changing the underlying character set
62:26 - yeah
62:33 - it's more bits yeah so the memory
62:46 - addressing problem we passed 64 bits
62:50 - looks like we're gonna be good for a
62:51 - long long time with that so and 64-bit
62:57 - is well so in JavaScript we get
62:59 - essentially 53 bits at least on our
63:02 - integers and that's quite a lot
63:06 - particularly when you compare it to the
63:08 - 32-bit architectures and much of
63:11 - JavaScript unfortunately is still 32
63:12 - bits and there's been some pressure to
63:18 - try to get JavaScript to add a 64 bit
63:20 - thing which I'm very opposed to that if
63:26 - you want extended arithmetic you can
63:28 - write a simple function in JavaScript
63:31 - that gets you extended precision so we
63:34 - don't really need to change the language
63:36 - fundamentally and if you have two number
63:39 - types and if they ever come in contact
63:42 - with each other you're guaranteed to
63:45 - have errors right because values are not
63:50 - yeah that kind of stuff so I'm very
63:54 - unhappy with the floating-point system
63:55 - we have in JavaScript it's it's horrible
63:58 - but I can't see that we're going to
64:00 - replace it because again we've accepted
64:03 - all the costs of a floating-point system
64:06 - that works really badly and so we're not
64:09 - going to get be able to overlook the
64:12 - costs of moving to something that's
64:14 - going to like add money correctly even
64:16 - though that I think is much more
64:18 - important I think Dex 64 would be great
64:23 - and I highly recommend that Dec 64 be
64:27 - the only number type in the next
64:28 - language but I have no hope that it will
64:31 - ever get a JavaScript JavaScript is
64:34 - whereas Brendan Eich used to say that
64:36 - ship has sunk
64:39 - yeah yeah quantum computing is a
64:54 - completely different thing so you've got
64:56 - these quantum bits which can be in
64:58 - multiple states simultaneously and it's
65:03 - presumed that that leads to the solution
65:05 - of problems which cannot be solved in
65:08 - linear time on conventional hardware but
65:11 - they don't act like bits so there's not
65:14 - a correspondence to bits they're
65:16 - different stuff so even if we do get
65:20 - quantum computing I think it will be
65:23 - used in very specific applications
65:26 - things where you get the benefit of the
65:28 - undecidability in order to solve very
65:30 - hard problems one of the most popular
65:34 - expected application that seems to be
65:36 - breaking of cryptographic systems so
65:39 - which will certainly be problematic but
65:43 - it doesn't appear that it's going to be
65:45 - a platform for general-purpose computing
65:48 - so I think we'll still have bits for a
65:51 - long long time now a more interesting
65:56 - breakthrough might be trying to figure
65:58 - out the neural stuff that we still
66:00 - haven't figured out how this stuff works
66:01 - yet but we know really well now that it
66:05 - works really differently than digital
66:07 - systems so it may be that eventually
66:10 - we'll figure out how to make neurons and
66:13 - stuff like that and that will work on a
66:16 - completely different principle and who
66:20 - knows what we'll do with that
66:26 - anybody else okay so I think we're done
66:31 - thank you very much so yeah yeah I think
68:05 - thank you I mean like this is amazing
68:08 - thank you guys for coming out
68:10 - stay tuned for more meetups lots to come
68:13 - does everybody know what our JavaScript
68:15 - la YouTube checklist feel like okay does
68:54 - anybody have questions I'm sorry on
69:06 - which side
69:14 - give me a better picture so I can find
69:19 - oh yeah oh great great thank you very
69:27 - much
69:43 - [Applause]