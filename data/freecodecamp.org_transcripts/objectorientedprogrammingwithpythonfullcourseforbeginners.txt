00:00 - It's important for software developers to 
understand object oriented programming.  
00:04 - In this course, Jim from JimShapeCoding will teach 
you all about object oriented programming and  
00:10 - Python object oriented programming, it could be 
what is holding you back from being a great Python  
00:15 - developer. And as well as lending your first job 
as a software engineer, Welcome everyone to Python  
00:23 - object oriented programming course. Now if you 
struggle to understand the concepts of object  
00:28 - oriented programming in the past, then you are 
totally fine. And you're in good hands. Because  
00:33 - in this course, I'm going to make sure that this 
will be the last tutorial that you will ever watch  
00:38 - about classes and the complex concepts that 
comes with object oriented programming. And we  
00:45 - are going to do this by developing a real Python 
application, that is going to be very cool to  
00:51 - write. And we will add to its complexity step by 
step. And throughout the way, we will understand  
00:58 - everything that we need to know about object 
oriented programming. Now there are going to  
01:02 - be some requirements to this course, I do expect 
from everybody to know at least about functions,  
01:08 - variables, if statements and as well as for 
loops. And if you know those things from  
01:14 - other programming languages, then this 
is also fine. So with that being said,  
01:18 - let's get started. Now to explain why you 
should write object oriented programs,  
01:22 - I will explain the concepts based on a store 
management system that we will start developing  
01:27 - together. So starting to think about how to 
take our first steps with such a problem,  
01:32 - we could first think about tracking after the 
items that we have right now in our store. So one  
01:37 - way we could get started, we could create those 
four variables to start tracking after our items.  
01:43 - So as you can see, we have our first variable item 
one equals to phone. And then we have three more  
01:48 - variables that are intentionally starting with the 
prefix of item one, so that we could describe that  
01:54 - those four variables are related to each other 
by following the correct naming conventions. Now,  
02:00 - you might think that those four variables are 
related to each other only because it uses the  
02:04 - same prefix of item one. For Python, those are 
just four variables with different data types.  
02:11 - So if we were to print the type, for each of those 
four variables, now, we will receive their types  
02:18 - with no surprises, right, we will receive string, 
and integer for price, quantity and price total.  
02:25 - Now I want to focus on those specific outputs 
right now, because as you can see, for each of the  
02:31 - types, we also see the key word of class. Now this 
means that those data types are actually instances  
02:40 - of strings or integers. So in Python programming 
language, each data type is an object  
02:47 - that has been instantiated earlier by some 
class. And for the item, one variable that has  
02:54 - been instantiated from a string type of class. 
And for the price quantity and price total,  
03:00 - those have been instantiated from a class that 
is named Iand, meaning integer. So it could  
03:06 - have been nicer. If we call the tail Python 
that we want to create a datatype of our own,  
03:12 - it will allow us to write a code that we can 
reuse in the future easily if needed. Now,  
03:17 - each instance could have attributes to 
describe related information about it.  
03:22 - And we can think about at least some good 
candidates for attributes we could have for our  
03:28 - item datatype, like its name, price, or quantity. 
Alright, so let's go ahead and start creating our  
03:35 - first class. So I will clean everything from here, 
and we'll go ahead with it. So it is going to be  
03:40 - divided into two parts, the first one will be the 
creation of the class. And the second one will be  
03:46 - the part that I will instantiate some objects of 
this class. Now when I say creating an instance,  
03:52 - or creating an object, basically I mean to the 
same thing, so you might hear me saying one of  
03:58 - those. Alright, so let's go ahead and say class. 
And then this needs to be followed by the name  
04:04 - of the class that you want to create. So we would 
like to give it the name of item. And then inside  
04:09 - of this class, in the future, we are going to 
write some code that will be very beneficial and  
04:15 - very useful for us. So we won't repeat ourselves 
every time that we like to take similar actions.  
04:21 - But for now, temporarily, I'm going to say here a 
pass so we will not receive any arrows inside this  
04:27 - class definition. Alright, so now that we have 
created our class, then we are allowed to create  
04:32 - some instances of this class. So let's go ahead 
and say item one is equal to item. And that action  
04:39 - is equivalent to creating an instance of a class, 
just like if you were to create a random string,  
04:46 - then you will say something like the following. 
This is equivalent to this one as well. So it  
04:52 - is very important to understand how classes are 
working in Python. So I will delete this line  
04:57 - because this was just for an example. And now I 
said that we are allowed to assign some attributes  
05:03 - to instances of a class. So let's go ahead and 
start creating attributes. And that will be  
05:09 - achievable by using the dot sign right after the 
instance of a class. And here you can say that you  
05:16 - want to give it an attribute, like a name, that 
will be equal to phone, and item one, that price  
05:22 - could be equal to 100. And I think one dot 
quantity could be equal to five, for example.  
05:31 - Now in that stage, you might ask yourself, what 
is the difference between the random variables  
05:36 - that we have created to those four lines? 
Well, here, we actually have a relationship  
05:41 - between those four lines, because each one of the 
attributes are assigned to one instance of the  
05:47 - class. And I could probably do this by going ahead 
and try to print the types of item one nil, and as  
05:55 - well as the types of the attributes of name, price 
and quantity. Now with name, price and quantity,  
06:02 - we are not going to have any surprises because we 
assign string type attributes to the item object.  
06:08 - But if we were to print that, then check 
out the result if I was to run this program,  
06:14 - so you can see that now we have a data type of 
item here. And that is the big difference between  
06:20 - what we have seen previously to this thing that 
we have just created. So now we understand how  
06:26 - we can create our own data types. Now let's go 
ahead and see what are the rest of the benefits  
06:31 - using object oriented programming. Okay, so until 
now, we understood how to assign attributes to  
06:37 - instances, we should also understand now how we 
can create some methods and execute them on our  
06:43 - instances. Now, if we will take as an example, the 
building class of string, then you know that we  
06:49 - have some methods that we can go ahead and execute 
for each of our strings. And for this example,  
06:55 - you can see that I grabbed an instance of a string 
that I named random str, and then I go ahead in  
07:01 - the next line and execute the opera method, which 
if you remember is it's possible to grab all  
07:06 - the letters and turn them to uppercase. Now the 
biggest question here is how we can go ahead and  
07:12 - design some methods that are going to 
be allowed to execute on our instances,  
07:17 - Well, the answer is inside our class. So we could 
go inside our class and write some methods that  
07:24 - will be accessible from our instances. So we could 
go ahead and say that and give our method a name.  
07:33 - Now a good candidate for a metal that we'd like 
to create now is actually calculate total price,  
07:40 - because as we understand, it could have been 
nice. If we were to have a method that will go  
07:44 - ahead and calculate the result, multiplying it one 
dot price, with item one dot quantity, so we can  
07:51 - get the total price for that specific item. Now 
before we go ahead and complete this function,  
07:57 - then I'm going to just create one more instance 
of this item by also deleting those two lines,  
08:02 - because we understood the example. So I'm 
just going to change those to item two,  
08:07 - like that. And I'm going to use something like 
laptop and change the price to 1000. And say  
08:14 - that we have three of those. Now just a quick 
side note, when you will hear me say methods,  
08:19 - then I basically mean two functions that are 
inside the classes. Because in terms of Python,  
08:25 - or in any programming language, when you have 
isolated definitions with this keyword, then those  
08:31 - are considered to be called functions. But when 
you go ahead and create those functions inside  
08:36 - classes, then those are called methods. So that 
is an important point that you should understand,  
08:42 - because I'm going to call those methods 
from now. Okay, so now if I was to continue  
08:47 - by opening up and closing those parentheses, 
then you are going to see one parameter that  
08:52 - is autogenerated that Python wants us to receive 
intentionally. Now the reason that this happens,  
08:59 - Python passes the object itself as a first 
argument, when you go ahead and call those  
09:06 - methods. Now, if I was to go here, and 
say item one dot calculate total price,  
09:14 - then the action that we are doing now is calling 
this method. But when you go ahead and call a  
09:19 - method from an instance, then Python passes the 
object itself as the first argument every time.  
09:27 - So that is why we are not allowed to create 
methods that will never receive parameters.  
09:33 - Now you will see this if I was to remove the first 
parameter, and say something like pass. Now if I  
09:40 - was to execute this program now, then you're going 
to see type zero, calculate total price takes  
09:48 - zero positional arguments, but one was given. 
So in simple words, what this exception says  
09:55 - is that Python tries to pass one argument and you 
are not received using any parameter, so that is  
10:01 - very problematic. And that is why you always have 
to receive at least one parameter when you go  
10:07 - ahead and create your methods. Now since we always 
receive this parameter, then it is just a common  
10:14 - approach to call this self. It was okay if I was 
to call it something like my perm, or I don't know  
10:20 - something else. But you never want to mess up 
with common conventions across different Python  
10:26 - developers. So that is why just make sure that 
you leave it as self every time. Now, if I was to  
10:33 - go ahead and run this program, then you got to see 
that we are not going to receive any errors. So  
10:39 - this means that this method has been implemented 
correctly. Now let's see how we are going to  
10:44 - benefit from creating this method, because it 
should go ahead and create a calculation for us  
10:49 - using price and quantity. So I will intentionally 
receive here two more parameters, which we could  
10:56 - name just x&y for now. And we could just 
say return x multiplied by y. And now I  
11:04 - will go ahead and pass in here, two additional 
arguments. And it will be item one dot price.  
11:11 - The second one will be quantity. So that is 
going to work because when you call this method  
11:17 - in the background, Python passes this as an 
argument. And then it passes the second argument.  
11:22 - And then this has been passed as a third argument. 
So that is perfect. And if I was to run that,  
11:28 - and actually print this, so excuse me for running 
this before printing it, so I will surround this  
11:36 - expression with this print built in function. 
And I will run that and you're gonna see 500 as  
11:41 - expected, now I could do the exact same thing for 
calculating the total price of our second item.  
11:48 - So if I was to grab this and paste this in, 
in this line, and actually change this to item  
11:55 - two, and change this one to item two, and 
as well as this one, then I will receive  
12:02 - 3000 as expected. And that is how you can 
create a metal. Alright, so until that point,  
12:08 - we understood that we can assign attributes and as 
well as creating some methods that we can go ahead  
12:14 - and use them from our instances directly, like 
those two examples in that line, and as well as in  
12:21 - that line. Now in that episode, we are going to 
solve some more problems that we have in terms of  
12:26 - best practices in object oriented programming, 
and things that you're going to see in each  
12:31 - project that is based on Opie. Alright, so let's 
get started. Now one of the first problems that  
12:36 - we have here is the fact that we don't have a set 
of rules for the attributes that you would like to  
12:42 - pass in in order to instantiate an instance 
successfully. And what that means, it means  
12:47 - that for each item that I want to go ahead and 
create, I need to hard code in the attribute name  
12:53 - like those in here. And it could have been nicer 
if we call somehow declaring the class that in  
13:00 - order to instantiate an instance successfully, 
name, price and quantity must be passed,  
13:06 - otherwise, the instance could not have been 
created successfully. So what that means, it means  
13:12 - that it could have been a great option if we could 
somehow execute something in the background. The  
13:18 - second that we instantiate an instance and there 
is a way that you can reach such a behavior. And  
13:24 - that is by creating a special method with a very 
unique name, which is called double underscore  
13:30 - init double underscore. Now you might hear this 
term as well as cold as constructor. Basically,  
13:37 - that is a method with a unique name that you need 
to call it the way it is intentionally in order to  
13:44 - use its special futures. Now, the way that this is 
going to work is by creating it the following way.  
13:52 - So it will be double underscore. And as you can 
see, I already have auto completion for some very  
13:58 - special methods that are starting and ending with 
double underscore. Now the collection of those  
14:04 - methods are used to be called Magic methods. And 
we are going to learn a lot of more magic methods  
14:10 - that you have in Opie, but the first one that we 
are going to start with will be the init double  
14:17 - underscore, like that. Alright, so now that we 
have created this method, then let's actually see  
14:23 - what this metal does in the background. So when 
you go ahead and create an instance of a class,  
14:28 - then Python executes this double underscore 
init function automatically. So what that means,  
14:34 - it means that now that we have declared our 
class, Python is going to run through this line.  
14:40 - And then since an instance has been created, and 
we have double underscore init method designed,  
14:45 - then it is going to call the actions that 
are inside this double underscore init  
14:50 - double underscore method. Now in order to prove 
that, then I'm going to start with a very basic  
14:56 - point here that will say I am created Like that. 
Now we got here, one instance. And here we got  
15:05 - another one. So we should see I am created twice. 
And in order to avoid confusions, then I'm going  
15:11 - to delete those print lines from here so we can 
see a cleaner picture. Alright, so if we were to  
15:17 - run our program, then we can see that we have I am 
created twice. And that is because Python called  
15:24 - this double underscore init double underscore 
method twice, thanks to those two instances that  
15:29 - we have graded. Alright, so now that we use the 
double underscore init function in this class,  
15:33 - we should take benefit from it and solve some 
more problems in order to implement Opie best  
15:39 - practices. Now if you remember in the beginning 
of this tutorial, I said that one of the problems  
15:43 - that we have till this point is the fact that we 
still hard code in the attributes in that way by  
15:50 - saying dot name, dot price dot quantity. And 
that is something that we can for sure avoid.  
15:56 - Now let's see how we can start avoiding creating 
those attributes hard coded for each of the  
16:01 - instances here. So we can actually benefit from 
the double underscore init method that we have  
16:05 - designed. And let's see how now we understand 
that for each instance that we will create, it  
16:11 - will go ahead and call this double underscore init 
method automatically. So what that means, it means  
16:17 - that not only we can allow ourselves to receive 
the self parameter, because this is a mandatory  
16:22 - thing that we should do, because Python in the 
background, passes the instance itself as the  
16:27 - first argument, we could, in addition, take some 
more parameters, and then do something with them.  
16:33 - So as a solder, let's say that we would like to 
receive one more parameter that we could name it  
16:39 - name. And as you can see, automatically, Python 
is going to complain how the name argument is  
16:46 - not filled in here. So now, I could go ahead and 
pass in the argument of phone for that one. And  
16:53 - for the second one, I can go ahead and pass in the 
argument of laptop. Now once I have created this,  
17:00 - then I can actually go ahead and change my 
print line a little bit. So it will be a unique  
17:04 - print line where I can identify from where each 
print line came from. So I can go ahead and say  
17:11 - an instance created and use a column here and 
then refer to the name like that. And now that  
17:19 - we have created this, then if we were to run our 
program, then you're gonna see unique sentences,  
17:25 - an instance created for the phone, and as well as 
for the laptop. Alright, so now that we have done  
17:31 - this, then there is something that is still 
not quite perfect, because we still pass in  
17:36 - the attribute of name here and here. So now pay 
attention to how the init method has to receive  
17:44 - the self as a parameter as well. And we already 
know the reasons for that. And the fact that we  
17:49 - have self as a parameter here could actually allow 
us to assign the attributes from the init method,  
17:55 - so that we will not have to go ahead and assign 
the attribute of name for each of the instances  
18:01 - we create. So what that means, it means that 
I can dynamically assign an attribute to an  
18:07 - instance from this magic method, which is called 
double underscore in it. So if I was to say, self,  
18:14 - dot name, so I'm assigning the 
attribute of name to each instance,  
18:20 - that is going to be created or created yet, 
and I'm making that to be equal to the name  
18:27 - that is passed in from here. So what that means, 
it means that now I can allow myself to delete  
18:34 - this line. And then this line. So as you can 
see, now I have a dynamic attribute assignment,  
18:42 - thanks to the self dot name equals name that 
we have wrote here in the to test that the  
18:47 - attribute assignment world, then I can go down 
here and use two more lines that will look like  
18:52 - the following. So I will print it one dot name, 
and I will also print item to that name. And in  
19:01 - order to avoid confusions, then I'm going to 
get rid of this line. So we could only see  
19:06 - the print lines from here. And now if I 
was to run that, then you can see that we  
19:10 - receive a phone and laptop. So it means that we 
were able to assign the attributes dynamically.  
19:16 - And that is perfect. And now that we get the idea 
of that, then we should also do the same for the  
19:21 - rest of the attributes that we'd like to receive. 
So we also got the price and quantity to take  
19:27 - care of. So I'm going to go to my init 
method, and I'm going to receive again,  
19:32 - price and quantity. And I'm going to do the exact 
same thing. So I'm going to assign the attribute  
19:38 - of price. And that will be equal to price. And the 
quantity will be equal to the quantity. And you  
19:46 - can also see that again Python complains about the 
price and the quantity not being passed in here.  
19:51 - So I can say 100 and then five, and then I can 
delete those. And then I can do the same here.  
19:59 - I could pass In 1000, and then three, and delete 
those, and in order to prove that this is going  
20:06 - to work, then I'm going to copy myself a couple of 
times and change this to quantity, I mean price,  
20:16 - this one will be price as well. This one will be 
quantity and this one as well. Now if I was to  
20:23 - run that, then you can see that the results are 
as expected. So that is a way that you should  
20:28 - work with the double underscore init method, 
you should always take care of the attributes  
20:33 - that you want to assign to an object inside the 
double underscore init method meaning inside the  
20:39 - constructor. Now a couple of signs that are quite 
important to remember when we work with classes.  
20:44 - Now when we go ahead and use the Ws coordinate 
method, this doesn't mean that we cannot  
20:49 - differentiate between mandatory parameters to non 
mandatory parameters. So say that you currently  
20:56 - don't know how much you have from a specific 
item, then you can go ahead and by default,  
21:03 - received this quantity parameter as zero, because 
it is realistic situation that you currently don't  
21:08 - know how much phones you have on your store. 
so we can directly go ahead and use a default  
21:13 - value for that, for example, zero, and then this 
will mean that you will not have to pass in those  
21:20 - five and three here. And now in order to show you 
the results of that, if I was to run our program,  
21:26 - then you can see that we receive zero twice for 
those two prints in here. So that is something  
21:32 - that you will want to remember. And one more quite 
important point that I'd like to talk about now  
21:38 - is the fact that you can assign attributes to 
specific instances individually. So say that  
21:45 - you want to know if the laptop has numpad are not 
because some laptops are not having the numpad on  
21:53 - the right side of the keyboard. But this is not a 
realistic attribute that you will want to assign  
21:59 - to a phone. And that is why you can go ahead 
and let me delete those print lines, by the way.  
22:05 - And that is why you can go ahead and say something 
like item two that has numpad equals to false like  
22:13 - that. And that is something that you want to 
remember, because the fact that you use some  
22:18 - attribute assignments in the constructor doesn't 
mean that you cannot add some more attributes that  
22:24 - you will like after you instantiate the instances 
that you would like to. Alright, so now that we  
22:30 - understood this, then there is still one small 
problem that is left that we need to solve.  
22:35 - Now pay attention how the calculate total 
price still receives the x and y as parameters.  
22:42 - And the question that we asked now is why it still 
receives those parameters. Well, we could for sure  
22:49 - now not received those parameters. Because as we 
know, for each metal that we design in classes,  
22:56 - then the object itself is passed in argument. And 
I know that I repeated this a couple of times.  
23:01 - But this is where I failed to understand classes. 
So that is why it is very important to understand  
23:07 - this behavior. And we already know that the 
object itself passed as an argument. So that's  
23:12 - why we receive self. And so this means that now 
we could just return self dot price multiplied  
23:21 - by self dot quantity. And this will mean that we 
don't really have to receive those parameters,  
23:27 - because we assign those attributes, once the 
instances has been graded. So this means that  
23:33 - we have access to those attributes through how 
the methods that we are going to add here in  
23:37 - this class in the future. So in order to 
test that this works, then I'm going to  
23:43 - delete this example for now. And I'm going to say 
print item one dot, calculate total price. So we  
23:51 - will be able to return the result here. And I will 
do the same for item two, sorry, only this one.  
24:00 - Now to show some real number other than zero, then 
I will go ahead and pass in here, quantities. So I  
24:07 - will say one and three, for example, because I 
don't want to multiply a large number which is  
24:12 - zero. And that could come from here. So I will run 
that. And you'll see that we receive the expected  
24:19 - results. So now we completely understand the big 
picture, how to work with the constructors in  
24:26 - classes, and what are the best practices that 
you should go ahead and implement. Alright,  
24:31 - so now that we understood this, then we might 
think that we have done everything perfectly.  
24:36 - But actually I want to show you what will happen 
if we were to pass in here a string besides  
24:43 - an integer and run our program. So if we were to 
run that, then you can see that we are screwing  
24:49 - things up here. Because this function for example, 
things that he chose to print the string three  
24:56 - times because you'll see we have 1000 multiply 
by three that is being returned in here. So it  
25:02 - shows us 1000 once, 1000 twice, and then one more 
time. So what that means, it means that we have  
25:10 - to validate the datatypes of the values that we 
are passing in. So there are a couple of ways to  
25:17 - achieve this. And one way is by using typing's in 
the parameters that you're declaring inside here,  
25:23 - so a great starter will be, for example, to 
declare that a name must be a string. Now, let me  
25:30 - first take this back and change those to integer 
and then go here and design those parameters.  
25:38 - So in order to specify a typing, then you should 
go ahead and create a colon sign, followed by the  
25:43 - type of the datatype that you expect to receive 
here. So if I was to pass in here, only the object  
25:50 - reference to the class of str, then it will mean 
that it will have to accept strings only. And I  
25:57 - can prove that by changing this to an integer. And 
you're going to see that we have a complaint here  
26:03 - that says expected type str God int instead. And 
that is perfect. So now that we have done this,  
26:11 - then I'm going to do the same for the price 
itself. And the price, we could actually do the  
26:17 - same thing with it by passing in float. Now when 
we pass float, it is okay to also pass integers.  
26:26 - And that is something very unique with floats 
and integers together. So that is okay to  
26:31 - use the typing of float. And for the quantity, we 
don't need to specify a typing, because the fact  
26:38 - that we passed a default value of integer already 
marked these parameter as to be integer always. So  
26:45 - that is why, for example, if I was to leave this 
as it is and change the quantity to a string, then  
26:53 - you're gonna see that it is going to complain, 
because the default value is already an integer.  
26:58 - So it expects for an integer. All right, so those 
things are actually great setups to make our init  
27:04 - function more powerful. But we might still want to 
validate the received values in the following way.  
27:11 - So say that you never want to receive a negative 
number of quantity. And you'll never want to  
27:17 - receive a negative number of price. So that 
is something that you cannot achieve by the  
27:22 - typing's in here. But there is actually a great 
way to work this around. And that will be by using  
27:28 - assert statements. Now assert is a statement 
keyword that is used to check if there is a match  
27:38 - between what is happening to your expectations. So 
let's see how we can get work with assert. So I'm  
27:44 - actually going to delete this from here. And I'm 
going to organize our init method a little bit,  
27:49 - I'm going to say here a comment and I will say 
assign to self object. And I will say up top  
27:57 - something like run validations to the received 
arguments. Alright, so now it is a great idea  
28:06 - to validate that the price and quantity are both 
greater than or equal to zero, because we probably  
28:13 - don't want to handle with those when they are 
negative numbers and we want to crash the problem.  
28:19 - So we could say assert and pay attention that 
I use it as a statement not a built in function  
28:24 - or something like that. And I can say here, 
price is greater than or equal to zero. Now  
28:34 - once I said this, then I can also do the same for 
quantity, actually. So let me do that quickly.  
28:43 - By this way, and then once we have this, then 
I can actually go ahead and run our program.  
28:50 - And you will see that I will not receive any 
arrows. But the second that I change this quantity  
28:56 - to negative one, for example, and this one being 
negative three, then I will have some arrows  
29:02 - that will say, assertion error. Now you can see 
that the fact that we see here, assertion error  
29:10 - is quite a general exception, that doesn't 
mean anything. Now what is so beautiful with  
29:16 - a third, you can add your own exception messages 
right near of it as a second argument. So let's go  
29:23 - up top here and go back to those two lines. So the 
first argument that is passed to the statement is  
29:30 - the statement that we'd like to check. But if we 
were to say here comma, and use a string to say,  
29:37 - actually formatted string, and I can say price and 
then refer to the value of it is not greater than  
29:49 - zero like that. They can add an explanation 
mark here, and they can use the same thing.  
29:56 - Copy that with a comma and paste this 
in here. And changed this quantity  
30:03 - and then refer to the value of it and say that 
it is not equal to i mean greater than or equal  
30:09 - to zero. So we need to be actually changed 
to greater than or equal to, like that.  
30:16 - And same goes for here, and I have some a 
space here that will be deleted. All right,  
30:24 - so now if I was to execute our program, then you 
can see that we receive assertion error quantity  
30:31 - minus one is not greater or equal than zero. 
So I should delete this, then here for that,  
30:38 - and now it is perfect. So now we understand 
that using the assert statement could allow  
30:42 - us to validate the arguments that we receive. 
And also, it allows us to catch up the bugs as  
30:49 - soon as possible, before going forward with 
the rest of the actions that we'd like to take  
30:54 - within this program. So let me actually change 
those back to valid values like that. And  
31:01 - that is perfect. Alright, so until this point, we 
learned about how to work with the constructor.  
31:06 - And we also learned about how to assign different 
attributes to instances that are going to be  
31:11 - unique per instance, which means that you can go 
ahead and create as much as instances as you want,  
31:16 - and you have the control to pass whatever 
values you would like to for the name,  
31:20 - price and quantity. Now consider a situation that 
you'll want to make use of an attribute that is  
31:26 - going to be global, or across all the instances 
now are a good candidate, for example of this  
31:33 - could be a situation that you will want to apply a 
sale on your shop. So this means that you want to  
31:38 - go ahead and having the control of applying some 
discount for each one of the items. And that is  
31:45 - a good candidate for creating an attribute that 
is going to be shared across all the instances.  
31:51 - Now we call those kinds of attributes, class 
attributes, and the kinds of attributes that we  
31:57 - have learned that till this point is actually 
called in a full name instance attributes.  
32:02 - So about instance attributes, we know 
everything, and we learned how to work with it,  
32:06 - but we did not work it with the other kind of the 
attributes, which we will do in this tutorial,  
32:12 - which is called again, a class attribute. 
So a class attribute is an attribute that is  
32:17 - going to be belong to the class itself. But 
however, you can also access this attribute  
32:23 - from the instance level as well. Let's go ahead 
and see a good candidate for a class attribute  
32:28 - that you want to go ahead and create it. So 
that's going to be going to our class here.  
32:34 - And just in the first line inside our class, 
I can go ahead and create a class attribute.  
32:39 - So let's go ahead and create an attribute like 
pay rate equals to 0.8. And the reason that I'm  
32:44 - doing this is because I said that there is going 
to be 20% of discount. So I probably want to store  
32:50 - an attribute that will describe how much I still 
need to pay. So I will say here, the pay grade  
32:57 - after 20% discount like that. Okay, so now that 
we have created this, then let's see what are the  
33:05 - ways that we can access this attribute. Now, if I 
was to go down and actually deleting one of those,  
33:12 - and say something inside this print line that will 
look like the following. So I will try to access  
33:17 - to the reference of the class itself. So I'm not 
going to create an instance like that, besides,  
33:22 - I'm just going to bring in the reference to the 
class level itself. And I'm going to try to access  
33:27 - this attribute by saying the PE underscore rate. 
Now if I was to run that, then you're going to see  
33:32 - that as expected, we see this class attribute, 
because that is a way that you can access  
33:38 - those class attributes. Now this might be 
confusing, but I said a minute ago that you  
33:43 - can also access those class attributes from the 
instance level. Well, let's see if that is true.  
33:49 - So if I was to duplicate those lines twice, by 
using the shortcut of Ctrl D, then let's go ahead  
33:56 - and change those to item one, and this one to 
item two. Now see how I try to access the pay rate  
34:05 - attribute from the instance, although we don't 
have such an instance attribute. Now if I was to  
34:11 - run that, then you're going to see that we still 
have the access to see that class attribute. Well,  
34:17 - that might be confusing. And that might be 
hard to understand why that is happening.  
34:22 - Well, there is actually something that we need to 
understand when we work with instances in Python.  
34:27 - So when we have an instance on our hand, then At 
first this instance tries to bring the attribute  
34:33 - from the instance level at first stage, but if it 
doesn't find it there, then it is going to try to  
34:40 - bring that attribute from the class level. So what 
that means it means that item one did something in  
34:47 - here and say to itself, okay, so I don't have this 
attribute right in here because that is just not  
34:53 - an attribute that assigned to me. So I'm going 
to try to search that from the instance level  
34:58 - and then I'm going to find it and if sprinted 
back. So that is exactly what is happening here.  
35:03 - Item one and item two are instances that could not 
find the pay rate attribute on the instance level.  
35:10 - So both of them went ahead and try to bring 
this attribute from the class level. And since  
35:16 - it really exists in the class level, then we 
were able to access those. Now to even give  
35:20 - you a better idea of what is going on here. Then 
I'm going to do one more additional thing. Now I  
35:26 - will delete these first print line. And I will 
go ahead and delete those attributes from here  
35:31 - as well. Now there is a built in magic attribute, 
not a magic method, that you can go ahead and see  
35:38 - all the attributes that are belonging to that 
specific object. And that is achievable by using  
35:45 - this double underscore vi CT double underscore 
like that. So this will go ahead and try to  
35:53 - bring you all the attributes that are belonging 
to the object that you apply this attribute and  
35:57 - want to see its content. So I will go ahead and 
copy this one and paste this in for the instance  
36:03 - level as well. So this will give me all the 
attributes for class level. And the second line  
36:11 - will do this for the instance level. 
Alright, and if I was to run that,  
36:17 - then let's explore the results for a second. Now 
we can see that at the first line, we see this  
36:23 - pay rate attribute. But in the second line, we 
never see it, we see name, price and quantity.  
36:29 - And you can also pay attention that this magic 
attribute is actually responsible to take all the  
36:34 - attributes and convert this to a dictionary. And 
that is from where the dict keyword coming from  
36:40 - it is just a shortened version of a dictionary. 
So that is a very useful magic attribute that  
36:45 - you can go ahead and use if you just want 
to see temporarily for debugging reasons,  
36:50 - all the attributes that are belonging to some 
object. Alright, so now that we understood this,  
36:56 - then let's take it to a real life example and 
come up with a method that will go ahead and apply  
37:00 - a discount on our items price. So that will be by 
creating a method that will we belong to each of  
37:07 - our instances in that means that we can go ahead 
and come up with a method that we could name apply  
37:12 - discount. So let's go ahead and start working 
on this. So I'm going to say def apply, discount  
37:19 - and pay attention that I'm using a new method 
inside a class here. So right inside of this,  
37:25 - then add first we need to figure out how we are 
going to override an attribute that is belonging  
37:31 - to an instance. And we already know that we can 
do that with the self keyword. So it will be  
37:36 - self dot price. And that will be equal to self dot 
price, meaning the older value of this attribute  
37:45 - multiplied by the pay rate. Now you might expect 
that we could access this directly like that. But  
37:52 - if you remember, that is actually belonging to the 
item class itself. Now this might be confusing,  
37:58 - because this method already inside this class. 
So you might think already that you can access  
38:03 - it directly by saying pay rate, because it is 
already inside the class. But that is actually not  
38:09 - going to work. Because you can either access it 
from the class level or the instance level as we  
38:14 - understood previously. So we can go ahead and say 
item dot pay rate like that. And there you have a  
38:20 - metal that can go ahead and basically override 
the price attribute for one of your items.  
38:26 - Now to show you that this works, then I can only 
use one instance for now. And I can go ahead and  
38:33 - call this method by saying apply discount. And I 
can also now try to print the attribute of price  
38:41 - for this item one, and we should see ad right. So 
if we were to run that, then you're going to see  
38:48 - that we are going to receive at point zero as 
expected. Now we should not forget the option  
38:53 - that you might also want to have a different 
discount amount for a specific item. So say that  
38:59 - one day you will have 20 items or in only for the 
laptop, you will want to have a 30% discount. But  
39:06 - it is going to be a bad idea changing the class 
attribute to 0.7 because it will affect all the  
39:12 - items that you have right now on your hand. So 
what you can do instead is you can assign this  
39:18 - attribute directly to one of the instances that 
you would like to have a different discount amount  
39:23 - for so let's go ahead and see an example for 
this. So I will allow myself to bring back the  
39:28 - item or laptop and then what I can do to apply 
a 30% discount for this item is assigning the  
39:37 - exact same attribute to the instance. So I can go 
ahead and use a item to that pay on the score rate  
39:43 - is equal to 0.7. Now what will happen here is 
that for item two, it will find the attribute  
39:51 - of pay rate in the instance level. So it does 
not really have to go ahead to the class level  
39:57 - and bring back the value of pay rate because 
Add first look, it is going to find it in the  
40:02 - instance level. But for item one, it is different, 
it is still going to read from the item level,  
40:08 - which is going to be 0.8. So now, if we were 
to try to use item two dot apply discount,  
40:16 - and as well as printing the price now, then let's 
see what will happen. So I will uncomment this  
40:24 - line to not see this screen for now. And I will 
go ahead and execute our program. Now you can see  
40:31 - that we still, however, receive 800. And what this 
means this means that the discount that has been  
40:38 - applied is still a 20%. And where this is coming 
from, well, this is coming from this method here  
40:46 - that no matter what we try to pull the pay rate 
from the class level. So a best practice here will  
40:53 - be to change these two cells. And that way, if 
we override the pay rate for the instance level,  
41:00 - then it is going to read from the instance level. 
But for item one, if we try to access the pay rate  
41:08 - from the instance level, then this is still great, 
because we did not assign a specific pay rate for  
41:14 - item one. So it is going to pull that from the 
class level. Now if we were to try to run that,  
41:20 - then you're gonna see now that we have expected 
results. And if we were to also uncomment,  
41:26 - the first print line for the item one and rerun 
our program, then you can see that for item one,  
41:33 - we had 20% discount. And for item two, we had 
30% discount. So when it comes to accessing  
41:40 - class attributes, you might want to reconsider 
how you want to access them when you will come  
41:45 - up with some methods. And specifically 
for creating a method like apply discount,  
41:50 - it is a great idea to access it from the instance 
level. So you also allow the option of using a pay  
41:56 - rate that is assigned to the instance level. 
Okay, so now that we understood completely  
42:02 - about the differences between a class to an 
instance attribute, let's jump ahead to the  
42:06 - next topic. Now you'll see that I have deleted 
those print lines that I have down below.  
42:11 - And I came up with five instances that I have 
created here. So you might also want to create  
42:16 - those five instances immediately. So that is why 
I will recommend you to go here to my repository,  
42:22 - accessing these class attributes directory, and 
then code snippets, and then go ahead and copy  
42:29 - the code from these five underscore items.py file. 
Okay, so considering a situation that your shop is  
42:35 - going to be larger in the future, meaning that you 
are going to have more items, then the more items  
42:40 - that you're going to have the more filtration 
like things that you want to do in the future.  
42:46 - But what is problematic currently with our class 
is the fact that we don't have any resource where  
42:51 - we can just access all the items that we have in 
our shop right now. Now, it could have been nicer  
42:56 - if we could somehow have a list with all the item 
instances that have been created until this point.  
43:03 - But currently, there is not an approach that 
will give us a list with five elements where each  
43:09 - element will represent an instance of a class. 
So in order to come up with such a design, then  
43:16 - here is a wonderful candidate for creating a class 
attribute that we could name all. And once we do  
43:23 - this, then we're going to see how we are going to 
add our instances to that list. So I will go ahead  
43:29 - and start by going here and use in all attributes. 
So it will be all equals to an empty list.  
43:40 - Now we need to figure out how we are going to add 
our instances for each time that we are going to  
43:47 - go ahead and create an instance. Now if you 
remember, the double underscore init method  
43:52 - is being called immediately once the instance 
has been graded. So it might be a wonderful idea  
44:00 - going down below inside this double underscore 
init method and use a code that will be  
44:06 - responsible to append to that list every time 
that we create an instance and that will be as  
44:11 - easy as saying something like the following. So 
first, you could pay attention that I actually  
44:17 - wrote some commands in this double underscore 
init function like run validations and assigned  
44:22 - to save object. So it might be a great idea to 
start with a comment here that will say actions  
44:29 - to execute just to really have a great separation 
between the different things that we are doing.  
44:34 - So now inside here I can say item dot all and 
you can see that I use the class object first  
44:41 - and then that is a list so I can use dot append 
and then I will just append the self object. Now  
44:49 - we know that self is actually the instance itself 
every time that it is being created. So once we  
44:56 - go ahead and launch such a command inside the 
unit Then for each instance, that is going to be  
45:03 - created, this all list is going to be filled with 
our instances. Now to show you that I can jump  
45:10 - line after we create the instances, and we can say 
print item that all. And now if I was to run our  
45:21 - program, then you're going to see that we're going 
to have a list with five instances. If I was to  
45:26 - scroll right a bit, then you can see that I have 
exactly five elements. And that is perfect. Now  
45:33 - that's going to be extremely useful if you want 
to do something with only one of the attributes  
45:38 - of your instances. So say that you'd like to 
print all the names for all of your instances,  
45:44 - then you can use easily a for loop to achieve such 
a task. So we can go ahead and say, for instance,  
45:51 - in item dot all and you can say print instance, 
dot name. And once we come up with this, then  
46:00 - you can see that we have all the names for all the 
instances that we have graded. So that is going to  
46:05 - be useful here and there, especially if you know 
how to use the filter function, for example, to  
46:10 - apply some special things on some of the instances 
that are matching your criteria. Alright, so now  
46:16 - that we understood this, then let's also take care 
of one problem that we saw previously. Now if I  
46:23 - was to use a Ctrl, D couple of times, and still 
use this print item dot all now you could see  
46:30 - that the way that the object is being represented 
is not too friendly. Now, it could have been nicer  
46:37 - if we could somehow change the way that the 
object is being represented in this list here.  
46:44 - Now, there is actually a way to achieve this by 
using a magic method inside our class. Now there  
46:51 - is a magic method that is called double underscore 
our EPR. And our EPR stands for representing your  
46:59 - objects. So that is why you can actually go 
ahead and use this magic method. And then  
47:05 - you will have the control to display your objects 
when you are printing them in the console. Now, I  
47:11 - actually recommend watching a video that compares 
between a metal that is similar to it, which is  
47:17 - called double underscore str. And you can take 
a look in the description of this entire series  
47:22 - to actually watch the video that I'm talking 
about. Alright, so let's go ahead and use the RPM  
47:28 - method to understand how this is going to work. 
So I'm going to say def inside our class. And  
47:34 - I'm going to use double underscore r e, PR double 
underscore and as expected, it will receive the  
47:41 - self. Now what we can do now is returning a string 
that will be responsible to represent this object.  
47:49 - Now obviously, we don't want to use something that 
is not unique for each of the instances. Because  
47:55 - say that I was to use now return items, something 
like that, and run our program, then you can see  
48:02 - that I'm going to receive a list with this string 
five times. But it is going to be hard to identify  
48:09 - which instance represents each string here. So 
it could be helpful if we were to return a string  
48:16 - that could be unique. So I'm going to close the 
console here and go ahead here and use a formatted  
48:23 - string. And in order to make this unique, it is 
a best practice to represent it exactly like we  
48:30 - create the instance like that. So what I'm 
going to do here is living the item and use a  
48:38 - brackets opener and the closure. And then I'm 
going to make the return string here as much  
48:44 - as equal as possible to the way that we create 
those instances. So I will start by typing here  
48:53 - single quotes to escape from the double quotes 
that are coming from here. And I'm going to refer  
48:59 - to the value of name by using self dot name. And 
then I will leave my single quotes. And I will  
49:07 - use a comma like that. And then I will go ahead 
and refer to the value of our price. I will use  
49:16 - one more comma, and I will say self dot quantity. 
Now if we were to execute our program again, then  
49:25 - you can see that now we receive a list that is way 
more friendly than what we have seen previously.  
49:32 - And you can also see that this first element, for 
example, is quite equivalent to this line here.  
49:40 - Now you might be curious why I worked so hard to 
return the representative version of our objects  
49:48 - the same way that we create them. So that is 
just the best practice according to pythons  
49:52 - documentations because it will help us to create 
instances immediately by only the effort of  
49:58 - copying and pasting these To the Python console. 
So if you think about it right now, if you open a  
50:04 - Python console, and you'll import this class, then 
it will be as easy as grabbing this and pasting to  
50:12 - the Python console. And then you will have an 
instance being graded. So that is the single  
50:17 - reason that I have came up with this approach. And 
also for sure, I just wanted to return a unique  
50:22 - string that will really represent our instance. 
And you can see that it is very easy to identify  
50:29 - the instances of our class with this list. And 
with this approach, alright, so until this point,  
50:36 - we understood how we can change the way that we 
represent our objects. And we also understood  
50:41 - how we can access to all of our instances by this 
class attribute that we intentionally named all.  
50:49 - Now in this part, we are going to take a look to 
solve one more problem that we have in terms of  
50:55 - best practices when we are going to extend this 
application and add more features. Now you can  
51:00 - see that until this point, we maintain our data as 
code in this main.py file by only instantiating.  
51:09 - Those five items. Now when we will look to extend 
this application and add some more futures,  
51:14 - then we might have a harder life to add those 
features because the actual data and the code  
51:21 - are maintained in the same location, meaning 
in the same main.py file. Now you could think  
51:27 - about creating a database that will maintain this 
information. But I want to keep things more simple  
51:33 - for the purposes of this tutorial. And that is 
why I'm going to use something that is called CSV  
51:38 - that you might have heard of. csv stands for comma 
separated values. So this means that you could go  
51:45 - ahead and use a CSV file, and you could store your 
values as comma separated where each line will  
51:53 - represent a single structured data in CSV is 
a great option here because it allows the data  
52:00 - to be saved in a table structured format. 
Alright, so let's go ahead and create a CSV  
52:06 - file. And I will actually go ahead and name 
these items, dot c is V, like that, and I will  
52:13 - go ahead and paste in some CSV content that will 
be responsible at the end of the day represent the  
52:20 - same data that we look to have here. So you can 
see that at the first line, I have name, price  
52:26 - and quantity. And you can see that those are comma 
separated. So those represents the columns that  
52:32 - we're going to have as the data that we are going 
to maintain. And in the second line and further,  
52:38 - we are going to have some data that will represent 
the actual data that we look to maintain. So if we  
52:44 - were to now split the panes, then you can see that 
those are quite equivalent. And now we should only  
52:52 - look for a way to read the CSV file and actually 
instantiate those objects. Now we can see that I  
52:59 - have a suggestion by pi charm to install a plugin 
that will support CSV files. So I'm going to just  
53:06 - click on that and install those plugins. And you 
can see that I will have a CSV reader here. And  
53:13 - we will see if we will be able to see this data 
in a table, which will be a lot nicer. So let's  
53:19 - go ahead and install this. And now you can see 
that I have some more options that I can actually  
53:24 - go ahead and use from here, I know that this is 
quite small, but actually you have some tabs that  
53:31 - you can go ahead and click on them. And if I was 
to click on table editor, and actually give this  
53:39 - file more focus, then you can see that I actually 
have the best way to read this data. Now,  
53:45 - you can see that I have my columns, you can see 
that I have my rows. And that is quite nice. Now  
53:53 - I can really go ahead and visualize my data more 
nicer. And it's just more common way to maintain  
54:00 - your data. Okay, so now that we understood how CSV 
files are working, let's go ahead and read our CSV  
54:07 - files and instantiate the instances in a generic 
way. So it makes sense to delete those five lines.  
54:14 - And I'm going to use those lines below 
the apply discount and use a metal that  
54:20 - I could name instantiate from CSV like that. Now, 
you can see that this one is also going to receive  
54:29 - itself because if you remember I said 
that in each metal that we will design,  
54:34 - we need to receive at least one parameter that 
will be passed as the instance itself, because  
54:42 - this is how Python op works. Now, the problem is, 
we are not going to have any instances on our hand  
54:50 - to call this method from the instance because 
this method is actually designed for instantiating  
54:56 - the object itself. So this means that this 
method could not be called from an instance.  
55:02 - So the way that this is going to be solved is by 
converting this method into a class method. Now, a  
55:10 - class method is a method that could be accessed in 
the following way. So I will use this line tool,  
55:18 - delete that, and it could be accessed from the 
class level only. So this will look like item dot  
55:26 - instantiate from CSV, and then in here, we will 
probably pass our CSV file. So this method should  
55:34 - take full responsibility to instantiate those 
objects for us. So now that we understood this,  
55:40 - let's go ahead and see how we can create a class 
method. So for sure, we need to delete the self.  
55:46 - And I know that we have arrows, but we are going 
to solve each one of those just in a second. Now  
55:52 - in order to convert this to a class method, we 
need to use a decorator that will be responsible  
55:58 - to convert this method into a class method. Now 
decorators in Python is just a quick way to change  
56:05 - the behavior of the functions that we will write 
by basically calling them just before the line  
56:11 - that we create our function. So we could use the 
Add sign and use the class method in here and then  
56:19 - this instantiate from CSV method will be a class 
method. Alright, so now that we understood this,  
56:25 - then we should also understand one more piece of 
information before we go ahead and design this  
56:31 - method. Now I want to show you what will happen 
if I was to delete the entire name and try to  
56:37 - recreate this function here. And I will just say 
instantiate from CSV again, Now pay attention  
56:44 - what will happen if I was to open up and close the 
parentheses, now we can see that it still receives  
56:50 - a parameter, but this time, it is named CLS. Now, 
what is going on here, and the thing that is going  
56:58 - on here is the fact that when we call our class 
methods, then the class object itself is passed  
57:06 - as the first argument always in the background. 
So it is a bit alike the instance where it is also  
57:12 - passed as the first argument. But this time, 
when we call a class method in this approach,  
57:18 - then the class reference must be passed as a 
first argument. So that is why you should still  
57:25 - receive at least one parameter, but we probably 
understand that we could not name this self,  
57:31 - because that is just going to be too much 
confusing. Okay, so now let's go ahead and write  
57:36 - some code to read the CSV file and instantiate 
some objects. Now, I'm going to go up top first,  
57:42 - and I'm going to import a library that is called 
CSV. So I will go here and I will use an import  
57:50 - CSV line, because that will be the library that 
will take full responsibility to read the CSV  
57:56 - file. And then we will see how we can instantiate 
some objects. All right, so now I can go ahead and  
58:02 - use a context manager to read the items dot CSV 
file. Now both of those files are located in the  
58:09 - same location. So I can just directly say, Wait, 
open items dot CSV, and the permission that I  
58:17 - will be passing here could be hour because we only 
look to read this. And I will say as f like that.  
58:24 - Now inside this open, I will go ahead and use some 
metadata to directly read the CSV, which at the  
58:32 - end of the day will be responsible to convert this 
into a Python dictionary. So I will say reader  
58:39 - is equal to CSV, dot d ICT reader like that. And 
I will pass in the content of our file like that.  
58:50 - Now, this method should go ahead and read our 
content as a list of dictionaries. But at the end  
58:57 - of the day, we should also go ahead and convert 
this into a list. So I will go ahead and create  
59:01 - one more variable that will be equal to items. 
And I will just convert the reader into a list.  
59:07 - And that's it. And now that we have completed 
the actions that we want to complete by reading  
59:12 - the CSV file, let's go ahead and use a Shift 
Tab to indent out. And now before we go ahead  
59:20 - and instantiate some objects, let's go ahead and 
see the results of iterating over the items list.  
59:26 - Now I will go ahead and use for item in items. 
And then I will just use print items to show you  
59:34 - the behavior of that. And excuse me, it should be 
item. All right, so now that we understood this,  
59:40 - then let's go ahead and see what we have in those 
lines. So after our class definition, we only go  
59:45 - ahead and call this item dot instantiate 
from CSV method. So if I was to run that,  
59:51 - then you can see that I received some dictionaries 
in separate lines. And that is because I iterate  
59:57 - over a list of dictionaries in Here, and that is 
just perfect. All right, so the only thing that we  
60:03 - miss right now is creating instances. Now besides 
printing those, then we could now say something  
60:10 - like item and open up and close parentheses. And 
this will be enough to instantiate our instances.  
60:17 - Now I can go ahead and pass my arguments in here 
by basically reading the keys from a dictionary.  
60:25 - So I can say name is equal to item dot get, and 
that will receive name. And now I can add a comma  
60:35 - and duplicate this line twice, and change 
those accordingly. So this will be price.  
60:42 - And this will be quantity. And now I need to 
replace my key names. So it will be price here,  
60:49 - and then quantity right there. And now let's go 
ahead and see what will happen if I was to call  
60:56 - this method. And as well as calling the attribute 
of item dot all because this one stores all the  
61:04 - instances inside the list. Now if I was to go 
ahead and run it, then you can see that I have  
61:10 - some arrows. Now you'll see that the arrows are 
related to the price. And you can see that we  
61:19 - receive is not greater than or equal to zero. 
Now let's go ahead and fix this very quickly.  
61:25 - So in the items dot CSV, you can see that those 
are actually integers that are greater than  
61:31 - zero. So the problem is probably the fact 
that those are passed as strings. So we  
61:37 - need to go ahead and pass those as integers. So 
I'm going to convert those into int, like that.  
61:46 - And now let's go ahead and see if we will have any 
problems as I expect to have any problem, because  
61:52 - the quantity should complain about the same thing. 
And you can see that this is exactly what is going  
61:57 - on here. So we can use the same for quantity like 
that, and work with that. And you can see that now  
62:08 - we see our instances perfectly. Now I want to show 
one more problem that we could have in the future  
62:13 - and we should avoid now. So those three lines 
are going to work with this structural of Aveda.  
62:21 - But if I was to change the price of our keyboard 
to something like 74 dot 90, something like that,  
62:30 - and re execute our file, then you can see that we 
will receive some problems. So we need to convert  
62:37 - the price not to an integer but to a float like 
that. And that is the only way to get over this  
62:44 - because we don't want to convert the price 
to an industrial directly because it could be  
62:48 - float. So now we could go ahead and execute 
and you can see that now it works perfectly,  
62:55 - although we see the prices as 100.0 but that is 
something that we will look into it in the future  
63:03 - but for now it works perfect. And now we are ready 
to jump on to our next topic. Okay, so now that we  
63:09 - completely understood the class methods, let's go 
ahead and also understand what static methods are  
63:15 - now established metal show do some work for you, 
that has some logical connection to a class. So  
63:21 - for example, if you want to check if a number 
is an integer or a float, then this is a good  
63:27 - candidate for creating a static method, because 
this has some connection to the class that we  
63:33 - work with. So it makes sense to check if a price 
of an item has a decimal point and by saying has  
63:41 - a decimal point, I obviously count out those that 
are point zero. Now to be honest, static in class  
63:49 - methods could look very alike to you. But we 
will explain the main differences very soon.  
63:54 - Okay, so I will use those lines to create our 
first static method. Now let's go ahead and  
64:01 - use the def keyword. And we will name this method 
is underscore integer because we said that we'd  
64:07 - like to write a static method that will check 
if a received number is an integer or not. Now  
64:12 - if I was to open up and close parentheses, this 
would obviously receive itself now I want you  
64:17 - to take a closer look what will happen if I was 
to change this method into being a static method  
64:23 - and the approach is going to be pretty much the 
same like we have done with the class method, we  
64:27 - will use a decorator that is called static method 
and this will be responsible to the conversion. So  
64:33 - I will go ahead and use this line and I will say 
add static method like that. Now pay attention  
64:42 - how the received parameter turned into the 
regular orange color that we are familiar  
64:48 - because that is just a regular parameter that we 
receive. Now this means that this static methods  
64:55 - are never sending in the background, the 
instance as As a first argument and that is  
65:02 - unlike the class methods, the class methods are 
sending the class reference as a first argument.  
65:10 - And that is why we had to receive the CLS. And 
that is why it is intentionally colored with  
65:16 - purple. But with static methods, we never send 
the object as the first argument. So that is why  
65:24 - we should relate to the static method, like a 
regular function that just receives parameters  
65:31 - like we are familiar with isolated functions. Now 
I will go deeper on this just in a few minutes.  
65:36 - But let's go ahead and finish up our static 
method first. So this should receive num as a one  
65:42 - parameter because we should receive at least 
something to check if it is an integer or not.  
65:47 - All right, so now that we are inside this method, 
then I can go ahead and use a couple of statements  
65:53 - to check if the received argument is an integer 
or mark. Now if you remember, we said that we'd  
65:58 - like to, we will count out the floats that are 
decimal that are point zero, okay? Meaning,  
66:10 - for example, 5.0 10.0, and so on. Alright, so 
now that we understood this, let's go ahead  
66:18 - and use an if statement view. So if in we will 
call the built in function that is called is  
66:24 - instance. And this should receive two arguments. 
And we can understand what this function is going  
66:30 - to do for us, it is going to check if the received 
parameter is an instance of a float or an integer.  
66:38 - So we will pass in as the first argument the num 
and as the second argument, the float without  
66:45 - calling those parentheses, so only the reference 
to the float keyword. So this conditional  
66:52 - should go ahead and check if the num is a folding 
number or not. Now inside this if statement,  
66:59 - I will say return num.is integer, so by 
saying.is integer, then I basically say  
67:08 - count out the floats that are decimal that 
are point zero. So this means that if I was to  
67:17 - pass in here a number like 10.0, then this will 
return false, but remember that this will enter  
67:24 - here because he thinks it is a flaw because it is 
represented in that way. And so the East amisco  
67:30 - interview should check if the point is zero, and 
true return false accordingly. Now, I will also  
67:36 - use an else if statement here to basically check 
if it is integer by itself. So I will say l E is  
67:45 - instance num, and check if it is an instance of 
an integer, then I will just return true. And  
67:53 - if it is just something else, then I will just 
say return false like that. So now that we have  
68:00 - designed this method, then let's take a look how 
we can call it. So now I will just remove this  
68:07 - and this, I'm not actually going to instantiate 
anything, I'm just going to show you how you can  
68:12 - access to the static method. So I will just call 
this item.is interview and I will just pass in  
68:20 - a number that I will like to check if it is an 
interview or not. Now for sure, we'd like to print  
68:26 - this. So we will see the result. Now let's go 
ahead and pass in seven. So, you can see that we  
68:31 - receive through now if I was to pass in 7.5 then 
I would receive false and what is happening in the  
68:38 - background it is the fact that it enters here, but 
it sees that it is not an integer so it returns  
68:46 - false. But if I was to change this to 7.0 
then this show Sorry about that, this should  
68:53 - still return true because what is happening 
it is entering inside this conditional and  
68:59 - then it checks if it is an integer, but we said 
that this method counts out the floats that are  
69:05 - point zero. So it returns true still so that is a 
perfect design Alright. So I have came up with a  
69:12 - new file, which I will just explain here when 
to use a class method and when to use a static  
69:17 - method. So we can completely understand the 
differences between those because I remember  
69:21 - myself I had a very tough time to understand why 
I need this and why I need the other one. So that  
69:28 - will be the main question that I will be answering 
in this Python file. So don't feel like you have  
69:32 - to copy and paste the code following along what I 
am explaining here by listening should be enough  
69:38 - Alright. So in this file, I will just go 
ahead and create this class item that we have  
69:45 - right and i will use pass to not receive 
arrows. Now when we will use a static method.  
69:51 - So we will use a static method when we want to do 
something that should not be unique per instance.  
69:58 - Exactly like we have I have done previously. So 
his interview is a method that is just going to  
70:04 - be responsible to check if a number is integer 
or not. So that is why I could allow myself to  
70:10 - include this under the item, just like I could use 
this def as an isolated function right above the  
70:17 - class. And that was also okay. But I prefer 
to not do that, because although this is a  
70:24 - metal that has nothing to do with instance, 
that is somehow related to the item class.  
70:30 - So that is the reason you want to create this as 
a static method, like we have designed previously.  
70:37 - And the reason that you would like to create 
a class method is for instantiating instances  
70:44 - from some structured data that you own. So 
exactly like we have done, we have created  
70:50 - a class metal that was responsible to read the 
CSV file and creating some instances. So as I  
70:58 - wrote here, those are used to manipulate different 
structures of data to instantiate objects, like we  
71:05 - have done with the CSV file, we could also use a 
class method like instantiate from a JSON file,  
71:12 - or from a yamo file, those just are different ways 
to maintain data in the best practice way in that  
71:20 - is the code that you will look to include inside 
your class methods. That is why they should be  
71:26 - existing in any class, especially if you 
look to instantiate hundreds of objects  
71:31 - on your programs. So it is a great idea to have at 
least one class method, like we have done in the  
71:38 - item class. Now the only main difference between 
a class method and to a static method is the fact  
71:47 - that static methods are not passing the object 
reference as the first argument in the background,  
71:53 - it is noticeable from the fact that we don't 
have a special highlight purple, in my case  
71:59 - for the first parameter. So if you remember, if I 
was to go ahead and use here a first fundamental  
72:05 - like num, then you will see that this is the 
first parameter that is colored with orange,  
72:10 - because that is a regular parameter. But that is 
purple, because this is a mandatory parameter that  
72:16 - we should receive, because what I have just 
explained, so those are the main differences  
72:22 - between a static method to a class metal. Now 
if you remember, I intentionally said that the  
72:28 - class methods and the static methods could only 
be called from the class level. But however,  
72:34 - those also could be called from instances. So as 
you can see, I can actually instantiate an object  
72:40 - and call the integer in as well as the instantiate 
from something can just pass in here in number  
72:46 - like five and I will not receive any arrows. 
And if I was to run the helper, then you can  
72:50 - see that I don't have an error. Now, I'm going 
to be honest with you, I never saw a reason to  
72:56 - call a static method, or a class method from the 
instance level. But that is just an option that  
73:02 - exists, I know that it is very, very confusing. 
But that is something you are rarely going to  
73:07 - see. And like I said, I never saw a great reason 
to call a static method or to call a class method  
73:14 - from an instance. So my recommendation 
to not confuse you is just not going with  
73:19 - calling those from the instance level. All right, 
so I minimize the code that we wrote so far  
73:24 - in the class item. Now in order to start solving 
the problems that we will solve in this episode,  
73:30 - then I'm going to create here two instances. 
So I will say form one is equal to an item.  
73:36 - And let's give it a name like JC phone v 10. 
And then just use a random price and quantity.  
73:44 - And I will copy and paste this and use another 
variable like phone two in there, we'll increase  
73:50 - the version by 10. And let's say that this price 
for the phone two should be 700. All right, so  
73:56 - now that we have created two instances of a phone, 
pay attention that those two items are phones. So  
74:03 - we could think about some attributes that could 
represent phones in real life. Think about an  
74:09 - attribute like broken phones, because we could 
have some phones that could have been broken.  
74:14 - And so we cannot really mark it as a phone that we 
could really sell. So this means that we could go  
74:20 - ahead and say phone one that broken phones, let's 
say that we have unfortunately one broken phone  
74:27 - on our hand right now. So I will go ahead and 
assign the same attribute for our second phone.  
74:32 - And now that we have came up with this realistic 
attribute, then the next step that we might think  
74:37 - about, could be creating a method that will go 
ahead and calculate the phones that are actually  
74:42 - not broken, meaning subtracting the quantity by 
the broken phones amount because this is totally  
74:48 - making sense. And then we can understand what are 
the phones that we could go actually and sell them  
74:54 - in the future. But we have couple of problems 
creating a method that will go ahead and calculate  
75:00 - Such a thing because we cannot we'll go ahead 
inside our item. And do this smooth enough,  
75:05 - because we don't really have the broken phones 
attribute assigned to self. And we cannot actually  
75:12 - go ahead and create this method inside this 
item class, because this method is not going  
75:17 - to be useful for other hundreds of items that you 
will go ahead and create. These just represent a  
75:23 - phone kind of item. So in order to solve this 
problem in terms of best practices in object  
75:29 - oriented programming, then we could go ahead and 
create a separate class that will inherit the  
75:34 - functionalities that the item class brings with 
it. And that is exactly where we could benefit  
75:40 - from inheritance. And we could go ahead and create 
a separate class that we call name phone. And then  
75:46 - this phone class will inherit all the methods in 
all the attributes that item class has. So let's  
75:54 - go ahead and simulate that. So I'm not going 
to delete the instances yet, but I'm going to  
75:59 - go ahead here and create a class that I will name 
it phone. Now pay attention that I will not use a  
76:06 - semicolon and I will use those brackets and I will 
specify what class I would like to inherit from.  
76:14 - So I will inherit from item. And then I will just 
use a pass temporarily because I will not like  
76:20 - to use additional functionality right now inside 
this class. Okay, so now that we have created this  
76:25 - class, then let's go ahead and first execute our 
program, where at the first stage, the instances  
76:32 - will be item instances. And this should not have 
any problems because we know that we can create  
76:38 - those item instances and we will not receive 
any arrows. But if we were to change those to  
76:44 - phone like that, then we should still 
not receive any arrows. And that's just  
76:51 - a basic way that you could use inheritance in 
order to represent different kinds of objects  
76:58 - when you want to do that. Now, this could also 
be applied to other real estate programs that you  
77:02 - want to come up with them and buy your own. But 
in my case, it totally makes sense to create some  
77:08 - classes where each class will represent a kind 
of an item. And then I could go ahead and inherit  
77:14 - from the item class in each of the child classes 
that I will go ahead and create in the future,  
77:20 - I could also use another class for a kind of item 
like laptop, and then I could go ahead and use the  
77:26 - separated functionality for that. Now when we talk 
about classes that we inherit from, then those are  
77:32 - considered to be called parent classes. And when 
we use multiple classes that inherits from that  
77:39 - parent class, then those are considered to be 
called child classes. So those are just terms  
77:45 - that you want to be familiar with when we talk 
about object oriented programming. And from here,  
77:50 - we will see more advanced things that you can go 
ahead and do with your child classes. Alright,  
77:56 - so now let's go ahead and understand some more 
advanced things about inheritance. Now to help  
78:01 - this series, we learned that it is not a great 
idea to assign attributes manually, once we create  
78:07 - those instances. And the better way to do that is 
actually going ahead and creating our constructor  
78:13 - and pass the value that we'd like to immediately 
in the instance creation exactly like here.  
78:20 - So in order to solve this, then we're going to 
need to figure out how we are going to do that,  
78:25 - because creating the constructor inside 
this phone class is going to will be tricky,  
78:30 - because we don't really want to break the logic 
that the development score in it brings with the  
78:35 - parent class. But we'd also like to pass in an 
additional attribute like broken phones, that  
78:41 - we will go ahead and deal with that attribute and 
assign it to the self object exactly like we have  
78:48 - done in the second part of our series. So in order 
to keep the logic the same for this child class,  
78:55 - and as well as received some more attributes. Then 
for now, I am going to go ahead and copy the code  
79:03 - in our constructor and just paste this in right 
inside our phone class. And that's making sense  
79:11 - temporarily, because we received the exact 
same parameters that we should receive when  
79:18 - we instantiate an instance. And we also have 
now the control to receive some more parameters,  
79:25 - like we want to do with the broken phones. 
So let's go ahead here and say broken.  
79:33 - So I will just scroll here, and I will say broken 
phones is equal to zero. Let's also receive a  
79:39 - default value for that. And let's go ahead and 
type in a validation for the broken phones. So  
79:46 - I will allow myself to just copy that and paste 
this in. And we'll use assert quantity I mean  
79:52 - broken phones is greater than or equal to zero 
and I will change this to broken phone Like that,  
80:02 - actually broken phones, and this should be 
exactly like we have done with the quantity.  
80:08 - And now let's go ahead to the section of assigned 
to self object. And we can use self dot broken  
80:15 - phones is equal to broken phones like that. 
And you can see that here we have actions to  
80:22 - execute. Now it could have been nicer if we 
could also create a class attribute for the  
80:28 - phone class. And that will mean that we could go 
ahead here and say all is equal to an empty list,  
80:35 - then we could go ahead and use a form dot all 
dot append, like that. And now if I was to go  
80:44 - ahead and run this program, then you can see that 
I will not receive any arrows. Now to check that  
80:51 - this works, then I'm also going to pass in 
here one. And I'm going to do the same here  
80:57 - as well. And I'm going to remove those. All right, 
I'm going to remove the hardcoded attributes,  
81:03 - and the program still works. Now I'd also like 
to test this by applying one of the methods that  
81:08 - we have wrote so far in that will be obviously a 
method that I like to use from the parent class,  
81:13 - because we inherit those methods. So 
I can go ahead and use phone one dot,  
81:20 - calculate total price, and it makes sense to 
print this. So I will go ahead and print that.  
81:26 - And you can see that print phone one dot calculate 
total price. And now if I was to run that,  
81:32 - then you can see that I received a result. 
So this means that I don't have any arrows.  
81:37 - Now I'm not sure if you pay attention to 
this. But if I was to scroll up a bit,  
81:42 - then you're gonna see that the constructor in the 
child class is complaining about something. And  
81:48 - let's Hover the mouse and see what is the warning. 
Now you can see that it says to us call to double  
81:53 - underscore in it of super class is missed. And 
what that means, it means that when we initialize  
82:01 - the double underscore init method inside the child 
class, then Python expects for some function to be  
82:06 - called intentionally. Now this function is named 
super. And what super allows us to do, it allows  
82:13 - us to have full access to all the attributes of 
the parent class. And by using the super function,  
82:19 - we don't really need to hard code in the attribute 
assignment, like we have done with the name,  
82:24 - price and quantity. And as well as for the other 
validations that we have executed every time  
82:30 - that we want to come up with a child class. 
Now imagine how hard that is going to be. If  
82:36 - for each of the child classes that we will create 
in the future, we will have to go through copying  
82:42 - and pasting assert price and quantity. And as 
well as doing the assigned to self object thing in  
82:49 - those three lines. That is going to be a lot of 
duplication of code. Now to save us that time,  
82:56 - that is exactly why we needed to use the super 
function, the super function will allow us to have  
83:01 - the attributes access from the parent classes. 
And therefore, we will be able to fully implement  
83:08 - the best practices in inheritance when it comes to 
object oriented programs. Now again, this program  
83:15 - works because we assign the attributes of name, 
price and quantity for the sales object in the  
83:22 - trial class. But if I was to remove those three 
lines, and as well as those two lines, now those  
83:30 - lines are happen to be the lines that I have 
copied and pasted and try to run this program,  
83:36 - then you can see that we receive attribute 
error phone object has no attribute price,  
83:41 - and pay attention from what line it comes from. 
It comes from line 21 from the item class,  
83:47 - because it thinks that it has the attribute of 
price. But we never have the price attribute in  
83:53 - the phone level. Because we just deleted the 
self dot price is equal to price. And that's  
83:58 - why now we have some problems. And we are going 
to replace all the lines that we have deleted  
84:04 - with the following thing that I'm going to just 
execute now. So I'm going to go to the first line  
84:10 - of our constructor, and I'm going to say call to 
Super function to have access to all attributes  
84:23 - slash methods. And then I'm going to say super, 
net I'm going to open up and close parentheses.  
84:29 - And then I'm going to use the double underscore 
init method like that. Now you can see that the  
84:35 - second that I have completed this, then there 
are no more warnings about the constructor in  
84:39 - this child class. And you can also see that these 
double underscore init method expects for some  
84:45 - special arguments. Now those special arguments 
obviously coming from the item class that we  
84:50 - inherit from. So if I was to pass in here, name 
and also price and also quantity Then this should  
85:01 - be fine. Now, you can also ask yourself isn't 
the duplication of code, the fact that we also  
85:07 - copied and pasted the parameters that we receive 
in the child class. And yeah, that is a perfect  
85:13 - question. That is something that could be solved 
by something more advanced. If you heard about  
85:18 - keyword arguments, that is something that we can 
solve it with that way. And then we will not have  
85:24 - to duplicate the parameters that will receive for 
the constructor, that is not something that I'm  
85:28 - going to show for that stage, I'm going to stick 
with it. And I'm just going to leave it as it is  
85:34 - now calling the super function. And as well 
as the init method right after it should be  
85:40 - responsible to have the same behavior like we 
had previously. So we should still see 2500  
85:48 - for this print line, and we should not see 
any arrows. And if I was to run the program,  
85:53 - then you can see that we receive the expected 
result. So that way, we implement the best  
85:58 - practices of object oriented programming for each 
child class that we use a separated constructor,  
86:04 - we also are going to need to call the super 
function in order to have fully access for all the  
86:11 - attributes and methods that are coming from 
the class that we inherit from. Alright,  
86:16 - so I minimize the code for our classes. And I 
also left with one instance of foam here. Now  
86:23 - I want to show you the results of the following 
things. So I will say print, and I will see what  
86:29 - is the list of all in the item class is going to 
bring us back. So I'm going to say item dot all.  
86:35 - And then I'm also going to say phone that all if 
you remember, we implemented this class attribute  
86:41 - as well here. So I will minimize the code back. 
And then I will run our program. Now you can see  
86:47 - something very weird in here we see item. And then 
we basically see the result of the array PR method  
86:54 - that comes from the item class. Now the reason 
that this happens, because we never implemented  
86:59 - in our EPR method inside the form class. So that's 
why we see this on generic result of item. Now you  
87:07 - can also pay attention that we only create an 
instance of the phone class. So that's not so  
87:13 - good that we see item in those outputs. So what 
we call use, instead of hard coding in the name  
87:20 - of the class in the rppr method inside the item 
class, then we go to access to the name of the  
87:26 - class generically. Now if I was to replace this 
with some special magic attribute that will be  
87:33 - responsible to give me the name of the class, then 
this will be perfect. So I'm going to delete that.  
87:38 - And I'm going to use curly brackets, and I'm 
going to say self, dot double underscore class,  
87:46 - dot double underscore name. So that is a 
generic way to access to the name of the class  
87:52 - from the instance. And by doing this, then besides 
receiving item, hard coded string, then I should  
87:59 - receive the name of the class that I initialize 
from the very beginning. So this should be  
88:05 - phone, because that is the only single instance 
that I have right now. And you can see that this  
88:09 - is exactly the result that I'm receiving back. 
So that is perfect. Now I said earlier that by  
88:15 - using the super function, then we basically have 
access to all the attributes and the methods that  
88:21 - are coming from the class that we inherit from. So 
what that means, it means that we will also have  
88:27 - the access to the class attribute of all that is 
inside the item class. And I'm talking about that  
88:34 - attribute, right. Now to show you that, then I'm 
going to open back the code from the form class.  
88:41 - And I'm going to remove the old attribute. 
And I'm just going to do that right now. And  
88:47 - I'm also going to delete the actions to execute 
where I use form dot all dot append, because we  
88:53 - no longer having the old attribute in the 
form class. And if I was to remove those,  
88:59 - and execute our program now, then you can see 
that I still receive the same result. So that  
89:05 - is a great idea removing the old attribute in the 
child class level, it is a great idea to only use  
89:13 - the old attribute in the parent class, because 
by using the super function in the child class,  
89:18 - we will have access to the old attribute. So 
this means that if one day we'd like to have  
89:23 - access to all the items instances that have 
been initialized, including the child classes,  
89:30 - then accessing them from item dot all should also 
be enough. Now you might be confused how this line  
89:36 - is responsible to add this instance inside the 
all attribute that is happened to be a list.  
89:42 - And that's happening because by using the super 
function and as well as the in it, then we  
89:49 - basically call the init method inside the parent 
class. Now in the latest line inside this method,  
89:55 - we also use item dot all dot append, which is 
also going to be accessible From the form class,  
90:01 - so that's why calling the all class attribute 
from the item class is a better idea, because  
90:08 - it will give us the complete picture. Okay, so 
before diving into the topic of that episode,  
90:14 - then we're going to need to do some code 
organization in here, because as you can see,  
90:19 - for each of the child classes that we will go 
ahead and create in the future to extend this  
90:23 - project, then we're going to need to do this in 
the main.py file, because that was the only single  
90:28 - file that we were working with. And now that 
our project grows, we need to start working with  
90:34 - multiple files. So that's why it may be working 
with a file that will represent the class of item  
90:39 - and working with a separate file that will 
represent the foreign child class will be a better  
90:44 - idea. So we will have the main.py file dedicated 
for only creating instances of those classes. So  
90:52 - let's get started with this. So I'm going to go to 
the project directory and create two Python files.  
90:58 - First one, we will name the item.pi. 
The other one should be named phone.pi.  
91:05 - And I'm going to take the code from our item 
class. And I'm just going to grab everything. Why,  
91:13 - while the following, and I'm going to cut this and 
then I'm going to paste this in inside of that.  
91:20 - Now pay attention that I use the CSV library. 
So that's actually the location that I need this  
91:26 - library. So I'm going to just copy the import 
line. And that should be good enough. Now I'm  
91:32 - going to do the same process for the form dot p y, 
I'm going to be copying this into the form.py file  
91:40 - as well. But now this file needs to import the 
item class because as you can see, we got an arrow  
91:46 - here. So we should say from item, import items 
like the following in the arrows should be gone.  
91:54 - And then in the main.py file, we can basically 
use this file to only instantiate instances,  
92:00 - meaning creating data that will represent 
something to Python. So this means that  
92:05 - we can go ahead and import the class from 
the item file, we can do the same from the  
92:12 - form file. And then we can go ahead and do the 
stuff that we use to do so we can say item dot  
92:18 - instantiate from CSV. into verify that this works, 
we can also say print, and item dot all like that.  
92:28 - And if we want to run this file now to see that 
this works, then we can do that. And you can see  
92:32 - that everything works just as expected. Now just a 
quick side note, I'm not going to rely too much on  
92:38 - the child class that we have created in the latest 
episode, to show the problems that we're going to  
92:43 - solve in that episode, I'm going to rely more 
on the item class so that it will be easier to  
92:49 - follow. And we will not complex things too much. 
Now that doesn't mean that I do not recommend  
92:55 - using child classes or something like that. But it 
will be just easier to show you the cases that I'm  
93:00 - going to show in the parent class. So that's 
why For example, I deleted temporarily the  
93:06 - input line of the form class. And I just came up 
with a random item instance that name is my item  
93:13 - in the price happened to be that number I did not 
specify quantity because we have a default value.  
93:18 - And now after this line, you can see that 
I override this attribute by the string of  
93:24 - other items. Now the expected result is not 
going to surprise anyone because we see at the  
93:29 - right time when we print this attribute. But we 
might want to ask ourselves is that the behavior  
93:35 - that we always want? What if we want to restrict 
our users to change the attribute of name, once  
93:42 - the name has been set up in the initialization, 
meaning in that line? Well, that's something that  
93:47 - we might want to achieve for critical attributes 
like the name of your instances, and in our case,  
93:55 - the name of our item. So what we could do, we 
could actually go ahead and create read only so  
94:01 - called attributes, meaning that we have only one 
opportunity to set the name of our item. And then  
94:08 - we cannot touch the value of that anymore. So what 
that means it means that we can set up this in the  
94:14 - initialization. And we should have arrows if we 
try to override the value of that. Now that's  
94:20 - also known as encapsulation when we talk about 
the principles of object oriented programming,  
94:27 - which I will be focusing more on the future 
episodes. But now let's go ahead and see how  
94:32 - we can come up with read only attributes how we 
can restrict our users to override the attributes  
94:39 - after the initialization of our instances. Okay, 
so on the left side we have the main.py file, and  
94:45 - on the right side we have the item.py file which 
we are going to work on and inside the class I'm  
94:51 - going to create our first read only attribute. Now 
the way that you can start doing this is by first  
94:57 - using a decorator and if you remember from 
the previous episodes decorators are like  
95:02 - functions that you can pre execute before another 
function. So I could go ahead and use the property  
95:08 - decorator, and then go ahead and create a 
function. And here is the exact location that I  
95:15 - could set up the name of our read only attribute. 
So for testing reasons, let's go ahead and call  
95:22 - this read only name something in that time, 
all right, and then I will open up and close  
95:28 - parentheses, and this will obviously receive self 
because it's going to be belong to each of the  
95:33 - instances. And now for testing purposes, let's 
only go ahead and return a random string like  
95:39 - a three times. Alright, and then now that we have 
done this, I can go to our main dot php file and  
95:46 - try to access this property. Now pay attention 
that I'm going to call those properties and not  
95:53 - attributes. So I'm going to go here, and I'm going 
to try to print item one, that name and now that I  
96:01 - have wrote name, pay attention to the differences 
in this drop down for read only name, we receive  
96:08 - a totally different icon here on the left side, 
which stands for a property where in here we see  
96:14 - the flutter which stands for irregular field. So 
if I was to try to print that and run our program,  
96:21 - then obviously we will receive the expected 
result. But if I was to try to set a new value,  
96:27 - for the read only name, say that we want 
to change this to something like that,  
96:32 - then you're going to see that Python is going to 
complain about this. And even if we try to execute  
96:37 - that, then we will end up with an exception that 
says attribute error can set attribute. So that is  
96:44 - how read only attributes, so called are working in 
Python, you can create those by using a property  
96:51 - decorator before your functions and return 
whatever value you'd like to return. Now the  
96:57 - biggest challenge here is going to be converting 
the name attribute that we actually have,  
97:03 - which is happened to be exactly here into obeying 
a read only attribute. And that is going to be a  
97:10 - little bit challenging. But let's go ahead and 
start working on that. So first things first,  
97:15 - I'm going to delete those three lines, because 
we are not going to use this property anymore.  
97:20 - And I'm going to scroll up a bit and 
work underneath this constructor here. So  
97:26 - you might think that converting the name attribute 
into being read only meaning a property is as easy  
97:33 - as doing something like first using the property 
decorator, and then go ahead and say def name,  
97:40 - then receive self as the parameter. And then use 
something like return self dot name, because we  
97:46 - already have the self type name assigned to the 
self object. But actually doing something like  
97:51 - this is like saying to that class, hey, from now 
on, you're going to have a name attribute that is  
97:59 - going to be rain only. And that is straightforward 
the effect of the property decorator. So I'm going  
98:05 - to leave a comment here that is going to look like 
the following. But if you remember, we try to set  
98:12 - the self dot name into a new value inside our 
constructor. So you can see that this action is  
98:21 - illegal because we have a read only property here. 
So when you go ahead and create a property with  
98:28 - the name of basically name, then you are 
normally allowed to set this value anymore,  
98:34 - you are only allowed to have access to see 
this back in whatever instance you will create.  
98:41 - So that is why if I was to hover my mouse here, 
then we're going to see an arrow that is saying  
98:45 - property name cannot be saved. So the pythonic 
way to doing this workaround to get over this is  
98:53 - using one underscore before the name of our actual 
attribute name that we assign to the self object.  
99:01 - And by doing this, we earn a couple of things that 
are quite important. So first, let me add here and  
99:07 - underscore and just use something like that. And 
then now I need to go to my property function,  
99:14 - meaning the property attribute. And I'm going to 
need to add here the double underscore as well.  
99:20 - Because First things first I go ahead and 
set up the value for my double underscore,  
99:25 - excuse me single underscore name into being equal 
to the value of this parameter here. And then I go  
99:31 - ahead and use one more read only attribute that I 
intentionally give the name of name and I and then  
99:37 - I return self dot underscore name. Now I can go 
back to my main.py file and see what effects those  
99:46 - lines are having right now on our instances. So 
first, I can go ahead and set a name for my item.  
99:52 - And I can access to the name of this item by 
saying something like I didn't want that name.  
100:00 - So I don't really have to go ahead and use item 
one dot underscore name, because that is going to  
100:04 - be a little bit ugly, and not convenient. Because 
accessing attributes with always an underscore  
100:11 - before is not nice for each of the instances that 
you look to access to the attributes. Doing this  
100:17 - one time inside the class is going to make it 
okay. But trying to access those attributes  
100:22 - outside of your class, meaning from the instances 
is not going to turn it into too much pretty. So  
100:28 - that is the best way to overcome such a thing. And 
now if I was to try to print that, then, excuse  
100:35 - me, let me fix that quickly by item one dot name, 
and run our program, then you can see that that is  
100:43 - working. And now let's go ahead and also see if 
we can set our name into being equal to another  
100:50 - thing like that, see, if that works, I can see 
that I cannot set that attribute. But how ever,  
100:57 - I can still see these underscore name from the 
instance level. And that is maybe something  
101:04 - that you look to avoid, it could have been a 
lot nicer if we could somehow prevent totally  
101:11 - the axis from this underscore naming here. So 
the way that this is achievable, is by adding  
101:18 - one more underscore to the attribute name. Now, 
this might remind you something that is called  
101:24 - private attribute. If you're familiar with 
programming languages, like Java, or C sharp,  
101:30 - that is pretty much the same behavior of using 
the private key word before your attributes in  
101:36 - those kinds of programming languages, where it 
has different principles when it comes to object  
101:41 - oriented programming. So to sum up, if you add 
one more underscore to your attribute names,  
101:45 - meaning you use double underscore, then you 
basically prevented the access to those attributes  
101:51 - totally outside of the class. So let's see a 
simulation of that. So I'm going to minimize  
101:57 - the terminal, and I'm going to go to my item.py 
file. And besides using here, single underscore,  
102:04 - I'm going to add one more. And then I'm going 
to change this to double underscore as well.  
102:09 - And now if we were to go to our main.py file, and 
let's use here it one dot and try to basically use  
102:19 - double underscore and try to access to name now we 
can see that I don't even have an auto completion  
102:24 - from my drop down, because I don't have access to 
see this attribute from the instance level. And  
102:30 - that is something that you look to achieve when 
you want to have a clean read only attribute. And  
102:36 - that is the way that you can do that. So 
if I was to try to print this, then that's  
102:41 - just going to complain about how it does not 
have the attribute of double underscore name  
102:46 - in this instance. And again, if I was to remove 
those double underscores, then I will just access  
102:53 - it as a property meaning as a read only attribute. 
And that is exactly what I looked to have here.  
102:59 - Alright, so now that we got the idea of that, 
then we still might be curious about how to  
103:05 - set a new value for the name attribute. 
Now obviously using the property decorator  
103:10 - is going to turn this into being a read only 
attribute. But there are still some decorators  
103:15 - that will allow you to however, set a new 
value for this property of name. So let's  
103:21 - see how that is achievable. So obviously, that 
is not going to work. Because it says can't  
103:27 - set attribute. So what we can do is we can use a 
new method, where we can declare that we like to  
103:34 - also set a new value for this attribute that we 
named name. So the way that that's going to work  
103:43 - is by going to our class here. And using here 
one more method with a special decorator. Now  
103:49 - this decorator is going to look like the 
following. So I'm going to refer to the  
103:54 - name because that's the property name. And then 
I'm going to use the dot setter. So by doing this,  
104:01 - then I basically say, hey, so I still want to 
set a new value for that name, although that  
104:08 - is a property meaning a read only attribute. So 
now if I was to go down and say something like  
104:15 - def name, and this will receive self and as well 
as one additional parameter because the additional  
104:22 - parameter should refer to the new value that 
I want to set to that name. So I will receive  
104:27 - a parameter that I could name something like 
value. And then inside here, I'm only going to  
104:32 - set the new value for our double underscore name. 
Because if you remember, when an instance tries to  
104:40 - see the value of name, then we basically return 
self dot double underscore name. So when a user  
104:48 - will try to set the name again to a new value, 
then it should execute self dot name equals to  
104:57 - value and by doing this, I basically allow our 
users to yet set a new value for name. So now  
105:05 - let's show what effect those three lines are going 
to have in our main.py. You can see that now the  
105:11 - arrows gone, I can now go down here and use print 
item one dot name. And that's going to work I can  
105:19 - see that I have other item. So this means not only 
I can set a new value for my underscore name, so  
105:28 - called in the initialisation, I can also do that 
later on, if I only use this convention in here.  
105:36 - Now those getters and setters thing are always 
confusing in normal programming language you work.  
105:42 - So I will do a final summary of all what we have 
learned until this point. All right. So using  
105:49 - add property will basically give you a control of 
what you'd like to do when you get a an attribute.  
105:56 - And also by using this then you basically convert 
this attribute into being read only if I was not  
106:03 - implemented these setters in here. So you 
can see that now, when I commented those out,  
106:11 - then this line is going to have some problems, 
because by not doing this, then I basically say  
106:16 - that hey, name is read only, you cannot set 
that if I was to again uncomment those back,  
106:22 - then I will have the control to set this 
attribute to whatever attribute I'd like to  
106:27 - now by using this statement here, basically 
getting the attribute, then I basically call  
106:34 - the bunch of codes that are being executed in 
here. So whenever I use item one dot name, then  
106:42 - Python says to itself, okay, you try to get that 
attribute. So, I will go ahead and try to execute  
106:47 - all the lines of codes are that are here. So 
that is what exactly happening here. And to  
106:54 - show you that, then I can just use a random print 
function here that will say, you are trying to  
107:02 - get name like that, then you should see this line 
being printed right before what the actual value  
107:10 - is. Because at first, we print you're trying 
to fit the name, and then we return the self  
107:17 - dot underscore name, so it prints that over 
here. So that is what happening when you try to  
107:23 - get an attitude. But when you try to set an 
attitude, then Python says to itself, okay,  
107:30 - so here, you try to set an attribute. So because 
you set an attribute, then I should go ahead and  
107:37 - execute the code that is inside here, because 
that is the center of that attribute. So that  
107:44 - is why when you go ahead and use this decorator, 
then you should always receive a parameter because  
107:51 - the other item is going to be passed 
as an argument to that parameter,  
107:57 - it is very important to understand that. And that 
is why I can only allow myself to use one line of  
108:03 - code that will say self dot double underscore name 
is equal to the new value that you try to set.  
108:12 - And to show you that again, I can go here and say 
print you are trying to set in this line should  
108:21 - appear just before this print line because at 
first I tried to set a different value for name,  
108:28 - and then I just print it back like that. Okay, 
so if I was to run that, then you can see that  
108:33 - at first we see the line of you're trying 
to set then right after it we actually see  
108:40 - whatever item one dot name is equal to. Now 
the reason that the value is set is because  
108:46 - we set it over here and then the next time I try 
to get the value, then those lines are getting  
108:51 - executed. So that is the lifecycle of getters 
and setters. And that is the way that it works.  
108:57 - By having the control of whatever you'd like to 
do when you set a new value, you can also restrict  
109:03 - it, you can go ahead and do some conditioning, 
or you can go ahead and raise some exceptions.  
109:09 - If you don't like the value that you receive, 
let's say that you want to restrict the length  
109:14 - of the characters for the name of that attribute. 
Alright, so that is something that you can do,  
109:20 - you can actually go here and say if when of 
the value is greater than 10, then you'd like  
109:30 - to raise exception, that will say something like 
your, the name is too long, something like that.  
109:42 - And then you can say else and then you can 
execute the line that will be responsible to  
109:47 - set that value. So intentionally I'm going to 
leave it as it is because the length of that is  
109:52 - nine characters. So we should not have any arrows. 
But if I was to add here, two more characters,  
110:00 - Like that, and executed, then you can see that we 
are going to receive an exception that will say  
110:05 - the name is too long. So that's how getters and 
setters are working in Python, you will now have  
110:11 - all the knowledge that you need to play around 
with different attributes, and manage them the way  
110:16 - that you would like to. So I believe that after 
the information that you received in that episode,  
110:22 - you have everything that you need to manage your 
attributes successfully and play around with it,  
110:27 - as well as coming up with rich classes that will 
have multiple attributes. And then you can set up  
110:33 - special behaviors to those attributes. And also 
you can decide that you will not like to force  
110:38 - to receive those attributes in the constructor, 
you can decide that you can delete some parameters  
110:44 - in your constructor. And you can say that, 
you will not like to assign those to the self  
110:49 - object immediately when you create an instance. So 
whatever you would like, do you have all the tools  
110:55 - to play around with how to manage your attributes, 
object oriented programming comes with four key  
111:02 - principles that you should be aware of. So you 
will understand how you should design your large  
111:08 - programs, so it will be easier to keep developing 
it. And I'm going to talk about those principles  
111:14 - which are encapsulation, abstraction, inheritance 
and polymorphism. So the first principle will  
111:20 - be encapsulation. And we will talk about this a 
little bit. So encapsulation refers to a mechanism  
111:27 - of restricting the direct access to some of our 
attributes in a program. Now notice how we did a  
111:34 - great job in the last part, where we implemented 
the encapsulation principle on our project.  
111:39 - So pay attention to how the name attribute could 
not be set to a new value, before it goes through  
111:45 - some conditions that we set here, like the length 
of the character being less than 10 characters.  
111:52 - So restricting the ability to override the values 
for your objects within your saddles, is exactly  
111:59 - what the encapsulation principle is about. Now to 
even give you a better example of encapsulation  
112:05 - principle, then we are going to apply similar 
things to an additional attribute, which is going  
112:10 - to be the price attribute. Now if you take a quick 
look in that program that I have just executed,  
112:16 - then you can already see that I have the ability 
to directly set these objects into whatever number  
112:22 - that I like to also negative 900 will work here. 
So that's probably something that we look to  
112:28 - change. And the way that we can change that is by 
implementing some methods that will restrict the  
112:35 - access to this price attribute. So it could have 
been nice if we could have two methods that will  
112:41 - be responsible to increment these price by some 
percentage amount. And the same goes for the  
112:47 - discount. Now if remember, we already came up with 
a similar method that looks like apply discount  
112:53 - when we talk about class attributes, because 
self dot pay rate multiplied by the actual price  
113:00 - is actually going to change this attribute being 
decreased by 20%. Because pay rate is set to 0.8,  
113:07 - if you remember from the previous episodes, so 
let's go ahead and continue designing this price  
113:13 - attribute to totally support the encapsulation 
principle. So first things first, I'm going to  
113:19 - convert this prize into being a private attribute. 
So it will be a great start avoiding to set this  
113:25 - price directly like we have seen previously. Now 
I'm not going to just add here double underscore,  
113:30 - besides I'm going to grab this whole 
thing. And I'm going to right click,  
113:36 - and then I'm going to say refactor, rename, 
and then I'm just going to rename this price by  
113:42 - setting it like that double underscore before that 
now doing this is actually going to refactor this  
113:47 - change on the entire class where we try to access 
the price attribute. So that is a great thing. So  
113:54 - we don't really have to change everywhere. So once 
I have done that, then if we will also take a look  
113:59 - in the apply discount, then you can see that 
we have this being set to a new variable name  
114:05 - that we came up with. So now that we have done 
this, then let's go ahead and create a property.  
114:11 - So we will have the ability to access the price 
attribute temporarily being only read only. So  
114:17 - I'm going to say add property. And then I'm going 
to say def price, then I'm just going to return  
114:26 - self dot price. So that's a great starter to 
restrict the access to the price attribute,  
114:33 - because now we still have access to the price 
attribute. And then we cannot set that. So you can  
114:40 - see that if we were to try to access item one dot 
price, we will have some errors, but we can just  
114:47 - access the actual value of that where it 
comes from the initialisation. So that's a  
114:54 - oh actually I see that we hit an error that says 
recursion error and that's probably because I did  
115:00 - not add the double underscore in here by mistake. 
So that's actually a great exception that we came  
115:05 - across right now, you can see that we are going 
to hit recursion error, maximum recursion depth  
115:11 - exceeded. And that happened because I tried to 
return the price without the double underscore. So  
115:16 - if we try to call the self dot price, then it is 
going to try to call this function. And if we try  
115:22 - to return that, then it's just going to loop over 
it again. And in some time, it's going to fail  
115:27 - with the recursion error as you see. So that's 
actually a great exception that we see. Now,  
115:33 - if you see this exception in your object 
oriented programs, now you know how to handle it.  
115:38 - And if I was to come back now to Maine and execute 
that, then you can see that the expected result is  
115:44 - here. Alright, so now that we have done this, 
then let's go back to our class and try to work  
115:50 - on our methods that will modify the attributes 
of double underscore price. So I will actually  
115:57 - cut this metal from here. And I will just put 
that right under the property price that we  
116:05 - came up with. So we will have a cleaner look. Now 
First things first, you can see that we have the  
116:11 - apply discount. And we will also like to come up 
with a ply. increment like the following. And we  
116:21 - will like to say here, self dot double underscore 
price is equal to self dot level underscore price  
116:30 - plus self dot level underscore price multiplied 
by some value that we can receive as a parameter.  
116:39 - So we could actually receive a parameter that 
we could name implement value, and then we could  
116:47 - just multiply it by that number. So now that we 
came up with this, then let's test this up. Okay,  
116:53 - I'm going to go back to our my main.py. And then 
I'm going to call it one dot apply increment,  
117:02 - and then I'm just going to pass in 0.2. So we 
will increment the value of 750 by 20%. Now the  
117:12 - next time that I access the item one dot price, we 
should be able to see the actual value of price,  
117:19 - which should be 900. And if I was to run 
that, then you can see that the price has been  
117:25 - incremented to 900 as expected. So that is exactly 
encapsulation in action, because you go ahead and  
117:33 - you don't allow the access directly to the price 
attribute. Besides you modify this attribute  
117:40 - by using methods like apply increments, or 
apply discount. Now the same will happen if  
117:46 - I was to now go ahead and use item one dot apply, 
discount, and you can actually modify this method  
117:54 - in the way that you'd like to. But this currently 
refers to a class attribute that we use here. So  
118:01 - this should also again, apply a discount of 20% to 
the 900 price, we should be able to see 720. And  
118:10 - that's exactly what is happening here. Alright, so 
the next principle that I'm going to talk about is  
118:15 - called abstraction. Now abstraction is the concept 
of object oriented programming that only shows  
118:22 - the necessary attributes and hides the unnecessary 
information. Now the main purpose of abstraction  
118:30 - is basically hiding unnecessary details from 
the users. Now by seeing users, I basically mean  
118:37 - people like me or you that are going to use the 
item class to create some item objects. Now we can  
118:44 - see that now we have a new program here that has 
one item object that it's name is my item price  
118:51 - being that number, and we have six from this item. 
Now we can also see that I came up with a method  
118:57 - that doesn't really exist, which is called send 
email. So that method at the end of the day should  
119:03 - send an email to someone that would like to decide 
about this item. And it will send info about how  
119:10 - much money we can earn by selling all the items 
and maybe about some more info that is related to  
119:16 - this item. Now sending an email is not as 
easy action just by calling it with that way.  
119:24 - Because in the background, email sending has to 
go a lot of processes like connecting to an SMTP  
119:30 - server. And as well as preparing the body of the 
email with an auto message that will display some  
119:37 - info about this item. So as we can understand 
we have to go through a lot of new methods  
119:42 - before we go ahead and just call a Send Email 
method. So to simulate that, then I can actually  
119:49 - go ahead and say send email. So I will just create 
the method that is necessary. Temporarily I will  
119:55 - use pass. Now as I said we also have to go through 
a lot of other processes. So it is a great idea to  
120:01 - create methods for each of those processes, like 
connecting to an SMTP, server SMTP server like  
120:10 - that. And I will just say pass because we only 
try to simulate the idea of abstraction here,  
120:15 - I'm not really going to send an actual email to 
someone, I'm just simulating an idea of sending  
120:21 - an email. And we will also have to go to preparing 
a body for an automatic mail prepare body, right,  
120:30 - and then I can just return a formatted 
string that will say something like hello.  
120:40 - Someone, we could receive this as a parameter as 
well. And then we can say, we have self dot name,  
120:51 - six times, right, so it should be six. So 
quantity times like that, then I can say regards  
121:01 - to shave. So that is just a very simple 
email that we can send to someone. Now we  
121:07 - can understand that we have to call those methods 
inside the same email. So simulating that will be  
121:13 - self dot Connect, and then self dot, prepare body. 
And probably we also need to go through sending it  
121:24 - right, so we can just say something like send 
here, then us passing it. Now you can see that  
121:31 - those metals at the end of the day are only 
going to be called from the Send Email.  
121:37 - Because those are just parts of the email 
sending process, that is a bigger process  
121:44 - that we divided into multiple steps in this 
class. Now the biggest problem is, we will have  
121:50 - access calling those methods from the instance. 
And that is exactly what abstraction is about.  
121:58 - abstraction principle says to you that you should 
hide unnecessary information from the instances.  
122:05 - So that is why by converting those methods into 
being private methods, then we actually apply  
122:12 - abstraction principles. And that is achievable 
in Python in a way, which I'm going to be honest,  
122:18 - is not too much convenient, but it is achievable 
by adding double underscore. Now again, in other  
122:25 - programming languages, this is achievable 
by having access modifiers for your methods,  
122:32 - like private or public. And I'm talking about 
programming languages like Java, C sharp, etc.  
122:39 - So if we were to convert those methods to 
private methods, by only adding level underscore,  
122:45 - then those only cool to be cold from the class 
level, meaning inside the class. So if we were to  
122:52 - try to access it, then you can see that I am going 
to have auto completion, meaning I will have the  
122:58 - ability to access those methods. And then I will 
just do the same for the other methods. Now this  
123:06 - arrow comes from here, because we did not really 
specify some argument, I'm just going to add an  
123:11 - empty string. Now if I was to go back to our 
main.py file, then you're going to see that we  
123:16 - are going to have some troubles. Even if I'm going 
to try to access it with a double underscore,  
123:21 - I'm not even going to have an auto completion. 
And the reason for that is because that is a  
123:26 - private method. So you really have to think 
about your methods if you want to make them  
123:31 - accessible outside of your class, meaning from the 
instances. And that is exactly what abstraction  
123:38 - is about. You want to abstract the information 
that is unnecessary to call it or to access it  
123:45 - from your instances. Okay, so inheritance is the 
third principle of object oriented programming.  
123:51 - inheritance is a mechanism that allows us to reuse 
code across our classes. Now, that's something  
123:58 - that we have totally designed well throughout this 
course, because we came up with more classes that  
124:04 - are child classes of the item class, where each 
child class represents a kind of an item. Now pay  
124:12 - attention how I change the import line from phone 
import from, and I use the child class of item,  
124:20 - which we came up with, which is called the phone, 
you can see that I'm passing similar arguments  
124:25 - in they can still use a code that is implemented 
in the parent class. If we were to execute this  
124:31 - program, then we are not going to receive any 
problems. Because phone uses all the methods  
124:38 - and the attributes that it inherits from the 
item class, which is exactly here. And if we  
124:45 - remember we designed the Send Email method 
in the parent class and we can use it from  
124:49 - the instance of a phone and we can also do that 
for the rest of the methods that we came up with  
124:55 - that really affect some of the attributes like in 
the interview. capsulation part where we applied  
125:02 - the apply increments method that receives an 
increment value. And if we were to test this  
125:09 - incrementing, the price by 0.2, and then 
printing item one dot price, then we should  
125:16 - see 1200. So if we were to print that, then 
you can see that that is exactly the result.  
125:22 - So that is mainly what inheritance is about. It 
is about reusing the code across all the classes.  
125:29 - And that's exactly the scenario here. And the 
beauty behind that is that you can come up with  
125:34 - more child classes that will represent the kinds 
of items like laptop, keyboard, camera, everything  
125:41 - that you will think about. And then you can just 
modify specific methods that you'd like to calling  
125:47 - to the kind of item that you have. So that's 
perfectly describing what inheritance is about.  
125:54 - Alright, so the last principle that we have now is 
polymorphism. Now polymorphism is a very important  
126:00 - concept in programming. It refers to use of a 
single type entity to represent different types  
126:07 - in different scenarios. Now, a perfect example 
for this definition, will be some of the functions  
126:14 - that we already know that exists in Python. Now 
just a quick side note, polymorphism refers to  
126:20 - many forms Paulie being many, and morphism being 
forms. So again, the idea of applying polymorphism  
126:29 - on our programs is the ability to have different 
scenarios, when we call the exact same entity and  
126:36 - an entity could be a function that we just call. 
Now, as you can understand polymorphism isn't  
126:41 - something that is specifically applied to how you 
create your classes. That is actually something  
126:47 - that refers globally to your entire project. 
And in the next few minutes, we are going to  
126:51 - see some bad practices where polymorphism is not 
applied. And we're also going to see where in  
126:57 - Python the polymorphism is perfectly applied. So 
a great example of where polymorphism is applied,  
127:03 - is in the lane built in function. Because the land 
building function in Python knows how to handle  
127:10 - different kinds of objects that it receives 
as an argument, and it returns you a result  
127:16 - accordingly. So as you can see in here, if we 
were to use the Len built in function in a string,  
127:24 - then we will have received the total amount of 
characters. But if we will do this in a list,  
127:31 - then we will not receive the length of characters 
of this entire expression in here. Besides,  
127:36 - we will receive back the amount of elements 
that are inside this list. And to show you how  
127:43 - this is going to work, then I'm just going to run 
this program and for sure, the results are just  
127:48 - as expected. So as the definition of polymorphism 
says, it is just a single entity that does know  
127:55 - how to handle different kinds of objects, as 
expected. All right. So now that we understood  
128:00 - that the polymorphism is applied everywhere in 
Python, especially in the land building function,  
128:06 - let's also understand where it is implemented on 
our project here. Now we can see that I tried to  
128:11 - call the apply discount method that is never 
implemented inside the phone class. And the  
128:16 - fact that I can use it from the item class, 
it is because we inherit from this class.  
128:22 - And that is the basically reason. Now if I was to 
go back to that main dot php file and run this,  
128:29 - then you can see that that is going to work 
because the apply discount is a method that  
128:34 - I can use from the inherited item class. Now 
that's exactly what polymorphism is also inaction.  
128:41 - Because polymorphism again, refers to one single 
entity that you can use for multiple objects. Now,  
128:48 - if I was one day to go ahead and create 
more kinds of items, meaning more classes  
128:54 - that will represent different kinds of items, 
and from them to call the apply discount method,  
129:00 - that's also going to work because the apply 
discount is a method that is going to be  
129:05 - accessible from all the kinds of objects so that's 
exactly why you might have heard about the terms  
129:10 - of inheritance and polymorphism together combined. 
Now to show you that, then let's try to create one  
129:16 - more class that is going to be identical to the 
phone class, right, I'm going to create a keyboard  
129:22 - file. And then I'm just going to say here, class. 
You know what, before that, let's go to phone and  
129:31 - copy everything from here and paste this in like 
that. I'm going to get rid from those lines.  
129:38 - And I'm just going to leave the init as 
it is I'm going to change the class name  
129:43 - from phone to keyboard and I'm also going to 
delete that attribute that we don't need broken  
129:49 - phones. Alright, so now that we have this, then 
I can actually go ahead to my main dot php file  
129:56 - and use one more important line that 
will say from key board import keyboard,  
130:02 - and then I'm going to change this to keyboard will 
replace this name, just to make it more realistic,  
130:09 - then I'm going to run the same problem, you can 
see that this works. So that's again exactly where  
130:15 - polymorphism is in action, because we can use this 
single entity from different kinds of objects,  
130:21 - and it will know how to handle it properly. Now by 
saying handle it properly, then I basically mean,  
130:27 - you can have the control of how many 
amount of discount you want to apply  
130:32 - inside your classes now, because if we were 
to go to keyboard and use a class attributes,  
130:42 - exactly like we used in the item class, which 
was pay rate, then we're going to have full  
130:48 - control for all the discounts that are going 
to apply to the keyboard. And to show you that  
130:54 - I am going to attempt the typing in pay rate. 
And you can see that I even have auto completion  
130:59 - because overriding in the child class that is 
legal, alright, so I can just say pay rate is  
131:05 - equal to 0.7. And that will be it. Now I have 
the same discount amount for all my keyboards.  
131:13 - If I was again to run the main.py file, then you 
can see that the results are just as expected, we  
131:20 - see 700. So that is the beauty behind inheritance 
and polymorphism together. And the same will go  
131:27 - for sure if we were to decide that we would like 
to have 50% discount. So it will only take for me  
131:33 - to go ahead and say pay rate is equal to 0.5. 
And that's it. So I hope that you understand  
131:40 - about polymorphism a bit better now. Now just a 
quick side note polymorphism is perfectly cool,  
131:46 - we implemented by using abstract classes. And that 
is just the identical way of using interfaces in  
131:53 - other programming languages like Java interface is 
a way that you can implement how a class should be  
132:00 - designed. Alright, so it is like a template 
for a class. And that is achievable by using  
132:06 - abstract classes, which I'm not going to cover in 
that part. But again, polymorphism, like I said,  
132:12 - is a term that is implemented in different 
areas in the whole python programming language.  
132:19 - So I hope you had a great time learning 
the object oriented programming course.  
132:23 - Now you have a lot of tools that you can go ahead 
and try to implement by yourself on your projects,  
132:29 - which will really help you to take you to the 
next step as a developer. See you next time.