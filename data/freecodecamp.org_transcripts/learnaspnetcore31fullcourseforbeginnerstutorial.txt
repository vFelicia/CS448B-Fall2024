00:00 - Hi guys, and welcome to the course on introduction 
to ASP dotnet core 3.1. My name is Megan and I  
00:08 - will be our instructor on this introductory 
course, we will understand the basics of  
00:14 - ASP dotnet core, the reason behind its evolution 
followed by the new files and folder structure  
00:21 - that have been introduced. Once we understand 
that, then we will take a look at new concepts  
00:28 - like middleware, routing, tag helpers, Razor 
syntax, and much more. Now, with ASP. NET Core,  
00:36 - there are two ways to build a web application. 
First approach is MVC application. And the second  
00:44 - approach is razor pages application. We will 
be building projects in both the technologies  
00:51 - to understand how the basics work. Both the 
projects will be built with a basic crud website,  
00:58 - which stands for create, read, update and 
delete functionality. So we will understand  
01:05 - how to connect with database and playing with 
Entity Framework in our ASP dotnet core web  
01:12 - application. Now, before we start, there are some 
prerequisites that you should be familiar with,  
01:19 - I would say about three months of coding in 
C sharp and familiarity with basic SQL will  
01:26 - be sufficient. Also, if you're stuck with the 
course, my code will be published on GitHub  
01:33 - repository. So you can always follow along with 
each lecture. And if there is something which  
01:40 - still does not make sense for you, you can always 
raise a question, and I will be happy to answer  
01:46 - that. But the first approach you should take 
is compare your code with my version on GitHub,  
01:53 - and try to identify the differences. This way, you 
will try to identify the errors yourself. Now this  
02:01 - would be a basic course on ASP dotnet core, but 
it will give you have a solid foundation before  
02:08 - you dive into deeper and complex courses. At 
the end if you are interested in more detail,  
02:14 - and in depth courses, I have courses on both MVC 
as well as razor pages with ASP dotnet core. And I  
02:24 - will also show you how you can enroll into those 
courses for the lowest price. That being said,  
02:32 - let's get started on this exciting journey to 
explore the basics of ASP dotnet core. And I  
02:39 - will see you in the next video. In this course, 
we'll be building two projects, first will be  
02:46 - a simple Razer project. And second one will be 
our main project which will use MVC. So let me  
02:54 - demo the first project that we'll be building. 
It's a simple book list raiser project in which  
03:00 - if you select the book tab, it will display a 
list of all of the books. Now here in the list,  
03:06 - you can see two types of tables. That is because 
at the end, here we are using data tables, which  
03:12 - makes call of API. On top here we have a simple 
table using th en tr tags here, when you create  
03:21 - a book, if you try to enter without anything, we 
have validations once you enter the details to  
03:28 - create a new book, and you hit the Create button, 
it creates the book and displays in both places.  
03:34 - here when we use data tables, if we click Edit 
here, and if we change something that will make  
03:41 - it a capital W and updated, there you go, you can 
see it is updated. If you try to delete anything,  
03:49 - it will display a suite alert to you. That being 
said, we have multiple ways. As I was saying  
03:55 - before, in the Create new book, you will see a 
new page called create. But if you go to absurd,  
04:01 - it will be the absurd page. And that will be the 
same page that we'll use to edit. If we go right  
04:07 - here. You see it's absurd. And if you look right 
here, it will be again an added page. So this is  
04:14 - more of a simplified view. And then at bottom, 
what we see is more of an advanced view. That  
04:21 - being said, we are performing CRUD operations 
on our book. But this project is not just that,  
04:26 - we'll be learning razor pages and how page model 
and page view comes into the picture. So even  
04:34 - though this is a small project for crud operation, 
that is lots of basic functionalities and basic  
04:40 - fine overview that you need to understand. That 
being said, let's take a look at the demo of  
04:46 - our final project, which is way more advanced 
than what you see right here. In this video,  
04:53 - let me walk you through the small project that we 
will build using MVC. This will be a very basic  
05:01 - project to create CRUD operations on book list. 
So right here, if you go on book list, we will  
05:09 - be using data tables to display all of the list 
from the database. You can add a new book here,  
05:16 - you can fill in the details. But let's say if 
you do not enter a name, we see validations that  
05:22 - have been enforced here. That being said, you can 
create a book and once it is created, you can edit  
05:29 - any of the details here. And you can also delete 
book. When you delete we have nice alerts that you  
05:36 - can display here. And once it is successfully 
deleted, you will also see nice notifications.  
05:43 - So this is a great project to get started with 
the MVC journey and learn what ASP dotnet core  
05:51 - has to offer. In this video, I want to give you 
a small introduction on ASP dotnet evolution.  
05:58 - asp dotnet core introduces probably the biggest 
shift the platform has experienced so far,  
06:05 - but let's take a look at how it has evolved over 
time. In 1996, Microsoft released framework known  
06:15 - as ASP, which stands for active Server Pages, or 
classic ASP. With classic ASP Microsoft made it  
06:24 - possible to have server side scripting to dynamic 
web pages. The biggest revolution came when  
06:32 - Microsoft released dotnet framework. Microsoft 
introduced ASP. NET webforms in 2002. This made  
06:42 - creation of web page similar to the creation 
of Windows form. There are a few downsides with  
06:50 - web forms, web forms, tried to make stateless web 
stateful. And in order to do that, it had to make  
06:58 - lots of changes to make sure web pages retain 
their state or their values automatically. View  
07:07 - states contained those values, and that resulted 
in a lot of data being generated and transferred  
07:14 - with each request. Sometimes even if it was 
not required. webforms was the first version  
07:22 - to introduce code behind code behind is good, but 
it makes testing difficult. Because in one line,  
07:30 - we are reading from the database, and in the next 
line, we are updating the UI. Another common issue  
07:38 - was page life cycle. When requesting the page, 
number of events were getting fired. Getting to  
07:46 - know all of these events was quite easy to get 
it wrong. Although there were a few downsides,  
07:53 - web forms were generally successful to get site 
up and running quickly. Couple of years later,  
08:01 - in 2009, Microsoft released the first version 
of ASP NET MVC, and they tried to overcome most  
08:11 - of the problems with webforms. It had emphasis 
on separation of concern. MVC code is typically  
08:19 - much easier to write unit test for MVC was the 
first edition where they released it as open  
08:26 - source. Now a lot of developers did not like MVC 
framework because it had its own flaws. When it  
08:36 - was created. It was built on top of the components 
already created for web forms, because of which it  
08:43 - was closely tied to system dot web, which was tied 
to IIS and eventually windows. On the other hand,  
08:52 - web is evolving quickly. And hence Microsoft had 
to keep MVC with everything that was changing.  
08:59 - Also, MVC was built before cloud came into the big 
picture. Even though a lot of MVC applications are  
09:08 - still running on cloud, but it is still not build 
with cloud in mind. Finally, in June of 2016,  
09:17 - Microsoft released ASP dotnet core and this was 
the first version. Now ASP dotnet core is built  
09:26 - on top of the new dotnet core framework dotnet 
core is the very first platform version of dotnet.  
09:33 - And hence, it is not tied to just wait knows ASP 
dotnet core as compared to the old version of MVC  
09:44 - is not tied to the dotnet framework assemblies 
like system dot web. asp dotnet core team has  
09:52 - been very active with the new versions. And then 
in 2017, they released dotnet core two followed  
09:59 - Buy 2.1 and 2.2 in 2018. Finally, in September 
of 2019, ASP dotnet core three has been released,  
10:09 - which we will be using in this course. In this 
video, let me show you all the tools that we'll  
10:17 - need for this course. The first and most important 
is Visual Studio 2019. This is the ID that we'll  
10:24 - be using. You can go on Visual Studio dot 
Microsoft comm forward slash Bs, and you can  
10:31 - download the community version for free, make sure 
you download the 2019 if it is 2017 dotnet, core  
10:39 - 3.1 will not work. Next, what you need is you have 
to download the dotnet core 3.1 and install it. So  
10:46 - if you go on the Microsoft website for dotnet 
core 3.1. Here, you can download the windows 4x  
10:54 - 64 and install it. Once you install it, then when 
you create a project in Visual Studio 2019, you  
11:01 - will see the dotnet core 3.1 option, which I will 
discuss when we get there. But make sure both of  
11:09 - these are installed. After that, you will have to 
install the SQL Server 2019 you can use an older  
11:16 - version of SQL Server but I would recommend the 
latest one, you can download it for free for the  
11:22 - developer version. Once you install SQL Server, I 
also want you to install the SQL Server Management  
11:30 - Studio, which will be a UI to your SQL Server. So 
make sure you install all four of these features.  
11:38 - And that are all the tools that you will need. All 
of these tools are free, so you should not have to  
11:44 - spend anything to install these software's on your 
laptop or desktop. In this video, I want to show  
11:52 - you where you will find all the code that we'll 
be building. For that one place will be you have  
11:58 - to go to brogan.com. in there, I have courses. 
Right now we are on the free course, if you go  
12:05 - on the details, if you click course content, 
it will download the completed code. But if  
12:11 - you want lecture by lecture on what was changed, 
you can click on GitHub code. Here, it will open  
12:17 - up both the projects that we'll be building in 
this course. here if you see the comments, they  
12:24 - will be based on the lecture name inside raiser as 
well for each lecture, you will see what exactly  
12:30 - was changed or updated. And you can make sure that 
you have those same things If you face any issue  
12:37 - in a particular lecture. So procon.com and in 
there, you have to go to the courses to find out  
12:45 - what course you're on. And in there in details, 
you will find the GitHub link. In this section,  
12:52 - we will be creating our very first project, it 
will be a razor project. And then once we created  
12:59 - we will take a look at the files and folders that 
are created. With this we will also understand how  
13:06 - an ASP dotnet core application is started. And 
what are the files that are involved. So let's  
13:15 - get started with all of that from the next video. 
When you open up Visual Studio 2019 it displays  
13:23 - a nice page on the left hand side you can see all 
the projects you were working on. And on the right  
13:29 - hand side you can see options to create a new 
project. So right here, we'll click on create  
13:36 - a new project. And once you do that, it will 
display all of the templates that are available.  
13:42 - Out of this, we will select ASP dotnet core web 
application. If you do not see on the top view  
13:49 - options, you can always search for that template 
on the top. Once you find the ASP dotnet core web  
13:57 - application, let's hit the Next button. And we 
need a project name. Let's call this book list  
14:05 - razor, and we'll change the location. I'll paste 
the location where I want to create this project.  
14:12 - After that, we'll hit the Create button. And 
we'll have more options for our project. In here,  
14:21 - the first thing to notice is we have dotnet 
core and the dotnet framework. We will be  
14:27 - using the dotnet core and what version we want to 
use, we want to use the latest version, which is  
14:33 - ASP dotnet core 3.1. Once you select that, then we 
have few templates here. We can go with an empty  
14:42 - application and API project, a web application 
which uses the razor pages or we can create an  
14:50 - application with MVC. Our main project will be 
built using MVC, but the first project I want to  
14:58 - give you an introduction To razor pages, here, I 
will display a CRUD operations so that you can get  
15:06 - comfortable with razor pages, because that will be 
used inside the identity in our MVC application.  
15:13 - So we'll get a basic overview when we build this 
project. Next, we have the authentication here,  
15:22 - you can select individual users account for 
authentication. But right now, we do not want  
15:28 - to do that. Because if we do that some of the 
things will already be configured for us. But I  
15:35 - want to start from scratch in this project. So 
we'll just create a web application with razor  
15:42 - pages. Then before proceeding, we'll make sure 
the source is dotnet core 3.1. And we'll hit  
15:49 - the Create button. Perfect. So with this, we have 
created our project, and we'll be taking a look at  
15:57 - all the files and folders that we created from the 
next video. In this video, we will take a brief  
16:04 - overview on what are razor pages, Razor pages have 
been introduced in ASP. NET Core 2.0. And since  
16:13 - then, they have become the default way of coding 
with ASP dotnet core stack. razor pages is a new  
16:21 - feature of ASP dotnet core that makes coding page 
focused scenarios more easier and more productive.  
16:29 - They provide a simpler way to organize code 
within ASP dotnet core applications. Keeping the  
16:38 - implementation logic and view models closer to the 
view implementation code. razor pages is not just  
16:47 - for simple scenarios, everything that you can do 
with MVC, you can do the same using razor pages,  
16:54 - like routing models, action result, tag helpers, 
and so on. Finally, Razor pages have two parts.  
17:04 - First is the UI, which is more like the view in 
MVC. And then we have the page model, which is  
17:11 - a combination of models, as well as view models 
and the controller action methods. Let me switch  
17:20 - back to the application that we just created and 
give you a quick demo of both the component. So we  
17:27 - are on the booklist razor. If we go to Solution 
Explorer, inside pages, we will have the razor  
17:34 - pages. Let's take a look at the Index page. If you 
see the Index page has an arrow, and there is dot  
17:43 - CSS, HTML, and dot CSS, HTML dot CSS, if you open 
the dot CSS HTML, that is the result view all the  
17:53 - UI of razor pages and then the dot CSS, which is 
not same as the code behind file, it is just a  
18:02 - naming convention. But this is actually the page 
model for our index razor page. You can see it  
18:10 - extends from the page model class. Inside this 
page model, we will define the model for this  
18:17 - view. Right here you can see it is index model. 
And if you go on index, you can see the class  
18:24 - name is index model. In here, we have handlers, 
which are like the controller action method. Right  
18:33 - now we only have the get handler that is defined 
here. But we will be adding a post handler when we  
18:40 - want to post anything from our view or the razor 
page. Another thing to notice is the name for the  
18:49 - get handler it is prefixed with the on keyword. 
Similarly, if you had a post handler, it would be  
18:56 - something like this, in which we'll have public 
wide on post, and we'll have the implementation  
19:02 - within the brackets. We will undo the change that 
we did because I just wanted to show that right  
19:09 - now. But as we proceed, we will be implementing 
the handlers for our razor pages. In this video,  
19:18 - let's take a look at the project configuration 
file. In order to open that you can right click  
19:24 - on the project not on the solution but on the 
project. And you have the Edit project file.  
19:31 - Or all you can do is double click on the project 
name and it will open up the project file. The  
19:39 - file name would be the project name and then the 
extension.cs project. project file has been there  
19:46 - since a long time but the format of the file and 
how it works is different in ASP dotnet core three  
19:53 - in the initial versions of ASP dotnet core, we 
had files called Project dot JSON and extra large.  
20:02 - The new cs proj file replaces both the file. Now 
right here you can see within Property Group, we  
20:10 - have the target framework, which is NET Core app 
three dot O, which is what we are using for this  
20:17 - project. The target framework here is also called 
a node. After that we will be adding more packages  
20:25 - into our solution. Let me show you a quick way 
we go to Tools nougat package manager solution.  
20:32 - And if we go on browse, let me install any first 
package that we have. We have Newton soft JSON,  
20:41 - so we just installed that, don't worry, we'll come 
back and uninstalled this. But I want to show you  
20:47 - for demo purposes, how the project file will be 
affected. Perfect This is installed. If you go  
20:54 - to the project file again. Now you see a package 
reference with Newton soft dot JSON. So every time  
21:02 - you add a nougat package, a package reference 
entry would be added here. Right now we only  
21:08 - have one of them, which we just added. And if we 
uninstalled this, it will go away. If we go back,  
21:16 - this should be gone. Whenever we need to add 
more packages, we'll be adding more packages  
21:21 - as per our requirement. Now, if you have worked 
with previous versions of ASP. NET Core, there  
21:29 - was a new good for meta package. And let me switch 
to the presentation for that. And here we will be  
21:36 - discussing what was the meta package and what is 
done with that the package has been discontinued.  
21:43 - And now it is a part of the dotnet core class 
library. They are now updated automatically  
21:50 - when you update the version of dotnet core. Prior 
to three dot o as I said before, the meta package  
21:57 - was included as a new get package. But now when 
you install dotnet core on your Windows or laptop,  
22:04 - that meta package is installed automatically. 
Also, some of the packages have been moved out  
22:11 - from that meta package like Entity Framework core, 
which has been moved to its own nougat package,  
22:18 - which we will be installing in the future videos. 
So that was a brief overview of where the meta  
22:24 - package is. Now with dotnet core three, you will 
no longer see the meta package Microsoft dot ASP  
22:32 - NET Core dot app, it has been moved within 
the dotnet framework. So it is installed  
22:38 - automatically when you install dotnet core. So 
that gives you a brief overview of the Cs proj  
22:44 - file. Mainly it is to reference all of the nougat 
packages and the target framework. In this video,  
22:54 - we will be taking a look at the properties 
in our folder. If you expand the properties,  
22:59 - you will see a file called launch settings dot 
JSON. This file tells ratio studio what to do when  
23:07 - you press the Run button right here on the top. 
By default, we have few profiles here. By default,  
23:15 - we have few profiles here. The first one is the 
IIS Express, which will launch IAS Express, which  
23:23 - will host the application and start a browser that 
will hit the URL. It will also set the environment  
23:31 - variables to development. In this case, we can 
detect the environment variables and make changes  
23:40 - based on that example, if it is development with 
a load the full CSS and if it is production, then  
23:48 - we will load the minified version of CSS. There is 
also a section to configure the IIS Express here,  
23:57 - you can set the launch variables here if you 
scroll down further, we have another profile  
24:04 - called as population raiser, which is the project 
name, it will run the application as a command  
24:10 - line application. So the internal castril which is 
internal web server would be used, then a browser  
24:19 - would be started which hits the URL. These can 
also be set by going into the properties of the  
24:26 - project, not the solution. And if we go on debug, 
we have all the profiles right here. And you can  
24:34 - set the environment variables URL, SSL, and other 
configuration. We will not be altering any of this  
24:43 - but I wanted to show you an overview of what it is 
and where you can change that. Also inside the run  
24:51 - here, you will see all the profiles. So you can 
select anyone to run your application. The next  
24:58 - thing that will be Taking a look is the www root 
folder. If you expand this, you will see folders  
25:05 - for CSS JS level. This is a new thing that has 
been introduced with ASP. NET Core. And this  
25:14 - has been created automatically. In this folder, we 
will be placing all the static files like images,  
25:20 - CSS, JavaScript, and also static HTML. This folder 
is the root folder for our website. None of the  
25:30 - code files that we'll be creating will go inside 
this folder. So you shouldn't be placing any C  
25:37 - sharp or razor files here. This folder has been 
created with an idea of having a nice separation  
25:45 - between code files, and the static files. Since 
we created the application using MVC template,  
25:54 - we can see that Visual Studio has already placed 
few bootstrap, CSS and other static files for us.  
26:02 - If you expand CSS, you see site dot CSS, with 
GS, you have site or chairs. And inside the lib  
26:11 - folder, we have bootstrap, jQuery validations, 
and some other scripts. Now the reason we have  
26:18 - all this CSS and JavaScript by default is we 
created the web application as a razor page. If  
26:26 - we selected an empty application, we would have to 
add all these files by ourselves. If you want to  
26:33 - explore that option, you can go ahead with that. 
But with believing right is when we'll be adding  
26:40 - more CSS or JavaScript will always do that inside 
our www root folder. So that is the one place for  
26:49 - all of your static files. In this video, we will 
be taking a look at the pages folder inside our  
26:58 - razor project. So the main folder inside any razor 
project is the pages folder. In here, we will have  
27:06 - all the pages that we want for our website, inside 
the pages folder using a shared folder. And if you  
27:13 - expand this, we have underscored layout and 
validation scripts partial. Now the name of  
27:19 - these two razor pages starts with an underscore, 
which means they are partial views. Now partial  
27:27 - pages is something like user components, which 
means you can reuse them in multiple places in  
27:33 - your website. The first one here underscore layout 
is the default master page for your application.  
27:40 - So if you open this up right here, you see we have 
the header for our application. You scroll down,  
27:47 - we have the main part, and we have the footer. We 
also have the scripts that we want throughout our  
27:54 - application. And if you scroll up right here, 
we have the CSS files. You can of course change  
28:01 - the default page that you have for the master 
page. But we will keep it the same. And right  
28:08 - now it is underscored layout. Next, what we have 
is validation scripts partial. Here we have just  
28:16 - included the JavaScript or jQuery that we will use 
for validations. And in the pages where we want to  
28:23 - include that, we can just include this partial 
page. After that outside of the shared folder,  
28:29 - we have the view import. Now with dotnet core 
2.0. When above, we have tag helpers. And we will  
28:37 - understand in detail about tag helpers in just a 
little while. But in the view import, you define  
28:44 - that you want to include tag helpers in your 
application by adding this one line, which starts  
28:51 - with x tag helper. You can also add custom tag 
helpers here if you create your own tag helpers,  
28:59 - and you want to register for this application. 
You can also add your custom tag helpers that  
29:05 - you want to be used in your application. If for 
some reason, you only want to use tag helpers for  
29:11 - some features, rather than defining this at global 
level, you can also define it at individual page.  
29:18 - But I like to define it at the global level in 
underscore view inputs so that when I need it,  
29:26 - it is already present. After that, we have the 
underscore view start file. And here we define  
29:32 - which is the master page that we'll use for our 
application. Right here you can see underscore  
29:38 - layout has been defined. After that what we have 
the rest three are the actual razor pages. So  
29:45 - you can think about whatever we discussed so far 
are more related to configuration master page and  
29:51 - user component. Then we have the Edit page, index 
page and the privacy page. Now if you open up the  
30:00 - index dot CSS HTML right here you see the UI, or 
the user interface with HTML and CSS. But where  
30:09 - is the page behind or the model defined here? 
In MVC, we used to have controllers, but we do  
30:17 - not have that anymore in the razor pages. So if 
you expand this, you see there is index dot CSS,  
30:24 - HTML dot CSS, and this is inheriting from page 
model. And the name here is index model. If you go  
30:33 - to the Index page, you will see the model is the 
same name. So whatever we define inside the page  
30:39 - model here will be used as the model for the index 
razor page. This page model will be a code behind  
30:47 - for our index page. This is nowhere as close 
to what we had in the classic ASP dotnet code  
30:55 - behind. This is completely rewritten and in a 
completely different format. And we will call  
31:02 - this.cs file as the page model. And the.cs. 
html will be the view or the razor page. Now  
31:10 - that we have a brief overview of where what code 
goes, let's see routing in the next video when  
31:17 - we will see the index privacy and the application 
coming along. One of the top level considerations  
31:26 - for the developer of a server side web application 
framework is how to match URLs to the resources on  
31:34 - the server so that the correct one processes that 
request. The most straightforward approach is that  
31:40 - you map URLs to the physical files on the desk. 
And this is the approach that has been implemented  
31:47 - by the ASP. NET core team for razor pages 
framework. Now there are some rules on how razor  
31:55 - pages framework matches URL to files, and how 
rules can be customized to give different results  
32:03 - if needed. The first rule is that razor pages 
needs a root folder. By default, the folder has  
32:12 - been named pages, and its location is inside the 
root folder of the web application project. You  
32:20 - can configure another folder as the root folder 
in the application configuration services method  
32:26 - inside the startup class, but that is beyond 
the scope of this course. So we believe that  
32:32 - as the default page, if we have any requirements 
that we had to change that, we would of course,  
32:38 - take a look at that. Let's switch back to the 
application that we have. Right here you see the  
32:45 - root folder is the pages folder, and all of the 
pages resides inside that. Of course, we can add  
32:52 - areas here and we can add pages inside the areas 
folder, then that will become the root folder for  
32:58 - the application. Another rule is that the file 
extension should not be included inside the URL  
33:05 - bat. So right here you see index dot CSS, HTML 
inside the URL will only mentioned index. Then let  
33:15 - me switch back to the presentation. And the third 
rule is that index dot CSS HTML is the default  
33:22 - file. Which means if a file name is missing from 
the URL, the request will be mapped to index dot  
33:29 - CSS HTML inside that folder. Now let's take 
a look at few examples. In the first example,  
33:38 - we have www.domain.com This will map to the pages 
folder and then look for index dot CSS HTML page,  
33:47 - since we have not defined anything in the URL 
index is the default page. In the second example,  
33:55 - we have www.domain.com forward slash index. 
Again, in this it will look for the same index  
34:03 - page inside the pages folder, because we have 
explicitly defined the Index page. Finally,  
34:11 - we have www.domain.com forward slash account. 
Now here it has two ways to find the page. First,  
34:20 - it will try to find inside the pages folder. 
First, it will try to find inside pages folder,  
34:26 - a file named as account dot CSS HTML, if it finds 
that it will render that if it doesn't find that  
34:35 - then it takes that account could be a subfolder 
name under pages. So it will check inside the  
34:42 - pages folder if there is a folder called account. 
And inside that it will try to find index dot  
34:49 - CSS HTML. So we have few examples here for 
routing. Let's see this in action. Let's go  
34:56 - to our project and run the application. In here, 
you can see the URL is localhost, and we do not  
35:05 - have anything else. So that means by default, it 
is loading the Index page. If we go back to our  
35:13 - application Solution Explorer, double click index, 
you can see the text is welcome. And that is what  
35:20 - we are seeing right here. If we explicitly defined 
index here, it will still load the same page. Now,  
35:29 - if we click on privacy, here, you can see it is 
adding privacy. And if we go back to the solution,  
35:35 - privacy is inside pages, so you can directly 
access that. Let me stop the application and  
35:42 - show you something else. I'll add a new folder. 
And I'll call this with my name, again here,  
35:49 - and I've been moved privacy inside again. 
Let's run our application and try to access  
35:56 - the privacy again. If we click here, it will not 
load anything because privacy doesn't exist in the  
36:05 - same location. In order to access that you have to 
type again, forward slash privacy. And with this,  
36:14 - it loads the privacy page correctly. So that 
way, you can see that the linking of all the  
36:20 - pages is exactly what you see here. I'll move 
the privacy back inside the pages folder,  
36:26 - and I'll delete my folder, not renamed. Perfect. 
So this was a brief overview on how routing works.  
36:35 - And we'll be using more tag helpers and routing 
as we proceed with the course. In this video,  
36:43 - we will take a look at tag helpers. Tag helpers 
are brand new to ASP dotnet core, Microsoft looked  
36:51 - at the success around the other libraries like 
Angular JS, react, and others, and decided that  
36:59 - implementing an Angular directive like experience 
in the new ASP dotnet was so important to the  
37:07 - adoption of ASP dotnet core, and because of which 
they decided to create tag helpers from ground up.  
37:15 - Tag helpers enable server side code to participate 
in creating and rendering HTML elements inside  
37:23 - the reason files. Do there are similarities 
between Angular directives and tag helpers,  
37:30 - there is a major difference. Tag helpers are for 
server side rendering, while AngularJS directives  
37:38 - are all about client side rendering. Now you might 
be wondering how tag helpers are compared to HTML  
37:46 - helpers. If you have worked with previous versions 
of dotnet core HTML helpers are really just  
37:53 - methods throughout your razor markup. Tag helpers, 
on the other hand, are very focused around HTML  
38:01 - elements and much more natural to use. Now let's 
switch back to the application. And let's take a  
38:08 - look at few tag helpers that we already have. In 
here, let's go on the Index page. And we do not  
38:16 - have any tag helpers associated inside here. But 
if we go on underscore layout, there should be  
38:22 - plenty of tag helpers. Right here you can see the 
tag helpers ASP area and ASP page. When we have to  
38:31 - redirect to any of the razor pages, we will use 
the tag helper ASP page, and then we'll define  
38:38 - the path. Right here we want to go to the Index 
page which is inside the pages folder. Hence,  
38:45 - we have defined forward slash index. Then if you 
scroll down with more navigations, we again have  
38:52 - those tag helpers. If you scroll down further, 
right here, we have another tag helper. And with  
39:00 - the script, we have the ASP up and version tag 
helper. We will be using more tag helpers for  
39:07 - labels, forms and all of the buttons. But we'll do 
that when we proceed. But the main thing about tag  
39:15 - helpers is you can use your regular HTML tag. And 
you can just append a tag helper like you can with  
39:22 - other JavaScript frameworks. Also, I want to show 
you few similarities that we have between the HTML  
39:29 - helpers and tag helpers. Both HTML helpers and tag 
helpers performed the same functionality. But here  
39:38 - you can see that the label tag is so not HTML 
friendly for HTML helper. But when you use tag  
39:45 - helper, you'll be using the same label tag class 
attributes. All you have to do is add ASP for  
39:52 - tag helper. If you do not understand all of this 
right now, do not worry as we proceed and start  
39:59 - coding This was start to make much more sense. 
In classic ASP dotnet core in the system dot web  
40:08 - assembly took care of starting the application, 
and global dot ASX had the methods in which you  
40:15 - could provide custom logic. The steps needed 
to start up an application are now determined  
40:22 - by you. And that starts with the program class 
file. The program class contains a main method,  
40:29 - which is the entry point for the application. 
When the runtime executes the application,  
40:37 - it looks for this main method and calls it most 
dotnet applications startup using the main method.  
40:45 - The application initially starts as a command 
line application, the main method configures,  
40:53 - ASP, dotnet. Core, and start. So let's switch 
back to the application and take a look at this.  
41:00 - So right here, we'll go to Solution Explorer, and 
we have the program.cs. In here you see we have a  
41:09 - main method. Here, the configuration is done by 
calling create host builder, which is a method  
41:17 - in the program class that returns I host builder 
on that object build and run is called. And from  
41:26 - that point onwards, this application has become an 
ASP dotnet core application. Create host builder  
41:34 - calls create default builder on a static web host 
class, that configures the web host using default.  
41:44 - It deals with the configuration on how ASP. NET 
Core deals with web server configuration files,  
41:52 - routing, and so on. You can see on top of the 
default configuration, done by the Create default  
42:00 - builder to web builder is also configured to use 
a startup class file. And if you go on the startup  
42:07 - class file by pressing F 12 here, or you can go to 
Solution Explorer startup class file. Right here  
42:15 - you can see startup class is a simple class not 
deriving from any other class. The runtime will by  
42:23 - convention, call two methods here. First is the 
configured services. And we have the Configure  
42:30 - method. Let's take a look at both of them and the 
startup class file in the next video. As we saw in  
42:38 - the previous clip, the runtime executes main which 
among other things, configures, the startup class,  
42:45 - the runtime will call methods configure services 
at Configure. Here we have an icon figuration  
42:53 - object that is being passed as dependency 
injection to the startup class. Here with the  
42:59 - Configure services it is written, this method gets 
called by runtime, it is used to add services to  
43:07 - the container. The purpose of configure services 
method is to configure dependency injection,  
43:14 - dependency injection in classic ASP dotnet 
was optional. In ASP. NET Core, it forms an  
43:22 - integral part of the ASP. NET itself. This method 
add services to the application to make them  
43:30 - available, you get the service collection object 
that is injected into the matter as parameter. Now  
43:38 - you can use this to build on the services that 
will be available to this application. Examples  
43:46 - of the services would be Entity Framework, core 
Identity Service, MVC, and many more. By default,  
43:54 - you will have the Add razor pages available, 
you will not have the razor compilation here.  
44:00 - So do not worry, it should look like this, you 
will only have the Add razor pages. And this is  
44:07 - because when we created the project, we selected 
that we want the razor pages. The other method  
44:14 - is the Configure method. And here this method 
is used to configure the HTTP request pipeline.  
44:21 - The pipeline specifies how the application should 
respond to HTTP requests. pipeline is composed of  
44:29 - individual parts called middleware. Let me switch 
to a presentation to explain that better. Now, in  
44:36 - any general scenario, what we will have is we will 
have a browser and then we will have a pipeline in  
44:43 - which we will make a request and we will get back 
a response. The individual parts that make up a  
44:49 - pipeline are called middlewares. Let's consider 
a few of the middlewares that we can add in a  
44:55 - pipeline. One of them can be MVC, and then we You 
can also add authentication and static files. You  
45:04 - should notice that when we add authentication 
middleware, it should be done before we add MVC.  
45:09 - And the order is important. The reason is we do 
not want to load MVC and then find out that user  
45:17 - is not authenticated. We also have to configure 
a middleware for static files in our project,  
45:24 - like HTML files, images, CSS, or JavaScript files. 
Now when the data travels through the pipeline,  
45:33 - it gets manipulated by individual middlewares. And 
so does the response or the result. Let's take a  
45:41 - look at a 10,000 foot image of what happens 
when this request is made in the next video.  
45:47 - So when the request is made from the browser, it 
first arrives at a web server like a yes is will  
45:57 - then invoke the dotnet runtime, which would load 
the CLR and then look for an entry point in your  
46:04 - application. It will find that in the main method 
of the program class and execute it, which starts  
46:13 - the internal web server in your application, 
we will have cash rule in our application,  
46:19 - the main method and the startup class would 
configure the application and the request would be  
46:26 - routed from is to cash flow, and then it will be 
pushed to the application. After that it will be  
46:35 - processed by all the middlewares and the generated 
response will be routed back to the cached role,  
46:41 - which will route it back to the is that will 
finally produce the response on the browser.  
46:48 - This is much more efficient than the old 
system dark web approach. Classic system  
46:55 - relied heavily on system dot web, which was 
tied to IIS. But using a pipeline approach,  
47:03 - we only plug in the middlewares that we need. 
Everything we plug in is in a separate assembly  
47:10 - exposed in a new get. Now since system ductwork 
was tied to is and is is tied to Windows, that  
47:19 - is the reason you cannot run classic ASP dotnet 
on other web servers, then IIS and Windows. Now  
47:28 - since that is no longer the case, ASP dotnet core 
applications can be run on web servers and other  
47:36 - operating systems. One thing you should keep in 
mind is that there are two web servers. One is  
47:42 - external like IAS or Apache or Linux. And that 
is also an internal web server hosted by your  
47:51 - application request from the external web server 
are passed to the internal web server and other  
48:00 - way around. You can choose different internal web 
server, but most common is cashkaro. Since it has  
48:08 - first class support in ASP dotnet core. Cash Flow 
is a lightweight web server which can only execute  
48:16 - a request. Because of age, you need external web 
server to configure other options like security,  
48:23 - hashing, and so on. This was a brief overview on 
how middleware and pipeline comes to the picture.  
48:32 - Let me switch back to the application that we were 
looking at an inside the Configure method. You can  
48:40 - see we have plugged in multiple middlewares 
using App and then the middleware name,  
48:45 - we check if it is development, we want to 
use the developer exception page or else we  
48:52 - want to use just a generic error page. Then 
we have the HTTPS redirection middleware,  
48:59 - we have the middleware for static files. Because 
of the static files middleware, we will be able  
49:06 - to use the CSS JavaScript and images that we will 
add inside the WW root folder. Then we have the  
49:15 - app dot use routing. And then we have app dot use 
authorization. Finally, we have used endpoints  
49:22 - with dotnet. Core three, they have introduced 
endpoint routing, in which you can configure  
49:28 - multiple routes. We will understand why we need 
this and we can configure more than one endpoints  
49:35 - here for different technologies, which we will see 
in upcoming videos. But right now the main thing  
49:42 - to consider is you can see how we are plugging 
in different middlewares. Now we have used the  
49:49 - terminology middleware quite a few times. So let's 
actually understand what middlewares are. Now that  
49:58 - we have seen the overview of how Application 
flow. Let's understand middlewares and pipeline  
50:04 - in much more detail. Whenever an HTTP request 
comes in, something must handle that request.  
50:11 - So it eventually results in an HTTP response. 
Those pieces of code that handles the request  
50:19 - and results in a response make up the request 
pipeline, what we can do is configure this request  
50:27 - pipeline by adding middlewares, which are software 
components that are assembled into an application  
50:34 - pipeline to handle request and response. So 
typically, a browser is going to send a request  
50:43 - to your server. And that request is going to 
be interpreted by the server, and handled by  
50:50 - some piece of software. Now first, that request is 
attached to something called as the context object  
50:58 - as a part of software that manages this context. 
In our case, it would be ASP. NET Core middleware,  
51:07 - you can essentially Think of it as a pipeline, 
which is a series of pipes, that is going to  
51:14 - determine what is going to happen to the context. 
So first, the request is passed along the first  
51:22 - pipe, and the first pipe interprets the context 
and checks out the request and determines if there  
51:29 - is some type of response needed and attach that 
to the context. If there is no immediate response  
51:37 - that should be handed back to the server, then the 
context is simply passed along to the next pipe in  
51:44 - the pipeline. This continues, again to the next 
piece of middleware, whatever it might be, and it  
51:52 - goes on till it reaches the very last pipe. Now, 
it is also possible that at end of the pipeline,  
52:00 - no response has been found. And that will cause 
a 404, not found and written back to whoever  
52:07 - originated the request. However, it is possible 
that in any one or more of these middlewares,  
52:14 - there may be a response that needs to be passed 
back. And it could happen in any of the pipes.  
52:21 - So sometimes it could happen that middleware 
would not pass the context along the next piece,  
52:28 - but rather says, Okay, I have a response 
that I need to send back. But typically,  
52:34 - your context will go all the way through 
the pipeline to the end, by the last piece  
52:39 - of middleware sends a response, which gets back 
through the pipeline to the server, and then the  
52:46 - server sends back the response to the browser. 
This is a very simplified version of how request  
52:54 - works. Let me just walk you through that, again, 
in a brief overview so that this makes complete  
53:00 - sense. When the request comes in to the server. 
The server then accesses the dotnet core framework  
53:08 - and puts the request into a context object, the 
context gets passed along to the middlewares. And  
53:15 - if a middleware has a response anywhere along 
the way, then it will attach that response to  
53:22 - the context object, and then pass that context 
object back through the pipeline to the server,  
53:29 - and then the server sends back the response to the 
browser. Now keep in mind, the order of pipeline  
53:36 - is important. It always gets past from the first 
to the last. A good example will be authentication  
53:44 - middleware. If the middleware component finds the 
request is an authorized, it will not pass it to  
53:51 - the next piece of the middleware, but it will 
immediately return an unauthorized response. It  
53:58 - is hence important that authentication middleware 
is added before other components that shouldn't  
54:05 - be triggered. In case of an unauthorized request. 
We will be adding more middlewares in our project,  
54:13 - but we'll do them as we face the requirement for 
that. Another file that we have in our project is  
54:21 - app settings dot JSON. All of the application 
settings are contained in this file. And any  
54:29 - changes to the app settings dot JSON file will 
require restarting of the IIS administration to  
54:36 - take effect. Let's switch back to the application 
and take a look at this file. So if we go here,  
54:43 - we have the app settings dot JSON file. In 
here right now you see we only have logging  
54:49 - we have log level and few other details. We will 
be adding more settings here for connection string  
54:56 - and also if you add new other data details like 
maybe something related to dependency if there  
55:03 - are some security keys or anything, you can also 
add them here. You can also store them remotely  
55:10 - on a server. But app settings is generally a 
place where you have them when you're initially  
55:15 - developing. In the future videos, we will be 
adding more settings here like connection strings,  
55:21 - and we'll be accessing this variables inside 
the startup class file when we use dependency  
55:28 - injection. So that's the brief overview of the 
app settings dot JSON file. ASP. NET Core supports  
55:36 - dependency injection software design pattern, 
which is a technique for achieving inversion of  
55:43 - control between classes and their dependencies. 
Now, you might be wondering what is IOC or  
55:51 - inversion of control container. IOC container is 
a framework for implementing automatic dependency  
55:59 - injection. It manages object creation and 
its lifetime and also injects dependencies  
56:07 - to their class. IOC container creates an object 
of the specified class and also inject all of the  
56:16 - dependency objects through constructor property or 
method at runtime, and disposes it at appropriate  
56:24 - time. This is done so that we do not have to 
create and manage the objects manually. Support  
56:32 - for dependency injection is built into ASP dotnet 
core. In ASP dotnet core, both framework services  
56:41 - and application services can be injected into 
your classes, rather than being tightly coupled.  
56:49 - dependency injection is a design pattern in 
which a class or object has its dependent classes  
56:58 - injected, rather than creating them directly. 
dependency injection can help developers decouple  
57:06 - the different pieces of their application. Let's 
try to see this with an example. We have Bob here  
57:13 - who has been thinking about going on hiking. So 
he makes a list of all the supplies like maps,  
57:20 - flashlights, protein bars, etc, and puts them in 
a backpack. Now next day, when he goes on hiking,  
57:28 - he takes the backpack with him. This pack acts 
as a container. So during the hike, whenever he  
57:36 - needs anything, he takes it out of the container 
and uses them. This is the simple concept that  
57:43 - you put items you will need in a container. And 
when you need them, it already exists inside a  
57:50 - container. Let's understand this in a way that 
is more related to coding. Let's imagine our  
57:59 - application have three pages. And in each page, we 
will need three functionalities, we need to lock  
58:06 - something we need to send email, and we need to 
save something to our database. So we will need  
58:13 - to create objects of these functions. In classic 
days, we'll be creating objects of email, database  
58:21 - and logger in the first page, then we will do the 
same in the second page, and so on. But this is  
58:30 - different with dependency injection. Let's take 
a look at that. With dependency injection. Again,  
58:37 - we have the same three pages, and we want the 
same three functionalities or the classes,  
58:43 - we have a dependency injection container, what we 
will do is we will register all the three classes  
58:51 - inside our container. Whenever any page will need 
anything, we will directly extracted from that  
58:58 - container. Rather than creating the new object in 
individual pages. It is created and registered in  
59:06 - the container, we only have to use this. This way 
container deals with creating, registering and  
59:14 - disposing of the objects rather than creating them 
in every page. This is how efficient dependency  
59:22 - injection is compared to the classic approach. Now 
that our project is created in this section, we  
59:30 - will start building all the functionalities in our 
project, we will first add the model that we want  
59:36 - to and push it to database. After that we will 
perform CRUD operations on book list. With that we  
59:44 - will complete our project with the razor pages and 
you will see how everything comes to picture. So  
59:52 - let's get started with all of that from the next 
video. In this video, we will be installing Our  
60:00 - first nougat package. So for that, let me run the 
application and show you why we need that package.  
60:07 - So when you hit the Run button, it will load 
our website. And you can see the default layout  
60:15 - that we have. We have a homepage and a privacy 
page. Let's go to our home razor page and edit  
60:23 - this text. So for that, we'll switch back to our 
application. And we'll go to Solution Explorer,  
60:31 - all of the pages will be inside the pages folder. 
When we double click on index dot CSS, HTML, and  
60:39 - right here, while the application is running, with 
an add my name, plug in here, save it, go back and  
60:47 - refresh. You can see the refresh was successful, 
but the content here did not change. This was an  
60:56 - existing feature before ASP dotnet core three. 
But with three, they have decided to add this  
61:03 - auto refresh for the view as a separate package. 
So we'll stop the application, we'll go to Tools,  
61:11 - nougat package manager, and manage nougat 
packages for solution. Inside the Browse tab,  
61:19 - we will search for Microsoft dot ASP NET Core dot 
MVC dot razor dot runtime compiled nation, we have  
61:29 - to install this package inside our booklists to 
raise our project will accept this. And once the  
61:38 - installation is complete, we need to make one 
change inside our startup.cs class file. And  
61:44 - we have the Configure services method. In here, 
while we have the dot add razor pages, we will  
61:52 - have dot add razor runtime compiler nation. After 
you add this line, if you press f5 or hit the Run  
62:02 - button here, it will load the website again. And 
the content will be welcome again right now. Let's  
62:09 - see that perfect. Let's switch back. Let's go back 
to our index and remove again. And let's refresh  
62:17 - the page. And this time, it should automatically 
reload and it should display welcome. Great,  
62:25 - you can see that in action. And with this whenever 
you will change anything inside the razor UI.  
62:32 - And you come back here while the application is 
running, and refresh, this should automatically  
62:39 - refresh. This is one of a core package that is 
needed for developers. Because we are many times  
62:46 - dealing with the view, we make changes, we come 
back and we want to see the change rather than  
62:52 - restarting the application. In this video, what we 
will do is we will be adding our first model. Now  
63:01 - models represents any table that you want in your 
database. In this project, what we want to do is  
63:08 - we want to manage a list of books so far that we 
will add a model or a table called book. In order  
63:17 - to do that, in our project, we'll write like add, 
let's add a new folder to separate things out. And  
63:23 - we'll call this model. Inside here. We'll right 
click, add a new class file. And we'll call this  
63:31 - book. Then in here, we will add few properties. 
First, we'll be the ID. So we'll say prop. This  
63:40 - will be an integer ID, this will be a unique key. 
So we can add a data annotation by typing key. And  
63:48 - if we do control dot here, you'll see using system 
dot component model data annotation, what key will  
63:57 - do is it will automatically add ID as an identity 
column. So that way we do not have to pass the  
64:03 - value, it will create an ID value automatically. 
Along with ID we also want name of the book. So we  
64:12 - do prop screen and name. Then we want the author. 
So we'll do prop again, prompt is a snippet for  
64:21 - property. So if you type prop and hit Tab twice, 
it will automatically create a property. We'll  
64:28 - call this as author. And let's make a string. Now 
for name I want to display book name. so far that  
64:38 - we have a display attribute and we also have a 
required data annotation. Let's try the required  
64:45 - first when we do required This means that name 
cannot be no the display data annotation I will  
64:52 - add it as we proceed with the course. So this 
looks good for my book and these three properties  
64:58 - should be sufficient Once we have created this 
book, next thing is to add this to database. For  
65:06 - that, we have to add few packages for Entity 
Framework. And we have to set up connection  
65:12 - string. Let's do that in the next video. Now that 
we have added a book model inside our project,  
65:20 - we need to set up the database. In order to set 
up the database, we need few packages. So we'll  
65:28 - go to Tools, nougat package manager, and package 
manager solution. Here, the first package we want  
65:35 - is Microsoft dot Entity Framework core, we'll 
select this, the version is three dot o looks  
65:42 - good, that's installed this. These are all the 
Entity Framework packages that we are needing,  
65:49 - because we'll be using Entity Framework to Access 
database. After this, we need that SQL Server.  
65:56 - So we'll search for that. And we'll be using SQL 
Server. So we'll add this package as well. And the  
66:07 - final package that we'll need is Entity Framework 
core dot tools. And this is required because we'll  
66:14 - be running migrations, I will explain you in 
the next video what exactly migrations are,  
66:20 - so don't worry, but these are the three packages 
that you need. If you remove and close this,  
66:26 - your application should have this four 
packages right now. Okay, so with this,  
66:34 - we have installed all the necessary packages. 
Now we need to set up our connection string.  
66:40 - Let's go to SQL Server real quick. And in here, 
when you try to connect, you need a server name,  
66:47 - the server name that you see right here, local DB 
in bracket backward slash MS SQL local dB. This  
66:55 - is the default server name that SQL server has. 
So right here, we'll use this in our connection  
67:02 - string. So let me just go back. And the connection 
string that we'll be adding will be inside app  
67:08 - settings dot JSON, as I explained before, so 
for connection string right here before logging,  
67:15 - let me just paste that. This is what you need 
to write. It will be connection strings with a  
67:21 - plural s at the end. And we'll set up a default 
connection, you can give default connection, any  
67:28 - other name that you want. Then for the CRN world, 
we have the exact server name that we see inside  
67:35 - SQL Server, make sure this is aligned. And also 
try to connect. Once you connect. This means that  
67:42 - this server name is valid. After that, you can use 
the same server name here. Then for the database,  
67:49 - we'll create a new database called vocalist 
raiser, make sure that you do not create that  
67:56 - database automatically from SQL Server, we will be 
doing that using Visual Studio. So right now you  
68:04 - see we do not have published razor database here. 
We'll go back we have the trusted connection true,  
68:11 - and we have the multiple active results adds to 
true, I will be pasting this exact string with  
68:18 - the lecture as well, so that you don't have to 
waste time to type this manually. But make sure  
68:23 - the server name is valid with what you have. 
Once the connection string is in app settings  
68:29 - dot JSON. Next thing we have to do is we have 
to configure our startup class file. And let's  
68:36 - do the configuration and brand migrations in 
the next video. Now that we have the connection  
68:43 - string inside app settings dot JSON, it's time 
to configure our configured services with Entity  
68:49 - Framework. In order to configure that we need an 
application DB context or a DB context class. So  
68:58 - that class we can add inside Solution Explorer 
model, right click Add a new class. We'll call  
69:05 - this class application DB context. Let's add this. 
Now the application DB context should inherit  
69:13 - from DB context class, which is a class inside 
Microsoft dot Entity Framework core. After this,  
69:21 - we need to implement the constructor. And we 
have to pass the DB context options to the  
69:28 - parent class. So for constructor we have a snippet 
called CTR, and we'll press Tab twice. Right here,  
69:36 - we have to pass the DB context options. And in 
here, we need the application DB context. We'll  
69:44 - call this options. This will have to pass to the 
base and we'll pass the options here. This is an  
69:53 - empty constructor but the parameter is needed 
for dependency injection. Once we have that,  
69:58 - then we need to Add the book model that we added 
to our database. In order to add any model to the  
70:05 - database inside the DB context, you need an entry, 
we will do public and this will be DB set of type  
70:14 - book. And let's call this property to blog as 
well. Once you add this, the last thing that  
70:21 - you have to do is add the DB context inside 
startup.cs. So inside startup.cs, we have to  
70:29 - add the DB context to our pipeline. So we'll say 
services dot add DB context. And right here, we  
70:38 - have to pass our class name, which is application 
DB context, we'll do our control dot here. And  
70:45 - we need to pass the options with connection 
string. So we'll say options dot use SQL Server,  
70:54 - we'll have to do a control dot here. And the use 
SQL Server we added as a nougat package. In here,  
71:03 - we need to pass the connection string from 
our app settings dot JSON. So for that,  
71:09 - we can use the configuration object that we have. 
So we'll just say configuration.in. Here, we have  
71:17 - to get connection string. And we need to pass 
the name that we used for our connection string,  
71:23 - which is default connection. We'll copy this, and 
we'll pass this in a string notation like this.  
71:30 - So this was the configuration that we had to do to 
include Entity Framework inside the configuration  
71:38 - pipeline. Once you have this, all you have to do 
is you need to push this to database. So for that,  
71:46 - we'll go to Tools new get package manager, this 
time, we'll be going to package manager console.  
71:52 - And in here, the project name, it should be 
published razor, we'll type the command add  
71:59 - migration, and we will add a meaningful name. What 
we are doing right now is add book to database or  
72:08 - DB will press Enter. And what add migration 
will do is it will create a script that will  
72:15 - be executed across the database. The script has 
been created right here you see what the script  
72:22 - is doing is it is automatically creating a table 
called book. And it is adding the columns ID name  
72:30 - and author. It is also making sure ID nullable 
is false. And name nullable is false. Author  
72:37 - nullable is true, because if we go, we do not 
have any required attribute with otter. Since  
72:44 - it is a key it knows that it is not nullable 
in the constraint, it is also adding primary  
72:50 - key for the table. And in the annotation. It is 
making sure that ID is identity column. So this  
72:58 - is the perfect script that is needed to create 
the book table. Now right now only script has  
73:05 - been created with the Add migration command. How 
do we actually create the database and create  
73:11 - the table. For that we have a command called 
update database. Once you hit update database,  
73:19 - it will check if the database exists. If it does 
not, it will create the database. And it will  
73:26 - also push the migrations. Once the update database 
command completes successfully, you can go back to  
73:33 - your SQL Server and to the database. Let's refresh 
it. Right now if you expand this and go on tables,  
73:43 - you see we have the book table that has 
been created. And if you do select up 1000,  
73:49 - you will see the three columns. Perfect. So with 
this, we created our database. And we also added  
73:56 - the book table with the properties that we wanted. 
Now the purpose of this course is to perform CRUD  
74:04 - operations on this book object. So for that we 
need pages to create a new book, edit a new book,  
74:11 - delete a book, and also view all of the books that 
are available. So we'll go to Solution Explorer.  
74:18 - And inside pages, we have the Index page and 
few other pages. All of the book pages. Let me  
74:26 - add this in a new folder. And we'll call this 
book vest. In here let me add a new razor page.  
74:34 - So what you have to do is right click Add and 
will add a razor page. We will go with the empty  
74:42 - razor page because going with this will solve our 
problems, but we will not know what was done. So  
74:49 - we'll go with the empty razor page. And let's call 
this index. What are all the options here? First  
74:56 - option is to create a page model class. As you 
saw with the Index page, here, we have index page  
75:03 - as well as page model, we need a page model class 
because we need to populate all of the books from  
75:10 - the database and pass that to the page to display 
it. So that's why we'll need that, then this won't  
75:18 - be a partial view, a partial view is something 
which is a small subsection, like maybe group of  
75:23 - buttons that you want to reuse in multiple places 
in your website. But this is a complete page. So  
75:31 - that won't be a partial view. And we will use our 
layout page because that is the master page. And  
75:37 - we want to be consistent. So with this, let's add 
this. One drawback that I see with the razor pages  
75:48 - is when we will be adding index pages, it might 
get confusing, because you see we have a master  
75:54 - index page. Inside vocalist, we have another 
index page. So whenever you are working, make  
76:01 - sure you are working on the correct index page. 
At this time, we'll be working on index an index  
76:08 - page model inside the book list. So if you have 
any other pages open, you can close them. Inside  
76:17 - the Index page, what we want to do is we want to 
retrieve all of the books from the database. So  
76:23 - for that, we need the application DB context. 
Whenever you have to deal with the database,  
76:29 - you will need the application DB context. When you 
added the application DB context right here in the  
76:37 - services, that means that you have added it to the 
pipeline. Once you have added it as a pipeline,  
76:44 - you can use them using dependency injection. So we 
need an object of application DB context, what you  
76:52 - will do is use a private read only application DB 
context. And let's call this underscore dB. Now we  
77:05 - need to initiate our constructor. So we'll type 
CT or our tab tab. And right here, we will get  
77:13 - the application DB context dB. This application DB 
context we are getting using dependency injection.  
77:21 - So right here, we'll say underscore DB is equal 
to dB. This way, you can extract the application  
77:29 - DB context that is inside the dependency injection 
container and injected onto this page. If you did  
77:38 - not have dependency injection, what you would have 
to do is you would have to create a new object.  
77:43 - And then once you are done with that, you'll have 
to dispose that and all the other things. With  
77:49 - dependency injection, you do not have to worry 
about anything. Now what we want to do is we  
77:55 - want to return a list or an ienumerable of book. 
So we'll say public I enumerable. of book. Let's  
78:05 - call this books, we'll have the getter and setter, 
what we will do is we'll assign this books,  
78:13 - all of the books from the database. How do we 
get that it's way too simple. Because we're using  
78:19 - Entity Framework. We'll use a weight here. And 
we'll say underscore DB dot books, you can see it  
78:27 - already has the book. And we have a method here, 
which is to list and we'll call the async method,  
78:34 - we'll have to do a Ctrl Dart for the async to 
use Entity Framework core. Now when you are using  
78:42 - async and await rather than why you will have to 
use async task. What we are doing here is we are  
78:52 - going to database and retrieving all of the books 
storing that inside the I enumerable. And we are  
78:59 - doing that inside the get handler. So when we 
go inside the view here, we will already have  
79:05 - the list of books available to display. All you 
did was right here, you extracted that and it is  
79:11 - already available inside your view to display. 
Now one thing to notice is right now I'm using  
79:18 - await and async. What async does, this is a basic 
C sharp explanation and not related to dotnet  
79:25 - core. So I won't be going into much details. But 
async will basically let you run multiple tasks  
79:32 - at a time until it is awaited. Right here we need 
to await because we need to assign all the books  
79:38 - that we found. But the method that we have is also 
a sink and task. So this was all you had to do for  
79:47 - the get handler. Again, if it was MVC this would 
be action methods, but with razor pages inside  
79:54 - the page model. We have handlers in the next week. 
Do let's write some code here and see the list of  
80:03 - books. Now that we have added the get handler 
method for the Index page inside book list,  
80:11 - it's time to add some UI. Here, the first thing 
we'll do is we'll go to Solution Explorer. And  
80:18 - we'll go to our master page, which is underscored 
layout. We have home and privacy, that may add a  
80:25 - book tab in place of privacy. And for that, 
we have to change the ASB page. So for that,  
80:32 - rather than privacy, we will have foreclosed 
forward slash index. And if you save this,  
80:39 - let's run our application. Once you click on this, 
it should load the Index page. In order to see the  
80:47 - difference, you have to go here and let me type 
index book save this. And let's click on the  
80:54 - book. Perfect, you can see the page is loaded. So 
with this, you can see inside underscore layout,  
81:02 - how you had to manipulate the routing for the ASP 
page tag helpers. If you want to access something  
81:10 - inside the book list, you have to write the book 
list name, followed by the page that we have,  
81:16 - which is the Index page, then we can keep 
this application running, we can go to index,  
81:22 - and we'll design this. So we'll just remove this, 
let me add br, then let me just remove this index,  
81:31 - and we'll start designing this page. We also 
do not need the view data, we can remove that,  
81:37 - we'll add a br and we'll add a div give it a class 
of container. These are the bootstrap classes row,  
81:45 - padding zero and margin zero. Within this first 
container, I'll add a div give it a class of  
81:53 - column 10. And I'll also add another div give it a 
class of column two. If you are not familiar with  
82:00 - bootstrap, bootstrap divides a row into 12 equal 
columns. So that's why I'm dividing one column  
82:08 - inside two separate columns. First will occupy 
10 columns, and the next one will be the rest  
82:14 - two columns. Inside here, I'll use edge to give 
it a bootstrap class of text info for a bluish  
82:22 - color. And we're display Polk vest. In here, we 
will add an anchor tag. And we'll give it a class  
82:31 - of btn btn. info, and form control. These are all 
bootstrap classes. And let's say create new book.  
82:44 - Let's save this. Let's go back and refresh the 
page. Perfect. This is coming along good. Let me  
82:51 - increase the size here. So we can do column three. 
And we'll have to make it column nine. Perfect,  
82:58 - this is good. We'll just make it text white 
here. So right here, we can do text white. Okay,  
83:08 - this looks good. Now what we want to do is we want 
to display a table with all of the books. Let's  
83:15 - continue working on the designing in the next 
video. Let's continue working on the designing  
83:22 - right now we have the Create new book. But when 
we click nothing happens, and that is because we  
83:28 - have not used any tag helpers on where it should 
redirect. We'll do that in while after this column  
83:36 - nine and column three. Let me add another div 
give it a class of column 12. We'll give it a  
83:43 - border padding three and margin top of three or 
bootstrap classes. And we'll add a form here,  
83:50 - give it a method of post. Within this form, we 
want to display this only if books exist inside  
83:58 - the table. So we can use razor syntax here like 
if else condition. For that you need add sign.  
84:06 - And then you can use C sharp syntax like if and 
we want to check if there are any books that are  
84:13 - returned from this get method. You can see inside 
the page model we have the ienumerable as book.  
84:21 - So inside the razor page, you can say model with 
a capital M dot. Right here you can see books is  
84:29 - available. This is the same box that is being 
passed from the get handler right here. So we  
84:36 - can check if model dot books dot count. If this is 
greater than zero, then we will display a table.  
84:43 - Else we will display a paragraph and say no books 
available. Let's save this. Let's go back and  
84:54 - refresh and we should see no books available. 
Now in order to see some books right now we  
85:01 - do not have the Create book page. So let's go to 
database and hack some things. We'll right click  
85:07 - on the book at the top 100. Let me do one, one, 
and any of the dummy record, we'll come back here,  
85:15 - and we'll refresh and that message is gone. And 
that is because it retrieved one book that we just  
85:22 - added. So how do we display that? Right here, we 
will have to add a table inside the if condition.  
85:30 - So we'll add table give it bootstrap classes of 
table, table striped, and water. Within here,  
85:40 - we'll add a tr give it a class of table secondary. 
And we will add a th for the table heading. Here,  
85:49 - we will use the label tag helper and the tag 
helper we have is ASP for we will go to our  
85:56 - books. And in here, we want the first or default, 
because the label we want for only one record. And  
86:03 - we'll say dot name. So this is how you can use tag 
helper. You can also use HTML helper for the same  
86:12 - thing. Let me show you that for the author. So the 
syntax for HTML helper was pretty weird. So it was  
86:21 - HTML dot display name for and in here, you will 
have to use the lambda expression m goes to m dot  
86:29 - books dot first dot default dot author. Now you 
can see how tag helpers have made this extremely  
86:37 - simple. It is the existing label tag, all you did 
was add a SP four. So that's why tag helpers are  
86:46 - preferred over HTML helpers. But HTML helpers are 
still there for some functionalities, which you  
86:53 - have to write custom tag helpers for. And I will 
show you that in just a while. Once you have this,  
87:00 - let me add a th here. And I will comment this code 
out. But I will leave there for reference. I will  
87:07 - copy this and paste it here for author. So this 
was the table header, we will add an empty th tag.  
87:16 - After this we want all of the records. So for that 
we need a for each loop. How do we get a for each  
87:24 - loop inside the view? Again, the answer is add 
sign. And then we have the for each which is a  
87:31 - C sharp syntax, we'll say variable item in model 
with a capital M dot books. So for all of the  
87:41 - books that we have, we will have item and we will 
display a table row here. So we will add a tr tag  
87:49 - and inside the TD we want to display the value. 
Now in this case, we do not have a tag helper,  
87:57 - but we have an HTML helper. The HTML helper 
is HTML dot display for in here, we'll have  
88:05 - to use link m goes to item.we want to display the 
name, we do not have an equivalent tag helper for  
88:15 - display for of course, you can write a custom 
tag helper that can do the exact same thing.  
88:20 - But that is beyond the scope for this project. So 
we can just use the HTML helper. We can copy this  
88:29 - and we'll paste it again for author. Let me save 
this. Let's go back and refresh. And we should see  
88:38 - our record. Perfect. This was so easy. Now this 
is not aligned. So we can do Ctrl A Ctrl KD to  
88:48 - align everything that we have. Last thing that I 
want is in here, I want buttons to edit or delete  
88:55 - a book. So after this TD, and we'll add another 
TD and ever give button, give it a class. Give it  
89:06 - a class of btn btn danger, and btn small these 
are all bootstrap classes. And I will display  
89:15 - delete. After the delete button, we need a link 
to redirect to the Edit page. So for that, we'll  
89:23 - use the anchor tag. And we'll give it a class 
of btn btn success 10 we'll do btn small here,  
89:34 - this will be added. Let me save this and refresh. 
And great this is good. We will not worry about  
89:42 - designing much things here. But this looks good. 
In delete. I'll just do text white so that it  
89:50 - is aligned with the Delete. So with this we have 
almost completed the Index page but we will come  
89:57 - back here later. Now The last thing that I want to 
do on index page for this video is on create book,  
90:04 - I want to add a link so that it redirects me to a 
create razor page. So for that right here, inside  
90:13 - the Create new book, you will need a tag helper, 
the tag helper we have seen before in underscore  
90:20 - layout, it is ASP page, what page do we want to 
redirect to that will be a Create Page. Now you do  
90:29 - not have to mention here that the Create Page will 
be inside book list. Because if you are in the  
90:34 - same folder, you can directly write the page name. 
That being said, let's add the Create Page in the  
90:42 - next video. In this video, we will be adding the 
Create razor page. So let me stop the application,  
90:50 - we'll go to Solution Explorer, inside the 
booklet will write like add a razor page. Again,  
90:58 - it will be the basic one. And we'll say create 
here, it won't be a partial view. Let's add this.  
91:05 - Now with the Create Page when the page will 
be loaded to we want to display any data. No,  
91:11 - we just want to display textbox. So user can enter 
a book name and an author. So for that right here,  
91:19 - we will again need the application DB context, not 
for the get handler. But when we hit the Create  
91:26 - button, we need to save it to our database. So we 
will just do that while we are here. So we'll say  
91:34 - private read only application DB context, we'll do 
a ctrl.to add model. And we'll have underscore dB.  
91:44 - We need constructor. So CTR tab tab will get the 
application DB context dB, then underscore DB is  
91:54 - equal to dB. Now inside the get method, we need 
to display text boxes to write the author name  
92:01 - and the book name, what will be the model. So that 
will be public book, let me call that book, we'll  
92:10 - have the getter and setter. On get we do not have 
to write that we will be passing this empty book  
92:16 - object, it does that automatically. So inside the 
Create view, you will be able to access this book  
92:24 - and display labels as well as text boxes. Before 
we do that in the next video. Many times it's  
92:31 - a common situation that you start with a model 
and then you feel no I need one more property,  
92:37 - or they are like Whoops, I need to rename this. 
So for that what we will do is right here, let's  
92:44 - imagine we have to add a new property called isbm. 
So we'll write the new property is b n. And let's  
92:53 - have a getter and setter. Once you add a property 
since you change something in the model here, you  
93:00 - have to add a new migration. So we'll go to Tools 
nougat package manager, package manager console  
93:07 - will right add migration, add ESPN to book model, 
always try to name your migration as meaningful as  
93:19 - possible. For effect, you can see it is adding a 
new column. And all you do is update database. So  
93:29 - this way inside your table, a new column will be 
added. If you go back now, and if you do select  
93:36 - top 1000 you can see I ESPN has been added, which 
is no this looks great. And now we know how we can  
93:45 - make changes to a model that we have already 
added. We'll have to change our index for the  
93:52 - same. I'll just copy this and paste it one more 
time or turn off the display for here we'll have  
94:00 - the iasb n. And we'll do the same for HTML helper. 
Perfect. So these are all the changes that were  
94:10 - needed. In the next video. Let's design the Create 
Page and see everything in action. In this video,  
94:21 - we will start designing the Create razor page. We 
will remove all of these things. We'll add a br  
94:28 - we'll give it a heading here, give it a class 
of text info. And let me display create a new  
94:37 - book followed by a br. Now let me just paste some 
bootstrap styling that we have I aligned this. All  
94:46 - I did was I added a div give it a class of border 
and container and some style with padding. Then I  
94:54 - added a form and in that form I have a div with 
class of form group and row Inside that row, I  
95:01 - have divided this into two parts, column two, and 
column six. Let me make it column four, and column  
95:10 - six. That should be okay. Even though the total 
should add up to 12, you can leave it like this.  
95:16 - Once you have the same designing, what we will do 
is within the form, we will add method of post,  
95:24 - because when we hit the Create button, we will be 
posting data back to our page handler. Within the  
95:31 - column for we want to display label. So we'll do 
label and ESB for this will be for book.we have  
95:41 - the name. After that we have column six here, we 
want a text box. So we'll say input, we'll use the  
95:49 - tag helper ESP for this is for book dot name. And 
we'll give it a class of form control. You can see  
95:58 - how easy the binding is with the tag helpers, you 
do not need to worry about anything in the post  
96:04 - book dot name will have the value that user enters 
inside this text box. So let me just copy this and  
96:13 - paste this two more times. We have author and we 
have ESPN. After author and ISP een we will add  
96:31 - another div give it a class of form group and row 
just like we did before. And we'll add a div give  
96:40 - it a class of column three offset of two. Let me 
do column six offset of four. That's what we have.  
96:49 - And we'll add a div give it a class of column 
four, this should be column three, and this will  
96:58 - be column three. This is because the six that we 
have, we are dividing that into two columns again,  
97:04 - the first one will be an input. And this will be 
type of submit for the button. And we'll give it  
97:12 - a value of create. Give it some bootstrap classes 
of btn btn, primary and form control. The other  
97:25 - one is to go back to the Index page. So we'll use 
the anchor tag and the tag helper ESB page will  
97:31 - take us back to the Index page. And the classes 
will be btn btn, success and form control will  
97:41 - display back to list. Let me save this and run 
our project. We'll go to our book. And this time  
97:50 - we'll hit Create new book. Great, you can see how 
good the page is coming along. If you think the  
97:57 - size is too big here, you can always modify that 
I'll change this to three in all the places. And  
98:04 - that way it will be more closer. Offset will also 
be three. Let's save this. And perfect looks much  
98:15 - better. Now if you click on back to worst, it 
works and uncreate we need to work on what will  
98:22 - happen when we hit the submit button. Right now if 
you do that nothing happens. And that is because  
98:29 - inside the Create Page model, we do not have a 
post handler. So let's see how we can add a post  
98:37 - handler so that whenever they submit anything 
from the page, how do we get the data and save  
98:43 - that inside our database. In this video, we need 
to make sure when we fill all of this information  
98:51 - and hit the Create button, it takes us back to the 
page. But before that we need some validation. As  
98:59 - you know name was a required property. So 
if you hit Create before pressing the name,  
99:05 - we want to see the error message right here. We'll 
do all of that. Let's stop the application. And  
99:12 - let's go to the page model. Right here we have the 
on get handler. But when we hit the submit button,  
99:20 - we will be posting data. So for that we need a 
post handler to retrieve that. So we'll create  
99:28 - public async and task. This task will be of eye 
action result because we'll be redirecting to a  
99:37 - new page. And the handler name will always start 
with on and what is the handler name. We want  
99:45 - a post handler so it will be on post. When this 
will be posted what will be passed from this razor  
99:53 - page. We will be passing a book object so far that 
will retrieve a book object. And we'll call this  
100:02 - book OBJ. Now, rather than getting a book object 
like this, we already have a book right here,  
100:09 - we can use the exact same property rather 
than writing this ESP dotnet core team has  
100:16 - given a property binding here, where you have to 
write bind property. Once you bind the property,  
100:23 - it is automatically assumed that on the post, you 
will be getting this book right here. So that way,  
100:31 - all you have to do is right here, you can check 
if model state.is valid, then proceed further.  
100:39 - Else. If it is invalid, we want to return back to 
the page. I'll explain you what model state is.  
100:48 - But hang with me right now. If the model state is 
valid, we want to add the book to database. Adding  
100:57 - that is really simple. We can use the underscore 
DB in here we have the book. And we have an add  
101:05 - a sink right here. What is the parameter we want 
to add the book with just do a wait here, and this  
101:15 - will work. After we add the book, we need to save 
changes to the database. Right now, this book has  
101:23 - not been added to the database, it is just added 
to a queue, which will be eventually pushed to the  
101:30 - database. When we type the command underscore DB 
dot Save Changes a synchronously, only when this  
101:39 - command is executed, then the data will be pushed 
to the database. And once the changes are pushed  
101:46 - to the database, all that is remaining is return, 
we will redirect to a page. And that page will be  
101:54 - the Index page. This looks good. Let's run our 
application and see this in action. So we'll go  
102:05 - to book, we'll try to create a new book. And let's 
hit the Create button. Great, you can see the book  
102:13 - has been created. Now let's try to create a new 
book and hit the Create button. You'll see nothing  
102:20 - happens. If you type name here and hit create, 
it gets created. But if you try it without name,  
102:28 - it won't be created. And that is because name is 
a required property. what is actually happening is  
102:36 - if we add a debugger here, and if we go back and 
try to hit the Create button, the control goes  
102:44 - back here. And let me add few more debuggers hit 
continue the model state if you hover is invalid,  
102:52 - what is not valid if you go on model state, you 
will have to go to result view. And right here you  
103:00 - will see the name is invalid. And the reason it 
is invalid is it is a required property. And you  
103:08 - are not passing any value. But we need some error 
messages to see that it is actually an error. In  
103:16 - order to do that, let me hit Continue. And we go 
back inside the view here, we need to add a div  
103:24 - will additive give it a class of text danger, 
this will be a red color. And that is a special  
103:31 - tag helper ASP Validation Summary, we'll change 
this to model only. Once we have this, what we  
103:40 - need is we want to display individual error. So 
we'll add span here. And we have ASP validation  
103:48 - for tag helper. Here we want the validation for 
book dot name will give it a class of text danger.  
103:58 - We can copy this will do the same for author, 
and ESPN. Once you do this, if you save this,  
104:11 - go back and refresh the page. The control comes 
back here. Let's hit the continue. Whoops,  
104:20 - I think there are some changes. We'll just stop 
this. Remove the debugger now. And let's just run  
104:26 - the application again. This time if we go to book 
and if we try to create new book hit the Create  
104:35 - button. You can see the error message comes right 
up. I need to show one more thing here. Let me  
104:41 - show you that in the next video. Now we see the 
error message. But there is one more issue. If  
104:50 - you go back to the application while it's running. 
Let's add a debugger here in the model state and  
104:57 - hit the Create button again. You can see that 
the control is going to the on post handler,  
105:05 - it finds the model status invalid, and it 
returns back with the error. We want this to  
105:12 - be done on the client side. In order to do that, 
if we switch back, we go to create, right here,  
105:20 - inside Solution Explorer, we have the validation 
scripts partial, all we have to do is we need  
105:28 - their reference. So right here, we'll do add 
section, this will be scripts. And right here,  
105:37 - we will use partial tag helper name, we will 
paste the name, this name will be exactly same as  
105:44 - validation scripts partial, make sure there is no 
spelling mistake, we'll save this. Let's go back,  
105:51 - go back to the homepage. Let me do Ctrl f5, for 
hard refresh. Let's try to create again. And let's  
106:01 - make it empty, hit the Create button, you see the 
error message pops up, it doesn't go back. And to  
106:08 - confirm if we go back, we still have our debugger. 
So this means the validation here is done on the  
106:15 - client side without posting back. So that way, we 
have both the validation server side as well as  
106:22 - client side. So this was one way I wanted to show 
you that the validation should be done both client  
106:30 - side as well as server side. Now the Create is 
completed in the next video, let's start working  
106:37 - on the Edit functionality. Now we will be working 
on the Edit razor page. So while this is running,  
106:47 - if we can go back, and we go to our index. If 
we scroll down where we have the edit in here,  
106:57 - we need to pass the routing. So the ASB page, this 
will be the Edit page, which we will create. Now  
107:04 - whenever an user clicks on the Edit button, 
we want to pass the ID of the field that they  
107:11 - are editing. In this case it will be ID of the 
book. So in order to pass that we have another  
107:18 - tag helper, and that is ASP, we have route. And 
then we need to define the name that we want,  
107:26 - we can just call this as ID. What we want 
to pass here is the actual ID of the book,  
107:33 - which is inside@item.id. This way, when a user 
clicks on Edit, it will go to the Edit razor  
107:42 - page. And it will also pass ID as the parameter. 
Let me save this, let me stop this. Let's go back  
107:51 - inside the pages book list. Let's add a new razor 
page called as edit. Perfect in the get handler,  
108:01 - we will get a parameter of ID that we just pass 
it will be an integer based on this integer, we  
108:09 - will retrieve the book, we can use bind property. 
And we can start first with private application DB  
108:17 - context. Because we'll have to update things. 
We'll do CTO our constructor will have the  
108:28 - application DB context DB underscore DB is equal 
to dB. Great, then we need to bind property. In  
108:41 - here we'll be working with just one book. So with 
the public book, let's call this book will have  
108:49 - the getter and setter. Here we need to populate 
this book object based on the database with the  
108:57 - ID that we received. So await will do underscore 
DB dot book dot find a sink. And here we just need  
109:06 - to pass the ID. This is another method that we 
have with our Entity Framework. Rather than why  
109:14 - this will be async. And task because we are using 
await here. This looks good for our get method. In  
109:24 - the next video. Let's design the edit view and 
continue working on posting or editing a book.  
109:32 - Now we will be working on editing the book UI. The 
UI will look similar to what we have for create,  
109:41 - but the only difference will be the data will be 
loaded. So we can go to create dot CSS HTML, and  
109:48 - we can copy everything right here. Do not copy the 
model because model will be different. So right  
109:56 - here, we'll remove everything and we'll Paste 
what we just copied. Rather than create new book,  
110:04 - it will be added book. Then if you scroll down, 
we have submit here, the value will be update,  
110:11 - and index. This looks good. Let's run our 
application and see the Edit page. Here we'll  
110:22 - go to book. And we'll hit the edit button. Great, 
you can see the data is loaded, it's added book  
110:30 - and we have the Update button. If you try to hit 
update, nothing happens because we have not added  
110:37 - the post handler. Also in the URL, you see the ID 
is being passed. And this is the ASP route ID that  
110:46 - we added. So everything is coming along good. In 
the next video, let's work on the post handler.  
110:54 - In this video, we'll be working on the Update 
button. If we close this here, inside the Edit,  
111:03 - you see the form method is post and we have the 
input type Submit. So on post, we need to write  
111:10 - a post handler in post handler will be redirecting 
to page. So that's why the return type will change  
111:18 - that to I action result. So task of I action 
result. And we'll call this on post. The first  
111:28 - thing we'll check here is if model state is valid. 
If this is valid, then we will proceed further.  
111:36 - And we'll retrieve the book from the database, 
because we have to edit this. Now updating can  
111:43 - be done in multiple ways. So one of the way is 
word retrieve that from TP is equal to whatsit  
111:51 - await underscore DB dot book dot find a sink. 
And we'll pass the book. Whoops book.id we have  
112:04 - the book object right here will retrieve it and 
pass the ID. And we'll say book from DB dot name  
112:11 - is equal to book dot name. We can just copy this 
and paste this two more times for ESPN and author  
112:21 - will copy the same here. Perfect. Once we change 
this, we will say await underscore DB dot Save  
112:31 - Changes a synchronous, and this will update the 
book object inside the database. Once we update,  
112:39 - this will return redirect to page. And we want to 
redirect to the Index page. If the model state is  
112:49 - not valid, we will return and redirect back to 
page. Now let's see this in action. And when we  
112:59 - try to run this with hit into an error, I want to 
show you that error message before I show you the  
113:06 - solution. We go to book here. Let's try to edit 
this. And we'll change the ESPN to 333. Great,  
113:15 - we see an error message here that object 
reference is not set to an instance of an  
113:21 - object. This is a common error message. And it is 
not self explanatory. It just says that the object  
113:29 - it was expecting value, but it is a null value. 
Now we have to debug on what's going on. So we'll  
113:37 - add a debugger inside the model state variable. 
And right here. Let's go back and we'll go back  
113:46 - here and hit the Update button. Okay, we'll see 
the model state is valid. Let's continue. We'll  
113:54 - see the book object. And you see the ID is not 
present. We have all the other values the ESPN is  
114:03 - the updated one, but the ID is missing. And the 
reason behind that is if we hit continue here,  
114:11 - let me remove the debuggers ad continue again 
we'll get the error that's okay. Inside the Edit.  
114:18 - We do not have the ID here. We have name right 
here, author and ESPN. We need the ID property  
114:28 - inside a hidden field. So we'll do input type 
is equal to hidden and we need the ASP for tag  
114:38 - helper for the ID so it will be book.id once you 
have it and save it and if you go back. Let's go  
114:50 - back here and let's do a hard refresh and update 
the value. This time it is updated the Cause it  
115:00 - finds the ID now. So always make sure that inside 
edit and such fields, you have the ID or any other  
115:07 - properties that you want while updating must be 
present in the hidden property if you do not have  
115:14 - that inside the input text box. Also, if you go 
on Edit, we already have our validations. So if  
115:21 - you try to update, it gives the error message. 
So with this we have completed create an edit,  
115:28 - let's work on Delete. In this video, we'll 
be implementing the Delete. Now with delete,  
115:36 - you can do it the same way we did for edit and 
create, you can create a new view where you will  
115:42 - display the details. And on the delete button, you 
can do a post event. But I want to try something  
115:48 - new here. This time, when we hit delete, I want to 
show an alert. And when the user clicks Ok, I want  
115:56 - to delete it too quickly from the Index page. So 
for that, let's implement the pop up first, we'll  
116:02 - go back, I will close edit, create. And we have 
the index. Right here we have the delete button,  
116:11 - I will add an onClick method here. And we will 
save return will have a confirm box. You sure  
116:21 - you want to delete. If this returns true, we want 
to go to a page handler on the same index page. So  
116:32 - we'll do a ASP page. And we'll have a handler, we 
have not used this tag helper before. This time,  
116:40 - we want to implement a custom tag helper other 
than the on get and on post, we want to call  
116:47 - this is delete. And when we'll be deleting, we 
need to pass the ID of the book, we already know  
116:54 - how to pass it using ASP route. We'll call it 
ID. And we'll pass item.id. Let's save this.  
117:03 - Let's go back and refresh. And when we hit the 
delete, we now see an alert here. On cancel,  
117:11 - nothing happens. What should happen when they 
click OK, we have to implement a delete handler  
117:18 - inside the Index page. So inside Solution Explorer 
will open the page model. Let me stop it here. And  
117:27 - we will implement public async task of I action 
result. Because we'll be redirecting to the same  
117:36 - page. And we'll implement on post delete, we'll 
have an integer of ID that we will fetch because  
117:47 - on the index, we have the ID. This is a button. 
So that's why it will be a post handler. So we  
117:54 - will have the on post and then the handler name 
which we have defined as delete. Okay, so what  
118:02 - we want to do in here, we'll say variable book is 
equal to, we can do it in multiple ways. First,  
118:09 - we can find the book. So we'll do await 
underscore DB dot book dot find a sync,  
118:15 - and we'll pass the ID, then we'll check if book 
is equal to now. That means that book does not  
118:25 - exist based on the ID that is passed and will 
return not found. If we find the book will say  
118:33 - underscore DB dot book dot remove. In here, we'll 
pass the book that we retrieved. And we need to  
118:42 - save the changes. So await underscore DB dot Save 
Changes a sink. Once we remove the book, we'll  
118:49 - return back to the page. Or we can return back 
to the Index page, making it reload. Let's save  
118:58 - this and let's run our application. We'll go to 
book. Let's try to delete this 111. And perfect.  
119:09 - You can see our delete functionality is working 
as expected. So with this we have completed the  
119:15 - CRUD operations on book list using razor syntax. 
Now we have implemented the crud functionalities  
119:24 - that we seen before. These current functionalities 
are basic HTML and dotnet. Core. How about we add  
119:32 - some styling and some data tables to that. So for 
that, I'll be needing three things. First will be  
119:40 - sweet alert, because of which we'll be having 
such nice alerts. Then we have toasters, for  
119:47 - notifications like this. And we'll be using data 
tables to list all the books in such a fashionable  
119:54 - way that our CD ends that are needed for that. 
What I will do I will have a file attached with  
120:02 - the CSS and the JavaScript. So you can just copy 
this, go back to your code. Word starboard, will  
120:11 - have to go to underscored layout. On top, we 
have the CSS will paste it here for data tables,  
120:18 - jQuery UI and toaster. And we'll also copy the J 
s. And we'll scroll down to the JavaScript. And  
120:28 - we'll paste it right here. Now with data tables, 
we need to add API calls to retrieve all of the  
120:36 - books in a JSON format. And we'll also add an 
API call for delete. In order to add API calls,  
120:44 - we need to add Web API to our project. Right now, 
it's only razor. So for that, we'll right click,  
120:52 - add a new folder. Let's call this controllers. 
I'll make it plural here, controllers work right  
121:02 - click, add a new controller in here, we can go 
with the MVC controller or the API controller,  
121:09 - anyone is fine. We'll just go with the MVC 
controller. And we'll call this book controller.  
121:17 - Inside the book controller, we will need our 
application DB context. So right here, we'll  
121:24 - have private read only application DB context, 
we'll do our control dot underscore DB will have  
121:33 - the constructor application DB context dB, and 
underscore DB is equal to dB, then we need to  
121:43 - implement the HTTP GET and HTTP delete. Let's just 
implement the HTTP GET, we'll change this to get  
121:52 - all and with the get it should be HTTP GET. What 
we want to do is we want to return a JSON here.  
122:02 - And within New, we want to pass data is equal 
to underscore db dot.to list. So that way, we'll  
122:13 - retrieve the book. And we'll pass it back when you 
call this API call. But API's are not supported  
122:22 - inside our startup right now. What we have right 
now is only add razor pages. So in order to do  
122:30 - that, we'll do services dot add controller with 
views. Once you add this, you will be adding the  
122:37 - API calls, we will also have to add that to our 
middleware, especially inside the endpoints. So  
122:45 - we'll use endpoints dot map controllers. This way 
the controller API's will be called. And right  
122:55 - here, we need to define the route that should 
be used to call this. So the route we'll just  
123:01 - call is API forward slash book. And this will be 
an API controller. So that way, we'll make sure  
123:09 - that the book controller is an API controller, 
and this is the route that will be used. In such  
123:16 - startup. Since we have added map controller, 
you can navigate to this URL and get request  
123:22 - will return you data from here. In this video, 
we'll be making changes to the Index page that  
123:30 - is inside pages book list index. And right here we 
have the first step that we are using right now,  
123:37 - I will add another div here. Let me just paste it. 
And all we are doing here is column 12. We have an  
123:46 - oar. And I have a div with column 12. I have a 
table with ID of DT lol. This is important. And  
123:54 - I'm just displaying the table headers. I think I 
have an extra div here. There we go. Now how do we  
124:03 - load this table, that table will be loaded using 
JavaScript. So for that, we'll add a section here.  
124:10 - And it will be script. We will have the script 
tag here will give SRC, inside GS, I will create a  
124:22 - new JavaScript called book list dot j s. Let's add 
that script file inside the WW root j s. We'll add  
124:32 - a new item. We can search for Java here. And let's 
call this book list. And then let's start working  
124:42 - on the JavaScript here. So we'll have the variable 
data table here and fill us the dollar document  
124:52 - dot ready function. We'll add a function in here 
And we'll call load data table. Let's add this  
125:07 - load data table. So we can just copy this. And 
we'll add a function here, paste that. And what  
125:15 - we want to do here is we'll load the variable data 
table, we want to load it on index, we have the DT  
125:24 - load, we can copy this will retrieve that hash, 
and DT load. That way we'll call data table. This  
125:34 - data table has been included with the JavaScript 
reference that you added with data tables. So dot  
125:41 - data table will populate a data table on DT load. 
In here, we have few things, we need to make an  
125:49 - AJAX call to our API. So for that, right here, we 
need to define the URL and URL is forward slash  
125:59 - API, forward slash book, then we need a type here, 
because this will be a get request, followed by  
126:09 - data type, and data type will be JSON. After the 
AJAX call, we need to define all the columns that  
126:18 - we have to display. So right here, we will have 
columns, and this will be an array. So right here,  
126:27 - the first one will do data. And what is the 
name of the column that is name itself, comma,  
126:35 - we want to say what width it should occupy. So 
that will be in percentage. So we can do 30%. We  
126:45 - can copy this and paste it two more time. We have 
author here, and we have our ESPN, make sure it  
126:55 - follows camel casing. If inside book the variable, 
you had his name, right here you had named ABC,  
127:04 - then what you would do is right here, this will be 
named ABC, the first one should be a lower case,  
127:12 - we only have named so everything is the lower 
case right here. After this, the last column we  
127:20 - want is edit and delete buttons. So in the last 
one, the data fields that we want is the ID,  
127:29 - because when we edit or delete, we need to pass 
the ID of the book. So we'll have ID here. And we  
127:38 - will have a render, because we want to render 
two buttons here. So this will be a function,  
127:44 - and we will pass the ID. So that's why we'll pass 
the data, which has the ID. In here, what we want  
127:53 - to do is we want to return a div with two buttons. 
Since this will be a multi line statement, we can  
128:01 - use the tilde sign and break up the statements. 
tilde sign is available right next to the one on  
128:08 - your keyboard. Here we start with Dave, give it 
a class of text center. And we'll add the ending  
128:17 - div. Since there is no IntelliSense, you have to 
do this manually. Then you have an anchor tag,  
128:25 - we'll do x ref, what we want to do is we want to 
add an edit page. And right here, we will have  
128:33 - booklist forward slash edit, and we need to pass 
the ID. So Id is equal to dollar. And in here we  
128:43 - have the data. So that way we'll be passing the 
data which has the ID of the book. We'll give it  
128:50 - a classes of btn btn success and text white, we 
will also give it a style of cursor of pointer  
129:01 - and we'll give it a width of 100 pixels. This 
looks good for our anchor tag. And then in the  
129:09 - next line, we will add the added button will close 
the anchor tag here. And we can copy this anchor  
129:18 - tag because we want another one for delete. So 
right here, I'll add some space ampersand nbsp  
129:26 - and we'll paste it one more time. On delete, we do 
not want to go to any of the URL. So we'll leave  
129:36 - the extract out right now. We'll have the classes 
of btn danger and we'll add an onClick but we'll  
129:45 - do that later. I'll just make it delete and we'll 
have the closing div. So this looks good. Then,  
129:55 - in this render with an ad with here and We'll 
make it 30%. Outside of this array that we had  
130:04 - four columns, we'll do comma. And I will add 
language here. In here, I do empty tables. If  
130:14 - there is no data, I want to display no data 
found. We'll do what columns are here, and  
130:21 - we'll give it a width of 100%. Everything should 
be in double quotes, like this. So with this,  
130:30 - we have our data table in place. Let me save this. 
And we need to run our application. To see this in  
130:38 - action. We already added the code inside the Index 
page. So if we go and book we will see two tables.  
130:47 - Now. The first one you can see right here, and 
here is the later one. But here the JavaScript is  
130:54 - not getting called. And I guess that's because we 
have a mistake with the file name here. It should  
131:01 - be booklists. JavaScript. Let's enter that and hit 
the Run button again. We get one book. And great,  
131:12 - we see our data table in place with the number of 
entries we have pagination, sorting, and search by  
131:19 - default. Here, the stylings has not been applied. 
Let me go back and take a look. We forgot an equal  
131:27 - to here. Let's save this, go back and refresh. 
And perfect. We see everything is coming along.  
131:35 - Let me just reduce the size here. I'll make it 
20. And we can make this 40. And width that will  
131:47 - make it 70 pixels, and both the places that 
save it and refresh, and perfect. This looks  
131:55 - much aligned. When you hit the Edit, it will take 
you to the Edit page. And if you click on delete,  
132:02 - right now, nothing happens. In this video, let's 
work on the Delete. On delete, we want to display  
132:10 - a nice alert here and on. Okay, we want to delete 
it directly but using an API call. So for that,  
132:19 - we'll have to go back and we'll have to add an 
API call inside our book controller. So we will  
132:26 - add an HTTP delete here. And this will be public 
I action result, delete. Here, we'll be getting  
132:36 - an ID that we have to delete. We'll say variable 
book from DB is equal to underscore DB dot pub  
132:47 - dot first or default. And we can say u goes to 
a u.it is equal equal to ID. Now right here,  
132:57 - it is always good to be consistent. So we will do 
a sync, and it will be task of I action result.  
133:05 - And we will do await here. And we have the 
tool list a sync, we'll have to do a control.to  
133:16 - include Entity Framework core firstar default, 
we have the async method in here. So we'll do  
133:22 - control dot oops, there we go. And we'll use 
await. We have a sync task of I action result,  
133:36 - then we'll check here if both from DB is equal 
equal to Now in this case, we will return JSON.  
133:46 - And we'll return new. This time, we want to make 
sure success is false, because we did not receive  
133:55 - any book. Karma will also display a message error 
while deleting. If we found that book with the  
134:07 - underscore DB dot, dot remove, and we'll say awake 
underscore DB dot Save Changes. It's synchronous,  
134:18 - then we'll return back the JSON. This time we'll 
have a new and success will be true. And we'll  
134:30 - have a message which will be delete successful. 
So this looks good. Here we are getting an error.  
134:40 - Let's do a control dot whoops and that is because 
we did not pass the object that we had to remove,  
134:47 - which is booked from dB. Perfect. So the Delete 
method looks good. All we have to do is inside the  
134:55 - JavaScript, we need to add a function to delete. 
Let's do that in the next video. In this video,  
135:05 - we'll be adding a function to delete and call our 
API. So right here where we have the Delete tag,  
135:12 - we will add an onClick method. So right 
here, we will say on click is equal to,  
135:20 - let's call a function, delete. And we'll pass our 
API call here. So we'll have API book. And then  
135:29 - we need to pass the ID is equal to, we'll do plus, 
and we have the dollar data. And then at the end,  
135:42 - we will be adding the Delete function. So we'll 
add function, delete will receive the URL here.  
135:50 - And we need to display sweet alert. So we'll 
do swa L, and will add the properties like  
135:58 - title. Are you sure karma will have text. Once 
deleted, you will not be able to recover. We can  
136:14 - have an icon here of warning. And we can have a 
danger mode here to drill. These are just some  
136:23 - of the properties that you can use. And we'll be 
using Ajax here. So we'll use them. And in here,  
136:31 - we'll say we'll delete this will be the response. 
Based on this we'll have a function. Here,  
136:37 - we'll check if we'll delete. That means if user 
selected Yes, they want to delete, we will make an  
136:45 - AJAX call here. AJAX call, we will have the type 
of delete, we're going to have the URL, which we  
136:59 - have right here inside the parameters, we'll do 
a comma. On success, what we want you to do is  
137:07 - we want a function with data that we retrieved. 
And we want to display a toaster notification. So  
137:16 - we will do toaster.we have this success here. 
And we want to display message. Inside here,  
137:26 - I need an if condition. And we'll check if this 
is success or not. If this is successful, we'll  
137:33 - display torstar dot message. And we will say data 
table. This should be message. And that is because  
137:42 - if we go to controller, we have message right 
here. And then we'll do data table dot Ajax dot  
137:51 - reload. In the else block here, we want to display 
an error. So I can copy this and paste it. And  
138:00 - this will be error. This looks good. We'll add the 
two semi colon. And now let's run our application.  
138:09 - We'll go to book. Let's try to delete. Great, we 
see the notification here, you can click outside,  
138:22 - or you can hit the Delete. And if we hit Delete 
here, it doesn't do anything. But actually,  
138:29 - if you refresh the data is deleted, we have 
some issues with the display. So right here,  
138:36 - let's see the toaster. This should not be message 
it should be data dot message, because we have  
138:43 - that inside the data object. And also, if you go 
to book controller, I have a mistake with success  
138:50 - spelling here. Let's run it and see everything 
in action. Let's go to book and create new book.  
139:02 - Let's hit the Delete. Okay, great. We see a 
nice toaster notification. And then if we just  
139:12 - scroll back inside the sweet alert IP, add another 
property here buttons is equal to true. And after  
139:20 - that if we go back and we go to book, create new, 
let's add one. Create and then if we click Delete,  
139:29 - we see ok and cancel. So that way we have 
everything working. Now here I have had request  
139:38 - from students many times that the Create view 
will look similar to what we have for our edit.  
139:45 - So why not combine both of them in one view or 
one razor page? So that can be done? Absolutely.  
139:52 - Let me stop the application and I'll show you how 
that is possible. Usually the name first Each page  
140:00 - is absurd, because it is a combination of update 
and insert. So we can just copy the edit that we  
140:08 - have. Or let me just add a new view, because when 
we copy, we have to make sure many things needs to  
140:14 - be updated like model. So the page name, it will 
be absurd. And this looks good. Let's add that  
140:22 - inside our ProQuest. It will be similar to edit 
page, but there will be modifications, let's first  
140:31 - copy everything that we have inside edit, not the 
model. So we'll copy this, and we'll close that,  
140:38 - we'll go to our absurd page. And we'll paste it 
right here. Let's save this. Let's go to the Edit  
140:47 - Page model. And we'll copy everything inside the 
model from application DB context. And we'll just  
140:55 - leave two brackets at the end. Whoops, we'll start 
after the two brackets. And there we go. Let's  
141:03 - copy this. Let's close this go to the absurd. And 
let's remove this and paste it right here. Now  
141:15 - what will happen within absurd is it will be used 
for creating as well as updating redo control dot  
141:22 - here, because of which inside the Edit model, this 
will be upset model actually. And because of which  
141:29 - the ad it is possible, there won't be any ID if 
this is used for create. So that's why we have to  
141:37 - use a nullable integer so that Id can be now then 
inside the get what we have to do is we'll say  
141:45 - book is equal to new book. Once we have that we'll 
check here if Id is equal to now. If Id is no,  
141:56 - that means that this is for create. So we will 
return back to the page. If that is not now we  
142:04 - will continue here. Because of this we need to 
change from task to I action result. If the ID  
142:12 - is not now that means we have to retrieve the book 
from the database. So book is equal to underscore  
142:19 - DB dot book dot first dot default a sink will have 
to do ctrl.to include Entity Framework core, we'll  
142:29 - do a weight here. And we'll say you goes to a u.id 
is equal equal to the ID, we will find the book  
142:38 - and after we find this we'll check if and we'll 
say book is equal equal to Now if that is true,  
142:46 - then we'll return not found. If this is not the 
case, we will return back to the page. Now when  
142:55 - we are retrieving from the database, you can use 
first or default async or you can use fine async  
143:01 - any of those methods will work. So this way, we 
will handle it for both create. This will be for  
143:09 - create. And this will be for update. So the same 
handler will be using for both the scenarios. That  
143:17 - looks good for the get handler, then inside the 
post handler, we will do the same. We will check  
143:25 - first if the model state is valid or not. If it's 
not valid, we'll return back then if it is valid,  
143:31 - what we will do is right here, we'll check if 
book.id is equal equal to zero. If this is true,  
143:42 - then underscore DB dot book dot add. And we'll 
add book. Else what we will do is underscore  
143:52 - db.book.we also have update method. In here, we'll 
pass the book. So previously, you saw other way of  
144:01 - updating the book by retrieving it from the 
database. And here we're using directly the  
144:07 - update method. So when should you use the previous 
one versus this one. This update should be used if  
144:14 - you want to update every property of the book. 
But if you only want to update two properties  
144:21 - within use the way that we used inside the Edit 
page. Once we do this, we'll save the changes.  
144:27 - And we'll redirect back to the page. So perfect. 
This looks good for our upset cat as well as post  
144:35 - handlers. In the next video, let's fix the update 
view or the razor page and we should be good. In  
144:43 - the last video, we fixed the handlers for absurd. 
In this video, let's work on the razor page. The  
144:52 - things that we have to do differently in create an 
edit is the title here. So in here we can use the  
144:59 - razor see index and we can check if model.book.id 
does not equal to zero. If this is true, we will  
145:08 - display edit, else we will display create we will 
copy this condition and we will have to do the  
145:17 - same for the ID in the hidden property will add f 
model.book.id does not equal to zero, then we will  
145:29 - have the ID else we do not need it in the Create. 
Lastly if you scroll down we need to do the same  
145:37 - for the pattern. So inside the input type we can 
just replace this with button we can say type is  
145:44 - equal to submit and we can add the same classes 
btn btn primary form control and we'll paste what  
145:55 - we had before for ad model. So if this is not 
now then we will display as update else we will  
146:03 - display create let's save this and with this the 
absurd view or the razor page looks good. How do  
146:12 - we test this we can go to our booklists.js and if 
we scroll up so we'll change this to absurd here  
146:22 - and we'll also change the Create so far that we'll 
have to go to the index and then if we scroll up  
146:32 - right here we'll change this to absurd. Let's save 
this and run our application. And right here we'll  
146:43 - go to book and hit Create new book we are on 
the absurd. Let's try to create one work great  
146:51 - this work. And if we click on the Edit here, it 
takes us to the absurd. Let's try to update this  
147:00 - perfect that is working. If I click on edit in the 
first one, it takes you to the Edit page. Here we  
147:08 - can also add a new text box so that we'll have 
both of them so I can just copy this and paste  
147:14 - it one more time. Next will be create and create 
new book and observed whoops I think I switched  
147:27 - that around fact me paste this will save this go 
back and refresh I have one more thing I have to  
147:37 - change this to six and perfect now we see create 
new book takes us to create add absurd takes you  
147:48 - to the absurd, but everything is exactly the same. 
So with this, we complete the absurd and how you  
147:55 - can combine both of the logic inside a single 
razor page. Now that we have completed Razer  
148:03 - project, it's time to explore the other type of 
application, which is an MVC project. So in this  
148:11 - section, we'll create our next project, which will 
be the book list. But in that we will use MVC,  
148:17 - we will take a look at how routing is different in 
MVC as compared to razor pages, and we'll see the  
148:25 - new folders with the MVC project. So let's get 
started with that from the next video. What we  
148:34 - have to do is we need to create project for our 
MVC crud operation. We'll start Visual Studio  
148:41 - 2019 and we'll select create a new project. In 
here we'll select ASP. NET Core web application  
148:50 - and hit the Next button. Then we need the name 
of our project. So we'll call it boquist MVC,  
148:57 - and you'll select a location. I'll change 
the location to where I want and I hit the  
149:04 - Create button. That being said, we need to select 
options for our project. Now in here we'll select  
149:12 - ASP dotnet core 3.1. And we'll be selecting MVC 
for our project. We can change the authentication  
149:21 - to select individual users account. But with 
that many things comes configured. So I do not  
149:27 - want to start with that route. We'll go with no 
authentication and we'll add database objects  
149:34 - manually. That way we will learn those concepts 
that being said once everything is aligned here,  
149:41 - let's hit the Create button. Perfect. So with this 
The project has been created with model views and  
149:49 - controller and this is slightly different to what 
we have seen with razor pages. As we saw from the  
149:56 - architecture we will have controllers which will 
have the logic models will have the data and view  
150:02 - will be the UI component. So we have all of those 
three folders right here. And the other things  
150:10 - are common like www root dependencies properties, 
app settings, program.cs and startup.cs. The only  
150:21 - difference is inside startup.cs class file. If you 
scroll down, inside configure services, we do not  
150:28 - have the Add razor pages, we have ADD controllers 
with views. Also, if you scroll down route here,  
150:36 - inside the routing, and endpoints, they have 
registered map controller route, because we  
150:43 - need controller actions and even areas in advanced 
courses. So these are the only differences between  
150:51 - MVC and razor pages inside the setup files. Of 
course, the working of controller models and views  
150:59 - is completely different. And we'll understand that 
in the upcoming videos. In this video, let's take  
151:08 - a look at the folder structure in an MVC project. 
The three main folders that are different our  
151:14 - model views and controller right here. The first 
folder is the controller's folder. And in here we  
151:23 - have the main logic of our web application. Here 
we have the home controller, one rule that we have  
151:30 - is the controller name will be home, and it should 
match exactly with a folder inside the view. So if  
151:38 - we have the views for homepage, the controller 
name will be home followed by a controller  
151:43 - keyword. inside the home controller, you can see 
we have methods here. And all of these methods are  
151:51 - called actions. So the terminal logic to remember 
is within controller we will have actions. The  
151:59 - next folder that we have is the models folder. 
Here as of now we only have error view model.  
152:06 - But as we proceed, we will be adding new models 
here. Any table that we have in our database,  
152:13 - we will have a corresponding class as a model in 
this folder. We will also have view models which  
152:21 - are a combination of multiple models, and we will 
discuss them in detail when we need them. Finally,  
152:29 - we have the views folder. In here if we expand 
we have the shared folder, in which we have the  
152:36 - underscore layout and validation scripts partial, 
which we discussed. And we have view imports and  
152:42 - view start. The new folder is the home folder. 
And in here we have index and privacy. And one  
152:50 - thing to notice is inside the home controller 
we have actions called index and privacy. So  
152:56 - here whatever data is being passed will be the 
model for these two pages or views. If we add a  
153:03 - new controller here, let's say Brogan controller, 
then we will have to add a new folder here called  
153:09 - pregame to add the views for that new controller. 
You will understand this more once we start  
153:17 - coding. But I wanted to give you a brief overview 
of all the three folders that we have. Now let's  
153:25 - just understand how routing works in typical MVC. 
asp dotnet routing is a pattern matching system,  
153:32 - which enables you to match the incoming request to 
a particular MVC action defined in a controller.  
153:40 - When ASP dotnet routing engine receives a request 
at runtime, it finds the match against the URL  
153:49 - pattern defined in the route table. If any match 
is found, then it forwards that request to the  
153:57 - controller. Otherwise, it will return a 404 not 
found message when we will create a new ASP. NET  
154:05 - Core MVC application routes are already added to 
the project. If we switch back to our application.  
154:13 - And if we go on startup.cs, right here, where it's 
adding controllers with view to our pipeline. And  
154:22 - when we see the middlewares, we have first the 
app dot use routing. And we have the app dot  
154:29 - use endpoints. Now you can keep endpoints or you 
can also use the routing without the endpoints in  
154:37 - versions one and two of ASP dotnet core. This was 
a part of MVC. But now it is a separate piece of  
154:45 - middleware to make routing available to all the 
middlewares and not just MVC. So that's why we  
154:53 - see app dot use routing on top. And then we have 
app dot use endpoints at the bottom endpoint is a  
155:00 - URL where incoming request will end up processing 
by the middleware. If you have used MVC, before,  
155:08 - you know that you have to specify the routes for 
this. And right here we are specifying a default  
155:14 - route in which if nothing is defined, it will 
look for the home controller, and it will call  
155:20 - the index action inside that. Now, ASP dotnet core 
is not just MVC, it supports different technology,  
155:29 - which uses routes, like razor pages, signaler, and 
MVC. And the routing is different for each one of  
155:38 - them. All of this tag uses middleware stack 
registers the endpoints. So if you see here,  
155:45 - right now, we only have the MVC endpoint that is 
registered, because that is what we'll be using  
155:50 - in this application. In previous version of ASP 
dotnet, core routing was embedded in MVC. But that  
156:00 - cannot work anymore. Since we have more than one 
technology, which uses different types of routing.  
156:06 - First we will do is we will add user routing, 
which will make the selected endpoint choices  
156:13 - available to all the middlewares that follows 
after that. And when we will do use endpoints at  
156:20 - that point, we'll be able to register and execute 
the endpoints. In lambda expression, we have  
156:28 - several extension methods to register endpoints. 
One of them you can see here is map controller  
156:34 - route. Let's try to run our application and see 
what happens. In the URL, we do not have anything  
156:43 - defined, it's just the domain name, or localhost 
and the port number. In that case, if we go back,  
156:50 - it should go to Home controller index action. 
So if we go on Solution Explorer inside home,  
156:57 - let me add a debugger inside index and privacy. 
Let's go back and press Enter Here, you can see it  
157:06 - goes to the index section of the home controller. 
And when we continue, it will load the view for  
157:13 - that. So the view if you go to Solution Explorer 
views home, we have the index view, right here,  
157:20 - we have a welcome text. And that is what we 
see inside the UI. When we click on privacy,  
157:27 - the link goes to home controller privacy action 
method, and then it should render the page  
157:35 - inside the home folder in views and privacy 
page right here. So if we do continue, here,  
157:42 - you can see home privacy is loaded. So the first 
one here is the controller name. And the latest  
157:50 - one is the action method. If you have not defined 
anything, it goes to the index action by default.  
157:57 - So if you just define home, it goes to the home 
controller and loads the index action method. If  
158:03 - you do not define home as well, it will go again 
to the home controller index action method. And  
158:10 - that is because you have defined that in endpoint 
to use as a default controller and action method.  
158:17 - So this was a brief overview of routing in MVC. 
And we'll continue exploring this more when we  
158:25 - start building our application. Now that we have 
the MVC application created, in this section, we  
158:34 - will work on the same booklist project to perform 
all the CRUD operations, but we will use our MVC,  
158:41 - we'll be adding models, views and controllers, and 
we'll see how everything comes together. Let's get  
158:49 - started with that from the next video. Now that 
we have a brief overview of our MVC project,  
158:57 - it's time to perform CRUD operations on the bucket 
list again. So the first thing we will do is we  
159:04 - will add model for our book. So we'll add a new 
class, we'll call it book. And in here, we will  
159:11 - add all the properties. First will be the ID. So 
we can use key data annotation, and we'll call it  
159:19 - prop integer ID. Next, we'll use the snippet prop 
tap twice with a string name. We can copy this and  
159:29 - paste this two more times. Name property, let me 
make it required. And the other one, I'll change  
159:38 - this to author and I ESPN. This looks good for our 
model. Once we have model in place, we need to add  
159:47 - this to database. So there are multiple things 
that we have to do to add it to the database.  
159:53 - First in the models, we'll add our DB context 
class, which we will call application DB context.  
160:02 - In here, we need the constructor. So CTR and 
within the constructor, we need to pass the DB  
160:10 - context options. We'll do control dot here, here, 
we need to include the package for Microsoft dot  
160:18 - Entity Framework core will find an installed 
the latest version. You can do this by going  
160:24 - to the new get package solution, but I want to 
do it right here directly. Here, we'll pass the  
160:32 - application DB context. And we'll have options. 
And we need to pass it to the base class, the  
160:39 - same options. Once we have that the application DB 
context should inherit from DB context. Now that  
160:48 - application DB context is looking good, what we 
need is we need to add our book to the database.  
160:54 - So whenever we have to add a table, we'll add 
that property inside the application DB context.  
161:01 - So we'll do prop. This will be of type DB set 
on book. And let me call this books. Perfect.  
161:11 - This looks good for our application DB context. 
And this is exactly what we did in razor pages  
161:18 - as well. Then the next thing is to add connection 
string, and to get the connection string inside  
161:25 - configure services in startup.cs. So we'll go to 
app settings dot JSON. And in here, let me paste  
161:34 - the connection string. Now remember, one thing 
that the server name, you have to double check. So  
161:41 - make sure if you're using this connection string, 
copy the server name, go to your SQL Server, paste  
161:48 - it here, you just need one backward slash and try 
to connect. As long as you're able to connect,  
161:54 - you can use the same connection string, the 
project, let me call this vocalist MVC. For the  
162:01 - database name, we have trusted connection to true 
and multiple active results search to true. Great,  
162:08 - so this looks good. And the connection string has 
been added in app settings dot JSON exactly like  
162:15 - we did increase our pages. The last thing that 
we have to do is we need to configure startup.cs  
162:22 - to use that connection string. So within the 
Configure services, we will add services dot  
162:30 - add DB context. In here, it will be on application 
DB context, we'll have to do a control dot here to  
162:40 - include models. And we need to pass the options 
for SQL Server. So options goes to options. use  
162:50 - SQL server will have to install a new nougat 
package. Let me do control dot here again. And  
162:59 - I do not see that nougat package here. So what I 
will do is I will just go to Tools, nougat package  
163:05 - manager solution. And we'll search for SQL Server. 
We have the package, which is Microsoft dot Entity  
163:15 - Framework, core dot SQL Server, let's install the 
latest version here. Perfect it is installed. Now  
163:24 - if we go back, and if we do Ctrl dot, we'll see 
the using statement for Microsoft, that Entity  
163:30 - Framework core. And once we do that, there we go. 
Here, we need to parse connection string from the  
163:38 - configuration. So we'll do configuration.we have 
a get connection string here. And we need to pass  
163:45 - the name inside our app settings, which is default 
connection. We'll copy that and paste it right  
163:52 - here. Let me break it in a new line. There we go 
looks much better. This looks good for all the  
164:03 - configuration that we have to do. But we also want 
to add the waser compiler package. So right here,  
164:10 - let me add the razor compilation package actually 
will search for runtime compilation, there we  
164:18 - go and install the package. This package we are 
installing so that if the application is running,  
164:24 - and we change anything in the view, and we 
refresh, we don't have to restart the application.  
164:30 - Whoops, there we go. And right here, we'll do add 
razor runtime compilation. Great. This is exactly  
164:40 - what we did with razor pages as well. That's why 
I'm not spending much time here. Once you do this,  
164:47 - let's add a migration. So we'll go to Tools nougat 
package manager console will add migration add  
164:58 - book to dB And here we see an error with the 
migration. That's because if we go to Tools,  
165:05 - nougat package manager, we have to install 
package for Entity Framework tools. So if you  
165:16 - search for Entity Framework, tattoos will install 
the Microsoft dot Entity Framework core dot tools  
165:23 - to our project. Once that is installed, then add 
migration should work. Awesome. Let's go back to  
165:32 - package manager and hit the command one more time. 
This time it is already building the project it  
165:39 - was successful, and it adds a migration right 
here. Great Migration looks good. Let's update  
165:47 - the database to push our model to database, it 
will first create that database, and then it will  
165:55 - add the tables. Great. Let's go back to make sure 
it's working. We'll go to database in SQL Server,  
166:03 - we have the new database. in there, we have our 
table called books. And great we have all the  
166:12 - columns as we wanted. Once we add the model to our 
database, next thing, let's go to our master page,  
166:20 - which is underscored layout. And let's add 
a link for a new controller for our book,  
166:26 - we'll copy the ally here, the new controller, 
let's call it books controller. And in there,  
166:34 - we'll have an index action. We'll call this 
as book list. And let's add a new controller.  
166:43 - Inside controllers, we have the home controller, 
in here, we'll add a new controller, we'll go  
166:51 - with the empty controller for MVC. And we'll 
call this as books controller with the name of  
166:58 - the controller controller has to be pre has to be 
added at the end. So whatever name you give before  
167:05 - controller will be the name of that controller. 
In this case, it will be books controller, great,  
167:13 - our controller is added. And in here we have the 
index action. Let's try to run our application and  
167:21 - see what happens when you click on the link. 
Since we already have index action. In here,  
167:29 - it will take you to books controller index action, 
but since we do not have any view, it will give  
167:36 - an error that the view index was not found. It 
tried to look inside views books index dot CSS,  
167:44 - HTML. And since it did not find it there, it also 
looked inside the shared folder. So even though  
167:52 - we have the action method for index, we do not 
have the view. To add a view, what you can do is  
167:59 - inside our views folder, you can create a new 
folder with the same name as your controller,  
168:05 - which is books. And in there, you will have to add 
index view, you can do that in Solution Explorer,  
168:13 - or you can just right click on index and click Add 
view. Here we'll go with the empty view. And we do  
168:22 - not want it to be a partial view. Partial view is 
something that you want when you will be consuming  
168:29 - that inside some other view. But in this case 
index will have a page by itself. That being said,  
168:37 - we'll select Use a layout page because we want 
the same header and footer for our index page as  
168:43 - well. Let's hit add here. Perfect. Now if you run 
the application, and if you navigate on the link,  
168:52 - you will see the word index, as you can see 
right here. So we click here. And great,  
168:59 - we see our view in action. Let's continue working 
here in the next video. Now in this video, since  
169:08 - we have our application running with the index, I 
want to install few third party tools. First is a  
169:15 - sweet alert that I want to display nice alerts in 
our web page. Next is a toaster notification. And  
169:24 - in here, if we go to toaster j s, we go to demo. 
And when you click Show toast, you see we have  
169:32 - nice toaster notifications here. We'll use this 
when we delete our poke. So we'll use toaster  
169:39 - and the last one is data tables. Here we get 
sorting functionalities, number of pages, paging  
169:47 - functionality and search right out of the box. 
So we'll be using all three of them. Now you can  
169:55 - go here and get the CD ends or I will have that 
attached with The lecture. So let me open that  
170:03 - up. And within the attachments, you will see CSS 
underscore js, we will copy the CSS. Let's go back  
170:11 - to our application. And in here, let me close, 
everything will be adding that in our master page.  
170:18 - Because once we add in the master page, it will be 
accessible in all the other pages. So on top here,  
170:26 - we will be adding the CSS. And when we scroll 
down, we have to add the JavaScript. So copy that  
170:34 - and paste it right here. So perfect, this looks 
good. And we have added all three of them to our  
170:42 - project. Now, since our application is already 
running, in our razor pages with index, we use  
170:50 - data tables, and we added a JavaScript will do the 
same in this MVC project as well. The JavaScript  
170:59 - will have the exact same functionalities. 
Before we work on the JavaScript, let's  
171:06 - work and create the action methods inside our 
controller. Let's do that in the next video. Now,  
171:14 - within our booklists MVC project, we want to work 
on our controller, which is the books controller.  
171:21 - Let me open up the razor project that we built. In 
here, I have pulled up the razor project in which  
171:30 - we added the API calls to get all of the book, 
as well as to delete a book, this course will be  
171:38 - exactly the same. So we can copy this. And let me 
close that project. We'll switch back to our MVC  
171:45 - project. And within our books controller, since 
those are API calls, we will create a region here,  
171:53 - and we'll call it API calls, I will enter the 
region as well. And between that we will paste  
172:01 - the code that we copied. Now, first thing in 
controller when we have to Access database,  
172:08 - we need the application DB context. So we'll 
have private read only application DB context,  
172:18 - we will do a control.to include using booklist MVC 
dot models. And we'll call this underscore dB. We  
172:28 - need to get this using dependency injection. So 
we'll create a constructor here. And we'll have  
172:35 - the application DB context dB. And we'll do 
underscore DB is equal to dB. This you must  
172:43 - be familiar by now that we need to do this to get 
the DB context using dependency injection. Then  
172:52 - if we scroll down rather than book, what we have 
is books inside our application DB context. Then,  
173:00 - for two lists and async, we'll do ctrl.to include 
Microsoft dot Entity Framework core will make  
173:08 - books in all the places other than that everything 
will be seen forget all and delete API's. Once we  
173:17 - have that, then inside index, when we return back 
to the view, we do not want to pass anything here,  
173:24 - because we will be loading this view using the API 
call right here with the help of data table. So  
173:33 - let me go to the View. And in here, we need to 
add us for our JavaScript. That being said the  
173:40 - JavaScript will be exactly the same with one 
or two modifications as compared to our razor  
173:46 - code. So I have that in the attachments as well, 
which is exactly the same as what we have in the  
173:53 - razor project. We will copy this, go to Solution 
Explorer, ww root j s, we will add a new item. And  
174:03 - this will be a JAVA script. And we'll call this 
book list dot j s. let me paste the code that we  
174:14 - copied. All we have to change here is URLs. All 
that was changed here was the URLs. Here we had  
174:24 - API forward slash books inside razor pages, but 
in MVC, we do not have that we are in the books  
174:32 - controller. And if we want to call any action 
method in here, all we need is the controller  
174:38 - name, followed by the action name. So the API 
calls are get all and delete because of which  
174:46 - if we go to publish.js to get all of the books we 
are calling books, which is the controller name,  
174:53 - followed by the action name, which is get all that 
will retrieve all of the books Then when we have  
175:01 - to edit the book, we are calling the controller. 
And then right here you see an action name, which  
175:07 - is absurd. We do not have this action yet, but 
we will add this in the upcoming videos. Lastly,  
175:16 - you see inside the Delete here, we are calling 
the books controller, and then the Delete action  
175:22 - method with an ID, which we are passing, which 
is the ID of the book. So if we go to books  
175:30 - controller, we have the Delete action. And here 
we are expecting an ID. So you can see the chain  
175:38 - is exactly similar as we did inside the razor 
pages. That being said, our JavaScript is in  
175:46 - place and our controller API are in place, all 
we have to do is we need to add the table and  
175:53 - call our JavaScript in index. Let's do that in 
the next video. In this video, let's modify the  
176:02 - index view and see how it looks. We do not need a 
model in this because we'll be loading everything  
176:10 - using data tables. With additive give it a class 
of container and row and give it padding zero and  
176:19 - margin zero. Within this main div, we'll add a div 
with class of column sex. And we'll have our title  
176:28 - here. We'll use bootstrap class for text info. And 
we'll call this book rest. After this column six,  
176:37 - let me add another div, give it a class of column 
six. And here I want the button rather than six  
176:44 - here, let me make it column three, and offset 
it by three. And we will add a button or a link  
176:52 - here. Now this link, I want us to redirect to an 
absurd page where we can create a new book. So  
177:00 - in order to redirect, just like we had ASP page 
inside razor pages in MVC, we have ASB action.  
177:09 - Let's say if you want to redirect to action in a 
different controller, we also have ASP controller.  
177:16 - So here you can write books controller. in there, 
we have the absurd action, which we will add,  
177:24 - then we'll add some bootstrap classes btn btn. 
info, and we'll give it form control. We'll also  
177:35 - make it text off white, there we go. And in here, 
I will display add new book. Now in this case,  
177:46 - since the upset action will also be added inside 
the books controller, it is okay if you do not  
177:53 - write this. So this is optional, but I will leave 
it there. After this Dev, let me add another div.  
178:01 - And this time, I'll give it a class of column 
12. For our main table, along with column 12,  
178:09 - I will add a border and I will give padding three. 
Then here we want our main table, we'll give it  
178:17 - an ID that we have inside purplish.js, which is DT 
underscore load will copy and pasted will add some  
178:27 - bootstrap classes like table, table striped, and 
table border whoops, table bordered. Along with  
178:39 - that, I also add a style to give it a width of 
100%. Perfect. Here we will add t head for the  
178:49 - headings in which we'll add the table row will 
have the th tag, we want to display name, author,  
178:57 - isbm and buttons to edit and delete. So I ESPN 
author, and the last one would have the buttons  
179:07 - to edit and delete. That being said, we need a 
reference to request dot j s. So we'll add section  
179:16 - scripts. In here we'll add the script tag, add an 
SRC for Java Script book list dot j s. Once you  
179:28 - do all of that, that's one our application and 
see how things look. Let's go to ProQuest here  
179:36 - and great it's loading and no data found. That's 
because we have not added any book yet. But we  
179:43 - can see the data table is loading as expected. If 
you click on add new book, it will give an error  
179:50 - because we have not added that action method or 
that view. In the next video. Let's work on the  
179:58 - absurd. Get Action method and the view. In this 
video, let's work and create an absurd get action  
180:08 - method. Absurd view will be used for two places, 
one to edit a book and one to create a book. Based  
180:16 - on that, sometimes it will retrieve an ID, if it 
is for edit. If it is for create, there won't be  
180:24 - any ID. So we can copy this index, paste it here. 
And we'll call this action method as absurd.  
180:32 - In here parameter, it can receive an ID or it 
cannot. So we'll make this a nullable parameter.  
180:41 - That being said, Now you need a book object with 
absurd. So we can add that book object right here,  
180:48 - we'll do Prop, it will be a book object. And we'll 
call this book. Now we can use find property here.  
180:59 - And once you find that property on post, you 
won't have to retrieve that it will automatically  
181:05 - be binded. That being said, inside the view here, 
first, let's initialize the book is equal to a new  
181:15 - book. And then we will check here if it is equal 
to Now if this is null, that means this is for  
181:25 - a create request. And we will return back to the 
view the book object, which is just a new object.  
181:33 - If this is not the case, that means this is for 
an update. If someone wants to update a book, we  
181:41 - need to retrieve all the data for that book from 
database. And we have to display that. So we'll  
181:49 - retrieve that input here from db.we have the books 
object or model, and we just want to retrieve one  
181:58 - book. So we can use first dot default here, and 
we'll say u goes to a u.it is equal equal to the  
182:07 - ID that we retrieve right here. After that, we 
can check here, if book is equal equal to Now,  
182:16 - if this is not, that means there is no book 
in the database. And we will just return not  
182:24 - found. If we find that book will return back to 
the upset view. But we will populate the Book  
182:31 - which We have retrieved from the database. So 
the view will expect a book regardless of if it  
182:38 - is used for create or update. This looks good for 
the absurd cat action method. In the next video,  
182:46 - let's add the absurd view. In this video, let 
me add the absurd view, we can right click on  
182:55 - the action method. And we'll click Add view. This 
looks good. Let's add this. Now the opposite view  
183:03 - first thing what will be the model, if we take 
a look at the books controller, we are passing  
183:09 - a book object to the view. So that will be the 
model. So we'll define model. It is book list MVC  
183:18 - dot models dot book, we'll add a br and we'll add 
heading here give it a class of text info. Here  
183:29 - we want to display edit book or create book based 
on the request. If we go back to our controller,  
183:36 - if Id is now then we pass the book object with 
a null ID. So if Id is null, then it is a create  
183:46 - request. So right here now will be zero. So we can 
check at and we'll say if model.id does not equal  
183:56 - to zero. If it is not zero, then display edit, 
else will just display create. Along with that  
184:05 - we want to display book. This way the single line 
will serve both create an edit book to display the  
184:13 - title. We will add br here and we'll add mean to 
give it a class of border and we'll add container  
184:22 - we will give it a style for padding of 30 pixels. 
Within here, let me add a form tag and we'll give  
184:31 - method of post. So that whenever a user submits 
the button, it will go to the post action method  
184:38 - for absurd inside the books controller. Here you 
can also define the action method as absurd. But  
184:47 - since we are on the absurd, if you did not define 
this, that will also work. If it was some other  
184:54 - action method as compared with the name then 
you would have to define it but in this case  
185:00 - we are good. Now when we will be posting it, we 
will need the ID if the ID is not now, so we'll  
185:09 - add an add a fear. And we'll check if model.id is 
not zero, then I want to show that Id in an hidden  
185:17 - property. So input type is equal to hidden ASP 
four will be the ID. Then just like razor pages,  
185:27 - we want validations here. So we'll add class of 
text danger. And we'll use ASP Validation Summary  
185:35 - for model only. Then we'll start displaying our 
property in class of form group and row. And in  
185:47 - each one of them, we'll add a div give it a class 
of column three. First, we want to display label  
185:53 - with ASP for this will be named. And we'll add a 
div give it a class of column six in here, we want  
186:01 - the input type. So input ASP for tag helper. This 
will be for name of the book, and we'll give it a  
186:10 - class of form control. Along with that, we will 
add a span with ASP validation for for our name,  
186:19 - and we'll give it a class of text danger. This 
looks good for our first property. Let me copy  
186:27 - this and paste it two more times. Let me do it 
three times actually, after name, we have author  
186:34 - will copy this and paste it here. And we have ESPN 
will copy and paste it here. Once we complete the  
186:46 - ESPN, next will be button to create or update 
and a link to go back to the page. So we'll have  
186:54 - column three here, let me also make it an offset 
of three. And this one will be three. In here,  
187:02 - let me have a pattern of type Submit. Since we are 
in a form, this will be good. We'll add btn btn,  
187:11 - primary and form control. Then what we want 
to display in button is we want the same logic  
187:20 - that we had right here. So we can copy this, 
and we'll paste it here. Rather than edit,  
187:28 - we will display update or create. Next is a 
link to go back. So right here, we can display  
187:36 - an anchor tag with the tag helper ESP action. 
If we click this action, we want to go to the  
187:43 - index section of books controller. Since we are 
already in books controller, it's okay if you do  
187:50 - not write ASP controller here. And just ASP action 
is sufficient. We'll add some bootstrap classes  
187:58 - here btn success and form control and will display 
back to list. That being said, let's save this.  
188:08 - And let's run our application. In here, if you go 
to book list, and we do not have any data, let's  
188:16 - add a new book and hit Create. Great, we have the 
validations. But when we hit it goes back. We do  
188:24 - not want that. So for that we will add the scripts 
right here. So we'll add section scripts. And in  
188:33 - here, we will add partial name off. If we go to 
our shared we have validation scripts partial  
188:42 - that need to rename and copy this. And we'll paste 
it right here. Let's run our application and give  
188:52 - this another try. Let's go to book list. Let's 
try to add one add create this time it did not do  
189:00 - a postback and displayed the validation, we will 
fill in some details and hit the Create Nothing  
189:08 - will happen. The reason is we have not configured 
the post action method for absurd. Let's do that  
189:15 - in the next video. Now that we have added the 
absurd view, what will happen when we hit a button  
189:24 - with all the details. For that we need to add an 
absurd post action method. So we can just copy  
189:32 - this and we'll paste it one more time. This time 
we need to mention that this is an HTTP POST. This  
189:41 - time we need to mention that this is an HTTP POST. 
And with post methods, we have to use validate  
189:49 - anti forgery token to use the inbuilt security to 
prevent some attacks. That being said in absurd.  
189:56 - Right here you can use book And we'll retrieve 
the object like this when you submit the form,  
190:04 - but if you go to the top right here you are 
using bind property, because of which you do  
190:11 - not need this, you can directly access the book 
object that we have inside our controller. Now,  
190:18 - within the absurd, what is the first thing that 
you should check, we should check if model state  
190:24 - is valid or not. So, if model state is valid, only 
then proceed further. If it is valid, then we will  
190:33 - check here, if both.id is equal equal to zero, 
if this is zero, this means it is a create. And  
190:41 - we will do underscore DB dot books dot add. And 
we will add the book object there. Else it is for  
190:51 - an update. So we'll do underscore db.books.we have 
an update method in here. And we just need to pass  
190:59 - the object that has to be updated, it will update 
this based on the ID inside this book object. Once  
191:08 - all of the system, we need to do underscore DB 
dot Save Changes to push all the changes to our  
191:16 - database. Once the changes have been pushed, we 
want to return back in razor pages we were using  
191:24 - redirect to page in MVC, we will use redirect 
to action, and we can redirect to the index  
191:33 - action. So what it will do is after it saves the 
changes, it redirects to the index action here,  
191:41 - and it will load all of the books again from 
the database. This looks good. Let's run this  
191:47 - and give this a try. Let's go to book list here, 
add a new book, we will fill in some details and  
191:57 - hit the Create button. Great. You can see our 
data tables is also working with the new book.  
192:04 - Let's try to update this. You can see create 
an edit both the functionalities are working  
192:13 - as expected. The only thing that is remaining 
is delete here. Now when you click on delete,  
192:20 - you'll see a nice sweet alert. And if you click OK 
here, it should delete the book. And it displays  
192:27 - nice toaster notification. You can see our create, 
edit, as well as delete are working as expected.  
192:36 - Now with this you can see how we can perform CRUD 
operations on booklist using an MVC project. And  
192:44 - this is just the beginning. That is much more to 
explore in ASP. NET Core. Whether you go with MVC  
192:54 - or razor pages, what we just learned is the tip of 
the iceberg. So if you're interested in learning  
193:01 - more about MVC or razor pages, I have many more 
in depth courses in which we will be building real  
193:09 - world application. But that's all we had for this 
course and good luck with your future projects.