00:00 - hello my name is mario um
00:02 - and i'm going to be doing a
00:04 - maybe a non-conventional crash course
00:06 - for you in elm uh i work at travelport
00:09 - locomote um travelport is one of the
00:12 - three major gds's in the world hands up
00:14 - if you've ever taken a flight before
00:16 - anywhere one in three chance we sold you
00:18 - that flight uh locomote what we do is we
00:21 - do corporate travel
00:22 - so those of you that work at a big
00:24 - corporate
00:26 - awesome come and talk to me later we
00:27 - have a great product for you
00:29 - but yeah we do corporate travel
00:30 - management and um we've been acquired by
00:32 - travelport so as you can probably tell
00:34 - by the accent i'm not
00:36 - english british um i come from australia
00:40 - and our company was started in melbourne
00:43 - but with the acquisition i now live and
00:45 - work in london
00:47 - you can find me on github my handle is
00:48 - super mario that is my actual real
00:50 - handle
00:52 - so
00:53 - the
00:55 - goals for what i'm going to do tonight i
00:57 - was originally thinking of doing um the
00:59 - same format that we do at the elm london
01:01 - meetups um which is to actually do a
01:03 - code night you pull out your laptops you
01:04 - actually work on stuff people get in
01:05 - different groups
01:07 - either you're going from scratch and i'm
01:08 - doing a from scratch tutorial or you're
01:11 - working on projects or you might be
01:12 - advanced and helping with open source
01:14 - stuff
01:14 - but i thought given that i've got a room
01:17 - of presumably javascript and react
01:19 - experience developers
01:22 - the more that i thought about it the
01:24 - more i thought about
01:25 - my own journey into discovering kind of
01:26 - element functional programming and the
01:28 - things that prevented me from
01:29 - understanding
01:30 - the
01:31 - value of those things to myself and what
01:33 - they would give me in my kind of
01:35 - day-to-day work and i thought it might
01:37 - be more valuable if i gave you a swathe
01:39 - of those kind of things because i found
01:41 - those really hard to find online i mean
01:43 - you control through lots of blog posts
01:45 - and things and try and scrape things
01:46 - together but until you've really kind of
01:48 - tasted
01:49 - um element functional programming for
01:51 - yourself it's really hard to understand
01:52 - some of those concepts so i wanted to
01:54 - maybe instead give you a little bit of a
01:56 - teaser of those things that you might
01:57 - not find so easily and then give you the
02:00 - resources of which there are plenty of
02:01 - for you to just learn like elm syntax
02:03 - and stuff so i'm going to try and cover
02:05 - things that might not be obvious i'm
02:06 - still going to go through a little bit
02:07 - of alum so you've got a bit of grounding
02:09 - but i'm going to talk about some awesome
02:10 - things that um
02:12 - that exist in the elm community that may
02:13 - not be obvious straight away i'll talk
02:15 - about some pitfalls and then i'll give
02:17 - you some references for more stuff
02:19 - um cool so
02:23 - this is an lmap
02:25 - that you're currently looking at some of
02:26 - you're still joining
02:27 - so let's just start really easy how are
02:29 - you feeling
02:31 - everyone's feeling good hopefully
02:33 - awesome
02:34 - uh
02:35 - no one's feeling bad that's great
02:37 - javascript experience
02:39 - zero starting confident or pro pro
02:42 - meaning you work in javascript
02:43 - professionally
02:49 - okay so we've got some people that are
02:51 - zero some people that are starting this
02:53 - is going to be awesome for you for the
02:54 - rest of you you've got prior knowledge
02:56 - that's going to hold you back
02:57 - i'm just kidding
02:59 - elm experience um has
03:01 - how has your elm experience been in
03:03 - terms of exposure or reading or anything
03:07 - awesome we have some elm developers here
03:10 - most of you zero okay great so um
03:13 - hopefully for those of you that are zero
03:14 - this will be
03:15 - informative and useful and help you
03:17 - understand one is elm something that
03:19 - you're interested investing your time in
03:21 - and secondly what it might
03:24 - give you generally
03:26 - okay cool so
03:28 - normally what happens sorry
03:31 - normally what happens with this is um i
03:33 - go through a set of live slides
03:35 - and you've got on your devices a set of
03:36 - reactions so you can give me like you're
03:38 - okay or you're confused thumbs up thumbs
03:41 - down thinking face falling asleep
03:44 - or bookmarks and then at the end of the
03:46 - talk
03:47 - you can put your email address in and
03:48 - get all that stuff back sounds really
03:50 - awesome except i'm not going to give it
03:51 - to you um because i didn't get to
03:53 - prepare these slides in the software so
03:55 - we're not going to use this i'm going to
03:56 - step out of it
03:57 - but this is more just to give you an
03:58 - idea that this is an app that i've used
04:01 - in in past talks um if you look at the
04:03 - elm europe conference you can see me
04:04 - doing it live on stage engaging the
04:05 - whole audience
04:06 - and it's something that i've tried for a
04:08 - number of years to build in lots of
04:10 - other things and i always kind of got to
04:12 - the point where i just couldn't keep
04:13 - pushing further the complexity in
04:15 - whatever language i worked in really
04:16 - really held me back
04:18 - and i think this is probably my best
04:19 - testament for myself personally
04:21 - of
04:22 - what elm can give you as a developer
04:25 - because it's the first time i've
04:26 - actually been able to succeed with a
04:27 - project of this kind of scale so anyway
04:29 - let's uh let's run through uh
04:32 - the president you can come talk to me
04:34 - afterwards if you want to know more
04:35 - about the elm app software so i'm going
04:38 - to avoid these things today
04:41 - because i think that there's better
04:42 - resources than me speaking to you for
04:44 - finding that stuff um so learning
04:45 - detailed syntax um fp concepts as a
04:48 - whole um and looking at comprehensive
04:50 - code examples it's probably better off
04:52 - in your own time and at your own pace so
04:53 - i'm going to avoid that kind of stuff
04:55 - but i will give you
04:56 - um
04:58 - things that you can
05:00 - look at afterwards for diving into more
05:02 - detail on those things so what i am
05:04 - going to go through is i'm going to give
05:05 - you a high level of what is elm i'm
05:07 - going to try and disambiguate some stuff
05:09 - that
05:10 - in my opinion i feel you might run into
05:12 - if you try and learn it yourself
05:15 - we'll run through some code but at a
05:16 - very basic level
05:18 - and i'm going to run through the elm
05:19 - architecture which i think is probably
05:20 - one of the big tripping points that
05:22 - people run into
05:23 - you know this question of is ellen the
05:25 - library is it a language
05:27 - and and trying to figure out what it
05:28 - actually does and how you do things i'm
05:30 - going to try to talk through some some
05:32 - awesome things at least as far as i find
05:34 - them
05:35 - roughly talk about how do i use element
05:37 - work which may be an interest point to
05:38 - some of you and then i'll give you some
05:40 - caveats
05:41 - that i found for myself personally
05:44 - awesome
05:45 - okay what is ellen
05:47 - so by its own admission this is on the
05:49 - top of the elm site elm is a delightful
05:51 - language for reliable web apps
05:53 - you can generate javascript with great
05:55 - performance and no
05:56 - runtime exceptions that's almost
05:58 - guaranteed
06:01 - so in more detail it's a functional
06:02 - language it's statically typed but it
06:05 - has type inference so if you don't want
06:07 - to write types you cannot
06:09 - and elm will still figure out the types
06:11 - view up until a point
06:13 - all data is immutable so there is no
06:15 - such thing as immutable
06:17 - value or reference or object in elm
06:20 - everything's immutable by default
06:22 - that's part of the language you can't
06:24 - opt out of that
06:25 - all functions are pure which means that
06:28 - every piece of code that you ever look
06:30 - at in elm
06:31 - the answer to the question of what does
06:32 - this code do the answer is nothing
06:35 - it takes inputs and it returns a value
06:37 - but it won't make any effects it won't
06:39 - change anything in the outside world it
06:41 - won't ask the outside world of anything
06:43 - it will literally do nothing so every
06:45 - line of code in any lm code base you
06:47 - ever look at has these two guarantees um
06:50 - null undefined and exceptions don't
06:52 - exist they're not part of the platform
06:54 - they're not part of the language you
06:56 - can't type null and have it compile
06:59 - and nothing within your elm code can
07:02 - throw an exception or give you back a
07:04 - null so those kind of things are removed
07:06 - from the language um so the these are
07:08 - all rather intentional choices and they
07:10 - have some really really interesting
07:11 - implications when you when you don't
07:13 - have these kind of things in your or
07:14 - rather when you have these kind of
07:15 - guarantees in your language um it
07:17 - actually comes out to be a very very
07:19 - interesting subset of
07:21 - um of the kind of programming that you
07:23 - may be experienced in already
07:26 - so to answer the question
07:28 - of exactly elm library this kind of gets
07:32 - confusing when you start looking at um
07:34 - stuff online
07:35 - if you're familiar with i mean how many
07:37 - of you using this kind of stack or
07:38 - something loosely related to this yeah
07:41 - cool
07:42 - so you know you get really excited you
07:43 - want to start with javascript like right
07:44 - how do you install packages oh you can't
07:46 - you gotta get npm right okay now i have
07:49 - npm like how do i bundle stuff together
07:50 - like you can't you gotta get webpack
07:52 - cool and then you know react at the
07:54 - moment you're all here because this is
07:55 - reactivate but this is you know a more
07:58 - recent paradigm before there used to be
07:59 - many other choices and spine and
08:01 - backbone and um you know more modernly i
08:04 - guess angular as a competitor but
08:06 - there's a lot of different options there
08:07 - so you have to pick one maybe you pick
08:08 - react
08:09 - then eventually you get to a point where
08:11 - you've got too much local state and your
08:12 - components are trying to send stuff
08:13 - everywhere and you're like ah how to
08:15 - solve this problem and you go oh redux
08:16 - so you learn redux you bring that in
08:19 - now you've got this problem where you
08:20 - know you add a new action in redux and
08:23 - now you don't know all the parts in your
08:24 - code that need to be updated so maybe
08:25 - you get something like typescript to
08:27 - flow to bring some level of kind of
08:29 - checking to figure out i've added stuff
08:31 - here and now my code breaks over here so
08:33 - you kind of bring that into the language
08:35 - then you get to the point where you're
08:36 - like oh you know mutable references are
08:37 - really killing us we're passing objects
08:39 - and accidentally setting methods on them
08:41 - and losing control of our state so you
08:43 - go well maybe we need to bring immutable
08:45 - js into
08:48 - a stack
08:49 - so what's the experience like when you
08:51 - start elm
08:52 - well you go well how do i get packages
08:56 - well that's built into elm yeah cool so
08:58 - how do i get all my files compiled into
09:00 - a single version that's built into elm
09:02 - you go okay so how do i actually
09:04 - architect my code how do i do the view
09:06 - layer and all that kind of stuff well
09:07 - that's actually built into elm so you go
09:10 - cool so how do i manage my state when it
09:11 - gets really big that's built into elm uh
09:13 - what about type checking and flow that's
09:16 - built into elm and immutability as i
09:18 - mentioned is also built into our so the
09:20 - analogy i've been trying to use recently
09:22 - for this is when people say oh well it
09:23 - can't be a language that has too many
09:25 - features
09:26 - it would probably be i'm assuming um
09:29 - similar to originally when memory
09:31 - management was all manual and you're a c
09:33 - developer and something like javascript
09:35 - came along
09:36 - now like we have automatic memory
09:38 - management now you're like so that's a
09:40 - library you're like no no it's a
09:41 - language feature and like i can't be a
09:44 - language feature like that's too
09:46 - featureful um so this is kind of the
09:48 - same in that same sense so when we say
09:51 - that elm has these things built in it's
09:53 - not built in as a library
09:55 - that you use
09:57 - it is actually the language so there's
09:59 - only one
10:01 - architecture in elm it's called the elm
10:02 - architecture there's only one way to
10:04 - structure on that initial set of code
10:06 - and that's all baked in all the
10:08 - libraries that you build in are for
10:10 - various other bits and bobs around
10:12 - is that making sense
10:14 - getting some nonsense lovely
10:16 - um
10:18 - now it's not all in isolation there is
10:20 - kind of like a lot of cross flow and
10:23 - lots of lots of the stuff that's in
10:25 - that react stack if you're already
10:26 - familiar with it lots of stuff in elm
10:28 - will just seem really really natural um
10:31 - so this is just a quote from the um
10:34 - dan abramov the author of redux
10:37 - who has quoted as pulling certain ideas
10:40 - back from elm so if you use redux you're
10:42 - actually using a
10:44 - subset of the same kind of function that
10:46 - that operates in elm so that kind of
10:48 - stuff will come natural to you um the
10:50 - the difference i feel though is that
10:53 - here you've got a lot of disparate
10:54 - components with lots of different
10:55 - authors different styles and different
10:57 - integration points
10:58 - whereas in elm the whole ecosystem is
11:00 - built around the premise that the call
11:02 - language has these functions so there's
11:04 - a huge amount of effort put into them
11:07 - working together really really really
11:09 - really nicely so a lot of the pain
11:11 - points that you may see on the left hand
11:13 - side when you kind of come over to the
11:14 - elm side um my experience has been those
11:17 - pain points are either way reduced or
11:19 - just non-existent um in that kind of
11:22 - environment so let me let me uh
11:24 - dive a little bit deeper into that
11:26 - side note let's just take a slight
11:29 - detour
11:30 - and then i'll come back
11:32 - um
11:33 - there's a personal bug bear of mine and
11:35 - it uh
11:37 - maybe it won't be the same for all of
11:38 - you but it really impacted my ability to
11:40 - learn functional because when i came up
11:43 - against these two things i was really
11:48 - defensive of my existing experience and
11:51 - a bit insulted that there could possibly
11:53 - be something that i didn't already know
11:55 - in programming
11:56 - so for me it was really humbling having
11:58 - to probably battle through a year worth
12:00 - of self-learning before i got kind of
12:03 - past these concepts and i think that
12:04 - they're needlessly complicated
12:06 - especially has anyone here tried to
12:07 - learn haskell or idris or any other kind
12:10 - of functional languages well i'm hoping
12:12 - your experience is better than mine but
12:13 - you know like
12:15 - space burritos and homomorphisms over
12:17 - funk to monads and it's kind of like the
12:19 - mathematics and the language and the
12:21 - kind of tone of that community is really
12:22 - really are really difficult to approach
12:24 - so i just wanted to kind of debunk two
12:25 - things that hopefully will help you
12:29 - separate hype from understanding a
12:31 - little bit more so two things
12:32 - unbreakable and functional um so what do
12:34 - we what do we mean when we say breakable
12:36 - yes i know it was a bit of a clickbaity
12:39 - title saying building unbreakable
12:40 - software um
12:42 - let me give you two statements first
12:44 - statement being is the sky is green
12:46 - most of you probably think that's wrong
12:49 - but like what if we're riding a computer
12:50 - game you know and maybe the sky is green
12:53 - or what if we're in the northern
12:54 - hemisphere and it's night time so this
12:57 - guy's green for those reasons
12:59 - uh
13:01 - might be wrong might be not like this is
13:02 - this is about semantics right this is
13:04 - what our job as program is
13:06 - is
13:07 - to take models of the real world and
13:09 - understand their semantics and then
13:11 - emulate them in code and we can get that
13:13 - wrong
13:14 - and probably unlikely for quite some
13:16 - time that anything's going to
13:17 - automatically replace that right because
13:19 - that's the thinking and the logic that
13:20 - really matters
13:21 - say for
13:22 - you know our ai overlords in the future
13:26 - uh
13:27 - here's the second statement this guy is
13:28 - uncaught type error cannot read property
13:30 - color of null anonymous
13:35 - this is broken i don't think you would
13:37 - ever want to have this feature
13:40 - i mean unless
13:41 - maybe you were writing like ironic
13:42 - javascript poetry or something but like
13:49 - this distinction wasn't really clear for
13:50 - me until i
13:52 - worked with functional programming
13:53 - because for me this was kind of normal
13:55 - life right like
13:56 - you can't avoid this
13:58 - this is what programming is this happens
14:00 - all the time it's called a bug and you
14:02 - fix it and you kind of move on
14:04 - and the premise of functional was yeah
14:05 - you can like you can just not have these
14:07 - in your life
14:08 - at all
14:09 - um and that kind of
14:10 - i really really struggled with so the
14:12 - reason i struggled with that is because
14:14 - of this definition
14:15 - functional will not save you from
14:17 - semantic incorrectness but it can save
14:19 - you from things that are actually broken
14:22 - we don't necessarily need to have these
14:24 - in a language
14:26 - the second
14:29 - thing um that i wanted to side note on
14:31 - was this whole notion of functional you
14:33 - know people say oh javascript's
14:34 - functional um that's
14:36 - not not true
14:38 - but
14:39 - the premise is that javascript has both
14:41 - functional features and imperative
14:42 - features and in between those two kind
14:45 - of paradigms there are actually some
14:47 - compromises yes you can draw good ideas
14:49 - from both things
14:50 - but ultimately one of the
14:53 - kind of premises of functional is
14:55 - functions and the mathematical sense
14:58 - where functions don't do things if a
14:59 - function does something we then define
15:01 - that as a procedure
15:03 - so
15:04 - straight away the fact that you can take
15:06 - imperative features and sprinkle them
15:07 - anywhere
15:08 - you put yourself in a situation where
15:10 - there's compromises and fp practices
15:12 - really require discipline
15:14 - so this is why
15:15 - you know especially redux is a good
15:17 - example of that people who maybe are new
15:18 - to the react stack and haven't used
15:20 - redux before and drag it in because they
15:22 - think that that's what they need as a
15:24 - baseline
15:25 - and it turns out maybe they don't yet
15:26 - need that now they're doing all these
15:27 - crazy things all over the place and
15:29 - trying to manage all this i'm kind of
15:30 - kind of a boilerplate um for this
15:33 - alleged
15:35 - benefit of fp
15:37 - while simultaneously having the ability
15:39 - to escape hatch and do their imperative
15:41 - stuff and i think you know path of least
15:43 - resistance the temptation is really
15:45 - really hard to do imperative features so
15:46 - i think my experience has been that
15:48 - functional features are really amazing
15:50 - learning them helps you think
15:51 - differently but ultimately wherein
15:52 - you're where you're in a code base
15:54 - especially under commercial pressure or
15:56 - time pressure you're going to compromise
15:58 - and do the imperative things um in a
16:00 - functional language as i define it uh
16:02 - you have functional features and that's
16:04 - it
16:04 - so there is no back door fp practices is
16:07 - the default you can't accidentally
16:08 - mutate stuff you can't accidentally do
16:10 - effects
16:11 - because it's kind of constrained so the
16:12 - premise is not to infantize a developer
16:15 - and say oh you can't manage this stuff
16:17 - but actually to say hey maybe when we
16:19 - don't have certain things here it
16:21 - actually helps us write better code
16:22 - right faster with more confidence and
16:24 - that's true of what i've found in l
16:27 - okay
16:29 - enough talking should i show you some
16:30 - code
16:32 - yeah
16:34 - okay so like i said i'm not going to go
16:36 - into super detailed examples but i'm
16:38 - going to give you a basic counter
16:40 - so that
16:41 - you see a full complete
16:44 - could deploy to production
16:46 - piece of elm code and then i'm going to
16:48 - use that to talk about the elm
16:49 - architecture that's powering things
16:51 - underneath
16:52 - does that make sense
16:53 - cool so i'm going to step through it and
16:55 - i'm really sorry i hope that you can all
16:57 - see
16:58 - um is that okay for everyone or is it
17:00 - struggling
17:03 - half nods okay um so uh at the top of a
17:06 - elm file um
17:08 - simply open a new elm file call it
17:10 - app.elm or whatever you want um we're
17:12 - gonna put module main
17:13 - exposing the syntax for dot dot means
17:16 - that we're exposing everything in this
17:17 - file we could choose to expose only
17:19 - certain functions if we were writing
17:20 - like a little library module but in this
17:22 - case we said wildcard just include
17:24 - everything we're going to import some
17:26 - stuff from the core library
17:28 - i'm going to import two things
17:30 - from the html library i'm going to
17:32 - expose uh four functions remember like i
17:35 - said before they're all functions they
17:36 - don't do anything they return values so
17:38 - beginner program um takes a bunch of
17:40 - parameters and returns a program value
17:42 - that l will run um button div and text
17:45 - are all
17:46 - functions that take a set of arguments
17:49 - for attributes a set of arguments for
17:51 - children and they return a virtual
17:53 - representation of what that markup might
17:55 - be
17:56 - that's all i kind of need and the
17:57 - onclick function will take a message
18:00 - type that i want to trigger and it'll
18:02 - give me a tribute that i can put in an
18:04 - element
18:05 - so
18:06 - in
18:07 - every elm app you'll experience
18:10 - at the basic level we write four things
18:14 - they are the only four things we ever
18:15 - write so once you learn these four
18:17 - things you can approach any lmap and
18:19 - immediately know where to start and what
18:21 - to look for so the four things are our
18:23 - initial model which is our initial state
18:26 - a
18:27 - type we're going to call it message you
18:28 - could call it whatever you want but
18:29 - we're going to call it message this is
18:30 - going to be um so if you know redux this
18:32 - is an action so all the actions that our
18:34 - app supports
18:36 - um we're going to write so they're the
18:37 - two they're the two models or the two
18:40 - two values that we're gonna write and
18:42 - then we're gonna write two functions
18:44 - one is an update function
18:46 - this update function will receive at a
18:48 - given any given point in time a message
18:51 - and the current model
18:53 - and what we need to return back is the
18:55 - new model based on our business logic
18:58 - so all of the business logic for an elm
19:00 - app sits in this function
19:03 - just one place
19:05 - then we've got the view and the view is
19:06 - very similar to what you might ex might
19:08 - have seen in react except here it's
19:10 - explicit it explicitly takes in a model
19:13 - and we will return to markup so let's go
19:14 - and implement that so for the counter
19:16 - we're going to start our counter with a
19:18 - value of zero our whole model is just
19:19 - going to be a single integer our model
19:21 - could be anything it could be a hash
19:23 - type with lots of things in it which is
19:25 - normally what you'd get to in a bigger
19:26 - app but let's just start with um just
19:28 - plain old value um for the message type
19:30 - uh or we want to be able to sorry i
19:33 - didn't actually show you the the button
19:34 - that we're sorry
19:36 - you're going blind uh so this is the
19:38 - this is the app that we're going to
19:39 - build so you can plus plus on the
19:40 - counter minus and we have no guards in
19:43 - our business logic so you can go
19:45 - negative
19:46 - cool
19:48 - okay so
19:52 - if you think about that up in terms of
19:53 - the actions we have we really just have
19:54 - two actions we want the counter to go up
19:56 - we want the counter to go down so we're
19:58 - going to just create two
20:00 - two
20:00 - types here in the message type so
20:02 - message is either going to be increment
20:05 - or it's going to be decrement
20:07 - i'm not going to stress this too much
20:08 - because it takes a little while to
20:10 - kind of learn this concept but
20:13 - you can kind of think of this a bit as
20:14 - an
20:15 - enumeration for now if that makes it a
20:17 - little bit easier
20:18 - or you can note that uh boolean has
20:20 - exactly the same type signature
20:22 - so type boolean is true or false where
20:25 - true and false are the actual values
20:26 - that get passed around you don't really
20:28 - pass around boolean does that make sense
20:29 - so increment and decrement are two
20:31 - actual values they're kind of like
20:32 - labels they're labels that we can pass
20:34 - around and they'll
20:36 - be type checked so we can't put a label
20:38 - that doesn't exist someone that doesn't
20:39 - exist
20:40 - um okay so our update function
20:43 - usually 99 times out of 100 we will
20:46 - start with a case
20:48 - and a case is as you would expect the
20:49 - messages of the message type so we're
20:52 - going to case on increment well if we're
20:54 - incrementing that's the message that we
20:55 - received um we're going to return model
20:57 - plus one if we're decrementing we're
20:59 - going to return model minus one
21:02 - and our view is going to use our
21:04 - functions so
21:08 - let's focus on this middle function
21:09 - first
21:10 - so you can see that the divider has no
21:12 - attributes so putting nothing in the
21:14 - tribute it's just the plain div and as
21:16 - its contents we're putting a text node
21:18 - so that's just a root text node with no
21:20 - wrapping
21:21 - and we're putting a two string of our
21:22 - model so model is an integer two
21:24 - stringed into the text version that's
21:27 - gonna be text node so that's gonna sit
21:28 - in the middle
21:29 - before and after we're creating two
21:30 - buttons the buttons do have attributes
21:32 - one has an attribute of onclick
21:34 - decrement the other one has an attribute
21:36 - of onclick increment
21:37 - and then they have the individual text
21:39 - nodes that they're showing and then
21:41 - those all those values are wrapped in a
21:43 - div
21:44 - that has no attributes and that's what
21:46 - we return back
21:49 - is everyone comfortable that they
21:51 - understand
21:52 - on a high level what this code does
21:54 - syntax aside for a second
21:58 - this is the last line that stitches
22:00 - everything together
22:01 - so elm always looks for an entry point
22:03 - called main
22:05 - and in main we have to give elm a
22:08 - program value so it's a value
22:11 - that describes how our program functions
22:14 - so what we're
22:20 - what we're doing here is
22:22 - we are
22:23 - taking the beginner program which is the
22:26 - the function that we've got from the
22:28 - elmcore library and it takes
22:31 - a hash
22:32 - that has three parameters or three
22:34 - attributes in it a model a view and an
22:37 - update so literally the stuff that we've
22:39 - just written the four things that we've
22:40 - written save for the the message type
22:42 - and we say to um okay well this is what
22:44 - our state looks like here's the initial
22:46 - model take that away lovely um here's
22:48 - the view function that i want you to run
22:51 - for me and whenever there's a new model
22:53 - and here's the update function that i
22:54 - want you to run for me whenever you get
22:56 - a message
22:59 - so the net outcome of that is
23:01 - um this little app
23:04 - and as you can see heading plus is
23:07 - triggering that message
23:09 - minus is pulling it back down
23:11 - um
23:16 - yeah okay any questions at this point
23:22 - more comfortable all right i'm just
23:23 - going to bang on the point a little bit
23:25 - um so that view function that we wrote
23:27 - takes a model and it returns something a
23:29 - value called html in elm it is an actual
23:32 - html similar to the way that react does
23:34 - it because ellen has a virtual dom
23:36 - implementation so it's efficiently
23:38 - checking for changes and things like
23:39 - that and managing the dom for us we
23:41 - don't go anywhere near the dom we just
23:42 - tell elem well here's what a markup
23:44 - should look like for that state you gave
23:46 - me
23:47 - so that's that's always a new set of
23:49 - html
23:51 - the update model works similarly it gets
23:52 - a message in the current model
23:54 - we do whatever logic we want make
23:56 - whatever changes we want to a new model
23:58 - and we give a new model back we can't
24:00 - mutate that old model
24:03 - so
24:05 - i'm going to try and visualize it again
24:06 - in another way and hopefully just just
24:08 - really syncs it in so here's our home
24:10 - runtime which we don't control the l
24:12 - runtime happens outside of our control
24:14 - we simply gave it our initial model we
24:17 - gave it our update function we gave it
24:18 - our view um so now we've compiled that
24:21 - we've booted up our javascript in the
24:22 - browser and our app is running so we've
24:25 - clicked
24:26 - a button
24:27 - which has fired one of our
24:29 - messages and remember that markup can
24:32 - only have the messages that we defined
24:33 - in our app if we typed any other kind of
24:35 - message there that was unhandled that
24:37 - would fail at compile time
24:38 - so the browser is going to give us a
24:40 - message type and it's guaranteed that
24:42 - that's going to be a message type we
24:42 - know about
24:44 - so the runtime is immediately going to
24:45 - do two things
24:46 - first it's going to send that uh
24:49 - to the update function call update
24:50 - function and get back the new model
24:52 - and it's going to go cool i'm going to
24:53 - retain that model that's the new model
24:55 - now
24:56 - then it's going to go right view
24:58 - function here's the model get me back
24:59 - that html
25:01 - great i've now got that html and it's
25:03 - going to do the virtual dom differing
25:05 - calculate the dom differences and
25:06 - actually communicate
25:08 - that back into the layout
25:13 - they're unhappy so far with that
25:16 - nods but like more furrowed brows now
25:22 - hopefully furrowed um because you're
25:24 - thinking well this is really nice mario
25:27 - but
25:28 - how do you actually do anything
25:32 - with the outside world
25:34 - um
25:35 - so like i said before the guarantee that
25:37 - we have when we're looking at any elm
25:38 - function
25:39 - in code is that it's not going to be
25:41 - doing effects
25:42 - so say we wanted to
25:44 - um
25:45 - write a little app where you pressed the
25:47 - button and it fetched a new gif of a
25:50 - hilarious cat
25:52 - animation right
25:53 - so when that button is pressed we would
25:55 - like to send an ajax request or
26:00 - a request to a server to get a new url
26:02 - and we'd like to get that request back
26:03 - and change it
26:05 - well actually it functions in exactly
26:09 - and exactly the same way as the browser
26:10 - so
26:11 - what we write in terms of our app
26:12 - doesn't change we still only have four
26:15 - things we have the model we have the
26:16 - types of messages that we can expect
26:19 - we have our update function which
26:22 - has our business logic and we have the
26:24 - view except what happens now is when um
26:26 - that message type comes through
26:28 - um this kind of upgraded so this is
26:30 - html.program we're on beginner program
26:32 - we've gone to program now so the type
26:34 - signature changes slightly um update
26:36 - function now returns two values instead
26:38 - of one so instead of just returning the
26:41 - model it now also returns an array of um
26:45 - what in l are called commands
26:47 - they're values that represent a command
26:50 - that elm may execute for you later
26:55 - so you can kind of think of it like
26:57 - promises
26:58 - that you cannot resolve
27:01 - there's no mechanism in elm to actually
27:03 - resolve commands yourself the only way
27:05 - to resolve it is to
27:07 - hand them back to the elm runtime
27:09 - so
27:10 - let's say we we'd done this and our
27:12 - request has uh we've asked for elm to do
27:14 - a request for our cat gif well in the
27:17 - meantime elm goes yeah that's nice but
27:19 - i'm gonna
27:20 - i've got a new model i'm gonna run the
27:21 - view and we're gonna put that stuff back
27:23 - in the dom so that whole process happens
27:25 - instantaneously then at a separate
27:27 - asynchronous juncture
27:30 - elm may choose to take that command into
27:32 - what is called an effect manager so elm
27:34 - has an implementation of a certain set
27:36 - of effects that the language supports um
27:39 - http requests to one of them
27:42 - and it will execute that command now
27:45 - when we issued that command what we had
27:47 - to issue along with the command is an
27:49 - instruction to elm of what message type
27:52 - we wanted to get back
27:54 - and so then elm deals with the busy work
27:57 - and the possible failures and the nils
27:58 - and all that kind of stuff and it'll
28:00 - only give us back
28:02 - well-defined conformed guaranteed
28:05 - actually okay messages if they happen to
28:07 - exist yeah so what the effect manager
28:09 - will be doing is it'll be sending back a
28:10 - message note that this message
28:12 - and this one here are the same exactly
28:14 - the same mechanism let's take it in
28:16 - isolation so imagine that that whole
28:18 - loop has happened and we've got our new
28:19 - dom and now asynchronously the effect
28:21 - manager has has triggered a command for
28:23 - us so there's been an event
28:26 - let's say we've successfully gotten back
28:28 - our http request so
28:30 - the message that we've defined which is
28:32 - a message in our update function that
28:33 - accepts back the specific value that
28:36 - we're looking for will get called for us
28:38 - the same thing will happen again
28:40 - just exactly the same route like as if
28:42 - it come from the browser we actually
28:43 - don't know where it's come from
28:45 - i mean it could have come from the
28:46 - browser it could have come from an
28:47 - effect manager we only know by the
28:48 - semantics of the messages the action
28:50 - types that we've implemented um
28:53 - model html view gets run again and the
28:55 - dom gets output so that same mechanism
28:57 - kind of works through for both versions
29:03 - that is the most complicated thing that
29:05 - i ever had to try and figure out with
29:07 - elm so i'm really hoping that that that
29:09 - um unlocks a lot a lot of the runtimes
29:11 - perhaps my favorite thing about elm is
29:13 - that it has the best
29:14 - pair programming buddy i've ever
29:17 - worked with
29:18 - mainly because they have no attitude and
29:20 - they're never wrong
29:21 - and it's just really really pleasant you
29:23 - don't have to talk to anybody like the
29:25 - the compiler just kind of
29:27 - yells stuff at you so
29:31 - i'm going to give you some nice canned
29:33 - scenarios first um just so you see the
29:35 - kind of quality of elmera messages
29:38 - um
29:39 - okay so the first one i'll show you is
29:46 - this name
29:47 - okay so here we've got um
29:51 - soon
29:52 - um here we've got an error from elm
29:55 - and uh this is how it would come up in
29:57 - your console so you could have a live
29:58 - reloader going and it's you save your
30:00 - file and it and it's i'm spitting stuff
30:01 - out or i have it directly in my editor
30:04 - and ellen said hey i've detected an
30:06 - error it's a naming error i can't find
30:08 - the variable list.nap you've lose this
30:11 - as an app a list does not expose nap
30:13 - maybe you want one of the following
30:14 - list.map any map to map three so it's
30:16 - not a heuristic search on on the name
30:19 - which is really nice so it not only does
30:22 - it tell you what's wrong exactly where
30:23 - it's wrong give it a little indicators
30:25 - to highlight specifically on which area
30:26 - of the line it's wrong
30:28 - it also gives you suggestions for other
30:29 - things so this is a live code example
30:30 - that i've just reloaded
30:34 - getting a little bit more advanced than
30:36 - that uh here we've got
30:39 - um an
30:40 - if statement we've said um if n is less
30:43 - than zero then let's return the string
30:44 - negative uh if n is greater than zero
30:46 - let's just turn the string positive
30:47 - otherwise let's return 42. um so elm
30:51 - here is telling us well you've got a
30:54 - type mismatch here the second and third
30:56 - branches of this if produce different
30:57 - types of values the second branch of
30:59 - this type is a string but the third is a
31:01 - number and then it gives you these hints
31:04 - these these are the best thing by far so
31:06 - that's the
31:07 - uh that's the nice can scenario
31:11 - which is what normally gets talked about
31:13 - in talks um
31:15 - so i figured it's probably better to
31:16 - show you where elm really shines in the
31:18 - worst possible scenario
31:20 - luckily i have the worst elm codebase
31:23 - known to me
31:25 - which is my own codebase
31:27 - and i'm just going to go and arbitrarily
31:29 - change something
31:31 - in the
31:31 - [Music]
31:33 - in the application that you're all using
31:35 - on your phones
31:37 - um to try and just give you a little bit
31:39 - of a sense of what it's actually like to
31:41 - do mass refactorings in elm
31:43 - so
31:44 - here we've got a foreign code base um
31:46 - that we've we've never been in before
31:48 - and it's got like tons and tons of code
31:50 - it has no tests like nothing like just
31:52 - you know like absolute horror someone at
31:55 - work has like gone full crazy on elm
31:57 - they've just built all this stuff and
31:59 - they've quit right now it's your job to
32:01 - deal with it
32:02 - and you're like you're ready to like
32:04 - quit your job and you know you're like
32:06 - on stack overflow looking for other
32:07 - stuff and you're like all right uh i
32:10 - remember mario said some stuff like i
32:11 - should recognize the cell map um you got
32:13 - app.um i'm gonna start okay so we've got
32:15 - a program with flags um thing here and
32:18 - we kind of see like okay um init update
32:20 - and subscriptions and some stuff is here
32:23 - um and we've kind of got this types
32:24 - thing here so it seems like uh types is
32:27 - let's say we need to extend this app
32:29 - right we want to we all want to add a
32:30 - new page to the presentation software so
32:33 - we go okay cool well we know that in elm
32:35 - to add a new page we probably need to
32:37 - find
32:38 - a type for that page or we probably need
32:40 - to find the actual core message type
32:42 - that represents all the actions that can
32:43 - happen and add something there
32:45 - so say we go into types
32:47 - we look through we've got type page type
32:49 - aliases we've got things oh here we go
32:51 - type message we go cool so this is all
32:53 - the stuff
32:54 - actually all of the things that this app
32:56 - does
32:58 - there's nothing this app does that isn't
33:00 - here
33:02 - like let that sink in for a second
33:04 - it's a code base that you've never
33:06 - touched before and immediately you
33:07 - already know everything that it does so
33:10 - let's say we go okay
33:12 - my new awesome feature
33:16 - is the new label like when you click a
33:17 - button it's going to trigger my new
33:19 - awesome feature which is going to be
33:20 - amazing
33:21 - and we save this and what we get from
33:27 - what we get from elm basically now is
33:31 - a pair programming buddy that intimately
33:33 - knows the whole code base and has in a
33:35 - split second gone through and checked
33:36 - every single file every single include
33:39 - anywhere that this type might be used
33:41 - and immediately started coming back
33:43 - with errors so the very first error that
33:44 - it's given us
33:45 - is saying well your update function
33:48 - which is in another part of the code
33:49 - remember the update function is the main
33:50 - function with all our business logic
33:52 - saying that update function doesn't
33:54 - cover this new feature that you have
33:56 - you need to go and add that in there so
33:59 - we'll say okay cool where's that update
34:00 - function
34:04 - it's quite a long update function so
34:06 - we're going to scroll to the top like i
34:07 - said is you know like the worst the
34:09 - worst possible code okay so it says
34:11 - state.m and here we go we've found our
34:13 - update function so let's kind of scroll
34:15 - to the bottom of it all the various
34:17 - things
34:18 - remember like worst worst worst possible
34:20 - code
34:21 - um my awesome
34:24 - feature
34:26 - and uh let's just say we're going to
34:29 - return the model as is and we're going
34:30 - to turn command. we're just not going to
34:32 - do anything right it's going to be a
34:33 - no-op
34:34 - now it's saying well can't find pattern
34:36 - my awesome feature why not
34:38 - because it's called my new awesome
34:39 - feature yes thank you pair programming
34:41 - buddy
34:42 - i've made that change now and only
34:45 - saying okay that's pretty good
34:48 - that's good
34:50 - that is all you needed to change nothing
34:52 - else in the code will break you didn't
34:53 - make any other side effects nothing else
34:55 - depends on that new feature you've added
34:57 - you are 100 a okay to deploy this to
35:00 - production
35:02 - so that for me is like
35:05 - chalk and cheese difference to the kind
35:06 - of development that i have day to day
35:10 - so much so that i'm finding it
35:12 - increasingly more difficult to program
35:13 - in other languages without these
35:14 - guarantees just because the
35:17 - level of uncertainty that you gain by
35:20 - working in a language like this kind of
35:22 - really decreases your confidence in
35:23 - other languages so i find myself now
35:25 - when i interrupt with javascript and elm
35:27 - and i'm working with javascript stuff
35:29 - you know with elm you you you write
35:31 - stuff and you compile it and it's wrong
35:33 - and you change it and it's wrong you
35:34 - change it again elm's like no you're
35:36 - wrong and you fix it and it's green
35:38 - you're like
35:39 - well it looks like it's pretty good and
35:41 - in javascript you change something
35:43 - and you're like where's the thing that
35:44 - tells me
35:45 - ah
35:47 - maybe it's okay i don't know like you
35:49 - gotta potentially now go write tests do
35:51 - your tests cover every single case
35:53 - potentially not
35:54 - so the wrong and broken difference that
35:57 - kind of broken bit just kind of
35:58 - disappears but the wrong bit is still
36:00 - your responsibility
36:03 - everyone's somewhat satisfied with the
36:05 - real life example
36:06 - okay
36:10 - cool
36:11 - very quickly i'm ending off with some
36:13 - high-level stuff so um lm packages have
36:15 - auto semva um so again when i talked
36:18 - about uh the nice side effects of having
36:20 - enforced purity and
36:22 - um
36:25 - side effect free code
36:27 - elm can look at your library and all the
36:29 - type signatures that you have exposed if
36:31 - you have changed no public interfaces l
36:33 - will minor version increase if you have
36:36 - added a public interface it will
36:39 - the middle version increase and if you
36:41 - have removed a public interface it will
36:42 - major version bump your code you can't
36:45 - change your own version numbers in elm
36:47 - packages it just does it entirely for
36:49 - you the flip side of that is when you're
36:52 - pulling down new package updates elm can
36:55 - automatically or you can safely pull in
36:57 - minor and
36:59 - intermediate versions because you know
37:01 - that they haven't fundamentally they
37:03 - shouldn't have changed
37:04 - they wouldn't have changed any of the
37:05 - interfaces they may have changed some
37:07 - behaviors but generally it's a lot safer
37:09 - and if you're dealing with a major
37:10 - change you know that something's going
37:11 - to be removed even still
37:13 - bringing that package in with a major
37:14 - change you're pretty happy because the
37:17 - elm compiler will then immediately tell
37:18 - you every single place in your code base
37:20 - where your usage of that package is now
37:22 - broken
37:24 - so you still have the protection and
37:25 - optional choice on whether you want to
37:26 - engage in that work or not but when you
37:28 - do upgrade it gives you like a bucket
37:30 - list of exactly how to upgrade which is
37:32 - pretty awesome
37:33 - the elm packages site if you want to
37:35 - kind of look at the kind of packages
37:36 - that exist in the om community they're
37:38 - on packages.online.org
37:41 - yeah check it out there's so much more
37:43 - to say there
37:44 - compiling elm so i haven't talked about
37:46 - how elm actually works in terms of
37:48 - compilation so like i said even though
37:49 - it has all this library stuff it is
37:51 - fundamentally a separate language that
37:52 - has its own runtime um so it's got its
37:54 - own compiler so you take you write a
37:56 - bunch of elm files and they run through
37:59 - the compiler and you get compiled
38:01 - javascript that includes both your code
38:03 - and the runtime and all the libraries
38:04 - and everything to do with it all kind of
38:05 - packaged up
38:07 - if you're in a project that has
38:09 - javascript files already you're probably
38:10 - going to want to
38:11 - pull in elm incrementally um into
38:14 - certain bits to try it out or to have
38:17 - kind of some interrupt
38:18 - so
38:19 - the very very simple way to do that is
38:20 - through webpack webpack has a elm
38:23 - webpack loader
38:24 - which will simply allow you to require
38:27 - elm files directly and then mount
38:31 - that elm app to whatever node you
38:33 - actually want that to attach to and then
38:34 - run the rest of its stuff through
38:37 - uh how do i use element work uh the
38:40 - answer is gradually there's actually a
38:42 - blog post by
38:44 - um the author of elm himself his name is
38:46 - evan um and he he talks about the
38:49 - incremental approach and also um what
38:51 - he's seen in his experience of the the
38:54 - number of years that he's been um
38:56 - improving elm for on projects that have
38:58 - succeeded
38:59 - and yeah generally the premise is that
39:01 - you take a small area of an existing app
39:04 - um or or if you're starting from scratch
39:05 - if you have that luxury
39:07 - and you can just try elm out in a very
39:09 - small section and experiment and see if
39:11 - it meets your needs and if it works well
39:12 - enough for the domain that that you
39:14 - write in and then if it does you simply
39:16 - just take more and more chunks of that
39:18 - tree or put elm in multiple places
39:20 - around your app
39:23 - so for those of you
39:25 - that are using react there's a kind of
39:27 - like a canonical example um by evan
39:29 - himself of uh react components um so
39:32 - very simply you're importing uh the elm
39:35 - uh
39:36 - elm wrapper for reactant components
39:37 - you're importing your lmap from wherever
39:39 - it might be like the compiled code and
39:41 - then you can just put that straight into
39:45 - a react render function there's a very
39:46 - simple example there's more complicated
39:48 - examples where if you want to pass some
39:49 - values of mlm initially or if you want
39:52 - to actually talk to and from that
39:54 - application um but
39:56 - all of this is like a 20 line wrapper
39:58 - it's really really simple so just with
40:00 - plain javascript you literally if you're
40:02 - using the l modpack loader you're
40:03 - requiring
40:05 - that javascript that um you've written
40:07 - and you can just embed it to a node
40:09 - that's the only attached point to get
40:11 - started
40:13 - cool cavetts
40:17 - general purpose programming language
40:18 - gets kind of thrown around a lot so
40:20 - something that i again i got cut on so i
40:22 - kind of want to put out there elm
40:24 - doesn't run on the server side yet it's
40:25 - not a server-side language and it's not
40:28 - a general purpose language you could run
40:30 - it on the server if you really wanted to
40:31 - i'm in 0.19 the next version there may
40:34 - be some server-side rendering stuff
40:36 - because a lot of people have been asking
40:37 - about that um but there is a really
40:39 - really good document about general
40:40 - purpose language written again written
40:42 - by evan um that i would recommend
40:44 - reading if that kind of infuriates you
40:46 - for some reason because it's actually
40:47 - really clear and articulate on why this
40:49 - kind of premise doesn't really exist so
40:51 - you know we might say python is a
40:52 - general purpose programming language but
40:54 - you're not going to go right assembly in
40:55 - it we might say c is a general purpose
40:57 - programming language but you're not
40:58 - going to do web development in it so
41:00 - general purpose languages do still have
41:01 - specializations so elem is the same in
41:03 - that sense it's specialization really is
41:04 - to be really awesome at front-end apps
41:08 - uh fiddling with a dom you're gonna have
41:10 - a bad time
41:12 - uh if you really really convinced that
41:14 - you really really need a fiddle with a
41:16 - dom or you have some application that
41:18 - for some reason are doing something with
41:21 - external libraries and pulling in markup
41:23 - and all that kind of stuff um that is
41:24 - not something that elm allows or is any
41:27 - good at really um you can still achieve
41:29 - what you wanted if you talk the reports
41:31 - to um some javascript kind of interrupt
41:34 - but on that side as well java script
41:36 - interrupt is really really strict in
41:38 - order for elm to preserve those kind of
41:39 - guarantees of runtime safety and not
41:41 - exploding on you the way that it talks
41:44 - in and out of javascript is also through
41:45 - a really strict typed interface so it
41:47 - makes sure that the types that come back
41:49 - are actual types that your app can
41:51 - handle and keeps anything else out so
41:53 - kind of all the javascript errors stay
41:54 - on the outside and the arm stuff stays
41:56 - pure
41:57 - and yeah this one's a little bit cynical
41:59 - but you
42:00 - you legitimately may be more frustrated
42:02 - with other languages at least i have
42:04 - been uh cool thoughts after two years of
42:07 - functional programming uh it's not a
42:08 - silver bullet i'm not claiming that um
42:11 - this is the solution for all problems
42:13 - like i've said before i'm not suggesting
42:14 - we go to linus torvalds and say hey
42:16 - let's rewrite linux and elm
42:18 - but i think if you're doing web
42:20 - development um and you're writing web
42:22 - apps which is specifically what um
42:24 - almost engineered for i think it trades
42:26 - off for better problems um the
42:27 - constraints that it gives you it's kind
42:29 - of like lego um if you've played with
42:32 - lego as a kid um you probably didn't
42:34 - think man i really wish i could just put
42:36 - glue and
42:37 - and wood sticks and and cut the lego
42:39 - pieces in half right you just kind of go
42:40 - ah they snap together and suddenly can
42:42 - you build all these kind of things so
42:44 - for me fp is that same kind of thing i
42:46 - don't see the type safety i've never
42:48 - felt it to be a restriction it's just
42:49 - been kind of like an enabler um but if
42:52 - you really really need glue and sticks
42:53 - well then use glue and sticks um i'm yet
42:56 - to see a broken run time i haven't seen
42:58 - one yet there are various edge cases
43:00 - that can cause them you can look them up
43:03 - on the online tracker i think they've
43:05 - gotten them down to like four or three
43:07 - now
43:09 - elm reveals your mistakes
43:11 - so as part of a previous talk i talked
43:13 - about why l made me realize how terrible
43:16 - of a programmer i am
43:18 - it's actually a positive
43:19 - because it improves your code overall
43:21 - but it it kind of does show you
43:24 - like i said before it lowers that
43:25 - confidence that you have in other
43:26 - languages because it increases your
43:27 - visibility of just how much you're not
43:29 - seeing that you're not catching um and
43:31 - refactoring is really awesome i
43:34 - before the last presentation that i did
43:36 - this live
43:37 - talk with i decided to change something
43:40 - from a single field to like an array
43:42 - like i had a one of something and i
43:44 - wanted to have a multi of something and
43:46 - i changed it and it broke the whole code
43:48 - base because my whole thing had been
43:49 - built with a premise of a singular
43:51 - relationship
43:52 - and 15 minutes before the presentation i
43:54 - was like
43:55 - yeah why not ah let's dive in
43:57 - managed to get like all the stuff
43:59 - checked off and all changed and
44:00 - compiling and deployed it and went
44:02 - flawlessly um so my experience with that
44:04 - has been that at a baseline level in the
44:07 - worst possible scenario writing the most
44:08 - terrible code with no tests you still
44:11 - end up in my experience better off than
44:14 - other languages that don't have these
44:15 - guarantees and you do have those kind of
44:17 - tests
44:20 - okay further reading watching uh the elm
44:22 - guide is kind of like the canonical
44:24 - intro um it'll teach you all the stuff
44:25 - that i've violently skipped over like
44:28 - actual um syntax and the type of values
44:31 - that are
44:32 - available and some of the library
44:33 - functions
44:34 - a lot of this talk i've kind of ripped
44:36 - bits and pieces out from kevin yank who
44:39 - does a much better and more eloquent job
44:41 - with much nicer slides and so check out
44:43 - developer happiness on the front end
44:44 - with elm especially if you also work
44:46 - with rails you may find that interesting
44:48 - and then two uh talks recently that i
44:50 - think really address um two problems
44:53 - that that kind of people run into um
44:55 - when they come to um because it's such a
44:56 - different paradigm is you your app gets
44:58 - larger and larger and you wanna scale it
45:00 - um or you you start with a file and like
45:02 - me i kind of started with my first file
45:04 - and once i got to 100 lines i was like
45:05 - oh
45:06 - this is bad
45:08 - 10 files and like modular structure and
45:10 - all this kind of stuff and and so evan
45:12 - talks about why that's the the reasons
45:14 - that we do that in other languages
45:15 - aren't actually present in elm so it
45:17 - doesn't make sense to do that so he
45:18 - talks through a really beautiful example
45:20 - of those kind of assumptions and how
45:22 - they fall over in the life of a file and
45:24 - growing kind of modules out and then
45:26 - richard feldman talks about scaling
45:27 - lmaps until much larger extent richard
45:30 - works at a company called no raid inc
45:32 - and i think it's 200 000 lines of elm
45:34 - code in production they have and their
45:36 - claim is that they still haven't had a
45:37 - single runtime exception so i think
45:39 - that's that's pretty cool so if you want
45:40 - to see either of those kind of things
45:42 - take it from
45:43 - the horse's mouth there
45:44 - um that's all i've got
45:46 - thank you