00:00 - you're about to learn about opengl from
00:01 - victor gordon he has created an
00:03 - excellent course for beginners with
00:05 - simple to follow instructions and
00:07 - informative diagrams welcome to this
00:09 - beginner's course on opengl if you're
00:12 - wondering what opengl is well it's a
00:15 - cross-platform graphics api that allows
00:17 - you to render 3d and 2d scenes with the
00:21 - power of your graphics card usually when
00:23 - programming we use our cpus which are
00:26 - great at doing a huge variety of tasks
00:29 - one after another in a linear fashion
00:31 - but when we deal with graphics a lot of
00:34 - the tasks are very similar and don't
00:36 - usually depend on one another so the
00:38 - fastest way to get a result would be by
00:40 - doing all of them at the same time in
00:43 - parallel this is what gpus or graphics
00:46 - cards excel at opengl is simply a way
00:49 - for us to communicate with the gpu by
00:52 - the end of this course you'll be able to
00:54 - import basic 3d models such as this into
00:57 - your application
00:58 - and have a firm grip on the basic
01:00 - concepts of computer graphics everything
01:03 - from basic buffers used to send data to
01:05 - the gpu to classic lighting algorithms
01:09 - and shaders the only things you should
01:11 - be familiar with before we start are the
01:13 - basics of the c plus plus programming
01:15 - language and the basics of visual studio
01:18 - since that's the ide we'll be working
01:20 - with
01:26 - the first thing you'll want to do is to
01:27 - check you have the latest drivers for
01:29 - your graphics card and the latest
01:31 - version of visual studio
01:37 - next make sure you download the 64-bit
01:39 - windows installer for cmake and go ahead
01:42 - with the installation
01:45 - now download the source package for glfw
01:50 - lastly you need to download glad make
01:53 - sure you select c c plus plus version
01:56 - 3.3
01:57 - core
01:58 - ignore everything else and press the
02:00 - generate button
02:02 - now press on the glad.zip to download it
02:06 - once you've finished installing cmake in
02:08 - visual studio open up visual studio and
02:11 - click on create new project select empty
02:14 - project for c plus click next type in a
02:17 - name for your project make sure the
02:19 - check box is checked and remember in
02:21 - what folder you've placed your project
02:28 - open up the folder of your project and
02:30 - create a new folder naming it libraries
02:33 - now we'll create another two folders in
02:35 - libraries naming them lib and include
02:39 - this is where we later import all our
02:41 - libraries into
02:44 - now we need to extract the glfw zip file
02:47 - and open up cmake in cmake select the
02:50 - folder we've just extracted as the
02:52 - source folder
02:56 - then create a new folder named build in
02:58 - the source folder and select it as the
03:00 - build folder
03:06 - now click on configure and after making
03:08 - sure you have the same settings as me
03:09 - click finish
03:11 - now again make sure you have the same
03:13 - configuration as me and click on
03:15 - configure again
03:17 - click on generate and once everything is
03:19 - done exit from cmake
03:24 - now we want to build glfw so open up the
03:26 - folder you've extracted
03:28 - then build then open up glfw.s
03:32 - in visual studio
03:34 - right click here and select build
03:36 - solution
03:38 - if this gives you any errors it probably
03:40 - means that you've messed around with the
03:42 - build and we'll just have to regenerate
03:44 - glfw using cmake and follow this step
03:48 - again
03:50 - once your build finished successfully
03:52 - exit from visual studio
03:57 - now it's finally time to import our
03:59 - libraries in so open up the glfw
04:02 - extracted folder and go into build
04:05 - source then debug and i'll cut and paste
04:08 - glf3.lib into your lib folder that's
04:11 - inside your libraries folder
04:18 - back to the extracted glfw folder going
04:21 - to include
04:22 - cutting and pasting glfw into the
04:24 - include folder of your project
04:27 - assuming you follow the steps correctly
04:29 - you can now delete the extracted glfw
04:31 - folder and open up glad.zip
04:35 - open up include and extract the two
04:37 - folders into your project's include
04:39 - folder
04:41 - now go folder back and open up source
04:43 - extracting glab.c into your project's
04:46 - main folder
04:48 - we'll now configure our visual studio
04:50 - project to know where to access the
04:52 - libraries from so open up your project
04:54 - and make sure you have 64-bit selected
04:57 - now go to project properties and select
05:01 - all platforms for your platform
05:03 - then go to vc plus plus directories
05:07 - open up include directories and point to
05:10 - the include folder in your libraries
05:12 - folder
05:19 - click ok and now do the same for your
05:22 - library directories with your lib folder
05:33 - once you're done with that go to linker
05:35 - input and open up additional
05:38 - dependencies
05:39 - here we'll write glfw3.lib
05:42 - and opengl32.lib
05:46 - don't worry even though it's called
05:48 - opengl 32 it's still the 64-bit version
05:51 - is just the naming convention now click
05:54 - ok and ok
05:56 - the last thing you have to do is to drag
05:58 - the glut.c file from your project folder
06:01 - into your source files folder in visual
06:03 - studio
06:04 - then right-click source files click add
06:06 - new item select c plus plus file
06:09 - name it main.cpp and click on add
06:13 - now in order to test that everything is
06:16 - fine include this and type int main
06:19 - brackets curly brackets return 0
06:22 - semicolon and run if you've done
06:25 - everything correctly you should get no
06:27 - errors
06:36 - so now we're gonna pick up where we left
06:38 - off and create the window
06:40 - we're gonna use glfw to do that so the
06:43 - first thing we need to do is initialize
06:45 - it so we can properly use its functions
06:50 - and since we've initialized it
06:52 - we should also terminate it before the
06:54 - function ends so i'll add this at the
06:57 - end of the function
06:58 - now glfw doesn't really know what
07:02 - version of opengl we're using so we need
07:05 - to tell it that we can do that by giving
07:08 - it so-called hints with the special
07:10 - function that takes a type of hint and a
07:13 - value
07:15 - for example here i'm giving it a hint
07:18 - that we are going to specify the major
07:20 - version of opengl that we are using
07:24 - and then i give it the version itself
07:26 - which is three
07:28 - since we are using opengl 3.3
07:32 - now i'm just gonna do the same for the
07:35 - minor version which is the exact same
07:37 - one
07:41 - the last hint we have to give it is
07:43 - about which opengl profile we want to
07:46 - use so i'll type glfw underscore opengl
07:51 - underscore profile
07:54 - now an opengl profile is sort of like a
07:57 - package of functions
07:59 - as far as i know there are only two
08:02 - packages
08:03 - core which contains all the modern
08:05 - functions in compatibility which
08:08 - contains both the modern and outdated
08:11 - functions
08:12 - we only care about the modern ones so
08:15 - i'm going to use the core profile
08:21 - now for the window itself
08:24 - this is the data type of a window object
08:26 - in glfw
08:28 - let's just name it window
08:30 - and use the create a window function
08:33 - this will take five inputs the width of
08:36 - the window
08:37 - the height of the window
08:39 - the name of the window
08:43 - whether we want it full screen or not
08:46 - which we do not
08:48 - and the last thing is not important
08:51 - and just to be on the safe side i'll add
08:54 - a bit of error checking in the case in
08:56 - which the window fails to create
09:02 - so great we now have a window object
09:05 - problem is glfw isn't the brightest kid
09:08 - around the block so i'll now have to
09:10 - tell him that since we've created the
09:13 - window we would also like to use it
09:16 - who would have thought
09:20 - this tells glfw to make the window part
09:22 - of the current context
09:25 - a context being a sort of
09:27 - object that holds the whole of opengl
09:31 - it's a bit abstract as context can hold
09:35 - and do many things
09:37 - but we'll just go with this for now
09:40 - now just like before once we are done
09:42 - with the window itself we want to delete
09:45 - it so let's do that at the end of the
09:47 - main function
09:49 - if you run the program now you'll maybe
09:51 - be able to spot a window pop up and
09:54 - instantly disappear into oblivion
09:57 - that happens because once the main
09:59 - function finishes creating the window it
10:02 - just continues to go about its business
10:05 - and tries to reach the end of itself
10:07 - which when it does it ends the whole
10:09 - program
10:11 - in order to stop that from happening we
10:14 - need to make a while loop which will
10:16 - only end on the condition that the
10:18 - window should close
10:20 - that condition will only happen when we
10:23 - press the close button
10:25 - or if another function tells the window
10:28 - to close
10:29 - and now just one more thing before we
10:31 - get our glorious window we need to tell
10:34 - glfw to process all the pulled events
10:38 - such as the window appearing being
10:41 - resized and other such things
10:44 - if we don't process those events the
10:46 - window will just be in a state of not
10:49 - responding
10:50 - and now
10:51 - press run and watch the fruits of your
10:54 - labor
10:56 - but i find this white window kind of
10:59 - boring so let's add some color to it
11:03 - we'll start doing that by finally using
11:06 - glad and telling him to load the needed
11:08 - configurations for opengl
11:12 - then we'll tell opengl the viewport of
11:14 - our window which is just the area of the
11:17 - window we want opengl to render in
11:20 - that will go from the bottom left corner
11:23 - of the window coordinates 0 0 to the top
11:26 - right corner of the window coordinates
11:29 - 800 800 in our case
11:32 - now in order to go forward i'll have to
11:35 - introduce some computer graphics
11:37 - concepts so
11:39 - lesson time
11:41 - as you probably already know screens
11:43 - display a bunch of images really really
11:46 - fast which give us the illusion of
11:48 - motion these images are called frames
11:52 - screens display frames by changing from
11:54 - the pixels of the display to the pixels
11:57 - of a frame
11:58 - these are changed one by one from the
12:00 - top left of the screen to the bottom
12:03 - right of the screen
12:05 - now while the screen is loading the
12:06 - pixels from the current frame and
12:08 - displaying them the next frame is being
12:11 - written in the background away from our
12:14 - eyes once the screen finishes displaying
12:16 - the current frame it switches it with
12:19 - the next frame and starts displaying dot
12:22 - well in the background the no previous
12:25 - frame is being overwritten with new
12:27 - information these two frames are called
12:31 - buffers
12:32 - and they're simply a space of storage in
12:34 - memory for pixels
12:37 - the buffer from which information is
12:39 - being read to be displayed on the screen
12:42 - is called the front buffer while the
12:44 - other one on which information is being
12:47 - written is called the back buffer
12:50 - now let's write the actual code
12:53 - we're gonna tell opengl to prepare to
12:56 - clear the color of a buffer and give it
12:58 - another color
13:00 - i'm gonna give it a nice navy blue in
13:02 - the normalized decimal rgb form of color
13:06 - and set the last number the alpha to one
13:10 - the alpha number dictates the
13:12 - transparency of the color one being
13:15 - opaque and zero being completely
13:17 - transparent
13:19 - now we want opengl to execute the
13:21 - command we've told it to prepare for so
13:24 - we'll use this function specifying we
13:26 - want to use the command on the color
13:28 - buffer
13:29 - we'll learn more about types of buffers
13:31 - in the next video
13:33 - so at this point we have a back buffer
13:36 - with the color we want and the front
13:38 - buffer with the default color
13:40 - so in order to see our color we'll want
13:42 - to swap the buffers since only the
13:45 - pixels on the front buffer are being
13:47 - displayed
13:49 - now press run in tada we don't have a
13:52 - nicely colored window that you can show
13:54 - off to your imaginary friends
13:58 - and the last thing that's left to do is
14:00 - just to write some comments so that you
14:02 - can make sure you understand what's
14:04 - happening
14:05 - try writing them with your own words but
14:08 - if you find that difficult then feel
14:10 - free to copy mine
14:12 - i'll leave the source code in the
14:14 - description and the pdf with some
14:16 - exercises so you can practice what
14:18 - you've just learned
14:26 - so now let's add a triangle to the mix
14:29 - but first i'll have to introduce you to
14:31 - something called the graphics pipeline
14:33 - the graphics pipeline is essentially
14:35 - just a series of functions which takes
14:37 - some data at the beginning and then at
14:40 - the very end of the graphics pipeline it
14:42 - outputs a frame
14:44 - now the input is called the vertex data
14:47 - this is just an array of well vertices
14:51 - though they're not mathematical vertices
14:54 - since each vertex besides having a
14:57 - position also contains other data such
15:00 - as color or texture coordinates
15:03 - the first phase of the graphics pipeline
15:05 - is called the vertex shader
15:08 - the vertex reader takes the positions of
15:10 - all the vertices and transforms them or
15:13 - if you want to it can keep them the
15:15 - exact same way your choice
15:17 - once all the transformations are done
15:20 - the shape assembler takes all the
15:22 - positions and connects them according to
15:24 - a primitive but what's a primitive i
15:27 - hear you asking well a primitive is just
15:30 - a shape such as a triangle or maybe a
15:34 - point or a line
15:36 - each primitive interprets the data
15:38 - differently for a triangle it would take
15:41 - three points and then draw a triangle
15:43 - between them whereas a line would take
15:45 - two points at a time and draw lines
15:48 - between them
15:49 - up next we have the geometry shader
15:51 - which can add vertices and then create
15:54 - new primitives out of already existing
15:56 - primitives
15:57 - but this one is a bit more complex so we
16:00 - won't be seeing it for a long while
16:03 - next comes the rasterization phase
16:05 - where all the perfect mathematical
16:08 - shapes get transformed into actual
16:11 - pixels so what before was a perfect
16:14 - mathematical triangle now becomes just a
16:16 - bunch of pixels which are just kind of a
16:19 - bunch of squares
16:21 - but these pixels don't really have any
16:23 - color to them so here comes the fragment
16:26 - shader which is one of the most
16:28 - important shaders so the fragment shader
16:30 - adds colors to the pixels
16:33 - this depends on many many things such as
16:35 - the lighting or the textures or shadows
16:40 - at this point you might have multiple
16:42 - colors for just one pixel because of
16:45 - multiple objects overlapping so that's
16:48 - fixed in the last phase as is the
16:50 - blending of transparent objects into the
16:54 - final color
16:55 - now for the actual coding so sadly
16:58 - opengl doesn't provide us with defaults
17:00 - for the vertex in fragment shaders so
17:04 - we'll have to write our own
17:06 - but since this tutorial doesn't focus on
17:09 - the shaders themselves but rather the
17:11 - overarching process of using the shaders
17:15 - i'll simply copy paste the shader scene
17:18 - don't worry though i'll be looking at
17:19 - those in a future tutorial
17:22 - so first let's specify the coordinates
17:24 - of our vertices for now we're going to
17:26 - work in 2d so we're going to ignore the
17:29 - z-axis
17:30 - as for the x and y axis well their
17:33 - origin is located in the middle of the
17:35 - window with x pointing to the right and
17:38 - y pointing up
17:40 - now the coordinate system is normalized
17:42 - which means that the leftmost part of
17:44 - the window for x is negative one and the
17:47 - rightmost part of the window for x is
17:50 - positive one while for y the lowermost
17:52 - part of the window is negative one and
17:55 - the uppermost part of the window is
17:57 - positive one
17:58 - so now i'll make an array of data type
18:00 - gl float why gel float well you would
18:04 - probably use normal floats but these may
18:07 - differ in size from the floats that
18:09 - opengl uses so it's just safer to go
18:12 - with the opengl version
18:14 - there is a link down in the description
18:16 - to a wikipedia page where you can see
18:19 - all the data types that opengl has
18:22 - now i'll just name these vertices and
18:24 - add some coordinates now in this array
18:27 - every three floats will represent one
18:29 - coordinate
18:31 - i'll first add the coordinate of the
18:33 - left corner then the right corner and
18:36 - then the top corner
18:38 - this may look kind of complicated but
18:40 - that's because i chose
18:42 - nice coordinates such that i get an
18:44 - equilateral triangle but you can put any
18:47 - coordinates you want to as long as
18:48 - they're between negative one and
18:50 - positive one
18:52 - so great now we have three coordinates
18:54 - so let's just fit them into the graphics
18:56 - pipeline and get a nice triangle well
18:58 - sadly it's not that easy we may have the
19:01 - source code for our vertex shader and
19:05 - our fragment shader but we don't have
19:07 - the shaders themselves
19:09 - so shaders are an opengl object and
19:13 - these are just kind of like in the
19:15 - background in the memory and we can only
19:17 - access them by references aka a value
19:22 - in fact all opengl objects are accessed
19:24 - by a reference keep that in mind as it
19:27 - is very important
19:29 - so let's create a value aka a reference
19:32 - to store our vertex shader in so i'll
19:35 - type in g l
19:37 - i g-l-u-i-n-t which is the open gel
19:39 - version of an unsigned integer aka a
19:43 - positive integer
19:44 - i'll name it vertex shader and use gl
19:47 - create shader to create the shader and
19:49 - get the reference value and as an input
19:52 - you'll have to specify what kind of
19:54 - shader you want in this case we want the
19:56 - vertex shader
19:57 - so now that we have a vertex shader
19:59 - let's fit it the source code we copy
20:02 - pasted earlier we'll use gl shader
20:04 - source and the first thing we're going
20:07 - to give it is the reference value then
20:09 - we're going to specify that we're only
20:11 - using one string for the whole shader
20:14 - then we're going to point to the source
20:16 - code and then the last thing doesn't
20:18 - matter just write null now the thing is
20:20 - that the gpu can't understand the source
20:23 - code so we'll have to compile it right
20:25 - now into machine code so i'll just use
20:28 - gl compile shader and give it the
20:30 - reference value so great now we have a
20:33 - vertex shader so not just do the exact
20:35 - same thing for the fragment shader only
20:38 - replace everywhere you see vertex with
20:41 - fragment if you get lost just check my
20:43 - code now in order to actually use both
20:46 - of these shaders we'll have to wrap them
20:48 - up into something called a shader
20:50 - program
20:51 - so just like before let's create a
20:53 - reference value name it shader program
20:56 - and use geocreate program this time not
20:59 - specifying anything else because they're
21:01 - just one type of shader program
21:03 - and to attach a shader to the shader
21:05 - program you're gonna use gl attach
21:08 - shader first plugging in the reference
21:10 - to the shader program then plugging in
21:13 - the reference to the shader itself once
21:16 - you've finished attaching your shaders
21:18 - we want to wrap up the shader program
21:20 - we're going to use geo link program for
21:22 - that and we're just going to pass it in
21:24 - the shader program reference
21:27 - and just to keep it tidy i'm now gonna
21:29 - delete the shaders we've created before
21:31 - because they're already in the program
21:33 - itself
21:34 - so great now we're done with the shaders
21:37 - so you would be tempted to press run but
21:39 - nothing is gonna happen because we
21:41 - haven't done anything with our vertices
21:44 - we haven't even told opengl how to
21:46 - interpret them so let's do that now
21:49 - so sending stuff between the cpu and the
21:52 - gpu is kind of slow so when you do send
21:55 - stuff you want to send it into big
21:57 - batches these big batches are called
22:00 - buffers do not confuse them with the
22:02 - front and back buffers from the last
22:04 - tutorial though so let's create a vertex
22:07 - buffer object where we'll store our
22:09 - vertex data and as always we're gonna
22:12 - use a reference integer for it
22:15 - now the vbo is actually an array of
22:18 - references
22:19 - but since we only have one object we
22:22 - only need one so for now we're just
22:25 - gonna leave it like this
22:27 - we can create the buffer object by using
22:29 - gl gen buffers and giving it one as the
22:33 - first argument because we only have one
22:36 - 3d object and then pointing it to the
22:39 - reference
22:40 - now let me introduce you to the concept
22:42 - of binding
22:44 - binding in opengl means that we make a
22:46 - certain object the current object and
22:49 - whenever we fire a function that would
22:52 - modify that type of object
22:54 - it modifies the current object aka the
22:58 - binded object so now i'll just bind it
23:01 - using gl bind buffer and giving it gel
23:04 - array buffer and the reference of the
23:06 - vbo now i used gl array buffer because
23:10 - that's the type we need to use for the
23:12 - vertex buffer
23:14 - if you want to see the other types of
23:16 - buffers i left a link in the description
23:18 - to the opengl documentation where you
23:21 - can look up this function and it will
23:23 - tell you what other kinds of buffers
23:25 - there are
23:27 - now let's actually store our vertices in
23:30 - the vbo
23:31 - we'll do that by using gl buffer data we
23:34 - first specify the type of buffer the
23:36 - total size of the data in bytes we can
23:39 - just use a c plus function to get that
23:42 - and now we give the actual data itself
23:45 - so the vertices
23:46 - and finally we specify the use of this
23:49 - data this is done by typing gl
23:52 - underscore and now we choose between
23:54 - stream static and dynamic
23:57 - stream means that the vertices will be
23:59 - modified once and used a few times
24:02 - static means that the vertices will be
24:04 - modified once induced many many times
24:08 - and dynamic means that the vertices will
24:10 - be modified multiple times and used many
24:12 - many times
24:14 - you need to specify these in order to
24:16 - improve performance
24:18 - so now we continue with another
24:20 - underscore and again choose between draw
24:23 - read and copy
24:25 - draw means that the vertices will be
24:27 - modified and be used to draw an image on
24:29 - the screen and you can imagine what the
24:32 - other two do
24:33 - so great now we have a nicely packed
24:36 - object with our vertex data but opengl
24:39 - doesn't know where to even find it in
24:41 - order to do that we make use of another
24:44 - object called a vertex array object
24:47 - this source pointers to one or more vbos
24:51 - and tells opengl how to interpret them
24:54 - vios exist in order to quickly be able
24:57 - to switch between different vbos so
25:00 - let's go back and put vao in front of
25:03 - vbo now let's generate the vreo using gl
25:07 - gen vertex arrays seeing that we only
25:09 - have one object and pointing to the vao
25:12 - reference
25:13 - make sure you generate the vao before
25:17 - the vbo the ordering is very important
25:21 - now let's find the vao so that we can
25:23 - work with it
25:24 - now let's configure it so that opengl
25:27 - knows how to read the vbo we'll do that
25:29 - by using the function gl vertex
25:32 - attribute pointer
25:33 - first we pass the index of the vertex
25:36 - attribute we want to use
25:38 - a vertex attribute is a way of
25:40 - communicating with a vertex shader from
25:42 - the outside i'll talk more about this in
25:45 - the tutorial for shaders the first input
25:48 - is going to be the position of the
25:49 - vertex attribute which in our case is
25:52 - zero
25:53 - the next input is how many values we
25:55 - have per vertex in our case that's three
25:58 - because we have three floats next we're
26:00 - going to tell what kind of values we
26:02 - have we just have floats
26:03 - now the next input only matters if we
26:06 - have the coordinates as integers but we
26:09 - don't have that so just write in gl
26:11 - underscore false now we have to give the
26:14 - stride of our vertices which is just the
26:16 - amount of data between each vertex in
26:20 - our case since we have three floats then
26:22 - that is just three times the size of one
26:25 - float and the last thing is called the
26:27 - offset which is a pointer to where our
26:30 - vertices begin in the array but since
26:32 - our vertices begin right at the start of
26:34 - the array we're gonna give this weird
26:37 - pointer void
26:39 - so finally we've configured the vertex
26:41 - attribute now in order to use it we need
26:44 - to enable it using gl enable vertex
26:47 - attribute array and give it 0 because
26:50 - that's the position of our vertex
26:53 - attribute
26:54 - now this next step is not mandatory but
26:56 - it's nice to have just so you can be 100
26:59 - sure you won't accidentally change a vba
27:02 - or vio with a function we basically just
27:06 - combined both the vbo and voa by binding
27:09 - to zero
27:10 - now once again
27:12 - make sure you have the same ordering of
27:15 - your functions as i do in the case of
27:18 - the vio in vbo
27:20 - because the ordering is extremely
27:22 - important
27:24 - and just to keep everything nice and
27:25 - clean let's go to the end of our main
27:27 - function and delete all the objects
27:29 - we've created so far and now just a few
27:32 - more lines of code and we'll finally
27:34 - have a triangle first copy and paste the
27:37 - gel clear color and gel clear functions
27:40 - into the while loop
27:41 - now let's activate the shader program
27:44 - we've created like a thousand years ago
27:47 - and now let's bind the vao so that we're
27:49 - telling opengl that we want to use this
27:52 - one
27:53 - it's not really necessary to do this
27:55 - because we only have one object in one
27:57 - video but it's good to get used to this
28:00 - now for the drawing function itself
28:02 - we're going to use gel draw arrays
28:04 - specifying the type of primitive we want
28:06 - to use triangles in our case
28:09 - the starting index of the vertices 0 in
28:12 - our case and then the amount of vertices
28:14 - we want to draw since we're drawing one
28:16 - triangle and a triangle has three
28:18 - vertices that's three
28:20 - and last but not least we make sure we
28:23 - swap the buffers so that the image gets
28:25 - updated each frame
28:28 - and finally after a long long journey we
28:31 - can finally press run and see a nice
28:34 - triangle pop up
28:36 - now i can imagine you probably feel a
28:38 - bit overwhelmed by the amount of
28:40 - information you just got
28:42 - don't worry though it's normal i was
28:45 - also a bit overwhelmed by it at the
28:47 - beginning so now a good way to make sure
28:50 - you understand most things is to add
28:52 - comments to all the steps and functions
28:54 - and rewatch certain parts that you don't
28:57 - fully understand yet if you want to know
28:59 - more about individual functions simply
29:02 - look them up in the documentation of
29:04 - opengl
29:05 - it helps more than you'd expect
29:08 - so as always i've left the link in the
29:10 - description to a pdf with exercises for
29:12 - you to do
29:14 - exercising and messing around with the
29:16 - functions really helps you learn what
29:18 - each of them does
29:24 - so now we're going to build on top of
29:26 - that by introducing the concept of index
29:28 - buffers
29:29 - as you hopefully remember we can draw a
29:32 - triangle by telling opengl to use the
29:34 - triangle primitive between three
29:36 - vertices in this case vertices 0 1 and
29:40 - 2.
29:41 - easy enough right but what about this
29:45 - case
29:46 - well here we have three triangles so
29:48 - that means we need 9 vertices 0 1 2
29:52 - 3 four five and six seven eight
29:56 - but as you can probably see we have
29:58 - duplicate vertices which means that
30:00 - we're just wasting memory space so let's
30:03 - rewrite the vertices but this time
30:05 - without duplicates
30:07 - so in this case we have vertices 0 1 2 3
30:12 - 4 and 5.
30:14 - if we give this to opengl it will draw a
30:16 - small upside down triangle on top of a
30:19 - big triangle which is not what we want
30:21 - in order to prevent that we need to make
30:24 - use of an index buffer
30:26 - an index buffer tells opengl the order
30:29 - in which it should go over vertices
30:32 - here it first goes over 0 4 3 then 4 1 5
30:38 - and then 3 5 2.
30:40 - we solve the problem of duplicate
30:42 - vertices by simply visiting the same
30:44 - vertices twice using indices
30:48 - so now let's actually implement this
30:51 - i'll first add the new vertices to my
30:53 - array
30:54 - and now i'll create an array of data
30:56 - type g l u i n t for the indices
31:00 - and type in the indices we saw
31:02 - previously generating the index buffer
31:05 - is very similar to the vertex buffer so
31:08 - let's first create its reference value
31:10 - next let's generate the reference value
31:12 - and store it in evo specifying we only
31:15 - have one object in order to do something
31:18 - with it we need to make it current aka
31:21 - bind it and also specify its of type gl
31:25 - element array buffer
31:27 - now we link it to our indices array if
31:30 - you don't know what these inputs mean
31:32 - check out my previous tutorial
31:34 - now we unbind it but make sure you
31:37 - unbind it after you unbind your vao
31:41 - since the ebo is stored in the vio
31:44 - so if you unbind it before unbinding the
31:47 - vao you're essentially telling opengl
31:50 - that you don't want the vao to use your
31:53 - ebo
31:55 - and to keep things clean we'll delete it
31:57 - at the end of the main function
32:00 - the last step is to replace gl draw
32:02 - arrays with gl draw elements specifying
32:06 - the primitive we want to use
32:08 - how many indices we want to draw
32:11 - the data type of our indices and the
32:14 - index of our indices which in our case
32:18 - is zero
32:20 - now just press run and enjoy your
32:22 - triangles
32:23 - as always i've left the source code and
32:25 - some exercises in the description
32:33 - now let's organize things a bit since as
32:36 - you can see we have a lot of stuff going
32:38 - on in here
32:40 - let's start by moving the shaders into
32:42 - their own separate text files
32:44 - open up the solution explorer and create
32:47 - a folder called shaders in the resource
32:49 - files folder
32:51 - now let's add a new item selecting
32:53 - utility then text file and naming it
32:56 - default.word
32:58 - open it up and copy paste the vertex
33:00 - shader source code into it
33:02 - make sure to get rid of the one variable
33:05 - you have and all the quotes and slash
33:08 - ends
33:09 - now do the exact same thing for the
33:11 - fragment shader only name it
33:13 - default.frag instead of default.vert
33:17 - now let's create our very own shader
33:19 - class
33:21 - go to header files add new item header
33:24 - file and name it shaderclass.h
33:28 - in this file we'll declare our class and
33:30 - other functions related to it
33:33 - first let's write hash if ndef shader
33:37 - class h
33:38 - hash define shader class h hash and if
33:43 - this lets c plus know not to open up the
33:45 - file twice since that would create
33:47 - variable clashes
33:56 - now we'll need to declare a function
33:57 - that will read the shader text files
34:01 - i will not go through the details of it
34:03 - though since the function itself is
34:05 - irrelevant to opengl
34:07 - just know it outputs the contents of a
34:09 - text file as a string
34:12 - now let's declare the shader class which
34:14 - will simply be an opengl shader program
34:17 - that's nicely wrapped up
34:19 - give it a public id aka reference
34:22 - declare a constructor that will take in
34:24 - the shader source codes and two
34:27 - functions activate and delete
34:30 - once you're done with that go to source
34:32 - files and create a cpp file named
34:35 - shaderclass.cpp
34:37 - i'll start by including shaderclass.h
34:40 - and then copy pasting the filereader
34:42 - function
34:43 - link in the description to all the
34:45 - source code
34:46 - now let's write the shader constructor
34:49 - first let's get the strings from the
34:51 - text files into two variables and then
34:54 - convert and store them into character
34:56 - arrays
34:58 - now we just need to copy paste all the
35:00 - shader related code from the main
35:02 - function
35:03 - modifying it slightly by replacing
35:05 - shader program with id and changing
35:08 - vertex shader source to vertex source
35:11 - and fragment shader source to fragment
35:13 - source
35:15 - don't forget to also write the activate
35:17 - and delete functions by again copy
35:20 - pasting from the main function
35:22 - great we've made the shader class
35:25 - next let's make a vertex buffer class
35:28 - create a header vbo.h and include glad
35:32 - for the opengl functions
35:34 - now create a vbo class giving it a
35:37 - public id variable and a constructor
35:40 - that takes some vertices in their sizing
35:42 - bytes the size of the vertices is in the
35:46 - gl size iptr data type since that's what
35:50 - opengl uses for sizes in bytes
35:53 - now just add some declarations for the
35:55 - bind unbind and delete functions
35:59 - then create a c plus file vbo.cpp
36:03 - and copy paste the same functions as me
36:05 - changing the name of some variables such
36:08 - as vbo to id
36:10 - make sure to also copy paste in the code
36:13 - for the other functions
36:15 - now repeat the same procedures we've
36:17 - done with the vbo for the ebo making
36:20 - sure to replace jill array buffer with
36:23 - gl element array buffer
36:32 - and now finally the vertex array class
36:35 - create a header and include glad like
36:38 - before but this time also make sure to
36:40 - include vbo.h as we'll need to link a
36:44 - vbo to the vao
36:46 - create the vio class give it a public id
36:50 - create a constructor without any inputs
36:53 - and then a link vbo function that will
36:56 - take a vbo and the layout which we'll
36:58 - learn more about in the shaders tutorial
37:02 - don't forget to declare the usual bind
37:04 - unbind and delete functions
37:07 - once you're done with that create the
37:09 - vao.cpp file and include the vao header
37:14 - now copy paste in the relevant functions
37:17 - but make sure to bind and unbind the vbo
37:20 - in the link vbo function make sure
37:23 - you've written everything the same way i
37:25 - did
37:33 - great now we're done with creating all
37:34 - the classes all that's left to do now is
37:37 - to go back to the main function include
37:40 - all the headers we've created and
37:42 - replace all the default functions we had
37:44 - with the new functions and classes
37:47 - i'll also move the vertices and indices
37:49 - to the top of the file as i think it
37:51 - looks better
37:56 - if you press run everything should work
37:58 - just like before
38:00 - as always the final step is to add your
38:02 - own comments in order to make sure you
38:04 - understand all of this
38:06 - if you run into any problems the source
38:09 - code is in the description
38:34 - now let's finally learn more about
38:36 - shaders
38:37 - you can think of shaders as functions
38:39 - that run on the gpu
38:41 - since they are similar to functions they
38:44 - can take inputs and also have outputs
38:47 - so let's take a look at our default
38:49 - vertex shader while looking at this you
38:51 - might think it's c code but it's
38:54 - actually opengl shading language aka
38:57 - glsl which has a similar syntax to see
39:01 - the first line contains the version of
39:03 - glsl we are using since we have opengl
39:06 - 3.3 we need to use glsl 330. the second
39:11 - line takes an input a plus using the
39:14 - layout with location zero layouts help
39:17 - opengl with the vertex data it receives
39:20 - in this case we say that on the zeroth
39:22 - layout there is a vector data type for
39:25 - positions
39:27 - now for the main function we simply
39:29 - assign gl position of eq4 with all our
39:32 - positions plus an arbitrary one for the
39:35 - fourth dimension which we can ignore for
39:38 - now opengl recognizes the keyword gl
39:42 - position and knows it needs to use it as
39:44 - the position for the vertex you can
39:47 - think of this shader as outputting gel
39:49 - position
39:51 - even though it doesn't specifically do
39:53 - that on the other hand the fragment
39:56 - shader specifically says on the second
39:59 - line that it outputs a vic-4 color
40:03 - now for the main function we simply gave
40:05 - it a color in rgba format to use for all
40:08 - the vertices
40:10 - but instead of having one color for all
40:13 - the points let's give each vertex its
40:16 - own color
40:17 - so i'll start by writing rgb values
40:20 - after each position in the vertices
40:22 - array then i'll add a second layout with
40:25 - location 1 that takes a vector named a
40:29 - color
40:30 - but since the fragment shader is the
40:32 - shader that takes care of colors we need
40:35 - to output the colors from the vertex
40:38 - shader to the fragment shader
40:40 - to do that i'll output a vectory named
40:44 - color and in the main function
40:46 - make it equal to the a color imported
40:49 - from the vertices array
40:51 - now in the fragment shader i'll input
40:53 - the exact same vectory named color
40:57 - it's very important to give inputs and
41:00 - outputs the same name
41:03 - since otherwise opengl wouldn't know to
41:05 - make the link between them in the first
41:08 - place
41:09 - and the final step for this shader is to
41:11 - make frag color equal to color since
41:14 - that's what we are outputting
41:17 - now we should configure the vertex
41:19 - attribute pointers but first we need to
41:22 - modify a function from the vao class
41:25 - let's change link vbo to link atrib and
41:29 - add four variables num components type
41:33 - stride and offset
41:36 - now do the same in the vao.cpp file and
41:40 - add in the new variables as inputs to
41:43 - the gl vertex attribute pointer just
41:46 - like me
41:47 - so we are sending the shader an array of
41:50 - a bunch of bytes in order for opengl to
41:54 - know how to interpret all of them we
41:57 - tell it how to do so in the gel vertex
42:00 - attribute pointer function
42:02 - first we specify the layout location
42:05 - in our case 0 for coordinates slash
42:09 - position and 1 for color
42:12 - then the number of components per layout
42:15 - 3 in both of our cases
42:18 - then the type of our components gl float
42:23 - and finally the stride in offset
42:26 - the stride is the distance in bytes
42:29 - between the beginning of one vertex and
42:32 - the end of another which in our case is
42:35 - six times the size of a float since each
42:38 - vertex has six floats
42:41 - the offset is simply the initial offset
42:45 - of a layout in bytes
42:47 - for the coordinates that's zero because
42:50 - they are right at the beginning well for
42:52 - the colors the offset is three times the
42:56 - size of a float in bytes since the first
42:59 - three components are coordinates
43:02 - now let's write all of this in code by
43:04 - linking the attribute for coordinates
43:07 - and colors from our vbo to our vao
43:11 - now if you press run you should see that
43:14 - the triangles have a nice gradient of
43:16 - color you might be asking yourself why
43:19 - there is a gradient of colors even
43:21 - though we only specified a couple of
43:24 - colors
43:25 - well that's because if a primitive has
43:28 - different colors for its vertices then
43:31 - opengl will automatically create a nice
43:34 - gradient from one color to another
43:38 - this is called interpolation
43:40 - and it is used in other things besides
43:43 - colors as well now let's look at the
43:45 - second method of getting inputs and
43:48 - outputs within and outside of a shader
43:51 - this second method makes use of uniforms
43:55 - uniforms are sort of like universal
43:58 - variables that can be accessed by other
44:00 - shaders and can even be accessed from
44:04 - within the main function of the program
44:06 - without the use of a vao
44:09 - let's create a float uniform called
44:12 - scale in our vertex shader
44:14 - now let's just add to each coordinate
44:17 - the corresponding coordinate multiplied
44:20 - by the scale
44:21 - what this essentially does is it
44:24 - increases the size of our triangles
44:26 - so if the scale is let's say 0.5
44:30 - then our triangles are 50 percent bigger
44:34 - one thing to note though is that you
44:36 - should never declare uniforms if you're
44:40 - not going to use them since otherwise
44:44 - opengl will delete them automatically
44:46 - and that may cause errors
44:49 - okay now
44:50 - in order to give the uniform a value we
44:53 - must first get its reference value in
44:56 - the main function we'll do that by using
44:58 - gel get uniform location and store the
45:01 - reference in an opengl unsigned integer
45:04 - variable called unid
45:07 - the function will take us inputs the
45:10 - reference of the shader program and the
45:12 - name of the uniform now in order to give
45:15 - it a value we must use the gl uniform
45:18 - function
45:19 - but we can only do so after activating
45:23 - our shader program so make sure you
45:26 - write it after shaderprogram.activate
45:29 - gel uniform is a bit of a weird function
45:32 - as its name's suffix changes depending
45:35 - on the data type we are inputting if you
45:38 - want to know all the variants of the
45:40 - function look it up in the documentation
45:43 - i left in the description
45:45 - we are going to use gel uniform 1f since
45:48 - we are only inputting one float and then
45:51 - for the inputs we'll use the uni id and
45:55 - 0.5 f
45:57 - now if you press run our triangles
46:00 - should be bigger as a final step i will
46:03 - add some error checking in the shader
46:05 - class since we don't have debugging for
46:07 - our shaders and so it would be nice to
46:10 - get a basic error message when a shader
46:13 - fails to compile
46:14 - if you want to know how the error
46:16 - functions work i left a link in the
46:18 - description to a wikipedia article on
46:21 - them
46:22 - don't forget to add comments to
46:24 - everything to make sure you understand
46:26 - what you've written
46:28 - and as always the source code and some
46:31 - exercises are left down in the
46:33 - description
46:39 - so now let's take a look at textures
46:41 - textures can be one-dimensional
46:43 - two-dimensional or three-dimensional but
46:46 - in this tutorial we'll only look at the
46:48 - two-dimensional textures as they're the
46:50 - most common type of texture so the first
46:52 - thing we'll want to do is to import an
46:54 - image into our program so that we can
46:56 - make it into a texture and display it in
46:59 - order to do that we're going to use this
47:01 - popular open source library called sdb
47:04 - to install it go to your project folder
47:07 - then libraries and then include now
47:09 - create a folder named stb and inside of
47:12 - it create a text file named stb
47:14 - underscore image.txt
47:17 - now go to the link i left in the
47:18 - description press ctrl a to select
47:21 - everything and then copy paste it into
47:23 - the text file we've just created make
47:25 - sure to save it and then rename it to
47:27 - stb underscore image dot h
47:30 - now create a cpp file named stb.cpp in
47:34 - your project source files and write the
47:36 - following into it so that we'll only use
47:38 - the things we need from this library now
47:40 - right click the cpp file and click on
47:43 - compile make sure to only do this once
47:46 - that's it now if you want to use the
47:48 - library simply include the header file
47:50 - into the file you want to use it in i'll
47:52 - do that in the main.cpp file
47:55 - now before we get to the texture let's
47:57 - make sure we have the coordinates for a
47:59 - square so that we can better see our
48:01 - texture when displayed don't forget to
48:04 - also change your indices and the gl draw
48:07 - elements function
48:08 - run your program to make sure you do
48:10 - indeed get a square
48:12 - if everything is all right then let's
48:14 - import our imaging keep in mind that
48:17 - square textures in powers of 2 such as
48:21 - 1024 by 1024 pixels or 2048 by 2048
48:26 - pixels are better optimized than
48:28 - textures with the random number of
48:30 - pixels so do try to make them fit this
48:33 - format i'll be using this image of
48:36 - popcat that's 512 by 512 pixels which
48:41 - i'll put into a textures folder in
48:43 - resource files don't forget to also put
48:45 - the image in your project's main folder
48:48 - first we have to create three integer
48:50 - variables to sort the width and height
48:52 - of the image in pixels and the number of
48:55 - color channels it has
48:57 - then we'll store the image itself in an
49:00 - unsigned character array named white
49:02 - using the function sdbi underscore load
49:05 - and giving it the location and name of
49:08 - the image the pointers of the variables
49:10 - we created and zero that's it for
49:13 - importing it in easy right now let's
49:16 - create the texture object itself just
49:19 - like any opengl object we'll first
49:21 - create a reference variable of type glu
49:23 - int and name it texture
49:26 - now just use gel gen textures to
49:28 - generate the texture object giving it
49:30 - the number of textures you want one in
49:33 - our case and the pointer to the
49:35 - reference variable since we've created
49:37 - it we also want to delete it at the end
49:39 - of the main function
49:41 - we now need to assign the texture to a
49:43 - texture unit
49:44 - you can think of texture units as slots
49:47 - for textures that come together as a
49:50 - bundle
49:51 - these generally hold about 16 textures
49:54 - and allow the fragment shader to work
49:55 - with all 16 textures at the same time to
49:58 - insert our texture in the slot of a
50:01 - texture unit we simply need to activate
50:03 - the texture unit we want using gel
50:06 - activate texture plugging in the index
50:08 - of the texture unit and then binding our
50:11 - texture with gel bind texture inserting
50:14 - the texture type and its reference value
50:17 - since we now have our texture binded
50:19 - that means that this would be a good
50:21 - time to adjust its settings to our
50:23 - liking
50:25 - first we'll have to choose how we want
50:26 - our image to be processed when scaled up
50:29 - or down we can choose gel nearest which
50:32 - keeps all the pixels as they are this is
50:35 - preferred when working with pixel art or
50:38 - we can choose gel linear which creates
50:40 - new pixels according to the pixels
50:42 - nearby this generally results in a
50:45 - blurrier image which one you choose
50:48 - depends on your needs in a certain
50:50 - context for now i'll just go with gel
50:52 - nearest
50:53 - i'll use the gel text parameter i
50:56 - function to tweak our texture settings
50:58 - and input the type of our texture the
51:01 - setting we want to modify and the value
51:03 - we want to give our setting i'll modify
51:06 - both the mean filter and mag filter
51:08 - settings now the second setting is how
51:11 - we want our texture to be repeated
51:13 - we can choose between gel repeat gel
51:16 - mirrored repeat gel clamp to edge and
51:19 - gel clamp to border
51:21 - the first one simply repeats the image
51:23 - the second one repeats the image but
51:26 - mirrors it every time it repeats it
51:28 - the third one stretches the borders of
51:30 - the image and the last one simply puts a
51:33 - flat color of your choice outside the
51:35 - image
51:36 - note that you can mix and match them
51:38 - since they only apply on one axis
51:41 - so you could have the texture repeat on
51:43 - the vertical axis but only have a flat
51:46 - color on the horizontal axis
51:48 - this axes are named str corresponding to
51:52 - the common x y and z axes
51:56 - just like before we'll use gel text
51:58 - parameter i plugging in the texture type
52:01 - the setting we want to modify and the
52:03 - value of our setting make sure to do
52:05 - this for both the s and t axes if you
52:09 - want to use dual clamp to order you'll
52:11 - have to also use gel text parameter fv
52:15 - plugging in the texture type gel texture
52:18 - border color and the color of the border
52:21 - which should be an array of 3 or 4
52:24 - floats
52:25 - now that our settings are complete we
52:27 - can generate the texture using gel text
52:29 - image 2d and inputting the following the
52:33 - type of texture
52:34 - 0 the type of color channels we want the
52:37 - texture to have the width the height 0
52:41 - this is just the legacy leftover thing
52:43 - the type of color channels our image has
52:46 - the data type of our pixels and the
52:48 - image data itself
52:50 - the most common types of color channels
52:52 - are glrgb in glrgba the first one is for
52:57 - jpegs and the second one is for pngs if
53:00 - you want to look at all the types of
53:01 - color channels and pixel data types i
53:04 - left a link in the description to the
53:06 - opengl documentation
53:08 - if at the end of this tutorial you get
53:10 - an error during compiling then it might
53:13 - be because you specify the wrong type of
53:15 - color channels or pixel data type for
53:18 - reading your image since we've already
53:20 - imported the image data into the texture
53:23 - we'll want to delete the data using sdbi
53:25 - image free and also unbind the textures
53:28 - so we don't accidentally do something to
53:31 - it the last thing you'll want to do
53:32 - after that is to use the gl generate
53:34 - mipmap function plugging in the data
53:37 - type of the texture this will generate
53:39 - the mipmaps for the texture which are
53:41 - just smaller resolution versions of the
53:43 - same texture that are used when the
53:45 - texture is far away for example great we
53:48 - have the texture but we did not specify
53:51 - how we want the texture to be mapped on
53:53 - the vertices so let's do that now by
53:56 - adding coordinates to our vertices
53:59 - the coordinates of the texture go from 1
54:02 - to 0 on both axis starting from the
54:04 - bottom left corner if you would give
54:07 - coordinates higher than 1 then the
54:09 - texture will be repeated such as in this
54:12 - example
54:13 - now that we've modified our vertices we
54:15 - also need to add a new layout to our
54:17 - vertex shader and make sure to modify
54:19 - our vertex buffer object
54:21 - since the fragment shader deals with
54:23 - colors we need to export the texture
54:26 - coordinates to the fragment shader and
54:28 - import them like so
54:30 - the last thing we need to do in the
54:31 - fragment shader is to create a uniform
54:34 - of type sampler 2d call it text 0 then
54:38 - equal the frac color to the function
54:40 - texture which takes text 0 and takes
54:42 - coordinates as inputs the uniform tells
54:45 - opengl which texture unit it should use
54:49 - so in the main function create a uniform
54:51 - just like in the shaders tutorial and
54:54 - assign the uniform the index of our slot
54:56 - 0 in this case
54:58 - make sure to do this after you've
55:00 - activated the shader program
55:02 - the last thing we need to do is to bind
55:04 - the texture object in the main function
55:06 - and we're done if you press run you
55:09 - should see a majestic texture appear on
55:12 - your square
55:13 - but wait it's upside down
55:16 - well that's because opengl reads images
55:18 - from the bottom left corner to the top
55:21 - right corner
55:22 - while sdb reads them from the top left
55:25 - corner to the bottom right corner so all
55:28 - we have to do to fix this is to write
55:31 - sdbi said flip vertically on load true
55:34 - before we load in the image file
55:37 - to wrap it all up i will create a custom
55:39 - texture class just like in tutorial
55:41 - number four
55:54 - don't forget to add comments to
55:55 - everything you've written so that you
55:57 - can make sure you understand what's
55:59 - happening the source code and some
56:01 - exercises to test your knowledge are in
56:03 - the description as always
56:10 - now let's finally leave the boring 2d
56:13 - plane and ascend to three dimensions but
56:16 - first a little correction for my past
56:18 - videos in the vio and texture class i
56:22 - forgot to make the vbo and shader inputs
56:25 - references so just add an and sign like
56:28 - so now for the main part as i have
56:31 - mentioned before opengl restricts our
56:34 - coordinates to normalized coordinates so
56:37 - in order to bypass this and enrich our
56:40 - coordinates with a wider range for three
56:42 - dimensions we can contract and expand
56:46 - the different coordinates using matrices
56:49 - if you don't know much about matrices
56:51 - then you should still be able to
56:52 - somewhat follow along but i highly
56:55 - recommend you watch street blue one
56:58 - braun's linear algebra playlist first as
57:01 - it will help you later down the line in
57:03 - any case we'll be using this nice little
57:05 - library called glm for our matrices so
57:09 - go to this website that's down in the
57:11 - description and click on download go to
57:13 - your libraries folder then include
57:16 - now open up the zip file go into glm and
57:19 - now extract the folder named glm into
57:22 - your include folder once that's done go
57:25 - to your project and include the
57:26 - following parts of the library that's it
57:29 - we can now use matrices easy
57:32 - all right theory time so in order to get
57:36 - a nice 3d image in perspective we need
57:38 - to apply different matrices to different
57:41 - coordinates
57:42 - let's take a look at these types of
57:44 - coordinates
57:45 - first we have the local coordinates
57:48 - these are the coordinates whose origin
57:50 - is the same as an object's origin
57:53 - these are usually located at the center
57:56 - of an object but that's not always the
57:59 - case
58:00 - then we have the world coordinates whose
58:02 - origin is at the center of the world
58:05 - these coordinates usually contain the
58:07 - location of other objects next we have
58:09 - the view coordinates which have the same
58:12 - origin as a camera or viewpoint notice
58:15 - that these do not yet account for
58:17 - perspective perspective is added in the
58:19 - next set of coordinates which are the
58:22 - clip coordinates these are essentially
58:24 - the same as the few coordinates except
58:26 - they clip aka delete any vertices
58:29 - outside the normalized range and can
58:32 - also account for perspective
58:34 - and the final coordinates are the screen
58:36 - coordinates where everything is
58:37 - flattened out such that it can be viewed
58:40 - on your screen now in order to move from
58:42 - a coordinate system to the next we make
58:45 - use of matrices
58:47 - there are three main matrices we make
58:49 - use of the model matrix which takes
58:52 - local coordinates to world coordinates
58:54 - the view matrix which takes world
58:57 - coordinates to view coordinates and the
59:00 - projection matrix which takes view
59:02 - coordinates to clip coordinates the
59:05 - final transformation from clip
59:07 - coordinates to space coordinates is done
59:09 - automatically all these matrices we are
59:12 - applying are 4d but we won't have to
59:15 - actually write them ourselves since glm
59:18 - can take care of that
59:19 - so let's create the model matrix we
59:22 - start by creating a variable called
59:24 - model of type math4 and equaling it to
59:27 - the identity matrix which is simply
59:30 - math4 1.0
59:32 - this is called initialization and it
59:35 - must be done since otherwise the matrix
59:37 - is full of zeros and any transformation
59:40 - we would apply on it would result in the
59:43 - same empty matrix
59:45 - initialize the other two matrices as
59:47 - well the model matrix can remain ocities
59:50 - since our object is in the center of the
59:53 - world coordinates and that's fine for
59:55 - now but right now our camera is also in
59:58 - the center so we want to move back and
60:01 - also a bit up but it's not really us
60:03 - doing this but the world itself
60:06 - we are essentially moving the whole
60:08 - world around us instead of us moving
60:10 - around the whole world
60:12 - in any case to do this we are going to
60:15 - use the function translate plugging in
60:17 - our view matrix and the vectory which
60:20 - will indicate in which direction and how
60:22 - much to move the whole world
60:24 - let's just move it down 0.5 and forward
60:27 - 2.0
60:29 - note that the z axis is positive towards
60:32 - us and negative away from us and for the
60:35 - projection matrix we'll use the
60:37 - perspective function plugging in the
60:39 - field of view in radians the aspect
60:42 - ratio of our screen and the closest and
60:45 - furthest point we can see in other words
60:47 - if something is closer than 0.1 units to
60:51 - us then it will be clipped and if it's
60:53 - further away than 100.0 units it will
60:56 - again get clipped you can see this in
60:59 - games when you are sometimes able to see
61:01 - through walls or characters while
61:03 - bumping into them or when objects
61:06 - disappear at far away distances notice
61:09 - that i've used the function radians to
61:11 - transform my degrees into radians let's
61:14 - also create two variables for the width
61:17 - and height of our window so we can
61:19 - easily modify them from now on now all
61:22 - that's left to do is to import these
61:24 - matrices into the vertex shader we can
61:27 - of course do this by using uniforms so
61:29 - let's simply declare three uniforms of
61:32 - type mod 4 and assign them values in the
61:34 - main function like so
61:36 - we first input their location
61:38 - then one
61:39 - then gel false since we don't want
61:41 - opengl to transpose them and finally we
61:44 - need to use the function value ptr which
61:47 - we give the matrix to this is done so
61:49 - that we can point to the matrix object
61:52 - itself not the data in it don't forget
61:54 - to have the shader activated before
61:56 - assigning these values then go back to
61:59 - the vertex shader and equal gel position
62:02 - to the projection matrix times the view
62:04 - matrix times the model matrix times avec
62:08 - 4 whose 3d coordinates are a pos
62:11 - and the fourth dimension is 1. now if
62:13 - you run the program you'll notice that
62:15 - things look different though you can't
62:17 - really see the perspective since the
62:19 - plane is flat and parallel to us so
62:22 - let's make a pyramid i'll start by
62:24 - setting the coordinates colors and
62:26 - texture coordinates then the indices and
62:29 - finally i'll modify the gel draw
62:31 - elements function which i'll generalize
62:34 - like so so we don't have to bother with
62:36 - it again i'll also use this brick
62:38 - texture which you can find in the
62:40 - description now if you press run we
62:42 - should see our pyramid but sadly it just
62:45 - looks like a triangle so let's make it
62:47 - spin so that we can see it in its 3d
62:50 - glory we simply have to apply the
62:52 - rotation function to the model matrix
62:54 - giving it the matrix we want to modify
62:57 - the rotation in radians and the axis we
63:00 - want to rotate it about in this case
63:02 - that would be straight up so y equals
63:05 - one
63:06 - then just create a simple timer that
63:08 - will change the rotation by half a
63:10 - degree every sixtieth of a second if you
63:13 - press run you should see the pyramid
63:15 - spinning around
63:16 - but you'll also probably notice some
63:18 - weird glitches that's because we're not
63:21 - telling opengl to account for the depth
63:23 - of these triangles so it's unsure which
63:26 - triangle to put on top of which one to
63:29 - fix that we simply need to enable depth
63:31 - testing once using gel enable chill
63:34 - depth test and when we clear the gel
63:36 - color buffer bit we should also clear
63:39 - the gel div buffer bit and now we're
63:42 - finally done and have a nice 3d spinning
63:45 - pyramid don't forget to add comments to
63:48 - everything you've written to make sure
63:50 - you understand it and as always the
63:53 - source code is in the description
64:11 - so now let's add a camera class to make
64:13 - our lives easier first start by creating
64:16 - a header file named camera.h
64:20 - preventing c
64:21 - from opening it twice
64:23 - and including all of the following for
64:26 - the camera class we'll put everything in
64:28 - the public section starting with the
64:30 - victory for the position of the camera a
64:33 - victory for the orientation aka
64:35 - direction of the camera and another
64:38 - victory for the up direction
64:41 - now we'll also want the place to store
64:43 - our width and height in
64:45 - the last two variables will be the speed
64:47 - of the camera and the sensitivity of the
64:49 - camera when looking around
64:52 - i'll also make a very simple constructor
64:54 - a matrix function which will create and
64:56 - send the view and projection matrices to
64:58 - the shader and a function to handle all
65:01 - the inputs now create a new cpp file
65:04 - named camera.cpp and include the camera
65:07 - header for the constructor we'll just
65:09 - assign values to the width height and
65:12 - position
65:13 - for the matrix function we first want to
65:15 - initialize our matrices and then we'll
65:18 - make use of the lookout function the
65:21 - lookout function takes the position from
65:23 - which you want to look at something the
65:25 - target you want to look at and the up
65:27 - vector in our case this would be the
65:30 - camera position the camera position plus
65:33 - our orientation and the up vector the
65:37 - orientation vector is always of length 1
65:40 - and we'll be using it as the vector we
65:41 - want to look at so to say
65:44 - for the second matrix we'll just do what
65:46 - we did in the last tutorial
65:48 - then we'll simply export our matrix to
65:51 - the vertex shader
65:52 - good now let's go to the main function
65:54 - and include the camera header let's
65:56 - delete the old stuff including this
65:59 - scaled uniform we had left over from a
66:01 - few tutorials ago and create a camera
66:03 - object named camera giving it the width
66:06 - and height variables in the position 002
66:11 - now in the while loop delete the old
66:13 - stuff again and use the matrix function
66:16 - naming the uniform cam matrix
66:18 - the last thing we need to do before
66:20 - getting back to what we had last
66:22 - tutorial is to go to the vertex shader
66:24 - and replace all the previous uniforms
66:27 - with a cam matrix uniform
66:29 - now if you press run you should have the
66:32 - exact same thing we had last time except
66:35 - for the spinning pyramid and the fact
66:37 - that everything is now much cleaner in
66:40 - the main function
66:41 - now let's just add some inputs to the
66:44 - camera i came up with these on my own so
66:46 - they might not be the best but they work
66:48 - just fine
66:50 - i'll start off with the wasd controls
66:53 - for which we'll simply need to add or
66:55 - subtract from our position the speed
66:58 - times the orientation or the right
67:01 - vector which we get by doing a cross
67:04 - product between the up vector and
67:06 - orientation vector
67:07 - make sure to use ifs and not else ifs
67:10 - since we want to be able to modify
67:12 - multiple of these at the same time in
67:14 - order to go diagonally now i'll just add
67:17 - space for going up and control for going
67:20 - down and make it so that when i hold
67:22 - shift my speed increases and when i
67:24 - release it my speed goes back to normal
67:27 - now include the inputs function in the
67:29 - main while loop and then if you boot up
67:31 - the program you'll see that you can move
67:33 - about
67:34 - though you can't really look around so
67:36 - let's add some mouse controls
67:39 - so i'll do an if and say that if i hold
67:42 - down the left mouse button i want my
67:44 - mouse to disappear and if i release it i
67:47 - want my nose to appear again now i'll
67:50 - create two doubles for the x and y
67:52 - positions of the mouse and assign them
67:55 - values using the function glf w get
67:58 - cursor position
67:59 - plugging in the window and coordinate
68:02 - references
68:03 - then create two variables for the
68:05 - rotation of our orientation vector and
68:08 - make them equal the sensitivity of the
68:10 - mouse times one of their coordinates but
68:13 - make sure to adjust both coordinates
68:15 - since they normally start in the top
68:17 - left corner but we want them to start in
68:20 - the middle of the screen and be
68:22 - normalized so subtract from them half
68:25 - the height or width and then divide them
68:27 - by the height or width
68:30 - now in order to prevent the camera from
68:32 - being able to do a barrel roll we want
68:34 - to preemptively calculate the new
68:36 - position of the orientation around the x
68:39 - axis and if the angle between the new
68:42 - orientation and the up or negative up
68:45 - vectors is not less or equal than 5
68:48 - degrees
68:49 - then we assign the new orientation to
68:51 - the orientation
68:53 - then we also apply the y rotation to the
68:55 - orientation which we always apply since
68:58 - we want to be able to spin around as
69:00 - much as we want
69:02 - at the end of the function we also want
69:04 - to set the position of the mouse to the
69:06 - center of the screen so that the mouse
69:08 - doesn't end up wandering in a corner and
69:10 - stopping us from freely moving the
69:12 - camera
69:13 - now if you start the program you'll
69:16 - notice that if we try to look around our
69:18 - camera jumps we can easily fix this by
69:21 - adding a new variable to the header
69:23 - named first click and then in the inputs
69:26 - function in the mouse part we want to
69:29 - check if it's the first time we press
69:31 - the leftmost button since we've looked
69:33 - around
69:34 - if it is then we reset the mouse
69:37 - position to the center and make the
69:39 - first click variables false
69:41 - the last thing we need to do is to make
69:43 - the first click variable true when
69:45 - releasing the left mouse button now
69:48 - everything should be running smoothly as
69:50 - always the source code is in the
69:52 - description and don't forget to add
69:54 - comments to everything to make sure you
69:56 - understand it
70:13 - so now we'll add some lighting to our
70:16 - scene
70:17 - first we'll slightly modify the camera
70:19 - class so that we can efficiently use the
70:22 - cam matrix on multiple objects and make
70:24 - sure the new camera functions work
70:26 - properly in the main function next we'll
70:28 - add a cube that will serve as our light
70:31 - source watch my previous tutorials if
70:33 - you don't know how to do this especially
70:35 - my coordinates video if you don't know
70:37 - what the light pose vector and light
70:39 - model matrix are for then if you start
70:42 - out the program you should see your main
70:44 - object in a small cube that's completely
70:46 - white
70:47 - so as you may have noticed in that nice
70:50 - little game called real life light can
70:52 - have multiple colors usually it's white
70:55 - and because of that it shows the true
70:57 - colors of objects so to say but if a
71:00 - light source is let's say red then all
71:03 - objects will appear reddish we can
71:05 - simulate this by multiplying the color
71:07 - of an object with the color of our light
71:10 - both of which are in rgb for example if
71:14 - our light has the rgb values of 1 0 0
71:18 - then when it's multiplied with the color
71:20 - of the object the green and blue parts
71:22 - will become 0 while the red part will
71:24 - stay the same since it's multiplied by
71:27 - one
71:28 - this simulates what happens in real life
71:30 - as only the red color is reflected back
71:33 - to us even though the object is actually
71:36 - orange so let's make a vic for called
71:39 - light color and make it completely white
71:41 - then we'll want to export it to both the
71:44 - light fragmentator and the fragment
71:46 - shader of our object in the light one
71:48 - we'll simply use it as the color of the
71:50 - object while in the object shader will
71:53 - multiply it by whatever you currently
71:55 - have in your frag color we are now able
71:58 - to simulate the color of the light
72:00 - hitting the object so next we'll want to
72:03 - simulate the intensity of that light
72:06 - you've probably noticed that the higher
72:08 - the angle between a surface and the
72:10 - source of light is the less intense
72:13 - color is on that surface this is the
72:15 - seen on a sphere where you can clearly
72:18 - see the gradient of the intensity along
72:20 - the curve of the sphere in order to get
72:23 - this angle and calculate the intensity
72:25 - we'll need a position of the light which
72:27 - we already have and a way to know the
72:29 - slope of the surface the traditional way
72:32 - of doing this is to represent the slope
72:34 - of the surface by a normal vector so so
72:38 - far we've had coordinates colors and
72:41 - texture coordinates inside the vertex
72:43 - now we'll also want to add normals
72:46 - normals are unit vectors aka vectors of
72:49 - length 1 that help us calculate how
72:52 - light should act on a certain object
72:54 - this can be either perpendicular to the
72:56 - surface of one triangle called phase
72:59 - normals or arranged in a different way
73:02 - such as being perpendicular to the plane
73:04 - created by all the adjacent vertices for
73:07 - example called vertex normals if you go
73:10 - for the first option you will get what's
73:12 - called flat shading where all your
73:15 - triangles are clearly visible if you go
73:17 - for the second option things look a lot
73:20 - smoother and nicer but which one you
73:22 - choose depends on your mesh and on your
73:25 - artistic style since we have a pyramid
73:27 - we'll go with a flat shading since the
73:30 - smooth shading looks weird on very
73:32 - angular geometric shapes such as cubes
73:34 - or pyramids now since the normals will
73:38 - be different on each side of the pyramid
73:40 - we won't be able to fit all of them in
73:42 - just five vertices like we have here
73:45 - we'll have to duplicate some vertices in
73:47 - order to change their normals so i'll
73:50 - just do that plugging in my
73:51 - pre-calculated normals for each face
73:54 - don't worry if some of your normals are
73:56 - not unit length it does not matter since
73:59 - we can just normalize them in the shader
74:01 - later don't forget to also change your
74:04 - indices the gel draw elements function
74:07 - in case you haven't automated it like me
74:09 - and add a new attribute to the vao so
74:13 - now for the vertex shader we'll include
74:15 - the normal layout and also export it to
74:18 - the fragment shader along with the
74:20 - current position which we'll use to
74:22 - calculate the direction of light for
74:25 - consistency purposes i'll also import
74:28 - the model matrix for the pyramid now in
74:30 - the fragment shader we import the normal
74:33 - and current position and the light
74:35 - position uniform then in the main
74:37 - function first normalize the normal
74:39 - vector and then get the light direction
74:42 - vector by simply subtracting the current
74:44 - position from the light position and
74:47 - normalizing it we now have the two
74:49 - vectors we need the lighting we're
74:51 - implementing now is called diffuse
74:53 - lighting so i will create a float called
74:56 - diffuse then in order to make it such
74:58 - that the larger the angle between the
75:00 - two previously calculated vectors the
75:03 - less intensity the light has we can
75:06 - simply use a dot product between them
75:09 - which is equal to the cosine of the
75:11 - angle between them since they are
75:13 - normalized now this can also be negative
75:16 - and since we don't want negative colors
75:19 - we'll take the maximum value between
75:21 - this and zero all that's left to do is
75:24 - to multiply the diffuse float with the
75:26 - color of the object a texture in our
75:29 - case if you now boot up the program you
75:31 - will notice that we have some nice
75:33 - lighting but that the areas not touched
75:36 - by a light are extremely dark this is
75:39 - realistic in our case where we only have
75:41 - one object in or in a vacuum but
75:44 - generally speaking it's not realistic a
75:47 - slide will bounce from other objects
75:50 - that are around onto our object this
75:53 - bouncing is expensive to calculate and
75:55 - pretty advanced so for now we'll
75:58 - simulate it by simply giving a base
76:00 - value of brightness this type of
76:02 - lighting is called ambient lighting so
76:05 - just create a float called ambient and
76:07 - give it a value like 0.2 and then add it
76:10 - to the diffuse value in the front color
76:13 - boot up again and notice this looks a
76:15 - bit better the last type of lighting we
76:18 - have to add in order to complete our
76:20 - lighting algorithm which by the way is
76:23 - called phong shading
76:25 - is the specular light this is dependent
76:27 - on the angle you look at an object from
76:30 - so you'll need to import the camera
76:32 - position into the fragment shader first
76:34 - now create a float specular light which
76:37 - will represent the maximum intensity of
76:40 - this type of light now we need a view
76:42 - direction
76:43 - which should just be the composition
76:46 - minus the current position normalized
76:48 - and the other thing we need is the
76:50 - direction of the reflection which we can
76:53 - get by using the reflect function
76:55 - plugging in the negative direction of
76:57 - the lighting since we want the vector to
77:00 - be towards the plane not away from it
77:03 - and the normal then create a float spec
77:06 - amount which will store how much
77:08 - specular light we have at a certain
77:10 - angle with our camera so the larger the
77:13 - angle between the fuse direction and
77:15 - reflect direction is the weaker we want
77:18 - the specular light to be so just use a
77:21 - dot product like before and take the max
77:24 - between this and zero then we'll want to
77:27 - raise this to a power the higher the
77:29 - power
77:30 - is the more point-like and defined the
77:33 - specular light will be i will go for a
77:35 - lower power such as 8. now create a
77:38 - float named specular and multiply the
77:40 - specular light with the spec amount last
77:43 - thing to do is to add the specular float
77:46 - to the diffuse and ambient floats now
77:48 - you have some nice decent lighting for
77:51 - your scene don't forget to add comments
77:53 - to everything you've written to make
77:55 - sure you understand it and as always the
77:57 - source code is in the description
78:15 - today i'll show you how to improve
78:17 - specular lighting with the use of
78:19 - specular maps i'll start by slightly
78:22 - modifying the texture class so that it's
78:25 - easier for us to assign multiple
78:27 - textures to the same shader then i'll
78:30 - delete the pyramid we had and simply
78:32 - create a flat plane i'll also import
78:35 - this wood texture in the specular map
78:37 - you can find this in the description
78:39 - i'll also assign the wood texture to the
78:41 - plane now as you can see the specular
78:44 - light is just sort of flat areas that
78:48 - shouldn't reflect much light such as the
78:50 - cracks in the wood still somewhat do so
78:53 - and the areas that should reflect a lot
78:56 - of light such as the smooth tops of the
78:58 - wood don't really do so in order to fix
79:02 - this we can make use of something called
79:04 - a specular map these types of maps are
79:06 - black and white textures that tell the
79:09 - program where specular light should
79:11 - appear and how strong it should be at
79:13 - that point the whiter a pixel on the
79:15 - specular map is the more specular light
79:18 - you'll get and the blacker a pixel is
79:21 - the less specular light you'll get the
79:23 - idea is really simple so to implement it
79:26 - we must first import a specular map into
79:28 - our program make sure to import it using
79:31 - gl red not gl rgba since it only has one
79:35 - color channel not four then simply
79:38 - export it to the shader and bind it in
79:40 - the main function now import the texture
79:43 - in the shader and in front color
79:45 - multiply its red value by the specular
79:48 - light and add that to the other texture
79:50 - which is only multiplied by the diffuse
79:53 - and ambient lighting now that's it for
79:55 - the specular light now i'll just change
79:58 - the value to make the light look better
80:00 - on the wood and if you then boot up the
80:02 - program you should see that the specular
80:04 - light looks much better and it makes the
80:07 - whole texture look better overall as
80:09 - always the source code is in the
80:11 - description
80:17 - now let's take a look at different types
80:18 - of light there are three main types of
80:21 - light point directional and spotlight
80:24 - point lights illuminate the environment
80:26 - in all directions but the intensity of
80:28 - their light withers as it gets further
80:30 - away this is the type of light we've
80:32 - used still now except we didn't
80:34 - incorporate the loss of intensity so
80:37 - let's quickly do that first let's create
80:39 - a vector function named point light and
80:42 - copy paste into it all the things from
80:43 - the main function and make frag color
80:46 - equal the output of this function so the
80:48 - intensity of light has an inverse square
80:51 - relationship to distance in real life
80:53 - but in computer graphics we use a
80:55 - somewhat more complicated equation to
80:58 - better control the properties of the
81:00 - light instead of having one over
81:02 - distance squared we have one over a
81:05 - quadratic equation with respect to
81:08 - distance this quadratic equation has two
81:10 - constants a the quadratic term and b the
81:14 - linear term we can modify this to change
81:17 - how fast the intensity dies out and how
81:19 - far the light reaches there is no
81:21 - general perfect number for these
81:23 - constants you just have to play with
81:25 - them and see what works for your scene
81:27 - just know that usually the numbers are
81:30 - smaller than one if you want your light
81:32 - to reach somewhat far so to implement
81:35 - this we first need a distance to the
81:37 - light the distance is simply the length
81:39 - of the vector that comes from
81:41 - subtracting current position from light
81:43 - position since we already use this in
81:46 - our diffused lighting i'll create a
81:48 - variable named light vector so that we
81:50 - don't have to calculate it twice now we
81:53 - can get a distance by simply using the
81:55 - length function lastly we just write out
81:57 - the equation with the variables and
81:59 - apply it to the specular and diffuse
82:01 - lighting here are some examples of the
82:04 - results i got using different constants
82:06 - the second type of light is the
82:08 - directional light this is usually
82:10 - considered to be so distant from your
82:12 - scene that the light rays it emits are
82:15 - essentially parallel to one another just
82:17 - like the rays of the sun this has no
82:19 - dimming and is actually the easiest of
82:22 - the three to implement we just need to
82:24 - copy paste part of the code from the
82:26 - point light and instead of calculating
82:28 - the light direction based on some
82:30 - positions we simply give it a constant y
82:32 - direction as a normalized vector 3. just
82:35 - note that it should point in the
82:37 - opposite direction you want it to affect
82:39 - due to the way i wrote the code here so
82:42 - if you want the light to come from above
82:44 - it should point up not down and if you
82:47 - press run you'll see everything is lit
82:49 - up as it should be the last type of
82:51 - light is the spotlight the spotlight
82:53 - only lights a conic area just like a
82:55 - flashlight or a disc clamp for this
82:58 - we'll copy paste the point light code
83:00 - again and begin by adding two floats
83:02 - which will represent the cosine values
83:04 - of two angles the first angle is the
83:07 - angle between the inner cone and the
83:09 - direction of the light and the second
83:11 - angle is the angle between the outer
83:13 - cone and the direction of the light we
83:16 - make use of these two cones in order to
83:18 - have a nice gradient between darkness
83:20 - and light areas since if we only made
83:23 - the use of one cone we would just have a
83:26 - direct cutoff from light to darkness i
83:29 - wrote a cosine value directly in order
83:32 - to save computational power do not write
83:34 - the inner and outer cones in terms of
83:37 - angles since that will require extra
83:40 - calculations and it will slow down the
83:42 - program now we need to calculate the
83:44 - angle between the current port that is
83:46 - being lit in the central direction of
83:48 - the light using a dot product this will
83:51 - give us a cosine value which is perfect
83:53 - to compare with our own cosine values
83:56 - the last step is to get the intensity of
83:58 - the current spot which is done using
84:00 - this formula make sure to also clamp it
84:03 - between 0 and 1 so you don't get weird
84:06 - values and lastly just multiply the
84:09 - diffuse in the spectral lighting by the
84:11 - intensity variable start the program and
84:14 - you'll see that the light is restricted
84:16 - to one area don't forget to write
84:18 - comments for everything you've written
84:19 - to make sure you understand it and as
84:22 - always the source code is in the
84:23 - description
84:33 - in this tutorial we'll wrap up all the
84:36 - classes we've made till now and a big
84:38 - part of the code in the main function
84:40 - into a mesh class that will also serve
84:43 - as a stepping stone for importing models
84:45 - in a future tutorial first a rough
84:48 - definition of a mesh a mesh is a data
84:51 - set that almost always contains vertices
84:54 - often contains indices and sometimes
84:56 - contains textures as well and they are
84:59 - generally used to create 3d models so
85:02 - let's create a header file for the class
85:05 - first we'll want to include the string
85:06 - library and then the vio ebo camera and
85:10 - texture classes since we want the three
85:13 - of our classes dependencies to look like
85:15 - this now for the class itself i'll
85:18 - declare three vectors named vertices
85:21 - indices and textures
85:23 - note that these are c plus plus vectors
85:26 - and not glm vectors we are using vectors
85:30 - instead of arrays since we can't know
85:32 - the size of our arrays so it's best to
85:35 - keep things flexible in terms of storage
85:38 - as you can see we get some errors but
85:40 - don't worry we'll fix those after we
85:42 - finish writing everything in here next
85:44 - we also want to store our vio since
85:47 - we'll be initializing it using this
85:49 - class then for the constructor we'll
85:51 - simply input the vertices indices and
85:53 - textures and lastly we'll make a
85:55 - function draw that will take in a shader
85:58 - and a camera now for the errors let's go
86:01 - to the vbo class if you've been paying
86:03 - attention you probably would have
86:05 - noticed that our vertices vector
86:07 - contains a structure named vertex but we
86:10 - don't have one so far so let's create
86:12 - one right here i'll simply name the
86:14 - structure vertex and give it three
86:16 - vectories for the position normal in
86:19 - color and then a vector for the texture
86:21 - coordinates having our data packed in
86:24 - such a structure is nicer than simply
86:27 - having all the data in one array at
86:30 - least in my opinion don't forget to also
86:32 - include the glm library though now we
86:35 - need to patch up the vbo class
86:37 - constructor to accept the vector of
86:40 - vertex structs instead of an array so
86:42 - let's also include the c plus plus
86:44 - vector and since we're using vectors
86:46 - instead of arrays we can now also get
86:48 - rid of the size input since we can
86:51 - calculate that inside the class so in
86:54 - the vbo.cpp file we can replace the size
86:57 - by
86:58 - vertices.size times size of vertex and
87:01 - for the data we just write vertices dot
87:04 - data if you return to the mesh class you
87:06 - should have no more errors now let's do
87:08 - what we did for the vbo class to the ebo
87:11 - class as well replacing the array with a
87:13 - vector now for the main part let's
87:16 - create the mesh.cpp file insert writing
87:18 - the functions for this class let's start
87:21 - with the constructor by simply assigning
87:23 - the inputs to the variables of the class
87:26 - then copy paste the initialization of
87:28 - the vio from the main function and
87:30 - modify the variable's names slightly and
87:33 - also the way the attributes are stored
87:35 - we want the position first then the
87:38 - normals then the colors and finally the
87:40 - texture coordinates since we've modified
87:43 - this we should go to the vertex shader
87:45 - and rearrange the new order of the
87:47 - vertices sections properly and then do
87:51 - the same thing in the fragment shader as
87:53 - well it's not mandatory to keep them in
87:56 - this specific order when importing or
87:59 - exporting them but it just looks nicer
88:02 - to have them in the same order
88:03 - everywhere though it is important to
88:06 - have them in the proper order when
88:08 - choosing the layouts in the vertex
88:10 - shader now let's continue with our mesh
88:12 - class by writing the draw function we'll
88:15 - start by activating the shader and
88:17 - biting the vio as usual now we'll have
88:21 - to do something a bit more complicated
88:23 - in order to properly load the textures
88:26 - since we won't always know how many
88:28 - textures a mesh has so let's create two
88:31 - unsigned integers that are equal to zero
88:34 - and are named num diffuse and num
88:37 - specular this will keep count of our two
88:39 - types of textures then we want to go
88:42 - through all the textures where we'll
88:43 - have a temporary string called num and
88:46 - another temporary string called type
88:49 - which will store the type of the current
88:51 - texture the problem is that our textures
88:54 - don't store their type yet i mean they
88:57 - do it's just that they store a different
89:00 - kind of type in any case we'll want to
89:02 - modify our texture class by changing the
89:05 - type variable to a constant character
89:07 - array and so also the type of the input
89:11 - in the constructor then in the
89:13 - texture.cpp file we'll want to make all
89:16 - the text type equal gel texture 2d since
89:19 - 99 of the time that's what we'll be
89:22 - using now let's go back to our mesh.cpp
89:25 - file and create some checks we'll check
89:28 - if the type is diffuse and if it is make
89:31 - the num equal to a string of num diffuse
89:34 - and then increment it by 1. then we'll
89:37 - do the same check for specular and
89:39 - increment num specular now we want to
89:41 - take care of the uniform using our
89:44 - function text unit plugging in the
89:46 - shader then a c string composed of our
89:49 - type plus num and the unit of our
89:52 - texture then simply bind the texture so
89:55 - our uniforms will be named diffuse 0
89:58 - diffuse 1 diffuse 2 specular 0 etc so in
90:02 - our fragment shader we want to replace
90:04 - our text 0 uniform by diffuse 0 and our
90:07 - text 1 uniform by specular 0. then again
90:11 - go back to the mesh.cppp file and send
90:14 - our composition and count matrix
90:16 - uniforms and also write the gl draw
90:19 - elements function all that's left to do
90:21 - now is to modify our main.cpp file first
90:24 - we can delete all the includes and only
90:26 - include our mesh class then we'll have
90:29 - to modify the vertices array and after
90:32 - that in the main function make an array
90:34 - for our textures as well delete the vio
90:37 - initialization and create vectors for
90:40 - our vertices indices and textures using
90:43 - the arrays from before then create a
90:45 - mesh named floor with the vectors we've
90:47 - just created do the same for the light
90:49 - except we don't have any textures on the
90:52 - light so we'll just place the same
90:54 - textures as a placeholder in the while
90:56 - loop we can just delete all the drawing
90:59 - stuff for the light and floor and
91:00 - replace them with our draw function and
91:03 - finally we just need to get rid of some
91:05 - of the deletes at the end of the file if
91:07 - you press run everything should now be
91:09 - fine if you have any errors go over the
91:12 - video again or check out the source code
91:14 - in the description as always you should
91:16 - add comments to everything you've added
91:18 - to make sure you understand what's
91:20 - happening
91:28 - in this tutorial i'll show you how to
91:30 - import 3d models into your opengl
91:32 - application by building a very basic
91:34 - importer this tutorial will also be
91:37 - longer than usual and only have visible
91:39 - results at the end so please have
91:41 - patience and pay attention to what i'm
91:43 - doing otherwise you might end up with a
91:45 - chain of errors by the end a small note
91:48 - first as you may know when it comes to
91:50 - storing images the industry is pretty
91:52 - standardized with the use of pngs and
91:54 - jpegs but when it comes to 3d models
91:57 - there are dozens upon dozens of file
91:59 - formats many of which are proprietary
92:01 - this diversity of file formats makes it
92:04 - a lot more difficult to export and
92:06 - import models from one program to
92:08 - another in the spirit of standardization
92:11 - i will use the gltf file format for this
92:13 - tutorial as it is made by the same
92:15 - people who've made opengl the chronos
92:17 - group and it seems to be a promising
92:19 - file format that could become the
92:21 - standard in the future i left a link to
92:23 - a nice article on this by the developers
92:26 - of the godot engine in the description
92:28 - now for the actual tutorial gltf makes
92:31 - use of the json file structure so the
92:33 - first thing we'll need to do is to
92:34 - install niels lofman's json library from
92:37 - github to be able to parse json files
92:40 - that does it for the libraries now we
92:42 - can create a header file for our model
92:44 - class a model being a group of meshes
92:47 - then we'll make a constructor that will
92:49 - take in the name of a file and the draw
92:51 - function that will take in a shader and
92:53 - a camera in the private section we'll
92:55 - want to store the name of our file a
92:57 - vector of bytes with all the data of the
92:59 - model and a json object which i'll
93:01 - explain more about in a moment now for
93:03 - the model.cpp file let's read the gltf
93:06 - file in the constructor using the same
93:08 - function we used to read the shaders
93:10 - then we parse the text and store it in
93:13 - the json variable so json files work
93:16 - like dictionaries within dictionaries
93:18 - dictionaries have keys and values
93:21 - associated to those keys if you give a
93:23 - dictionary a key it will point you to a
93:25 - certain value this json object abstracts
93:28 - the gltf file into such structures so
93:31 - let's just store our file and then
93:34 - equate our data variable to a function
93:36 - get data we want this function to get us
93:39 - a vector of points from an external
93:41 - binary data file so let's create a
93:44 - string named byte sticks to hold the raw
93:46 - text to get the location of the file we
93:49 - can look at the buffers key which will
93:50 - point us to an array where we want to
93:52 - look at the first element which will
93:54 - again be a dictionary so we again want
93:56 - to use a key this time the uri key this
94:00 - uri gives us the name of a dot bin file
94:02 - which contains the binary data then we
94:05 - just get the text put it in a vector and
94:07 - return it so now that you have your
94:09 - first taste of the json file let's take
94:11 - a closer look at it the file has
94:13 - dictionaries which contain arrays of
94:16 - other dictionaries thus making it a sort
94:18 - of tree but it's not a very nice tree
94:21 - since many branches will contain indices
94:23 - that will point us to other branches so
94:26 - things will get entangled pretty quickly
94:29 - in order to avoid confusion in such a
94:31 - situation i like to start from the
94:33 - leaves and work my way down to the root
94:36 - of the three keep in mind that i will be
94:38 - taking some shortcuts in the gltf file
94:40 - since otherwise this importer would
94:42 - become too complicated with that out of
94:45 - the way here is a simplified view of one
94:47 - of the main branches of the tree and the
94:50 - one we care most about at the top we
94:52 - have our data that's stored in the
94:54 - buffers but to know which parts of it we
94:56 - should read we need to take a look at
94:58 - the buffer views then again these will
95:01 - only tell us where to look not what to
95:03 - look for in order to know what types of
95:06 - data types we are reading we need to
95:08 - look at the accessors so great the
95:10 - accessories tell us that we are reading
95:12 - an int or maybe a fake tree for example
95:15 - the problem is that they don't tell us
95:18 - what these are used for a vectory could
95:20 - be both a position and a normal to find
95:23 - out which is which we need to once again
95:26 - take a step back it's just that this
95:27 - time we'll have to split in two if we
95:30 - look at the attributes then we know
95:32 - which accessors are part of which vertex
95:34 - attributes aka positions normals texture
95:38 - coordinates etc if we look at the
95:40 - primitives we can find the accessor of
95:42 - the indices of our mesh keep in mind
95:45 - that the attributes are pointed to by
95:47 - the primitives these also point to
95:49 - materials which point to textures but
95:51 - we'll ignore that since materials often
95:54 - have pbr data and since we haven't
95:56 - learned about that yet we'll skip
95:58 - directly to the textures ignoring the
96:00 - materials if we get back to our main
96:02 - branch the primitives are pointed to by
96:05 - the meshes which are again pointed to by
96:07 - the nodes and lastly the scenes in our
96:10 - case we'll have one scene 99 of the time
96:13 - so we can ignore those and just focus on
96:15 - the notes which will contain pointers to
96:17 - all our meshes don't worry if you don't
96:20 - fully understand what i just went
96:22 - through it's normal to not fully
96:24 - comprehend it from the start you should
96:26 - get a better idea of it when we write
96:28 - the code so let's start with the leaves
96:30 - by assuming we get an accessor node
96:32 - let's declare a get floats function and
96:35 - get indices function then we'll also
96:37 - want to declare three functions that
96:40 - will take the array vectors outputted by
96:42 - the get functions and group them into
96:44 - glm vectors so we'll first want the
96:47 - buffer view the count the byte offset
96:50 - and the type from the accessor notice
96:52 - how i use the value function instead of
96:55 - brackets to get the byte offset in
96:57 - buffer view the brackets will simply
96:59 - give you the value of the key while the
97:01 - folded function will give you the value
97:03 - of the key if it exists otherwise it
97:06 - will give you the second input these two
97:08 - parameters are not always found in gltf
97:11 - files so i want a backup value for them
97:13 - in case they do not exist while the
97:15 - other two always exist so i don't need
97:18 - any backup to see which of these are
97:20 - always found and which or not check out
97:22 - the specification of gltf on github link
97:25 - in the description now using the index
97:28 - of the buffer view we got we want to
97:29 - create a json variable for the buffer
97:32 - view dictionary from which we'll get the
97:34 - byte offset now to explain all the
97:36 - parameters we got the buffer view index
97:39 - simply pointed us to the correct buffer
97:41 - view as mentioned a second ago the count
97:44 - tells us how many floats we have to get
97:46 - the accessor byte offset tells us from
97:48 - what index to look at the data with
97:51 - respect to the beginning of the buffer
97:53 - view and the byte offset tells us where
97:56 - that buffer view starts the reason we
97:58 - have two different offsets is that
98:01 - sometimes two different accessories may
98:03 - share the same buffer view for example
98:05 - we could have a vector3 buffer view
98:07 - which is shared by a positions accessor
98:10 - and a normals accessor and finally the
98:13 - type tells us how we should group the
98:15 - floats it can either be scalar vector
98:18 - vectory or vect4 using this type we'll
98:21 - want to get the number of floats per
98:23 - vertex then in a for loop go over all
98:26 - the data we'll store the bytes in a
98:28 - temporary array which will then using
98:30 - the function mem cpy to transform the
98:33 - bytes into a float which will then store
98:36 - in the variable value and push it in the
98:38 - float fake vector at the end simply
98:40 - return the float veck now i'll do the
98:43 - same thing for indices except this time
98:46 - we won't check the num per vert since
98:48 - indices are not stored in vertices
98:50 - instead we'll check the data type of the
98:53 - index itself and according to that read
98:55 - it differently from the data the index
98:58 - can either have type
99:00 - 5125 which is an unsigned integer type
99:04 - 5123 which is an unsigned short or type
99:08 - 5122 which is a short now for the
99:10 - grouping functions we'll simply go over
99:12 - all the floats in the float vector and
99:15 - group them in their corresponding glm
99:17 - vectors really easy stuff using the get
99:20 - floats function we'll be able to get all
99:22 - the attributes of a vertex so the next
99:24 - logical step would be to combine those
99:26 - attributes in a vertex so let's declare
99:29 - a function for that which takes the
99:31 - vertices normals and texture coordinates
99:34 - and combines them into a vertex which
99:36 - will be put in a c plus vector very
99:38 - straightforward stuff notice that i did
99:41 - not include the colors in here since
99:44 - even though we declared them in our
99:46 - vertex they are actually very uncommon
99:48 - in 3d models so we can ignore them we
99:51 - now have the vertices and indices all
99:53 - that's left for a complete mesh is the
99:56 - textures but before we take care of
99:58 - those we should first modify our texture
100:00 - class a bit first we should remove the
100:02 - last two inputs of the constructor since
100:05 - we'll atomize the first one and the
100:07 - second one is the same 99 of the time
100:10 - for the first one we'll simply check the
100:12 - number of color channels a texture has
100:14 - and assign a corresponding color type to
100:17 - the texture then for the second one we
100:19 - just replace it everywhere with gel
100:22 - unsigned white so now let's create a get
100:24 - textures function we want to skip
100:26 - directly to the images key which will
100:29 - give us an array of your eyes here we
100:32 - loop over all of them while keeping
100:34 - track of the unit of each texture then
100:36 - if the texture contains base color in
100:39 - its name it's a diffuse texture if the
100:41 - name contains metallic roughness we can
100:44 - somewhat use this texture as a specular
100:46 - map keep in mind that this way of
100:49 - checking the type of a texture is not
100:51 - ideal and may differ from model to model
100:54 - also the reason the metallic roughness
100:56 - just sort of works for a specular map is
100:59 - because it's something that's meant for
101:01 - pbr the problem with this function
101:03 - though is that it can load the same
101:06 - texture multiple times which we don't
101:08 - want to do since it will use up a lot of
101:11 - ram to prevent that we want to create
101:13 - two variables loaded text name and
101:16 - loaded text we'll use loaded text name
101:19 - to determine whether or not we've loaded
101:21 - a texture and loaded text to store the
101:24 - textures for all meshes to use then in
101:26 - the function we'll add a skip variable
101:29 - which will become true if the texture we
101:31 - are currently trying to load has the
101:33 - same name as a texture in loaded text
101:35 - name if it becomes true we don't load it
101:38 - anymore instead simply pushing an
101:40 - already loaded texture to the textures
101:42 - vector we can also replace the unit by
101:45 - the size of the loaded text vector as
101:47 - well this does it for our textures we
101:50 - don't have all the elements needed for a
101:52 - mesh so let's make a load mesh function
101:54 - that will take in as an argument the
101:56 - index of a mesh we want to load we'll
101:58 - also want to create a meshes vector to
102:01 - store all the loaded meshes into so
102:03 - first we want to get the indices of all
102:05 - the accessors of the vertices then we'll
102:08 - simply use our get floats and group
102:11 - floats functions for the attributes of
102:13 - the vertices after that we assemble our
102:15 - vertices and get our indices and
102:18 - textures then we just create a mesh with
102:20 - these three vectors and push it to the
102:22 - meshes vector now we can load multiple
102:25 - meshes by simply iterating over them the
102:28 - problem is that we don't know where to
102:30 - place those meshes so they will likely
102:33 - all be within one another at the origin
102:36 - in order to know where to place them and
102:38 - how big they should be we must extract
102:41 - the matrix transformations from the gltf
102:43 - file and we can't just get the matrix of
102:46 - each mesh but must instead keep track of
102:48 - what children each mesh has in order to
102:51 - multiply the matrices of each mesh
102:53 - together all the information for the
102:55 - matrices and the relationship between
102:58 - meshes is in the nodes so let's create
103:00 - the function named traverse node which
103:02 - takes the index of a node and the matrix
103:05 - making it half the identity matrix as a
103:07 - default value then let's also create
103:09 - vectors for different types of
103:11 - transformation matrices we have
103:13 - translations which move the mesh
103:15 - rotation switch rotated scale switch
103:18 - change its size and matrices which are a
103:20 - combination of the offer mentioned but
103:23 - we can't know if the first three will be
103:25 - used or just a matrix so we need to
103:27 - account for both we must first modify
103:30 - our mesh class by adding these
103:32 - transformations to the draw function as
103:34 - inputs with default values that don't
103:36 - change anything and then sending them to
103:38 - the shader at the end of the function
103:40 - don't forget to also create uniforms for
103:43 - these transformations in the vertex
103:44 - shader and multiply them like so i put a
103:47 - negative sign in front of the rotation
103:49 - matrix since that's what i found to work
103:52 - it might be a bug in my code or the fact
103:54 - that glm and gltf use different rotation
103:57 - standards aka clockwise versus counter
104:00 - clockwise and since we're in the vertex
104:03 - shader we also need to rotate the
104:04 - texture coordinates by 90 degrees which
104:07 - we can do with this matrix this again
104:09 - either has something to do with the bug
104:11 - in the code or different standards
104:13 - what's important is that it works
104:15 - decently well now for the function
104:17 - itself we'll want to get a current node
104:19 - as a json object and then extract the
104:22 - transformations if they exist notice how
104:24 - for the rotation quaternion i get the
104:27 - indices in the order 3 0 1 2 instead of
104:30 - 0 1 2 3. this is because gltf encodes
104:33 - quaternions as x y z w while glm uses
104:38 - them as w x y z again just
104:41 - standardization problems now we want to
104:43 - combine all of these transformations
104:45 - including the matrix we get us an input
104:48 - then we check if we have an index to a
104:50 - mesh and if we do we push all the
104:52 - transformations and load the mesh after
104:54 - that we check if the mesh has any
104:56 - children and if it does we want to apply
104:58 - this same function to all of them while
105:01 - also giving them the current matrix we
105:03 - have so this function is recursive and
105:05 - so we'll split along the parts of the
105:07 - tree till it gets to all the nodes now
105:10 - we can write this function in the
105:11 - constructor and give it 0 as an input
105:14 - the last thing we need to do is write
105:15 - our draw function and that's it for the
105:18 - model class in the main.cpp file we just
105:20 - have to include the model class and
105:22 - delete all the old mesh related stuff
105:25 - then get some models create a model
105:27 - object and draw it in the main while
105:29 - loop here are some examples of models
105:31 - i've been able to load in i've left some
105:33 - models that should 100 work in the
105:36 - repository of this tutorial on github so
105:39 - if you're getting some errors check
105:40 - those models to see if you have a
105:42 - problem with your code or the model
105:44 - you're trying to load in again keep in
105:46 - mind that this importer is in no way
105:48 - complete and is in fact very basic so
105:51 - don't expect to be able to load in any
105:53 - model you find on the internet i find
105:55 - that a decent amount of models from
105:57 - sketchfab.com work pretty well
105:59 - especially if they don't have too many
106:01 - meshes that's it for this tutorial it
106:03 - was a really long one but also a very
106:05 - rewarding one if you ask me as always
106:08 - don't forget to add comments to
106:09 - everything you wrote to make sure you
106:11 - understand it and the source code is in
106:13 - the description bye