00:04 - [Music]
00:07 - good evening everyone
00:09 - thank you first of all to vijay for
00:11 - having me back i was with a group of
00:13 - developers who worked on a react open
00:16 - source project having to do with server
00:17 - side rendering and we had a lot of fun
00:20 - speaking together it was five of us
00:22 - passing off the the speaking roles back
00:24 - and forth for the course of the meetup
00:27 - so this time i'm holding down the ford
00:29 - alone but i'm excited i'm very excited
00:32 - to have a chance to nerd out with you
00:34 - guys for a little bit about javascript
00:37 - modules
00:38 - and this is a top topic that i think is
00:40 - particularly fascinating because when we
00:43 - look at the history and the development
00:45 - of modules in javascript we're kind of
00:48 - going in parallel with
00:50 - we're tracing
00:51 - the history of javascript growing as a
00:54 - language from kind of humble origins as
00:57 - this lightweight scripting language that
00:59 - was running in netscape to really
01:02 - becoming a powerhouse that gives us the
01:04 - modern web with all of its interactivity
01:06 - and
01:07 - everything that we love about it so now
01:10 - we're basically in an era where
01:12 - we have javascript running everywhere
01:14 - universal javascript javascript on the
01:16 - client and on the server side um on
01:20 - we have it in our thermostats even
01:21 - flying drones for us so needless to say
01:24 - javascript has come a very long way
01:26 - and so have modules
01:30 - oh and the pronunciation of my name for
01:33 - uh anyone who might have been wondering
01:35 - is meijin rhymes with regen so
01:38 - just
01:38 - well anyway
01:41 - so the first thing that i would like to
01:43 - posit is that modules are a fundamental
01:46 - part of our lives as javascript
01:48 - developers they're kind of part of the
01:51 - scenery
01:52 - so i do a lot of my day-to-day work in a
01:54 - react code base so when i fire up my
01:56 - code editor many of the files i'm
01:59 - looking at have kind of a predictable
02:01 - structure
02:02 - i see some import statements at the top
02:04 - some export statements at the bottom
02:06 - i almost don't even think about them i
02:09 - mean unless i've
02:11 - put a typo in my file path or something
02:13 - and i then i am thinking about them but
02:15 - um i imagine there are other folks in
02:16 - the room working in other frameworks and
02:19 - working in other
02:21 - type code bases and environments
02:24 - so
02:25 - modules and modular thinking are kind of
02:28 - second nature to us and that's really
02:30 - how it should be modules are supposed to
02:33 - make our lives easier as developers they
02:36 - do this by giving our code
02:38 - structure
02:39 - and boundaries so that way we don't have
02:42 - to think about all of the moving parts
02:45 - i don't have to have the react source
02:46 - code mingling with my component logic i
02:49 - can take a grand take for granted that
02:51 - it's going to be available for me and do
02:54 - what i want it to do most of the time
02:57 - so for now it resides elsewhere out of
02:59 - sight
03:00 - and out of mind
03:02 - and this is especially important as code
03:04 - bases get bigger
03:06 - so when we hear about terms like
03:08 - modularity and separating concerns
03:11 - that's really
03:12 - about our sanity as developers who are
03:15 - working with each other and working with
03:16 - a lot of code
03:20 - so let's start out and get on the same
03:22 - page as far as our
03:24 - concepts and terminology we'll start
03:26 - with the basics what's a module anyway
03:29 - i like to think about modules as
03:31 - building blocks of data
03:34 - and functionality
03:35 - and
03:36 - we can bring them into a program
03:39 - and we can also make them available to
03:41 - other programs
03:42 - and ideally you can kind of treat them
03:44 - like you would building blocks and
03:46 - hopefully you can add or remove pieces
03:48 - from the hole without
03:50 - the whole structural integrity falling
03:52 - apart
03:54 - so when we're talking about modules
03:56 - we're really talking about the higher
03:57 - level design of our software we're often
04:00 - thinking about modules in terms of a
04:02 - single file because that's typically how
04:04 - we organize our modules one module
04:07 - one file
04:09 - we can also talk about modules in terms
04:11 - of their relationships to other modules
04:14 - so
04:14 - a module has an interface and that's
04:18 - its exposed bits
04:20 - that let us have data and functionality
04:22 - available for use in other programs
04:25 - i kind of like to think of the module
04:27 - interface
04:28 - as the little bumps on the top of a lego
04:31 - brick so
04:32 - you can try to put your lego bricks side
04:34 - by side and they won't really stick
04:36 - together but those little bumps which i
04:39 - actually just found out are called studs
04:41 - lego studs
04:43 - are how we actually get our structures
04:46 - to stick together and so module
04:47 - interfaces are a little bit like that
04:49 - and a module can also have dependencies
04:53 - and often that just means that we're
04:55 - dealing with other functionality that
04:57 - we're relying on
04:59 - to
04:59 - have the functionality of whatever
05:01 - module we're working in
05:05 - and so just to have a hammer at home in
05:07 - case there's any ambiguity about my
05:09 - personal position on this modules are
05:12 - awesome they help us to keep organized
05:14 - code bases especially as those code
05:17 - bases are growing in complexity
05:19 - they help us
05:21 - resolve our dependencies making sure
05:23 - that any pieces of code are supposed to
05:25 - be there and we don't have to worry
05:26 - about getting them all in the right
05:28 - order
05:29 - they also help us to share and reuse
05:31 - code so we have a wonderful thing called
05:35 - npm that gives us
05:37 - access to literally i think 700 000
05:39 - packages right now
05:41 - a lot of packages of code and we
05:43 - ourselves can be part of a community
05:45 - contributing to that global repository
05:48 - alongside others
05:49 - so kind of cool
05:53 - but
05:54 - before we go any further there is
05:57 - an elephant in the room and
06:00 - we should acknowledge it
06:02 - so these modules which i've been talking
06:03 - about and that are so fundamental to
06:05 - modular to modular and modern
06:08 - programming are actually
06:10 - just barely
06:12 - a part of javascript they weren't built
06:14 - into javascript pre es6
06:17 - so for most of its years
06:19 - as a language javascript didn't have any
06:22 - kind of built-in
06:24 - native module system so this is unlike
06:27 - python for example
06:29 - and so modules only really recently
06:32 - became part of the language and they've
06:34 - actually only just landed in modern
06:36 - browsers like as of this year
06:40 - so oftentimes when we're working with
06:42 - modules we're not working with the
06:44 - built-in module system at all
06:47 - we might be using require statements if
06:49 - we're working in node or com.js
06:52 - we might be using import statements like
06:55 - i showed earlier from react code we
06:57 - might be using valve to transpile them
06:59 - down to es5 and then
07:02 - to bundle those files that were all
07:05 - supposed to be separate into a single
07:06 - one for consumption by the browser um so
07:10 - what's going on
07:12 - well this is where i started getting
07:14 - curious like what how did we work for so
07:17 - long without modules in javascript
07:20 - and as i started to take a peek into the
07:21 - history i found that there was this
07:24 - overarching storyline that javascript
07:26 - was
07:27 - really built disadvantaged when it came
07:29 - to modules it wasn't built with any kind
07:31 - of modularity in mind
07:33 - when it was first invented it was just
07:35 - supposed to be lightweight scripting
07:37 - inline scripting
07:38 - and over time as
07:40 - more demands were made of javascript as
07:43 - a language to do more for us
07:45 - we see an increasing need
07:47 - so running in parallel for
07:49 - usable module systems
07:53 - so i like to think of the history of
07:56 - javascript as unfolding in four phases
08:00 - i made these up so
08:04 - i call it the pre-module era the
08:07 - do-it-yourself module phase the
08:09 - specification phase and the
08:10 - standardization phase and because it is
08:14 - something i made up and because it is a
08:16 - system of chronology it is not perfect
08:19 - not precise but what i was aiming to do
08:22 - and kind of
08:23 - splitting
08:24 - our timeline into these four segments
08:26 - was to bring some order
08:28 - to overall trends that we were that were
08:31 - taking place
08:32 - so i'll do a little fly over right now
08:35 - before we jump in and get into more
08:37 - detail for each of those phases but
08:40 - let's start at the beginning in the
08:42 - pre-module era when modules were not
08:45 - really a thing at all javascript didn't
08:47 - itself have much of an identity or much
08:50 - respect let's be honest at that point
08:52 - it was nothing like it is today
08:55 - that didn't last too long
08:57 - before we started realizing that we
08:58 - needed some kind of modules but in the
09:01 - absence of those built-in modules we
09:03 - were improvising we were making
09:06 - module type structures ourselves
09:09 - so
09:10 - uh
09:11 - roughly in 2011 we start to see module
09:14 - specifications growing in popularity
09:18 - the javascript community especially the
09:20 - service server side javascript community
09:22 - was really starting to take off
09:25 - and a lot of work had to be done just to
09:27 - make javascript the language people
09:28 - wanted to develop in
09:30 - and a big part of that was just coming
09:33 - onto the same page
09:35 - so that's also kind of our era of
09:39 - single page apps and frameworks like
09:41 - backbone and angular starting to come
09:43 - into vogue
09:45 - and finally today
09:47 - we have arrived
09:49 - in the era of standardization and that's
09:51 - the phase that is currently underway
09:54 - and i hate to spoil the plot
09:56 - right at the beginning but javascript is
09:59 - still pretty far from having a
10:00 - standardized module system
10:02 - we do have a standard system in place
10:04 - but we're still working out the kinks
10:06 - and we're still making things
10:08 - hold together in the ways that we hope
10:11 - that they will so that one day
10:13 - we will all be
10:16 - gloriously developing with modules and
10:19 - not having to think about all the uh the
10:22 - quirks that go with with trying to do
10:24 - that
10:26 - all right
10:28 - so
10:29 - let's begin our tour
10:31 - we begin
10:33 - in a time before modules
10:36 - javascript's age of innocence
10:40 - and as we peek into the yearbook
10:43 - dun
10:44 - dun we come across gems like this
10:49 - so totally 90s and i'm calling this the
10:51 - dark ages but really i think we were
10:54 - probably having a good time
10:56 - um
10:57 - anyone had a geocities
10:59 - website
11:02 - i sure did
11:04 - i think it was called like the raspberry
11:06 - garden or something
11:08 - it was like 12 anyway it had all these
11:10 - cool neighborhoods like soho and sunset
11:13 - strip and times square and i guess you
11:15 - can go to the wayback machine if you
11:17 - want to
11:17 - have some nostalgia but anyway
11:21 - as i'm looking at this specimen from the
11:24 - archives i think i'm seeing at least for
11:26 - sure
11:27 - one definite use of inline scripting
11:30 - which is probably like this fun little
11:32 - animated
11:33 - status bar that's going it's crossing
11:36 - the screen for your entertainment
11:38 - um
11:39 - anyone spot any others
11:42 - that's the only one that i feel like
11:44 - kind of confident on
11:48 - what a time
11:50 - what a time
11:52 - but
11:53 - anyway yes a wild west of inline
11:55 - scripting and script tags
11:57 - no modules to speak of really
12:00 - a question i want us to start thinking
12:02 - about is
12:04 - um
12:05 - is this scalable what are some of the
12:07 - problems we encounter in this wild west
12:11 - scenario
12:14 - well i'll say more about that in a
12:15 - moment
12:17 - but
12:18 - first let's get one thing straight
12:20 - at this stage in the game no one was
12:22 - really thinking about thinking about
12:24 - scalability that was not the name of the
12:26 - the game and if you don't take it from
12:28 - me take it from the inventor of
12:30 - javascript himself mr brendan ike i hope
12:34 - i
12:35 - hope he pronounces it that way too i
12:37 - could i could be butchering it but he
12:38 - did say in an interview with infoworld
12:42 - that no one thought
12:44 - javascript would be used at the wide
12:47 - scale that it is
12:49 - not just reaching lots of people on the
12:50 - web
12:51 - but large applications like gmail
12:55 - to write large code you don't just want
12:58 - this little snippet language that i made
13:00 - for beginners
13:02 - beginners
13:04 - you want strong apis and ways of saying
13:06 - hey this is my module and this is your
13:09 - module
13:10 - and you can throw your code over to me
13:12 - and i can use it safely
13:15 - so a quick trivia question does anyone
13:17 - know what your javascript was invented
13:24 - 95
13:25 - or did you say 95 that is exactly right
13:29 - over the course of 10 very intense days
13:32 - for
13:32 - mr ike and um
13:35 - i think his original instructions from
13:37 - netscape were actually to
13:39 - have a language that was a lot more like
13:42 - scheme for the browser
13:44 - so
13:45 - if anyone's worked with scheme which is
13:47 - kind of a dialective lisp you know it
13:49 - looks
13:50 - completely different from the javascript
13:52 - we know and love those instructions
13:54 - those marching orders changed
13:56 - significantly and
13:58 - i feel grateful for that
14:02 - so in the in 2006 we get the first of
14:05 - several manifestos that we will see
14:09 - um
14:10 - so this particular
14:12 - manifesto came from the yahoo user
14:14 - interface team in a blog post with the
14:17 - title
14:18 - global domination
14:21 - and they had a good point i would say
14:23 - and the point that they were trying to
14:25 - make is that global variables are
14:28 - a terrible risky practice that we're all
14:30 - engaging in
14:31 - this unsafe behavior that we're all
14:33 - engaging in
14:35 - but um
14:37 - in growing code bases we really had to
14:39 - cut cut cut that out
14:41 - and so what's the problem
14:44 - well
14:44 - global variables are notoriously
14:47 - unreliable and insecure and there are a
14:49 - few reasons for that and the first has
14:51 - to do with variable naming collisions
14:53 - so assuming mary and george
14:56 - on the u
14:57 - on the ue dev team are working on the
14:59 - same code and name to the very their
15:01 - variable the same thing
15:03 - they were likely to run into trouble
15:06 - pollution in the global name space
15:09 - and globally scoped variables are
15:12 - just well they're just really easy to
15:14 - break or to
15:15 - forget that they even exist
15:18 - and secondly because they're exposed
15:21 - they're not secure so it's not just
15:23 - co-workers who might innocently bump
15:24 - into each other in the global namespace
15:27 - dance floor
15:29 - third-party scripts and malicious code
15:31 - might join in the fun and
15:33 - global variables are a vulnerability
15:35 - that we generally want to avoid
15:37 - especially if we're yahoo and we're the
15:39 - big guns in the game in the mid 2000s
15:42 - so the ue team actually went as far as
15:44 - to say that an objective measure of the
15:48 - quality of a javascript program is
15:50 - how many global variables and global
15:52 - functions does it have
15:55 - a large number is bad because the chance
15:57 - of bad interactions with other
16:00 - programs goes up
16:04 - and a few other issues were cropping up
16:05 - in this era in this pre-module era
16:08 - whenever you wanted to reuse code you'd
16:10 - likely be doing some kind of copy-paste
16:12 - job and then following the trail of
16:14 - breadcrumbs wherever it led you and
16:17 - anytime you tried to update your code it
16:18 - would likely be a logistical nightmare
16:20 - as you tried to find all the pieces the
16:22 - places where you needed to update it
16:24 - dependencies were a hassle to manage
16:26 - especially if you were dealing with
16:28 - version control you had to worry about
16:30 - putting your script tags all in the
16:31 - right order
16:33 - and
16:34 - basically as code bases were getting
16:35 - more complex
16:38 - we needed a way to manage them better
16:42 - so let us set foot into the next era
16:47 - do-it-yourself modules and in the second
16:51 - phase of javascript history
16:53 - not all of the problems from the
16:55 - pre-module era were going to go away
16:58 - right off the bat
16:59 - but we'll start to see some of them
17:01 - being addressed particularly the problem
17:03 - of global variables because that was an
17:05 - immediate concern
17:07 - so this insight about needing to limit
17:10 - global variables actually spurred a ton
17:12 - of innovation um with
17:14 - an improvisation really with what was
17:16 - possible within the constraints and
17:19 - flexibilities
17:20 - of the javascript language
17:22 - and this was really an era of
17:24 - transformation for the web
17:26 - we're really moving away from the
17:28 - geocities model of static websites we're
17:30 - moving toward more interactivity and
17:33 - ajax requests were becoming more of a
17:35 - norm during this period
17:37 - jquery hit the scene during this time
17:38 - and the web was really starting to grow
17:41 - up a little bit from websites to web
17:44 - apps
17:45 - and so let's just keep that in mind as
17:47 - we start to look at some of the ways
17:49 - that people addressed
17:50 - the shortcomings of living in a world
17:53 - without modules
17:57 - we'll pick up the story where we left
17:59 - off with our friends at yahoo who had
18:01 - just declared that global variables are
18:04 - evil
18:05 - and their answer to this problem of
18:08 - global variables was actually just to
18:10 - restrict them let's let's stick with a
18:11 - single object
18:13 - with god-like status the yahoo object
18:16 - and the aim of the yahoo global object
18:18 - was
18:19 - literally to contain all of yahoo
18:23 - their state their and all of their
18:25 - webstate and being in all caps you can
18:27 - tell that it was
18:28 - very important it was the global
18:31 - so
18:32 - if you wanted to do anything you would
18:34 - say
18:36 - yahoo.util.dom.get or whatever it might
18:38 - have been you were somehow crawling
18:40 - through this object tree to find
18:43 - find what you wanted
18:45 - and
18:46 - jquery might be a more familiar example
18:48 - you might remember having to have the
18:50 - jquery object
18:52 - in available in globe global
18:56 - but as
18:58 - as much as this
19:00 - approach was touted as great practice
19:02 - there were definitely downsides to it
19:03 - too so
19:05 - it was still relying on a global
19:07 - variable a single one that could have
19:09 - been rewritten with a single line of
19:11 - code and then poof
19:12 - potentially everything could be gone
19:15 - there was still no code reusability
19:17 - and really no help with dependency
19:19 - management or versioning
19:22 - but you were starting to mitigate some
19:24 - of the risks of just having
19:26 - free range global variables
19:30 - so the basic structure of the namespace
19:33 - approach looks kind of like this
19:36 - we've got an object literal here and
19:38 - we've got some properties on it some
19:39 - data
19:40 - and some functionality
19:42 - and um
19:44 - we can assign those additional
19:46 - properties
19:47 - additional data
19:48 - um
19:50 - while we're declaring that namespace
19:53 - object or after the fact
19:55 - with our handy dandy dot notation
20:00 - and
20:02 - let's look at another approach that
20:04 - started coming up in this area era and
20:06 - that's the module pattern
20:08 - and the essence of the module pattern
20:10 - is
20:11 - being able to use
20:13 - an immediately invoked function
20:15 - expression
20:17 - with the power of closure so
20:20 - the power of closure is that it would
20:22 - shield private variables from being
20:24 - accessed outside of that function scope
20:27 - and as most of you know closure is what
20:30 - allows us to have access to the variable
20:32 - variable environment a function of a
20:34 - function
20:36 - even after we've exited its scope so
20:39 - you'll continue to see this pattern as
20:41 - we move along that function
20:43 - scoping is how we're going to start to
20:45 - get these boundaries and start to
20:48 - collect our variables in places where we
20:51 - can kind of protect them and not have
20:53 - them hanging loose
20:55 - everywhere
20:57 - control yourself javascript
20:59 - so
21:01 - here's a rather simple example
21:04 - of the module pattern in practice
21:08 - so this
21:09 - my do-it-yourself module we're assigning
21:12 - to it the return value of this
21:15 - iffy
21:16 - and
21:17 - in that iffy we've got in our closure
21:20 - scope some private variables and then
21:22 - we've got our exposed functions that are
21:24 - returned via an object with the
21:27 - increment and print properties
21:30 - and so as one might expect
21:33 - you can call the print
21:35 - function and find out what your counter
21:37 - variable's
21:38 - value is at any point you can call the
21:41 - increment function increment your
21:43 - counter
21:44 - if you printed it again its value is one
21:46 - but you cannot access that counter
21:48 - directly that is the important thing
21:50 - thanks to
21:51 - our
21:52 - function scoping it is
21:55 - it has lived it is gone you can't touch
21:58 - it
22:01 - and here's another popular
22:04 - implementation from back in the day
22:07 - also the module pattern just a flavor of
22:10 - it called the revealing module pattern
22:12 - which is almost exactly the same
22:14 - but in this case both our
22:16 - public and private variables are
22:18 - declared outside of the return statement
22:21 - so pretty much everything all of our
22:23 - variables are being defined in closure
22:25 - scope
22:27 - and
22:28 - we're selectively revealing what we want
22:31 - to
22:32 - and i my understanding is that this
22:35 - revealing module pattern was mostly just
22:38 - readable it was easy to use it was easy
22:40 - to work with
22:41 - you could
22:43 - work mainly within that returned object
22:46 - and decide what you wanted to have and
22:47 - what you didn't want to have included
22:50 - you didn't have to use
22:51 - this keyboard as much when you well oh
22:54 - at all really you could simply refer to
22:57 - variables by
22:58 - name
23:00 - potential disadvantages of this approach
23:03 - this was actually considered
23:05 - by people who were thinking about it one
23:07 - of the most fragile ways of actually
23:10 - implementing the module pattern
23:12 - you might imagine that if you had some
23:14 - public variable that you were trying to
23:17 - change
23:18 - say you were trying to reassign it
23:20 - after having declared it
23:23 - and
23:24 - suppose you also had a private variable
23:26 - in here which somehow used or depended
23:29 - on that public variable
23:31 - well
23:32 - you might have a little bit of trouble
23:33 - and not get what you expect because
23:36 - because these variables are defined
23:39 - in this function scope
23:42 - what's
23:43 - accessible to those private variables
23:45 - into private methods is the closure
23:48 - functionality is what was in this
23:51 - function scope at the time
23:54 - at the time
23:55 - this
23:56 - iffy was invoked and so you might
23:59 - basically this is just to say that you
24:00 - might get some unexpected
24:02 - results it wasn't
24:06 - wasn't the best of the module pattern
24:08 - but
24:10 - it was out there quite a bit in the wild
24:13 - and just so we're clear namespace
24:16 - namespaces and the module pattern are
24:18 - not mutually exclusive approaches they
24:20 - often
24:21 - did go hand in hand which is something
24:23 - the late doug crockford advised um so
24:26 - here we've got a variation of the module
24:29 - pattern that takes a namespace object as
24:32 - a parameter
24:34 - you can also sometimes find this out
24:36 - there with the dot call function and
24:39 - you're using the dot call function and
24:41 - passing in the
24:43 - namespace object and then you just use
24:45 - this keyword instead of having that
24:47 - namespace in there as a function
24:49 - parameter
24:51 - but anyway
24:52 - same kind of idea we pass in the
24:54 - namespace add some data and
24:56 - functionality to the namespace but we've
24:58 - got privacy we've got that privacy that
25:01 - that immediately invoked function scope
25:04 - provides us
25:06 - nice closure so javascript is kind of
25:08 - cool
25:10 - okay so that's a wrap on our quick
25:14 - blazing
25:16 - tour through the early module era
25:19 - and as you can see the tools within
25:20 - javascript did take us a long way
25:23 - towards solving
25:24 - the global namespace pollution problem
25:26 - but we still feel like it's
25:29 - we still weren't where we wanted to be
25:31 - iffy still felt a little like a hack job
25:34 - um
25:35 - we were still dealing with this
25:38 - giant global god object
25:40 - and we still had some problems that
25:42 - remained we never got to the point that
25:44 - we were able to actually swap modules
25:46 - with one another module sharing was not
25:49 - made any easier by this
25:52 - so
25:53 - and related to that the copy paste
25:55 - problem with reusing functionality um
25:58 - so even with a module pattern we didn't
26:01 - really get what we mean when we say
26:04 - modularity we didn't get all of those
26:05 - benefits that we wanted
26:07 - so that brings us to the next phase
26:12 - specification
26:15 - so
26:16 - what's getting specified here
26:18 - is a format a format that modules should
26:21 - take so we can consistently know and
26:24 - reliably know
26:25 - how we're going to load them
26:28 - and send them out into the world
26:31 - and as in the last era we start with a
26:34 - manifesto
26:36 - around 2009 or 2010
26:38 - people were feeling
26:40 - too
26:41 - strong emotions
26:43 - about javascript
26:46 - on one hand people were very excited
26:48 - about javascript's potential as a
26:50 - language and folks who were especially
26:52 - working on the server side were excited
26:54 - to see
26:55 - that javascript could be used on the on
26:57 - the server side
26:59 - so great excitement on one hand great
27:02 - frustration on the other
27:04 - frustration about the limitations of the
27:06 - language and all the things we wanted to
27:08 - do with it but remember little baby
27:10 - javascript coming from mr brendan ike's
27:13 - womb wasn't really built for any of the
27:16 - things any of these expectations that
27:18 - were piling onto javascript
27:21 - so kevin dengue
27:23 - another name that i may be butchering
27:26 - my respects to him
27:28 - wrote a blog post in january of 2009
27:31 - that was called
27:33 - what server-side javascript needs and he
27:36 - outlined a proposal that included among
27:38 - other things
27:40 - a model system
27:42 - so there are some other things that he
27:43 - proposed and many of them we actually
27:45 - know and love today so he talked about
27:47 - having a package system for deploying
27:49 - and distributing modules he talked about
27:52 - having some kind of package repository
27:54 - for finding and installing these
27:56 - distributed modules
27:58 - and none of this existed at the time
27:59 - this was all kind of a pipe dream like
28:01 - wouldn't it be nice wouldn't it be nice
28:04 - if we as a javascript community had
28:06 - these resources available to us
28:09 - he talked about cross interpreter
28:11 - standard libraries also being important
28:13 - so apis that could be used across
28:15 - different browsers like date and math
28:17 - already were at that time
28:19 - so he said you know wouldn't it be great
28:21 - if we had an api for the file system
28:23 - that was consistent across browsers
28:26 - anyway
28:28 - the bottom line is that
28:31 - dengue felt that what he was describing
28:33 - was not actually a technical problem it
28:36 - was an organizational problem it was
28:38 - about finding consensus among the
28:41 - javascript community
28:42 - bringing people together so they could
28:44 - make a decision and step forward and
28:46 - start building something bigger
28:48 - something better together
28:50 - so like adopting some a common currency
28:52 - or a common language
28:55 - his blog post
28:56 - which you're welcome to check out
28:58 - ultimately led to the formation of a
29:01 - grassroots group of
29:03 - similarly fed up developers who called
29:05 - themselves eventually or
29:08 - common js
29:10 - and they decided that they would start
29:11 - setting some standards for javascript
29:13 - including standardizing module loading
29:17 - so
29:20 - not too long after that node came out
29:22 - just a few months later so this was may
29:24 - 2009
29:25 - dangoor wrote his blog post in january
29:28 - and they created a module implementation
29:30 - which has since
29:32 - taken the name common js but it's
29:34 - distinct from that original group um as
29:36 - we'll see that original group
29:38 - didn't end up meeting all of their goals
29:41 - they kind of created some things that
29:42 - they didn't
29:43 - mean to
29:45 - but um anyway node had a number of
29:47 - competitors at the time that were also
29:49 - in the business of creating server-side
29:50 - environments for javascript but node one
29:53 - and the cjs the common js specification
29:57 - name stuck with that the node
29:59 - implementation so that's what we think
30:01 - of when we say commons as today we're
30:03 - talking about nodes implementation
30:06 - of modules
30:08 - and
30:09 - the common js spec stipulates support
30:11 - for module loading via a require method
30:15 - and assigning exports to this property
30:18 - on the module object called
30:21 - module.exports
30:24 - and this was really designed with server
30:27 - development
30:28 - in mind
30:29 - that will become important in a few
30:31 - minutes
30:33 - you might be working
30:35 - in node already but if you're not
30:38 - and if you're not hanging out in cjs
30:40 - regularly
30:42 - we'll have a quick look at the syntax
30:45 - we've got an awesome.js file here
30:48 - and
30:50 - we are attaching we are exporting
30:53 - as
30:54 - its module interface
30:56 - this awesome person function
30:59 - that says so and so is awesome
31:02 - i wish i had people affirming me like
31:04 - that all the time
31:06 - and
31:07 - in some other file we are using that
31:09 - wonderful require method
31:11 - to bring in
31:13 - that awesome person functionality
31:16 - and
31:18 - that required method is going to have
31:21 - you load a module and now you can have
31:23 - dependencies
31:28 - the require function is actually really
31:30 - powerful
31:31 - it is
31:32 - something that will block node's thread
31:35 - of execution
31:37 - module loading in node is synchronous
31:40 - not a big deal actually because on the
31:42 - server side you're working typically
31:44 - with file systems and your files are
31:46 - there already it's not a huge tax or a
31:48 - huge cost to be dealing with
31:51 - with synchronous module loading in node
31:54 - but i'll walk through a few fun pointers
31:57 - related to the
31:59 - require method one thing that i learned
32:01 - actually this year while working on that
32:03 - react
32:04 - project was that
32:06 - node actually caches
32:08 - its modules and it looks in the cache
32:10 - first to see if the module has already
32:12 - been created as a module instance
32:16 - and
32:17 - so the fun report repercussions of that
32:19 - are that you could potentially modify
32:22 - that module after caching it and then
32:25 - when you're working with that same
32:26 - module again it might have some
32:29 - additional
32:31 - properties that you might have assigned
32:32 - to it it may have
32:34 - it
32:35 - it can change or evolve and
32:38 - have
32:38 - all of those properties that you you
32:40 - give it
32:42 - and then this
32:44 - module dot underscore load function
32:46 - that's kind of under the hood of the
32:48 - require method
32:49 - then calls this module
32:51 - dot underscore compile function and
32:54 - that's where the magic happens
32:57 - this method creates a special require
33:00 - function actually it's specific to every
33:02 - module instance that's being created
33:05 - and it generates a wrapper function so
33:08 - remember just like with the module
33:09 - pattern where we had to scope
33:13 - things scope the contents that we wanted
33:16 - sort of protected in a module um within
33:19 - a function so that we could have that
33:21 - little pile of
33:22 - data and functionality and properly
33:24 - scoped variables
33:25 - same trick here a little more
33:27 - sophisticated but we're still using
33:29 - function scopes
33:30 - and then it actually runs that wrapper
33:32 - function on the spot
33:33 - and i think i want to highlight here
33:35 - that all of this kind of happens at once
33:38 - you
33:39 - start wherever your entry is into your
33:42 - you start wherever
33:44 - with whatever file you're entering into
33:46 - you hit your require statement
33:49 - node goes off to another file does its
33:51 - thing doesn't move on until it comes
33:53 - back and finishes
33:55 - its trail of dependency
33:58 - unwinding
34:00 - so
34:02 - anyway
34:03 - so
34:04 - in case you're curious here's what the
34:05 - wrapper function
34:07 - roughly looks like i just grabbed this
34:08 - from the node docs in github they've got
34:11 - a nice
34:12 - a nice little readme type page on
34:14 - modules
34:16 - and
34:17 - yeah kind of made this point already but
34:19 - function scoping is a powerful tool in
34:20 - javascript
34:21 - nothing outlives the
34:24 - execution of that wrapper function
34:26 - except what's actually exported from
34:28 - that module
34:29 - and that's
34:31 - i think i say that yeah
34:33 - so that function will
34:35 - that wrapper function will assign
34:37 - whatever is being exported to that file
34:39 - to the module.exports and off you go you
34:41 - have whatever you wanted that was
34:43 - exported from that file
34:45 - file name and dur name are just
34:46 - convenience variables so you don't have
34:48 - to type out the whole path and directory
34:51 - it's nice that node did that for us
34:55 - so there are of course options for using
34:57 - the commonjs module format on the
34:59 - browser many of us are again doing some
35:02 - kind of translation
35:04 - to whatever newfangled javascript code
35:06 - we're using so that we have
35:08 - continued compatibility
35:11 - anyway so cjs
35:13 - wanders beyond the server every now and
35:15 - again if we wanted to we can use those
35:17 - required methods if we want to
35:22 - so uh
35:23 - remember our friends at common js
35:26 - like the the group of
35:28 - fed up developers not the not the
35:30 - specification
35:32 - um so in a strange plot twist even
35:34 - though they were really talking about
35:35 - javascript for the server side
35:37 - they didn't succeed in offering any kind
35:40 - of usable spec for the server side but
35:42 - they did create one for the client
35:43 - called
35:45 - asynchronous module definition or amd
35:49 - quick look at the syntax there
35:52 - this define method
35:55 - takes as its
35:56 - first
35:58 - parameter this array
36:00 - of dependencies and then it has this
36:03 - function that it's going to
36:05 - fire off once those dependencies have
36:07 - been loaded
36:08 - true to its method it is asynchronous it
36:11 - is better suited
36:12 - to the browser
36:13 - and
36:14 - require.js is one of the more popular
36:17 - libraries folks are using with amd
36:20 - and then umd
36:22 - the universal module definition
36:25 - which i heard a developer or i read that
36:28 - a developer was joking that when you try
36:29 - to please everybody
36:31 - no one leaves happy
36:33 - so this was an attempt to support both
36:35 - the cjspec and the amd spec and
36:40 - with this hulk of
36:43 - boilerplate
36:45 - um as you might imagine it never really
36:47 - caught on no one wants to do that
36:50 - no one wants to do that so
36:52 - so um
36:55 - rest in peace umd i'm sure there are
36:57 - people or i'm sure there are some code
36:59 - bases that are using it
37:01 - anyway
37:02 - so we may say that specifications really
37:05 - flourished in the early part of this
37:07 - decade but
37:09 - while they were a wonderful thing and
37:10 - while there was a lot of innovation and
37:12 - a lot of effort to come up with
37:14 - specifications that we all use
37:17 - it is possible to have too much
37:20 - of a good thing
37:21 - um
37:22 - czech glow wacky
37:25 - man all these names are hard um
37:27 - he was a member of ember's core team and
37:29 - he wrote in 2014 that unless all
37:32 - dependencies use the same module format
37:36 - dependency tree of depth greater than
37:38 - one is so painful nobody does it
37:40 - nobody agrees on a solution to this
37:42 - problem we are all
37:45 - so anyway
37:47 - specification hell
37:52 - and finally
37:55 - that brings us to the last part of our
37:56 - tour where are we now
38:01 - well
38:02 - i really wish i could tie up this
38:04 - presentation in a nice bow but the fact
38:06 - is that we're still kind of in the
38:07 - awkward teenager phase of javascript
38:10 - really
38:11 - finding its adulthood and finding
38:14 - it its way of living up to the
38:16 - expectations we've put on it
38:20 - we've seen a lot of far from ideal
38:22 - solutions but
38:24 - we finally do have a built-in module
38:26 - system and that's a huge leap forward in
38:30 - the development of a language that was
38:31 - never supposed to come this far
38:34 - so
38:35 - think about where we started
38:38 - um
38:39 - es modules actually are supported by all
38:42 - major browsers as of this year i think
38:46 - it was last month actually that firefox
38:50 - just released their es modules
38:53 - compatible version
38:55 - and there's a lot of talk about how es
38:57 - modules are asynchronous that's not
38:59 - exactly right
39:01 - really depends on the loader
39:03 - we'll we can talk a little bit about
39:05 - that but i think that's probably beyond
39:07 - the scope of what we can talk about
39:09 - tonight
39:10 - but other cool cool things include
39:13 - support for cyclic dependencies so those
39:15 - are dependencies that either
39:17 - depend on each other directly or
39:20 - with a few degrees of separation in
39:22 - between
39:23 - um
39:24 - not going to go too
39:26 - deep under the hood with es modules
39:27 - today
39:28 - but
39:30 - let's at least look at this beautiful
39:32 - and consistent and concise syntax that
39:36 - it offers us
39:37 - we've got
39:39 - two export types
39:40 - on the left we can have default exports
39:44 - some of this may be review for those of
39:46 - you who are doing this on a daily basis
39:48 - we can have
39:49 - named exports so here
39:52 - i've got a default export coming from a
39:54 - message.js file i've got
39:57 - three little
39:58 - trivial arithmetic functions that are
40:00 - coming from a library.js file
40:03 - and then
40:05 - their corresponding import method so we
40:08 - can import whatever we
40:11 - exported as a default export using the
40:13 - import
40:14 - statement like so
40:16 - with the word from
40:18 - when we're dealing with a
40:21 - file that
40:22 - has multiple name to exports then we
40:24 - have the option of importing all of them
40:27 - we can even name
40:29 - give a name to the containing object so
40:32 - importing all of these little functions
40:34 - is
40:35 - live or i guess i could have called it
40:36 - arithmetic or something from
40:38 - lib.js
40:40 - we can selectively decide
40:43 - which
40:45 - parts of the interface that we want to
40:46 - bring in
40:47 - using i guess this is kind of it's not
40:50 - exactly i guess that's kind of objective
40:53 - destructuring
40:55 - yeah i would call that objective
40:56 - destruction
40:58 - cool
41:00 - and in the browser
41:02 - we
41:03 - still have our trusty old script tag
41:05 - that has survived many years of
41:07 - javascript
41:08 - but now we have a new special attribute
41:11 - called
41:12 - type
41:13 - that we can
41:14 - call type and we can assign it
41:17 - module to let the browser know this is
41:19 - not regular javascript that you're going
41:21 - to be parsing you're going to be looking
41:24 - at
41:24 - a module file and that has to be handled
41:26 - differently
41:28 - so javascript can begin its
41:31 - process of
41:32 - module loading build building out a
41:34 - dependency tree and all of that
41:37 - we also have a fallback for older
41:39 - browsers
41:40 - so when you have the no module attribute
41:44 - this is going to be ignored by those
41:46 - modern browsers that are using
41:49 - modules natively the no module attribute
41:52 - says
41:54 - ignore me to those browsers but if you
41:56 - are not in one of those browsers if
41:58 - you're in an older browser you've got
42:00 - your trusty bundled regular javascript
42:03 - file in all of its global variable glory
42:11 - one of the conflicts one of the current
42:13 - issues in javascript is that
42:17 - while most browsers are up to speed with
42:19 - es modules node is not and
42:22 - you might be asking yourself why
42:24 - node and es modules can't just get along
42:27 - well
42:28 - the implementation actually is pending i
42:30 - was able to play around with it a little
42:32 - bit
42:33 - and just make sure you have the most
42:35 - current version of node and just use the
42:38 - i think it's called experimental modules
42:40 - flag or something experimental something
42:42 - flag
42:43 - and you can absolutely play with them in
42:45 - node
42:47 - but really what's going on is that es
42:49 - modules and common js modules these are
42:53 - really different specifications
42:55 - so when i was talking about node earlier
42:57 - doing the synchronous loading and
42:59 - execution of
43:01 - um of those wrapper functions that it
43:03 - was creating with require that's a
43:05 - really different approach to modules
43:07 - than es modules it's just
43:10 - they they don't play nicely together
43:12 - they are two different concepts of
43:13 - modules so um
43:15 - one of the things that's caused a lot of
43:17 - contention is the dot mjs i think it's a
43:20 - modular javascript file extension which
43:23 - is
43:24 - basically to node what the type equals
43:27 - module attribute on the script tag was
43:29 - to the browser so this dot mjs file
43:31 - extension says to node hey you're about
43:34 - to parse
43:35 - um an es modules an es module file
43:38 - some people have called it the michael
43:40 - jackson script file extension
43:45 - anyway
43:49 - as i said i wish i could just wrap this
43:51 - up in a tidy bow but there are still a
43:53 - lot of questions about what the future
43:55 - is going to look like
43:56 - there's a lot of thought that es modules
43:58 - and http 2 will be very complementary to
44:01 - each other
44:02 - with the possibility of server push and
44:04 - being able to sort of chunk out bits of
44:07 - bits of code um
44:09 - quickly
44:10 - on demand
44:11 - and uh
44:13 - yeah i think we have yet to see what's
44:15 - to come and we're kind of in an exciting
44:17 - phase in the life the not so long life
44:20 - of javascript i think it must be in its
44:23 - i'm terrible at arithmetic it's a
44:26 - 23rd year
44:28 - it's going into its 23rd year
44:31 - just it's young adulthood and we all get
44:35 - to be a part of that and
44:38 - maybe at the end of that
44:40 - we will get to
44:41 - the promised land
44:43 - thank you
44:45 - [Applause]