00:00 - so in this series of tutorials we'll see
00:02 - how to build a reddit clone application
00:04 - using spring boot and angular we will be
00:07 - using spring boot spring mvc spring
00:09 - security with jwt authentication spring
00:12 - data jpa with mysql database to build
00:15 - this application
00:17 - so without wasting any time let's have a
00:18 - look at the application we are going to
00:20 - build
00:21 - just a small note you can find the link
00:23 - to the written tutorial of the series by
00:25 - clicking on the link in the description
00:26 - section where you can check out the
00:28 - complete source code of this application
00:30 - and there is also a written companion
00:32 - for each part inside the tutorial so you
00:34 - can go through it at your own pace
00:40 - as i said before we are building a
00:42 - reddit clone so reddit is of course a
00:44 - very popular website that needs no
00:45 - introduction
00:46 - and this is how our homepage looks like
00:49 - i have copied some of the css from
00:50 - reddit to provide a similar look and
00:52 - feel for our application
00:54 - we have our header section with the
00:56 - reddit icon on the left side and the
00:58 - login and sign up buttons on the right
01:00 - side we have our home page where you can
01:02 - see different links which are posted by
01:03 - the users
01:04 - each post has a voting section where you
01:06 - can either upload or download a post you
01:08 - can also see there is a comment section
01:10 - here which shows how many comments are
01:11 - there for each post
01:13 - you can click on read post button to see
01:15 - the post and
01:17 - comments for this post
01:19 - if you want to create a post you need to
01:20 - be logged in so first let me register
01:22 - quickly by clicking on sign up button
01:24 - and providing my details
01:27 - and once you click on register button
01:29 - you're navigated to the login page
01:31 - you can also see a nice roaster
01:32 - notification here on the top right side
01:35 - so after the user registration we have
01:37 - to activate the account before we log in
01:40 - for that we receive an email to which
01:42 - contains uh the activation link for the
01:45 - account in this application i'm actually
01:47 - using a fake smtp server called as
01:49 - mailtrap instead of a real world mail
01:51 - server so all the mails which we sent
01:53 - from our application are sent to this
01:55 - mail trap inbox
01:57 - you can see that we have already
01:58 - received an email with subject as please
02:00 - activate your account and here as i am
02:03 - using a free account we can only see the
02:05 - text version of this email even though
02:06 - we are sending an html template as the
02:09 - email body
02:10 - so let's copy this activation link
02:12 - inside this email and open this in the
02:14 - new tab and you can see that our account
02:16 - is activated successfully
02:19 - now we should be able to login let's go
02:20 - back to our login page
02:22 - type our credentials
02:24 - and click on login
02:27 - so now we are navigated to the home page
02:29 - so first let's create a subreddit and
02:31 - then create a post inside the subreddit
02:33 - i will click on create subreddit button
02:36 - give a title and description for the
02:37 - subreddit and click on post
02:40 - now let's create a post i will provide
02:43 - the title
02:52 - so you can see that we are navigated
02:53 - back to the home page and this time you
02:55 - can see the post we have just created it
02:57 - shows the time as just now
03:00 - now let's log in as a different user
03:08 - and in the home page
03:09 - i can upload or download this post we
03:11 - have just created before so uh let's
03:13 - upload this and you can see that the
03:15 - upward icon now turns to green and even
03:18 - if you reload the page it shows a visual
03:20 - indication that the user has uploaded
03:22 - this post the same thing applies also of
03:25 - course for the download of the post and
03:27 - the last thing is as you can see on the
03:29 - top right section we have our username
03:31 - if you click on that we see a menu and
03:34 - let's click on profile
03:36 - and in this page you can see all the
03:37 - posts and comments which are created by
03:39 - the user
03:41 - so that is how our application looks
03:42 - like and the next step would be to
03:44 - actually start coding i will be first
03:46 - developing the back end and then we will
03:47 - see how to develop the front end so to
03:49 - create the backend project the first
03:51 - thing you have to do is to go to
03:53 - start.spring.io website
03:55 - this is the place where you will
03:57 - generate our project with all the
03:58 - required dependencies
04:00 - for this project we will add spring web
04:02 - as we are using spring mec
04:05 - we will add a very useful library called
04:07 - as lombok this library helps us to
04:09 - generate the usual boilerplate code in
04:11 - java like getters setters constructors
04:15 - equals hash code methods etc
04:18 - and the next thing is we also need
04:20 - spring security spring data jpa
04:23 - mysql java driver
04:25 - and lastly we will also add java mail
04:27 - sender dependency
04:30 - once this is done you can click on
04:31 - generate and
04:33 - and the source code will be downloaded
04:35 - to your machine
04:37 - now let's unzip the project and open it
04:39 - in your favorite ide
04:41 - i will be using intellij for the rest of
04:43 - the back-end development for this
04:44 - project
04:45 - and for the front-end i will be using
04:47 - visual studio code so i open the project
04:49 - in intellij now the first step would be
04:51 - to create the domain entities for our
04:53 - application
04:54 - so let's expand this package structure
04:56 - and go to the root package
04:58 - and inside this package i already
05:00 - created two packages called as model and
05:02 - repository inside the model package we
05:05 - have all the domain entities we need for
05:07 - our application
05:08 - the first one is the post entity it
05:11 - contains a field post
05:13 - it contains a free post id which is
05:16 - annotated with id and generated value
05:18 - with a strategy of identity
05:20 - next we have a field name which has at
05:22 - not blank annotation so when we validate
05:25 - this entity before saving it to the
05:27 - database if at all the name field is
05:29 - either empty or null we will get a
05:31 - validation error with the message as
05:33 - post name cannot be empty or null
05:35 - next we have the field url which can be
05:37 - nullable
05:38 - followed by the description field which
05:40 - can also be nullable and is annotated
05:42 - with a lob annotation because we can
05:46 - have large chunk of text stored inside
05:48 - this
05:48 - description section we also have a vote
05:51 - count for the post followed by a
05:52 - reference to the user of the post
05:55 - we have many to one relationship here
05:57 - and a join
05:59 - and lastly we are storing the time at
06:01 - which the post is created through the
06:03 - created date field and this field is of
06:05 - type instant
06:07 - and also we have a reference to the
06:09 - subreddit entity with a many-to-one
06:10 - relationship and a join one thing you
06:12 - may have observed here is we don't have
06:14 - the usual boilerplate code for this
06:16 - entity like the getters setters and
06:18 - constructors because these are generated
06:20 - automatically at compile time using the
06:23 - library called as lombok
06:25 - the first annotation we are using here
06:26 - is at data annotation this is
06:28 - responsible to mainly generate the
06:30 - getters and setters for our class it
06:32 - also does some other things if you're
06:34 - interested you can check the
06:35 - documentation for this annotation
06:37 - and the next we have a gpa annotation
06:39 - entity followed by the all aux and works
06:42 - constructor annotation which generates
06:45 - the constructors for the class
06:47 - and we also have a builder annotation
06:48 - which will generate the builder methods
06:50 - for our class
06:51 - this annotation mainly uses the famous
06:53 - builder design pattern to create the
06:55 - objects for a class with data
06:57 - you can check the link in the
06:58 - description to know more about this
07:00 - builder pattern
07:01 - before we go any further to enable
07:03 - lombok in your ide you have to install
07:06 - lombok plugin
07:07 - you can do that by pressing ctrl shift a
07:10 - and typing plugins
07:12 - and inside the plugin window search for
07:14 - lombok and make sure you install this
07:15 - plugin and restart the ide
07:18 - after that
07:19 - press ctrl shift a again
07:21 - and type enable annotation processing
07:24 - just make sure that this checkbox is
07:26 - activated and click on ok
07:28 - by doing this intellij will detect the
07:29 - lombok annotation and generate the
07:31 - related code at compile time
07:34 - if you are using any other ide
07:36 - i have added a link in the description
07:38 - to the lombok website there you can find
07:41 - step by step instructions on how to
07:43 - enable lombok on your favorite ide the
07:45 - next entity is subreddit we have the
07:47 - usual fields here the id
07:49 - name
07:50 - description a reference to the list of
07:53 - post with one to many relationship
07:55 - the created date field
07:57 - and reference to users with many to one
07:59 - relationship
08:01 - the user entity has the user id name
08:04 - password
08:05 - email
08:06 - created date and enable fields
08:09 - so here the user is enabled after
08:11 - completing the email verification
08:12 - process
08:13 - which brings us to the verification
08:15 - token entity
08:16 - whenever a user is registered we
08:18 - generate a token we store it in the
08:20 - database through this entity and send
08:22 - this token as part of the activation
08:24 - link to the user whenever the user
08:26 - clicks on that link we look up the user
08:28 - associated with this token and enable
08:30 - that user
08:31 - we will discuss this functionality in
08:33 - detail in the next upcoming videos and
08:35 - next we have the vote entity which
08:36 - stores the votes by the user
08:38 - we distinguish whether a vote is either
08:40 - upward or downward using a needham
08:42 - called as vote type
08:44 - the cnam has two possible values upward
08:46 - and downward
08:47 - and of course we have references to the
08:49 - post and user entities and both of them
08:51 - has many to one relationship
08:53 - that leaves us with the last domain
08:54 - entity comment
08:56 - it has an id text a reference to the
08:58 - post and the user with the many to one
09:01 - relationships for both of them and a
09:02 - join
09:03 - and we have the time step at which the
09:05 - comment is created through the a date
09:07 - field of type instant so the next step
09:09 - would be to create repositories to store
09:11 - these entities inside the database
09:13 - i have already created the repository
09:15 - package and all the interfaces we need
09:17 - so let's go through them one by one
09:19 - first of all we have the post repository
09:21 - which is extending the jpa repository
09:24 - which is taking the post and the long as
09:27 - generic arguments post is of course our
09:30 - entity and long is the type of our
09:33 - primary key
09:34 - and this interface is annotated with at
09:37 - repository annotation
09:39 - next we have the subreddit repository
09:41 - which is also extending the jpi
09:42 - repositories and
09:44 - taking subreddit and long as generic
09:47 - arguments
09:49 - followed by the user repository
09:51 - and next we have a word repository
09:55 - and lastly we have the comment
09:56 - repository now let's configure the
09:58 - database in our project for that open
10:00 - the application.properties file inside
10:03 - the source main resources package and
10:05 - add the following properties the first
10:07 - one is a property for mysql driver class
10:09 - name we will use the driver class of the
10:12 - com mysql cjdbc package the next
10:15 - property is the data source url will
10:17 - provide the jdbc url of our database
10:19 - schema we will see how to create this
10:21 - shortly using mysql workbench next up we
10:23 - have our username and password of the
10:24 - database
10:26 - followed by the hibernate dialect
10:28 - property
10:29 - here as we are using mysql database
10:31 - version 8 we are providing the mysql5
10:33 - innodb dialect as the value for this
10:35 - property
10:36 - next up we have our ddl auto property
10:40 - i'm going with the value as update for
10:42 - now but if you are developing a
10:43 - production grade application you will
10:46 - give it a value of none and perform all
10:48 - your database changes through migration
10:50 - scripts using libraries like flyway or
10:52 - liquibase just take a note of this point
10:55 - and lastly we have the initialize and
10:57 - show sql properties as true now before
10:59 - we run our application we have to make
11:01 - sure that the schema already exists in
11:03 - your database here we have provided the
11:05 - schema name as spring reddit clone now
11:07 - let's open mysql workbench and once you
11:10 - are connected to the local database in
11:12 - the bottom left side corner of the
11:14 - screen you can find the schema section
11:16 - just right click over there and select
11:18 - create schema
11:19 - as i have already created the schema i
11:21 - won't be creating it again
11:23 - just make sure to add the schema name
11:25 - here and click on finish to create the
11:26 - schema and also make sure you put the
11:29 - same schema name inside the spring
11:30 - configuration pack inside the
11:33 - application.properties file
11:35 - now that should be it for the initial
11:36 - setup
11:37 - if you go back to intellij and go to the
11:39 - main class
11:41 - the spring reddit clone application
11:42 - class just click on the green arrow to
11:45 - the left side and click on debug
11:47 - this should start up the spring context
11:49 - and the tomcat server at port 8080
12:09 - so inside the root package let's create
12:11 - another package called less config
12:13 - and inside this package let's create a
12:15 - class called as security config
12:18 - this class as the name suggests holds
12:20 - the complete security configuration for
12:22 - our back end the first thing we are
12:24 - going to do is add the add enable web
12:27 - security annotation to this class this
12:30 - is the main annotation which enables the
12:31 - web security module in our project which
12:34 - we have added to this spring security
12:36 - starter dependency
12:38 - after that let's extend our class using
12:41 - web security configure adapter this is
12:44 - the base class for our security config
12:46 - class
12:46 - it provides us all the default security
12:49 - configurations which we can override and
12:51 - customize in our application
12:54 - to do that first we have to override the
12:56 - configure method which is coming in from
12:58 - the base class
12:59 - this configure method takes http
13:02 - security object as input and inside this
13:04 - method we will disable csrf protection
13:07 - for our backend
13:08 - we are disabling it because csrf attacks
13:11 - can mainly occur when there are sessions
13:13 - and when we are using cookies to
13:14 - authenticate the session information
13:17 - as rest apis are stateless by definition
13:20 - and as we are using json web tokens for
13:22 - authorization we can safely disable this
13:24 - feature
13:25 - next up we will allow all the incoming
13:28 - requests to our backend api whose
13:29 - endpoint url starts with slash api slash
13:32 - auth
13:33 - and we make sure that any other request
13:35 - which does not match this pattern should
13:37 - be authenticated
13:42 - so we are done with the security
13:44 - configuration for now let's create the
13:46 - endpoint to register our users
13:48 - i'm going to create a package called as
13:50 - controller
13:51 - and inside this package i'm going to
13:53 - create a class called as auth controller
13:55 - and i'm going to add rest controller
13:58 - annotation on top of this class
14:00 - followed by the request mapping
14:02 - annotation which takes the value slash
14:04 - api slash auth
14:07 - now let's create a post mapping inside
14:09 - the class with value as slash signup
14:16 - let's also create a method called as
14:18 - sign up
14:19 - and to this method we will be giving an
14:21 - input of type register request
14:24 - through this class we'll be transferring
14:26 - the user details like username password
14:28 - and email as part of the request body
14:31 - we call this kinds of class as a gto
14:34 - that means a data transfer object
14:36 - i am going to create this class and put
14:38 - it inside a package called as dto
14:44 - and to this class let's add our lombok
14:47 - annotations at data at all logs
14:50 - constructor and lastly nox constructor
14:52 - now let's declare the fields the first
14:54 - one would be username
14:56 - followed by email and lastly the
14:58 - password field
15:05 - now let's create a class called as auth
15:07 - service inside a new package
15:09 - called as service
15:11 - this all service class contains the main
15:13 - business logic to register the users
15:15 - that means creating the user object and
15:17 - saving it to the database
15:19 - and sending out activation emails etc
15:22 - i will create a method called as sign up
15:24 - inside the class which takes in the
15:26 - register request object as input and the
15:29 - first thing we have to do is to create
15:30 - an object for the user class
15:39 - and we will map the data we have from
15:41 - the register request object to the user
15:43 - object
15:44 - first one would be the username
15:48 - email
15:49 - and password fields
15:54 - the created field i will pass in the
15:56 - value as instant dot now this is the
15:58 - java 8 class to get current time and
16:01 - lastly by default we will disable the
16:03 - user so let's set the value for ease
16:06 - enabled as false and once the user is
16:09 - successfully
16:11 - validated we will set this value we will
16:13 - set the enable flag as true
16:16 - before saving the user object to the
16:17 - database we have to make sure that we
16:19 - encode the password storing the password
16:21 - in clear text is a very bad idea so
16:24 - imagine that if your database is
16:25 - compromised you have to make sure that
16:27 - it would be very hard for the hacker to
16:29 - actually crack the password
16:31 - that's why we encoded using different
16:32 - hashing algorithms which makes it very
16:34 - hard to decode the passwords one of the
16:36 - best hashing algorithms we can use in
16:38 - this scenario is the bcrypt hashing
16:40 - algorithm spring security provides us a
16:42 - class which implements this algorithm
16:44 - called as bcrypt password encoder now
16:46 - let's use this class to encode our
16:48 - passwords
16:49 - i will go back to security config class
16:52 - and here i will create a bean for the
16:54 - password encoder
16:55 - as the password encoder is an interface
16:58 - we have to create a bin manually inside
16:59 - the configuration class and whenever we
17:01 - are auto wiring this bean we will get an
17:03 - instance of type bcrypt password encoder
17:07 - now let's go back to our service and
17:09 - autobuy the password encoder
17:16 - now let's call the encode method of the
17:18 - password encoder before setting the
17:20 - password field for the user
17:22 - and that should be it spring will now
17:24 - take care of encoding the password now
17:26 - it's time to save our user inside the
17:28 - database for that let's first automate
17:30 - the user repository in our class
17:34 - and inside the signup method let's type
17:37 - user repository.save
17:39 - and pass the user object to the save
17:40 - method
17:42 - now it's time to do some refactoring for
17:43 - this class you can see that we are using
17:46 - auto wired annotation there is no there
17:48 - is actually nothing wrong with using
17:50 - auto wired annotation but it is not
17:52 - usually recommended to use it because we
17:55 - are using field injection here and
17:57 - spring recommends us to use constructor
17:59 - injection whenever possible so i will
18:01 - add a link to a very good article which
18:04 - explains why to use constructor
18:06 - injection over field injection but just
18:08 - make sure to check that link
18:10 - i will not explain it in detail in this
18:13 - video but
18:14 - so let's remove this ultraviolet
18:15 - annotation and declared our field as
18:18 - final
18:19 - and usually we have to create a
18:20 - constructor and set the variable for our
18:22 - fields
18:23 - and set the variable for our fields but
18:25 - all this is taken care by the h haulocks
18:27 - constructor let's add that to our class
18:30 - and lastly let's not forget to add the
18:32 - transactional annotation to this method
18:34 - as we are interacting with the
18:36 - relational database
18:37 - now let's enhance our registration
18:39 - process by sending out account
18:41 - activation emails
18:42 - for this the idea is to generate a
18:44 - verification token right after we save
18:46 - the user to the database and send that
18:48 - token as part of the verification email
18:51 - once the user is verified then we enable
18:54 - the user to log into our application by
18:56 - setting the enable field as true
18:59 - let's create a method called as generate
19:01 - verification token
19:02 - which takes user object as input
19:05 - and let's generate a random token here
19:07 - we can do that by typing uuid
19:10 - dot random uuid
19:12 - this will generate a unique and random
19:14 - 128 bit value which we can use as our
19:17 - verification token
19:19 - now it's just enough to send now it's
19:21 - just not enough to send this token
19:23 - through email and forget about it we
19:25 - also need to purchase this token in our
19:27 - database so if the user chose to verify
19:29 - the account after two or three days we
19:31 - may not have this in memory at the time
19:33 - so it's better to save this token in the
19:35 - database and whenever the user has
19:37 - verified the email here we will look up
19:39 - the token and then enable the user
19:41 - so i will create an object for
19:43 - verification token and pass in the user
19:45 - and token details
19:52 - now let's auto wire the verification
19:55 - token repository and save the token to
19:57 - the database
19:59 - and also we will just return this token
20:01 - back to our signup method
20:11 - right now it's time to send out the
20:12 - activation email for the users
20:15 - as first step we need to add some
20:16 - additional dependencies to our project
20:18 - if you want to send html emails from our
20:21 - application we will use a template
20:23 - engine called as time leaf which enables
20:25 - us to create html templates and use
20:27 - those templates to send the emails let's
20:30 - go to our pom.xml file and let me add
20:32 - the timely starter dependency
20:36 - now let's go to the source main
20:37 - resources folder and inside the template
20:39 - folder here we create a html file called
20:42 - as mailtemplate.html
20:45 - and inside this file i will paste this
20:46 - html code which contains a span tag and
20:50 - here a variable called message is
20:51 - injected through timeleaf's text tag
20:55 - back inside the service package let's
20:57 - create a class called as mail content
20:59 - builder
21:01 - this class contains a method called as
21:03 - build
21:04 - and this method takes the email message
21:06 - we want to send to the user as input
21:09 - and we set this email message inside the
21:11 - time leaves context object
21:14 - we are doing that by using the set
21:16 - variable method of context
21:18 - and lastly we will be passing the html
21:20 - file name and the context to the
21:22 - template engine through the template
21:24 - engines process method
21:27 - so at runtime timeline will
21:29 - automatically add the email message to
21:31 - our html template
21:33 - okay now it's time to send out email
21:35 - messages let's create another class
21:37 - inside the service package called as
21:39 - mail service
21:41 - let's add an annotation to this class
21:43 - the usual service and at all logs
21:45 - constructor annotation
21:48 - let's create a method called as send
21:49 - mail and this method takes the object of
21:52 - type notification email as input if you
21:55 - go inside the notification email class
21:57 - you can see that it encapsulates all the
21:59 - details we need for an email such as
22:01 - recipient subject and body of the email
22:05 - let's go back to send email method and i
22:07 - will quickly paste in some code here
22:09 - and now let me explain this
22:11 - so we are constructing an instance of
22:13 - type my message helper inside the lambda
22:16 - which creates an instance of type my
22:18 - message prepared my message preparator
22:22 - and to this my message helper we are
22:24 - passing in the data like the sender
22:26 - information we are hard coding it as
22:28 - springreddit.email.com
22:31 - this can be any fake email address you
22:33 - like
22:34 - but here as we are using a fake smtp
22:36 - server it doesn't matter if you want to
22:38 - use a real world smtp server like gmail
22:41 - or something else then you have to give
22:43 - a real email address here or else it
22:45 - won't work
22:46 - so moving on we have our set to set
22:48 - subject and set text methods we are just
22:51 - mapping these fields from notification
22:53 - email object
22:54 - but for the set text method we are
22:56 - calling the build method of mail content
22:59 - builder object
23:01 - so this method will return the message
23:03 - in the html format
23:05 - lastly we are using the send method of
23:07 - the java mail sender class and we are
23:09 - logging a message called as activation
23:11 - email sent but we have a compilation
23:14 - error here because we did not define
23:16 - this log variable anywhere for that we
23:18 - can use the slf 4j annotation from
23:21 - lombok which will create an instance of
23:24 - slf4j logger object and inject it into
23:27 - our class
23:30 - so we have this particular code wrapped
23:32 - inside the try catch block and inside
23:34 - the catch block we are throwing a new
23:36 - exception called as spring reddit
23:38 - exception with a message
23:40 - let's create this class and place it in
23:42 - another package called as exceptions
23:45 - this clash should extend the runtime
23:47 - exception class and inside the
23:49 - constructor we will call the super
23:51 - method
23:52 - and pass in the exception message
23:55 - so you may ask why are we doing this
23:57 - what is the purpose of doing this right
23:58 - so let's discuss about this briefly
24:01 - in our back end especially when we are
24:02 - building rest apis exceptions are pretty
24:05 - common in our code so whenever those
24:07 - exceptions occur we don't want to expose
24:09 - the technical information to the user
24:11 - for instance like illegal state
24:12 - exception null pointer exception or
24:15 - socket exception something like this we
24:17 - should ideally present this information
24:19 - in an understandable format we can do
24:21 - that by creating custom exception like
24:23 - this spring reddit exception and pass in
24:25 - our own exception messages
24:27 - you can either create multiple
24:29 - exceptions for each use case in our
24:30 - application or create one exception to
24:33 - your whole application and reuse them
24:35 - everywhere in your code
24:37 - alright so we have covered all the logic
24:39 - to send out the emails but one thing we
24:41 - still need to do is to configure the
24:43 - smtp server details in our application
24:46 - for that we are going to use a fake smtp
24:48 - server called as mailtrap you can use
24:50 - this service to test your code which
24:52 - sends out the emails first of all you
24:54 - can go to mailtrap.io and make sure to
24:57 - sign up for the service and after
24:59 - signing up you can get
25:03 - and after signing up you get your smtp
25:06 - server details inside the inbox these
25:08 - details look something like how you see
25:10 - on the screen you get a host of the mail
25:13 - server a port which we can use and a
25:15 - username and password so let's configure
25:18 - these details inside our
25:19 - application.properties
25:21 - so i am going to copy these properties
25:23 - here we have a spring mail host port
25:26 - username and password
25:28 - all these details you can get through
25:30 - the mailtrap service and lastly the
25:33 - protocol we're going to send emails
25:34 - would be smtp okay now we have
25:37 - configured our smtp server and created
25:40 - our mail service we still need to call
25:42 - our mail service from our sign up method
25:44 - let's do this
25:46 - back inside the odd service class let's
25:48 - inject the mail service class and write
25:50 - after this
25:53 - and right after the generate
25:54 - verification token method i am going to
25:56 - type mail service dot send
25:59 - and we are going to create an object of
26:01 - type notification email
26:03 - and to this
26:04 - email the and to this object the first
26:07 - argument would be the subject let's pass
26:09 - in a string please activate your account
26:12 - as the first argument the second
26:14 - argument would be the recipient for that
26:16 - we type user.getemail and the last one
26:20 - is the body of the email i'm going to
26:22 - paste in a string here this string
26:24 - contains a url which redirects the user
26:27 - to our server and to this we are going
26:29 - to append a verification token so
26:32 - whenever the user clicks on this url we
26:34 - take the token from the url parameter
26:37 - and look it up in our db
26:39 - fetch the user who created this token
26:41 - and enable that user that's how the flow
26:43 - would be
26:44 - so the remaining part here is we have to
26:46 - call this signup method from our auth
26:48 - controller let's do that back inside the
26:51 - controller i am going to inject the odd
26:53 - service class and call the signup method
26:57 - and so if the registration is successful
26:59 - we have to send a message to the client
27:01 - we can do that by just returning a
27:03 - response entity which takes a string as
27:06 - the first argument and will pass the
27:08 - string user registration successful
27:11 - and the second argument would be an enum
27:13 - value okay from http status enum
27:17 - okay we are ready to test okay now we
27:20 - are ready to test our registration flow
27:23 - let's start the server and go to postman
27:31 - so i am using a rest client called
27:33 - postman to make calls to our backend
27:35 - here
27:36 - i'm making a post call to our sign up
27:38 - endpoint with the user details in the
27:40 - body now let's click on send
27:43 - and we go to response brock and we got a
27:45 - response back from the server as user
27:47 - registration success
27:49 - the first thing is let's check the
27:51 - database and check if our user is really
27:53 - saved and the password is encoded or not
27:57 - so inside the mysql workbench you can
27:59 - see that we have our user test user 5
28:02 - and the password we have typed as
28:04 - password 5 in the initial request but
28:07 - you can see that the password is encoded
28:09 - inside the database
28:11 - now let's check if we got the email or
28:12 - not let's open our mail trap inbox as
28:16 - you can see we already got the email and
28:18 - you can see the activation link in the
28:20 - email
28:20 - if you copy this activation link and
28:22 - open it in the new tab
28:24 - nothing happens because we did not
28:25 - create the endpoint to activate the user
28:28 - let's do that now
28:34 - now inside the auth controller let's
28:36 - create an endpoint which contains get
28:38 - mapping with value as account
28:40 - verification followed by token which
28:43 - acts as a path variable now let's create
28:45 - a method which returns a response entity
28:47 - of type string
28:49 - with name as verify account
28:51 - and as we are passing the token as the
28:53 - parameter inside the url
28:56 - we have to add path variable annotation
28:58 - to grab the token
29:01 - and now inside the method let's call
29:03 - auth service
29:05 - and this time we call the method verify
29:07 - account and pass in the token to this
29:09 - method
29:11 - of course this method does not exist yet
29:13 - so let's also create it
29:18 - so here we have to query the
29:19 - verification token repository by token
29:22 - which we receive as input to the method
29:25 - so here let's type verification token
29:27 - repository dot find by token
29:32 - and pass the token as input
29:34 - of course this method definition does
29:36 - not exist in our repository so let's
29:38 - create it and this find by token method
29:40 - should return an optional of
29:42 - verification token entity so back inside
29:44 - the verify account method let's store
29:46 - this written type into a variable and as
29:49 - we are returning an optional here in
29:51 - case if the entity does not exist we can
29:53 - call the oral throw method and throw the
29:56 - custom exception with message as invalid
29:59 - token
30:01 - all right now we have to query the
30:02 - corresponding user who is associated
30:04 - with this token and enable that user for
30:07 - that let's create a method with name
30:09 - fetch user and enable which takes
30:11 - verification token as input and inside
30:14 - this method let's get the username by
30:16 - typing
30:17 - verificationtoken.getuser.getusername
30:21 - and store this written type inside a
30:22 - string variable called username
30:25 - now let's type userrepository.find by
30:28 - username and pass in the username as
30:30 - input
30:31 - let's also create this method inside the
30:33 - user repository and this returns an
30:35 - optional of type user now let's also
30:37 - call the oral store method and to this
30:39 - method let's pass in the supplier which
30:41 - throws our custom spring reddit
30:43 - exception with message as usual not
30:46 - found with name
30:51 - and we will append the username to the
30:53 - end
30:54 - so now let's store this result inside
30:56 - the variable user and let's enable this
30:58 - user by typing user dot set enabled as
31:01 - true
31:02 - lastly save the user inside the database
31:04 - and mark the method as transactional
31:08 - now let's go back to our auth controller
31:10 - and let's return a response entity back
31:12 - to the client by typing written new
31:15 - response entity let's pass in the first
31:18 - argument as message account activated
31:20 - successfully and the second argument
31:22 - would be http status dot ok
31:28 - ok now it's time to test the user
31:30 - verification let's start the server
31:32 - register with the new user and test the
31:34 - verification process
32:06 - okay so you can see that we received the
32:08 - response accounts activated successfully
32:10 - as expected now if you observe carefully
32:13 - an interesting thing is our api call to
32:15 - register users took more than 10 seconds
32:17 - to complete that means the user has to
32:19 - wait for 10 seconds after he clicked on
32:21 - the sign up button in the ui
32:23 - this is because we are sending a
32:24 - verification email after storing the
32:26 - user inside the database this kind of
32:28 - operations are very expensive and takes
32:31 - time to complete so as we are contacting
32:33 - an external mail server so of course
32:36 - there will be delay and this response
32:38 - will be slow what we should do in this
32:40 - case is to execute the code which sends
32:42 - the verification email asynchronously by
32:44 - running this part in a different thread
32:47 - if you're not aware of what is
32:48 - asynchronous processing i suggest you to
32:50 - google about it i will also provide a
32:51 - link in the description to know more
32:53 - about this
32:54 - but so fortunately in spring um running
32:56 - this piece of code asynchronously is not
32:58 - complicated
33:00 - spring framework provides us with
33:01 - asynchronous capabilities which we can
33:03 - use whenever we required to enable that
33:06 - we have to go to our application class
33:08 - and on top of the class just type at
33:11 - enable async
33:13 - this should already enable the
33:14 - synchronous processing through and now
33:16 - let's go to the piece of code which is
33:18 - responsible to send the email
33:20 - that would be the send email method
33:22 - inside the mail service class and on top
33:25 - of this method type at async
33:28 - so that is it now our code should run
33:30 - asynchronously and the response time for
33:32 - register users api call should be much
33:36 - faster
33:37 - so let's restart our server and test it
33:39 - again
33:51 - so as you can see the api call is taking
33:53 - very less time and looks far better than
33:55 - the previous response time this is the
33:57 - advantage with asynchronous processing
33:59 - anytime taking any time taking task can
34:02 - be executed asynchronously
34:04 - so
34:04 - these long running responses won't
34:06 - affect the user experience an
34:08 - alternative way to do this is to use
34:10 - message queues like active mq or
34:12 - rabbitmq
34:13 - but this these are too heavyweight for
34:16 - our use case right we don't have um
34:18 - we don't need to provide reliability to
34:20 - the emails but you want to put it we
34:23 - want to keep it simple so but if you are
34:26 - using this email sending functionality
34:28 - on a larger scale
34:29 - uh using this rabbit mq our active mq
34:32 - would be
34:33 - recommended
34:39 - so let's have a look at our
34:40 - authentication flow how would look like
34:43 - on the high level before we go and
34:45 - implement it
34:46 - so first of all we have a client who
34:48 - wants to login to our server
34:50 - the client makes a login request to the
34:52 - server by providing the credentials the
34:54 - server receives this information and
34:56 - validates the credentials
34:58 - and if they are matching it creates a
34:59 - json web token and sends this
35:01 - information back to the client
35:03 - the client uses this token to
35:04 - authenticate itself for all the
35:06 - consecutive requests it's going to make
35:08 - to the server
35:09 - so once the server receives a request
35:11 - with this token it first validates this
35:13 - token whether it's the same token which
35:15 - is generated by the server or not and
35:17 - after the successful validation it
35:19 - responds to the client with the required
35:21 - data
35:22 - before we dive in and start coding i
35:24 - would like to take a moment and explain
35:26 - you how the authentication mechanism
35:27 - works in spring security this is a high
35:30 - level uh overview because there are also
35:32 - lots of hidden uh functionalities and
35:34 - hidden components
35:36 - used in this uh in this uh in this
35:38 - authentication mechanism
35:39 - and because we are implementing in
35:41 - spring using spring security is not so
35:43 - straightforward if you are not clear
35:45 - what you are doing its very easy to get
35:47 - lost and confused
35:48 - okay here is the diagram which shows us
35:50 - the high level flow which is followed
35:52 - inside our project
35:53 - these are the main components we will be
35:55 - using to create our authentication
35:56 - mechanism the first thing is of course
35:59 - our auth service which we will receive
36:02 - which will receive the authentication
36:04 - request and inside this odd service we
36:06 - grab the username and password from the
36:08 - request and create a username password
36:11 - authentication token class
36:13 - we will pass this class to an
36:14 - authentication manager which takes care
36:17 - of all the authentication of its which
36:20 - takes of authenticating our users this
36:23 - authentication manager will use an
36:24 - interface called as user detailed
36:26 - service which can fetch the user details
36:29 - from multiple sources
36:31 - in our use case it would be database
36:33 - if the user details are incorrect we get
36:36 - an exception at this stage and if they
36:38 - are correct the user details are passed
36:40 - on to authentication manager which
36:42 - returns an authentication object back to
36:45 - the odd service
36:46 - so at this moment our authentication is
36:48 - successful
36:49 - so as you see in the previous diagram we
36:51 - will create a jwt
36:52 - and send it back to the user as a
36:54 - response
36:55 - so this is a bit in-depth explanation of
36:58 - the authentication flow i hope it is
36:59 - clear for you
37:01 - without any further delay let's start
37:02 - coding
37:04 - all right so the first thing we need to
37:06 - do is to update our security config
37:08 - class we have to create our
37:09 - authentication manager for that spring
37:12 - uses a class called last authentication
37:13 - manager builder
37:15 - so let's configure this
37:17 - for that let's create a method public
37:19 - void configure global
37:21 - and now let's inject the authentication
37:23 - manager builder to this method using
37:25 - method injection we can do that by
37:27 - adding authentication manager builder
37:28 - object as input and adding ultrawide
37:31 - annotation on top of this method
37:34 - inside this method now we can use the
37:35 - authentication manager builder and since
37:38 - for this object we have a method user
37:41 - details service
37:42 - this method takes input of type user
37:44 - details service though we have saw so we
37:47 - saw what this user detail service does
37:49 - in the previous in the previous diagram
37:52 - so it mainly loads the user data from
37:55 - different sources in our case it would
37:56 - be database and provides the user data
37:59 - to spring so as this is an interface we
38:01 - have to create an implementation class
38:03 - so let's create a class called as user
38:05 - details service impul
38:07 - which implements the user details
38:09 - service interface
38:21 - now inside this class let's override the
38:22 - load user by username method this method
38:25 - takes the username as input and returns
38:28 - the user details object let me quickly
38:30 - paste the logic we are going to use in
38:32 - this method
38:43 - so first of all we are acquiring the
38:45 - user repository to retrieve the user
38:47 - based on the username
38:49 - if the user does not exist we throw a
38:50 - username not found exception this is the
38:53 - exception which is provided by spring
38:55 - and with that user object we create
38:57 - another object which is like a wrapper
39:00 - with the same name user this clair this
39:02 - class is provided by spring framework
39:04 - which implements the user details
39:06 - interface
39:09 - and here we are just mapping the user
39:11 - details to this user class
39:13 - and lastly we are providing an authority
39:16 - called as simple granted authority for a
39:18 - role called user
39:20 - so now we have the core part of the user
39:22 - authentication let's create the logic
39:24 - where we receive the request from the
39:26 - client
39:26 - so for that let's open the auth
39:28 - controller class and here let's create a
39:31 - new endpoint with a post mapping with
39:33 - value as
39:34 - slash login
39:36 - let's create a method by the name of
39:38 - login and to this method we'll pass an
39:40 - object of type login request
39:42 - so this is the same dto
39:45 - this is a similar dto we used for
39:47 - register for a registration
39:49 - functionality called as register request
39:51 - and let's create this login request
39:53 - class and this class contains mainly two
39:56 - fields
39:57 - a username and a password
39:59 - and let's also add the necessary lombok
40:02 - annotations
40:03 - uh namely data
40:05 - all aux constructor and nox constructor
40:08 - now let's go back to earth controller
40:10 - and type odd service dot login and pass
40:13 - the login request object as input to
40:15 - this method
40:16 - let's create this method inside all
40:18 - service
40:19 - now what we need to do here is to
40:20 - implement the logic to authenticate the
40:22 - user
40:24 - as we saw in the diagram minutes ago the
40:26 - auth service contains the logic to
40:28 - create username password authentication
40:30 - token and use authentication manager to
40:33 - perform login
40:34 - to do that first we have to autowire
40:36 - authentication manager
40:38 - into the odd service class
40:40 - if you read the documentation for
40:42 - authentication manager we can observe
40:44 - that this is an interface
40:46 - and for an interface if we do not
40:48 - mention explicitly what kind of bin to
40:50 - create spring throws an exception
40:52 - because there are multiple
40:53 - implementations of authentication
40:55 - manager
40:57 - so we have to create a bean inside our
40:58 - security config which extends the web
41:01 - security configure adapter so let's do
41:04 - that
41:05 - so whenever we auto wire authentication
41:07 - manager spring finds this bean and
41:09 - injects it into our class
41:19 - now let us continue the implementation
41:21 - inside the earth service class let's
41:23 - type authentication manager dot
41:25 - authentication
41:27 - and here we are going to pass an object
41:29 - of type username password authentication
41:31 - token by typing new username password
41:34 - authentication token
41:36 - and passing the username and password
41:38 - from the login request object as the
41:40 - constructor arguments
41:50 - okay so let's go back to our diagram and
41:52 - see where we are
41:53 - we implemented the part where we create
41:55 - the username password authentication
41:57 - token
41:58 - we pass this token to authentication
42:00 - manager's authenticate method
42:02 - which in turn calls the user detail
42:04 - service
42:05 - we also implemented the logic to read
42:07 - the user from database and return the
42:09 - user details to the authentication
42:10 - manager
42:11 - so now this authentication manager
42:13 - verifies our credentials in the
42:15 - background and if they are matching it
42:17 - returns us an object called as
42:18 - authentication
42:20 - that means we have implemented the
42:21 - authentication functionality but not
42:23 - completely we still have to create json
42:26 - web tokens and send it as a response to
42:28 - the client
42:29 - so before we create the functionality to
42:31 - create json web tokens we have to add
42:34 - some even dependencies
42:36 - so open up the bom.xml file and make
42:38 - sure you add these three jwt
42:41 - dependencies
42:42 - the jjwt api jwt impel and jjwt jackson
42:49 - so now let's create a class with the
42:50 - name jwt provider
42:52 - i will create this class in a separate
42:54 - package called as security
42:56 - let's add the service annotations to
42:58 - this class and
42:59 - now let's create a method public string
43:02 - generate token
43:04 - and this method takes an object of type
43:06 - authentication as input
43:08 - and inside the method i will type
43:11 - dot get principle
43:13 - let's cast it to user object and store
43:16 - it in a variable called as principle
43:21 - now we have the user information we can
43:23 - create our jwt by using the following
43:25 - code
43:26 - so here we are using the jwts class to
43:29 - construct our jwt
43:31 - we set the user name as the subject for
43:33 - the json rib token and to sign the json
43:36 - web token we should provide a key which
43:38 - we will implement shortly once we
43:40 - provide the subject and sign the jwt
43:43 - we get the token retained in the form of
43:45 - a string
43:46 - and now coming to the key
43:48 - in this example we'll be using
43:50 - asymmetric encryption that means we'll
43:52 - be using a keystore to sign the json web
43:55 - token
43:57 - specifically the private key of the key
43:58 - store to sign our json with token
44:01 - i'll quickly copy the required code and
44:03 - we'll explain you how we can use private
44:05 - private key to sign the json with tokens
44:09 - all right now let's go through the code
44:11 - first we have a field called as keystore
44:13 - and we are initializing this field
44:14 - inside this post construct block
44:17 - which is goes inside a method named init
44:20 - we are providing a keystore instance of
44:22 - type jks to the field and in the next
44:25 - line we are getting the input stream
44:26 - from the keystore file with the name
44:29 - springblog.jks
44:31 - this is the keystore file i also used
44:33 - for my other tutorial series build a
44:35 - blog with spring boot and angular
44:38 - if you're interested you can also check
44:39 - out the series inside the description
44:41 - section
44:42 - so once we load the input stream from
44:44 - the keystore you have to provide the
44:46 - input stream to the load method of the
44:48 - keystore followed by the password of the
44:50 - keystore
44:51 - and after that we just have to read the
44:53 - private key from the key store and pass
44:56 - it to the jwts class to sign our json
44:58 - web token
44:59 - to read the private key should mainly
45:01 - provide the alias of the keystore
45:03 - followed by the password of the keystore
45:06 - and this particular code throws so many
45:07 - different exceptions so as a best
45:09 - factories we are wrapping all those
45:11 - exceptions and just throwing a custom
45:13 - runtime exception with an understandable
45:15 - and meaningful exception message
45:19 - now let's call the generate token method
45:21 - of our jwt provider class from inside
45:24 - the odd service
45:25 - before that we have to store the
45:26 - authentication object inside the
45:28 - security context
45:30 - we can do that by typing security
45:32 - context holder
45:34 - dot get context
45:36 - dot set authentication
45:38 - and to this method to enter this method
45:40 - called pass in the authenticate object
45:43 - so if you want to check if a user is
45:44 - logged in or not we can just look up the
45:47 - security context for the authenticate
45:49 - object for the authentication object and
45:51 - if we find the object then we can be
45:54 - sure that the user is logged in and if
45:56 - not the user is not logged in
45:58 - so now let's inject the jwt provider
46:00 - class inside the odd service
46:03 - and back inside the method we will call
46:05 - the generate token method of the jwt
46:07 - provider and of course this method
46:09 - returns a string which is our
46:11 - authentication token
46:13 - now we can send this back now we can
46:15 - send this token back to the user
46:24 - to send this token we will use a dto
46:27 - called as authentication response
46:29 - let's create this class inside the dto
46:31 - package
46:33 - this class contains the fields with name
46:35 - authentication token and username
46:38 - both are of type string
46:40 - so now inside the login method let's
46:42 - create an object for authentication
46:44 - response
46:45 - fill that object with our token and the
46:48 - username
46:49 - and then return it back to the
46:50 - controller
47:01 - and inside the controller let's add a
47:03 - written statement
47:05 - to our call to the login method of the
47:07 - auth service
47:09 - and change the written type of the
47:11 - method to authentication response so now
47:14 - it's time to test whether the login is
47:16 - working or not
47:17 - but before that make sure that you have
47:19 - this springblog.jks file inside the
47:22 - resources folder or else the jwt
47:25 - creation won't work
47:27 - so now let's start the server and make a
47:29 - login request using postman
47:36 - so i made the login request using the
47:38 - account i have created before and you
47:40 - can see that we received the token the
47:42 - authentication token and username as
47:44 - response back from the server
47:52 - in the last video we saw a sequence
47:54 - diagram which provides a high level
47:56 - overview of the authentication mechanism
47:59 - in this video we're going to dive deep
48:01 - onto the fifth point
48:03 - where we validate the json web token on
48:04 - the server so this is how the actual
48:07 - process looks like the client makes a
48:10 - request to the server
48:11 - the request is intercepted by a custom
48:14 - filter called as jwt authentication
48:16 - filter
48:17 - this filter will retrieve the access
48:19 - token and validates it if the validation
48:22 - is successful the request will be
48:23 - forwarded to the corresponding
48:24 - controller
48:26 - now let's go ahead and implement this
48:27 - functionality so first of all we are
48:29 - going to create a class called as jwt
48:31 - authentication filter inside the
48:33 - security package
48:35 - and this class extends the once per
48:37 - request filter class
48:39 - and
48:40 - we're going to overwrite some methods
48:42 - and inside the do filter internal method
48:45 - we will intercept the request and fetch
48:46 - the token from the request headers
48:49 - because the client sends the token to
48:50 - the server as part of the request
48:52 - headers by following the bearer scheme
48:55 - so inside the two filter internal method
48:58 - i will call a method called as get jwt
49:01 - from request and this method takes in
49:03 - the http servlet request as input
49:06 - so to get the token from this request
49:08 - object we have to get the authorization
49:10 - header from the request
49:12 - we can do that by typing
49:14 - request.getheader of authorization
49:18 - let's store this value inside a string
49:20 - called as bearer token
49:21 - and this token is now sent
49:24 - in the structure you see on the screen
49:27 - so it starts with the term bearer
49:28 - followed by a space and followed by the
49:31 - json group token
49:33 - to get the token we have to exclude the
49:34 - term bearer and just retrieve the term
49:37 - and just retrieve the token
49:39 - we can do that by using substring method
49:41 - of string class
49:43 - so here i am going to type
49:45 - bearertoken.substring of 7.
49:54 - so let us store the token inside a
49:55 - variable called as jwt and now let's go
49:58 - to the jwt provider class and create a
50:01 - method called as validate token
50:04 - this method takes in the jwt and as the
50:07 - name suggests it is responsible to
50:09 - validate the json web token
50:11 - if you remember in the last video we
50:13 - used asymmetric encryption to create our
50:15 - tokens by assigning them with the
50:17 - private key from our key store and now
50:19 - we will validate the token by using the
50:21 - public key
50:22 - we can do that by typing jwts
50:26 - dot parser
50:27 - dot set signing key
50:29 - and here we're going to pass in the
50:31 - public key
50:32 - for that let's create a method called as
50:34 - get public key
50:36 - and here i will quickly copy paste the
50:38 - implementation which is very similar to
50:40 - the get private key method
50:42 - implementation but here we are going to
50:44 - call the getcertificate method of the
50:46 - keystore so we will get the certificate
50:48 - which goes by the alias name of the
50:50 - keystore
50:51 - and then we call the method get public
50:54 - key which returns the actual public key
50:56 - from the keystore
50:58 - and of course as this piece of code
50:59 - throws some checked exceptions willing
51:02 - to catch them and read through them as a
51:03 - runtime exception
51:05 - and now back inside the validate token
51:07 - method
51:08 - i will call the parse claims jws method
51:11 - and pass in the json web token which we
51:14 - are receiving as input
51:16 - and if this particular piece of code is
51:18 - executed without any errors we can be
51:20 - sure that the json web token is
51:22 - validated so in the next step we are
51:24 - just going to return the boolean value
51:26 - true
51:28 - so now let's inject the jwt provider
51:30 - class inside the jwt authentication
51:32 - filter class and call the validate token
51:35 - method
51:39 - so now if we have a valid token we have
51:41 - to load the user from the database and
51:43 - set the user details in the spring
51:46 - securities security context
51:48 - to do that first we have to get the
51:50 - username from the token we can easily
51:52 - retrieve the username from the token
51:54 - because we are using it as a subject
51:56 - when creating the token
51:58 - i will go back to the jwt provider class
52:01 - and create a method called as get
52:03 - username from jwt which takes the token
52:06 - as input
52:08 - inside the method i'm going to get the
52:10 - body of the token which is nothing but
52:12 - the claims
52:13 - and from the claims object i can
52:15 - retrieve the subject by typing claims
52:18 - dot get subject
52:20 - so this is going to be a string
52:22 - let's return this value from the method
52:24 - and also let's change the written type
52:26 - of this method to string
52:28 - back inside the jwt authentication
52:30 - filter class
52:32 - let's call the get username from jwt
52:34 - method
52:35 - and now we have the username
52:37 - again i'm going to copy the code which
52:39 - retrieves the user from the database and
52:42 - sets the user details into the security
52:44 - context
52:45 - first we are constructing here
52:48 - so here first we are constructing an
52:50 - instance of type username password
52:52 - authentication token and then storing
52:54 - this inside the spring security context
52:56 - so now the last part is to call the
52:58 - filter chain if our token is valid
53:00 - spring is going to find the user details
53:02 - inside the security context and it will
53:05 - fulfill our request if not it will throw
53:07 - an exception which we will see at the
53:09 - end of the video okay so we implemented
53:11 - the validation part now to test this we
53:14 - don't have any secured apis so let's go
53:16 - ahead and create one api to create and
53:19 - read subreddits
53:21 - let's create a class called as subreddit
53:23 - controller and the first thing we have
53:25 - to do when we create a controller is to
53:27 - annotate the class as rest controller
53:30 - and for this api we're going to provide
53:32 - the request mapping as slash api
53:34 - subreddit
53:36 - let's also add the usual lombok
53:38 - annotations we are going to need
53:40 - and the first method we are going to
53:41 - implement is the create subreddit method
53:45 - this method will follow a post mapping
53:47 - and as the request body we will send the
53:49 - information in the form of a dto
53:52 - let's call this dto as a subreddit dto
53:55 - and let's also create this class
53:57 - so basically to create a subreddit the
53:59 - information we are going to need is just
54:01 - subreddit name and description but we
54:04 - are also going to read the subreddit
54:05 - information for that we need the id of
54:08 - the subreddit and lastly the number of
54:10 - posts which are inside the subreddit
54:13 - let's create all these fields inside the
54:15 - dto and provide all the required lombok
54:18 - annotations
54:32 - okay so we should always try to avoid to
54:34 - write business logic in our controllers
54:37 - the responsibility is to receive
54:39 - requests from the client and delegate
54:41 - them to the service layer
54:43 - so to implement the functionality we are
54:44 - going to need a service class let's
54:46 - create this class inside the service
54:48 - package with the name as subreddit
54:51 - service and inside this class let's
54:53 - create a method called as save
54:55 - which is responsible to create and save
54:57 - the subreddit information
54:59 - to create the subreddit first we have to
55:01 - map the information we need from dto to
55:04 - subreddit entity let's create a method
55:07 - to do this mappings which is called as
55:09 - map subreddit to dto
55:12 - inside this method we're going to use
55:14 - the builder pattern to construct our
55:15 - subreddit entity
55:17 - and we'll just return it back to our
55:19 - method we can also use some mapping
55:21 - libraries like mapstract to make our
55:23 - life easier
55:24 - i will introduce that library in the
55:26 - upcoming videos but for now let's
55:28 - concentrate on creating the api and test
55:30 - the token validation logic
55:33 - so we have our subreddit entity let's
55:35 - save this inside the repository for that
55:38 - we need to first inject the subreddit
55:40 - repository into a class and later just
55:42 - save the entity by typing subreddit
55:45 - repository.save
55:47 - after saving the entity we can set the
55:49 - id field inside our dto and return it
55:51 - back to the controller
56:01 - back inside the controller let's inject
56:03 - the subreddit service and call the save
56:05 - method
56:07 - let's store the written type and return
56:08 - it back to the client but we just won't
56:11 - return the subreddit detail we will wrap
56:13 - the dto using spring's response identity
56:15 - class in this way spring provides us
56:17 - some sensible default information as
56:20 - response to the client
56:21 - we will type response entity dot status
56:25 - as it is a post call and as we are
56:26 - creating a subreddit the appropriate
56:28 - written type for this kind of rest call
56:30 - is value 201
56:33 - in spring this value is represented by
56:35 - the enum created
56:37 - and lastly let's include the subreddit
56:39 - dto as the body of the response entity
56:42 - and written it back to the client
56:45 - now let's also quickly create an api to
56:47 - read the subreddits
56:49 - for that i will create a get all
56:50 - subreddit method
56:52 - which supports get mapping now let's
56:54 - create a method called as get all inside
56:56 - the subnet service
56:58 - and the most important annotation we
57:00 - forgot to add before
57:02 - is the at transactional annotation
57:08 - as we are using a relational database to
57:10 - guarantee consistency we need to add the
57:12 - annotations to all the methods which are
57:14 - going to interact with the database
57:16 - for the get all method we will add the
57:18 - transactional annotation with read-only
57:20 - flag as true
57:22 - so inside this method let's simply call
57:24 - the find all method of the subreddit
57:26 - repository and now we should do the
57:28 - mappings from subreddit entity to the
57:30 - subreddit dto
57:32 - let's create another method to perform
57:34 - these mappings
57:35 - and here let me quickly copy the
57:36 - necessary code as we are not doing
57:38 - anything complex apart from just some
57:40 - simple mappings
57:46 - once this is completed return the dto
57:48 - back to the controller and the
57:49 - controller will return this tool
57:52 - and the controller will return this dto
57:54 - with appropriate http status
58:09 - all right so we are coming to the end of
58:10 - the video
58:12 - before we go ahead and test our
58:13 - validation logic and apis we have to
58:16 - make sure that spring security knows
58:18 - about our jwt authentication filter
58:21 - class so let's go to the spring security
58:23 - config class and inside the configure
58:26 - method let's add this line of code
58:29 - which is http security dot add before
58:32 - and to this method we are passing the
58:34 - jwt authentication filter
58:36 - followed by the username password filter
58:39 - so now spring tries to first check for
58:41 - the access token the jwt token
58:44 - before trying the username password
58:46 - authentication scheme
58:48 - with that all the configuration part is
58:50 - completed so let's go ahead start our
58:53 - server and test our implementation
58:59 - so after starting the server open your
59:01 - favorite res client i'm using postman
59:04 - and here i've already prepared some
59:06 - requests to show you how it is working
59:09 - first of all i have made a login request
59:11 - with some credentials and i received a
59:13 - token as response
59:15 - so we are going to use this token inside
59:17 - the bearer scheme
59:19 - and make a request to create the
59:20 - subreddit
59:22 - as you can see the request was
59:23 - successfully completed
59:25 - and we received back the id of this
59:27 - update
59:28 - now let's try to read all the subreddits
59:31 - also for this i have prepared a request
59:33 - and here you can see all the subreddits
59:35 - i have in my database
59:38 - lastly let's test the negative case that
59:40 - means what happens if we try to send an
59:42 - invalid token to the server
59:45 - so let's go to the authorization tab and
59:47 - remove the last character from the token
59:49 - and send the request
59:51 - so as you can see we got back an error
59:53 - message from our server
59:55 - if we put back the correct access token
59:57 - and make the request again
59:59 - you should see all this updated
60:00 - information
60:08 - so let's have a look at what is
60:09 - mapstruct if you go to the mapstruck.org
60:11 - website you can see in the home page it
60:13 - is written that is a java library which
60:15 - generates the mapping code uh the
60:17 - mapping logic in our application that
60:19 - means if you have two two objects and
60:21 - you want to map the data between these
60:23 - two objects we can use mapstruct to
60:25 - generate the mapping code by just using
60:28 - some annotations
60:29 - if you scroll down you can see the
60:31 - section map struct in two minutes here
60:33 - we have an example where we have a car
60:35 - object and a car dto object so if you
60:38 - want to map the data between these two
60:40 - objects first usually what you will do
60:42 - is create a new car object and then use
60:45 - the setter methods to set the data for
60:47 - each field
60:49 - and imagine if you have like five or ten
60:51 - fields or more than ten fields in the
60:52 - pujo class then you have to write the
60:55 - mapping code manually so this will be
60:57 - pretty uh sometimes may be complex and
60:59 - also mainly it's pretty boring to write
61:01 - this kind of code so we can just
61:04 - ask abstract to generate this kind of
61:06 - code automatically by just writing the
61:08 - method definition which takes in the
61:10 - source object as input and we provide
61:12 - the target object type as the written
61:14 - type of the method and that's all we
61:16 - have to do mapstruck will then generate
61:18 - all the required mappings at compile
61:20 - time
61:20 - and so we will actually see how it
61:23 - generates the code and what kind of code
61:24 - it generates very soon but i hope you
61:26 - understand what is abstract so let's go
61:28 - ahead and install this library in our
61:30 - project okay so let's go to the
61:32 - documentation section in the home page
61:34 - and under the apache maven section you
61:36 - can see the the library details in the
61:39 - form.xml file so let's just copy these
61:42 - details into the corresponding section
61:44 - of our pom.xml file we need to copy the
61:47 - dependency and the plugin
61:49 - so the only change we have to do here is
61:51 - to add also the long block dependency to
61:53 - the annotation processor parts because
61:55 - lombok is also a library which generates
61:58 - code at compile time in our project so
62:00 - if you forgot to add this lombok
62:03 - dependency you will get some compilation
62:05 - errors in your project so so that's it
62:07 - for the installation we are ready now to
62:09 - use the mapping map struct in our
62:12 - project so let's start by creating some
62:15 - mappings in our subreddit service first
62:17 - of all i'm going to create a new package
62:19 - called smapper and inside this package
62:22 - i'll create a new interface with the
62:24 - name subreddit mapper
62:26 - and now let's animate this interface
62:28 - with headmapper and pass in the
62:30 - component model value as spring
62:33 - the first method we are going to define
62:35 - is the map to dpto method
62:37 - so this method takes in the subreddit
62:40 - object as input and returns us back the
62:42 - subreddit dto object
62:44 - so if we compare the fields we have id
62:46 - name description posts created date and
62:49 - user fields inside the subreddit and
62:51 - inside subreddit we have id name
62:53 - description and post count
62:55 - so we have some fields which with the
62:57 - similar field names and also types
63:00 - so maps track will identify and generate
63:02 - the mapping logic automatically for
63:03 - these fields
63:05 - and for the remaining field the number
63:07 - of posts
63:09 - this is just an integer field we have to
63:10 - create mapping from list of post to
63:12 - integer that means we have to just
63:14 - return the size of this list we can do
63:16 - that by creating a new method called as
63:19 - map post
63:20 - so which takes in a list of posts as
63:22 - input
63:23 - and inside this method we will just
63:25 - return number of post dot size so that
63:27 - means we're just returning the size of
63:29 - this list so we can tell to maps to use
63:31 - this method when mapping the post field
63:34 - by just annotating by using annotation
63:37 - called as app mapping with target as
63:40 - number of posts
63:41 - and here we are using a method to do
63:44 - this to use the mapping
63:46 - and here we're using a method to do the
63:48 - mapping so we will just use that method
63:51 - in the form in the field called
63:53 - expression so we just type expression
63:55 - and we pass in the java so let's try to
63:58 - compile this interface if you're using
64:00 - intellij you can type ctrl shift f9
64:03 - and now you can check the implementation
64:06 - to see the generated code by mapstract
64:16 - let's create mappings from subreddit dto
64:19 - to subreddit entity
64:20 - we can do that by declaring another
64:22 - method but in this case we just add an
64:25 - annotation called as inherit inverse
64:27 - configuration so this and annotation
64:30 - will create the mappings similar to map
64:32 - subreddit to dto method but instead this
64:34 - time it will create mappings from
64:36 - subreddit gto to subreddit entity
64:42 - and in this case actually we can ignore
64:44 - the post field because we have to set
64:46 - this field when creating the post
64:53 - now let's also compile this code and
64:55 - check whether the mappings are created
64:57 - or not
64:58 - so as you can see we have generated the
65:00 - mapping successfully also for this
65:01 - method now it's time to refactor the
65:03 - existing code by first removing the
65:05 - mapping methods and replacing them with
65:08 - the methods from subreddit mapper
65:34 - so in the previous video i forgot to add
65:36 - an endpoint to retrieve a subreddit
65:38 - based on the id
65:40 - so let's quickly add this
65:42 - endpoint
65:43 - inside the subreddit controller i have
65:45 - created a method called as getsubreddit
65:48 - which takes an id of type long
65:50 - and this is also a path variable
65:53 - and i've also added the get mapping
65:55 - annotations which takes the id as the
65:57 - value
65:59 - inside this method i'm calling the get
66:00 - subject method of the subreddit service
66:04 - and this subreddit so and this get
66:06 - subreddit method is
66:08 - actually retrieving the subreddit based
66:11 - on the id
66:12 - and then doing the mapping and then
66:14 - returning the value
66:16 - and then returning the subreddit back to
66:18 - the controller
66:21 - all right now let's start our
66:22 - application and let's try to create a
66:24 - subreddit and see if the mapping is
66:25 - working correctly or not
66:58 - okay so now let's go back to intellij
67:00 - and let's start creating the api to
67:02 - create and read post
67:03 - the first thing we have to do is to
67:05 - create a class called as post controller
67:07 - and let's annotate this class with the
67:09 - usual annotations rest controller
67:11 - request mapping with value slash api
67:14 - slash posts
67:15 - and the last one is all aux constructor
67:17 - annotation
67:19 - so i will just copy paste all the
67:21 - methods which we are going to create
67:23 - here so the first one is a post mapping
67:25 - which is of course used to create new
67:26 - posts for this methods we are taking a
67:29 - post request as input and let's create
67:31 - this class inside the dto package
67:34 - and this class contains the fields post
67:36 - id subreddit name
67:38 - post name url and description
67:41 - and the remaining methods in our
67:43 - controller are get mappings we have one
67:45 - method to read all the posts in our
67:46 - application
67:47 - one method to written a particular post
67:50 - and another method to return all the
67:52 - posts under a subreddit
67:54 - and the last method is to return posts
67:56 - which are created by a specific user
67:59 - okay so let's implement these methods
68:01 - inside our post service class of course
68:04 - it's not existing let's create this
68:05 - class first inside the service package
68:08 - and let's add the service and all logs
68:10 - constructor annotations to this class
68:13 - now let's create the method save which
68:15 - takes the post request object as input
68:18 - now here we have to create the mappings
68:20 - from post request to post entity
68:23 - i have
68:25 - so i have already created a post mapper
68:27 - interface for this
68:28 - so let's go into that interface and you
68:30 - can see the first annotation we have is
68:33 - a mapper annotation from abstract on top
68:36 - of our interface and the first mapping
68:38 - method you see is to create a post from
68:40 - the post request object
68:43 - so to create a post we not only need the
68:44 - post details but also the subreddit and
68:47 - the user details we'll be passing these
68:49 - details through the post service
68:52 - class to this method and you can see
68:54 - here that we have mappings for the
68:56 - fields created date subreddit user and
68:59 - description
69:00 - and the first mapping for the field
69:02 - created date here i'm using the
69:04 - expression property and passing the
69:06 - value as instant dot now so this value
69:09 - will be mapped to the created date field
69:11 - inside the post object
69:13 - next one is the for the fields user and
69:15 - subreddit
69:17 - so here the field names are same between
69:20 - for these two objects that means post
69:22 - request and post so we can go ahead and
69:24 - remove these mappings because of the
69:26 - field name matches in the source and
69:27 - target objects then we don't need to
69:29 - explicitly mention the mappings that
69:31 - will be taken care by mapstruct the last
69:34 - mapping is for the field description
69:36 - here we have to mention that the source
69:38 - is inside the post request object that's
69:40 - why we put the value as post request dot
69:43 - description
69:44 - in the same way we have the other
69:45 - mappings for the method called as
69:48 - map2d2o
69:49 - and here we are mapping from
69:53 - and here we are mapping from post object
69:55 - to the post response up so the first
69:57 - mapping is for the field id inside the
69:59 - post response and here the source is the
70:02 - post id and followed by the post name
70:05 - description and url
70:07 - and the next mappings are for the fields
70:10 - subreddit name inside the post response
70:13 - but this for this field we are get using
70:15 - the subreddit the name field inside the
70:18 - subreddit inside the post class that
70:20 - means if i go into post we have the
70:22 - field subreddit and if i go inside
70:23 - subreddit we have a name field so we
70:25 - want to map this particular field to the
70:28 - post response
70:30 - subreddit
70:32 - name field so that's what we are
70:34 - inferring here through this post through
70:36 - this annotation we will be mapping the
70:38 - subreddit dot name field to the
70:40 - subreddit name field inside the post
70:42 - response the same applies also for the
70:44 - username field
70:46 - so as i said before we can remove the
70:48 - mappings whenever where the source and
70:50 - the target names are the same so let's
70:52 - do that
70:59 - now let's compile this interface and see
71:01 - whether the mappings are generated or
71:02 - not
71:03 - i will type control shift f9 which is
71:06 - the shortcut to compile in intellij
71:09 - and if you click on the green button
71:10 - here you can see the implementations
71:13 - which are generated by mapstruct
71:22 - let us go back to the post service class
71:24 - inside the save method let's implement
71:26 - the necessary logic
71:28 - we have the post request object and to
71:30 - construct the post object we need the
71:32 - subreddit and user details for that we
71:35 - need the subreddit repository and odd
71:37 - service classes let's inject these two
71:39 - dependencies to our post service
71:43 - now i'm going to retrieve the subreddit
71:45 - from the subreddit repository by typing
71:47 - subreddit repository dot find by name
71:51 - and pass in the subreddit name
71:53 - so if there is no subreddit with this
71:55 - name we are going to simply throw the
71:56 - subreddit not found exception
72:05 - next we need the details of the user who
72:07 - made this request we can get the user
72:09 - details by calling get current user
72:11 - method inside the odd service class
72:14 - now we have all the needed objects to
72:16 - get our post object
72:18 - so
72:19 - so let's inject the post mapper into a
72:20 - class
72:22 - and after that i am going to type
72:23 - postmapper.map
72:26 - and pass in the post request subreddit
72:28 - and user objects as inputs to this
72:30 - method
72:31 - and lastly and lastly let's not forget
72:34 - to add the written statement to the
72:35 - method
73:00 - okay now we are done with the save
73:02 - method the important thing here is to
73:04 - add the transactional annotation
73:06 - let's add it on top of the class
73:08 - and after that we have to implement the
73:10 - method to read the port and after that
73:12 - we have to implement the method to read
73:14 - the post by different criteria
73:17 - that means to get one post get so that
73:19 - means to get a single post to get all
73:21 - posts and to get the post by subreddit
73:24 - and users
73:25 - i'm not going to bore you by tapping all
73:27 - the usual find buy methods so just to
73:30 - make it quick i'm going to quickly copy
73:31 - paste and the required code so we have
73:34 - the method get posts here we are reading
73:36 - the posts by querying the post
73:38 - repository by id
73:40 - using the find by id method
73:42 - and if there are no post with that id we
73:44 - are throwing the post not found
73:46 - exception
73:47 - and if we do find the post then we are
73:49 - using the map to dto method from post
73:51 - mapper we defined and returning the post
73:54 - response back to the controller
73:57 - similarly we have the get all posts
73:59 - method and for the get posts by
74:01 - subreddit we have to first read out the
74:03 - subreddit details by id
74:06 - and then query all the posts by the
74:08 - subreddit
74:09 - then we get a list of force back from
74:11 - the
74:12 - find all by subreddit method which is
74:14 - defined inside the post repository
74:16 - interface
74:17 - and here we are going through each post
74:19 - inside the list using streams and
74:22 - mapping the post object to the response
74:24 - post response object and finally we are
74:27 - collecting to a list and returning it
74:30 - back to the controller
74:32 - the same thing is happening also here
74:34 - for the get post by username method so
74:36 - i'm not going to go into much details i
74:38 - hope it is clear for you what's
74:40 - happening inside this method before
74:42 - testing before testing this let's go to
74:44 - the post controller class and you can
74:46 - see that for every method inside this
74:48 - controller
74:49 - i am wrapping the response we are
74:51 - getting from the post service class with
74:53 - the response entity object
74:55 - so this is a class from spring mvc so
74:58 - through this object we can return the
74:59 - different status codes for different
75:01 - scenarios
75:02 - that means for instance if we want to
75:04 - create a post usually if we are creating
75:06 - a resource in rest world we should
75:08 - return http status as 201 that means
75:11 - created
75:12 - we can do that by using the status
75:14 - method and here i am passing the http
75:16 - status dot created
75:19 - enum value to this method
75:21 - similarly for the get mappings we are
75:23 - returning an okay status that means http
75:26 - status 200
75:27 - in this in this way we can have nicely
75:30 - in this way we can nicely control what
75:32 - kind of responses we are sending back to
75:34 - the client
75:35 - so okay so as we are through with this
75:37 - it's time to start up the application
75:39 - and test the functionality we have
75:40 - developed so far
75:42 - so i will be back once i have started
75:44 - the application
75:47 - so we are going to test our post api now
75:50 - first of all i am going to login to our
75:52 - app and get a valid json web token from
75:55 - the application
75:57 - once i receive this token i am going to
75:58 - use it to create a post so here i am
76:01 - going to throw in some dummy data
76:03 - quickly
76:04 - and call the slash api slash post api
76:07 - with the http post method
76:10 - so as you can see we received a 201
76:12 - response back from the server that means
76:15 - my request is successfully
76:18 - so that means my request is successful
76:20 - actually to be honest we have to return
76:22 - the id of the post here so just the user
76:24 - knows what what is the id of the post he
76:26 - has just requested to create
76:28 - but we can add that in the next sections
76:30 - for now let's go ahead and test the get
76:33 - functionality
77:00 - so as i mentioned before we are going to
77:02 - create the api to manage comments in our
77:04 - application before starting the code
77:06 - let's go ahead and see what all the
77:08 - endpoints we are going to create in this
77:10 - video so i opened the link for the
77:11 - written tutorial here and if you go to
77:14 - the section implement api for managing
77:16 - comments you can see a table where we
77:19 - have our required mappings along with
77:21 - the http method and the name of the
77:23 - method we are going to implement inside
77:25 - our controller
77:26 - so the first one is an endpoint to
77:28 - create comments in our application that
77:31 - would be a post mapping
77:33 - and the path is slash api slash comments
77:37 - the next one is the mapping to retrieve
77:39 - comments for a particular post
77:41 - here we have a get mapping and we are
77:43 - passing the post id as a uri path
77:45 - variable
77:48 - and similarly we have our last mapping
77:49 - to retrieve comments for a particular
77:51 - user
77:52 - which also takes the username as the uri
77:54 - path variable
77:57 - so now let's go ahead and start coding
78:00 - inside the controller package i am going
78:01 - to create a class called as comments
78:03 - controller.java
78:05 - and
78:06 - and the first thing we are going to do
78:08 - is to annotate this class with the usual
78:10 - rest controller annotation
78:12 - and after that the request mapping
78:14 - annotation
78:15 - and the value here would be api
78:18 - api slash comments
78:20 - lastly let's add also the lombok
78:22 - annotation or logs constructor
78:25 - now let's create our first method create
78:27 - comments and annotate it with the post
78:30 - mapping annotation
78:31 - as this is handles uh as this is going
78:34 - to handle the post request
78:36 - this also contains a request body so
78:38 - let's add the request body annotation
78:41 - and now we have to create a dto class
78:43 - called as comments dto which represents
78:46 - the structure of the request body
78:48 - so
78:49 - inside this comments dto i'm going to
78:51 - quickly copy the necessary fields and
78:53 - paste them
78:54 - and also the annotations we are going to
78:56 - use
78:57 - so we have the fields id
78:59 - post id created date text and username
79:03 - and here the text would be the actual
79:05 - comment posted by the user
79:07 - now let's go back to our comments
79:09 - controller class and here we have our
79:11 - request body now we have to convert this
79:13 - object into our comment entity and save
79:16 - it to the database as usual we are going
79:18 - to handle these logic inside our service
79:20 - class so let's create a comment service
79:23 - class inside the service package and add
79:26 - the needed annotations
79:28 - i'm going to create a method called as
79:30 - save which takes comments dto object as
79:33 - input
79:34 - now we have to map the data inside
79:36 - comments dto to our comment entity
79:38 - so if i open the comment entity class
79:40 - you can see that we have the fields id
79:43 - text
79:44 - post created date and user
79:47 - and we have the fields text inside our
79:49 - dto as we saw before and the field
79:51 - created date will be generated
79:53 - dynamically and all we need is a post
79:56 - and user to construct the comment object
79:58 - now if you open the comments dto you can
80:01 - see we have already the post id and
80:03 - username fields so we just have to query
80:06 - the post repository and user repository
80:08 - interfaces to retrieve the corresponding
80:10 - user and post objects
80:12 - so
80:13 - here i'm going to
80:14 - show a small tip if you're using
80:16 - intellij if you want to see multiple
80:18 - editors at once we have this very good
80:20 - option to split the screen vertically
80:22 - and also horizontally so that if i want
80:24 - to compare the fields i just can right
80:26 - click on the editor name here and select
80:29 - split vertically
80:31 - now you can see more than two editors at
80:32 - once this will come in handy when you
80:34 - are dealing with uh the projects which
80:36 - have lots of lots of files
80:38 - and also another tip is if you want to
80:40 - switch between windows you can use
80:42 - control tab this is a key combination
80:45 - this opens up a switcher window and
80:47 - there you can see the file history you
80:49 - have your file history and then you can
80:51 - navigate through that by pressing tab
80:53 - while holding the control key so this is
80:56 - the shortcut i use every time to
80:58 - navigate between the files
81:00 - in the history okay now back to our
81:02 - comment service class and let's inject
81:04 - the post repository and user repository
81:07 - into our comment service and inside the
81:09 - save method i'm going to query the post
81:12 - repository by using the find by id
81:14 - method and by passing in the post id
81:18 - so as this returns an optional if the
81:20 - post is not available we can call the
81:22 - orals throw block
81:24 - and
81:25 - inside that we will pass in a supplier
81:27 - to throw a post not found exception next
81:30 - thing is we have to determine the order
81:32 - of the comment
81:33 - so for that instead of using the
81:34 - username we can check who is the
81:36 - currently logged in user and use that
81:39 - object to create our comment object for
81:42 - that i need to also inject all service
81:44 - class into our comment service
81:48 - now we have all the necessary
81:49 - information all we need is a mapper
81:51 - which can map our comments dto to
81:53 - comment objects
81:55 - so let's quickly create an interface
81:57 - called as comment mapper
81:59 - which is inside the mapper package
82:08 - okay so i've already prepared all the
82:10 - method definitions and mappings inside
82:12 - this comment mapper interface the first
82:15 - mapping we have is for the
82:17 - map method which takes in the comments
82:19 - dto and the post and user and returns
82:22 - the comment
82:23 - so the first
82:24 - so the first mapping is for the field id
82:26 - so we are ignoring this uh id field
82:29 - because
82:30 - the id will be auto generated whenever
82:32 - we save the object to the database so
82:34 - there is no need to specifically mention
82:36 - the mappings here that's why i've used
82:39 - ignore equal to true value inside the
82:41 - annotation
82:42 - the next one is for the field text
82:45 - here we are taking the text value from
82:48 - the commons tto
82:50 - object and mapping it to the text val
82:52 - text field of comment object
82:55 - and the next mapping is for the created
82:57 - date field here we are evaluating an
83:01 - expression a java expression
83:03 - and i'm passing the java.time
83:08 - expression to the java
83:10 - to the expression field abstract will
83:13 - evaluate the instant.now
83:15 - expression and will take the written
83:17 - statement and map it to the createdate
83:20 - field
83:20 - so you may ask me why did i mention
83:23 - java.time.instant instead of just
83:25 - writing instant because whenever map
83:27 - struct creates the implementation class
83:29 - for this interface
83:31 - it will not add the import statement to
83:34 - the class because we did not mention how
83:36 - to so there is no explicit so there is
83:38 - no way to add the import statement to
83:40 - the implementation class so that's why
83:42 - if we provide the fully qualified class
83:44 - name then map then there is no need to
83:47 - add import statements specifically so
83:49 - these are the mappings we are providing
83:51 - explicitly
83:52 - next up is the method map to dto here
83:56 - this is a straightforward
83:57 - we have just a comment object coming in
84:00 - as an input argument and we are
84:02 - constructing and returning the comments
84:03 - dto object here and the first mapping is
84:07 - for post id
84:08 - here also we are going to use the
84:11 - expression
84:12 - field and we are going to pass in the
84:15 - java expression comment dot get post dot
84:17 - get post id because we have the post id
84:20 - inside the post object
84:22 - and
84:23 - similarly we are going to map the user
84:25 - name to the common studio object by
84:27 - using the expression
84:29 - comment.getuser.getusername
84:32 - now let's go back to our service class
84:34 - and inject this mapper
84:36 - inside the save method i am going to
84:38 - type commentmapper
84:40 - inside the save method i am going to
84:41 - type
84:42 - commentmapper.map and pass in the
84:44 - comments dto
84:46 - post and for the user object i am going
84:48 - to make a method call to auth service
84:51 - or services getcurrentuser method which
84:54 - returns us the currently logged in user
84:57 - so now let's store the written type of
84:59 - this into a variable and to save the
85:01 - object we need a comment repository so
85:03 - let's inject that quickly and save the
85:06 - object to the database
85:09 - okay we are done with the save logic now
85:11 - we have to also implement the
85:13 - functionality
85:14 - to send a notification email to the
85:17 - author of the post so that means
85:19 - whenever a user submits a comment on the
85:21 - post we will send a notification email
85:23 - to the
85:24 - creator of the post
85:26 - if you remember we have already built
85:28 - the mail sending functionality
85:29 - previously and so we can just reuse
85:32 - those code and
85:33 - so we can just use that code so i'm
85:36 - going to go ahead and inject the
85:37 - required components into a service and
85:39 - paste in the required code and we will
85:41 - have a look at it what's going what's it
85:43 - and we will and we will use it and see
85:45 - what it is doing
85:47 - so you can see we are first building the
85:49 - body of our email by using the mail
85:51 - content builder once we get our email
85:54 - message we can send the email by using
85:56 - the mail service dot send mail method
85:58 - and inside this method we are passing
86:01 - the notification email object where we
86:03 - pass the subject line of our email
86:05 - followed by the email address of the
86:08 - post author and followed by the email
86:11 - message
86:12 - so
86:13 - once we execute this one we are already
86:16 - sending the email message asynchronously
86:18 - to the user
86:20 - we have completed the implementation
86:21 - part inside the service
86:23 - now let's go to the controller and
86:25 - inject comment service and call the save
86:28 - method
86:38 - now we have to send the response back to
86:40 - the client that the comment is created
86:42 - we can do that by returning a response
86:44 - entity which takes the http status
86:47 - object as the constructor argument as we
86:50 - are creating a resource in the rest
86:52 - world we'll send back the response as
86:55 - status 201 or created
86:58 - so we have an enum value called as
87:00 - created inside http status enum so we
87:03 - will return that value
87:06 - so we will use that value inside the
87:08 - constructor argument of response entity
87:11 - let's create the implementations for our
87:13 - two get mappings the first one is the
87:16 - get all comments for post method which
87:18 - takes in a path variable of type long
87:21 - with name post id
87:23 - inside this method we are calling
87:24 - another method inside the comment
87:26 - service with same name get all comments
87:28 - for post
87:30 - and we are returning the response back
87:31 - to the client by adding the written type
87:33 - of this method call to the response body
87:37 - and finally we are sending the http
87:38 - status as ok for this rest call
87:43 - now let's create this method inside the
87:45 - comment service and inside the method we
87:47 - have to first query the post repository
87:49 - to find the post by id
87:52 - and as this method returns an optional
87:54 - we can use the oral throw method truth
87:57 - to throw a post not found exception
88:00 - if we do find a post then we store it in
88:02 - a variable
88:04 - and we will find all the necessary
88:05 - comments which are associated with this
88:07 - post
88:08 - by using the find by post method
88:11 - as this method returns a list of
88:13 - comments we use the stream and map
88:15 - functions in the java 8 to map the
88:18 - comment object to comment dto object by
88:21 - using the map2dto method from the
88:23 - comment mapper interface
88:26 - finally we are collecting the result
88:27 - back to a list and we'll return it back
88:30 - to the controller
88:51 - now let's create our last method get all
88:54 - comments for user which also takes in
88:56 - the path variable of type string and
88:59 - with variable name as username
89:01 - we are calling the get all comments for
89:03 - user method inside comment service and
89:05 - if you go inside that method
89:07 - we are first querying the user from the
89:09 - database and then querying all the
89:11 - comments by the user using find by user
89:13 - method inside the comment repository the
89:16 - resulting list of comments we are
89:18 - streaming and then mapping them to
89:20 - comments dto objects and returning the
89:23 - list of comments dtos object back to the
89:25 - controller
89:26 - we are also returning back the response
89:28 - entity to the client similarly to our
89:31 - previous method by adding the written
89:32 - value from the service to the body and
89:35 - the
89:37 - and the http status as okay
89:41 - all right we have completed the
89:42 - implementation of the api to create and
89:44 - read comments let's test our
89:46 - implementation now by first starting up
89:48 - the server and opening the postman
89:50 - client
90:31 - so let's open our controller class which
90:33 - is named as vote controller and here we
90:36 - have the annotations for our class the
90:38 - rest controller rest mapping
90:40 - and our logs constructor
90:42 - and the risk mapping is for the value
90:44 - slash api slash votes and inside this
90:47 - class we have only one method which is a
90:49 - post mapping so it's just its main
90:51 - purpose is to submit a vote
90:53 - um
90:54 - for a particular post
90:56 - and we are receiving a vote dto object
90:58 - as a request body as input from the
91:00 - client and if i drill down we have two
91:02 - fields in this class one it is a vote
91:05 - type
91:06 - and the post id so vote type is an enum
91:09 - which contains values for
91:12 - either an upward or downward and we also
91:14 - have a direction
91:15 - field inside this enum so for the upward
91:18 - we have the direction as one and for the
91:21 - downward we have direction as minus one
91:24 - and if you go back to the word dto the
91:26 - other field is an identification of the
91:28 - post so it would be just post id
91:31 - back inside the controller i injected
91:33 - the vote service class and inside the
91:36 - vote method of the controller i called
91:38 - the vote method of the vote service
91:40 - class so let's go ahead into the word
91:43 - service and this method is first
91:45 - retrieving the post
91:47 - which needs to be updated with the vote
91:51 - so as this find by method returns an
91:53 - optional we are using the orals throw
91:55 - method here to throw a post not found
91:58 - exception in case if we don't find any
92:00 - post
92:01 - and if you do find then we are storing
92:04 - this written type inside the variable
92:07 - so the next query is an interesting one
92:09 - we are finding the recent vote which is
92:11 - submitted by the user for this post
92:14 - so as we are using spring data here
92:17 - spring data jpa i created the method
92:19 - find top by post and user
92:23 - order by vote id descending so what does
92:26 - it query do so here we are first finding
92:29 - the user by post and the user
92:31 - information
92:32 - order those results by vote id in
92:35 - descending order and get the top one so
92:39 - what that would be so so we are just
92:41 - getting the recent vote
92:43 - by the user for a particular post so
92:45 - that would be the latest vote by the
92:47 - user so once we retrieve this
92:49 - information we want to do some
92:51 - validations here so we want to make sure
92:53 - that the user is able to either approach
92:55 - or download only once consecutively that
92:59 - means if i uploaded a post
93:01 - i should not be able to upload the post
93:02 - again because i'm the same user and i
93:04 - cannot do the same actions consecutively
93:07 - the only value reaction at the time is
93:09 - to downvote
93:10 - so here we are doing this validation and
93:12 - after that we are making sure that the
93:15 - vote is uh present and if the vote
93:17 - existing is the existing vote type is
93:20 - equal to the requested vote type then we
93:24 - throw an exception with the message
93:25 - because we cannot throw the we cannot
93:28 - vote in the same direction twice in the
93:30 - row so now after this validation we do
93:33 - either increment or subtract the vote
93:36 - count of the post by one based on the
93:38 - word type and finally we have to map
93:40 - this vote dto to vote so and then we
93:44 - save this inside the database
93:46 - the same also apply for the post so here
93:49 - in this method we are manually mapping
93:51 - uh the all the fields so because i don't
93:53 - like to create the mapper when we are
93:55 - creating a small mapping logic just
93:57 - mapping logic and
93:59 - it's just one method so it's better off
94:01 - putting this method inside the service
94:03 - itself so and what we are doing inside
94:05 - this method is to use the builder method
94:08 - inside the wood dto
94:10 - so we have this builder annotation which
94:12 - will be
94:13 - generating the builder method at compile
94:15 - time
94:16 - and so this builder method is used to
94:19 - construct the object of what dto so
94:22 - and as this builder methods name
94:25 - suggests it builds the objects by making
94:27 - the code more readable and easy to
94:29 - understand so this is there's a design
94:31 - pattern behind this method called as a
94:34 - builder pattern
94:35 - and you can read more about builder
94:36 - patterns and
94:38 - if you want to learn more design
94:40 - patterns in general i highly recommend
94:42 - you know going through the book head
94:44 - first design patterns
94:46 - this is a book which introduces you to
94:48 - the design pattern and it's a very good
94:49 - book okay let's move on and go back to
94:51 - the controller so after saving the vote
94:53 - information to database we just return a
94:55 - success response back to the client with
94:57 - status as ok
94:59 - now we have to include the vote and
95:01 - comments information when user is
95:02 - retrieving the post so i have added some
95:05 - additional fields inside the post
95:06 - response class i added this comment just
95:09 - for you to understand i will repo it now
95:12 - so these new fields are number of votes
95:14 - for a post the number of comments and
95:16 - the last field is duration
95:18 - so this field shows us the relative time
95:21 - duration of the post creation time so we
95:23 - are calculating this using a library
95:26 - called as time ago so let me open the
95:28 - github page of this library it's just a
95:30 - cortland library
95:32 - so we can also use it in our java
95:34 - project here in the example
95:36 - you can see that the time is displaying
95:38 - as
95:39 - four days ago a month ago and also you
95:41 - know just now
95:43 - so this is how you see the time stamp in
95:45 - sites like reddit and also stack
95:46 - overflow so let's go back to our project
95:49 - i can quickly show you the dependency
95:51 - information of this time i go library
95:53 - inside the form xml file
95:55 - and here we have this dependency
95:58 - followed by the kotlin libraries the
96:00 - kotlin standard libraries because
96:03 - this is a kotlin based library and we
96:05 - need to add also these dependencies to
96:07 - our project the first one is the kotlin
96:10 - standard library for jdk 8 and the
96:12 - kotlin test
96:14 - junit
96:15 - dependency and for this dependency
96:18 - kotlin standard library jdka to work
96:20 - with our project we need to also add a
96:22 - maven plugin
96:25 - with
96:26 - called as scotland maven plugin so this
96:29 - is including in the compile phase so
96:31 - whenever it finds some kotlin specific
96:34 - code it
96:35 - make sure to generate the java code for
96:38 - it
96:39 - and we are filling this value inside our
96:41 - post mapper
96:42 - and if we go to the post mapper if you
96:46 - notice that i have changed
96:48 - this from an interface to an abstract
96:50 - class here
96:55 - because uh
96:56 - we have to add because we have added
96:58 - four new fields into inside our dto and
97:01 - we need some dependencies to fill these
97:02 - details in the mapper that means for
97:05 - comment count
97:06 - we need access to the comment repository
97:09 - and for vote count we need to access
97:12 - the vote repository and also the odd
97:14 - service is used to calculate the votes
97:16 - uh word count so
97:18 - let us see what we have what we have
97:20 - changed here so after changing it to the
97:23 - abstract class i automate these
97:24 - dependencies as as i said before and our
97:27 - first method
97:28 - is a map which maps the post request to
97:32 - the
97:32 - post object
97:35 - and here we have set the word count to
97:38 - zero because whenever we are saving the
97:41 - post the default vote count should be
97:44 - should be zero
97:45 - right there is no need to put any value
97:47 - here so that's why i use the constant
97:49 - field inside the mapping annotation to
97:51 - send the value as 0.
97:53 - if
97:54 - i click on the green button you can see
97:56 - the implementation here of this
97:57 - particular
97:59 - abstract class
98:00 - so if you scroll down there is uh so
98:04 - there is a line of code called post dot
98:06 - word count as zero so the next method
98:08 - here is the map to dto method here we
98:11 - are mapping from post to post response
98:14 - and the newly added fields here are the
98:16 - comment count and the duration fields
98:19 - so the first common count is actually we
98:22 - are getting this written type from a
98:24 - method so here we have this expression
98:27 - field which is calling the comment count
98:29 - method using for taking the post as the
98:32 - input and this comment on method is just
98:34 - returning the comments
98:36 - um size of the comments which are which
98:39 - belong to a particular post so it's just
98:41 - returning an integer and the next one is
98:44 - the duration so this is where we are
98:45 - using the time i go library inside the
98:48 - get duration method we are using the
98:50 - using method of the
98:53 - time i go library so this takes in a
98:55 - long
98:56 - variable as input and to get that long
98:58 - variable
98:59 - we are using this get createddate
99:02 - function which returns an instant
99:05 - and on this instant we are calling
99:08 - a method called as to epoch milli
99:11 - so this converts the instant to a long
99:15 - long type and it basically calculates
99:18 - number of milliseconds starting from
99:20 - first january of 1970 until now so until
99:24 - the created date so if you go inside the
99:26 - documentation
99:27 - now you can see it returns the number of
99:29 - milliseconds since the epoch of
99:31 - first january 1970. so the good thing
99:34 - here is we updated our mappings and we
99:37 - didn't even touch the post service class
99:40 - because of this changes because we just
99:42 - updated our post mapper class methods
99:45 - inside this class and by creating this
99:47 - mapper we are able to decouple the
99:49 - mapping logic with with the actual
99:51 - business logic which is handled inside
99:53 - the service so that's always a good
99:55 - thing to decouple our components right
99:58 - so we have made all our changes we can
100:00 - start our application and inside the
100:02 - postman client
100:03 - as usual make sure to log in and get the
100:06 - authentication token back from the
100:08 - server
100:09 - and use that authentication token inside
100:11 - the builder token section
100:13 - and let's submit a vote to the server
100:15 - now i created this body so i have
100:18 - provided the watch type as
100:21 - download and provided a post id
100:24 - now let's test and send this request and
100:26 - see what it happens and as you can see
100:29 - the server responded with status that
100:31 - means with status 200 that means okay
100:35 - now let's see if the vote count is also
100:37 - included in the post response so now i'm
100:40 - going to
100:41 - call the end point to get all posts
100:44 - so here you can see that for the post id
100:46 - which i used before the vote count is -1
100:50 - as we have downloaded this post
100:52 - so that means our implementation so that
100:54 - means our implementation is working as
100:56 - expected
100:57 - and let's also test another case so if
100:59 - we try to download the post again
101:02 - that means one more time you can see we
101:04 - have received the message you have
101:06 - already downloaded this post
101:09 - okay and the last thing i forgot to
101:10 - mention is you can now see the duration
101:12 - field inside the response
101:14 - this is channel this is changing
101:16 - dynamically now as i've you created this
101:18 - post long time back you are seeing these
101:20 - dates here like two months ago and six
101:22 - days ago
101:27 - as you are aware we are using json web
101:28 - tokens for the authentication mechanism
101:31 - and the main advantage of using these
101:32 - tokens are they are stateless and easy
101:35 - for the server to identify whether is
101:37 - request coming from a valid user or not
101:40 - so this may so this behavior makes
101:42 - implementing a perfect logout solution
101:44 - for the json web token based
101:46 - authentication scheme in the backend
101:48 - application very tricky and also
101:50 - difficult
101:51 - having said that there are four possible
101:53 - ways we can implement the
101:55 - json web token invalidation mechanism so
101:59 - the first one is to obviously delete the
102:01 - token from the client's browser so this
102:03 - is for sure a must when we have to
102:05 - implement the login but there is a
102:07 - possibility that a hacker may have
102:08 - already access to the json web token and
102:13 - this and that is the reason we have to
102:14 - find a solution to invalid the token
102:17 - also on our back end
102:18 - which brings us to our second point
102:20 - which is to introduce an expiration time
102:22 - for our tokens and make them as
102:24 - short-lived as possible so ideally we
102:26 - have to give an expiration time of 10 to
102:29 - 15 minutes for our json web tokens and
102:32 - here i will be using the terms the json
102:34 - web token and access token
102:36 - interchangeably from now on so but the
102:38 - downside here so as i was saying before
102:40 - but the downside here is once the tokens
102:43 - are expired we have to ask the user to
102:45 - log in again which is
102:48 - a terrible user experience so we can be
102:49 - sure that this solution is bad
102:53 - the third solution is to introduce a
102:54 - concept called as refresh tokens which
102:57 - builds on our point number two but the
102:59 - idea is to provide the user an
103:01 - additional token called as reference
103:03 - token at the time of authentication so
103:05 - we use this refresh token to generate a
103:07 - new access token whenever the access
103:10 - token is expired or about to be expired
103:12 - so in this way we can keep on rotating
103:14 - the access tokens and when the user logs
103:17 - out we can just delete this refresh we
103:19 - can just delete this reference token the
103:21 - last solution is
103:23 - when the user wants to log out we just
103:26 - store the token inside a database and
103:28 - once we have done that we check each
103:31 - token each request and check whether
103:33 - this request and check whether this
103:36 - token is inside the database or not so
103:38 - if this if it is part of if it is inside
103:40 - the database then we throw an error
103:42 - because this token is not is not valid
103:44 - anymore
103:46 - and
103:47 - as i said before this solution defeats
103:49 - the purpose of using a json web token
103:51 - because we're using a state and we are
103:53 - doing a database lookup for every
103:54 - request
103:55 - so
103:56 - even though instead of using the
103:58 - relational database if we use an
103:59 - in-memory database like redis we can
104:02 - hugely info improve we can hugely
104:04 - improve the performance of this
104:06 - particular solution so of ideally i
104:08 - guess a combination of 0.3 and 4
104:11 - would be the better solution in other
104:13 - use cases but in our use case
104:15 - we will just go with the third solution
104:17 - and we'll see how to implement this
104:19 - refresh token mechanism in our
104:20 - application
104:23 - the first step here is to introduce
104:25 - expiration time for our access tokens to
104:28 - do that i am going to open the jwt
104:30 - provider class and inside this class i
104:32 - am going to inject a value from the
104:34 - properties file called
104:36 - jwt.expiration.time
104:39 - let me also add this
104:41 - so i also added this property inside our
104:43 - application.properties file with the
104:45 - same name as a key and the value as 900
104:48 - 000
104:49 - so now we have to change the generate
104:50 - token method to include this expiration
104:53 - token so i can do that by adding a new
104:56 - method called set expiration
104:59 - and this method takes in the date object
105:01 - as input so for that as we have a long
105:05 - we can use the instant.now dot plus
105:08 - millis of the plus millis method call to
105:11 - convert this long to an instant object
105:14 - and from there we can use the date dot
105:17 - from method to convert this instant to a
105:20 - date object
105:24 - and let's also add a getter method for
105:26 - this expiration time as we will use this
105:28 - method soon
105:31 - let's open authentication response class
105:33 - and here we will add two new fields the
105:35 - first one is of type string and it's
105:37 - called as refresh token and the second
105:40 - one is an expiration date which is of
105:42 - type instant now let's open
105:45 - authentication service and inside the
105:46 - login method we will enhance the
105:48 - response we are sending back from the
105:50 - method
105:51 - so i'm going to add the expiration date
105:54 - to the response by first getting the
105:58 - expiration time in milliseconds from the
106:00 - jwt provider class and from there i'm
106:03 - going to calculate an instant from the
106:06 - time step by using the instant.now plus
106:09 - milliseconds method and for now we can
106:12 - just pass in the refresh token as empty
106:14 - string
106:15 - and so if you try to perform login so
106:17 - what we will get is one json web token
106:20 - one and one refresh token which is empty
106:22 - and an expiration date
106:25 - now next step is to implement the
106:26 - refresh tokens part first i am going to
106:29 - add a post mapping inside the auth
106:30 - controller class which takes a request
106:33 - mapping value as refresh slash token
106:36 - and this method is taking request body
106:38 - of type refresh token request
106:40 - this is a new class i have already
106:42 - created and this class contains only one
106:44 - field called reference token and this
106:46 - field is annotated with not blank
106:48 - annotation and if you add a valid
106:50 - annotation before the request body
106:53 - spring will automatically throw an error
106:55 - if you pass in an empty or null value as
106:57 - refresh token
106:58 - i did not implement this validations
107:00 - anywhere else in our application but in
107:02 - a real world application we use this
107:03 - validation mechanism very frequently
107:06 - so now inside this method i am going to
107:08 - add a method call to refresh token
107:10 - inside the odd service class and let's
107:13 - create this method
107:15 - so before so before doing any more
107:17 - implementation let's leave this aside
107:19 - and create a class with name refresh
107:21 - token service
107:22 - this class will be responsible to create
107:24 - delete and validate the refresh tokens
107:27 - so the first thing i'm going to do is to
107:28 - add in a method called as generate
107:31 - refresh token
107:32 - and here i'm going to create an object
107:34 - for refresh token and this refresh token
107:36 - is uh so we so we are going to store
107:39 - this refresh token inside the database
107:43 - if you go inside this class you can see
107:44 - that we have the usual data entity and
107:47 - all logs constructors the long block and
107:49 - the jpa annotations and the first field
107:52 - here is the id
107:53 - and followed by the token and the
107:55 - created date so we also have a
107:57 - repository created for this refresh
107:59 - token which is similar to all the
108:01 - repository we have
108:15 - so inside the refresh token service i am
108:17 - going to create
108:18 - a new object for the reference token and
108:21 - set the token so for the token the value
108:23 - would be uuid dot random uuid so this
108:26 - will so this will create a 128 bit
108:29 - unique random uuid and i am going to
108:32 - convert this uuid to a string and we
108:34 - will use this as our refresh token and
108:36 - for the created date i am going to pass
108:38 - in the present
108:40 - time by using the instant.nav method and
108:43 - after that i am going to save the token
108:45 - by just using the save method of the
108:47 - refresh token repository
108:50 - and the next method is the validate
108:51 - refresh token so this method is just
108:54 - takes the token as a value this method
108:57 - just takes token as input
109:00 - and we are just going to look up for
109:02 - this token using the find by token
109:04 - method and as this method
109:07 - returns as an optional
109:09 - we are going to use the oral throw
109:11 - method to throw a spring reddit
109:13 - exception saying that this is an invalid
109:14 - refresh token
109:16 - the next one is a delete refresh token
109:18 - method so this is just
109:20 - the normal delete method so we are just
109:22 - calling the delete by token method
109:24 - inside the reference token repository by
109:26 - passing in the bypassing in the token so
109:29 - if the token is not there inside the
109:31 - database spring automatically throws an
109:34 - illegal argument exception in this case
109:44 - now i'm going back to the refresh token
109:46 - method inside the all service class and
109:48 - here let's inject the refresh token
109:50 - service
109:51 - and down here inside the refresh token
109:53 - method first i'm going to make a method
109:55 - call to validate the incoming refresh
109:57 - token
109:58 - if the token is invalid then there will
110:00 - be a runtime exception and if not the
110:02 - execution goes on to the next step which
110:04 - is to generate new token
110:07 - we can use the generate token method
110:08 - inside the jwt provider class
110:11 - but if the jwt is already expired then
110:14 - there will be no user information inside
110:16 - the security context and as we need
110:19 - subject while creating the token which
110:20 - is the username
110:22 - we can just
110:23 - create another method called generate
110:25 - token with username
110:27 - and inside this method i'm going to pass
110:29 - in the username which is coming from the
110:30 - refresh token request as the subject
110:34 - so let's call this generate token with
110:36 - username method from our reference token
110:38 - method
110:39 - and let's store the written value as
110:41 - string variable called token
110:44 - now i'm going to construct
110:45 - authentication response object using the
110:47 - builder method we have our newly
110:49 - generated token
110:50 - the refresh token which is coming in
110:52 - already from the request
110:54 - the expiration date of this new token
110:56 - and username
110:58 - let's go back to auth controller class
111:01 - we do not see any errors inside the
111:02 - refresh token methods that's good and
111:04 - now let's go ahead and create our last
111:07 - method called log out which also has a
111:10 - post mapping annotation
111:12 - and here we are going to receive again
111:13 - the reference token request as request
111:16 - body from this object we can retrieve
111:18 - the reference token and we can call the
111:20 - delete refreshed and we can call the
111:22 - delete refresh token method inside the
111:24 - refresh token service
111:26 - to make this work let's inject the
111:28 - reference token service class inside the
111:30 - auth controller
111:31 - and lastly we can return a response
111:33 - entity with status okay and body as the
111:36 - refresh token deleted successfully
111:43 - okay so a quick correction inside the
111:45 - login method of our auth service class
111:48 - so here in the authentication response
111:50 - we are sending an empty string as the
111:52 - refresh token so instead of that we will
111:54 - be sending
111:56 - the generated refresh token by calling
111:58 - refresh token service dot generate
112:00 - refresh token so this will return us the
112:03 - string and we will pass this
112:05 - to the authentication response
112:08 - okay so that's it we have covered all
112:10 - the points to implement refresh token
112:12 - mechanism in our application
112:14 - let's start the application and test it
114:02 - so we'll be using angular 9 which is the
114:04 - latest version as of today when
114:06 - recording this video
114:08 - and i am going to use visual studio code
114:10 - as my ide for developing the front-end
114:12 - application
114:13 - so first thing first make sure you have
114:15 - the latest angular cli installed on your
114:17 - machine and after that open a terminal
114:20 - and type ng new and here i'm going to
114:23 - give the project name as angular reddit
114:25 - clone
114:27 - we'll be using angular routing in our
114:29 - project so i'm going to type y
114:31 - and for the style sheets we're going to
114:32 - just use the css
114:35 - and now angular cli is going to create
114:37 - all the project files and install the
114:38 - project for us
114:40 - and i will be back after the
114:41 - installation is completed
114:43 - so as you can see the installation is
114:45 - completed now and the project is
114:46 - initialized successfully as a git
114:48 - project okay now i'm going to type cd
114:51 - space angular reddit clone and after
114:53 - that i will type ng serve and our
114:56 - application should start successfully at
114:58 - localhost 4200.
115:06 - so if you face any problems while
115:07 - starting up the application one of the
115:09 - root cause may be the incompatibility
115:11 - between the versions of angular cli and
115:13 - some dependencies of angular
115:15 - this usually happens when you are
115:17 - running an older version of angular cli
115:19 - so to troubleshoot those problems i have
115:21 - a section inside the written tutorial
115:23 - based on the angular cli version you may
115:25 - have to change the version number of the
115:27 - angular dev kit dependency to be able to
115:30 - start the application successfully
115:34 - so if you open the address in the
115:36 - browser you can see the default homepage
115:38 - of the application
115:41 - alright so the next step is to install
115:42 - bootstrap in our project so in the
115:44 - terminal inside the project folder npm
115:47 - install save bootstrap
115:50 - this should install the latest bootstrap
115:52 - to our application
115:53 - once the installation is completed you
115:55 - can see that the bootstrap is added to
115:57 - the list of dependencies inside the
115:59 - package.json file
116:05 - now we have to update the angular.json
116:07 - file with the location of the bootstrap
116:09 - css files
116:11 - because the angular cli by default will
116:13 - exclude the bootstrap css files when
116:15 - creating the bundle
116:17 - when starting the application so we can
116:19 - instruct a cli to include these files by
116:21 - going to the angularjson file and inside
116:24 - the styles array we have to provide the
116:26 - location of the bootstrap css file just
116:29 - above the definition of styles.css
116:32 - so i am going to type here node modules
116:35 - bootstrap
116:37 - dist
116:38 - css
116:40 - and there we have the
116:42 - bootstrap.main.css file so i'm going to
116:44 - provide this definition inside the
116:46 - angularjson file
116:48 - and save it
116:49 - okay now it's time to create our first
116:51 - component we will start off with the
116:53 - header component we can create the
116:54 - component by typing nggc which is short
116:58 - form for ng generate component and the
117:00 - name of the component we are going to
117:01 - create is header so this will create all
117:04 - the needed files inside the header
117:06 - folder
117:09 - okay so in this series i'm going to
117:11 - mainly focus on the angular side and
117:12 - i'll be explaining the concepts of
117:14 - angular so i'll just copy paste the html
117:16 - and css part and some bootstrap is
117:19 - involved
117:20 - so to start things off i will first copy
117:22 - the needed html to the
117:24 - header.component.html file so you can
117:26 - see that we have a header tag and inside
117:28 - that we have a nav bar
117:30 - to the left side of the nav bar we have
117:32 - the reddit icon this is an svg icon
117:34 - which i copied directly from the reddit
117:36 - website
117:37 - and to the right side we have the login
117:39 - and sign up buttons
117:41 - so before checking how this html looks
117:43 - inside the browser first we have to add
117:45 - the app header selector to our
117:48 - appcomponent.html file so i am going to
117:50 - delete the existing code inside the app
117:52 - component html and and i am going to
117:54 - type app header inside the file
117:57 - so now when you open the application you
117:58 - should see this huge reddit icon to the
118:00 - left side of the screen and to the right
118:02 - side we have the links for login and
118:04 - sign up now let's make this look nice
118:08 - i'm going inside the
118:09 - header.component.css file and i'm going
118:11 - to paste again the required css here
118:14 - so now if you open the browser you can
118:16 - see that we have a very nice nav bar
118:18 - where to the left side we have the
118:19 - reddit icon followed by the edit icon
118:22 - followed by the logo text and to the
118:24 - right side we have the login and sign up
118:26 - buttons
118:28 - all right i know i told you our backend
118:30 - implementation part is completed for a
118:32 - dead clone application but before
118:34 - starting to develop our angular
118:35 - application i thought it would be good
118:37 - to also show you the procedure to
118:39 - document the rest apis we have developed
118:41 - in that way we can refer to the
118:43 - documentation whenever we need to write
118:44 - the logic to make rest api calls to our
118:46 - backend so now let's see why we need to
118:48 - document our rest apis in the real world
118:51 - you will be obviously developing a rest
118:52 - api so that other clients can consume it
118:55 - in our case the client is an angular
118:57 - application it's always the best
118:59 - practice to create documentation for our
119:01 - api so that the other developers can
119:02 - understand what they are working with so
119:05 - in the real world having this
119:06 - documentation is very helpful and
119:08 - improves the user adoption of your api
119:10 - and this also makes the maintenance of
119:12 - the rest api very easy all right now to
119:15 - implement this documentation in our
119:16 - application we will be using an open api
119:19 - specification called as swagger and a
119:21 - library called as springfox which allows
119:24 - us to automatically generate the
119:25 - documentation for our rest api by
119:27 - following the swagger specification so
119:29 - as a first step open the bomb.xml file
119:32 - and add the following maven dependencies
119:35 - the first one is springfork's swagger2
119:38 - and the next one is springforks swagger
119:40 - ui
119:42 - both these dependencies are on version
119:44 - 2.9.2 as the latest
119:47 - at the time of recording the video after
119:49 - that make sure that there are no errors
119:50 - shown inside the pom.xml
119:53 - and now i'm going to create a class
119:54 - called as swagger configuration inside
119:56 - our config folder
119:59 - inside this class i am going to add the
120:01 - configuration annotation and here i am
120:03 - going to enable swagger in our
120:05 - application by adding enable swagger to
120:07 - annotation
120:08 - and inside this class i am going to
120:10 - create a bean
120:11 - the name of the bean can be anything you
120:12 - like so i'm going to create it as reddit
120:15 - clone api
120:17 - and here we are creating and returning
120:19 - an object called as docket
120:21 - and according to springfox documentation
120:28 - a docket is a brief statement of the
120:30 - contents of the document
120:32 - you can configure this docket object to
120:34 - decide what shows up inside our swagger
120:36 - documentation
120:38 - for now we will use the defaults except
120:39 - for the api infos here we are calling a
120:42 - method called as get api info which
120:44 - returns an object of ipinfo inside this
120:47 - method we are providing the details of
120:49 - our api which are like the title version
120:52 - number contact details and licensing
120:54 - information if you want to have a simple
120:56 - rest api documentation this is a very
120:58 - good starting point and this
121:00 - configuration should be sufficient now
121:02 - we have added the configuration class
121:04 - let's import this configuration inside
121:06 - our application class i am going to
121:08 - import this configuration using the add
121:10 - import annotation in this way at the
121:12 - application startup spring will invoke
121:14 - springfox and springfox is going to scan
121:16 - all the rest controller components in
121:18 - our application and the corresponding
121:20 - details for the stress controllers and
121:22 - generate the rest api documentation for
121:24 - all of these
121:25 - let's start up the application and check
121:27 - whether we are able to see the
121:28 - documentation or not
121:31 - once you open the browser go to address
121:33 - http localhost 8080 swaggerui.html
121:38 - and as you can see that we received at
121:40 - 403 error so this is because spring
121:42 - security is not going to allow access to
121:45 - this resource because we have configured
121:47 - to block all the requests without the
121:49 - token
121:51 - we have already added some exceptions to
121:52 - our security configuration so we can
121:55 - also add the swagger ui.html
121:58 - and some other parts to our exclusion
122:00 - list
122:00 - so this helps us to display the rest api
122:02 - documentation webpage
122:09 - once this is completed restart the
122:10 - application and open the url inside the
122:13 - browser
122:14 - now you can see the complete western pa
122:16 - documentation for our application
122:18 - so you can see we have all our rest
122:20 - controllers which are defined inside our
122:22 - project here in the swagger
122:24 - documentation we can see what are the
122:25 - end points which are there in our
122:27 - application including the http methods
122:30 - they support we can also check the
122:32 - models these are the request and
122:33 - response classes which are also called
122:35 - as dtos
122:37 - and we can also see the example values
122:40 - we can provide to the request payload
122:42 - and which data type they support
122:46 - and lastly you can also see the
122:47 - documentation as a raw json by clicking
122:50 - on the url localhost 8080 v2
122:54 - api docs
123:00 - so in the part 10th of the video
123:01 - tutorial series we have already created
123:03 - our angular application created the
123:05 - header section
123:06 - which contains the buttons for login and
123:08 - sign up
123:09 - so in this video we are going to
123:11 - implement the signup functionality and
123:13 - for that let's go ahead and implement
123:15 - the signup functionality for that i'm
123:17 - going to open the terminal
123:19 - and type nggc or slash signup
123:23 - this will create our signup component in
123:25 - a typescript html and css file inside
123:28 - the auth sign up
123:30 - folder
123:31 - now i'm going to open the written
123:32 - tutorial and copying the
123:34 - sign up component html file code from
123:37 - there and paste it inside our project
123:41 - after that let's also copy the css file
123:43 - to the signupcomponent.css
123:54 - now before checking out how this looks
123:56 - inside the browser you have to add a
123:57 - route from the sign up button on the
123:59 - header section to the sign up page
124:02 - if you check the signup anchor tag
124:04 - inside the
124:05 - hydracomponent.html file it's pointing
124:07 - to the path signup
124:09 - let's add this path to the approaching
124:10 - module.ts file
124:13 - where we declare all the routes which
124:14 - are there in our angular application
124:17 - and here i'm going to update the routes
124:19 - array with the route information for
124:20 - signup component
124:23 - now let's go to the browser and check if
124:24 - you are able to navigate to the signup
124:26 - page after clicking on the sign up
124:28 - button on the header section so perfect
124:30 - it works now let's handle the form input
124:33 - inside our signup page using reactive
124:35 - forms
124:36 - as a first step let's import the
124:38 - reactive forms module inside our
124:40 - appmodule.ts file i am going to add
124:42 - reactive forms module just below the
124:44 - approaching module and also make sure
124:46 - that to add the import statement for
124:49 - reactive forms module from angular forms
124:51 - after that let's declare a variable
124:53 - called as signup form which is of type
124:55 - form group inside our
124:57 - signupcomponent.ts5
124:59 - and inside the ng on init i am going to
125:01 - type this dot sign of form
125:03 - equals new form group and inside the
125:06 - form group i'm going to declare the
125:08 - found controls for the fields we have
125:10 - inside our signup form the first one is
125:12 - the username field
125:13 - so here i'm going to type new form
125:15 - control and pass the form state as empty
125:17 - for now
125:19 - and the same thing also applies for the
125:20 - other fields email and password
125:27 - we can also add validations for this
125:28 - field let's update our form control by
125:30 - adding validators dot required for each
125:32 - field and especially for the email field
125:36 - inside the signup form we will also add
125:38 - validators dot email to check the input
125:41 - value for email field is in the valid
125:42 - format or not
125:44 - all right so we have made lots of
125:45 - changes inside our signup
125:47 - signupcomponent.ts file we have to sync
125:49 - these changes also to our html file
125:52 - so now let's open
125:54 - signupcomponent.html and first let's
125:56 - declare the form group directive for the
125:58 - top form tag
125:59 - and pass the variable signup form
126:02 - next we have to assign the form control
126:04 - names to the input fields
126:06 - inside the input tag of the email field
126:09 - i will type form control name in square
126:11 - brackets
126:12 - and provide the value email with single
126:14 - quotes
126:15 - if we do not provide single quotes
126:17 - angular will check for a class level
126:19 - variable with name email but we declared
126:21 - this field as a form control so by so by
126:23 - adding the single quote angular
126:25 - understands it as a form control value
126:28 - i am going to add the form control names
126:30 - also for the username and password input
126:31 - fields
126:41 - and lastly let's add also the code where
126:43 - we display the validation errors for
126:44 - each field
126:46 - so just below the input tag i'm going to
126:48 - add a span tag
126:50 - and inside the spanning tag i'm going to
126:52 - add an ngif directive
126:54 - and type signup form dot get
126:57 - the single quote
126:59 - dot valid
127:00 - and sign up form dot get
127:02 - email again with single quote dot
127:04 - touched
127:06 - and let's add text please provide valid
127:08 - email
127:09 - so what's happening here is
127:12 - we have added the validators inside the
127:14 - form controls for each field
127:16 - so if the given form control is invalid
127:20 - signupform.getemail.valid will return
127:22 - either true or false
127:24 - so if the given field is changed by the
127:26 - user
127:27 - and the value provided by the user is
127:29 - not valid we will display this message
127:32 - let's copy this and also adapt it for
127:34 - the username and password fields
127:43 - now let's check how this looks inside
127:45 - our browser i am going to select the
127:47 - input field inside the email and then
127:48 - click somewhere else
127:50 - so you can see that we receive the
127:51 - message please provide valid email
127:53 - address
127:54 - the same thing should also apply for
127:56 - username and password fields
127:58 - perfect
128:00 - okay now if there is an error let's show
128:01 - the input with the red border for that i
128:03 - am going to open styles.css file and
128:06 - type
128:06 - and type input dot ng invalid dot ng
128:10 - touched
128:11 - and then i'm going to provide the border
128:13 - as one pixel solid with red color
128:16 - okay now let's save okay let's save this
128:18 - and go back to the browser and if i try
128:20 - to change the input field and click
128:22 - somewhere else on the page you can see
128:23 - the error message along with the red
128:25 - border on the input field
128:27 - okay now it's time to take the input
128:29 - from the form and make a http call to
128:31 - our backend api
128:33 - before that let's check the swagger
128:34 - documentation we prepared
128:36 - so i'm going to open the url http
128:38 - localhost 8080
128:40 - swaggerui.html
128:42 - and under the out controller
128:44 - expand the endpoint for signup
128:47 - and here you can see the payload
128:49 - which is accepting that is we need a
128:51 - username email and password
128:54 - so we already have those fields inside
128:56 - our form
128:57 - so let us create a model in our angular
128:59 - application to encapsulate these fields
129:02 - i am going to open i'm going to go
129:04 - inside the signup folder and create a
129:06 - file called as signuprequest.payload.ts
129:11 - and inside this field i'm going to
129:12 - create a signup request payload model
129:15 - interface with fields username email and
129:18 - password
129:24 - okay now let's declare this model inside
129:26 - of component i'm going to give the
129:28 - variable name as signup request payload
129:31 - and i'm going to initialize this model
129:33 - inside the constructor
129:36 - here i'm going to provide an empty
129:37 - string value for each field
129:40 - all right now we forgot to add the ng
129:42 - submit directory to our form
129:44 - which handles the on submit action
129:47 - so let's quickly add it and
129:49 - this ng submit directive should call a
129:51 - method called as sign up
129:53 - let's also create this method inside
129:54 - your component
129:56 - and inside the signup method i am going
129:58 - to read the values from our form group
130:00 - one after another and assign them to the
130:03 - fields inside the signup request payload
130:06 - i am going to access each field by using
130:08 - the get method on the signup form
130:11 - and accessing the value property which
130:13 - returns the value of the form control
130:21 - now we have our request payload object
130:23 - ready next step is to make the http call
130:26 - to our backend we will make that call in
130:28 - a separate class called azure not
130:30 - service
130:31 - so let's create this service
130:33 - i'm going to open the terminal again and
130:35 - we'll type nggs
130:37 - auth
130:38 - shared
130:40 - this is going to create an odd service
130:41 - dot ts file inside the auth shared
130:43 - folder
130:45 - perfect
130:46 - so let's open this all service class and
130:49 - declare a method called as sign up
130:51 - and inside this method we have to make
130:52 - the http call
130:54 - for that we need access to the http
130:56 - client class inside angular
130:58 - let's inject this class into our service
131:00 - through the constructor
131:03 - and after that let's come back to the
131:04 - sign up method
131:05 - and type this dot http
131:08 - dot post and here i'm going to paste the
131:11 - url for the sign up api
131:14 - and we'll be receiving the signup
131:15 - request payload as the input for this
131:17 - method so let's pass this object as the
131:20 - request payload
131:22 - and lastly let's add a return statement
131:24 - for this method and declare the written
131:26 - type as observable of any
131:32 - also as the response from the backend
131:34 - call for the signup call is a string we
131:36 - are going to change the written type as
131:38 - text so now before accessing the http
131:41 - client inside our service we have to
131:43 - declare the http client module inside
131:45 - the module.ts file so let's open the
131:48 - file and declare the http client module
131:52 - now let's inject this all service class
131:54 - into the signup component.ts file and
131:57 - inside the signup method i'm going to
131:59 - type this dot
132:00 - all service dot sign up and i'm going to
132:03 - pass in the sign up request payload as
132:05 - the input
132:06 - as this method returns an observable
132:09 - i am going to subscribe to this
132:11 - return type and add some console log
132:14 - and lock the response
132:16 - so now let's open the browser and check
132:17 - viewer now let's open the browser and
132:20 - check if you are receiving a success
132:21 - response
132:22 - or not
132:24 - so here what we are receiving is an
132:26 - error response which says the request is
132:29 - blocked by course policy
132:31 - and our preflight request doesn't pass
132:33 - the access control
132:35 - this
132:36 - we are receiving this error because our
132:38 - back end is blocking the request because
132:40 - we did not specify any course policies
132:42 - yet so let's configure them by the way
132:44 - if you are not sure what is cause i'm
132:46 - not going to go into the details about
132:48 - that i have already created a separate
132:50 - video in my previous builder blog with
132:52 - spring boot and angular series i will
132:54 - add a link to the description you can
132:56 - check that video and come back
132:58 - so please check the video for more
132:59 - information
133:01 - so now let's go back and open our
133:02 - intellij ide and here i'm going to
133:05 - create a class called as web config
133:07 - inside the config folder and i'm going
133:09 - to add the configuration and enable
133:11 - webmec annotations here on top of the
133:14 - class
133:15 - and i'm going to implement
133:17 - webmvc configure interface for this
133:20 - class
133:21 - and i'm going to overwrite the add
133:23 - course mappings
133:24 - method
133:26 - and this method contains all the
133:29 - course related
133:31 - configurations which we required for the
133:33 - back end and here we are actually
133:35 - accepting the request from all is from
133:37 - all origins
133:39 - to our backend if you are developing a
133:40 - production grade application you may
133:42 - want to not do this and read more about
133:44 - what
133:45 - are the right way to do
133:47 - but for now this configuration should
133:49 - resolve the problem we have with our
133:52 - registration so let's restart the
133:54 - backend application and try to register
133:55 - one more time
133:57 - so now you can see that we are receiving
133:59 - the success response from our backend
134:06 - so in the last video we implemented the
134:08 - sign up functionality let's go ahead and
134:10 - implement the login now the first thing
134:12 - i want to do is
134:15 - the first thing i will do is of course
134:16 - create the login component
134:18 - for that type nggc
134:22 - login in the terminal
134:24 - this will create all the required files
134:26 - after that open the blog post which is
134:28 - linked in the description
134:30 - and copy and paste the html code for the
134:32 - login page and paste it inside the
134:36 - login.component.html file and next also
134:38 - copy the css code to the
134:41 - login.component.css file
134:47 - now if you compare the css files of
134:48 - login and signup components you can see
134:50 - that the css classes login and sign up
134:53 - share the same code
134:54 - so let's extract this code from this
134:56 - files and put it in a commonplace
134:58 - styles.css file
135:01 - the next step is to configure the routes
135:03 - for our login page so so when you click
135:05 - on the login button on the header will
135:07 - be navigated to the login page
135:09 - we can do that by first opening the
135:12 - approaching.modules.ts file which is the
135:14 - place we declare all the routes in our
135:16 - angular application
135:18 - and then i will be updating the routes
135:19 - array with the path for login component
135:23 - after that is done let's open the
135:25 - logincomponent.ts file and let's
135:27 - configure the form group with variable
135:29 - name as loginform
135:31 - and i'm going to initialize the form
135:32 - inside the ngoninetblock
135:35 - here we are defining the form controls
135:37 - for two fields we have inside our form
135:39 - which is username and password
135:41 - and we also have defined the validations
135:43 - that these fields require when
135:45 - submitting the form now let's open our
135:47 - login component html file and sync the
135:49 - validations we did in the component.ts
135:52 - file
135:53 - just below the input text for username i
135:55 - am going to add a span tag which is
135:57 - going to access the form control
135:59 - information through login form
136:01 - form group and here if the user has
136:03 - touched the input and did not provide
136:05 - any value we will display the message
136:07 - please provide a valid username
136:09 - now i am going to do the same thing also
136:11 - for the password field and in this case
136:13 - we will display the message password
136:14 - cannot be empty if you open the
136:16 - application in the browser and try to
136:18 - click on the input field and click away
136:20 - on somewhere else on the page
136:22 - you should see the validation message
136:23 - and also the border is marked as red
136:26 - all right so let's move ahead and write
136:28 - the logic to make an http call to our
136:31 - login rest api
136:33 - similar to what we did for signup rest
136:34 - api let's try to access our swagger api
136:37 - documentation at http localhost 8080
136:40 - swaggerui.html
136:43 - and you see we've got a 404 error
136:45 - this is because after enabling the web
136:47 - mvc for the course configuration in the
136:50 - la in the previous videos
136:53 - we broke the swagger configuration
136:54 - because now the spring mvc does not know
136:57 - how to handle the web jars which is
136:59 - coming as part of the swagger spring fox
137:02 - library
137:04 - and that below function just below the
137:06 - course mapping method
137:08 - so in this method we are pointing to the
137:09 - location where the web charge and the
137:11 - swagger ui.html can be found in the
137:14 - class path
137:16 - after that restart the application and
137:17 - refresh the shraggerui.html page and we
137:20 - should be able to see the swagger rest
137:22 - api documentation again
137:24 - expand the art controller and click on
137:26 - the login api
137:28 - section
137:29 - and you can see this api accepts
137:31 - username and password has the request
137:33 - payload and it returns the odd token
137:35 - reference token username and expiration
137:38 - time as responses
137:40 - so now let's go ahead and create the
137:42 - models in our wrangler application to
137:44 - hold this data back to the visual studio
137:46 - code let's create a file called login
137:48 - request.plo.ts
137:50 - inside the auth login folder and let's
137:53 - define an interface called request
137:55 - payload
137:56 - with field definitions for username and
137:58 - password
137:59 - both of them are of type string
138:01 - and i'm going to also create a file
138:03 - login response payload.ts under art
138:06 - login
138:08 - and also here i'm going to create an
138:09 - interface with fields auth token refresh
138:12 - token expire set and username now let's
138:15 - open the odd service class under the
138:17 - auth shared folder and add a method
138:18 - called as login which takes the login
138:20 - request object as input
138:22 - and inside this method let's make a post
138:24 - call to the login api
138:27 - here we want to specify the written type
138:29 - as login response by passing in the
138:31 - generic type to the post method
138:34 - and let's use the pipe method and map
138:36 - method from the rxjs to map the response
138:40 - to
138:42 - and let's use the pipe and inside that
138:44 - we will use the map method which is part
138:46 - of rxjs
138:47 - and we can access the fields which are
138:50 - part of the response here now inside
138:52 - this method we are going to store these
138:54 - details inside browser's local storage
138:56 - for that we need to add a dependency to
138:58 - a project called as ngx web storage
139:01 - let's add it to our package.json and run
139:03 - npm install
139:05 - once it is completed we can enable ngx
139:08 - web storage in our application by adding
139:10 - the ngx web storage module to the app
139:12 - module.ts file just below the http
139:15 - client module i am going to declare ngx
139:18 - web storage
139:19 - dot for road
139:20 - and
139:21 - and also make sure to add the import
139:23 - statement from the ngups ngx web storage
139:25 - package
139:27 - all right now we are ready to access the
139:29 - local storage from our application so
139:31 - let's go back to our auth service class
139:33 - and inject the class
139:35 - local storage service from ngx web
139:37 - storage
139:39 - and once it is run let's store the token
139:41 - and user information inside the local
139:43 - storage by typing this dot
139:46 - local storage dot store
139:49 - followed by the key and value of the
139:51 - data we're going to store
140:00 - now the last thing remaining is updating
140:02 - our login component so let's do that by
140:04 - first declaring the login request
140:06 - payload variable just below the form
140:08 - group declaration
140:10 - and i'm going to initialize this login
140:12 - request payload object inside the
140:13 - constructor
140:15 - next i am going to create the login
140:16 - method and read the username and
140:18 - password values using the login form
140:20 - form group variable and assign it to the
140:23 - username and password fields inside the
140:25 - login request payload object
140:28 - and after that i'm going to call the
140:29 - login method of the or service by
140:31 - passing in the login request payload
140:33 - object
140:35 - and as this returns an observable let's
140:37 - subscribe to this and add a console
140:39 - statement called as login successful
140:42 - now we are ready to test our
140:43 - implementation so let's restart the
140:45 - application to reflect the changes we
140:47 - did to our app module the trees file
140:50 - so now i'm going to open the application
140:52 - inside the browser and try to log in
140:55 - so you can see that we don't see that
140:57 - nothing happens on the screen but if you
140:59 - open the console you can see the message
141:01 - login successful and let's open the
141:04 - application tab under the local storage
141:07 - and let's open the application tab in
141:09 - the console and under the local storage
141:11 - you can see the auth token and refresh
141:13 - token information along with the
141:14 - username and expiration time
141:17 - as a first improvement let's add a
141:18 - toaster notification to the application
141:21 - so after every successful sign up and
141:23 - login the toaster notification should
141:25 - look something like how you see on the
141:27 - screen
141:28 - so first i'm going to open the
141:29 - package.json file and add a dependency
141:32 - called as ngx toaster we're going to use
141:34 - the version 12.0.1 as of now because it
141:37 - is compatible with angular 9
141:40 - and after that we have to run the npm
141:42 - install command to install this
141:43 - dependence after that open the
141:44 - appmodule.ts file and we have to add two
141:47 - modules here the first one is browser
141:49 - animation module which is coming in from
141:51 - angular animations
141:53 - and the next one is toaster module so
141:55 - for that we have to type toaster module
141:57 - dot for root which is coming in from the
142:00 - ngx stores to dependency next we are
142:02 - going to inject the toaster service
142:04 - inside the sign up component along with
142:06 - the router class
142:07 - and inside the signup method on
142:09 - receiving successful response you are
142:11 - navigating to the login page and we are
142:13 - also adding a query param called
142:16 - registered with value as true
142:18 - so we are using this to notify the login
142:20 - component that registration is
142:22 - successful in the case of receiving an
142:24 - error response we want to display an
142:25 - error notification so now let's go to
142:27 - the login component and here we are
142:29 - going to inject the router and toaster
142:31 - service classes and additionally we will
142:33 - also inject the activated route class to
142:35 - the
142:36 - login component to access the route
142:38 - parameters which is coming in from the
142:40 - signup component inside the ng on init
142:42 - method we are subscribing to the query
142:45 - params from the activatedroute object
142:47 - and in case we receive a query parameter
142:49 - with the value for registered as true
142:52 - then we display the success notification
142:54 - message sign up successful using the
142:56 - toaster.success method and the next
142:58 - thing is we are setting the value for
142:59 - the field register success message we
143:01 - will be accessing this message inside
143:03 - the login component html file after the
143:05 - successful registration inside the login
143:07 - method we are subscribing to the
143:08 - response we are receiving from the
143:10 - allservice.login method and in the case
143:13 - of successful login we are navigating to
143:14 - the view to url
143:16 - and then we are enabling the success
143:18 - notification with the message login
143:19 - successful
143:21 - if we receive a failure response from
143:23 - our login call
143:24 - we are setting the value for the boolean
143:26 - variable ease error and inside our html
143:29 - file we have an ng if statement which
143:30 - displays the error and asks the user to
143:33 - retry
143:37 - now let's go ahead to the main section
143:39 - of this tutorial which is to handle the
143:41 - reference tokens in our angular
143:42 - application our backend server which we
143:44 - have implemented expects the json web
143:47 - token for each request and it checks for
143:49 - this token inside the authorization http
143:51 - header so we have to make sure that our
143:53 - each request going from our angular
143:55 - client to the backend server contains
143:57 - this token this can be achieved by using
143:59 - a special component in angular called as
144:01 - interceptor
144:03 - the concept of the interceptor is
144:04 - similar to the servlet filters in java
144:07 - in our case we need an interceptor which
144:09 - modifies each request going to a backend
144:11 - server by adding the token information
144:14 - to the header and of course we also
144:16 - maintain the logic for reference tokens
144:18 - inside this interceptor
144:19 - when the client sends an expired token
144:21 - to the server
144:22 - the server responds back with the 403
144:24 - error
144:25 - and at that point request a new token
144:28 - using a refresh token
144:30 - and using that new access token for
144:32 - subsequent requests
144:34 - now let's go ahead and implement this
144:36 - logic in our angular application i am
144:38 - going to create a file called as token
144:39 - interceptor.ts under the app folder
144:42 - and this file contains a class called as
144:44 - token interceptor which implements http
144:47 - interceptor interface inside the
144:49 - interceptor method
144:50 - we first read the token from our local
144:52 - storage using the all service dot get
144:54 - jwt token method which is just
144:57 - retrieving the authentication token from
144:58 - the local storage if the token is valid
145:01 - we will be setting the value inside the
145:02 - authorization headers if our json web
145:04 - token is active this will this is how
145:06 - the process works
145:08 - now if the token we are setting to the
145:09 - headers is an invalid token
145:11 - we receive an error response from a
145:13 - backend
145:14 - in that case you have to prepare our
145:15 - client to make the reference token call
145:17 - to the backend and when we make this
145:19 - call we have to temporarily block all
145:21 - the outgoing back-end calls for this
145:23 - user and once we receive a new
145:25 - authentication token from our backend we
145:27 - are going to release all the requests
145:28 - again
145:29 - so we are able to fulfill this
145:30 - functionality with the use of a boolean
145:32 - variable called as ease token refreshing
145:35 - and a behavior subject called as refresh
145:37 - token subject
145:38 - which in our case acts as a semaphore to
145:41 - block the outgoing calls
145:43 - the main reason to use a behavior
145:45 - subject instead of a subject or an
145:46 - observable is because the behavior
145:49 - subject can have a value assigned to it
145:51 - so when we receive the new token from
145:52 - the refresh token method we can assign
145:55 - the token to the behavior subject and
145:56 - access the new token
145:58 - inside the interceptor coming to our
146:00 - refresh token method if we check the
146:02 - rest api documentation
146:03 - this method takes in two fields as input
146:06 - the refresh token and username
146:08 - so we are constructing this object
146:10 - inside the refresh token method and
146:12 - making a http post call to our backend
146:15 - for this post wall we are receiving the
146:17 - login response object from our backend
146:20 - as response and we are storing the new
146:22 - authentication token and username values
146:24 - inside the local storage
146:26 - as we discussed before we are setting
146:28 - the new access token value to the
146:30 - behavior subject and setting the ease
146:31 - token refreshing field value to false
146:35 - or else all the outgoing calls will be
146:37 - failing with the 403 error
146:39 - okay now before we test this
146:40 - implementation we need to create a home
146:42 - page component in our application
146:45 - for that i am going to type ngc home
146:48 - this component retrieves and displays
146:51 - all the posts we have in the database
146:53 - so for that now open the written
146:55 - tutorial and copy the html under the
146:57 - create home page component section and
147:00 - paste it into the home component html
147:02 - file
147:03 - i will be explaining what's inside this
147:05 - file in the next tutorial but for now as
147:07 - we are just testing the refresh token
147:09 - functionality let's leave this as it is
147:11 - so so i'm going to create a new service
147:13 - using the command ngg has shared post
147:17 - so this will create a class called as
147:18 - post service under the shared folder and
147:20 - inside the constructor i'm going to
147:22 - inject the http client class to our post
147:24 - service
147:26 - and let's create a method called as get
147:28 - all post
147:29 - so now let's go ahead and check our rest
147:31 - api documentation
147:33 - so you can see this is just a normal
147:35 - catch call and we receive an array of
147:38 - object which contains all these fields
147:41 - which are related to the post so now
147:43 - let's go back to the vs code and create
147:45 - a file called as post model dot ts
147:49 - and inside this file i'm going to create
147:50 - a class called as post model which
147:52 - contains all the fields in the rest api
147:54 - documentation all right now let's open
147:57 - the home component class and here i'm
147:59 - going to declare a variable called as
148:01 - post
148:02 - which is of type array of post model
148:05 - and inside the constructor i'm going to
148:06 - first inject the post service class and
148:09 - i'm going to call the get all post
148:10 - method of the post service and subscribe
148:13 - to the response and assign the
148:15 - response to the post variable inside the
148:18 - component
148:21 - finally we have to add route to the home
148:22 - page component so open up the
148:25 - approaching module.ts file
148:27 - and add an entry to the routes array
148:29 - just above the signup route information
148:32 - and specify the component as home
148:34 - component all right so there's a lot of
148:36 - changes we have done we also need one
148:38 - small change before we go ahead and test
148:40 - the implementation
148:41 - we forgot to add the css entry for the
148:44 - ngx toaster library inside our
148:47 - angular.json file
148:49 - so let's quickly add it
148:50 - just below the styles.css declaration so
148:53 - let's restart the server just to make
148:55 - sure that all the configuration is up to
148:57 - date
148:58 - and test our implementation
149:00 - first i'm going to register as a new
149:02 - user
149:03 - and let's see if the sign up successful
149:05 - notification is visible or not so we can
149:08 - see this notification that's good now
149:10 - let me quickly activate this user or
149:12 - else we will not be able to login
149:15 - and now let's try to log in
149:26 - you can see we are able to see the
149:28 - toaster notification with the message
149:30 - login successful and we are also able to
149:32 - see the post information which is coming
149:34 - from our end this looks ugly but for now
149:37 - let's leave it we will make it look
149:38 - decent in the next tutorial but
149:44 - in the last episode we just dumped in
149:45 - the html code for our homepage into the
149:48 - homecomponent.html file let's go through
149:50 - it step by step and try to understand
149:51 - the code so we just have a container div
149:54 - and inside that we have another div with
149:56 - class row
149:57 - then we divided this row into two
149:59 - columns one with the width of nine units
150:01 - and the next column with a width of
150:03 - three units
150:04 - inside the first column we have again a
150:06 - div which displays the post information
150:09 - as seen in the comments and this div
150:11 - element contains ng4 directive which is
150:14 - looping through all the posts which we
150:15 - are receiving from the post service so
150:17 - if the post variable contains four posts
150:20 - for example
150:21 - this day will be repeating four times
150:23 - and inside the div we again have two
150:24 - columns the first column has one unit of
150:28 - width
150:29 - and as you can see in the comments this
150:30 - section is used to mainly display the
150:32 - vote information for our posts and
150:34 - inside this deal we have two icons one
150:36 - above and one below the vote count div
150:39 - this element displays the vote count for
150:41 - this post so these icons are coming from
150:43 - the fort awesome library we will install
150:46 - this library see how to start working
150:48 - with this icons and so the next column
150:50 - contains the post information
150:52 - this div is 11 units wide and here as
150:54 - you can see we already have all the post
150:56 - information we need this column first
150:58 - contains the subreddit name
151:00 - and after that the name of the author of
151:03 - the post and also the duration that
151:05 - means how much time back this post was
151:08 - submitted by the user the next field is
151:10 - the post name
151:12 - followed by the description
151:14 - and the number of comments which are
151:16 - associated with this we have another
151:18 - icon in the section an icon for comments
151:20 - we will also shortly see how this looks
151:22 - now let's install the fourth awesome
151:24 - icons in our project
151:26 - the first dependency to add inside our
151:28 - package.json file is angular font
151:30 - awesome followed by font awesome svg
151:33 - core and free solid svg icons
151:36 - dependencies
151:37 - these are the latest versions for each
151:39 - of these dependencies at the time of
151:40 - producing this episode
151:42 - if you somehow provided an older version
151:44 - number vs code automatically suggests to
151:46 - update to the latest version so you just
151:48 - have to click on the section and run npm
151:50 - install
151:52 - after running npm install we have to
151:54 - enable the font awesome module in our
151:56 - project so i'm going to open
151:58 - appmodule.ts file
152:00 - and add this module information under
152:02 - the imports array and also make sure to
152:04 - add the import statement for this module
152:06 - from angularfont awesome library now we
152:08 - have to import the required icons into
152:10 - our home component.ts file from the free
152:13 - solid svg icons library
152:15 - so i am going to import the icons fa
152:17 - arrow up
152:18 - fa arrow down and fa comments
152:21 - and these properties are already tied to
152:23 - a html file through the icon property so
152:25 - we just have to declare these properties
152:27 - inside our homecomponent.ts file now if
152:30 - you go ahead and open the application
152:31 - inside the browser you can see the up
152:33 - and down arrows along with the icon for
152:35 - comments
152:36 - but one thing which looks strange is
152:38 - that the home component and the header
152:40 - component are overlapping
152:42 - we can fix that easily
152:44 - we can fix that easily by adding the css
152:46 - to our styles.css file
152:49 - we basically added a margin top value
152:51 - has 63 pixels for a body
152:53 - if you go and check the application you
152:55 - can see now the home component is not
152:57 - overlapping with the header component
152:59 - anymore okay now let's go ahead and try
153:01 - to break down this home page to
153:02 - different components
153:04 - for that i'm going to use the screenshot
153:05 - of the final version of the home page to
153:07 - get an idea how we are going to refactor
153:09 - this page
153:11 - so in the homepage we have many posts to
153:13 - the left side of the screen
153:14 - and to the right side we have the
153:16 - sidebar section where we can create post
153:18 - and subreddits
153:20 - and we have another section where we can
153:22 - view the subreddits which are created in
153:23 - our application so we are going to
153:25 - divide this mainly into four components
153:27 - the first one is called as post tile
153:29 - component which contains the information
153:31 - needed for each post
153:33 - and inside this component we have a
153:34 - voting section which contains an up
153:36 - arrow a down arrow and the vote count
153:39 - we will create a separate component also
153:40 - for this section called as vote button
153:42 - component the next two components are
153:44 - the sidebar component and the subreddit
153:46 - view sidebar component
153:48 - so let's go ahead and create those
153:49 - components one by one
153:51 - i am going to put those components
153:52 - inside the shared folder under the app
153:54 - folder
153:56 - because we can reuse these components to
153:57 - display in multiple pages
154:00 - now let's copy and delete the code which
154:02 - is displayed just below the display post
154:04 - comment
154:06 - you can easily copy the code by first
154:07 - collapsing the step element to just two
154:09 - lines
154:11 - and after that let's delete this code
154:14 - open the post style component.html and
154:16 - paste this code
154:18 - as we are in a different component now
154:19 - we no longer have access to the post
154:21 - variable inside the post style component
154:24 - as we are reading the post inside the
154:26 - home component
154:27 - we have to either move the code inside
154:29 - the post style component or pass this
154:31 - variable pose as input down to the post
154:34 - style component i would prefer to move
154:36 - the logic from the home component
154:37 - because from now on this component
154:39 - serves only as a placeholder so i am
154:41 - going to go inside the
154:43 - file and remove the injected post
154:46 - service class and also the method call
154:48 - to get all posts from the home
154:50 - components constructor
154:52 - and add it to the post style
154:53 - component.ts file
155:03 - let's also transfer the font awesome
155:05 - icon properties to the post style
155:07 - component.ts5
155:12 - so the selector name of this component
155:14 - is app post tile
155:16 - let's go ahead and declare this inside
155:18 - our homecomponent.html file
155:21 - we should also add some css for this
155:23 - component for that i am going to take
155:25 - help from the written tutorial under the
155:27 - post style component section
155:29 - copy the css under the
155:31 - poststyle.component.css file and paste
155:33 - it inside the project
155:37 - now inside the post style component we
155:39 - have to extract the vote button
155:41 - component so i am going to again
155:42 - collapse the due section with class call
155:45 - mg1
155:46 - copy and delete it
155:48 - open the
155:49 - votebutton.component.html file and paste
155:51 - that code
155:52 - now to display the vote count inside the
155:54 - vote button component we need also
155:56 - access to the post information
155:59 - so for that let's provide the post
156:01 - object as input to the word component
156:03 - so i am going to create an input
156:05 - property called as post of type post
156:07 - model
156:09 - let's copy the selector for the wordput
156:10 - component and declare it inside inside
156:12 - the post style component.html file
156:15 - enter the selector tag passing the value
156:17 - for the property post let's also copy
156:20 - the necessary css from the written
156:22 - tutorial and copy it inside our
156:25 - votebuttoncomponent.css file
156:32 - next up it's time to add logic inside
156:34 - the sidebar and subreddit sidebar
156:36 - components
156:38 - also here i am going to copy the html
156:40 - and css code from the written tutorials
156:42 - and paste it inside our project
157:01 - now for subreddit sidebar we have to
157:04 - read the subreddits from our backend and
157:06 - display them under the section
157:08 - let's quickly have a look at our swagger
157:10 - rest api documentation and you can see
157:12 - that we are receiving the following
157:13 - properties as response for the subreddit
157:15 - api call
157:16 - for that first let's create the service
157:18 - file which makes the http calls to our
157:20 - backend i am going to create the service
157:22 - using the command ng gs
157:25 - which stands for ng generate service
157:27 - subreddit
157:29 - subreddit
157:30 - this should create a
157:31 - subredditservice.es5
157:33 - under the newly created subreddit folder
157:35 - now let's also create a model class
157:37 - which holds the response from the
157:39 - subreddit http call
157:41 - i am going to create a file called as
157:42 - subreddit response.ts
157:44 - and i'm going to create a class which
157:46 - contains the field id description
157:49 - name and number of posts inside the
157:51 - separated service first i'm going to
157:53 - inject the http client inside the
157:56 - constructor
157:57 - and i'm going to create a method called
157:59 - as get all subreddits inside this method
158:01 - i am going to make a http call to the
158:03 - get all subreddits api let's add the
158:06 - array of subreddit response class as a
158:09 - generic argument for the http get call
158:12 - and specify the written type as
158:13 - observable of array of subreddit
158:15 - response
158:17 - now let's open the subreddit sidebar
158:19 - component file and inject this updated
158:21 - service
158:22 - and inside the constructor
158:24 - let's add the call to the
158:25 - subreddit.getall subreddits and let's
158:28 - subscribe to this response and assign
158:31 - the response to the subreddits variable
158:34 - which is declared inside the component
158:36 - this property is already bound to the
158:38 - html as we have an nga4 directive which
158:41 - is displaying the subject names for all
158:43 - the subreddit responses now one thing we
158:45 - have to observe here is the list of
158:47 - subreddit response can contain any
158:48 - number of records and if you just
158:50 - reiterate and display all of them and
158:53 - will face problems while rendering the
158:55 - section that's why it would be a good
158:57 - idea to limit the number of values we
158:58 - display in this section
159:00 - and if there are more than say four
159:01 - records in the array we'll only we will
159:04 - display a view all button which takes us
159:06 - to a new page and display all the
159:09 - subreddit information
159:10 - for now let's add this view all button
159:12 - to our section we can add that by
159:13 - declaring a boolean flag first inside
159:16 - the subreddit sidebar component
159:18 - called as display view all and inside
159:20 - the subscribe method of the get all
159:22 - subreddits call if the response contains
159:25 - more than four entries
159:26 - we will use the splice method to take a
159:28 - subset of only four values from this
159:30 - array
159:31 - and display those values inside the
159:33 - section
159:34 - or else we just assign the array as it
159:36 - is to the subreddit property
159:38 - before checking our refactored home page
159:40 - inside the browser we have to make some
159:42 - additions to the vote button
159:43 - component.ts file
159:45 - we have to move the fa arrow up and fa
159:47 - arrow down properties
159:49 - from the post tile component.ts to the
159:51 - woodbutton component.ts file
159:57 - and lastly i am going to copy the
159:59 - selectors for sidebar component
160:01 - subreddit sidebar component
160:03 - and add them to the right column of the
160:05 - homepage html file
160:09 - now if you open the application inside
160:10 - the browser you can see the list of
160:12 - course along with the vote button
160:14 - component the left side of the page
160:17 - and on the right side we can see the
160:19 - sidebar which contains the create post
160:21 - and subreddit buttons
160:23 - and below that we have the sidebar with
160:26 - subreddit information along with the
160:27 - view all hyperlink
160:34 - let's start off by generating the
160:35 - components required to create the
160:37 - subreddits and posts
160:39 - inside the terminal i'm going to type ng
160:42 - gc
160:43 - subreddit slash create subreddit which
160:46 - stands for ng generate component
160:49 - with the name create subreddit under the
160:51 - subreddit folder
160:53 - and after that i am going to type nggc
160:56 - post create post
160:58 - which generates the required files for
161:00 - the create post component in the
161:02 - previous episode we have already created
161:04 - the buttons for create subreddit and
161:05 - create post inside the sidebar as we
161:08 - have now created the components we have
161:09 - to add a route from the create subreddit
161:11 - and create post buttons to this
161:13 - components
161:14 - inside the
161:15 - approaching.module.ts file let's add two
161:18 - entries with part create post and create
161:20 - subreddits which point to the respective
161:22 - component after that if you go to the
161:24 - sidebar.component.html file you have
161:26 - defined the value for the click
161:28 - directory as go to create post
161:30 - and go to create subreddit but we are
161:32 - missing this method definitions inside
161:34 - the sidebar component so let's go to the
161:35 - component and here i am going to
161:37 - implement these two methods
161:39 - we have the logic to navigate to the
161:40 - create post component inside the go to
161:42 - create post method
161:44 - and we also have the similar logic
161:47 - inside the go to create subreddit method
161:49 - where we are navigating to the create
161:51 - subreddit route now let's go ahead and
161:53 - implement the logic to create subreddits
161:55 - from our angular application
161:57 - i'm going to open the written tutorial
161:59 - and click on the section create
162:00 - subreddit and i'm going to copy the html
162:03 - and css code and paste it into the files
162:06 - inside the project
162:11 - inside the create
162:13 - subreddit.component.html file we have a
162:14 - form which contains the form group with
162:17 - value create subreddit form and an ng
162:19 - submit directive which calls the create
162:21 - subreddit method inside the component
162:24 - inside this form we have a div which
162:26 - contains the heading for this form
162:28 - create subreddit next we have an input
162:30 - of type text which holds the title of
162:32 - the subreddit
162:33 - we declare this field as a form control
162:35 - by using the form control name directive
162:37 - after that we have a text area which is
162:39 - another form control which holds the
162:41 - description of the subreddit next we
162:43 - have two buttons create and discard and
162:46 - we have an on click event which is bound
162:48 - to the methods discard and creates
162:50 - updated for these buttons using the
162:52 - click directive now let's go ahead and
162:54 - implement the required form groups form
162:56 - controls and methods we need inside the
162:58 - create
162:59 - subreddit.component.ts file so inside
163:01 - the component first we declared a form
163:03 - group of variable creates updated form
163:06 - which we saw before in the html file and
163:08 - we are initializing this form group
163:10 - inside the constructor with fields title
163:12 - and description
163:13 - each of these fields are assigned to a
163:15 - form control object which contains a
163:17 - validator which validates that the value
163:19 - for the fields title and descriptions
163:22 - are not empty
163:23 - next we also declared an initialized
163:25 - subreddit model object
163:27 - if you remember we have created this
163:29 - class in the last episode while
163:30 - refactoring the form component then we
163:32 - have the create subreddit method which
163:34 - reads the form control values for fields
163:36 - title and description
163:38 - and then we are assigning it to the
163:39 - subreddit model object
163:42 - after constructing the object we are
163:43 - calling the create subreddit method
163:45 - inside the subreddit service where we
163:47 - are making a post call to the create
163:49 - subreddit rest api and returning an
163:51 - observable inside the component we are
163:53 - subscribing to this observable response
163:56 - and when we receive a success response
163:58 - we are navigating to the list subreddits
164:00 - page
164:01 - and if we receive an error we are
164:03 - throwing an error using the throw error
164:05 - method from rxjs
164:08 - lastly we have the discard method which
164:10 - takes us back to the home page so here
164:12 - we are navigating to the list subreddits
164:14 - page but this route and the components
164:17 - do not exist yet
164:18 - let's fire up the terminal and create
164:20 - the components by typing ng gc
164:24 - subreddit slash list subreddits to
164:27 - create the components and html css files
164:30 - now again i'm going to take the help
164:32 - from the written tutorial
164:34 - and here i'm going to go to the section
164:37 - show all subreddits and copy the html
164:40 - and typescript code
164:41 - and paste them into the project so
164:44 - inside the list
164:45 - dot component.html file
164:47 - we are using an ng for directive to loop
164:50 - through all the subreddits which are
164:52 - stored inside the variable subreddits
164:54 - and for each subreddit we display the
164:55 - name and we have an anchor tag which has
164:58 - a router link with the value view
165:00 - subreddit followed by the subreddit name
165:04 - this route does not exist yet we will
165:06 - create it soon and inside the other
165:07 - column to the right side of the page we
165:09 - have the sidebar component now if i go
165:11 - to the list subreddits component we are
165:14 - calling the get all subreddits method of
165:16 - subreddit service
165:17 - inside the ngoninet of the component
165:20 - we are subscribing to the response and
165:22 - assigning the response to the subreddit
165:24 - object which is of type array of
165:26 - subreddit model if we receive an error
165:28 - response back from the get all
165:29 - subreddits call
165:31 - we throw an error using the throw error
165:33 - method of rxjs all right now let's
165:36 - register the route for slash list
165:38 - subreddits to the list subreddits
165:40 - component inside the
165:42 - approaching.module.ts and after that if
165:44 - you remember in our home page we have a
165:46 - separated sidebar component which
165:48 - contains a link to display all the
165:50 - subreddits
165:51 - let's go ahead and update that router
165:53 - link value
165:56 - now let's open the application and try
165:58 - to create a subreddit
166:03 - and as you can see we are navigated to
166:04 - the list subreddits page and we can also
166:07 - see the subreddits we have just created
166:09 - let's also test whether the navigation
166:10 - is working from the subreddit sidebar so
166:13 - yes it's working perfect our next task
166:16 - is to implement the functionality to
166:18 - create posts we have already created the
166:20 - components and the supporting source
166:21 - files in the first section of this
166:23 - episode before we start our
166:24 - implementation we need to install some
166:26 - dependencies to our application to
166:28 - create the post we need some kind of
166:29 - editor so for that let's use this editor
166:32 - called as tinymce with all these fancy
166:35 - controls and options
166:36 - we can integrate tinymce into our
166:38 - angular project by typing the below
166:40 - command npm install save
166:43 - tinymce angular
166:46 - this should install and add the tinymc
166:48 - angulardependency in the package.json
166:50 - file next we will enable tinymce in our
166:53 - project by adding the editor module to
166:55 - the appmodule.ts5
166:57 - alright so before starting the
166:58 - implementation let's refer our swagger
167:00 - rest api documentation one more time to
167:03 - see what is the request payload we need
167:05 - to create a post
167:07 - so here under the post controller so
167:09 - here under the post controller under the
167:11 - create post section
167:13 - you can see the payload which takes the
167:15 - fields description post name subreddit
167:18 - name and url
167:19 - you can ignore the post id as this is
167:21 - auto generated so let's create these
167:23 - fields inside a class in the angular
167:26 - project
167:27 - i am going to create a new file under
167:30 - the create post folder called as create
167:32 - post
167:33 - payload
167:35 - and inside that i'm going to create a
167:36 - class which contains the fields post
167:38 - name subreddit name url and description
167:42 - all right now we need the html and css
167:44 - code for create post
167:46 - i'm going to again go to the written
167:47 - tutorial because i don't want to spend
167:49 - time writing the html and css code
167:52 - i think there is nothing special in that
167:53 - so we will just emphasize in the angular
167:55 - part so what we have here is in the html
167:58 - file is a form tag which contains the
168:00 - form group and ng submit directives
168:02 - inside the form tag we have the create
168:04 - post heading followed by the form
168:06 - control inputs for post name and url
168:10 - we also have a drop down list which
168:12 - contains all the subreddits in our
168:13 - application
168:15 - we need this because each post should be
168:16 - assigned to a subreddit
168:18 - and the interesting part here is the
168:20 - editor tag
168:21 - this i copied from the tinymc page
168:24 - if you go to the documentation here you
168:26 - can see all the steps required to
168:28 - install the editor in our application
168:30 - which we have followed before
168:32 - and lastly we have the buttons post and
168:34 - discard so now let's see what's inside
168:37 - the post component so we have declared
168:39 - and initialized the create post form
168:40 - variable of type form group inside the
168:43 - ngoninit method
168:45 - and inside the form group declaration we
168:47 - define all the fields which our form
168:49 - contains and we also added the
168:51 - validators to this form control next we
168:54 - are reading all the subreddit
168:55 - information as we have to display them
168:57 - in the drop down when creating the post
168:59 - after reading them from the subreddit
169:01 - service we are assigning the response to
169:03 - a subreddits variable
169:05 - next we have the create post method
169:06 - which first reads the form control
169:08 - values and creates the create post
169:10 - payload object
169:12 - once we have the necessary data we call
169:14 - the create post method inside the
169:16 - subreddit service which is making the
169:18 - http post call to the create post rest
169:20 - api
169:22 - this method is returning an observable
169:24 - so we subscribe to the response and once
169:26 - we receive a success response we
169:28 - navigate to the home page
169:30 - or else we throw an error using the
169:32 - throw error method from ngrx library
169:36 - lastly we have a discard post method
169:38 - which redirects us again to the home
169:40 - page
169:42 - now let's test our implementation i'm
169:44 - going to open the home page and click on
169:46 - the create post button on the sidebar
169:48 - section and i'm going to provide the
169:50 - necessary details here so you can see
169:51 - the cool tiny editor we installed looks
169:54 - something like this
169:56 - so i'm going to use this controls and
169:58 - provide some text
169:59 - and click on the post button
170:02 - and you can see we have navigated to the
170:03 - home page if you scroll all the way down
170:06 - you see the html code instead of seeing
170:08 - the text in the expected format
170:11 - this is because the tinymce produces
170:13 - html code as the output and we are
170:16 - saving this html code inside the dp
170:18 - under the description field
170:20 - first of all there is a security risk by
170:22 - storing the raw html inside the db but
170:26 - we will talk about it later
170:27 - but for now we have to change the way we
170:29 - are rendering this information inside
170:31 - the post style component so let's open
170:33 - up the post style component.html file
170:36 - and under the div section where we
170:38 - display the description i am going to
170:40 - change the interpolation to a inner html
170:43 - directive and pass the value
170:45 - post.description to it
170:47 - this will render our text as html and
170:49 - now we are able to see the text as we
170:51 - expect
170:58 - so in the last episode we developed the
170:59 - logic to create the pose in our
171:01 - application but we still don't have a
171:03 - way to drill down and read the post
171:05 - information
171:06 - let's create a component called as view
171:08 - post
171:09 - so i'm going to open the terminal and
171:12 - type ngc
171:14 - post slash view post
171:16 - to generate the view post component
171:18 - under the post folder so you want to
171:20 - display this component when the user
171:21 - clicks on read post button on the home
171:23 - page
171:24 - so first i am going to add a click event
171:26 - for the read post button in the post
171:29 - style.component.html file which calls
171:31 - the go to post method by taking the post
171:34 - id as input and inside the post style
171:36 - component we first injected the router
171:39 - class from at angular router package and
171:41 - added the method go to post
171:43 - where we have logic to navigate to the
171:45 - url now to make this work we have to
171:47 - define the route to view post component
171:49 - inside the
171:50 - approaching.module.ts file
171:52 - so i have added an entry inside the
171:55 - routes array where we are mapping the
171:56 - path viewpost to the viewpost component
172:00 - the next step is to write the html code
172:02 - for the viewpost component i am going to
172:04 - refer to the written tutorial here and
172:06 - copy the html and css code from there
172:21 - okay now let's see what we have in this
172:22 - viewpost component html file
172:25 - we are displaying the vote button
172:27 - component using the app vote button
172:29 - selector and passing the post object as
172:32 - input to the component
172:33 - we did not yet implement the voting
172:35 - functionality in angular so we will
172:37 - cover this in the next video which will
172:38 - be the final video of the series so
172:41 - moving ahead we have some sections where
172:43 - we are displaying the fields subreddit
172:45 - name username
172:46 - name and description of the post
172:49 - as we saw in the previous episodes our
172:50 - description of the post contains html
172:52 - code generated by the tinymc editor so
172:55 - to render the html we are passing the
172:58 - description to the inner html directive
173:01 - now if we looked into the viewpost
173:02 - component we injected the post service
173:04 - and activated route classes into the
173:06 - component and we are trading the post id
173:09 - which is passed in as a query parameter
173:11 - using the
173:13 - activatedroute.snapshot.params property
173:14 - i am going to access the query parameter
173:16 - id
173:18 - and the value is assigned to the post id
173:20 - variable
173:21 - in the next line we are calling the
173:22 - method post from the post service which
173:24 - takes the post id as input
173:27 - and inside this method we are making a
173:29 - http get call to our backend
173:31 - this method returns an observable of
173:33 - type post model
173:35 - so we are subscribing to this observable
173:37 - in our view component
173:38 - and assigning the response to the post
173:40 - variable
173:43 - the next part is to add the
173:45 - functionality for the users to submit
173:47 - comments i am going to refer to the
173:49 - written tutorial again to copy the html
173:51 - and css code
173:53 - okay the difference here is we added a
173:56 - section to display
173:58 - form to submit comments we named this
174:00 - form group as a comment form and we have
174:02 - an ng submit directory which is calling
174:04 - the post comment method inside the
174:07 - viewpost component we will have a look
174:09 - at this shortly
174:10 - and inside the form we have a text area
174:12 - with the form control name as text and
174:15 - submit button below the text area
174:17 - besides this form we have a section
174:19 - where we are looking through the
174:20 - comments
174:21 - and displaying each comment along with
174:23 - the username of the commenter
174:25 - now let's have a look at the view
174:27 - component
174:28 - and first of all we have declared and
174:31 - initialized the form group called
174:33 - comment form
174:34 - we also declared and initialized an
174:36 - object of type comment payload which
174:38 - contains the fields text post id
174:42 - username and duration
174:44 - these are the fields which are expected
174:45 - as part of the post comment api call
174:48 - so inside the post comment method we are
174:50 - first reading the value from the
174:53 - form control with name text and
174:55 - assigning the value to the text field
174:57 - inside the comment payload object
175:00 - after that we are calling the post
175:02 - comment method inside the comment
175:03 - service
175:05 - i created this service under the comment
175:06 - folder and injected the service to the
175:09 - view component
175:10 - if you go inside the comment service
175:13 - we need the http client class to make
175:15 - the back-end calls so i injected this
175:17 - class into the service
175:19 - and after that there are two methods
175:20 - defined in this service
175:22 - the first one is post comment method and
175:24 - the second one is the get all comments
175:26 - for post method which takes in the post
175:28 - id as input and makes a get call to
175:31 - retrieve all the comments for a given
175:33 - post we are calling the get all comments
175:35 - for post method after receiving a
175:37 - success response back from post comment
175:39 - method call
175:40 - and once we receive a success response
175:42 - we are resetting the value inside the
175:44 - text area to allow a new comment
175:48 - whenever we try to reload the viewpost
175:49 - component we have to load the post
175:51 - information and the comment information
175:53 - from our backend
175:54 - for that reason in the ngoninet method i
175:57 - am calling these two methods get post by
175:59 - id
176:00 - and get comments for post
176:02 - before we go ahead and test our
176:04 - implementation let's have a look at a
176:06 - bug which we have in our token
176:08 - interceptor.ts file
176:10 - if you are following along with this
176:11 - tutorial from the beginning chances are
176:13 - that it's not so hard to replicate this
176:15 - bug
176:16 - in fact we have not one but two bugs
176:18 - let's have a look at them
176:20 - the first one is inside the intercept
176:22 - method where we are retrieving the token
176:24 - from the local storage
176:25 - and inside the add token method we are
176:28 - cloning this request and adding the
176:30 - authorization header
176:32 - we are cloning this request because the
176:33 - initial request object is immutable
176:36 - but we are not passing the clone request
176:38 - but the initial request as it is to the
176:41 - next dot handle method
176:43 - this is causing a 403 error because we
176:46 - are passing an invalid jwt and expired
176:48 - jwt
176:49 - to the back end the second one is inside
176:52 - the handle errors method
176:54 - if we try to make multiple http calls at
176:56 - the same time at that point of time the
176:59 - auth token is expired we will try to
177:01 - refresh the token multiple times
177:03 - in this case we added an if condition we
177:06 - allow the reference token request only
177:08 - if there isn't any existing reference
177:10 - token process going on
177:12 - so in our case the first request wins
177:14 - and request a refresh token but the
177:16 - second request will fail silently to fix
177:19 - this bug we will add an else condition
177:21 - and we will use the filter on the
177:23 - behavior subject until we receive a
177:25 - non-null response then accept the first
177:27 - entry in the behavior subject using the
177:29 - take method and finally we will use the
177:32 - switch map method to take the new token
177:35 - and use it to make the request
177:55 - now let's go ahead and start our angular
177:57 - application using the ng serve command
177:59 - by going to the address localhost 4200
178:02 - so you can see there is only one post in
178:04 - the database right now because there
178:06 - were some test data issues because of
178:09 - missing references of the foreign keys
178:11 - so i have just cleaned up all the posts
178:13 - in the database and tried to create
178:15 - recreate them from the ui i also suggest
178:17 - you to do the same
178:19 - so i'm going to click on the read post
178:21 - button and here you can see all the post
178:23 - information
178:24 - the comments which i've already created
178:26 - before so let's try to create one more
178:28 - comment
178:29 - and you can see all the comments are
178:31 - loaded successfully without the need to
178:33 - refresh the viewpost component
178:41 - now the next task is to display the
178:43 - username in the header section
178:45 - right now we are always displaying the
178:47 - login and sign up buttons
178:49 - so before we make any changes we have to
178:51 - install one library called ng bootstrap
178:54 - we will use the drop down menu in this
178:55 - library so let's install this library
178:58 - using the following command
179:00 - i'm going to reference an image here
179:02 - because i've already installed this
179:03 - library but you can first we ran
179:06 - first we are going to run the npm
179:08 - install save ng bootstrap command and
179:10 - after that i run the and after that we
179:13 - are going to run ng add angular localize
179:16 - command because there are some
179:17 - compatibility issues for the
179:19 - internationalization future between
179:20 - angular 9 and ng bootstrap library after
179:23 - running these commands we have to enable
179:25 - ng bootstrap in our application by
179:26 - adding the ngb module to the
179:29 - appmodule.ts file
179:32 - now we are ready to make the changes so
179:34 - i'm going to open the written tutorial
179:36 - and under the section displaying
179:38 - username in the header section go to the
179:40 - header component html and css files
179:44 - copy the code and paste it into the
179:46 - respective files
179:49 - so we basically updated the header
179:50 - component by adding a drop down from the
179:52 - ng bootstrap library we are displaying
179:55 - this drop down based on the value of
179:57 - ease logged in flag if the flag is true
179:59 - we are displaying the drop down and the
180:01 - options in the drop down are profile and
180:03 - log out
180:04 - so we have some functions defined
180:05 - through the click directive
180:07 - we will be implementing the go to
180:09 - profile we'll be implementing the go to
180:11 - user profile function in this video and
180:14 - we'll cover the logout in the next one
180:16 - the user is not logged in we are just
180:18 - displaying the login and signup buttons
180:20 - as we have before
180:22 - alright now let's open the header
180:23 - component.ts file and here we are
180:26 - assigning the value to ease logged in
180:28 - flag
180:29 - through the ease logged in method inside
180:30 - the alt service
180:32 - where we are retrieving the token from
180:34 - the local storage and we will be
180:36 - returning
180:37 - and we are returning a true or false
180:39 - value based on the availability of the
180:41 - token
180:42 - we have also defined the go to user
180:44 - profile method where we have the logic
180:46 - to navigate to the user profile page
180:49 - we don't have this component yet so
180:51 - let's create this component by typing
180:53 - the command
180:54 - ngc user profile
180:56 - in the terminal
180:58 - and once again i'm going to open the
181:00 - return tutorial
181:01 - and i'm going to go to the section
181:03 - displaying user profile and
181:05 - i'm going to copy the html code under
181:07 - the user profile component.html file
181:11 - and copy it inside the project so in
181:13 - this page we should display all the
181:15 - posts and comment information the user
181:17 - has submitted
181:19 - so we have some welcome text here along
181:21 - with the number of posts and comments
181:22 - submitted by the user
181:24 - we are using this we are using this app
181:27 - post style component here because we
181:29 - want to display a list of posts
181:31 - and lastly we are displaying all the
181:33 - comments which are posted by the user
181:36 - to use this post style component inside
181:38 - the user component we have to make a
181:40 - small refactoring
181:41 - in the previous episodes we had the
181:43 - logic to read post from backend inside
181:46 - the post style component
181:47 - now we have moved this logic away from
181:49 - this component so instead of making a
181:51 - backend call this this component
181:54 - receives this pose it should display as
181:56 - an input
181:57 - so as part of this refactoring i also
181:59 - changed the home component now we are
182:01 - reading all the posts inside the
182:02 - constructor and passing them as input to
182:05 - the post tile component
182:07 - we are doing the same thing also in our
182:08 - user profile component if we open the
182:11 - user profile component we are reading
182:13 - the username
182:14 - we are doing the same thing also in our
182:16 - user profile component
182:17 - we are reading the user name from the
182:19 - query params using the activated route
182:21 - class
182:22 - and we are calling the get all posts by
182:24 - user method to read all the posts by the
182:26 - username
182:27 - we are just making yet another http get
182:30 - called to the backend and inside the
182:32 - component we are subscribing to the
182:33 - response and assigning the response to
182:36 - the post variable
182:38 - so we also calculate the number of posts
182:40 - we received and
182:42 - assign it to the post length variable
182:44 - lastly we retrieve all the comments
182:46 - created by this user by making a get
182:48 - call to the backend
182:49 - the same thing applies also here we are
182:51 - subscribing to the observable and
182:53 - assigning the values to the comments and
182:55 - comment length variables
182:58 - so let's open the application and test
183:00 - the what you have implemented
183:02 - so now you can see a nice drop down to
183:04 - the right side and if we click on the
183:06 - profile button nothing happens because
183:08 - we did not update the routing module
183:11 - let's quickly
183:12 - because we did not update the routing
183:14 - module for the user profile path
183:17 - so let's quickly add the entry to the
183:19 - routes array for the path user profile
183:22 - now if you try again we can see the user
183:24 - profile page and here you can see this
183:27 - particular user have logged in has
183:28 - posted one time and commented three
183:31 - times
183:32 - you can also see the post and comment
183:34 - information in this page
183:36 - so all right before we conclude this
183:38 - video i'm going to point out two small
183:40 - changes have done to the back end the
183:43 - first one is inside the get post by user
183:47 - method inside the post controller
183:50 - i forgot to add the path variable
183:52 - annotation
183:53 - so we are going to add this path
183:55 - variable annotation and we are going to
183:57 - rename the
183:58 - input variable from username to name
184:02 - or else you will get an error when
184:03 - trying to call this api
184:05 - so the second one is inside the
184:07 - postmapper class
184:09 - for the post for the method map we have
184:12 - added an additional mapping
184:14 - for the field user
184:16 - so without this mappings if you want to
184:18 - try if we were creating a post it will
184:21 - not save the user information
184:27 - okay we have already created the vote
184:29 - button component in the previous video
184:31 - when refactoring our homepage
184:33 - we have the upward and downward icons
184:35 - and inside the html the click directive
184:38 - for these icons is calling the upvote
184:40 - post and download post methods but as of
184:42 - now we are not doing anything inside the
184:44 - components before starting the
184:46 - implementation we need to create the
184:48 - word service class where we can make
184:50 - backend calls to the vote api
184:52 - so inside the terminal i am going to
184:54 - type ng gs
184:56 - shared slash vote this will generate the
184:58 - vote service class under the vote folder
185:01 - which is inside the shared folder inside
185:03 - the class we are going to first inject
185:05 - the http client class and declare a
185:07 - method vote which makes a post call to a
185:10 - vote api if you open the swagger
185:12 - documentation we need two fields as part
185:14 - of the request payload vote type and
185:16 - post number i have already created a
185:19 - class called as word payload which
185:21 - contains these two fields and field vote
185:23 - type is an enum called as word type
185:26 - where the possible values are upward and
185:29 - downward back to the vote service the
185:31 - vote method takes the
185:33 - payload as an input and here as i said
185:36 - before we are making a post call to the
185:38 - backend now if we look inside the vote
185:39 - button component we have first injected
185:42 - the vote service
185:43 - our service post service and toaster
185:46 - service classes through the constructor
185:49 - we declared and initialized the vote
185:50 - payload object inside the constructor
185:53 - then we have upward post and downward
185:55 - post methods where we are setting the
185:56 - word type for the vote payload object
185:59 - and calling the votes method and this
186:01 - vote method is setting the value for the
186:04 - post id field which is coming as input
186:06 - from the parent components and after
186:08 - that we are calling the vote method of
186:10 - the word service class which returns us
186:12 - an observable and then we subscribe to
186:14 - this returned observable and in the case
186:16 - of a success response we are updating
186:18 - the word details like the vote count and
186:20 - also an indication whether this post is
186:23 - either uploaded or downloaded by the
186:25 - user the upward and downward fields are
186:27 - newly added to the post model this helps
186:29 - us to decide if a post is either
186:31 - uploaded or downloaded by the user if
186:33 - the user is not logged in then we
186:34 - obviously don't see any indication
186:36 - whether the post is supported or
186:37 - downloaded so we are receiving these
186:39 - fields from the backend so let's jump
186:41 - into intellij idea and inside the post
186:43 - response class you can see the two
186:45 - fields upward and downward these two
186:47 - fields are mapped inside the post mapper
186:49 - class under the map to tto method i've
186:51 - added two mappings for each field where
186:53 - we are calling the methods is upwarded
186:56 - and is downloaded which in turn calls
186:58 - the check would type method which finds
187:00 - the latest votes submitted by the
187:03 - given user and compares it to the vote
187:05 - type which is being passed in and we are
187:07 - doing this only if the user is logged in
187:09 - if not we just return false
187:14 - so the next task is to implement logout
187:17 - in our angular application
187:18 - implementing the logout on the front end
187:20 - is a simple task we just have to delete
187:22 - the stored jwt and refresh tokens along
187:25 - with the user information from the local
187:28 - storage
187:29 - after that we will make an api call to
187:31 - the backend to delete the refresh token
187:33 - so that it won't be possible to rotate
187:35 - the json web tokens we can quickly have
187:38 - a look at the swagger documentation so
187:40 - here all we need is a refresh
187:42 - request payload object which we can
187:45 - construct it on the fly so first let's
187:47 - go to the header component html5 where
187:50 - we are calling the logout method inside
187:52 - the click directive of the logo pattern
187:54 - we are just calling the logout method
187:57 - inside the earth service where we are
187:59 - making a post call to our backend
188:02 - this call returns a string as response
188:04 - which we are just logging to the console
188:07 - then we are clearing all the details
188:09 - which are stored in the local storage
188:10 - like the username authentication token
188:13 - refresh token and expiration time
188:16 - as we are in the service i would like to
188:17 - show you a small change added to the to
188:20 - the login method so here after storing
188:22 - the token and the user details in the
188:25 - local storage we are emitting two values
188:27 - from this class the first one is the
188:29 - boolean flag called logged in
188:31 - and the second one is a string called as
188:33 - username so these two output variables
188:37 - are actually used in the header
188:38 - component so you can see these two
188:40 - fields are marked with output decorator
188:42 - we are subscribing to these two fields
188:45 - inside the header component and whenever
188:46 - the user is logged in the earth service
188:49 - emits these values to the header
188:50 - component and we can see the user name
188:53 - and the drop-down information in the
188:55 - header section at the time
188:56 - okay the next task is to protect the
188:59 - secured routes in our angular
189:00 - application that means some of the
189:02 - routes in our application should only be
189:05 - accessible when the user is logged in in
189:07 - angular we have a concept called guards
189:10 - which tells the router whether to allow
189:12 - the navigation to a particular route or
189:14 - not so there are different types of
189:16 - guards but we will use the can activate
189:18 - guard in our scenario to generate a
189:20 - guard we can type the command ng g
189:23 - g
189:24 - auth auth which stands for ng generate
189:27 - guard with the name auth
189:30 - under the auth folder
189:32 - you will be prompted to select the kind
189:33 - of interface you would like to implement
189:35 - as i told before we are implementing a
189:37 - can activate card so you can select the
189:40 - can activate option and press enter
189:43 - now the guard should be created
189:44 - successfully
189:46 - inside the auth guard class i first
189:48 - injected the out service and router
189:50 - classes
189:51 - and inside the can activate method we
189:53 - are first checking if the user is locked
189:55 - in or not by calling the is logged in
189:58 - method from hot service
190:01 - if the user is logged in then we return
190:03 - a value true or else we redirect to the
190:05 - login page
190:07 - all right now the next step is to
190:09 - configure the guards in the app routing
190:10 - module so i am going to open the
190:12 - approaching module.es file and inside
190:15 - the routes array we are going to add the
190:18 - can activate property for the user
190:19 - profile create post and create subreddit
190:22 - components and as this property takes an
190:25 - array and we just have one single value
190:27 - we just have pass in the
190:30 - value auth guard
190:32 - okay we have implemented a lot so let's
190:34 - open our browser and start testing
190:36 - first i would like to check whether the
190:38 - logout is working or not so let's first
190:40 - open the developer console and under the
190:42 - application tab
190:44 - local storage make sure that we have the
190:46 - token and user details
190:48 - now open the application
190:50 - let's log out from the application and
190:52 - check the developer console again
190:56 - you can see that the values are not
190:57 - there anymore so that's good but if you
191:00 - check the home page you don't see any
191:02 - posts or subreddits inside the sidebar
191:04 - section
191:05 - this is because the end points which are
191:07 - supposed to expose this information are
191:09 - secured
191:11 - if the user is not logged in
191:13 - then we don't provide the token as part
191:15 - of the request and we don't get any
191:17 - response back so we have to exclude
191:18 - these two endpoints in our spring
191:20 - security configuration i am going to
191:22 - open intellij one more time and inside
191:24 - the configure method of the security
191:26 - config class let's add entries to permit
191:29 - the calls to the get all subreddit and
191:31 - get all post api
191:33 - notice that i specifically mentioned to
191:35 - permit only the get calls that that
191:38 - means spring will not try to authorize
191:40 - this calls for the token
191:42 - in this way even the visitors can see
191:44 - the post in our application
191:46 - now i'm going back to the visual studio
191:48 - code and here i'm going to show one last
191:51 - change i did to the token interceptor
191:53 - class inside the intercept method i
191:54 - added an if condition where we first
191:57 - check if we have a valid token and the
191:59 - local storage or not
192:00 - if yes then we add this token to the
192:02 - authorization header or else we just
192:05 - send the request without any headers on
192:06 - it in this way we prevent unnecessary
192:08 - errors in the back end because in the
192:10 - previous way we used to always add the
192:12 - authorization header even though the jwt
192:15 - is null or undefined this fix brings us
192:17 - a bit of consistency to our
192:18 - authorization process so now let's go
192:20 - back to the application and now you can
192:22 - see we are able to see the post and
192:24 - subreddits in the home page even though
192:26 - i'm not logged in
192:28 - now let's try to log in
192:31 - and if i try to click on the upward icon
192:33 - you can see the green color
192:35 - and if you try to upload again you will
192:37 - see the error message as a toaster
192:39 - notification saying that we have already
192:41 - uploaded this post so the only possible
192:44 - action is download and if you try to
192:46 - downward again
192:48 - i again see an error message with a
192:50 - different message now that you cannot
192:51 - download the post
192:54 - you can also upload and download from
192:56 - the post page so let's click on the read
192:58 - post button so we can see that the color
193:00 - indication is also visible in this page
193:03 - now let's try to upload and the arrow
193:05 - turns green again so all right that
193:08 - brings us to the end of the episode and
193:09 - also the end of this tutorial series it
193:11 - was very exciting to produce his videos
193:13 - and i appreciate all the encouragement
193:15 - from you guys
193:16 - so thank you very much for that