00:00 - [MUSIC PLAYING]
00:16 - COLTON OGDEN: Hey, good evening.
00:17 - Welcome to GD50 lecture four.
00:19 - This is Super Mario Bros.
00:22 - As seen on the slides
here, though, we're
00:23 - not using the actual Super
Mario Bros. sprite sheet.
00:26 - This is sort of like a rip off.
00:27 - But I found a really
awesome sprite sheet
00:28 - that has all the basic tiles that
we need to get this thing working.
00:33 - There's a link in the distro as
to where you can find it online.
00:36 - I had a lot of fun playing with it.
00:38 - So hopefully, maybe
if you're curious, you
00:40 - can use some of the sprites in there
to go off and do your own thing.
00:43 - But Super Mario Bros.-- the actual game
which this lecture and assignment are
00:48 - based off of-- is the game shown here.
00:51 - I think everybody knows what it is.
00:53 - It's probably the most
famous game of all time.
00:55 - But this game came out in 1985--
00:57 - sort of revolutionized
the gaming industry.
00:59 - It was the game that brought
the gaming industry from a crash
01:03 - in the '70s thanks to a lot
of poor game making policies
01:08 - and companies and low QA standards.
01:11 - It basically took the gaming
crash of the late '70s, early '80s
01:15 - and brought games really back to the
forefront of people's consciousness.
01:19 - This and games like Legend of
Zelda and a lot of other NES titles
01:22 - made Nintendo basically the
dominator of the video games
01:25 - industry in the '80s and '90s.
01:27 - And even today, with games
like Breath of the Wild,
01:29 - they're still doing their thing.
01:31 - This is Super Mario Bros.
01:32 - It's a 2D platformer.
01:34 - And what this basically means is
you control Mario, who's a plumber.
01:38 - He goes around, walks sort of
looking at him from the side.
01:41 - He walks left to right.
01:42 - He can jump up and down.
01:44 - He's affected by gravity.
01:45 - He can hit blocks.
01:46 - He can jump on enemies.
01:47 - He can go down pipes, and
there's a bunch of levels.
01:50 - It was, for its time,
quite a complicated game,
01:53 - and it spawned numerous offshoots
and rip offs and other good quality
01:58 - platformers.
02:00 - While we talk about
Super Mario Bros. today,
02:02 - some of the topics we'll actually
be talking about are tile maps--
02:05 - so how we can take basically
a series of numbers--
02:10 - tile IDs-- and turn
that into a game world.
02:13 - As you can see here, the game is broken
up into blocks of 16 by 16 tiles.
02:20 - You can see the bricks and
the question mark blocks,
02:22 - and the pipes are even all
composed of simple tiles.
02:26 - And they map to IDs.
02:28 - And when you take a 2D table or array
and you just iterate over all of it
02:34 - and render the appropriate
tile at the appropriate x, y,
02:37 - you get the appearance of
existing in some game world,
02:40 - even though it's just composed
of a bunch of tiny little blocks.
02:43 - 2D animation is something
we'll talk about.
02:45 - So far, we haven't
really done any animation
02:47 - at all in terms of at least characters.
02:50 - We'll do that with Mario.
02:52 - He'll have-- our version
of Mario, an alien--
02:55 - when he's moving, he'll have
two frames of animation.
02:58 - The frames of animation--
that's sort of like a flip book
03:00 - if you've ever used one, where
you can see individual pictures.
03:03 - And when you display them
rapidly back to back,
03:05 - you get the appearance of animation.
03:07 - We'll be talking about that.
03:08 - Procedural level generation--
we'll be making all of our levels
03:11 - generate randomly.
03:12 - So every time we play the
game from the beginning,
03:14 - everything will be completely different.
03:16 - We don't have to hard code
a finite set of levels.
03:19 - Everything will be dynamic and
also interesting, in my opinion.
03:23 - We'll talk about the basics
of platformer physics
03:25 - and how we can apply
that to our game world
03:27 - here, because we are just
using a table of tiles,
03:34 - each with an x, y that's hard
coded in the game world space.
03:37 - All we have to really do is take
an x, y of Mario, for example,
03:41 - and then just divide
that by the tile size.
03:44 - And then we get basically
what tile that is
03:46 - in our array at that point in the world.
03:48 - And so it's really easy to do
arbitrary collision detection based
03:53 - on what direction you're going
and not have to iterate over
03:56 - every single tile in your world.
03:57 - Because it's just a simple mathematical
operation to get the exact tile
04:01 - given two coordinates, since
the world is in a fixed space.
04:05 - We'll have a little
snail in our game that
04:07 - walks around and does a
couple of random animations
04:09 - and will go after the player, sort
of like a little basic intro to AI.
04:13 - And then lastly, we'll touch on
things like power ups and game objects
04:16 - and how we might be able to
influence Mario and pick those up
04:19 - and that sort of thing.
04:21 - So first though, a demo.
04:22 - So if anybody is willing
to come up on stage
04:24 - to test out my implementation
of Mario, that would be awesome.
04:29 - James?
04:31 - I'm going to go ahead into here,
so we should be all ready to go.
04:35 - So as soon as you're ready,
go ahead and hit Return there,
04:39 - and you should be up and running.
04:42 - So as a part of having random levels--
04:45 - so currently, we have a green alien.
04:49 - The blocks have a random chance
in this case to spawn a gem.
04:53 - And so once they do,
you can pick the gem up.
04:56 - Either they have a gem or they don't.
04:58 - You can pick it up,
and you get 100 points.
05:00 - As we can see, the world
is sort of shifting
05:02 - based on where James's avatar
is, so it tracks the character.
05:07 - We have some notion of a camera.
05:08 - You're getting unlucky
with the blocks so far.
05:11 - So you can fall down through the spaces,
so you probably want to avoid that.
05:15 - But if you want to
demonstrate doing it--
05:18 - so in that case, we collided
with the two blocks below it.
05:20 - The one on the right had the gem.
05:23 - So go ahead and just fall
down so we can demonstrate.
05:26 - So when we fall down, we
detect whether the player
05:28 - has gone below the world limit,
and then we start him back
05:31 - at the beginning of the game.
05:32 - You can press Enter, it should
regenerate a brand new world.
05:35 - Notice how we have random
holes in the ground.
05:38 - We have random tiles.
05:39 - We have random toppers for them.
05:41 - All the blocks are random.
05:42 - We have snails now.
05:44 - They're sort of chasing after James.
05:45 - He can jump on top of them.
05:47 - There's a lot of little moving
pieces here, but a lot of them
05:50 - are actually pretty simple.
05:51 - And I'll show you very shortly.
05:54 - JAMES: Should I stop?
05:55 - COLTON OGDEN: Yeah, sure.
05:56 - That would be a great point.
05:57 - So thanks, James.
05:58 - Appreciate it.
05:59 - Currently, there is no
notion of a level ending.
06:04 - That's part of the
piece that actually will
06:06 - spawn an object that the player can
interact with to just sort of retrigger
06:09 - a new level, basically.
06:11 - But the whole engine behind this basic
platformer is there, and it all works.
06:18 - And so our goal is seen here.
06:22 - Our goal in this lecture
is to demonstrate
06:24 - how we can get things like a character
that moves around on a screen,
06:27 - and a camera that tracks their
position, and tiles that are randomized.
06:32 - And maybe there are pillars in
the ground, holes in the ground.
06:35 - All of this, again--
06:36 - at least the tiles-- are
stored as just numbers.
06:38 - So all we really need to do is perform
a transformation on a series of numbers.
06:42 - Maybe 1 is equal to a tile being
there, 0 is equal to empty space.
06:48 - And so just by looking at it,
we'll see we go column by column.
06:51 - We can say, oh, maybe there's a chance
to not spawn any tiles along the y
06:55 - column on this x of the world map.
06:58 - Or on this particular y, maybe
instead of spawning the ground level,
07:02 - we spawn a couple above it and
down so that we get a pillar
07:05 - and so on and so forth.
07:06 - And it's just this summation
of these randomizations
07:10 - equals a nice little
variety of game levels.
07:14 - So the first thing we should talk
about really is what a tile map is.
07:18 - And what I've alluded to so far is
you can really think of a tile map
07:21 - as being effectively a 2D
array or a table of numbers.
07:27 - And it's a little more complicated
than that depending on how complex
07:30 - your platformer is, because some numbers
are equal to tiles that are solid
07:35 - or not.
07:36 - So you should be able to check
whether a tile is collidable,
07:39 - meaning that the player or whatever
entity you want to check for
07:42 - can actually collide with it or
07:44 - Not.
07:45 - So obviously, we don't want to
trigger a collision on empty tiles.
07:48 - We want the player to
move freely through those.
07:50 - But if they run up against a wall
or if gravity is affecting them,
07:53 - and they hit tiles below them or above
them, we want to detect a collision
07:56 - and then stop them based on
which direction they're moving.
07:59 - And depending on how complicated
you get with your platformer, maybe
08:02 - you have animated tiles, for instance.
08:04 - So if a tile's animated, it will
display a different frame of animation
08:07 - based on what timer you're on.
08:09 - Really, the sky's the limit.
08:10 - In this case, we'll be fairly simple.
08:12 - Our tiles will mostly just be numbers
with a couple of other traits, which
08:17 - we'll see later on.
08:19 - And this is just an example here of
a very simple map-- just a colored
08:22 - background.
08:23 - We have our character, and then we can
sort of visualize all of those tiles
08:28 - as being just for the
sake of theory 0s or 1s.
08:34 - So tiles0-- so I'll actually get
into a little bit of implementation
08:37 - here as to how we can get
drawing some very simple tiles.
08:41 - So if you're looking at
the distro, in tiles0
08:46 - is going to be where we start off here.
08:47 - And I'm going to go ahead and run tiles0
so we can see what that looks like.
08:53 - So this is just tiles0.
08:54 - It's a much simpler program than what
we just saw, but all we're doing here
08:58 - is just a color in the
background and then tiles.
09:05 - Off the gate, anybody have any ideas
as to what the first step would
09:08 - be if we wanted to implement this?
09:14 - AUDIENCE: Just put the tiles in a loop,
draw them, and then have a background?
09:19 - COLTON OGDEN: So put the
tiles in a loop, draw them,
09:21 - and then have a background.
09:22 - Yes.
09:23 - So basically, if this is
main.lua in our tiles0,
09:29 - first thing we're going to need
is a tiles table to store our--
09:33 - we're not going to be
storing just flat numbers.
09:35 - We'll be storing little mini tables
that have a number in them and ID,
09:39 - so we can say tile.ID
if we have a 2D table.
09:45 - Here, we have an empty table.
09:46 - We're going to populate that.
09:50 - If we're going to draw our tiles, we
are going to need a sprite of some kind.
09:54 - And what I did was I just chopped
out a little segment here.
09:57 - So this is tiles.png.
10:00 - It's just literally one
tile from the main sprite
10:04 - sheet that comes with the distro.
10:05 - And then on the right side is just
transparent so that we can offset--
10:12 - maybe tile ID 1 is equal to solid block,
and then tile ID 2 is equal to empty.
10:19 - And so if we recall generate quads,
we can split up a sprite sheet
10:24 - into however many quads we want to.
10:26 - Let's say this is 16 tiles tall--
10:29 - each tile-- and then the whole
thing are two tiles wide.
10:33 - So it needs to be split
into two separate tiles.
10:36 - We'll just generate quads, and
then we'll have, recall, a table.
10:41 - Each of the indexes
of that table will be
10:45 - a quad that maps to one of these tiles.
10:47 - So number 1 will be
this tile here, number 2
10:50 - will be the transparent
bit over here, and then
10:53 - that's how effectively
our IDs are going to map
10:55 - into what gets drawn onto the screen.
10:57 - The ID is the index into our quad table.
11:02 - So going back into tiles0, we have
here just a map width and height.
11:08 - We're just going to say
generate a map 20 by 20.
11:13 - RBG-- we're just going
to make it random,
11:15 - so we're going to clear the
screen with a random color.
11:19 - And then this is the
quads = GenerateQuads.
11:24 - And notice that we're
passing in tile size here.
11:26 - It's good practice just to
make your tile size a constant.
11:28 - So our tile size in
this entire lecture--
11:31 - they're all going to be 16 by 16.
11:33 - And so since they're symmetrical,
we just pass in tile size TILE_SIZE.
11:36 - And then here is where we
actually end up spawning the map--
11:40 - so nested for loop.
11:42 - y gets 1 to map height,
x gets 1 to map width.
11:47 - Remember, we have to insert a blank
table into the base table that's
11:50 - going to act as our current row.
11:52 - And then in that row, we're
going to add a small at tiles y,
11:56 - because y is going to be up
here-- our current row and ID.
12:01 - And so what we're doing here
is if y is less than 5--
12:07 - meaning we'll just set an arbitrary
point for the ground, basically.
12:11 - If it's less than 5 tiles from the
top, then just make it the sky.
12:15 - And so sky-- up here on
line 24, 25-- we just
12:19 - set two tile IDs, as I said before.
12:20 - Sky is 2, so it's going to be
on the right side of the sheet.
12:23 - And then ground is one.
12:24 - It's going to be the very first
quad generated in the sheet.
12:28 - So if y is less than 5, that
ID should be equal to sky else
12:33 - it should be equal to ground.
12:35 - And so down here is where
that comes into play.
12:38 - We're going to clear the
screen with our random color.
12:41 - We're going to iterate over
the loop, as James said.
12:44 - We're going to get
the tile at tiles y x,
12:47 - and then we're just going to draw the
sheet and the quads at that tiles ID.
12:53 - And then recall, since tables are 1
indexed but coordinates are 0 indexed,
12:58 - we take the x and the
y, subtract 1 from them,
13:01 - and then we just multiply
them by tile size.
13:03 - And that has the effect of
drawing each of those tiles
13:07 - at their respective point
in the world and making
13:10 - it seem as if we have this
world-- this bunch of bricks
13:14 - with a random background every time.
13:17 - Which isn't all that interesting,
but just a little bit more variety.
13:20 - And so that's the very
basic gist behind it.
13:22 - I mean, it's essentially almost the same
thing as what we did in match three,
13:26 - where we just mapped the
individual tiles that
13:29 - were in the grid to indexes in the tile
sheet based on the color and variety.
13:38 - Only this time, they're always
going to be in the exact same place,
13:41 - so we don't have to worry
about whether their x and y are
13:43 - different from their grid y and grid x.
13:45 - We're not maintaining
a reference to those.
13:48 - And so that's static tiles.
13:49 - Does anybody have any
questions about how we just
13:52 - draw static tiles to the screen?
13:53 - Pretty basic stuff.
13:58 - The whole name behind
side scrolling game
14:02 - is that the tiles scroll based
on what we're doing in the game.
14:06 - It can be an auto
scroller, in which case
14:08 - maybe you're an airplane
that's sort of going
14:10 - through a level that's
scrolling automatically,
14:12 - and you're shooting things.
14:14 - And you're not really in
control of where you go.
14:16 - Or it can be like Mario,
where you control an avatar.
14:18 - And you can walk around
and jump and stuff,
14:20 - and the camera will
always be fixed on you.
14:22 - And so the scrolling is just relative
to where your character's x and y are.
14:27 - So I'm going to show you
guys an example of how we can
14:30 - get scrolling implemented in our game.
14:32 - And to do that, the function that
we're really going to be looking--
14:35 - at a new function--
14:37 - is love.graphics.translate(x, y).
14:41 - And so what that does is
effectively just translates
14:45 - Love2D's coordinate system so
that whenever we draw something,
14:48 - it gets automatically shifted by x, y.
14:52 - And so that has the effect of the
everything being sort of skewed
14:58 - based on the x, y that we pass it.
15:00 - And so if we maintain a reference
to where the character is,
15:05 - we can just shift where everything
gets drawn on the screen.
15:09 - And that will have the effect of
it being a camera, but it's not.
15:13 - All we're doing is just
shifting the coordinate system
15:15 - based on some offset--
15:16 - x being in this case where
the players is effectively.
15:19 - AUDIENCE: So it changes the
whole coordinate system?
15:22 - COLTON OGDEN: It does.
15:22 - It shifts everything in the coordinate
system that you draw by the x and y.
15:27 - And so that will basically
affect what's getting rendered
15:31 - into the active window at that time.
15:35 - So I'm going to go ahead
and pull up tiles1 here
15:38 - so we can see how this works.
15:40 - Let me go ahead and
first run the program.
15:44 - So if we're going into
tiles1 in the distro,
15:47 - currently it looks almost identical.
15:49 - But I can move it if I
just press left or right.
15:53 - And so we can see here, this
is where the 2D array of tiles
15:57 - gets cut off here.
15:59 - And then it also cuts off, because
we're only generating a 20 by 20 level.
16:02 - It also gets cut off at the
very right side as well.
16:05 - And these are details you would
normally hide from the user
16:08 - by just clamping the x
between 0 and the right side
16:13 - of the map minus VIRTUAL_WIDTH.
16:17 - And that will have the effect of
whenever you get to this point,
16:19 - it won't let you go right anymore,
and same thing for the left side.
16:22 - Well, all we're doing
right now-- we're not
16:24 - doing it based on the character at all.
16:26 - We're just using keyboard input.
16:29 - So let's go ahead into tiles1.
16:35 - And so the important thing that
we're going to look at is--
16:41 - as I just alluded to, we're
calling love.graphics.translate
16:45 - on some value called cameraScroll.
16:53 - It has to be a negative value,
because if we're moving to the right
16:56 - up here or to the left--
16:59 - if we're moving to the left, camera
scroll basically is going to decrement,
17:02 - so it's going to get less.
17:03 - So we can say the
camera scroll when we're
17:05 - going left is going to be 0 or
less if we're starting at 0,
17:08 - or it's going to decrement.
17:10 - If we press right, camera
roll should increase.
17:14 - If we want the appearance of moving
to the right or moving to the left,
17:19 - you actually have to translate
by the opposite direction.
17:22 - Because if we look at this, and if we
call love.graphics.translate positive,
17:34 - all of this is going to
get moved to the right.
17:36 - So it's going to have the
appearance of us moving left.
17:39 - And if we translate it to the
left by a negative amount,
17:41 - it's going to have the
appearance of us moving right.
17:44 - So if our scroll is positive and
we want to move to the right,
17:48 - we actually have to translate
by a negative amount.
17:52 - And so that's why I'm calling
negative math.floor(cameraScroll).
18:00 - Does anybody know why we're
calling math.floor on cameraScroll
18:04 - instead of just calling
negative camera scroll?
18:09 - Does anybody remember
what math.floor does?
18:13 - So math.floor will return the--
18:17 - it'll basically truncate the
number down to the lowest integer.
18:21 - It will basically take off
the floating point value.
18:24 - Because we're rendering
to a virtual resolution
18:26 - with push, if we basically offset the
translation by a fractional amount,
18:32 - you'll get artifacting.
18:34 - Because it's taking your
window and just condensing
18:37 - your image onto a virtual canvas, you'll
get weird blur and stuff like that.
18:42 - So whenever you draw something and you
have a fractional number for something,
18:48 - and you're drawing it to a virtual
canvas that's been magnified
18:51 - or it's being condensed, just
make sure to math.floor it
18:55 - so you don't get any
weird blur artifacting.
18:58 - If you take this out and experiment
around, or even if in the distro
19:02 - you take it out of the player's
position, you'll see the player
19:04 - will get weird blurry
artifacting and stuff like that.
19:07 - So that's why that's there,
in case you're curious.
19:10 - And so all we're doing
here-- we're just saying
19:12 - if it's equal to left, scroll
the camera left, scroll it right,
19:16 - or basically decrement our camera scroll
and then increment or camera scroll.
19:22 - And then just use the
negative version of that here.
19:25 - You could also just assign
camera scroll equal to positive
19:30 - when you move left and
negative when you move right,
19:32 - and then you could give it the
regular camera scroll here.
19:35 - But it's sort of mentally
flipped in terms of this part.
19:39 - So I just made the decision to decrement
it here when we're pressing left,
19:44 - because we're going less on the x and
then more on the x when we press right.
19:51 - Does this make sense?
19:52 - Anybody have question?
19:52 - AUDIENCE: I have a question.
19:53 - Is there a corresponding
function in JavaScript
19:56 - and in other languages like this where
you can shift a whole coordinate?
20:01 - COLTON OGDEN: Is there an
equivalent function in JavaScript
20:04 - where you can shift the
whole coordinate system?
20:06 - Not in base JavaScript, probably.
20:09 - I'm not too familiar with CSS.
20:10 - There might be a CSS
function that does it.
20:14 - In a lot of 2D game
engines, yes, I would say.
20:18 - And a lot of actual 2D game engines
will have a camera object, which
20:22 - sort of encapsulates this behavior.
20:24 - Love2D doesn't have a
camera, so this is sort
20:26 - of why we're doing this-- is because
it's kind of a lower level game
20:30 - framework, Love2D.
20:30 - It doesn't really give
you as many things
20:32 - right out the gate, which makes it
great for teaching these concepts.
20:36 - But a more robust solution
like Unity or Phaser
20:41 - or a lot of other game frameworks is
that they'll just have a camera object.
20:45 - And you just basically give that
your x, and then you just move that.
20:49 - You basically tell that
to track the player--
20:51 - like camera.trackPlayer
or trackEntityPlayer--
20:55 - and that'll have the same effect.
20:57 - It's a little bit more abstract.
20:58 - It's a higher level
than what we're doing,
21:00 - but it's the same exact
principle underlying.
21:04 - So any other questions
as to how this works?
21:09 - All right, cool.
21:11 - So that's all we're effectively doing.
21:13 - We're just getting a camera scroll,
decrementing it and incrementing it.
21:17 - And then just every frame,
we're translating everything
21:19 - before we draw everything.
21:21 - You have to do the translation before
you draw, because everything that you
21:25 - draw after the translation gets affected
by the new coordinate system change.
21:30 - So that's scrolling.
21:33 - Let's get to actually talking about
drawing a person-- an avatar--
21:37 - more than just a set of tiles, since
that's what the game revolves around.
21:46 - If we look at character0, this
would be our first example here.
21:53 - This is just going to be
a very simple example--
21:57 - charactr0.
22:00 - You guys probably know
how this works already.
22:02 - All we're doing is just drawing
a sprite to the screen--
22:07 - so just love.graphics.draw.
22:09 - We're getting quads from a tile sheet.
22:13 - I believe it's in the slides.
22:15 - The actual sheet is here.
22:18 - So we have this little guy--
22:21 - several frames of animation.
22:22 - It's 16 wide, 20 tall,
and we just take a quad.
22:26 - We split it up into quads first.
22:27 - So we know that it's 16 wide by
20 tall, so we just generate quads
22:32 - on this image by 16 and 20.
22:35 - And then in this
example, all we're doing
22:38 - is taking the first frame, which
is quads1, and just drawing that.
22:42 - As you can see here, we have
a bunch of different things.
22:45 - We have like a crouching
state, and we'll
22:47 - get to more about
animations in a little bit.
22:50 - But here, we have him
climbing up a ladder.
22:53 - But you can see all
these different frames.
22:55 - We'll end up showing how you
can play them back to back
22:57 - and get different animations.
22:59 - But for the sake of this
basic example, all we're doing
23:01 - is just rendering the very first frame.
23:05 - And we can see that--
23:08 - let me make sure I'm in the
right file, which I am--
23:11 - we are getting the character
sheet here on line 43 and 44.
23:17 - And then we have to give him an
x, So characterX, characterY.
23:21 - In this case, we're just
setting him above tile 7,
23:24 - so we do 7 minus 1 times TILE_SIZE
because tiles are 1 indexed
23:29 - but coordinates are 0 indexed.
23:31 - And then we just subtract
the height so that he's
23:33 - right above the tile instead
of right at the tile.
23:38 - And then down here, we
do a love.graphics.draw
23:44 - on, as I said before,
just characterQuads 1.
23:46 - Just a very basic hard coded example.
23:49 - Any questions at all
as to how this works?
23:58 - So now let's say we want him to move.
24:00 - What do we need?
24:01 - What's the next step if we
just wanted him to move?
24:08 - AUDIENCE: Give him an x and y?
24:11 - COLTON OGDEN: Yes, give him an x and y.
24:13 - So yes, so he does have
an x and y already.
24:17 - So if you look at--
am I in the right one?
24:19 - So if you go to character0,
this is character0 still.
24:23 - We have given him an x and y already,
but there needs to be another step.
24:26 - What's the other step involved?
24:32 - So if we wanted to move, we need
to check for keyboard input.
24:36 - And then we need to take his x--
24:39 - we're just going to move
him on the x-axis for now.
24:42 - We basically need to take his
characterX variable up here,
24:47 - and we need to modify that.
24:49 - We can basically do the same thing
that we did down here in love.update.
24:55 - Previously, it was on
the coordinate system--
24:58 - love.graphics.translate.
24:59 - We modified the camera scroll.
25:01 - We set that equal to scroll
speed times delta time.
25:05 - We subtracted or added it.
25:07 - In this case, what we're doing
is we have a new constant called
25:09 - CHARACTER_MOVE_SPEED, and we're
just doing that exact same operation
25:13 - but on characterX
instead of cameraScroll.
25:18 - So the end result of that is
that we have the character here.
25:24 - And then we can move him left
or right, and he go off screen.
25:28 - Now, there's a couple of things wrong.
25:29 - What's wrong?
25:30 - What are some of the things that
are wrong with the scene right now?
25:33 - AUDIENCE: The camera
should move with him.
25:35 - COLTON OGDEN: Camera
should move with them.
25:36 - AUDIENCE: No animation.
25:37 - COLTON OGDEN: Does not have animation.
25:39 - Those are probably the two
real things that are wrong.
25:41 - So camera does not track him,
which is an important thing.
25:45 - Obviously, we want to be able to
maintain a reference to our character,
25:48 - unless we're at the
left edge of the screen.
25:50 - If we're at the left edge of
the screen, this is actually OK.
25:52 - And that's part of the
distro-- is we clamp the x so
25:56 - that it doesn't go past the left edge.
25:59 - But if we're beyond the middle and
not to the right edge of the screen,
26:05 - it should be moving along
with him and vice versa.
26:08 - And then he needs to
animate, so his sprite
26:11 - needs to change every certain number
of seconds whether he's moving.
26:15 - And it has to be only
when he's moving, right?
26:17 - If he's standing still, you
can have an idle animation.
26:20 - Some characters will tap their
foot and do stuff like that.
26:23 - But let's say for the sake of
this example we want him just
26:26 - to stand still when he's idle.
26:28 - And we want him to have an actual
animation when he's moving.
26:31 - We need to take care
of these two pieces--
26:34 - three pieces if you count
the idle animation part.
26:38 - So let's go into character2 and
take care of the first part, which
26:43 - is tracking him.
26:45 - So let me go into character2.
26:47 - Let's run it first so we
can see what it looks like.
26:54 - So now the camera is basically
affixed to the player.
26:58 - In this example, we don't take
care of the left edge issue.
27:01 - In the distro, that's fixed.
27:03 - But we have the basic side scrolling
mechanic-- take a character,
27:09 - follow him.
27:11 - How do you think that
we're accomplishing this?
27:17 - Yes.
27:18 - AUDIENCE: Translate the
drawing against the characterX?
27:22 - COLTON OGDEN: Yes, exactly.
27:24 - And it can't be exactly
the characterX though,
27:28 - because if it is, then the character
is going to be on the left edge, right?
27:31 - So we need to offset our
x that we translate by.
27:35 - We need to basically translate by
his x minus half the screen space
27:40 - plus half the character width.
27:42 - And that will have the effect of
translating it but always keeping
27:45 - that offset half a screen width away
from the player, if that makes sense.
27:48 - And so what we're doing is in
character-- this is character2, right--
27:52 - character2, we're still
doing the same thing we did.
27:58 - Actually, that's the wrong file.
28:01 - We are modifying characterX here.
28:05 - So same thing we did before--
28:07 - multiply the move speed by delta
time and either add or subtract it
28:10 - if we're pressing left or right.
28:12 - But also, here--
reintroducing camera scroll.
28:16 - And we're setting it to, like I said,
characterX minus VIRTUAL_WIDTH divided
28:20 - by 2, half the screen,
and then positive offset
28:23 - of his width divided by 2 so that
he's perfectly right in the center.
28:27 - Because remember,
characters' coordinates
28:30 - are set by their left, not their center.
28:34 - And then we just do what we did before.
28:36 - We translate the scene
based on cameraScroll,
28:40 - and we render him at characterX
characterY using math.floor
28:44 - to prevent him from being at a
fractional point in our world space
28:48 - and then it being blurry and artifacted.
28:50 - And that's sort of it in terms of how
we can get tracking over character.
28:55 - And if you wanted to
track along the y-axis,
28:57 - you could do the exact same thing.
28:58 - Maintain a cameraScroll
x and a cameraScroll y--
29:02 - so keep them separated.
29:04 - And then you would just translate here.
29:09 - So we're passing in 0,
because we don't want
29:11 - to track along the y-axis necessarily.
29:13 - But all you would need to do
is pass in your y cameraScroll.
29:18 - And then you could do
it based on characterY
29:20 - and whether or not
they're above the ground
29:22 - or past a certain point in the sky.
29:25 - So any questions at all as to how
the camera tracking is working here?
29:31 - All right.
29:33 - So we took care of one issue,
which was the lack of tracking.
29:38 - But there was one other issue,
which was he's not animated.
29:40 - All he's doing is just moving
sort of like M.C. Hammer--
29:47 - or is it M.C. Usher?
29:48 - M.C. Hammer?
29:48 - I forget.
29:50 - He's doing that.
29:51 - He's not doing anything.
29:52 - We need to actually animate him so that
he looks like he has some life to him
29:55 - and that you can also
differentiate importantly
29:57 - between two separate states.
29:59 - He can be idle, he's not
moving, and he can be moving.
30:02 - So we should have some
sort of visual feedback
30:05 - as to what's currently going on.
30:08 - So anybody know how we
can go about implementing
30:14 - an animation for our character?
30:16 - What are the pieces that we'll need?
30:18 - AUDIENCE: I guess if
he's moving right, then
30:20 - call a function and a render
that looks through some images?
30:25 - COLTON OGDEN: Yes.
30:26 - So if he's moving right,
then have a function
30:29 - that sort of loops through some images.
30:31 - That is effectively
what we will be doing.
30:34 - We have a class called Animation,
which I've introduced here.
30:37 - And all it basically does
is keep track of-- you
30:40 - pass it in a table, which
has the frames of the sheet
30:44 - that you want to animate over.
30:45 - So we can just pass in--
30:47 - let's go ahead and take a look here.
30:50 - And I referenced the slide
earlier, but all of these
30:53 - are 1, 2, 3, 4, 5, 6, 7, 8, 9,
10-- however many there are,
30:57 - you just pass into the animation.
31:01 - Let's say he's on a ladder.
31:02 - So let's say this is 1,
2, 3, 4, 5, 6, and 7.
31:05 - You say, the frames are
going to be 6 and 7,
31:08 - so those will just loop
left to right, starting back
31:12 - at the beginning when it's finished
And then you give it an interval.
31:16 - So say I want the animation to
happen this fast in terms of seconds,
31:19 - so I want it that maybe
happened every 0.2 seconds.
31:23 - And so that will have the
effect of every 0.2 seconds,
31:25 - it'll keep track of a timer.
31:27 - So have we gone over 0.2 seconds?
31:30 - Start at 0 and then add
delta time to it every time.
31:33 - If we have, increment what our
current frame of animation is.
31:37 - So our current frame is this one,
and then 0.2 seconds elapses,
31:42 - it's going to be this one.
31:43 - And then 0.2 second elapses, and we
need to loop back to the beginning.
31:47 - So we'll end up using
modulus to take care of that
31:49 - as we can see in the Animation class.
31:54 - Basically, that's all done here.
31:55 - So if we have more than one frame of
animation, recall it gets a def here.
32:00 - So we get frames, we get an interval,
get a timer that's initialized to 0,
32:04 - and then get a current frame.
32:05 - We'll say the current frame is 1.
32:09 - And then as long as we
have more than one frame,
32:12 - there's no point in looping
over or trying to animate
32:14 - any animation that only has one frame.
32:16 - And we can, of course, have
animations that only have one frame.
32:20 - Idle is only one frame of
animation, as we saw here.
32:23 - That's only one frame.
32:24 - We don't need to do any
sort of logic to say, oh,
32:27 - what's the next frame, because
there's only one frame.
32:29 - But if we were to look at character3,
we can see two frames there.
32:37 - And then that's just
one, frame he's idle.
32:39 - And when we move left, he
moves in that direction.
32:42 - Anybody recall how we can
get him-- because obviously,
32:45 - we saw the spreadsheet
just a second ago,
32:47 - and there was only one direction
that the sprites were facing--
32:50 - how we can get him to look
that way, even though there's
32:54 - no sprites for him to look that way?
32:57 - AUDIENCE: Flip it on the axis.
32:59 - COLTON OGDEN: Flip it,
so love.graphics.draw.
33:03 - Recall you can pass in a negative
scale factor on whatever axis you want,
33:07 - and that'll have the result of
flipping it along that axis.
33:10 - That's all we're doing.
33:11 - So this is the default frame,
so we're just drawing it.
33:14 - And then we have to keep a reference
to whatever direction he's facing.
33:17 - And if his direction is
equal to right, we'll
33:19 - just draw that frame and then
loop and process the animation.
33:23 - If he's facing left, draw it, but also
perform a negative 1 transformation
33:29 - on the x-axis.
33:30 - And just like that,
we have that working.
33:33 - So all we're doing--
33:34 - just keep a timer.
33:36 - And then when the timer goes over our
interval, just increment the frame.
33:41 - And then use modulus
to loop back over it--
33:44 - back to starting at 1.
33:45 - And that's all done
here on this line 28.
33:48 - And so you can look
in there a little more
33:50 - if you want to get a handle
on how the math works,
33:53 - but it is just a simple sequence of
iterating over a collection of frames
33:58 - based on a timer.
33:59 - And that has the effect-- just like
a flip book, as I said earlier--
34:02 - of our character having an
animation and having some life.
34:06 - So any questions as to how
this animation class works?
34:10 - AUDIENCE: The render is
in the Animate class?
34:12 - COLTON OGDEN: So no.
34:13 - The render is not in the animate class.
34:14 - So the render is--
34:16 - I realize I didn't show
any actual main here.
34:20 - We have two animations here,
which was just the idle one,
34:22 - so we're just passing in one frame.
34:24 - We're going to give it an interval of 1.
34:26 - It's not going to really matter, but
just for the sake of consistency,
34:29 - we're giving it an
interval of 1-- arbitrary.
34:31 - And maybe we want to
change his animation later.
34:35 - So by having an interval here,
we won't forget to add one later.
34:39 - Moving animation-- recall 10 and 11.
34:41 - So it's toward the end of the sheet--
34:43 - the two walking frames.
34:46 - Interval here is 0.2 seconds.
34:48 - We need a current
animation to render him,
34:51 - and then we keep a reference to
whatever direction he's looking at.
34:55 - So if he's looking to
the right, we're going
34:58 - to reference this in the
love.graphics.draw at the bottom.
35:02 - And that's what we're going to
use to perform the sprite flipping
35:04 - along the x-axis.
35:07 - Maintain a reference to that.
35:09 - And then down here, the part that
we actually reference the animation
35:14 - is on line 150 if you're
looking at character1.
35:18 - Or is it character2?
35:20 - Sorry, character3.
35:22 - If you're looking at
line 150 in character3,
35:26 - we're using
currentAnimation:getCurrentFrame().
35:29 - So the class will actually just tell you
whatever the current frame of animation
35:32 - is, because it keeps a reference to
what frame it is based on the timer
35:37 - and how much has elapsed.
35:39 - AUDIENCE: So the class is generating
a different frame real time
35:43 - and plugging it in there.
35:45 - COLTON OGDEN: Yeah.
35:45 - It's maintaining a reference to
whatever the current frame is,
35:49 - and it's in the table of frames
that it got when you gave it
35:51 - the definition up at the top here--
35:56 - lines 51 to 58 where we
create the two animations.
35:59 - Basically, it maintains a reference
to which index in this frame table
36:03 - we're at.
36:04 - So if 0.2 seconds has elapsed, we
start at 1, and then we go to 2.
36:10 - And then we'll go back to 1.
36:11 - And so it'll just basically
return frames, index.
36:15 - And frames index 1 is
10, frames index 2 is 11.
36:20 - And so the function is getCurrentFrame.
36:25 - So characterQuads,
currentAnimation, getCurrentFrame.
36:29 - And then here, because we're
performing an origin transformation--
36:37 - so that's another thing to consider
when you're flipping sprites.
36:43 - When you flip a sprite,
it actually flips along
36:45 - whatever its default origin is.
36:47 - And the default origin of any
sprite is its top left corner here.
36:53 - So if you flip something
along its x-axis,
36:56 - it'll appear here instead
of just flipping in place.
37:00 - So you actually have to set
the origin to its center
37:03 - when you do any sort of in
place flipping of a sprite.
37:07 - So you'll notice in the
code when you're looking
37:10 - at it that we have plus CHARACTER_WIDTH
divided by 2 and plus CHARACTER_HEIGHT
37:16 - divided by 2 on these two here.
37:21 - So we shift where it gets drawn,
and then we shift its origin
37:24 - offsets which are here on line 160.
37:26 - So if you look at
love.graphics.draw, you'll
37:28 - see it has a lot of optional arguments.
37:31 - And these two at the bottom are
the origin offset arguments.
37:36 - And so these only really
come into play when
37:39 - you do some kind of flipping
of a sprite on an axis
37:44 - and you want graphical consistency not
to have it flip one way or the other.
37:50 - Sometimes that's the effect you're
looking for, but in this case,
37:53 - it's not.
37:53 - We want him to literally
stay in the exact same place.
37:56 - So to flip a sprite in
the exact same place,
37:58 - you need a set its origin to
its center, not its top left.
38:00 - Does that makes sense?
38:04 - OK.
38:05 - And also here, 0 is the rotation here.
38:08 - So it's sort of required
if you're going to add
38:11 - this many arguments to the function.
38:13 - But we're testing if direction is equal
to left, we want to flip by negative 1
38:18 - on the x, else just give it 1.
38:22 - So 1 just means default
transformation, so no flipping.
38:26 - And then we don't flip on the y
at all, so that will always be 1.
38:30 - And so that's in a nutshell how you can
get your character to animate and also
38:34 - stay in place when you animate it.
38:37 - So any questions as to how animations or
the origin offsets or any of that work?
38:47 - OK.
38:48 - So we did talk about animations.
38:50 - The last thing we'll talk about
for the character is jumping.
38:53 - So if you recall from Flappy Bird,
how can we get our character to jump?
38:58 - What are some of the pieces we need?
39:02 - AUDIENCE: Key press,
and then the y goes up.
39:07 - And then we have to have gravity.
39:08 - COLTON OGDEN: Yep.
39:09 - So key press is one thing
we need, so check for space
39:14 - is going to be the default key.
39:16 - y goes up, and then check for gravity.
39:19 - So not only do we need y,
but we also need delta y.
39:22 - We need velocity, because gravity
is a transformation on velocity, not
39:29 - strictly on position.
39:31 - So if we go back to
character4, this is sort
39:39 - of a hackish way of
implementing gravity,
39:41 - because we haven't actually
incorporated tile collisions.
39:44 - And I'll defer most of the
implementation for that
39:47 - as to the distro, and I'll
go over with you guys.
39:51 - But right now, we have the
exact same thing we had before,
39:53 - where we have tile scrolling.
39:55 - But if I press space bar, I
go up, and then he comes down.
39:58 - And notice that he has
an animation as well.
40:01 - He has a different frame.
40:02 - So if he's jumping, he's
got a little jump frame.
40:05 - So that means now we
have three animations.
40:07 - We have an idle animation,
we have a moving animation,
40:09 - and then we have a jump animation.
40:11 - So effectively, we have
three states as well--
40:14 - idle state, moving
state, and jumping state.
40:18 - Four states, actually.
40:20 - And also, I noticed a slight bug here
where if you're still in the air,
40:23 - his frame doesn't change.
40:25 - So it actually probably
should stay to that frame,
40:27 - even if he's standing still.
40:28 - But I guess it doesn't matter too much.
40:30 - We also interpret it as a feature.
40:34 - But he's got a couple of
states when he's in the air.
40:40 - There should be two states here.
40:42 - One is jumping state,
and one is falling state.
40:44 - And do we know why the two being
different is an important thing?
40:52 - So if we think about Super Mario Bros.
40:56 - and we think about the differences
between jumping and falling,
41:00 - what are some of the things that change
based on whether Mario is jumping
41:04 - or whether he's falling?
41:07 - How does he interact differently
with the environment, I should say?
41:15 - So if unfamiliar, Mario-- when he
jumps, he can actually hit blocks.
41:21 - So if he's below a block
and he hits a block that
41:23 - has some sort of behavior in it, it
will trigger whatever is in that block,
41:27 - whether it's a coin or whether
it's to destroy the block.
41:29 - And if he's falling, recall if he
lands on top of an enemy like a goomba,
41:34 - he'll destroy the enemy.
41:36 - And so we need to distinguish
between these two states.
41:39 - Because when he's jumping,
he's not able to--
41:43 - when he's actually going up,
he can't attack the enemy.
41:46 - And likewise, when he's falling
down, he can't destroy the block.
41:49 - So even though he's
jumping up in the air
41:52 - and the gravity is
applying a transformation
41:55 - and it all looks like one state,
there's actually two important changes
42:00 - in his state that are relevant.
42:02 - And that's something that
we'll need to pay attention to,
42:04 - and it's in the distro.
42:05 - He has a falling state
and a jumping state.
42:09 - Even though they share
the same animation,
42:13 - they have different behavior.
42:15 - So let's go ahead and look at
the character4 distro here.
42:24 - So what I've done here is I've
added a delta y for the character.
42:28 - So just like in Flappy
Bird when we press space
42:31 - and we made our delta y
go up to negative 50--
42:34 - so instantly shot up pretty
high, because that was getting
42:37 - applied every frame.
42:38 - Same thing here.
42:41 - Once we press space, we're going
to change delta y to negative 50
42:45 - if we go down to right here.
42:53 - So if the key is equal to space, I have
it in the love.keyPressed function.
42:56 - Since we're doing all this in
main.lua just for illustration,
42:59 - things are a little simple.
43:02 - If key is equal to
space and his delta y is
43:05 - equal to 0, what would
happen if we didn't
43:07 - check to see if delta y was equal to 0?
43:09 - AUDIENCE: We double jump in the air.
43:11 - COLTON OGDEN: Yep.
43:12 - We'd be able to jump infinitely,
so we have to do a check for that.
43:15 - We set his dy to JUMP_VELOCITY.
43:17 - JUMP_VELOCITY is a constant up top
on line 29, which is negative 200.
43:26 - And then gravity is equal to 7.
43:29 - And so what we do is we set it
to negative 200-- his delta y--
43:34 - as soon as he jumps.
43:35 - And then every frame down
in update, we basically
43:40 - increment his delta y by gravity.
43:43 - And then we increment his y
by delta y times delta time.
43:50 - And so it'll have the effect
of when he's in the air
43:52 - and he's got a negative
velocity, it'll actually
43:57 - start becoming positive and
positive until it is positive,
44:00 - and then he falls back to the ground.
44:03 - And then the hack that I
was referring to earlier--
44:05 - since we don't have collision detection
implemented in this example yet--
44:10 - is we're just basically
checking to see whether he has
44:13 - gone below what we set the map's floor.
44:17 - And if he has, then set his position,
first of all, to be above that tile
44:22 - here on line 133.
44:23 - And then set his delta y equal to 0.
44:25 - And that will allow us
then to hit space again,
44:27 - because his delta y will be equal to 0.
44:29 - AUDIENCE: So I didn't
see [INAUDIBLE] on it.
44:32 - Looks like there's always gravity, then.
44:34 - COLTON OGDEN: There is
always gravity, something
44:35 - I realized shortly before lecture.
44:37 - But all you would really have to
do is, I think, if character dy--
44:44 - Yeah.
44:45 - You could easily take that out of
there-- just an if statement around it.
44:48 - AUDIENCE: It's just a
waste of resources, right?
44:50 - COLTON OGDEN: It is.
44:51 - I mean, it's not expensive,
because all you're doing
44:53 - is incrementing a variable
by a certain amount.
44:57 - If anything, if you're introducing
an if condition every frame,
44:59 - which is probably the
same if not actually more.
45:01 - I think a branch is more
CPU than just an assignment.
45:06 - I'm not entirely sure about that.
45:09 - AUDIENCE: Interesting.
45:09 - COLTON OGDEN: Yeah.
45:10 - In this case, it doesn't
really have any side effects.
45:13 - But it's a good thing to notice.
45:16 - But now notice that we can just
sort of walk along the floor here,
45:20 - because there's no collision detection.
45:21 - We'll talk about how we implement
a collision detection soon.
45:27 - So one thing that we'll start talking
on-- and we'll take a break fairly
45:31 - soon--
45:32 - is procedural level generation.
45:34 - So I am a big fan of
procedural level generation,
45:36 - and platformer levels are
actually fairly easy--
45:39 - at least in a simple sense--
45:40 - to procedurally generate.
45:43 - And so like with match
three, all we basically
45:47 - did was just loop
through our grid and just
45:48 - say, oh, get a random
color and a random variety.
45:52 - And then with the assignment, it
was a little bit more complicated,
45:56 - where you actually had to check to
see whether you were on level one.
45:59 - And then if you weren't,
then your variety
46:01 - should be maybe a certain amount
depending on how far along you've
46:05 - progressed in the game.
46:09 - With a platformer
level, we have to think
46:13 - about how we can take that grid of tile
IDs and think about it mathematically.
46:21 - How can we get the results of a level,
but make it different every time--
46:26 - introduce some variation, right?
46:30 - And so the solution that I
found that makes the most sense
46:33 - is going column by column.
46:37 - So here, we just have a
bunch of-- this is just
46:41 - a very simple perfect screenshot
to illustrate a very simple way
46:45 - of generating the level.
46:47 - But recall, if we just think about
these tiles here-- these empty spaces--
46:53 - being a 0 and these being a 1, it's
sort of almost like binary in this case.
46:59 - We could just fill the entire thing
with 0 first, just assume empty space.
47:05 - And then we could just column by
column go down and just have a chance
47:10 - every column.
47:10 - OK, do I want to generate a ground here?
47:12 - If I do, start at the
ground level and then just
47:15 - generate earth tiles all the way down.
47:18 - And then go to the next x position,
do the same thing, do the same thing.
47:22 - And then maybe every column of
the world that you're generating,
47:26 - you also have a chance to
generate a pillar like this.
47:29 - So if generate pillar is
true, then I want to spawn--
47:35 - instead of starting the ground
here, I want to start it here.
47:38 - And then maybe you
have a flag that says,
47:41 - OK, not only do I want
to generate pillars,
47:43 - I also want to generate chasms--
47:45 - just empty space,
obstacles for the player.
47:47 - Because if he falls down-- it
goes below the world space--
47:50 - it should be game over.
47:51 - So in that case, you just
say if generate chasm--
47:55 - make math.random 10 or whatever it is--
47:59 - then just go to the next x.
48:01 - Don't even do anything.
48:02 - And that will have the
result of generating a chasm.
48:04 - And so little piece by piece--
48:07 - doing small things like
that has the net effect
48:10 - of generating a lot of
visually interesting, dynamic,
48:14 - and random levels.
48:15 - You never know what to expect.
48:16 - And this is a very basic example.
48:19 - You could go infinitely far with it.
48:21 - However many ideas you
have in terms of how
48:25 - to create obstacles and interesting
levels and scenery for the player--
48:28 - you could absolutely implement that.
48:30 - AUDIENCE: How do you handle if
there's a platform to jump on?
48:35 - You have to have that consistency.
48:37 - COLTON OGDEN: Yeah.
48:38 - So if it's a platform, it depends on
how you want to implement platforms.
48:45 - And actually, I did a
seminar on Super Mario Bros.,
48:47 - and we did platforms as tiles.
48:50 - In this case, we'll have
blocks that are actually
48:53 - what we've denoted as
game objects-- which
48:55 - are a little bit different than tiles.
48:58 - Because they can have arbitrary
sizes, and they don't necessarily
49:00 - have to be affixed to the world grid.
49:02 - But if you were to treat a
platform that was, let's say,
49:08 - two tiles wide as
tiles, all you would do
49:14 - is just basically have a flag up
here that's like, generate platform
49:19 - equals true or whatever--
49:20 - AUDIENCE: And then turn it off after--
49:22 - COLTON OGDEN: Turn it off
after however many iterations.
49:24 - You also need the size of it.
49:25 - You'll need a flag that's like
platform width equals however many,
49:29 - and so you'll just keep a counter.
49:31 - It's like current platform
tile equals 1, 2, 3.
49:35 - And if it's equal to width, then
you don't generate it any more.
49:39 - And that has the effect of
potentially colliding with pillars
49:43 - if you don't account for that.
49:44 - So you can also in your logic say, if
I'm generating a platform right now,
49:49 - don't generate a pillar.
49:50 - But you could generate a
chasm, because the chasm
49:52 - doesn't interfere with your platform.
50:01 - If you don't have platforms as
tiles-- if they're different objects--
50:04 - then you don't have to do it during
the actual world generation phase.
50:07 - You can just test.
50:08 - You can just create a game
object that's a platform.
50:12 - Depending on how complicated
your algorithm is,
50:14 - maybe make sure that it's not next
to a pillar when you generate it.
50:17 - And you could just do that by getting
the tile here and then looking
50:20 - at the next four tiles--
50:22 - something like that.
50:23 - We don't do platforms in this
example, but it's something
50:29 - that you could pretty
easily do with tiles.
50:31 - And slightly more difficult
but also still fairly easy to
50:36 - do with game objects, which
is included in the distro
50:40 - and which we'll touch
on in a little bit.
50:45 - Let's see, we're at level--
50:49 - oh, another couple of things
that I wanted to show before we
50:51 - actually start getting into the
code for how to generate levels.
50:55 - This is the sprite sheet for this whole
project, which is a really cool sprite
51:00 - sheet that I found online.
51:02 - It's in the spirit of
platformers like Mario,
51:04 - and it's got a nice little
mockup here on the right.
51:07 - So I encourage you to
take a look at that
51:08 - and just maybe get some inspiration
and see all the different cool stuff.
51:12 - Tinker around with it if you want to.
51:14 - But as you can see here, there's a
couple of pretty prominent things.
51:17 - We have a ton of tiles.
51:19 - These are all tiles here--
51:20 - different tiles and variations.
51:22 - And then we have a ton
of these toppers here.
51:25 - And so what really helps
this whole demonstration
51:32 - of generating these levels
is the fact that we have
51:35 - so much visual content to work with.
51:37 - And so here, again, are the tiles.
51:40 - Here are the toppers.
51:42 - And then when you take the
two together and then you also
51:46 - have these random backgrounds--
51:49 - these are toppers here,
the top of the tiles here.
51:52 - It's incredibly easy to just have
a sheer abundance of visual variety
51:57 - and interesting things in your
game levels without even--
52:00 - and the algorithms here are very simple.
52:02 - All we're doing is just checking
to generate pillars and columns.
52:06 - I know.
52:07 - I thought it was really cool and helps
illustrate the importance and power
52:13 - of this whole procedural approach
to creating the levels for this.
52:15 - And there's actually not that many
games that take advantage, I think,
52:18 - of procedural level generation
in the platformer genre.
52:21 - Plenty of games like
Minecraft and Terraria--
52:24 - Terraria is a great platformer
that is an example of that.
52:26 - But I don't think I've seen a
really good Super Mario Bros.
52:29 - game that does something like that.
52:33 - Let's see.
52:34 - What time is it?
52:34 - 6:23.
52:35 - Let's take a five minute.
52:37 - And then as soon as
we get back from that,
52:39 - we'll start going into how we actually
can implement the procedural level
52:43 - generation in more detail.
52:45 - All right, welcome back.
52:46 - This is lecture four.
52:47 - And before we took a
break, we were talking
52:49 - about procedural level generation
in the context of platformer levels.
52:54 - So recall, here are just a few examples
that I took pretty quickly of my code.
53:00 - And you can see they have different
backgrounds, different tiles.
53:04 - Sometimes we have chasms,
sometimes we have pillars.
53:07 - We'll be talking about a few ways
to do the tile version of that,
53:12 - because there's two levels here.
53:14 - In the distro, we'll see there are
also things like bushes, for example.
53:18 - We can see in the top
middle there the purple--
53:21 - well, I guess those little purple cacti.
53:24 - And the one right below that, there
is a pillar with a yellow fern on it.
53:28 - Those are separate
objects from the tiles--
53:31 - game objects.
53:32 - But the actual tiles themselves we'll
dig in here a little bit as to how
53:38 - to get those generated.
53:39 - So the first thing we want to look at,
level0, is just some flat levels-- so
53:44 - just basically what we've already done.
53:46 - So I'm going to go ahead
and go into level0.
53:54 - And then if we see here, we
have a simple flat level,
53:59 - just like we did before.
54:01 - Now the tiles are different.
54:02 - And if I press R, they're
randomly generating every time.
54:07 - So you can get a sense of just how
visually diverse this generation looks.
54:12 - Oh, I think that might
have been a bug earlier.
54:14 - I'm not sure.
54:16 - Haven't seen that yet.
54:17 - But we can see here, I'm pressing R.
54:19 - All I'm doing is taking the
array of tiles that we have,
54:26 - and I'm assigning it a
tile set and a topper set
54:30 - in the case of the scope
of this generation.
54:35 - So recall that the topper is
just the top layer sprite,
54:39 - and the tile set is
the tiles underneath.
54:46 - Anybody want to just suggest how I'm
rendering the topper versus the tiles
54:51 - and what's going on there?
54:53 - AUDIENCE: You're just pulling it
from part of the sheet, right?
54:58 - COLTON OGDEN: Yes.
54:58 - Yeah, in a nutshell, I'm
just pulling the toppers
55:01 - from a different part of the sheet.
55:02 - Any idea how I'm storing
information-- what's being stored here
55:05 - to get it to render like this?
55:08 - AUDIENCE: Maybe you just need to
store the position of the topper
55:12 - and know that everything
else is below that.
55:15 - COLTON OGDEN: Yes.
55:16 - So you could store the
position of the topper
55:18 - and know that everything
else is below that.
55:21 - That would work for a flat level.
55:24 - I don't think that would be reliable
for a level that has pillars on it,
55:27 - because the pillars are a higher
elevation than the ground.
55:29 - And then there's also
chasms and stuff like that.
55:35 - So what's going on
here actually is we're
55:37 - storing a flag in the tile that says
whether or not it has a topper on it.
55:41 - And if it has a topper, then
we render not only the tile,
55:45 - but as soon as we render the
tile, we also render the topper.
55:49 - And I won't go too deep
into the code here.
55:54 - But what we're doing to get all these
different tile sets and topper sets
55:58 - too is we have to take all of these
tile sets-- these collections of tiles--
56:04 - and divide them up, right?
56:06 - We have to know that if we want
to render the entire level in tile
56:09 - set one, then we should basically
take this into its own sheet--
56:15 - its own table-- this into its own
table, this into its own table, going
56:19 - left to right actually.
56:21 - And we have basically
four way nested loop.
56:26 - So we go every set on the
x by every set on the y.
56:31 - And then within each of those, we want
to look for every tile along the x
56:36 - and every tile along the
y therein and split up
56:40 - the tile sets so that we can
index into the individual quads.
56:45 - So in the actual code, I won't
go too deeply into it here.
56:49 - But I'll show you where it is if you're
curious to look into how we do that.
56:53 - It's in Mario in Source, util.lua,
which is recall where we before
56:58 - stored our generateQuads function,
which does a simple split on a tile
57:02 - sheet along its x and y based on
whatever width and height you pass in.
57:08 - We have in here also a generateTileSets
function, which takes in the quads
57:14 - from a generateQuads table.
57:16 - So we first generate quads on
all of this or all of this.
57:22 - So we have every single frame of
this divided by 16, which is--
57:26 - I don't know how many that is.
57:28 - 6 by 5 times 10 by 5, 10 by 4--
57:33 - that many quads, so thousands of
quads, I think, if not hundreds.
57:38 - This I'm pretty sure
is thousands of quads.
57:41 - And then we take that
and then divide it using
57:45 - the number of sets along the
x-axis, sets on the y-axis,
57:49 - and then the size of each tile set
along the x and size along the y.
57:53 - We basically divide it using
a four way nested loop here.
57:59 - We basically just divide it up.
58:01 - And then instead of
doing a generateQuads
58:03 - along the entirety of
the picture, we just
58:09 - basically do a 2D slice of
that quad table we get back
58:12 - from the first generateQuads call.
58:14 - So I encourage you to look in
here and experiment with that.
58:18 - You don't need to necessarily know
how it works for the assignment.
58:21 - But that's how we can basically
take a giant sheet like this
58:25 - and easily integrate it into our code.
58:28 - We can just swap in and
out whatever active tile
58:32 - sheet we want to work with,
assuming that everything
58:34 - is cleanly laid out like this, which
is on the part of you or your artist.
58:38 - You want to make sure that everything is
conducive to programmatic organization.
58:44 - Had things been scattered
around in a very awkward way--
58:46 - maybe things were zig zagged or there
were weird spaces or something like
58:50 - that--
58:50 - we wouldn't be able to do something
as clean as what we did here
58:53 - in util.lua with just 63
minus 20 lines of code
58:57 - by getting each individual tile set.
59:01 - So that's an important
consideration if you're
59:03 - looking at creating
assets for your project
59:06 - and you want to do some programmatic
hot swapping of your tile sets.
59:11 - Let's make sure we're in the right--
59:13 - we're not in the right
example here, so we're
59:15 - going to go into level0 into main.
59:23 - And we have constants now for all of
our tile sets and what the height is
59:27 - and how many they are wide by tall.
59:32 - We do it here.
59:33 - We get our regular quads
from our tiles and toppers,
59:36 - so these are just literally every
single tile within that big tile
59:39 - sheet put in one table.
59:40 - And then we just divided
up into tile sets
59:42 - and topper sets here with
generateTileSets function.
59:45 - And then we get a random tile set
and a random topper set here--
59:50 - math.random, number of tile
sets, number of topper sets.
59:54 - And then at the very bottom also,
we have a generateLevel function--
60:00 - 223-- which is going to be built
upon in the next two examples.
60:03 - Level0 is just a flat
level, so it's actually
60:05 - exactly what we saw before, which
was just if y is less than 7,
60:11 - ID should be equal to sky or ground.
60:14 - And then this part is
actually what I was
60:17 - alluding to before with
the topper, because recall
60:19 - we need to store a flag in a
tile to render a topper or not.
60:23 - And it should be whatever the top
tile is in the level on the ground.
60:28 - In this very simple flat
thing, we can always
60:31 - assume it'll be the same y level.
60:34 - In this case, if it's
equal to 7, then topper
60:36 - should be true, otherwise, false.
60:38 - So every tile along y 7 is going
to have topper equals true.
60:43 - And this comes into play up here.
60:46 - If we do love.graphics.draw(tilesheet),
we have not only just tile.ID as we did
60:55 - before, but we have tile sets
indexed into tileset now.
61:01 - So remember, tileset got
a random value between 1
61:03 - and however many tile sets we had that
we spliced out of our massive tile
61:08 - sheet.
61:09 - Now, we just index into that,
and then we index into tile.ID.
61:14 - And tile.ID will then be whatever our
ID is but relative to that sheet, not
61:21 - the whole entire sprite at once.
61:24 - And the same thing for topper.
61:25 - We have a topper set,
we index into topper
61:27 - sets here at the topper set
that we got, and then that's
61:31 - where we'll have the collection of
tiles that form that particular set.
61:38 - And so the two are completely separate.
61:39 - They can be one random color tile with
one random topper, but it's consistent.
61:43 - It's global.
61:43 - We have one topper set and one tile
set that are active at any one time.
61:47 - And if we press R, which
I did up here, then we
61:50 - just reset them to random
on line 139 and 140.
61:52 - Tile set gets a new random number,
topper set gets a new random number.
61:55 - It has the effect of--
61:58 - we can just walk around and
then generate random sets.
62:04 - So pretty simple.
62:04 - And recall again, topper is--
62:07 - because the tile that we're standing
on is y seven, topper equals true.
62:12 - So in that case, that particular top
layer is always going to have a topper.
62:16 - And it gives us a nice
little bit of visual variety,
62:18 - because it actually makes quite
a bit of a difference having
62:22 - a topper versus no topper.
62:23 - And you can also just not
have a topper and consider
62:26 - that a permutation of the toppers
times tiles, like procedural algorithm.
62:33 - That's flat levels.
62:34 - Does anybody have any
questions as to how this works
62:36 - or anything that we're doing here?
62:41 - OK.
62:42 - So things are a little
flat, a little boring.
62:46 - The next step will be actually
introducing one of the things
62:50 - that we can see here in our little
collection of sample levels,
62:55 - like this pillar right
here in the very middle.
62:58 - Does anybody recall how we go
about spawning a pillar as opposed
63:02 - to just flat land?
63:06 - AUDIENCE: For that column, just put
some more dirt down or more tiles down.
63:10 - COLTON OGDEN: Yep.
63:11 - So for that column, just put more tiles
down instead of just the ground level.
63:15 - That's exactly what we're going to do.
63:17 - So I'm going to go ahead
and open up level1 and main,
63:21 - and I'll run the example here as well
just so you can see it looks like.
63:30 - So here we have quite a few.
63:32 - And notice we haven't
implement collision,
63:34 - so we're still walking through them.
63:35 - But they're just random.
63:38 - Their random amount is
up to taste, really.
63:40 - Right here it's pretty
common, so it might be worth
63:43 - lowering the amount a little bit.
63:46 - If you wanted to, you could also maybe
have a flag that says, spawn pillar,
63:51 - and maybe you want a pillar width.
63:52 - You could have anywhere
between one and three tiles.
63:56 - And if its width is greater than
1, then just loop over a few times
64:02 - and just draw that same height a few
times as opposed to just one time,
64:05 - and then set the flag back to false.
64:08 - A lot of things you can do with it.
64:10 - And also, they're a little tall here.
64:12 - For the main distro, I ended up
making them a little shorter.
64:15 - But we'll see how we do
this in the code here.
64:17 - It's going to mostly be down
in our generateLevel function.
64:23 - So what we're doing here--
go ahead and hide that--
64:26 - is we have basically this code here--
64:28 - line 227 to 236.
64:31 - So all we're doing here is just
filling our entire thing with just sky.
64:38 - We're just setting the
entire thing to empty.
64:41 - And now we have a fully
populated 2D array.
64:45 - All we need to do in order
to change a tile-- we
64:47 - don't have to worry about insertions
or adding too many tiles to our array.
64:52 - All we can do now is just directly
change whatever tile exists there.
64:56 - So all we need to do is
starting on line 239,
65:01 - we're going to start doing the column by
column iteration over our entire level
65:05 - and deciding whether we should
generate pillars or not.
65:09 - And we're always going
to generate ground.
65:11 - So here's the flag spawnPillar.
65:14 - And if it's equal to 1, this is going
to basically be assigned to spawnPillar.
65:18 - So math.random(5)==1.
65:20 - We have a 1 in 5 chance
of spawning a pillar.
65:24 - If we just want a pillar, then
pillar gets equal to 4 from 4 to 6--
65:28 - so y gets 4 to 6 effectively--
65:34 - tiles at pillar x, ID ground.
65:37 - And then here's where we
set the topper, recall,
65:41 - because now pillars can be the
top most tile on the surface.
65:47 - But they're above the ground level.
65:49 - So we just basically say, when
we're generating a pillar,
65:53 - if pillar is equal to 4-- which is
the very first tile that we start at--
65:57 - then set topper equal to true here.
65:59 - Otherwise, set it to false.
66:01 - So that's how we can get pillars to
also have toppers and then in this case,
66:06 - we're not generating any chasms yet.
66:08 - So all we're going to do--
66:11 - once we've generated a pillar
on that particular column,
66:15 - we'll just say ground gets
7 until the map height--
66:18 - so towards the very
bottom of the screen.
66:21 - And then we'll just set it to ground.
66:22 - And then topper-- in this
case, we're going to make sure
66:25 - that we're not spawning a pillar.
66:27 - Because if we don't
check this, then it'll
66:29 - also spawn a topper where
the pillar meets the ground,
66:35 - and it'll look a little bit silly.
66:36 - And then we also want to check
that ground is equal to 7.
66:39 - And so all together, that has
the effect of this behavior.
66:44 - And so if we didn't check
for that spawnPillar,
66:47 - we'd have a topper right
below our feet here too,
66:49 - which looks graphically strange.
66:52 - And also, you can see--
66:54 - emergently, we're getting
double width pillars.
66:59 - And that's just kind
of a natural byproduct
67:00 - of a lot of these randomizations.
67:02 - A lot of these procedural algorithms--
67:05 - they'll generate outcomes
that you might not necessarily
67:08 - have anticipated, which
is kind of a cool thing.
67:10 - You didn't necessarily program it to
have pillars that were two tiles wide,
67:15 - but just the nature of randomization--
that's just what you get.
67:18 - And that's another exciting thing
about procedural level generation
67:20 - is that it can surprise even the
person that wrote the algorithm.
67:25 - It's really cool, and it saves
you work having to create levels.
67:30 - So that was pillared levels.
67:32 - Chasm levels-- who can tell
me how we can do chasm levels?
67:37 - AUDIENCE: You just skip a column.
67:40 - COLTON OGDEN: Yep.
67:42 - you skip a column.
67:43 - So at the very beginning,
all we can just basically say
67:45 - is, do I want to generate a chasm here?
67:48 - If I do, just skip.
67:50 - Go to the next iteration of the loop.
67:53 - And so we'll take a look at that.
67:56 - As simple as it is, because Lua
doesn't have the notion of continue--
68:00 - this will be a refresher,
because I believe
68:02 - this was in one of the assignments--
68:04 - it has a goto statement.
68:08 - So basically, same code as
before, starting column by column.
68:13 - x equals one until map width.
68:16 - We have a 1 in 7 chance--
68:17 - just arbitrary.
68:20 - And this should ideally--
68:22 - if you're engineering an entire
large game or application,
68:28 - this would be called
SPAWN_CHASM_CHANCE probably,
68:31 - and just set that to seven somewhere.
68:33 - But we're just setting it to 7 here--
68:35 - just a static magic number, but
magic numbers are generally bad.
68:39 - Goto continue-- and so continue is
here at the very bottom of the loop
68:46 - here, which is this for x = 1, mapWidth.
68:50 - So it will have the effect of skipping
straight to x equals 2 if this at 1,
68:53 - for example.
68:55 - A lot of languages just
simply have continue.
68:58 - Lua does not have continue, so this
is a community established tradition
69:05 - for implementing
continue-like behavior in Lua.
69:07 - You create a label via double colon
with a name and then a double colon,
69:14 - and then you just goto it.
69:16 - And so that's as simple as
it is for generating chasms.
69:18 - And so if we go to level2
and run that, we get chasms.
69:26 - And so now we've got a little bit
of interesting visual variety.
69:30 - It's not spawning a ton
of chasms in this example.
69:33 - It spawned one so far.
69:35 - There's another one.
69:36 - And then sometimes just
emergently, you can get two.
69:38 - See, there we go.
69:39 - We get some interesting
obstacles as a result.
69:41 - It almost looks as if someone
intentionally did that--
69:43 - almost.
69:45 - I would probably, like I said,
shrink the pillar size a little bit.
69:47 - It's a little tall.
69:52 - That's that.
69:52 - That's basic procedural-- in
the context of platformers,
69:56 - that's the mental model
for how we can start
69:58 - thinking about generating obstacles.
70:01 - And there's a lot of different
directions you could go.
70:03 - Let's say maybe you wanted
to generate pyramids.
70:09 - I mean, it's a common thing in Mario.
70:10 - There will be steps,
[INAUDIBLE] set for it.
70:14 - The same implementation
would basically happen here.
70:18 - It would be a little bit
different, because you're
70:20 - doing it on a column by column basis.
70:22 - But you'd effectively
just maintain a reference
70:24 - to something like step
height, and then you
70:27 - would say generate stairs is true here.
70:30 - And then you would just
set step height to 1.
70:32 - So then you add a tile here.
70:34 - You would go from ground level up
until step height, generate a tile,
70:37 - go the next one, and then
increment step height to 2.
70:40 - And then do from ground
until step height--
70:44 - tiles go up.
70:45 - So 1 and then 2 and 3 until you've
gone to stairs width, in which case
70:51 - you stop generating stairs.
70:52 - That's this principle
behind how you could
70:56 - do something a little more complicated.
70:58 - Or pyramids-- same exact
thing, pyramid width.
71:00 - And then you just go until
pyramid width equals--
71:03 - or we're at pyramid width
divided by 2, make it go up.
71:07 - And if we're higher than
that, make it go down.
71:09 - And then you have the effect
of the pyramid approach.
71:12 - Yeah.
71:13 - AUDIENCE: Where are
you putting the column
71:15 - generation if it's a [INAUDIBLE].
71:18 - It's not in the play state.
71:20 - COLTON OGDEN: In this
case, it's all in main.lua.
71:22 - But in the distro, it's going
to be in levelmaker.lua.
71:25 - So we've broken out all
of this functionality
71:28 - into just how we did Breakout.
71:31 - We had the same sort of
thing-- level maker--
71:34 - and it just has levelMaker.generate.
71:35 - And then you give it
a width and a height,
71:37 - and it will generate an
entire level for you.
71:39 - AUDIENCE: An entire level,
but it has to continuously--
71:42 - oh, you generate it all at once?
71:44 - It doesn't generate as you walk?
71:48 - COLTON OGDEN: The question is, does it
generate continuously or all at once?
71:51 - It just generates all at once.
71:53 - So you could implement a--
71:56 - if you wanted to do an infinite runner,
the way you would do that is you
72:01 - would break up your level into chunks.
72:04 - And with infinite runners, usually
you can only move in one direction.
72:07 - So as you go right, your levels that
you've generated before-- they get
72:10 - discarded, so you avoid
memory overconsumption.
72:14 - What you would do is you
would just generate a chunk--
72:17 - maybe a 100 by 20 level.
72:19 - And then you would go
through that, through that.
72:22 - And then when you get to level end
minus maybe like five tiles or 10 tiles,
72:28 - you would generate another one,
append it, put it to the right,
72:32 - and then you would just go
from the left to the right.
72:36 - And you probably would need
some sort of semi-fancy code
72:40 - to splice them together
once you've generated them.
72:44 - Alternatively, you could
just always pad your--
72:47 - no, you probably wouldn't want to pad.
72:49 - I would probably just splice them end to
end and then get rid of x equals 1 100
72:56 - or however many on the left once it's
gone past the left edge of the screen.
73:01 - In this case, to
summarize, it's all static.
73:05 - But you could very easily--
73:06 - not easily, but you could very
well make it an infinite runner.
73:11 - Yeah.
73:11 - AUDIENCE: So we're rendering the entire
level, but we just can't see it all?
73:16 - COLTON OGDEN: The question is,
are we rendering the entire level,
73:19 - but we just can't see it all?
73:20 - The answer is yes.
73:21 - Currently, in this implementation,
we're just rendering the entire level--
73:24 - so tile by tile is getting
drawn to the screen.
73:26 - For small examples like
this, it's not a concern.
73:30 - But for a large level-- like if we
did a Terraria level, for example.
73:33 - Terraria's thousands and thousands
of tiles wide by probably
73:38 - 1,000 or more tiles tall--
73:40 - you want to render only a chunk,
only what you can visibly see.
73:44 - And for that, you could use your
camera offset and then just render
73:49 - from one tile to the left and above
that to one tile below the bottom edge
73:53 - of the camera and to the right of it.
73:55 - Just render that subset of tiles.
73:57 - So you just need a for loop to
iterate over a small section.
74:01 - AUDIENCE: So you can
kind of make an array
74:04 - of what the map's going
to look like and then
74:07 - just render only slices of
the array that you can see.
74:11 - Is that right?
74:12 - If you put a multi-dimensional array
and then you just go through it
74:18 - and render as you go--
is that the thought?
74:20 - COLTON OGDEN: Question
was, you just have
74:22 - a multi-dimensional array
of tiles for your level,
74:24 - and then you just render it as you go.
74:25 - The answer is yes.
74:27 - You would have your overall tiles--
74:29 - your big 2D array of 100 by 20 or
however many thousands of tiles.
74:35 - And then based on wherever
your camera is rendering,
74:38 - it's just a for loop within
that just of a nested amount.
74:41 - So maybe your player is
at x 30 plus 6 tiles.
74:46 - So you would just render from
30 tiles to maybe 45 tiles
74:51 - on x and maybe 10 to 20 on the y--
74:55 - just that chunk.
74:56 - And it's just relative
to where your camera is.
74:58 - You're always rendering
just a small little--
75:00 - basically, it is effectively
a camera at that point.
75:02 - It's rendering a chunk of
the tiles to the screen.
75:05 - AUDIENCE: But in this code, it's not.
75:07 - COLTON OGDEN: In this code, no.
75:08 - The levels here are--
75:10 - it's sufficiently
complicated to introduce.
75:13 - I mean, it's not too
complicated to introduce.
75:15 - It's pretty easy.
75:16 - But the consumption--
the processing here--
75:20 - is very light, because the
levels are fairly small.
75:23 - And even if we did have
really large levels,
75:25 - it's sufficiently small to
not have to worry about it.
75:29 - But if we did get to a point where
your levels were 1,000 tiles or more,
75:33 - and then maybe those
tiles have additional,
75:35 - you just want to squeeze all
the performance possible out
75:38 - of your application.
75:40 - You could look into
just rendering a subset.
75:43 - It's fairly simple to introduce
but just not something
75:46 - that we included in this assignment.
75:50 - Any other questions as to
how this sort of thing works?
75:58 - OK.
76:01 - So far, we've talked about
procedural level generation.
76:04 - We've talked about animation and
rendering and all that stuff.
76:09 - We haven't really talked about
how to do tile collision.
76:12 - And we won't go into a
terrible amount of detail,
76:15 - because the code is a little lengthy.
76:17 - It'll be part of your assignment
to read over it and understand it,
76:19 - but it's in the TileMap
class that we have.
76:24 - Basically, the whole gist
is that because we're
76:29 - on a 2D tile array that's fixed,
it'll always be at 0, 0, at least
76:34 - in the model that we've
currently implemented.
76:37 - We can just convert
coordinates to tiles and then
76:42 - just check to see whether or not
the tiles at whatever that is
76:48 - are solid or not.
76:51 - Let's say we wanted to look at the
top of our character in this case.
76:57 - So if we have our character here.
77:00 - For the sake of illustration, I
put him between two tiles above him
77:04 - just to show why we need to do
this the way that we are doing it.
77:07 - But you take the point here--
77:10 - his very top left, so
player.x and then player.y,
77:14 - which is effectively
their version of 0, 0.
77:17 - And then player.x plus
player.width minus--
77:20 - we do a minus one for
a lot of collisions
77:27 - so that he can walk between
blocks and stuff like that.
77:29 - Because if you don't basically give
him slightly less than the amount--
77:33 - because he's 16 pixels wide, and
the tiles are 16 pixels wide--
77:37 - if he's between two blocks
and he wanted to fall down,
77:39 - he just won't fall down, because
it's still detecting a collision.
77:45 - Because if he's on the hole here--
77:47 - let's say this is the hole,
and these are the tiles here.
77:50 - The x plus the width--
77:52 - it'll trigger a collision on
this tile and this tile still.
77:55 - So basically, you need to minimize
his collision box by one pixel
77:58 - to fit through 16 pixel gaps
essentially is what it boils down to.
78:03 - But the gist behind collision--
78:07 - in this case, this would
only apply when he's
78:09 - jumping, because this is the
only time at which he can really
78:11 - collide with tiles that are above him.
78:13 - You would test for whatever
block falls on this pixel
78:17 - and whatever block falls on this pixel.
78:19 - And if either of them are
solid, you trigger collision.
78:23 - And if not, then there's
no collision at all.
78:25 - So if he's right here, for example--
78:29 - right directly beneath a tile--
it's only going to check one tile.
78:31 - This point and this point are
both going to fall on this tile.
78:35 - But the reason that we want to
check for both points here and here
78:39 - is in the event that he is
beneath two separate tiles,
78:42 - because now this point's
going to check this tile,
78:45 - and this one's going to check this tile.
78:47 - We can't just check this tile,
because if we only check this tile
78:50 - and there was no tile here
but there was a tile here,
78:53 - him jumping would still
not trigger a collision.
78:57 - It would think that it was
only looking here and not here.
78:59 - So for every collision on every
side we do of him effectively,
79:05 - we need to check both corners
of that edge effectively.
79:09 - So when he's jumping,
we turn this point--
79:14 - this x, y-- into a tile by
just dividing it by tile size.
79:19 - So we can say, player.x
divided by tile size plus one.
79:23 - That's going to equal whatever
tile this is on the x.
79:27 - And then same thing for the y--
79:29 - we just divide the y by tile
size, and then we add 1 to it.
79:32 - And that will allow us
to get the exact tile.
79:34 - If we use those x, y that
we get from that operation,
79:39 - we get the exact tile at that y, x index
in our tile's 2D array effectively.
79:44 - So we do that for jump.
79:45 - We check both corners
of the top of his head.
79:50 - We do the same thing for the
bottom, only at that time,
79:52 - we're checking x, and
then y plus height,
79:56 - and then x plus width, y plus height.
79:58 - And then if we're doing the
left edge, what are we checking?
80:05 - AUDIENCE: The bottom left and top left?
80:07 - COLTON OGDEN: We are.
80:08 - So that will be x0, y, and
then x0, y plus height.
80:13 - And then if it's the
right edge, same thing.
80:15 - We check x plus width y, and then
we check x plus width y plus height.
80:23 - And so that's the gist behind
collision detection in the distro here.
80:30 - And you can see it in
Mario if we go to TileMap.
80:39 - Point to tile-- this is
effectively where it happens.
80:49 - On line 32, we're basically returning--
80:52 - this bit of code here--
80:53 - 28 to 30-- is a check.
80:56 - Because we can jump
over the map edge, we
80:59 - won't be able to check at
tile y divided by TILE_SIZE
81:02 - plus 1, x divided by TILE_SIZE plus
one, because those will be nil.
81:05 - Those won't exist,
because he'll literally
81:07 - be outside the map boundaries.
81:08 - Same thing if he goes below it or he
goes beyond the left or right edge.
81:12 - So that's all this code is here.
81:14 - It just makes sure that if we
do go beyond the map boundaries,
81:17 - we return nil.
81:18 - So that way, we can check nil rather
than getting a tile index error.
81:23 - And then on line 32 is the
operation that I just mentioned,
81:26 - which was we take the y--
81:28 - so this x and y that we pass in are
going to be the player's actual x, y.
81:33 - When we pass those in, we're just
going to get the tile at self.tiles,
81:38 - and then effectively y divided by
TILE_SIZE taken down to an integer,
81:43 - and then add 1.
81:43 - Because recall, tables are 1 indexed,
but the coordinates are 0 indexed.
81:49 - So this will result in a 0 indexed
outcome, so we want to add 1 to it.
81:53 - Same thing for here-- math.floor(x)
divided by TILE_SIZE plus 1.
81:57 - So effectively, points to tiles.
81:59 - And then we'll just
get a tile from that.
82:01 - And the tile-- we can just check,
hey, is that tile solid or not?
82:05 - If it is, trigger collision.
82:07 - So that's the gist behind being
able to do it in a platformer
82:12 - where everything is fixed.
82:14 - That's sort of like a
shortcut we can take.
82:16 - Because now, what's the
nice thing about this?
82:19 - What jumps out as being a super
nice thing about this algorithm,
82:24 - imagining that we have, let's say,
10,000 tiles in our game world.
82:35 - So if you look and
see, all we're doing is
82:38 - we're just doing a simple
mathematical operation
82:40 - on what his x and y is, right?
82:44 - What's the alternative to this?
82:46 - If we were doing this
via AABB, for example,
82:50 - we'd have to iterate over
every single tile, right?
82:54 - AUDIENCE: Can you summarize?
82:56 - To avoid iterating over
everything on the screen,
83:00 - you just check the column that
he's in and the column tile?
83:03 - COLTON OGDEN: Yep.
83:04 - So the gist is he's got an x and a y.
83:09 - The x and the y are going to be in
world coordinates, so his x could be 67
83:13 - and his y could be 38
or something like that.
83:16 - They don't map evenly to tiles.
83:17 - But if we divide those by whatever
the tile size is in our world--
83:20 - 16-- that's going to be the exact tile.
83:25 - We also have to add 1 to it, because
the tables in lua are 1 indexed.
83:30 - But we can index our
self.tiles at the x, y
83:34 - that we get from that--
the dividing by 16.
83:36 - And that will be the exact
tile that he's colliding with.
83:43 - We don't have to basically
have a collection of tiles
83:45 - that we iterate over
and check whether they
83:48 - collide with the player using
AABB collision detection
83:51 - like we've done before.
83:52 - Because recall, in Breakout,
we had the bricks, right?
83:54 - They all had their own x, y,
but they weren't on a grid.
83:56 - They weren't fixed.
83:58 - So we had to actually
take them and do an AABB.
84:01 - We had to iterate over them
and perform AABB on them,
84:03 - because there's no deterministic way
to just index at them really quickly.
84:08 - It's the same thing with
arrays versus linked lists.
84:11 - Because arrays-- you can calculate
how far some value is given an index.
84:16 - You have instant access to it.
84:18 - It's an order of one operation
as opposed to a linked list.
84:22 - If you want to try and
get to a particular value,
84:24 - you have to iterate through the
entire thing until you find it.
84:26 - AUDIENCE: Can you just look for the
column that you might be landing on?
84:31 - COLTON OGDEN: You're getting the exact
tile at whatever your x divided by 16--
84:36 - or whatever your tile size is--
84:38 - and your y divided by 16 is.
84:40 - And you're doing it, recall,
for two different points
84:43 - depending on what you're looking for.
84:44 - If you're looking for the tiles
that are above your character,
84:47 - you're going to be
doing it for this point.
84:49 - So whatever this value
is-- his base x, y--
84:53 - whatever that is divided by 16 and
then whatever that is divided by 16.
84:57 - And then that'll get you whatever
tiles are directly above him.
85:00 - It will intersect with whatever
tile intersects with this point
85:03 - and whatever tile
intersects with this point.
85:05 - Same thing with here and here
if we're looking on the left,
85:07 - here, here if we're
looking on the bottom,
85:09 - and here and here if we're
looking on the right side.
85:11 - And we check for collision
after he's already
85:13 - moved so that these points will be
intersected with potential blocks.
85:18 - And that's how we can check
whether it's a collision or not.
85:20 - We do this when he moves and is
in some sort of movement state.
85:26 - AUDIENCE: So you're still
doing collision detection
85:29 - with his actual
coordinates, but you're just
85:31 - narrowing what you're character width--
85:34 - COLTON OGDEN: Yep.
85:36 - we're turning it from iterating
over every single tile
85:39 - to an instant operation, because
we can just mathematically get
85:42 - the exact tiles that
he's at without having
85:45 - to worry about where he is in the map.
85:47 - It's just instant access.
85:50 - And this only works because
we know the tiles are always
85:53 - fixed in the exact same locations.
85:55 - They're always starting at 0, 0.
85:56 - They're always going to be TILE_SIZE.
85:58 - Things get a little
more complicated when
85:59 - we introduce game objects, which
have their own independent x, y.
86:04 - And for those, you do
have to iterate over.
86:06 - You have basically a collection of game
objects or a collection of entities.
86:09 - Let's say we have snails
in the game world.
86:12 - The snails aren't going to be at
some fixed location every time.
86:16 - They can move continuously.
86:19 - So for those, we have to actually
keep them all in a container
86:21 - and then loop through them and say, has
my player collided with any of these?
86:26 - If he has, then trigger a
collision with that snail--
86:29 - kill it or kill the player if he's
in a walking state or a jump state.
86:34 - And if he's in a
falling state, then they
86:36 - should die, because he's
colliding with them from the top.
86:39 - And you narrow down what collision you
check for, as you can see at the bottom
86:43 - here.
86:44 - Tile collision-- when you're
looking above your character,
86:47 - you're only testing that when
you're in the jumping state,
86:49 - because it's the only time you need to.
86:51 - So that's the only point at which you'll
collide with tiles that are above you.
86:55 - When you're in the falling state is
when you'll check for tiles below you.
86:58 - And then you can interact
with tiles to your side
87:01 - when you're in either the
jumping, falling, or moving state,
87:04 - so you should check for left and right
tiles in all three of those states.
87:08 - AUDIENCE: Shouldn't you always test for
beneath you in case you get a chasm?
87:12 - COLTON OGDEN: In case what?
87:13 - AUDIENCE: In case you get a chasm.
87:15 - COLTON OGDEN: In case
you get chasm, yes.
87:21 - You're correct.
87:21 - This should actually be
tested only when in the player
87:24 - falling state and player
walking state, yes.
87:26 - So the question was, shouldn't you
be testing for tiles beneath you
87:30 - when you're walking?
87:32 - And yes-- not just falling,
but walking as well.
87:35 - This one only jumping, this
one falling and walking,
87:37 - and this one for jumping,
falling, and moving.
87:44 - Does that make sense--
87:45 - how we can take the x, y and
sort of turn that into a tile
87:49 - by just dividing it by 16?
87:52 - And do note the plus 1 as well,
because our tiles in our self.tiles
87:56 - are 1 indexed.
87:58 - And so when we divide
x, y by tile size, we're
88:01 - going to get a 0 indexed coordinate.
88:05 - If our x is at 14, we're
within the first tile.
88:10 - But if we divide that by
16, we're going to get zero.
88:13 - So we need to add 1 to that so that
we get the first tile in the array
88:16 - still, which will be
whatever that tile is.
88:20 - So that's how the collision works.
88:23 - It's all implemented in TileMap here.
88:27 - And basically every state that the
player is in, which is in StatesEntity,
88:36 - and then player falling,
idle, jump, and walking--
88:38 - these are all states
that perform this check.
88:43 - They basically do all
the logic that's here
88:45 - at the bottom, which is
testing in the player
88:47 - jumping state, falling state, and moving
state for left or right collision.
88:51 - And then in the falling state,
we check for collision below us.
88:55 - And then in jumping state, we
check for collision above us.
88:57 - That's all done within
the states themselves.
89:01 - But the actual transformation
from pixels to tiles--
89:05 - that's just a function
that we call from TileMap.
89:07 - It's just a utility function.
89:09 - AUDIENCE: What's the
function called again?
89:11 - COLTON OGDEN: It's called pointToTile.
89:13 - So if you're in TileMap on line 27--
89:18 - pointToTile(x, y).
89:19 - And the first little
bit here is just the bit
89:22 - that lets you basically
go outside the map bounds
89:25 - without getting a tile index error.
89:27 - So if it's just outside the tile limits,
less than 0, or greater than width,
89:33 - just return nil.
89:34 - And so you can do a
check on nil to check
89:35 - to see whether TileMap
pointToTile is equal to nil
89:40 - or not when you do the collision.
89:41 - And if it is, then just
don't do anything probably.
89:46 - But assuming that you're within
the tile boundaries, on line 32
89:51 - is where you do that transformation--
the math.floor, recall,
89:54 - because we want to get
integer values for these.
89:56 - We don't want to get
fractional numbers, because you
89:58 - can't index these tiles as fractional
numbers, although I'm not sure.
90:03 - I think you might be able to
in Lua generally-- index a tile
90:06 - by a fractional number.
90:07 - But in this case, we just want integers.
90:10 - So we call math.floor on y
divided by TILE_SIZE plus 1,
90:14 - y divided by TILE_SIZE
then add 1 to that,
90:16 - and then we do the same thing for the x.
90:18 - So that's the operation.
90:20 - And then wherever we want to check for
whatever tiles we want to collide for,
90:23 - we just call pointToTile on
those x and y coordinates.
90:28 - That's the backbone behind all the
tile-based collision in the game
90:33 - effectively.
90:37 - Any questions as to how this works?
90:41 - Yes.
90:41 - AUDIENCE: So you're only
detecting the collision of corners
90:45 - and not the edge itself?
90:47 - COLTON OGDEN: Correct, because you
don't really need to check for the edge
90:51 - if you're taking into consideration
the top and bottom corner,
90:53 - unless your entity is
sufficiently tall that they need
90:57 - to check for more than three tiles.
91:00 - In this case, our entity is
not more than two tiles tall,
91:03 - so we only need to check for
his top left, bottom left.
91:08 - If we're doing a left collision,
top right, bottom right.
91:10 - If we're doing a right collision, his
top left, top right for top and bottom
91:16 - left, bottom right for bottom.
91:17 - If you had an entity that
was eight tiles tall,
91:20 - you need to check every single
tile along his right side, which
91:26 - just means you need to iterate over
his entire height divided by tile size.
91:30 - And then just offset the y that you're
checking for each of those tiles.
91:34 - Does that makes sense?
91:36 - OK, cool.
91:38 - All right.
91:39 - I alluded to this briefly
by mentioning state.
91:45 - I don't know if I alluded so much to
the fact that we're using entities.
91:48 - But in this distro, we're introduced
to the concept of entities.
91:53 - An entity can be almost
anything you want it to be.
91:57 - In this distro, we're
considering entities
91:59 - to basically be anything that's
living or sentient moving around--
92:03 - in this case, the player or snails.
92:04 - Those are entities, and then
they just are subsets of entity.
92:10 - An entity is a very abstract thing.
92:11 - You'll see it in a lot of game
engines and a lot of discussions
92:15 - about how to organize your
game and how to engineer it.
92:19 - Unity is probably the
most prominent adopter
92:24 - of what's called the entity
component system, whereby
92:27 - you have everything in your game.
92:29 - Every single thing in
your game is an entity,
92:31 - and then every entity is
comprised of components.
92:34 - And these components
ultimately drive your behavior.
92:37 - It's sort of like if you're familiar
with composition over inheritance.
92:41 - If you've heard of this as a
software engineering thing,
92:43 - that's effectively the same paradigm.
92:45 - Rather than inherit a bunch of
different things to be your--
92:50 - let's say you have a base monster class.
92:52 - And then you have a goblin
that's a subset of monster,
92:55 - so it inherits from monster.
92:56 - And then you have a goblin
warlord who inherits from goblin,
92:59 - and then you have an ancient goblin
warlord that inherits from that.
93:02 - Rather than have this
nested tree of inheritance,
93:06 - you adopt composition, which
means you take a base container,
93:11 - and then you fill it with
different components that represent
93:14 - what the behavior of your object is.
93:16 - So if you have an entity--
93:19 - let's say you give it
a monster component.
93:21 - And then maybe you also give
it an ancient component,
93:25 - so it's an ancient monster.
93:26 - And maybe you give it
a goblin component,
93:28 - so then it's an ancient monster goblin.
93:32 - And then you give it
a warlord component,
93:33 - so it's an ancient
goblin monster warlord.
93:35 - So it has all the
pieces that make it what
93:36 - it is without you having to create
this crazy chain of inheritance.
93:40 - That's effectively what the model
of an entity component system
93:44 - is versus standard inheritance--
using that to drive
93:48 - the model of your problem.
93:51 - In this case, we're not going
into crazy entity components.
93:53 - But I wanted to bring
it up, because Unity,
93:56 - which we'll be covering in a few
weeks, is entirely component-based.
94:01 - Everything you write in
Unity is a component.
94:03 - And entities, whether they're in
an entity component system or not,
94:08 - form the backbone of most large games.
94:10 - Most games that have
some complexity to them
94:15 - model most of the pieces within
them as entities that have behaviors
94:19 - and do things.
94:21 - And so in this case, entities
are snails and our player.
94:28 - And then separate from the tiles--
94:31 - when we do collision for that--
94:33 - we want to also check collision
on every entity with the player.
94:36 - So we make sure that the player's
collided with the snail in this case,
94:39 - because that's the only other
entities that they can be.
94:41 - But you can have an arbitrary
number of enemies if you want to.
94:47 - If you collide with an
entity-- so just a for loop.
94:49 - So for entity in pairs of
entities, check collision.
94:54 - If you're in the jump state, then die.
94:58 - If you're in the fall
state, kill it, et cetera.
95:02 - When you're doing most of your
entity to entity interaction stuff,
95:06 - that's generally how you'll model it.
95:08 - You'll just iterate over everything
and then just collide everything.
95:11 - Depending on what
collides with what, you'll
95:13 - just collide everything with everything
else and process interactions that way.
95:16 - That's effectively how we do it.
95:18 - We have in the--
95:20 - I believe it's in GameLevel.
95:22 - This maintains a reference
to a table full of entities,
95:28 - a table full of objects.
95:29 - Objects can be-- we'll talk
about that in a second--
95:32 - gems, and blocks, and bushes, and
stuff like that, and then a tile map.
95:40 - For every entity, we just update it.
95:43 - And then for every object, we update it.
95:45 - And then for every object in
objects, we render it as well.
95:49 - And then we render every entity.
95:50 - This is just sort of basic how
you would take a game world,
95:55 - populate it, and then
process and update it.
95:57 - Just containers, tables that maintain
a bunch of references to everything,
96:02 - and then just update them.
96:03 - The actual interaction
takes place in the--
96:06 - because they're dependent
on what state we're in.
96:09 - If you look at all the different states
for the player in the states slash
96:16 - entity folder, you'll see, for example,
on line 62 of the player falling state,
96:23 - we're iterating over every
object in the level.objects.
96:28 - And notice the player has
a reference to its level
96:31 - so that it can access
everything within it.
96:33 - And then within that level,
all the objects are stored.
96:36 - So all it needs to do is just
say, if the object collides
96:38 - the player and the object is
solid, then set our dy to zero,
96:43 - et cetera, et cetera.
96:44 - All this code's actually
pretty easy to read through,
96:47 - so I would encourage
you to take a look at it
96:49 - and just understand how all
the collision and stuff is
96:51 - working between the player, the objects,
the blocks, and things like that--
96:57 - things like blocks are solid,
things like bushes are not solid.
97:01 - But that's the gist.
97:05 - Have a collection of
objects or entities.
97:07 - And then depending on what state
you're in, collide with some.
97:10 - And then depending on the
state, maybe that kills you,
97:14 - maybe that kills the enemy,
maybe nothing happens,
97:17 - maybe you become invincible.
97:18 - Maybe you collide with
a power-up game object,
97:21 - and that power-up triggers your
self.player.invincible is true.
97:26 - And then if
self.player.invincible is true,
97:29 - then maybe you render him
with a rainbow animation.
97:32 - And then in any of the functions where
he would collide and die with an enemy,
97:35 - he no longer dies, he just kills them.
97:38 - So that's sort of the gist behind
how you would interact with objects
97:44 - and how to process it.
97:46 - Game objects are different.
97:50 - Like I said earlier, these are examples
of some of the objects here we can see.
97:54 - The gems on the bottom left
there are all in the distro.
97:58 - If you hit a block-- and
if we have a few minutes,
98:00 - I'll show you really
quickly how that works--
98:02 - if you hit a block, you'll
have a chance to spawn a gem.
98:06 - If you collect the gen-- which means
if you collide with that game object--
98:11 - increment your score 100.
98:13 - These are all other objects that I
didn't have any time to implement.
98:16 - But just off the gate,
just as a mental exercise,
98:21 - how do you think we
could implement a ladder?
98:26 - Yeah.
98:28 - AUDIENCE: You would
just have a climb state.
98:30 - And if the player is touching a
ladder and presses a certain key,
98:34 - they would enter the climb state,
and that would cause them to go up.
98:37 - COLTON OGDEN: Correct.
98:37 - So what Tony said was if
they go onto a ladder,
98:41 - they should go into a climb state.
98:43 - And depending on whether
they're in a climb state
98:45 - or not, if they press a button,
they should go up or down.
98:49 - And then you would check.
98:50 - If they're at the top of the
ladder, get off the climb state,
98:54 - go into a walk state.
98:56 - Or if they're at the bottom of
the ladder, go into a walk state.
98:59 - And that's just another game
object that you just collide with,
99:02 - and then it's a new state for you.
99:03 - Yes.
99:04 - AUDIENCE: You may actually
want it in a fall state,
99:06 - because that way you could have a ladder
that doesn't actually go anywhere,
99:08 - it just gives you height.
99:09 - But you could use that
to jump over wide gaps.
99:13 - COLTON OGDEN: What
Tony said was you could
99:15 - have the ability to jump off a ladder.
99:17 - Is that what you Said Yeah.
99:19 - The ability to jump off a ladder so
that you can then use it as an obstacle.
99:21 - That's absolutely true.
99:22 - Actually, in the mock up that we
saw up here, it's super hard to see.
99:26 - I'll see if I can maybe
zoom in on it here.
99:35 - Mario, Mario, graphics, and
then it's called full sheet.
99:41 - The whole entire sheet that I used for
this lecture is called fullsheet.png.
99:46 - I don't know what that is.
99:49 - So if you zoom in really high
here, we can see effectively
99:56 - what you were alluding to--
99:58 - right here, this little rope thing.
100:01 - I'm guessing for the sake
of this mock up that's
100:03 - what they were trying to illustrate.
100:04 - But you have a game object that
lets you go into a climb state.
100:07 - Whether it's a ladder
or whether it's a rope,
100:11 - just add a new state for the player.
100:15 - If they're in that climb state,
then we have this new animation
100:18 - which we saw in the sheet earlier,
which was their back or their front.
100:21 - And then they just climb
up it and just update it
100:24 - if they're moving up or down the ladder.
100:27 - And then just give them
the ability to jump off.
100:29 - And then when you get to the
top or bottom, just get off.
100:33 - And you could think a lot of the same
thing with a lot of these obstacles,
100:37 - like the spikes here.
100:39 - If you're jumping and you hit
it, you should probably die.
100:43 - And so you would check for if the
object.ID maybe is equal to spikes
100:50 - or whether object.lethal equals true.
100:55 - Same thing with this one.
100:56 - And then some obstacles are completely
cosmetic, like this mushroom here.
101:01 - In the case of the distro,
bushes and mushrooms and cacti
101:04 - and all those sorts of things
are just completely cosmetic,
101:07 - so you can walk through them.
101:08 - They don't trigger collision, but
they're rendered as game objects.
101:11 - They're not part of the tile grid.
101:17 - They don't get processed
in the same way as tiles.
101:19 - They're not stored in the y, x.
101:24 - So that's effectively how we
can start thinking about objects
101:27 - and how to give them behavior.
101:29 - Part of the assignment is
going to be adding a flag.
101:32 - So this flag is in the sprite sheet.
101:34 - So what you'll do--
101:36 - and I'll touch on this at
the end of the lecture here.
101:38 - We're getting close to it.
101:41 - These keys here actually
at the bottom right--
101:44 - so part of the assignment will be to--
101:47 - it's actually right here.
101:48 - So I'll go over it really quickly.
101:50 - Ensure the player always
starts above solid land.
101:52 - So in this case, when James came up
here and ran, you ran the first example.
101:56 - The very first time that
we spawned the game,
101:58 - it generated a chasm right
where the player spawned at x1.
102:06 - And so he just falls to
his death if that happens.
102:11 - Just right off the gate,
anybody have any ideas
102:13 - as to what we could do to check
to see if we're at solid land,
102:16 - assuming that the player's
default start is at x1?
102:21 - AUDIENCE: At that tile,
check if it's solid.
102:24 - If not, then just move it
there over x until it's true.
102:27 - COLTON OGDEN: Yeah.
102:28 - What we probably want to do is
look all the way down the column,
102:31 - because we start towards the top.
102:36 - If we find that there's no tiles
down there-- it's just pure chasm--
102:39 - we probably want to shift the player.
102:42 - And then random keys and locks--
102:45 - let me open up LevelMaker so we can
see what you'll be interacting with,
102:50 - because most of what you'll be
doing actually is in LevelMaker.
102:58 - It does a lot of what we did
before with just math.random,
103:01 - and then it will insert into objects.
103:05 - So objects is a table here.
103:10 - It will insert a game object
depending on some logic.
103:14 - So in this case, if we're
generating a pillar,
103:17 - we have a chance to generate
a bush on the pillar.
103:19 - So if math.random(8) is 1, in this
case, we're already generating a pillar.
103:23 - So we have an additional chance
that's on top of the chance
103:26 - to generated a pillar--
103:27 - so basically, I think it's a 1 in 64
chance on that particular iteration
103:33 - to generate a pillar with a bush.
103:39 - You just add a new
game object to objects.
103:42 - In this case, this is the
constructor for a game object.
103:44 - You give it an x, y, width,
height, and then a frame.
103:48 - And then the frame is relative to
whatever quad table matches the texture
103:52 - string here.
103:52 - So bushes is the texture, and
so whatever quad in bushes
103:56 - you want to give it--
103:57 - in this case, we just gave
it a random frame from that.
104:02 - And then a lot of the same
logic applies to other parts.
104:05 - This is another part where we
generate bushes just on flat land.
104:08 - We have a chance to generate a block--
104:10 - 1 in 10 chance this is a jump block.
104:13 - So here we have texture,
x, y, width, height, frame.
104:16 - Notice that we have
collidable is true, and this
104:18 - is how we can test to see whether
a tile is collidable or not.
104:22 - Hit is false, meaning that
we haven't hit it yet.
104:26 - And if we have hit it, then we do this
code basically-- onCollide gets called.
104:37 - You can see where this gets
called in the collision code for--
104:43 - if we look in Player.
104:52 - Player has check left collisions,
check right collisions,
104:55 - and check object collisions.
104:59 - It doesn't have check
up and down collisions.
105:02 - There is a corner case
for both of those such
105:04 - that the logic had to be duplicated.
105:05 - I forget exactly why.
105:06 - But you basically get a list
of objects that you check for.
105:15 - Oh, the reason why is
because when you get
105:17 - the collided objects when
you're in the jump state,
105:19 - you trigger the onCollide function.
105:22 - So let's go to PlayerJumpState.
105:26 - If we're in the jump state,
this is where we would basically
105:34 - check to see if we've gotten any
objects that collide with the player.
105:37 - If it's solid, call its onCollide
function, object.onCollide, and then
105:41 - we just pass in the
object itself, basically.
105:44 - And so if you go back
to LevelMaker, that's
105:48 - where we write the onCollide function.
105:50 - We write the onCollide function
within the game object here.
105:55 - So we just give it an
onCollide, remember,
105:56 - because functions are
first class citizens.
105:58 - We can just say onCollide
gets function obj,
106:03 - where obj is going to be this object.
106:06 - If it wasn't hit already, one
in five chance to spawn a gem--
106:12 - so going to create a gem.
106:14 - It's got all the same stuff in it.
106:16 - In this case, it has its own
function called onConsume.
106:20 - onConsume takes a player and an object.
106:24 - And then this is all
arbitrary, by the way.
106:26 - You can create whatever
functions you want.
106:27 - These are callback
functions, effectively.
106:31 - We're just going to play the pickup
sound and then add 100 to our score.
106:35 - And then here, in the event
that we did get a gem,
106:38 - we tween it over the
course of 0.1 seconds.
106:41 - We tween its y to be from
below the block to up above,
106:46 - so it has an upwards
animation, effectively.
106:49 - And then we have another
sound that plays.
106:50 - But that's effectively how
we're spawning game objects.
106:53 - Game objects have textures,
x, y, width, height, and then
106:56 - you can give them callback
functions that you then
106:58 - execute wherever it's relevant to you.
107:01 - In this case, you'll only really
need to worry about onCollide,
107:05 - because the assignment is
create random keys and locks.
107:12 - They have to be the same color,
but you can choose them at random.
107:15 - If the player collides
with the key, then he
107:18 - should probably get some flag
that's like key obtained is true
107:21 - or something like that.
107:23 - And then you go to the block
that spawns in the level,
107:27 - so you should spawn a
block with that same color.
107:31 - And then on collide, you should
unlock it, so get rid of the block
107:37 - and then spawn a new game object--
107:40 - the flag.
107:42 - And then that flag will
have its own on collide.
107:44 - And when you collide with
the flag, restart the level.
107:47 - And that's effectively the
gist behind the problem set.
107:51 - So it probably shouldn't take--
107:52 - I would say probably maybe 40 or 50
lines of code probably should do it.
107:57 - AUDIENCE: That game object--
107:59 - was that a class?
108:01 - It's not a table.
108:02 - What is that?
108:03 - COLTON OGDEN: It is a class.
108:05 - There's a GameObject class.
108:06 - A game object is basically-- and I
realize I didn't touch on it too much.
108:11 - In the context of this distro, you
could almost think of it as an entity.
108:18 - In this case, what I've
done is I've differentiated
108:21 - between living things
and non-living things
108:24 - as being entities versus game objects,
which is a semi-arbitrary distinction.
108:28 - But for a small project
like this, it makes sense.
108:31 - For a large project, I would probably
create everything as an entity
108:37 - and then give different
kinds of entities
108:39 - their own behavior and
their own components,
108:41 - sort of like how you do with
an entity component system.
108:43 - AUDIENCE: Are there two ways
to create a class in Lua,
108:46 - one with the curly brackets and
one with regular parentheses?
108:50 - COLTON OGDEN: There is, actually.
108:53 - So the question was, is there more
than one way to create a class in Lua
108:56 - whether it's parentheses
or curly brackets?
108:59 - Yes.
109:00 - I don't think I've ever
actually talked about this.
109:05 - Let's go back to LevelMaker.
109:08 - If you instantiate a
class and that class
109:12 - takes in just a table as its only
argument, you can just pass in this.
109:22 - This effectively is that argument table.
109:25 - You don't need parentheses.
109:27 - It's effectively doing this--
109:30 - same thing, only you don't
need the parentheses.
109:32 - AUDIENCE: And then that's a
table that's being passed in?
109:35 - COLTON OGDEN: Correct.
109:37 - It's just an alternative
form of instantiation
109:40 - on things that only take a
table as their argument for when
109:44 - they get instantiated.
109:45 - AUDIENCE: And you can only
have one table in that case?
109:47 - COLTON OGDEN: Correct, yes.
109:49 - AUDIENCE: Wouldn't it be easier
to create a new class which
109:53 - would have its own set
of game objects so you
109:59 - would create a gem which
would be helper dot gem, which
110:04 - would in turn create a game object?
110:06 - COLTON OGDEN: Can you
say that one more time?
110:08 - AUDIENCE: It's kind of hard to explain.
110:10 - Wouldn't it be easier to
create another class which
110:15 - would have your gem and everything,
and your gem in that class
110:19 - would be a game object?
110:20 - But in this class,
when you wanted a gem,
110:22 - you would say local gem
equals helper class dot gem.
110:27 - COLTON OGDEN: The
question was, wouldn't it
110:30 - be easier to create a helper class that
would allow you to instantiate gems?
110:37 - Possibly.
110:40 - I think if you were going to design
this a little bit more robustly,
110:45 - and if this were going
to be a larger game,
110:47 - then you would just create a
subclass for blocks, gems, et cetera.
110:51 - To shrink the number of files that
we had in the distro and to sort
110:54 - of consolidate everything together
and put all of the level code together
110:59 - in one spot, I decided to just create
GameObject as an abstract class that
111:04 - you could then just create your
own behavior for within the actual
111:07 - constructor-- which is this bit
here, which is just the table--
111:11 - and then allow you to override the
onCollide and onConsume functions.
111:14 - You can actually give it
whatever functions you want.
111:16 - You could give this some arbitrary named
function and then test for it later.
111:22 - This is almost like an
obscure way of inheritance.
111:26 - But I think if I were to engineer this
with the goal of making it a really
111:31 - large game, I would just subclass.
111:34 - I would just create a class for gem,
a class for block, a class for bush,
111:38 - et cetera, et cetera.
111:40 - It wasn't strictly
necessary for this example,
111:43 - so we ended up keeping
everything a little bit
111:45 - more abstract in a sense-- a
little bit more general purpose.
111:52 - But yeah, you could definitely
create classes for those.
111:57 - And if you were in an
entity component system,
112:00 - you could have a consumable component.
112:03 - And then that consumable
component would then
112:05 - allow you to give it some sort of
behavior that affects the player when
112:09 - the player consumes that object.
112:11 - In this case, a gem is a
consumable, so you would just
112:13 - give it a consumable component
with a texture of the gem
112:16 - and then give it a
callback function that
112:18 - just increments the player's score.
112:20 - You could probably put that
in 10 or 15 lines of code.
112:24 - It would be pretty easy.
112:25 - And then blocks would
be a spawner component,
112:29 - so they have a chance to spawn.
112:31 - And then you would pass in that
spawner component a gem maybe,
112:36 - so it would have a chance to spawn the
gem that you passed into the spawner
112:40 - component-- and then also a solid
component to say, oh, this is solid.
112:46 - So if I hit it, I should
trigger a collision
112:48 - and not be able to walk through it.
112:49 - So you just layer on these components.
112:53 - I would encourage you to think
about this way of composing
112:58 - your objects a little bit, particularly
as we get towards Unity, which
113:02 - makes a lot of use of this concept.
113:07 - In short, yes.
113:10 - I think that's pretty much everything.
113:12 - Let me just go ahead.
113:13 - We're running out of time here,
but like I said, one more time--
113:18 - make sure the player starts above
solid land, random color key and lock,
113:21 - and then make sure that when you get
the key, you can unlock the lock,
113:24 - and that spawns the goal.
113:25 - So this is all something you can
just add to the LevelMaker class,
113:30 - and it will all work with
your game level that way.
113:35 - And then you touch the goal
flag, then respawn the level.
113:39 - So today, we talked
about Super Mario Bros.
113:41 - The other big Nintendo
game of that era--
113:44 - arguably one of the greatest
of all time-- is Zelda.
113:47 - So we'll be talking about a very
simple Legend of Zelda game,
113:51 - where we just have a random
dungeon that we can go through,
113:54 - a top down perspective,
fight simple monsters,
113:57 - open chests, blow up
walls-- that sort of thing.
114:00 - We'll talk about triggers and events.
114:02 - And then we'll talk about
hurt boxes, inventory,
114:06 - a very simple GUI for opening
up a menu, and then world states
114:09 - so that we can see which doors
have been blasted open so that they
114:13 - render appropriately and whatnot.
114:15 - And that's it for Mario.
114:16 - Thanks a lot for coming.
114:17 - I'll see you guys next time.