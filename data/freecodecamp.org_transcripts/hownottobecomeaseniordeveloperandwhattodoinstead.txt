00:00 - this talk is titled how not to become a
00:01 - senior developer
00:05 - not to be confused with how to not
00:07 - become a senior developer which is
00:10 - don't just don't do it
00:13 - this suggests that there are several
00:15 - approaches and that some might be better
00:17 - than than the others
00:20 - so when i was when i was writing this
00:22 - presentation it came out as a sort of
00:24 - stream of consciousness
00:26 - thing and it didn't want to conform any
00:29 - other format because the ideas inside
00:31 - are a bit
00:33 - interconnected
00:35 - so i just try to make it as coherent as
00:37 - possible
00:38 - and what i want to do is
00:41 - reveal a little bit uh about how i
00:43 - reason about my work as a vp engineering
00:46 - and the work of
00:47 - our programmers and our field in general
00:51 - and some of these ideas might not apply
00:53 - to you directly and that is fine
00:56 - the point is not in the the details of
00:59 - the ideas really it's in the reasoning
01:01 - about the ideas
01:03 - and i'm hoping to help you get a bigger
01:05 - picture of uh whatever context you're
01:07 - working in right now and your journey to
01:10 - becoming a senior developer
01:17 - so
01:17 - the talk might be slightly
01:19 - mislabeled because
01:21 - i will only talk very briefly about how
01:23 - i think you should not become a senior
01:25 - developers
01:27 - so one of the most
01:28 - popular and
01:30 - according to me probably the most
01:32 - incorrect way
01:34 - is
01:35 - just list out a number of technologies
01:37 - that you should learn and then once you
01:39 - reach the bottom of the list you are a
01:40 - senior developer
01:43 - so i understand that the idea is
01:45 - extremely compelling because
01:47 - it becomes
01:49 - a journey that is bite-sized and
01:51 - gamified
01:52 - and it's just about memorizing new tools
01:55 - and because we are developers we tend to
01:57 - have high learning capacity
01:59 - and a keen interest in what we're doing
02:02 - so the the prospect of just learning
02:03 - some new frameworks or tools is very
02:05 - compelling
02:08 - and i'm not saying you shouldn't learn
02:09 - any technologies
02:11 - of course you need to know
02:13 - something to be able to do work
02:15 - but
02:16 - i think about it as a prerequisite so i
02:19 - like to say that it's required to know
02:21 - these things but it's not sufficient
02:24 - to do a good job
02:27 - and
02:29 - i don't place too much confidence in
02:31 - better tools
02:34 - history has shown that better tools tend
02:36 - to allow us to be bigger and more
02:38 - complex software just as poorly as we
02:41 - were able to build smaller and more more
02:43 - simple software previously
02:46 - and the only thing that's that
02:48 - creates better software is
02:51 - improving the people
02:54 - so as a disclaimer this is some repo
02:56 - that has a developer roadmap
02:59 - and i don't know the person who created
03:00 - it and it's a great thing because it
03:03 - works as a reference for
03:05 - um
03:07 - sort of what the ecosystem looks like
03:09 - right now in terms of technologies
03:11 - so you can use this to get an overview
03:13 - but i wouldn't treat it as a roadmap to
03:15 - becoming a senior developer
03:17 - it's
03:18 - probably a road map to something else if
03:21 - you follow it blindly
03:24 - and that is a trap
03:27 - and that trap is called
03:29 - expert beginnership
03:33 - so if you are
03:34 - if you've been in teaching or education
03:36 - this is
03:37 - the bottom part is
03:39 - a dreyfus model of skill acquisition
03:44 - and when we reach the advanced beginner
03:46 - stage and this is a stage of
03:50 - just accumulating facts and putting them
03:52 - inside us
03:55 - we sort of see a fork in the road
03:58 - and one of the paths leads on to be
04:02 - more competent and beyond uh to become
04:05 - an actual expert
04:07 - and that path involves
04:09 - getting the big picture of what we're
04:11 - doing
04:12 - but is also another path which is the
04:14 - trap into expert
04:16 - beginnership
04:18 - and that is
04:19 - treating it as
04:21 - ourselves as sort of a bucket that just
04:22 - needs to be filled with more and more
04:24 - low-level implementation details
04:29 - and i i think that this simple
04:31 - accumulation of facts is not really
04:33 - enough
04:35 - it has been talked about in the terms of
04:37 - just
04:40 - more and more content
04:42 - but just letting the ideas pass through
04:45 - us without
04:46 - interacting with any of like our
04:48 - reactive parts
04:52 - isn't that
04:53 - hard
04:54 - and we need to let the ideas
04:57 - sort of transform our understanding of
04:59 - what it is we're doing
05:05 - so i show hands who knows about
05:07 - continuous integration
05:10 - okay who does continuous integration at
05:12 - work
05:15 - okay
05:16 - so continuous integration is is the act
05:18 - of
05:19 - bringing the team's
05:22 - systems together and making sure they
05:23 - work together
05:25 - but what is it we're actually
05:26 - integrating
05:29 - it's not really code
05:30 - because that's just making the
05:32 - characters work together
05:34 - we could argue that we're integrating
05:36 - our systems
05:37 - but when we do continuous integration i
05:40 - like to think of it also as an
05:41 - integration of
05:42 - ideas
05:45 - and i
05:48 - i extend this
05:50 - concept to myself as well i constantly
05:53 - to integrate the ideas of others
05:56 - with my current
05:58 - lattice work of ideas
06:01 - and i like to think of this as
06:04 - laying a latticework or weaving a
06:06 - sort of a
06:07 - web
06:09 - of ideas and i think as a junior
06:10 - developer you have an advantage here
06:12 - because you can look at your seniors and
06:15 - you can look at this web and you can see
06:16 - these are the really nice part i'm just
06:18 - going to take that and integrate it into
06:21 - my own
06:22 - but you can also
06:24 - see the thorny parts
06:26 - where
06:27 - the ends don't really meet in in my
06:29 - understanding and in my integration of
06:31 - ideas
06:32 - so you can use that as a counter example
06:34 - and say oh
06:36 - ted is really contradicting himself on
06:38 - these things so i'm going to avoid
06:39 - ending up there
06:41 - whereas for me who has been doing this
06:43 - integration over this for a very long
06:45 - time changing that part might
06:47 - take a lot of work
06:50 - so just be critical and by critical i
06:53 - don't mean
06:55 - being close-minded
06:58 - i come across junior developers who tend
07:00 - to reject everything uh until they have
07:03 - sort of experienced it themselves or
07:06 - inferred the things from first
07:07 - principles
07:09 - but i think this is a bit of a waste of
07:11 - the potential of having mentors and
07:13 - having seniors around you
07:15 - who have experienced things and who can
07:17 - warn you about certain certain mistakes
07:22 - and then of course
07:24 - pick up the ideas that's that are the
07:25 - best ideas you have heard of so far
07:28 - knowing that he will come across
07:29 - something better and then be ready to
07:31 - drop it
07:35 - so that is actually everything i will
07:36 - say about what not to do
07:40 - so the rest of the talk i will be
07:41 - dedicated to talking about
07:44 - things we can do instead how we can
07:46 - reason about our work and i think
07:48 - reasoning about our work is
07:51 - how we can get better at it
07:54 - and this will hopefully eventually allow
07:57 - juniors who are at the advanced beginner
07:59 - stage to graduate the competent stage
08:03 - and i like to start this part by asking
08:06 - a question
08:09 - the question is how long is a string
08:13 - and if you have
08:15 - if you think that this question is
08:16 - nonsensical that is on purpose
08:19 - this particular question is a rhetorical
08:21 - device that's used in my
08:24 - home country which is sweden
08:26 - and we use it as a retort when someone
08:28 - asks us a question that doesn't have
08:30 - enough information or enough context to
08:32 - be answered in any meaningful way
08:35 - and it's often paired with another
08:36 - saying which is the way you ask the
08:38 - question is the way i will answer it
08:42 - and although we all can seem to agree
08:44 - that this question without any
08:46 - supplementary information
08:48 - is quite
08:50 - absurd
08:52 - we see people ask questions like this
08:55 - seriously and people trying to answer
08:57 - them seriously
09:03 - but this question is equally
09:06 - absurd we could we could approach it
09:09 - with sort of an empirical mindset and
09:11 - say that
09:12 - well if there was a best programming
09:13 - language everyone would be using it and
09:15 - there would only be one right
09:16 - which is not true
09:19 - or we can approach it with a rational
09:21 - mindset and
09:23 - see that programming languages seem to
09:25 - necessitate certain trade-offs and how
09:28 - we value those trade-offs determines how
09:31 - good it is or not
09:33 - that is to say
09:34 - it is a subjective evaluation
09:38 - and the third and absolute the worst
09:40 - option is that we can approach it with
09:42 - sort of an emotional mindset where we
09:45 - value our own attachments or
09:47 - affiliations with certain programming
09:49 - programming languages
09:52 - and to me it seems like the first option
09:54 - is is the best one
09:56 - having the empirical mindset we can look
09:58 - at outcomes which is
10:00 - a very powerful
10:02 - manual model to have to reason about the
10:04 - outcomes that we're looking for
10:10 - and a lot of times
10:12 - we don't really have enough data to make
10:14 - an
10:15 - empirical
10:16 - judgment and we need to resort to the
10:18 - the rational
10:21 - the rational mode of reasoning about
10:23 - things
10:24 - but reasoning about things is very
10:26 - thorny place to be
10:28 - because human reasoning is is
10:30 - fundamentally very flawed
10:33 - and especially when the emotional part
10:35 - comes in as well
10:37 - so be very careful that
10:41 - rationalism can very easily turn into
10:43 - sort of
10:45 - religious dogma as well
10:50 - but if we're given the choice i prefer
10:52 - to never have feelings about code or
10:54 - feelings about
10:56 - ideas because it
10:58 - it seems to be a dead end to me it sort
10:59 - of locks my locks me in
11:04 - so whenever i find myself typing in a
11:06 - code review i feel
11:08 - i just tend to stop myself and say
11:12 - why am i feeling anything about this
11:15 - very objective piece of the system
11:17 - uh because it probably means i have some
11:19 - unexplored
11:21 - things there
11:25 - so be candid and question things
11:27 - objectively whenever you can
11:31 - uh
11:32 - i'm
11:33 - i'm going on with the questions here
11:35 - is javascript a bad language
11:38 - who has ever proclaimed that javascript
11:40 - is a terrible language or made jokes
11:41 - about it or used it as an icebreaker
11:46 - okay
11:50 - so most likely the the reason for that
11:53 - was
11:54 - emotional we had some bad experience
11:57 - either first hand or we had heard a
11:58 - story from someone else about how bad
12:01 - their experience was
12:04 - but if we tried the other mindsets
12:06 - empirically javascript is a great
12:07 - language because
12:08 - tons and tons of people are using it
12:10 - successfully for tons and tons of things
12:15 - if we try the rational mindset we can
12:18 - sort of start to articulate
12:20 - what what what our gripes with
12:22 - javascript
12:24 - so we can look at what it's used for we
12:27 - use it for
12:28 - ui
12:29 - so it's invented that's cool we have
12:31 - events in ui
12:33 - but it's general purpose and ui is sort
12:35 - of a
12:37 - specific applications we could probably
12:39 - do with something more specialized
12:42 - uh it's imperative which is not so nice
12:44 - because your eyes tend to lend
12:46 - themselves to a declarative approach
12:49 - so then we can
12:51 - we can revise our judgment that it's a
12:53 - bad language into
12:55 - it's probably a bad philosophical fit
12:57 - for you eyes for the web
13:01 - but it could be a great language if you
13:02 - are building a heavily evented and
13:04 - streaming system for example
13:07 - and this sort of unlocks the trap of
13:10 - that
13:11 - emotion where we
13:13 - look at a word or a name and we have a
13:14 - negative emotion and then we just try to
13:17 - avoid it
13:20 - and i think abandoning these emotional
13:22 - evaluations
13:23 - and resorting to reasoning or
13:26 - empiricism is
13:28 - can yield some very important insights
13:30 - so if we look at this question and we
13:32 - start exploring it
13:35 - it leads to a very important insight
13:36 - that programming is not really one
13:38 - single
13:39 - homogeneous discipline
13:43 - and
13:45 - just because
13:46 - the different disciplines
13:48 - share the common denominator that we
13:50 - write code
13:52 - doesn't mean that they have the same
13:54 - challenges and constraints
14:00 - and i think we should consider them
14:02 - different disciplines
14:04 - as a whole
14:07 - and if you're a games programmer maybe
14:09 - you need to know uh linear algebra by
14:11 - heart
14:12 - if you're a web developer maybe you
14:14 - don't need to know any linear algebra
14:16 - but you need to understand the
14:17 - business domain and you need to be
14:20 - intimately familiar with user behavior
14:24 - if you are building embedded
14:26 - applications maybe you need to be on top
14:28 - of memory management and cpu cycles
14:31 - which is wasted effort in other
14:33 - applications
14:37 - and
14:38 - i like to
14:41 - even say that programming is not about
14:44 - code that much
14:46 - and that might be heresy you'll be like
14:48 - what who is this guy saying that
14:50 - programming is not about code there's
14:52 - this t-shirt that says that
14:54 - programmers are people who turn coffee
14:55 - into code and all true wisdom is found
14:58 - on t-shirts right
15:02 - but i think programming is about code in
15:04 - the same sense that writing is about
15:07 - words
15:09 - it's just a means that we use to express
15:11 - our ideas and what is important are
15:13 - those ideas
15:15 - themselves
15:16 - and i think program is about systems in
15:19 - the same sense that writing is about
15:20 - stories so
15:25 - so just uh when we are while we're at it
15:28 - uh
15:28 - [Music]
15:29 - this
15:31 - this is not really a junior developer
15:32 - question this is like i want to be a
15:34 - developer question
15:36 - so which which language should you learn
15:37 - first
15:38 - any takers
15:42 - it depends
15:48 - on question it could be yes
15:50 - who said that
15:55 - okay just send me your estimate after
15:57 - them
15:58 - okay
15:59 - you should learn english because really
16:01 - we're
16:02 - we're translating
16:04 - problems and ideas from natural language
16:06 - into code and if we cannot
16:10 - articulate those problems or ideas in
16:13 - natural language then we have a really
16:15 - bad starting point it doesn't matter how
16:16 - good we are at rating code
16:22 - so after you learn your first language
16:24 - english and your first programming
16:25 - language what should you learn next
16:29 - maybe maybe
16:31 - if if you are into like 3d programming
16:34 - then that might be a good good idea
16:37 - uh but as well pointed out it's the
16:39 - might be the wrong question
16:41 - we need to ask what i want to do what
16:44 - problems am i solving what kind of
16:46 - programming do i want to get into
16:48 - and don't accept run-of-the-mill
16:51 - universal answers to questions like this
16:54 - because
16:54 - there there tend to be none
16:58 - uh
16:59 - okay so to explore this
17:02 - a bit further we do a show of hands
17:04 - again
17:05 - who here would say they work in a
17:06 - technology company
17:11 - okay and who would say they work in a
17:13 - product company
17:17 - okay i have no idea what the rest of you
17:18 - are doing
17:21 - uh
17:22 - no there are no more options
17:24 - uh but i like to differentiate between
17:26 - the two
17:28 - and by technology company i i tend to
17:30 - mean a company where new technology is
17:32 - invented and where the primary
17:33 - constraint is the technology
17:36 - and by product company i tend to mean
17:38 - companies where
17:39 - we take existing technology and we
17:41 - assemble it
17:42 - into products that solves particular
17:44 - problems for some fields
17:48 - yes
17:49 - so some large companies do both so
17:51 - google is the most
17:53 - google is the most prominent example
17:55 - right
17:55 - they create the technology but they also
17:57 - build products from it because they are
17:59 - large enough to be able to do everything
18:03 - but because the constraints and the
18:05 - challenges are different
18:08 - what's required from you as a senior
18:10 - developer is is different
18:13 - so there's no one path to to senior
18:15 - developership
18:19 - and anecdotally i think
18:22 - this misconception the programming is a
18:24 - single
18:25 - discipline
18:27 - can lead to a
18:29 - sort of lack of work satisfaction
18:31 - so i met
18:33 - a lot of programmers who are quite
18:34 - unhappy and they're jumping from
18:36 - product company to product company
18:39 - and they they
18:41 - they are very into deep technology and
18:43 - they don't realize that
18:45 - uh these companies that they are joining
18:47 - are not like gated playgrounds where you
18:49 - can work with deep tech they are doing
18:51 - something else they are solving other
18:52 - other problems
18:56 - and these product companies tend to be
18:58 - rather open business
19:00 - almost arenas that have human context
19:02 - that might not be interesting to
19:05 - to those
19:06 - purely interested in tech
19:09 - so i'm going to go on and talk about
19:11 - product companies so if you work in a
19:13 - technology company
19:14 - feel free to to follow along
19:18 - uh
19:19 - so i like to think that all product
19:21 - development is is integrated and that is
19:23 - because products have many interfaces
19:26 - so our product interfaces at least with
19:28 - different markets and with different
19:29 - users and with technology
19:33 - which is why we have
19:35 - different teams
19:37 - dealing with those
19:39 - different interfaces
19:41 - so we can have a product owner who
19:43 - interfaces with the market
19:44 - we can have engineering team that
19:46 - interfaces with technology and
19:48 - design team that interfaces with users
19:53 - and these tend to answer different
19:54 - questions so the product owner
19:59 - the designer can answer what should it
20:00 - look like
20:02 - and the developer says how
20:04 - what is the best approach to building
20:05 - this
20:07 - and that work is sort of done in in
20:09 - isolation but i tend to think that
20:12 - the real magic happens in the
20:14 - intersections or what i call the arenas
20:17 - so for example if you have product and
20:19 - development come together
20:21 - product knows how valuable something is
20:22 - and development knows
20:24 - how hard something is to build
20:26 - and then suddenly we know what is the
20:28 - return on investment for building a
20:30 - certain thing which informs when we
20:31 - should build it in what order
20:36 - but this requires us to understand the
20:37 - objectives and and constraints of
20:42 - the other functions as well
20:44 - because if we don't understand their
20:46 - objectives then we cannot make the right
20:48 - compromises or we cannot negotiate when
20:51 - it's appropriate
20:55 - but of course we should obsess about our
20:58 - own objectives the most because those
21:00 - are the ones we need to to defend
21:03 - so
21:04 - what then is the objective of the the
21:06 - development team
21:08 - we could
21:09 - be misled to think that it is value
21:12 - because value is our deliverable
21:17 - what products are already obsessing
21:19 - about value so that seems wrong
21:23 - if our objectives are the same there
21:25 - wouldn't be any need for negotiation in
21:27 - the first
21:28 - place i tend to think the objective of
21:31 - the development team is flow
21:32 - that is
21:34 - we develop we deliver value today and we
21:36 - deliver it
21:38 - continuously
21:40 - and indefinitely
21:43 - and i think we should obsess about that
21:45 - and
21:46 - the biggest threat to flow and
21:48 - the greatest enemy of the development
21:50 - team is
21:51 - complexity
21:53 - and i think all complexity added to our
21:55 - code base needs to be thoroughly
21:56 - examined and tested for necessity before
21:59 - we commit to it
22:02 - this means
22:04 - that solutions to four problems are a
22:06 - big no-no
22:08 - and that applies even if it means adding
22:11 - our own favorite technology or or
22:14 - pattern to to the problem
22:17 - uh because we all have pet solutions and
22:19 - technologies but as professionals we
22:21 - need to
22:22 - sort of stuff them into a drawer and
22:26 - wait until the right problem
22:28 - calls for it
22:30 - because all solutions also come with
22:32 - their own problems and they're no such
22:34 - thing as a free feature or a free
22:38 - framework
22:41 - so i use this chart with business people
22:43 - to illustrate the typical trajectories
22:45 - for flow
22:46 - the red line sort of illustrates what
22:48 - happens if we cut a lot of corners early
22:51 - on in order to achieve some short-term
22:53 - delivery maybe we're not writing any
22:56 - tests we're not really doing any
22:57 - modeling we're just
22:59 - focusing on grinding out features
23:04 - but if we ask the product owner
23:07 - in
23:08 - one month from now would you like eight
23:10 - units of value or one unit
23:12 - they're gonna say eight units
23:14 - uh
23:15 - and it's important for us
23:17 - to protect our objective of flow and
23:19 - explain to the product owner that if we
23:22 - do that we're screwed already
23:28 - which brings us to another question i'm
23:30 - doing these questions just to make sure
23:31 - you're you're awake
23:33 - so assuming we took the red pill and now
23:35 - we're knee deep into the complexity
23:38 - depth and everyone is miserable
23:41 - is it better to rebuild the project or
23:43 - to salvage it
23:45 - so we can do a show of hands how many
23:46 - think it's better to rebuild
23:49 - okay how many think it's better to
23:51 - salvage
23:54 - okay
23:55 - so i've tried both several times
23:57 - and i
23:58 - will tell you the answer
24:01 - so the answer to the question is it
24:02 - better to rebuild or to salvage is no
24:10 - i can tell you that both are extremely
24:12 - miserable experiences and they are
24:14 - demoralizing and soul crushing and
24:18 - it's not something you want to go
24:19 - through
24:23 - so the answer is for us to to sort of
24:27 - maintain our professional integrity and
24:29 - defend our objective before it can
24:31 - happen
24:32 - and this this is extremely hard uh
24:35 - and it can't protect us from legacy code
24:37 - bases that came in like from from
24:40 - elsewhere
24:41 - but i think it's the only way to be
24:44 - part of the
24:45 - solution
24:49 - so in practice this involves deciding on
24:51 - some what is our maximum tolerable
24:54 - death level
24:56 - and
24:57 - make sure we don't exceed it
24:59 - and i think this is mostly done by
25:01 - making good decisions in in our
25:02 - day-to-day work and i'm a strong
25:05 - believer in like the compounding effects
25:07 - of small improvements
25:10 - and the compounding effects of small
25:12 - regressions is equally powerful in the
25:14 - other direction
25:20 - and there might be short stints or
25:22 - cleanup but don't buy into the
25:25 - don't buy into the myth of the big bang
25:27 - refactoring because it never works
25:30 - because refactoring requires very deep
25:32 - contextual knowledge of the parts of the
25:34 - app you're working on
25:37 - so you can't do like
25:39 - breadth refactoring you have to go
25:42 - depth wise
25:44 - and it requires you to have all the
25:45 - details loaded into your working memory
25:46 - which takes time
25:53 - we need to ask ourselves when we accrue
25:56 - that why are we doing it and this is
26:02 - martin fowler's
26:03 - blog
26:05 - so it's it
26:06 - subdivides death into
26:08 - reckless or prudent
26:11 - and inadvertent and deliberate
26:14 - so you can see reckless deliberate is
26:16 - saying things like we don't have time
26:17 - for design which is
26:20 - this is abandoning our object in favor
26:22 - of some other other objective
26:25 - there might be reckless inadvertent uh
26:28 - as june she said you
26:30 - this is where we need to ask questions
26:31 - to our senior developers because we
26:33 - don't know what we're doing really
26:36 - it can be prudent and and deliberate
26:38 - thing we must ship now and deal with the
26:39 - consequences
26:41 - and the key word there there is deal
26:42 - with the consequences which means we
26:44 - need to negotiate with the product owner
26:47 - yes we can deliver next week but then we
26:50 - need some time to recover from the depth
26:52 - that we incur
26:55 - uh there's prudent inadvertent like we
26:57 - didn't know that it was gonna go so bad
26:59 - to this approach
27:05 - uh and as i as i mentioned product
27:08 - development has a
27:09 - an acutely human context
27:12 - and at some end of the chain humans will
27:14 - interact with the product
27:16 - and even
27:17 - if those humans are
27:19 - other developers they are still humans
27:21 - as well
27:23 - so if you look outside your own product
27:24 - team there's a
27:26 - sea of stakeholders that usually your
27:28 - product owner
27:29 - will protect you from by being the
27:33 - the authority on what's to build one
27:38 - and these stakeholders they provide
27:39 - their candidates problems for us to
27:41 - solve it doesn't mean that we'll solve
27:43 - all of them
27:44 - but what they do have in common is that
27:47 - they are human problems
27:49 - so they tend to be
27:52 - unconstrained by any form of logic or
27:55 - reason
27:57 - because that's the nature of human
27:58 - problems they tend to be fussy
28:00 - uh and this matters a lot because
28:02 - getting the problem right is the hardest
28:04 - and most important part of
28:06 - of the job
28:08 - and getting it's wrong often means
28:10 - imminent defeat
28:12 - regardless of how beautiful the the
28:14 - solution is or how flawless the the
28:16 - execution
28:17 - because we were not solving the right
28:19 - problem in the first place
28:23 - so no i don't think you need to think
28:24 - like a computer so there was this trend
28:27 - in like computational thinking and
28:29 - algorithmic thinking
28:31 - i think mostly you need to think like a
28:33 - human
28:37 - and define them and frame them properly
28:40 - so we can solve them
28:42 - and it's to take
28:45 - take ideas
28:47 - from the natural language that you use
28:49 - and
28:50 - turn those ideas into code
28:55 - mostly we need strong conceptual
28:57 - thinkers
28:58 - so so focus on that
29:02 - and because we are solving human
29:04 - problems which are fussy and
29:06 - not well isolated and defined
29:09 - like the problems we receive in school
29:12 - there's no magic formula really to
29:14 - follow
29:15 - and
29:16 - it doesn't really help to learn
29:17 - algorithmic thinking
29:21 - and in a way this is very nice because
29:22 - if
29:24 - programming was deterministic it would
29:26 - be a paradox in itself because
29:29 - programmers tend to automate things
29:31 - so if programming was
29:33 - deterministic we will be able to
29:34 - automate it and we would have automated
29:36 - it sorry and we would be out of jobs
29:45 - so i'd like to show you this mental
29:47 - model which i use to
29:51 - make sure that we're solving the right
29:53 - problems which is
29:55 - the most important part
29:57 - so i consider three parts of any effort
29:59 - i consider the diagnosis
30:01 - the definition and the framing of the
30:03 - problem
30:05 - the prescription how it intends to solve
30:07 - that problem
30:08 - and the execution which is just typing
30:11 - on the keyboard
30:15 - and i leave them in order of importance
30:17 - this is
30:18 - like orders of magnitude
30:21 - from the left to the right
30:25 - and i think it again it shows the
30:27 - relative insignificance of code
30:30 - it's just committing the ideas that we
30:32 - already generated in the previous steps
30:34 - into into code and it's those ideas that
30:37 - matter
30:39 - but you should be fluent with your
30:41 - programming language
30:43 - which is
30:44 - not really not that hard
30:46 - compared to all the other things we do
30:48 - so it just means read up on the standard
30:50 - library and on the language syntax so
30:52 - that you can use it fluently to express
30:54 - ideas
30:55 - just like you would
30:57 - uh english
30:58 - but don't
30:59 - be tricked into thinking that is what
31:02 - makes you a good developer
31:05 - so
31:06 - just like learning the entire english
31:08 - dictionary doesn't make you hemingway
31:11 - learning
31:12 - ruby's standard library does not make
31:13 - you
31:15 - brilliant at coding
31:18 - and execution is still important and
31:21 - this has to do
31:24 - with partly with credibility
31:26 - so ken talked a bit about spelling
31:28 - errors in the newspaper
31:30 - and it doesn't kind of doesn't matter
31:32 - how relevant the story is if it's all
31:34 - with spelling errors the credibility is
31:36 - already already hurt
31:39 - so don't abandon it try to improve your
31:41 - execution with every
31:43 - with every task
31:50 - and this is usually
31:55 - people can get a bit annoyed with
31:56 - sometimes
31:58 - i'll say oh it's just an implementation
31:59 - detail
32:01 - and what i mean by that is we have
32:03 - already gone through the process of
32:04 - diagnosis and prescription which are the
32:06 - interesting parts
32:08 - how we type out the code is
32:11 - not that interesting to me
32:16 - in the interest of time
32:17 - my own guidelines as we i've just
32:20 - discussed
32:21 - i think better humans beats better tools
32:23 - every time
32:25 - and i think technical competence is
32:27 - required but it's not sufficient
32:29 - and i think
32:30 - what lies beyond technical competency is
32:33 - what sets you apart
32:36 - as a developer
32:39 - always think about constraints
32:41 - if you do web applications
32:44 - and you're thinking should i
32:46 - do this language level optimization to
32:48 - my ruby code
32:50 - the answer is no because the constraint
32:51 - of
32:52 - performance is io and the constraint of
32:54 - your team is
32:56 - developer resources
32:58 - you're trading
33:00 - very valuable developer resources for
33:05 - very non-valuable work
33:07 - but also think about constraints in in
33:09 - your organization and your team
33:12 - if especially if your team is the
33:13 - bottleneck because then we need to
33:15 - utilize the
33:16 - our effort wisely
33:19 - obsessed about flow
33:21 - make sure you're solving real problems
33:23 - this is probably the most important one
33:26 - and don't have feelings about code
33:30 - so these are just my guidelines you
33:31 - should probably develop your own
33:33 - guidelines as you go along so whenever
33:36 - you come across an idea that is
33:38 - especially
33:40 - that integrates especially well with
33:42 - your understanding of our work then
33:44 - make it your own
33:48 - i think finally
33:50 - we need to beat the stereotype so
33:53 - programming is not
33:54 - manufacturing and you are not part of
33:57 - any manufacturing economy
34:00 - and
34:02 - there is the stereotype of the code
34:04 - monkey
34:05 - and we don't want to be cold monkeys
34:07 - and being the big monkey does not mean
34:10 - knowing the most tricks
34:12 - and i think the best anti-thesis to the
34:15 - the code monkey is
34:17 - is credible
34:18 - discerning and reflecting professionals
34:22 - and professionals who
34:26 - holds and protects their own objectives
34:29 - and who know
34:30 - when to negotiate and
34:33 - went to compromise
34:36 - and one who can tell conceptual issues
34:38 - from implementation issues
34:42 - and
34:43 - re
34:43 - reframe the problem and propose other
34:45 - solutions
34:47 - and i think it's it's developers who
34:50 - know what they know and what's what they
34:51 - don't
34:53 - so we need bold developers as involved
34:55 - not not both
34:59 - and of course for everything else
35:00 - there's always taco
35:04 - that's all
35:07 - [Applause]