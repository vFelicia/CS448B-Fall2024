00:00 - Welcome to the course. My name is Gwen, 
and I'm a software developer. Here is the  
00:11 - itinerary for today. Part One will start in the 
browser to get a feel for the syntax. And part  
00:18 - two will be on a local computer building 
apps as you regularly what. Along the way,  
00:24 - we'll cover different bits of the view API so you 
can get started right away. First, let's define  
00:31 - what view is. On a basic level. It's a front end 
library to help you build JavaScript applications.  
00:38 - Now Vue js is more robust than something like 
jQuery, since it gives you specific recommended  
00:44 - patterns for code organization. Although it did 
borrow a lot of good ideas from jQuery, Angular,  
00:50 - React, and others. It's usually not found in 
the wild by itself, you'll see it used with  
00:56 - lots of other libraries and combined to make 
sort of a framework and alternative to react,  
01:01 - Angular, and others. And we'll cover many of 
these libraries today. So let's get straight  
01:06 - into it. I'm here my browser at JS fiddle dotnet 
is just another place to put front end code. And  
01:19 - I'm going to try hello world. So this is if I was 
just writing a plain HTML or jQuery application, I  
01:29 - might put something like this. So how do I attach 
this to the view instance? Here, I've reloaded  
01:39 - the view library. So I can just choose it from 
frameworks and extensions, I'm just pulling in the  
01:44 - latest version. And from that library, I have a 
view instance. So I can instantiate it like this,  
01:51 - and then pass it an object of options. The only 
required option I have to set is element. So which  
01:59 - element in the DOM do I want to attach my view 
instance to going to attach it to route. And then  
02:07 - of course, I need to have a root element with ID 
of root here. So now my view instance is attached  
02:16 - to this div in the DOM. If I run it, of course, it 
doesn't do anything different. So let's make it do  
02:23 - something different. There's also a data object 
I can use. And I can populate this with variables  
02:33 - to use in the DOM. So I can say data greeting. 
Hello view. Now how do I put this in the DOM  
02:47 - view has something called double mustache mustache 
syntax. So anything inside of this inside of these  
03:01 - double curly braces view looks at a more parse 
as JavaScript. So view comes down here and says,  
03:07 - Okay, I have a variable in data called greeting. 
And so I'm going to render the contents of  
03:14 - the variable, we run this again, changes to 
Hello view. Another important concept in view  
03:23 - is data binding view uses two way data binding 
through a directive called v model. On an input,  
03:33 - when I put v model, it binds it to a variable in 
the data object that I give it. So in this case,  
03:40 - I'm telling Vue to bind this value of the input 
to the greeting variable from data. If I run this,  
03:51 - everything inside of my input is the same as 
the greeting variable. And then if I change it,  
03:57 - it live updates. extremely simple. The model 
is something called a directive. There are a  
04:10 - lot of directives in view, and they're used to 
interact with the DOM. Let's look at another  
04:16 - common directive. V if V f evaluates an expression 
to a boolean value, either true or false. So let's  
04:29 - start with something that we know is true. So if 
one equals one, you're telling view to display  
04:45 - this div and render it to the page? Yep. So this 
isn't so useful, it's usually used in combination  
04:59 - with data attributes here. So let's make a new 
data variable, we're going to call it count. So  
05:07 - if count equals one, then display this diff to the 
screen. So put my changes to count equals zero.  
05:24 - And of course, it won't display to the screen. 
Now there are other directives that you can chain  
05:38 - called v. Else if and V else just like an if else 
statement. So let me change these. Orange, just  
05:53 - different values red. Let's say if count equals 
two. So this is pretty self explanatory. If count  
06:16 - is one, nope, if count is to render this, anything 
out, other than that render v else. So if I put  
06:27 - two, it's going to render red, and so on. Now, the 
thing to note about vi if these divs, if they're  
06:39 - not true, they don't get rendered to the DOM at 
all. Now, this might be the behavior you want, and  
06:45 - many times it is view also has another directive, 
called v show. So let's call this the show. There,  
07:02 - we'll just do the same thing. If count equals 
one, change Capital One, run, and it's green. Now,  
07:20 - this time if count is two, of course, nothing 
displays here. But it's actually still being  
07:34 - rendered to the DOM, just with display none set in 
the CSS. Have you look in here to kind of dig in,  
07:45 - but you can see that there's a div with green 
inside this our same div up here. And it's set  
07:53 - to style display none. So it's still in the DOM 
here. And so sometimes you want to use v if and  
08:00 - sometimes you want to use v show, it depends 
on what you're doing in the application. And if  
08:04 - you need better performance if you're constantly 
adding and removing things from the DOM. So let's  
08:12 - look at some more directives. I've already typed 
this out to save some time, it's just an input  
08:17 - with a submit button. You click it it alerts. And 
also an email variable that is bound through the  
08:25 - V model directive to the what's entered into the 
input. To view has this directive called v. Bind,  
08:35 - a V bind can take an HTML attribute, like 
disabled, that works in vanilla HTML,  
08:44 - and parse it as JavaScript. So email that links 
will say is less than two. So what this does is  
08:54 - the regular HTML attribute disabled with disabled 
this button, but we're telling view to parse this  
09:02 - as JavaScript, so we're going to take that email 
length, and the button will be disabled only if  
09:08 - the email length is less than two. If it's greater 
than two, then the button will be enabled. So  
09:13 - let's run this. And you can see I can't click on 
it, it's disabled. But if I type something here,  
09:20 - now it's enabled again. So you can do this on 
many different attributes, not just disabled.  
09:28 - And there's also a shorthand, which is what 
you'll usually see in view applications. So  
09:34 - it will be just whatever HTML attribute preceded 
by a colon and that's shortcut for saying v bind  
09:43 - colon because it's so common in view. Now, another 
use for V bind that's common is to dynamically add  
09:51 - classes. So, Stu colon, the shorthand for V bind 
Last. And then there's two different ways of doing  
10:04 - it, I'm going to start with the first syntax, 
which is called object syntax. So I'm going  
10:11 - to dynamically had this read class. And I'm going 
to say, if the email dot length is less than two,  
10:27 - I want to have a border, a red border around this 
input box. So let me run that. And I have a red  
10:37 - border. And as soon as I get past two, or I get 
two or greater, then I don't. So that's how you  
10:48 - can dynamically toggle classes. So there's another 
syntax used if you want to toggle in between two  
10:55 - different classes, which is array syntax. So we 
can use just a regular JavaScript ternary here.  
11:03 - So email dot length, is let's say, if it's less 
than two, then we're going to use the class red,  
11:15 - and if it's greater than or equal to two, will 
be the class green. So let me run this. And we  
11:25 - had the class red. And now it toggles back and 
forth in between green. There are several other  
11:32 - directives in view, these are a bit less common, 
but I just want to mention some of them. So we  
11:40 - already know that we can put variables in the DOM 
using the double mustehsan mustache syntax. If I  
11:47 - run this, I can type and it shows up, I can 
actually do the same thing using a directive  
11:53 - called v text. When you put a paragraph tag, the 
text equals email, and then just close the tag. So  
12:08 - if you're used to jQuery, you'll be used to the 
dot text that it uses to put text inside of an  
12:14 - HTML element. This is doing the exact same thing. 
So if I run this, it does the same thing as using  
12:21 - double curly brace. There's also the HTML, which 
will parse it and we'll just put text inside. But  
12:30 - it will parse it as HTML, similar to the dot html 
and jQuery. So if I type stuff in, it does the  
12:38 - exact same thing. But I can also type in HTML 
tags. And it parses it as HTML. So what if you  
12:50 - want to render something just once a static HTML? 
Well view has another directive called v once, say  
12:58 - once and put the email in here. Just to compare, 
I'm going to copy this and put it outside of the  
13:19 - ones. So let me start with something initially 
here. So as I update this, it only changes in  
13:36 - the second one because it's frozen and just set as 
the static HTML of whatever it was initially. The  
13:43 - second one will still display and update as you 
change the V model for that variable. So let's  
13:52 - look at looping and view. I'm just going to clean 
this up real quick. of all of this. And let's make  
14:03 - a list an ordered list. No I. And the directive 
to handle looping in the DOM and view is called v  
14:18 - four. So let me come down here and get something 
to actually loop through, which is an array of  
14:29 - cats have already written. Paste it there. And 
the syntax for this will be you need to take  
14:38 - care of a cat's and you're gonna say, item in 
items. So it will just be like a four in loop  
14:47 - in JavaScript. So you'll say cat in cats. And 
then during every iteration of the loop, you'll  
14:56 - have access to the cat variable which will be 
Per index in the array. So I'm just going to put  
15:04 - cat here and run this again. And it comes out with 
all the different cats in the array. So of course,  
15:14 - in the first iteration, it displays in Li element 
with the first cat inside, which is kick cat,  
15:22 - at index zero, and then it moves the loop 
moves to index one, and then index two,  
15:27 - and so on, and so on. And if you look, in the dev 
tools, you can see it has the full array there.  
15:37 - Now, you can also do this with objects, of course, 
these are just simple objects with one key value  
15:46 - pair each. So now cat would equal this object with 
the name inside. So to display the cat's name,  
15:56 - now, I'd have to do cat dot name. Run it, 
and I get all my cats. Great. So there's  
16:05 - more we can do with looping. And there's 
more we'll get to later when we're looking  
16:09 - at local applications. But that's pretty much 
how it works. So let's look at functions. Now,  
16:17 - what if we wanted to add a new item to this array. 
So I'm just gonna add something similar to what  
16:24 - there was before with an input. The model was new 
cat, button. So I'll add a function to the button  
16:45 - in a second. Let me run this, and it renders my 
static HTML. That's good. Let me add this new cat.  
17:11 - So this is modeling my new cat that I'm going 
to add to this list. So I need some kind of a  
17:19 - function to add it for me. And I can do that with 
a directive called v on on click, so when I click  
17:30 - this button, I want it to perform an action. In 
this case, I want it to run the function ad Kitty,  
17:35 - which we're about to make. So the data object is 
just four variables. So to put a function here,  
17:46 - I need to add one called methods. And this is 
another object with functions inside. So add  
17:58 - Kitty, oops, and Kitty, which is a function. And 
I'm going to need to push a cat on to this array  
18:16 - to add it to this array. So I can access any 
any data variable inside of a method by doing  
18:26 - by using this. So this dot, cats will access my 
cats array in data here. So this cats dot push,  
18:37 - and then I want to push my new cat and my new cat, 
I also have access to this. So I can say this dot  
18:46 - new cat and I have the new cat's name. Of course, 
this would work if we had just a plain array,  
18:55 - but we actually have an array of objects. So I'm 
going to put this inside of an object and then  
19:02 - say, name is this dot new cat. So this will push 
another object on to this array. So let me see if  
19:13 - this works. ran it. Let me add and I can't press 
Enter right now. But when I click the button, it  
19:25 - adds it pushes on to my array perfect. Of course 
it's kind of annoying to click Add every time. So  
19:33 - what if I want it to respond to an enter as I'm 
typing, so I can quickly add more kitties. I can  
19:38 - actually add another event with V on again but in 
this case I want v on key up and then equals add  
19:55 - kitty so I want to run the function add kitty on 
kiya. So let's run this and see What it does. So  
20:03 - unfortunately, though, I didn't tell it which key 
up. So any key that I press is just adding a new  
20:11 - cap for each one, which isn't the functionality 
that I want. So I can modify this key up by saying  
20:18 - key up dot Enter. And we run that their key up 
dot enter. So I have to hit Enter, and it adds  
20:32 - it to the array, which is perfect. Unfortunately, 
it's not really the functionality that we want to  
20:40 - leave the same cat in the input box. So how do 
we clear the input box, we can just set new cat,  
20:53 - this, that new cat equals an empty string. We've 
already pushed the new new cat so we don't need it  
21:05 - anymore. And this new cat is fine to be emptied 
again. So let's run this. There. And now MTS,  
21:20 - ready for more cats. So there's many more events, 
and modifiers that you can chain on to events.  
21:29 - For example, view has an API for chaining things 
on to the click event, you could do dot prevent,  
21:40 - which means prevent default. And you can also do 
stop for stop propagation. Basically all of the  
21:48 - common things you might do, that are associated 
with that type of event, which is super useful. I  
21:53 - want to show one more shortcut here. And this is 
what you'll normally see in a view application,  
21:58 - instead of V on because it's so commonly used, 
they have a shortcut to just do at. So at click,  
22:05 - and then you can do this with any type of event 
anywhere you would use vi on. So you can say  
22:12 - key up. Let me just show that this still works. 
And it works fine. Both ways work, this is just  
22:21 - adding a shortcut to it. So let's say you want to 
update something that's rendering to the DOM view  
22:28 - has something called filters. So I'm just going 
to write a simple filter to illustrate what it  
22:36 - does. And I'll come down here after methods, I 
can add another object. And this one is similar  
22:47 - to methods. It's an object of functions. And I'm 
going to put the function capitalize function and  
22:59 - actually a value here and I'll return the value 
but I'm going to change it to uppercase. viewable  
23:19 - will parse this as JavaScript with cat dot name, 
and then it will pipe it to this capitalized  
23:26 - function, which is a filter. So it doesn't change 
the actual value stored in the view state here in  
23:35 - the data property. So all of these names will 
still be lowercase, but just the display on the  
23:42 - DOM will be piped through this capitalize 
function. And it will come out value that  
23:49 - to uppercase. So if we run this. So I actually 
misspelled filters here and the add ins. And there  
24:00 - you go. It filters through the capitalized so 
you can also pipe these. So I'm going to add one  
24:05 - more catify. And I'll make another filter here. 
function value. And I'll return the value plus y.  
24:26 - So run that and it returns y on the end. If I 
piped it the other way the y would be capitalized.  
24:35 - Really this isn't used that often in view. In my 
experience, it's just a good thing to know about  
24:41 - for when the need arises. Another set of methods 
in view for updating what's seen on the DOM,  
24:47 - or the computed methods. So let me get rid of 
filters real quick. And this filters block here  
24:56 - and I'm going to add compute instead. And I'm 
going to use the same and scroll down. And I'm  
25:17 - going to use the same method. So let's get a fi, 
cat name, function. This time the function doesn't  
25:31 - have to take anything. So let's say if this dot 
new cat, which is our cat name that's entered in  
25:47 - in this input box. So if that the length of that 
is greater than one, I'm going to return this  
26:00 - stock cat name plus y. And let's display this in 
the DOM. Killer filename. I'll put a break after.  
26:22 - So you probably noticed the connection, that view 
whenever it sees a variable. Inside of the double  
26:32 - curly braces, it looks down here at the data 
property, and the methods and the filters and  
26:37 - the computed and tries to find a match for it. So 
let's run this. There we go. And as I type, well,  
26:48 - it's adding the Y for computed but it's coming up 
with undefined. And that's because I misspelled  
26:56 - the variable. So I put new cat there and run 
it again. And that should work. So later on,  
27:09 - you'll be using computed a lot when you deal with 
view x. It's also extremely useful. If you have a  
27:17 - lot of logic in the DOM, let's say you're doing 
a lot of computation or updating inside of this  
27:25 - block, then you could clean it up, take all of the 
logic outside of the DOM here, put it inside of  
27:32 - a computed property and then just display it in 
the DOM like we're doing. So let's say you want  
27:38 - to update something that's rendering to the DOM 
view has something called filters. So I'm just  
27:46 - going to write a simple filter to illustrate what 
it does. And I'll come down here after methods,  
27:55 - I can add another object. And this one is similar 
to methods. It's an object of functions. And I'm  
28:04 - going to put the function capitalize function and 
actually a value here and I'll return the value,  
28:22 - but I'm going to change it to upper case view, 
we'll parse this as JavaScript with cat dot name,  
28:36 - and then it will pipe it to this capitalise 
function, which is a filter. So it doesn't  
28:43 - change the actual value stored in the view 
state here in the data property. So all of  
28:51 - these names will still be lowercase, but just 
the display on the DOM will be piped through  
28:56 - this capitalize function. And it will come 
out value that to uppercase, so if we run  
29:04 - this so I actually misspelled filters here and 
add an s. And there you go. It filters through  
29:15 - the capitalized You can also pipe these. So I'm 
going to add one more catify and I'll make another  
29:24 - filter here. function value. Then I'll return the 
value plus y. So run that and it returns y on the  
29:45 - end. If I piped it the other way the y would be 
capitalized. Really this isn't used that often  
29:51 - in view. In my experience, it's just a good thing 
to know about for when the need arises. Let's talk  
29:58 - about custom components. Vue has a component 
architecture that lets you reuse bits of code,  
30:06 - just like most modern, single page application 
frameworks. So let's illustrate this, I'm going  
30:14 - to create a new component using view component. 
And I'm just going to call it catalyst. And then  
30:25 - I pass it an object of options. That's it, there's 
a template. And I'm just going to do a multi line  
30:34 - string with. So for right now, and actually, a 
list should be inside of you. How does this work?  
30:57 - Close this, I will have to attach it to my view 
instance. So I'm going to say, component. And then  
31:08 - given an array of components, components, same is 
catalyst. Now let's add catalyst to the DOM. So to  
31:22 - add any custom component that you make, you can 
just add it by its name. and run it and you can  
31:29 - see cat down here, you can also pass in logic 
and variables. So let's pass in our cats array  
31:38 - and display the array through the component. 
The way to accept variables in a component is  
31:43 - through something called props. I'm going to pass 
in the cats array, I'm going to say props. Cats,  
31:51 - actually this array. And I'm going to pass 
in cats. And then here, I can use a V for  
32:07 - the for cats. And then display it has to be cat 
name. So here I actually have to pass in cats.  
32:28 - So I'm passing in cats. But if you remember 
here, I have to add v bind for the shortcut,  
32:40 - which is just the colon. Because if I don't add 
that, it's just going to treat cats as a string,  
32:46 - when it gets passed into the component, instead of 
treating it as JavaScript, and then looking in the  
32:54 - data property and getting the array. So now cats 
is set to the array of cats. And if I run this,  
33:00 - again, it's the same array. And it adds on 
together. So the idea of having components  
33:08 - is that they're reusable modular pieces. And 
when you're developing view locally vcli breeds  
33:16 - a really nice project with you with a modular 
architecture that kind of handles this under the  
33:22 - hood for you. To wrap up here, I just want to talk 
quickly about view lifecycle methods, view will  
33:29 - trigger certain functions to run, which can be 
very useful when you're developing an application.  
33:33 - So I have four functions here created, mounted, 
updated and destroyed, and they're just logging  
33:44 - things. I'm going to run this. And if I look at 
the console, it shows created when the component  
33:55 - is created, and when it's mounted to the DOM, it 
runs mounted. Now it's been updated, because the  
34:02 - state in the data object has been updated. Now 
for destroyed, it's a bit harder, because in  
34:08 - the small applications, instance, never leaves 
the DOM is destroyed. So I'm going to take a  
34:17 - function to call destroy. So I'm basically setting 
a timer for five seconds. And after five seconds,  
34:27 - it's going to call app dot destroy, because the 
view instance is set equal to the app variable.  
34:34 - So this will destroy it. Let me run this again. 
So I see created, mounted and then destroyed.  
34:44 - This also means I won't be able to update anything 
here because it will be just statically rendered  
34:52 - HTML as it is, is no longer connected to view. 
There are many other functions that run including  
34:59 - before Or mounted before destroyed. And I 
think they're very well drawn out in the view  
35:06 - documentation, so Vue js.org, the version two 
guide. And if you look at the lifecycle diagram  
35:14 - section, it shows you exactly when each function 
is going to be run during the lifecycle of the  
35:22 - component. So this is a really good reference. 
And you'll be using these a lot as you develop  
35:26 - applications. Next, we're going to go over how to 
start developing applications with vcli locally.  
35:35 - To create a Vue JS application, we're going 
to start with the command line interface. So  
35:42 - if you come to see ally dot view, J s.org. And 
click on getting started. Over here on the left,  
35:49 - there's a link for installation. And it prompts 
you to npm install dash G, view COI globally.  
35:58 - So if you copy this command and come over to your 
terminal, you can enter this and install view COI,  
36:09 - I've already done this. So I'm just going to check 
my version. My version is 3.1 point one. So now  
36:19 - I'm going to create a view app, I can do this with 
the view create command. So view space create. And  
36:26 - then whatever I want to name my application, 
which in this case, I'm going to call it quiz.  
36:31 - So it takes me through a series of prompts. So if 
you'll notice the last one, manually select so you  
36:40 - can select routing, testing, linting, etc. The 
default gives you just Babel and es lint and is  
36:47 - a pretty basic site. on top. This is a template 
I created, which I'm going to talk about how to  
36:52 - do later. So for right now, we're just going to 
pick the default to get started and see how it  
36:58 - works. It's installing all the dependencies, this 
will take a few minutes. And it creates a folder  
37:07 - for you called quiz with your view application 
inside. Now, it also tells me how to run the  
37:18 - application. So I can move into the quiz, folder 
NPM, run serve. And it's going to run my view  
37:32 - application on port 8080. I'm going to copy this, 
go to my browser. And it gives me a boilerplate  
37:49 - application. Let's open up our application and see 
the code. I'm going to be opening up in VS code,  
37:59 - which is a free code editor. And you can see 
by default, it gives you a few config files,  
38:06 - package dot JSON, which is where you reference all 
of the code that you didn't write any third party  
38:14 - libraries. And then the meat of the application 
is in the source directory. And this is where  
38:21 - your j s gets rendered or your view gets rendered 
to the page. So you can see it's creating a new  
38:26 - view instance. So it's like we did before the 
syntax is a little bit different. But it's doing  
38:30 - the exact same thing. It's mounting it to a DOM 
element with the ID of app. If you're wondering  
38:37 - where your HTML file is, it's in the public 
directory, you can see your index dot HTML and  
38:42 - view is doing quite a few things under the hood 
that you can't see. So it auto injects your  
38:47 - script files. So it creates a bundle out of your 
main j s and all of these different view files,  
38:55 - it bundles them all together, and then it injects 
a script into your HTML file for you. That's one  
39:01 - of the really nice things about using view, c li, 
you have all of this boilerplate and setup done  
39:07 - for you like Webpack, and Babel. So you can just 
start building right away. If you want to look at  
39:13 - the view scripts, these are the different scripts 
that view is calling to run your application  
39:18 - locally or to build it for production or to lint 
it for you. So let's look at the application.  
39:24 - From the main j s. It's importing this app dot 
view file, which is the entry point of the view  
39:30 - application. If you look at app dot view, you can 
see that it puts a template. This isn't created  
39:37 - by view. This is part of the html5 standard, but 
it puts it in the same file with a script tag,  
39:42 - and also a style tag. How view works is when 
you're building an application locally, you create  
39:49 - many different files, each with their own template 
tag containing your HTML, and then a script tag  
39:56 - which contains the JavaScript that interacts with 
that ah, tml. So in that way, you can divide up  
40:02 - your application into components, and then put 
them all together. They're all bundled into this  
40:09 - main dot j s and render to the page. So here's the 
first project we're going to be building. It's a  
40:15 - quiz application that keeps track of the number of 
total questions you have answered and the number  
40:20 - you got correct. The questions are pulled in from 
an API, and displayed along with the answers. The  
40:29 - only user actions are to select an answer, click 
Submit. And you also have the option of resetting  
40:36 - the count of questions to zero. When you choose 
an incorrect answer, the color of the answer will  
40:43 - turn red once you hit submit, and the correct 
answer will turn green. If you get it correct,  
40:49 - it will only show the correct answer that you 
selected. Back in our quiz app, let's start  
40:56 - making components. First, I'm going to delete 
this hello world dot view which will not need  
41:01 - and create two new components header dot view and 
question box dot view which is wearable display  
41:19 - the question answers and the submit button. Inside 
of components, the only required element is to  
41:27 - have a template tag for HTML. You don't really 
need a script tag or a style tag. So I'm just  
41:36 - going to put some dummy text in here. Question 
box. And I'm going to copy this for the header  
41:48 - component. And just put a header here. So the app 
component is still expecting hello world. So I'm  
41:58 - going to put our new components in here. Instead, 
I say header. And how header. To be able to use  
42:25 - the component in the template section. I need to 
add header here. It's comma, and then question  
42:34 - box. And now I can get rid of the hello world and 
image. And I'm going to add the header here. As  
42:45 - well as the question box. All right, let me run 
this NPM run serve. In the browser, we can see  
43:05 - we have both components header and question box. 
So before I update any of the components anymore,  
43:12 - I'm going to install a third party library called 
bootstrap view. bootstrap view has a lot of built  
43:22 - in components and CSS already written. So we don't 
have to worry about styling. If you're interested  
43:28 - to see more, you can go to their docks or see 
all the components that they offer, like buttons,  
43:33 - different form elements, and they're rather nice 
layout and grid system, which we will be using. So  
43:39 - to get started. I'm going to go back, get started 
and copy this command. It wants me to npm install,  
43:49 - view, bootstrap view and bootstrap. So I only 
need bootstrap view in bootstrap. I'm going to go  
43:56 - ahead and copy it. Go to my terminal. Let me close 
this and get rid of you. Alright, now that that's  
44:10 - installed, I can add it to my project in my main 
JavaScript file. I'm going to import view and then  
44:18 - call view dot use to add it to my application. So 
when you create view apps using the vcli this will  
44:26 - be in the main js file. Get add import bootstrap 
view, I like to do my relative dependencies last.  
44:35 - And I'm calling view dot use bootstrap view. 
Of course, this view dot use is just for the  
44:43 - JavaScript portion of bootstrap. So I'm also going 
to take the CSS and import it. We import bootstrap  
44:55 - CSS. And now I can start using These built in 
bootstrap components. So let's use view bootstrap  
45:04 - in the header component, I'm actually going to go 
over to the view bootstrap docs and find the nav.  
45:12 - And the header is not going to be a real nav in 
this application. But just for styling purposes,  
45:18 - I'm going to go ahead and use this. When I switch 
to two spaces here for consistency, put a wrapper  
45:31 - div. Okay, someone that attach classes to it 
later. Also, now, I only want two items in here.  
45:42 - I want to have the name of the application to be 
something like fancy quiz app. And then a counter  
45:54 - for the number of correct versus total questions. 
So I'm just going to hard code this right now. And  
46:04 - replace these with variables. Once I have that 
part of the app working. Let me see how this  
46:09 - looks. Let's run the app again. And now it's 
now in the browser. Awesome. Well, the problem  
46:24 - is these are links because it thinks it's an ER 
view, bootstrap thinks we're making a navbar. So  
46:29 - I'm just going to go ahead and disable these. 
Set of active here I'm going to put, disable,  
46:37 - and disabled. And then for the logo, I just want 
to differentiate the style a little bit. So I'm  
46:49 - going to make it bold. Also, to offset the header. 
I'm just going to add tabs here. And this should  
46:55 - auto restart. Yeah, this auto restarts in here. So 
I'll go to my browser tabs added this line here.  
47:03 - And then I have my logo and the counter. So the 
header component is done for right now. Let's move  
47:09 - to the question box and go ahead and get that set 
up. So the question box is going to use another  
47:17 - view bootstrap component called the jumbotron, 
which is basically a page element that sets itself  
47:25 - out of the page like this, I'm actually going to 
copy this code with the enclosing div, switch back  
47:32 - to my code editor and paste it here. Just like 
before, I want to have two spaces. indent here,  
47:42 - just to know I always like to have this wrapper 
div around components. Because I like to make  
47:49 - container classes for when I use sass or CSS. So 
I would put something like question box container  
47:57 - here. And then reference this class to style 
this whole component. So this is a pretty plain  
48:04 - jumbotron. We'll see it in our app. And it's not 
exactly what we want, because we want a question  
48:09 - and then answers below it. So in the jumbotron 
docs, we can actually use templates inside that  
48:18 - will make the component look more like this. So I 
can put the question on top, then list the answers  
48:24 - and have the submit button at the bottom. And the 
submit button is another view bootstrap element  
48:29 - for buttons. Notice, it's perfectly fine to have 
more templates inside of the parent template,  
48:35 - which is your component. And you'll see libraries 
doing this using something called slots that we'll  
48:40 - talk about later. But for right now, I'm just 
going to copy these, go back to my component.  
48:45 - And I'm going to put this inside. So let's see 
what this looks like. Not too bad. I am going to  
49:01 - remove the header. Because we already have a logo 
on the page. And we just need to put the question  
49:08 - here. So this will be our question. And then our 
list of answers will go somewhere here as well as  
49:23 - a submit button and a button once you've submitted 
to navigate to the next question. Let's see what  
49:32 - that looks like. So we'll also have to get rid of 
these which we don't want. Now let's see what this  
49:39 - one looks like. Perfect question list of answers 
buttons. And one more thing I want to do in view  
49:46 - bootstrap before I get to the JavaScript is set up 
a grid to kind of prevent these questions or the  
49:52 - question box from going fullscreen. So layout and 
grid system. See the examples of how you can lay  
49:59 - out a page With different containers in rows and 
columns. For this, I don't have different rows.  
50:05 - So I'm just going to use, I'm just going to use 
the basic one here. Go back to my code editor.  
50:15 - And I'm going to go to here. And I want this to 
wrap the question box component. So get rid of the  
50:27 - extra two columns, enter, and then just copy this 
paste. And then in this column, I'm going to tell  
50:44 - it. So on a small screen, or anything larger than 
a small screen, I want to take up half the page,  
50:52 - which is six, because bootstrap basically gives 
you 12 vertical columns. So if you want half the  
50:58 - page, you can do six, offset, offset equals three. 
And let me show you what this is doing. So I'll  
51:07 - inspect element here. And the jumbotron in the 
question box container is taking up six columns.  
51:18 - So if I hover over this, you can kind of see that 
the yellow part is a three column offset from the  
51:25 - left. And the extra white padding on the far left 
is from the container. So putting it inside a  
51:33 - bootstrap container just automatically centers an 
element on the page and gives it a little bit of  
51:38 - padding on either side. So inside the container, 
we have 12 columns, we're using six and offsetting  
51:44 - by three. Great now let's jump into the API for 
the questions and start pulling some actual data  
51:50 - for the application. Open tdb.com is a quiz API 
that we can pull questions from. They give you a  
51:58 - lot of nice options. Like you can browse through 
questions, you can submit your own questions,  
52:03 - because these are all user submitted questions. 
And they also have a pretty nice API. by filling  
52:11 - out this information, we can actually generate an 
API URL to pull questions from. So I think pulling  
52:17 - 10 questions is good. Any category, I'm just going 
to select the animals difficulty any is fine. Any  
52:26 - type multiple choice, just so the UI is the same 
for every question. Default encoding is fine. So  
52:35 - now it generates me this API URL. I'm going to go 
put it in my browser. And I can see every time I  
52:46 - make a request to this API, it pulls 10 questions 
about animals? I think one kind of confusing thing  
52:54 - with working with this API is that instead of 
putting all of these in one array, they put the  
52:59 - correct answers separate from all of the incorrect 
answers, which is fine, because we're just going  
53:06 - to take the correct answer with the incorrect 
answers, write a function to shuffle them all  
53:11 - together, and then match up the correct answer 
based off of what the user selects. And of course,  
53:18 - every time you hit this API, it's going to come up 
with a different series of random questions that  
53:24 - it pulls. Let's put the API in our application 
now. So I'm in my app component now. And I'm just  
53:31 - going to add a function to pull in the questions 
and answers from the API. So if you remember  
53:38 - when we were in the browser, using GS fiddle, we 
covered something called lifecycle methods, which  
53:44 - are functions that get called automatically by 
view as components either get created or mounted  
53:50 - or destroyed, etc. So we're going to use one 
called mounted here can be a function. And in it,  
53:59 - we're going to use the standard fetch API, which 
is a web standard and doesn't need a library to be  
54:06 - imported. So I'm going to paste our questions API 
endpoint. And then I'm going to pass an object,  
54:17 - an options object with the method to get from 
this. Now, that's all I really need. But I'm  
54:25 - going to add a dot then and take the response. So 
never say in the response, when you use an arrow  
54:35 - function here and say, just let's console dot log, 
this response in JSON format, JSON. Alright, let's  
54:46 - see what this does. Let's run this. By the way, 
don't mind any of this orange text that says which  
54:55 - git branch I'm on and I'm trying to put different 
parts of this tutorial on different brain I'm  
55:00 - going to do NPM, run serve again. Nope, we have 
an error. Oh, it's just complaining that I'm using  
55:09 - a console dot log, this isn't a JavaScript error. 
It's a linting error. So I'm actually going to add  
55:15 - this to my package dot JSON. And all of my linting 
config is right here. So I'm going to add this as  
55:25 - a rule here. And say no console. Try to remember, 
this is just for demo purposes. If I were actually  
55:41 - building an application, I would probably want to 
have a warning or an error there, just so I would  
55:47 - remember to remove all of those extra console 
dot logs. Anyways, it's running now. So I'm  
55:51 - going to check it out in the browser. Of course, 
nothing is different right now. But if I look in  
55:58 - the console, may refresh. And I'm actually getting 
a promise back, which is good, it means I'm  
56:05 - getting the data back. But we can't see it right 
now. Because I have to update my promise chain.  
56:10 - So let me go back to the code. And app file, I'm 
just going to return this turn response dot JSON.  
56:20 - And I'm going to change in chain another dot then. 
So I'll just say it's JSON data. And let me wrap  
56:29 - this, this so it's more clear. And then here is 
actually where I want to be able to access the  
56:38 - data from my application. So I'm going to create 
doesn't look like I have a data method yet. So I'm  
56:45 - going to create a data function and add a comma. 
And I'm going to return an object, oops, object.  
56:59 - Now, if you notice, this is a little bit different 
from how we did it in the browser. The reason this  
57:04 - is different has to do with some more complex 
features of JavaScript. So we're not going to  
57:09 - talk about those. But it's basically required when 
you're making this type of single page application  
57:16 - with a bunch of different components that instead 
of just making a data object, you return an object  
57:22 - from within the data function. So it's a minor 
change. So here, I want to add a questions array,  
57:28 - which will be empty at first, and can be populated 
from the questions from the API. So here,  
57:36 - I don't need to return anything. But I want to set 
the questions, this questions array to equal the  
57:43 - questions we get back from the API. So I'm going 
to set this dot questions equal to the data we  
57:52 - get back from the API dot results. Because if 
you remember, the API gives us back two things.  
58:00 - It gives us a response code, and then a results 
array. And the results array is where all 10 of  
58:06 - the questions we are pulling back are located. 
I can save this, I am still running all test it  
58:15 - in the browser, and you can't see it yet. So to 
inspect the data on our components, we actually  
58:21 - need something called Vue JS dev tools. So if you 
google view, Dev Tools, this is the GitHub repo,  
58:27 - if you scroll down, you can see they have 
a Chrome extension, a Firefox extension,  
58:32 - which I'm using Firefox right now, if you're using 
something else, or you just want a standalone app,  
58:37 - that's fine, too. They all have pretty much 
the same functionality. So I already have  
58:42 - it installed. And it comes up on my dev tools as 
view. One of the things I love about view is that  
58:49 - it has all its dev tools in one place, we're gonna 
get into view x and different things later. Some  
58:54 - other libraries, you have different dev tools for 
different things that you're doing. So under app,  
58:58 - I can see all of the components imported into 
app, the child components, I can also click on  
59:04 - app and I can see any data variables associated 
with that component. Under questions I can see,  
59:10 - we have all 10 questions that we pulled from the 
API. And it's in the same format that the API  
59:16 - showed us with the incorrect answers, and then the 
single correct answer by itself. So the next step  
59:24 - here is to display the question to the screen. 
So let's go back to our code. I'm back in the app  
59:31 - component. And I'm want to be able to display the 
question from this question box component. So I'm  
59:38 - going to have to pass it from the app component 
to that one. And I want to pass just the question  
59:44 - that we're on. So as you're clicking next through 
questions, I just want the question box component  
59:51 - to know about the current question. So I'm 
going to keep in index of the question here,  
59:58 - which We'll start at zero. And then view 
lets me pass data variables and methods to  
60:08 - my child components by using v bind with custom 
attributes. So I can say, the question I want to  
60:20 - pass equals my questions array and the index. So 
just the current question that we're on, and then  
60:32 - eventually we'll be able to click next, and this 
index will increment. So question one, Question  
60:37 - two, etc. Now, if you remember the structure of 
our data, off of each question of each question.  
60:51 - So this is one question this object, we have the 
correct answer incorrect answer and the question,  
60:58 - so we have to get the question text off by using 
question. So let's do that in the question box. So  
61:09 - I'm going to come here. And remember the double 
mustache syntax to use variables. So I'm going  
61:17 - to do question which is passed from the parent 
component. And then I have to do dot question.  
61:23 - So maybe it would be more clear if I did. Let me 
change this to, I guess, current question. To make  
61:31 - it more clear, and then I have to go and change 
it in the parent component there. So you can give  
61:38 - this any name, but it's going to be the same name 
in the child. But that's not the only thing. In  
61:45 - order for this question to display properly in the 
child component, we not only have to reference it  
61:53 - in the HTML, but we have to pass it through the 
JavaScript. So I'm going to create a script tag  
62:01 - here. And a regular ex ported object. And for 
now, I'm just going to give it the key props,  
62:14 - which isn't another object. And I'll put a current 
question which is also an object datatype that  
62:27 - I received from the parent. So any variables, 
whether it's a data property, or a method that  
62:33 - I'm passing from app to question, in order for it 
to display in the HTML, I have to reference it in  
62:40 - props and say, Hey, I'm receiving this particular 
named variable from the parent, and you reference  
62:47 - it the same way you would a data variable. So 
you have your component state, which would be  
62:53 - local to this component in data. So this is local 
to the app dot view component. And then you can  
63:02 - also have props, which is any variable passed from 
another component to this component, and you use  
63:11 - them the exact same way in the HTML. So let's see 
if this is working. NPM, run serve again. So it  
63:23 - built and now let me check in my browser. There we 
go. And it's showing one of my animal questions,  
63:30 - zero question. I can check this. If I go down 
here into my view dev tools. I'm inspecting  
63:37 - the question box component. And looking at the 
props, I see, I get the current question object,  
63:45 - which has the question a carnivorous animal eat 
flesh, the same thing we're seeing on the screen.  
63:50 - And if I go to my app component, I can look at my 
index, which is zero. So if I edit this and say,  
63:59 - one, then it actually changes the question 
that I'm passing to the question box component,  
64:06 - because now it's at the first index instead of at 
the zero index. So if I go back to question box,  
64:12 - you can see the question is changed. So let's 
set up the navigation between questions this  
64:18 - next button without having to go into the view dev 
tools to change the index. Back in my app dot view  
64:25 - component, after data, I'm going to create 
another object called methods. And in here,  
64:34 - I want a method to increment my index value to so 
I can navigate through the questions. So I'm going  
64:42 - to call it next. As a function. This is basically 
a shorthand syntax for having a key of next and a  
64:52 - value as a function. But I can just write it like 
this in JavaScript. And in here, the only thing I  
64:58 - want to do right now is take The index, which 
I can refer to as this dot index in my method,  
65:04 - and increment it by one. So this dot index plus 
plus, and that will take the current value of  
65:13 - this index and data and add one to it every time 
the next method is called. So I'm also going to  
65:19 - want to pass the next method into the question 
box. So the same way I did with current question,  
65:28 - I'm going to pass in the next function, and then 
go to question box and receive it here. In my next  
65:37 - button, I'm going to spread this out, I'm going 
to add an app click method, and then call the  
65:46 - next function on click. And of course, down here, 
I have to receive that prop. So I'll say next,  
65:54 - which is also a function. So now when I click 
the Next button, it should increment the value  
66:02 - by one by calling the next function in app dot 
view, and then app dot view should pass down the  
66:11 - next question in the list. So let's see if this 
works. View is still running. And let me go to the  
66:18 - browser. So I have my zero index right now. And 
something's not working correctly. It says current  
66:24 - question is undefined at question box. So let 
me go in here and see it's still at index zero,  
66:33 - of course, because we're getting an error. 
And here, I have the next function and current  
66:39 - question. So everything looks okay in our data. 
And I think we're not quite getting the best error  
66:46 - message. So I'm going to check in another browser, 
copy this, go to Chrome. And now I can check in  
66:55 - the Chrome Dev Tools. And here it's saying cannot 
read property question of undefined. So let's go  
67:05 - to the question box component and see what it's 
talking about. Oops. is in question box. It says,  
67:17 - cannot read property question of undefined. So 
that means current question is undefined. But  
67:23 - when we look at the dev tools, it's defined. So 
that means for a brief moment, when this component  
67:29 - is mounting, it's still waiting for the data to 
come from this component. And we can see that I'm  
67:36 - just going to add a lifecycle hook here. And I'm 
just going to console dot log, this dot current  
67:52 - question, Ben back in the browser, I'm gonna 
refresh this. And it's undefined. But in the dev  
68:01 - tools, it is defined. So that means right when the 
component mounts, it's still undefined. And it's a  
68:09 - moment later when the questions come back from 
the server, and it goes into the state in this  
68:17 - component, and then it gets passed to the question 
box component. So an easy thing to do would be not  
68:24 - to render the question box component until these 
questions are defined. So wait until we fetch the  
68:32 - questions and save them in the component state 
until we render this component. So I'm going to  
68:39 - add a V if directive. And I'm going to say V if 
questions dot length. So if the array is empty,  
68:51 - then the length will be zero, which is a false e 
value. So the question box won't render. But as  
68:59 - soon as the questions come back from the server, 
the question length will not be equal to zero.  
69:04 - And so question dot length will be truthy. And 
question box will render. So let's see if this  
69:10 - fixes the error. Refresh. Let me go to the 
console. And now there's no error. Of course,  
69:20 - we're still getting our lock. But it fixed 
the error, because now for the brief moment  
69:24 - in time question box is not rendering without the 
data available to it. And now we're able to also  
69:31 - navigate between questions, just as we would 
expect, with the next function incrementing  
69:40 - the index. Of course, there are still problems 
because when the index gets to 10, it'll throw  
69:45 - an error because that's past the length of the 
questions right, and we'll fix that in a minute.  
69:51 - Back in the question box component, let's add the 
list of answers here instead of the dummy text. So  
69:58 - if you remember our data's Structure had a list of 
the three incorrect answers and then the correct  
70:04 - one separately. So to display all four answers, we 
just need to put the four answers together. So as  
70:11 - a temporary solution, let's use a computed method. 
So I have an object of computed methods. And I'm  
70:21 - going to call it answers. So I basically have to 
take current question from props, and the array  
70:31 - of incorrect answers. And I'm actually going to 
assign this to a new array, I'm going to say let  
70:40 - answers equal question that incorrect answers. And 
what I'm doing here is making a copy of the array  
70:52 - instead of referencing the same array. And now I'm 
going to need to take answers this answers array,  
71:00 - and append or push the correct answer onto the 
end. So take current question that correct answer  
71:11 - and push that onto the array. And of course, this 
is the array that I want to return. So I'll just  
71:17 - return that. So I should have all four of my 
answers in this array now. And for right now, I  
71:22 - will just replace it in here with a V four. So I'm 
going to do V for vehicles and answer in answers,  
71:35 - which is going to reference our computed answers. 
And here, it's going to complain, because for any  
71:43 - V for loop, I'm going to need a key attribute. So 
view requires this for accessing these elements in  
71:50 - the DOM. So I can do a V bind key. And usually, 
you want to do something unique. Here, we kind  
72:00 - of know all of the answer, or each answer is 
going to be unique. So each paragraph tag that is  
72:09 - created in this for loop is going to have a unique 
key, which will be equal to the answer. Usually,  
72:15 - if you're doing this in an actual application, 
you'll want to use some kind of unique identifier,  
72:22 - or view also gives you the option here of 
getting the index in the array. So you could  
72:29 - call it index, and then use index here as your 
unique identifier. And I guess I'll just leave  
72:37 - it like that for now. Now, if we were to look at 
this right now, we would see four empty paragraph  
72:43 - tags. So I'm going to put the answer text inside 
with double curly braces. Save that now I'll test  
72:53 - it in the browser, go here, refresh. Looks like 
I'm getting an error. What error Am I getting?  
73:00 - Seems like a similar error to before getting 
current question is not defined. Oh, so I actually  
73:07 - referenced current question incorrectly. If you 
look here, I'm referencing current question.  
73:15 - But that's assuming that it would be inaccessible 
variable, actually, because it's a prop. I need to  
73:23 - access it through this current question. And I'm 
going to have to do this current question correct  
73:28 - answer as well. So this should fix the problem. 
And actually, anytime you want to access a prop  
73:35 - or a data variable in another function, whether 
it's a method or computed, or anything else,  
73:42 - you have to do this dot the name of your variable. 
So I'll save that. See if that fixed it. And yes,  
73:49 - it is fixed. These are just old aerosol refresh. 
So it is fixed. But we're getting just the numbers  
73:56 - of the answer and not the answer text. So there's 
actually another mistake here. And it was in how I  
74:03 - returned answers. So I'm going to pre push answers 
here, push the correct answer onto the array. And  
74:11 - now I will return answers. And that should fix the 
problem. Yep. And now we're getting the correct  
74:18 - looping through our answers. And they're all 
for displaying if we go to the next next next,  
74:23 - and is displaying all their answers. Now, we 
actually want this to look a bit more like a list  
74:28 - and also make it clickable for the users. So I'm 
going to go to View bootstrap again. components,  
74:36 - bootstrap view. And I'm going to go down to should 
be a list group. Here's it, here it is. And we  
74:44 - want to display it like this. This will make it 
easy for a user to hover and click on an element.  
74:50 - So this is pretty easy. I'm just going to copy 
this list group here. Since this is exactly what  
74:55 - I want it to look like. Go back to my code and 
I'm going to paste the list group in here. These,  
75:05 - tab them over. And I'll get rid of all except one. 
Now I want the list group on the outside, and I  
75:13 - want to loop through and make a bunch of these 
items. I'm going to put this on another line, put  
75:20 - this over format at nice. And now I can copy paste 
the loop before loop, and also copy this and then  
75:38 - put the answer inside instead of the dummy text. 
And that should work. Let me save that and see  
75:46 - how it looks in the browser, go here. And it works 
just fine. So I don't really like how the buttons  
75:53 - and everything rubbing up against each other and 
then up against the answers. So if I look in my  
76:01 - dev tools, I can refer to these with the class 
list group or list group item. So I'm going to  
76:07 - copy this class, go back to the application and 
just add a style tag to the bottom. Any view  
76:19 - component can have a style tag in it. And there 
are different options you can use for styling.  
76:26 - I'm just going to use default CSS. You can also 
use sass, if you want to. I'm also going to denote  
76:34 - that these styles are scoped, meaning they won't 
be global styles, they will only affect styling in  
76:41 - this component. And I'm going to paste the class 
that I copied and say that for the list group,  
76:49 - I want to have a margin, let's say margin, bottom 
of 15 pixels. Save that, see how it looks. And  
77:03 - there's a little bit of padding. Now for the 
buttons, I'm going to put a sideways margin,  
77:08 - and I'm going to reference these as btn from the 
button class. So I'll put margin, I'll just make  
77:19 - the top and bottom zero, and then left and right. 
Maybe I'll give it five pixels. Save that. Now it  
77:29 - looks a little bit better spaced out. So now 
to make the buttons clickable. Let's go back  
77:34 - to the question box component. And I want to add 
an add click function here. So at click equals a  
77:43 - new function, I'm going to create called select 
answer. And I'm actually going to pass it the  
77:52 - index of the answer that was selected. And I'll 
go down and create this function under methods  
78:02 - an object and selected answer. And then I'm just 
going to log out the index here. Let me test this  
78:19 - in the browser. See if it works. And it does. 
So I have the correct index of the answer I'm  
78:28 - selecting, the next thing is to save the Select 
index on the component. So I'm going to create a  
78:36 - function here and return an object of our data 
variables. And the first one, I'm going to say  
78:50 - is selected index. And for right now just set it 
to null. And now down here in the selected index  
78:59 - method, I'm going to say this dot selected index 
equals index. And we can see this in the view dev  
79:10 - tools. Go back to the browser. Gonna refresh, 
go to the View dev tools. And in question box,  
79:20 - I can see selected indexes No. Okay, so I tried 
refreshing. And let me click again. And again, and  
79:29 - for some reason, this state here isn't updating. 
But if I hit refresh, in my view dev tools,  
79:35 - then the state updates to the correct number. And 
now if I click on this first one here, and click  
79:44 - refresh, now the state updates to zero. So for 
some reason, the view Dev Tools aren't updating  
79:49 - but our function is working correctly. There are 
still a few more steps to do to be able to get  
79:56 - our answers working correctly. And first of all, 
there's no visual feedback to the user to let them  
80:02 - know to first click on an answer or that they've 
selected an answer. So let's first create a hover  
80:09 - style. And I'm going to go below here, copy this. 
And say list group item. Hover, hover state. So  
80:22 - when the user hovers over it, I want to just 
change the background color slightly. Right now  
80:28 - the background on the answers is white, I believe. 
So let me change it to a shade of gray. If FFF is  
80:37 - white, maybe I'll do E. And see how that looks. 
Now when you hover over it, you can see that it's  
80:46 - a clickable item. Another thing I should add is 
changing the cursor to a pointer. And now when I  
80:58 - hover, I can see that I have this little clickable 
hand. Unfortunately, when I click, let me click  
81:04 - on Neanderthals. And I still have to refresh this. 
It's selecting the index in the data, but the user  
81:12 - has no feedback here as to which answer they've 
selected, or if the application is even working.  
81:18 - So let's fix this by adding selected classes. Back 
in the code, I'm going to add two more classes  
81:26 - here. One is for a selected answer. And I'm going 
to give this background color. Let's just say blue  
81:39 - for right now. Background color blue, and then 
correct answer. When the answer is correct. We're  
81:47 - going to give it a background color of green. And 
one more when the answer is incorrect. I'll give  
82:00 - it a background color of red. In order to add 
these classes into the code, we're going to use  
82:10 - one of our data variables selected index, which 
should be set to the user selected index when they  
82:19 - click on an answer. And we need to add a V bind 
property here and bind and bind a CSS class to  
82:27 - this. So we're going to put class equals, and then 
it's going to be an array, we're actually going to  
82:34 - add things to this later on. But for right now, 
I'm just going to do selected index. If it equals  
82:44 - index, then we're going to use a ternary. And I'm 
going to say, let's give it the class selected,  
82:54 - selected. And if it's not, then we'll give it just 
an empty string, no class, save this. And then in  
83:04 - the browser, we try selecting a class. And it's 
not quite working, when we look at the console. If  
83:13 - I refresh, then it does work. Unfortunately, it's 
a really dark, ugly color. So let's just change it  
83:22 - to maybe a light blue, may go down selected could 
be light blue. Let's do light green, back in the  
83:33 - browser. Now it looks much better. And then if you 
go next? Of course, it's not clearing the answer,  
83:44 - which is another bug we're going to have to fix a 
second bug is that our answers aren't shuffled. So  
83:50 - we actually know that every fourth answer here 
is the correct one. And then on top of that our  
83:57 - Submit button doesn't do anything yet. So let's 
go back to the code and fix these three things,  
84:02 - starting with the answer shuffling. to shuffle the 
answers. For every single time that the question  
84:09 - changes, I'm going to add something called a watch 
method here. It's just like computed or methods  
84:17 - in that it takes an object of functions. And in 
this object, I can watch for changes to my props,  
84:24 - it will run this function when it changes. So 
I'm actually going to give it the same name  
84:29 - as my current question prop. And then when the 
current question changes from the parent, it's  
84:39 - going to run this function where we will shuffle 
our answers every time. So the first thing I want  
84:45 - to do in the function is to set this that selected 
index back to no every time the question changes,  
84:54 - and then I want to shuffle the answers that 
shuffle answers. And shuffle answers is going  
85:04 - to be another method that I create here. And 
I'm going to copy paste this answers array  
85:13 - I was creating there. And here, I'm going to put 
this that current question dot correct answer. So  
85:28 - I have them all in an array, all four answers. 
Now I could do this with a for loop and some  
85:34 - randomization. But there's actually a really nice 
helper library that I can use for this to help me  
85:40 - shuffle an array, and it's called lodash. lodash 
is a very popular JavaScript library that's full  
85:46 - of useful utilities that might take you a while 
to write on your own, and that are common in  
85:52 - many projects, like having to shuffle an array. So 
I'm going to go to the lodash. github. Right now,  
86:05 - we're just going to do NPM, I lodash in 
the terminal. While that's installing,  
86:14 - I'm going to go back to the browser. And we're 
going to be using a function called shuffle.  
86:25 - In the root of the lodash GitHub repo, you can see 
that every single utility function in the lodash  
86:33 - library is listed here as its own file. So I can 
actually go into shuffle j s, and see exactly how  
86:42 - it works, what algorithm they're using for the 
shuffle. And if I wanted to, I could just borrow  
86:48 - this one file and any files that it imports, 
instead of importing the whole lodash library,  
86:55 - I think it's really nicely laid out in this 
fashion. And it's a very good learning experience,  
87:02 - if you want to look through some wall written 
algorithms in JavaScript. So it should be done  
87:07 - installing. Let me go back to my server NPM run 
serve. Now back in my code, I'm going to add the  
87:18 - lodash library, I need another data property, 
where I'm going to put shuffled answers, this  
87:26 - is going to be an array and I'm just gonna call 
it shuffled answers. And here, I'll put this dot  
87:36 - shuffled answers equals now lodash. The convention 
is to import it with an underscore and then use  
87:46 - it instead of calling lodash dot shuffle. I would 
import it as an underscore here. And so I'm going  
87:57 - to do that at the top of the script file, say 
import underscore from lodash. actually get rid of  
88:09 - this mounted function, and I need to tell it what 
array I want shuffled, which in this case is the  
88:16 - answers array. So I do have a typo here. Instead 
of saying current question, I'm saying correct  
88:22 - question. Just going to fix that. Now, if I look 
at the browser, then I'm going to refresh. And  
88:30 - let's take a look. So right now we don't have any 
shuffled answers. Let's see if when we hit next,  
88:36 - we actually get shuffled answers, which you can 
see bird is the first element of the array at  
88:44 - the zero index, in the regular answers where we're 
just appending, the correct answer onto the end.  
88:50 - And then in the shuffled answers, bird is the at 
the second index, so we can see shuffling works,  
88:57 - unfortunately, it only works as we click through 
the questions. Also, we can check and see that  
89:03 - selection works. And then it does reset after we 
click for the next question, which is good. Now,  
89:10 - how do we get it to shuffle on the first question, 
there are actually two ways we can do this. Let  
89:16 - me go back to the code. And the first way is 
something that you already know, we can add a  
89:22 - mounted lifecycle hook just like we had before. 
And then we could call this dot shuffle answers  
89:29 - from here. And that would work that would shuffle 
answers on the first component mount. And then  
89:37 - every time after that, when the current question 
is updated in props, it would shuffle the answers,  
89:43 - which is fine, it gets the same functionality, 
but there's also another way that might be a  
89:49 - little bit better. So I'm just going to show you 
in these watch functions. Instead of making them  
89:56 - a function. You can make it an object And set 
some options on the object. So I'm just going  
90:03 - to comment this out real quick and set it to an 
object. And one of the options we have is to set  
90:13 - immediate to true. And then we can add a handler. 
Oops, which is another function. And then inside  
90:24 - of this handler function, we can do the same 
things we were doing before, and it will be called  
90:30 - like a regular watch function. Get rid of this. 
And now let's see if it does, in fact, update  
90:38 - and shuffle the questions for the first question 
that is shown back in the browser, window refresh.  
90:47 - And then check and see if they are shuffled. And 
yes, this is great. We do have shuffled answers  
90:54 - now. So just to reiterate, what immediate does 
is, instead of only running this watch function,  
91:02 - when current question updates, it's going to also 
run it when current question first gets passed as  
91:09 - props. And then every subsequent time that it 
updates, it will also run the handler function  
91:13 - again. Here, I'm going to update the submit 
button. And to clean it up a little bit, first,  
91:22 - take away this H ref that we're not going to use, 
and then put it on separate lines, because we're  
91:28 - going to add a couple more things here. For right 
now, if you remember, there's the V on directive,  
91:36 - which I can attach to events like click, so v on 
click. And then I want to run a function that I'm  
91:44 - going to create called Submit. Answer. And here 
I'm going to change this directive to use the  
91:50 - shortcut. And now let's create the function submit 
answer here. Down in our methods, submit answer,  
92:02 - and this will run whenever that button is 
clicked. And the first thing we want to do is  
92:07 - store whether or not the answer is correct. So 
I'm going to create a variable and by default,  
92:15 - I'm going to set it to false. And then if the user 
got the correct answer, I'll set it to true. So if  
92:23 - this dot selected index equals the correct 
index, meaning they got the correct answer,  
92:34 - then I'm going to set is correct to true. And 
what this is, is correct variable, I need to be  
92:42 - able to tell the app component whether or not 
the user got it correct. And also let the app  
92:48 - component know that the answer was submitted. 
Because in the header, we have a counter of the  
92:54 - correct answers versus the total answers. And this 
information will have to come from question box  
93:01 - through the app component and passed as props to 
the header. So let me create a new prop from the  
93:08 - app. And it's going to be this dot increment. And 
I'm going to pass whether or not the user got the  
93:15 - answer. Correct. So is correct. And I'm going 
to go ahead and add this as a prop here. It's  
93:23 - increment is going to be a function. And now from 
the parent component, I need to actually add this  
93:33 - function. So let me go ahead and pass it down. And 
I have to create the function in methods. Add the  
93:46 - increment function with the is correct Boolean. 
And here, I need to keep track of two things, the  
93:56 - number of total user submissions for answers, and 
also the total number that are correct. So first,  
94:04 - I'm going to check if it's correct. So if is 
correct, I'm going to increment a new data  
94:13 - variable for the number of correct. So up here in 
data, I'll go ahead and add these. So let's say  
94:21 - the number of correct answers set to zero and the 
number of total answers that the user has answered  
94:30 - also set to zero to start. And down here, I can 
say the number of correct increment that number by  
94:39 - one and then the number of total, also increment 
that number by one. I forgot that this here. So  
94:49 - this DOT number, correct increment by one, this 
dot total increment by one. And I want to do one  
94:57 - more thing here. And that's pass these two values 
to the header component to use. So add it here  
95:04 - or use v bind and pass the number of correct. And 
also the numb total. Now in the header to receive  
95:23 - these props, I'm going to create the script tag, 
script and export an object with props. And I'm  
95:39 - going to do props as an array this time, just to 
have both different ways. And I'm receiving the  
95:44 - number of correct answers from the parent as well 
as the number of total answers. And I can put them  
95:54 - here with double curly braces. So the number of 
correct out of the number of total. Now we changed  
96:07 - a lot of things. Let's look in the browser and 
see if this works. Let's see what it's complaining  
96:14 - about. Seems to be okay, right now. I'm gonna 
select an answer, click Submit. Click Next. Now,  
96:26 - I'm wondering why it's not incrementing. correct 
them total. And it seems to only be incrementing,  
96:36 - the number of correct. So let's look back in 
the code and see why the total number is not  
96:41 - incrementing. So we have the num total as props, 
that should be fine. Let's look in app num totals  
96:51 - getting past your num total here. And here. I'm 
just doing total. So I'm going to put num total  
96:59 - and that should fix the problem. Let me refresh 
just in case. Click on and answer. Submit. And now  
97:09 - my num total is incrementing. Though we shouldn't 
be able to submit a question more than once.  
97:15 - Because right now there's nothing stopping us from 
continuously submitting, or even submitting before  
97:22 - we have selected anything. So really, we should 
be disabling the submit button until we make a  
97:29 - selection. So let's go ahead and do that. And 
I want it to set as disabled if they have not  
97:36 - answered the question yet. So I'm going to do v 
bind and then the HTML attribute of disabled. And  
97:45 - I want this to be true if they haven't answered 
the question yet. And false if they have already  
97:53 - answered it, and then the button will work. So I 
can use one of our data variables, selected index,  
98:00 - because it will be no until they've selected an 
answer. So I'm going to say selected. index equals  
98:11 - No. And let's look in the browser and see if that 
works now. So it is disabled, I can't click on it  
98:20 - right now. But when I select an answer, it 
gets brighter, darker blue. And now when I  
98:26 - hover over it, you can see the hand. And now it 
selects correctly. And if I scroll up, it will  
98:32 - still be incrementing. Two out of seven. Great. 
Now let's work on not being able to submit the  
98:39 - answer multiple times like we can right now. What 
we are doing here, just checking if the selected  
98:46 - index is now only accounts for the case where 
the user has not answered the question yet. So  
98:53 - we're going to have to add another check to see if 
the question has already been answered. And if it  
98:59 - has then also disabled this. So I'm going to add 
another data variable called just answered and set  
99:10 - this equal to false. And then up here, I'm going 
to say and answered so as long as both of these  
99:21 - conditions are met. And now I'm going to have 
to add these to some functions down here. In the  
99:31 - Submit answer function, I want to set this.is for 
this dot answered equal to true because they've  
99:44 - already answered the question if this function is 
running, and then in my watch handler, I also want  
99:50 - to reset this thought answered, as false for 
every question I think actually in the button,  
100:05 - I think I'm actually going to have to do 
in order here. So if it's No, they haven't  
100:13 - selected answer at all. Or if it already has 
been answered in either one of these cases,  
100:18 - it should be disabled. Let me save that and then 
go to the browser refresh. And then see my button  
100:28 - is disabled. Probably not a very good color for 
disabled button. Oh, well. And now it's enabled.  
100:34 - And I submit, and now it's disabled again, after I 
submit, and it counted up and I got the incorrect  
100:41 - answer. Now, it would be kind of nice to see which 
one is the correct answer, because I know I got an  
100:46 - incorrect because of this counter. But I don't 
really know which one of the other three was the  
100:52 - correct answer, and I can't submit it again. So 
let's change that in the styles. Jumping back into  
101:00 - the code, let's store the correct answer. I scroll 
down to my data, I'm going to add another variable  
101:09 - called correct index. I'll set that equal to null 
initially. And now when I shuffle my answers,  
101:19 - meaning when I get a new question, I'm going to 
store which one of the answers is correct. I'll go  
101:26 - down to my shuffle answers function. And I'll say 
this dot correct index equals this dot shuffled,  
101:36 - shuffled answers inside the shuffled answers 
array. I want to get the index of the correct  
101:47 - answer after it's shuffled. So I'm going 
to use the JavaScript property index of the  
101:54 - array. And then I'm going to say it's the index 
of whatever the correct answer is. So I already  
102:00 - have the correct answer stored in this dot current 
question dot correct answer. So now this should  
102:10 - keep the correct answer. So we still know it, even 
though all the answers are shuffled together. So  
102:15 - let's see if this is working. Go to the browser 
refresh. Now look at my question box. And I have,  
102:28 - huh? Well, that's interesting. I must have made 
a mistake in typing this out. Let me go and check  
102:36 - the code and see what I did actually misspelled 
shuffled answers. I left off the s. So now I'm  
102:44 - going to save this, go back to the browser 
again. And it shows the correct index. Let  
102:53 - me go to the next question. And the correct index 
changes per question. Unfortunately, as a user,  
103:04 - how do I know if what I selected was correct? 
There's no way for me to know, it just moves on to  
103:11 - the next question. So let's add some functionality 
and styling. So the user can see feedback that the  
103:17 - answer is correct or not. And in doing this, we'll 
need to make the submit button work as well. If  
103:24 - you remember a while back, we made these different 
CSS classes selected, correct and incorrect. And  
103:30 - so far, we've only used the first one. So let's 
use the other two, we show the correct answer as  
103:36 - green after they hit submit. And if they selected 
the incorrect answer, then that's going to turn  
103:41 - from light blue, blue to red. So we're actually 
going to make a dynamic class. And here, I'm going  
103:48 - to put this on a separate line. So I'm going to be 
adding some stuff, just for the time being here.  
103:55 - Actually, I only want this selected class to 
appear if the question is not yet answered. So  
104:02 - I'm going to add a not answered here and selected 
index. And just for a second, I'm going to be  
104:11 - nesting ternary statements here, and then I'll 
clean it up after. So right now we have the case  
104:17 - where it's not answered. And they've selected a 
choice. So what about if that case is not correct?  
104:23 - So here, I'm going to add a case if it's answered. 
And the correct index equals index. In that case,  
104:41 - they got it correct. We want to show it as 
correct. believe that's the name of our class  
104:51 - here. Yeah, correct. And otherwise, I can show it 
Has nothing. So let me save that and see how it's  
105:02 - working so far. Yep. So that's the correct answer. 
And now it shows the correct answer there. It says  
105:18 - this, there's going to be another case that we 
have to add here, after here, so I'm going to copy  
105:24 - this actually. And it fits not equal to index, 
I'm going to say we're going to use the incorrect  
105:36 - class. Otherwise, no class. So if it's answered, 
and they didn't get the correct answer, then I  
105:43 - want it to turn red. So let's see if that works. 
Obviously, it didn't work that well, because every  
105:50 - incorrect answer is turning red. And I just want 
the user selected one to turn red. So back in the  
105:58 - code, I'm going to have to add one more check 
into this chain. And that will be if selected,  
106:05 - index equals index. And this is getting kind of 
long. And back in the browser, I mean, refresh.  
106:16 - There. And now it correctly shows, of course, 
this logic that I wrote is kind of out of hand.  
106:27 - And it's definitely messy to do all of this inside 
of a class. Just to clean this up. We're going to  
106:35 - move all of all of these nested ternary E's into a 
method. And we'll call that method. Answer class.  
106:46 - And we'll pass it the index, each list group item 
that's created. So each answer is going to call  
106:56 - this method in order to see what class it's going 
to have. So I'll go down to methods and add this  
107:05 - one on to the end. And answer class, it's going 
to be past the index of the answer. And then,  
107:14 - just for reference, these are all the nested 
Turner's I had up there. I'm going to copy the  
107:20 - first one. And first I need to create a variable 
called answer class. And set that equal to an  
107:31 - empty string of an if statement. So if it's not 
answered, but they've selected an answer, then  
107:41 - I'm going to set answer class equal to selected. 
And I'll just change some offsets here. And if  
107:52 - it's answered, and they got the, or the answer 
is the correct answer, then in the class for that  
108:04 - particular answer is going to be correct. And then 
a final case is if the user answered the question,  
108:18 - but they got it incorrect, and we want to make 
that red with the incorrect class. So it would  
108:25 - be answer class equals incorrect. And then down 
here, I'm going to return as answer class. Let  
108:39 - me clean this up. And let's see if that still 
works. Yes, so the answered is not defined. And  
108:49 - that's because again, I forgot to put this 
dot answered. So remember, in the template,  
108:58 - you can use any of these variables. But if you're 
referencing them in the JavaScript, you have to  
109:03 - reference them as this.so, this correct answer, 
this dot answered, and this dot selected index  
109:12 - and this correct index. So this is kind of long. 
I'm gonna put this on a few lines. And that should  
109:22 - work. So let me try it in the browser again. 
seems to be working. It's selected correctly.  
109:31 - Now I can submit, and I got it wrong. So it's red 
and green. Try one more question. Submit. Yep,  
109:40 - it works perfectly our counter still working. This 
is the whole quiz application. The GitHub code  
109:45 - will be linked below if you want to take a look. 
And you can see that there are different branches  
109:51 - so you could look at different parts of the 
tutorial in different stages. If you wanted to.  
110:00 - Now we're going to build an app that's slightly 
more complicated to demonstrate how view routing  
110:07 - and view x, which is view state management 
system work, it's going to be a basic four screen  
110:13 - application. Its theme is getting cats and dogs to 
be adopted. And we're going to be performing basic  
110:20 - CRUD operations to get used to state management. 
Now, there's a homescreen, two screens,  
110:25 - one for cats and one for dogs. And then you can 
click on any animal name, either cat or dog,  
110:31 - and it will load a screen just for that animal. So 
here in the terminal, I'm going to create another  
110:38 - view application using view create that I'm going 
to call it, adopt pets. If you remember last time,  
110:48 - we use the default boilerplate. This time, 
we're going to manually select features to  
110:54 - manually select, you can go up and down with the 
arrow keys, and press spacebar, such as here, I  
111:00 - want to select router. So I press spacebar. I also 
want view x. If I wanted to use SAS or something,  
111:07 - I would select this one. And then I think I'm 
going to leave testing out of this particular  
111:13 - application. So that's all I want. I'm going 
to hit Enter. And then it asked me a few other  
111:18 - questions. History mode for router is literally 
a one line change in the router. And I'm going to  
111:23 - show you how that works later. For right now I'm 
just going to put Yes, I'm going to pick SAS since  
111:28 - it's the most popular CSS preprocessor. And I want 
to show you how I include it my applications. For  
111:34 - this, I'm just gonna put standard config, although 
prettier, and Airbnb have some nice features as  
111:39 - well. Either way, all of these are just templates 
and starting points. So you can always modify any  
111:46 - rules that any of these set for you, I'm just 
gonna have it run linting every time I save a  
111:51 - file, and this is a personal preference of mine, I 
like to have my configuration in their own files,  
111:58 - such as my unit testing, config, Babel config, or 
my es lint file by itself instead of cluttering  
112:06 - up the package dot JSON that can get pretty 
unwieldy. Now, if I want to save it as a preset  
112:13 - for future projects, I can click I can type y and 
it's going to ask me to give it a name, I'm just  
112:20 - going to type no here, and then show you the one 
I already have. And now it takes a few minutes to  
112:25 - build the project. Great, it's done installing. 
I'm going to go into IE adopt pets directory and  
112:35 - open this in VS code. This is very similar to the 
project last time still have the index dot HTML in  
112:45 - public. A few differences here are that in the 
main j s. Instead of only rendering the app we're  
112:52 - setting our store for view x as well as our view 
router configuration in our view options. Another  
113:01 - difference is you'll notice that here we have a 
views directory and a components directory. Now,  
113:08 - if you look in the router, you'll notice 
that home and about which are the two routes  
113:15 - are both views. So these are the pages of your 
applications which are connected to the router,  
113:22 - and components are imported into the views 
or into each other. So if I look in home,  
113:29 - I can see it's importing the Hello World component 
hello world dot view. And it's displaying it to  
113:36 - the DOM. The idea is that components are reusable 
pieces. And each page stands alone as a distinct  
113:44 - view in your application. Now if I go back to the 
router, there's a lot of things you can do such  
113:49 - as lazy loading, or even using multiple components 
here. But I'm going to keep it simple for now. So  
113:56 - I'm going to take this out of here and import. And 
now I can set component to just about and get rid  
114:08 - of all these comments. And now it's and it renders 
exactly the same. It's just a bit easier to read  
114:15 - right now. Now the store I'm just going to give 
a quick overview. And I'll go in deeper, you're  
114:21 - basically creating a new view x store, which is 
a global object. So any functions or variables,  
114:29 - data, anything that you want to use maybe in 
multiple parts of your application. You can store  
114:37 - them all here, and then import them into whatever 
component you want. And it's like a global object  
114:45 - for your application. The first thing I want to 
do in this app is create the four pages and link  
114:51 - them together. If I look in views I have about 
at home, I'm going to go ahead and leave the  
114:56 - home component and delete the about one And then 
create one called cats dot view, dogs dot view.  
115:13 - And the other one I'm just going to call pet dot 
view. And I'll put a boilerplate template here.  
115:19 - And I'll do the same thing for dogs. put just a 
template here, and one for the pet page. And I'm  
115:44 - going to hook these up to the router. Now I've 
defined all four routes that I'm going to use  
116:14 - in this application, I'm going to update my app 
file to link to all four of those pages instead  
116:21 - of just home and about duplicate those. And now 
put cats, dogs and the pet page, which eventually  
116:35 - is going to be linked through these two pages. 
But I'll just leave it for now. Dogs and cats.  
116:43 - And let's see how that looks. Okay, it has all 
of the links here can go to the different pages,  
116:53 - I'm just going to add this pipe in between. Copy 
this. There looks much better. Now let me get  
117:07 - rid of all this extra stuff on that page, which 
is in the home component, importing HelloWorld.  
117:14 - And using this image, I'm just going to get rid 
of both of these. And just say home. Get rid of  
117:23 - this. And this. And now I'll delete the Hello 
World component. Perfect. Now just like before,  
117:39 - I want to import view bootstrap to help do 
the styling for me and lay out the pages,  
117:44 - we're going to go to the browser to bootstrap. 
Get started and install it with NPM. Start my  
118:03 - server and NPM I bootstrap view. Now back in 
my browser, I can copy the import in view.us.  
118:20 - And I'll put it in my main.js file. I'll put it 
up here with my other library imports. And since  
118:36 - I don't have a section for view.us, I'll put it 
right there. Now I need to import the CSS as well.  
118:41 - So I'll go and grab these links. And put them 
here. And that's it. Now that I'm importing view  
118:52 - bootstrap, I'm going to use some of their table 
components to display the tables of cats and dogs.  
118:59 - So if I scroll down here, see they have a table. 
And this table looks fine to me. So I'm going to  
119:11 - copy this big table and save it and go back to my 
code and include some of these. Now let me start  
119:22 - with cats. And here I'm going to add that table 
component. And now of course I need the data.  
119:28 - So I'll add a script tag to close it and export 
default, this object data function and return an  
119:42 - object. And now back in the browser and see I 
need an array of objects, which I already have  
119:50 - in another file. And I'm just going to copy paste 
that into my application. So I'll create another  
119:58 - folder in source And I'm just going to call it 
data. And in data, I'm going to make two files,  
120:06 - one file, cats dot j, s. And the other one will 
be dogs, dot j s. And I'm going to copy and  
120:17 - paste data that I already have here. Here are my 
dogs. This is an array of dogs. So I'll do export  
120:28 - default, this array, and I have some different 
information and metadata about the dogs. And make  
120:37 - close this one. And now I'll add my cats, which is 
also a very similar array. I'm going to add them  
120:50 - here. And now back in my cat stop view, I'm going 
to import cats from at data, slash cats. Now,  
121:09 - this app symbol is a shortcut that view COI sets 
up for you. And it's a reference to the source  
121:16 - directory. So that way, you don't have to do 
things like dot dot slash dot dot slash dot, dot  
121:23 - and whatnot. So I'm just going to use the shortcut 
at. And now I'm going to return cats here. So this  
121:34 - is the same if you don't know the shortcut, this 
is the same as setting a cat value equal to this  
121:42 - cats array that we're importing. But the shorthand 
is just to do it like this, since they both have  
121:47 - the same name. So now for items, I'm going to 
say, cats here. And I'll see how that looks in the  
121:55 - browser. Back in Firefox, if I go to adopt pets, 
and refresh, I must have stopped my server. Let  
122:04 - me look back at I turn, and yes, I did. So let me 
run NPM, run serve again. Great. Now my browser.  
122:20 - Alright, it's working. And now I have a cat's 
table showing all of my cats, I'm just going  
122:28 - to clean this up a little bit. So it doesn't 
go all the way to the edges of the page here.  
122:33 - And I'm going to add a B container in my app dot 
view. So for this router link, I'm going to wrap  
122:42 - it in B container, which is another bootstrap 
component provided by view bootstrap. And they'll  
122:51 - go back to the browser, refresh. And that looks 
much better. As far as the width, I also need a  
122:58 - page title. So let me create that real quick. Back 
in cats, I'm going to have an h1 here. And say  
123:07 - this is just cats for adoption. Alright, that's 
good. Not too fancy, but looks fine. Now I'm  
123:19 - going to copy paste this and do the same thing for 
the dogs tab. And I'll go back here. Go to dogs,  
123:30 - I'm going to copy paste this table and the script 
tag. And then I just need to change it to dogs.  
123:53 - Oops. Hear as well and hear. Great, so those 
two pages are looking good. Just to finish up  
124:03 - the homepage, I'm going to change this to an h1 as 
well. And I'm going to say adopt a new best friend  
124:15 - h1. So that's all of the nitty gritty out of the 
way. Now if I go back to my browser, you can see  
124:24 - that I have these three pages. But this page is 
supposed to be that of an individual cat or dog  
124:33 - kind of like seeing his individual profile. So 
if I go to cats, for example, then the pet page  
124:40 - should be something like cat slash one for the ID 
of that cat. So let's learn how to do this through  
124:48 - the view router. View router has something called 
dynamic route matching. What it does, instead of  
124:56 - hard coding the whole route, you actually have 
dine namic route variable as part of the route,  
125:02 - it's preceded by a colon, and then you can call 
the variable, whatever you'd like. And then you  
125:09 - can access this variable when you go to that route 
in the component associated with the route on the  
125:15 - route params object. So let's see what this 
would look like in our pet component. First,  
125:21 - I'm going to update the router. And say here under 
pets, I'm going to change it to be plural pets,  
125:29 - and slash ID for the pet ID. And I'm going to 
leave these as they are for right now. Now,  
125:37 - let me get rid of the link in the app dot view 
file to pets, let me just get rid of that. And now  
125:45 - we need our table components to have links to the 
pets page for every item. So we'll have to update  
125:53 - this table. Since right now it's kind of a black 
box. And we're passing in this array of cats to a  
125:58 - third party bootstrap component. So let's go to 
the bootstrap docs and see how we can turn each  
126:05 - cat in the table into a link to that page. I'll go 
to the browser. And I'm still under the bootstrap  
126:12 - component tables. This whole page is pretty big. 
So I've skipped down to this format our callback.  
126:18 - And basically, what it allows you to do is pass in 
a template with a dynamic href. So let's copy this  
126:27 - and go back to the code. I'm going to expand 
this, close it here and put this inside. Now  
126:40 - I want to mention something about slots, because 
you're probably going to see this a lot in view,  
126:45 - especially if you are using third party 
libraries like view bootstrap, or if you are  
126:51 - creating your own components for someone else 
to use. Now, in bootstraps B table component,  
126:58 - it's going to look something like my format or 
doesn't like this very much. So it's going to look  
127:07 - like template and then have something exactly 
like what we have with maybe a div inside. And  
127:13 - it's going to have a bunch of other tags, and 
it will have this somewhere slot. So bootstrap  
127:23 - is basically telling the component where to put 
things that we pass in to the this B table. So  
127:31 - it has different slots inside. And if it has 
multiple slots, which in this case, it does,  
127:37 - it will say name equals name, which will be a 
dynamic, because we have lots of different columns  
127:46 - that could vary in the table. So bootstrap will 
have a slot for each of our columns. And that's  
127:53 - how we can pass it in here. If you want to know 
more about slots, they're pretty easy. And they're  
127:59 - described really well in the view documentation. 
And here, I'm just going to replace this with  
128:05 - slash pets slash Variable Data dot value. And I'm 
going to change this to a router link, not using  
128:17 - a tag to router link and a forgotten link here do 
link you can use an a tag, I think it's a little  
128:28 - better and more consistent to use a router link. 
So let me go to the browser and refresh. And now  
128:36 - I have links for all of these. Now, I don't really 
want it to have the pet's name, I want the ID. So  
128:43 - let me go back and change it. And instead of data 
dot value, which will give me the name of the pet,  
128:50 - I'm going to do data dot index, which will give 
me the index of the row in the array. So let me go  
128:56 - back to the browser and try this. And now if I let 
me go home. Now if I go and hover over it, I can  
129:05 - see the link gives me the index. And if I go here, 
you can see in the URL, I have pet slash zero,  
129:13 - which is the ID of the pet in the array. So now I 
want to populate this page with the details on the  
129:20 - individual pet. So what I could do is take these 
pets arrays and import them into my pet component,  
129:28 - and then get the index off of the router variable 
and just look in the array in this component. But  
129:35 - I'm actually going to put all of the pets, dogs 
and cats in state and then pull the pet I want  
129:42 - from state. So let me go to the store. And this is 
a very small project. So I don't need to do this  
129:48 - but I just want to show you how I generally set 
this up. I make a new folder called store and in  
129:57 - store, I make a separate file for everything. 
So I have a file for State DOT j s, and one  
130:06 - for you tations dot j, s, and then one for actions 
dot j s. And now I'll make an index file to tie  
130:17 - these together, index dot j s. And I'm going to 
take what's in store right now. Take all of this,  
130:26 - copy it, put it in the index file. And now I'm 
going to import the other three files. So import  
130:35 - state, from state port, he tations from mutations, 
import actions from actions. And now I can use the  
131:02 - shortcut here. And here, oops, this object and 
get rid of that. And now of course, I need these  
131:15 - to be actual objects in each file. I'll just for 
some of these export a blank object for now. Same  
131:28 - thing in mutations save the save this. And now 
in state, I'll have a blank object. But I'm also  
131:36 - going to be importing the cat and dog data. So I'm 
going to import cats from a directory data slash  
131:48 - cats. And I'll do the same thing for dogs. Oops 
dogs, and dogs. And now on state now this object  
132:00 - is the default state of my application. So it's 
the data that I'm going to be able to pull into  
132:07 - any component that I want. So for right now, I 
will have these separate, I'm going to do cats  
132:12 - and dogs as separate arrays on my state. And now 
what I can do with this is go into my cat stop  
132:25 - view. And instead of importing cats from here, I'm 
actually going to import something from view x,  
132:32 - called map state. From view x, and down here, I'm 
going to use a computed object computed. And the  
132:50 - syntax for map state is to use a spread operator 
and call the function and pass it an array of the  
133:02 - items on state you would like to be able to access 
from this component. So here, I want to access  
133:08 - cats from state. So I won't actually need this in 
my data anymore. And I'm going to get rid of it.  
133:15 - So now I can get it directly from my view x store, 
I'll get this array. So let me go to the browser,  
133:23 - make sure that's working. Go home refresh. Now, 
let me go to cats. And it's not working. So I  
133:32 - must have an error. Let me see what error I have 
none here. Let me go to the terminal. Now that  
133:38 - looks good. So let's check the dev tools and see 
if we have a problem with our data there. And in  
133:44 - my view, Dev Tools, I can see cats is undefined. 
So let me see why it's undefined. If I go to my  
133:50 - VS code, it seems like I am mapping the state 
correctly from UX. So let me look and see if  
133:59 - it's in the view x dev tools, maybe view x. And 
in my base state, I don't have anything in my  
134:09 - base state. So let me see why nothing is in my 
state. If I go back to VS code, so I'm pulling  
134:16 - in the store from here. So I think the only thing 
I'll have to do here is just delete this old file,  
134:23 - because now it should look at the relative path 
store, which is now a directory. And since I'm  
134:32 - not specifying a file, it's going to look for 
the index.js file. And I'm exporting as default  
134:39 - the store from there. So let me go back to the 
browser. Refresh. Great, now it's working and I'm  
134:48 - getting the appropriate pets. So now I'm going to 
do the same thing for dogs. So I'm going to take  
134:57 - this actually the whole computed here and go to 
dogs. And I'm going to add that computed object  
135:06 - here. And I also need map state to connect the 
view x state from the store to this component. And  
135:15 - I'm going to map dogs here. And I'll get rid of 
dogs in data. Perfect. So now how do I figure out  
135:27 - whether it's a dog or a cat in the pet component, 
I could set this up a few different ways. But for  
135:34 - right now, I'm just going to put slash cat's here. 
And I'm going to turn this into another variable.  
135:40 - And because this isn't in my dogs component, I'm 
going to copy all of this and come back to dogs.  
135:50 - Instead of the end here, I think I missed the 
template. Oh, yeah, that's actually important.  
136:00 - So I'll come back to this. And I'm going to close 
the table here. And I just need to change this  
136:08 - to dogs. Now in my router, I'm going to have to 
change this to store this species. And then the Id  
136:21 - let me just make sure that's working back in the 
browser. Now. If I click on one of these, it takes  
136:29 - me to the species and then the ID. And now I can 
access these from my component. So back in my pet  
136:38 - component, I'm going to say this start route, 
actually, because of in the template, I don't  
136:52 - need this. So I'll just say route dot, I believe 
it's params dot species, and then duplicate this  
137:03 - row. And Id. Let me see if that works. So back 
in Firefox, and it does work as a species and  
137:13 - the ID. Now quick way for me to get to the right 
cat in this component is to pull in the cats and  
137:21 - dogs from state because this component is its own 
view, and is not connected to cats or dogs. So I'm  
137:28 - going to copy the script tag here, and then modify 
it. I have map state, which I want. And I'm going  
137:34 - to add dogs here. So I can listen to cats and 
dogs from here. And I just want to mention real  
137:41 - quick that you could do this same thing by saying 
cats, adding as a method here, and then returning  
137:49 - something like this dot store, dot State DOT cats. 
And this is actually the same thing as doing map  
138:02 - state here. But you're never going to see this in 
an application. This is pretty much the standard  
138:07 - syntax. It's shorthand. And it's easier to do, 
because sometimes you have a lot of elements on  
138:13 - state. And it's much easier to just use the map 
state method. And now I have access to these in  
138:20 - my DOM. So what I want to do is find out if it's 
a cat or a dog, and then display the information  
138:27 - here. So I'm going to make a method for this real 
quick. Methods object. I'm going to call it pet,  
138:37 - pet. And inside of pet, I'm going to check for 
first this species. So I'm going to say that  
138:51 - animals equals Actually, I need this here, this 
dot route dot params dot species. And now this  
139:04 - will either return cats or dogs. And so I want 
to access it on my this object. So I'm actually  
139:13 - going to pass it in as a variable. If this is 
confusing to you, then it's the exact same thing  
139:20 - as accessing these arrays off of state. So I could 
do this cat or this dot dogs. But I can also use  
139:28 - the bracket syntax and pass in a variable here. So 
I could pass in this cats, which is exactly what  
139:35 - I'm doing right here. Get rid of that. And now I 
have my animals here. And on my animals, I want to  
139:42 - see which animal I want to display. I'm just using 
an index right now. So it's easy. If I was using  
139:50 - an ID, then I would have to search through the 
array and find the animal with the correct ID. So  
139:57 - for right now, I suppose I'll just say animal, and 
then pass the index of the animal which will be  
140:06 - route.params.id. So I can do this.route.params.id 
here. And that should get the correct animal. And  
140:17 - now I'm going to return that animal and I should 
be able to use it in my DOM. So let me see if this  
140:26 - works. And instead of all of this, I'm just going 
to have animal dot name. Go back to my browser,  
140:37 - see if I don't have any errors, but I do. Oh, 
yes, property or method, animal is not defined,  
140:43 - of course, because I called it the wrong thing. 
So the method is called pet. So I actually have  
140:49 - to get rid of animal here. And I'm calling it pet. 
And then I'm returning animal from here. So this  
140:58 - should return the correct animals name. And let 
me check it back out in the browser. And great.  
141:07 - So now, if I click on, let's say, kick cat, 
it shows up with the correct name. Of course,  
141:13 - this is a little bit messy. And I don't want to 
be calling the method every single time I want a  
141:17 - property off of this animal. So what I can do is 
in data, I can put animal and set it equal to an  
141:26 - empty object. And then here, instead of methods, 
what I could do is put a lifecycle method here.  
141:34 - So I can say, for example, when the component is 
mounted, get rid of this. And now I can set this  
141:45 - dot animal equal to animal, which will set 
animal on my data object, and then appear,  
141:54 - I will be able to access animal dot name. And let 
me wrap animal dot name in an h1. Let me close my  
142:05 - h1. And I'm going to add the animals age here as 
well. So animal that age, close the p tag. And I  
142:17 - think I have a breed property. So let me just add 
that one real quick, too. So animal that breed.  
142:25 - Now I'll go back to the browser. Awesome. So these 
are old errors, I can just ignore them. Now I have  
142:37 - the name of my pet the age in years, and then the 
breed. And this works if I have dogs as well. Now,  
142:46 - I could probably put something to denote whether 
it's a cat or a dog here. So I think I should  
142:52 - take this species. And I'm going to add that in 
here. And I'll put it inside parentheses. And  
143:04 - then I also want a label for the animals age. So 
here's old. And for breed, I'm going to put this,  
143:17 - I should have this year to four age, I can put 
here and that should look a lot nicer. And now  
143:26 - when I go here, I can see I have labels on these. 
And I can now see if it's a cat or a dog. Great.  
143:35 - So another thing we probably want to do is be 
able to edit these animals to add CRUD operations.  
143:40 - And that will lead into how to use actions and 
mutations in the store. So let's jump back into  
143:48 - view x. Let's start by adding the functionality 
to be able to add a pet. To do this, we're going  
143:55 - to have to append the new pet to the array in 
store to one of the arrays. Now the pattern that  
144:02 - you'll generally see for doing this is definitely 
not updating state directly. Because that's what  
144:09 - mutations are for mutations are there to update 
state for you. And generally speaking, you will  
144:15 - call it an action that calls a mutation, which 
update state. And a lot of the time the actions  
144:22 - that you call will be where you're also making API 
calls because they're asynchronous. So we're just  
144:29 - going to use that pattern of using actions that 
call mutations that update state. So in actions,  
144:35 - I'm going to add an add pet method. And view gives 
me a context object here. And then I can use an  
144:48 - argument when I call this function. I'm just going 
to call that pet for right now. make this an arrow  
144:55 - function. And with context here, it has a couple 
MIT method on it. So I can use commit. And this  
145:05 - will call a mutation for me. So I'm going to need 
to create a new mutation. And I'm going to call  
145:11 - it append, pet. And I'm going to append that 
pet with my new pet object that's going to be  
145:20 - passed into this function. I want to make a note 
here that this is generally not how you will see  
145:26 - this being used. Because context, you only need 
the commit method off of it. So you can actually  
145:33 - pull that directly off the object here. And this 
is generally how you will see commit being used.  
145:43 - And remember, this object comes from view x. And 
this pet is the custom parameter that we're going  
145:51 - to be passing into the function. Now I'm going to 
copy this name, append pet, and go into mutations.  
145:58 - And I'm going to add a mutation called append 
pet. Here, again, we have two parameters. So the  
146:07 - first that view x gives us is state. So we have 
the application state. And then the second is  
146:14 - whatever payload we're passing into this function. 
So that would be pet here. And I'm going to make  
146:21 - this an arrow function again. And from here, we 
can mutate or update state. So I'm going to say,  
146:27 - so State DOT whatever species, which is an 
array, so I can actually push the new pet onto  
146:37 - that array. To do this, of course, I'm going to 
have to pass species into this with pet. So here,  
146:44 - I'm going to change this so that I'm passing in an 
object with pet, and also the species of the pet.  
146:56 - So for shorthand, and because I'm just passing 
this straight through, I'm just going to call it  
147:02 - my payload, which will have payload dot pet and 
payload dot species. And I can pass this payload  
147:09 - directly into my append pet mutation. And from 
here, I can D structure this and say, species,  
147:23 - and pet and state that species, which will be 
cat or dog, and I'll push the new pet onto that.  
147:34 - And that should append to either our cats or dogs 
arrays. So I'm going to do this for cats and dogs  
147:42 - at the same time. So I'm going to go to home and 
add a button here with a bootstrap class of btn.  
147:54 - And I think btn primary to give it some color, I'm 
going to say add new pet, and this should toggle  
148:03 - and add new pet form. And now in my JavaScript, 
I'm going to add a methods object and say,  
148:13 - toggle pet form. And this dot pet form equals 
the opposite of this pet form. And of course,  
148:27 - this is going to be a Boolean. So I also need 
to add data method and return an object of my  
148:35 - data variables. And one of them, of course, 
will be pet form, maybe to be more explicit,  
148:41 - I should say, Show pet form. So it's obvious 
that it's a Boolean. And to start off with,  
148:49 - I don't want to show this pet form. So I'm 
going to say it's false. And then every time  
148:56 - that this method is called, it will toggle the 
form from showing. So now we actually need the  
149:03 - form. And for that, I'm going to copy of view 
bootstrap form. And I'm just going to take this  
149:09 - most basic form at the top and then modify it. So 
I'll come down here and copy everything in B form  
149:23 - up b form. And now back to the code, going to add 
that form here. That looks good. And I have to of  
149:34 - course, update all of these functions because 
it's not going to run right now. So get rid of  
149:39 - at reset, which I'm not going to use now show 
pet form. So it will show this pet form if this  
149:48 - variable is true. So this button will toggle it. 
And I'm going to make a handle submit function  
149:55 - for when the user submits this form which will 
have Eventually call our action. Right here,  
150:02 - I'll add the handle submit function. And for right 
now it's not going to do anything. So let me just  
150:08 - fix the rest of my form real quick. We want the 
pet's name. First and foremost, we don't need  
150:15 - an email address for the pet. So I'll get rid 
of that one. And now this example input group,  
150:22 - I'm going to say pet's name. And for the drop 
down, I'm going to say, species. And for options,  
150:35 - it will just be an array of cats and dogs to 
choose from. And that should give me a good  
150:47 - drop down menu. I'll add one more form group here, 
copy this one, and overwrite the check boxes. And  
150:55 - I'll say pets age, enter age here. And type will 
be a number. Now here, of course, all of these v  
151:08 - models I need to update. So I'm going to make 
a new data variable here, I'm going to call it  
151:16 - form data. And it's going to be an object that's 
going to model all of my different form inputs. So  
151:25 - I'm going to have form data dot name, which will 
start as an empty string. And I'll just give age  
151:33 - a default of zero for right now. And species, I'm 
going to say is no. And let me update these here.  
151:42 - So form dot age, formed that species and name 
is fine. So also need to update this to form  
151:59 - data instead of just form form data and one more 
form data. So our form should be functional all  
152:07 - the way until submit right now, let me just try it 
in the browser, I have the add new pet button. And  
152:14 - it's not toggling the form. So let's see in the 
Vue JS dev tools, in app in the home component,  
152:23 - show pet form, doesn't switch to true ever. So let 
me say true here. And it does show the pet form.  
152:35 - Now I know where the errors happening, I go back 
to my code, I can see that this toggle pet form is  
152:45 - never being called. Because I forgot to add it to 
the button. So I'm just going to do an add click  
152:50 - here. Say toggle pet form. That should work back 
in the browser, refresh. And now it toggles on and  
153:02 - off. Great. Let's hook up the submit button. In 
the JavaScript here, I'm going to import another  
153:09 - view x helper called map actions. And this works 
in the same way as map state. To do this, we need  
153:25 - to add map actions to methods. Now the reason why 
we add the actions to the methods and the state  
153:36 - to computed is that we are watching for changes to 
state. And we're not watching for changes to these  
153:44 - static methods. They're just functions for us 
to call so that we can get state updated. So now  
153:51 - I'm going to pass in an array. And my action was 
called add pet. So I'm mapping that to my methods.  
154:00 - And now I'm going to call it from handle Submit. 
And I can do that by just saying this dot add pet  
154:09 - and then passing it the payload. So the payload 
is an object that I'm going to create here. So  
154:20 - const payload equals this object, and the payload 
should have the species and then it will have a  
154:28 - pet object with things like the name and age. Now 
to get this information. I'm going to pull it off  
154:36 - of data here. So the form data object. And I can 
do that by using this syntax. When a pull species  
154:50 - age and name off of this that form data and put 
this in the wrong spot. So Click this outside of  
155:02 - that object. And now here I should be getting all 
of my right information, passing it as an object  
155:10 - with species and pet as the payload. And then this 
will go into the actions here as my custom payload  
155:18 - that I'm passing through to a mutation. And the 
mutation will have species and pet pulled off  
155:27 - payload. So I can update state cats or State DOT 
dogs and push the new pet. Let me see if this is  
155:36 - working in the browser. refresh this add pet, 
add Bosco, and is a cat Smit, okay. So if you  
155:53 - notice the page refresh here is pretty quick. 
But it's not actually going to submit the form  
155:59 - correctly because of that refresh. It's handling 
it in the default way when it's supposed to be  
156:05 - submitting a form to a server. But of course, 
that's not the functionality that we want. So  
156:09 - I'm going to come back here, go to home. And now 
for our submit handler, I'm just going to add  
156:17 - that prevent. And if you remember, this modifier 
is just like calling event dot prevent default,  
156:25 - just like you would in a regular function submit 
handler. But this is a shortcut that view has. So  
156:32 - I'm going to come back to the browser. And now 
if I add a new pet, cat, the age is 22. And I'm  
156:43 - going to submit this. And I think it's submitted 
correctly. But of course, we're not clearing out  
156:49 - the form after so there's no feedback, whether or 
not it's submitted. So let's go to cats, and we  
156:55 - see a cat is appended to the table. Awesome. Now 
I just want to clean it up a bit and clear out the  
157:01 - form when I'm done. I'm gonna see, no, it's clear 
now. But I wanted to clear right after I submit to  
157:08 - give some user feedback. So if I come down here, 
I'm going to add something to reset the form after  
157:17 - Submit. So I'm gonna say that this start form 
data equals an object. And I'm going to reset  
157:29 - it to exactly what it was before. These. Okay, 
now, let me try to submit another pet. This time,  
157:38 - I'm going to submit a dog 12. Submit. And now it's 
resetting the form after it's submitted. And let  
157:49 - me go to dogs here. And it correctly added the 
dog. Of course, there's a lot of other things we  
157:55 - could add. But that's basically how view x works 
is that you'll call an action from a component  
158:01 - and actions are asynchronous. And then from the 
action whenever you're done doing what you want  
158:07 - to do with the action, you call a mutation, and 
then the mutation update state, and then whatever  
158:12 - components are listening to state, because 
you're mapping the state to a computed function,  
158:18 - those components will update in the DOM, where 
it's needed. Now I want to show you real quick  
158:24 - how getters work. There is actually another object 
that goes into the store. And it's called getters.  
158:34 - So getters are like computed properties. But for 
your view x store, what does that mean? Perhaps  
158:42 - you want to pull state into a component, but you 
want to modify what the component receives while  
158:50 - you're pulling it. So it won't actually update 
state, but it will get back something that you  
158:56 - want out of state. For example, we could count how 
many animals we have in our arrays in a getter,  
159:03 - and then call that getter from everywhere, we 
want to get the number of animals. So let's just  
159:10 - create that real quick. I need to first create a 
getters object and a getters file. And it's the  
159:27 - same as the other view x objects. I'm going to 
export default in object here, and I'm going to  
159:33 - call it animals count, which is a function and 
here I'm going to have access to the state and  
159:41 - I can do whatever I want with the state before I 
return it to a component, another arrow function,  
159:47 - and if I want to get the total count of 
both cats and dogs, I could say something  
159:56 - like state that Cats dot length plus state that 
dogs dot length. And now, to use these getters,  
160:12 - I need to put it in one of my components. So I'm 
actually going to put this in the home component.  
160:17 - And I'm going to put it just above the button. So 
I'm going to say, animals count here. Of course,  
160:29 - I need to map this. So there's another method 
called map getters. And I need this inside the  
160:39 - computed, because we're watching for changes on 
this. So I'll put map getters here. And this is  
160:47 - using the spread operator as well. So that's a 
method with an array, the same format, and that  
160:55 - will be animals count, let me make sure I got that 
right. Animals count animals count perfect. Let's  
161:02 - see if that works in the browser, if I go home, 
and I see I have eight, which is exactly how many  
161:09 - animals I have, because I have four cats and four 
dogs. But of course, pulling this from a getter  
161:14 - didn't update state at all, is just modifying 
how state is seen by a component. So I can run  
161:20 - whatever function I want. Now, one common thing 
that you'll be using getters for is for filtering,  
161:28 - so I can say something like get all cats. Now, 
to do this, I'm going to need to create another,  
161:41 - we're going to need to create another array here. 
And this time, I'm going to call it pets. So  
161:50 - instead of cats and dogs in separate arrays, I'm 
going to give it one array, cats and dogs. If you  
162:02 - haven't seen this syntax before, it's basically so 
that the array is flat, because if I just put cats  
162:09 - and dogs without the three dots behind each, it 
would come out being all of the cats in one array,  
162:16 - and then all of the dogs in another nested 
array. So this is an easy and nice way to  
162:22 - make all of the pets together in one array. 
So now that all of the pets are together here,  
162:29 - I'm going to need to add what species they are 
inside the data to differentiate between the two.  
162:35 - So I'm going to add species is cat. I'm going 
to copy this and just paste it in all of these.  
162:54 - one extra. And I would put this in dogs too. But 
just to show the getter example, I'm going to say  
163:01 - get all cats will be return State DOT pets, which 
will have both cats and dogs in it. And then dot  
163:11 - filter, the filter method takes a function, 
which will give us each pet one at a time,  
163:19 - and allow us to return just the pets we want in 
an array. So I'm only going to include the pets  
163:26 - in the array where pet sees me pet that species 
equals cat. And now I should be able to use this  
163:40 - get all cats getter? Well, once I add state from 
my component, and I'm going to do that here. So  
163:48 - I'm going to say add another variable, get all 
cats. And I don't want to print out all of those  
163:58 - objects. So I'm just going to put length to see 
how many cats is returned. And of course, I need  
164:06 - to add that inside my getters. Get all cats. And 
now I should be able to call this from the DOM  
164:14 - and check how many cats are returned versus the 
total number of pets. Back in the browser. I see  
164:21 - it's getting the correct number of cats versus all 
pets. In case you can't see, there are four cats  
164:29 - and eight total pets. That's basically how getters 
work do used a lot for filtering or making changes  
164:38 - to what's going to be rendered on the DOM. You 
can do a lot of different things with getters, you  
164:43 - could also pass in other getters. So here I could 
actually call another getter inside this getter,  
164:51 - because view x gives me that as a second argument. 
This whole system is pretty simple. Once you've  
164:58 - practiced it a little bit Another thing that I 
think would be helpful in a production application  
165:04 - or as you're building your personal projects, 
that is setting up SAS inside of a project. And  
165:12 - this is how I generally do it in view. So I add a 
folder inside of source slash assets called sass.  
165:20 - And then I have an index dot sass file. And I make 
a couple folders inside of my sass directory. So  
165:32 - I have my components, and my libraries, and my 
global styles, which I usually call base. And  
165:44 - then I import all of these files into my index. 
So I'll import first libraries, and then base.  
165:54 - And then I'll import components here. So inside 
of the libraries folder, I might have mixins,  
166:04 - or material design or whatever other sass files I 
want to import here. I can also import CSS files,  
166:10 - I just renamed them dot s CSS, because any valid 
CSS can also be used inside of dot SCSS files,  
166:20 - which is a type of sass file. I just prefer 
to use invented syntax without curly braces,  
166:26 - or semi colons. And there are some extra shortcuts 
that you get with the indented syntax that I like.  
166:33 - So after the libraries, the base files, I'll 
generally have something called variables,  
166:42 - dot SAS. And now this underscore is just a 
convention in SAS to mean that this file is  
166:50 - imported into another file and not compiled as an 
individual file. So I have a variables file. And  
166:58 - here I might do something like, set my fonts as 
a variable. So I could set let's say, main font.  
167:08 - And set that equal to I'm not sure how vedika 
if that's right, or whatever, Google Font that  
167:16 - I've imported, or any other font, and then sans 
serif. And do colors and padding and spacing,  
167:26 - I'm just going to do maybe a blue color here, 
which could be 000034. And then you get the idea,  
167:43 - you can put pretty much anything you want to be 
able to use in other parts of your application,  
167:48 - and then you can just change it in one place. 
And this also makes it easy. If you're doing  
167:53 - different themes, or letting a user choose their 
theme and their application, you just save all the  
167:59 - different themes here and then attach them to a 
class and toggle that class dynamically from the  
168:05 - JavaScript inside your view components. 
So now that I have some variables here,  
168:10 - I can import this into my main sass file. And 
within at import, I'll say base slash variables,  
168:22 - and I don't need the underscore or the dot SAS on 
the end, it's going to look for either dot SAS or  
168:29 - dot SCSS files. And I think this makes the file 
look really clean, it's easy to look through a  
168:35 - whole list of these. Now in the components, 
let me just pull up one component here,  
168:40 - let's say a view and my home view. And it starts 
out with the class home. But generally, I don't  
168:49 - think this is descriptive enough. So I usually 
call things like home view container or something  
168:56 - like that in my project. And this is a wrapper 
class so that I can contain my nested classes, and  
169:04 - they don't affect other parts of the application. 
Because my global styles will all be in base. But  
169:10 - each component that I make will also have its 
own styles. So I'm going to create a new style  
169:16 - file for the home component. And then I put this 
wrapper class, and then any other classes that I  
169:23 - want to affect the home component I'll put nested 
inside of here, just so you can see the nesting,  
169:29 - I'll put four spaces instead of two, which is 
generally what I use whenever I'm doing something  
169:36 - like Python or SAS using indented syntax, because 
it makes the indentation easier to see. So now I'm  
169:43 - just going to say color and use my color variable 
that I'm also importing into my index file. So now  
169:53 - in components, I will add import, base slash home 
Now I have styles that are specific only to the  
170:04 - home component. So how do we get these styles to 
apply to the components, you have to import them  
170:11 - into the main.js file. So right below where I 
have these bootstrap files imported, I'm also  
170:18 - going to import from the assets folder, sass, and 
index that sass. And now, that should apply all  
170:30 - of my sass files to my project. Because if you 
remember, when we created this project from the  
170:38 - vcli, we chose sass as the preprocessor. So the 
vcli, set up all of the sass processing for us,  
170:46 - and being able to compile it to CSS and things 
like that, which makes it really easy to use sass  
170:52 - inside of projects. So it's complaining about this 
app import statement. So let me add components  
171:00 - here. And now it's working fine of the the text 
is not turning blue. Let me see why that is,  
171:12 - if I go to inspect element, it is actually blue. 
But it's just so hard to tell, because it's not  
171:19 - a very bright color. So let me change that to 
a brighter color. If I go into the variables,  
171:26 - and I'm just going to change this to any color, 
not necessarily blue, just so it shows up. I have  
171:33 - no idea what color this is okay, purple. And it 
doesn't affect any other page here. Because I  
171:40 - am using a namespace in sass. So it only affects 
anything inside of this class, which is specific  
171:48 - to the div wrapper around home dot view. So 
hopefully that makes sense. I do make usually  
171:55 - one of these components for every single of my 
component files. And then in global styles, I'll  
172:02 - put inside various styles in the base directory. 
So that's enough about sass, I just wanted to show  
172:09 - you how I usually set up a sass project. This 
code will all be online, if you want to see it,  
172:14 - I want to change one more thing that feels a 
little bit dirty about this project. And that is  
172:20 - to pull this table out into its own component. In 
my components, I'm just going to create a new file  
172:29 - called pet table dot view. And I'm going to use 
this as a table inside both cats and dogs. So to  
172:39 - start this, I'm going to just steal this template, 
put it here. And to make it unique for each one,  
172:46 - we're going to need to pass in some props to this 
component from both our cats and dogs views. So  
172:56 - I need to have props are my default object. I'm 
going to make this an object and say first of all,  
173:05 - I think we're going to need a species, which 
will be a string. And then here, I can replace  
173:14 - this with species. It's gonna be lowercase. And 
here I'll replace this with pets because we'll  
173:25 - pass either cats or dogs as pets. And pets will be 
in array. And then here I also want to use species  
173:39 - to dynamically pass. And I think that's it really, 
we just have to import pets table. Let's import it  
173:46 - into cats first. So import pets, or pet table. 
From at components slash pivot table dot view,  
174:07 - and I need to set it as a component I'm going 
to use my Dom here, components pet table.  
174:16 - Not sure if I mentioned this previously in the 
video, but using pet table as a component here,  
174:24 - I can do this in two different ways. I'm going to 
get rid of this and I can use it capitalised or  
174:32 - view gives me another default way to do it. Which 
is kebab case by default to make it more HTML like  
174:40 - I could do that. Generally the recommended way 
that I've heard from members of the core team  
174:46 - and others and also from using it myself, is to 
just keep it capitalized. And that lets you see  
174:52 - the difference between the custom components that 
you create and the other HTML tags like div So I'm  
175:00 - going to be passing in this species here. And 
I know the species is cats. So I don't have to  
175:08 - do anything else to that. And I'm also calling for 
the pets or the cats, which I need to pass in. And  
175:16 - I have that array here, mapped through computed. 
So I'm going to pass that in using v bind as pets  
175:26 - pass in the cats array. Of course, this is kind 
of confusing, because these have the same name.  
175:33 - But this one is an array because we're using v 
bind. So view is looking for a variable. So it's  
175:41 - actually pulling this variable cats array off of 
computed and sending it in as pets. Now species,  
175:51 - we're not using v bind here, so it's just static. 
So it's the string cats. And let's see how this  
175:58 - works. If we go to the browser, and go to cats, 
it's still working the same way. So I'm going  
176:05 - to copy this for dogs. Go here, into the dogs 
component, and get rid of all this table stuff  
176:16 - here. except we're going to be passing dogs in 
for both of these. And then we need to pull in  
176:24 - the pet table component from here and also add 
that component so that we can use it in the DOM.  
176:35 - And I'm going to add it here. And then it should 
work still for both cats and dogs refresh. And  
176:43 - it works for dogs just as well. And we can still 
see that we have the correct number of both being  
176:51 - pulled in. So that's all for this view tutorial. 
If you're interested in going further with view,  
176:57 - let me know and I might make a more advanced intro 
to view in the future. Here are the resources  
177:03 - I think are most helpful for getting into view. 
First, there's the state of uJs, which is a yearly  
177:10 - report put out by ovenu, who's the creator of 
view, he gives lots of great talks about how the  
177:17 - project and library are evolving every year. And 
you can find those for free on YouTube. Another  
177:22 - resource I highly recommend is somebody who's the 
senior view developer called the Jared Wilker,  
177:29 - he livestreams. Various tutorials mostly about 
view every Thursday night at 7pm. Eastern time  
177:36 - in the USA. He's a really great teacher. So I 
highly recommend jumping into some of those chats  
177:42 - and asking him questions. Then there's one of my 
favorite people on the Vue JS core team, Sarah  
177:48 - dresner. Now I didn't cover animations in this 
tutorial, but she's actually the best person to  
177:54 - talk about those types of things. Vue JS has a lot 
of great built in animation features. I'm going to  
178:01 - link a video of a talk she gave on view animations 
that I think is really good. One last thing I  
178:09 - recommend for getting into view is checking out 
the views on view podcast. You can find it on  
178:14 - dev chat TV, or on overcast or any of your other 
favorite podcasting applications. Thanks so much  
178:23 - for watching this whole tutorial. I know it's kind 
of long, but I hope you got something out of it.  
178:28 - If you have any questions or feedback from me. You 
can find me on Twitter at Gwen underscore Faraday,  
178:35 - or shoot me an email at Gwen faraday@pm.me. I 
also have a YouTube channel called coding with  
178:44 - Gwen that I'm going to be starting back up here 
soon. And this is kind of a kickoff video for  
178:49 - that. So if you are interested in more of these 
types of videos, you can check me out there thanks