00:00 - this Blazer framework crash course
00:02 - covers all the essential fundamentals
00:05 - needed to start building web apps with
00:07 - Rich and interactive uis Blazer is a
00:10 - modern front-end web framework based on
00:12 - HTML CSS and C that helps you build web
00:15 - apps faster Alan omary developed this
00:18 - course if you want to get started with
00:20 - Blazer and learn all the fundamentals
00:23 - needed to start building applications in
00:25 - Blazer you are in the right place we'll
00:27 - get started with learning what Blazer is
00:29 - with learn about the project structure
00:32 - and what each file does and we'll go
00:34 - into the different render modes in
00:36 - Blazer and how to create web apps with a
00:38 - crowd operations so just keep on
00:41 - watching well welcome to code the future
00:44 - this is Alan by the way and I help you
00:46 - learn CP and.net on your own without
00:49 - losing any time let's start with our
00:51 - first
00:55 - section in this video we'll get to know
00:57 - Blazer its main characteristics and what
01:00 - it is used for Blazer is the modern
01:03 - front end web framework part of the net
01:05 - platform which is based on HTML CSS and
01:09 - C this framework allows us to build our
01:12 - entire web app from the front end to the
01:14 - back end using a single development
01:16 - stack sharing code for common Logic on
01:19 - the client and server a key feature of
01:22 - Blazer is its component based
01:24 - architecture a Blazer component is a
01:27 - usable piece of web UI that encapsulates
01:30 - both its rendering and UI event handling
01:33 - logic you can create your own components
01:36 - but Blazer also provides many built-in
01:38 - components for many different use
01:41 - cases in Blazer components can be
01:44 - rendered from both the server and the
01:46 - client in order to deliver the best
01:48 - possible web app
01:49 - experience depending on the
01:51 - interactivity required different
01:53 - components or even Pages within the same
01:55 - application can be rendered from the
01:57 - server the client or even a comp
01:59 - comination of both all the render modes
02:02 - and their specifications we will see in
02:05 - detail later on in the series it's
02:08 - important to know that Blazer is not
02:10 - limited to web applications but it's
02:12 - also capable of building native mobile
02:14 - and desktop apps through a hybrid
02:17 - approach known as Blazer hybrid blending
02:20 - native and web
02:25 - Technologies so I have just opened up
02:28 - visual studio here just create new
02:32 - project and I'm going to need to find
02:34 - the Blazer web app
02:37 - template let me just see what we have
02:40 - here okay so the first one we got is the
02:43 - one we need click on next I'm leaving
02:47 - everything as default here the project
02:51 - name and it
02:54 - location and here we can see that we are
02:56 - using net 8 I'm going to leave every
02:59 - everything as it is the interactive
03:02 - render mode is selected as server by
03:05 - default we're going to see later on in
03:08 - another video all of these render modes
03:11 - in Blazer but for now we're just leaving
03:13 - everything as it is and the
03:16 - interactivity will leave as it is as
03:19 - well per page and component and let me
03:22 - just create our first Blazer web app
03:31 - okay our project is created just run our
03:35 - project here click on start without
03:38 - debugging and let's see our
03:42 - default
03:50 - project okay so here's our Blazer web
03:53 - application we have a homepage here just
03:56 - stating hello world welcome to your new
03:59 - app
04:00 - and then we see we have a
04:02 - navigation menu on the left or like a
04:05 - panel here where we can navigate to The
04:07 - Counter page we just have a counter that
04:10 - we can increase by clicking on the
04:12 - button and we also have a weather page
04:15 - that just loads some boilerplate weather
04:20 - forecast
04:22 - data so right now in this video we're
04:25 - just going to go back to our project and
04:27 - see what each file in our
04:30 - project
04:33 - contains every C based net project has a
04:37 - project file with a CS Pro extension
04:41 - here are usually inputed properties and
04:43 - settings that determine how the project
04:45 - will be built and compiled we have
04:48 - specified here the net version that we
04:51 - want our project to use and this other
04:54 - line enables notable reference types and
04:58 - here is specified that the licit usings
05:00 - are enabled in this project which
05:03 - automatically includes common namespace
05:06 - Imports based on the project type this
05:09 - feature basically reduces the need for
05:11 - repetitive using directives at the top
05:14 - of every
05:15 - file let's now go to program.cs file
05:19 - which is the entry point of our
05:21 - application let's just start from the
05:23 - top this line creates a new instance of
05:27 - web application Builder by ining the
05:30 - static create Builder method then we
05:33 - configure Services of for the
05:36 - application here we adding eraser
05:38 - components and interactive server
05:41 - components and in this line here this
05:45 - line here builds the web application
05:48 - instance or basically our app and we
05:52 - have now an
05:54 - app and then we write the middleware for
05:57 - a bunch of different things this line
06:00 - adds middleware to redirect HTTP
06:02 - requests to
06:04 - https then here we add middleware to
06:07 - serve static F static files like HTML
06:11 - CSS JavaScript from the web rout
06:15 - directory this line adds middleware to
06:17 - protect against cross site request forer
06:21 - your
06:22 - text and here we are mapping the app
06:25 - component as the root component for
06:27 - razor components in aing interactive
06:30 - server rendering
06:32 - mode and in the end we are on the
06:35 - application which is now ready to listen
06:38 - for and to handle HTTP
06:42 - requests let's go now to the www root
06:46 - folder which contains static web assets
06:49 - that are served directly to the client's
06:51 - web browser here you can have HTML CSS
06:55 - and JavaScript files as well as images
06:58 - or other static
07:00 - Assets in the properties folder then we
07:03 - have the launch settings. JSM file that
07:06 - contains settings related to how the
07:08 - application is launched during
07:10 - development they can be modified to sue
07:13 - the specific requirements of the project
07:16 - or different development
07:19 - environments we have as well the app
07:21 - settings. Json file which contains
07:24 - configuration settings for the
07:26 - application that you want to be part of
07:28 - your app at run time things like
07:31 - connection strings various application
07:33 - settings such as logging levels default
07:36 - values for certain parameters or even
07:40 - third party service
07:42 - configurations we have an an app
07:45 - settings. development. Json file as well
07:48 - which stores configuration settings
07:50 - specific to the development environment
07:53 - and just like this we can create files
07:55 - for the other specific environments like
07:57 - for staging and production as
08:00 - well let's go now to the components
08:03 - folder where we have all of the
08:05 - components of our app in app datar Razer
08:09 - we have the root component where we can
08:11 - see the root HTML document the Blazer
08:15 - router and the Blazer script
08:19 - tags inside the routes. Eraser file is
08:22 - defined the routing configuration for
08:24 - the application it basically specifies
08:27 - the mapping between URLs and the
08:29 - corresponding components or pages to
08:33 - render all of our pages are inside our
08:36 - Pages folder as we can see here we have
08:39 - the home the weather page or
08:44 - component now let's go to the layout
08:46 - folder which contains the layout
08:48 - components layout components Define the
08:51 - overall structure and appearance of our
08:53 - applications Pages we have the main
08:56 - layout. Razer file which is the main
08:58 - layout component component used by our
09:01 - application and it usually defines the
09:03 - overall structure of the of the
09:05 - application Pages such as the header the
09:08 - navigation the footer if needed and so
09:12 - on and then the nav menu data Razer file
09:16 - contains the markup and code for the
09:17 - navigation menu
09:20 - component lastly we can see that we have
09:23 - the imports. Razer file which is
09:25 - actually a special razor file that
09:28 - contains the using directives that
09:30 - import namespaces globally for use
09:33 - across all of our bler components within
09:35 - the project this way we do not need to
09:38 - specify the namespace in each individual
09:41 - component
09:43 - file so this was an overal introduction
09:46 - of the files in our project and what
09:49 - they are used for just as a quick
09:51 - reminder if you have been getting value
09:53 - so far please like the video and
09:55 - subscribe to the channel for more
09:57 - content now back to we left
10:04 - off let's start by navigating to the
10:07 - components folder in our
10:09 - project here you'll find various eraser
10:12 - files as you can see and this files in
10:16 - Blazer Define the usable components that
10:19 - make up different parts of our
10:20 - application's user
10:22 - interface now what exactly is a razor
10:25 - file well it's essentially a blend of
10:28 - HTML and C Razer is a markup syntax that
10:32 - allows us to Define rendering logic like
10:36 - conditionals and expressions alongside
10:39 - our HTML
10:40 - markup if we navigate to the pages
10:43 - folder we'll find the pages of our
10:45 - application also written as Razer
10:48 - files for example the homepage is
10:51 - defined by the Home data Razer file or
10:54 - we can call it the home
10:56 - component here we see the page directec
10:59 - specifying the route for this page this
11:02 - ensures that the home component is
11:04 - displayed when the user navigates to the
11:06 - route of the
11:07 - app additionally we have the page title
11:11 - component which sets the title for the
11:13 - current page displayed in the browser
11:16 - tab so except for the components that we
11:19 - can create we also have built-in
11:21 - components just like this page title
11:25 - component the rest of the file is normal
11:28 - HTML that defines the content for the
11:31 - page if we try to run our application
11:34 - we'll be redirected to the root of the
11:36 - app which is our
11:42 - homepage now let's take a look at the
11:45 - counter component it is located in the
11:47 - Pages directory as well this component
11:51 - renders a simple counter that increments
11:53 - each time a button is clicked notice the
11:56 - page directive specifying the route for
11:59 - the component and the render mode
12:02 - directive enables interactive server
12:05 - rendering and we will actually see in a
12:08 - separate video in more detail all the
12:11 - render modes in Blazer but this
12:13 - basically makes possible the user
12:15 - interactivity in our web app what we
12:19 - have next each time we select the click
12:22 - me button the onclick event is
12:25 - fired the increment count method then is
12:28 - called which is declared in our code
12:31 - block where we write most of our C code
12:35 - and this method increments the current
12:37 - count field which is defined above
12:40 - inside this code block as
12:42 - well and then the current count is
12:45 - displayed inside the paragraph element
12:47 - using C syntax with the add
12:51 - sign if we navigate now to our counter
12:54 - page we can use the menu on the left to
12:57 - go there we can see how the counter
13:01 - Works each time we click the button the
13:03 - current count is then incremented and we
13:06 - can see its value displayed on the
13:10 - screen but how do we use components in
13:13 - specific parts of our application well
13:15 - we just add an HTML style tag with the
13:18 - name of the component for instance to
13:21 - add the counter component to the
13:23 - homepage we simply include a counter
13:26 - element in the home data rer file
13:31 - we can run the application and we will
13:34 - see that we have a counter in our
13:36 - homepage as
13:42 - well components can also have parameters
13:45 - which allow you to pass data to the
13:47 - component when it's used component
13:50 - parameters are defined by adding a
13:52 - public C property to the component which
13:55 - also needs to have a parameter attribute
13:58 - we can then specify a value for a
14:00 - component param parameter using an HTML
14:04 - style attribute that matches the
14:06 - property name so we can define a
14:09 - parameter on the code Block in the
14:11 - counter component to specify how much it
14:13 - increments with every button
14:22 - click we are defining a public int
14:27 - increment amount
14:31 - property and we're setting its initial
14:33 - value to one so that it increases with
14:44 - one and we need to change the increment
14:47 - count method to use the increment amount
14:51 - value when incrementing the value of
14:53 - current
14:57 - count now in home doar Razer we can
15:00 - update the counter element to add an
15:02 - increment amount attribute that changes
15:05 - the increment amount to let's say 10 but
15:09 - you can put here any value any
15:12 - integer we can run the app
15:21 - again and we will see that the home
15:23 - component now has a counter that
15:26 - increments by 10 each time we click the
15:30 - button we can go and see in our counter
15:33 - page that the counter increments only by
15:36 - one since these are two different
15:39 - counters and one was the default value
15:42 - given to the property of the component
15:45 - and that concludes our brief overview of
15:47 - components in bler and how to use
15:53 - them webui elements can trigger
15:56 - different kinds of events in response to
15:58 - user interactions and we'll see how to
16:01 - handle these events in order to create
16:03 - Dynamic and responsive user interfaces
16:07 - in our Blazer applications some of the
16:10 - common UI events that will cover are
16:12 - click events Mouse events keyboard
16:15 - events form events and focus events
16:19 - event handlers in Blazer are attached to
16:21 - HTML elements or Blazer components using
16:24 - special attributes but we'll see now how
16:28 - it works works okay so let's go back to
16:31 - our project we have here just like a
16:35 - simple Blazer web project just created
16:39 - just like in previous videos as well and
16:42 - let me just open up the solution
16:45 - Explorer so in our counter page we
16:48 - basically see in the previous videos as
16:50 - well that we have actually handled an
16:53 - event in this component we have handled
16:57 - here the unclick event event with this
17:00 - event handler right here so basically
17:03 - the unclick event is specified in the
17:07 - button element with this unclick
17:10 - attribute and it has received a value of
17:13 - the method that we would want to
17:16 - basically be called as soon as this
17:20 - event is fired so after we have uh the
17:25 - buttons clicked this method is being
17:28 - called and we have specified the method
17:30 - in our code block below just like we saw
17:33 - in the previous video and if we click on
17:36 - the button this increases the current
17:39 - count variable and it is basically
17:42 - displayed here above there's also
17:44 - another way to handle this events we
17:47 - could use a Lambda
17:52 - expression in the value of this onclick
17:57 - attribute and we could just increase the
18:00 - current
18:02 - count fied with this increment operator
18:07 - and this would do the same thing that
18:09 - this method does we usually do it with
18:11 - methods but if it's something pretty
18:14 - simple or short we could use a Lambda
18:17 - expression let me just test it
18:23 - here so this still works just the same
18:27 - way now I'm we're just going to see some
18:30 - other type of events that we can handle
18:32 - in this video let me just take firstly
18:36 - an example of a form event I am taking
18:39 - the oninput event which basically is an
18:42 - event that is handled as soon as we inut
18:45 - some data in an input tag uh we'll see
18:48 - how this works I'm just going to take
18:51 - like
18:51 - an input elements
18:59 - single tag I'm just giving it a type of
19:03 - text basically just to specify that it
19:06 - receives text and here we can just write
19:09 - this add sign to get the event to to
19:13 - write the event attribute which uh has a
19:16 - name
19:18 - of on
19:21 - input and will give a value to this
19:25 - attribute like handle input which will
19:28 - be the name of the method which will'll
19:30 - use to handle this we could manually
19:32 - just write another method just like we
19:34 - did below
19:36 - here but if we just hover over this name
19:40 - of the
19:42 - method we can see a light bulp here
19:45 - which gives us an option to generate for
19:47 - us an event handler or an asynchronous
19:50 - event handler so a synchronous or an
19:52 - asynchronous event handler depending on
19:55 - the use case so basically just a method
19:57 - to help us Define what we want to do
20:01 - with our event I'm just clicking the
20:04 - first one to have a synchronous event
20:07 - handler which is just a method and we
20:09 - can see by default here that this method
20:12 - also takes a change event argument this
20:17 - arguments basically just
20:19 - contain some additional information
20:22 - about the the event that is erased we
20:26 - could basically just use the argu this
20:28 - argument ments in the as a parameter in
20:31 - our
20:32 - methods they are not necessary if we do
20:35 - not want the information that this
20:36 - arguments give us we we do not have to
20:38 - use them but we'll see why they are
20:41 - useful just right here so how I want to
20:44 - handle this event is that basically I
20:48 - just want as soon as we type something
20:49 - in the input I want to show it just
20:52 - below for this reason I'm just going to
20:54 - take a paragraph tag here and I going to
20:59 - have a string variable below naming it
21:03 - text giving it an initial value of like
21:06 - an empty string and I'm displaying its
21:09 - value
21:12 - here by using the add sign I'm taking
21:15 - the value of the variable right here
21:17 - just below the input tag and I'm just
21:20 - going to put all this part in a single
21:23 - div so that they are like in two
21:27 - different lines
21:35 - and I would want them to be like to have
21:37 - a bit space from above for this reason
21:38 - I'm just going to give them like a boot
21:40 - strap class of margin four it just gives
21:44 - some margin on top on bottom in each
21:48 - side basically just a boot strap class
21:52 - and right here on the method now as soon
21:54 - as we input something on the input
21:59 - so we're going to set the text variable
22:03 - to the value of the input and for this
22:07 - reason we're using this argument we can
22:10 - see here that this argument contains
22:12 - different properties if we use this
22:16 - value property here this gives us the
22:19 - information of the value let's input it
22:21 - in our input tag we see an error here
22:25 - this happens because this expression is
22:27 - basically an object we can just
22:30 - simply cast it to string since we are
22:33 - assigning it to a string variable we
22:36 - also see this other underline here which
22:39 - basically is the compiler is telling us
22:43 - that this expression could be null and
22:45 - if we just put the exclamation mark on
22:48 - the end we're telling the compiler that
22:51 - the value of the expression won't be
22:54 - null let me run the application so we
22:56 - see the result
23:01 - okay here we have our
23:03 - form as soon as we input something on
23:07 - the input it is automatically the method
23:11 - is being called and the on the text
23:16 - variable everything that we inut in our
23:18 - form is displayed just
23:21 - down
23:23 - below so let me just now see like a
23:27 - mouse
23:29 - event for this reason I'm just going to
23:31 - make the codes so that as soon as we
23:34 - hover over some specific div we would
23:37 - want the some text to appear or
23:41 - something for this reason I'm just
23:43 - taking a div element
23:47 - here I'm making it a bit visible so I'm
23:51 - giving it a b border
23:58 - so I'm making the border to be one
24:01 - pixel solid and
24:06 - black and here I'm just going to need to
24:09 - input I'm going to need another actually
24:11 - another variable I'm taking uh I'm
24:15 - naming it like the
24:18 - text so as soon as we hover over some
24:21 - specific a division we want text to be
24:25 - displayed just using a paragraph
24:31 - tag again and here I'm just inputting
24:34 - the value of the the
24:39 - text and we need to specify the event
24:44 - attribute
24:47 - here on we have different Mouse events
24:50 - that can be triggered that we can
24:52 - actually handle I'm just using the on
24:55 - Mouse over
24:59 - and we'll handle this event with a
25:02 - handle mouse or like a
25:06 - mouse over
25:08 - method then click over here and generate
25:12 - an event handler as you can see in this
25:16 - different event we have a different
25:18 - argument than the argument of the other
25:21 - event this is just because that this
25:23 - event take different kind of information
25:26 - about that specific
25:29 - about that specific event which once
25:32 - again we can use if we want to or if we
25:34 - do not want to we we don't have to use
25:38 - this arguments in my case I'm just going
25:40 - to display to the div
25:43 - text like a text
25:49 - of
25:51 - overing over the div just some text let
25:55 - me run this
26:02 - and as soon as we we see this this div
26:05 - with a a
26:06 - border and as soon as I hover over with
26:09 - the mouse we see this text being
26:13 - displayed inside the div because the
26:16 - method was
26:18 - triggered and we updated the value of
26:21 - this D text variable that was inside the
26:25 - div inside the paragraph text here
26:29 - now let's just see another event let me
26:32 - just take the example of the keyboard
26:35 - keyboard events so we have different
26:37 - kind of keyboard events I'm just going
26:39 - to use the unkey down event now I'm just
26:42 - going to show you how it works so it's
26:45 - triggered as soon as we input something
26:49 - as we press something in a
26:52 - keyboard and for for this for this
26:55 - demonstration I'm just going to use this
26:57 - first div that we wrote above so I'm
27:01 - just going to change the event handler
27:03 - here so I'm taking an ony
27:08 - down
27:09 - attribute
27:11 - and I handle it with the method and
27:17 - the key
27:25 - down so you can see again other argument
27:29 - the keyboard event argument that
27:31 - contains information about that this
27:34 - event for this case I'm just going to
27:38 - I'm just going to set to the text
27:42 - variable the value of the key that we
27:45 - have pressed so to do this I'm just
27:48 - taking the event we have the different
27:51 - properties here and I just need to write
27:54 - to use this key property to get the
27:56 - value of that key
27:59 - you can see how this will work if I run
28:01 - the
28:03 - application so now we'll we're handling
28:07 - this event in this first
28:09 - input and as if I press something on my
28:13 - keyboard we see this displayed then so
28:17 - basically the last key that we have
28:19 - inputed that we have pressed we see
28:21 - displayed below this doesn't only take
28:24 - numbers and characters but also the
28:28 - other the other keys in our
28:32 - keyboard okay so one last a couple last
28:36 - events that we'll see now are the focus
28:39 - events so we have an on focus and one on
28:42 - blur event which basically just are
28:44 - triggered the first one when we click on
28:48 - a form and the second one when we click
28:50 - out of a
28:54 - form okay so I'm still going to use this
28:57 - first form for this demonstration as
28:59 - well so I'm just removing this event
29:02 - handler and I'm using firstly
29:05 - on the
29:08 - unfocus
29:11 - event and the focus will be the name of
29:14 - the method and on the same input I'm
29:18 - just also handling the on blur
29:24 - event with the method
29:28 - I'm giving it the name of handle
29:31 - blur so now let us just generate an
29:35 - event handler for each one of those so
29:39 - we see yet again another argument that
29:43 - contains information about this event
29:46 - and but we're not going to use it in our
29:49 - case so I'm just basically going to
29:50 - display to the text something
29:54 - like you are typing
29:58 - whenever we click on the
30:00 - form or basically the form is focused
30:05 - you that's okay I would
30:08 - suggest and for the handle blur method
30:11 - let us change so for the
30:15 - onblur event let us generate an event
30:19 - handler and just some different text
30:23 - there
30:30 - you are
30:35 - not
30:37 - typing you have clicked
30:46 - away let's see how this works so as soon
30:50 - as I click on the form we see this
30:53 - text as soon as I clicked outside the
30:56 - form then this other so basically the
30:59 - umblr event was triggered so when we
31:03 - click the form the on Focus event is
31:07 - triggered and we see this message
31:10 - displayed and then we need to click
31:12 - actually not just overover outside the
31:14 - form the input but click outside the
31:17 - input to to be able to trigger the onpl
31:22 - event and there are different kind of of
31:25 - events that we can handle but these were
31:27 - some of the types just to give you an
31:30 - understanding on how handling web UI
31:33 - events
31:37 - works as an overview data binding
31:39 - connects our applications UI with
31:42 - underlying data sources with data
31:45 - binding we can synchronize the state of
31:47 - our components with changes in data
31:50 - resulting in a responsive and dynamic
31:52 - user experience so we are in Visual
31:55 - Studio here I have opened up a project
31:58 - that I've been working on in this series
32:00 - so basically just a blank project where
32:03 - on the counter component here on the
32:05 - counter page and I've just left a small
32:09 - piece of code from the previous video
32:11 - when we saw event handling and basically
32:14 - we have an inside a div element we have
32:17 - an input when we type anything in our
32:20 - input this we have specified an event
32:23 - handler here to basically just take the
32:27 - value of whatever we inut there and
32:30 - paste it into this paragraph using this
32:33 - this add sign to display the value of
32:36 - the text field that we have specified
32:39 - below and basically what we have seen
32:41 - here is a oneway data binding so the one
32:44 - a one way data binding occurs when the
32:47 - information or the data flows only in
32:50 - One Direction which is basically used to
32:52 - display data in the UI so this happens
32:56 - when we take the data uh from a c codee
32:59 - or from a database and just display it
33:01 - in our UI usually using this at sign and
33:06 - the difference between one-way data
33:08 - binding and two-way data binding is that
33:11 - on in two-way data binding the data
33:14 - flows in both directions so basically
33:17 - whenever a value changes in the UI this
33:22 - also updates our C code or the data in
33:26 - our database and vice versa whenever we
33:30 - change something right here in the C in
33:33 - our C code this will also update our UI
33:38 - and to basically do this we need the we
33:41 - can just delete this code we do not need
33:44 - this event handler here we can use the
33:48 - bind attribute and we can bind our input
33:52 - here to the text field so just this line
33:57 - here will do the same thing that our
34:00 - event handler did whatever we write in
34:02 - our input the content of our input will
34:05 - be binded to this text field and then
34:08 - here below we are
34:09 - displaying the text field value let me
34:13 - just run our
34:16 - project so here in our counter page if I
34:19 - type something and I'm going to click
34:23 - away we see that the content of our
34:27 - input was binded to the text variable
34:30 - and just like we saw there The Binding
34:33 - occurred on the on change event actually
34:37 - that's what happens by default but we
34:40 - can change the binding event by just
34:43 - using the bind attribute bind then colum
34:47 - and then
34:48 - event we want the binding to happen on
34:51 - input so as soon as we type any key in
34:55 - our keyboard we would want the binding
34:58 - to happen and the value of the text to
35:02 - be updated let me just H load the
35:06 - project
35:09 - here we refresh as just after any
35:12 - character I type we see that the value
35:16 - of the
35:18 - paragraph element just
35:24 - updates okay one other concept that is
35:27 - work mentioning is that we can
35:30 - basically choose to to run a specific
35:34 - block of code after The Binding happens
35:38 - uh this would be very useful if we had a
35:40 - search box and we would basically want
35:42 - to query in a database and would want
35:45 - some action to occur if we type
35:48 - something in our search box to do this
35:50 - just need to use this bind after
35:54 - attribute and here we can specify the
35:57 - the name of the method that we want to
35:59 - be triggered so let me just create a
36:02 - method I'm just name the method search
36:04 - here we can create an asynchronous
36:06 - method here just we're just simulating a
36:09 - search like we're searching something in
36:11 - the database
36:13 - so async task since we're writing an
36:16 - asynchronous method I'm naming it search
36:20 - I mean that's the name of the method
36:22 - that we specified above and we would
36:25 - want to basically didn't just take
36:28 - another string field here naming it a
36:32 - result giving it an initial value of an
36:36 - empty
36:37 - string we're going to display it just
36:40 - below inside the paragraph
36:42 - tag we're using the oneway data binding
36:46 - here with this add sign and when our
36:50 - method our search method is triggered we
36:53 - want to update the value of our result
36:56 - field to let's
36:58 - say let's write the number here
37:02 - 150 results were
37:13 - found and we can also just use this task
37:19 - not
37:20 - delay method here to delay the execution
37:25 - of the following line with let's say 3
37:29 - seconds so since this is an
37:32 - asynchronous method we need the the wait
37:36 - keyword before the method let me just
37:39 - run the project one more time to
37:42 - see how it
37:48 - works okay so as soon as we type
37:51 - something
37:53 - here after 3 seconds we should be able
37:56 - to see meth the search method was
37:58 - triggered and we
38:00 - see this
38:03 - displayed in our paragraph
38:06 - below so that was Data binding in Blazer
38:09 - please make sure to leave a comment if
38:11 - you have any questions and just as a
38:14 - reminder you can check out my C ebook if
38:17 - you want to learn more about C or even
38:20 - if you already know the language just to
38:23 - have a high quality reference guide at
38:25 - all times
38:30 - we'll explore each render mode in Blazer
38:32 - introducing them discussing their usage
38:35 - and we'll cover some examples in action
38:38 - we'll start by using a default Blazer
38:41 - web app project as we've been doing so
38:43 - far in this series so let's get
38:48 - started the first render mode we are
38:51 - going to see is static server side the
38:54 - rendering by default our bler components
38:56 - are static Ally rendered from the server
38:59 - what this means is that as soon as a
39:01 - request is routed to our component playe
39:04 - HTML will be rendered as a response from
39:06 - the server and that's basically it no
39:10 - state is maintained on the server static
39:13 - components are great when you do not
39:15 - need to handle UI events from users but
39:17 - you only want to render some plain
39:20 - HDML most of the components in our
39:23 - default app are statically rendered such
39:26 - as the homepage the weather page or the
39:29 - layout
39:30 - component but Blazer can actually
39:33 - enhance static components to make user
39:36 - interactions more responsive for example
39:39 - Blazer can enhance page navigation and
39:41 - form
39:42 - handling enhanced navigation in Blazer
39:45 - allows users to navigate between
39:47 - different pages or components within a
39:49 - Blazer application while preserving the
39:52 - application State users can transition
39:56 - between different View faster and
39:58 - smoother without full page reloads what
40:02 - happens in the background is that Blazer
40:04 - intercepts the navigation and makes a
40:07 - fet request to the
40:09 - server Blazer receives the HTML from the
40:12 - server and then applies the needed
40:14 - changes to the
40:16 - Dome Blazer enhances navigation by
40:19 - default while forms can be optionally
40:22 - enhanced if you want
40:25 - to let us now take a look at at
40:27 - streaming rendering streaming rendering
40:30 - allows your application to render parts
40:32 - of a web page or component as data
40:34 - becomes available from the server this
40:37 - surrender mode is particularly useful
40:40 - when your page needs to perform some
40:41 - long asynchronous tasks before it fully
40:44 - renders such as making a fetch request
40:47 - to an API or pulling data from the
40:51 - database with streaming rendering in
40:53 - Blazer the server starts sending HTML
40:56 - content to the client as soon as it's
40:58 - available rather than waiting for the
41:00 - entire page or component to be fully
41:03 - rendered you usually see some
41:05 - placeholder content like those loading
41:08 - do do dot messages on the screen this
41:11 - allows users to start interacting with
41:13 - the application sooner even before the
41:16 - content is fully loaded when the ASN
41:19 - tasks complete then the rest of the
41:21 - content will be
41:23 - rendered streaming rendering is used on
41:26 - our weather page
41:27 - if you refresh the page you'll see this
41:30 - placeholder content loading do do dot
41:33 - displayed after moment the weather
41:36 - forecast data will then render on the
41:39 - screen if we navigate to our code we'll
41:41 - find that streaming rendering is enabled
41:44 - by applying this streaming rendering
41:47 - attribute we can see below that we are
41:49 - specifying an if block if we don't have
41:53 - the forecast data the loading paragraph
41:56 - is surrendered
41:58 - otherwise we display a table with the
42:00 - weather forecast
42:02 - data in our code block we can observe an
42:05 - uninitialized async method which is a
42:08 - method that is invoked when a component
42:10 - is initialized
42:12 - asynchronously here we're simply
42:14 - simulating an asynchronous call using
42:16 - this task ad delay method and we're not
42:19 - making an API call or something like
42:22 - that and then we're generating the data
42:25 - below once the data is generated the
42:28 - component re renders and the update
42:31 - becomes visible to the client so as we
42:34 - saw earlier initially we see the loading
42:37 - text displayed and after about half a
42:40 - second the table with the data
42:43 - appears now let's explore how we can
42:45 - create fully interactive bler components
42:48 - capable of handling UI events from the
42:50 - browser the two primary interactive
42:53 - render modes we have in Blazer are
42:56 - interactive server rendering and
42:58 - interactive web assembly
43:00 - rendering interactive server rendering
43:03 - manages UI events from the server via
43:06 - websocket connection with the browser
43:09 - Blazer transmits UI events to the server
43:12 - through this
43:13 - connection then Blazer updates the
43:15 - browser Dom with the rendered
43:18 - changes alternatively Blazer components
43:21 - can utilize the interactive web assembly
43:24 - render modes for interactive rendering
43:26 - on the client Cent side in this mode the
43:30 - component code is downloaded to the
43:32 - browser and executed client side using a
43:36 - web assembly based net around time in
43:40 - interactive server rendering the server
43:43 - always requires an open connection with
43:45 - the browser which may result in server
43:48 - costs or some
43:50 - latency the second approach interactive
43:53 - web assembly rendering initially has a
43:55 - longer load time
43:57 - while the net around time is downloaded
44:00 - but once it's done uh it is cached
44:04 - available for future use and as a result
44:07 - it uploads the entire workload from the
44:10 - server to the
44:12 - client there is also a third interactive
44:15 - render mode that combines the strengths
44:17 - of the previous two
44:19 - modes interactive outo render mode
44:23 - components utilizing this mode are
44:25 - initially rendered from the ser server
44:27 - while in the background the net web
44:30 - assembly around time is
44:31 - downloaded upon completion of the
44:34 - download the component automatically
44:36 - switches to web assembly based rendering
44:38 - for future visits so this page loads
44:42 - faster initially as it's surrendered
44:44 - from the server but afterwards the
44:47 - workload is entirely offloaded to the
44:49 - client and no connection with the server
44:51 - is
44:52 - needed our default Blazer project has
44:55 - only one component that uses interactive
44:58 - server mode which is our counter
45:01 - component on top of the page we can see
45:04 - that we are using the surrender mode
45:06 - directive attribute and we're specifying
45:08 - the interactivity to be of type
45:11 - interactive server if we go to our
45:13 - counter page uh basically we when we
45:16 - perform an onclick event on this button
45:18 - we see that the counter increases so the
45:21 - page is basically interactive if you can
45:23 - go click on the page with the right of
45:26 - the mouse and go to inspect to use our
45:29 - developer tools here I'm going to
45:32 - network let me reload the page and here
45:36 - we'll see a websocket connection which
45:39 - has a status of pending what this
45:41 - basically means is that websocket
45:43 - connection is open with the server and
45:46 - is active and if I go to another page if
45:49 - I wait wait a bit we'll see here 16
45:52 - seconds comma 44 and basically this
45:55 - means that the websocket action was
45:57 - opened for this amount of time so
45:59 - whenever we use components that use the
46:03 - interactive server rendering the web so
46:07 - con connection is opened and then it's
46:10 - closed when we are not using it again if
46:12 - I'm going back to the counter we'll see
46:15 - another webset connection being opened
46:17 - here if I go back to another page the
46:21 - web c connection is was open for 8
46:25 - seconds for about 8 Seconds
46:28 - and our default laser project does not
46:31 - support the other two render modes so
46:34 - the interactive web assembly rendering
46:36 - or the interactive Auto render mode so
46:40 - for this reason we're going to need to
46:42 - create a new
46:44 - project let me just go to our menu
46:49 - above and create a new project so we're
46:53 - going to create again a Blazer web app
46:56 - project Pro click on next I'm going to
47:00 - leave the name as it is and the location
47:03 - of the
47:07 - files and here in this page now we have
47:10 - the option to select the
47:13 - interactivity type so basically we have
47:15 - here the option to select to set the
47:18 - interactivity of our project To None to
47:20 - server web assembly and auto so
47:23 - basically the first one is the first
47:26 - render mode that we learned which was
47:28 - the static server side rendering with no
47:31 - interactivity at all the second one was
47:34 - the interactive server rendering then
47:37 - the interactive web assembly rendering
47:39 - and then the interactive Auto rendering
47:43 - for this project I'm going to select the
47:46 - uh interactive Auto rendering this
47:48 - project will give us the option also to
47:51 - check how the interactive web assembly
47:54 - rendering works so that I can show you
47:57 - these two types together so I'm going to
48:01 - select this and next we have the option
48:05 - to
48:06 - choose the interactivity location what
48:09 - this means is that as it is per page or
48:12 - component this means that we're going to
48:14 - need to set up the interactivity of each
48:17 - page or each component we specified for
48:20 - each component one by one if we set it
48:23 - to Global all of our components of our
48:25 - application will be set with the same
48:29 - interactivity with the interactive Auto
48:31 - rendering in our case so I'm going to
48:34 - leave it per pager component and going
48:37 - to click on create to create our
48:44 - project okay the project is being loaded
48:48 - what we can see in our solution Explorer
48:51 - is that basically here we have two
48:53 - projects we have a server project and
48:56 - and the client project the server
48:59 - project contains all of our server code
49:02 - and as you can see this is similar to
49:05 - the project structure of our previous
49:08 - Blazer Web projects that we have been
49:10 - creating so far and about the client
49:15 - project the client project basically
49:17 - builds the code that's going to be
49:19 - downloaded on the browser and then that
49:23 - is going to run client side on the users
49:26 - br
49:27 - browser so in the we can just go and
49:31 - check to in program.cs in our server
49:34 - code we can see that the interactivity
49:37 - is set to so it's been it's enabled the
49:42 - interactive server rendering the and the
49:45 - interactive web assembly rendering
49:48 - here we can if we would check what we
49:52 - have in our server project we would see
49:55 - that the on if we go to Pages we will
49:59 - see that all of our Pages or all of our
50:01 - components are as before except the
50:05 - counter page or the counter component
50:08 - this happens because this component was
50:11 - the only component that we had also in
50:13 - our previous projects that is
50:15 - interactive and for this reason this is
50:18 - pushed down in the client project if we
50:22 - check on pages counter data Razer we see
50:25 - that here we have the counter
50:27 - component and basically all of the
50:29 - components or pages that we would want
50:31 - to be eventually run from the browser we
50:35 - all we set this components we place
50:38 - these components in our client project
50:40 - we'll see that by using this render mode
50:44 - directive attribute on top we have set
50:46 - the interactivity to be interactive Auto
50:49 - so basically interactive autor rendering
50:53 - and I'm just going to run the project
50:54 - firstly to see how this work
51:03 - works okay so we are in our homepage I'm
51:06 - going to just inspect the page to open
51:09 - up the developer
51:10 - tools and I'm going to network
51:15 - here and if we try to go to our counter
51:18 - page we'll see all of this stuff being
51:20 - downloaded all of this libraries being
51:24 - downloaded as you can see this takes a
51:27 - while but our page is actually
51:30 - interactive the counter works so what
51:33 - happened here if we filter on websocket
51:36 - we see that the websocket connection is
51:40 - opened so we have a connection with the
51:43 - server here but as well if we go to web
51:46 - assembly here all of these libraries
51:48 - from our client code are being download
51:50 - it and the most important one on here on
51:54 - top we see this net. native thatw file
51:58 - which is theet web assembly around time
52:02 - so this was being downloaded on the
52:04 - background and now it seems to be
52:07 - downloaded so how this works as we
52:10 - explained before let me just go back to
52:12 - our
52:13 - homepage we should see that the
52:16 - websocket connection here ended it was
52:19 - opened for 56 seconds for about 56
52:22 - seconds but now if we go back to our
52:25 - counter page the counter page is
52:27 - interactive but no other webset
52:30 - connection was opened no circuit
52:32 - connection is actually active here this
52:36 - happens because right now the components
52:39 - rendering switched from interactive
52:42 - server rendering basically to
52:44 - interactive web assembly rendering now
52:48 - all of the UI events that the user
52:51 - triggers will be handled on the
52:54 - browser's side because we download did
52:57 - this net web assembly around time and
53:00 - this is how the interactive auor
53:04 - rendering works I'm going to go back to
53:07 - our project and I'm going to change go
53:09 - to the counter page and change the
53:11 - interactivity to be interactive web
53:15 - assembly so that you will see the
53:18 - difference let me just run the
53:23 - project okay let me go back to here and
53:29 - refresh I think I'm going to need to
53:32 - basically clear this storage data so
53:37 - that we'll
53:38 - see everything that's being downloaded
53:41 - there so if I go to the counter page the
53:44 - counter is not at first interactive this
53:48 - happens because the load time of the
53:51 - component is a bit bigger in the
53:53 - interactive web assembly rendering
53:56 - because all of this stuff were being
53:59 - downloaded in the background when all of
54:02 - these library liaries and
54:05 - this net web assembly around time
54:08 - finished
54:09 - downloading then the component became
54:13 - interactive so all of the UI events were
54:16 - handled then by our by blazer from the
54:20 - users browser so this is was actually
54:24 - the drawback of the interactive web
54:27 - assembly rendering because at first the
54:30 - load time is a bit is a bit longer but
54:33 - once everything was finished and the r
54:35 - time is finished then this is cached and
54:38 - the user events will be then handled
54:42 - faster from the client's browser and if
54:46 - we actually
54:47 - check the websocket connection we'll see
54:50 - no socket con web socket connection was
54:53 - initialized because a server connection
54:56 - is not needed in this type of
55:02 - interactivity to be able to create an
55:04 - application of any level of complexity
55:06 - you need to First learn how to work with
55:09 - Crow operations crud stands for create
55:12 - read update and delete and these are
55:14 - essential operations in all applications
55:18 - in this video we will create the
55:19 - different components in our Blazer web
55:22 - app to perform these operations using
55:25 - scaffolding we will cover various topics
55:28 - including working with data in our
55:30 - Blazer web app connecting our project to
55:32 - a
55:33 - database understanding how form
55:35 - submission and validation work in Blazer
55:38 - and much more so let's get
55:42 - started so let us just create a new
55:44 - project here we're going to select a
55:47 - Blazer web app template
55:50 - here I link the application Blazer
56:00 - CR click on next and I'm going let the
56:04 - interactivity to be server so
56:07 - interactive server rendering and I'm
56:10 - going to set it leave it as it is per
56:13 - page component and not globally I'm
56:16 - going to create the project now
56:26 - okay the project is created the first
56:29 - thing we are going to need is we're
56:31 - going need to create the data model for
56:33 - us to be able then to perform the croud
56:36 - operations for that data model so I'm
56:40 - going to the project directory here and
56:44 - I'm going to add a models
56:46 - [Music]
56:48 - folder inside this folder I'm going to
56:51 - add a Class A model
56:55 - class let's let's say a model class for
57:06 - student let's give a few properties to
57:09 - this
57:10 - class public in ID
57:15 - property as always a property for the ID
57:18 - and then a property for the name I'll
57:22 - set it to be
57:23 - nullable so name
57:28 - for the
57:32 - AG and one for the let's say a date
57:37 - time property for the
57:49 - birthday let's just leave it with these
57:52 - four properties right now the Blazer
57:55 - actually
57:56 - gives us the option to create all of the
57:59 - pages or components to be able to
58:02 - perform the crowd operations for a
58:04 - specific model and we can do this by
58:07 - just going to the components folder to
58:09 - the pages folder here and I'm going to
58:13 - click on add a new scaffolded item that
58:18 - we go to raser components and click on
58:20 - eraser component using Entity framework
58:24 - it's basically a very easy way and a
58:26 - simple way to for us to get started with
58:30 - blazer even if we have some specific
58:33 - project and we could for example we
58:35 - could select we could only need like a
58:37 - create page an edit page or one of these
58:41 - we can select only one of these options
58:43 - here but for this video I'm going to
58:45 - tell Blazer to create all of the five
58:48 - all of the five pages for our crowd
58:51 - operations I'm going to select the model
58:54 - to be student the model that we created
58:57 - then I'm going to add a new DB context
58:59 - class here that we haven't created yet
59:01 - basically this is just the C class that
59:05 - connects our models to the database each
59:08 - time we create a new model a new data
59:11 - mod model we write its instance inside
59:15 - this context class and then when we want
59:18 - to access some specific data or some
59:20 - specific model we then again use the
59:23 - context to get the data from it so I'm
59:26 - just going to add a new context here I'm
59:28 - going to leave the database provider to
59:30 - be SQL Server click on ADD and let the
59:34 - Blazer do basically all the work for
59:39 - us okay inside the pages folder we have
59:43 - a student Pages folder with all of our
59:47 - crowd Pages or with our components we
59:50 - have a create component here a delete
59:53 - details component edit and an index
59:57 - component here as well and we're going
59:58 - to see what all of these do and how they
60:00 - work but firstly we're going to need to
60:03 - I'm going to create a
60:05 - database so that we store all of the
60:07 - data in it and then we do this croud
60:11 - operations by accessing the database so
60:15 - I'm going to go to view server
60:19 - Explorer click here on create new SQL
60:22 - Server
60:23 - database I'm going to need the server
60:26 - name of our my SQL Server management
60:32 - Studio C the server name
60:36 - here input it here and in the encrypt
60:40 - field here I'm going to set the
60:42 - encryption to optional or basically to
60:46 - false initially so that we do not need
60:48 - to log into the database with a password
60:50 - or so each time when we access the
60:54 - database click on trust server
60:57 - certificate and I'm going to give a name
60:59 - to our database let's
61:01 - say
61:04 - pleaser C
61:08 - data click on
61:13 - okay my database instance is created in
61:16 - the properties folder here we have the
61:18 - connection string which I'm going to
61:20 - need to
61:22 - take and paste it in the app settings. J
61:26 - basically when we added our scaffolded
61:29 - item Blazer created like an address here
61:32 - for the for the database a connections
61:36 - since we see here a connection string to
61:39 - be inputed there but I'm just going to
61:41 - substitute it with our database instance
61:44 - that I just
61:49 - created so here we see the encryption
61:51 - was put to false the datab base name is
61:55 - here
61:56 - and then this connection string should
61:58 - already be the service in program that
62:01 - CS file so right now all that's left to
62:04 - do is to add migrations to our database
62:08 - adding migrations basically means that
62:10 - we
62:11 - specify the art database schema so I'm
62:15 - going to need to go
62:17 - to
62:19 - tools n get package manager and package
62:23 - manager console and we need to add to
62:27 - write the command add
62:29 - migration and the name for the
62:36 - migration and basically what will be
62:39 - inputed in the database is the model
62:41 - that we created with its
62:44 - properties this is the migration is
62:46 - basically you can see it here a
62:49 - migrations folder we created in our
62:51 - project it's basically a C Class
62:53 - specifying a database schema and I'm
62:57 - just going to
62:58 - need to write the comment here update
63:04 - database and our model will be then
63:07 - stored in the database with our
63:09 - specifications and now we'll be we are
63:12 - ready to basically see how these croud
63:16 - operations work the index page if we can
63:20 - see here has let's find the route which
63:24 - is slash students so this is where we'll
63:26 - go
63:29 - first and just go to
63:33 - slash
63:38 - students okay we have an empty table
63:41 - here if I click on create new will be
63:44 - redirected to the create page let me
63:47 - give a name here to okay
63:50 - Sean the age 20 and I'm selecting a
63:56 - birthday if I click on
63:59 - create we see that we have a student
64:03 - basically was created in the database
64:06 - and then it's stored here we have its
64:09 - name the age the birthday which is not
64:11 - as well shown actually the date so we
64:14 - actually don't need the hour here but
64:17 - we'll modify it later and on the end on
64:19 - the last column we have three links that
64:23 - can that take us to the details page
64:25 - page with all of the details of the
64:28 - student the edit page allows us to
64:31 - modify the data here if I click on Save
64:35 - we see that the age was modified and if
64:38 - I click on
64:40 - delete here we have the option to delete
64:43 - this student from the database so you
64:46 - can see that our crowd operations are
64:48 - functional and work pretty well right
64:51 - now we just will
64:53 - see how each of this Pages actually
64:56 - works in
64:58 - detail so if I go back we'll start with
65:00 - the index page the main part of the
65:04 - index page here is the quick grid
65:07 - building component quick grid is a data
65:11 - grid component that is built in in
65:14 - Blazer quick grid can access data from
65:18 - different kind of sources here in the
65:20 - items attribute we are accessing the
65:23 - data from our DB Conta
65:26 - here on top of the page we're injecting
65:28 - the our context here and we're giving a
65:31 - name of DB and then we are taking the
65:35 - data from the context this buil-in
65:38 - component is very useful actually
65:40 - because it has it offers multiple
65:43 - features like sorting enabling
65:46 - pagination to the tables and much more
65:49 - actually which we're not going to see
65:50 - all in this video but let's just see
65:56 - below we see these property column tags
65:59 - that basically specify each column that
66:01 - will be inside of the table we are in
66:04 - this property attribute here we are
66:07 - specifying each property of our students
66:10 - model so the student name the students
66:13 - age
66:15 - birthday and we are accessing this by
66:18 - accessing the data from the
66:20 - context and Below on the last column as
66:24 - we saw we are using this template column
66:28 - buil-in component we are just
66:31 - specifying some links to go to the edit
66:35 - page Details page and to the delete page
66:38 - of that specific student using the
66:41 - student ID and this is what we can do in
66:45 - this quick grid component is that as we
66:48 - saw the birthday was not specified as we
66:51 - wanted it to we can basically add a
66:53 - format attribute
66:57 - and let's
66:58 - say
67:00 - dat set it to
67:05 - month
67:07 - day and year if I run the project this
67:11 - should be able to
67:13 - remove the time of the age but we don't
67:18 - have a student anymore here so let me
67:20 - create a new
67:22 - one James Johnson
67:26 - 40 pick a
67:28 - birthday and click on create we'll see
67:32 - that in the birthday column we do not
67:34 - see the time anymore we only see the
67:37 - specific
67:39 - date let me go back to our project we
67:42 - can actually we can use properties to
67:44 - change how this column's name will be
67:48 - displayed so birthday we
67:50 - can set it to if we want to change it
67:53 - let's say we can use the type
68:01 - property to set it to date of birth
68:05 - let's
68:09 - say we should see the column name will
68:12 - be changed
68:15 - here date of birth and this is basically
68:19 - it for the index page if I go now let's
68:22 - just go to the create page we can see
68:25 - that in a create page we're using an
68:27 - edit form building component and this
68:31 - building component is just substituting
68:35 - the form HTML tag and it makes it much
68:39 - easier to connect the data of the form
68:41 - to a specific model here we have we have
68:45 - specified the method type to be of post
68:48 - and we can see this model attribute that
68:50 - specifies the model dat the data model
68:53 - which is student and actually this
68:56 - connects the data that will be submitted
68:58 - from the form it connects it to the this
69:01 - student property here we can see that
69:04 - this student property here has an
69:07 - attribute above Supply parameter from
69:10 - form which basically specifies that as
69:13 - soon as the data is submitted in the
69:15 - form it will be bound to this property
69:18 - here then we'll use this property data
69:23 - here in this add student method below
69:26 - actually we can see that the form had an
69:29 - unvalid
69:31 - submit attribute as well which was set
69:34 - to add student so this is the method
69:37 - that will be invoked as soon as the data
69:40 - in the form was correctly submitted so
69:44 - it was validated the validation was also
69:47 - done correctly which we'll see in a bit
69:49 - and then the form was submitted the
69:51 - method here will be invoked and we'll
69:54 - basically store in the inside the
69:57 - context using this add method here our
70:03 - student that was submitted in the form
70:06 - we'll save the changes to the database
70:08 - and then we'll navigate back to the
70:11 - index page one last thing is the form
70:15 - name was specified to create here in
70:19 - this using this form name attribute and
70:23 - this is necessary in cases that we have
70:25 - multiple forms in our page and when we
70:29 - basically have a property below here we
70:32 - can specify the form
70:35 - name inside this property so that the
70:39 - data of each specific form will be bound
70:42 - to the correct property in our case we
70:45 - do not need this because we only have
70:47 - one form but if we would need to we
70:50 - could use it the last thing we see we
70:53 - have an enhan attribute in the edit form
70:58 - component this basically
71:00 - enables enhanced form handling in Blazer
71:04 - this is some something similar to the
71:07 - enhanced navigation that we saw in a few
71:10 - videos a few videos back so when a form
71:14 - is basically submitted the Blazer
71:17 - intercepts the form submission performs
71:20 - a fetch request to the server and gets a
71:24 - response from the server B basically and
71:26 - performs the needed changes in the Dom
71:29 - it's basically a feature that makes the
71:32 - form more interactive and enhances it so
71:36 - we can see basically saw also before how
71:39 - the form worked but let's just see now
71:43 - what we have inside the edit form we
71:46 - have some divs in each div we have a
71:50 - label for the input we have in the first
71:53 - case here we have an input
71:57 - text building components that take that
72:00 - only takes text input and its value is
72:03 - binded to with this bind
72:07 - value attribute is binded to the
72:10 - student. name so to the name property of
72:14 - the student
72:16 - model and in the second case we have an
72:19 - input number component then an input
72:23 - date component depending on the data
72:25 - that we are inputting there this is
72:28 - bounded to the specific property of the
72:31 - model so that then the all of the data
72:35 - that will be submitted by the form will
72:37 - be easily bound to our property to our
72:41 - student property here below and we can
72:44 - see basically that we have on the end of
72:47 - each div we have a validation message
72:50 - component here we saw on top also we
72:53 - have a data annotations validator and
72:55 - the validation summary component what
72:59 - this now do is that they validate the
73:01 - data so that the correct input will be
73:05 - submitted there to be more specific let
73:08 - me show you how this works if I go back
73:10 - to the models class that we created
73:13 - above we
73:15 - can input restrictions for our
73:18 - properties here let's say we can using
73:20 - data annotations I can put the name to
73:22 - be required
73:31 - and let's say I'm going to put the age
73:34 - to
73:35 - be in a Range within
73:39 - 18 and 35 so students have to be in an
73:44 - age between 18 and 35 then
73:48 - this data annotations validator will
73:52 - display an error message on the end of
73:56 - each input and also on top of the page
73:59 - validation summary with all of the
74:01 - errors that occurred so let me just run
74:05 - the project so that you can see how that
74:07 - basically
74:10 - works okay let's create a new page let's
74:13 - create a new
74:15 - student and let me put a name
74:20 - like them here let's put the age to be
74:24 - 36
74:26 - let's inut a birthday click on Create
74:29 - and we see that the form was actually
74:31 - not submitted we see the error message
74:34 - here the field age must be between 18
74:37 - and 35 just like we we specified it and
74:41 - we see the on top of the page a summary
74:45 - of all of the validation errors that
74:47 - occurred if I correct it to be 34 let's
74:51 - say and click on create
74:56 - this student will be stored in the
74:57 - database and then we can see it in our
75:00 - index page this was actually quite
75:03 - useful but one thing missing is that we
75:05 - would want actually to validate for the
75:08 - application to validate the input as
75:10 - soon as we click out of the input form
75:14 - we can enable this in Blazer but we're
75:16 - going to need to make our component page
75:19 - interactive I will do this we can just
75:22 - we just need to specify the render mode
75:26 - on top of the page to be interactive
75:30 - server since we created an application
75:33 - that allows interactive server rendering
75:37 - and if I run the application now it will
75:39 - be more interactive and the validation
75:43 - will happen just as soon as we click out
75:47 - of the
75:50 - form let's just try it one more time let
75:54 - say
75:55 - compter I put AG 15 and I just click
76:00 - away of the of this input form we'll see
76:05 - that this was validated and we see that
76:07 - the age field must be between 18 and 35
76:11 - we can actually see in the first input
76:14 - form that we see a green outline which
76:17 - basically see says that the data input
76:21 - it is correct and this is what we'll see
76:23 - also if we fix the H here we'll see that
76:26 - the form is outlined with this green
76:30 - color here let me put a birthday here
76:35 - and create the other student so we have
76:38 - three students now let's go to the
76:40 - delete
76:42 - page so on top of the page we have like
76:46 - this big header asking us if we really
76:49 - want to delete the student and here is
76:53 - displayed if the student is not
76:55 - basically loaded yet we see this message
76:58 - if so we'll see all of the data of the
77:00 - student and then an edit form again an
77:04 - edit form component to basically delete
77:07 - this student now code block here what is
77:11 - what we see is that we see an ID
77:14 - property which has this attribute Supply
77:18 - parameter from query what this does is
77:22 - that the this ID property gets the value
77:25 - of from the URL when we go to that URL
77:30 - let me just go to the delete page of the
77:32 - First Student in the URL we see that we
77:35 - have an ID equal to two and what this
77:39 - does is that this
77:42 - property will'll get in this case this
77:44 - ID property will get the value from the
77:48 - URL and then we we're going to use it
77:51 - down below actually we have an un
77:53 - initialized Asing meth method which is a
77:55 - method that is initialized as soon as
77:57 - the component renders we are basically
78:00 - going to find the student by checking
78:03 - through our database for the student
78:06 - with that ID that we got from the URL
78:09 - and then we're going to use this student
78:12 - data here firstly to display the name
78:15 - the age the birthday of the student and
78:18 - then we're going to use it down below
78:20 - here in the edit form if the form is
78:23 - submitted by if when we click to the
78:25 - button here this unvalid submit method
78:29 - will be triggered the delete student
78:31 - method and here we basically go to the
78:35 - context and remove that student save the
78:38 - changes to the database and go back to
78:41 - the
78:42 - students uh to the index page let's just
78:46 - go to The Details page now The Details
78:49 - page as well has an ID property that
78:53 - gets the value from the URL then as soon
78:57 - as the component renders this un
79:00 - uninitialized Asing method is called it
79:04 - Loops through basically the student with
79:06 - that specific ID in the database and
79:09 - then it displays the data to the users
79:13 - as we can see here pretty simple the
79:16 - edit page then basically it is similar
79:20 - to our create page we have this edit
79:23 - form build-in component component but
79:25 - the only difference is that the data is
79:27 - already filled in the inputs of this
79:30 - form because as soon as the component is
79:35 - rendered uh a database check is being
79:37 - done to find the student with that ID
79:40 - that we get from the URL here when it
79:44 - finds this student then its data will be
79:47 - inputed to each input here and we can
79:50 - then make a change make a modification
79:53 - to any of the input that we would want
79:57 - to if we click on Save then the update
80:01 - student method will be
80:04 - triggered which you can see here below
80:08 - basically the first line basically just
80:11 - helps the context to track the changes
80:14 - in the context so sets the state of this
80:18 - entity to modified and then it the
80:22 - changes will be saved to the database if
80:24 - an error occurs will be redirected to a
80:28 - not found page otherwise will just then
80:31 - be redirected again to the students page
80:33 - here let me just show you how the edit
80:38 - works so if you click on edit we make we
80:41 - see that the input is already filled
80:44 - with the users data with the ID of two
80:48 - actually in our case if we make any
80:50 - modification
80:53 - here and save the changes the changes
80:57 - will be saved and we are still
80:58 - redirected to the index page now after
81:02 - completing the Blazer fundamentals make
81:04 - sure to watch my food menu web app
81:06 - project in Blazer it's a very simple
81:08 - project that will help you practice and
81:10 - reinforce what you have already learned
81:13 - I really appreciate you watching this
81:15 - far if you got value from the video
81:17 - don't forget to like it or subscribe to
81:20 - the channel for more content thank you
81:22 - as always for watching and I will see
81:25 - you in the next video