00:00 - hello internet so i'm super grateful to
00:02 - be here today on free code cam to talk
00:04 - to you about the winners of the js 13k
00:07 - games that's right so in other words 20
00:10 - winning games that means 20 amazing code
00:12 - snippets from 20 insanely talented
00:15 - developers my name is anyakuba and i'm a
00:18 - software developer and a youtuber who
00:19 - loves to create all sorts of awesome
00:21 - tutorials online but hey today's not
00:24 - about me it's about these guys if you
00:26 - are just starting out in javascript or
00:28 - perhaps you're well seasoned but haven't
00:29 - actually heard of the js 13k games
00:31 - before well you are in for a treat as a
00:34 - judge on the 2020 js 13 games panel i
00:37 - had first time experience of these
00:39 - amazing developers so i really can't
00:41 - wait to show you that code today it is
00:43 - absolutely incredible to see what these
00:45 - guys have built using just javascript no
00:47 - libraries that fits in a 13kb file but
00:50 - first what is js 13k games you ask as
00:54 - the name would suggest all your game and
00:56 - game asset should be smaller than or
00:58 - equal to 13 kilobytes that is exactly 13
01:02 - 312 bytes to be precise you can of
01:06 - course zip it but don't over complicate
01:08 - building the zip package it should open
01:10 - on any platform anywhere anytime and you
01:13 - can use tools that minify your
01:15 - javascript source code if that helps too
01:18 - two you are not allowed to use any
01:20 - external services or libraries you can't
01:22 - use libraries images or data files
01:24 - hosted on server or services that
01:26 - provide any type of data for example
01:29 - google fonts are not allowed which let's
01:31 - face it and while the developers are so
01:33 - often scrolling through npm to find the
01:35 - latest package that will do some sort of
01:37 - shortcut it's nice to strip back a
01:39 - little bit right and just use plain old
01:41 - vanilla javascript number three stick to
01:45 - the theme this year's theme was 404 so
01:48 - the number 404 so if you know what that
01:50 - means you know like get creative with it
01:52 - the theme is announced every year in
01:54 - august so it was announced this august
01:56 - and that is what the developers had to
01:58 - work with and finally how many games can
02:01 - you submit well you can submit as many
02:03 - as you want you can also work on a team
02:05 - you work with your dog like it doesn't
02:07 - matter just get involved it's really
02:09 - meant to be a lot of fun this awesome
02:12 - competition was started in 2012 by anjay
02:15 - mazur he created it from scratch out of
02:18 - his own pocket sending out you know like
02:20 - t-shirts and gifts using the money that
02:23 - he had saved up what an awesome guy i
02:26 - can't wait to introduce him to you and
02:28 - now hello there my name is andre mazur
02:31 - i'm the creator of the js 13k games
02:34 - competition
02:35 - and i have to admit that
02:37 - i'm impressed with quality of the games
02:40 - submitted this year
02:42 - it's so cool to see that
02:45 - the games are getting better and better
02:48 - every single year since 2012.
02:52 - i'm also proud of the community because
02:55 - even though it's a competition
02:57 - developers are helping each other
03:00 - to build better games to fix
03:02 - issues and the bugs
03:06 - if you're interested about how those
03:08 - games were built remember that all the
03:11 - games from all the years
03:13 - the source code is on github so you can
03:16 - learn from that um okay um thanks anya
03:20 - for doing the video
03:23 - and helping promote the competition i
03:25 - really appreciate this thank you bye
03:28 - okay thank you andre and thank you also
03:30 - to free code count for giving us your
03:33 - platform to showcase this year's winners
03:36 - give it up for bo from free code camp hi
03:39 - i'm beau from freco camp js 13k games is
03:42 - a great initiative we're all about
03:44 - learning to code at freecoatcamp and
03:47 - coding a game is a great way to hone
03:48 - your skills i think 13 kilobytes is a
03:51 - brilliant constraint
03:53 - constraints often lead to greater
03:55 - creativity and that's definitely true
03:57 - with this year's winners we're honored
04:00 - to showcase these projects on our
04:01 - channel
04:02 - i encourage everyone watching to try to
04:04 - create your own 13k game yourselves and
04:07 - see how it improves your skills
04:09 - okay so hopefully you're ready to start
04:11 - looking at some code because next up we
04:13 - have the 20 overall winners starting
04:16 - from descending order so number one
04:18 - don't forget i will be putting a link to
04:20 - all the developers where you can find
04:22 - them on twitter as well as play their
04:24 - games and also of course their github
04:26 - source code for each game too let's do
04:29 - it
04:34 - hello everyone
04:36 - my name is remy vancillin and i'm a
04:38 - french game development hobbyist
04:40 - i've been participating in j7k games
04:43 - every year since 2013
04:45 - and this year i made ninja versus evil
04:48 - corp
04:50 - every year
04:51 - i try to make something a bit unique for
04:53 - js13k
04:55 - and try to push the limits of what you
04:56 - can get within the size constraint
04:59 - instead
05:00 - in 2020 i only had a week to work on my
05:03 - game so i decided to go for something a
05:05 - bit less risky
05:07 - and i wanted to polish it as much as
05:09 - possible
05:12 - one of my favorite game genres is 2d
05:14 - platformers so i decided to build just
05:16 - that
05:17 - with two main goals in mind
05:19 - first make it snappy
05:21 - i wanted it to be fast
05:23 - and i wanted the controls to feel right
05:26 - second
05:27 - have preset levels
05:29 - typically i make games where you have
05:31 - randomly generated levels
05:33 - the benefit of that approach is that it
05:35 - takes less bites and also less
05:37 - creativity you only need to have a
05:39 - decent algorithm
05:42 - this year
05:43 - i wanted to make a game that lasted
05:44 - about 5 minutes with a beginning
05:47 - an end and well-designed level
05:51 - some other goals came after
05:53 - such as having levels represented by
05:55 - floors in the tower
05:57 - similar to the die hard game if you've
05:59 - ever played that
06:01 - i wanted to have shortcuts
06:03 - optimized for speed running
06:05 - and polish the game as much as possible
06:09 - i was on vacation in quebec when the
06:11 - theme was announced so i had some time
06:13 - to prepare
06:14 - i was able to sketch the character his
06:16 - trademark floating bandana
06:19 - some basic levels enemies and various
06:22 - elements
06:23 - i was also able to write a few
06:24 - algorithms on my notebook
06:28 - like i mentioned before
06:30 - one of my main goals was to have preset
06:32 - levels
06:33 - it's not something i usually do and i'm
06:36 - pretty happy with the result
06:37 - so i can say that one of the main things
06:39 - i'm proud of is the level design
06:42 - a lot of it is due to how much time i
06:44 - spent adjusting the levels thanks to all
06:46 - the people who play tested the game
06:49 - and the part i'd like to focus on is how
06:51 - i managed to squeeze 17 levels in a 13
06:53 - kilobyte game
06:55 - more specifically how the ai was defined
07:00 - if you look at levels.js
07:02 - you'll notice that all the level
07:04 - matrices are stored as json
07:06 - and the enemy behavior is defined next
07:08 - to each matrix
07:10 - the game is filled with cameras that
07:12 - typically transition between two angles
07:15 - and guards that transition between two
07:17 - positions
07:19 - one of the constraints was that i needed
07:20 - all their cycles to be consistent
07:23 - i couldn't have them be framer dependent
07:25 - or you have the slightest difference
07:27 - between two runs otherwise speed running
07:29 - would just suck
07:31 - in other words i needed to be able to
07:33 - determine their exact state based on the
07:35 - current clock
07:38 - if you look at the way those cycles are
07:39 - defined it is actually relatively
07:42 - readable
07:43 - i didn't want to use some obscure arrays
07:45 - as it'd be much harder to read and
07:47 - maintain
07:49 - everything follows a builder pattern
07:50 - that allows for a lot of control
07:52 - while still taking very few buys
07:56 - for instance cameras are defined by
07:58 - their position and initial angle in the
08:01 - constructor
08:03 - and then their behavior can be chained
08:05 - if the camera needs to rotate by a
08:07 - certain amount we can simply call rotate
08:09 - by and provide the angle and the time
08:13 - it should take to perform that rotation
08:16 - if it needs to wait we can call wait and
08:19 - provide the duration
08:22 - and if we need two cameras to have the
08:23 - exact same cycle but with a slight
08:26 - offset we can call with phase
08:29 - and guards also follow a very similar
08:31 - pattern
08:34 - the details of how it all works under
08:35 - the hood iron cycle.js
08:39 - it's all very simple algorithms and this
08:41 - is why i'm still proud of it
08:43 - it lasts for a lot of control without
08:45 - looking too complex
08:47 - which is what most code should be
08:49 - we should always try to make it as
08:50 - readable as possible
08:53 - anyway i hope you like this quick
08:55 - walkthrough of a small portion of my
08:57 - code
08:58 - if you're interested in seeing progress
08:59 - on various unfinished game projects
09:02 - you can follow me on twitter at remvst
09:05 - and i hope to see you all joining js13k
09:07 - next year
09:17 - hello i'm tom hammels
09:19 - i'm a dutch developer who also makes a
09:22 - video game sometimes
09:23 - and for this year's year's turning k jam
09:26 - i made edge not violent
09:28 - it's a puzzle game on an infinitely
09:30 - repeating world
09:33 - i really like a towel based box pushing
09:36 - games like chocobon and i've already
09:38 - made several of them this is probably my
09:41 - most complex one yet i've been sitting
09:44 - on the idea for this game for a while
09:46 - and the gem was a good opportunity to
09:48 - develop it and design some cool puzzles
09:51 - for it
09:53 - so let's talk about the rendering for a
09:56 - bit
09:57 - each frame in the game is drawn using
09:58 - three steps in the first step i create
10:01 - multiple gaps that serve as sprites for
10:04 - the various puzzle elements like walls
10:06 - and boxes
10:08 - these are drawn using the rough library
10:10 - which generates nice hand-drawn looking
10:12 - shapes
10:15 - the second step runs the current puzzle
10:17 - state using these sprites like this
10:21 - then finally it will draw the level
10:23 - repeatedly
10:24 - to fill up the entire game canvas and i
10:27 - really like the bit of code that handles
10:29 - this so today i'll explain how this
10:31 - infinitely wrapping world
10:33 - works exactly
10:36 - so for demonstration purposes i've
10:39 - regenerated the level image from the
10:41 - game instead of generating one from
10:42 - scratch just to keep it simple
10:46 - now then i've isolated code in this
10:49 - sample i'll go over the most important
10:51 - bits but if you want to toy around with
10:53 - helping you can access the example with
10:56 - this link
10:57 - so let's go through it the core of the
11:00 - dialing
11:02 - magic happens here with the x and y
11:04 - offsets these essentially affect how the
11:07 - levels are tiled for example if you play
11:10 - the game then you know that this level
11:12 - can't be solved because the crate can't
11:15 - reach the goal
11:16 - but if we change the y offset to 2
11:24 - the level becomes a straight line and
11:26 - the puzzle becomes solvable
11:29 - it's kind of complicated but it is used
11:31 - in a lot of tricky puzzles
11:35 - so next we calculate how much left scan
11:39 - fit on the screen
11:40 - exactly the clip offset here
11:44 - here
11:47 - adds a small margin to the level border
11:50 - but
11:52 - it also shows if you put this into
11:55 - as a negative value then you can confirm
11:58 - that scope actually works because then
12:00 - levels that are very near the border
12:03 - won't get drawn either
12:05 - so
12:06 - this essentially makes sure that nothing
12:08 - will be drawn if it will end up being
12:11 - nearly or completely visible invisible
12:15 - anyway
12:17 - so finally
12:18 - a nested for loop actually draws levels
12:23 - note that levels further away from the
12:25 - center will get more transparent so if i
12:28 - zoom out
12:29 - all the way
12:30 - then you can see that the wrapping will
12:33 - go on for a bit but eventually it'll
12:36 - become so opaque that it will stop
12:39 - drawing
12:42 - so when drawing the image with an offset
12:45 - defined we shift the image out on the
12:49 - grid
12:50 - which you can kind of see here because
12:52 - of the shape
12:55 - so if i enable the coordinates display
13:01 - you can see that the image also shifts
13:04 - two steps down
13:07 - for each step on the y-axis kind of like
13:09 - a staircase and that's due to the level
13:12 - offset
13:14 - why i said earlier
13:17 - and
13:18 - that's pretty much it once again you can
13:21 - view the code snippets here uh do
13:23 - consider playing edge not found first if
13:26 - you haven't so you can learn how this
13:28 - level wrapping is used for the more
13:30 - tricky puzzles
13:33 - so i hope this inspired you to make your
13:36 - own infinite worlds
13:38 - if you like this then you can find me as
13:41 - a rory excellence victor uh for more of
13:44 - my things
13:45 - and if you look the name up on github
13:48 - then you should be able to find the full
13:50 - source code of the game
13:52 - bye and thanks for watching
14:03 - hey i'm caustic1337
14:05 - we with my friend lamp sprites created
14:07 - the game called church
14:09 - before gem started i decided that i want
14:11 - to create game where everything is
14:13 - rendered in a single screen fragment
14:15 - shader this technique is not often used
14:17 - in game dev but it's very common in demo
14:19 - scene and on websites like shader toy
14:22 - i never created any games like this so
14:24 - it was an experiment for me
14:26 - in a nutshell shader is a program
14:28 - executed on a gpu you can think of a
14:31 - single screen fragment shader as a
14:32 - function that returns pixel color based
14:34 - on its position
14:36 - since this function runs on gpu it's
14:38 - pretty fast and you can do fancy things
14:40 - there
14:41 - this has some pros and cons comparing to
14:43 - usual techniques like drawing sprites
14:45 - with textures
14:46 - so the goal for me was to make the most
14:48 - of pros and try to make cons negligible
14:52 - one of the pros is that you can get this
14:54 - new laser effect essentially for free
14:56 - first off all geometry is represented
14:58 - with sign distance fields or sdfs
15:01 - in short sdf is a function that for any
15:03 - point in space returns distance to the
15:05 - closest geometry and it's positive if
15:08 - you are outside of geometry and negative
15:09 - otherwise
15:11 - in our game we actually have three sdfs
15:13 - for bounds checkpoints and deadly zones
15:16 - there are a lot of awesome articles in
15:18 - internet about how to construct sdfs go
15:20 - read them if you are interested
15:22 - after you created your sdf you can for
15:24 - example render pixels white whereas df
15:27 - is negative and the black where it's
15:28 - positive so you can see your geometry
15:30 - after that creating neon effect is very
15:32 - simple it's this simple equation
15:35 - parameter g corresponds to brightness
15:37 - and p for blurriness
15:39 - it's very simple effect but it looks
15:40 - pretty
15:41 - after that to make it look 3d ish just
15:44 - render the sim multiple times each time
15:46 - slightly offsetting can scaling the
15:47 - layer
15:48 - that's basically everything about
15:50 - rendering almost all objects in game are
15:52 - rendered this way including the spider
15:54 - protagonist
15:55 - collision checks and game are done in
15:57 - shader as well
15:58 - to check collision you only need to
16:00 - evaluate your sdf and spider position
16:02 - and if it's less than spider size
16:05 - like if distance to closest geometry is
16:07 - less than your size then you are
16:09 - collecting something
16:10 - after that you can calculate surface
16:12 - normal vector by calculating gradient of
16:15 - sdf in needed point
16:17 - to pass this data from shader to js code
16:20 - i write this data in first three pixels
16:22 - of the screen
16:24 - they are bottom left although they are
16:26 - very small to spot them
16:28 - there are ways to do this better but it
16:30 - takes a little of code and works ok
16:33 - let's talk about music a bit
16:35 - i'm not good at composing music so i try
16:37 - to make it as generative as possible
16:40 - all sounds and music and game are done
16:42 - using plain web audio ip
16:44 - web audio ip is kinda cool it's like a
16:47 - modular synthesizer where you create
16:49 - audio processors and route them in any
16:51 - way you want
16:52 - so this piece of code generates ambient
16:55 - music in game
16:56 - basically it creates three sine wave
16:58 - oscillators each of them slightly
17:00 - detuned with another low frequency
17:02 - oscillator
17:03 - then they all are summed up and passed
17:06 - through echo with huge amount of
17:08 - feedback and reverb to create nice
17:10 - ambience
17:11 - every time you place checkpoint chord
17:13 - changes i have hardcoded a bunch of
17:15 - random chords in a minor scale
17:17 - they are just changing in loop
17:20 - also every 3 seconds according versions
17:22 - changes randomly
17:24 - chord inversion is when chord nodes are
17:26 - shifted octave up and down
17:29 - the chord stays the same but it sounds
17:31 - differently
17:32 - with huge echo it creates interesting
17:34 - effects sometimes
17:36 - all other sound effects are created with
17:38 - web audio ip as well
17:40 - they include ring modulation essentially
17:43 - it's just signal multiplication and some
17:46 - filters
17:47 - all these effects except reverb are
17:49 - available out of the box with web audio
17:51 - ip
17:53 - the last thing i'd like to tell you
17:54 - about is this little piece of code
17:57 - this is definitely not the code you
17:58 - would like to see in production it's
18:00 - very high key but for fitting a game in
18:02 - 13 kilobytes it did its work pretty well
18:06 - it is used in intro and autocad scenes
18:08 - where text is printed on screen
18:11 - basically it prints text to converse
18:13 - character by character it also can
18:15 - evaluate code to modify some internal
18:17 - state for example for moving to a new
18:19 - line changing delay between prints
18:22 - printing whole string at once and other
18:24 - things this function utilizes async
18:27 - await.js without it this code probably
18:29 - could be a lot larger here is example
18:32 - how it is used
18:35 - strings with exclamation point prefixes
18:37 - are evaluated
18:40 - anyways i hope you learned something
18:42 - here
18:43 - if you want to learn more check out
18:45 - whole code of our game on github you
18:47 - might find more hacky tricks there
18:50 - if you want to learn shaders check out
18:52 - book of shaders it's an awesome
18:54 - introduction to shaders
18:56 - also check out shadertoy.com it's a huge
18:59 - community of people writing shaders you
19:02 - can learn a lot there
19:04 - you can follow me on github as
19:05 - caustics1337
19:07 - and on twitter as caustics 13 337
19:11 - and i will be glad to see you all at
19:13 - next year's js13k
19:21 - for this recording i will be reading it
19:23 - on behalf of maxine
19:25 - hi i'm maxime web dev passionate of code
19:28 - golfing puzzle games and css
19:31 - for js 13k 2020 i wanted to make a 3d
19:34 - game using css 3d and emoji my game is
19:38 - about helping a train to cross bridges
19:41 - using optical illusions
19:43 - it was inspired by the indie game fez
19:45 - and the mobile games monument valley
19:48 - earlier this year i made a micro
19:50 - framework cs3d framework allowing to
19:54 - render a plane a sprite or a cube with a
19:57 - single line of code
20:00 - these 3d shapes are simply made of html
20:03 - elements and so they can contain
20:05 - anything you want
20:06 - css gradients images texts emojis
20:10 - so this gave me the idea to create 3d
20:13 - emoji
20:14 - i put one emoji on the front one emoji
20:17 - on the back and i filled the exterior
20:20 - with colored planes like an ice cream
20:22 - sandwich
20:23 - for example this train is made up of 16
20:27 - planes
20:29 - after adding some tree sprites around
20:31 - the train and a few planes under it for
20:33 - the track the illusion of movement is
20:35 - made with simple css animations that
20:38 - make the track and the trees scroll
20:40 - infinitely from right to left
20:42 - even though the rest of the scene is
20:43 - completely fixed
20:45 - here is the css code used for this
20:49 - and that's how i made my title screen
20:52 - next i'm going to show you how to
20:53 - implement the optical illusions in my
20:55 - games puzzle
20:58 - for example in the third level of the
21:00 - game the player must switch between 2d
21:03 - view scene from the side and 3d view
21:06 - with perspective to help the train move
21:08 - from track piece to another
21:11 - first the switch between 2d and 3d is
21:14 - made by transitioning the css 3d
21:16 - perspective value
21:17 - if it's low the perspective will be
21:19 - enabled if it is high the scene will be
21:22 - in 2d
21:26 - you may notice that this kind of puzzle
21:28 - violates the laws of physics the train
21:30 - is simultaneously at different places of
21:32 - the scene depending on which button is
21:34 - pressed 2d or 3d and how much it has
21:37 - progressed through the bridge
21:39 - it took me a few days to figure out how
21:41 - to implement this
21:42 - i declared three views of the same scene
21:46 - a real one saying where the track parts
21:48 - are located in the real world
21:50 - two virtual ones saying where the track
21:52 - parts appear to be in 2d and in 3d
21:57 - in the real world no block parts are
21:58 - aligned
22:00 - in the 3d virtual view the blocks 1 2
22:03 - and 3 and the blocks 5 6 and 7 are
22:06 - aligned thanks to an optical illusion
22:12 - as well as here in the 2d virtual view
22:14 - the blocks 3 4 and 5 are aligned thanks
22:17 - to an optical illusion
22:22 - finally here's what happens when a
22:24 - camera transition occurs
22:26 - the train moves on the part 2 in 3d view
22:30 - this part has a virtual 3d position so
22:33 - the train uses this position as if it
22:35 - were real but in reality it flies in the
22:37 - air to preserve the optical illusion
22:42 - the player clicks on the 2d button
22:45 - at this moment the train is instantly
22:46 - teleported and scaled up into its real
22:49 - position so you don't see it fly in the
22:52 - air and then the camera transitions as
22:54 - if the train had always been there
22:58 - if we are on a part that also has a
23:00 - virtual position in 2d view which is the
23:03 - case for the fourth part of the puzzle
23:05 - then the trainers teleported a second
23:08 - time just after the camera has finished
23:09 - moving
23:10 - once again it will fly in the air to
23:12 - preserve the illusion
23:14 - the same thing happens when
23:15 - transitioning from 2d to 3d
23:20 - thanks for watching this video as always
23:22 - there will be more information about
23:23 - this game and the making of it in the
23:26 - description below
23:33 - hey i'm ian xiao from taiwan i am a
23:36 - software engineer currently based in
23:38 - seattle
23:39 - i am the creator of the stolen sword
23:44 - stolen sword is a action platform game
23:47 - that you can play with only one finger
23:50 - and
23:52 - basically you play a swordsman trying to
23:55 - reclaim this word from a thief
23:58 - and
24:00 - the sword was used to suppress demons so
24:03 - now that it's being stolen
24:05 - the demon have been released so you have
24:07 - to
24:08 - fight him along the way
24:12 - and
24:13 - visually this game was inspired by a
24:16 - 2002
24:17 - movie
24:18 - called hero
24:22 - i was
24:23 - obsessed with the late 56 in the movie
24:26 - so
24:28 - i just want to
24:30 - kind of recreate it the scene in the
24:32 - game
24:34 - and also crouching tiger hidden dragon
24:37 - is another movie that i referenced
24:41 - so today i'm gonna share a little bit of
24:44 - how i create
24:46 - water effects in the lake level the
24:49 - water effect can be break into
24:52 - three parts
24:54 - repo and
24:56 - reflection
24:58 - and the gradient mask
25:01 - the repo is just two semi lips the lower
25:04 - part has a
25:06 - outer shadow and the upper part has an
25:08 - inner shadow so it creates a 3d illusion
25:12 - just like a crater the code snippet here
25:15 - is not an actual code it's just a high
25:17 - level concept of the implementation
25:19 - because the actual code is way uglier
25:24 - first i use the scale function to squash
25:26 - the circle a little bit
25:29 - to make it more like a oval instead of a
25:32 - circle so
25:34 - so that it looks like it's on the water
25:36 - surface
25:38 - then i use radial gradient to
25:41 - draw the shadow
25:43 - i use color stops to control the shadow
25:46 - goes inward or outward
25:49 - and then use ellipse function to
25:52 - draw a half of circle
25:56 - most of the image assets in this game
25:58 - are vector graphics
26:00 - it's basically
26:02 - layers of shape defined by a path
26:05 - which is an array of points
26:09 - so to draw this image
26:12 - i simply traverse the path array
26:14 - and connect all the points together with
26:17 - line two function
26:19 - that's it
26:21 - based on that the reflection is pretty
26:23 - straightforward
26:25 - first add some transparency by tweaking
26:27 - the global alpha
26:28 - and then add a little bit of vibration
26:31 - by
26:32 - adding random number to the x-axis
26:34 - coordinate
26:35 - so that it looks like it's on the water
26:37 - surface
26:39 - and lastly flip the shape across the
26:42 - y-axis
26:44 - but the reflection of the enemy is
26:45 - another story
26:47 - enemies are simply chinese characters
26:50 - drawn with failed text function
26:54 - i didn't find a way to flip the text
26:57 - i do know there is a transform function
27:01 - but
27:02 - i just didn't figure out how to use it
27:04 - so i take advantage from chinese
27:07 - characters
27:09 - every enemies appears in the leg level
27:11 - are vertically symmetrical
27:14 - which means the characters looks
27:17 - identical even when it's upside down
27:21 - and if it's not symmetrical then it must
27:25 - be a character that you can find a
27:27 - upside down version of it
27:30 - the last element of the water effects is
27:33 - the gradient mask
27:35 - it is used to show that the player is
27:37 - dipping the water
27:39 - and
27:41 - it's basically it's just
27:43 - drawing the player again
27:45 - but this time it is filled with
27:48 - linear gradient because the gradient is
27:51 - using absolute coordinate its position
27:54 - is fixed no matter where the shape is
27:57 - so i can easily keep the boundary at the
28:00 - same high as the water surface
28:04 - so that's a high level overview of how i
28:06 - created water effects in my 13k entry
28:10 - and
28:11 - i really appreciate jfk for hosting this
28:14 - amazing event i've learned a lot from
28:16 - the community
28:19 - so i highly recommend you to give this a
28:21 - try next year
28:23 - and you can find me on github and
28:25 - twitter
28:26 - my username is ciaogu that's
28:31 - csiaogu
28:32 - and
28:34 - feel free to reach out thank you
28:43 - reading on behalf of michael farren
28:47 - my name is michael faran i am a software
28:49 - engineer for minneapolis minnesota usa i
28:52 - spent most of my time professionally
28:53 - building web applications in reacts and
28:55 - typescript
28:57 - occasionally i like to build javascript
28:59 - games in my free time this is my fourth
29:02 - time participating in the js 13k
29:05 - i wanted to take a different approach to
29:07 - the 404 theme than the common not found
29:10 - approach to help my game stand out
29:13 - one of the ideas i brainstormed was to
29:15 - use 404 as a time period for the setting
29:17 - of my game
29:19 - from there the idea to use ancient
29:21 - greece led to what became the last
29:23 - spartan i like to play hack and slash
29:26 - games as it felt like a good genre that
29:28 - could be achievable within the
29:30 - constraints of that nkb
29:32 - this is my animation class that powers
29:34 - all the animations for the player and
29:36 - enemies in the last spartan
29:38 - this class accepts keyframe animation
29:40 - configurations as input and interpolates
29:43 - values between those keyframes to create
29:46 - smooth animation loops for idling
29:48 - attacking jumping etc in my game
29:51 - what i really like about the solution is
29:53 - it allows me to make some really
29:55 - impressive animations utilizing each
29:57 - component of my characters individually
29:59 - the head the shield the sword and each
30:01 - leg and by only defining a subset of
30:04 - positions and rotations for each when
30:06 - rendering each of these parts of the
30:08 - character i use the offsets that were
30:10 - generated by the animation class between
30:12 - the keyframes and i get smooth
30:14 - animations without defining every single
30:17 - frame myself
30:19 - thanks so much for watching please do
30:21 - reach out to me on twitter or check out
30:23 - my project in the description below
30:26 - where you can play it and check out the
30:27 - code
30:33 - for this game i will be reading on
30:35 - behalf of saud
30:37 - when asked about his favorite code
30:39 - snippet for the game he chose this one
30:41 - right here
30:42 - a little brief note about it is
30:45 - when creating the level editor for the
30:47 - game i didn't want to impose any sort of
30:49 - constraint on players so i wanted the
30:51 - space to feel like an infinite grid
30:54 - i thought a lot about how to maintain
30:56 - the state of a virtually infinite grid
30:58 - with different type of platforms and
31:00 - obviously an array wouldn't suffice
31:02 - since that would mean the grid has a
31:04 - start index and no platforms can be
31:06 - created before the start index
31:09 - finally i came up with this snippet what
31:12 - it does is keep track of the negative
31:14 - offset or in other words the number of
31:16 - platforms beyond the start index
31:18 - represented by negative x y
31:21 - a player has traveled and then shift the
31:24 - whole level data
31:26 - so a 2d array by that amount
31:29 - the grid can now be virtually infinite
31:31 - in all directions and not limited by the
31:33 - start index of the arrays
31:39 - you can find more about this game in the
31:41 - description below
31:48 - for this game i'm going to be reading on
31:50 - behalf of mark vasilkov
31:53 - my name is mark vasilkov and i'm a
31:55 - russian israeli computer programmer and
31:56 - security enthusiast i love video games
32:00 - the thing i do for a living are
32:01 - distinctively not video games though
32:04 - life's unfair like that
32:06 - a proper puzzle game can be designed as
32:08 - follows
32:09 - players are taught a game mechanic
32:12 - this allows them to solve puzzles of
32:14 - progressing difficulty
32:16 - then another mechanic is introduced
32:18 - upping the combinatorial complexity and
32:21 - then we repeat until done
32:23 - this game or in other words i want to
32:26 - google that game is an opposite of that
32:28 - a whimsical experience with no
32:30 - meaningful level progression
32:32 - each level changes the rules
32:34 - there is nothing to learn no
32:36 - understanding to develop
32:37 - this design was suggested by my
32:39 - beautiful wife natalia as a satisfactory
32:41 - metaphor for the entirety of the year
32:43 - 2020
32:45 - in regards to the code snippet i am most
32:47 - proud of i'm ashamed of most of it
32:49 - really but i think the following main
32:51 - loop turned out
32:54 - nicely making a smooth animation in
32:57 - javascript is surprisingly difficult
32:59 - modern screens don't have any semblance
33:01 - of consensus as to how many frames per
33:03 - second to render
33:05 - a 4k screen connected to my mpb runs at
33:08 - omega 30 frames per second because of
33:10 - apple
33:11 - gaming laptops on the other hand
33:13 - commonly run at around 300 frames per
33:15 - second
33:16 - this obviates the need to decouple
33:18 - movements computations from the refresh
33:20 - rate we cannot do plus plus x in every
33:24 - frame as the results would be very
33:25 - different between machines and even on
33:28 - the same machine depending on rendering
33:30 - complexity gc pauses and so on
33:34 - the simple solution is to use delta t
33:37 - the time interval between frames as a
33:39 - multiplier for movement distance this
33:41 - approach has issues of its own though
33:43 - for one we are dealing with floating
33:46 - point numbers that are close together
33:48 - some computations tend to accrue large
33:50 - errors
33:51 - look up catastrophic cancellation as i
33:54 - can't pretend to explain it
33:56 - then again there are state changes that
33:58 - are abrupt these can be difficult to
34:00 - express in terms of delta t
34:02 - also jumps as in 2d platformer will miss
34:05 - their apex point when the frames per
34:08 - second is slow
34:09 - the solution i arrived at which can
34:12 - absolutely be improved on is the fixed
34:14 - step loop showing in the listing
34:17 - the only requirement is your render
34:19 - function should be capable of learning
34:21 - objects between their current and last
34:24 - known positions
34:25 - meaning that every object stores its
34:27 - previous coordinates
34:28 - conveniently when you're writing a valid
34:30 - integration this is already the case the
34:34 - update function then uses the fixed step
34:36 - of 0.02 seconds or 50 updates per second
34:40 - in this example
34:42 - it can do plus plus x for all its worth
34:45 - and the animation will still be smooth
34:47 - and independent of the rendering frames
34:49 - per second
34:51 - moreover the update function doesn't run
34:53 - in every frame reducing the cpu load at
34:56 - the expense of game's responsiveness to
34:58 - controls yep
35:00 - there's also a safeguard for when an
35:02 - update takes an inordinate amount of
35:04 - time although the end result will still
35:06 - look janky
35:07 - implementing an algorithm that would
35:09 - scale the tick crate based on the
35:11 - observed performance of the machine is
35:13 - left as an exercise for the reader
35:17 - once again you can find more on mark's
35:20 - game in the description below including
35:22 - weatherfan on github his homepage and
35:24 - his twitter handle
35:31 - hi everyone my name is jerome leconte
35:34 - and i'm a software developer specialized
35:36 - in javascript
35:38 - one month per year i'm also a game
35:40 - developer for the js 13k games
35:42 - competition
35:44 - in 2020 the theme was 404
35:47 - and it turns out that my home province
35:49 - of ontario canada has numbered its
35:51 - highways in the 400 range
35:53 - so there is a real highway 404
35:56 - and i decided to make a game about it
35:58 - the goal is to survive the perils of the
36:00 - highway which are triggered by http
36:02 - status code
36:04 - 404 makes the road behind you disappear
36:07 - 501 makes the lane ahead unavailable and
36:10 - so on
36:14 - today i'm going to share with you how
36:15 - linear interpolation also commonly
36:17 - referred to as lerp
36:19 - in game development allowed me to add
36:21 - some juice to my game
36:25 - lerp is a function that takes a value
36:27 - in a range 0 to 1 and maps it to another
36:30 - value in the range between a min and a
36:32 - max using a linear scale
36:35 - for example if the min is 10 and a max
36:38 - is 20
36:39 - at t equals zero the function will
36:41 - return 10.
36:43 - at t equals 0.5 it will return 15.
36:47 - at t equal 1 it will return 20.
36:52 - this is the function that my game loop
36:54 - calls on every frame to calculate the
36:56 - distance that a car is moving forward
36:59 - it uses the elapsed time
37:01 - usually tens of milliseconds and
37:03 - multiply it to the car speed that i've
37:05 - expressed in pixels per second to get a
37:08 - distance which i then add
37:10 - to the car's y position
37:14 - another way to think about it
37:16 - is that there's an acceleration factor
37:18 - always set to 1
37:20 - that gives me the full car speed on
37:22 - every single call
37:24 - where this is a problem is that on the
37:27 - title screen the game loop is not
37:29 - running
37:30 - and as soon as the game starts the car
37:32 - is going to move from zero to full speed
37:36 - in an instant
37:38 - similarly when a car crashes the game
37:40 - loop exits and the car comes to a full
37:42 - stop
37:43 - instantaneously
37:46 - and this is where lerp is going to come
37:48 - in andy
37:50 - now when the race just started i can
37:53 - progressively increase the acceleration
37:55 - factor from 0 to 1
37:58 - in about a second and a half using the
38:01 - log lerp function this is going to feel
38:04 - like the car is progressively
38:05 - accelerating to its full speed
38:09 - similarly when a car crashes i can now
38:12 - decrease the acceleration factor from
38:14 - one to zero in about one and a half
38:17 - second giving the impression that a car
38:19 - is slowing down to a full stop
38:22 - i was so happy with the result that i
38:24 - started using lerp everywhere
38:27 - another instance is in the function that
38:30 - steers the car from left to right
38:33 - the idea is the same
38:34 - elapsed time times car speed gives you a
38:37 - distance
38:38 - and the distance either negative or
38:40 - positive depending which of the left or
38:43 - right arrow key was pressed last
38:46 - once again the problem as the car moves
38:48 - from zero to full speed on the left
38:50 - through on the right as soon as the key
38:52 - is pressed which makes for precise
38:55 - control a bit difficult
38:58 - using lerp i can also increase the
39:00 - direction factor from zero to minus one
39:03 - or zero to one
39:05 - in about a quarter of a second
39:07 - and this gives the car some inertia
39:09 - which makes for a nicer driving
39:11 - experience
39:13 - and that's about it
39:14 - you can play highway 404 by visiting
39:17 - bitly forward slash
39:19 - hwy-404
39:22 - the source code is on my github account
39:24 - and i've written about the making of in
39:27 - a medium article
39:29 - you can also visit my website
39:30 - herebyfrogs.com
39:32 - or follow me on twitter hatre frogs
39:36 - thank you for listening
39:42 - hi my name is cody and i am the creator
39:44 - of mini punk a 3d action adventure game
39:47 - for the 2020 js 13k games competition
39:51 - let's take a quick look at the game
39:55 - the enemy of the game is the evil 404
39:58 - megacorp they are threatening to take
40:00 - over the internet and you must stop them
40:07 - it's a third person 3d game with
40:11 - melee combat
40:16 - gives you an idea of the gameplay of the
40:17 - game
40:21 - now i'd like to talk to you about some
40:22 - of the technical details of the project
40:27 - it's part of the competition the game is
40:29 - open source and available on github
40:31 - i wrote a postmortem that talks about
40:33 - the origin of project
40:35 - some of the technical details
40:37 - in terms of choosing the project
40:41 - it's based on some of the ongoing
40:42 - debates about internet censorship it's
40:44 - really because i'm excited about the
40:46 - upcoming release of cyberpunk 2077
40:53 - the game itself uses a voxel engine
40:56 - similar to minecraft
40:58 - unlike minecraft where
41:00 - each tile is one meter by one meter by
41:03 - one meter the voxels in mini punk are
41:06 - one meter tall and four meters wide and
41:08 - four meters deep
41:09 - this helps with performance um
41:12 - and keeps the code a little bit smaller
41:15 - one of the most interesting technical
41:17 - details of the game is the bloom effect
41:19 - which creates this neon glow
41:22 - the implementation is based on an opengl
41:24 - tutorial that i ported to webgl
41:27 - which creates this great city glow
41:30 - effect
41:32 - here's the code for the bloom shader
41:35 - as you can see most of it is implemented
41:37 - in glsl that's the language that your
41:39 - video card uses to actually render
41:43 - and it's done as a post-processing
41:44 - effect
41:48 - there you have it that's a quick look at
41:50 - mini punk for the js 13k games
41:52 - competition
41:54 - thank you
42:00 - [Music]
42:03 - hello i'm nicholas and i created a game
42:06 - for js13k called searching 404.
42:16 - it's a classic single-player dungeon
42:18 - crawler game containing one level with
42:21 - smaller labyrinths
42:26 - puzzles
42:31 - two different weapons with weapon
42:34 - progression
42:36 - two different enemies to fight
42:40 - and finally a boss fight
42:43 - [Music]
42:45 - this also features a static lighting
42:47 - system
42:49 - [Music]
42:54 - projectiles
42:56 - particles
42:57 - [Music]
43:04 - and some very basic audio effects
43:07 - [Music]
43:11 - in all this i managed to cram into a
43:13 - zipped package at 13 kilobytes
43:16 - [Music]
43:35 - so does this mean that i'm working as a
43:38 - full-time game developer no it doesn't
43:41 - i'm actually working as a system
43:43 - administrator maintaining servers and
43:46 - networks 8 hours a day
43:48 - but in the evenings and weekends i'm
43:51 - creating games
43:53 - this was the first game i created in
43:55 - javascript usually i'm creating games in
43:58 - java or c-sharp in unity
44:02 - mostly for the ludum dare gaming
44:03 - competition but i wanted to do something
44:07 - new and decided to participate in jay's
44:10 - 13k this year
44:13 - i never thought i would be able to
44:15 - finish a game nor create a 3d game in
44:18 - just 13 kilobytes but with a few weeks
44:21 - works
44:22 - two three hours a day i managed to
44:24 - create this game and i was very
44:26 - surprised when i saw that i ended up at
44:28 - place 11 and at place 5 in the gameplay
44:32 - category
44:34 - [Applause]
44:36 - [Music]
44:39 - the source code you can easily tell by
44:42 - the source that i'm actually a java
44:44 - developer and doing my first game in
44:46 - javascript
44:48 - [Music]
44:56 - i was using es6 which gives me classes
45:00 - and the possibility to
45:02 - use class inheritance
45:04 - instances and static class variables
45:08 - [Music]
45:12 - is there any code that i'm proud of
45:14 - as this is the first time i'm doing a
45:16 - game in javascript and especially since
45:18 - i managed to do a 3d game in just 13
45:21 - kilobytes i'm proud of all the code but
45:24 - i've have the big one that i'm extra
45:26 - proud of it will probably be the code
45:28 - that adds static lights to the level
45:30 - because without the lights the game
45:33 - would be
45:34 - well the ambience the light gives it
45:37 - would miss a lot of that
45:39 - the algorithm for adding the lights is
45:42 - very silly simple and not efficient at
45:45 - all but javascript executes it's very
45:48 - fast so for my level that is 64 by 64
45:52 - tiles just does that code in just a few
45:56 - milliseconds
45:57 - [Music]
46:08 - so how does this light code work well
46:11 - the entire level is built of grids like
46:13 - this
46:14 - where every grid is tiled so it can
46:17 - either be a floor like this
46:20 - then we can add walls
46:23 - like this
46:24 - and finally a light source in the middle
46:26 - here
46:28 - so the light code will loop through all
46:31 - of these tiles looking for a light
46:34 - source the first time
46:36 - and it will set the light value to 1
46:38 - like this
46:40 - then when a loop enters again
46:43 - every tile will check enable tiles so
46:46 - when it enters this one it will find
46:48 - that the bottom tile
46:50 - has a brighter
46:52 - light value than it currently has which
46:56 - means it will set the light color like
46:58 - this
46:59 - then we'll continue do that for the rest
47:01 - of the tiles
47:03 - now when the loop enters again
47:07 - this style
47:08 - is the next and we'll check
47:11 - if there is a brighter tile
47:14 - neighbor tile
47:16 - and we'll find these two and both has
47:18 - the same color so it will just pick one
47:20 - of them
47:21 - and you can see it decreases the light a
47:24 - little bit so it can fall off
47:26 - the light value otherwise it will just
47:28 - flood the level with the same light
47:32 - then we'll continue like this and then
47:34 - the light would spread like this all
47:36 - over the level a good thing with this is
47:39 - that we can actually
47:41 - get the light a little bit into the
47:43 - corridor like this so when you
47:45 - enter the room here you
47:47 - already see the light here
47:51 - when the walls calculate the light they
47:53 - always set the light value to zero
47:56 - because we don't want light to spread
47:59 - through walls
48:00 - so it's always zero
48:03 - okay so now when i have this light map
48:07 - what do i do with it
48:08 - well for the floors it's
48:10 - quite easily i just set the light value
48:13 - of the tile
48:14 - but for the walls
48:16 - well each wall is built of four corners
48:20 - and
48:20 - each corner will check like this into
48:24 - the light it's facing and it will do
48:26 - like that
48:27 - this wall and this wall will have the
48:30 - same color as this tile
48:33 - this wall is having the color of this
48:36 - style
48:37 - and finally
48:39 - this wall
48:40 - the other side of the wall it's it's the
48:42 - same tile
48:43 - but it's the other side of the wall well
48:46 - without this will be zero so the light
48:49 - would never never spread through it's a
48:52 - very silly algorithm but it's very fast
48:56 - in javascript
48:58 - and the whole level just takes a few
48:59 - milliseconds to process
49:07 - [Music]
49:21 - and that was my game searching for a
49:23 - four that i made for years 13k 2020. you
49:27 - can find me at my not very updated blog
49:30 - at
49:30 - snooki.se
49:32 - or at nikasloof at twitter or my youtube
49:36 - channel
49:38 - [Music]
49:42 - you can also find me at spotify and
49:44 - other streaming services since i'm also
49:46 - making music and the tune you ever heard
49:49 - in this video is mine you can search for
49:51 - album recollecting memories by niklas
49:54 - love
49:58 - thanks for watching and year 2021 i
50:01 - challenge you to also participate in
50:03 - jay's 13k
50:05 - try it it's a lot of fun and if i could
50:08 - do it i bet you can easily do it too
50:18 - this recording is being done on behalf
50:20 - of paul brunt paul brunt says i'm just
50:23 - your standard web guy building websites
50:25 - for a living and i love graphic
50:26 - programming and making games in my spare
50:28 - time
50:29 - this year's game for gs 13k was my
50:32 - fourth entry for the competition it's
50:34 - basically a platform game with a twist
50:36 - instead of jumping as you would in a
50:38 - traditional platform game you control a
50:40 - light source that costs shadows that you
50:43 - can walk on
50:44 - i came up with the idea early on when i
50:46 - was just doing some array casting to add
50:48 - some lighting effects
50:50 - at the time the shadows were casting in
50:52 - the same color as the platform and there
50:54 - was no visual distinction
50:56 - so i thought why not make them act as a
50:58 - platform as well
51:00 - my favorite piece of code in the game
51:02 - was the collision detection code it
51:04 - still blows my mind that with nothing
51:06 - more than some pythagoras you can
51:08 - perform what seems to be really
51:09 - complicated collisions
51:11 - the code isn't that complex but i
51:13 - believe it's the first time i've taken
51:15 - the maths from scribbles and implemented
51:17 - it in code without making any silly
51:19 - mistakes
51:20 - it all worked as intended from the
51:22 - get-go so a very rare event
51:25 - the shadows are made up of a bunch of
51:27 - line segments and the code checks the
51:29 - distance of the player's bounding circle
51:31 - from the line segments
51:33 - if the line is less than the radius of
51:35 - the bounding circle away then a
51:37 - collision occurs and the normal and
51:39 - overlap distance is returned
51:41 - the nice part of writing this code was
51:43 - that i don't venture into the world of
51:44 - 2d much but the 3d stuff i've learned
51:47 - over recent years transferred over
51:48 - really well
51:51 - as a result there wasn't as much head
51:53 - scratching as i'd first anticipated when
51:55 - i originally came up with the idea of
51:56 - making the shadows part of the
51:58 - environment
51:59 - thanks so much for watching my video and
52:01 - as always you will find my website and
52:03 - my twitter handle as well as my game in
52:05 - the description below please do check it
52:08 - out
52:12 - this video is going to be read by any
52:14 - okubo based on a post morten on github
52:17 - for this game by ben clark and salvatore
52:20 - privity island not found is a game that
52:22 - is rendered primarily using a technique
52:24 - called ray marching or sphere tracing
52:27 - this is where you define the world as a
52:29 - mathematical function representing a
52:31 - distance to the nearest geometry it is
52:33 - much more inefficient in processing than
52:36 - standard polygonal rasterization but
52:38 - appears to be much more effective in
52:40 - code size
52:41 - curved surfaces are easier to render
52:43 - with better fidelity and less overhead
52:46 - since there is no triangulation involved
52:49 - ben and salvatore met up one day after
52:51 - work after the theme 404 was announced
52:53 - and began deciding what they should
52:54 - build the general linking of these
52:56 - things from 404 was ideas about finding
52:59 - things being lost you know lost the
53:01 - television series not knowing where you
53:03 - are
53:04 - a code piece that they used in their
53:05 - post-mortem was this
53:08 - it is all about code golfing salvatore
53:10 - says while for our previous game last
53:13 - year we didn't have to put much energy
53:14 - in code golfing this time much more
53:16 - effort was required a large portion of
53:18 - the final bundle is occupied by glsl
53:22 - code to reuse functions uniforms and
53:24 - variables across multiple shaders the
53:26 - best solution was to have a single big
53:28 - file and switch the main function to use
53:30 - a string replace when loading the glsl
53:33 - transpiler on the browser already
53:35 - performed unused functions elimination
53:37 - and constant folding so it was not
53:39 - concerned to load unused variables and
53:41 - functions you can read more about this
53:43 - piece of code on the postmortem online
53:45 - that is attached to the github game
53:47 - please do enjoy the read
53:49 - and do give ben and salvatore a follow
53:52 - on twitter as well
53:54 - oh and if you're curious about what this
53:56 - game looks like in a single picture of
53:58 - code this is it pretty cool
54:06 - for this video i'm going to be using a
54:08 - postmortem that mark posted on github
54:13 - speaking as mark
54:14 - a little bit about you have found
54:17 - it's a soothing game about perspective
54:19 - it's important to turn your sound on
54:21 - head votes advice tap and hold to move
54:23 - the trail make a loop to catch things if
54:25 - you want
54:26 - getting started to prove to myself that
54:29 - it is perfectly possible to use hakes
54:30 - for this i started to create a small
54:33 - engine in hakes
54:34 - i called the project
54:36 - hx13k initially
54:38 - higgs is a programming language that
54:39 - compiles to many languages including
54:42 - javascript es6
54:44 - as mainly part of my daily job i am a
54:47 - game developer and make html5 advert
54:50 - games so i like the idea of this gem
54:52 - first i started by making a basic engine
54:55 - well actually i stripped down the setup
54:57 - i normally use which is a combination of
54:59 - pixy js and a customized flambe library
55:02 - i'm a big fan of using entity components
55:05 - and the way that flambe library did it
55:06 - is how i like to work it's very
55:08 - pragmatic and usable for creating games
55:11 - in the end pixie js was removed as a
55:13 - render because it was too big it's too
55:16 - bad because pixie gs is such a great
55:18 - fast 2d rendering framework
55:20 - if you would like to read more about my
55:22 - game please do visit on github and have
55:24 - a go yourself
55:30 - hi my name is jeremy and i'm a game
55:32 - developer from edmonton canada and i
55:34 - made 404 kph for the 2020 js 13k games
55:38 - jam i first got the idea to make a
55:40 - driving game of some kind after last
55:42 - year's jam last year some friends and i
55:44 - made a game where you would fly through
55:45 - canyons and i thought it would be neat
55:47 - to drive a monster truck over the sort
55:49 - of canyony bumpy terrain
55:51 - however once this year's jam started and
55:53 - i started prototyping i i just couldn't
55:55 - quite get the monster truck physics to
55:57 - feel good but uh the physics ended up
56:00 - being pretty good for a car
56:02 - so i looked to one of my favorite
56:04 - uh racing games which is trackmania and
56:07 - decided to get some inspiration from
56:08 - that and kind of go into the
56:10 - surreal crazy physics-y
56:12 - uh time trials type racing direction
56:15 - the game itself has a pretty strange
56:17 - architecture in order to stay under 13
56:18 - kilobytes for instance the audio is done
56:21 - through a custom synth that's
56:22 - essentially hard coded to produce the
56:24 - game's music and other sound effects
56:26 - also the game's state is stored in a
56:28 - small texture and all the game update
56:30 - code including the physics and
56:31 - everything
56:32 - is run inside of a fragment shader on
56:34 - the gpu
56:35 - and this is done in order to share some
56:38 - code and data between the rendering and
56:40 - physics code as well as to make use of
56:42 - the really terse vector math functions
56:45 - that are available in the shader coding
56:47 - languages
56:49 - on top of that the build system runs a
56:51 - series of like custom steps in order to
56:53 - make the final html file more friendly
56:56 - to zipping and just squeeze a couple of
56:58 - extra bytes out of that
57:01 - the thing i'm most excited about though
57:02 - is probably the level editor
57:05 - i mentioned that the game update code
57:06 - runs inside of a shader this is done
57:08 - partially because the world is
57:09 - represented as a signed distance field
57:11 - or sdf you can think of an sdf as a
57:14 - function that takes a point in space and
57:16 - returns the distance to the nearest
57:18 - surface in that space sdfs are really
57:20 - easy to render and they're really easy
57:22 - to test collision against which is why i
57:23 - chose them as a representation for the
57:25 - tracks
57:26 - however this means i have to represent
57:28 - the tracks as a collection of functions
57:31 - in order to not go crazy trying to
57:33 - manually write functions for every
57:34 - individual track
57:37 - i decided to build a unity plugin where
57:39 - i could
57:40 - represent
57:42 - different components of a track as their
57:44 - own functions
57:45 - but then translate scale and change the
57:47 - properties of them
57:49 - just by dragging around
57:51 - the objects in the editor
57:53 - the editor then
57:56 - when i hit build will generate a bunch
57:58 - of shader code
58:00 - which is the sign distance function
58:02 - itself
58:04 - so i get the benefits of sort of a gui
58:06 - editor
58:09 - and i can see my work as i'm working on
58:11 - it i get a really quick iteration time
58:14 - um but it's still generating this sign
58:17 - distance function in the end which i can
58:18 - just embed directly into the game
58:21 - and so that's how the editor it works
58:23 - for 404 kph
58:25 - and that's how i built all of the tracks
58:27 - i actually built all of the tracks that
58:29 - are in the final game on the last day of
58:31 - the jam
58:32 - because i was busy building everything
58:34 - else up until then
58:39 - this is a recording based on elliot's
58:41 - github repo
58:43 - wizard with a shotgun is a top down 2d
58:46 - shooter you have the wizard recover the
58:48 - missing pages of the shotgun arcana from
58:50 - the dungeon by blasting everything you
58:52 - see
58:53 - play on your desktop using any browser
58:55 - and use the controls of your keyboard
58:57 - and your mouse
58:59 - the main character is intended to be a
59:01 - sort of wise cracking street smart
59:03 - wizard think harry dresser not harry
59:06 - potter the main character also has this
59:08 - awesome text show up unfortunately
59:10 - elliot discovered that dialogue is very
59:12 - expensive in the final zip file so i had
59:15 - to cut a lot of the planned lines
59:17 - there's a few things that elliot says
59:18 - he's really proud of in this game and
59:20 - these are some of them
59:21 - elliott says
59:23 - the first is my approach to canvas size
59:26 - this game is intended to look like a
59:28 - classic 2d pixel art game so i selected
59:30 - 480 480x270 as my desired display pixels
59:34 - then what i do is make the canvas
59:36 - element take up the full size of the
59:37 - browser and i select the smallest scale
59:40 - that would fill the canvas horizontally
59:41 - and vertically
59:42 - now i end up with a 2d context that was
59:45 - always roughly 480 by 270 but it might
59:48 - be less wide or tall depending on the
59:50 - browse dimension
59:52 - if you want to see what i'm describing
59:53 - try playing my game and dragging your
59:55 - browser window around to resize it
59:57 - you'll see that the ratio stays fixed
59:59 - and the scale will adjust it to give you
60:00 - as much playing real estate as possible
60:02 - while still looking nice i'm pretty
60:04 - happy with this and will likely keep the
60:06 - algorithm for my future games
60:08 - the second is the collision response
60:10 - this year i chose to simplify and use
60:12 - bounding circles instead of rectangles
60:14 - which meant i needed some math for the
60:17 - circle rectangle walls and circle circle
60:20 - player enemy collision detection i'm
60:22 - pretty proud of the result which is
60:24 - quite a bit of code but allows you to
60:26 - totally surrounded by multiple adjusting
60:28 - enemies and still push your way out of
60:30 - them all while looking about like you
60:32 - want it to look
60:33 - the same math applies to any moving
60:35 - object with a position and velocity
60:37 - which meant i accomplished what i could
60:39 - not last year
60:41 - another thing i tried and i'm happy with
60:43 - is breaking up logic into systems
60:45 - it's not for nc component system or
60:47 - anything but my upgrade loop now works
60:49 - in specific stages first behavior where
60:52 - the entity thinks
60:54 - then movement where velocity is applied
60:56 - and collision detection happens
60:59 - then damage damage queued up by the
61:01 - first two rounds is now applied to each
61:04 - entity potentially killing it
61:06 - last culled entities are cleaned up
61:09 - this made it easier to figure out where
61:10 - to put logic and helps keep the main
61:13 - game update function nice and clean
61:15 - i didn't want to mess around with the
61:16 - level editor so i used ask sprite to
61:18 - draw the map and then my gut build turns
61:21 - it into level data
61:22 - each room is color coded to represent a
61:24 - particular pattern number which controls
61:26 - the type and quantities of enemies in
61:28 - the room
61:29 - this wouldn't cut it if i had multiple
61:31 - tiles and entities and decorative
61:33 - objects to place but for this game it
61:35 - worked pretty well
61:36 - if you want to see more about this game
61:38 - please do check out the github below
61:48 - connection is a game made by federico
61:50 - tibaldo it is a pattern-based puzzle
61:53 - game connect the tiles on the board with
61:55 - your fingers and mouse to replicate the
61:57 - given combination or press the not bound
61:59 - button play through the levels to unlock
62:01 - the arcade mode and ultimately achieve
62:03 - the final trophy
62:05 - some feedback from the expert says
62:07 - dan sullivan really really enjoyed this
62:10 - first mode was a bit tough
62:12 - as was the 30 plus in arcade but
62:14 - otherwise a really really fantastic
62:16 - little puzzle reflex game
62:18 - i will not be going through the code for
62:20 - this game however if you want to have a
62:22 - look at how federico made this game in
62:24 - less than 13kb please do check out his
62:27 - github in the description below
62:35 - this video is read on behalf of marcus
62:39 - i am a software developer from nuremberg
62:41 - germany primarily i write apps for
62:43 - android and sometimes for other systems
62:45 - too
62:46 - a bit about the game and how you go
62:48 - through it
62:49 - my game is a short adventure game about
62:51 - two cosmonauts getting lost in space
62:54 - the player needs to find the way home by
62:56 - solving a couple of puzzles
62:58 - i chose cosmonauts because the story is
63:00 - about a secret escape drive and such
63:02 - things are more likely to be attributed
63:04 - to the mysterious early russian space
63:06 - program
63:07 - originally i had a much darker story in
63:10 - mind
63:10 - two cosmonauts on the way to venus one
63:13 - dies for unknown reasons the survivor
63:15 - fastens the dead man outside the capsule
63:17 - and is from then on haunted by
63:19 - mysterious happenings outside the window
63:21 - so essentially a ghost story in space
63:24 - but somehow the story did not really
63:26 - work and i focus on getting lost in the
63:27 - space thing instead which is really
63:30 - enough for an adventure in 13kb
63:33 - but the idea with the dream sequence
63:34 - still comes from the original story
63:36 - when asked what marcus was most proud of
63:39 - he says i'm afraid there isn't a snippet
63:41 - i am particularly proud of instead the
63:43 - challenge to make this game was to
63:45 - squeeze the graphics into 13kb and still
63:48 - have enough left for an adventure game
63:51 - so minimizing the size of the vector
63:53 - graphics was key
63:54 - to improve compression i only used
63:56 - integer coordinates on a 100 by 100
63:59 - canvas to make doubles
64:01 - by doubles i mean doubles of coordinate
64:03 - numbers
64:04 - this way there were just a hundred
64:06 - possible coordinate numbers from 0 to 99
64:09 - for all the vertices of all the graphics
64:12 - this code here this is the hull of the
64:14 - soyuz spaceship defined in just a few
64:16 - integer numbers that occurs later on and
64:18 - a lot of other shapes and since
64:20 - repetitive string patterns can be
64:22 - compressed very well i was able to pack
64:24 - all graphics and the game in 13kb this
64:27 - way
64:28 - thanks for watching my video and you can
64:29 - find me on twitter github or on my
64:32 - website these are all in the description
64:34 - below
64:38 - hi i'm sarah zamek i'm a web developer
64:41 - with a passion for graphics the web
64:43 - music and design
64:45 - for this year's js 13k competition i
64:48 - created a puzzle game heavily inspired
64:50 - by the puzzle system and paper mario the
64:52 - origami king the goal in my game is to
64:55 - create a symmetrical sequence of symbols
64:57 - by sliding and rotating them
65:00 - on top of that for each puzzle there's a
65:02 - time limit and a life system
65:05 - as you've seen the game takes place on
65:07 - what i'd like to call a roller coaster
65:09 - i'm going to talk about how i
65:10 - implemented it and how i got there
65:13 - pretty early on i decided that the
65:15 - puzzles should be solved while racing on
65:17 - an infinite track that goes left and
65:18 - right randomly but also very smoothly
65:22 - while working out how to approach this i
65:24 - quickly realized i may have been a bit
65:26 - too ambitious
65:27 - creating an infinite random track that
65:29 - feels also smooth
65:31 - isn't easy
65:32 - but then i had my first eureka moment
65:35 - needs to feel like it's infinite it
65:36 - doesn't have to be infinite
65:38 - i can just define a path that's super
65:40 - big and eventually loops back on itself
65:43 - what better way than to just define the
65:44 - parametric curve using sines and cosines
65:48 - i experimented a bit with sine and
65:49 - cosines and settled on this definition
65:51 - of the parametric curve
65:54 - however the rollercoaster is not just a
65:56 - curve every point also needs an
65:58 - orientation i need to know what's
65:59 - forward and what's up for every point
66:02 - forward this simple it's just the
66:04 - derivative of the parametric curve
66:07 - but what way is up
66:08 - well the curve loops around the origin
66:10 - so i guess i can just use this as the up
66:13 - vector alright
66:16 - well it works but as you can see it
66:18 - doesn't really feel quite right
66:21 - at least to me it doesn't
66:23 - but then after some dueling i have my
66:25 - second eureka moment
66:27 - second derivative
66:28 - now what if i use the second derivative
66:30 - as an up vector
66:33 - as you can see it's perfect
66:37 - and that's how i created the basis of a
66:38 - streamingly influenced smooth roller
66:40 - coaster
66:41 - hope you learned something
66:44 - [Music]
66:51 - we have now come to our last and final
66:53 - winner of the js 13k games 2020.
66:56 - feedback from the experts is this
66:59 - jupiter hardly says really impressive
67:01 - sound machine bjorn rizzo absolute
67:04 - genius i really look forward to seeing
67:06 - what people will be able to create with
67:07 - this is there already some place where
67:09 - people can share their creations and
67:11 - michelle mannering goes oh my god it's
67:13 - like scrabble great instructions good
67:16 - documentation and nice work thanking
67:18 - everyone
67:19 - this maybe is not so much a game as a
67:21 - platform to create musical creations
67:24 - using coach
67:25 - it also has some awesome demos of what
67:27 - you can make like for example the intro
67:29 - to mario i'm not going to go through the
67:32 - code for this one so simply enjoy
67:47 - okay so there we have it those were this
67:49 - year's winners for the js 13k games
67:51 - 2020. i really do hope this video has
67:54 - inspired you to go forth and create some
67:57 - games i mean it definitely inspired me i
68:00 - loved being a judge on it and i can't
68:03 - wait to see your submissions it doesn't
68:05 - matter if you're just running out
68:07 - doesn't matter if you've been doing this
68:08 - for years and the creativity that comes
68:10 - out of it is just so inspiring it's
68:12 - amazing i mean it's just mind-blowing so
68:15 - don't forget all the developers are in
68:17 - the description below if you want to
68:19 - check them out as well as their games
68:21 - and the source code to their games i'm
68:23 - also going to put a link to andrea's
68:25 - competition in the description and of
68:27 - course please do like and subscribe to
68:29 - this video and my own channel my youtube
68:32 - channel if you enjoyed this and would
68:34 - like to see more
68:35 - thanks very much and i'll see you soon