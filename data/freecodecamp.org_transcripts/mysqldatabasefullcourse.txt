00:00 - MySQL is one of the most popular databases,
learn how to use it in this course from a
00:05 - senior database engineer. Welcome to this
basic MySQL course I want to start by appreciating
00:12 - you for trying to learn a new skill. Let me
introduce myself. My name is Barbara and I
00:17 - work for Salesforce as a senior database engineer,
I have over 12 years of experience with a
00:23 - variety of databases Oracle being the main
one, I have experience working with companies
00:29 - like Chase, PayPal, Wells, Fargo, StubHub,
etc. Let me answer a few basic questions for
00:35 - you first, and that is who, what and why.
So who should take this course this course
00:41 - is meant for database professionals who want
to expand their skill set. If you are a software
00:46 - engineer or a full stack developer and you
want to gain a deep understanding of MySQL
00:52 - database, this course is for you. And if you're
a college student, or a computer science student
00:57 - or a fresh graduate, this course will give
you some knowledge on database internals.
01:02 - So why should you learn MySQL, MySQL is the
most popular open source database and of course,
01:09 - Postgres. SQL is definitely up there. As companies
move their data from on prem to cloud, they
01:15 - usually like migrate to a cloud native database,
or an open source database, like MySQL or
01:23 - Postgres sequel, in order to save costs. So
let's say that you are an Oracle Database
01:29 - expert. If you gain knowledge on a database
like MySQL, then you could help companies
01:34 - migrate their data from Oracle to MySQL, and
that can be really valuable. Now let's look
01:39 - at what is being covered in this course. Now,
first of all, by MySQL, I mean, the MySQL
01:46 - InnoDB storage engine throughout this course,
which is used behind any commerce website,
01:52 - or a bank or a financial institution, and
so on. And MySQL offers a variety of storage
01:58 - engines, my I Sam, in memory storage engine,
or some popular storage engines, which are
02:04 - available, we are going to learn about MySQL
InnoDB, I am not covering any other type of
02:09 - storage engines. Now, these are the topics
that I'm going to cover in this course. And
02:13 - please note that this is a database administration
course. So it is 80% database administration.
02:21 - And for people who are completely new to databases,
I have included SQL basics. So you'll be learning
02:27 - about database installation, MySQL Workbench,
database indexes, database logs, you'll also
02:35 - learn a little bit of performance tuning,
that is SQL explain. So these are some interesting
02:41 - topics that I'm going to cover. So what do
you exactly need to get started with this
02:45 - course, you need a PC or a Mac. So if you're
using a PC, then I recommend you to actually
02:51 - look into the worksheets or supplemental material
that is attached in the description. If you
02:57 - have a Mac laptop, then you are in the best
position to learn this course. Because then
03:03 - you can just see what I'm typing. And you
can just type the same commands and just follow
03:08 - along from end to end. And most of all, this
is the main requirement, I want you to create
03:15 - an AWS account, that's correct and amaze on
Web Services account. So if you don't know
03:20 - what I'm talking about, please do look into
my worksheet which can be found in the description,
03:26 - I've attached some resources, which will show
you how to create an AWS account, I will be
03:30 - using an AWS EC two instance throughout the
course. And I'll show you how to create one.
03:36 - But one main thing that I want you to remember
is after each study session of yours, you
03:42 - can shut down your EC two instance. That way
you don't have to pay any unnecessary cost.
03:48 - And please do remember that you don't have
to keep your EC two instance running 24 seven.
03:59 - So once you have created an AWS account, and
sign in, you will land on this dashboard,
04:05 - or this page. And you can go to the services
menu right here. And then under compute, you
04:13 - can choose easy to so over here on the left
hand side, you can choose instances. And then
04:20 - here we're going to create an instance which
will be our lab environment. So click on launch
04:25 - instance. And then let's choose an image for
our instance. So I'm going to choose Red Hat
04:34 - Enterprise Linux version 864 bit and my instance
type is going to be T two micro which is free
04:42 - tier eligible. And you need to choose an appropriate
subnet. If you just created an AWS account,
04:50 - you can just leave. Leave it whatever default
subnet that shows up for you. For me, I'm
04:58 - going to choose me Be a specific one. And
then make sure to enable this auto assign
05:05 - public IP option. Because that will assign
a public IP to your instance using which you
05:12 - can SSH into your instance, from your laptop,
and leave all the other settings as is. And
05:24 - let's allocate like 25 gigs, for the database,
or for the entire instance. And you can just
05:36 - leave the rest ISIS, go to the next page read,
you can create a tag for your instance. So
05:47 - I'm gonna call it my SQL instance. One, go
to the security group page. And then here,
06:00 - what's important is that you need to be able
to SSH into the instance. And you need to,
06:08 - you need to create proper firewall rules for
that anyone, basically, anyone in the world
06:13 - can log into this instance, via Port 22. And
that's not secure at all. And I will take
06:21 - care of this instance. Because once I finished
recording, I usually remove it. So I know
06:27 - how to handle this. But when you create rules,
make sure to put your laptop's IP in there,
06:36 - just so it's more secure, then now you can
review your configuration, and then click
06:42 - on launch. But if you want, you can create
a new key pair, and then just give it some
06:51 - name. And then download it before you create
the instance. For me, I'm just going to choose
06:58 - an existing key pair. Maybe this one, and
I say knowledge, maybe a different one. All
07:11 - right, this one. And launch instance. Now
your instance is getting created, it probably
07:20 - take a couple of minutes to create this instance.
Okay, that's how you create an EC two instance.
07:27 - And now that my instance is up and running,
and I can see the public IP. Later, I will
07:36 - be installing MySQL on this instance. So that's
what I wanted to show you in this lesson.
07:47 - So what you're seeing is basically my sequel
documentation showing all these different
07:54 - installation guides, like Windows and Mac,
and so on. So we are interested in Linux installation
08:05 - are basically MySQL installation on Linux.
And there's a couple of guides actually. So
08:12 - this one is basically installing jannettek
binary, we're gonna skip that and go here.
08:19 - And even within installing MySQL, on Linux,
there's a bunch of guides. So the recommended
08:26 - method of installation is using RPM packages
from Oracle. But we're going to use this MySQL
08:35 - yum repository based installation. And it's
actually quite straightforward. So for this
08:42 - installation, we need to go to MySQL comm
and downloads. And we are downloading the
08:51 - Community Edition and go to yum repository.
As you know, the instance that we created
09:00 - has Archie l eight, Red Hat, Enterprise Linux
eight running on it. And so we need to download
09:10 - this rpm. But then we need to download the
RPM on the instance itself, the one that we
09:16 - created. So let's actually log into the instance.
So I'm going to use SSH, and we're going to
09:25 - use my private key. And logging is easy to
user choose the default user and basically
09:38 - get the public IP of my instance login and
we switch to a root okay. So one thing that
09:53 - we need for downloading this RPM to this Linux
instance is W get package. So let's go ahead
10:02 - and install that first. Alright, so now that
w gate is installed, we need to download the
10:15 - RPM that we just saw. So to get the link of
this RPM, we need to go into this download.
10:23 - And we have to right click here and copy the
link. And if you're installing on a different
10:31 - OSS, you need to click on the appropriate
button. Okay, so we got the link, and let's
10:38 - just go ahead and paste that link over here,
like w get and the link. And that command
10:48 - downloads this package, now we are going to
use an RPM command to install this package.
10:56 - So this package, as I mentioned before, is
going to add this MySQL yum repo to your local
11:05 - system repo list. With Red Hat Enterprise
Linux installation, you get like a MySQL module
11:13 - by default. So let's disable that one. If
you don't disable it, then this will interfere
11:22 - with our MySQL installation. So let's go ahead
and disable it using this command. And don't
11:30 - worry about writing these commands, I will
put a link to my Git repo with all these comments
11:37 - in the description. So all these have been
disabled. Now let's go ahead and install MySQL
11:45 - community Server Edition using yum install
MySQL community server. And let's put minus
11:56 - y in there just to go ahead and accept all
the prompts. And that's installing all these
12:09 - packages. Alright, so my SQL has been installed.
Let's go ahead and start the MySQL database
12:19 - using system CTL. Command. And let's check
the status. So now, my SQL database is up
12:29 - and running. Okay, so the log file of this
MySQL database software is under var log.
12:41 - And then if you grip temp from this log file,
you will get the temporary password for root
12:50 - user. And you can use that to log into the
MySQL database. And how do you log in, you
12:57 - use this command my sequel minus u, that's
going to be root and minus P is for password
13:08 - based login. And then we're logging into MySQL
database. So let's use this password and see
13:16 - if it logs in. And we are in. And if you run
any command at this point, my sequel is going
13:26 - to ask you to reset the password using alter
user statement. We can do this in a different
13:36 - way. So there is a executable called MySQL
admin. And this is the command for it. MySQL
13:45 - admin, minus you the user name and minus p
password. We are going to reset the password
13:51 - of root user. And let's provide the current
password which is this temporary password
13:57 - first. And let's provide the new password
No. All right, the password has been accepted.
14:09 - Now let me try to log in with this new password
using the previous command my SQL minus u
14:17 - proved and minus p MySQL. Let me put the password
I said just now we are in. So let's go ahead
14:26 - and run a simple show databases command which
shows all the default databases that come
14:32 - as part of the installation. So one more thing
that we need to do to complete the installation
14:37 - is to load a timezone file or timezone table
as shown here. So if I do a select star, which
14:47 - is basically a SQL query to read from this
table, you can see that the table is empty
14:53 - right now. So let's exit out and run another
command. To load timezone related data. So
15:05 - this is the command. And let's go ahead and
run it. And I'm going to go ahead and put
15:12 - my password, and that loads a bunch of data,
you can ignore all these warnings. Let's go
15:19 - back to our MySQL database. So if you do as
select star, from MySQL dot timezone, again,
15:31 - it shows a bunch of data. So now, you're good.
And that completes the MySQL database installation.
15:40 - Alright, folks, in this section, we are going
to talk about data modeling. Okay, so database
15:48 - design, data modeling, schema design, these
are all interchangeable words, terms for database
15:54 - design is an ongoing process. So you come
up with a basic design, when you sort of like
16:01 - create your application. And then as the application,
you know, gets added new features, enhancements,
16:09 - improvements, you basically iterate over this
design, right, you keep adding new things
16:16 - to your design, and so on. So the first thing
that you do when you're doing database design
16:22 - or data modeling is understand business data.
And then once you understand business data,
16:27 - you have to come up with logical design of
your database. What do I mean by that? Well,
16:34 - basically, you have to design your tables,
the columns, that goes into those tables,
16:41 - indexes, constraints, like primary key constraint,
unique key constraint, not null constraints,
16:48 - default values, foreign keys, these are all
various things that you need to create. When
16:58 - you when you come up with a logical design
of your schema, once you actually have this
17:04 - basic table design or schema design, then
you can look for data redundancy, that is
17:13 - basically you see where your data is repetative.
And then you start eliminating it by normalizing
17:22 - your tables actually. And that's because data
redundancy causes data anomalies. What I mean
17:28 - by that is, when you have like multiple occurrences
of the same data, when you're, let's say,
17:36 - updating certain data, you have to update
in many places. And if you forget to update
17:42 - even one place, now you you have two versions
of the same data in your database. And that
17:49 - creates like data anomaly data inconsistency
is along the same lines actually. And all
17:54 - that happens because of data redundancy. So
what we are looking at is basically a spreadsheet
17:59 - and the spreadsheet is basically a huge table
a large table, right? And, and what what we
18:08 - are going to do is basically design a table
for a ecommerce website, an e commerce website
18:15 - is basically like an amazing zone, or E Bay,
or whatever, like online business, like online
18:23 - e commerce website, like Alibaba, or whatever,
right? Let's say like, you have only one table
18:29 - in this database, right? And you start, as
the orders come in, through this website,
18:35 - you start putting data into this table, right?
You have, you know, let's look at some of
18:40 - the things that you will record in this table,
right, you obviously need like a count of
18:46 - your orders. So you might like numbering your
orders, and then how it is coming like, you
18:52 - know, is it desktop or mobile? Or what product
is it? Like, you know, here I have got like
18:58 - a couple of books, the book titles, and then
the price of the products. And then who is
19:03 - the customer customers details, payment details,
delivery details, and so on. So these are
19:11 - all part of like, e commerce word, basically.
Right? And you have one giant table. And if
19:19 - you look at the data here, right? So, you
know, here, I've got like a couple of customers
19:25 - buying you know, sort of like two different
product products, right. So, and you can see
19:33 - that the data has been repetitive. What I
mean by that is like every time I buy the
19:43 - same product, I have to repeat this data,
like the first order that came in was through
19:50 - the web desktop website that was brought by
birth and then you can see all the details
19:56 - of this customer and all that details about
the product and the payment, payment details
20:04 - as well. Then the second order that came was
from a different person, but then it was,
20:10 - you know, the order was for the same product
and you had to repeat the product information.
20:16 - Right. The third was from the previous customer.
But then this time he bought bought a different
20:24 - product, his information, the customer information
has repeated actually. So there is a lot of
20:33 - data redundancy data has been repetative.
So, this is basically a denormalized database,
20:40 - where you have only one table or a handful
of tables, we back all the information from
20:48 - your website, or your business into these
few tables. Actually, this is a denormalized
20:53 - version of your database, let's actually go
look at what else you could do. So what you
21:00 - can do is basically, you can start with this
basic denormalize table, and then you can
21:07 - start taking out all the redundant information
out of your database or your table action,
21:13 - it first thing I did was I took out like the
customer information, they put it in a separate
21:19 - table, right. And I've got only customer details
here. And I started like putting a ID number
21:26 - for each customer ID or customer number, whatever
you call it. Once I take out the customer
21:31 - information, I have the Orders table, the
initial table, I'm calling Orders table looking
21:38 - like this now, right? And you can see that
I've got like customer ID column over here.
21:47 - And what is this customer ID column? Your
guesses? Right? So this customer ID column
21:53 - is the same as what you see over here. Right?
So and why do I have that because I need a
22:01 - way to relate these rows. As you can tell,
like, you know, these are columns, these are
22:08 - rows, these rows, I need to be able to relate
to a customer, right? If I take out customer
22:13 - information, then how can I relate? You know,
this table and that table? It's through a
22:19 - common column, or a bunch of columns. Actually,
in this case, it's just one column. So customer
22:25 - ID, right? I'm just like putting the ID number
over here. And what else actually we can take
22:31 - out of this table. So this is one level of
normalization. Right? So let's keep normalizing
22:37 - which is like take out the product details.
Right? So product details are also repeating.
22:43 - So here, you don't feel that much pain, because
there's only three records in this table.
22:48 - What if the table has million records, right?
This is why we need to normalize the table.
22:54 - Now you actually take out the product information
and move it to a different table. And then
22:59 - I have a product ID column just to number,
like ID the products actually, and your Orders
23:04 - table will look like this, then you take out
the payment information to a different table.
23:09 - And your Orders table will then look like
this. This is basically the process of going
23:15 - from a denormalized schema or a database to
a normalized database. When you have your
23:21 - data in a single table, then you don't need
to do any joints. So you might ask actually,
23:27 - what are joints actually, when you're running
queries, like using SQL, SQL is a language
23:34 - right? A Structured Query Language, when you're
running commands in your database, you, you
23:40 - can get all your data from this one table
if your table database is totally denormalized.
23:45 - Whereas if you have many tables, you need
to sort of combine or join the stables and
23:53 - then you have to get the data out. So that
is called joining the tables. So when you
23:58 - have a denormalize database, you don't have
to do many joints. And that is kind of good
24:05 - in a way because your database doesn't have
to think that much to get the data. You say
24:10 - I want this data and this data is available
in this table. So it's just very straightforward.
24:15 - Whereas like in a in a normalized database,
when you join many tables, then your database
24:21 - engine with which they call optimizer in,
in Oracle or in most of the tape most of the
24:29 - databases. So this database engine has to
think more as then like, okay, which table
24:34 - Should I scan first? And how should I filter
the data in this table. And then Okay, I take
24:40 - the result set from that table and have to
join with these other tables. So there is
24:45 - so much more thinking there's so much more
processing that has to happen on whichever
24:52 - server this database is running on. Right.
And because of that, the performance will
24:59 - be kind of flexible. Lower right and it will
consume a lot of resources and you have all
25:06 - that happening at scale as in like many operations
are happening at the same time, then you basically
25:14 - have slow performance actually, or at least
lower than what it would have been in a denormalize
25:20 - database, but at the same time, we are removing
so much data repetition or data redundancy
25:26 - is very low, because of that, the storage
needed in a normalized database is much lower.
25:33 - So, you cannot actually like generalize and
say a normalized database will always be slow
25:39 - or denormalize database will be fast, it is
all like it depends actually you have to look
25:45 - at the data and see how much repetition is
happening, etc, etc. So, but generally this
25:52 - is how it goes, as you go through this design
process, right, you know, see what we have
26:00 - done actually, right. So, we have decided,
the tables that we need, like you know, we
26:05 - have orders, table products got the customers
and payments, and we decide the column names.
26:11 - And then not just that for each table, you
need to decide actually what will be the primary
26:16 - key. What I mean by that as a primary key
is a unique key and which cannot be null,
26:22 - actually, which is very important. So using
this primary key, you should be able to identify
26:28 - any record in this table, any row in this
table. For example, if I say here, the primary
26:35 - key is order number, then I can, anytime if
I have an order number, then I can look up
26:43 - this table, let's say order number equals
two, I can just get this record out of my
26:48 - database. And then you need to also have like
some unique keys actually, right. So unique
26:53 - keys is pretty much like primary key. And
a unique key can be now a primary key cannot
27:00 - be null, as I mentioned. And then you can
also have indexes on your table. So indexes
27:06 - are ways to basically select your day data
faster. Let's say that I often search this
27:14 - table based on a customer's email, then I
need an index on customer email column, right,
27:22 - you need to decide that. And you need to decide
about which columns can be null. Right? Here,
27:30 - none of the columns can be null. Let's say
you have another column called preference
27:36 - a the customer preference as in what kind
of shipping or what kind of or which phone
27:41 - number is preferred, or something like that.
So that can be a null column, right? So you
27:47 - can have none columns. Otherwise, you define
your columns as not null. Let's say like,
27:52 - in your Orders table, you have this delivered
column, when an order is basically created
27:59 - when a customer buys a product on your website.
Of course, it's not delivered immediately,
28:05 - at the time of order creation, the delivered
column will always have no or n, a n value,
28:13 - right? All these things, all these decisions
that we are making we're talking about is
28:19 - part of schema design. And once you have all
this figured out, you can put the information
28:25 - in your design tool Entity Relationship design
tool. And in the next section, I will show
28:33 - you how I do that on sequel workbench, my
sequel world workbench, basically, you can
28:39 - actually then have a pictorial representation
of your logical design of your database, right.
28:47 - And that's basically what you call an ER diagram.
And of course, you can talk about the relationship
28:52 - between the two tables, let's say you can
say oh, this table in this table, they have
28:58 - one to many relationship, for example, each
customer can place many orders. So that is
29:07 - actually a one to many relationship, right.
But one, you know, one order can be done by
29:13 - only one customer. Right? So, so that kind
of thing. So you have one to one relationship,
29:21 - one to many relationship, or many to many
relationship between tables. Actually, these
29:25 - are all part of data modeling. But you don't
need to be worried so much about that, as
29:32 - long as you have a clear idea of like what
data is coming into your database. And along
29:38 - the way, you need to define like the data
type of your columns. Actually, that is very
29:42 - important. Your names are going to be a wild
char. You know, phone numbers can be numbers,
29:49 - and then email is again like a watch chart.
And your ID column or number columns are going
29:55 - to be int or number. These are all some decisions
that you would make you In a data modeling
30:03 - task, actually, that's pretty much what I
want to say about data modeling, then there's
30:09 - much more we can talk about it. And like atomicity,
like you, you have all the address, sort of
30:17 - like attributes packed into one column, we,
we need to split that as well. So that is
30:25 - called atomicity. You can have address separately,
city separately states separately, and, you
30:30 - know, zip code separately, right. So those
kinds of things, there are nuances that make
30:36 - your database more and more efficient. And,
of course, we're not going to go into a lot
30:41 - of details there. But this is the basic data
modeling that you need to understand. And
30:48 - as I said before, in the next section, I will
show you how to take this and then input that
30:53 - on my sequel workbench. quick recap of what
I did in the last section, I basically created
31:04 - a logical design of an e commerce website.
So what you're looking at is a table that
31:12 - I started with. It's a denormalize table,
and we basically took this denormalized table,
31:18 - and we normalized it. As you can see, there
is four versions of this table, I'm calling
31:25 - this table Orders table. So there is four
different versions. And I with each iteration,
31:30 - I took out repeating data. So finally, we
landed with four tables, apart from the original
31:38 - Orders table. So now we have also customers
products and payment. In this video, I'm going
31:45 - to take this now all the stables and then
I'm going to take the structure, and I am
31:49 - going to create a logical design. Okay, so
let's actually go to MySQL Workbench and I
31:56 - am already connected to a database, what I
am going to do is go to File and go to new
32:05 - models. so here we can add a new ER diagram,
an entity relationship diagram. And let's
32:14 - call this database eecom. Store, something
like that. So let's go ahead and start creating
32:21 - our tables. Now, I'm not going to be creating
all four tables that would take probably more
32:28 - time or long, and I'm going to be creating
a couple of tables. And that should be enough
32:32 - for you to understand how we're doing this.
So let's just start with the Customers table.
32:39 - So the customer table has five columns, this
is the icon for creating a new table, you
32:46 - can drag and drop, or you can try to draw
now double click and then create a table called
32:53 - customer and here we can start putting the
table the column names customer ID, and then
33:01 - this is going to be populated by your sequence.
So sequence is a database object. And it's
33:09 - going to be an integer. So we can leave it
as is. And we can have it as a primary key,
33:18 - that's fine and a primary key has to be populated,
it cannot be now. So that is automatically
33:24 - selected. The next one is customer name, we
could split that into first name, and then
33:30 - we can choose watch our and maybe give a little
bit more room as in the length of the name
33:39 - and then last name, I can watch 100 and then
all these cannot be now so we can choose not
33:47 - null constraint. So these are different constraints
which are available. Let's go ahead with the
33:53 - next one address again address. And if you
remember I talked about atomicity. So you
34:01 - want your columns to be you know, atomic in,
in the sense that here, basically the whole
34:08 - address is packed into one column. good practice
to actually split that into atomic columns
34:15 - as an address separately, city separately
state separately and then zip code separately.
34:26 - So we have all these, of course, none of these
can be now and what else is there? So customer
34:41 - phone number, phone number is going to be
all numbers. But then I want to make get 10
34:47 - numbers, of course not null and customer email.
So I can just say email id 100 Okay, not null.
34:59 - So since I Id is the primary key here or customer
ID, I want to make sure that that we have
35:05 - a constraint to avoid repeating customer information.
For example, if you have one customers data
35:15 - for ID one, I don't want the same customer,
customers data to repeat for a different ID,
35:21 - for example, Id two. So I'm gonna actually
make email id unique for each record over
35:29 - here. And then may or may be phone number
also. So these are all unique key constraints,
35:35 - or unique constraints. That's it. So we have
the Customers table created. So let's go back
35:42 - and see what else we have. So let's now create,
I would say product. And then you basically
35:49 - do the same thing, select that is for creating
a new table. And then now here, you can just
35:56 - draw in this one, I'm going to call it product.
And we want to go through the same process
36:02 - and then put the product column names in there.
If you're wondering, this is the same customer
36:37 - ID column that we added over here. And we
are going to make that a foreign key in a
36:47 - minute. So let's go ahead and split that into
multiple columns. Because, again, everything
36:56 - is packed into one column, which is not a
good practice. So let's say let's call it
37:03 - credit card number. If the customer is using
PayPal, then we need that email. So can use
37:25 - email id over here. So this can be null or
not null based on what payment type is being
37:31 - used. So that's okay, so expiration date is
going to be a date column. So let's actually
37:37 - change that. So if you're not sure, you can
hit that the drop down and then choose your
37:45 - proper data type for each. The other thing
that I mentioned, which is basically about
37:56 - foreign key, this customer ID is the same
as what we added over here. So let's actually
38:03 - make that customer ID a foreign key. So we
can just call it customer ID foreign key one.
38:13 - And then the table that is going to be referenced
is the customers. And the column is going
38:20 - to be customer ID. And that's it. So you can
see that now we have connection or a relation
38:28 - between these two tables, I'm going to actually
just add the Orders table as well. I've created
39:02 - the Orders table as well, which is the main
table and I'm going to now create some foreign
39:08 - keys for the orders. Everything is done. If
you want to create any indexes at this point,
39:22 - you can do that. So I guess we are done. So
we are basically added four tables to our
39:30 - logical design these four tables and then
we have created columns and then define their
39:38 - data types. And also we created the foreign
keys and of course primary key and unique
39:48 - key for each of the tables. And you can see
the foreign key relationship you know clearly
39:55 - showing here and that You know, that's what
you would do to create a data model. Alright,
40:04 - so now actually, let's just go ahead and create
a SQL script for this data model. So you go
40:12 - to database, and then do forward engineer.
And then basically, you provide the database
40:22 - details where you want to create this, these
tables are the schema. So this is, these are
40:31 - my details continue, go to the next one, provide
the password. Right now we are connected,
40:40 - I had to try the password two, three times.
And this has basically created SQL script
40:49 - for us to create the schema and the tables
with all the primary key unique key and foreign
40:57 - key constraints. So what we can do is we can
just continue and then now the database or
41:09 - the schema is created as it goes through and
then executes that script. And close. And
41:17 - now you can see the stables are actually created.
So you can even go to your SQL editor, and
41:27 - then you can start reading your can start
querying your tables. There you go. So you
41:42 - ready came back, of course, there is no data
in it. And you can now start using your database.
41:51 - So we actually successfully created the basic
schema, or designed the data model for this
41:59 - e commerce website. Table creation or a CREATE
TABLE command starts with CREATE TABLE keyword
42:09 - followed by the name of the table and followed
by parenthesis. So within the parenthesis,
42:14 - this pair of parentheses, you have all these
column names, followed by the column data
42:20 - types, and followed by the constraints. And
you can also use this auto increment keyword,
42:27 - if you want your column value to be incremented.
Automatically, as you load values to the as
42:33 - you load records to this table, and after
the column definition, you have the option
42:39 - of specifying the keys like primary keys,
unique keys, foreign keys, and so on, you
42:46 - can also specify the storage engine type as
part of your table creation. And this is a
42:52 - very simple table. You can also have partition
tables or partition tables that have compressed
42:59 - tables, encrypted tables, and all these things
require special keywords to be used in your
43:05 - table definition. And please check my sequel
documentation. If you want more details about
43:12 - the syntax. As mentioned, I'm using just integer
watch char data types, the MySQL documentation
43:20 - shows like all these different data types
like numeric, date, and time data types, string
43:26 - data types, like the ones I'm using, and JSON
spatial. So these are all available in MySQL
43:33 - for you to use. So let's go ahead and create
this table. And before creating the table,
43:39 - I want to run this drop command just to make
sure the table doesn't exist. And I'm going
43:43 - to be creating that table and see if the table
has been created. Yes, the table has been
43:49 - created successfully, I'm going to be running
a select star from the table name to see if
43:55 - I can successfully query from this table as
well. And then it returns. Basically, it doesn't
44:01 - return anything that means no data exists
in the stable. And that's how you create a
44:07 - table using CREATE TABLE syntax. Finally,
there is actually a default keyword which
44:13 - helps you specify default values for a certain
or for your columns. So if you don't specify
44:21 - a value for this quantity column in your insert
statements, or when you're loading through
44:27 - procedures, loading data through procedures,
it will automatically take this default value.
44:33 - That's pretty much it. And I'll see you guys
in my next MySQL SQL session. So I just did
44:43 - a describe on the table that I created and
it has product ID product name, product type,
44:49 - price and quantity. And you can see that product
ID is also an auto incrementing column right
44:56 - now there is no data in it a typical insert
Statement looks like this, let's go to insert
45:02 - into keyword and the table name a bunch of
columns within parenthesis, the ones that
45:08 - you want to populate, followed by the values
keyword. And followed by the actual column
45:13 - values. If you can realize I haven't actually
specified the product ID value because it's
45:19 - an auto incrementing column. So let's go ahead
and execute this and insert statement goes
45:24 - through. So let me also run the select statement.
As you can see, the product ID table has taken
45:31 - the value one, and that's happened automatically
ident supply the value one, so I'll go ahead
45:36 - and commit the change. And then let's actually
move on to the second variation. So this time,
45:43 - I'm going to specify a value for product ID,
nothing else is different. So just want to
45:49 - show you that it is possible. So it goes through
and then a commit. And then let's do a select
45:55 - to make sure the value has been inserted.
So let's go to this third variation of this
46:01 - insert statement. So it's going to be pretty
much the same, except Actually, I'm going
46:06 - to just jump some values and then insert the
value 10. For this product ID column, I'll
46:11 - go ahead and do that. It goes through a comment
and select again, then you can see that that
46:19 - is also fine. So yeah, so that worked. So
you can actually jump a few values. let's
46:25 - actually look at the next variation. Again,
I'm going to insert a record into the stable,
46:32 - with no product ID specified exclusively.
Or explicitly, the product ID column is missing
46:40 - over here, and I'm going to run the insert
statement and commit. And then I'm going to
46:45 - run the select statement. So just wanted to
show you that wherever the latest value is
46:52 - for this auto incrementing column, I inserted
the value 10 for product ID last time, and
46:58 - then the next time I do an insert is auto
increment kicks in and then you know increases,
47:06 - increases this value from 10 to 11, right
picks up from the value that was inserted
47:10 - last time. And I'm gonna just take another
insert statement, and this time, it's actually
47:17 - insert into the table name. And instead of
the values keyword, specifying the column
47:23 - names, values, etc, we actually select from
a different table. Basically, if the products
47:30 - three table is exactly matching the structure
of products, one table, then we can do even
47:37 - a select star from if the columns don't match
exactly as in like products, one has a different
47:46 - set of columns, and product three has a different
set of columns, then we need to make sure
47:51 - that we actually select the columns. And then,
for example, this product ID from products,
47:57 - three maps to this product ID and products
one, and product name from products, three
48:03 - maps to product one in I'm sorry, Product
Name and product one, and so on. Let's go
48:09 - ahead and run this and see what happens. And
then that goes through. And then if I now
48:15 - select the products, one table, you can see
like take all these rows are inserted properly.
48:22 - And basically the products one table is populated.
And then we got all the data from products
48:29 - three table. So this time I want to show you
the insert statement. Again, this is kind
48:34 - of like a bulk insert or multiple insert just
combined into one statement, you can see the
48:41 - insert into clause is specified only once
but in the values spark in this clause, actually,
48:48 - we have two rows specified at the same time.
So we can even use such as syntax and a commit,
48:56 - and then do a select all good. So these are
a few variations of insert statement. I hope
49:03 - you understood how this works. I will see
you guys in the next session. Hey, my sequel
49:12 - learners. So in this session, actually, I'm
going to be talking about update and delete
49:19 - statements. So as usual, I'm going to be using
my eecom store schema. And I will be using
49:25 - my products table to do this demo. So just
quickly, if we select products table, there's
49:31 - two rows right now. So the first update is
just to show you the syntax of update. So
49:38 - you have the update keyword followed by the
table name followed by set keyword. And then
49:44 - you can have as many columns as your table
contains, but in this case, I've got only
49:49 - one column and I can just run this update.
So let's actually add one more clause to it,
49:54 - which is the where clause and this is to just
update the rows that Do you really want to
50:00 - update so we will be updating only the rows
with product ID equals one. So let's go ahead
50:06 - and do that. And then I'll just come in and
do a SELECT FROM products quantity has gone
50:11 - up by 50, it went from 299 to 349. Now one
more thing to realize is actually like you
50:17 - can, you know, you can specify literal values,
when you are updating, you know, that happens
50:22 - all the time. Or you can also like specify
a formula, or you can have SQL functions like
50:29 - replace substring, length, and so on, you
know, you can look at my SQL documentation
50:34 - to see what kind of functions are available
in this update, like, I just wanted to show
50:38 - you the syntax, basically, to let you know
that like you can have multiple, you can update
50:44 - multiple rows at once. In this case, I put
like, values one, two, and three, you know,
50:49 - you don't have to do one row at a time or
anything. So when you use the end keyword,
50:55 - and you can say product ID or whatever, call
them in and then a bunch of values to select
51:00 - the rows that you want. And there are other
ways to do it. But the point being, you can
51:05 - update multiple records at once. And another
interesting usage is using the case statement,
51:12 - you know, you can let's say you have a bunch
of update statements, one for product ID equals
51:18 - one another for product ID equals two and
another for the other product ID values. And
51:24 - you can combine all that into one UPDATE statement
using a case when then and clause or keyword
51:31 - basically, in this case, actually, for product
ID equals one, I want to increment the quantity
51:35 - by 50. And product ID equals two, I want to
increment the quantity by 100, and so on.
51:40 - So then I've got this similar WHERE clause
are similar to the one that I showed you before,
51:45 - I'm going to run this you can see the columns
are getting incremental, I'm not going to
51:50 - go back and check I'm pretty sure that it's
done the right thing. So the next one is basically
51:55 - when you want to delete records from a table
or purge data from a table, then you can just
52:01 - use a simple delete statement. And if you
are wanting to delete a particular row, again,
52:06 - similar to the update, you can use a where
clause to actually like narrow down the data
52:12 - that you want to delete this particular statement,
which is delete from a table name, and then
52:17 - where column name equals or the column value.
And you can have multiple filters in here.
52:23 - So here I don't have the row number three,
I think I deleted it already. Alright, so
52:29 - let's keep going products three table, I just
wanted to show you it contains a lot more
52:33 - data than my other table. You can see it contains
data about 5849 rows, I wanted to also show
52:42 - you this particular parameter MySQL configuration
parameter to basically enable and disable
52:49 - safe updates. So let's say like if your delete
statement or UPDATE statement is not using
52:56 - a primary key column in the where clause,
you know, then basically if you enable this
53:02 - particular parameter, let's say by setting
this one, and then if you run your delete,
53:08 - you will get like an error code 1175 it mean,
and then it says you're using safe update
53:14 - mode, etc, etc. It's not leading you to the
run this kind of add delete statements, because
53:20 - it could be a good cause bad performance.
So if I disable the same thing, and then if
53:25 - I run the Delete statement, and then just
run a select again, then it should go through
53:32 - because now the parameter is disabled. And
two more things. One is actually like if you
53:38 - have a huge table and you want to delete only
a few rows at a time, then you can use the
53:42 - limit keyword to limit the number of records
that are deleted by the statement, you know,
53:49 - in this case, because I wanted to delete only
10 rows, let's go ahead and do that. And it
53:54 - should work just fine. And then if I do a
select, you'll see the difference in the row
54:00 - count actually, now it's like 5839, before
it was fired four nights. So that's how the
54:05 - LIMIT clause helps you also in the limit floors,
you can also specify the ORDER BY clause.
54:12 - It basically sorts the data by these columns,
first by quantity, then by product ID, then
54:18 - it deletes the top and or 100 or whatever
value you put here, actually. So let's go
54:23 - ahead and do it and then select again. Yeah,
Kearney, seven D is gone. So the top 10 rows
54:30 - are gone. And yeah, that's pretty much it.
Actually, those are all a few variations of
54:37 - update and delete statements. And of course,
there's lots of tangents we can get into but
54:42 - I will leave that task to you. And I hope
it was useful. And if you have any questions,
54:48 - let me know in the comments. I'll see you
guys in the next session. MySQL learners.
54:56 - So in this session, we'll look at SELECT statements,
not just the syntax But also like some ways
55:01 - you can actually like improve the performance
of your queries, I'm going to be using the
55:06 - schema called income store to explain about
this SELECT statement in its most simple form
55:11 - will look like this. So you have the Select
and from keywords and then after the Select,
55:17 - you specify the Select list, which is the
columns that you want to select. If you specify
55:23 - a star, or asterik, that actually selects
all the column columns from this table, and
55:29 - then after the from keyword, you specify the
table names where you want to select the data
55:34 - from. So if I do a select star from products
underscore three, it's going to return all
55:39 - the data from products underscore three table.
But do remember that anytime you are using
55:45 - a star after the Select, or in the Select
list, you're basically querying all the columns
55:51 - in this table, you don't need to query all
the columns in the table in most of the cases,
55:56 - so you only like specify the columns that
you need to query. So in this next query,
56:01 - let's go line by line and see what changes
that have done to this query to make it better.
56:07 - So let's say I want to select only these columns.
That's why I specified only these columns
56:11 - in the Select list. In the from clause, I
have specified products underscore three table
56:17 - very often you will be selecting from multiple
tables, you need to join the tables and then
56:22 - retrieve useful data out of it. And in the
where clause, you specify all the filters,
56:29 - or the conditions based on which your data
will be filtered out. So here I am, including
56:34 - only the data which have quantity less than
25. So this way, I'm able to actually filter
56:41 - most of the data out of this table, this is
very useful in minimizing the amount of data
56:47 - that you retrieve from the database. And your
queries are going to be fast as ordered by
56:51 - is basically going to sort the data that is
retrieved based on the columns that we specify
56:57 - here. So here, I'm just like ordering by product
name. And of course, like when you're sorting
57:02 - data, especially when you're sorting a lot
of data, the operation can be expensive, unless
57:07 - your source buffer size, that is actually
the memory area where the slots happen. Unless
57:12 - it is sized properly, the operation can be
really slow. So you need to pay attention
57:17 - to that configuration as well. And I have
this other query, which just goes to show
57:22 - you that like this is a very simple SELECT
statement. Again, in this select, actually,
57:27 - I have only the Select keyword and a function,
I'm using the now function. But there are
57:32 - several other SQL functions that you can use
in the script, for example, I can use the
57:40 - database function to return the database that
I am actually connected to. And as you can
57:44 - see, I am actually able to invoke multiple
functions in the same query. So that's pretty
57:49 - much it. I'll see you guys in the next session.
In this session, I will be teaching about
57:57 - SQL joints, let's dive straight into the demo,
I will be using a schema called eecom store.
58:04 - And I'm creating a table first called T one
with one column, the column name is C one,
58:11 - and I'm inserting these two values in this
table. One and two, I'm creating another table
58:17 - called T two with a column called C one and
inserting these two values again, into table
58:23 - D two, one and three. So it's one and two
here and one and three, here, we're going
58:29 - to go ahead and run a commit to make my changes
permanent. So I'm going to be just creating
58:35 - these two tables just to show you the records,
D one has one and two, D two as one and three.
58:42 - Of course, a join is an operation that joins
two tables. And we have all these different
58:48 - types of joints, we'll go one by one and understand
what they are. So this is the syntax, so select
58:55 - an a column list that you're selecting. So
we're joining T one and T two. And then we're
59:01 - specifying the kind of join that we are making.
And then we also have this on keyword. And
59:07 - then comes the condition on which the table
is joined. So I'm going to go ahead and run
59:12 - this query and see what happens. As you can
see, this query, this inner join has returned
59:19 - the value one, so that means actually, so
it returns the values that exist in both the
59:25 - tables that match. So that's what INNER JOIN
does. So let's just change it to a left to
59:31 - join, go ahead and run it. Now the left join
is gonna return all the values from your left
59:37 - to table which is T one. So T one has values
one and two are the rows one and two, and
59:43 - then T two, it's going to return only the
matching values. And then for this value,
59:49 - which only exists in table T one, it's going
to return and now and then I'm going to change
59:54 - it to right join and as you might have guessed
it's going to return all the way Use from
60:00 - table t to in the places where there is no
matching value, it's going to return a null.
60:06 - So let's see if that happens. That's what
we expected. So we got all the rows from T
60:11 - two, and then for three, there is no matching
value and T one, you know, that position has
60:16 - no value. Now we'll jump quickly to a union.
And then we'll come back to a full join, a
60:22 - union is basically going to look like this.
So two queries, and then in between, we have
60:29 - the union keyword, let's see what it returns,
you can see that it's written one, two, and
60:34 - three. So that's actually the rows from both
the tables, but it's kind of like combined
60:40 - the data and then smashes them together. And
then you have one, two, and three, and then
60:46 - let's run the same query with a slight difference.
We'll put union all and then we'll see what
60:51 - happens. That's written one, two, and one,
three. So that's returned all the data from
60:57 - both the tables, but except this time, we
have duplicate values, Union gets rid of all
61:02 - the duplicate values, it's almost like a set
where you have a unique set of data, a union
61:08 - all returns all the values, including duplicate
data. Jumping back to full join, we don't
61:15 - have a full join keyword. So rather, we do
full join this way in my sequel. So basically,
61:23 - you have the similar query where you're joining
T one and T two, a left join first on this,
61:29 - there's one column that we have, and then
you have another query, again, joining T one
61:34 - and T two on this, just one column, but then
we are doing a union of these two, and that's
61:39 - going to return the data from both the tables,
we have one, two, these two are matching,
61:45 - then for two, there is no matching value.
So it returns and now for three, there is
61:50 - no matching value in T one, it returns a null
over here. So this is a full joint, that's
61:55 - basically all the joints, all different types
of joints that you can do in MySQL, I hope
62:00 - this example was clear. And I'll see you guys
in my next session. All right, my SQL learners.
62:09 - In this section, we're going to learn about
locks. More specifically, I want to talk about
62:14 - the isolation level section. So the first
thing is just see what I have here, I have
62:20 - two terminal sessions. One is in black. The
other one is in slight maroon color. So I'm
62:29 - actually going to log into the database as
the root user. And I'm going to do the same
62:36 - thing over here. There you go. I am logged
into my SQL database. So I have a little script
62:43 - here to create a dummy table called T one.
Okay, so let me show you the SQL script. At
62:51 - this point, actually, you might not understand
the SQL syntax and so on. But then let me
62:58 - explain. Briefly, first thing I'm doing is
setting auto commit to zero or commit is basically
63:05 - a command that you use to save your work.
Basically, the data changes that you're doing
63:15 - is permanently stored in the database. When
you issue a commit command, in my sequel,
63:22 - you have this variable called auto commit,
which is turned on by default, meaning all
63:31 - your commands will be automatically committed.
If you don't turn this off, I want to have
63:36 - more control over what I'm doing here. So
basically, I am doing an auto commit, disable
63:44 - first, so and then I'm starting a transaction.
And just to be safe, I'm dropping this table
63:51 - if I had already created it. So this table
doesn't exist. So it says unknown table. And
63:58 - the next thing is I'm creating a table called
T one in eecom store schema. And then the
64:05 - column name is C one. And the data type is
int and its primary key. So and then I'm actually
64:12 - inserting value, just one row into this table
called p one, right, the one that we just
64:19 - created. And I issue a commit command, alter
or the alternative to commit is rollback command.
64:28 - So which basically rolls back rewards the
changes that you just done in that session.
64:34 - So if I just do a select star from the stable,
then I'm going to see this value, so which
64:42 - is fine so far. So this is pretty straightforward.
So far, we haven't talked about the isolation
64:49 - levels. So what I mean by isolation level
is when multiple sessions are trying to modify
64:57 - or access the same data data, then you need
locking mechanism to make sure the data is
65:06 - not corrupted, or the database is behaving
in a way that you expect to see how you actually
65:14 - set isolation levels. And this is the command.
So this is the other session I had opened
65:20 - show session variables like isolation. So
that shows like the transaction isolation
65:28 - level is set to read committed. Right. So
this is one of the possible options action.
65:34 - So this is read committed, and you have read
uncommitted, and you have repetative read,
65:41 - or repeatable read. And then you have a serializable
value, actually, so let's go one by one, right.
65:49 - In this session, I already started a transaction.
So I'm going to actually try to update this
65:57 - value using an update command. So basically,
I am updating the same table, and I'm updating
66:04 - this column to to where the column value is
currently one, right. So I'm going to do that
66:12 - the auto commit is turned off. So it's not
committed yet for the start a transaction
66:16 - over here. And let me run a query against
the same table and just copy and paste the
66:23 - table name, want to type it, okay, so we see
the value one, which is the previous value.
66:30 - And if I ran the same query over here, in
this session, I see the value two, because
66:38 - this is the session where we are modifying
the data, right? So and I can see the changes
66:44 - before committing in the same session here.
Actually, since the value of this transaction
66:52 - isolation, or the isolation level is set to
read committed, it is possible only to read
67:01 - the committed data. In other words, when multiple
sessions are accessing the same data, in this
67:06 - case, this column right here from this table,
apart from the session that is actually modifying
67:11 - the data, the other sessions can only see
committed data, any data that is committed
67:17 - just before this select is executed. So I'm
going to go here and run a commit, and come
67:27 - back over here and run a select. So now you
see the latest data because that commit happened
67:35 - before I ran this query. Now let's talk about
read uncommitted isolation, setting actually
67:41 - freshly log in again, because these things
can get tricky. So every time I want to just
67:46 - recreate the tables to remove any confusion.
So let's actually log in again, okay, in here,
67:55 - and I'm actually going to execute the same
script that I showed you before. So just disabling
68:02 - auto command, starting a transaction, dropping
the stable and recreating it, inserting this
68:08 - value, and then running the command. So now
here, what we could do is go ahead and update
68:17 - this value to two. But remember, I haven't
committed this data yet. Let's go to this
68:23 - session. And here, go ahead and change the
setting to the isolation setting to read uncommitted,
68:34 - because by default, it is always set to read
committed action. Right. So you can see that
68:43 - here. So and this is a session level setting.
And you can also change it at global level.
68:50 - But for the purpose of this demo, we just
need to change it at the session level. So
68:57 - session level isolation initially read committed,
then I ran the set session transaction, isolation
69:04 - level, read uncommitted, and then checking
the value again. Now it's changed to read
69:10 - uncommitted, if I ran a select star from this
table, then I get the value two, and if you
69:20 - remember that I I only updated the value from
one to two. And you can already see this beta
69:30 - even though it is not committed over here.
So that is how read uncommitted works. So
69:36 - there is not much locking going on here. Because
database is now letting the sessions do dirty
69:44 - reads because one session is able to read
and other sessions changes even before the
69:51 - commits happen actually, right. So those are
dirty reads. Yes, actually. So let's go on
69:56 - to the next one. So we have seen read, committed
and read Committed so far. So now let's move
70:02 - on to repeatable reads action. Right? So exit.
So here I am going to just commit. And I'm
70:11 - gonna re rerun my initial script just to clear
the table. So drop table and then recreated
70:18 - insert, value one again, and then commit.
So now, the table is back to how it looked
70:26 - before. So here, let me log in again. So this
is repeatable read setting, right? So remember
70:36 - that the default value for this isolation
setting is always read committed. So if I
70:45 - change it to repeatable read, write, and then
check the value again, then you can see this.
70:53 - So and again, remember, or show variables
is the command to check the current value.
71:00 - And then set is the command to set the configuration
right, so I will put all these commands in
71:07 - like a git GitHub repo file, then you can
actually grab the commands from there, and
71:15 - then you can try them yourself. Basically,
I'm changing the I'm changing the setting
71:20 - from read committed to repeatable read, right,
so I'm going to just start a new transaction
71:26 - over here in here, I'm going to update this
value to two. And over here, I'm going to
71:35 - run the Select query that we saw before just
selecting everything from this table. And
71:42 - you see that the value is currently one. And
that makes sense. So let me go ahead and run
71:49 - commit. And if I ran the same query, again,
I see the value one. And this is the same
71:57 - as the value that was read before, even though
the data was changed by this other session.
72:06 - And then committed within this transaction,
the data that we are seeing is the same in
72:11 - in other terms, basically, we are, we are
reading the same data, or the reads are being
72:21 - repeated. Right. So that is the third setting.
And the last one is the most strict locking
72:30 - configuration. So which is called serializable.
So I'm going to, as usual, I'm going to drop
72:39 - the table and then just recreate them recreated,
inserted value one again, they might come
72:46 - in. So here, we're going to log in again.
And as usual, the default setting is read
72:54 - committed, right? So let's check that first,
just to show you, and then I'm going to change
73:01 - it to serial serializable. So what this means
is, basically, I'm going to start a transaction.
73:10 - So on the first session, I'm going to run
an update, basically changing the value from
73:15 - one to two. And here, I'm going to start a
transaction, and I'm going to run a query
73:23 - on that table. Right. And now this query,
even though it's just a select, select is
73:29 - just a read, it's not updating, it's not deleting
or doing anything, it's just a read, it is
73:36 - waiting, because the update is basically updating
this data. And then it's not database, MySQL
73:47 - databases, not even letting this read or the
Select query from the other session to see
73:53 - the data. So this is the most strict setting
action. So if I do a commit over here, then
74:00 - on this other session, you will see that the
Gradius return and it's seeing the latest
74:06 - value, right. So if I go ahead and run another
select, of course, it's returning the same
74:14 - thing. But if I try to update this value from
two to three, another update, that is basically
74:22 - going to wait on the Select, basically this
transaction that is running right now because
74:29 - the Select again, select is just a read, it
is just reading the data. But still it is
74:36 - locking that row in the database, and it's
not letting any updates or modifications to
74:44 - that data. And then you can see that the update
even failed because it waited for some time
74:50 - and then the timeout value exceeded so we
don't have to go into those details. But I'm
74:55 - going to try updating now. And here. I'm just
going to exit out of this session, which will
75:01 - release all the locks. And that will help
the update to go through. And then I can commit
75:09 - and exit as well, and how you hope it was
clear to you guys. And if you have any questions,
75:14 - please put it in the comments and reach out
to me somehow I know you can figure it out,
75:19 - as you guys are next section. Hey, MySQL learners.
So welcome back to this new section of my
75:27 - MySQL tutorial. So in this video, or in this
section, we're going to talk about locks.
75:34 - So what are these locks? Right? So let's actually
approach this kind of like logically. So if
75:41 - you have a database, and if you're the only
person working in this database, then you
75:47 - basically need not worry about anything, right?
You know what you're doing. So you will insert
75:55 - data, delete, or update data the way you want.
And there is no one else trying to intervene
76:03 - or interrupt your work. But unfortunately,
that's not the case. In today's world. If
76:11 - you think of a busy ecommerce database like
Amazon, then then there's like, a lot going
76:19 - on on the on those websites. There's like
multiple people browsing is like, a lot of
76:27 - people buying stuff. There's the people who
are selling stuff on on these websites, they're
76:34 - updating data relevant to their products.
So that is basically concurrency, right? So
76:40 - you have many users trying to do something
on this website at the same time, so how do
76:49 - you manage this concurrency, that's why we
need locks. So if I let everyone work on the
76:57 - same data at the same time, then there's going
to be a lot of confusion. And we might end
77:04 - up losing some data. So let me actually show
you a simple example of how that happens.
77:11 - So I have a table, a product table. So if
you've been following my tutorial, thus far,
77:21 - we talked about this table called products.
So where we store all the product information,
77:29 - right. So now, there's a couple of records
over here. And let's say that we have a seller
77:37 - and a buyer who are working on these records,
especially like this particular record, the
77:45 - first one, which is a book, and the books,
prizes, this and the quantity, the thing we
77:51 - didn't have quantity when we talked about
it in my previous sections. But then I added
77:57 - quantity here. So there's this quantity column.
And there's a there's a seller and buying
78:05 - buyer interested in this record, let's look
at this, right, so we have sort of like a
78:11 - time sequence here. So what the seller of
this particular product is trying to do is
78:18 - he's trying to update the quantity of this
product at nine one, he is adding 60 more
78:27 - quantity to that product, which is you know,
40 plus 60, which 100. And that's what we
78:36 - have over here. So then a buyer comes and
he looks at the quantity. And then he basically
78:45 - wants to order two or these books, that's
100 minus 90 100 minus two, it's 98 and then
78:53 - you have the quantity 98 over here. So this
happened in a sequence. So but we are worried
79:02 - about concurrency, right? concurrency is like
when things happen at the same time. But what
79:08 - if Okay, first the seller comes and then he
reads the quantity of this item. Initially
79:15 - it was 40 and then buyer comes and he also
sees that the quantity is 40. Right? And at
79:25 - 901. So the first two operations happen at
the same time at nine or one seller comes
79:32 - in he says I want to update I want to add
60 more quantity, like meaning I have 60 more
79:41 - books of this title, but then buyer comes
and he says okay, I'm buying two items or
79:48 - two of these books. So but while you that
he saw before was 40. So 40 minus two is 38.
79:59 - So he updates the quantity 38. So the seller
updates at 200. But then, because of this
80:07 - previous look up, the quantity is updated
to 38. due to which this whole thing, this
80:17 - whole operation is lost. And we end up with
sort of like corrupted data for this quantity
80:26 - column. So this is a simple example of how
concurrency when not managed well might cause
80:33 - issue data issues like this. MySQL learners.
So in this video, we are going to look at
80:45 - basically how table locks works. In the context
of e commerce database, we created a simple
80:57 - database or schema called the column store.
And we created a bunch of tables or used another
81:05 - dummy table to explain our transaction isolation
levels. So if you haven't seen my previous
81:13 - material, go back and check it out. And come
back here. But then yeah, you have four tables
81:19 - for main tables. And the main table that we
are interested in is products table here.
81:25 - And in the products table, I inserted a couple
of records. These are dummy records. So I
81:32 - don't have a front end or application running
over here. So we're just looking at database,
81:38 - right. So what what's going to happen in this
tutorial is, so we, we're going to basically
81:47 - simulate a situation where a seller is trying
to update the quantity of the book that he
81:57 - is selling on this website, which is this
first book actually, the common path to uncommon
82:04 - success. And then the right now the quantity
of this the quantity available. You know,
82:11 - for this book is 40, right? So he wants to
update this quantity 200. And also, we'll
82:20 - have a couple of more users, or buyers, basically
one buyer is trying to buy the same book,
82:29 - we'll have another buyer Hill, who tried to
buy a different book, which is this book,
82:35 - tiny habits, and then the same buyer will
also try to browse the website, like of course,
82:42 - like, we are going to have to imagine a little
bit because I don't have a front end to show
82:48 - you everything. So let's actually see how
this goes. So first of all, you know basics
82:57 - first, actually, let's actually turn off the
auto commit. Just so just so actually, we
83:07 - have more control over what's happening. And
let me do that in all the three sessions I
83:15 - have open and the first session is the seller
session. The second session is the buyer one
83:21 - session. And the third session is the buyer
to session, basically. So I'm going to turn
83:28 - off the auto commit, which is basically a
mechanism that commits automatically if it's
83:34 - enabled. And I don't want that. So I'm disabling
it. So next is I want to show you the transaction
83:43 - isolation level. And we talked about it in
my previous session. So right now it's a repeatable
83:51 - read. And it's the same for all. So we are
going to change that to read committed, because
84:00 - read committed is isolation is the right isolation
level for OLTP databases. So now let's actually
84:10 - start with the first seller session. So three
sessions. So the first seller session is going
84:19 - to update the quantity of this book that he's
interested in or his selling action. But we
84:30 - are going to take this aggressive approach
and log the whole table. Right. So let's say
84:37 - the application is returned in a way that
it logs the whole product stable for right.
84:42 - And then the other session, let's say by one
second session, buyer one comes and he is
84:51 - going to try to buy two books and and how
actually we're going To do that is by running
85:01 - an update. So we are basically updating the
products table and we are subtracting the
85:05 - quantity by two, which means actually the
we are buying two books. And which book is
85:13 - there in the book? Where are the record where
product ID equals one, right? So if you remember
85:20 - the data, product ID one is this book, let's
go ahead and run this update in the second
85:27 - session. And it's going to obviously, wait,
because the table itself has been locked for
85:34 - right by the seller session, the buyer, one
session is waiting. And let's go to the buyer
85:42 - to session the buyer to Australia trying to
buy a different book, which book is it this
85:49 - other book, which is tiny habits book where
product ID equals two. And we're gonna do
85:58 - that. Of course, even that is hanging or waiting.
And that is actually a little bit crazy, isn't
86:09 - it. So just sellers trying to update the quantity
of this one record with just one book. And
86:17 - everything is tanking. And the buyer, too,
was trying to buy a different book, he kind
86:25 - of gives up. So he moves to a different session.
And instead of buying or trying to buy a book,
86:32 - he just tries to browse the website, which
is a select query or read query, read a select
86:41 - query, which is also hanging. So the buyer
too is getting frustrated right now. So you
86:49 - can see how restricted this kind of sequences.
So if someone's using table logs, that's going
86:58 - to basically reduce the concurrency of the
operations that can happen in this database.
87:07 - So that's the main point here in this demo.
Hey, my sequel learners. So in this session,
87:17 - we are going to take a brief look at row level
locks. In my sequel, I have three sessions,
87:24 - I'm already connected to my ecommerce database,
MySQL database, and this is how the data looks
87:31 - now. So we have a products table which holds
you know, this data, only two books now, just
87:40 - dummy data that I created this, this is the
price and you have the quantity column showing
87:49 - you how many, how much quantity is left for
each of these books. So the first session
87:55 - is seller session. The second session is buyer
session, we can call this buyer one session.
88:06 - And the third session is a buyer to session.
So this is the data. And just for clarity,
88:17 - actually, I wanted to show you the transaction
isolation setting, which is read committed.
88:24 - And the auto commit is turned to turned off
basically, it's disabled. So unless I commit
88:34 - explicitly, my transactions will not be permanent.
So let's actually start with a seller. He's
88:48 - going on the website or a portal that he has
available to update the inventory of, let's
88:55 - say the book one, it or the product one, which
is this book. And so he is going to click
89:04 - some buttons, which is going to translate
to an update statement being executed in this
89:12 - database, right? So let's say he wants to
increase the number of books available in
89:19 - the inventory. So that will mean quantity
is going to be increased incremented by 50.
89:28 - So that's the UPDATE statement. And he's going
to run that update. And we can look at the
89:41 - buyer one session, let's say buyer one is
trying to buy the same book. And and then,
89:52 - so he's going to go on the website and then
click on buy now or whatever and then is going
90:00 - to translate into this UPDATE statement in
the database, choose quantity equals quantity
90:05 - minus one. So reducing the quantity by one,
meaning he's buying a, buying a book. And
90:13 - of course, there's going to be, you know,
other statements updating other tables. But
90:19 - then to keep it simple, I'm just showing you
the product table changes section. So as you
90:28 - can see, this is going to wait because seller
is updating this particular row action. And
90:39 - that can be seen using acquittee. On data
locks, so if you're under this greddy, of
90:57 - course, you can modify this query as per your
needs. But then if you query this, you will
91:02 - see that there's bunch of sessions and is,
is the lock mode column. And then the table
91:12 - on which the database on which the locks are
happening the table, so it gives you a lot
91:20 - of details. So, so if you want to understand
what's going on here. So we have products
91:27 - table, and then we have ix lock, which is
intention, exclusive lock on the table itself,
91:36 - meaning like a transaction is about to get
an exclusive lock. And this is at the table
91:42 - level, but don't get tricked by that. There
is also another row indicating there is a
91:50 - record level or a row level lock. And, and
that is logging only this data equals one.
92:01 - So if you remember that UPDATE statement,
we are using product ID. So and data for which
92:09 - is one, actually, so product ID equals one.
So that's what we are seeing over here. And
92:15 - if you see here, this buyer session has actually
timed out already, so he's going to attempt
92:21 - to buy again. So that's how like, you can
actually look at the locking details in this
92:28 - table. Let's try, let's say like buyer two
comes in at this point. And then he just tries
92:36 - to browse the inventory on this ecommerce
website. So that would mean a select query
92:44 - or read query. And he's, he's able to do this
happy reaction. Right. So there is no problem.
92:50 - So while the rollouts are happening, other
sessions can read this table, they can even
92:56 - look at the data for the same product. But
they they just cannot buy this book, because
93:03 - that is being blocked by the seller. So again,
it timed out. So at this point, buyer two
93:09 - wants to buy a different book, you know, I'm
not able to buy this book, let me try buying
93:15 - a different book, that's going to translate
to, you know, product ID ID equals two, which
93:22 - is not being locked by the seller. And then
that update goes through. And at this point,
93:28 - let's say the seller has completed updating
the inventory. And, of course, if you look
93:36 - at the data, now, it's going to look different,
because this has been updated to 150. And
93:43 - of course, this hasn't gone down because buyer,
buyer, one is still in the process of buying
93:51 - the book, because the commit has not happened
yet in the application. And then if we look
93:59 - at the data, again, the data has gone down,
or the quantity has gone down, then via two,
94:08 - let's say wants to buy the first book that
buyer one wanted to buy. At this point, there
94:16 - are no no locks in this table. Because everyone's
committed, and let's say buyer, who is trying
94:26 - to buy this, this book, and then he goes through
with that date, and then commits and look
94:37 - at data. And then the data is changing actually.
So this is how row level log basically allows
94:47 - for high concurrency. So only the rows which
are logged by your transactions are not available
94:55 - for these other sessions to modify. Right
So the other records which are not touched
95:05 - by your transactions are available for updating,
deleting, etc. and all, of course, you can
95:14 - add new books, that means inserting new records
in this table. So I just wanted to show you
95:22 - the difference between table level logs and
row level locks. So this session and my previous
95:29 - session will, will be useful in understanding
that difference. Thank you, I'll see you in
95:36 - my next session. In this session, we're going
to be talking about deadlocks. And I just
95:46 - want to show you how deadlocks happen, they
do happen in in a busy ecommerce or B. database
95:55 - often, so it's good to know what they are.
So it's going to be a very short and sweet
96:04 - session. So here, we have a couple of sessions
again, so connecting a connected to the same
96:12 - database has two sessions, two different sessions.
So let's say that we are working with products
96:21 - table, right. So we have seen the stable before
in my previous sessions. Basically, this table
96:29 - has information about the products that are
being sold on, you know, an e commerce website.
96:37 - So we have a couple of records over here,
you know, we're going to first let's say,
96:45 - you know, I seller comes to actually update
the quantity of this product, basically, let's
96:51 - say if he wants to increase the quantity by
25. For this first book, this is the command
96:58 - that he's, you know, that's going to be executed,
you know, whatever buttons he is clicking,
97:04 - will be translated to an update command like
this. Right. And let's say like a different
97:11 - person from the same company wants to update
the price of this book, not this book, let's
97:16 - say we have it the other book, I'm just actually
using the product ID to update the right product,
97:23 - right. So we have one session where seller,
one is updating the quantity of this item,
97:29 - we have another session where we are updating
the price of this item. And then if you see
97:36 - the prices incremented by two, let's say $2.
And this is fine, right? So now we have row
97:43 - level locks. So this guy is holding a row
level lock on this row. And this guy is holding
97:51 - a row level lock on this row. So this is fine,
right? So we are operating on two different
97:57 - records, two different locks are independent
of each other. All good. So now let's say
98:05 - the same seller, the second person who is
updating with price, wants to update the price
98:17 - of this other book to actually like he is
actually increasing the price. Again, by $2
98:22 - of this book, the product ID equals one, which
book, this one right here, let's go ahead
98:28 - and try to increment the price. By running
this command, you know, he's waiting on waiting
98:38 - for the lock ECI exclusive lock. And that's
not available, because this seller has not
98:44 - committed actually is not committed. So let's
actually go back here and, and this seller
98:52 - at the same time price to update the price
of or quantity of this book. So two sessions
98:58 - are fighting for pretty much the same resource,
you know, we ended up in a deadlock situation.
99:06 - So my sequel was smart, smart enough to just
kill the session. Otherwise, we would have
99:14 - two sessions waiting for each other endlessly.
Right? So here you can see the error code
99:22 - that is thrown, it says deadlock found when
trying to get locks and try restarting that
99:29 - transaction. So let's go ahead and query the
products table and see how it looks. You can
99:37 - see this, this whole transaction was rolled
back. Correct. Both the transactions were
99:43 - rolled back. There's even this one was rolled
back. So I think that Locke was also killed.
99:49 - So that's why this this one went through.
If you can see the prices have increased by
99:57 - $2. right because initially For 1699 and 2039,
and here 8099 and 20 to 39. Okay, so that's
100:10 - how it works. This is a typical deadlock situation,
I hope this explanation was clear. And I will
100:17 - see you guys in my next session. All right,
my sequel learners. So in this session, we're
100:26 - going to talk about clustered indexes. So,
so clustered index is not a different index
100:33 - type as in, like, you can, you know, directly
create a create a clustered index yourself.
100:41 - So it is a type of index that, that MySQL
kind of maintains in the, you know, behind
100:48 - the scenes actually. So, in also your table
data, the data that you insert into your tables
100:55 - or load into your tables are maintained in
these indexes. indexes only what I mean by
101:04 - that is, so let's say this is a B tree index,
right, so this is a B tree index. So you have
101:11 - my sequel, creating this B tree index, as
you load the data into these tables. And then,
101:19 - you know, in the leaf nodes, what you have
is actually the data, the data that you're
101:26 - loading into these tables, right? In the clustering,
the sorting is based on the primary key that
101:33 - you define, or, you know, in this table, actually,
so if you don't define a primary key, MySQL
101:40 - will automatically pick up a non nullable
index key, what that means is, so let's say
101:49 - that, in fact, actually, let's jump straight
into the example that I have prepared for
101:55 - you guys. So so this is my MySQL Workbench.
And, you know, I'll show you this table definition.
102:08 - So this is called products underscore one.
And it's basically a products table that is
102:13 - typically used in a ecommerce store. And if
you've been following my lessons, this is
102:18 - what I've been using, I just changed the name
of the table for, you know, demonstrating
102:24 - this concept, this clustering, clustered index
concept. So you have all these like columns,
102:31 - and I'm defining a primary key. Okay, so let's
just start by, you know, I'm just going to
102:38 - switch to a database called eecom, store our
schema called the econ store, I'm going to
102:44 - drop, you know, these tables if they exist
already, by any chance. So the table doesn't
102:51 - exist, which is okay, so I'm going to create
this table, which I just talked about, called
102:56 - products. And then this table has primary
key in a primary key is product ID. So product
103:08 - ID is sort of like an integer column. So this
is an auto increment, right? So you don't
103:13 - even have to provide value for this column,
actually, when you load the data, so you can
103:19 - just put all this information and load it
and then we are good, MySQL will automatically
103:26 - increment the value of this column action.
So and then, of course, like I said, like
103:32 - there is isbm column, which is over here,
sort of leg book iasb. And information if
103:39 - you are, you know, if you remember your school
days like this, this is be a number attached
103:45 - with any book, so something like that. So
some kind of ISDN alphanumeric number. So
103:52 - I'm going to call that like a unique key or
a unique constraint. And let's go ahead and
103:59 - create the stable and this constraint. So
that was successfully created. And I'm going
104:05 - to create a procedure, which I can use to
kind of like populate the stable, right, so
104:13 - don't worry about the details of this procedure.
This is something that I wrote to populate
104:19 - this table. And then that is successfully
created and change the delimiter back to a
104:28 - semi colon. And then I'm going to call this
procedure and which is going to throw some
104:33 - warnings, which is okay with me. As long as
as long as the data gets populated, I'm fine.
104:40 - So it's going to probably generate some, you
know, load some 6000 plus rows into this table.
104:48 - So we'll see how much we get this awesome.
So it's actually loading a lot of data. It
104:54 - seems to be done. So let's go ahead and commit
the data and Now Actually, I'm going to select
105:02 - the data in this table, right? Just select
all the data, and you will see that the data
105:10 - by default, or the data is actually sorted
based on the primary key, which is product
105:15 - ID. And you can see, we know, I haven't like
specified any ordering. So this is, you know,
105:22 - this is the default ordering of data, right.
And so basically, your table data is sorted
105:30 - based on your clustered index, which is primary
key over here, because you have the primary
105:38 - key in the table section. Right. So now the
next thing is actually, I'm going to create
105:42 - a similar table, which is, you know, so I'm
going to call it products too. But in this
105:48 - case, I'm going to basically not define a
primary key, I'm still going to have a unique
105:55 - key called, again, the same thing, you know,
it's isbm, it's a unique key. And let's just
106:03 - give it a different name, just so we have
kind of like, we have different names for
106:10 - different constraints. So let's actually go
ahead and create this table. And so this table
106:18 - is created, I'm going to copy the data from
the first table that you know, where I loaded
106:25 - a lot of data. So I'm going to copy the data
from that table into this table, right. So
106:30 - just very simple. And then I'm going to commit,
right, so that's a board 6455 6455 number
106:40 - of rows inserted into this table. And I'm
going to select all the rows from this table.
106:50 - And you can see that now, the data is not
sorted by product Id rather it is sorted by
106:56 - this iasb. And it is sorting based on first
character first, and then Initially, the first
107:02 - and second characters are the same, then 010
true. And that keeps going 05 and then 090,
107:12 - a BCD of GE hedge and then having after the
zeros, you know, see one, so it is basically
107:21 - sorting data based on iasb. And and why is
being because because of the absence of primary
107:29 - key, it's going to choose this iasb and column,
as are the it's going to choose this non nullable
107:38 - unique index key, which is based on iasb and
column, right. So it's starting based on this,
107:45 - but this is actually a terrible, terrible
idea. Because if you're generating random,
107:50 - alphanumeric strings for iasb. And, you know,
then you're not going to be generating the
107:57 - string in sort of like an ascending order
or in any type of order, actually. So in that
108:03 - case, actually, you know, when you're, as
you're inserting data into the stable, this
108:09 - B tree is going to be created behind the scenes.
And then my sequel, like whatever program
108:17 - is creating or maintaining this data structure
behind the scenes has to work really, really
108:21 - hard to manage this Bre B tree index, actually,
right. That's why this is a terrible idea
108:27 - to have like a you UID or some kind of alphanumeric
string as a primary key actually, or in the
108:36 - absence of primary key. Well, my sequel is
going to use this this key for clustering.
108:41 - And again, it is very bad. So keep that in
mind when you're creating tables actually.
108:48 - Right. So finally, what I'm going to do is
create another table called product three.
108:55 - And before that, I'm going to show you the
output of this query, which is basically going
109:01 - to come up empty or no, no, no road rows returned.
All I'm doing is actually checking whether
109:09 - this index the index with named Jen flushed
index is there in this database, actually.
109:15 - And then I'm checking the InnoDB tables and
information schema I'm joining in odb tables
109:21 - and in odb indexes. And I'm checking whether
this index indeed exists, right? Saying it
109:28 - doesn't exist, which is where the this, this
credit, return no rows, and I'm going to create
109:35 - this table and this time, I'm not even going
to create the create a unique key. And I'm
109:40 - going to make all these columns as nullable
columns, you know. So I just want to show
109:46 - you what happens when you have a scenario
where you're creating a table with all nullable
109:52 - columns and no primary key index no unique,
not nullable index and you know Then I'm going
110:01 - to insert data into this table. Again, six,
the 400 plus rows inserted, commit. And then
110:11 - I'm going to select from this product three
table right now. And when the data comes up,
110:18 - you can see that there is still some ordering
that's happening. And, you know, we don't
110:23 - have any of these options primary key or a
not nullable, unique key available, then how
110:30 - is MySQL able to sort data? What is it using,
so it actually uses a hidden, hidden key actually,
110:39 - right, a hidden primary key. So if you run
the same query, again, is ready, you can see
110:46 - that this index has been created on products
three table, which is maintained internally
110:54 - by my SQL, for just the purpose of clustering
this table, actually. Okay, so that's a lot
111:01 - of information. I hope you found this useful.
And I will see you guys in my next video.
111:08 - Hello, my SQL learners. So in this session,
I want to teach you the basics of using explain
111:18 - or explained plan in MySQL. Alright, so now
let's just let me just show you the table
111:23 - that I'm going to be working with, I'm going
to be working with that table called products
111:28 - underscore one. And it's got some net in a
product name, product type price. And if the
111:36 - product is a book, it will have an ISP a number
attached with it. And then there is a quantity
111:44 - column. So these are some basic columns that
you would see in an e commerce online store.
111:51 - So let's get started by just looking at the
indexes of this table. So this basically has
111:59 - two indexes. One is a primary key index, which
is on the product ID. And the other one is
112:09 - an index on the iasb and column. And this
is a unique index, actually. So let's get
112:14 - started by picking a simple query that we
are going to kind of like optimize using explain.
112:24 - So the query that I'm going to be using is
this. So I'm going to be selecting iasb. And
112:32 - from this products underscore one table where
product name has cat in it. So the product
112:49 - name is cat. Okay, so And before I run this
query, I'm going to look at the explained
112:55 - plan of it. And I'm going to put a slash g
at the end. So I get that we'll put in there
113:04 - in a readable format. So first of all, it
gives this output, right, and selectors, just
113:14 - one straights, simple select. That's what
this is showing. But the main thing is we
113:20 - are working with our this particular row is
referring to this table. And apart from that,
113:27 - actually, you have all these columns, and
then they are all null right now, like they
113:31 - don't make much sense apart from this. So
this is a tight column and all means that
113:40 - it is doing a full table scan. Basically,
MySQL is doing a full table scan, it's scanning
113:46 - the whole table. And how many rows is that
it's these many rows. And we are using a filter
113:54 - over here, it gets all those rows and then
it filters the output. And basically a you
114:02 - know, there's about 600 rows with product
name equals cat, right, so the filtered person
114:14 - ages like 10%, basically, and then there is
some extra information. Let's go ahead and
114:20 - create an index on this table. Create index
called, you know, we can give an arbitrary
114:27 - name. And, and I'm going to create add on
products, one table and the column is product
114:37 - name, of course. This is the column on which
I'm creating the index. Actually, let's just
114:42 - go ahead and run the explain again. So this
is the explained plan. And that's how it looks.
114:57 - So basically, you can see that the Again,
it's pretty much the same kind of output,
115:04 - but this time, it is also showing some data
for all these columns. So first of all possible
115:10 - keys column shows like all the indexes that
this query can use. And, and out of which,
115:18 - like this is the key or index that it is,
you know, it is going to use this particular
115:26 - execution is going to use, and this is the
key length in bytes actually write the number
115:33 - of rows that is being scanned in this key,
which is 589. And, you know, since this is
115:44 - index based, we're not really filtering data,
rather, we're just going to the index and
115:50 - getting the data. So there is no filtering
over there. Let's actually create another
115:56 - index, which also includes iasb. And, and
see, like, what happens, actually, we're gonna
116:04 - create the other index and give it a different
name. So let's go ahead and run the explain
116:17 - plan again. So now, again, the possible keys
are these two indexes, but it still chooses
116:27 - to go with this particular index, and the
index, key length is the same, and then grows,
116:35 - and etc, etc. So there's no filtering that
happened, right? Because we're choosing an
116:42 - index. So you might be wondering, like, you
know, why it's not using the covering index,
116:49 - right. So this is supposed to be the covering
index and covering indexes are supposed to
116:55 - be better than normal, non clustered index
or a secondary index. So you can actually
117:02 - like, use a format like JSON format to get
more information. So how you can do that is
117:12 - by just specifying like format equals JSON,
and use the use that. And so that's going
117:26 - to give you the output in JSON format. And
you can see that the you know, it gives you
117:33 - a little bit more information as then like
the query cost, you know, this is how much
117:38 - it's going to cost for my sequel to execute
this query. And this is a representation of
117:44 - the amount of work MySQL has to do to run
this query actually. So the cost for this
117:53 - one is 7690, right. And then again, it says
these are the possible keys. And used key
118:01 - is used key parts is product name, which was
not given over here. And then there is a cost
118:09 - and for which is a split of where the cost
is going. So you can read my SQL documentation
118:18 - on all these fields. You know, you might be
wondering why the covering index is not being
118:25 - used. And we can actually force that index
by using this use index. Syntax or use index
118:37 - keyword. And then I'm going to put the index
name that I want to force which is this one.
118:46 - And when I ran it, this ran the explained
plan this time, it shows the cost of this
118:55 - one is going to be 109 point two seven, you
know in comparison to the previous explain
119:03 - plan, where the cost is only 76. And this
is why my sequel is going with this particular
119:12 - plan instead of this guy. Okay, I hope this
session was useful.