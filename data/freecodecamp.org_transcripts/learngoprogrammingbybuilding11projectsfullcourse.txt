00:00 - if you want to take your go programming
00:01 - skills to the next level this is the
00:03 - course for you experienced go developer
00:06 - akil sharma will teach you how to build
00:08 - 10 projects using go the projects go in
00:11 - order of difficulty starting with a
00:13 - simple web server
00:16 - so in this video we learn how to build a
00:17 - very basic golang web server the
00:19 - prerequisite to this video is that you
00:21 - should have golang installed on your
00:22 - system
00:23 - and you should have a very basic idea of
00:25 - how golang works like packages trucks
00:27 - and interfaces
00:28 - and uh you can watch a video on how to
00:31 - install golang if you don't have it on
00:32 - your system and it doesn't matter if
00:34 - it's open to
00:36 - mac or
00:37 - windows the steps that i'll be covering
00:39 - in this video will be similar for all of
00:41 - them
00:41 - so i i'm on my windows laptop and i've
00:44 - opened my up my powershell uh which is
00:46 - basically a terminal for windows and on
00:48 - mac you'll have terminal on opendo
00:49 - you'll have uh your bash or your
00:52 - terminal again
00:54 - so
00:55 - you once you've installed golang on your
00:57 - system you'll have
00:59 - a folder called go so that's where you
01:02 - want to be you want to be inside that
01:04 - folder called go and inside this folder
01:06 - you want to be inside a directory called
01:08 - as src
01:10 - inside this src directory
01:13 - uh we'll create a new directory called
01:16 - go server
01:19 - and we'll go inside this directory
01:22 - this is where we
01:23 - create our code
01:24 - so i'll open this in my code editor
01:26 - which is vs code
01:32 - so now that i'm in my code editor i'm
01:34 - going to go ahead and create a folder
01:36 - called static where i'll keep my html or
01:38 - static files and my main dot go file
01:40 - where all my golan code will reside as
01:43 - you know when we start writing any golan
01:45 - code we have to write package main in
01:47 - the beginning and then we have to
01:49 - import some packages from package main
01:52 - so
01:54 - one
01:54 - uh of the packages that i need is fmt
01:57 - then i need the log package then i need
01:59 - net slash http package which has most of
02:02 - the functions that i need to create a
02:04 - web server and routes right and then as
02:06 - you know for every golang
02:09 - code we have to have trunk main which is
02:11 - where most of the control of the
02:13 - operation lies right now i'll switch
02:16 - over to my draw.i o board and show you
02:18 - what exactly we're building
02:20 - so i thought before we start building
02:22 - any of the functions it's better to show
02:23 - you uh what we're building so we here's
02:26 - our server file and here are the three
02:28 - routes that we'll be building today
02:30 - one is the root route which is just a
02:33 - slash then we have slash hello and then
02:35 - we have slash form
02:36 - when we hit the slash
02:38 - route or the root route we'll just
02:41 - open up index.html file
02:43 - and then we have slash hello
02:45 - uh which will just uh call function
02:48 - hello function and just print hello to
02:50 - the
02:50 - screen and then we have a slash form
02:53 - route which will have a form function
02:55 - associated with it and then that will
02:57 - open up a form.html file for us right so
03:00 - we have to create index.html and form
03:01 - the html files right now
03:03 - and then we have to write these
03:05 - routes inside our funk main and then we
03:07 - have to create these functions also
03:10 - inside our main.go file right so now
03:12 - that you have a 10 000 feet view of what
03:14 - we're doing it'll just uh everything
03:16 - will make a lot more sense so now let's
03:18 - uh switch back to our vs code
03:21 - back in our vs code you have seen that
03:24 - we had worked till this point till funk
03:26 - main now it's time to create two files
03:29 - index.html
03:33 - form dot
03:35 - html in our static folder in index.html
03:38 - we'll write some very basic code we'll
03:40 - say html
03:42 - and then we'll say
03:44 - head
03:47 - and
03:48 - sorry we'll say
03:51 - title
03:55 - here we'll say static
03:58 - website
04:00 - and after the head we'll place a body
04:04 - tag
04:06 - inside the body tag we will have an h2
04:08 - tag
04:10 - and we will again say static
04:12 - website and that's that's about it
04:16 - in our form
04:18 - we'll have
04:20 - slash doc
04:22 - type
04:26 - html then we have an html tag
04:30 - we'll have a head tag
04:33 - inside the head tag we'll say meta card
04:36 - set
04:37 - is equal to
04:38 - utf-8
04:42 - slash right so that's what our meta tag
04:45 - does
04:46 - and then we have our body tag
04:52 - which will have a div
04:54 - it will have a form method
04:58 - is equal to post
05:00 - right so we want to
05:02 - post
05:03 - the form
05:06 - and then we will have slash form
05:11 - right
05:15 - and then
05:16 - we have our label
05:18 - uh i'm i'm assuming that you already
05:21 - know uh html so i'm not explaining a lot
05:23 - of things
05:24 - right but anyways this is the name
05:26 - field that we want the user to input
05:29 - right so we'll have input
05:31 - name is equal to
05:33 - name
05:34 - and then you have type is equal to text
05:38 - and you can also skip this part if you
05:40 - don't really uh you know want to
05:43 - bother about html
05:46 - and then you have label then you have
05:48 - address
05:50 - [Applause]
05:51 - then you have your input name is equal
05:54 - to
05:55 - address and type equal to
05:58 - text
06:00 - and value
06:02 - nothing
06:04 - right and then you have your
06:09 - end code type is equal to your submit
06:11 - button
06:14 - value
06:16 - submit so a submit button which will
06:18 - have
06:19 - submit written over it
06:22 - all right
06:23 - and this completes our form
06:27 - that we want the user to fill right and
06:29 - now we want to start wiring up our
06:32 - main
06:33 - logic which is inside the funk main
06:36 - so inside funk main
06:39 - we'll have a file server
06:44 - which is basically
06:47 - uh a function that we get inside the hdb
06:49 - package that we just imported so let's
06:51 - say file
06:53 - server where s is capital so make sure
06:56 - you say that
06:57 - and here
06:59 - uh
07:00 - you have a short form assignment
07:03 - operator which basically declares and
07:05 - defines a variable right so with colon
07:08 - and is equal to
07:10 - and then you have http
07:13 - dot directory
07:17 - dot static
07:21 - slash static i meant
07:24 - so we're telling
07:25 - uh golang that we want you to check out
07:29 - the static directory
07:31 - and now golang automatically knows that
07:32 - it has to look at the index.html file
07:34 - because uh
07:36 - as you know php golang node.js all of
07:38 - them look at the index.html file right
07:40 - that's what they're trained to do as
07:42 - servers
07:43 - and now you have
07:46 - a handle
07:47 - function inside your hdb package
07:51 - right
07:52 - and so i want to start handling my root
07:55 - route which is just the slashed out so
07:56 - how do i handle it i say
07:59 - send that to
08:00 - the file server function that i just
08:02 - created which is you know just on top of
08:04 - this
08:05 - and then you have your http dot andrew
08:10 - funk
08:11 - which handle funk is another uh
08:16 - what he called function that we get
08:17 - inside the http package and now i want
08:19 - to handle my
08:21 - slash form route and you have
08:24 - form handler
08:26 - right so we'll create the form handler
08:28 - function shortly
08:29 - and then you have another handle func
08:34 - where we'll handle
08:35 - our slash hello function
08:37 - right slash hello route that which we'll
08:40 - call the
08:41 - hello handler function
08:44 - so far so good i've already shown you
08:46 - what slash hello and slash form are
08:48 - supposed to slash form will show us the
08:49 - form which is from.html just the slash
08:52 - will serve as the index.html file which
08:54 - i've shown you how it will do that and
08:56 - slash hello will just print out hello
08:58 - to the screen and we'll have to create a
09:00 - function called hello handler for that
09:03 - and
09:04 - now let's
09:07 - also
09:10 - print out what will be printed out when
09:12 - our server connects
09:14 - so server.port 8080
09:18 - and
09:20 - right so if you want to put new line you
09:21 - have to use printf which is inside the
09:23 - fmt
09:24 - package that we've just imported
09:29 - now let's handle
09:32 - our
09:35 - server
09:36 - so we
09:37 - uh you know use the listen and serve
09:41 - function inside the http package so as
09:43 - you can see hd packet is very important
09:45 - and this will create the server so this
09:48 - is really the heart of the
09:51 - software that you're creating
09:54 - right so they can be
09:56 - uh the error can be there or it could be
09:59 - nil so one of these two values will be
10:01 - assigned to err which is the error so
10:04 - now let's handle the error if it's not
10:06 - equal to nil
10:08 - then we want to do something so we want
10:09 - to log dot
10:11 - fatal
10:13 - error and this is where we used our log
10:15 - package
10:16 - to handle or to you know log the error
10:20 - so so far so good with the
10:22 - main.go now we want to start creating
10:25 - our main functions so first we'll create
10:27 - the hello handler
10:29 - and func
10:33 - hello
10:34 - handler
10:37 - this usually has two things so one is w
10:40 - and the other is r
10:42 - right so w is
10:44 - http dot
10:45 - response writer
10:47 - so as you know with any api or any route
10:50 - you'll have either a response and a
10:53 - request
10:54 - so request is something that the user
10:56 - sends to the server and response is what
10:58 - the server sends back to the user
11:01 - so we'll keep that value in w which is
11:03 - the response and for the request that
11:05 - the user will send
11:06 - which will be in http dot request
11:09 - this star is a pointer so r is basically
11:12 - pointing to the request right
11:14 - so yeah i'm assuming you have basic idea
11:16 - of how pointers work even if you don't
11:19 - uh
11:20 - it's okay i think you can just follow
11:22 - this video right so as soon as we wrote
11:24 - funk uh hello handler you can see the
11:27 - squiggly line below hello hundred went
11:28 - away because now it's uh it knows what
11:30 - to do when it uh you know encounters
11:32 - this route now let's start writing out
11:35 - our function
11:37 - so url
11:40 - r is as you know the request so when the
11:42 - uh user sends a request which will be in
11:44 - the form of like let's say slash hello
11:47 - right so what you want to see is if user
11:49 - dot if the r url dot
11:52 - path
11:53 - is not
11:54 - equal to hello
11:57 - now we're sending the uh the request
11:59 - which is slash hello to the hello
12:01 - handler but let's say by mistake
12:02 - something comes here so now we want to
12:04 - check if uh you know the path is not
12:06 - yellow handler then we'll do something
12:08 - we'll say sleepy dot
12:10 - error
12:13 - w slash
12:16 - 44 not found
12:18 - and
12:20 - http dot
12:22 - status not
12:25 - found
12:26 - all right
12:27 - and we'll just return from the function
12:31 - and then
12:32 - if
12:33 - r dot
12:35 - method
12:37 - not is equal to get
12:39 - so we want only uh
12:41 - like when you type slash hello in your
12:43 - browser right that default by default is
12:45 - a get method
12:47 - right
12:48 - and we don't want people to post
12:49 - anything to slash hello we want people
12:51 - only to get and in the sense just print
12:53 - out hello right that's why we're saying
12:55 - that if it's uh
12:57 - not get then again you'll
12:59 - return an error http dot error
13:03 - which will be w again
13:05 - and method is not supported
13:10 - then you have http dot
13:12 - status not
13:14 - found
13:15 - now again status not found is again
13:18 - inside http packet so you can see how
13:19 - important that is
13:21 - and then we'll again return from this
13:23 - function if this is the condition
13:26 - but the ideal condition would be that we
13:28 - want to just print to the screen which
13:30 - is
13:31 - f
13:32 - print
13:34 - f
13:35 - so fmt by the way has a lot of these
13:38 - uh
13:39 - you know functions like printf print ln
13:42 - fprintf right you can check them out and
13:45 - they're all for very different things
13:48 - and so we'll say hello
13:51 - and that's what our hello handle will do
13:53 - now there's this quickly line below form
13:55 - handler
13:57 - so that means we want to write a form
13:59 - handler function
14:01 - so let's start doing that so we'll say
14:03 - funk
14:04 - form handler
14:06 - w http dot
14:09 - response
14:14 - writer and our
14:18 - asterix http dot
14:23 - request
14:25 - now uh you're going to be using this
14:27 - very often so just
14:30 - i mean it's the same syntax so
14:32 - uh you can keep it copy paste it
14:33 - somewhere and then just keep copy
14:35 - pasting it that's completely all right
14:37 - and
14:39 - again we'll have the same thing if error
14:44 - parse form so you want to
14:46 - parse a form right
14:47 - uh we want people to submit something in
14:49 - their form their html file and there
14:51 - will be a post request and they will
14:53 - then that will parse the form
14:57 - error not equal to nil
15:00 - basically if there is error then we want
15:01 - to say print
15:03 - fmp dot
15:06 - f print f
15:09 - w
15:24 - error okay
15:26 - didn't we look done so this is just
15:28 - basically printing out the error
15:30 - and
15:32 - here we'll say f print
15:35 - if
15:38 - [Applause]
15:40 - w comma
15:42 - post request
15:44 - successful which is the ideal scenario
15:46 - which is where you want to be
15:48 - and we'll say name
15:51 - is equal to
15:52 - so whatever we'll fill in the form right
15:54 - you remember the form so whatever we'll
15:57 - fill in the form
15:58 - uh
15:59 - we want the values to be taken into
16:01 - these variables so r dot
16:04 - form value
16:08 - name so we want name from the form to
16:10 - come to
16:11 - uh name
16:14 - and then we want
16:16 - address
16:17 - to be equal to
16:18 - r dot
16:20 - form value
16:22 - address
16:25 - and we'll say fmt dot
16:27 - f
16:28 - printf
16:31 - w comma
16:34 - name is equal to
16:36 - percentage s
16:38 - new line
16:39 - comma name
16:44 - and then we say fmp dot
16:47 - f
16:49 - f printf is basically printing it on the
16:51 - screen
16:53 - print f
16:55 - comma
16:57 - so whatever the the user has written so
16:59 - we're just going to basically
17:01 - um
17:03 - printed out here now uh
17:05 - you must have seen that there was a
17:07 - squiggly line below and a name and then
17:09 - once we used name out here the squiggly
17:11 - line went away because golang tries to
17:13 - tell you that you're you've defined this
17:14 - variable but you're not using it so
17:15 - that's an error in golang and this
17:17 - doesn't happen with javascript and you
17:18 - can have like millions of variables that
17:20 - you never end up using and that's a
17:22 - problem right
17:23 - uh so that's a nice thing about golang
17:25 - that it catches all of that
17:27 - and then you'll say address so now the
17:30 - squiggly line below address is also gone
17:31 - away
17:33 - now this completes our function
17:35 - so let's uh head over to the
17:39 - um
17:40 - powershell and check it out if it works
17:44 - so back inside our terminal or
17:46 - powershell we're still inside that
17:47 - folder go dash server where we've
17:50 - written all our code
17:51 - and now we're going to
17:54 - run a command called go
17:56 - build which will create a binary
17:58 - executable file it'll be a dot exe file
18:00 - because i'm in windows
18:02 - and um
18:05 - now i can run
18:06 - go run main dot go so
18:09 - we have given our main file the name
18:11 - main.go but you could have named it
18:12 - anything else but main.go is the usual
18:15 - accepted standard right so that's why we
18:17 - named it main.go now we're going to run
18:19 - that code
18:20 - and it's going to say starting server at
18:22 - port 8080 because that's what we had
18:23 - written if you remember in our funk main
18:26 - uh it's it's given me so it's showing me
18:28 - a pop-up which is asking me for my
18:29 - permission for my firewall so i'm going
18:32 - to allow access you might not see that
18:33 - in your in the screen recording software
18:35 - probably now we'll have to head over to
18:37 - our browser to see what's happening out
18:39 - there
18:40 - so let's go to our browser
18:44 - and here we'll open a new tab
18:46 - we'll say localhost 8080 now you
18:48 - remember we have three uh routes we're
18:51 - handling three different routes right so
18:53 - one is the route route which is this
18:55 - just the slash then we have slash hello
18:58 - and then we have slash
19:00 - form.html right so we have those three
19:03 - uh routes that we're handling so slash
19:05 - we're handling
19:06 - uh using file server and then we're
19:08 - handling hello using hello uh hello funk
19:11 - handler uh the function hello handler
19:13 - function then we're handling slash form
19:16 - using the
19:17 - uh form handler function right so in the
19:20 - diagram if you see this right slash
19:22 - hello slash form and then with slash we
19:24 - want to open up the index.html file we
19:26 - just written static server and that will
19:28 - be printed to the screen and then we
19:30 - have slash hello where we just want to
19:32 - print out hello to the screen and then
19:33 - we have a slash form where we open up a
19:35 - form
19:36 - from the html file and then we'll have
19:38 - we'll fill up the form and then we'll
19:40 - you know post to the server and print
19:43 - out something to the screen again
19:44 - all right so let's uh start off by
19:48 - checking out the slash route and see
19:50 - what happens it says static website
19:52 - right which is exactly what is written
19:54 - inside the index.html file and if we say
19:57 - slash hello
19:58 - uh the hello handler function will be
20:00 - called and you will just print out hello
20:02 - uh to the screen and then if we have
20:05 - form
20:06 - dot
20:07 - html
20:09 - i'll just enter my details here and
20:11 - submit so remember it'll say posts
20:14 - request successful because that's what
20:16 - we had written in our code right inside
20:17 - the form hillary function and after uh
20:21 - you know you submitted those details
20:22 - it's just going to print out those
20:23 - details to the screen that's all it does
20:25 - so f printf name and f printf address if
20:27 - you remember writing that right so it's
20:28 - just printing out those values
20:30 - to the screen
20:31 - that's what our simple web server in
20:34 - golang does in this video we'll build a
20:36 - complete crud api using
20:38 - golang and we'll have something called
20:40 - as a movie server which will give us the
20:42 - list of all movies and we can create
20:44 - update and delete as well
20:46 - that's what crutch stands for and uh
20:48 - this diagram is a 10 000 feet view of
20:51 - what we'll be building so that once we
20:52 - start coding you won't have any um
20:55 - confusions right of what why we're doing
20:56 - certain things
20:57 - so there won't be a database that's why
20:59 - i put a big cross here that we are not
21:00 - going to use the database we'll instead
21:02 - use trucks and slices to actually
21:04 - perform operations on the data inside
21:05 - the server itself and uh we'll be um
21:09 - serving it on localhost 8000. we'll be
21:11 - using gorilla mux and gorilla mux is an
21:13 - external library so i'll show you how to
21:15 - install it as well and
21:18 - so we'll have five different routes so
21:19 - we'll have get all route we'll have a
21:21 - get by id route create route update
21:22 - route and delete route and that's
21:24 - something you need to remember because
21:25 - uh once we start coding you'll
21:28 - understand why i have shown you this
21:30 - diagram so every single route will have
21:32 - a corresponding function so if it's a
21:33 - get all route it'll have a get movies
21:35 - function if it's get by id then you'll
21:37 - have a get movie function uh without the
21:39 - s and then if it's a create route we'll
21:41 - have a create movie function and so on
21:43 - for updating delete as well right now
21:45 - there are two types of endpoints slash
21:46 - movies or slash movies by id and we have
21:48 - to use them depending on
21:50 - what we're doing in the sense if we're
21:52 - creating then obviously it's slashed
21:53 - movies if you're updating then obviously
21:55 - the id is required so it has to be slash
21:56 - movie slash id right
21:58 - then there are methods so
22:00 - there are get methods for get all and
22:01 - get by id we'll use get method for
22:03 - create we'll use post for update we'll
22:06 - use put and for delete we'll use the
22:07 - delete method
22:08 - and we'll be using postman to test all
22:11 - these endpoints
22:13 - using all these methods right so um
22:16 - what we'll start doing now is we'll
22:18 - start first we'll create a
22:21 - directory for uh keeping this
22:23 - project and then we'll start writing the
22:25 - code and then i'll take you to postspan
22:27 - to test all the apis so the prerequisite
22:30 - here is that you need to have golang
22:31 - installed on your system
22:33 - uh now i'll see you on the powershell
22:36 - so now we are at our powershell for
22:38 - windows we have powershell for ubuntu or
22:40 - mac you'll have your terminal uh is the
22:42 - same thing and the commands that i'll be
22:44 - writing here will be exactly the same
22:46 - for uh mac and ubuntu as well so you
22:48 - don't have to worry uh now the
22:49 - prerequisite like i said is that you
22:51 - should have golang installed in your
22:52 - server on your system i meant and that
22:54 - means that you'll have a folder called
22:56 - as go
22:57 - in your system right so you have to go
22:59 - inside the go folder you have to go
23:00 - inside src if you don't have src then
23:02 - you can create src but you'll definitely
23:04 - have been in uh package i think so you
23:07 - can create the src folder and now you're
23:08 - inside the src folder right as you can
23:10 - see here
23:11 - uh now we'll create
23:15 - a
23:15 - directory called go movies product
23:20 - and we're going to see it inside this
23:23 - directory
23:25 - right
23:26 - and like i
23:27 - mentioned in the beginning of the video
23:28 - that we'll be using gorilla marks now
23:30 - gorilla mux is
23:32 - not part of the main package that you
23:34 - get with golang right so it's an
23:35 - external package
23:37 - so uh the way to install that is using
23:39 - goget
23:40 - and you have to put the github.com uh
23:43 - link for the same right so
23:45 - the link for gorilla is gorilla slash
23:48 - mux and then
23:50 - github.com then you use go get to get it
23:53 - and then once i hit enter
23:57 - it's going to install it or in my go
23:58 - moviestrad folder
24:01 - now i'll
24:03 - open up my code editor window you could
24:05 - use notepad plus plus i'm using vs4 in
24:07 - this video so i'm going to open up this
24:08 - folder in code plus in vs code like i
24:11 - said and i'm going to try and shift
24:14 - to the
24:15 - visual studio code so i think now you
24:17 - can see vs code on your screen as well
24:20 - and
24:21 - here we'll create a file called main.go
24:25 - now this video is a beginner friendly
24:27 - video so i'm not going to have different
24:28 - folders and a very complex project
24:30 - structure which will have routes and
24:31 - controllers and models and database and
24:33 - all of those files
24:34 - and folders because that will uh you
24:36 - know
24:37 - i'll have to configure the go path i'll
24:38 - have to configure
24:40 - the relative routing and all of those
24:41 - things so
24:42 - i don't want you to be confused if
24:44 - you're a beginner so
24:45 - if you've just learned golang and you
24:46 - just want to get your hands dirty with
24:48 - building a server and building a rest
24:50 - api this is the right video for you so
24:51 - i'm going to try and write everything in
24:52 - the main.go uh file right so so that you
24:56 - don't get confused and this is also why
24:58 - i'm also not using a database and i'm
25:00 - using just structs and slices to
25:02 - actually manipulate the data inside
25:03 - golang itself
25:04 - and so let's get started so as you know
25:07 - that when we write the main.go file the
25:09 - first thing that we have to write is the
25:11 - package main right so and then we start
25:14 - importing the packages that we need
25:16 - so i know that i'll be using fmt because
25:18 - i'm going to be printing out stuff like
25:20 - your server is connected and that kind
25:22 - of stuff i know that i'll be using log
25:25 - because i want to log out the errors if
25:26 - there's any error for connecting to
25:29 - the server and then i'll be using
25:31 - encoding json or by the way all these
25:34 - are part of the package main so you
25:35 - don't have to really uh you know worry
25:38 - so encoding slash json uh i need this
25:40 - because i want to encode uh
25:43 - my data into json when i send it to
25:45 - postman and then i need
25:48 - math slash random
25:50 - we'll be creating
25:52 - uh so let's say the user adds a new
25:54 - movie to this movie server so we need to
25:56 - create a new id for it and that will be
25:58 - created using math.math random so that's
26:00 - why i need that and then i obviously
26:02 - need net slash http because this allows
26:06 - us to create a server in golang so
26:08 - that's it's quite important obviously
26:10 - and then you have your string conversion
26:14 - uh because the
26:16 - id that i'll create using math.random
26:18 - will be an integer and then i'll have to
26:20 - convert into a string so i'll use string
26:22 - and string convert and i'll use itoa to
26:25 - format the the integer and then um
26:28 - you know convert into string
26:30 - so and then i'll have the external
26:32 - library that we just installed which is
26:34 - gorilla marks
26:36 - so you'll say github.com and slash word
26:37 - class remarks now you'll get a quick
26:39 - line for all these packages because
26:41 - uh you have imported them but you're not
26:43 - using them so golang knows that and
26:44 - golang is going to trouble you till the
26:46 - time you start using those packages and
26:48 - which will be quite soon for us so we'll
26:50 - start using them soon now uh if you
26:53 - remember i told you that we won't be
26:54 - using a database we'll be using structs
26:57 - and slices right
26:59 - struct is basically like an object in um
27:02 - in javascript if you view javascript or
27:04 - java or any other language it's like an
27:05 - object and you're going to define you
27:08 - are going to have almost like key value
27:09 - pairs and you're going to define uh you
27:11 - know the types of data inside that
27:14 - so i'm going to have a struct of type
27:17 - movie and i'm going to have
27:20 - uh start of type director
27:24 - okay
27:26 - and
27:28 - movies and directors are going to be
27:29 - associated in the sense that every
27:32 - movie has a director
27:34 - that's how they're going to be
27:35 - associated so movie will have multiple
27:37 - other things he'll have
27:38 - an id
27:40 - which will be string right and then you
27:42 - put this character which is
27:45 - i think called carrot not sure this is
27:47 - directly below the escape button on your
27:48 - left on your keyboard and then you say
27:51 - json
27:52 - and then you say
27:56 - id
27:59 - within double quotes
28:01 - then you have isbn which is basically
28:03 - just a number uh assigned a unique id
28:06 - assigned to a film
28:07 - and then you have again those characters
28:10 - and then you have json and
28:15 - isbn
28:18 - it's right struct here then this quickly
28:20 - like hopefully go away
28:23 - and then you would have the title of the
28:25 - movie obviously the movie has a title
28:27 - right and you'll put string here and
28:29 - then you put a json
28:32 - and then you'll say it's
28:34 - title
28:37 - then you have to say director
28:39 - star
28:42 - director and
28:45 - json
28:53 - and
28:54 - star
28:55 - is a pointer as you know
28:57 - uh so that means if i create a struct
28:59 - call director
29:01 - it will be associated to movie struct
29:04 - and with director what i'm saying is
29:06 - that director will have the same values
29:08 - that i'll define inside the director
29:09 - right so these are strings idea has been
29:12 - entitled strings but director is a type
29:13 - of director which is the struct that
29:15 - i've defined which i'm defining right
29:17 - now and
29:18 - director will have first name
29:21 - which will be a string
29:24 - json
29:25 - and
29:27 - hostname
29:29 - and we'll have a last name
29:34 - so again djson
29:40 - right so when we send this data using
29:43 - postman we'll be using isbn id title and
29:46 - director in small
29:48 - with small
29:49 - you know what do you call it
29:51 - small caps
29:53 - same with first name and last name
29:55 - that's why we're defining json like this
29:58 - so that we're able to encode and decode
29:59 - the json when it comes from postman
30:02 - and so we've defined our two structs and
30:04 - like i said movies are associated to
30:06 - directors right every movie has one
30:08 - director
30:10 - and then we'll have our
30:12 - so we'll define
30:15 - a variable called movies it will be a
30:16 - slice
30:17 - of the type movie
30:19 - this right so because we'll be using
30:20 - movies very often now you'll see why
30:23 - uh i won't
30:24 - try to explain it i'll just show you uh
30:26 - instead so we as you know every golan
30:29 - code every go file has
30:31 - funk main
30:33 - right in funk main
30:36 - you will have your
30:38 - uh so
30:39 - in golang i'm sure you know that you
30:41 - have colon is equal to which declares
30:43 - and defines the variable at the same
30:44 - time so you'll have much dot
30:46 - new
30:47 - router
30:52 - new router is a function inside the mux
30:53 - library inside correla
30:55 - so r is now your new router router
30:59 - and then you'll have r dot
31:02 - handle
31:03 - funk
31:04 - and you'll have
31:05 - uh five functions here
31:07 - so let me take you back to
31:10 - the
31:11 - yeah
31:12 - chrome
31:13 - and show you those five functions so
31:14 - we'll have
31:15 - uh five routes as you remember one two
31:17 - three four five and we'll have five
31:18 - different functions right
31:20 - so
31:21 - inside our uh funk main file itself funk
31:23 - main function itself we'll have to
31:25 - define these routes and functions
31:27 - so let's go back to the code window
31:33 - i'm not sure if you can see it
31:43 - yeah so now you can see it
31:45 - so i'm back at the code window and now
31:49 - i need to create five different routes
31:51 - and five different functions right so
31:53 - first route is the movies route
31:57 - i'll get
31:59 - movies
32:00 - get movies will be the function so if i
32:02 - hit the get move slash movies route i'll
32:04 - need to take it to the get movies
32:05 - function which i'll define in some time
32:07 - till the time i don't define it it's
32:08 - going to give me a squiggly and say that
32:09 - you don't have this function
32:11 - and the method i'll be using here is get
32:14 - you've seen this on the diagram that
32:15 - i'll be using get method for getting all
32:17 - the movies right then you'll have our
32:19 - dot handle fun
32:23 - slash movies
32:25 - slash
32:27 - id
32:29 - and get
32:30 - movie
32:31 - so as you can see there's no s here it's
32:33 - get movie get a singular movie
32:35 - and methods again is
32:38 - get
32:40 - then you have another handle
32:43 - funk
32:45 - slash movies
32:51 - and methods
32:52 - is post
32:56 - then you have r dot handle i'm not
32:58 - copying and pasting r dot handle from
33:00 - this line uh i'm typing it again and
33:02 - again because i want you to type as well
33:04 - and that will ensure that you have some
33:07 - muscle memory
33:08 - and then you'll be able to write code on
33:10 - the fly really quickly and you won't
33:11 - make a lot of mistakes so it's always
33:13 - good to write it again from scratch
33:16 - so you have a function here called
33:18 - update movie
33:20 - then you have methods
33:23 - and say put
33:25 - and say r dot handle
33:29 - funk
33:31 - slash movie slash
33:33 - id again
33:36 - we have delete
33:38 - movie
33:40 - dot
33:41 - methods
33:44 - delete
33:47 - okay
33:48 - so we have the functions we have the
33:50 - methods and we have the routes so all of
33:52 - that makes sense
33:54 - and
33:55 - to start the server what we'll say is so
33:58 - first we'll have to print
34:01 - starting
34:03 - server at port
34:06 - 8000
34:10 - slash n
34:12 - right
34:13 - and i'm going to say
34:15 - i'm going to log out if
34:17 - the server doesn't start
34:19 - and i'm going to put i'm going to use
34:21 - the
34:22 - listen and serve function inside the hd
34:24 - package that i have here http package so
34:26 - to start a server it's very simple in
34:27 - golang right all you have to do is http
34:29 - dot
34:30 - listen
34:31 - and
34:32 - serve that that's all you have to do you
34:35 - have to write the name of the
34:39 - port
34:41 - so i have to put this code in front of
34:42 - it because localhost colon8000 right
34:45 - uh we'll be hitting that address when
34:47 - you start the server so i have these
34:50 - five functions
34:52 - get movies get movie so i have to create
34:54 - all those five functions and i have the
34:55 - method set out here
34:56 - now before i do any of that
34:59 - when we go to our postman and we'll hit
35:02 - the server right when we hit the api
35:04 - uh slash movies and we want to get all
35:06 - the movies in the beginning
35:08 - there won't be any movies
35:10 - so that uh we don't want that we want it
35:12 - to have at least a couple of movies
35:14 - right so that we know that the server
35:16 - the api is working perfectly otherwise
35:18 - we'll never come to know
35:19 - so what i'm going to do is i'm going to
35:21 - take movies struct uh this slice of
35:23 - movies right that i just created here
35:24 - that's what that's what i was saying
35:25 - that i'm going to show it to you very
35:27 - soon so you don't have to worry about it
35:29 - so we have the slice called movies and
35:30 - i'm going to append a couple of movies
35:32 - to it
35:33 - and by the way all the operations that
35:35 - we'll be doing in this and all these
35:36 - five functions will be around
35:38 - uh this slice called movies because
35:39 - we'll be storing a lot of these
35:41 - different movies uh and the type
35:43 - obviously is this this is an entire type
35:46 - right or you can call it a class or an
35:48 - object or whatever this is an entire
35:50 - type and then we'll have multiple movies
35:52 - of this type the complete structure
35:54 - right and then you have
35:56 - uh
35:57 - movies append and then you have
36:00 - movies
36:01 - right because we want to append to
36:02 - movies and you want to append a movie to
36:05 - movies
36:06 - right which will be an object just like
36:08 - this it will be an object a struct and
36:10 - we'll have to define all these things
36:11 - like id isbn titled and all those things
36:13 - so i'll say id
36:16 - 1
36:18 - also isbn
36:22 - 4 3 8
36:23 - 2
36:24 - 7.
36:26 - let's say
36:28 - title
36:32 - movie one
36:35 - and for director
36:38 - the syntax is slightly different
36:41 - okay
36:45 - so you'll say
36:47 - director
36:50 - and then you'll say ampersand director
36:53 - because we want the reference object we
36:55 - want the reference of the address of
36:57 - director right which is
36:59 - this out here that's how we'll be able
37:00 - to use the pointer director
37:02 - so if you've used pointers in c or any
37:04 - other language you'll just know that
37:06 - ampersand is to give you the address and
37:09 - percentage or so the aztecs is
37:12 - used to access that address for the
37:15 - pointer
37:17 - and then you have uh the directory which
37:19 - is
37:20 - first
37:21 - name
37:25 - john
37:27 - and last name
37:32 - so i have one movie i will create
37:34 - another movie append
37:36 - movies
37:41 - movie object
37:44 - and it will have
37:46 - an id
37:49 - oh just a second essentially some issue
37:52 - yeah
37:53 - so it will be id
37:56 - 2
37:57 - ispn
38:01 - 4 5 4
38:12 - [Applause]
38:15 - then you have your director again
38:27 - first name
38:29 - so what should be a good first event
38:32 - last name
38:34 - let's keep it steven smith
38:37 - and last name
38:39 - because
38:41 - smith
38:44 - i'll actually keep
38:46 - the s capital
38:49 - even with
38:50 - yeah steve s capital i think
38:53 - so like i said
38:56 - we have our movies so when we now hit
38:59 - the get movies function at least we'll
39:01 - have two movies that will show up right
39:02 - so we'll at least know if the api is
39:04 - working and the server is working fine
39:07 - and now let's start creating our get our
39:10 - movies function
39:14 - what i'll do is i'll create the get all
39:15 - movies function
39:16 - then i'll create the delete function
39:19 - and then i'll create the get movie
39:20 - function create function and update
39:21 - function the update function is
39:23 - uh
39:24 - it will look a little complicated to you
39:26 - it will be the most intimidating so i
39:28 - want to calculate it last so that you at
39:30 - least get used to the syntax before that
39:32 - so let's create get
39:35 - movies
39:36 - okay w
39:37 - http dot
39:39 - response
39:41 - writer
39:43 - comma
39:44 - r
39:45 - star http dot
39:47 - request
39:48 - so we point uh passing a pointer of the
39:51 - request that you will send from your
39:54 - postman to this function and w is the
39:57 - response writer so when we send a
39:58 - response from this function it will be
40:00 - w right
40:02 - so we'll say w dot
40:04 - header
40:06 - dot set
40:09 - basically we want to set the content
40:10 - type as
40:11 - json right so we want to work with json
40:13 - the thing is that um the struct uh our
40:16 - golang stack needs to be able to convert
40:18 - the json coming uh into it into uh you
40:21 - know
40:22 - its own format so that's why we have to
40:24 - set this content type and then we'll say
40:30 - application slash
40:32 - json
40:34 - and then we'll say json.new
40:38 - encoder which we got from here encoding
40:41 - json right json this is the same json
40:43 - json.new encoder
40:45 - and you're going to encode w basically
40:47 - the
40:48 - response that you want to send to it you
40:50 - want to encode it into json and dot and
40:52 - code
40:54 - and you want to pass the complete movies
40:57 - slice that you have so like i said you
40:59 - know whenever we
41:00 - uh when we're whenever we create slices
41:02 - we're just going to append um
41:05 - you know a new movie
41:07 - to the movie slice that already exists
41:08 - whenever we want to update anything
41:10 - we'll be uh traversing inside movies and
41:13 - we'll be updating something inside the
41:15 - movies slice as well so movie slice is
41:17 - quite central and when we all obviously
41:19 - when we return uh the list of all movies
41:22 - we'll be returning or resolving
41:24 - basically the entire movie slices at the
41:25 - same time so this is why the movies uh
41:28 - slices at the center of uh this entire
41:31 - operation that we're doing right now
41:33 - uh so you've seen how now you know how
41:36 - you can get all movies right so you
41:38 - basically uh want to you know encode
41:41 - into json and then you want to just
41:43 - encode movies and send
41:46 - the json of all the movies of uh
41:49 - the slice
41:50 - which has the type struct which is
41:52 - struck movie right so all of these
41:54 - movies you will be able to send
41:56 - to the front end or to postman or
41:58 - wherever
41:59 - now we'll create the delete function
42:01 - because that also looks a little
42:03 - easy right
42:05 - and then we'll get into crea get one and
42:08 - create and delete functions so let's
42:12 - delete them
42:14 - now when you want to delete a movie
42:16 - you'll be passing an id of the movie
42:18 - so we'll say w
42:20 - http dot
42:22 - response
42:24 - writer again
42:25 - and r star http dot
42:29 - request
42:31 - you'll have w dot header
42:34 - dot set again the same thing
42:37 - content
42:38 - type
42:40 - and you want it to be
42:42 - application slash json
42:47 - and now i'll get some params right so
42:49 - the id that i'll pass from my postman
42:51 - which will will go as a param to uh this
42:55 - function create movie
42:56 - and that param uh which will be the id
42:59 - will be present inside
43:01 - mux dot vars and inside the response
43:04 - sorry the request which is r
43:06 - so it will be part of the request right
43:08 - the pointer to the request i'm sending
43:09 - out here
43:11 - so in params now i have the now i'll be
43:13 - able to access the id
43:15 - so
43:16 - what i'll do is i'll
43:18 - range over
43:22 - movies
43:23 - ranging over movies if you used
43:25 - javascript it's very similar to like for
43:27 - each basically
43:29 - so all you're doing is you're just going
43:32 - over all of the movies and you want a
43:34 - put you want to find a particular movie
43:36 - and uh now what you want to do is if
43:38 - item dot id or the id that you pass so
43:41 - you'll say that delete uh the id uh two
43:44 - in the sense the movie with the id2
43:46 - right so the id which you now have uh
43:50 - right access to which
43:52 - will be params
43:55 - id
43:56 - so you know that we got params we got
43:57 - the id that you sent as a request to
44:00 - this function will be inside params and
44:02 - will be inside id so you'll have access
44:04 - to that particular movie uh that
44:07 - particular id i mean and um
44:11 - and inside movies you will go
44:13 - uh
44:13 - through all the movies one by one and
44:15 - each of the movie will be inside items
44:17 - so item that with item.id you'll be able
44:19 - to access each of the ids of the movies
44:21 - of each of the movies right so if
44:24 - uh
44:25 - the item dot id of a movie which is
44:27 - inside our uh
44:29 - movie slice is equal to
44:32 - the id that you just passed as a
44:33 - pronounce to the request
44:35 - then what should we do we should
44:37 - take the movie slice
44:38 - and we should append
44:40 - basically we want to delete it right so
44:42 - we appending it
44:43 - i'll show you how you can delete
44:44 - something by using append
44:46 - so we'll say movies
44:49 - and index
44:53 - so for range for a range function right
44:54 - you have to pass index an item
44:57 - index is like you know i is equal to one
44:59 - well this very much like javascript like
45:02 - so so for index you have i so i uh you
45:04 - know starts from zero and goes to a
45:06 - particular value and item is actually
45:08 - the item so if you used a for in loop or
45:11 - a for off loop you would know that you
45:13 - can access or iterate over the exact
45:15 - items itself
45:16 - and in go like you can do both at the
45:18 - same time
45:19 - and you'll have movies
45:22 - index
45:23 - plus one
45:26 - and
45:28 - dot
45:30 - so what you're doing here essentially
45:34 - is
45:35 - whatever id that's matching right now
45:37 - that you want to delete
45:38 - it's going to basically take that
45:41 - and directly append all of the other uh
45:43 - you know data which is basically index
45:45 - plus one all of the other data is going
45:46 - to just append it in that place in this
45:48 - place
45:49 - so that means this movie now won't exist
45:52 - it's the id that you just passed with
45:53 - the index it won't exist because in in
45:56 - place of that the entire movie's uh
45:58 - you know uh index plus one after that
46:00 - all the movies that were there they came
46:02 - out here right in this place
46:04 - so the movies uh movies that you want to
46:06 - delete now will not exist so that's how
46:08 - you delete a movie right using a pen
46:10 - now we'll get
46:12 - a particular movie
46:14 - by using get movie function
46:17 - so we'll create the get movie function
46:24 - and again we'll have w http dot
46:39 - header
46:41 - dot set
46:45 - and again your
46:47 - content
46:48 - type
46:50 - comma
46:51 - application slash
46:53 - json
46:57 - then
46:59 - just the same way we did with a delete
47:01 - movie
47:02 - uh you will get params the id in the
47:04 - params right
47:06 - in the same place exactly where
47:09 - r where r is the request that the user
47:12 - sends and
47:16 - mux is the package that we're using for
47:17 - creating these routes and vars is
47:20 - inside mugs right which helps us to uh
47:24 - get access to the
47:26 - all the things and uh requests so
47:27 - basically the params
47:29 - and uh then we'll loop through the
47:31 - movies one by one so if i want to get a
47:34 - particular movie from the slice of the
47:36 - movies that i that exist uh with me in
47:38 - golang
47:39 - all i have to do is i have to go through
47:40 - all the movies and then find that one
47:42 - and then
47:43 - encode into json and send it to the
47:45 - front end or to postman right
47:48 - so
47:49 - here
47:50 - we'll again use the for loop just like
47:51 - we did in delete movies
47:53 - uh but there'll be a difference here
47:56 - instead of index we'll write the blank
47:58 - identifier because we don't want to use
48:00 - index because we won't be using index
48:02 - right and if you don't use something in
48:04 - golang you have to use the blank
48:06 - identifier otherwise golang will give
48:08 - you uh those squiggly lines and give you
48:10 - an error that you've defined this
48:11 - variable but you have not used it
48:13 - right that's why we have to use this
48:16 - uh blank identifier now we'll range over
48:18 - the movies and we'll say if
48:22 - item dot id
48:23 - is equal to is equal to parents
48:28 - id
48:29 - right so
48:31 - inside params i have passed an id so
48:34 - it's going to try and compare that with
48:36 - item.id because it's going to range over
48:38 - all the movies one by one and each movie
48:40 - will be inside item and so we'll have
48:42 - the access of id inside the item and
48:45 - that will compare with params or id that
48:47 - just passed
48:49 - and if they're equal
48:50 - then you just have to return it that's
48:52 - all you need to do you don't have to do
48:53 - any other operations so you say
48:55 - new encoder
48:57 - w
48:59 - dot and code
49:01 - item
49:03 - and then you'll just return
49:04 - now uh
49:06 - i'm sure now you can see why i showed
49:08 - you the delete function
49:10 - uh before
49:12 - the
49:13 - get movie function
49:15 - right and that's because
49:17 - in delete function we we used the range
49:20 - uh but we didn't have a blank identifier
49:22 - if if i would have used a blank
49:23 - identifier directly then you would have
49:25 - gotten confused so that's why i want to
49:26 - show you the delete function before now
49:29 - in delete movie once we delete the movie
49:31 - i think it's better to
49:33 - uh also return all the existing movies
49:35 - after you've deleted that movie so what
49:37 - i'll do is i'll uh
49:40 - try and return the remaining movies as
49:41 - well so i'll say new encoder
49:45 - w dot
49:47 - encode
49:49 - movies
49:51 - just like i did in get movies right
49:52 - json.new encoder
49:54 - w dot encode movies
49:56 - right and then get moving we're just
49:58 - sending one particular movie which will
50:00 - be the item as you know that with range
50:02 - you can access each movie using the item
50:05 - right so we're just sending back one
50:06 - movie whereas with delete movies we're
50:09 - sending back all the remaining movies
50:10 - with get movies we are sending back all
50:12 - the movies
50:13 - so get delete get movie
50:16 - i'm sure these are clear now
50:18 - now we'll take a look at create movie so
50:21 - we'll create
50:23 - create
50:24 - movie which obviously is the most
50:26 - important function because you want to
50:28 - create
50:29 - movies it's going to be a post method
50:31 - response writer and
50:34 - r
50:36 - star http dot request
50:40 - the spelling of response is wrong so
50:42 - it's giving me a squiggly line
50:44 - response
50:46 - it's best to keep uh
50:48 - looking at this quickly line so that you
50:49 - can
50:50 - handle all the errors
50:53 - during while writing the code itself so
50:55 - now you can see that i none of the
50:58 - functions have a squig line anymore
50:59 - except update movie because you've not
51:00 - defined it yet so that's why there's a
51:02 - squiggly line there
51:03 - and we have used all of the
51:05 - packages as well so those quick lines
51:07 - have gone except math random and string
51:09 - convert that we'll be using in update
51:11 - movie and update movie is obviously the
51:13 - most uh
51:15 - intimidating function so i have not
51:17 - shown it to you yet
51:19 - and uh that's why we look it at the last
51:23 - and now we have create movie
51:27 - error
51:28 - dot set so this is something that we do
51:30 - every single time right
51:32 - content
51:34 - type
51:35 - comma
51:36 - application slash
51:40 - json
51:43 - then we'll define
51:45 - we'll define a variable called movie of
51:47 - type movie
51:49 - and you'll soon see why
51:51 - and we'll create a blank identifier
51:53 - again
51:55 - we'll
51:57 - decode our dot query so uh while
52:01 - creating a movie we'll send something in
52:02 - the body we'll send an entire movie like
52:04 - this an entire movie like this we'll
52:07 - send it in the body in postman so we
52:09 - want to now decode that body right we
52:11 - want to
52:12 - decode uh that json body and we'll say
52:16 - decode
52:18 - and
52:20 - right so we'll get that value here in
52:22 - this and movie right
52:24 - after decoding it
52:27 - i will say movie dot id
52:29 - so this is where we'll use your string
52:31 - convert and your uh math.random because
52:34 - you want to create a new movie all right
52:36 - so to create a new movie we also need to
52:38 - create a new id which will be completely
52:40 - random id so what we'll do is we'll say
52:43 - random dot
52:45 - which is a function inside random math
52:47 - random library package and we'll say one
52:50 - one two three four five six seven eight
52:51 - you can put as many zeros as you want so
52:53 - i want to value between zero between one
52:56 - and this
52:57 - uh maximum value
52:59 - to create a random value right and then
53:01 - i'll
53:04 - have to now format it into string so
53:06 - i'll say string
53:08 - convert
53:10 - dot
53:11 - ito a which is a function inside string
53:14 - convert package
53:16 - and
53:17 - that's how i'll get a new movie id
53:19 - so i'll say movies is equal to append
53:23 - uh
53:24 - like we saw how uh with delete movies
53:26 - you could append right and now with
53:28 - create movie also you want to append uh
53:30 - just like we did when we created a new
53:32 - movie we want to append the new movie
53:33 - that has just come to movies that's all
53:35 - we want to use it's very simple so we'll
53:36 - say append and we'll see movies comma
53:38 - movie
53:40 - because the new movie that has come out
53:42 - come from the body is now inside uh this
53:45 - movie which uh you know uh we decoded
53:47 - from json into now a format that is
53:49 - readable by golang and it will now look
53:52 - like this it'll look like a struct
53:54 - right so that
53:55 - like we said movies comma and the entire
53:57 - movie so that's what we're doing here
53:58 - essentially we're just saying movies and
53:59 - comma movie that we just received from
54:02 - uh
54:03 - the body that the user just sent from
54:05 - their postman and now which has been
54:06 - converted
54:08 - into a formatted by calling right
54:10 - so uh
54:12 - really simple now since we have appended
54:14 - it here now we want to also return
54:18 - this movie that was just created just to
54:20 - tell the user that hey you know i have
54:23 - created this movie so you don't have to
54:25 - worry
54:26 - encode
54:28 - and movie
54:30 - so the movie is now created
54:32 - now comes the most intimidating
54:36 - function which is update movie function
54:39 - i'll start writing it out
54:41 - update
54:42 - movie
54:43 - and here uh we'll be passing an id right
54:46 - so you know how to get the id right
54:47 - you'll get it in params which will be
54:49 - inside mux dot
54:51 - vas and inside r right the params will
54:54 - be there and then we'll have to again
54:56 - range over all the all the movies
54:59 - and then what we'll be doing for
55:01 - updating movies is we'll first delete
55:04 - that movie uh for the id that you'll
55:06 - send and then we'll just simply add the
55:07 - new
55:08 - uh id that uh
55:11 - uh the new movie that we'll be sending
55:13 - from postman so this is not obviously
55:15 - the right way to do things when you work
55:17 - with databases uh but we're just doing
55:19 - it here since we're not using a database
55:21 - we can get away with that we'll just
55:22 - delete the id of the movie that uh the
55:25 - the movie with the id that you send from
55:27 - postman and then we'll
55:28 - uh
55:29 - uh you know just add the new movie that
55:31 - you'll send the new structure in that
55:33 - same place we added there
55:36 - so
55:37 - uh i hope that makes sense or maybe i'll
55:39 - should i just write some pseudo code and
55:41 - so that it becomes really clear to you
55:42 - so first what we'll do is we'll uh set
55:45 - our uh
55:47 - content type which we always do right
55:50 - and then the next step will be that
55:52 - we'll get access to our params then
55:53 - we'll
55:55 - loop over
55:59 - the movies or we'll range over them to
56:02 - introverted movies
56:04 - then what we'll do is we'll
56:05 - uh delete
56:08 - the movie
56:11 - of
56:12 - of uh
56:14 - the id sorry with the id
56:18 - that we have sent
56:20 - suppose we'll delete it
56:22 - and then
56:23 - we'll simply add
56:25 - a new movie
56:27 - which will be
56:37 - so instead of actually updating
56:39 - uh that particular record in a database
56:41 - we're just deleting it and then just
56:42 - adding a new record from the body that
56:44 - you're sending
56:45 - which is nice little hack and something
56:48 - uh that you shouldn't do when you work
56:49 - with actual databases it's just to show
56:52 - you right now
56:53 - so this is the pseudocode
56:55 - one by one let's start writing out code
56:56 - then right
56:58 - so now
57:00 - we want to set
57:01 - json content type
57:03 - how do we do that
57:04 - we do that by w
57:07 - header
57:08 - dot set
57:13 - content type
57:15 - exterior
57:17 - and we will say comma
57:19 - application
57:22 - sorry application
57:24 - slash one
57:27 - and then we want our parents right so to
57:30 - get parents we'll say params
57:33 - dot
57:34 - where's r we've been doing this till now
57:38 - now we're going to loop over uh the
57:40 - movies
57:41 - and we're going to delete the movie and
57:42 - then we'll add a new movie so we'll do
57:44 - all of those three things now at the
57:45 - same time
57:47 - so we'll say for index now we want to
57:49 - use index in this case so we won't use
57:51 - this blank
57:52 - uh
57:52 - identifier because you want to use index
57:56 - we'll say it's equal to range
57:58 - movies
58:00 - and if
58:02 - item dot id
58:04 - params
58:06 - id
58:09 - what should happen
58:10 - so like i said we'll first
58:12 - so we'll delete over the movies uh using
58:15 - range
58:16 - and then we'll find that uh movie in our
58:20 - movies slice then we'll delete that
58:22 - particular movie with the id that you've
58:24 - sent so if you found it with the id that
58:26 - you've sent now we delete it so we'll
58:28 - say movies is equal to
58:30 - fn so we'll write the exact same line
58:33 - that we've written in delete movies to
58:35 - delete it so we'll say
58:38 - in a inside a pen we'll use the exact
58:39 - same syntax so let's say movies
58:42 - and
58:43 - index
58:45 - comma movies
58:48 - index
58:49 - plus one
58:52 - let's say dot dot
58:53 - right so let me see if that's what we've
58:55 - written
58:56 - earlier
58:58 - yeah there were no mistakes earlier so
59:00 - it's the same thing
59:03 - now we'll say where
59:05 - moving of type movie now because we want
59:07 - to append that movie so that's why we're
59:09 - going to uh try and follow the same code
59:12 - that we've written for create movie
59:14 - and we're essentially going to almost we
59:16 - can copy and paste this whole thing but
59:18 - i'm just going to write it again right
59:20 - so
59:21 - so like i said you know we are adding a
59:22 - new movie the movie that we sent at the
59:24 - body
59:25 - so we'll say equal to json dot
59:28 - new
59:29 - decoder
59:50 - so the id that we have passed so this is
59:52 - the only step that's different from
59:53 - create movie right because
59:55 - we want to have it in the same id we
59:57 - want to use the same id so let's say
59:59 - movie is equal to append
60:02 - movies
60:05 - let's say json.new
60:07 - encoder
60:10 - w
60:10 - dot
60:12 - and code movie because you want to
60:14 - return
60:15 - uh the movie to the user to tell him
60:18 - that hey
60:19 - i have done what you wanted me to do
60:21 - i'll remove these comments
60:25 - since now you already
60:26 - know how this is supposed to work
60:31 - now
60:32 - one thing that we've not done inside
60:33 - update movie is
60:36 - w
60:38 - http dot
60:40 - response
60:53 - all we have to do now i think is right
60:54 - return here and then we're good to go
60:58 - i don't think there are any
61:00 - issues or errors here so i can
61:04 - go ahead and compile this code maybe
61:06 - right so
61:08 - let me take you back to the powershell
61:11 - uh how do i yeah so i'm back in the
61:14 - powershell now
61:16 - so i'm inside i'm still inside that
61:17 - folder go movies crud and as you can see
61:20 - i have that main.go file so all i have
61:22 - to do now is go build
61:24 - i've built it
61:26 - and now we have to say go run
61:28 - main dot
61:32 - it's going to now start the server and
61:34 - it's going to ask me for firewall access
61:37 - maybe you don't see it in your screen
61:39 - because it's a pop-up so i'll say allow
61:41 - access
61:42 - so yeah so now it's running on server
61:44 - 8000
61:46 - uh
61:48 - now let's go head over to our
61:51 - so let me see if i can do that or i'll
61:53 - have to maybe pause the video
61:55 - and then show you post man yeah yeah i
61:58 - can show you postpartum yes i think you
62:00 - could see it now
62:01 - uh i'm using obs so it's difficult to
62:03 - switch between tabs actually in obs
62:05 - screen recorder
62:07 - uh now i have created this folder called
62:09 - rough just for my own use uh you can you
62:12 - can probably create just a new folder
62:14 - and inside this i'm going to create a
62:15 - new folder called
62:17 - go
62:18 - movies
62:20 - inside go movies i'll have
62:24 - a request
62:25 - the request will be get all
62:29 - then i'll have a new request get by id
62:35 - i'll have a new request again
62:37 - it'll be
62:39 - yeah
62:40 - create
62:43 - then update
62:46 - and
62:49 - delete
62:51 - so forget all all you have to do is http
62:53 - slash localhost movies
62:57 - right
62:58 - so you have to write
62:59 - http
63:00 - double slash localhost colon 8000
63:03 - slash movies that's what you have to
63:05 - write
63:06 - and let's hit
63:08 - the server and voila the server is
63:10 - working
63:11 - we have got our two movies that we
63:12 - created
63:14 - in our posts in our vs code right
63:16 - because we didn't want this to be empty
63:18 - so we had created two movies using
63:19 - append and in our funk main so these are
63:22 - those two movies
63:23 - let's get a movie by id so i'm going to
63:25 - take
63:26 - the same
63:28 - route
63:30 - here i'm going to put slash one because
63:32 - i want just
63:34 - the first movies like i'll get
63:36 - uh just the first movie as you can see
63:38 - right now i want to create a movie
63:41 - to create a movie i'll
63:46 - just say
63:47 - uh i won't give the id obviously because
63:49 - i uh golang will create the idea and so
63:51 - on and i'll go here and say the body and
63:53 - i'll say raw and i'll say json
63:56 - and now right
63:58 - i'll just try and call i'll just copy
64:00 - paste this one little
64:03 - from my get all i'll copy and paste one
64:05 - movie here in the body i'll change the
64:08 - id i'll say seven else this i'll change
64:10 - the number something else let's see
64:12 - movie seven
64:18 - and the name here i'll say
64:22 - okay
64:24 - sure
64:27 - so it has added
64:29 - that movie called seven but it's not
64:31 - sending me that
64:33 - uh
64:34 - movie seven
64:36 - it should have sent me the 27 here
64:39 - so there's something wrong we'll have to
64:40 - oh sorry i'm still on get so remember to
64:44 - switch to post method here right so when
64:46 - you say send
64:47 - it gives you the movie that you just
64:49 - created which is this movie 7 right and
64:51 - id there's no point of sending id
64:52 - because id as we know it's going to
64:54 - create on its own so i was wrong when i
64:56 - did that
64:57 - so even if i create one more it's going
64:59 - to create one more id with the same
65:00 - values so now when i get all
65:03 - i'll see four different values right
65:06 - now let's try and edit one of these so
65:09 - let's update
65:10 - uh first let me just copy this whole
65:12 - thing here
65:14 - and switch this to put and then we'll
65:17 - put the id of one of the movies here
65:20 - let's put this id here and update
65:23 - right and then we'll have to say send
65:25 - something in the body which will be the
65:26 - new movie
65:28 - the new movie
65:29 - can be
65:31 - copied from here
65:33 - and we can change some of the values
65:34 - like we'll put it
65:37 - on
65:39 - and i'll just say s because i can't
65:41 - spell shot maker
65:44 - say something else here isbn
65:47 - and
65:48 - so let's see what happens
65:51 - so yeah the movie has been updated
65:53 - the movie seven had first name akil
65:56 - sharma now it's just has arnold so even
65:58 - if we
65:59 - get all we'll be able to see that the
66:00 - movie seven has uh so there's one movie
66:03 - with atletico there's on one we with
66:05 - arnold s because we had created two
66:07 - right in the beginning
66:09 - now let's try to delete this
66:12 - so i'm going to first copy this thing
66:15 - and put in delete and then i'll put the
66:18 - id
66:20 - i'll go back here i'll get the id from
66:22 - here
66:28 - so now it's returning me the
66:31 - movie that has been deleted which was
66:33 - movie seven on test so now when i get
66:35 - all
66:35 - i
66:36 - i won't see that movie hopefully
66:40 - i'm still seeing that movie
66:42 - actually
66:44 - why is not working
66:48 - oh sorry it's on get i'm i again i made
66:50 - the same mistakes i have to uh use the
66:52 - method delete for it
66:54 - so don't make the same mistakes that i'm
66:55 - making all right so now there are only
66:57 - three movies so it's returned me all all
66:59 - the movies uh that are now left right so
67:01 - there are only three movies left even if
67:03 - i say get all
67:05 - there are only three movies left let's
67:06 - delete one more
67:09 - let's read this one also so that only
67:11 - two movies will be left
67:14 - so yeah only two movies are left now
67:16 - right so remember to change the method
67:18 - when you're using postman we'll be
67:19 - building a bookstore management system
67:21 - using golang so we'll be building some
67:23 - cred apis and these are beginner
67:26 - friendly you'll be using mysql database
67:28 - we'll be using the gogorm package to
67:30 - interact with our database
67:32 - and then we look at json marshalling and
67:34 - marshalling and the biggest change here
67:36 - is that we'll have a proper project
67:38 - structure in the sense we won't be
67:40 - writing all of our code in main dot go
67:42 - file we'll have a proper project
67:43 - structure which i'll explain to you
67:44 - shortly
67:45 - and then we'll be using gorilla mugs
67:48 - so with project structure this is what
67:49 - we're going to do we're going to have
67:50 - two main folders in our project one will
67:53 - be the cmd folder the other will be the
67:54 - package folder the cmd folder would only
67:56 - have the main.go file and the package
67:59 - folder uh will have the config folder
68:02 - controllers folder models folder routes
68:03 - folder and utils folder so we'll have
68:05 - six sorry five
68:07 - uh different folders inside the package
68:09 - folder right
68:10 - inside config we'll have app.go file
68:13 - uh which will help us to connect with
68:15 - our database in the controllers we'll
68:17 - have book controllers which will have
68:18 - the functions that will help us to uh
68:20 - you know process the data that we'll get
68:22 - for as response and also the
68:24 - request that we'll get from the user and
68:26 - the response that we need to send so
68:27 - we'll process all of that in the book
68:28 - controller in the book models in the
68:30 - models folder we'll have book.go file
68:32 - which will help us to create those
68:33 - structs and models that will be used by
68:36 - our database
68:37 - in the routes as you know we'll just
68:38 - write our routes and which i'll get into
68:40 - later on in just two minutes i'll show
68:42 - you what the routes are and in the utils
68:44 - we'll just have uh for uh some code for
68:47 - marshalling and marshalling json from
68:48 - our
68:49 - response and our request right and then
68:53 - these are the routes that we have so
68:55 - we'll have
68:56 - uh slash book slash route
68:58 - uh twice one will be for post and one
69:01 - will be forget and these are our
69:02 - controller functions that i've mentioned
69:04 - here so uh if you post on the slash book
69:07 - route uh
69:09 - sorry i think this needs to change this
69:11 - will actually be get
69:12 - and this will be post
69:14 - all right so if you get on our slash
69:17 - book route you will
69:18 - we'll call the get books controller
69:20 - function if you post use the post method
69:22 - on our slash book route we'll create a
69:24 - book right we'll have to send something
69:25 - in the body and we'll have to
69:28 - uh use our uh json master link and much
69:30 - link to uh you know get the data here to
69:33 - the database and then uh we'll if we do
69:36 - get on slash book slash book id which
69:38 - which we'll pass the book id so we'll
69:40 - get the book by id so we'll have to
69:42 - create function to get a book by id then
69:44 - we'll have our put
69:45 - method for updating the book right and
69:48 - on the same route slash box slash book
69:50 - id
69:51 - and then we'll have our delete uh method
69:53 - on slash book slash id route which will
69:55 - give us the delete book uh
69:58 - the function and controller functions so
70:00 - that's our entire uh
70:03 - you know introduction on what we're
70:05 - going to build and how we're going to
70:06 - build it
70:07 - the next steps include where
70:09 - i'll go to my
70:11 - overdue terminal i'll start these uh
70:13 - different folders i'll create this
70:14 - complete project structure and then
70:15 - we'll open our vs code we'll start
70:17 - creating these folders and these files
70:19 - and then we'll start writing all of that
70:21 - right and before that in our ubuntu
70:23 - we'll also have to install the packages
70:25 - that we'll be using so uh
70:27 - in many of the videos that you'll see on
70:28 - youtube you'll also you might see people
70:31 - first including those packages in their
70:33 - uh
70:34 - files while they're coding and then
70:36 - they'll
70:37 - use go mod id or something like that to
70:38 - install the package that they've used
70:40 - but in our case what we'll do is we'll
70:41 - install those packages beforehand and
70:43 - then we'll include them in our code it's
70:45 - just something that i prefer and i also
70:47 - recommend you also do that
70:50 - so that's that's the introduction and
70:53 - let's get started
70:59 - so as you can see i've opened up my
71:00 - terminal uh since i'm on ubuntu this is
71:02 - a terminal if you are on windows it will
71:04 - be a powershell and if you are on mac it
71:06 - will be a terminal again the commands
71:08 - will be the same it doesn't have to uh
71:10 - the commands won't change
71:11 - so i'm going to go ahead and go inside
71:13 - the folder where i write all my go code
71:16 - where all my go programs reside you can
71:17 - do the same and i'm going to go ahead
71:19 - and create a directory for the new
71:21 - project and it will be called go
71:24 - bookstore in my case
71:27 - and i'm going to go ahead and see the
71:29 - inside
71:30 - uh
71:31 - the go book store and now since we are
71:33 - here
71:34 - we'll have to install a couple of
71:35 - packages right so
71:37 - before we install the packages we'll
71:38 - have to create a go.mod file which will
71:40 - uh crea store all the packages it's
71:42 - almost like the package.json file if you
71:44 - are from a node.js background right so
71:46 - it contains all our packages that we'll
71:48 - be using in this project so we'll first
71:50 - do go mod in it and
71:53 - even if you're not storing uh right now
71:55 - inside a github account i just recommend
71:58 - you use github.com and slash your name
72:00 - or any other name and then slash the
72:01 - name of the project which is bookstore
72:03 - this gives us like a relative route or
72:05 - then or an absolute route based on which
72:07 - we can you know include and import
72:10 - different files into our main.go file
72:13 - so it has created our
72:15 - go.mod file okay and now we'll start uh
72:18 - importing the package that we need so
72:20 - the first package that i need
72:23 - is the gorm package which will help me
72:26 - to interact with my database
72:28 - jinzoo slash form so jinzo is the name
72:32 - of the guy i think just created gorm
72:36 - so we have added gorm
72:37 - and now more specifically i need
72:40 - uh the mysql package inside uh
72:44 - guard because gorm uh is a is an orm
72:47 - right it helps for for golang and it
72:49 - helps you to interact with sqlite and
72:51 - postgres but for this example we need
72:53 - mysql so we're going to go ahead and
72:55 - install that and then uh we need to
72:57 - install
72:58 - uh the
73:00 - gorilla mux package since we need to use
73:02 - that for our routes so i'm going to say
73:04 - go
73:05 - get
73:07 - github.com
73:09 - gorilla
73:12 - slash mux
73:15 - so we've installed gorilla mux as well
73:17 - now as per my knowledge uh these are the
73:19 - three packages that we will require but
73:21 - as we go along uh you know i might find
73:23 - that we need more packages so uh it's
73:25 - not a problem we'll install them uh as
73:27 - we go go ahead so from from what i see
73:30 - what be building right now i think these
73:32 - three should be enough probably
73:34 - uh so let's get started with the actual
73:37 - code now that we have our packages in
73:38 - our go mod file
73:40 - uh go mod file also helps us to uh you
73:42 - know go build which will create the
73:44 - build or the exe file which will uh
73:46 - execute on our
73:48 - uh machine exe if you have windows and
73:51 - dot deb if you have uh basically it's a
73:54 - binary file if you have ubuntu and so
73:57 - we're going to go ahead and open up our
73:59 - vs code editor so i'll say code and
74:02 - space dot
74:04 - and that will open up my code editor
74:10 - so as you can see i'm inside my vs code
74:12 - window and now i'll start creating the
74:14 - folders that we had seen in the diagram
74:17 - and you may have noticed that there's a
74:18 - time
74:20 - delay between when i switch between my
74:22 - google chrome and my
74:24 - vs code and my power shell or my sorry
74:26 - my terminal and that's because i'm using
74:28 - obs to record these videos and it's not
74:30 - very user friendly in terms of helping
74:32 - you switch between the tabs very easily
74:34 - so kindly bear with me so let's start
74:36 - creating the folders quickly uh as i've
74:38 - shown you in the
74:40 - in the diagram we have a cmd folder and
74:41 - we have a pkg folder right these are two
74:43 - main folders inside our pk inside our
74:46 - cmd folder we'll have a main folder and
74:48 - inside the main folder we'll have our
74:51 - main dot
74:52 - go file where all the magic will happen
74:54 - right the main controller the main
74:56 - control
74:57 - of our entire project and inside the
74:59 - package uh folder we have config
75:03 - and we have our
75:05 - controllers
75:08 - then we have so i think by mistake what
75:11 - i've done is
75:12 - i've created controllers inside uh
75:16 - config
75:18 - so i have controllers
75:20 - and then i have models
75:26 - and then i have routes and utils right
75:30 - routes
75:33 - and
75:34 - details
75:36 - so as as you've seen just a second back
75:38 - that i had created controllers inside
75:40 - config by mistake and that's a very
75:42 - common mistake by the way and uh that
75:44 - will happen to you if you're not very
75:45 - careful so please make sure that inside
75:47 - your package folder all of these
75:49 - different folders are at the same level
75:50 - inside the package folder right they're
75:52 - not inside one another yeah that's a
75:54 - very common mistake by the way so let's
75:56 - start creating our files inside uh
75:58 - config we have app.go uh inside our
76:01 - controller i i by the way in the diagram
76:03 - i'd already shown you
76:04 - uh the name of the files as well so we
76:07 - have controller.go to control.go and
76:09 - then inside models we have our book dot
76:12 - go file and inside our routes
76:16 - we'll have
76:18 - bookstore
76:20 - routes dot go
76:22 - okay
76:23 - and inside our utils uh the name of the
76:25 - file will just be
76:27 - utils.com
76:28 - now
76:30 - you know there's so many files right
76:31 - here so we need a strategy on where to
76:33 - begin and where to end the program at so
76:36 - how do we start coding how do we begin
76:37 - this whole uh journey of uh writing so
76:40 - much code right it can be confusing it
76:42 - can be daunting it can be overwhelming
76:44 - uh many times so that's why i have a
76:46 - small strategy for you that will help
76:48 - you understand everything really well
76:49 - what i'll do is i'll start with the
76:51 - routes
76:52 - so i'll create the routes first and uh
76:55 - that will help you visualize the
76:56 - routes where the users
76:58 - will hit you know from their front end
77:01 - or from their postman the user will hit
77:03 - on those routes right so we'll start
77:04 - with the routes and then what we'll do
77:06 - is we'll then write our app.go file
77:08 - which will help us to connect with our
77:09 - mysql database then we'll create our
77:10 - utils file so uh app app.go which is the
77:13 - config file and utilize files are very
77:15 - small files so
77:16 - they won't confuse you too much and the
77:19 - routes file is also very small and then
77:20 - we'll create a main.go file the main.go
77:23 - file all it will do is it will just uh
77:25 - you know tell golang that here in
77:27 - bookstore dot routes is where my all my
77:29 - routes reside so all these files will be
77:31 - really small uh then we'll create our
77:33 - models file which will be slightly
77:34 - bigger and then our book controller will
77:36 - have a lot of code so uh we'll tackle it
77:39 - at the end because after the routes the
77:41 - control will go to each of the functions
77:42 - in book controller file
77:44 - so this is the book controller is what
77:46 - we'll tackle at the end and before that
77:48 - you'll get a little bit of
77:50 - an idea of what we're building so it
77:51 - things won't be very confusing for you
77:53 - that's what i'm uh at least trying to
77:55 - attempting to do so uh as you can see i
77:58 - started coding here i've written package
77:59 - routes and then i've said uh started
78:01 - importing the packages that i'll be
78:03 - needing
78:04 - since this is my routes file uh
78:06 - the one package that i most definitely
78:08 - need is gorilla mux which will help me
78:11 - to create the routes in the first place
78:13 - and
78:14 - the other package that i need is not
78:16 - really a package but i need my
78:18 - controller file here
78:20 - so
78:21 - first just see what this is then i'll
78:23 - try to explain to you what's happening
78:24 - so i'll say akil slash go bookstore
78:27 - slash pkg and slash controllers
78:32 - so this will help me import my
78:34 - controllers folder and uh
78:36 - in turn the file inside the controllers
78:38 - folder as well right now if you're from
78:40 - a node.js background you will be very
78:41 - confused when you look at this right so
78:43 - this is uh this is an absolute path
78:45 - whereas with uh node.js you're used to
78:47 - something like this right so you'll say
78:49 - controllers
78:50 - and that's because routes and
78:52 - controllers are both in the same package
78:54 - called pkg so you would say that okay i
78:56 - just want to import controller so i'll
78:58 - just say like this right
79:00 - but that's not how it works with golang
79:02 - golang has absolute parts and once you
79:04 - get used to golang you'll understand
79:06 - that that's kind of the right even if it
79:08 - looks lengthy but it's kind of the right
79:10 - way to do things right because uh this
79:13 - uh the
79:13 - github.com go bookstore uh till here is
79:17 - the path that we created which was like
79:18 - the absolute part that we created for
79:20 - our project when we were initiating the
79:21 - go mod file if you remember
79:23 - and package.controllers is where you
79:25 - know we'll come inside package and then
79:26 - it comes and controls this is where the
79:28 - controller's file lies and that's what
79:30 - we want to use so it may take you a
79:32 - while to get used to this absolute
79:33 - routing but uh but once you get used to
79:36 - it uh i'm telling you you won't go back
79:38 - so i i am a no just developer i was not
79:41 - just developer i can say for a very long
79:43 - time but once i started using golang
79:45 - i can tell you there is no going
79:48 - right because uh golang is so so much
79:50 - better
79:52 - so you have registered bookstore so i
79:54 - want to create a function called
79:55 - register bookstore routes and this
79:57 - function will have basically all my
79:59 - routes and
80:00 - this the routes will help me to get the
80:02 - control to my controller where which is
80:04 - where i'll have meet the meat of the
80:05 - logic
80:06 - so i'll have router
80:08 - marks dot router
80:11 - right and here
80:13 - is where
80:14 - in this function is where i'll create my
80:16 - handlers so router dot
80:21 - handle
80:23 - func right so if somebody comes to my
80:26 - slash book slash
80:27 - right so i'll say controllers dot
80:31 - create
80:33 - book
80:34 - so i've shown you the create book
80:36 - function
80:36 - right in the diagram i have not written
80:39 - the from function till now but i'll be
80:40 - writing this function in the controllers
80:43 - file
80:44 - and this is why i needed my controller's
80:45 - package on top controllers file on top
80:47 - right because if somebody hits the book
80:49 - uh
80:50 - route i want my controllers.createbook
80:53 - function to handle it and the method
80:55 - uh you know is going to be post here
80:58 - because i'm trying to create a new book
81:02 - so i'm sure that's very clear
81:04 - and then we'll create another handle
81:07 - funk
81:09 - and it will again be slash book slash
81:12 - but this time i want it to
81:15 - say
81:17 - get book you'll get the list of all
81:19 - books for me and the method
81:22 - in this case
81:24 - as you know
81:26 - will be get so on top by mistake i had
81:28 - put two h uh for methods i i removed one
81:32 - of those
81:33 - so just make sure you don't make any uh
81:36 - you know typos or any spelling mistakes
81:38 - then we have another handle trunk
81:41 - where we will handle
81:42 - as you have seen in the diagram before
81:44 - the uh you know the scoring part started
81:47 - we'll have slash book and
81:49 - inside this we'll have our book id
81:53 - right
81:53 - and then you have controllers
81:56 - dot
81:58 - get book
82:01 - book by
82:04 - id
82:05 - all right so that's the function i want
82:07 - to get one book by id and dot methods
82:10 - you know the method would be
82:13 - get in this case
82:15 - all right
82:16 - so i think all clear till now now we
82:19 - want to create the two more routes
82:21 - they will be same slash book and slash
82:23 - book id will be there but there will be
82:24 - our put and delete functions right so
82:27 - i'll say router dot handle
82:29 - func
82:32 - sorry
82:32 - [Applause]
82:34 - and here also i think the us capital it
82:36 - should be a small queue
82:39 - and then you have slash book slash
82:44 - book id
82:46 - and then we'll say inside my controllers
82:48 - file i'll have a function called update
82:50 - book
82:53 - okay and then
82:54 - the method for this will be put
82:58 - and similarly for our
83:06 - delete route as well book slash
83:10 - book id
83:12 - and we'll have controllers
83:17 - dot
83:19 - delete
83:20 - book
83:22 - dot methods
83:24 - and we'll have the delete method here
83:26 - right so
83:28 - so far all looks great
83:30 - right everything is uh working out
83:33 - pretty fine for now
83:35 - so we have written our routes
83:37 - uh package so if you read this far then
83:40 - you should be proud of yourself i think
83:42 - so now like i promise you we'll write
83:44 - the
83:45 - app.go file which is the inside the
83:48 - config
83:50 - folder right
83:52 - and so we'll come here and we'll
83:54 - uh give it the name
83:57 - config package config sorry it's not
84:00 - capital
84:01 - package
84:03 - config
84:05 - all right
84:06 - and here i want to import just two of my
84:08 - packages and
84:10 - they will both be related to
84:14 - talking to mysql so the first package
84:17 - will be jinzu
84:20 - slash gorm
84:21 - which is my orm
84:23 - and the second package
84:25 - will be the more specific one which is
84:29 - dot github.com slash
84:31 - jinzo slash gorm
84:34 - slash dialects
84:37 - slash mysql so if you go and look at the
84:40 - documentation for uh
84:41 - the corn package you will notice this
84:44 - blank character here and then space and
84:46 - then the uh
84:48 - link right so just make sure you do that
84:50 - as well so once we have imported these
84:52 - two packages uh the mysql package and
84:54 - the gom package
84:57 - now is the time to create a
85:00 - variable called db so the the whole
85:02 - point of this file will be to return uh
85:05 - a variable called db which will help the
85:08 - other files to interact with the db
85:10 - right so we'll say star born dot
85:13 - db
85:15 - and then we'll create a connect function
85:21 - the connect function helps us to
85:23 - open a connection with our database and
85:26 - the database in this case as you know is
85:29 - uh mysql database right so we'll have d
85:32 - comma e r r uh the if there isn't so
85:35 - i'll write some statement here and then
85:37 - if there's an error the error will come
85:39 - inside err if if there's no error and
85:41 - the database connection has open it will
85:43 - come inside d right so i'll be able to
85:45 - access
85:46 - the connection using d so i'll say
85:48 - gorm.open which will help me open up my
85:51 - connection with the database
85:53 - right and here i'll write something so
85:54 - i'll i'll say
85:56 - the name of the
85:57 - database that i want to use mysql
85:59 - because gorm helps me as i had said talk
86:01 - to sql lite and postgres as well but in
86:04 - my case i want to use my sql
86:06 - and
86:07 - here i'll say the name of the user and
86:10 - my password
86:13 - and
86:15 - my
86:17 - the name of my
86:19 - table
86:20 - simple rest
86:22 - and
86:23 - and then we'll write some little lines
86:25 - here which are required by mysql so uh
86:30 - if there is is uh you know an error
86:33 - right which means that if error not
86:35 - equal to null which means that if there
86:36 - is an error so we'll say panic er r
86:40 - and here we'll say
86:42 - db is equal to d
86:44 - right so
86:46 - whatever was in d here that we received
86:48 - we'll transfer that to now db
86:52 - variable
86:54 - and
86:57 - we'll have a get db function which we'll
86:59 - use in other files
87:01 - and
87:03 - it just returns
87:06 - deep so like i said you know the purpose
87:08 - of this file is to return um a db
87:11 - variable that will help us to talk to
87:14 - the database other files can talk to
87:16 - database easily
87:18 - now
87:19 - uh as you can see i have not written
87:21 - some code ahead of
87:23 - this part right so
87:25 - for mysql to connect we have to write
87:26 - some things after
87:28 - my username my password and the name of
87:30 - the table so that needs to be care set
87:33 - is equal to utf 8 just make sure you
87:36 - copy this exactly and you have parse
87:40 - time is equal to true so this is some
87:41 - requirement by
87:44 - mysql right so you have location
87:48 - right
87:49 - so these few lines you have to write
87:53 - and then your app.go file is complete
87:56 - now
87:58 - the next
87:59 - code that we'll be writing will be our
88:00 - utils dot go file
88:03 - so when whenever when we start writing
88:05 - our book controller we will be using uh
88:09 - you know we'll we'll need data that is
88:11 - unmarshalled data so we'll we'll receive
88:14 - some requests from the user right and it
88:15 - will be in json but we need to unmarshal
88:17 - it to be able to use it in our
88:19 - controller so we just need to write a
88:20 - one one very small code here to be able
88:23 - to unmarshal uh the json that we'll
88:25 - receive from the request so it's going
88:27 - to be very simple
88:28 - we're going to call it utils package
88:30 - utils and we'll
88:31 - import a couple of packages one is
88:33 - called encoding slash json
88:36 - right the other is called i o slash i o
88:39 - util
88:41 - and the third is called netslash http
88:45 - right
88:46 - and here
88:47 - is where i'll create my
88:51 - function
88:52 - and the function is called
88:54 - parse body that will help me
88:57 - uh to pass the body uh especially in the
89:00 - create function in the sense when i'm
89:03 - when i'm trying to create a book
89:05 - uh you know the create book function in
89:07 - my controllers
89:09 - i will receive somebody in the request
89:12 - right so i need to parse that body
89:13 - because that body will be in json so i
89:15 - need to be able to unmarshal it so i'm
89:17 - just creating one small function to do
89:18 - that
89:20 - right so i get
89:22 - the request and a pointer to it and i
89:25 - take that in r so i'll be able to use
89:28 - r to access the request that i've
89:29 - received from the user and i'm sure you
89:31 - know what a request is you know request
89:33 - has that body that we're sending of the
89:36 - uh
89:36 - the book right
89:38 - and then you have x and you have
89:42 - uh interface
89:43 - so i'm sure uh you know you know basics
89:47 - of how interfaces work
89:49 - so we'll say body and error is equal to
89:54 - ioutil dot
89:56 - read
89:58 - all
89:59 - all we're doing is just reading the body
90:02 - right and if there
90:04 - is no error so error double equal to nil
90:08 - then we'll say error is equal to
90:12 - json dot then we'll start unmarshaling
90:14 - it basically
90:16 - on marshall
90:17 - there's a single l
90:19 - right and we'll say
90:22 - byte
90:23 - and body
90:26 - comma
90:27 - after body you say
90:29 - comma x
90:30 - so just one thing guys the x
90:33 - is a small x not a capital x by mistake
90:36 - i written here capital x just make sure
90:39 - of that
90:40 - and
90:42 - then error
90:45 - not equal to
90:47 - nil
90:49 - and then we'll just return
90:51 - right so even
90:52 - uh this
90:54 - looks like it's complete
90:57 - right
90:58 - and so your utils file is complete and
91:02 - your
91:03 - bookstore routes file is complete
91:05 - now we want to start concentrating on
91:08 - our app.go file
91:11 - yeah sorry the adword file is also
91:13 - complete so now we want to start
91:15 - concentrating on our models file
91:17 - right which is slightly uh more advanced
91:21 - so
91:23 - but let's start anyways right so we have
91:26 - package
91:27 - models we'll call
91:28 - it and then we're going to import as you
91:31 - know
91:32 - we'll import our gorm package first
91:34 - github
91:35 - dot com slash
91:37 - jinzu
91:39 - slash form and there's one more thing
91:41 - that we need to
91:43 - install or import and that will be my
91:45 - config file that i just created right
91:48 - because the config file helps me to
91:50 - connect with my database so i need that
91:51 - here so i'll say github.com
92:00 - [Music]
92:07 - right
92:08 - so let me just
92:10 - be sure that
92:12 - yeah this the routes required
92:14 - controllers and
92:16 - the app.go file required gorm
92:19 - and the models required config yeah so
92:23 - i think yeah so we're on the right track
92:25 - so we'll create a database uh the
92:27 - variable called db
92:30 - gordon.db you've seen this already in
92:32 - the config file
92:35 - and we'll create a struct
92:37 - called book
92:39 - structs basically are based on models
92:43 - and
92:45 - a model is something that you know gives
92:47 - us a structure to help us
92:49 - store something in the database
92:52 - so in this case we'll have name
92:55 - because every single book will have a
92:56 - name right and then you put these back
92:59 - two backticks inside that you say gorm
93:05 - then you say
93:06 - json
93:09 - name
93:11 - let me say author
93:14 - and you say string again so name of type
93:17 - string and author of type string and
93:19 - then you say gorm sorry you'll say
93:22 - json
93:24 - and you'll say here
93:26 - author
93:29 - okay
93:30 - and then you'll say publication
93:32 - and string
93:33 - backticks again json again
93:37 - and
93:39 - publication
93:41 - so let me read through it and make sure
93:43 - everything is fine gorm json alright
93:46 - author and publication right name author
93:49 - and publication so we have three things
93:51 - and uh
93:52 - so usually almost like almost always you
93:55 - will find this that we have to
93:57 - whenever we working with databases we
93:58 - have to edit our database so if you've
93:59 - seen the golang to-do list video that
94:01 - i've created so a few days back you must
94:03 - have noticed that init function
94:05 - so here also we need to have an inner
94:07 - function that will help us to initialize
94:09 - the database in the first place so
94:11 - config.connect this is the function that
94:13 - we created together just some time back
94:15 - where which is the connect function
94:17 - which helps us to connect with the
94:18 - database that's inside the config folder
94:20 - you know that already and db is equal to
94:23 - so whatever we get from that um
94:26 - uh you know config file
94:29 - uh by calling the getdb function which
94:31 - we have created together just some time
94:32 - back get db function inside app.go as
94:35 - you can see this is your getdb function
94:36 - which returns just the db which
94:39 - uh you know we had connected to the ddtv
94:41 - right
94:42 - and
94:43 - so
94:45 - that's what you get here inside db so
94:46 - here also you have a db variable where
94:48 - you're just storing the dv that you get
94:49 - back from the config file
94:52 - right
94:53 - so till now i think everything should be
94:55 - highly clear and then we'll just
94:57 - auto migrate it with a book
95:02 - an empty work
95:06 - okay
95:08 - so all good till now
95:10 - uh now
95:11 - you know the control
95:14 - first is in the routes
95:16 - right here in the routes
95:18 - and then the routes basically give the
95:20 - control to the controllers
95:22 - and the controllers will give the
95:24 - control to the
95:26 - book.go which is basically the models
95:29 - right so that's how the flow works in
95:31 - the sense the user interacts with the
95:33 - routes and the routes send control to
95:35 - the controllers where we have all our
95:37 - logic which will write in some time and
95:39 - the controllers then have to
95:41 - perform some operations uh with the
95:43 - database now the the operations of the
95:45 - database have to reside inside our
95:48 - models file which is book.go in this
95:50 - case
95:50 - so that means we'll have to have a
95:52 - different function for the different
95:55 - controllers that we create so we need to
95:57 - have a create a create book uh function
95:59 - here we need to have a get all books get
96:01 - by get booked by id and delete book so
96:04 - we need to have all these different
96:07 - uh functions here
96:09 - right
96:10 - so
96:11 - uh now we have two options one is that i
96:13 - start creating those functions directly
96:15 - or i create the main.go file and then
96:17 - that will give you more clarity and then
96:19 - we create the functions that are
96:20 - required for database right so i think
96:22 - i'll create the main.go file so that you
96:24 - have a little more clarity so let's
96:26 - create the let's go on main.main.go file
96:28 - and then we'll come back to the
96:30 - uh
96:32 - book.go file as well
96:34 - now the so yeah so we have one more
96:36 - option one is that i start creating the
96:37 - controllers and then once we are writing
96:39 - the function the controllers then i'll
96:40 - start creating the model functions but
96:42 - that may confuse you so that's why i
96:44 - want to create the model level functions
96:46 - first which talk to the database right
96:48 - and then we'll have a corresponding
96:50 - function to that in the controls so that
96:52 - i think i feel at least from my opinion
96:54 - that that will make things very easy for
96:56 - you so anyways that let's write out our
96:59 - uh package main file
97:00 - inside our package main file we'll
97:02 - import log because i want to log out if
97:04 - there's any error we'll have nest slash
97:07 - http so as i told you earlier that in
97:09 - our main file all we're going to do is
97:11 - we're going to create the server right
97:13 - which will be which will will also
97:14 - define our local host that's the first
97:16 - thing that we'll do the second thing
97:18 - that we'll do is we'll tell golang where
97:21 - our
97:22 - uh routers reside so basically all that
97:24 - main.go file will do is tell that you
97:26 - know bookstore.routes has our
97:28 - routes so please look there
97:31 - because i don't want to write all my
97:33 - routes in the main.com file right so
97:35 - that means i need my
97:38 - gorilla mux package here
97:41 - slash marks
97:45 - sorry there's slash here
97:48 - and then i need my
97:50 - uh mysql package here
97:53 - github.com
98:00 - dialects
98:02 - slash
98:03 - mysql
98:05 - and then there's something else i need
98:07 - here i need to import the routes right
98:09 - so i know that the routes is inside uh
98:12 - package
98:13 - folder inside that is routes folder so i
98:16 - need to again use my absolute path which
98:18 - will be github
98:20 - dot com slash hill slash go
98:24 - bookstore
98:26 - slash package
98:31 - so let me make sure if in my
98:33 - uh yeah so here also it's correct
98:36 - package config
98:38 - right so yeah so we have google
98:39 - bookstore slash package slash routes so
98:40 - we need the routes here like i said and
98:43 - now you know that inside uh a main dot
98:45 - go file you always have funk main
98:48 - so let's create the function
98:51 - which will basically have
98:56 - mux dot new router so we're creating an
98:58 - r variable with
99:00 - which will initialize the router here
99:03 - and we'll say routes dot
99:05 - register
99:09 - register bookstore routes and we'll pass
99:11 - r to it
99:12 - so if you remember in our routes
99:15 - we have some a function called as
99:17 - register bookstore routes
99:19 - here it is registered bookstore routes
99:21 - and we are passing the router to it r
99:23 - which is the router that we just created
99:24 - inside main.go file we are passing it to
99:26 - it and then we are
99:28 - handling the functions using
99:31 - as you know controllers
99:33 - functions right so the r that we are
99:35 - passing here becomes router right which
99:37 - is of type mux dot router
99:40 - so i hope everything makes sense now if
99:42 - there was a confusion earlier that i'm
99:44 - sure everything is making a lot of sense
99:45 - now
99:46 - so http dot handle
99:51 - comma
99:52 - r right and then you say log dot
99:56 - fatal
99:58 - so like since this is a slightly big
100:00 - project in terms of different files and
100:02 - project structure so i uh you know it's
100:04 - very important to know what's the
100:07 - order in which you want to build the
100:08 - files right so if if i would go in the
100:10 - order that's comfortable to me then you
100:12 - might get confused and so that's why i'm
100:14 - having to pick an order which i will
100:16 - make a lot of sense to you right so
100:18 - you'll have listen
100:19 - and
100:21 - so which helps us create the server in
100:23 - the first place right and these brackets
100:25 - i'll say localhost
100:28 - nine zero one zero
100:30 - and comma r
100:33 - so uh by now i'm sure you know that
100:35 - listen and serve is a function that
100:37 - helps us create a server and we pass to
100:39 - it this which is uh the the post port or
100:42 - the address on which that we want to
100:44 - start the server and it's inside the
100:46 - http package which we have here
100:48 - right so and if there's an error it's
100:50 - going to say log it's going to just log
100:52 - it out right
100:53 - so that's our main.go file now let's
100:56 - come back to our models file which is
100:59 - book.go
101:01 - so
101:02 - uh i'm going to start creating all the
101:05 - functions that i need to talk to my
101:06 - database
101:08 - uh
101:09 - things might look very
101:10 - i won't say very what things might might
101:11 - look a little confusing to you right now
101:13 - but when we stop when we finish writing
101:15 - our book controller file it will make a
101:17 - lot of sense to you so the routes from
101:20 - the routes the data uh you know the
101:22 - control goes to the controllers like i
101:23 - said and the controllers there will be
101:24 - different functions that i've shown you
101:25 - in the diagram that will have
101:27 - uh like you know create book and get
101:30 - booked by id get books right uh all of
101:32 - those functions will be there and then
101:34 - those functions will again to in order
101:36 - to connect with the database not to you
101:37 - know uh make changes in the database
101:39 - they have to go through these models
101:41 - right so we we have to write these model
101:43 - functions and that's what i'm creating
101:44 - right now out here
101:46 - we can do this like i said after we
101:48 - create the controllers as well but
101:50 - it may get confusing for you so that's
101:52 - why i want to you know write these right
101:54 - now
101:55 - so we'll have a create book
101:57 - function
102:04 - and we have something called as a db
102:06 - right which we have created here on top
102:09 - db so db is what helps us to talk to the
102:11 - database so db.new record
102:15 - now new record is a function that exists
102:18 - inside garm that's why we're using god
102:19 - because we don't have to write those
102:21 - queries for uh mysql the query part
102:25 - gordon will write which is an orm which
102:26 - helps us to talk to
102:28 - uh the database we have to write these
102:31 - simple functions like create a new
102:32 - record those kind of things right so
102:34 - we'll say dv dot create
102:37 - ampersand b
102:40 - right where b
102:41 - is something that we'll receive which
102:42 - will be uh of type book right and what
102:45 - we're going to return is also of type
102:47 - book so that's why we have a star book
102:48 - here so we are going to return b
102:51 - of type
102:52 - book right so we receive something of
102:54 - type book which is b so we create that
102:57 - and then we also return that same book
102:59 - that we created so that's why we have
103:01 - star book out here as well
103:03 - now i want to create
103:05 - the get
103:06 - all
103:07 - books function
103:12 - that will help me clear all books so
103:14 - return all the books that i have in my
103:16 - database
103:18 - and here we'll have
103:21 - books now i'm using a slice here because
103:24 - i want to return a slice or a list of
103:26 - the books that i have in my database
103:27 - right
103:30 - so we'll create a variable which is
103:32 - books which is of type slice book
103:36 - where b is capital just make sure b is
103:38 - capital
103:39 - and then all you have to do is db dot
103:41 - find
103:46 - books
103:49 - and then you return
103:51 - books right so you'll be returning the
103:54 - list of books which is slice
103:56 - right
103:57 - now i want to create a function for
104:01 - getting
104:02 - a book by id
104:05 - so that means it needs to take an id
104:06 - first obviously that's very clear which
104:08 - will be of n64
104:10 - there's no space between ninten64 my bad
104:14 - and
104:20 - so these two things have written star
104:22 - book and start start gom.db don't worry
104:24 - about that right now i'll explain to you
104:26 - as we go along
104:27 - so we have where
104:29 - get book of type book
104:32 - okay and db
104:36 - is equal to db dot
104:39 - where
104:40 - w is capital by the way
104:42 - and
104:43 - id
104:45 - equal to
104:48 - id
104:49 - right so we are basically running a
104:51 - where command in mysql where we are
104:53 - saying that where id is equal to id
104:56 - right then find that book
104:58 - find
105:00 - and get
105:03 - so not only are we going to just return
105:06 - uh the book that we found right now from
105:08 - the database but we're also going to
105:10 - return the db uh variable as well so
105:12 - that's why we have the book that we're
105:15 - returning get by id the book that we're
105:17 - returning
105:18 - with that particular id in our database
105:20 - and we're also returning the db uh
105:22 - variable that we had created which was
105:23 - of type coord dot db right
105:26 - and then we have a delete function
105:28 - func
105:29 - delete
105:30 - book
105:32 - id again is int 64
105:36 - and there is book before it
105:41 - book of type book
105:45 - so
105:46 - db.where where it helps us to find the
105:48 - book with the id which which i've just
105:50 - shown you some time back
105:52 - question mark comma
105:55 - id
105:57 - right so uh and get get booked by id i
105:59 - take an id where d was small now in this
106:02 - case i'm taking id reduce capital
106:04 - and then i'll say dot
106:06 - delete
106:08 - and bracket book
106:11 - and then i'm just going to return
106:13 - the book
106:16 - so these are all the
106:18 - uh
106:19 - database functions i have now here there
106:21 - will be a big doubt for you
106:24 - you will be wondering why is there no
106:26 - update uh function
106:28 - why don't we have an update function
106:30 - because uh in this video the way update
106:33 - will happen uh in the controller will be
106:35 - that
106:36 - uh we'll find the the book the id that
106:39 - you'll send as the from the the user
106:41 - that the id that we'll receive so we'll
106:42 - find that book first
106:44 - and then we'll delete that particular
106:46 - book and then the new data that the user
106:48 - has sent us to be uh updated so we'll
106:50 - use that to update uh the book and
106:53 - created basically a new data so we don't
106:55 - have uh an update function as such in
106:58 - our
107:00 - you know models we're just going to use
107:03 - uh get and
107:05 - delete and then post create basically
107:07 - we're going to use a combination of
107:08 - those three to update a file in our
107:11 - database so uh it may sound uh confusing
107:14 - to you right now but uh once we build
107:16 - our controller uh file everything will
107:19 - make a lot of sense
107:21 - right so let's start building our
107:23 - controller so we have package
107:26 - controllers
107:28 - and then we're going to import the
107:29 - packages that we need so i i know that i
107:31 - want to use
107:32 - encoding slash json package
107:37 - and
107:37 - the other packages that i need i'm just
107:39 - making sure that the video is still
107:42 - recording because
107:44 - because you know obs
107:46 - obs has a lot of problems and then i
107:48 - want to use the fmt package because i
107:49 - want to print out things to the console
107:51 - then i have my
107:52 - github.com
107:54 - gorilla mux that i want to use dot com
107:56 - slash
107:57 - gorilla slash max that i want to use
108:00 - right
108:01 - and i want to use my net slash http
108:04 - package
108:06 - i want to use string
108:09 - convert package
108:11 - and i also want to use
108:13 - now i want to import my utils and my
108:15 - models so by both my utils and my models
108:17 - are inside my package folder so you know
108:19 - how to do that right github.com
108:22 - go
108:23 - book store slash
108:26 - pkg slash utils
108:28 - right
108:29 - and
108:30 - com then
108:31 - uphill slash go
108:34 - book store slash pkg slash models so i
108:37 - have both my utils and my models right
108:40 - now we'll create new book which is a
108:43 - variable of
108:44 - type models dot book
108:47 - right so in
108:48 - in our model file which is book dot go
108:51 - we have created a struct of type book
108:54 - right and that's what we have been using
108:56 - all this file
108:57 - so uh
108:59 - of type book is what we are creating
109:01 - here we're creating a new book of type
109:03 - book right so model when i say model i'm
109:05 - referring to uh the models sorry with an
109:09 - s i'm referring to my models
109:11 - file and i'm referring to the struct
109:12 - inside uh the book struck book call
109:15 - inside inside my models file right so
109:18 - new book is of type book which is a
109:20 - struct and which has all these different
109:23 - things it has a name and author and
109:24 - publication right
109:26 - and it's called new book
109:28 - i'm explaining to you
109:30 - uh
109:31 - this slowly because
109:32 - controllers is where people get confused
109:35 - right
109:36 - so first
109:37 - uh
109:38 - yeah so here we have our five functions
109:40 - which is get books and create book and
109:42 - get booked by id and update and delete
109:45 - so the strategy that we'll follow here
109:46 - will be that we'll create the get books
109:49 - function first because that's the most
109:51 - easy in my
109:53 - uh x in my
109:55 - you know from my perspective at least
109:57 - uh from you know at least what i think
109:59 - is the get books function is the easiest
110:01 - so we'll build that first so whenever
110:03 - you're building a function
110:05 - a controller function you know that you
110:07 - have
110:08 - two things you have a response writer
110:11 - and a request
110:13 - for request you put a pointer to the
110:15 - request that you receive from the user
110:17 - and then so we have a request in r and
110:19 - our response in w so whenever uh the
110:22 - response that we'll send to the user
110:23 - will be with w so we'll have to return w
110:25 - basically and then we'll have new books
110:30 - models dot
110:32 - get all
110:34 - books
110:36 - now uh the model functions may not have
110:38 - made any sense to you but here it will
110:39 - make sense because what we're trying to
110:40 - do here is uh we have uh
110:43 - you know new books and in that we'll
110:45 - store models dot get all books so models
110:47 - dot get all books is this function that
110:49 - we just created together
110:51 - model.getallbooks
110:53 - right which will just basically find all
110:55 - the books and send a list of the books
110:57 - back to the user right so now back in
111:00 - our books controller
111:02 - we have a list of books inside new books
111:04 - and then we want to have a response
111:08 - json dot
111:10 - marshall
111:11 - new books
111:12 - so we want to convert it into json right
111:15 - whatever we see from our database so
111:16 - that's why i use the marshall function
111:18 - and then we'll use
111:20 - in the header we want to say
111:28 - content
111:30 - type
111:32 - comma
111:40 - json
111:42 - w dot
111:44 - right
111:46 - header http dot
111:49 - status okay
111:53 - okay so basically it will give us a 200
111:55 - status okay means it gives us a
111:57 - uh 200 and then
112:00 - we say w dot right
112:02 - which is the main thing now which
112:04 - uh you know helps us to send something
112:06 - to the front end or to postman which is
112:09 - the response the response
112:12 - is basically
112:13 - a json version of new books that we
112:15 - found from the
112:16 - database
112:18 - so we're just going to write a response
112:20 - which will basically json right and the
112:22 - list of the books that we found in our
112:24 - database
112:24 - that's all it is
112:27 - and now the second easy function in my
112:30 - opinion
112:31 - is get booked by id so let's create that
112:33 - as well
112:34 - so funk
112:37 - get book
112:38 - by id
112:40 - w
112:42 - http dot response writer
112:46 - and comma r
112:49 - http dot
112:50 - request
112:52 - all right
112:59 - so we'll get access to our r which is
113:01 - our uh request right so inside our
113:04 - request obviously will be the book id
113:06 - right so we want to access our request
113:08 - and we want to access the book id inside
113:10 - our request
113:11 - so book id
113:12 - is equal to
113:14 - vars
113:20 - and book id
113:26 - so we'll have string conversion dot
113:30 - parse
113:31 - paint
113:32 - book id comma zero comma zero
113:35 - so we just want to make sure that
113:40 - the book id that we've received that
113:42 - could be in string right mostly it's a
113:44 - string and we're just passing it to int
113:46 - using the string conversion package that
113:48 - we have imported here
113:51 - and if there is an error
113:55 - error not equal to nil
114:00 - we'll have fmt dot print ln
114:03 - error
114:04 - while parsing that's what we'll return
114:07 - and then we'll have book
114:10 - details
114:11 - comma
114:12 - the blank character
114:14 - and say models dot
114:16 - get book
114:18 - by id
114:22 - and id
114:25 - right
114:26 - so
114:27 - we are getting get
114:29 - uh booked by id models.getbookbiod right
114:32 - which is a function that we created
114:33 - together if we remember let me take you
114:36 - to the models file and show you
114:38 - so inside the model file inside book.gov
114:40 - we have get book by id
114:42 - so we will be returning two different
114:44 - things like you know we'll be doing the
114:45 - book and we'll be returning the db uh
114:47 - variable
114:48 - right and since i don't want to use that
114:51 - use the db variable right now so that's
114:52 - why i'm using the blank uh
114:54 - character here because i don't want to
114:56 - use it in golang if you don't want to
114:58 - use something uh it's better not it's
115:00 - better to use the blank character
115:02 - because if you define something and
115:03 - don't use it golang is going to give you
115:05 - a big error so just make sure you use
115:07 - the blank character here right
115:08 - so
115:09 - uh
115:11 - yeah so i'm going to get booked by id
115:13 - i'm going to get that inside my book
115:15 - details uh variable right
115:18 - and
115:19 - now
115:20 - i want to start thinking about the
115:22 - response that i want to send to my user
115:25 - which will be
115:26 - very simple it will be just
115:29 - json.marshall and book details
115:33 - so to my user i have to
115:35 - send a json response
115:38 - right because i get something from my
115:40 - database i have to convert it into json
115:42 - and then i want to send that to my
115:44 - user right so that's why i have to
115:45 - marshal it into json
115:47 - so now let's start creating my header
115:49 - that i want to set
115:51 - and will be of type
115:54 - content
115:56 - type
116:02 - give type json
116:05 - and w dot
116:07 - write
116:09 - header
116:10 - http dot
116:12 - status
116:13 - okay
116:15 - and then you have your w dot
116:19 - write response
116:24 - okay
116:25 - so i hope this is making sense till now
116:29 - so inside our right header uh we are
116:31 - sending status okay which is 200 that
116:33 - everything worked fine
116:35 - and
116:37 - we are sending the response and inside
116:38 - the response inside rds which is the
116:40 - response we just have a json version of
116:43 - the book details basically the book that
116:45 - we found in the database based on the id
116:47 - right
116:48 - so i am sure all of all of that is
116:50 - making sense if things are not making
116:52 - sense to you then you just you know
116:54 - watch this video slower or you just type
116:57 - it out with me just quote it quote along
116:58 - with me i hope you're coding along but
117:00 - maybe once more you can code long and
117:02 - then uh you know things will start
117:04 - looking becoming clearer to you and if
117:06 - you still don't understand then you can
117:07 - just you know put a comment in the
117:10 - description in the comment box below
117:12 - uh for the video and then i can probably
117:14 - help you out
117:15 - so you have your response writer
117:17 - comma r is your http dot
117:21 - request
117:22 - so this is a quite long video
117:26 - right so if you've reached this far then
117:27 - you should be
117:28 - really proud of yourself
117:31 - model stock
117:32 - book
117:33 - [Applause]
117:36 - all right so utils dot parse body
117:39 - now we'll receive something from the
117:41 - user right as a request and now we want
117:44 - to pass that
117:45 - uh
117:46 - into
117:48 - uh so we're getting that in json we want
117:49 - to pass that into something that our
117:51 - database will understand so that's why
117:53 - we are using parse body which is a
117:55 - function that we created together inside
117:57 - the utils file right
117:59 - so we're going to say r comma
118:02 - create
118:03 - book
118:06 - all right
118:09 - and then we'll say
118:11 - b is equal to
118:15 - create
118:16 - dot
118:18 - create book
118:22 - so
118:23 - create book
118:25 - right
118:26 - is a model of type
118:27 - uh is a model uh inside the models you
118:29 - have books right so create book is of
118:31 - type that basically and then when we say
118:33 - create book dot create book so i'm
118:36 - referring to the create book function
118:37 - here
118:40 - this one that's what i'm referring to
118:41 - out here okay
118:44 - so we'll have create book.trade work and
118:46 - then i'm gonna i now have to start
118:48 - thinking about my response
118:50 - my response will be json.marshall
119:00 - inside that i passed b
119:02 - so b is something that was returned to
119:04 - me by my
119:06 - create book function inside models let's
119:08 - look at what it's returning to us so
119:10 - it's returning to me the same model that
119:12 - is the same object or same
119:15 - it just created inside the database so
119:17 - it created something inside the database
119:19 - and it's just returning to me the same
119:21 - exact thing so that's what i have access
119:24 - to which is b in this case
119:26 - so it's basically the same book that was
119:28 - sent to me by my uh user
119:30 - as a request
119:32 - right so in the response i'm just going
119:34 - to convert that into json so from uh in
119:38 - the beginning we received json and then
119:39 - we passed it into something that the
119:41 - database would understand we sent it to
119:43 - the database the database sent us that
119:45 - same uh you know
119:48 - record and then that record we are
119:49 - converting that into json right now to
119:51 - be able to send that to our
119:54 - user to postman basically so we'll say w
119:57 - dot
119:59 - write header and then we'll say http dot
120:06 - status okay
120:09 - w dot
120:10 - right
120:11 - and we're just going to write our
120:12 - response
120:13 - to the uh
120:15 - postman right
120:17 - so create book was also uh
120:20 - i feel quite straightforward now we'll
120:22 - work on the delete book
120:24 - function func
120:27 - delete
120:28 - book
120:29 - so which will have w
120:32 - http
120:33 - dot so let me just check if the video is
120:35 - still recording i'm not sure
120:37 - yeah it seems like it's still recording
120:39 - anyhow
120:41 - so in our delete book
120:43 - uh function
120:45 - so as you are seeing right now that all
120:46 - of these functions are talking to
120:47 - another function inside our models right
120:50 - so same similarly with delete book we'll
120:51 - be talking to the delete book function
120:53 - inside
120:54 - our model which is book.go
120:57 - so let's have responsewriter and comma r
121:00 - which will have a pointer to
121:02 - the http dot request that you'll get
121:04 - from the user
121:07 - and then we'll use vars again
121:09 - to be able to
121:10 - uh you know access
121:13 - the request that we've received from the
121:14 - user
121:15 - and now we want to access the book id
121:19 - where's
121:20 - both id
121:22 - right
121:24 - and then we have
121:26 - our error
121:29 - so string convert
121:32 - so basically if you're not
121:35 - understood by now this we're doing the
121:36 - exact same step that we were uh doing in
121:39 - the get book by id so because we need uh
121:42 - to access the request then we need to
121:43 - access the book id then we need to
121:45 - convert that into hint which will uh you
121:47 - know do by string convert.parse and
121:49 - package and then we'll also print out
121:51 - the error if there was some error
121:54 - right while passing so we're doing the
121:55 - exact same thing steps there's nothing
121:57 - new here
121:58 - parse hint
122:00 - and book
122:03 - id comma 0 comma 0
122:07 - and if there is an error which means if
122:09 - error is not equal to nil then we'll say
122:12 - fmt dot
122:13 - brain talon
122:15 - and here we'll say error
122:18 - while parsing
122:20 - all right so
122:21 - that's great till now
122:23 - and then we'll have book is equal to
122:26 - model start
122:27 - delete
122:28 - book
122:30 - id so you know this function write
122:33 - delete book which we have created
122:34 - together in the models
122:37 - file delete book it takes an id and it
122:39 - just deletes the book and then returns
122:40 - the book that it just deleted right so
122:42 - the book that has been just returned to
122:44 - us will be inside the book variable
122:47 - all right
122:48 - now we have to start thinking about the
122:49 - response and how we have to send it to
122:51 - our user inside postman so we'll say
122:54 - json.marshall
122:56 - the book that we received from our
122:58 - database function right now that needs
123:00 - to be converted into json
123:02 - so and now we'll start creating our
123:04 - header and we'll setting set or header
123:09 - content
123:12 - type
123:15 - comma
123:16 - pkg
123:18 - location
123:19 - slash json
123:22 - w start right
123:25 - write header
123:26 - http dot status okay
123:30 - w dot
123:32 - right
123:33 - and this is the response the last three
123:34 - steps are the same for almost all
123:36 - functions there's nothing new there
123:39 - now there's only one function left to go
123:42 - which has obviously the people find it
123:44 - the most complicated function
123:48 - which will be the update function
123:50 - and it will
123:51 - have some aspects of
123:53 - all of the different functions that we
123:54 - have seen till now it's also the biggest
123:56 - function so update book is the
123:58 - biggest function and uh
124:00 - let's get started i mean that's why i
124:02 - always covered the update function at
124:04 - the end because it can be confusing to
124:05 - people so that's why we have already
124:07 - seen delete book create book get booked
124:08 - by id and it will just have a
124:10 - combination of all of these functions
124:12 - right so let's create the
124:14 - update book function where u is capital
124:17 - and b is capital
124:19 - w http dot
124:22 - response writer comma r which will be
124:25 - http dot request
124:33 - right so i'll go till here
124:35 - no confusions
124:39 - so we have update book which is of
124:43 - models
124:45 - dot
124:46 - book
124:47 - pretty similar to our create book right
124:50 - the same same code we're writing out
124:52 - here
124:54 - details dot
124:56 - parse body so whatever you have sent in
124:58 - your request
125:00 - as the new body to be updated in the
125:02 - database for that same id that's what
125:05 - we're going to parse and we're going to
125:07 - take from json into a into a
125:09 - uh we're going to unmarshal it into a
125:11 - format that golang understands in the
125:13 - database understands
125:15 - so that's what we have done here
125:17 - now we want to
125:18 - get our id which is what is equal to mux
125:21 - dot
125:23 - vars
125:24 - so like i said so it's a mixture of
125:27 - the post the create book
125:29 - function and the get by id function
125:31 - right
125:32 - so book id
125:35 - let's go to vars
125:36 - and we get access to book id
125:39 - so till here uh we wrote some code from
125:41 - the create book function
125:44 - and here we have started writing some
125:45 - code from the
125:47 - get booked by id function right the same
125:48 - thing the same part we have to repeat
125:50 - here
125:52 - so id
125:53 - comma err i'm not going to copy and
125:55 - paste it because uh i always encourage
125:58 - you to write everything so that you get
126:00 - very very comfortable with the code
126:01 - right
126:04 - parse hint and book id comma 0 0
126:09 - and if
126:13 - there is an error which is error not
126:15 - equal to nil
126:16 - then we're going to print out
126:18 - fmp dot print ln
126:22 - say error right
126:25 - right
126:26 - so
126:27 - completely the same till here right this
126:29 - this whole part is exactly the same
126:33 - and these two lines i just showed you is
126:34 - the same from create book
126:38 - so till now i think there's nothing
126:40 - confusing at all
126:43 - so now
126:44 - let's get the book by
126:47 - id
126:49 - right so we need to find that book if
126:51 - that book even exists in our database
126:53 - only then we'll update it right
126:55 - so let's find that book about details
126:59 - db
127:00 - equal to models dot
127:03 - get book by id
127:06 - and we'll pass
127:08 - capital id there
127:10 - if
127:11 - update
127:12 - book
127:14 - dot
127:15 - name is not equal to
127:18 - empty string it's not empty
127:20 - and book details start named
127:29 - okay so let me type all this out and
127:30 - then explain to you what all this means
127:33 - and if
127:35 - update book
127:38 - dot author
127:40 - is not equal to
127:42 - empty
127:45 - then book
127:47 - details dot
127:49 - author
127:51 - is equal to update book dot
127:54 - author
127:56 - right and then f
127:58 - update
127:59 - book dot
128:01 - publication
128:03 - is not equal to empty string
128:09 - then
128:10 - book details
128:13 - dot publication
128:16 - is equal to update
128:18 - book dot
128:20 - pub location
128:24 - so
128:25 - in our book model as you had seen
128:27 - there are three things right name author
128:29 - of application
128:30 - so when we have to create a new book
128:34 - right
128:35 - then while creating the new book
128:37 - uh
128:38 - you'll have to have these three fields
128:39 - name author and publication
128:41 - so we are assuming here in our
128:43 - controllers that the request that we'll
128:45 - get from the user
128:47 - it will have
128:48 - uh all these three properties name
128:51 - author and publication
128:53 - so we'll take the request that we got
128:55 - from the user inside update book and we
128:57 - have uh you know parsed it
129:00 - right so it should be utils dot yeah so
129:03 - this is a big mistake here that i've
129:04 - made it should be utilized parts body
129:07 - and not just parts make sure you update
129:09 - that as well right so let me check if
129:11 - everywhere else i have not made that
129:13 - anywhere else i've not made that same
129:15 - mistake yeah i have not so it's parts
129:17 - body little dot parts body and
129:19 - uh
129:21 - everything else looks to be all right
129:24 - okay so we are assuming that that update
129:27 - body after parsing has three things name
129:30 - author and publication so we found that
129:33 - uh body as we found that book from
129:36 - inside the
129:39 - database using get booked by id function
129:41 - because we have when whenever we pass
129:43 - whenever we call the update function we
129:45 - call
129:46 - we pass the id and we pass the body the
129:48 - new body
129:49 - for the new details which need to be you
129:51 - know
129:52 - set inside the database now
129:54 - so we'll have name author in publication
129:55 - and for book details
129:58 - right we need to start setting
130:00 - uh those three things so now book
130:02 - details is something that we get from
130:05 - our models get booked id so get booked
130:07 - by id by passing the id we get a book
130:09 - back in
130:10 - return
130:11 - and now we are setting the details for
130:13 - that particular book object right so we
130:16 - said book data's dot name now that will
130:18 - become equal to the
130:19 - new name that we have sent as part of
130:21 - the request that we had also passed
130:23 - right
130:24 - and the author will also now become
130:25 - equal to the author of the update book
130:29 - you know which is basically the request
130:30 - inside that we have passed an author so
130:32 - that will be become the new author and
130:34 - similarly the publication will also
130:35 - become the new publication so all of
130:37 - that detail is now inside the book
130:38 - details
130:40 - record which we now want to save in our
130:42 - database right so we since we have
130:44 - updated it now we want to just
130:46 - save it so updating is taking place
130:47 - inside our go link it's not taking place
130:49 - anywhere else so we just found it by id
130:52 - we now updated all the details and we're
130:53 - just going to go ahead and save it again
130:57 - right so dot save details
130:59 - now we want to send some response
131:03 - to our user as you know it has to be in
131:05 - json
131:08 - so we're going to send the book details
131:10 - which we just updated right so the
131:12 - updated things is going to go to the
131:14 - user
131:15 - so header
131:17 - and dot
131:18 - set
131:20 - content
131:22 - type
131:23 - comma
131:24 - pjq relation
131:27 - slash json
131:29 - then w dot
131:31 - write
131:32 - header
131:34 - http dot status okay
131:37 - and w dot
131:39 - write
131:41 - response
131:42 - so we've even sent the response to the
131:44 - user
131:45 - and so we have written our
131:48 - uh update function delete function
131:50 - create book get booked by id and get
131:52 - books so i think
131:54 - all of the work is complete so now let
131:57 - me just go between all my files and see
131:58 - so main.go file is complete
132:01 - config file is complete controller is
132:02 - complete models are complete routes are
132:05 - complete and utils are complete
132:08 - so all of this makes sense and now it's
132:10 - time to start testing and start
132:12 - fixing if we get any errors or bugs and
132:14 - also to check how to work with our of
132:17 - these apis in our post plan so let's
132:19 - head over to postman
132:21 - so we are back in our terminal because
132:22 - now we want to start trying to run that
132:24 - code that we have written the entire
132:26 - bookstore api
132:28 - so uh
132:29 - as you can see i'm inside my google
132:30 - bookstore folder right
132:32 - and it has cmd and package you can see
132:34 - that i want to go inside my cmd package
132:37 - and it has a main
132:39 - folder so i want to go inside my main
132:41 - folder
132:42 - this has that main.go file now main.go
132:44 - file is the file that we need
132:46 - to be able to run the go build command
132:48 - if you run the go build command anywhere
132:50 - else it won't run because it needs the
132:52 - main.go file
132:54 - now when you run go dot go uh space
132:57 - build
132:58 - i'm expecting to see a lot of errors
133:00 - right
133:01 - and uh
133:02 - you don't have to worry if you see the
133:03 - errors because that's a part and parcel
133:05 - of being a developer
133:07 - so you will have to
133:08 - uh
133:09 - you know get used to solving those
133:11 - errors that you get so as soon as i
133:13 - press go build it's going to give me
133:14 - some errors so right now it's giving me
133:16 - only one error but once i solve this
133:18 - error i know there will be many more
133:19 - errors right so right now it's saying
133:22 - that
133:22 - in book dot go
133:24 - file at line number 11 it cannot refer
133:28 - gordon dot model so i kind of
133:30 - know where the error is now i'm not
133:32 - going to edit all all of this out you're
133:34 - going to solve the errors with me so
133:36 - that you become better as a developer
133:38 - so you can uh you know identify so it's
133:41 - saying uh book.go file
133:44 - and at line number 11 is going to say
133:46 - gone dot model is not there so all i had
133:48 - to do was put a capital m here and now
133:51 - it won't give me the same error again
133:54 - or so i expect
133:55 - so if i say go build again
133:57 - it's giving me like i told you so this
133:59 - error is sorted but it has given me so
134:01 - many more errors right so the first
134:02 - error it's saying is it cannot refer to
134:04 - an exported name mux.vars
134:06 - so let's go head over to line number 47
134:09 - in our go book controller
134:11 - line number 47
134:12 - [Music]
134:14 - yeah so vars
134:17 - uh vars has to be capital v right so
134:19 - that's why it's not able to access
134:23 - so we'll say capital v
134:26 - and
134:27 - that error should at least go away right
134:29 - so this error will go away
134:31 - and then it says label book id defined
134:33 - and not used which is line number 64.
134:37 - so yes it's saying define but not used
134:39 - because i missed the is equal to sign
134:41 - here
134:43 - and i have a feeling that all of the
134:45 - other uh errors
134:47 - because they are much later into this
134:49 - same function so till line eighties here
134:52 - till nine number eighty from 65 to 80
134:54 - i'm seeing all these errors and i have a
134:56 - feeling that they're all because of this
134:58 - is equal to sign that i've missed so now
135:00 - i'm going to go ahead and
135:02 - go build again and let's see if there
135:03 - are any more errors yeah so there are
135:05 - more errors it's saying uh
135:09 - go 71 3 undefined book details so
135:14 - let's find out
135:16 - so these errors are on line 71 74 77 and
135:20 - 79 and 80.
135:22 - let's look into the code what could be
135:24 - the issue here
135:25 - so 71 74
135:28 - and all of these lines
135:30 - and the error basically saying that book
135:31 - details is not defined
135:33 - so i can see here that i've written
135:35 - books by mistake
135:36 - and not book details so once i fix that
135:39 - i remove that extra s
135:41 - hopefully these errors should go away
135:44 - and there could be new more errors
135:46 - no so there are no new errors
135:48 - when i ran go go build uh there were no
135:51 - new errors and it created this main file
135:53 - here for me
135:54 - and now i can start to
135:56 - uh run this code
135:58 - and i can start showing you
136:00 - uh from postman so you can say go
136:03 - run main dot
136:06 - go
136:07 - it it won't say anything that means that
136:10 - uh
136:11 - it's started running on your postman so
136:13 - now let's head over to our postman and
136:15 - i'll show you how
136:16 - to work with each of these apis that we
136:18 - i've opened up my postman window so
136:20 - postman is a tool that helps us to test
136:22 - all the apis if you don't know what
136:23 - postman is you can go ahead and watch
136:25 - any video from youtube
136:26 - and uh
136:28 - so what i'm going to do is i'm going to
136:29 - create a collection here and i'm going
136:31 - to call it bookstore
136:35 - my server is still running so
136:37 - inside my bookstore collection i have to
136:39 - create
136:40 - a request and i'll call it
136:43 - get all
136:45 - all right
136:46 - and then i have a request called
136:49 - create
136:51 - then i have
136:56 - get
136:57 - by id
137:00 - i'll have
137:03 - update
137:06 - and
137:07 - finally i'll have
137:09 - delete
137:10 - [Music]
137:11 - so for
137:13 - get all
137:14 - i need
137:16 - localhost
137:18 - 9010 where this project is running
137:21 - and slash
137:23 - book slash
137:25 - okay
137:26 - and if i get all
137:29 - i get an empty array and if this is what
137:32 - you get then your server is working
137:34 - perfectly fine you're getting the right
137:36 - result because right now we don't have
137:37 - any books so we get an empty array
137:40 - right and so that's why if we had don't
137:42 - have any books we have to create the
137:44 - book in the first place
137:45 - so we will create the book using the
137:48 - post
137:50 - uh or create right so we'll say book
137:53 - slash
137:54 - and then we'll use the post method we'll
137:56 - send somebody now remember in the body
138:01 - we have to send json
138:03 - and json will have
138:05 - three fields one is name
138:08 - the other is author
138:15 - and the third is
138:18 - make sure you get the spellings of
138:19 - author and name in publication right
138:23 - what is publication
138:25 - so name of the book is zero two one
138:29 - and author is peter
138:31 - thiel
138:35 - publication is penguin i think
138:38 - so you send it
138:40 - and you get
138:44 - a response
138:45 - which basically shows us that everything
138:47 - is fine and we get status 200 okay which
138:50 - we have only sent we wrote it right in
138:52 - the code
138:54 - that is that header
138:56 - status okay
138:57 - and let's create another book let's call
139:00 - it
139:02 - startup way
139:06 - by eric
139:09 - rice
139:11 - and i don't know what the name of the
139:12 - publication is so i've created two
139:13 - different
139:15 - books
139:16 - by the way both of these books are
139:17 - amazing if you're planning to start your
139:19 - own company i highly recommend you read
139:21 - these books
139:22 - and so you when we run the get all
139:25 - uh api again
139:27 - it works perfectly fine right we get
139:30 - both the books that are there in our
139:31 - database
139:32 - and now let's get by id
139:34 - so we have one book with id3
139:37 - and we get that zero to one
139:39 - and one book with id4 and we get that as
139:42 - well
139:43 - perfect
139:44 - now we'll update the book by
139:47 - which which has the id4
139:49 - and for the body i'm going to again
139:51 - select raw json and i'm going to
139:54 - simply copy and paste
139:57 - this here
139:59 - and let's change the publication to
140:01 - orion
140:05 - so it's updated the book and now the
140:07 - publication
140:08 - should have been oh sorry i have to read
140:11 - put here
140:12 - the publication will become orion
140:15 - right so
140:16 - don't forget to change the methods here
140:19 - right
140:20 - and for create the method was post and
140:22 - for update it is put
140:24 - right i hope that makes sense
140:26 - now we can go ahead and delete this book
140:29 - and for that i'll need the delete method
140:31 - in my postman
140:32 - when i send that
140:35 - you know the book is gone
140:37 - hopefully
140:40 - so now there's only one book remain
140:43 - which is which has an id3 which is
140:44 - basically zero to one by beta theta
140:46 - so all our five apis working perfectly
140:49 - fine and
140:51 - if you have completed this video and you
140:52 - have been able to uh code out till this
140:54 - far
140:55 - uh congratulations in this video we're
140:57 - building something very interesting
140:58 - we're building a slack bot that
140:59 - calculates age uh using golang
141:02 - without any delays let's get started so
141:05 - uh the prerequisites to this video are
141:07 - that you should have a slack account
141:09 - right obviously that's how you'll build
141:10 - a slack bot right so you should have a
141:11 - slack account you should have a
141:13 - workspace in your slack and you should
141:14 - be the admin of that workspace only then
141:16 - uh you'll be able to build a bot right
141:18 - in slack and then you have to come to
141:19 - this link api.slack.com
141:21 - apps and this is where we'll be able to
141:23 - start our apps so i'll say create new
141:25 - app and ask me two different questions
141:27 - from scratch or from an app manifest so
141:29 - in this case i'll be building and
141:31 - building a bot from scratch i'll call it
141:33 - the
141:34 - agebot
141:35 - right and i'll
141:36 - give it my
141:38 - workspace
141:42 - and now uh
141:45 - we have to find socket mode on the left
141:47 - is the third button on the left right
141:49 - socket mode and we have to enable it
141:51 - and we'll call it socket token so this
141:54 - will generate an app token for us x app
141:57 - so when it says xapp it is your app
141:58 - token and it says xob it's your bot
142:00 - token right x2 xb it'll be your bot
142:02 - token so you can make a note of this you
142:04 - can copy this i won't copy it right now
142:06 - i'll come back for it later on in the
142:08 - video
142:09 - uh so this is your
142:11 - that was your app token and now let's go
142:14 - for our
142:16 - uh event subscriptions which is the
142:18 - third uh button so the fourth button
142:20 - from the from the last right and we have
142:22 - to enable our event subscriptions we
142:24 - have to subscribe to what events and uh
142:27 - let's add some events right so events
142:29 - are basically uh that or something that
142:31 - our bot uh would be subscribed to so
142:33 - these are socket events so i'll say app
142:35 - mentioned whenever somebody mentions my
142:36 - bot and i'll say
142:41 - message history and i'll say message.im
142:46 - right it can read messages
142:49 - and then messages.channel messages.mpim
142:54 - right so these are the
142:56 - uh events that i think my bot uh would
142:59 - need to be subscribed to uh
143:01 - but then there's always you can always
143:03 - come back and tweak them later on if you
143:05 - by mistake if you leave out any and you
143:07 - can always uh you know this is mostly
143:10 - uh you'll get these by trial and error
143:14 - right so i've built more than 50 slack
143:16 - bots so
143:17 - i know and and this is a tip for you as
143:19 - well that it's always better to add more
143:21 - events than less because and and also
143:23 - now uh what we'll do is we'll add uh
143:25 - oauths and permissions so come to this
143:27 - uh option above event subscriptions so
143:30 - oauth and permissions also you have to
143:32 - add some uh permissions like scopes to
143:35 - your uh bot
143:36 - uh these are very similar to your event
143:38 - subscriptions so here also it's always
143:40 - recommended uh with even subscription
143:42 - and with uh oauth information it's
143:44 - recommended that you add more than you
143:46 - need because uh most of the errors that
143:48 - you'll face when building slack bots
143:49 - would be around uh your bot not having
143:52 - enough permissions or authorizations or
143:53 - authentication you know those will be
143:55 - the kind of errors that you'll face so
143:56 - it's better to always
143:57 - uh you know add these so that you don't
143:59 - have to like deal with a lot of errors
144:00 - right later on so i'll just add some
144:03 - regarding chat right and
144:06 - uh
144:07 - let's say channels read
144:09 - right and then say
144:10 - um
144:12 - i am read and i am right
144:16 - these are the items are basically direct
144:17 - messages
144:20 - mp i am read and npm right also i'll add
144:24 - right and i don't think i need any more
144:26 - um
144:29 - permissions for now but if i have any
144:32 - errors then i'll come back here and i'll
144:33 - add those permissions right and now the
144:36 - problem with building slack boxes
144:37 - sometimes they that you don't even get
144:38 - an error and your ad
144:40 - you're
144:41 - uh you know doesn't respond properly or
144:43 - and it doesn't give you the behavior
144:45 - that you're expecting it to give you and
144:48 - and those problems are mostly revolving
144:50 - around scopes right so there are so many
144:52 - errors on stack overflow when you go and
144:53 - you won't find answers to those problems
144:56 - because uh those most of them are around
144:58 - scopes those aren't even errors like
144:59 - people would be saying my slack bot
145:01 - isn't working and those kind of issues
145:02 - right so those are all around scopes i
145:04 - can tell you that from experience
145:06 - anyhow what we'll do now is we'll
145:08 - actually click on install this to
145:10 - workspace
145:12 - and it'll ask me for some permissions
145:13 - i'll say allow
145:15 - so that means now age bot is uh
145:18 - installed to my workspace
145:20 - and it has given me a bot user oauth
145:22 - token right so i need to make a copy of
145:24 - this as well
145:25 - uh so now what we'll do is
145:27 - since we have our
145:29 - credentials in place
145:31 - now it's time to
145:32 - actually start uh
145:34 - building the bot in golang right so i'm
145:36 - in my uh directory where i keep most of
145:39 - my golan code and i'm going to create a
145:40 - directory for this particular project
145:42 - called slack age bot
145:45 - sorry for the wrong spelling of age
145:48 - and i'm going to go inside
145:52 - directory
145:53 - and here what i'm going to say is i'm
145:54 - going to go mod init github dot com
145:58 - slash
145:59 - uphill slash slack
146:02 - i'll say um
146:04 - slack age bot is the name of the project
146:07 - so this is an absolute link that helps
146:09 - me to
146:11 - import other files in my project and in
146:13 - this project particular project we don't
146:14 - have multiple files we are going to only
146:16 - get to have the main.go file but if this
146:18 - was a bigger project then this would
146:20 - have been very very uh helpful and also
146:22 - using github.com
146:24 - uh you know helps helps a lot because
146:27 - later on if you have to push this to
146:28 - github and then use it as a package in
146:30 - your own project later on or somebody
146:31 - else has to use it as a package in their
146:32 - project it's very very useful so this is
146:35 - the best practice uh you can always
146:37 - innit your
146:38 - go programs like this
146:40 - so we'll init and it is taking some time
146:43 - i don't know why
146:44 - okay that's done and there is one uh
146:48 - external package that we need so i have
146:50 - to run the go get command and the
146:52 - package that i need is github.com
146:55 - shoma
146:58 - lee one one slash slacker
147:01 - all right
147:05 - and uh
147:07 - just to be sure i'll say go mod tidy
147:12 - okay
147:14 - and
147:15 - so we have added the the package that
147:16 - you want so if we ls right now we'll see
147:19 - our go modern go some file which is
147:21 - perfect which is exactly what you want
147:22 - so now what we'll do is we'll
147:25 - open up our code editor
147:33 - which is
147:36 - uh vs code in our case
147:38 - in my case uh you can have any other
147:40 - code editor that you want but vs code
147:41 - works best for me so i'm going to use
147:44 - obvious code
147:45 - and now we'll start writing our code as
147:47 - you know uh
147:48 - the main file in a go program is called
147:50 - main.go and the first thing that you
147:52 - have to write is
147:54 - package main then you have to import
147:56 - some packages i know that i'll be
147:57 - needing the context package i know i'll
147:59 - be needing
148:00 - fmt to print out stuff and log is
148:03 - something that i'll be needing i'll be
148:04 - needing
148:05 - os package
148:09 - and
148:11 - the most important thing that i'll be
148:12 - needing
148:13 - is the external package that i
148:15 - installed right so i'll say show molly11
148:20 - now if you're uh
148:24 - yeah so if you're uh
148:27 - coming from a javascript background so
148:28 - what i did there with goget command is
148:31 - simply
148:32 - uh you know uh npm installer it's it's
148:34 - exactly equivalent so it creates uh
148:36 - those entries in your go modern go some
148:38 - file which is almost like your if you're
148:40 - from a flutter background it's almost
148:41 - like a pub spec yaml file or popsicle
148:43 - dot log file and if you're from a uh
148:46 - node.js background it's from it's like a
148:48 - uh you know package.json and
148:50 - package.json.log files you know that's
148:52 - what these are it's very very similar
148:54 - concept right
148:55 - and uh so what we're doing here is we
148:58 - are going to
148:59 - uh
149:00 - write our main function funk main
149:03 - and in funk main i'm going to set my
149:06 - environments right so i'll say
149:09 - uh now you can you know set your
149:11 - environment in an env file but i'm not
149:12 - going to do that i'm just going to uh
149:14 - you know
149:15 - use my os uh package to actually set
149:18 - environments and i'll say
149:20 - slack bot
149:25 - token
149:26 - okay comma and here i need to copy and
149:29 - paste my
149:30 - slack bot token and then i'll say set
149:32 - environment
149:34 - slack app token right so far so good
149:38 - and now what i'll do is i'll just uh go
149:41 - ahead and get my
149:44 - tokens from the
149:46 - slack
149:47 - uh this is my bot token so i'll copy
149:49 - this and i'll paste it here
149:53 - this is my what token
149:56 - all right
149:57 - and
150:00 - here is my
150:04 - yeah i'll and to find my
150:08 - main token i have to come here
150:11 - this is the socket token that we created
150:13 - that is our the xapp one that is our
150:15 - main app token
150:17 - so i'll say
150:18 - i'll copy and paste that here as well
150:21 - so far so good
150:22 - and now we have to create
150:24 - a bot
150:26 - right so we'll say
150:28 - bought
150:29 - an assignment operator or the walrus
150:31 - operator whatever you want to call it
150:32 - slacker dot
150:35 - new client
150:37 - and
150:38 - we'll say os dot
150:41 - get
150:43 - paid environment
150:45 - this is slack
150:47 - port
150:48 - token
150:53 - and we will say
150:54 - comma os dot
150:57 - get
150:58 - environment
151:00 - slack app
151:02 - tool
151:06 - now uh you don't have to have uh you
151:09 - know set environment get environment you
151:10 - can directly pass
151:12 - the
151:13 - tokens here directly right inside the
151:16 - new client uh function but why i'm doing
151:18 - this is because this makes your program
151:20 - more extensible so later on when you
151:21 - have to
151:22 - extend your program and uh you you have
151:24 - those environment files or you have a
151:26 - production environment where you have
151:28 - these tokens
151:30 - or you're using some program that
151:31 - manages all your
151:33 - credentials
151:34 - then this comes in very handy so i'm
151:36 - just getting you in the habit of
151:38 - you know going
151:40 - the right way from the beginning
151:42 - so here we'll start to go routine which
151:44 - will
151:45 - uh
151:46 - it doesn't do any much it just prints uh
151:48 - command events
151:50 - so we'll say
151:51 - command
151:52 - events
151:54 - by command events i mean uh the e like
151:57 - let's say whenever i pass a command to
151:59 - my slack bot uh so whatever it does or
152:01 - whatever the the way it handles the
152:03 - event at the event itself it's going to
152:05 - print it out right so this means that
152:06 - print command events needs to be a
152:08 - function which we have not created right
152:09 - now so let's create that function so
152:10 - we'll say func
152:12 - print
152:13 - command events
152:15 - and we'll say analytics
152:21 - channel
152:25 - and chan creates a channel and we'll say
152:27 - slacker dot
152:29 - command event which basically we're
152:32 - passing here right
152:35 - and here we'll say
152:37 - for
152:39 - event
152:41 - we're going to arrange over the
152:43 - analytics event analysis channel
152:45 - and we're going to print out a couple of
152:47 - things so we're going to print out the
152:48 - timestamp as in when the command was
152:50 - received by slack right and the command
152:53 - itself and the parameters that we have
152:54 - passed to that command and the event
152:57 - right so let's get started so we'll say
152:59 - print
153:01 - ln
153:03 - and here i'll say
153:05 - command
153:07 - events
153:09 - and then i'll say fmt dot
153:11 - println and i'll say
153:13 - event dot timestamp like i said we need
153:16 - the timestamp
153:18 - fmp dot
153:20 - rent ln
153:22 - event dot
153:23 - command
153:24 - and fmt dot print ln
153:28 - by the way all of this is uh totally
153:30 - optional you don't have to do all this
153:32 - like i'm printing out uh in my
153:35 - console whenever any event takes place
153:38 - uh in my
153:39 - program but you don't have to do this
153:42 - given dot
153:43 - event
153:47 - and then
153:48 - just an empty line we'll put them into
153:50 - line
153:51 - print ln
153:54 - okay
153:55 - so far so good
153:57 - now comes the real
154:00 - uh
154:02 - function the most important function
154:04 - but before that we need to write some
154:05 - code to actually stop our bot cdx cancel
154:12 - context start
154:14 - with
154:15 - cancel
154:17 - and context
154:19 - dot
154:21 - background if you're a golang beginner
154:23 - i'm sure you already know what context
154:25 - does and what differ is differ basically
154:28 - make sure that uh the cancel
154:31 - uh
154:32 - is
154:34 - you know uh all like played or or this
154:37 - function is called towards the end like
154:38 - when this function is about to end right
154:39 - so that's what therefore does
154:42 - and error is equal to bot.listen
154:47 - your bottle listen to the context
154:49 - if
154:50 - there is an error which means if error
154:52 - is not equal to null
154:54 - you're going to log out
154:56 - the fatal log.fatal fatal is a function
154:59 - that logs out the error
155:01 - so we have used our log package that we
155:03 - had here we've used our os package to
155:04 - set the environments we've used our fnd
155:06 - package to print out stuff and all we
155:08 - need to do now is use the slacker
155:10 - package
155:12 - right
155:13 - uh
155:14 - now let's create the program
155:17 - that we need to create
155:19 - so that program is
155:23 - bot.com so we have the what we've
155:24 - created the bot here right
155:26 - and here we need to say
155:31 - bot dot
155:32 - command so this is where the magic is
155:34 - happening
155:35 - my year
155:37 - of birth is
155:39 - and you pass a parameter inside here so
155:41 - this with these two
155:43 - uh angular brackets is the parameter and
155:46 - you'll say ampersand slacker dot
155:48 - command definition
155:51 - and this is the description of the
155:54 - command
155:56 - so we'll say
155:57 - you know
155:59 - iob
156:00 - calculator
156:03 - and just give an example
156:07 - sorry example
156:10 - my is
156:13 - here
156:17 - 2020 all right so this is an example
156:20 - and then we give it a handler so handler
156:22 - is where
156:23 - we handle this uh event using a function
156:26 - which takes
156:27 - the bot context slacker dot dot
156:31 - context
156:33 - and we
156:36 - pass it the request so as if whenever we
156:39 - have any functions that uh you know work
156:41 - with http kind of data or socket data
156:43 - you know you have to have request and
156:45 - response right
156:48 - and request will be slacker dot request
156:52 - and response
156:54 - will be slacker which is the package
156:55 - again dot
156:57 - response writer
156:59 - so uh slacker dot request lack of dos is
157:01 - responsible we are using the slacker
157:03 - package here
157:04 - all right
157:06 - so everything makes sense till now
157:09 - i hope everything makes sense to know
157:12 - it's giving us one error i don't know
157:13 - where the error is
157:16 - but anyhow so let's create this error so
157:18 - we'll say here
157:20 - is equal to request dot
157:25 - param
157:26 - here so whatever here has been passed
157:29 - so when the user says my yob is here
157:32 - this uh
157:33 - param
157:34 - uh we'll get into a variable call here
157:36 - right now using this
157:38 - and then we'll have a variable called
157:40 - yob
157:41 - so we'll say string
157:43 - convert dot ato i here we'll convert
157:47 - into
157:48 - here so now this means that i need
157:50 - another package called
157:52 - string convert because this is not
157:55 - native to golang this is a this is
157:57 - a package in the golang library right so
158:00 - we have to get string convert
158:02 - as well
158:04 - uh
158:06 - so uh
158:07 - so far so good so we have our
158:11 - here in yob
158:13 - and then if error not equal to nil
158:17 - we'll say print ln
158:21 - error
158:22 - okay
158:24 - and then we'll say age not equal to
158:27 - sorry a is equal to
158:33 - 2 0 2 1
158:35 - minus
158:36 - y
158:36 - to calculate h all you have to do is
158:38 - year of birth has to be subtracted from
158:40 - the current here that's going on right
158:41 - now it's 2021.
158:43 - if you didn't do this right if you don't
158:45 - use string convert and atoi function
158:48 - you would have this uh in a string
158:50 - format and you won't be able to subtract
158:52 - it here golang won't allow it
158:54 - so to have a number of took uh to get a
158:57 - number from string you have to do this
159:00 - and only then you can perform a
159:01 - subtraction operation right because
159:03 - golang is a statically typed uh language
159:06 - you can't
159:07 - subtract a string and a sprinter and an
159:10 - end so we'll say sprint f which formats
159:13 - our string for us age
159:15 - is
159:17 - percentage d
159:20 - comma h
159:22 - we'll say response dot
159:25 - reply
159:26 - r
159:28 - so in age we store 21 minus yob which is
159:31 - the edge and then we format it out like
159:33 - this with this text and then we reply
159:35 - this
159:36 - now i'm getting two errors one is this
159:41 - so we don't have this package it's
159:42 - saying
159:44 - somali
159:47 - double one we should have had it because
159:49 - we added it
159:50 - um
159:54 - i did add it actually
159:59 - so let me
160:04 - say again go get
160:08 - github.com slash
160:10 - somali
160:12 - one one
160:13 - slash
160:14 - slacker
160:20 - it says it has added this package then i
160:22 - don't know why my
160:24 - uh vs code is acting up and then uh it
160:27 - doesn't seem to have any more errors
160:29 - this is the only error that says uh
160:31 - there is
160:32 - there could be an issue with the
160:33 - spelling though i mean uh now there's no
160:36 - squiggly line so everything seems to be
160:38 - all right
160:40 - um
160:42 - and then it's giving me a red squiggly
160:45 - line out here
160:46 - i don't know why
160:48 - let me check
160:50 - so it says bought command
160:53 - okay yes so my mistake
160:56 - uh this function definition we can't
160:58 - close it out here
160:59 - this needs to be closed somewhere out
161:01 - here
161:12 - and here there needs to be comma
161:17 - now uh
161:18 - [Music]
161:20 - there shouldn't be an error now and yes
161:23 - spelling of command events is wrong
161:26 - so i've collected that as well
161:29 - now it's a question about of
161:32 - i think
161:35 - counting these
161:41 - brackets
161:44 - so i'm just going through it again i
161:46 - have written the description
161:49 - i have the command line
161:51 - the description
161:53 - and there's the example there's the
161:55 - handler func
161:58 - uh request response
162:00 - then i have the year then i have iob
162:03 - uh print line age 21
162:07 - sprint f response reply
162:10 - everything seems to be all right to me
162:13 - but uh it seems there's still one error
162:16 - right so it says in the even dot
162:18 - parameters there's an issue
162:21 - yeah that's because the spelling of
162:22 - parameters is wrong
162:24 - and now as you can see we don't have any
162:26 - issues
162:27 - i'm using a golang plugin that helps me
162:29 - to find these errors
162:31 - without actually running the code so
162:32 - which is very helpful
162:35 - now what we'll do is we'll say go build
162:39 - to see if there are any errors there
162:40 - there seem to be no errors it has
162:42 - created the dot apc file for us
162:44 - and uh what we'll do now is we'll head
162:46 - over to our
162:48 - uh
162:50 - slack channel
162:52 - and here
162:53 - we will uh
162:55 - be expecting our
162:57 - bot once
162:58 - uh we start the bot right we start the
163:00 - program
163:02 - and so let's do that let's actually
163:04 - start our program so
163:06 - go run main.go
163:12 - so it says connected to slack with
163:14 - socket mode that means everything should
163:15 - be fine
163:16 - and so here i'll say agebot
163:20 - and i'll say agebot
163:22 - my yob is
163:26 - 1990.
163:28 - so it says the slackward says that you
163:30 - mentioned each board but they're not in
163:31 - this channel so i'll say invite them and
163:32 - then
163:33 - uh agebot automatically replies age 31
163:36 - awesome right so you'll say age bot
163:41 - my y o b is
163:43 - 1995
163:46 - let's say age 26
163:49 - isn't that awesome
163:50 - so i hope you learned a lot in this
163:52 - video and
163:53 - uh you were able to uh you know
163:55 - understand how to actually apply your
163:57 - golang skills and how to build a slack
163:59 - bot right and how to get the tokens from
164:02 - slack how to add those permissions and
164:04 - how to enable socket mode all of those
164:05 - things are really important in building
164:07 - a slack watch and also this kind of
164:09 - function and the package that we've used
164:10 - slacker right that makes making a slack
164:12 - bot really easy in this video we're
164:14 - building something very interesting
164:15 - we're building a slack bot that can
164:16 - upload files on a slack channel right so
164:19 - the prerequisites are that you need to
164:20 - have a slack account obviously and you
164:22 - need to be the admin of a workspace
164:24 - basically on slack and then you have to
164:25 - come to api.slack.com apps now if you
164:28 - have built slack bots before and you
164:30 - just want to
164:31 - know about how to upload files then you
164:33 - can skip the part where you know i'll
164:35 - show on how to uh get your bot token and
164:37 - your app token
164:38 - and you can skip directly to the part
164:40 - where uh we start working with golank
164:42 - or otherwise you can stick around and
164:44 - see how we need the we can get the
164:46 - bottom right so uh we're on api.com apps
164:50 - we'll create new app from scratch
164:53 - i'll call it filebot
164:56 - and the workspace is worldtech create
165:01 - now
165:02 - i need socket to be enabled
165:05 - so i'll click on socket mode the third
165:06 - option
165:07 - i'll enable it
165:09 - and i'll call this token the socket
165:10 - token
165:13 - generate
165:14 - so let's generate a token for me
165:16 - and i don't need this token for this
165:18 - video i just need the uh what token in
165:21 - this video
165:22 - so what we'll do now is we'll actually
165:25 - go to
165:26 - even subscriptions and we'll just enable
165:28 - it as well
165:29 - even though we won't be using events in
165:31 - this video but we'll just enable it
165:33 - anyways
165:34 - and then we'll go to our oauth and
165:36 - permissions all right so let's
165:39 - give it some scopes
165:41 - so obviously we need to be able to
165:44 - uh read messages so let's
165:48 - i'll just say chat write and channels
165:50 - read
165:52 - and then
165:54 - i need files read and files right
165:58 - and
166:01 - i'll also say i am reading i am right
166:05 - now uh if you've watched my other videos
166:08 - on how to build slack bots the other
166:10 - videos then you know that i always
166:11 - recommend going for more scopes than you
166:13 - need because a lot of the errors on
166:16 - slack stack overflow around slack bots
166:18 - have been caused because because of
166:21 - authorization authentication and
166:23 - permissions issues right and they all
166:24 - revolve around the scopes so it's always
166:26 - uh
166:27 - good to have more scopes than you think
166:29 - you would need because
166:31 - sometimes the slack bots don't even give
166:33 - you errors so that can be very
166:34 - frustrating sometimes right so we'll
166:36 - have remote files read and remote files
166:38 - share and write also i'll take those as
166:40 - well
166:41 - so remote files sorry not remind us
166:43 - right but remote files
166:46 - the remote files right and share
166:51 - okay
166:52 - now most of these we may not even use
166:55 - but we are still like i said you know
166:57 - you're still keeping them
166:59 - so we have all these uh scopes and it
167:03 - might so happen that we uh you know um
167:06 - we might need to add more uh depending
167:08 - on if our bot is able to perform the
167:10 - actions that we're expecting it to uh
167:11 - perform so it's asking me for some
167:13 - permissions i'll allow it
167:18 - okay and now you have your slack
167:20 - watercolor i won't copy it right now but
167:21 - i'll come back for it
167:23 - all right and
167:24 - uh
167:25 - the other thing that you would need is
167:27 - your slack channel
167:28 - id on which you would interact with your
167:31 - file bot
167:32 - and i'll show you that as well all right
167:34 - so now what we'll do is we'll head over
167:36 - to our powershell or uh you could be on
167:38 - your mac terminal or ubuntu terminal
167:40 - doesn't matter the commands will be the
167:41 - same all right so i'm in the
167:44 - in the folder where i keep most of my
167:45 - column code and what i'll do here is
167:47 - i'll create a directory called slack
167:50 - file port all right and i'll cd into
167:53 - slack file bot
167:56 - and i'll go mod in it
168:03 - and slap
168:05 - file what
168:07 - this is my absolute link if you if
168:08 - you're very new to golang this is your
168:10 - absolute link with the help of which
168:11 - you'll be able to uh refer refer other
168:14 - files in your project in this project
168:16 - particular project we are going to have
168:17 - only one file main.go but if this was a
168:19 - much larger project uh then we would
168:21 - have to uh you know write multiple files
168:24 - and github.com because once you upload
168:26 - your project to github you might want to
168:28 - use it as a package in your other
168:29 - projects right so it's always a good
168:31 - practice to have your absolute link like
168:33 - set up like this so this is a good
168:35 - practice we'll go mod in it and
168:39 - it has created a go mod file so if ls
168:40 - you'll be able to see your go mod file
168:42 - right and then uh you need a an external
168:45 - package to be able to work with slack so
168:48 - we
168:49 - are going to import that now if you're
168:50 - from a javascript background you would
168:52 - recognize this as your npm in it and you
168:53 - would recognize this as your npm install
168:55 - so don't we are just installing an
168:56 - external package
168:58 - so we will call it github.com
169:04 - right so this person uh just like us
169:07 - this person had given github.com link so
169:10 - that you know now we are able to access
169:12 - his
169:13 - library very easily
169:15 - into our project so we will get that
169:19 - so it has hopefully added
169:22 - the
169:24 - slack go slash package
169:26 - and what we'll do is
169:28 - just to be sure we'll also run go mod id
169:30 - and says all match no packages no issues
169:33 - everything works perfectly
169:34 - and now what we'll do is we'll open up
169:36 - our code editor so i'm using this code
169:38 - you could be using any other collateral
169:39 - no problem
169:41 - and
169:42 - just
169:43 - another pointer i'm also using a
169:46 - golang
169:49 - plugin in my vs code that helps me write
169:52 - better code so i'll leave the name of
169:55 - that in the description box below
169:57 - but even if you just search for
169:58 - extensions uh golang extension you'll
170:00 - find it it's not it's not something very
170:03 - rare everybody uses it so we are in our
170:07 - vs code and i've opened up a file called
170:09 - main.go which is uh what the main file
170:11 - in golang program is called in case
170:13 - you're new to golan the first thing that
170:15 - you write in a golang program is package
170:17 - main and then you import some
170:20 - libraries and then you have something
170:21 - called respond right so these are the
170:24 - things that are uh the most important in
170:26 - a
170:28 - golang program and uh
170:30 - i know that i'll be needing fmp to print
170:32 - out stuff so the format package has uh
170:34 - things that are required to print out
170:36 - stuff to the terminal
170:37 - then i know i need the os package to set
170:40 - and get my environments and i know that
170:41 - i need the external package that i just
170:44 - installed called slackgo to
170:46 - help me talk to the slack apis right
170:50 - now slack go is a rapid library that
170:53 - somebody has written around the slack
170:55 - apis in golang so that we can call uh
170:58 - the funk the golang the slack
171:01 - apis as functions rather than as actual
171:03 - api so we don't have to make network
171:04 - requests to the slack api because
171:05 - somebody has already
171:07 - written wrapper functions around it and
171:08 - we just have to call those functions
171:10 - uh using this library right so that
171:12 - makes our job extremely easy and then
171:16 - you can uh
171:21 - create a variable called api and it will
171:24 - have slack dot name
171:26 - so using this package now slack and
171:28 - we're creating a new connection we are
171:31 - calling it
171:32 - and here we will get uh
171:34 - you know uh something from our
171:35 - environment and it will basically be our
171:38 - slack
171:40 - token
171:41 - now uh ideally you would have an
171:43 - environment file right or if you're in
171:44 - production environment you would have uh
171:47 - that those the environment set up to
171:49 - have these variables but since we don't
171:51 - have it
171:52 - set up what we'll do is we'll actually
171:54 - set our environment right now using the
171:56 - set env
171:58 - you don't have to do it you can directly
171:59 - pass your bot token here but i do this
172:01 - because this makes the code uh very
172:03 - extensible and you can
172:05 - extend it later on if you in case you
172:07 - want to go to production
172:08 - uh like i said we don't want to go to
172:10 - production right now but if you wanted
172:11 - to you
172:12 - could
172:14 - because we're keeping everything
172:16 - uh modular right so uh here we'll put at
172:18 - what token and also one more thing that
172:21 - i need
172:22 - uh like i said is the
172:25 - channel id on which uh the bot will be
172:29 - able to
172:31 - uh
172:33 - write the upload the file okay
172:37 - so here i'll have something called as
172:39 - channel
172:43 - uh
172:44 - and this will be my channel basically
172:47 - it's also string
172:48 - and os dot
172:50 - get environment
172:52 - inside that we'll have our channel id
172:56 - all right
172:59 - and then i'll have my file
173:01 - file arr
173:05 - string
173:06 - and here i'll put the name of my file
173:08 - you know whatever i wanted to be
173:12 - so
173:13 - now let's go back to our uh
173:16 - google chrome and get our slack bot
173:18 - token and channel ids
173:19 - so
173:20 - slack bot tokens this is my bot token so
173:23 - i'll copy it
173:25 - and i'll paste it here
173:28 - okay
173:29 - and now we'll have our
173:31 - channel id
173:33 - and i need to get to my channel id
173:37 - so this i wanted to post it out also on
173:39 - the general channel so i'll say
173:41 - i'll right click on the general channels
173:42 - i'll say
173:47 - open channel details
173:50 - then towards the end you'll find the
173:51 - channel id which is
173:52 - this
173:54 - okay
173:55 - and then i'll go back here and i'll
173:57 - paste it here
173:59 - makes sense
174:01 - so now we have set our environment for
174:03 - our slack buttock and slack and channel
174:05 - id
174:06 - and
174:07 - we uh
174:09 - sorry
174:11 - yeah and then
174:12 - we have our
174:14 - uh
174:14 - you know
174:16 - uh variables api channel and file which
174:19 - have the api connection with slack and
174:21 - then
174:22 - uh the channel and then the file that
174:24 - will be
174:26 - sending out uploading basically
174:28 - and now we'll create a for loop
174:38 - so uh right now we have only we'll have
174:40 - only one file here but we could have
174:41 - multiple files right so we have to uh go
174:43 - over all of the
174:45 - files that exist in this variable in the
174:46 - slice right
174:49 - so in the slice all the files that are
174:50 - there we'll say i plus plus
174:53 - and
174:55 - say programs
174:58 - slack dot
174:59 - file
175:00 - upload parameters so this is a function
175:03 - that
175:04 - slack
175:05 - gives us
175:07 - and it will have two parameters
175:11 - okay and
175:12 - we'll take that into of our own variable
175:14 - called params so the two parameters are
175:17 - channels
175:18 - where i'll
175:19 - pass the channel
175:21 - in which i want to
175:23 - upload the file and i'll pass the file
175:25 - itself
175:27 - which will in this case be
175:30 - file a r
175:33 - i
175:34 - right because we are looping over file
175:37 - arr which
175:38 - uh in the for the sake of this video
175:40 - will have only one file but you could
175:41 - have multiple file here files here like
175:43 - hundreds of files and then you could
175:44 - loop over them and then you could uh you
175:46 - know send them here all right so put a
175:48 - comma here because it's giving me some
175:50 - formatting errors
175:52 - so
175:53 - i'll
175:54 - say
175:56 - api dot upload file
176:01 - with the params
176:02 - all right so i have my param set here
176:04 - with channel and file and i'm going to
176:06 - call the function called upload file uh
176:08 - in my connection the slack api right and
176:10 - i'm going to
176:11 - uh take that into a variable called file
176:13 - or it's going to return an error to me
176:15 - and so i'll check for the error so if
176:17 - error is not equal to nil that means
176:19 - there is an error i'll print it print
176:21 - out
176:22 - fmt dot
176:24 - printf
176:26 - i'll say percentage s
176:28 - new line
176:30 - comma error
176:33 - all right and we'll save it on
176:37 - and then
176:41 - we'll print out
176:42 - the name and url of the file so let's
176:44 - say
176:45 - name
176:46 - percentage s
176:49 - url
176:50 - percentage s new line
177:01 - so
177:02 - this is a very short simple program
177:06 - and
177:07 - even though i've added
177:09 - slack i don't know why it's giving me
177:11 - shoes
177:12 - [Music]
177:13 - i don't know why there's a
177:15 - squiggly line and
177:17 - shows one error
177:19 - even though i had actually
177:22 - got my
177:23 - import the package
177:26 - so this sounds
177:28 - this looks a bit off to me
177:33 - uh but yeah everything else in the
177:35 - program looks okay to me where uh let me
177:37 - just go through it again so that uh you
177:38 - know we're able to minimize
177:40 - uh the errors
177:43 - so there's the channel
177:45 - id and slack dot new
177:48 - slack
177:50 - oh yeah so here we have to just uh pass
177:52 - the file so you can copy any file that
177:55 - you want and i'm going to just copy and
177:57 - paste a file called
177:58 - zipl
178:00 - uh dot pdf
178:03 - all right so i'm going to pass here
178:05 - is that apple.pdf
178:10 - but you could have any file out there
178:15 - and
178:16 - after that everything else looks
178:19 - pretty all right to me
178:22 - so i don't know why there's a squiggly
178:23 - line here even though i've
178:25 - installed the package
178:27 - what i'll do is i'll again run
178:31 - go get github accounts like
178:33 - slash slack
178:35 - so i'll again add it and now hopefully
178:38 - the error should go i'm not sure
178:41 - yeah now it's gone weird right
178:43 - anyways so let's uh run our code let's
178:47 - build our code at least to see if there
178:48 - are any errors in runtime there are no
178:50 - errors so we will say go run
178:53 - main dot go and at the same time we have
178:55 - to keep our slack channel open right so
178:57 - here in the general channel is where i'm
179:00 - expecting the file to come up right so
179:02 - i'll say
179:03 - go run main dot co and let me head over
179:05 - to my slack channel and see if the file
179:07 - comes here
179:12 - i don't see the file yet
179:20 - says not in channel
179:23 - so this looks like
179:25 - an error to me
179:27 - uh and i'm pretty sure it has something
179:29 - to do with the permission so let me
179:31 - uh go over to my
179:34 - uh
179:35 - slack
179:36 - terminal and slack dashboard and see
179:38 - what these
179:39 - so back in my
179:41 - slack dashboard or my channel
179:44 - i think the issue could be that
179:48 - the file bot is not part of the channel
179:49 - right so what i'll do is i'll try
179:50 - mentioning filebot
179:54 - and so it says want to add this question
179:55 - instead
179:56 - isn't in general yet so i'll say add to
179:58 - channel
179:59 - so file bot was added by kil sharma
180:01 - and
180:03 - now
180:04 - what we'll do is we'll run our code
180:06 - again and see what happens
180:11 - and let's go back see it was able to add
180:13 - the file it was able to upload the file
180:15 - so it works perfectly
180:17 - so you'll have to add your file bot to
180:19 - the channel before it can start
180:21 - pushing files to this channel right
180:24 - and if you see this error it's not very
180:26 - helpful right so it's not in channel i
180:28 - mean what the hell does that mean and
180:30 - i've uh you know had so many errors in
180:32 - the past like i've built more than 50
180:34 - slack bots like are there on production
180:36 - on you can get them on the app store at
180:38 - the slack app store uh marketplace and
180:40 - then uh the thing is
180:42 - it's so frustrating to build a slackbot
180:43 - because most of the time the errors are
180:45 - around like i told you the scopes right
180:47 - and
180:48 - uh because you're trying to do something
180:50 - and you don't have that particular scope
180:51 - selected and then it won't even give you
180:53 - the right error it'll just say
180:54 - uh you don't have uh the authorization
180:57 - or you don't have the permission
180:58 - something like that but it won't tell
180:59 - you uh what permission you don't have
181:02 - so it can get really confusing so just
181:04 - make sure you add more scopes than you
181:06 - need and whatever scopes you think you
181:09 - might need you can obviously add them
181:10 - and don't be shy and just add as many
181:12 - scopes as possible just add all of them
181:14 - probably
181:15 - you know it's not like you're going to
181:16 - share your
181:18 - tokens with anybody else right uh like
181:20 - delete so for example i just made this
181:22 - uh test uh uh app i'll just delete this
181:24 - uh what after uh the video is over
181:28 - and uh
181:29 - now if you're going to into production
181:30 - obviously if you're launching a slack
181:32 - bot to the marketplace then obviously
181:35 - you need to think about what are the
181:36 - exact scopes that you need and you can
181:38 - remove the ones that you don't need to
181:39 - make it more secure but otherwise
181:41 - while testing it while learning go ahead
181:43 - and do whatever you want right in this
181:45 - video we're doing something really
181:46 - interesting we are building an email
181:49 - verifier tool
181:50 - so if you search for email verifier tool
181:52 - on google you get all these different
181:56 - options right hunter dot io snow dot io
181:58 - zero bounce never bounce
182:01 - and all these tools like let's say if
182:02 - you open up snow bio and if you open up
182:05 - email address verifier
182:07 - all these tools are quite expensive and
182:10 - some of some of them even say that well
182:12 - didn't check in real time right uh they
182:14 - try to sound really fancy but what's
182:16 - happening here is really straightforward
182:17 - it's there's nothing fancy happening
182:19 - there only in some tools like let's say
182:22 - um hunter dot io they use a little bit
182:24 - of machine learning here and there to uh
182:26 - you know
182:27 - determine uh basically to make the tool
182:29 - even better and more enhanced but
182:31 - otherwise most of them are just using
182:32 - very simple uh tools to
182:35 - uh create an email verify tool so
182:37 - if you wanted to you could uh simply
182:39 - take this program that we'll build right
182:40 - now and you can just launch your own
182:42 - email wi-fi tool if you want to i mean
182:44 - completely optional all right so we'll
182:46 - use golang nothing fancy we won't have
182:48 - bulk uh verification um
182:50 - ability right now in this program it's
182:52 - very simple you can extend this the
182:53 - functionality of this program to include
182:55 - bulk uh checking as well and in the
182:58 - future uh a few weeks from now i'll
183:02 - actually build a complete uh you know
183:04 - like a complete solution for email
183:06 - verification
183:08 - all right so this is just a precursor
183:09 - this is a very simple program that
183:10 - you're building right now but a few
183:12 - weeks from now i'll build a complete
183:13 - project around it all right where you
183:15 - can
183:16 - uh also do bulk checking and you know
183:18 - there'll be a more there'll be a few
183:19 - more checks right now we're doing a
183:20 - couple of checks but there will be few
183:22 - more checks
183:23 - all right so let me show you how the
183:25 - program is going to work
183:27 - i am now in my terminal and
183:30 - what i'll do is i'll start the program
183:32 - and mind you this program is super
183:34 - simple so it won't take us more than 20
183:36 - 25 minutes to actually build this whole
183:37 - thing right it's very very
183:38 - straightforward
183:40 - so if you go down main.go
183:42 - it shows you these options it says that
183:44 - when you uh enter a domain name right
183:47 - now it will give you the domain names
183:48 - name and will check for mx records spf
183:50 - records if it has any fcf records if it
183:52 - does then we'll give you the spf records
183:54 - if it has any demarc records and we'll
183:56 - give you the democratic calls all right
183:58 - and by checking these then we'll know uh
184:00 - if the domain is at least right from
184:03 - which that email id is come out from to
184:05 - which you have to send the emails to
184:06 - right you'll just check the domain if
184:08 - the it even has any imax records
184:10 - so that's like the first stage the first
184:12 - check of any email looking up or any
184:14 - email verification that checking if that
184:16 - domain name even has an mx recorder an
184:18 - spf record as a democrat record right so
184:20 - that you can know at least you know
184:21 - there are mx servers set up there a mail
184:24 - server set up there all right so uh here
184:27 - let's say you write mailchimp
184:31 - dot com
184:32 - so this is like uh irony because these
184:35 - guys uh help people send emails and we
184:37 - are building a tool using their website
184:39 - to check if
184:41 - they have any
184:42 - valid uh you know email records
184:45 - so let's enter that it'll take a while
184:48 - because mailchimp has done a lot of
184:49 - clever things to uh you know
184:51 - not respond straight in a
184:53 - straightforward manner so i'll say that
184:55 - uh the request has timed out right it
184:57 - says uh this operation returned because
184:59 - the timeout period expired but it'll
185:01 - give you still give you the right
185:02 - records it'll give you mailchimp.com
185:04 - which is the domain
185:05 - does it have a mx record that says yes
185:07 - true it does does it have spf records
185:10 - false so that means spf records uh
185:13 - there's you can see this there's a blank
185:15 - here that means uh since there's no spf
185:17 - records it won't return the spf records
185:19 - obviously does it have dmarc it'll say
185:21 - true and demarcus records this these are
185:24 - the mark records all right
185:26 - so now you know that mailchimp.com is a
185:28 - valid email people it's like emails have
185:30 - been set up on this record and now you
185:32 - can start looking for the names of the
185:33 - people and then actually finding email
185:35 - addresses of those people if you wanted
185:36 - to right like i said a few weeks down
185:38 - the line we'll build the entire product
185:40 - right now we're just building like uh
185:42 - you know just telling people if the the
185:43 - email is real or not just like something
185:46 - like uh you know
185:48 - this this tool out here called email
185:49 - hippo you
185:51 - write something like you know akil at
185:53 - the rate mailchimp.com
185:56 - and the first thing is going to check is
185:58 - what we just checked right now does it
185:59 - have mx records uh spf records or dmacc
186:02 - records if it doesn't we'll just say
186:04 - that this email address is not valid
186:06 - obviously because the domain itself is
186:07 - not valid right the one itself does not
186:09 - have any mx record setup
186:12 - but here in this case it'll say true
186:14 - because in our case also it returned
186:16 - true
186:20 - so i'm not sure if this is yeah so it's
186:21 - saying the result is bad because yes the
186:23 - email address does not exist but
186:25 - uh probably it's saying that this exists
186:27 - but this email
186:28 - on this this person on this domain does
186:31 - not exist something like that right
186:33 - so anyways so you get the picture of
186:35 - what we're building and now let's start
186:37 - building it like i said there's no
186:38 - external library used here we're just
186:39 - using like the basic golang packages
186:42 - that you get so if you know even basic
186:43 - golang if you just completed the golang
186:45 - tour if even if you don't know that
186:46 - actually
186:47 - uh you can you can still complete this
186:49 - project so this is like a
186:50 - you know simple uh
186:52 - like a beginner level project so feel
186:55 - free to follow along with me all right
186:56 - now since this is a beginner level
186:58 - project i won't explain a lot of things
186:59 - there's not much to explain anyways i
187:01 - won't explain a lot of things uh feel
187:02 - free to code along with me if you don't
187:04 - understand anything look it up on the
187:06 - internet or put it in the comments below
187:08 - i'm always there to help you out right
187:10 - but it'll be really simple right so it's
187:12 - i mean there's nothing complicated here
187:13 - we're not using go routines we're not
187:15 - using channels we're not using
187:17 - even structs we're not using uh
187:19 - interfaces nothing like that it's just
187:21 - like plain simple colang all right so
187:23 - let's get started
187:27 - what i now want you to do is open up
187:29 - your new terminal
187:30 - and
187:31 - traverse to the
187:33 - path where you usually keep your golang
187:36 - code and create a new directory
187:40 - let's say like email checker tool
187:44 - cd into it
187:47 - and open up using your favorite code
187:50 - editor in my case it's vs code
187:54 - and here
187:56 - there's not much in this project right
187:58 - it's just main.go
188:01 - so
188:04 - you'll start with package main
188:07 - you'll import some things
188:09 - obviously we'll talk about them in a
188:11 - while
188:12 - and then there's yours there's your uh
188:14 - funk main right the most important
188:17 - function in any golang program
188:20 - funk main basically calls another
188:22 - program called
188:24 - funk
188:25 - check domain
188:27 - all right
188:29 - and this function just takes in
188:31 - a domain
188:34 - so essentially all you're entering uh
188:36 - that you just saw in the demo or you're
188:37 - entering is the domain name right so
188:39 - that domain name basically gets passed
188:42 - passed from our uh terminal using funk
188:45 - main something we'll write in our funk
188:46 - main we'll pass it and we'll just push
188:48 - it or send it to our check domain
188:50 - function which will do all the magic all
188:52 - right the packages that i need here
188:56 - i need buffalo
188:58 - the buffer package to to be able to
189:00 - parse whatever i put in the
189:04 - terminal
189:05 - i need fmt to print out stuff
189:07 - log as well
189:09 - need a net package to make those
189:11 - requests os and strings
189:17 - once we use these packages it will make
189:18 - more sense to you why we're using it
189:21 - so firstly you'll create a variable
189:23 - called scanner
189:25 - and you'll use the buffer package
189:29 - and there's a function called new
189:31 - scanner
189:35 - that you'll use okay
189:37 - and here you'll say
189:40 - printf
189:43 - and the things that we're printing out
189:44 - when the program started will be
189:46 - basically domain
189:48 - has
189:50 - mx
189:51 - has spf
189:53 - and if it has spf then it'll show you
189:55 - the spf records
189:59 - then we'll check it has the mark
190:03 - and then we'll check for the mark
190:05 - record
190:08 - okay
190:10 - so if you remember when we started the
190:11 - program it just showed us these things
190:13 - so that we come to know in the order
190:15 - which will in which the information will
190:17 - be shown to us okay
190:18 - so it's exactly the same thing
190:21 - and now
190:22 - for you to scan
190:24 - the information
190:26 - you'll use scanner.scan function
190:31 - and you'll
190:32 - so let's say there are multiple
190:34 - items to be scanned you'll
190:36 - now i i know i said that there's no no
190:38 - bulk uploading uh as in bulk checking
190:40 - but you can check like a few uh you know
190:42 - emails but when i say bulk uh checking i
190:45 - mean like like uploading big csvs of
190:48 - thousands of records and then checking
190:49 - them in one go right that's what we
190:51 - don't have but like multiple checking is
190:53 - there all right i hope that makes sense
190:55 - so you have scanner dot
190:58 - text
191:03 - so uh whatever was
191:05 - typed by you in the
191:07 - power shell or in the
191:09 - terminal
191:10 - is now basically sent to the check
191:12 - domain function one by one so multiple
191:14 - domains if
191:16 - you know if you want to
191:18 - or it's just a single domain mostly
191:21 - i have tested only on single domain so
191:23 - please um if you know there's a there
191:26 - are problems working with multiple
191:27 - domains then uh you know it's only
191:29 - because i've not tested it i've just
191:30 - associated with a single single domain
191:32 - so start the program and just put a
191:34 - single domain like mailchimp.com like i
191:35 - showed you in the demo so it just works
191:37 - perfectly fine for that i've tested only
191:39 - for that
191:40 - and then we have like i said this is not
191:42 - a production level software right
191:46 - i said like you can put it on your
191:48 - website as a small simple free email
191:50 - checker tool but don't like charge
191:52 - people for it because you don't have uh
191:54 - the complete architecture required for
191:56 - it to be a complete production software
191:57 - right
191:59 - i hope that's clear
192:01 - because i i get strange uh
192:04 - comments sometimes so that's why i just
192:06 - you know clarify all these things
192:09 - so to um log out the error now if
192:11 - there's an error obviously uh then we're
192:14 - just logging out the error so the error
192:15 - is
192:17 - could not read
192:19 - from input
192:24 - comma error
192:27 - so if you notice all that we have done
192:29 - in the funk main is just pick up or scan
192:33 - the user's input from the terminal all
192:35 - right the domain name that you've put
192:37 - and if it's not able to scan it properly
192:39 - whatever domain name that you put is
192:41 - going to say could not read from input
192:43 - right it's going to print out an error
192:46 - and what we are sending to this check
192:48 - domain function is the text and that
192:50 - whatever you've
192:52 - posted in the terminal
192:54 - and now the check domain is the is the
192:56 - part where
192:57 - which is basically the meat of this
192:58 - entire program because this function
193:00 - will have all the logic
193:02 - required to actually check those records
193:05 - okay
193:07 - so firstly we'll define some variables
193:09 - the first variable will be has mx
193:11 - has spf
193:14 - has d mark
193:16 - all of these are boolean
193:19 - then we'll have the spf record
193:24 - i mean if it has an spf record then
193:26 - we'll show the spf record right like in
193:27 - our case when we uh did a demo with
193:29 - mailchimp
193:30 - there was uh this was false so that's
193:32 - why we didn't have any spf record it was
193:34 - blank
193:36 - and if there's an uh dmark tool like we
193:37 - had did for mailchimp we had democtool
193:40 - we'll have remark record here and
193:44 - it'll be a string
193:48 - all right
193:51 - now we'll all be doing here basically is
193:53 - using the net package
193:55 - to firstly look up the mx
193:59 - so the net package already gives you
194:01 - um the ability to look up the mx of the
194:04 - domain that you just sent here domain is
194:06 - that string that you're passing to this
194:07 - function all right
194:09 - and
194:11 - whatever comes back from this function
194:16 - we captured in a variable called mx
194:18 - records
194:20 - and this function if there's anything
194:22 - that goes wrong will also return an
194:24 - error
194:32 - and now you're getting these quickly
194:34 - lines because you've defined all these
194:35 - variables but you've not used it
194:38 - right
194:40 - so what we'll do now is we'll say
194:43 - if error
194:45 - not equal to nil
194:48 - this error basically will handle on this
194:49 - line
194:52 - log dot
194:53 - printf
194:56 - error
195:01 - percentage v comma
195:02 - error
195:09 - and we will check for
195:12 - length
195:14 - and extra chords
195:16 - greater than zero
195:20 - is equal to
195:24 - so
195:25 - you looked up the mx for the domain
195:28 - using the net package and there's a
195:30 - function called lookup mx that you get
195:32 - in that net package
195:34 - and you got the mx records
195:36 - or
195:37 - optionally you must have got the error
195:39 - so if you got the error which means
195:40 - error not equal to net
195:42 - you'll just print out the error
195:44 - and if you got back the mx records
195:46 - then you'll check if the length of the
195:48 - mx records is greater than zero
195:50 - if obviously if it's greater than zero
195:51 - that means that mx
195:53 - that this domain has mx records so we'll
195:55 - set mx is equal to true has mx is equal
195:57 - to true okay so this has been used
196:01 - now comes the txt records
196:05 - which are your spf records okay so we'll
196:07 - use
196:08 - net dot lookup
196:10 - txt package
196:12 - so here um i just want i wanted to
196:15 - observe how easy these kind of things
196:17 - are with a language like golang
196:20 - if you want to do the same with uh
196:22 - node.js for example you will have to use
196:24 - an external npm right something like
196:26 - that
196:27 - um
196:28 - i mean i'm a node.js user i've been
196:30 - using it since many many years now i
196:32 - have uh built multiple products with
196:33 - node.js
196:35 - so um i should have nothing against
196:37 - node.js but actually i do so i do have a
196:39 - lot of cloud against node.js because to
196:41 - do something as simple as this you have
196:43 - to uh you know do a lot you have to do a
196:46 - lot of bending uh in case you know a
196:48 - better way to do this with node.js do
196:51 - reply in the comments and to share it
196:53 - with me i don't know but with golang
196:55 - it's super simple right you don't have
196:56 - to install any external package there's
196:59 - all these are you know the standard
197:01 - golang packages that you're using right
197:02 - now
197:04 - and that's insane right a language that
197:06 - has so much support out of the box
197:08 - it's just killer
197:10 - this is that's why you know it's the
197:11 - language i use the most right now
197:15 - uh so here also you look up the texture
197:17 - codes which are basically your spf
197:19 - records right so if uh similarly you'll
197:22 - check for the error so if you say you'll
197:24 - say if error not equal to nil then
197:25 - you'll do something here so you'll say
197:27 - log dot
197:30 - printf
197:32 - error percentage v
197:35 - slash and comma error
197:40 - and
197:41 - then what you'll do is you'll
197:43 - you'll range over these records so
197:46 - range by by ranging over if you're very
197:49 - new to golang i basically mean like
197:50 - using a for loop to go over all the
197:52 - values okay so we'll go over
197:55 - the text records
197:57 - and the right syntax for that is for
198:01 - and records so
198:02 - this is going to be your iterator and
198:04 - this is going to be your uh every single
198:06 - value that you'll have access to with
198:08 - the help of range records so inside your
198:10 - text records you'll range over them and
198:12 - every single value inside that text
198:14 - records you'll have access to it using
198:15 - this variable called record and here you
198:18 - could have used the
198:20 - iterator like i or j or something like
198:22 - that but since we don't want to use it
198:24 - we put a blank character here because in
198:26 - golang you can't just define something
198:28 - and then not use it okay that's why you
198:30 - have to use blank characters
198:32 - so here we'll use the strings
198:35 - package provided by golang again by
198:37 - default
198:40 - and you'll
198:41 - use the record
198:43 - record is basically every single value
198:44 - like i told you from this text records
198:46 - once you range over it every single
198:47 - value can be accessed using record so
198:49 - we're passing strings.hash prefix in
198:51 - that function we're passing uh the
198:53 - record
198:54 - and we're checking if this uh it has
198:57 - been represented like this so usually
198:58 - the spf records
199:00 - in your text records right all your txt
199:02 - records and that you want to find or
199:05 - search the spf one records okay if the
199:08 - way they represented so if you go to
199:09 - your let's say your godaddy or your name
199:11 - cheap
199:12 - you'll see that you'll you have these
199:14 - dxj records and they will look like this
199:15 - they'll have like a v is equal to spf
199:17 - one
199:20 - and so you'll
199:22 - obviously
199:24 - set the spf has spf is equal to true
199:27 - and then you'll also
199:29 - have your spf
199:31 - record which will be set equal to the
199:33 - record now
199:35 - and then you'll just break away
199:39 - from this program
199:44 - so a few minutes into the program we
199:45 - have already checked for
199:48 - the mx records and spf records all we
199:50 - now need to check for
199:52 - are the
199:54 - dmacc records
199:57 - now to check for the democracy calls
199:59 - we will again
200:01 - use the net
200:03 - dot
200:04 - look up
200:06 - txt
200:08 - but we'll check for
200:12 - dmarc plus the domain
200:18 - domain again is that same variable that
200:20 - was
200:21 - passed into this function
200:26 - and
200:29 - here we'll say
200:31 - dmarc
200:33 - records comma error
200:36 - so whatever is coming back from this
200:37 - function
200:38 - the function is lookup text that you
200:40 - have already used in the net package
200:42 - you're passing domain plus the dmac
200:44 - record to check if you know you're
200:46 - looking up the remark records using the
200:47 - same function
200:49 - and whatever you're getting back you're
200:51 - either getting an error or you're
200:52 - getting the dmac records
200:54 - so we'll check for the error so if error
200:56 - not equal to nil
200:58 - say log dot printf
201:05 - and we'll print out the error
201:12 - and otherwise we'll range over
201:16 - the dmacc records
201:22 - to do that you have to follow the same
201:25 - kind of a syntax
201:30 - and here you start to say if strings dot
201:32 - has prefix
201:36 - record comma v is equal to d mark
201:41 - one
201:43 - so you're doing you're following the
201:44 - same uh method process there's no change
201:47 - here
201:48 - all right
201:49 - same process and here instead of record
201:51 - spf 1 we're saying dmacc one
201:55 - and if it does then we'll say has the
201:57 - mark has become equal to 2 true
202:01 - and dmarc
202:03 - record
202:04 - value is equal to the record value
202:07 - and then you break away
202:10 - and
202:12 - at the end
202:13 - you'll just print out all the results
202:16 - right so you have to use the printf
202:17 - method
202:19 - and to print out the values so you'll
202:20 - say um
202:23 - i'll put the percentages later on
202:24 - percentage vs later on
202:26 - the values that i want to print out to
202:27 - the terminal our domain has
202:29 - mx
202:31 - has
202:32 - spf
202:34 - i have this reference right domain has a
202:36 - mix has this we have all these this was
202:37 - just text and here we're actually
202:39 - pushing out like printing out those
202:40 - values
202:42 - but in the same order spf record comma
202:44 - has
202:45 - daymark
202:47 - comma d mark
202:49 - record
202:52 - so how many
202:54 - v's do we have to put here one two three
202:57 - four five six so let's say percentage v
203:00 - comma percentage v comma percentage v
203:03 - comma
203:05 - delta v comma percentage v
203:07 - so it's five now and then the last one
203:09 - is six
203:11 - six percentage v and this whole function
203:13 - is complete
203:14 - now all we have to do is test this
203:15 - function and
203:17 - we know that we'll get some errors and
203:19 - then we have to solve those other errors
203:20 - and everything will work
203:22 - to actually find the errors and see if
203:24 - it's working we'll have to actually run
203:25 - it on our terminal so here i'll say go
203:27 - run main.go
203:30 - and as you can see it's working so i'm
203:32 - surprised that there are no errors it's
203:33 - working everything's working fine let's
203:35 - try entering
203:37 - mailchimp.com again
203:39 - i've tried it with many of the websites
203:41 - like mailchimp and sendgrid send in blue
203:43 - all of those main big
203:44 - uh email
203:46 - sending tools
203:47 - you can try more um
203:50 - domain here actually any domain you try
203:51 - you can try it here
203:53 - so this as you know the request will
203:55 - time out after a while and then we'll
203:56 - get those results
203:59 - and if it doesn't give you any results
204:01 - then
204:02 - that means there's some error with our
204:03 - program
204:04 - but i'm hoping it'll give some
204:07 - output
204:09 - yeah so we have got that output that
204:13 - timeout be expired and then you know you
204:15 - get your dot com true false true and you
204:17 - get the d marked records
204:20 - okay so i hope you enjoyed this program
204:22 - uh this project this is a very small
204:24 - simple project but
204:25 - you know obviously
204:27 - it's a nice flex you can flex in front
204:28 - of your friends
204:30 - you built like an email verifier tool
204:32 - all right in this video we're building a
204:33 - very simple aws lambda function using
204:36 - golang so aws lambda is a serverless
204:38 - technology where basically you create
204:41 - functions and you host them on the cloud
204:43 - and you only pay for usage so whenever
204:45 - only somebody uses your functions only
204:47 - then you pay for them so there are a lot
204:49 - of use cases for serverless it's a
204:51 - growing technology everybody's uh
204:53 - shifting their stacks and hashtags to
204:54 - serverless these days
204:56 - and uh it's a very i found it to be a
204:58 - very good fit for let's say if you're
205:00 - building an mvp because you don't know
205:02 - if there will be traffic coming to that
205:04 - product right it's not a proven product
205:05 - so you don't know if there's any traffic
205:07 - that's going to come to it
205:08 - so that kind of uh you know um at least
205:12 - ensures that you don't have to keep
205:13 - paying for your servers right you only
205:15 - pay when somebody uses your product
205:17 - um and a lot of people use it throughout
205:19 - the development life cycle like they uh
205:21 - throughout the product cycle life cycle
205:23 - right like uh right from uh the pro poc
205:26 - to the mvp to actually scaling because
205:28 - the scaling uh in serverless uh using
205:30 - lambdas is very easy because you
205:32 - actually don't have to
205:33 - uh write any like huge configs right you
205:36 - don't have to create servers everything
205:37 - is done automatically for you on the
205:39 - cloud
205:40 - uh so it's a completely managed fully
205:42 - managed service you don't have to do a
205:43 - lot basically right so you just have to
205:45 - focus on the business logic which is
205:46 - just creating your functions and
205:47 - everything else is taken care of
205:49 - by the cloud it's also very cheap to use
205:51 - because you're not paying for the
205:52 - servers right you're only paying when
205:53 - somebody uses your programs or functions
205:57 - so if you're building an api that's
205:58 - going to be
206:00 - you know exposed to the world and the
206:02 - world is going to and
206:03 - there are many more developers who are
206:04 - using your api then aws lambda is again
206:06 - a very good use case for that
206:09 - now there are a few drawbacks to using
206:10 - aws lambda for example uh there's cold
206:13 - start wherein you know if you're if
206:15 - somebody's using your lambda and
206:18 - basically the lambda takes a while to
206:19 - start so that's called as a cold start
206:21 - because there's a slight delay there
206:22 - sometimes uh so they've tried to reduce
206:25 - it but it's still there i feel uh cold
206:27 - start problem is still there so so
206:28 - drawbacks will always be there but it's
206:30 - a it's a very good technology
206:31 - everybody's kind of adopting it
206:33 - everybody's using it it's widely used
206:35 - very popular it's important right so
206:36 - it's important to learn and so that's
206:38 - why i wanted to create this video uh
206:40 - which is the basic uh creating a very
206:42 - basic co-lang function and then
206:45 - deploying it as a lambda function in aws
206:47 - now uh you will find a lot of videos
206:50 - where people use the gui the aws gui to
206:52 - deploy a lambda function but in in my
206:55 - case in this case i'll be using aws cli
206:57 - because i did not find many uh tutorials
207:01 - actually i didn't find any tutorial on
207:02 - youtube which uses aws cli to deploy uh
207:05 - golang lambda function all right so
207:06 - that's why i thought
207:08 - let me create one because i don't use uh
207:11 - the
207:12 - aws gui a lot i use the aws cli all
207:15 - right so now there are two prerequisites
207:18 - to this video one is that you should
207:20 - know the very basics of golang and
207:22 - actually even if you don't know the very
207:23 - basics of golang i'll explain line by
207:26 - line the whole program to you it's a
207:27 - very small program so that's probably
207:28 - not a big prerequisite the second one is
207:31 - important second one is that you should
207:32 - have aws cli installed and configured on
207:35 - your laptop or on your whatever desktop
207:37 - machine whatever that you're using right
207:39 - so that's that's kind of important you
207:40 - need to have aw cli installed because
207:42 - like i said you know i'll be showing you
207:43 - the aws cli approach not the aws
207:46 - gui approach because that's something
207:48 - that many people have covered already
207:49 - right aws cli i find it to be quicker
207:51 - faster and uh you don't have to like
207:53 - leave your window
207:55 - and if you're a nerd like me like
207:57 - obviously you like working on your
207:58 - terminal you don't want to
208:00 - use gui right now for uh now the next
208:03 - video that i'll create after this will
208:04 - be a complete serverless stack that will
208:06 - be creating right we will create apis
208:09 - that can be exposed to the public
208:11 - and those we'll create using lambda
208:13 - dynamodb and api gateway that's a
208:16 - complete serverless stack that's in the
208:18 - video that's coming up soon
208:20 - in that case since
208:22 - i don't want to create very complex
208:24 - config files i'll use the aws gui to
208:26 - deploy the lambda functions and to
208:28 - actually configure my api gateway um but
208:31 - only because the config files are going
208:33 - to be very very complex like yaml files
208:35 - so that's why i want to do it
208:36 - on the gui and not from
208:39 - and not write those yaml files so that's
208:41 - why uh here because uh it's kind of easy
208:44 - i'll just use my
208:46 - cli all right i hope that makes sense
208:49 - and
208:50 - even in the upcoming video i'll create
208:52 - uh config files if you want me to i'll
208:54 - show you how to do that but i kind of
208:55 - prefer going the gui route in a project
208:58 - that's a little more complicated all
208:59 - right that's just my personal preference
209:02 - so
209:04 - having said that let's get we'll have to
209:06 - get started now a lot of talking has
209:08 - happened so this is my terminal and uh
209:12 - you don't you don't necessarily need to
209:15 - um
209:16 - keep the project in a folder where your
209:17 - golang is installed right like go path
209:19 - and go route could be somewhere else you
209:20 - can have the project anywhere else
209:21 - doesn't matter because we'll be using
209:23 - the uh like like we always do right the
209:25 - golang 1.12 uh the
209:28 - the format that came after golang 1.12
209:31 - which was basically
209:32 - uh you know using co mod in it right
209:34 - which can initialize your go mod file
209:36 - anywhere it doesn't have to be in the
209:38 - root or path
209:41 - so but uh usually also i i prefer
209:43 - keeping it in the go root and go path
209:45 - because i've been a golang developer for
209:47 - a very long time so that's why i prefer
209:48 - keeping it there but you can keep it
209:49 - anywhere right so because i'm i'm saying
209:51 - this because i get a lot of questions on
209:53 - youtube saying that hey my go path is
209:56 - you know configured like this where i'm
209:57 - keeping my project like this is that
209:58 - okay and do i need to keep my project in
210:00 - guru so the answer to that is you don't
210:02 - have to do all of that you can you know
210:04 - keep it anywhere i i keep
210:06 - my projects in the go root most of the
210:08 - times because
210:10 - that's how i've been doing it since very
210:12 - long time before even before golang 1.12
210:14 - was there right so you don't have to do
210:16 - it i mean um
210:17 - you know the go modern it takes care of
210:19 - everything you don't have to do anything
210:21 - so let's create a new directory so we'll
210:22 - say lambda
210:24 - yt example
210:26 - okay
210:27 - and so we'll cd into it lambda yt
210:31 - example
210:32 - and here we'll just say go mod in it
210:35 - and
210:36 - to initialize i'll say github.com slash
210:39 - akil slash
210:41 - um
210:43 - go lambda function
210:46 - lambda
210:47 - function
210:48 - three okay because i've created many
210:50 - lambda functions on my
210:53 - aws account so i just need to be sure
210:55 - that this is a different lambda function
210:57 - all together
210:59 - all right now this is
211:02 - my project file project name
211:05 - and i don't have to keep the same name
211:07 - as my lambda function that i declare in
211:09 - my aws but i'm just for consistency's
211:12 - sake and that's what i'm going to do i'm
211:13 - going to have this name the same exact
211:15 - name in my aws uh lambda console as well
211:18 - when i declare the function all right
211:20 - uh so there are two parts to this video
211:23 - uh as in the video will be one but then
211:25 - i'm dividing it in two parts like
211:27 - contextually the first part where i'll
211:29 - be building the golang function with you
211:30 - which will be a simple function and the
211:32 - second part where we'll deploy that
211:33 - we'll we'll do the aws configuration
211:35 - parts the second part is slightly
211:37 - uh where you need to pay more attention
211:39 - uh because that's where all the magic
211:41 - happens and the first part is just
211:42 - creating the golang
211:44 - file so if you want to go quickly
211:46 - through the first part no problem uh you
211:48 - know just make sure that you slow down
211:51 - in the second part where i actually show
211:52 - you how to deploy uh the golang
211:54 - functions because there are a lot of
211:56 - caveats there a lot of different you
211:58 - know working parts there
212:00 - and uh one small mistake will completely
212:02 - mess up your entire deployment all right
212:04 - so
212:06 - now what we'll do is we'll open up our
212:09 - code editor i'm using vs code you could
212:11 - be using anything else
212:13 - and let me bring uh
212:15 - vs code here
212:19 - all right and here all i have to do is i
212:20 - just have to create a main.go file and
212:23 - we'll be just using one dependency in
212:24 - this entire project that is it all right
212:28 - so this program is going to be short and
212:29 - we're going to code a bit quickly in
212:31 - case you're new to golang main.gov file
212:34 - is
212:35 - basically the entry point into the
212:36 - project and in this program since it's a
212:38 - very small and simple program we have
212:40 - only one file which is the main.go file
212:42 - right
212:43 - and
212:44 - the way main.go file starts with is you
212:46 - write package main on top and you import
212:49 - a couple of packages here other packages
212:51 - that you want to use in this file
212:52 - and you have
212:54 - the most important function from uh
212:56 - where basically the control of this
212:59 - project program starts which is the funk
213:00 - main all right
213:02 - and
213:04 - sorry
213:06 - i need two packages one is called the
213:08 - fmt package and the other is called
213:11 - uh the lambda packet so i'll say aws
213:13 - slash aws
213:15 - dash
213:17 - lambda dash co slash
213:20 - lambda
213:21 - all right
213:22 - and we need that lambda package
213:23 - obviously
213:24 - because we're creating a lambda function
213:26 - and fmd basically helps us if you need
213:28 - to go lang again fmt basically helps us
213:30 - with some basic functions like printing
213:32 - and all right so golang is very modular
213:34 - even printing is not there
213:36 - in golang so you have to import a
213:38 - package
213:39 - which is a native package by the way for
213:41 - uh printing stuff
213:43 - right
213:44 - and
213:46 - all we're going to say here is we're
213:48 - going to say lambda dot start
213:50 - and that
213:52 - so lambda is basically this package that
213:53 - we have imported and start as a function
213:55 - that that package gives us and here
213:57 - we'll say lam handle lambda
214:00 - event which is a function that we are
214:02 - passing to this function all right so
214:04 - this means that handle lambda event is a
214:06 - function that we'll have to create here
214:08 - so we'll create that function and lambda
214:09 - event
214:13 - and it accepts some things and it
214:15 - returns something right so what does it
214:17 - accept except it accepts an event
214:20 - so we'll say my
214:22 - event
214:24 - and
214:24 - it returns a response
214:28 - it can also return an error if there's
214:30 - an error
214:33 - and here we'll just basically return
214:37 - response right
214:38 - now let's define what response and event
214:40 - are so we'll say type
214:43 - this my event and my response are two
214:44 - things that we'll define here
214:46 - so my event
214:49 - is basically a struct
214:52 - similarly with my response
214:56 - is again a struct so in case you're new
214:58 - to golang structs are basically your own
215:00 - data types that you can create which are
215:02 - a combination of multiple different data
215:03 - types all right so if i'm creating a
215:06 - data type called my event it's going to
215:08 - have
215:09 - name which is a string
215:11 - and json
215:15 - what is your name
215:18 - by the way i have more than 100 golang
215:20 - videos on my channel so if in case
215:23 - you're planning to learn golang do take
215:24 - a look
215:26 - there are a lot of different type of
215:27 - projects and the way i teach golang is
215:29 - that i basically
215:32 - show you how to build projects and not
215:34 - just teach the basics right
215:37 - so it has just two things name and age
215:40 - all right event
215:41 - so string which is basically what is
215:43 - your name and
215:44 - end which is how old are you and it's
215:46 - going to store um an integer which will
215:48 - be the age out here all right
215:51 - and your my response duct will just have
215:54 - message which will be a string and it
215:55 - will be
215:58 - json
215:59 - and
216:00 - answer
216:03 - okay in case you're wondering why we
216:04 - have to define json like that we're just
216:06 - you know defining
216:08 - that for the purpose of golang golang
216:10 - understands string and end it doesn't
216:12 - understand json right
216:14 - but what we're going to send
216:16 - when we invoke our lambda function
216:18 - we're going to send jsons to it right so
216:20 - that's why we have defined how it's
216:21 - going to look in json
216:24 - so
216:25 - here
216:26 - in
216:27 - my response you already know that my
216:28 - response consists of message so it will
216:30 - say message
216:32 - fmt dot sprint f is a function that
216:34 - helps you to format your strings
216:37 - and
216:39 - you'll say percentage s is percentage d
216:42 - here's
216:43 - old
216:45 - now you have to substitute percentage s
216:46 - and so you'll pass those values here so
216:49 - you'll say event dot
216:51 - name
216:52 - comma event dot h
216:55 - so event will have the name is let's say
216:58 - john
216:59 - and how old are you will be the age
217:01 - so uh all you get in the response when
217:03 - we invoke this lambda function is we get
217:06 - john which is percentage s percentage
217:08 - string right the name
217:09 - is uh 32 years old or whatever like
217:12 - whatever you want to
217:13 - send here
217:15 - and here
217:17 - for the error
217:20 - you would want to pass nil
217:24 - because it passes response and error so
217:26 - for the error we are saying
217:28 - send nil for now
217:30 - and this is what the entire program is
217:32 - about i mean that's it 24 lines
217:34 - even if you remove these spaces it
217:36 - becomes even less but i won't remove
217:38 - that space so it becomes like let's say
217:40 - 20.2 lines that's it that's all we're
217:42 - going to test right now right so that
217:43 - you basically come to know what lambda
217:45 - is how it works and then once you're
217:46 - comfortable with it then uh we'll build
217:49 - the entire serverless stack project all
217:52 - right
217:52 - so
217:54 - now is a good time to go back to our
217:56 - terminal and we'll start doing some
217:58 - operations here
218:00 - now i'm obviously assuming that you
218:02 - already have aws cli setup
218:04 - right
218:05 - and now there are three things that you
218:07 - want to do
218:08 - in the beginning itself now these three
218:10 - commands that i'll show you here
218:12 - are from the official lambda deployment
218:14 - documentation so if you open the lambda
218:16 - documentation for aws deployment
218:18 - documentation you'll see these things
218:20 - these exact same steps right so this is
218:22 - nothing new uh and i'll copy and paste
218:24 - these in the description box below as
218:25 - well so that you can copy and paste them
218:28 - and also there's and you can easily find
218:30 - them on the internet so
218:31 - you don't have to worry too much about
218:33 - it
218:34 - the first command that we're going to
218:35 - paste here
218:37 - is basically a command that creates a
218:40 - role name
218:41 - right called lambda x
218:43 - which will have the right role policy
218:45 - documents and that's what will basically
218:47 - allow you to
218:49 - access lambda
218:50 - on your aws account all right uh so when
218:53 - i press enter in my case it it should
218:55 - give me an error saying that this has
218:57 - already been set up for my uh account
219:00 - ideally that's what yeah so it says an
219:02 - error code
219:03 - uh it already exists right now the
219:06 - second thing that you need to do
219:08 - is you need to go back to your function
219:10 - here and you need to create a file
219:13 - called trust
219:14 - policy.json and this is something that
219:18 - lambda requires
219:20 - right to be able to trust the program
219:22 - that you've created
219:23 - so
219:25 - i'm going to copy and paste some json
219:26 - code here
219:28 - and i'll share this code with you in the
219:30 - description box as well
219:31 - so that's all you have to do now these
219:33 - two steps like i said are directly from
219:35 - the lambda documentation
219:37 - now there are there's another third
219:43 - this is the third command that you need
219:45 - to now
219:46 - put in your terminal
219:50 - i'm not sure why it's not coming just
219:51 - one second
219:55 - yeah so this is basically pointing uh to
219:58 - the trusspolicy.json
220:00 - document saying that this is the you
220:02 - know rule policy document here
220:05 - all right so in this case also should
220:07 - give me an error because i've already
220:08 - done it
220:18 - all right
220:20 - it's already exists
220:22 - and now there's another another command
220:25 - so there are four commands till now
220:26 - right
220:28 - so this fourth command also is very
220:29 - similar
220:33 - there's some issue with copying and
220:35 - pasting that i'm facing right now
220:42 - so all that these functions are doing
220:43 - are helping you to basically set up your
220:46 - policies and roles and permission all of
220:47 - those things all right
220:49 - so now that the basic
220:51 - work is done
220:53 - and now
220:54 - golang won't basically
220:57 - sorry aws won't stop you from uploading
220:59 - and deploying your lambda function now
221:01 - because you have already
221:02 - the trust policy document
221:04 - so all you have to do now is you have to
221:06 - build
221:07 - your main.go file so you'll say go build
221:10 - main dot go
221:14 - so it says that um i have not installed
221:16 - this package so i'll say go mod tidy
221:19 - first
221:24 - this is what's really great about golang
221:26 - because it doesn't make let you make any
221:27 - mistakes right so you'll say go build
221:31 - main.go
221:34 - so it's built the
221:37 - so as you can see this main right this
221:39 - is the executable file which we want to
221:41 - uh send to lambda now before you send or
221:44 - upload anything to lambda you need to
221:46 - have that file
221:48 - as a zip file
221:50 - so you'll say
221:52 - zip function.zip and you're going to zip
221:54 - the main
221:55 - project right so now if i ls
222:00 - they'll have this function.zip which is
222:02 - the name of the file right so we will
222:04 - call zip now it's possible that your
222:07 - particular ubuntu terminal doesn't have
222:10 - this function called zip right so if
222:12 - you're on ubuntu it's very easy it's i
222:14 - think it's just sudo apt install
222:17 - zip and similarly if you're on
222:19 - powershell or on
222:21 - powershell it's also easy i think you
222:22 - can use the choco installer now package
222:25 - installer and on
222:27 - mac you can use homebrew to install zip
222:30 - and that's straightforward as in it just
222:32 - takes your main executable file and
222:35 - zips in into a file called function.zip
222:37 - and that's the one that you want to
222:39 - upload
222:41 - now comes the most important
222:44 - function
222:45 - right
222:47 - so
222:48 - i'll paste this function here and then
222:50 - we'll have to change the name of the
222:53 - function
222:56 - not sure why i'm not able to
222:58 - copy and paste it easily
223:08 - some issue
223:11 - wait
223:12 - actually i just bring out my notepad
223:14 - because i need to make changes to that
223:18 - uh program right so this is the entire
223:21 - uh function that we want to basically um
223:25 - the entire command that we want to run
223:27 - right now and all it does is it
223:29 - basically creates a lambda function and
223:31 - it gives the function a name
223:34 - and what we are saying is that this is
223:35 - the zip file function.zip
223:37 - and handler is basically main inside
223:40 - that zip file is main executable file
223:42 - and the runtime that you need is golang
223:44 - 1.x
223:46 - all right and here the name of my
223:48 - function is actually
223:50 - something else so that's what i need to
223:51 - just
223:53 - verify
223:55 - go lambda function 3 that's the name of
223:56 - my function so i'll say go
223:58 - lambda
223:59 - function
224:00 - 3
224:01 - all right
224:02 - so i'll just copy and
224:06 - paste this command here and i'll run it
224:10 - everything seems fine right now
224:15 - one more thing that i forgot to mention
224:16 - is that this is my particular amazon
224:19 - account id
224:20 - you need to replace this
224:22 - number with your
224:24 - account id all right
224:26 - otherwise this program won't work
224:36 - it's taking a while
224:39 - because it has to create that lambda
224:40 - function also has to upload that
224:42 - function.zip file so it will take a
224:44 - while
224:45 - and then the last command that we'll
224:47 - build we'll be running will basically be
224:50 - for invoking that function
224:52 - so
224:53 - in the meantime while this function is
224:54 - running
224:58 - just
225:00 - copy and paste that other function here
225:02 - that we'll use to invoke
225:05 - so as you can see what's happening here
225:06 - is it's basically this function this
225:08 - command will invoke your lambda function
225:10 - in my case the lambda function is called
225:12 - go
225:15 - lambda
225:18 - function
225:21 - 3 right
225:24 - and so this uh
225:27 - part this i found from stack overflow
225:30 - this is not in the documentation if you
225:31 - don't do this and you pass json in the
225:34 - payload because you have to pass json in
225:37 - the payload right
225:38 - we have to pass json in the payload
225:40 - because that's how our request and
225:42 - response will work it'll be what is your
225:44 - name how old are you
225:45 - right and sorry let me just make this
225:48 - full screen yeah so what is your name
225:50 - is jim and how old are you as 33 right
225:52 - that's how our function is structured in
225:54 - case
225:56 - you don't remember
225:57 - this is what is your name and how old
225:59 - are you and the answers for that is jim
226:01 - and 33
226:02 - and whatever happens
226:04 - like let's say even if there's an error
226:06 - or the response will be formed in a file
226:09 - called output.txt
226:11 - all right and if you don't so this is
226:12 - something that i didn't found find in
226:14 - the um
226:15 - lambda documentation decide to find from
226:18 - uh stack overflow because when i was
226:19 - passing my json i was getting some
226:22 - errors so just make sure you write this
226:24 - little you know text here
226:27 - and so this is your program now if you
226:29 - see here if this has stopped
226:32 - you know this is basically deployed and
226:33 - everything seems to be fine and it's
226:35 - giving you the latest version
226:38 - so your lambda is deployed
226:40 - and now you'll just say control c
226:46 - and now you want to just pass the last
226:48 - command
226:49 - let's try and invoking it and seeing
226:51 - what happens
226:56 - something wrong with my copy and paste
227:02 - let me actually
227:05 - start another terminal
227:07 - i will see it into the directory
227:16 - is called uh lambda
227:23 - something like that right sorry yeah
227:25 - user
227:26 - cd lambda
227:29 - and
227:33 - yt example
227:42 - and here
227:44 - yeah so this is the exact project that
227:46 - we're in and here is where i'll just
227:51 - run this command
227:54 - you don't have to necessarily run this
227:55 - command here inside this project
227:57 - directory but i'm just doing it
228:00 - because of habit
228:04 - so again it'll take a while to
228:07 - invoke so it took about four five
228:09 - seconds to invoke i say status score 200
228:12 - and execute latest version which is
228:14 - called as dollar latest
228:16 - now how do we know
228:18 - uh that everything worked fine because
228:21 - we need to check for this file called
228:23 - output.txt so we told our lambda that
228:27 - you invoke this function and whatever
228:28 - output that you get by sending this
228:30 - payload into the function you write that
228:32 - in a file called output.txt so that's
228:35 - what the file we need to look for so as
228:37 - you can see this there's a new file
228:38 - called output.txt here you click on it
228:41 - and you say that jim is zero years old
228:43 - which is
228:44 - wrong because it should have been 33. so
228:47 - that means our program is misfiring i
228:49 - need to just check for that now
228:53 - so we'll just go through our code
228:55 - quickly and see the issue
228:58 - the issue seems to be
229:02 - out here because there's no question
229:03 - mark here so when we're
229:06 - passing this here right
229:09 - as a question mark or just remove this
229:11 - question mark for now
229:13 - for now just remove this question mark
229:15 - because if we remove add a question mark
229:17 - here we'll have to redeploy this entire
229:19 - function by uh you know zipping it right
229:21 - so for now let's just change our
229:23 - invoking function and copying it
229:26 - and pasting it again here
229:29 - and let's see what that what happens
229:32 - so we'll wait for it
229:38 - it has
229:39 - uh completed
229:41 - the execution
229:42 - now it shows jim is 33 years old right
229:44 - so what's happening here is basically
229:45 - it's matching this completely properly
229:48 - like even if there's an extra question
229:49 - mark it won't read this value right so
229:51 - just make sure uh these both statements
229:54 - they match
229:55 - and that's the only error that i got and
229:57 - everything else seems to be working fine
229:59 - so that's it you know that's your
230:01 - complete
230:02 - lambda function
230:04 - and deployed to the cloud when now when
230:06 - somebody uses it or you use it only then
230:08 - you have to pay for that particular
230:10 - usage otherwise
230:11 - everything is perfectly fine in this
230:13 - video we are building a very basic lead
230:15 - management system or crm using golang
230:17 - and go fiber and this is a completely
230:19 - beginner friendly video so if you have
230:21 - no uh hands-on experience with golang
230:23 - this is the right video for you to get
230:25 - get your feet wet and start working with
230:26 - golang
230:27 - now i'll be using a very basic database
230:29 - called sqlite so it will be very
230:31 - difficult for you to set up or start
230:33 - using okay
230:34 - and uh i won't be using any concepts
230:36 - that throw beginners off with golang
230:38 - with like i won't be using any pointers
230:40 - difficult advanced struct modeling i
230:42 - won't be using marshalling and
230:43 - marshalling i won't be using like
230:45 - channels and go routines i wouldn't use
230:46 - any of the concepts that people the
230:48 - beginners find really difficult to
230:50 - understand
230:51 - so this is a great product to get
230:52 - started the only prerequisite is that
230:54 - you should have
230:55 - sql lite installed ideally if you're on
230:59 - ubuntu uh it's very simple it's very
231:01 - easy to install sqlite just one command
231:03 - i think uh apt get installed sqlite you
231:06 - don't have to do much so with that out
231:08 - of the way
231:09 - um let's let's start uh setting up the
231:12 - project
231:13 - so i'm in my terminal now and it doesn't
231:15 - matter how you go path is set up
231:17 - we are creating a new project using go
231:20 - mod so that will create the entire
231:22 - package for us and do the package
231:24 - management for us
231:25 - so we can create this folder or this
231:27 - project anywhere in our computer okay
231:30 - so i'm going to create
231:32 - a new directory and i'm going to call
231:34 - the project go
231:36 - fiber
231:38 - crm
231:39 - i think
231:41 - basic
231:44 - and the cd into it
231:49 - and i'll also go mod in it
231:55 - i'll just give my username and then i'll
231:57 - give the name of the project go fiber
232:00 - crm basic
232:03 - now
232:04 - go mod in it creates a go.mod file which
232:06 - is going to basically
232:08 - contain the list of all the dependencies
232:10 - that we use in this project
232:12 - so you
232:14 - open this up
232:16 - with i'm opening it up using vs code
232:20 - you can use any other
232:24 - code editor and here i'm using uh if you
232:27 - if you go to your golang if you go to
232:29 - your vs code extensions the first few
232:32 - extensions that come up when you type
232:33 - golang just install those
232:35 - uh because that'll just make your
232:36 - experience better in the sense they'll
232:38 - rent the errors and the issues for you
232:41 - by default and i've i've already done
232:43 - that so
232:45 - even if you don't do it it's completely
232:46 - okay but if you do it then you're just
232:48 - able to find those issues much faster
232:50 - and easier
232:52 - the way we structure this program is
232:54 - going to be really simple
232:56 - we just have
232:57 - a database folder
232:59 - we'll have our
233:01 - lead folder
233:02 - and we'll have our main
233:04 - file now main.go file is the most
233:06 - important file in your golang projects
233:10 - and this is basically the entry into
233:11 - your
233:12 - project
233:15 - and in your
233:16 - lead you'll have
233:18 - a lead code go file in the lead folder
233:23 - in your database folder you'll just have
233:25 - a database.profile
233:28 - so with main.go
233:32 - this is how you start the main.profile
233:34 - right it's called main
233:36 - and the second thing that you usually
233:38 - write are the import statements for the
233:41 - packages that you might want to use
233:44 - and
233:45 - [Music]
233:47 - then the most important function here in
233:49 - the main.go file is usually
233:52 - or it's actually always funk main
233:57 - so this is how you write funcman you
233:58 - just create these two
234:00 - brackets
234:01 - and then you create these two curly
234:02 - braces inside which you'll actually like
234:04 - the function definition
234:06 - and
234:07 - um since i've only told you that i'll be
234:09 - using
234:11 - golang fiber for fiber
234:14 - i'm going to go ahead and install it so
234:16 - i'll say github.com
234:24 - now um
234:26 - [Music]
234:27 - since we're using this package
234:29 - whenever you want you've written down
234:31 - any packages and you want to install
234:32 - them you just have to run this command
234:34 - called
234:35 - id and you'll find all the packages that
234:37 - have been defined but not
234:39 - installed yet and we'll install all
234:41 - these for you
234:42 - so i'll go ahead and find the model for
234:44 - package and install it automatically
234:49 - okay
234:52 - what you want to do is you want to
234:54 - create some routes
234:55 - so
234:57 - we'll create some routes we'll say funk
235:00 - setup
235:01 - routes
235:04 - here
235:08 - and the routes
235:12 - will be simple
235:13 - there will be uh
235:15 - get leads
235:19 - right in the crm here there will be a
235:21 - create lead
235:23 - so we'll have app dot
235:26 - post
235:28 - new lead
235:30 - there will be delete leads so app dot
235:34 - delete
235:36 - there will be
235:42 - okay
235:45 - and uh
235:46 - now you've been calling this app but
235:48 - what is this app exactly
235:50 - app is basically an instance of
235:52 - your file
235:54 - so you'll call the fiber library like
235:56 - this
235:57 - and you'll say dot
235:59 - new
236:04 - okay
236:08 - and
236:10 - you'll go to the next line
236:12 - you'll say
236:14 - set up routes
236:16 - and you're going to pass
236:18 - app
236:19 - into this folder
236:20 - i meant function part folder
236:23 - so
236:23 - into this function which is set routes
236:25 - you pass app which is basically an
236:28 - instance of your fiber
236:31 - and
236:32 - by the way you've seen that this
236:33 - squiggly line has gone away that means
236:35 - it has done it's done installing the
236:37 - five word package for us okay
236:40 - now if you're passing phi app here in
236:42 - this function that means you have to
236:43 - accept app into this
236:45 - function right so this is how you accept
236:47 - it
236:49 - so you say fiber dot app
236:50 - i know it's there's a star here and it's
236:52 - a pointer and i said there's no i'm not
236:54 - going to using any pointers but this is
236:56 - just one little exception okay i won't
236:58 - be using it anywhere else but just to
237:00 - give it reference and to it
237:01 - you know refer to the app that's being
237:03 - passed into this function we have to use
237:05 - the pointer
237:07 - so in case you don't know what pointers
237:09 - are don't worry right now i'll be
237:10 - creating very basic videos and
237:12 - explaining pointers but for now you just
237:13 - have to remember that app
237:16 - has been passed into this function
237:18 - and we don't uh we just want to uh use
237:20 - it or call it by reference just remember
237:23 - that call it by reference as in we don't
237:25 - want to directly um you know use app
237:28 - and uh why and how it works and what our
237:30 - pointers all of that i'll be explaining
237:32 - a different video in a very basic kind
237:33 - of video for now just remember that you
237:36 - just have to put a star here that is it
237:37 - right that's all you have to care about
237:40 - anyhow
237:41 - so you have uh
237:43 - defined these four uh these three
237:45 - different things but i need one more
237:46 - okay i need one more it's called just
237:48 - getting one lead
237:50 - dot
237:51 - get
237:53 - and just get lead
237:56 - so how this is working is that for this
237:59 - new lead you'll have a route which will
238:00 - help you create a new lead and for
238:02 - getting all leads you can have get leads
238:05 - for getting just one lead
238:07 - using an id you can have get lead
238:09 - function and then delete lead function
238:11 - is will be for
238:13 - deleting a particular read with the with
238:15 - an id
238:16 - okay
238:17 - so uh
238:18 - [Music]
238:20 - now
238:22 - you want to have
238:23 - app.listen
238:27 - this starts off your server at
238:32 - the port 3000
238:36 - and
238:42 - and you also want to
238:44 - uh connect to the database
238:47 - uh but what i'll do is i'll just define
238:49 - the database first and then i'll come
238:50 - here and then start we'll connect with
238:52 - the database
238:54 - now
238:56 - you want to create a function here
238:59 - called init database
239:09 - okay
239:11 - and you want to go to database.go
239:16 - and here you want to write package
239:18 - database
239:21 - we'll import a couple of things
239:27 - and we'll define a variable
239:29 - we will define a variable to be able to
239:30 - connect a connection or to be able to
239:32 - create a connection with our database
239:34 - so we'll call it dbcon
239:36 - as a representation or reference to db
239:38 - database connection
239:40 - and it's going to be of type
239:42 - corn dot d
239:44 - now gorm is basically uh golang orm
239:48 - which helps golang to interact with the
239:50 - database
239:51 - otherwise you would have had to write
239:53 - all those queries yourself but here you
239:55 - don't have to because you get the help
239:57 - of gordon
239:58 - and now that also means that you'll have
240:00 - to import god because god is not is an
240:02 - external library right so you'll say
240:04 - github.com
240:07 - slash
240:08 - jinzu which is the name of the person
240:10 - who's created gorm and then
240:14 - right corn
240:17 - you'll also
240:19 - get the exact um
240:22 - support for the exact database that
240:24 - you're using so the database that we're
240:25 - using is called sqlite inside corn
240:28 - we have something called as
240:30 - dialects
240:33 - and you get sqlite
240:36 - so dialects basically means language
240:38 - right so uh
240:39 - inside gone what what language do you
240:41 - want to use so we want to use the sqlite
240:44 - support language basically to be able to
240:46 - connect our co-language sqlite
240:48 - so what you want to do is you are
240:51 - put a slash here and then just copy
240:56 - and paste it here
240:59 - right
241:01 - and just run go mod id again and you'll
241:04 - get these two packages and the script
241:06 - line will go away
241:08 - so always just keep running uh go more
241:10 - tightly right so i just run it some time
241:12 - back
241:13 - and i got all the packages
241:16 - so your database.go file is complete
241:19 - now we'll come back to our main.co file
241:24 - here what you want to do is the database
241:26 - that you just created right the database
241:27 - file that you just created or the
241:28 - database package that you just created
241:31 - you want to
241:33 - import it here
241:35 - so you want to say github.com
241:38 - slash account slash
241:40 - uh the name of the project the name of
241:42 - the project is go fiber crm basic so
241:44 - just
241:44 - write that same name here
241:49 - and slash database
241:51 - this tells golank that you want to
241:54 - import the database package that you
241:55 - just created here in this
241:57 - folder
241:58 - and you just want to
242:00 - import that
242:01 - so once you import that then you can
242:04 - access
242:04 - the code that you've written there
242:07 - okay so this makes the golan code
242:09 - monitor in the sense you don't have to
242:10 - keep everything in the same file
242:12 - you can divide it into different
242:13 - packages and you can install or report
242:15 - those different packages into your
242:16 - main.com file
242:18 - and this is how i've imported
242:20 - the database package that i've just
242:21 - created
242:22 - into the main
242:24 - file
242:27 - all right um
242:28 - now
242:30 - um
242:32 - what i want to say is
242:34 - in my um main file our main function
242:38 - how to call a function called init
242:40 - database
242:44 - and i want to start a connection
242:52 - so you have both we have just defined
242:55 - the db connection
242:57 - variable right
242:59 - so you want to say database which is
243:00 - your database package which we are
243:03 - accessing using this database
243:05 - dot db connection which is the variable
243:07 - that you just created
243:08 - which is of type column.dp remember
243:11 - so you say database or db connection dot
243:14 - close
243:16 - at the end now differ uh is a statement
243:20 - that you can check out it's it's a
243:21 - golang
243:22 - statement which basically means that
243:25 - this line that we've just said that the
243:26 - connection to be closed
243:28 - will happen at the end when the function
243:30 - has completely run everything has
243:32 - happened after that only this function
243:34 - this line
243:36 - will run this command will run which
243:38 - will close the connection right so we're
243:40 - just making sure that after everything
243:42 - is done after the whole funk main has
243:44 - executed only at the end when everything
243:46 - is done
243:47 - just at the end just before the uh you
243:49 - know end of the program
243:51 - the last pro the last line or the last
243:53 - command to run will be
243:55 - this one
243:56 - database connection up close
243:58 - anyhow
244:01 - so um
244:04 - this in a database
244:07 - function that you have called here
244:09 - and we've defined here
244:11 - we can now start
244:13 - defining it properly
244:16 - so first you'll define a variable called
244:18 - error
244:19 - and you'll say database dot
244:22 - db connection just to remind you
244:25 - database is our folder the package that
244:27 - we just created here
244:28 - database.gov package
244:30 - and dbconnection is the string that we
244:31 - just created so we are accessing the
244:33 - database package in the database
244:34 - connection string just like we did out
244:36 - here
244:38 - and
244:39 - we also have our error and here we say
244:42 - gone
244:44 - dot open
244:48 - sqlite3
244:53 - and comma leads.tv
244:57 - so what's happening here is that you use
245:00 - gorm
245:01 - to open
245:02 - a connection to your sqlite3 database
245:06 - the database name specifically is
245:08 - leads.db
245:10 - and you get that connection in this
245:13 - database dot connection
245:15 - or uh if it's not connected you'll get
245:17 - an error
245:19 - now
245:20 - with the golang what you do is you
245:21 - handle error red after every single
245:23 - operation that's taking place so just as
245:25 - this has happened that are taking place
245:28 - we want to handle the error right here
245:29 - itself so let's say if error
245:31 - modification
245:33 - you want to panic
245:35 - and say failed to
245:37 - connect
245:39 - [Applause]
245:41 - but if everything went well
245:43 - then you want to say
245:48 - connection
245:49 - open
245:50 - database
245:53 - and you'll say database dot db
245:56 - con
245:57 - dot auto migrate
246:01 - ampersand lead dot
246:04 - i'll explain to you what this is
246:08 - and at the end you want to save
246:10 - print
246:10 - ln database
246:14 - migrated
246:18 - okay
246:20 - now lead right
246:22 - lead that you see here
246:25 - you want to define the lead now uh the
246:27 - reason we're getting squid lines here is
246:29 - that fmt is
246:30 - not imported fmt is a package that helps
246:33 - you to print now golang is so modular
246:35 - that it doesn't even have the ability to
246:37 - print on its own so it's there in a
246:39 - package called fmp that you have to
246:41 - import into your program and then you
246:42 - have to use print println and this keeps
246:45 - go angry light and fast
246:48 - so um
246:56 - you also want to have
246:57 - um
247:01 - yeah i think this this looks good
247:03 - yeah so you want to uh now we want to
247:05 - talk about lead university basically
247:08 - lead is going to be this package here
247:10 - that
247:10 - we'll define right so firstly we can
247:12 - find this package we can say package
247:14 - lead
247:16 - right just like package database we
247:17 - defined
247:18 - it's going to have some import
247:19 - statements
247:21 - and most importantly
247:23 - it will have
247:24 - a struct
247:26 - now we won't have any uh difficult or
247:28 - anything these trucks and you know
247:30 - relationship between the structs and
247:31 - modeling all of that we don't have any
247:33 - any of that just have one struct start
247:36 - is basically a data type that you're
247:37 - creating on your own
247:39 - so there are some data types that you
247:40 - get with golang like string and hint and
247:43 - that's all we're using we're just using
247:44 - string in it in this video
247:46 - so you get these kind of data types with
247:47 - column write string and
247:49 - but what if you wanted to create your
247:51 - own data type
247:52 - uh with the combination of strings
247:54 - elements
247:55 - and you can do that with golang and it's
247:57 - called struct right so structs your own
247:59 - data type that you're defining out here
248:01 - and you're saying that lead is of the
248:03 - data type struct and the struct is going
248:05 - to have
248:06 - is going to be
248:08 - modeled
248:09 - it's going to have name
248:10 - company
248:12 - email
248:15 - sorry
248:17 - company
248:19 - email
248:21 - and phone
248:22 - so for a lead management system
248:24 - we'll just have name company email phone
248:25 - that's it
248:27 - phone will be inked now what i'll do is
248:29 - i'll just
248:30 - create proper spacing between them so
248:32 - that it all just becomes a little more
248:34 - readable
248:37 - and
248:39 - um
248:41 - that's that's about it actually
248:44 - so this is how what you need is going to
248:46 - look like
248:47 - right so when you go back to your
248:48 - main.go file
248:51 - you want to now import that lead right
248:54 - so right now obviously the lead file is
248:55 - not complete but eventually at some
248:57 - point of time will be completely
248:58 - complete but you would want to import
249:00 - the complete lead package into your
249:02 - main.com file because you want to run
249:04 - some operations on it
249:06 - and um
249:08 - so how do you import it you just do the
249:10 - same thing just this is your main part
249:13 - of the project right
249:15 - uh your project is github.com i killed
249:16 - slash go fiber basically because that's
249:18 - how you had defined it when you was
249:20 - doing a go mod in it right that's how
249:22 - you initialize the project
249:23 - and uh you can always put a slash here
249:26 - and you can say
249:28 - lead
249:29 - and it'll know golang will know that
249:30 - you're talking about this lead package
249:32 - out here
249:34 - now uh all these functions right so
249:37 - get leads get lead newly deleted
249:39 - functions
249:40 - we can either define them inside our
249:42 - main.go file or we can define that in
249:44 - the lead file and keep our main.co file
249:46 - lean and simple and small
249:48 - so that's what we're going to do we're
249:49 - going to keep all those functions in our
249:50 - lead.go file and we're not going to keep
249:52 - them here so that means that um those
249:56 - functions will be in
249:57 - a lead package and that's how you
250:00 - refer anything in another package
250:03 - in a lead package
250:05 - we'll have these functions get leads get
250:07 - new lead and delete
250:08 - and the way to access them will be
250:11 - like this the documentation dot
250:13 - okay
250:14 - now you want to define the actual route
250:19 - right
250:20 - so that will be slash we'll keep a
250:25 - lead
250:26 - right so if somebody using postman or
250:29 - using um
250:32 - you know girl hits this route api slash
250:35 - v1 lead then he is going to be able to
250:38 - get all the leads
250:40 - if he uses the get
250:41 - method
250:42 - if you use the post method on the same
250:45 - route you'll be able to post a new lead
250:49 - and
250:51 - for the um
250:54 - get one by id
250:56 - and delete by id
250:58 - it'll be same but at the end there'll
251:00 - also be that id of
251:02 - uh
251:03 - you know of the lead particularly
251:07 - [Music]
251:09 - cool
251:11 - this is what you get right this is how
251:13 - you're set up the routes
251:17 - now the
251:19 - program looks complete right
251:23 - and
251:24 - we'll head over to our
251:27 - lead.go file now
251:30 - so it's saying that i don't recognize
251:31 - what gom dot model is it's giving you a
251:34 - squiggly line that means you have to
251:38 - import
251:41 - the corn
251:42 - i think my video had
251:44 - stopped for a while
251:45 - i've just switched it on back again
251:48 - anyhow so with import uh you want to
251:50 - import the god right so you'll say
251:52 - github
251:53 - dot com
251:55 - slash
251:56 - gen
251:57 - zoo slash
252:00 - now you notice that it doesn't give you
252:02 - a squiggly line out here and that's
252:04 - because
252:05 - gold line already recognizes it because
252:07 - it's already there in your co dot mod
252:09 - right ginger.com is there so you don't
252:11 - have to run go more tightly again you
252:12 - just have you can just um
252:14 - keep this or import this into any
252:17 - um
252:19 - in any file once you've done go mod id
252:21 - once you have imported it in your
252:23 - project right
252:24 - so
252:26 - now
252:28 - you'll again get your go fiber so i'm
252:31 - just going to go to my main and just
252:33 - copy co fiber
252:34 - because um i'll be defining the
252:37 - functions to work with those dogs so
252:38 - that's why i need go fiber here again
252:40 - and similarly that what i need
252:42 - uh in the database
252:44 - the sqlite i'll just copy and paste that
252:47 - also here
252:53 - all right
252:57 - and i also need access to the database
253:00 - so what i'll do is i'll just copy this
253:02 - line
253:04 - and i'll put it here
253:09 - so soon in a while i'll need access to
253:11 - the database
253:12 - right the database connection all
253:14 - because i have to um
253:17 - for those get all leads and post it i'll
253:18 - have to work with the database so i need
253:21 - access to database
253:22 - connections that's why i've imported the
253:24 - database as well
253:27 - and
253:28 - now
253:33 - i want to
253:34 - define all these functions
253:36 - that i have in my main.com file
253:38 - which is basically get leads get lead
253:40 - new lead and delete so let's do that
253:42 - quickly
253:43 - so first function will be
253:45 - get leads
253:48 - second function will be get
253:56 - just lead
253:59 - third function will be new lead
254:06 - and fourth function will be
254:10 - delete delete
254:13 - now they'll have they'll accept some
254:14 - things and then they'll have their own
254:16 - uh function definition
254:19 - so just do that for all of these
254:21 - [Music]
254:28 - now what are they going to accept right
254:30 - they're going to accept
254:32 - c
254:34 - which is basically your fiber dot
254:36 - context
254:38 - fiber rcdx
254:41 - in case you have no idea how context
254:43 - works don't worry
254:46 - i'll have another video and the basics
254:48 - on explaining context
254:50 - but this is a very basic concept of
254:52 - golang and in case you know already know
254:54 - that's really good but if you don't know
254:56 - it just remember that
254:58 - to all these functions that are uh
255:01 - being driven
255:02 - from these apis right from the apis you
255:04 - hit it out
255:05 - and you call a particular function there
255:07 - you have to pass your context to your
255:10 - fiber okay
255:11 - so
255:12 - i'll just give you a very basic idea
255:13 - what this is doing is that this function
255:16 - now can start
255:18 - to work with the data that's coming from
255:20 - the user
255:22 - so for example in my get lead function
255:24 - in my delete function
255:25 - i'll need to use id
255:27 - right
255:28 - and i can use that i can find that id in
255:31 - my c dot params basically c will have
255:34 - all the data that's coming from the user
255:37 - so let me i'll show it to you with an
255:38 - example you understand it so for example
255:40 - in my func get lead
255:43 - now i want a particular id right i want
255:45 - to read off particular id
255:47 - so that means i need to define a
255:48 - variable called id
255:50 - and
255:52 - i can now get access to the params that
255:54 - the user is sending the user is going to
255:56 - say that from the postman or curl that
255:58 - hey i want the i the lead for this
256:00 - particular id
256:01 - so that id
256:03 - you'll have
256:04 - access to that id using c dot params so
256:06 - this is why
256:08 - c which is of type type fiber dot
256:09 - context is important
256:12 - so uh what we'll do is we'll just copy
256:14 - this
256:16 - and paste it everywhere
256:22 - make sense
256:24 - now um
256:27 - let's just finish this function off
256:29 - first
256:30 - so here i'll have
256:32 - a variable called db
256:34 - which will be of type
256:34 - database.connection
256:39 - and i'll have
256:41 - a variable called lead which is of type
256:43 - lead
256:48 - now i have the id that the user has sent
256:49 - to me that's saying that hey i want the
256:51 - deal of this id and i'm now going to my
256:53 - database to fetch the data for that
256:55 - particular id
256:56 - and what i'm saying is that db which is
256:58 - my database or dbconnection right which
257:00 - is the instance of the database
257:02 - session that's going on right now
257:04 - i will find in it
257:07 - the lead
257:08 - with the particular id so i'll say lead
257:11 - with the particular id is what i need
257:15 - and we'll say c dot json lead
257:19 - so we are able to also respond using c
257:22 - the fiber context will also respond we
257:25 - are able to send the response
257:27 - right so we are able to work on the
257:28 - request we are also able to send the
257:30 - response using c dot json and we'll send
257:32 - the lead in the json format okay so this
257:35 - kind of
257:36 - saves our effort from marshalling and
257:38 - marshalling
257:40 - now with the get leads
257:42 - we'll do the same thing we'll say db
257:47 - is equal to database dot daily
257:50 - connection
257:53 - and
257:54 - we'll define
257:56 - available leads
257:58 - which is of type lead but it's a slice
258:01 - now when we say get leads we are
258:03 - basically saying that get all the leads
258:05 - that exist in the database you're not
258:07 - saying that get a particular lead with a
258:08 - particular id we're saying get all the
258:10 - leads in the database to do that you
258:12 - need um
258:14 - something called as a slice which is
258:16 - almost like an added you need a slice of
258:18 - all the leads
258:20 - right so
258:21 - lead in this case is the struct that
258:23 - you've defined and when you say slice of
258:25 - leads that means that there can be
258:28 - multiple such leads with this particular
258:30 - struct
258:32 - right um
258:34 - or in short uh in if you're from a
258:36 - javascript background you would
258:37 - understand that it's a
258:38 - it's an array of objects it's not just
258:40 - an array it's an array of objects that's
258:42 - what a slice is
258:43 - okay
258:44 - so you have variable leads and you have
258:48 - the slice
258:50 - of type slice delete
258:52 - and
258:53 - you'll do the same thing you'll say
258:54 - db.find
258:55 - and you can say db.find because db is
258:57 - the
258:58 - instance of the session
259:00 - for database connection right
259:02 - so you'll say db.find and you'll
259:06 - get all the leads and you'll response
259:09 - send the response you did just see.json
259:11 - will say it needs
259:13 - to send all the leads
259:16 - similarly you want to also have
259:19 - uh the code for new lead
259:21 - and again you'll start with db is equal
259:23 - to database dot
259:25 - db connection
259:28 - and you'll define a variable called lead
259:31 - which is new
259:33 - lead
259:36 - and if
259:37 - uh
259:39 - is equal to c dot
259:41 - parser
259:44 - lead
259:51 - header
259:52 - or equal
259:55 - c dot
259:56 - status as the three
259:59 - dot
260:00 - send
260:02 - error
260:04 - return
260:10 - okay so what's happening here is
260:15 - you get um
260:18 - you use
260:19 - uh body parser that you get in your
260:22 - fiber right in your fiber package you
260:24 - get access to body passes it parses the
260:27 - body of the lead data
260:29 - that the user is sending to you
260:31 - so the user is using postman
260:34 - mostly postman or girl and it's sending
260:36 - you the data for a new lead
260:39 - this data needs to um
260:43 - you know uh checked first so we'll parse
260:45 - it we'll do the body parser
260:48 - and if there's some problem with parsing
260:49 - it right it's going to send an error
260:52 - so this error is 503 that we're sending
260:54 - here
260:56 - but if everything goes well we'll just
260:58 - create that lead so let's say dot create
261:02 - ampersand lead
261:05 - zero json and once you have
261:09 - created that lead in the database you
261:10 - want to send that lead just to show the
261:12 - user that hey this is the lead i was
261:14 - just created in the database right now
261:17 - and uh
261:19 - this is how you create a new instance of
261:21 - the lead okay
261:24 - so the new lead function is quite simple
261:26 - is just
261:28 - using body parser to go through the data
261:31 - of the lead that the user has just sent
261:34 - and then checking if there's an error or
261:36 - creating a new lead
261:39 - and then sending the response with that
261:40 - same read
261:41 - i hope that makes sense
261:43 - now delete lead
261:48 - to delete a lead you need a particular
261:49 - id right because you want to delete a
261:51 - particular need
261:54 - and so we'll say id is equal to c dot
261:57 - paragraphs
261:59 - id
262:01 - and you'll say database is equal to
262:05 - database dot
262:07 - table connection
262:11 - we will define
262:13 - a new lead of type lead when you when
262:15 - you write something like this right you
262:16 - say
262:17 - var lead lead
262:19 - right you've done it here also but this
262:21 - is um you know um i probably didn't
262:24 - realize that maybe it might confuse some
262:26 - some people right so lead is the struct
262:28 - that you've defined right it's the data
262:30 - type that you have defined
262:32 - which is almost like var lead could be
262:34 - an end could be a string or could be a
262:36 - lead lead is your own data type here so
262:38 - lead is the name of the variable whereas
262:40 - lead is the data type which in this case
262:43 - is lead itself which is a start
262:46 - okay
262:49 - now you want to say
262:51 - db dot
262:54 - first
262:57 - lead comma id
263:02 - and
263:04 - if lead dot name
263:08 - is equal to is equal to none
263:11 - we'll say c dot status
263:13 - [Applause]
263:15 - 500 dot
263:17 - send
263:20 - no lead found
263:24 - with
263:25 - id
263:29 - and you'll return from here
263:31 - [Applause]
263:33 - and say db dot
263:36 - delete
263:39 - never send elite
263:42 - and see that send
263:45 - delete
263:47 - successfully
263:49 - delete it
263:54 - so um
263:56 - we get the id
263:58 - right using the same method that we did
264:00 - for get lead
264:03 - sorry this lead here is actually capital
264:05 - l
264:07 - right so i hope you can see what the
264:08 - issue was there shows that there was a
264:09 - small l here the red written lead
264:12 - but it will always be capital l because
264:14 - that's how you've defined this
264:16 - lead start
264:18 - okay so delete lead you got the id using
264:21 - the same method that we did in get lead
264:23 - you got the id right from c dot params
264:26 - then you have db which is the instance
264:28 - of the database connection then you
264:29 - define a lead of type lead struct
264:32 - and then you find the first lead that
264:33 - you find with this id
264:35 - now if you
264:36 - if you uh if the name of that lead is
264:38 - nothing which means that lead is not
264:40 - there that means that no lead was found
264:42 - with that id
264:44 - but if that was found then you'll just
264:45 - go ahead and delete it
264:47 - and you'll say lead successfully deleted
264:50 - that's about it that's it that's your
264:52 - lead.go
264:54 - uh file
264:55 - and then
264:58 - there's only one thing we are left with
265:00 - okay
265:02 - and uh this is the thing that sometimes
265:04 - throws people off uh
265:06 - mostly people who are coming from a json
265:07 - background or from a javascript
265:09 - background is that javascript
265:11 - understands json by default right so
265:13 - whenever javascript developer goes to
265:15 - another programming language like golang
265:17 - or
265:18 - python or java or anything else rust
265:21 - ruby whatever
265:23 - they get confused with this idea of that
265:24 - how can a language not understand json
265:26 - right it's because json is javascript
265:28 - object notation and obviously only
265:30 - javascript understands it natively but
265:32 - all other languages like golang we have
265:34 - to massage uh the data the you know the
265:37 - language to be able to understand
265:40 - json
265:41 - so what you need to do out here is
265:44 - with name you'll have to say
265:47 - json
265:49 - name
265:51 - and you'll say json
265:55 - company
265:58 - so json
266:01 - email
266:03 - json
266:05 - phone
266:10 - what i have done is i have used these
266:12 - backticks
266:15 - and inside that i've used uh
266:17 - said json and i've used
266:19 - in double quotes name company email
266:21 - phone number like that
266:24 - and what's happening here is that
266:26 - um
266:28 - we're telling golang that in json
266:32 - this is what it's going to look like so
266:34 - for your reference uh hey golang for
266:36 - your reference you're saying that it's
266:37 - name with capital n company with capital
266:40 - c
266:40 - email with capital e
266:42 - but the json that you'll receive
266:44 - will be with small n small c small ds
266:47 - small b right
266:48 - this is how the the json is going to
266:50 - look like uh going to look like and
266:53 - we we're expecting
266:55 - uh golang to understand the json
266:59 - right so this is what i basically wanted
267:02 - to show you
267:03 - and when you say um
267:07 - you know
267:08 - that c dot json and in bracket leads
267:10 - you're basically saying to go like that
267:12 - hey whatever you've received from the
267:13 - database now you have to convert it back
267:15 - into json and select to the postman or
267:18 - the terminal whatever
267:20 - okay
267:21 - so what i'm trying to say here is that
267:23 - golang
267:24 - does not understand json and it
267:26 - understands one's constructs and it can
267:29 - only function or
267:30 - perform operations on that struct that
267:32 - it understands and then it then again
267:34 - has to convert something into json and
267:36 - then only it can send it to the response
267:39 - which we will understand
267:41 - or our front end will understand
267:44 - so this was basically your lead.
267:46 - go file
267:47 - and
267:49 - database your dot co file is complete
267:52 - as well
267:54 - and your main.go file
267:57 - is also complete
267:59 - and i'm just checking uh just to see in
268:02 - case there are any issues
268:04 - um
268:05 - in my main file i need uh
268:10 - gorm as well
268:11 - so what i'll do is i'll just
268:14 - go ahead and i'll get the
268:17 - gorn fiber and sqlite all these three
268:19 - packages i'll get into my
268:23 - if i already have so i'll remove that
268:24 - from here
268:27 - i just needed these two packages here in
268:28 - my
268:29 - main.co file as well
268:33 - okay
268:35 - so i think we are ready to be able to
268:37 - build this file now so you want to uh um
268:40 - before you run this file you want to
268:42 - build it so what you'll do is you'll
268:43 - head back to your tunnel
268:46 - and you'll say go build
268:48 - name
268:52 - as soon as you build it
268:54 - you see this file called just main it's
268:56 - just called main
268:59 - and what that means is it's an
269:00 - executable file it's a dot exe file it's
269:02 - executable and uh like dot exe
269:06 - uh
269:07 - if it was windows it would be dot exe
269:09 - file but whatever uh
269:12 - operating system you're using you'll
269:13 - create and create a
269:14 - uh operator like an executable file for
269:16 - that operating system so that you'll be
269:18 - able to run that program
269:19 - and now all you have to do is uh go run
269:24 - main.go and it'll run the program for
269:27 - you
269:28 - as soon as as soon as you do that you
269:30 - need to see these two things connected
269:31 - connection open database you have to see
269:33 - that
269:34 - database migrated in case you don't see
269:36 - any of these that means your program is
269:38 - not working properly and you need to
269:40 - check the code i'll push the code to
269:41 - github as well
269:43 - so
269:44 - this means that our project is working
269:46 - like we see this nice fiber uh
269:49 - you know text here and then you have
269:51 - your port 3000 on which it is working
269:54 - so everything seems to be fine
269:56 - you have four apis for hunters
269:59 - okay so now all we have to do is go to
270:01 - our postman
270:03 - and this is the collection that i've
270:04 - created for my go fiber basic
270:07 - uh project
270:08 - there's an add lead here as you can see
270:11 - right so i'll create this ad agree this
270:14 - lead
270:17 - so this had an id it has created ad
270:19 - updated at delta and then you have your
270:21 - name company email phone
270:23 - now these three time stamps right
270:25 - created updated deleted these can be
270:27 - added automatically uh when you add some
270:30 - data and these are optional right now
270:32 - you don't have to add them but
270:35 - but you may have seen that in many
270:37 - programs it's added automatically and
270:39 - i've shown how to do that
270:41 - using the time package in my other
270:43 - projects since this is beginner friendly
270:45 - project i have not used the time package
270:46 - i've not shown you how to use those
270:47 - timestamps okay
270:49 - and i'm sending it manually from the
270:51 - front end or from postman
270:53 - so here
270:54 - i'll just change the id i'll create
270:56 - another
270:57 - record i'll call this
271:00 - alex
271:03 - clinton
271:04 - let's call him alex clinton
271:06 - we'll call the company name microsoft
271:09 - and email would be alex at
271:11 - microsoft.com
271:17 - and we'll change this phone number a
271:18 - little bit
271:20 - we'll send
271:21 - and you can see that let's create
271:22 - another lead for us
271:25 - if i want to get all leads i'm uh you
271:27 - can see that i'm in the same apis that i
271:29 - have defined here right so if i go to my
271:31 - main.co file
271:32 - um
271:34 - api slash v1 lead
271:36 - so you come here localhost 3000 and api
271:38 - slash v1 that's the apa you're on
271:41 - you send and you can see we have created
271:43 - these two leads so it's working
271:44 - perfectly you created two leads you can
271:45 - see those two reads
271:47 - now you want to get a particular lead
271:49 - right so you'll come here
271:51 - and you will now look at the api
271:54 - uh which is the get
271:57 - api
271:58 - for the particular id in the end you
272:00 - want to add an id right so in the end
272:02 - i've added two
272:04 - i do that i get my ramsay beaters and if
272:06 - i add one
272:09 - i get my other guy
272:11 - and if you want to delete a particular
272:13 - lead
272:14 - it's the same right same api
272:16 - as in same route but the method is
272:18 - delete so you want to change your method
272:21 - here from here to delete and you want to
272:23 - delete the lead tool so it says lead
272:25 - successfully deleted and now when you
272:27 - check get all leads
272:28 - they'll show you only one lead make
272:30 - sense that means your entire project is
272:32 - working this is your simple lead magnet
272:34 - system this is a very simple
272:35 - beginner-friendly project we'll be
272:37 - building an hrms which is a human
272:39 - resource management system
272:40 - and we'll be using golang go fiber and
272:43 - mongodb
272:44 - so essentially you'll be learning how to
272:46 - use go fiber along with mongodb but um
272:50 - in a in a format of a small project so
272:53 - it's very it's a very good way for a
272:55 - beginner to get their feet wet and
272:56 - actual uh you know up applying what
272:58 - they've learned till now
273:00 - now since this video is very uh beginner
273:02 - friendly uh i won't even be having
273:04 - different files i'll be having
273:06 - everything in the same file may not go
273:08 - file so we won't be learning about
273:09 - project structure here because it's ugly
273:11 - again for complete beginners
273:13 - and but in case you want to see more
273:16 - project complex project structures and
273:17 - design patterns and all that i have a
273:19 - lot of projects already on my playlists
273:22 - without further delay let's get started
273:25 - and
273:26 - i'll just open up my terminal now
273:29 - you can see i've opened up my terminal
273:31 - now i'm using powershell on windows for
273:33 - this project
273:35 - and it doesn't matter how you've set up
273:37 - your go path or how you've installed go
273:39 - we'll be using go mod and that means
273:41 - that we can have the project anywhere
273:42 - and go mod will handle dependencies for
273:44 - us
273:45 - so i'll create a new
273:47 - directory for myself for this link
273:49 - project i'll call it go fiber
273:55 - hrms
273:57 - and i'll cd into it
274:02 - and i'll open up uh so before i open up
274:04 - this on on a vs code or any other code
274:07 - editor
274:08 - i'll go ahead and say go more in it
274:10 - which initializes your mod file
274:13 - and
274:14 - you'll give it an absolute path you'll
274:16 - see github.com
274:19 - and the name of the project go fiber
274:23 -  hrms
274:26 - okay and now you can go ahead and open
274:28 - it up in a code window i'm using vs code
274:32 - vs code works out really well for golang
274:34 - so in case you're using something else
274:36 - just drive your code once
274:38 - so as you can see there's uh already a
274:40 - file called co dot mod
274:42 - that exists for me right and it mentions
274:44 - my uh
274:45 - name of the project
274:47 - and also mentions the version of golang
274:49 - that i'm using so that if anybody else
274:51 - takes up this project they can easily
274:53 - install all the external packages that
274:55 - i'll use using this file
274:57 - and all the external packages that we'll
274:58 - install in our project for example the
275:00 - drivers that we'll use to work with
275:02 - mongodb
275:04 - you'll see them listed out here
275:08 - [Music]
275:10 - so as i said we'll have only one file in
275:12 - this project
275:13 - and
275:14 - um so main.go is the file the most
275:16 - important file usually in the golang
275:18 - project
275:18 - and what you want to start off with is
275:20 - you want to say package main
275:24 - and you'll want to import
275:28 - some things here
275:29 - okay
275:30 - and
275:32 - after importing those things that we'll
275:33 - talk about in a while mostly around the
275:36 - things that we'll import will be mostly
275:37 - packages around mongodb
275:39 - uh we also want to create a
275:42 - instance instance of a session with
275:44 - mongodb so that we're able to interact
275:46 - with mongodb and
275:48 - it will be basically a struct
275:52 - so instance
275:54 - struct
275:56 - and you'll have a client and you'll have
275:58 - a database
276:00 - [Applause]
276:02 - so a struct is basically your own data
276:04 - type
276:05 - so you get some data types with golang
276:06 - like int string uint you know all of
276:08 - those float and all of those different
276:10 - uh data types but what if you wanted to
276:12 - create your own data type right uh you
276:14 - can do that in golang using something
276:16 - called a struct almost like an object
276:18 - with javascript
276:20 - and so it will have two different things
276:21 - one is client one is db
276:24 - and
276:25 - uh here we'll have to write some things
276:27 - which i won't write
276:28 - as of now because we have not installed
276:30 - those packages
276:31 - but
276:32 - to be able to work with this struct i'll
276:34 - need a variable
276:36 - called instance
276:39 - now this is how you define variables in
276:41 - mongodb in golang
276:43 - you have this variable mg and subtype
276:46 - this is the data type so it could have
276:47 - been string it could have been end but
276:49 - right now for this uh
276:51 - for what we're doing right now it's
276:53 -  instance among which longer sense
276:55 - is our own data type that we've just
276:56 - created right it's a struct it has a
276:58 - client it has a database
277:00 - okay
277:01 - so
277:03 - i also want to define two uh constants
277:07 - so the first constant will be
277:09 - the db name
277:11 - name of the database that i want to work
277:12 - with db
277:14 - sorry
277:16 - name
277:17 - and it's going to be called let's say we
277:19 - call it fiber
277:21 - hrms
277:24 - and
277:24 - don't define a constant for url
277:31 - now in this video i'm going to be using
277:33 - the localhost
277:35 - mongodb that means that mongodb is
277:37 - installed in my local computer
277:39 - and it'll be running on a port and
277:40 - mongodb usually uses 27017 as the native
277:43 - port now you could be using mongodb on
277:46 - your local machine like i am using to
277:47 - keep things simple but if you are using
277:50 - a fully managed service like mlab they
277:52 - will give you a link to embed in your
277:53 - program and that's the link that you put
277:55 - here in the mongodb uri okay so in my
277:57 - case i'm using localhost so this is how
278:00 - i'll write the
278:02 - link so it'll be mongodb
278:05 - and after these two slashes you'll put
278:06 - your own actual link that you got from
278:09 - your
278:11 - managed service in my case it's just
278:13 - localhost
278:14 - and my port is 27017
278:18 - the way you have configured up your
278:20 - mongodb also makes a difference here
278:23 - because you might have to write your
278:24 - username at the rate your password and
278:27 - then uh your localhost
278:30 - so in my case the way i have configured
278:32 - my mongodb i have not kept any username
278:34 - or password for my admin user to uh as
278:37 - an
278:38 - activity with mongodb without recording
278:40 - any username or password
278:41 - uh in case uh you don't know how to set
278:43 - it up like that there is a video on how
278:45 - to install mongodb uh i think it's long
278:48 - i uh put it up long long back so you'll
278:50 - just have to search red bit on my
278:52 - channel and you'll find it
278:54 - it's very simple it's very
278:55 - straightforward right you just set up
278:57 - mongodb without any users or passwords
279:00 - it's just
279:03 - you know easier to work like that
279:05 - especially if you're building very
279:06 - simple projects right
279:08 - and here
279:09 - you want to add the db name
279:13 - the dv name is fiber hrms and that's
279:16 - what will be added so when your mongodb
279:18 - gets connected we'll get connected to
279:19 - 27017 and by default to this database
279:22 - called fiber hrms
279:24 - now comes an important part which is
279:27 - basically how you'll define your
279:29 - employee
279:31 - now in human resource management system
279:32 - means it's a company and they have a
279:34 - database of their employees that work
279:35 - there so the employee
279:37 - will be a struct
279:39 - now um
279:41 - you can you can manage
279:43 - name like name as a string or
279:46 - you know salary as a as a string or as a
279:48 - number but how do you manage all of that
279:50 - together for one employee right so
279:52 - that's why you create a struct right so
279:54 - there are these data types that golang
279:55 - understands then there are these data
279:56 - types that you can create called structs
279:58 - that you can make go like understand
279:59 - because they have these uh different
280:02 - fields like for example there'll be a
280:04 - field called id field sorry
280:06 - field called id field called name
280:11 - just name
280:14 - and field called
280:16 - salary
280:18 - field called age
280:20 - and all of these fields will have a data
280:22 - type like string for example
280:26 - name will be string
280:29 - salary
280:30 - is float
280:34 - and age is also float
280:38 - right so now these fields like id name
280:41 - salary h there are data types string or
280:44 - end or float whatever so that means
280:46 - golang can understand what we're trying
280:47 - to say right
280:49 - but all of those
280:51 - combined
280:52 - make up a struct
280:54 - and since golang understands those
280:55 - individual things like id name salvage
280:57 - it will also understand this whole start
280:59 - right which is now a new data type that
281:01 - we've treated for uh argues
281:05 - okay
281:06 - now uh
281:09 - there's there'll also be something else
281:10 - that i'll add here but not right now
281:13 - and i'll explain to you what it is but
281:15 - uh just keep this
281:17 - like this keep this as
281:19 - just a struct for now okay
281:22 - now you'll
281:25 - have a function for connection
281:28 - which basically helps you to connect
281:30 - your
281:31 - co-link to mongodb so you'll have the
281:33 - connect function here
281:37 - and every function basically takes in
281:38 - something and returns something so error
281:40 - is what's returned by this function if
281:42 - things go wrong and it takes in nothing
281:44 - basically so this so there are these
281:46 - empty brackets right
281:47 - and inside this will be a function
281:49 - definition that we'll write in a while
281:51 - and at the end
281:54 - will be funk main
281:56 - so funk main is an important function
281:59 - usually the main file funcman is the
282:01 - most important function and that's where
282:03 - the control of the program uh usually
282:06 - begins
282:07 - okay
282:08 - and um here
282:11 - you want to first define your app
282:13 - now if you've used
282:15 - um node.js by any chance
282:18 - uh and if you use express because you
282:20 - have to use express with most days right
282:21 - mostly
282:22 - so if you've used express that then you
282:24 - know that you have to define the app
282:27 - variable in the beginning which is
282:28 - basically an instance of express and
282:29 - that's how you interact with express
282:32 - and exactly that's what we're doing here
282:34 - because fiber is the equivalent of
282:36 - express so express is for with node.js
282:38 - and fiber is with collage it's an exact
282:40 - equivalent but fiber is like i think
282:42 - they say it's 10x faster or something
282:43 - like that it's really fast basically
282:45 - that's all i need to know okay
282:48 - so um
282:50 - now when i say fiber dot new that means
282:52 - i should have had
282:54 - the fiber package
282:56 - so this is how you install or
282:59 - sorry
283:00 - in the import statement
283:04 - this is how you
283:07 - import
283:10 - an external package so you say go fiber
283:12 - slash
283:13 - fiber slash
283:19 - v2
283:22 - sorry it's a small v okay so small v
283:26 - and
283:27 - um
283:29 - you also want to get some mongodb
283:31 - related packages
283:32 - but for now let's uh let's just keep it
283:35 - this much
283:36 - and what we'll do is we'll go over to
283:38 - our terminal and whenever you import a
283:41 - new package right you have to say
283:43 - go mod
283:44 - typing so that
283:47 - golang will
283:49 - go online and find the model package for
283:51 - you
283:52 - and will install it in your program
283:55 - now after
283:57 - your fiverr definition
283:59 - you want to have
284:02 - the standard functions
284:04 - so which are also your routes right so
284:06 - the first route that you want to define
284:08 - is slash employee
284:11 - and this is the get route
284:14 - then you'll
284:16 - so this this the first route with the
284:18 - get method is going to help you get the
284:20 - list of all the employees that are there
284:21 - in your database
284:23 - then you will have a post route
284:26 - and then you want to have
284:27 - a put route
284:30 - and
284:32 - a delete route
284:35 - okay
284:37 - and for
284:38 - post route
284:40 - the route will be the same
284:43 - for put there will be just
284:46 - an id
284:48 - after employee
284:49 - for delete also
284:51 - there will be an id
285:00 - and the way you start off a function is
285:03 - basically
285:04 - when something lands on this route or
285:06 - some or somebody calls this route you
285:09 - want a function to get called
285:11 - and that function basically
285:16 - can return an error if something goes
285:17 - wrong
285:21 - and it will have a definition right the
285:22 - function will have a definition
285:24 - the function usually takes c
285:27 - which gives you fiber dot context
285:31 - you know c which basically is type of
285:34 - fiber
285:35 - which you get access to from here from
285:37 - the library fiber
285:38 - dot context
285:40 - now um
285:41 - there's something really important here
285:43 - for you to understand is that um
285:46 - whenever you have a function like this
285:47 - like a route function
285:49 - you want the request you want to be
285:51 - working with request and you want to
285:53 - have the ability to send out a response
285:55 - a json response
285:57 - by request you mean whenever the user
286:00 - sends let's say from his post manner
286:02 - from curl whatever the user sends to the
286:04 - program
286:05 - and it could be an id it could be uh
286:07 - like in the in case of the post request
286:09 - where you want to add a new employee it
286:10 - would be the new employee data right the
286:12 - data for the new employee
286:13 - so that will all come in the request so
286:15 - you need the ability to be uh to work
286:17 - with that request and you want to be
286:19 - able to process that like let's say you
286:20 - added a new employee or you depleted
286:23 - an employee using the id or you updated
286:25 - an employee using the id
286:27 - and you need the ability to also send
286:29 - out a response back to postman or to the
286:32 - terminal
286:33 - so uh both of this can be done using
286:36 - uh fiber.context and c is how you're
286:39 - going to be accessing the response and
286:41 - request okay
286:42 - so this is what was important for you to
286:44 - understand now uh before you start with
286:47 - all this right you also need to be able
286:49 - to connect with the database so you'll
286:51 - call the connect function here
286:53 - and connect function exactly the same
286:55 - function which you're going to define
286:56 - out here
286:58 - [Applause]
286:59 - so
287:00 - um
287:02 - what's happening here is you'll have f
287:05 - error you'll handle the error here
287:06 - itself
287:08 - and error not equal to nil
287:12 - then your
287:14 - log dot fatal
287:17 - here
287:18 - so the log library helps you to log out
287:20 - errors
287:22 - and we have not imported it here so we
287:23 - have to import the log library
287:25 - right here like this
287:28 - all right and um
287:32 - what you want to do now is we want to
287:33 - start creating our connect function
287:36 - so
287:39 - convert your connect function and we'll
287:41 - say dot
287:43 - new
287:44 - client basically going to create a new
287:46 - client for mongodb
287:48 - now this word
287:51 - basically comes from the library
287:53 - that we have not installed or imported
287:55 - yet
287:55 - so let's go ahead and get the mongodb
287:59 - libraries
288:00 - the first one is go.mongodb.org
288:07 - driver
288:09 - slash
288:11 - so firstly just get actually just
288:13 - get longer
288:16 - right
288:17 - and the spelling here is uh wrong so
288:20 - just make sure you write the right
288:21 - spelling which is mongoose and
288:23 - driver
288:24 - okay so that's the main important
288:25 - library now this library has a few more
288:28 - things that you can get right the so the
288:30 - first thing that you can get is are the
288:32 - options so let's say go dot
288:34 - mongodb dot org
288:36 - slash driver
288:41 - slash
288:42 - and then you'll get some options
288:46 - and then has some bs on the
288:48 - primitive that helps you to create that
288:49 - id right
288:52 - so we'll have to import that as well so
288:54 - you'll say
288:56 - go.mongodb.org
289:01 - slash driver
289:03 - slash vsan
289:05 - this will help us to create
289:10 - the id for every single record
289:13 - there will be a ps1 id
289:15 - and we'll have again mongodb.org
289:21 -  driver
289:25 - slash nissan slash
289:27 - primitive
289:30 - now if in case you're worrying that
289:32 - you'll have to remember these four legs
289:33 - you don't have to you just use it once
289:35 - here and every time you now connect with
289:37 - mongodb you just have to copy those four
289:38 - links i didn't copy them i could have
289:40 - copied them and any other tutorials will
289:42 - see online they will copy them but i'm
289:44 - just showing it to you you know so that
289:45 - uh you you understand that you go to
289:48 - go.mongodb.org website then you go to
289:50 - the mongodb which is the main
289:52 - driver which is like the main apparent
289:53 - library then you have like uh
289:55 - which is the package the orm that you
289:57 - use and then you have your options then
289:59 - you also have your psalm primitive okay
290:01 - so that's why i i just wrote it for you
290:03 - to see that they're all linked and all
290:05 - related so that you're not just blindly
290:07 - copying all of that okay but mostly from
290:09 - now on uh once you've done this project
290:11 - you just have to copy and paste these
290:13 - four lines every year
290:15 - so what happened is when i when i just
290:18 - uh
290:19 - pressed ctrl s to save it uh there are
290:22 - some plugins or extensions that i'm
290:24 - using for golang that basically
290:25 - recognize that i'm not using those
290:27 - packages right now so they have removed
290:29 - those packages for me so i'll control z
290:31 - and not save it as of now but if i try
290:34 - and save it it'll remove those packages
290:35 - that i'm not using so it basically helps
290:37 - with error solving
290:39 - and you can also go to your um
290:42 - what you call it your extensions and you
290:44 - can just write golang and the first
290:46 - three four packages that come just you
290:47 - can just install them they just make
290:48 - development little easier
290:50 - um
290:53 - now
290:54 - now that we have installed or imported
290:56 - these packages now it's going to be very
290:58 - easy for us to
290:59 - work with our connect function okay
291:03 - so you say
291:04 - mongod.net client
291:06 - and then you say options.client
291:11 - dot
291:13 - apply uri so this function right the
291:15 - options dot client dot apply ui you
291:18 - already get from the package that
291:20 - we're using and apply uri is a function
291:22 - where in that function you pass
291:24 - basically your uri that you've
291:26 - just created so all it's doing is it's
291:28 - going to apply that url and basically
291:30 - going to connect
291:32 - and you know
291:33 - create a new client
291:34 - for you and for that
291:36 - url that you've just created or just
291:38 - given to this program
291:41 - um
291:44 - you'll get access to this this whole
291:45 - thing as in the complete connection
291:48 - instance
291:49 - using the client
291:50 - right so whenever you want to work a
291:52 - client you don't want to keep writing
291:53 - this all the time right you want to be
291:55 - able to uh you want to get all of that
291:57 - in one variable that you can use later
291:59 - on so that's what the client is in this
292:00 - case
292:02 - and in case you don't know what this is
292:04 - this is the walrus character this
292:05 - basically um you know
292:07 - defines a variable and also declares
292:09 - declares and defines at the same time
292:11 - so here you also want to have something
292:14 - called as a timeout now there are some
292:16 - functions with mongodb that are blocking
292:20 - functions like insert right and you
292:22 - don't want it to block the entire
292:23 - program so you want to always have a
292:25 - timeout and timeout basically with this
292:28 - mongodb package for uh specifically uh
292:32 - it gives you it uses the context package
292:34 - that already has to give you this
292:36 - ability to have defined timeouts so this
292:39 - is how we define timeout so you say
292:40 - context
292:41 - dot with timer
292:47 - so in case your mongodb is not
292:48 - responding or something goes wrong or
292:49 - insert is taking too long you have a
292:51 - timeout you don't want to block the
292:52 - entire program
292:54 - and uh now this is not compulsory but uh
292:56 - this is a good practice i mean you have
292:58 - to it's not like without writing this
292:59 - the program won't work it will work
293:01 - without it completely fine but uh you
293:03 - know i recommend always writing this
293:05 - down okay
293:07 - so you'll see backgrounds comma
293:09 - and you can give any time here you can
293:11 - give a time of 10 or 20 or 30. now
293:14 - what you'll notice here is that um
293:18 - time as soon as you write time
293:20 - it's not
293:21 - recognized by golan that's because
293:23 - golang is so modular that golon doesn't
293:26 - doesn't even have the ability to print
293:27 - things or uh even the time package is
293:30 - not is even the time ability to
293:32 - understand time is also not inherently
293:34 - available inside co-language so this
293:36 - basically makes golang very lightweight
293:38 - and very fast
293:39 - okay
293:40 - that means that time um
293:42 - is not understood by golang that means
293:44 - it's a different package altogether so
293:45 - you'll have to come up here and you'll
293:46 - have to install time package on your own
293:52 - now uh the extensions that i'm using
293:54 - were able to get the context package for
293:56 - me automatically so when i used context
293:58 - out here even context is not understood
294:00 - by golank but somehow the extension
294:03 - decided to get the context package for
294:05 - me automatically i didn't have to do it
294:08 - anyhow
294:12 - there's a quick line here that means
294:14 - context there's no function called with
294:16 - time out and that's because
294:18 - uh the o should have been small
294:20 - and now golang starts understanding it
294:22 - very quickly
294:24 - you get a squiggly line here with client
294:26 - and error that's because you have
294:27 - defined these and you have not used
294:28 - these as of now and golang has a problem
294:31 - with that so in case you define
294:32 - something and you don't use it golang
294:34 - has a big problem so we'll quickly uh
294:37 - we'll use it we'll basically use these
294:39 - two variables
294:40 - okay
294:42 - now um
294:46 - you want to run this cancel script at
294:47 - the end of this program and that's why
294:49 - you use differ
294:50 - and now you want to say client.connect
294:54 - and you want to pass this context
294:56 - here
294:59 - so here um i forgot to show you that
295:02 - ctx and cancel are the two things that
295:04 - you'll get here
295:07 - right
295:08 - so when you say control c whenever you
295:10 - run your program right and determine you
295:12 - say ctrl c will basically cancel this
295:15 - it'll have that timeout here directly
295:17 - it'll just cancel the entire operation
295:19 - whatever is running out there
295:20 - so um now you have client.context cdx
295:24 - the context is what you will pass here
295:26 - to be able to connect the database with
295:28 - the right context
295:29 - and you will
295:31 - again
295:33 - get that in the error if there's an
295:34 - error there you'll get that in this
295:36 - error
295:37 - variable that you'll handle now and
295:41 - you'll also have a variable called db
295:44 - so we'll say client.database
295:47 - and you'll pass the db name here
295:51 - so you've connected to the
295:53 - database
295:54 - uh to the you know mongodb but you also
295:56 - want to go into the right database right
295:59 - and this is how you do it and uh
296:01 - you can you'll be able to use this now
296:04 - um
296:04 - the database using this db
296:07 - variable
296:09 - so this error that we have received that
296:11 - we may have received if things went
296:12 - wrong while connecting
296:14 - or while creating this new client
296:17 - those errors will handle right now so
296:18 - let's say if error or equipment and by
296:20 - the way this is a common
296:22 - theme with the golang that always when
296:25 - you write something and then you might
296:26 - expect an error there you will always
296:28 - handle that error just there itself so
296:30 - here we will handle the error and we'll
296:32 - have return
296:34 - errors
296:40 - now you might remember that we had
296:42 - created our
296:44 - uh mg here right our instance mg
296:49 - and here we'll say
296:51 - mg
296:53 - is equal to
296:54 -  instance
296:57 - then you'll have client
297:00 - comma
297:01 - db
297:14 - and you'll return
297:17 - nil
297:18 - from this function
297:20 - okay
297:22 - so if you created your mg which is your
297:24 -  instance which is a flight start
297:26 - and the way the values here for the
297:28 - client and database right have now been
297:31 - set so this is what we did here in case
297:33 - you didn't understand is that for the
297:34 - client
297:35 - it comprises of two things remember
297:37 - struct is basically your own data type
297:39 - and in this case it's longer instance
297:41 - which is a struct and has two things one
297:42 - is the client the other is the database
297:44 - so client means the client mongodb and
297:47 - database means that database name that
297:49 - you want to connect with
297:50 - and that's why we created this db and
297:52 - that's why we created the client these
297:53 - two variables here
297:56 - so that we're able to define our own
297:57 - start complete sort and mg is basically
297:59 - what we'll
298:00 - be using to you know further on if you
298:02 - want to work with the database
298:06 - so that's what your instance consists of
298:10 - now here
298:12 - you want to say that client is of type
298:14 - mongo.client
298:17 - and db is of type
298:21 - members
298:31 - make sense
298:40 - right
298:41 - now i know i said i won't use pointers
298:43 - and this star is basically a pointer so
298:45 - what you're saying is that it's a
298:46 - reference to dot client and mongod
298:49 - database if you don't understand
298:50 - pointers right now it's not a problem
298:52 - you don't have to uh you know really
298:54 - worry about it i'll have really basic
298:56 - videos coming up on what pointers are
298:58 - and how they work and why they're used
299:00 - for now here this is the only place
299:01 - where you'll be using it so
299:03 - uh and also the other place where
299:06 - uh we're passing a pointer to the fiber
299:08 - dot context so just have to remember
299:09 - that you have to put stars in front of
299:11 - these for now and we're just passing
299:13 - these by reference about pointers i'll
299:15 - create like a 20 30 minute video just
299:17 - explaining pointers so don't worry about
299:18 - this right now okay
299:20 - and there's no advanced pointers getting
299:22 - used here just just for
299:24 - this part so don't worry
299:26 - uh anyhow
299:29 - now coming to your uh employee start now
299:32 - there's something that i want to do here
299:34 - and i think right now is the right time
299:36 - to do that before we start creating all
299:38 - these
299:40 - handler functions for our routes
299:43 - so um one important thing that i want
299:46 - you to understand is that um golang does
299:48 - not understand json natively
299:51 - on its own
299:52 - just like if you're coming from a
299:54 - javascript background you might feel
299:56 - that
299:57 - you know json is always is basically
299:59 - understood by all languages and
300:00 - javascript people have
300:02 - uh this confusion because they feel that
300:04 - javascript understands co-lang json so
300:06 - that means all
300:07 - languages will understand json but it's
300:09 - not like that is because json is
300:11 - javascript object mutations only
300:13 - javascript understands it natively all
300:14 - other languages have to
300:16 - use some packages to be able to
300:17 - understand it in our case we have to use
300:19 - um a package called json
300:22 - we have to do a lot of encoding
300:24 - encoding and marshaling and marshalling
300:26 - basically for understanding and working
300:28 - with json and but in this case since
300:30 - we're using fiber fiber takes care of a
300:32 - lot of things for us automatically by
300:33 - default and it's all happening under the
300:35 - surface like all a lot of marshaling and
300:37 - marshalling is happening under the
300:39 - surface so fiber makes things very easy
300:40 - for us
300:41 - uh but otherwise uh by default uh golang
300:44 - does not understand json right so that's
300:46 - why we in whenever you define a struct
300:48 - and the struct is going to actually
300:49 - represent uh the data in the database in
300:52 - your mongodb which understands json by
300:54 - the way it's a javascript database and
300:56 - uh the data that you're getting going to
300:57 - get from
300:59 - the user as a request
301:01 - is also going to be json right so when
301:04 - data comes from the user as a request to
301:06 - golang it does not understand it because
301:08 - it's json and when data comes from the
301:10 - other way from the mongodb uh to golang
301:13 - and then golan has to send it to the
301:14 - user again golan does not understand it
301:16 - because it's coming as a json
301:20 - so this is why
301:21 - you have to tell
301:22 - golang that hey
301:24 - you understand id as string
301:27 - and this is what it's going to look like
301:28 - to you right id is going to be string
301:30 - and names interesting but in json it's
301:32 - going to look a little different so we
301:33 - just have to tell we just have to help
301:35 - uh just go like here and we have to say
301:37 - in json this is going to look like this
301:40 - man
301:42 - id and we'll also write omit empty for
301:45 - id
301:49 - and as you have may have worked with
301:52 - golang it also sorry with the mongodb it
301:54 - also needs pson for the id
301:57 - and this is how it represents id at the
301:59 - database level id
302:01 - comma
302:02 - format
302:06 - now when i i'll show you name also and
302:08 - then i'll explain the difference here
302:12 - okay
302:13 - so what's happening here is
302:15 - name
302:16 - is understood by postman is understood
302:18 - by your terminal when you uh or by the
302:20 - user when you send a girl request right
302:23 - name is understood as
302:25 - in json as name with small n
302:28 - whereas golang understands it as name
302:29 - with capital n and for column it's a
302:32 - string
302:33 - right but when it comes to id
302:36 - um the postman stands just as json id
302:39 - whereas mongodb stores us at as bson
302:43 - which is underscore id so this is why we
302:45 - have written bson again right for this
302:46 - for mongodb
302:48 - i hope that's
302:51 - understood
302:52 - and then you have your salary which is
302:55 - again json
302:56 - and your age
302:59 - which is
303:00 - agent json right so all of these fields
303:02 - they have small n small s small a
303:04 - whereas for golan to understand and go
303:06 - like to work with this information it
303:08 - will be capital n capital s capital a
303:10 - so now we want to start working with our
303:12 - main functions the main handler
303:13 - functions like get
303:16 - and post would delete
303:18 - all of these functions right and the
303:20 - route handlers
303:22 - so we'll start with get that means we
303:24 - want to get all the employees from our
303:25 - database to do that you need um like i
303:29 - told you golan does not understand json
303:31 - right and you'll get something from the
303:33 - database golang needs to understand it
303:35 - and go language to send a json response
303:38 - to the front end or to postman
303:40 - now to be able to work with that
303:42 - i need my
303:44 - a variable called employees
303:47 - and it's of
303:49 - type employee right so this is how you
303:50 - define a variable you say this is the
303:52 - variable name
303:53 - this is the type
303:54 - and you see these two brackets here that
303:56 - means it's a slice so it's okay if you
303:58 - don't know what slices slice is
303:59 - basically like an array but
304:02 - instead of containing just numbers it
304:03 - contains actual objects by objects you
304:06 - mean basically all of the things the
304:08 - multiple things that this
304:10 - area will contain will be
304:12 - an actual uh employee the whole employee
304:14 - right so this means that if you're
304:16 - coming from a javascript background this
304:17 - would mean that it's an array of
304:20 - multiple objects
304:22 - so now you initialize it using
304:24 - the make
304:26 - command
304:26 - [Music]
304:30 - and employee
304:38 - so um
304:40 - you've defined your
304:42 - employee variable right this will help
304:43 - you to work with the records that are
304:45 - fetched by the database from the
304:47 - database now to get something from the
304:49 - database you have to use um the find
304:51 - command that mongodb already has right
304:54 - so the find command you usually send a
304:56 - query
304:57 - in our case since we want all the
304:59 - employees from the database that means
305:00 - the query that we have to send is
305:02 - completely empty or just two empty
305:03 - brackets
305:04 - okay so we'll have to define the query
305:06 - here so query is equal to the sound dot
305:08 - t
305:10 - and inside these two curly braces you'll
305:11 - define the
305:13 - query usually in our case the query like
305:14 - i said are just two empty brackets
305:16 - because it's an empty query so this is
305:18 - uh the query basically so we've defined
305:19 - the query now
305:21 - you want to use the find function that
305:23 - mongodb will give you and inside that
305:25 - find you will pass query right the query
305:27 - that you've defined here but you'll also
305:28 - pass
305:30 - the context
305:33 - right so you'll pass e.context and
305:34 - you'll pass
305:36 - query here
305:38 - so i hope that's making sense
305:41 - now um
305:43 - this
305:45 - find function
305:46 - is available to you inside mongodb you
305:48 - know that already and how are we talking
305:51 - to mongodb in our program we're talking
305:53 - to it using the mongodb instance that we
305:56 - have defined here right the
305:57 - instance
305:58 - and the instance has something
306:00 - called as db so we want to uh target
306:02 - that instance and we want to talk
306:04 - to the database exact database inside
306:06 - that we want to talk to a collection
306:07 - collection is like a table so with
306:09 - mongodb you have collections and with an
306:11 - sql database like post like postgres or
306:13 - mysql you will have tables so if you're
306:15 - familiar with tables it's the same thing
306:17 - this is a collection so you want to go
306:18 - to that instance you want to go to the
306:20 - database and you want to go to the
306:22 - collection and then you want to
306:24 - basically uh run the find command
306:27 - that means you'll go to the instance mg
306:30 - dot you'll get the database
306:32 - inside mg right so it's mg and this
306:34 - database you've already defined the
306:36 - variable there already it's all be set
306:38 - and dot you want to get the collection
306:40 - so the collection
306:42 - so it's c capital and everything else is
306:45 - small collection is
306:48 - employees
306:50 - and you'll say dot find and you'll find
306:52 - the query
306:53 - and here what you get back
306:57 - is usually the cursor
306:58 - basically it'll have will have all the
307:01 - uh employees records
307:03 - or you'll get back the error
307:05 - so
307:06 - now you want to handle the error so
307:07 - you'll say error
307:11 - and for the error you want to return a
307:13 - status of
307:17 - 500 which is basically your internal
307:19 - server error
307:20 - you want to send a string which is your
307:23 - error string basically sending the
307:25 - entire error itself
307:27 - you've defined your employees already
307:30 - here
307:33 - okay one small mistake that i see here
307:35 - that i've made is that this bracket is
307:37 - not here it's actually here the closed
307:39 - bracket because it's a slice right it
307:41 - implies the slice this is how you find
307:42 - the slice
307:43 - there's two brackets and then employee
307:46 - all right now what you'll do is you'll
307:49 - use this cursor
307:52 - and here also i see one small mistake is
307:54 - that d is going to give you capital we
307:55 - will be small and now go language
307:57 - understand it so that's why the
307:58 - squiggly line
308:01 - quickly goes away
308:03 - all right
308:06 - so
308:08 - now what you want to do is you want to
308:09 - say
308:10 - cursor
308:12 - dot
308:13 - all
308:14 - c dot
308:15 - context
308:18 - comma
308:21 - ampersand employees
308:23 - when i say ampersand employees i'm
308:25 - basically passing a reference to this
308:26 - variable employees that i have
308:28 - sent
308:31 - and
308:32 - what's happening here really
308:34 - is basically whatever data we've
308:36 - received in our cursor right and from
308:38 - this function that you've done here
308:39 - cursor
308:41 - which is all the
308:42 - data of all the employees from the back
308:44 - end that has been received
308:46 - and this is going to basically convert
308:48 - that into
308:49 - a format into the structs that are
308:50 - understandable by coolant so that's why
308:53 - you pass these employees right so in in
308:55 - the end you'll get um employees
308:59 - right
309:00 - but that will be basically a slice of
309:02 - multiple different employees
309:04 - and we did this because
309:06 - gold line cannot understand json which
309:08 - mongodb understands and when mongodb
309:10 - sends some data from by running that
309:12 - find function you don't need to convert
309:14 - it into something that golang
309:16 - understands right and this is how you've
309:18 - done it
309:21 - so
309:23 - you'll say if
309:24 - error is equal to
309:28 - sorry in front of this you want to say
309:30 - if
309:32 - error
309:35 - and error is not equal
309:38 - and you want to return c dot status
309:42 - 500 dot
309:44 - send
309:45 - string
309:46 - error dot error
309:48 - right
309:50 - and here you wanna return
309:53 - if everything goes well you want to
309:54 - return
309:56 - the employees that you just
309:58 - you know now converted
310:01 - employees was that variable that you
310:02 - defined which was a slice of employee
310:04 - right that means multiple employees will
310:07 - be there
310:09 - and that basically is what you got from
310:11 - the database you converted into a nice
310:13 - uh you know understandable and
310:14 - understandable format and in json you
310:16 - sent it in json to as a response to the
310:19 - front end
310:21 - okay
310:22 - so i hope all of that makes sense now
310:24 - we'll move towards our post function
310:29 - so we'll make some space here for for
310:31 - post function we'll have our func
310:34 - and similarly this function will also
310:36 - accept
310:38 - a pointer to fiber dot ctx which gives
310:41 - us access to
310:43 - our
310:45 - response and request this is how we're
310:46 - able to talk uh use response request and
310:49 - it also does a little bit of marshalling
310:51 - and marshalling for us like here we did
310:52 - c dot json so it can do some mastering
310:55 - and marshalling for you by default
310:57 - it does take a lot of work away from you
310:59 - and gives you some abstraction
311:02 - so here you want to find your collection
311:04 - so we'll say collection
311:06 - is mongodb dot
311:08 - database dot
311:09 - collection
311:11 - and employees
311:12 - so instead of
311:14 - uh saying this again again
311:16 - mgb dot db dot correctional employees
311:19 - i've defined it and i can now use it in
311:21 - a variable called collection
311:23 - and i'll create an employee now um
311:27 - when creating
311:28 - something in a database right you have
311:30 - to use the insert function that mongodb
311:32 - will give you and also you will get just
311:34 - one employee that one employee data that
311:36 - you're getting from the postpan that as
311:38 - in the user will send the data of a new
311:40 - employee and that that new employee
311:42 - uh right variable is going to basically
311:45 - go to the database
311:47 - and this is how we'll define that
311:49 - employee
311:50 - variable
311:52 - is equal to
311:53 - mu
311:56 - so when we say this
311:58 - right um
312:01 - you can define it like this or you can
312:02 - say var
312:03 - employee and employee you can say like
312:05 - that or you can say implies equal to new
312:06 - employee
312:07 - all that's doing is that it's defining a
312:09 - variable employee
312:11 - which is of type
312:12 - employee you know the employee structure
312:14 - that you want to define which has id
312:15 - name salary image
312:18 - right
312:19 - so now you have defined your employee as
312:20 - well
312:21 - and what you'll do now is um you'll get
312:24 - some data in the request you'll get the
312:26 - data of an actual employee as in the
312:29 - user wants to add a new employee so
312:30 - you'll send a new employee data like
312:32 - name
312:33 - and all those different things
312:35 - uh your name and salary and age
312:38 - to
312:39 - this api
312:41 - and this api
312:42 - needs to now read that information and
312:44 - it does that using
312:46 - c which is basically your fiber context
312:48 - dot body parser so you'll say worry
312:51 - parser
312:53 - and when you say
312:55 - employee here
312:57 - that means all that data basically
313:00 - becomes formatted in the format that you
313:02 - need and you get it into this variable
313:03 - called employee
313:05 - right so it basically passes the body
313:07 - which is json you're sending from json
313:09 - into post from postman to this guru lang
313:11 - program into struct
313:13 - that golang now understands
313:17 - and after you've done that you want to
313:19 - handle the error so you'll say error is
313:20 - equal to c dot
313:23 - body parts are implied
313:25 - and if error is not equal to nil
313:31 - uh there can't be any space between
313:33 - exclamation mark and is equal to
313:35 - and here you return
313:36 - c dot status
313:40 - 400 dot
313:43 - send
313:44 - string error dot
313:46 - error
313:49 - okay
313:51 - now we always want mongodb to create its
313:53 - own ids and this is why what we'll do in
313:55 - the beginning is we'll say
313:57 - employee dot id
314:00 - equals zero this force is mongodb
314:01 - creates one id
314:03 - and now i want to take this collection
314:05 - that you have defined here
314:07 - so it's good that if i define this as a
314:09 - variable because i can now start keep
314:10 - using it i don't have to always write
314:12 - this again again so i'll say collection
314:14 - dot
314:15 - insert one now insert one is a function
314:18 - that i get with mongodb so if you're
314:19 - familiar with mongodb and the functions
314:21 - that you get mongodb it's really easy to
314:22 - understand you can insert one insert one
314:24 - basically takes data and inserts that
314:26 - into a database just one data
314:30 - into that insert one function you'll
314:31 - pass c dot context
314:35 - comma
314:37 - employee
314:38 - so you received some data
314:40 - in the body you used body parser to
314:43 - convert that into employee which is your
314:45 - employee struct and that employee stack
314:46 - basically is your is what you're sending
314:48 - to the insert one function
314:50 - along with the context
314:52 - and
314:53 - whatever i get back from this function
314:55 - after inserting right i'll keep that in
314:58 - a variable called
315:00 - insertion result
315:06 - and also an error so if the the error is
315:09 - there then i'll handle the error if
315:11 - error is not equal
315:12 - that is
315:14 - return c dot status
315:18 - 500 dot
315:20 - send string
315:22 - error dot
315:24 - error
315:26 - spreading the return is wrong
315:29 - now after it gets inserted it will come
315:31 - in this variable called insertion result
315:32 - while you'll get an error and this error
315:34 - will handle it right now itself and we
315:37 - want to do something with this insertion
315:38 - result
315:40 - what we're going to do is we want to um
315:42 - get the id from this insertion result
315:45 - that you get right then this id we'll
315:47 - use that to search the actual record
315:50 - uh that has just been inserted in the
315:51 - database and then after finding that
315:53 - record we want to return that to the
315:55 - front end okay and this makes us doubly
315:57 - sure
315:58 - that whatever we
316:00 - did the post request for right now it
316:02 - was inserted into the database and we
316:04 - can make it make that short by actually
316:06 - going and searching for that record
316:08 - using the id and then sending that
316:10 - record and this makes it very sure that
316:12 - uh this data was actually inserted in
316:14 - the database make sure yeah that makes
316:16 - sense all right so um
316:18 - here first i'll handle the error okay
316:21 - quickly
316:21 - so if
316:23 - error is not
316:27 - i'll give some space here
316:29 - then you wanna do something you wanna
316:30 - return
316:32 - c dot
316:34 - status
316:36 - 500 dot
316:38 - send
316:41 - string
316:42 - and error dot
316:44 - error
316:47 - all right now like i said you know we
316:49 - want to take the insertion result which
316:51 - is insertion result and we want to get
316:57 - we want to we want its id right so we
316:59 - want the inserted
317:01 - id
317:04 - and using this id we'll create a query
317:06 - and then we'll find the
317:08 - record that has this id
317:10 - to check if
317:11 - what we just inserted right now using
317:13 - insert one was actually inserted in the
317:15 - database or not okay
317:17 - and
317:19 - so let's say value
317:23 - is equal to insertion result inserted id
317:30 - and
317:32 - basically we're building up a query
317:33 - right
317:34 - so the key is id
317:38 - and for that key which is id
317:40 - the value is this inserted id that you
317:42 - just received
317:44 - and close it with
317:46 - inside another pair of curly brackets
317:53 - and say
317:56 - filter
317:57 - is equal to this one dot t
318:03 - just like you had created a query here
318:06 - for get
318:07 - which was um
318:10 - bs on the d and it was the query was
318:12 - empty right
318:14 - now you have vsan.d
318:16 - it's called sorry it's called filter not
318:17 - filler filter and based on these and the
318:20 - query has key which is id
318:22 - and the value of id is basically in
318:24 - session result that you just receive
318:26 - right now and the inserted id of that
318:30 - and you want to get the created record
318:34 - that you just created how do you get it
318:36 - you use collection dot
318:38 - find one
318:40 - and you pass c dot context to it
318:43 - and you pass this filter query that you
318:46 - just created
318:47 - you pass it there
318:49 - and that's how you get the created
318:50 - record so i'll repeat again
318:53 - you uh inserted the employee
318:56 - data that we just sent using postman
318:59 - then complete empire data and you used
319:01 - insert one
319:02 - query to insert that data of employee
319:05 - and you got that uh you know whatever
319:08 - you got back from this function was
319:10 - stored in insertion result
319:13 - and that insertion result also has a
319:16 - variable called inserted id which
319:17 - basically has the id of the data that
319:19 - just got inserted and you keep that um
319:23 - you know to to build a query and you
319:25 - keep that in this variable called filter
319:28 - and this filter is basically what you
319:29 - send to find one function and we're just
319:31 - rechecking that
319:33 - this data was created and then you get
319:35 - that into this
319:37 - variable called created record so this
319:39 - is the record that was just created
319:40 - right now by you and this is what you
319:42 - want to send
319:44 - to the front end
319:47 - so you will
319:49 - create
319:50 - a variable called created employee
319:54 - now want to structure and format that
319:56 - data right so you
319:57 - say
320:02 - that created employee is a variable
320:04 - of type
320:05 - employee
320:06 - which is your own struct
320:08 - right so created employee will have id
320:10 - name salary
320:12 - type employee
320:14 - and you want to do you want to say
320:15 - created
320:17 - record
320:18 - dot decode
320:20 - and you want to decode the created
320:22 - employee
320:25 - okay we are doing this decoding because
320:27 - as you know go line does not understand
320:29 - json
320:30 - so we have decoded that into a created
320:32 - empire
320:33 - right the whole json that we just
320:35 - received from mongodb
320:36 - and now you want to send that json
320:39 - as response to the front end so you'll
320:41 - say return
320:43 - c dot status 201
320:46 - dot json by the way 200 201 203 400 500
320:50 - these are standard uh
320:53 - you know statuses uh http statuses
320:56 - you can read more about them in case you
320:58 - don't know which status is used when
321:01 - so you'll send the graded employee
321:04 - make sense
321:06 - now um
321:09 - i've actually used insertion result here
321:11 - so
321:14 - let me make sure if this is the same
321:15 - spelling i've used here
321:19 - here's the scenes wearing
321:22 - now uh a lot of these packages have
321:23 - these quick lines so what i need to do
321:25 - obviously is i need to say
321:28 - so it gets all those mongodb and
321:30 - driver options since i have not done
321:32 - that for quite some time now
321:34 - and if i go ahead and save it
321:37 - it removes one package on which package
321:39 - it did remove
321:43 - any let me actually
321:46 - um
321:49 - so yeah just save it actually for now
321:51 - and you can see that all the issues have
321:53 - gone away right we don't have any issues
321:55 - now
321:57 - now we want to work on our
321:59 - uh put function but let me first check
322:01 - if everything looks fine with
322:03 - the post function if there's no
322:05 - big thing that we're missing as of now
322:08 - yeah everything seems to be all right
322:10 - so now we want to work on our put
322:11 - function put is basically your update
322:14 - and then you have at the end you have
322:16 - delete so i'll just create some space
322:17 - here just for some
322:20 - you know uh
322:21 - clarity
322:23 - and here
322:25 - as soon as somebody hits this
322:27 - route you want to call a function you
322:28 - want to call the function and this
322:29 - function
322:30 - is going to take c which is of type
322:33 - fiber dot
322:34 - cdx
322:36 - returns an error
322:41 - yeah
322:43 - now the thing with ids is that
322:47 - you get them very easily you can access
322:50 - them pretty easily
322:51 - using the c which is the context c dot
322:56 - params so the parents will have the
322:59 - parameter which is id that you just
323:00 - passed
323:02 - and i'll capture this in a variable
323:04 - called id param
323:09 - and also
323:11 - i will create it uh
323:13 - from hex so i'll say primitive
323:15 - the primitive package that we're using
323:17 - let's say object
323:19 - id
323:21 - from x
323:23 - id parent
323:29 - and i'll store that in employee id
323:31 - variable
323:32 - [Music]
323:34 - or we'll get an error so either it'll
323:36 - get converted or we'll get an error so
323:38 - it's giving us quickly line for
323:39 - primitive that means
323:41 - yeah so that means
323:42 - when i saved it last time i did remove
323:44 - the primitive
323:46 - package here
323:48 - so i'll copy this paste it here
323:51 - and i'll stay slash
324:01 - all right
324:03 - showing me three
324:05 - issues in the file
324:07 - i know there are two issues from here
324:08 - because these two we have defined but we
324:10 - have not
324:11 - yet
324:13 - used
324:15 - anyhow
324:16 - so now we'll we'll go forward we'll
324:19 - handle this error that we might receive
324:20 - here so if error
324:24 - is more equal to nil
324:26 - you want to return c dot
324:28 - send
324:29 - status
324:31 - 400
324:33 - okay
324:35 - and just like you did with post right so
324:37 - update apis are usually very similar to
324:39 - the post apis so just like you defined a
324:42 - variable called employee and it was of
324:44 - type struct which is employee start
324:46 - similarly we'll have it here right and
324:48 - similarly the data you need to get from
324:50 - the body parser and you want to get it
324:52 - into this variable called employee
324:54 - so very similar so you will define a
324:56 - variable called employees of type
324:59 - employee
325:00 - and
325:02 - you can define a variable like like i
325:03 - said you know where employee employee or
325:06 - you can just say is equal to new implied
325:08 - there's two ways to define a variable in
325:09 - golang
325:10 - many more but uh these two are the most
325:13 - most widely used
325:14 - so here you'll say c dot body parser
325:19 - and employee just like you did in the
325:20 - post api
325:22 - and you'll handle the error here
325:24 - error
325:27 - not three are ours just two hours if
325:29 - error is equal to
325:30 - less than error or equal to nil
325:34 - then you'll return c dot status
325:38 - 400 dot
325:40 - send
325:41 - string
325:42 - err dot
325:44 - header
325:50 - now i'm going to start building up the
325:51 - query okay
325:53 - so because uh why do we want to build
325:55 - the query because uh the id that we've
325:57 - just received in this api right from the
326:00 - request
326:01 - for that id we need to find the exact
326:03 - record in the database and then with
326:05 - this new data that we've received to
326:07 - update we want to update or replace that
326:09 - data with this new data make sense so
326:11 - first we need to find the data for that
326:13 - id how do you do that you create a query
326:18 - you say based on d
326:21 - and you'll say key
326:23 - is
326:25 - underscore id
326:27 - comma
326:28 - value
326:31 - is
326:33 - employee
326:34 - id
326:36 - that you just defined out here
326:39 - okay
326:41 - then
326:42 - you'll say bsn.d
326:50 - and now what you want to do is you want
326:51 - to build the update quit
326:55 - how do you build the update query
326:57 - you uh want to have so when you do an
327:00 - update query right you have to have
327:00 - dollars set as in set this new data for
327:04 - instead of the old data
327:05 - so in case you already are familiar with
327:08 - mongodb will be very easy for you to
327:10 - understand if you're new to mongodb just
327:11 - remember that dollar set is the operator
327:14 - that you have to use inside mongodb to
327:16 - set this data
327:17 - for the data that you are replacing
327:20 - so this is how it's going to look like
327:22 - it's going to be sunday inside that
327:24 - you'll have a key
327:27 - and the key will be dollar set like i
327:29 - just mentioned
327:32 - comma
327:33 - there will be a value for that and the
327:35 - value
327:36 - is defined like this this one dot
327:39 - d
327:41 - inside that you have three things you
327:43 - have three things inside here
327:47 - a few things about the three
327:50 - fields to it one is the name
327:53 - comma
327:54 - value
327:55 - employee dot
327:57 - name
327:59 - and here you'll have key
328:02 - h comma
328:04 - value
328:07 - and employee dot
328:09 - h
328:11 - then you have
328:13 - k
328:16 - salary
328:18 - comma value
328:21 - employee dot
328:23 - salary
328:25 - makes sense
328:26 - here you'll just put a comma here and
328:28 - then here also you put a comma
328:31 - so now that you've built this query you
328:33 - to
328:34 - capture this and read it in this
328:36 - variable called update
328:39 - now you can see all the squiggling score
328:41 - went away quickly
328:44 - and you want to write the
328:47 - update function
328:49 - so the function update function that you
328:50 - get with mongodb is called find one and
328:52 - update so let's say find
328:55 - one and
328:56 - update
328:58 - you pass c dot context in
329:01 - you pass the query
329:05 - and when i say query i mean this query
329:07 - that i just created with the id so you
329:09 - find that video with the id and the
329:12 - update basically is the query where you
329:14 - set
329:15 - the new data for that particular id
329:17 - right so you pass query and you pass
329:19 - update both of these things
329:22 - you say dot
329:23 - err here
329:25 - and where you want to run this you want
329:26 - to run this very similar
329:28 - to what you've done before right
329:30 - you want to run this query in the
329:32 - instance like this the instance that you
329:34 - have
329:36 - right among instance which is mg
329:38 - dot database dot um collection just like
329:42 - you did here with your app.get right
329:44 - so the same thing you want to write here
329:45 - you want to say mg
329:47 - dot
329:49 - tv dot
329:52 - collection
329:55 - inside that collection will say
329:59 - employees
330:00 - [Applause]
330:02 - right
330:04 - and error is equal to
330:06 - all of this
330:08 - now you'll handle the error so guys i
330:10 - just need some
330:11 - uh energy drink because i'm getting
330:16 - you know it's a long video
330:18 - if you don't mind
330:21 - all right
330:23 - so if error is not equal to nil
330:30 - that means that
330:32 - the filter did not match any documents
330:34 - so you want to say if error
330:37 - is equal to dot
330:40 - there are no documents
330:45 - right
330:46 - so there's an error and an error
330:49 - is that mongodb does not have those
330:50 - documents
330:52 - then you're going to return
330:54 - c dot
330:56 - send status
330:58 - 400. so 400 status you mean you know
331:01 - it's for not found that means whatever
331:03 - id that you're trying to find and
331:05 - replace the data for it does not even
331:06 - exist so
331:08 - there's something wrong so that's what
331:10 - you'll do otherwise
331:11 - if there's a regular normal error then
331:13 - you just want to return
331:18 - [Applause]
331:21 - 500
331:24 - all right
331:28 - and uh you want to set the employee id
331:30 - so inside employee
331:31 - dot
331:33 - id is equal to id
331:36 - param
331:37 - and
331:38 - uh if everything has gone well
331:40 - you want to send 200 saying everything
331:43 - is okay you want to send the employee so
331:46 - let's say return
331:47 - c dot
331:48 - status 200 dot json
331:53 - and employee
331:56 - cool
331:57 - now the only function that's that we're
331:58 - left with is
332:00 - uh the app.delete function
332:04 - but you may have realized that till now
332:06 - we have not actually started our server
332:08 - right we've not done anything to start
332:10 - our server
332:11 - so to start our server we'll just have
332:13 - to do just this app.listen
332:17 - on port 3000
332:21 - and if there's an error you want to
332:22 - enclose this
332:25 - whole thing and you want to say
332:26 - log.fatal
332:28 - so if the star server does not start you
332:30 - do some issue like the port is already
332:32 - taken or there's some other issue
332:34 - we'll just basically be able to log out
332:35 - that fatal error
332:38 - now you want to start building the
332:40 - delete function
332:43 - the process is very similar you want to
332:49 - as soon as somebody hits this
332:51 - route
332:52 - or api you want to call this function
332:55 - which accepts c
332:58 - you'll have fiber dot
333:02 - ctx
333:04 - and it returns an error
333:07 - inside that you'll have
333:09 - now you obviously want access to the id
333:11 - right which
333:13 - is inside parents so it says c dot
333:16 - params
333:19 - inside that you have your id
333:23 - and you want to enclose this whole thing
333:31 - into
333:34 - object
333:36 - id
333:38 - from hex
333:40 - and let's say
333:43 - bring the dot
333:46 - so instead of doing those those two
333:47 - steps that we did earlier like perimeter
333:49 - object id from hex id param and then
333:52 - doing this we have done both of those
333:53 - things in just one step so if i did this
333:55 - earlier in one step you would have been
333:57 - confused
333:58 - so this is why i showed you
334:00 - how to do it in two steps and now how
334:02 - you can do it in actually just
334:05 - one step
334:06 - and you get access to employee id
334:09 - directly
334:10 - this means
334:12 - you don't have to do all this
334:14 - part with id param and then employee
334:16 - right you directly got access to
334:18 - the employee id
334:22 - anyhow
334:25 - now you can handle this error so you'll
334:27 - say if
334:28 - error is not equal to
334:31 - you'll return c dot
334:33 - send status
334:36 - 400.
334:40 - that means that probably the id that you
334:42 - got here is not valid so that's why
334:46 - we'll say it's not found 400.
334:50 - now uh what you want to do is you want
334:51 - to find the record with that id and you
334:54 - want to delete that record
334:56 - okay how do you do that
334:57 - you will first have to always like
334:59 - you've been doing till now you have to
335:00 - build a query because mongodb
335:02 - understands queries
335:04 - and the queries are in psalm format
335:07 - and this is what the query looks like it
335:09 - has a key
335:10 - and this key
335:12 - we're going to pass the id
335:14 - has a value
335:16 - and the value is
335:19 - employee id
335:22 - okay so it has a keyhander
335:24 - value
335:27 - and i've put a
335:29 - double quote here by mistake so that's
335:30 - why everything looks off
335:32 - you know it's kind of fixed
335:34 - and now i want to do the same thing i
335:35 - want to
335:36 - call the delete
335:38 - one function but where how do i get
335:40 - access to the defunct function i have to
335:42 - access the
335:44 - instance
335:45 - i'll have to access the database i'd
335:46 - have to access my
335:50 - collection
335:54 - the collection is called
335:57 - employees
335:59 - and inside delete one you're going to
336:01 - pass
336:04 - context
336:06 - comma
336:08 - ampersand
336:09 - query
336:12 - just make sure the spelling of context
336:13 - is correct
336:19 - and whatever you get back from this
336:23 - right from running this query
336:25 - whenever we get back you stored in
336:28 - result
336:30 - or you get back an error
336:33 - and you can handle the error now if
336:35 - error is not equal to nil
336:39 - then you return
336:43 - status um
336:46 - service
336:47 - internal server editor so let's say
336:48 - return
336:50 - c dot send status
336:53 - [Music]
336:56 - 500 and
336:58 - [Music]
337:00 - if the result is dot
337:02 - deleted
337:06 - the count is less than one
337:08 - so that means if it didn't get deleted
337:10 - then you want to return c dot
337:12 - send
337:13 - status
337:15 - folder for not found
337:20 - yeah so
337:22 - gonna say you wanna say that's basically
337:24 - not found okay
337:25 - uh if uh
337:27 - nothing got deleted or if the related
337:29 - count is less than one so obviously that
337:31 - means there was no
337:33 - um
337:34 - record like that
337:35 - i think uh earlier by mistake i said did
337:38 - i say somewhere that 400 is for not
337:40 - found sorry uh my bad it's actually 404
337:42 - uh that's not found i got confused for
337:45 - 400
337:46 - here's your other type of server error
337:49 - all right and here now if
337:53 - the record gets deleted so you want to
337:55 - say
337:56 - c dot status
337:58 - 200 dot
338:00 - json
338:02 - record
338:03 - deleted
338:06 - okay
338:08 - and that's your entire delete function
338:11 - so in about 16
338:14 - 8 169 lines you are able to write the
338:16 - entire program
338:19 - things look good to me and now i think
338:20 - we should start um
338:23 - testing it out and start seeing if
338:24 - everything works all right
338:26 - so what you want to do now is you want
338:28 - to head over to your terminal
338:30 - not this one sorry
338:32 - this one
338:34 - and you want to say
338:36 - go
338:37 - build
338:40 - main dot code
338:45 - now what happens is
338:47 - you see this main.exe file right so and
338:49 - since i'm using windows it creates a dot
338:51 - exe file for me which is an executable
338:53 - file and uh that's what build does it
338:56 - creates a build builds a exe file for
338:58 - you
339:00 - and what you want to do is you want to
339:01 - now run this program which is recorded
339:05 - let's see if it works
339:10 - okay so we get some
339:13 - uh issue here
339:14 - so let's try and fix things fixing it
339:17 - so we've received this error right and
339:19 - what do you make of this it says there's
339:21 - something to do with
339:23 - mango driver mongodb client
339:26 - right so it's quite apparent that
339:27 - something has gone wrong with
339:30 - and if i go to my code
339:33 - and i see that the drivers look fine to
339:35 - me
339:36 - and i know the code that i've written is
339:38 - quite all right
339:39 - and the only mistake that i see right
339:41 - now
339:42 - is with obviously is that i've not
339:44 - put a slash here at the end and maybe
339:46 - when it's trying to add this with the
339:48 - database name uh the whole thing is kind
339:50 - of fading maybe right that's my
339:52 - hypothesis
339:53 - and i save it and i run it again
339:57 - and i'll have to build it obviously
339:59 - first
340:02 - and then i'll run it again
340:04 - if you don't build it sometimes it runs
340:05 - the old
340:06 - uh executable file so just build it and
340:09 - now i can see that it's running the
340:11 - program so that was the mistake right so
340:14 - uh with golang you don't have to be a
340:16 - genius to
340:17 - solve errors so that's why
340:20 - i am very comfortable writing a lot of
340:22 - code and not testing it again again with
340:24 - other languages right you have seen
340:26 - other like instructors they have to keep
340:30 - showing you how just build a small part
340:31 - of the code and then they test and check
340:33 - check it out if it's working or not
340:35 - with golang you don't have to do it just
340:37 - write everything
340:38 - all at once and then
340:40 - easily you can debug it you don't have
340:41 - to be a genius we will tell you the
340:43 - exact issue where the issue is right
340:46 - anyhow so it says uh fiber is working on
340:49 - port 3000
340:51 - there are five handlers processors is
340:52 - one pids to one three zero
340:55 - all right so now you head over to your
340:56 - postman and you
340:59 - come here i've created a collection set
341:01 - of collections so get all employees
341:02 - which is basically
341:04 - localhost
341:05 - 3000 slash employee
341:07 - and i get all the employees i that i
341:09 - have
341:10 - and right now it's saying that i have
341:12 - zero employees right it's an empty added
341:14 - obviously we have uh no employees that
341:16 - means i'll start creating employees so
341:18 - firstly i'll create an employee caller
341:21 - that's created so it's created it for me
341:24 - i'll create another employee
341:27 - called rupert
341:32 - uh now i see that there's another issue
341:34 - there's a duplicate key error issue okay
341:38 - so this means there's something wrong
341:39 - happening with our id and i kind of
341:41 - suspected that when i was reading
341:44 - it didn't send didn't show me an id that
341:46 - means there was something wrong there as
341:48 - well so now let me try and fix this id
341:50 - issue back in our code
341:54 - in the post function
341:55 - everything looks all right to me
341:58 - that means there could be some issue
341:59 - here yes now i see the issue there's
342:02 - just one small space between id and omit
342:06 - empty so let's remove that
342:08 - and now i think it'll work because this
342:10 - format that i had gone for it
342:13 - probably
342:14 - mongodb did not understand it
342:17 - so let's
342:19 - cancel our process
342:22 - buildmain.gov
342:24 - and runway.go
342:29 - and now i'll allow access on my firewall
342:34 - and so let's
342:36 - try adding some employees let's try
342:38 - adding
342:40 - robert
342:43 - cool you get an id here now
342:45 - and you add
342:48 - alex
342:50 - right so you're getting these ids here
342:52 - you get all employees
342:56 - and you'll see so many employees right
342:58 - now what you'll do is you want to edit
343:00 - an employee so let's edit rupert so i'll
343:04 - take this id go to edit employee
343:07 - just see that it's local 3000 slash
343:09 - employee slash the id of the employee so
343:11 - the id of the employees are what i want
343:12 - to replace
343:14 - and i wanna and i can send any data here
343:16 - that i want
343:17 - i'll change his name to
343:18 - peter
343:21 - when i do that rupert's name has been
343:22 - changed to peter so if i get all
343:24 - employees
343:26 - that second rupert has been competed but
343:28 - this first and third rupert are always
343:30 - still there but the second rupert has
343:31 - now become peter okay
343:34 - you want to delete an employee now so
343:36 - you just copy and paste his id again for
343:38 - delete employee
343:41 - when you paste it here
343:42 - send record deleted
343:44 - now when you get all employees you'll
343:45 - see that peter is not there so the first
343:47 - rupert is there second looper is there
343:49 - and peter can't be found so you can see
343:51 - that right the issue that we were having
343:52 - earlier was that id was not being
343:54 - generated for the first record
343:57 - and if i was trying to add more records
343:59 - i was saying that that same idea already
344:00 - exists so it's an error for mongodb but
344:03 - now the ids are being generated because
344:04 - i removed that small space so all the
344:07 - apis are working perfectly here's your
344:09 - little
344:10 - human resource management system you can
344:12 - create employees delete uh and updated
344:14 - employees you have learned how to work
344:16 - with go fiber which is a very nice
344:18 - library learn how to
344:20 - uh connect a program which uses go fiber
344:23 - with mongodb
344:25 - it's a complete serverless stack
344:27 - right so you're using dynamodb
344:29 - serverless you're using lambda
344:31 - serverless again
344:33 - and then we'll be using api gateway
344:34 - again serverless now api gateway helps
344:36 - us uh enables anybody across the world
344:39 - to interact with our lambda function
344:41 - right so we'll be deploying all these
344:43 - three things
344:44 - uh from the aws console right we'll be
344:47 - using the aws console and then we'll
344:48 - make settings for all these three things
344:50 - and we'll deploy all of this
344:51 - and anybody across the world can use our
344:54 - lambda function so this is more like a
344:56 - real world scenario
344:58 - so i'm in my terminal now and you don't
345:01 - really have to keep this project in your
345:03 - go root because since golang 1.12
345:06 - anyways they had you know go mod in it
345:08 - which we're going to do anyways out here
345:09 - go modern it takes care of everything i
345:11 - mean you don't have to really uh do
345:13 - anything manually all right so here
345:15 - we'll say
345:16 - we will make a directory first we'll say
345:19 - go
345:20 - serverless
345:21 - and yt all right and we'll see into this
345:24 - go serverless stack yt for yt is
345:27 - basically youtube i'm making this
345:28 - project for youtube specifically all
345:30 - right and here i'll say
345:32 - um
345:33 - go mod in it
345:35 - and which is basically github
345:38 - dot com
345:39 - slash akil
345:41 - slash go
345:43 - serverless yt
345:45 - so that's my project it's initialized go
345:47 - mod for me go mod is basically like my
345:49 - package.json file if you're from a
345:51 - javascript background it'll have all my
345:53 - dependencies for me you know easily
345:55 - listed out
345:56 - so
345:57 - um
345:59 - now what i can do is i can just open
346:01 - this project up and
346:05 - code editor which is vs code in my case
346:07 - um just as a pointer
346:09 - right i'm using
346:11 - windows inside windows i'm i have
346:13 - something called as wsl inside that i'm
346:15 - using ubuntu 20.04 and i use multiple
346:18 - different versions of ubuntu right and
346:20 - this for this particular video i'm using
346:22 - ubuntu 20.04 and in my ubuntu 20.04 uh
346:26 - instance i have vs code set up all right
346:29 - now uh i don't want to install a lot of
346:33 - extensions uh for golang because i know
346:35 - when i'll start typing uh i'll start
346:37 - writing a lot of code i'll make some
346:39 - mistakes right with golang i'll make
346:41 - some mistakes but i will fix them so
346:43 - don't worry i don't have extensions
346:44 - because i don't want to like start uh
346:46 - you know ballooning up my instance
346:49 - because this is just one of the
346:50 - instances that i use uh on my windows pc
346:52 - for ubuntu i have
346:54 - like 10 15 different versions of ubuntu
346:55 - right
346:57 - so
346:58 - uh if you new to golang by the way
347:00 - main.go file is your main
347:02 - file right in the project
347:04 - and this is how you start domain.go file
347:05 - you say package main and you say import
347:08 - and because you'll import some packages
347:09 - right not everything you'll have
347:12 - inside golang golang is very modular uh
347:14 - you have to install a lot of external
347:16 - packages and a lot of uh you know
347:17 - packages that come with golang you have
347:19 - to specifically tell that you know i
347:20 - need this package from coolant
347:23 - and uh so the
347:25 - the third party packages that we'll be
347:26 - using will be mostly around
347:29 - lambda all right so we'll talk about
347:31 - them in a while
347:32 - and then uh
347:34 - the most important thing here will
347:36 - always be funk main because that's your
347:38 - entry point into the program right the
347:40 - funk main uh now before i start writing
347:43 - anything in main.go file what i'll do is
347:45 - i'll just try and create
347:47 - like a very simple
347:49 - project structure
347:50 - i need the build folder right because
347:52 - i'm going to keep my build of this
347:54 - entire project in my build folder and
347:55 - that's i'm going to zip it up and then
347:57 - i'm going to keep take that zip file to
347:59 - my lambda uh sorry my aws lambda console
348:02 - all right so that's why i need the build
348:03 - folder
348:04 - and i need my cmd folder because that's
348:07 - where i usually keep my main dot go
348:09 - sorry not in the
348:11 - build but in my cmd folder i use keep my
348:13 - main.co file
348:16 - all right
348:16 - and then you'll have a package folder
348:20 - so uh if you've worked with golang
348:22 - before this is like the very standard
348:23 - kind of uh
348:24 - structure right nothing nothing new so
348:26 - package will as you already know will
348:28 - have handlers
348:30 - right handlers to handle the apis
348:32 - and then you will have i'll have a
348:35 - folder for user
348:37 - i'll explain to you why i'm doing that
348:39 - and then i'll have a very simple
348:40 - validation function so i'll keep that in
348:44 - a folder called validator write daters
348:46 - sorry
348:47 - uh that's it yeah so in validators i
348:51 - will have just one little file
348:54 - of badly like
348:56 - five six lines of code i think
348:57 - it's just going to be as email valid
348:59 - just to check if my email is valid for
349:01 - the user
349:02 - and here in my user
349:05 - i'll have a file called user.go
349:08 - all right and my handlers that's where
349:11 - my main logic resides so this is a very
349:13 - short very small project handlers i'll
349:15 - just have two files i'll have
349:17 - api response dot go because i need this
349:20 - uh
349:21 - file for uh my api gateway i'll build it
349:25 - you'll understand what it is
349:27 - and then it's handlers.go
349:31 - right
349:32 - now my user.go file
349:34 - is kind of
349:35 - a combination of my models
349:38 - and my
349:40 - almost like my controllers as well you
349:43 - know so i have handlers uh but you know
349:45 - user.go file will have a lot of code
349:48 - which kind of which talks to my database
349:50 - all right directly talks to my database
349:52 - so i'll have those models like those
349:53 - structs as well at the same time i'll
349:55 - have model functions uh those uh sorry
349:57 - database functions at the same time i'll
349:59 - head over to your main.co file in funk
350:02 - main i think what i'll do is
350:05 - i'll start with this place right i'll
350:07 - say os dot
350:10 - get environment
350:13 - pws region so aws region is very
350:15 - important because that's where your uh
350:18 - lambda will go and sit right so with aws
350:21 - if if you've worked with aws a lot you
350:23 - know that it has different regions right
350:25 - so my particular aws is configured with
350:28 - india which is asia pacific south once
350:29 - uh if you have uh been using cli and
350:32 - it's set up it's uh it'll be amazing uh
350:34 - otherwise also i don't think you should
350:36 - have a problem
350:37 - right
350:38 - but just try and
350:39 - uh just try and set up awcli it's very
350:41 - easy it's just a five minute process and
350:43 - it will be very simple for you to follow
350:44 - along with all of my other videos as
350:46 - well because uh in my other videos it's
350:48 - a prerequisite
350:50 - so um
350:51 - how do you create a session
350:54 - so you'll say session dot new session
351:00 - now
351:01 - if i'm calling this os
351:03 - here right so i need to have os here
351:05 - that's the package right and if i'm
351:07 - calling session here session is
351:09 - something that aws lambda gives me aws
351:12 - gives me sorry so i'll say github dot
351:14 - com
351:15 - slash now i'm looking at the
351:16 - documentation for the aws packages at
351:18 - the same time you can do that otherwise
351:21 - in case you're you're the type of person
351:23 - who wants to like know uh exactly which
351:25 - package you are installing because i am
351:27 - that type of person i don't want to
351:28 - install any extra packages right so if
351:31 - you like me you you might want to open
351:32 - up um just like i've done you might want
351:35 - to open up the
351:37 - aws sdk it's called so i'll say aws aws
351:41 - sdk for go you want to you want to open
351:44 - up the documentation and here you'll see
351:46 - it will be slash session
351:50 - all right
351:51 - and to create the new session
351:54 - you'll see
351:56 - aws dot
351:58 - config
352:03 - and the bracket
352:05 - which will be curly braces bracket
352:08 - you'll say region
352:10 - aws dot
352:13 - string
352:15 - inside that you'll pass the region
352:20 - all right
352:29 - all right
352:32 - and then
352:33 - as you know with all everything to do
352:35 - with golang whenever we haven't
352:37 - uh we get two things usually right we
352:39 - get the thing that we're looking for
352:40 - which is the aws session which will come
352:42 - from the session function
352:44 - right sorry the new session function
352:46 - which is a part of the session
352:48 - package that we have here
352:50 - and
352:51 - we get the error so
352:53 - with golang you have to like keep
352:55 - handling errors and this is a very neat
352:58 - and clean way of handling errors because
353:00 - at every stage you know where there is
353:02 - coming from and you can handle it there
353:03 - itself
353:04 - so if there's an error just return all
353:06 - right
353:07 - and i want to create a variable called
353:10 - dynaclient which for my dynamodb
353:13 - and
353:17 - dot new
353:19 - and
353:20 - uh how do you create a new client you'll
353:21 - say aws session
353:24 - perfect which you've just created out
353:26 - here
353:27 - so you've created the session and then
353:30 - you'll say lambda.start
353:33 - and handler
353:36 - so this you may not understand right now
353:38 - not a problem
353:40 - so firstly we want dynamodb how do you
353:43 - get dynamodb you get it like this it'll
353:46 - say github.com
353:47 - aws slash aws
353:50 - sdk go slash service slash
353:54 - dynamo
353:56 - db
353:59 - all right
354:01 - so you have session you have dynamodb
354:03 - and
354:05 - you want aws itself in the first place
354:07 - so you'll say github.com
354:11 - slash aws
354:13 - sdk go slash eight plus
354:18 - to get this lambda function
354:23 - uh sorry the lambda package which has
354:25 - the start function
354:27 - you need the start function
354:29 - what you'll do is you'll say github
354:32 - dot com
354:33 - slash aws aws
354:36 - lambda go slash
354:40 - lambda cool
354:44 - so far so good that's what i needed you
354:46 - know
354:48 - and
354:50 - i need something called as the handler
354:53 - which we'll talk about in a while
354:57 - okay
354:58 - for now
355:00 - i am creating a constant
355:04 - called table name
355:06 - stable name is
355:09 - lambda user
355:10 - i'll say lambda in
355:12 - go user
355:16 - and
355:18 - now it's time to create my handler which
355:20 - is this basically
355:22 - so i'm passing my handler there
355:24 - in my handler what i'm doing is
355:27 - i have a request
355:30 - basically i accept some things right in
355:32 - this function and i turn some things and
355:35 - it has
355:36 - some
355:36 - definition so what does it accept except
355:39 - accepts events dot
355:41 - api
355:43 - gateway
355:45 - proxy
355:53 - request so you're wondering what's
355:55 - events right so events is basically what
355:57 - uh
355:59 - golang lambda will give us so
356:01 - i'll come here
356:03 - and
356:06 - i'll say
356:07 - github.com
356:11 - slash aws aws
356:14 - lambda go
356:15 - slash
356:16 - events
356:20 - perfect
356:26 - and
356:27 - the other thing that this accepts is
356:32 - star events dot api
356:36 - okay to a
356:38 - proxy response
356:40 - sorry i meant that this it accepts a
356:42 - request
356:43 - returns a response
356:49 - i'm not sure what i said actually before
356:51 - that what i'm trying to say here is that
356:53 - you know this is a function that accepts
356:54 - something and it turns something
356:56 - obviously accepts a request obviously
356:58 - returns a response right no complication
357:00 - there that's what you wanted to do
357:04 - and what you'll do here is you'll switch
357:06 - uh with the
357:08 - http method so you'll say switch
357:11 - we'll say request dot
357:13 - http
357:14 - method so what are the htm methods that
357:17 - you have you have get post put and
357:18 - delete that's all you have so for
357:21 - every single
357:23 - different
357:24 - uh hb method you want to call a
357:26 - different function
357:27 - how do you do that so you'll say switch
357:29 - sorry we've already switched right we've
357:31 - already switched uh it's like um
357:35 - it's 8 30 here some kind of sleepy uh i
357:38 - usually get sleepy at 11 pm but somehow
357:40 - today i'm sleepy earlier because i woke
357:42 - up really early
357:43 - i have joined this martial arts class
357:45 - that that you know
357:47 - gets me to wake up at 5 00 am these days
357:50 - so
357:54 - so you'll have something called as
357:56 - handlers
357:57 - right
357:58 - and where will those handlers come in
358:00 - from it's basically these handlers that
358:02 - you want to
358:03 - import so which are basically your own
358:06 - uh creation your you know the handlers
358:08 - are your own creations you'll say
358:09 - github.com
358:13 - [Music]
358:20 - handlers
358:24 - cool
358:26 - so you're saying to go lank is that uh
358:30 - this is my project
358:31 - github.com go serverless yt
358:34 - inside that i have a folder called
358:36 - package instead of
358:37 - a
358:38 - package called handlers
358:40 - right
358:42 - and handlers the file
358:45 - uh on top of that file will say package
358:47 - handlers and it belongs to the handlers
358:49 - folder then golang understands okay that
358:51 - this is what we're talking about all
358:53 - right that's the format i mean the the
358:54 - folder name and the package name have to
358:56 - be the same
358:57 - just letting you know in case you didn't
358:59 - know that i mean
359:00 - um
359:02 - i mean i'm pretty sure you knew that but
359:04 - i'm just making sure right so you have
359:07 - request table name and diana client
359:10 - right so you send this to this function
359:12 - called handlers.getuser which we'll work
359:14 - on in a while
359:16 - so that was your case get now you have
359:20 - more cases right you have depending on
359:22 - the http method so you have post
359:26 - you will have
359:28 - put
359:30 - and you'll have
359:33 - delete
359:36 - post you'll set it on
359:38 - handlers.create
359:42 - user again you'll pass request comma
359:45 - table name
359:47 - comma dyna client for put you'll pass
359:51 - return
359:53 - handlers dot
359:55 - update user request comma sorry
360:00 - request comma
360:01 - table name comma dinoclient
360:04 - and for delete
360:06 - we'll just do handlers dot
360:09 - delete
360:11 - user
360:13 - and same things you'll pass the same
360:15 - things comma dyna client
360:19 - and after delete you will just
360:21 - give it a default
360:25 - if you work with case search and case
360:26 - statements you obviously know there's a
360:28 - default right and try to keep the
360:30 - identitation same
360:34 - it won't affect it but just it's just a
360:37 - good habit you know
360:39 - i mean i don't do it many times but you
360:41 - know
360:42 - i
360:43 - try to do it
360:45 - these days
360:46 - all right
360:49 - so by default you want to call this
360:51 - function called unhandled method
360:55 - which is again in your handlers
360:57 - file or handlers package and this is the
361:00 - entire picture i mean uh i don't think
361:02 - we're missing anything we have the os
361:05 - package down here we have events lambda
361:07 - aws session dynamodb
361:09 - yeah there's one more package actually
361:11 - if you look at the aws sdk
361:14 - document
361:16 - then you want to import
361:18 - h sdk go slash
361:22 - service slash
361:25 - dynamodb slash
361:27 - dynamo
361:28 - dvi face
361:31 - just keep these packages
361:32 - and what i think we should do is we
361:34 - should just say go mod diary
361:40 - so i'll get us all the package that
361:42 - we've just uh talked about
361:44 - and usually like many times i do this at
361:46 - the end of the
361:48 - end of the video right but this time i'm
361:50 - just doing it beforehand itself because
361:53 - many people they can start freaking out
361:54 - hey you're you're installing all these
361:55 - packages if not you've not run the
361:57 - command go my go mod id or you're making
362:00 - so many mistakes man while typing why
362:02 - don't you install some extensions i've
362:04 - explained to you why i don't install
362:06 - extensions right
362:08 - so so with golang i mean what happens is
362:11 - that you know we usually come from
362:12 - javascript kind of a background and then
362:14 - we think that oh you know if you're
362:16 - making all these mistakes then the
362:17 - complete program will crash and uh it
362:19 - will be difficult to solve it but with
362:21 - golang golang is very different from
362:22 - other programming languages right
362:27 - make as many mistakes as you want
362:29 - and once you run the program golang will
362:31 - really handle everything for you it'll
362:32 - tell you which line what's the problem
362:34 - it's quite intelligent
362:36 - right it's not like your regular uh
362:41 - other programming languages like
362:43 - javascript
362:46 - so here one thing that we missed out was
362:48 - to create the dyna client in the first
362:50 - place right so the then a client has in
362:52 - the variable
362:53 - and
362:54 - defining the type of variable the dyna
362:57 - client is so what type of dynam uh there
362:59 - it will be
363:00 - that's where we'll use this thermodb i
363:03 - face right we'll say dot
363:06 - dynamo
363:11 - thermodv
363:15 - api
363:17 - just make sure you get this right all
363:19 - right
363:21 - so that's your main file your main file
363:22 - is complete
363:25 - and
363:26 - now you want to
363:27 - start handling handlers so here
363:30 - so since these two files belong to the
363:31 - same folder called handlers we want it
363:34 - to
363:34 - both to be
363:36 - package handlers
363:38 - right so we'll say
363:39 - package
363:42 - handlers
363:43 - right that's clear till now i'm hoping
363:46 - and
363:47 - after writing the package you say import
363:50 - and then you have your
363:52 - main func you know for in this case this
363:54 - the main function of this
363:56 - file is
363:58 - called
364:01 - api response
364:03 - accepts some things
364:05 - return some things and has a function
364:06 - definition
364:08 - what does it accept accepts status
364:12 - which is end
364:14 - and body
364:16 - which has an interface
364:20 - what does it
364:21 - return it returns
364:25 - event start
364:27 - api gateway proxy proxyresponse
364:31 - comma error
364:37 - right
364:39 - for importing you will say encoding
364:41 - slash
364:44 - json
364:46 - and github.com
364:49 - slash aws
364:51 - slash
364:53 - address lambda go
364:56 - slash events
365:01 - okay
365:04 - all we're doing with this is basically
365:06 - defining
365:07 - the response right so
365:10 - we'll say response is equal to
365:13 - event start
365:15 - api gateway response
365:20 - the response you're just setting the
365:22 - headers
365:27 - pretty standard
365:29 - because the way we're going to set up
365:30 - these headers
365:32 - are something that you've already seen
365:33 - so many times which is basically content
365:35 - type and application json so we're
365:36 - saying that
365:38 - we're returning json from
365:41 - our lambda function
365:43 - right nothing
365:45 - uh out of the ordinary so we'll say
365:47 - response dot
365:49 - status code
365:51 - is equal to status
365:57 - and
365:59 - so i will be basically your like 400 for
366:01 - 300 uh something like that
366:04 - and then you'll say string body comma
366:09 - json.marshall
366:13 - sorry so you are uh if you've been with
366:15 - golang you already know what's matchling
366:17 - and d marshalling unmarshalling sorry is
366:20 - golang doesn't understand
366:21 - json on its own so it needs the help of
366:25 - json marshalling
366:26 - which is part of this encoding slash
366:28 - json package
366:30 - and uh yeah so whenever you send some
366:32 - json from postman into
366:34 - um postman or maybe terminal wherever
366:37 - you send some uh json
366:40 - uh it basically we we want uh golang to
366:42 - understand it also and also the
366:44 - information that golang produces for it
366:46 - to become json uh
366:48 - and send it as a response that also
366:50 - needs uh you know help a goal i need
366:52 - help with both so that's why it's called
366:53 - mastering and muscling there are
366:55 - hundreds of videos about it
366:57 - on youtube you can check it out nothing
366:59 - fancy or nothing
367:01 - complicated
367:02 - you have to do that in uh you know
367:04 - almost all the other languages right
367:05 - which are not javascript which is like
367:07 - basically java and python all these
367:09 - languages you have to do something like
367:10 - that right
367:12 - because any language that's not
367:14 - javascript does not understand json by
367:16 - default because json is javascript
367:19 - object notation
367:20 - so this is your api response dot go all
367:23 - right that's it i mean there's nothing
367:26 - much going on here in this file
367:30 - but
367:31 - the other file in handler's package
367:32 - handlers this is where we're going to
367:34 - spend some time because
367:37 - obviously there will be a lot going on
367:39 - here right
367:41 - uh so the main functions that
367:45 - usually will be there will be
367:47 - based on our main.go file so main.go
367:49 - file requires get user function create
367:51 - user update user delete user and unlock
367:53 - method unhandled method sorry so these
367:55 - are the functions that obviously that
367:56 - you need to create right so you say get
367:59 - user
368:03 - and
368:04 - you'll say create user
368:14 - you will say update user and delete
368:16 - users func
368:19 - update user
368:23 - and delete user
368:26 - alright so here
368:28 - the last function that we want to keep
368:30 - here
368:31 - is
368:32 - unhandled method
368:35 - right so
368:37 - for let's say if somebody uh uses the
368:39 - patch method because you're handling get
368:42 - post put delete if somebody uses batch
368:43 - then we'll say that hey
368:46 - it's not handled right so we'll say
368:47 - unhandled method
368:49 - accept some things return some things
368:51 - and has a
368:53 - function definition
368:54 - all right so this is uh in general this
368:57 - is how your
368:58 - handlers file is going to be like
369:02 - and
369:03 - what we can do is we can work on our is
369:06 - email validated uh valid file
369:11 - so we'll say package validators
369:16 - and there's a package that you get with
369:19 - golang it's called regular expressions
369:22 - and we're just creating a simple
369:24 - function where we're just saying if the
369:25 - email is valid or not
369:28 - right really simple
369:31 - all it does is accepts
369:33 - an email string
369:37 - and returns a boolean like yeah true or
369:38 - false
369:42 - we'll take a variable called rxemail
369:45 - we'll use the reg expression regular
369:47 - expression package
369:49 - and if you look at the regular
369:50 - expression documentation like i have in
369:53 - front of me go to the golang official
369:54 - documentation and check out the regular
369:56 - expression package
369:57 - um i i highly recommend you to open it
369:59 - if you want because that's what i've
370:01 - done out here in my other screen
370:04 - we'll use
370:06 - the
370:08 - function called must compile
370:10 - and i'm going to copy and paste a
370:12 - regular expression string here
370:17 - you don't really need to understand what
370:18 - this does you just get it directly from
370:19 - the
370:22 - documentation but if you really want to
370:24 - know basically uh you're just checking
370:26 - if you know the numbers are between a to
370:28 - z a to z
370:29 - and zero to nine that kind of stuff
370:31 - right that's all it's doing and it's
370:32 - also checking for at symbol
370:36 - right that means obviously if it's an
370:38 - email it needs to have an ad right
370:40 - so those kind of things just basic email
370:42 - validation check is happening out there
370:44 - do check out the regular expression
370:46 - document if you want to really
370:47 - understand what this regular expression
370:48 - does all right
370:51 - but if you want to save time just copy
370:52 - and paste it like i did just did
370:55 - and
370:57 - now we want to check the length of email
371:01 - female if length of females less than
371:02 - three or
371:04 - length of email
371:06 - is more than 254
371:09 - or
371:12 - our rx email
371:14 - variable
371:17 - dot mat string
371:22 - then you'll just return false
371:24 - right so this returns either true or
371:26 - false
371:27 - if these conditions are not met
371:29 - then you return false otherwise you
371:30 - return true that means everything is
371:32 - fine and email is valid right obviously
371:35 - if this is not uh proper it's not
371:38 - working properly if uh length is more
371:40 - length is less
371:41 - we'll say the email is not valid
371:43 - otherwise we'll say it's true you can
371:45 - change these numbers as you want but
371:46 - i've kept them to be 3 and 254. all
371:48 - right you can change it on your taste
371:51 - so uh now we'll go to our user.go file
371:55 - and we'll just add a very 10 000 feet
371:58 - level i'll just set up this file now
372:00 - what i want uh should happen is that
372:02 - from my handlers
372:04 - like the main control you know that will
372:06 - go to the main file
372:07 - to our uh you know to this function
372:09 - basically and this function is calling
372:11 - the get user function and create user
372:13 - function update user and all these
372:14 - functions are as you know mentioned in
372:15 - the handlers right and from the handlers
372:18 - from the handlers you'll call the
372:20 - functions in your user.go file and these
372:22 - functions will be actually the database
372:23 - functions that actually talk to the
372:24 - database right so every function that
372:27 - you have here
372:28 - except for the unhandled method because
372:29 - it doesn't do much uh these four crud
372:32 - functions that we have they have an
372:34 - equivalent function in your user.go file
372:36 - a complete like one is to one function
372:38 - in your user.go file that
372:40 - talks to the database all right so let's
372:42 - do that let's create those functions so
372:44 - firstly as you know when we start off a
372:46 - file
372:47 - we import some things and then
372:50 - here i also want to find some variables
372:52 - some errors that i want to define
372:56 - so the functions that i want to have
372:58 - here in my user.google file which will
373:00 - have one is to one relationship with
373:01 - these four functions
373:03 - the first function will be
373:04 - called i'll call it
373:06 - fetch user
373:09 - so that means is
373:10 - uh
373:12 - my get user function gets called in my
373:13 - handlers and this function will call in
373:15 - my user.go file the fetch user function
373:18 - which directly gets uh the user from the
373:20 - database itself the database in this
373:22 - case being dynamodb right
373:24 - so it accepts some things returns some
373:26 - things and it has a function definition
373:27 - simple
373:29 - the second function that i want to have
373:30 - is for
373:33 - getting multiple users actually so i'll
373:35 - say funk
373:38 - fetch
373:40 - users
373:42 - similarly it'll look very similar
373:45 - then i want to have
373:47 - a create function
373:49 - so i'll have create user
373:53 - and then
373:55 - it has update user
374:05 - okay you just have to keep looking here
374:06 - and then creating these functions
374:09 - and then you have the last one is delete
374:11 - user right so you'll come here
374:22 - right if it doesn't get deleted then you
374:24 - don't have to return anything specific
374:25 - so especially you can just return an
374:27 - error that's why
374:28 - from the return here is just an
374:30 - error right
374:33 - and
374:34 - that's about it so we have one into one
374:36 - functions all of these but one extra
374:38 - function is there which is fetch users
374:40 - all right so we'll see where to get
374:42 - where to use it
374:43 - so from a 10 000 feet perspective this
374:46 - is your user.google file and this is
374:48 - your handlers file so what we'll do is
374:50 - we'll start working on our handlers
374:51 - function and then at the same time we'll
374:53 - start working on our
374:56 - uh user.go functions
374:58 - and here you'll obviously import some
375:00 - things right
375:03 - um
375:04 - the first thing that i need is net slash
375:06 - http
375:08 - then i need my lambda event so i'll say
375:11 - github.com
375:14 - aws
375:16 - lambda go slash events now it's possible
375:19 - that i'm importing these but you're not
375:21 - understanding why i'm importing these so
375:22 - you might get confused so
375:24 - uh now there are two ways to do it one
375:25 - is when i'm actually writing the code
375:27 - and then i use this events
375:29 - packet somewhere and then i come and
375:30 - come up and you know import it or i know
375:33 - um you know which ones i need so i'll
375:35 - just import them right in the beginning
375:36 - itself so that i can use them later on
375:39 - so i'm just doing this so try not to get
375:41 - confused because we'll actually be using
375:43 - these packages in just like two three
375:45 - minutes
375:46 - don't worry you know why we're importing
375:47 - them where will we use it so
375:52 - please be patient
375:55 - slash aws
375:57 - right so these are the same packages
375:59 - that we already use in our main.co file
376:03 - and we'll say github.com slash aws
376:07 - slashing plus
376:08 - okay go slash service slash
376:13 - turnover db slash dynamo tv i face
376:17 - [Applause]
376:19 - great
376:21 - one thing that i need here
376:23 - because i would want to call these
376:24 - functions like i told you right i won't
376:26 - call these functions so that's why
376:28 - i want to import this user package in my
376:30 - handlers file how would i do that i
376:32 - would say github
376:34 - dot com slash a kill slash
376:38 - go serverless
376:40 - writing
376:42 - slash
376:46 - package slash user
376:49 - so inside package
376:50 - inside the user package
376:53 - we've imported it here
376:58 - all right
376:59 - and then before i get started these
377:00 - functions i want to define a very a
377:02 - variable called error
377:05 - method not
377:07 - allowed
377:07 - [Music]
377:10 - is equal to method not
377:12 - allowed
377:14 - and
377:16 - why do i need to create
377:18 - this because
377:20 - firstly we'll be working on this
377:22 - function unhandled method right so
377:23 - that's why we want to call this function
377:24 - so here
377:26 - this returns an
377:29 - event
377:31 - api gateway event so it will say api
377:34 - gateway proxy response comma
377:37 - error
377:39 - right so we'll just send response from
377:41 - here
377:42 - or we'll just send an error and here
377:44 - you'll say return api response the
377:46 - response that you want to send
377:49 - is http dot
377:52 - when we say http we are talking about
377:53 - the http package net http package all
377:56 - right status
377:58 - method
378:00 - not
378:01 - allowed comma
378:03 - header method not load which we have
378:04 - just defined
378:05 - together right
378:07 - that's what you're saying so we're
378:08 - saying that
378:09 - uh we have uh you know something for get
378:12 - post but complete but we don't have
378:14 - something for patch so patch or any
378:16 - other method that somebody uh plans to
378:18 - use
378:19 - so if you get something like that like
378:20 - an unhandled handle method so you'll
378:22 - send a response saying that hey
378:24 - this method is not allowed
378:27 - all right
378:29 - and
378:30 - i want to create
378:33 - another variable
378:34 - but it's actually a struct right so it's
378:36 - an error body
378:38 - and i'll be using it a lot so just bear
378:40 - with me as to why i'm creating it
378:43 - this struct
378:46 - has a variable called error message
378:49 - chat string
378:53 - error comma
378:55 - commit
378:56 - empty
379:00 - cool
379:03 - now for your get user
379:05 - [Music]
379:06 - you have
379:08 - you accept something and you turn
379:10 - something here
379:11 - for a get user what do you accept what
379:13 - do you what does the function get you
379:15 - get a request right from postman the
379:17 - request that you get is
379:19 - um
379:21 - part of this events packet so you'll say
379:23 - event start
379:27 - api gateway request
379:30 - comma table name which is string
379:34 - comma
379:35 - diana client
379:41 - dot
379:42 - dynamo
379:44 - db api
379:46 - and what is return
379:47 - it returns a response obviously so we'll
379:49 - say events
379:50 - dot api gateway proxy proxyresponse
379:54 - comma error
380:00 - straightforward
380:03 - and actually
380:04 - this
380:06 - these two things right well it's going
380:08 - to accept what's going to return
380:11 - it's going to be used by all of the
380:12 - functions so what you'll do is you just
380:14 - copy and you'll just paste it here
380:16 - for create user
380:19 - for update user as well
380:26 - and
380:28 - for delete user as well
380:34 - awesome so we've done a lot of heavy
380:37 - lifting
380:39 - now we want to start working on the
380:43 - function definitions for these all these
380:44 - functions
380:46 - right so the first thing that you'll say
380:48 - is email
380:51 - request dot
380:52 - query
380:54 - string parameters
380:57 - email
381:00 - so if you've
381:02 - guessed what's happening here is you
381:03 - want to get the user but by using the
381:06 - email id of that user
381:08 - so from a request you'll have your query
381:11 - string parameters which we'll pass as
381:13 - email
381:14 - and that we're going to capture in a
381:15 - variable called email
381:17 - and then we'll check
381:20 - the length so we'll say if length
381:22 - of email is greater than zero
381:26 - then you'll get a single user so you'll
381:28 - say user dot
381:30 - fetch user which we've just created
381:32 - together right we've not created the
381:33 - definition but you know which function
381:35 - i'm talking about it's in my user
381:37 - uh package which have been imported here
381:39 - already
381:41 - so fetch user is going to take the email
381:46 - table name and die in a client
381:52 - and i'm going to capture this in
381:54 - the result
381:56 - or they're going there's going to be an
381:57 - error and if there's an error i'll
381:58 - handle the error so i'll say f error not
382:00 - equal to nil
382:02 - return
382:04 - api response
382:06 - http dot
382:07 - status bad request
382:14 - comma
382:15 - error body
382:17 - so error body is a struct that i've
382:19 - already defined and in error body i want
382:21 - to pass
382:22 - aws dot
382:24 - string
382:25 - error dot
382:27 - error
382:31 - [Music]
382:39 - and otherwise you'll see hdb dot
382:42 - everything is okay so we'll say status
382:43 - okay
382:45 - if everything goes well
382:46 - and you'll pass the result from this
382:48 - function
382:51 - now if
382:54 - um
382:56 - if you want
382:58 - multiple users
383:01 - you'll say user dot
383:03 - fetch users
383:06 - same thing table name
383:08 - and a client
383:15 - and
383:16 - what you'll do is you'll again use
383:18 - result and error to capture the values
383:20 - coming from this function
383:22 - and if there's an error and you'll check
383:24 - if error is not equal to nil you'll
383:26 - return the api response
383:29 - saying
383:30 - http.statuspad request because there's
383:32 - an error right
383:35 - and you'll send the error body just like
383:37 - we did earlier error body is the struct
383:38 - that we've already defined
383:40 - that's the error body that we are
383:41 - sending which is basically json
383:43 - and here the error body
383:45 - uh inside that we're going to
383:48 - send you're going to send aws.string
383:51 - header dot
383:53 - error
383:56 - got it
383:58 - but if everything went well and there
384:00 - was no error then we're going to return
384:02 - api response
384:04 - and http dot status okay
384:08 - comma result
384:12 - so basically that's your get user
384:14 - now what you can do is we can
384:17 - work on our fetch user and fetch users
384:19 - both of these functions in our user.go
384:20 - file or we can work on our create user
384:23 - function in our handlers so i think i'll
384:25 - do the former
384:27 - i'll work on fetch users and
384:30 - i'll work on fetch user let me just
384:32 - check if everything is recording yes
384:33 - everything is recording perfectly
384:35 - and i just i need to keep making sure
384:36 - otherwise you know i end up making a
384:38 - long video when nothing has recorded and
384:40 - that leads to a big problem
384:42 - all right so before i do anything with
384:46 - users
384:47 - i want to first create a user right so
384:50 - like i said this file is a mix of that
384:52 - model file that you usually create where
384:53 - you define the struct of how the user is
384:55 - going to look like so i'll say user
384:58 - struct
385:01 - email
385:02 - now since this user struct is small and
385:04 - we don't have multiple structs like if
385:06 - this was
385:07 - a um
385:08 - e-commerce for example then you would
385:10 - have had users and orders and you know
385:12 - all those different like products and so
385:13 - many different structs right so you'd
385:15 - have to have like a model separate
385:16 - models folder for all these different
385:18 - models and then you'll have you'd have
385:20 - you know database
385:22 - functions separately and controllers or
385:25 - something like that
385:26 - right
385:27 - but since we don't have that
385:28 - we have a very small project which just
385:30 - has users and users all itself it's a
385:32 - very small struct because you just have
385:34 - email first name and last name
385:39 - you don't have too much here right you
385:40 - can
385:41 - combine controllers and models into the
385:43 - same file
385:45 - now email is going to be
385:47 - a string
385:52 - which is going to say json
385:54 - and you say like this json email because
385:57 - for golang's purposes it'll be emailed
386:00 - with a capital e whereas when json where
386:01 - it's stored
386:02 - uh it's going to be emailed with a small
386:04 - e so you need to tell golang that you
386:06 - know there are two versions of it one
386:08 - the json version the another here's the
386:10 - version that golang understands because
386:12 - golang does not understand
386:14 - json as i've already told you so that's
386:16 - why we'll also you have to use some
386:18 - marshalling and unmarshalling
386:20 - uh to get it to understand
386:22 - and interact with json all right so
386:25 - you'll have first name and last name
386:28 - and then what we'll do is we'll create
386:29 - our fetch user function
386:31 - what does it accept so if you actually
386:32 - go to handlers you'll see the fetch user
386:35 - function
386:36 - accepts email table name dynaclient so
386:39 - we'll say here email
386:41 - and table name which is string
386:46 - and your dyna client which is of type
386:49 - you already know that more
386:50 - dbi face dot
386:52 - dynamodb api
386:55 - and it just returns a user
386:58 - obviously i mean you fetch user you
387:00 - return that particular user or you turn
387:02 - error if nothing works out
387:06 - you define a variable called input
387:10 - and it's of type dynamodb dot
387:14 - get
387:16 - item
387:18 - input
387:22 - so we'll have to define the key based on
387:23 - which our
387:25 - database function will run to find that
387:27 - particular user and you already know
387:28 - that the user will be found from the
387:30 - database based on the email id so we
387:32 - take an email id we're taking an email
387:34 - id and then we want to find the user
387:36 - that's associated with that email id all
387:37 - right so
387:39 - straightforward
387:41 - we'll say dynamodb dot
387:42 - attribute value
387:47 - and
387:48 - we're going to say email because we want
387:50 - to run a query on email so email is
387:51 - equal to
387:53 - s is equal to aws.string
387:55 - dot
387:57 - sorry inside that bracket will pass
387:59 - email now the string
388:01 - is a function that is given to us by aws
388:04 - package aws packet is something that
388:05 - we'll have to import out here all right
388:07 - uh and similarly with the dyno db so
388:08 - we'll have to also import the dynamodb
388:10 - package
388:11 - so come here on your import and uh
388:14 - firstly called encoding
388:17 - json because like i told you golang does
388:18 - not instant json by default so you need
388:21 - uh encoding slash json package to uh
388:24 - use the marshalling and unmarshalling
388:26 - functions and i need the errors package
388:28 - also
388:30 - then i want to
388:32 - uh get my hands on
388:36 - the events
388:38 - and i'll be using it soon
388:40 - to send responses and
388:44 - the usual ones uh as you can see i need
388:47 - dynamdb and i need aws so let's
388:49 - get those ones
388:51 - so i'll say aws slash aws
388:55 - sdk
388:57 - go slash aws
389:01 - and i'll say github.com aws slash aws
389:05 - sdk go slash
389:08 - dynamo tv
389:12 - um and what i'll also do i'll also get
389:16 - this
389:18 - particular package
389:21 - um
389:22 - yeah let me do that for now
389:25 - so i'll say github.com aws slash aws hd
389:29 - case
389:30 - go
389:31 - slash service slash
389:34 - dynamo
389:36 - db slash
389:37 - dynamodb
389:39 - i face
389:44 - all right
389:47 - now coming
389:49 - here
389:51 - you've already
389:53 - passed this and
389:55 - after this bracket
389:58 - you need to specify the table name in
390:00 - which this
390:01 - function is going to run so
390:03 - we'll use the uw string function again
390:07 - to pass the table name
390:10 - and after this bracket
390:12 - you want to use your dyna client to
390:14 - finally
390:17 - start getting the item
390:21 - input is this basically the query that
390:22 - you created right and get item is the
390:24 - function that you get in a client
390:27 - and
390:28 - you will capture that in result and
390:30 - error
390:32 - so
390:33 - standard practice if there's an error
390:35 - we'll have to return the error so we'll
390:37 - return nil
390:38 - for the value and
390:40 - we'll return errors dot new
390:45 - error
390:46 - failed
390:47 - to
390:49 - fetch
390:51 - record
390:54 - so um
390:56 - you must be wondering where is where
390:58 - does this error come from you've
390:59 - probably never seen this error right
391:00 - because this is a new error that i've
391:01 - created on my own
391:03 - how can i create my own errors i can
391:05 - create my own errors like this so error
391:10 - fail to fetch record
391:12 - is equal to
391:14 - fail to fetch
391:16 - record
391:18 - and similarly i can define any errors
391:19 - that i want in this variable uh
391:23 - defined as a variable right
391:27 - so you've uh you know created a query
391:31 - very similar to mongodb write you've
391:33 - created a query based on the email
391:35 - because you want to search for that
391:37 - email so that you can retrieve the user
391:39 - and you've run the function get in get
391:41 - item for dynamodb
391:43 - and you've passed the query to it and
391:45 - you've received that in something called
391:46 - as result or you received an error so if
391:48 - there's an error you handle the error
391:50 - but if the result is fine and nothing
391:52 - really happened then you would do
391:53 - something right
391:54 - but before that
391:58 - we'll create a variable called item and
392:01 - it'll be basically a new user
392:05 - and here you'll say error is equal to
392:08 - dynamo
392:10 - db attribute
392:15 - dot on marshall map
392:19 - okay so
392:20 - dynamodb attribute is another uh by the
392:23 - way if you have not opened up the dyno
392:24 - db uh and aws sdk go documentation do
392:28 - that because i have it open on my other
392:29 - screen
392:30 - you can do that as well and then
392:32 - everything will make a lot more sense
392:34 - because these are actual packages inside
392:35 - that main package right
392:38 - so i'm using those and once you go
392:40 - through the documentation you'll
392:41 - understand
392:42 - where to use uh
392:44 - which one
392:45 - or you or if you really don't care about
392:48 - that you can just keep following along
392:50 - with what i'm doing but i just recommend
392:52 - that you just read it because
392:54 - you know everything will make more sense
392:57 - here i need
393:01 - this package right then would be
393:02 - attribute
393:03 - this is helping me unmarshalling the
393:05 - user
393:07 - so first let me write the whole code
393:09 - so i'll say result sorry not here
393:13 - here upper bracket will say result dot
393:15 - [Music]
393:17 - item comma
393:20 - item
393:24 - and this error if this error is not
393:26 - equal to nil
393:27 - what we want to do
393:29 - we want to return nil comma errors dot
393:32 - new
393:35 - error
393:37 - failed
393:38 - 2
393:39 - on
393:41 - marshall
393:42 - record
393:46 - so you must be wondering what's
393:47 - happening here right
393:49 - so when you get the
393:51 - data from your dynamodb using the get
393:53 - item
393:54 - function into result
393:57 - you want to unmarshal that into an
393:59 - actual user
394:01 - which the front end can understand
394:04 - as a json basically
394:06 - so you use the user struct
394:10 - and you uh you know
394:12 - take that in a variable called item
394:14 - right so item is basically um
394:17 - a variable of type user
394:20 - and then uh you know you want the data
394:23 - that's coming from your result dot item
394:25 - you want that to be unmarshaled and
394:27 - brought into item so that now whatever
394:29 - has come as uh json
394:31 - uh becomes
394:33 - uh you know the type which is user which
394:35 - is understood by golang but and it's
394:37 - captured in a variable called item
394:39 - right
394:40 - um so i've tried to explain to you every
394:42 - single line in case you don't understand
394:44 - it do check out what's marshalling and
394:46 - unmarshalling all right
394:48 - and if you have any error like if you
394:50 - still have any confusions you can just
394:52 - put it in the comments below
394:53 - i'll sort it out for you but it's
394:55 - nothing very difficult right you're just
394:57 - um taking what's coming from dynamodb
394:59 - the json and you're unmargining it to uh
395:02 - make it into a struct right
395:05 - which is of type user which has email
395:06 - first name last name something that can
395:07 - be understood by golang and you're
395:09 - capturing that in a variable called item
395:11 - which is obviously of type user right
395:13 - that's stuck that we have defined
395:16 - this is standard practice i do this in
395:18 - all my other videos as well in case
395:20 - you're new to this channel i have
395:21 - hundreds of videos on golang you can
395:23 - check all of them out
395:25 - like literally hundreds of videos on go
395:27 - like right check them out build projects
395:28 - with me and you'll understand very
395:30 - everything very easily so if everything
395:32 - went well
395:34 - if there was an error obviously you sent
395:36 - nil and you sent the errors but if
395:38 - everything went well you would return
395:39 - the item and then you will return nil
395:40 - for the error
395:42 - now you'd want to also work on the fetch
395:46 - users function the plural fetch users
395:48 - function
395:50 - how do you do that you
395:52 - are passing table name there
395:55 - as you can see here you're passing table
395:56 - name and nano client
395:58 - so table name has been passed which is
396:01 - obviously your type string
396:02 - you passed denmark dyna client which is
396:04 - of type
396:06 - you already know dynamo dpi face dot
396:10 - dynamodb api
396:13 - and you return multiple users
396:18 - how do you run multiple users you return
396:19 - basically a slice
396:21 - of
396:22 - users
396:23 - wherein users is the struct that you've
396:26 - defined right so you're using a struct
396:27 - you're making a slice of all those users
396:29 - and then that's what you're returning
396:32 - i hope that makes sense
396:34 - if you don't know basics of like of
396:36 - course like slices and structs then i
396:38 - highly recommend you check out the basic
396:40 - tutorials before uh
396:43 - you get more confused
396:47 - so
396:48 - um
396:49 - i want to use a function but that
396:51 - dynamic db gives me it's called
396:54 - scan input
397:00 - to get access to table name which is aws
397:02 - dot
397:04 - string
397:05 - and
397:07 - table name that we are already passing
397:08 - here
397:11 - got it
397:13 - and you will say dynaclient
397:16 - dot scan and you want to scan
397:19 - the input the query that you just
397:21 - created
397:23 - right so here as you saw
397:26 - uh we had a more elaborate query because
397:28 - we had to get a particular user with
397:30 - email
397:32 - but with fetch users you're just getting
397:33 - all the users you don't have a specific
397:35 - query that okay you know for this email
397:37 - i get a particular user saying get me
397:39 - all the users
397:40 - so you don't have any query as such
397:42 - you're just passing the table name so
397:44 - that's when your dynaclient.scan you
397:46 - just pass the input that's it
397:48 - and
397:50 - scan is like get all you know you can
397:52 - say that so if you've used
397:54 - uh that mongodb it's you have find find
397:57 - all something like that here you just
397:59 - have scan
398:00 - find and find one you have in mongodb so
398:02 - you just have
398:04 - scan all right
398:06 - scan and get item so you're doing scan
398:09 - to get all the results and you're going
398:11 - to capture that in a variable called
398:13 - result and then you'll obviously if you
398:15 - have an error you know that standard way
398:17 - to handle errors is like this you'll say
398:20 - return
398:22 - nail for the value and
398:25 - you'll return an error so you'll say
398:26 - errors dot new
398:29 - error
398:30 - failed to fetch record
398:33 - and
398:35 - again like we did out here
398:37 - item
398:38 - we'll define an item right
398:41 - the item here is
398:43 - not just a user it's a slice
398:46 - of users multiple users because we're
398:48 - getting all the users from our database
398:52 - and
398:53 - again the same thing that we've just
398:54 - done here we'll do the same thing here
398:55 - so we'll say error is equal to
398:58 - just copy the whole thing actually
399:02 - copy and paste
399:04 - but there's only one small little change
399:06 - instead of result.item
399:09 - you'll have result dot
399:10 - items
399:12 - because obviously from your database
399:14 - you'll get multiple items multiple users
399:16 - that's what you're getting
399:17 - and you're returning
399:20 - your item
399:21 - and for the error you're turning nil
399:24 - makes sense
399:26 - so
399:27 - we've done quite a bit right we've
399:28 - already done the get user function and
399:30 - get user function had fetch user and
399:32 - fetch users two functions from your
399:34 - user.com file
399:36 - now there are three functions left here
399:38 - and
399:40 - three functions left here because we've
399:41 - already taken care of the unhandled
399:43 - method function you don't have to do
399:44 - anything more here so just three
399:46 - functions left here
399:47 - three functions left here
399:48 - and all the other files are kind of
399:50 - complete
399:52 - right so if you've reached this far
399:53 - congratulate yourself because
399:55 - you've come you've come a long way right
399:59 - um
400:00 - so now let's start thinking about
400:03 - how our create user function is going to
400:05 - work
400:06 - all right
400:09 - so for the create user function let's
400:12 - let's start building that
400:14 - there's actually not much happening
400:16 - there
400:17 - all these functions right uh create user
400:19 - update user delegator
400:20 - they're all going to look very very
400:22 - similar so
400:23 - i'm going to say user because you know
400:27 - uh you want to call the create user
400:28 - function the user package so you'll see
400:30 - user dot
400:31 - create user which is
400:33 - this function that's what you're calling
400:35 - right and you're passing it three things
400:37 - request
400:39 - table name
400:40 - and a client
400:42 - make sense
400:43 - now whatever response
400:45 - this function returns you want to
400:47 - capture that in a variable called error
400:49 - sorry result and you'll get an error
400:51 - which will be captured in error
400:54 - and you know the process from here if
400:55 - there's an error
400:57 - which means error not equal to nil
400:59 - you'll return
401:00 - api response
401:02 - http dot
401:04 - status bad request comma
401:06 - error body and what will be in the other
401:08 - body everybody in this case by the way
401:10 - is
401:12 - sorry the struct that we've already
401:14 - defined right
401:15 - so what's there in the everybody it's
401:17 - aws.string
401:20 - with a single r sorry string
401:24 - err dot error
401:27 - and comma
401:30 - okay
401:32 - and you'll return api
401:34 - response http dot status created
401:41 - comma result
401:44 - so if that means if there is no error
401:45 - everything goes well then you'll say
401:47 - hdb.status created
401:50 - all right
401:52 - and
401:55 - that's about it that's it actually
401:56 - that's your create user function there's
401:58 - nothing more to it
402:00 - all right and then for your update user
402:02 - function
402:03 - very similar you'll obviously call the
402:05 - user just like you did here user dot
402:08 - create user here you'll call user dot
402:11 - update user method so you'll see
402:13 - update user and you'll pass three things
402:15 - request
402:16 - table name and dyna client
402:20 - and
402:23 - you'll capture that in result comma
402:25 - error
402:27 - and then you'll check again if error is
402:29 - not equal to nil
402:34 - you'll return an api response http dot
402:36 - again
402:37 - status bad request comma
402:40 - error body inside the other body
402:44 - again the same thing it resource string
402:46 - error dot
402:48 - error
402:49 - all right but if everything went well if
402:51 - the user did get updated then
402:53 - you'll return api response
402:59 - and you'll say http dot
403:02 - status okay
403:03 - that everything went well and you'll
403:06 - return the result
403:09 - so that means what's happening in these
403:10 - two functions create user update user
403:13 - is that
403:15 - these two functions are being called
403:17 - that means a lot of the logic the main
403:19 - logic is going to happen in these two
403:20 - functions right because not much
403:22 - happened in the in the handlers
403:24 - similarly let's work on our
403:27 - delete user function
403:28 - here you'll say user dot
403:31 - read user you'll say request comma table
403:34 - name comma
403:36 - diana client
403:39 - here also
403:43 - though
403:44 - the only thing you'll run from here is
403:45 - the error right
403:47 - if
403:48 - the user didn't get deleted you'll
403:49 - return the error you don't need to
403:51 - return the result any result from the
403:52 - delete function
403:55 - so if the result is not equal to nil
403:57 - you'll return api response
404:00 - it you know by now what we're going to
404:02 - say we're going to say status bad
404:04 - request and we're going to also send the
404:06 - error body
404:07 - which will have aws.string
404:09 - [Music]
404:11 - and
404:13 - the error itself
404:16 - but if everything went well you would
404:18 - want to return
404:19 - the response with
404:23 - status ok
404:26 - and
404:27 - ultra nil
404:30 - for the error
404:35 - okay
404:42 - so that's
404:46 - um that's about it
404:50 - and
404:51 - um yeah that's it i think
404:53 - the entire file is complete now
404:56 - we don't have anything else to do
404:59 - i've also gone through the aws uh sdk
405:01 - documentation i don't think anything
405:03 - else need to be done in the handler so
405:05 - everything looks all right to me
405:07 - uh and now we'll have to work on our uh
405:10 - user.go file and all these different
405:12 - functions that exist on our user.com
405:15 - file
405:17 - for your create user function
405:21 - what all it's going to accept depends on
405:23 - what you're sending from here which is
405:24 - requestable and nanoclient
405:27 - so here you'll say request
405:30 - event start api gateway proxy request
405:34 - comma table name which will be string
405:37 - and
405:38 - data client which will be you already
405:40 - know then mdbi face
405:43 - dot nano db api
405:46 - so what is it going to return it's going
405:47 - to return
405:48 - the user that has been just created
405:51 - or
405:52 - an error
405:55 - so here the first thing that we'll do is
405:56 - we'll create a variable u which is of
405:59 - type user user being the struct that we
406:01 - will define that means you will have
406:02 - email first name and last name all right
406:05 - so let's start from there
406:08 - now we'll use u
406:10 - why did we create this variable u
406:12 - it's because we want to capture what's
406:14 - coming from
406:15 - postman so from postman or from let's
406:17 - say the terminal wherever we'll send the
406:19 - json of the user with
406:22 - the
406:23 - email first name and last name and that
406:25 - data needs to be unmarshaled into you so
406:29 - that golang is able to understand it and
406:30 - also perform any operations on it
406:33 - so what you want to do is we want to use
406:35 - the json encoding json package to call
406:38 - the unmarshall
406:40 - function
406:43 - [Music]
406:49 - and what you want to do is you want to
406:50 - pass the request dot body to it
406:55 - comma ampersand u
406:59 - [Music]
407:01 - if error is not equal to nil
407:04 - and also here
407:09 - we'll fold the right syntax
407:11 - for the if statement and if error is not
407:12 - equivalent then we'll return
407:15 - nil and we'll return something for the
407:17 - errors
407:18 - we'll say error
407:21 - invalid
407:23 - user data
407:28 - but we don't have this error here right
407:30 - so we don't have
407:31 - uh this error error fail to and marshall
407:33 - record
407:36 - we don't have error in values of data we
407:38 - just have error field to fetch record
407:40 - that's all we have defined
407:41 - so now let's define all the other errors
407:45 - let me define all the other errors that
407:46 - i'll need in this entire
407:48 - file
407:50 - in the beginning itself
407:52 - so we'll say error failed
407:55 - to
407:56 - unmarshal record
407:58 - is equal to
408:00 - fail to unmarshal
408:02 - record
408:04 - an error run
408:08 - and
408:10 - i'll add
408:12 - error and valid
408:15 - user data is equal to
408:19 - invalid
408:22 - user data
408:26 - invalid email also will be there and
408:28 - valid
408:30 - email is equal to
408:33 - invalid email
408:37 - then we'll have
408:41 - good
408:42 - not
408:44 - marshall
408:46 - item
408:53 - and could not delete item so
409:07 - then we'll have could not
409:09 - put item so we'll say error
409:11 - could not
409:14 - dynamo put
409:16 - item is equal to
409:18 - code not dynamo put item
409:22 - and
409:23 - user already exists
409:37 - user does
409:39 - not exist
409:42 - user.user
409:44 - does not exist
409:49 - so why do i need all these errors
409:51 - obviously by now you would have
409:53 - understood i'll just give you an example
409:54 - that
409:55 - uh when creating
409:57 - a user right
409:58 - if we check if that user already exists
410:00 - then we don't need to create that user
410:01 - so that's why we need this kind of an
410:02 - error
410:03 - and if you want if you're updating a
410:04 - user then or deleting a user we can use
410:07 - this that user does not exist so why are
410:09 - you trying to update that user right
410:11 - that's why um i'm just thinking about
410:13 - all the type of error functions i'll
410:14 - need error statements i'll need
410:17 - so depending on that i've just created
410:18 - them
410:20 - so coming back to your create user
410:25 - right
410:26 - here
410:28 - now we will start validating
410:30 - uh the email so we'll say
410:33 - validators dot
410:35 - validators is the package that we have
410:37 - created together right this one
410:40 - and the function that we created in that
410:41 - package was is email
410:43 - valid
410:47 - and you is
410:49 - the variable that you defined and now
410:51 - after unmarshaling the request that you
410:53 - uh in the body body is of the request
410:56 - that you got from let's say postman or
410:58 - from the terminal as json you captured
411:01 - that in you
411:02 - so now you can now golang can easily
411:05 - understand you because it's unmarked
411:06 - right it's not json anymore so you can
411:09 - access u.e mail
411:11 - and
411:12 - you can run the validation function on
411:14 - it so here the spelling is wrong
411:16 - so it should have been
411:18 - is email valid
411:20 - and you'll return
411:22 - nil
411:24 - errors
411:26 - dot new
411:28 - error
411:30 - invalid
411:32 - email
411:36 - right and
411:40 - now the reason why i created this
411:43 - uh error is because
411:45 - i want to
411:46 - see if that user already exists
411:48 - right so if that user already exists
411:49 - then you don't need to create it so we
411:50 - need to throw an error
411:52 - so we'll check
411:54 - if the user already exists right so i
411:57 - won't put that comment actually i was
411:58 - just trying to show you
412:00 - so
412:01 - to check if the user actually exists you
412:03 - have to run the fetch user function you
412:05 - will say u dot
412:06 - email comma table name comma diana
412:09 - client
412:13 - and
412:16 - you'll
412:17 - capture whatever
412:18 - comes from this function in current user
412:20 - and we won't handle the error so i'll
412:22 - put a
412:23 - blank there
412:26 - so if current user is not equal that
412:27 - means there is
412:29 - this user exists right
412:31 - if current user is not equal to nil
412:34 - and
412:35 - length of
412:37 - current user dot
412:39 - email
412:41 - is not equal to zero
412:44 - then you return
412:45 - nil comma
412:47 - errors dot new
412:50 - error
412:51 - user already exists
412:57 - and so all of this if the user exists
413:00 - but if the user doesn't exist you will
413:02 - just save that user right so how do you
413:04 - save that so first to save that
413:06 - obviously
413:07 - uh whatever you now have in you you want
413:09 - to start
413:10 - um
413:13 - you want to start marshalling it right
413:15 - so that dynamodb can understand it now
413:18 - so you'll say dynamodb
413:21 - attribute dot
413:22 - marshall map
413:26 - you
413:30 - and you'll capture this in av
413:35 - and you'll check for the error
413:38 - so if there's an error we'll return nil
413:40 - and errors dot new
413:43 - error could not
413:47 - marshall
413:48 - item
413:51 - which we've already defined we've
413:52 - already defined this error right
413:56 - and
413:58 - now
413:59 - you want to start creating your
414:02 - um
414:03 - data that you will be sending to
414:05 - dynamodb
414:06 - so how would you do that you'll say
414:07 - dynamodb
414:09 - dot put
414:11 - item
414:12 - input
414:15 - item is av
414:18 - comma
414:20 - table name is aws dot
414:23 - string table name
414:27 - and finally you'll say
414:30 - dynaclient
414:32 - dot port item
414:35 - and you'll send
414:37 - this input that you've defined here so
414:38 - yes missed the is equal to sign by
414:41 - mistake
414:43 - similar to fetch users right you created
414:45 - this input and then you call the dyna
414:46 - client function similarly you're doing
414:48 - that the same thing here you're calling
414:50 - the put item
414:52 - function
414:54 - and you'll capture that
414:57 - in a blank character blank variable or
414:59 - and or you'll get an editor from here
415:01 - and if
415:02 - error is there then you'll just handle
415:04 - it very easily you'll say return l comma
415:07 - headers dot new
415:10 - error
415:11 - could not
415:12 - time output item right you've created
415:14 - this error already
415:15 - but if everything went well you just
415:17 - want to return
415:19 - the user
415:24 - awesome
415:27 - so this is your create user function
415:31 - and now you're
415:34 - left with update user and delete user
415:38 - everything else you have taken care of
415:39 - right the handlers.go file is complete
415:41 - api response is complete as as
415:43 - email validate is complete and main.go
415:45 - is complete
415:48 - and i think for our user file we have uh
415:53 - imported all the packages except for
415:55 - validators so you need validators so
415:57 - you'll say
415:58 - github.com the validators package that
416:00 - you've already created we talk i'm
416:02 - talking about that one so we'll say go
416:04 - serverless yt
416:07 - slash pkg slash
416:11 - validators
416:13 - let me also check what else am i missing
416:16 - for handlers i think i've already
416:18 - imported user
416:20 - and i don't need any more packages
416:23 - for api response
416:26 - um
416:27 - i don't need more packages
416:30 - for is email valid i don't need anything
416:31 - else
416:32 - my main.go file probably i might have
416:35 - missed something so it has handlers it
416:37 - has os
416:38 - events lambda aws session dynamodb
416:41 - dynamic dbi face
416:42 - so everything is proper based on the aws
416:46 - sdk go right check out this
416:48 - documentation you'll know why i'm
416:50 - importing these packages and how i've
416:52 - used these functions you already know
416:54 - that because you've been
416:55 - building it with me all right
416:57 - um
417:00 - then we'll come here again back to our
417:02 - user.com file
417:04 - and let's start working on the update
417:05 - user function
417:08 - so what does it accept accepts request
417:12 - which is of type events
417:15 - dot api gateway request comma table name
417:19 - which is string comma
417:21 - dyna client which is of type dynamodb i
417:24 - face
417:26 - dot dynamodb
417:29 - api
417:32 - returns a user the updated user
417:35 - and
417:36 - or i mean i mean r it sends back an
417:39 - error
417:41 - and we're going to do a lot of things
417:43 - which are going to be very similar to
417:44 - the create user function which is
417:46 - basically we create the user
417:48 - first we create the user right which is
417:50 - the variable u which is of type user
417:53 - and we're going to unmarshall just like
417:56 - we did
417:58 - uh we're going to unmarshall the
418:00 - request body that you get so request dot
418:04 - body
418:05 - comma ampersand you
418:12 - so by mistake
418:15 - um yeah so i have to close the bracket
418:17 - here because
418:19 - this is together
418:21 - and
418:22 - this is this variable u
418:26 - okay
418:28 - and
418:29 - here are not equal to nil
418:31 - if you don't want to follow along you
418:32 - can just copy and paste this part right
418:33 - i'm not copying and pasting because uh
418:36 - this syntax might be new to many people
418:38 - because it's dynamite kind of working
418:40 - with dynamodb
418:41 - so i'm uh writing everything by hand
418:44 - but if you want to copy and paste if
418:45 - you're very comfortable with dynamodb
418:48 - go ahead and do that you don't need to
418:50 - you know practice along with me
418:54 - then you want to fetch the user and see
418:55 - if that user even exists so you'll say
418:57 - u.e mail comma table name comma
419:01 - then a client
419:04 - and you want to capture that in current
419:07 - user
419:14 - and you want to check for that current
419:15 - user so
419:16 - if current user
419:19 - not equal to nil
419:21 - this is exactly what you did in the
419:23 - create
419:24 - function as well
419:26 - and length of
419:28 - current user dot email
419:32 - is equal to equal to zero
419:38 - then you'll return nil comma
419:42 - errors dot new
419:44 - error
419:46 - user does not exist
419:50 - so for the create user function we were
419:51 - checking uh for the user associated with
419:54 - that email because we wanted to see you
419:56 - know if that user only exists we don't
419:58 - want to add that user but for update
420:00 - we're doing the reverse we're checking
420:01 - for that user because
420:02 - only that user exists we can update the
420:05 - data for that user makes sense
420:07 - and
420:09 - exactly the same things we'll do because
420:11 - now we want to start so now that the
420:13 - user uh you know um
420:17 - if the user doesn't exist we'll throw an
420:18 - error but if the user exists then you
420:20 - want to start
420:21 - updating
420:22 - the table with the new data how do you
420:24 - do that whatever you've unmarshaled
420:26 - right now from json to you know
420:28 - unmarshalled to something that golang
420:30 - understands now you want to start
420:31 - marshaling it to something that animaldb
420:34 - understands
420:35 - so you already know what you want to use
420:36 - you want to use the marshall map
420:37 - function
420:41 - i want to pass you to it because you've
420:42 - just unmarshaled
420:45 - and
420:46 - which package is a part of so it's part
420:48 - of the dynamodb
420:51 - attribute package
420:57 - we'll capture it in a variable called av
421:00 - or we'll get an error
421:02 - and now we can easily handle the error
421:03 - so we'll if error not equal to nil
421:07 - return l comma
421:10 - errors dot new
421:12 - error could not martial item this one
421:17 - really really straightforward now you
421:19 - just want to create your input item and
421:21 - then you want to just call the dyna
421:22 - client function
421:23 - only two steps remaining so you'll say
421:25 - input is equal to ampersand dyna
421:28 - modb
421:31 - dot put item input
421:34 - and the item is
421:37 - equal to av
421:39 - comma the table name
421:42 - will be equal to aws dot
421:44 - string
421:46 - table name
421:50 - and the last thing is you'll use dyna
421:52 - client
421:54 - dot put item
421:58 - and you'll pass the input
422:06 - and if error not equal to nil
422:10 - nil comma
422:13 - errors dot
422:18 - new
422:19 - error
422:21 - could not dynam output item
422:24 - return ampersand u comma nil
422:30 - so now even my update function is
422:32 - complete everything looks okay
422:34 - and all i want to do now
422:39 - is
422:40 - um
422:42 - run the
422:45 - gomot id command
422:50 - to get all of the packages that
422:52 - are
422:53 - you know not there
422:59 - so i think it's taking a while
423:02 - i can't find my phone anyways
423:05 - so um
423:08 - while that's happening in the background
423:11 - we can start working on the delete user
423:12 - function
423:15 - so as you can see it's all
423:18 - installed
423:20 - i had a couple of issues actually
423:22 - um as you can see
423:24 - and most of the issues were because i
423:25 - had a couple of spelling mistakes here
423:27 - instead of sdk i did an skd you know so
423:30 - a small small few mistakes i had made
423:33 - just make sure you get these right um
423:37 - you can easily get them on aws sdk go
423:40 - um you know
423:42 - documentation or if i put mostly i'll
423:44 - put this code on github
423:46 - so you can just pick it up from there
423:49 - all right make sense
423:50 - just pick it up from there instead of
423:52 - typing it all yourself because i made a
423:54 - couple of mistakes so it was taking a
423:56 - while
423:56 - but now it's installed all these
423:58 - packages
424:01 - so in your user.go file everything works
424:04 - perfectly right
424:05 - like we don't know if it works perfectly
424:07 - but everything looks perfect to me
424:09 - and all the packages are in place
424:11 - all you need to do now
424:14 - is work on your
424:16 - read user function which is actually the
424:18 - most
424:20 - actually the like the easiest function
424:21 - so it takes request
424:24 - event start
424:25 - api gateway request comma table name
424:29 - which is of type string
424:30 - done a client which is a type already
424:32 - know you already know that
424:34 - dot
424:35 - dynamic api all right
424:40 - so what do you want to put in the
424:41 - function definition you want the email
424:43 - of the user right
424:44 - so request dot
424:46 - query string parameters
424:49 - and the parameters
424:51 - email
424:52 - then you'll create your input to the
424:54 - function which is of type dynamodb
424:59 - and dot
425:01 - delete item input
425:03 - item
425:06 - input
425:14 - star
425:15 - dynamodb
425:17 - dot attribute
425:21 - value
425:24 - basically you're passing the email and
425:26 - then finding the user and deleting that
425:28 - user with it associated to that
425:29 - particular email right
425:31 - nothing complicated
425:33 - so you'll say aws dot
425:37 - string
425:39 - and you pass email to that
425:43 - after this you'll say table name
425:46 - here ws dot string
425:49 - pass the table name
425:54 - and now that you have your input ready
425:56 - just like we've done all other functions
425:58 - you take the dyna client
426:00 - you call the dynamodb function which is
426:02 - delete item in this case
426:04 - and
426:06 - you pass the input to it
426:08 - input basically has your query for
426:10 - deletion which is
426:11 - the email id
426:15 - and you get the error
426:18 - and if there is an error
426:24 - you'll return
426:26 - errors dot new
426:29 - error could not delete item
426:33 - perfect
426:37 - otherwise you just return nil nothing
426:39 - basically that means that the user has
426:40 - been deleted now i'm sure there are a
426:42 - lot of errors
426:44 - because i'm not using any
426:46 - type checking extension or any golang
426:48 - extension right so there will be a lot
426:50 - of errors here
426:51 - so i need to start solving them one by
426:53 - one before i deploy it to the cloud
426:57 - so to find those issues and to fix them
427:00 - i'll head over to my terminal
427:02 - and i'll head over to the cmd folder and
427:05 - i'll say go build
427:08 - main.go
427:09 - and
427:10 - starts giving me errors right so it says
427:14 - on this file
427:16 - line number eight
427:18 - um yeah i can see the issue it has to be
427:21 - double right that's what makes it the
427:24 - or operator
427:26 - so
427:27 - you'll run the command again and now
427:28 - you'll get all these nice
427:31 - errors that we were expecting right and
427:33 - now you want to go start solving them
427:35 - one by one
427:36 - so starting from line 37 all the way to
427:38 - line 145 too many errors so when it says
427:40 - too many errors that means that even
427:42 - after you solve these it'll give you uh
427:44 - many more errors right
427:46 - so this is why i don't really you know
427:49 - use
427:50 - extensions because
427:52 - because golang takes care of everything
427:53 - it tells you which exact line which part
427:56 - what you're missing you don't like
427:58 - it's a no-brainer right you don't have
428:00 - to apply a lot of brains just solve
428:02 - these issues just like woodland wants
428:03 - you to and everything will run so that's
428:05 - why i'm so chilled out all the time man
428:09 - so if i can go back to your
428:12 - code
428:13 - on line 37 what could be the issue it's
428:16 - that i have not put comma here and comma
428:19 - here
428:19 - basic syntax issues right that's what it
428:21 - says it says basic index issues
428:24 - here also you need to put a comma
428:26 - and let's keep putting commas wherever
428:28 - you know i think
428:30 - um
428:32 - it will
428:34 - uh need commas so this needs comma here
428:37 - which is line 58 in my case you can
428:39 - check it out where
428:40 - you know it is for you
428:43 - for create user again
428:45 - i'll just put a comma here just to be
428:46 - sure
428:47 - and i'll put a comma
428:51 - in the input part which is
428:53 - this
428:56 - all right
428:58 - and in the update user function
429:01 - again let's go to the input
429:05 - area
429:07 - here i've put the commas so i don't see
429:09 - any issues here
429:11 - and for delete definitely you need to
429:13 - put a comma here as well as here
429:17 - as well as here so
429:21 - now if we run it
429:25 - a lot of the errors have gone away right
429:27 - and now you have
429:29 - some other errors
429:31 - there are some syntax errors also like
429:33 - four syntax errors and one
429:37 - this one also that you're not able to
429:40 - refer to this function so let's try and
429:42 - fix those as well at the same time
429:48 - so let's hover over back to our code let
429:51 - me see the line first line says 88
429:55 - line 88 blah blah blah blah blah yes
429:59 - m is small whereas m should be large
430:02 - what was i thinking am i stupid
430:04 - you know that i was not able to
430:07 - that i didn't make the m uh you know
430:09 - large because obviously the
430:11 - function is martial map with
430:13 - the capital m right so this just means
430:15 - that no matter how stupid you are golang
430:17 - takes care of everything right so you
430:19 - don't need to be the smartest guy on the
430:20 - planet
430:21 - so let's look at other stupid mistakes
430:23 - one zero eight
430:26 - comma missing it's a syntax error super
430:28 - simple right it's even telling you
430:30 - expecting comma right i mean
430:33 - how obvious can
430:35 - error statements be and then people you
430:38 - know tell me download this extension i
430:40 - don't have downloaded any extension man
430:41 - golang does everything for me
430:43 - and uh missing statement after label 125
430:47 - 125
430:49 - missing statement after label blah blah
430:51 - blah blah blah yeah obviously
430:54 - the is equal to sign is off
430:57 - and then 147 147
431:01 - put a comma here auto after 147
431:05 - and then
431:07 - unexpected
431:10 - yep
431:11 - found it
431:14 - now let's run it now let's see some more
431:16 - errors
431:18 - yes so it found us some more errors
431:21 - and now you have to go to line number 66
431:23 - 76 and 140
431:25 - but these are not
431:29 - syntax errors so here you'll have to
431:31 - think a little bit as to why there's an
431:33 - error there
431:38 - so head over back to your code on line
431:40 - 66. line 66
431:46 - yeah so it says
431:48 - let's look at the error it says
431:50 - cannot use results dot disorder items
431:54 - and something something something to do
431:55 - with this function called unmarshall map
431:59 - that is because you're receiving items
432:01 - not item you're receiving multiple items
432:03 - right so you can't use that marshall map
432:05 - function here you'll just re use
432:07 - unmarshall
432:08 - list
432:10 - of maps
432:13 - super simple man super simple 76 line 76
432:19 - all right it says blah blah blah blah
432:21 - blah
432:22 - request our body see it says request dot
432:24 - body undefined
432:27 - and it also says does not have body with
432:30 - capital b
432:32 - right
432:33 - i mean you don't you can be the
432:35 - stupidest person on the planet and fix
432:37 - this issue because you just had to make
432:39 - this b capital right
432:41 - so that's how intuitive go language and
432:44 - then you go to line number 140 line
432:46 - number 140 i mean i can guarantee you
432:49 - that you can't do any like something
432:50 - like this with any other language right
432:52 - it says there's a problem with this
432:53 - function obviously because there's a
432:54 - spelling mistake here
432:56 - parameters so everything is fixed now
432:59 - and now let's see
433:01 - so it gives me another error that says
433:03 - unmarked list of map is wrong yeah
433:06 - because i made a mistake again it should
433:07 - have been
433:08 - unmarshalled list of maps
433:11 - not map
433:13 - awesome
433:16 - so now
433:18 - now that your user.go file is
433:20 - sorted as in it first shows you the
433:22 - syntax errors you've solved them then
433:24 - you solve the logical errors and now
433:26 - it's giving you some issues with the
433:28 - handlers file right handler.com it's
433:29 - giving you all these syntax errors we'll
433:31 - solve them then we'll give you some
433:33 - logical errors we'll solve them as well
433:35 - and then we're good to go all right so
433:36 - we're on the right path
433:38 - and now let's
433:39 - go back to our code
433:42 - so open up your code and start from line
433:45 - 19 line 19.
433:48 - put a comma here
433:50 - line 42
433:53 - 42 per comma here it's because saying
433:56 - it's exactly expecting a comma from you
433:57 - right
433:58 - and line 54
434:02 - put a comma
434:03 - line 59
434:06 - blah blah blah blah blah blah comma
434:09 - line 66 and 72 96 for a comma 72 for a
434:14 - comma
434:16 - all right
434:19 - now you start getting the real
434:21 - errors right the real errors
434:23 - so um line 22 we just solved this issue
434:26 - on the other file line 22
434:29 - because the spelling of parameters is
434:31 - wrong
434:32 - and now you want to worry about
434:37 - line
434:38 - nine
434:40 - line nine
434:44 - so one thing to notice is that it's line
434:46 - 9 but of another file api response would
434:48 - go so
434:49 - open up the api smaller go file and here
434:53 - i can see there's an issue
434:59 - all right
435:00 - i have fixed the issue it was basically
435:01 - to do with
435:03 - uh those brackets and now it's starting
435:05 - to show me
435:06 - issues with main.go file which is what i
435:08 - want i want to fix the main.go file
435:11 - issues but on line 44
435:14 - line 44
435:15 - let me see what's happening
435:18 - okay yeah i can see it i can see the
435:20 - issue it's basically
435:22 - all the cases have to be together
435:26 - and by mistake i'd written this outside
435:29 - the bracket
435:30 - also the switch bracket
435:32 - and i've included inside
435:35 - so that error should also go away
435:38 - and now when i do this it's created the
435:41 - go build may not go file for me so let
435:44 - me see if it has yeah i can see the main
435:47 - file i just have to
435:49 - move it here
435:50 - to my build folder
435:52 - and i've created the build file without
435:54 - any issues no errors right
435:57 - so now let's start
435:59 - uh the deployment process
436:02 - before you do anything else you need to
436:04 - first
436:06 - create a zip file so you'll just
436:10 - come here you'll say zip minus jrm
436:14 - build
436:15 - slash main.zip
436:18 - from build
436:20 - slash main so build is your folder main
436:23 - is the build that you've created for in
436:24 - your folder and
436:26 - build slash main.zip will be the zip
436:28 - file using the zip function maybe in
436:30 - your linux you don't have zip you'll
436:32 - have to install it using sudoku apt-get
436:35 - zip
436:37 - so
436:39 - now if we check here
436:41 - we can see the main.js file in my build
436:43 - folder
436:44 - and now we're ready to kind of start
436:47 - uploading it on lambda or aws lambda
436:51 - but as remember as you remember i told
436:53 - you that i have windows installed on
436:55 - that i'm running the wsl on that i'm
436:57 - running this
436:58 - ubuntu and on top of that i've built
437:00 - this
437:01 - folder right so i need to be able to
437:04 - access this main.zip file from my
437:07 - uh windows
437:09 - from my windows to be able to install
437:11 - like upload it on my hero player school
437:13 - and lambda aws lambda
437:15 - dashboard so for that i'll do something
437:18 - [Music]
437:21 - so to in order to help me to do that i
437:23 - have to run
437:24 - this command explorer.exe
437:29 - dot
437:31 - and now hopefully it should open yeah it
437:34 - has it has opened up the
437:36 - explorer at this location for me and
437:39 - i'll copy this
437:42 - i'll put this on my desktop
437:47 - awesome
437:48 - and now i can start to deploy this on my
437:50 - aws console
437:53 - so you want to start deploying
437:55 - but there's one thing i wanted to change
437:56 - is this
437:58 - table name
438:00 - so i'll keep this table name same as my
438:02 - other name of my
438:06 - program
438:09 - go serverless yt
438:12 - okay just for consistency's sake
438:14 - because we will have to create this
438:15 - table in dynamodb
438:18 - and
438:20 - let me just search
438:23 - uh if i was using the other table name
438:25 - sorry i'll just ctrl z
438:27 - and i'll just see if i was using this
438:28 - table name anywhere else in any other
438:30 - file
438:34 - oh it's this only place there's only one
438:36 - place i was using it
438:38 - so here's the table name has to be
438:39 - changed
438:40 - you will say go
438:42 - serverless righty
438:46 - okay
438:47 - and now is when we start deploying
438:49 - so
438:50 - log into your console
438:52 - and head over to lambda you have to just
438:54 - create function
438:56 - go
438:58 - serverless
439:00 - right
439:02 - so we're using golang one point x i
439:03 - think we'll have to change the uh
439:06 - execution rules create new role
439:09 - from aws policy templates this option is
439:11 - what you have to select
439:13 - and the role name
439:14 - go
439:15 - serverless
439:17 - righty
439:19 - executor
439:20 - from the templates you have to choose
439:25 - simple microservice permissions create
439:27 - function
439:28 - successfully created right
439:31 - now you want to change the handler
439:36 - so as you know our main uh the file that
439:38 - we'll be uploading is called the main
439:40 - file that's what our build is called
439:42 - right so we'll have to change the
439:43 - handler to main upload
439:47 - the zip file and upload it go back to
439:50 - aws
439:53 - and go to dynamodb
440:07 - and you will click on
440:10 - create table
440:13 - table name so table name is what you
440:15 - selected here go server syt
440:18 - simple right because we have kept
440:19 - everything
440:22 - with the same name so
440:26 - and primary key so it says enter the
440:28 - partition key name i think this is the
440:30 - primary key
440:31 - yeah it's the primary key so the primary
440:33 - key in our case is email
440:36 - which is string obviously
440:40 - and everything else is same and we can
440:42 - just create the database active it's now
440:45 - active so now you can proceed to the
440:47 - next stage
440:49 - which is
440:50 - configuring your
440:51 - api gateway
440:54 - so head over to your api gateway
441:03 - create api
441:06 - you want to build a rest api
441:12 - protocol is test
441:14 - select new api here
441:17 - and now you want to put the api name
441:20 - which is go
441:23 - serverless
441:24 - yd
441:28 - and
441:31 - you then create the api
441:41 - from the actions
441:45 - select create method
441:48 - select any
441:56 - and here you'll select integration type
441:58 - lambda function
442:00 - and
442:01 - check this use lambda proxy integration
442:05 - and give the name of the lambda function
442:07 - here which is
442:10 - go serverless yt
442:14 - and you have to also have to ensure this
442:16 - is checked default timeout
442:36 - now we need to deploy our api so
442:40 - from actions
442:43 - deploy api
442:48 - select new stage
442:50 - stage name is staging
442:54 - and
442:55 - deploy
443:05 - so this is
443:06 - your url that you get here
443:10 - which you will be using right now to
443:14 - test
443:17 - so let's test it out i'm
443:21 - expecting some errors to be there
443:23 - but not a problem
443:25 - let's clear our screen
443:28 - and
443:29 - um
443:31 - first we'll have to build this command
443:32 - so just give me a second
443:35 - so here are my four commands
443:39 - and obviously uh this is
443:42 - post which is creating a user this is
443:44 - get all users get a particular user by
443:46 - email id
443:48 - and this last command is for
443:50 - update
443:51 - now we can use postman or you can you
443:53 - just use curl which is the same thing
443:55 - right and you set your header and you
443:57 - tell it what's the request which is post
444:00 - and the data that you need to send which
444:01 - is email which is my email address my
444:03 - name my last name
444:05 - and
444:06 - this is the the unique link that i just
444:08 - got
444:10 - this
444:11 - link is the unique link that i just got
444:13 - from my
444:15 - invoke url okay so
444:17 - i'll post these comma i i'll post this
444:19 - command somewhere how do i post it now
444:21 - okay so i'll what i'll do is i'll upload
444:23 - this project on github and then in the
444:24 - description i think i'll just post these
444:26 - commands so that you know you can just
444:27 - copy and paste them directly
444:30 - uh i think that'll be the best option or
444:32 - you can just use postman i mean you have
444:34 - to use these commands if you don't want
444:36 - to all right
444:39 - and similarly for uh the update
444:42 - you say it's request put you give the
444:44 - new data is going to find email based on
444:46 - that because emails are primary key as
444:48 - you already know
444:49 - and this is my api link
444:53 - these are the four commands i need one
444:54 - more command which is
444:58 - the delete command
445:02 - so i'll change that
445:05 - to this
445:10 - so you'll get all these in the um
445:16 - an api gateway documentation on how to
445:18 - call these apis you can get that also
445:20 - and so i'm just copying those and i'm
445:22 - just changing
445:23 - uh those commands all right
445:26 - so what we'll do now is we'll try and
445:28 - test it
445:30 - i'm pretty sure there'll be some error
445:31 - it'll fail
445:33 - but
445:35 - let's do it anyway
445:45 - oh so it worked it worked all right so
445:48 - it created this user
445:49 - which is amazing
445:51 - let's run the second command
446:01 - sorry this command
446:09 - and now it's not copying and pasting it
446:15 - now we're running the get all users
446:17 - command
446:18 - so we'll get all the users so only one
446:20 - user is there so it's getting that
446:22 - and
446:24 - then we'll get the particular user
446:26 - the particular user has this email id
446:29 - it will get that user also for me
446:30 - because there's only one user right now
446:35 - yeah so that's also working and now we
446:38 - will work on our
446:41 - put
446:43 - function so
446:44 - it's taking my
446:45 - email address and changing my first name
446:47 - to la la la and last time to blah blah
446:49 - blah blah blah right so it's done that
446:51 - so even update is working
446:53 - and now we have to work on
446:55 - the delete function
447:01 - so if the delete function works
447:04 - it won't
447:06 - return anything so we'll check
447:09 - if that user is still there so we're
447:12 - getting all the users
447:16 - so that means delete work because it's
447:18 - an empty array right the same user is
447:20 - not there anymore
447:22 - perfect
447:23 - so that means everything is working i
447:24 - hope you enjoyed uh this tutorial
447:27 - uh it's a it's a long video i know
447:29 - there's a lot to follow there's a lot to
447:31 - learn there and i hope you really
447:33 - enjoyed it i hope you learned a lot in
447:34 - this uh
447:36 - project
447:37 - and um very soon i'll have i'll have one
447:39 - more project coming up with serverless
447:41 - stack but it's a little more advanced
447:42 - we'll have multiple lambda functions
447:43 - we'll have cloud formation we'll have
447:45 - you know those cloud formation scripts
447:47 - so and everything will be through
447:49 - uh you know yaml files and then aws cli
447:52 - and we'll also use aws sam for the
447:55 - entire setup so that's going to be
447:56 - really complicated um so make sure
447:58 - you've done the aws lambda uh you know
448:01 - that video and you have done this
448:02 - serverless video and then you read up a
448:04 - little bit more about how serverless
448:05 - works and all the aw technologies and
448:07 - that will really help you in the next
448:09 - upcoming video that'll be slightly
448:11 - longer actually much longer and they'll
448:13 - have like way more complicated project
448:15 - right so the point of that is where this
448:17 - is like a monolith serverless project
448:19 - right that will be serverless
448:21 - microservices project there will be api
448:24 - gateway cloud formation
448:26 - uh there will be a lot more technologies
448:28 - i will use aws sam for all the writing
448:31 - all the
448:32 - configuration files
448:33 - anyhow so i hope you're enjoying it and
448:35 - do subscribe to this channel if you
448:36 - haven't already and there are hundreds
448:38 - of videos on golang on my channel check
448:40 - them out and i also keep sharing some
448:42 - nice advice on uh you know your
448:45 - development career so you keep watching
448:47 - that as well
448:48 - all right so see you uh and connect with
448:50 - me on linkedin there's the linkedin uh
448:52 - link in my description box below thank
448:54 - you in this video we're doing something
448:56 - very interesting we're building an
448:57 - intelligent chatbot so till now we've
448:59 - built many slack bots but most of them
449:01 - have had a hard coded
449:03 - command and response but in this case
449:05 - we're building an nlp aware completely
449:08 - intelligent slack bot so we'll be using
449:10 - four different technologies one is
449:11 - obviously golang because we'll be
449:12 - writing the code in golang then we have
449:14 - slack to interact with the bot
449:16 - then we have vit dot ai to understand
449:18 - nlp responses and wolfram to actually
449:21 - run the computational models and can get
449:23 - the responses from the internet okay so
449:26 - vid is a technology that facebook has
449:29 - developed it's very similar to
449:30 - dialogflow by google or lex by amazon
449:33 - and you can basically train it to
449:35 - understand different um
449:37 - sentences so for example if i want to
449:38 - find out who the president of india is
449:40 - uh so you can have uh different type of
449:42 - queries right you can ask him uh you can
449:44 - ask the what who is the president of
449:46 - india or
449:47 - who is the president of india now or
449:49 - who's currently who's the current
449:50 - president of india so all of these
449:52 - things right all of these statements
449:53 - they uh
449:55 - they basically mean the same thing that
449:56 - who's the president of india right now
449:58 - right but then uh
450:00 - slack doesn't understand it golang
450:01 - doesn't understand it so vet is the
450:03 - intelligent nlp part where vic can be
450:05 - trained with all these hundreds of
450:07 - different statements to understand that
450:08 - you're basically trying to say the same
450:10 - thing so it so it basically uh creates
450:12 - like a confidence score to uh tell you
450:15 - that okay i've understood the query now
450:17 - and uh you know i understand your
450:18 - question so what is that nlp
450:20 - intelligence engine right and then once
450:22 - you have once it has understood the
450:24 - query you can send it to wolfram
450:26 - world fam is the competition and so
450:28 - wolfram has the answer of who the actual
450:30 - president of india is it doesn't have
450:31 - that answer wolfram has that answer so
450:33 - so vit basically can be trained with
450:35 - hundreds of different sentences to
450:36 - actually understand uh what your query
450:39 - means and then it will send the query uh
450:41 - to wolfram and then we'll get the answer
450:43 - and then uh you know we'll get the
450:44 - answer to slack so let me take you
450:46 - through the entire diagram of how we're
450:47 - going to do it so the user will enter a
450:49 - message it goes to slack
450:51 - and slack then sends the message to us
450:54 - go lank server golang server then sends
450:55 - it to vit
450:56 - whit then sends it again to golang
450:58 - server and from there we can again send
450:59 - to vol from because there's no
451:00 - connection between width and volt ram
451:02 - and slack and width right so our golang
451:04 - server is going to be the connection
451:05 - between all of these things from wolf
451:07 - wolf ram we want to send the response to
451:09 - slack so it has to go through our golang
451:10 - servers right everything i'm sure makes
451:12 - sense now
451:14 - and there are going to be some packages
451:15 - that we'll have to use to interact with
451:17 - it to interact with cool uh wolfram to
451:19 - interact with slack so slacker is my
451:21 - favorite package if you've done my other
451:23 - previous slack bot tutorials i'm sure
451:25 - you know that there are many on my
451:27 - channel so you can go ahead and do those
451:28 - as well so slacker is the package that i
451:31 - often use so you can look at this somali
451:34 - slash lacquer right on it go on github
451:36 - so i've kept these tabs open because all
451:37 - of these uh are important to us so
451:40 - that's why i've kept all of these tabs
451:41 - open right i'll take you through all of
451:42 - these one by one so slacker is the um
451:46 - wrapper on top of the slack go package
451:48 - uh which is a wrapper on top of the
451:51 - slack bear uh api right right so this is
451:54 - like a third level abstraction of uh how
451:57 - we can build a slack bot and this makes
451:58 - our job very very easy so that's why i
452:00 - always use slacker so now that i've
452:02 - shown you this i can cancel it out i can
452:04 - you know close that tab then we'll be
452:06 - using uh with our commands that we get
452:09 - from slacker the user that he enters the
452:11 - command it we process it and are using
452:13 - our slacker and then
452:14 - uh we send it to witco right uh using
452:17 - vidgo vs into vid and that's how of it
452:19 - will process it
452:21 - so with go you can think of it as a
452:23 - wrapper uh around wits apis written in
452:26 - golang so you can use this as functions
452:28 - you all you have to just call these
452:29 - functions that are written in with go
452:32 - all right
452:33 - and now uh
452:35 - with gives us some response that we need
452:37 - to we need to send to wolfram right but
452:38 - the response that vid gives us has
452:40 - uh it's a really big uh
452:44 - json
452:45 - and to process that json
452:46 - it's uh it's quite challenging in the
452:48 - sense that uh
452:50 - if
452:51 - if you know how to work with json with
452:52 - golang you know that it's not very
452:54 - straightforward you have to use struct
452:55 - sometimes you have to use unmarshalling
452:57 - and all that
452:58 - so uh i found this package called gjson
453:01 - so first let me close fit go so i found
453:04 - this packet called g json it helps you
453:06 - query json very very easily so for
453:09 - example and now this guy is a genius
453:10 - obviously so i have to give him that so
453:12 - ted wall
453:13 - or actually there are so many more
453:15 - contributors in him so these guys are
453:17 - geniuses because they have built a
453:19 - package that helps you
453:21 - take a json like this and then just
453:24 - access them like you would in something
453:26 - like javascript right which is so simple
453:28 - so you if you wanted to get name uh so
453:31 - inside this entire json object is this
453:33 - uh key value pair called name which is
453:36 - an object itself so you can if you
453:38 - wanted name and last you could just say
453:40 - name dot last right and you could get
453:42 - access to anderson
453:43 - and if you have worked with golang you
453:45 - know how difficult it is to actually
453:47 - restructure
453:49 - a json object like this and then get an
453:51 - actual access to something like this
453:53 - right
453:54 - so uh so this library makes it very easy
453:56 - and i'm going to use this in this video
453:58 - and also in the future videos i'm
454:00 - trying to use this a lot more uh so that
454:02 - that will save us a lot of time right
454:04 - building all these structs and then
454:06 - unmargining and marshalling it and then
454:08 - trying to access this value and it's a
454:10 - lot of work so we'll use this ge json
454:12 - right so now that i've shown this to you
454:14 - i'll just close it off
454:17 - and
454:18 - uh to work with wolfram now wolfram is a
454:21 - big uh technology right it has a lot of
454:24 - apis it's quite complicated
454:26 - so there is somebody who has written a
454:28 - go wolfram
454:30 - uh package for us
454:32 - now this
454:34 - looks simple but as you can see there's
454:36 - so many structs right all these
454:38 - different stocks are there
454:40 - that help you to work with that help you
454:42 - to basically translate or unmarshal the
454:44 - data coming from the apis and then it's
454:46 - a big file it's just one file but it's a
454:48 - big file
454:51 - right so somebody has done it for us
454:53 - they're calling the wolfram uh api
454:56 - and then getting all the data for us all
454:57 - right
454:58 - so all we have to do is just call the
454:59 - functions inside
455:01 - the go over from package
455:03 - like so
455:04 - right so you can create a client you can
455:06 - get query results
455:08 - simple and straightforward
455:10 - so we'll be using google form like i
455:11 - said and we'll just close that off right
455:12 - now
455:14 - and the other thing that we need to use
455:16 - uh
455:17 - you know uh so you know that the way i
455:20 - manage uh environment so i don't uh so i
455:23 - since i make very beginner friendly
455:24 - videos i don't try and confuse you with
455:26 - uh you know trying to set your
455:28 - environment so i just use os dot set
455:31 - environment and os dot get environment
455:32 - that's i do something very very simple
455:34 - and straight forward but
455:36 - this is the right way of uh setting that
455:38 - environment so
455:39 - i'm uh if you might also know that i'm
455:42 - also a ruby developer i've been a ruby
455:43 - developer for many many years and ever
455:46 - since golang
455:47 - you know i started using golang i
455:48 - stopped using ruby uh many years back
455:51 - so uh so this is a go uh you know
455:54 - implementation of
455:57 - very famous and rupees.nbc very popular
455:58 - ruby gem right dot and here you call
456:00 - them libraries but in ruby you call them
456:02 - gems so this is very very popular and
456:04 - this lets you manage
456:06 - uh and your environment variables very
456:08 - easily right so all we'll have to do is
456:10 - we'll have to create a dot and file and
456:12 - we'll put all of our
456:14 - uh you know keys there and then we'll be
456:16 - able to just uh load it simply with go
456:18 - dot invert load and then we can easily
456:21 - use them with os.get and environment
456:23 - variables right
456:24 - so
456:25 - this also means that i won't be pushing
456:26 - my environment file into github so you
456:29 - need to create your own environment file
456:30 - with your your own apis api keys so pay
456:34 - attention when i show you how to get
456:35 - your api keys
456:37 - uh
456:38 - because that can be confusing to some
456:39 - people right
456:41 - so this is the golang sorry the wolfram
456:45 - uh portal
456:46 - uh
456:48 - now one one uh thing that i have to tell
456:50 - you about wolfram uh website is it's
456:52 - very slow uh it can be a frustrating
456:55 - experience to work with it because the
456:57 - website somehow is stuck in the 19 uh
456:59 - sorry the early 2000s it's not
457:01 - it's not a new website it doesn't work
457:02 - like a modern website would and the api
457:05 - is also kind of shaky so obviously the
457:07 - the wolfram go package makes it easy for
457:09 - us but uh but i'm just telling you
457:12 - because
457:12 - if you can see this it's still lowering
457:14 - since yesterday actually so
457:17 - don't get frustrated just try to you
457:19 - know be patient and also it gives you
457:20 - only 2 000 requests
457:22 - per month so and it you can make only 20
457:25 - apps uh at one go otherwise you'll have
457:27 - to upgrade so just make sure you stay
457:29 - within those limits if you don't want to
457:31 - uh pay a lot of money to upgrade all
457:32 - right
457:33 - and
457:35 - i have created these two projects here
457:37 - so
457:38 - if you want to create a new project
457:40 - you can just go ahead and say get an app
457:41 - id
457:44 - and before that obviously you have to
457:46 - sign in to you have to create an account
457:47 - in wolfram alpha you have to sign up and
457:49 - then you have to head over to
457:49 - developer.wolfram.alpha.com
457:52 - and uh as you noticed i clicked get an
457:55 - app id a long time back and sometimes
457:57 - you have to refresh it
457:59 - and sometimes very weirdly it would have
458:01 - logged me out but no not today it has
458:03 - not logged me out now so anyhow so i'll
458:05 - just click it again so now it's asking
458:06 - me for my application name so i'll say
458:08 - uh new
458:10 - nlp all right so i'll send you an lp
458:12 - what
458:12 - this is the youtube
458:16 - demo
458:17 - bot
458:18 - if you don't give a description it won't
458:20 - let you create a new app so i'll say
458:21 - create an app
458:24 - so it has given me this app id but but i
458:27 - won't be using this app id i'll be using
458:29 - my old app id the the one that i had
458:32 - created yesterday which is the nlp what
458:34 - uh sorry the wit ai one which has uh
458:37 - already has 13 total queries the reason
458:39 - for this is very simple uh with wolfram
458:42 - uh if you have not uh if you've not
458:45 - waited for 24 hours uh it won't let you
458:47 - use uh
458:49 - as in it gives you a lot of error
458:50 - sometimes and unpredictable type of
458:52 - error so it says
458:54 - uh you know invalid app id or some some
458:56 - editor like that so i looked it up on
458:58 - stack overflow and the answer that i
459:00 - found was that you have to wait 24 hours
459:02 - sometimes or at least 12 hours for the
459:04 - api to work correctly so
459:06 - uh if you create an api right now api
459:08 - right now chances are you won't be able
459:10 - to
459:11 - run this program properly and we'll say
459:12 - error app id invalid or something like
459:14 - that okay
459:16 - so that's the thing with wolfram alpha i
459:18 - know there are a lot of quirks with this
459:20 - so basically just remember to get
459:22 - your uh
459:23 - app id from here and that's all that's
459:26 - all you need to do at wolfram also
459:28 - website
459:29 - all right so just copy and paste it with
459:30 - yourself
459:32 - and then let's come to vid ai so here
459:35 - you'll have to log in using facebook
459:36 - because it's a technology built by
459:39 - facebook so we'll say continue with
459:40 - facebook
459:42 - it takes a while
459:46 - so i have all these bots built up and
459:49 - now we'll create another app called new
459:51 - app
459:51 - and let's call it then
459:53 - i already have a new llp so i'll just
459:55 - say with ai
459:57 - i'll just call it
459:59 - youtube demo all right
460:01 - so
460:02 - remember to keep it open and we'll say
460:04 - create and language is english
460:07 - and now it has
460:09 - a couple of things on on the left side
460:11 - right so you have your intense entities
460:13 - so we'll go to intense we'll create an
460:14 - intent
460:16 - and we'll call it
460:17 - uh
460:18 - let's see if there's a
460:20 - wolf ram intent already
460:23 - so there's no old friend intent
460:26 - so we'll just call it
460:27 - wolf
460:28 - ram
460:30 - and next
460:33 - right so we have this
460:34 - uh intent
460:36 - now we'll have to create entities so
460:37 - we'll create an entity
460:40 - and we'll
460:42 - find a built-in entity so we'll
460:44 - look for wolfram
460:46 - so the integration between wit ai and
460:48 - wolfram is so deep that they actually
460:50 - have an entity called wolfram search
460:52 - query so
460:53 - vdi would come to know that this is a
460:54 - wolfram search query and needs to send
460:56 - it to wolfram
460:57 - so it'll give us a relevant format so
460:59 - we'll say next
461:01 - and now we have our entity setup and
461:04 - this role is added by vitiai themselves
461:07 - and now whatever uh you send it to uh
461:10 - with ai right these will show up in your
461:12 - utterances so we won't actually write
461:14 - utterances and train our vti right now
461:16 - this is that's not the scope of this
461:17 - video you can find thousands of videos
461:19 - that train your vti or your dialog flow
461:22 - bot right we won't be training it we
461:24 - will be sending it very straightforward
461:25 - questions that will just identify as
461:28 - uh
461:29 - a wolfram uh
461:31 - query and send it forward so for example
461:33 - if i said
461:34 - what uh sorry
461:36 - who is
461:38 - the president
461:40 - of india right
461:42 - so with 92 confidence it is understood
461:44 - uh this question right so we don't have
461:46 - to train it right now that means
461:48 - so um but if you wanted to train it for
461:51 - this sim same query with multiple
461:53 - different uh statements you could do
461:54 - that right so anyways we won't be doing
461:57 - this like i said we won't be training it
461:59 - we're just sending it straight queries
462:01 - which are directly sent to wolfram
462:04 - so now that i've shown you the go dot
462:06 - end package i'll just delete that i'll
462:08 - just close that tab as well and i've
462:10 - shown you this video
462:11 - uh which doesn't work anymore so we'll
462:13 - close it so we won't be using any of the
462:15 - packages that have been used in this
462:17 - video we're completely rebuilding
462:18 - everything from scratch
462:20 - so we'll close this as well
462:22 - and we just need to keep our uh
462:25 - you know these videos tabs open just in
462:27 - case you need your uh
462:29 - app id so yeah i'm not showing you how
462:31 - to get your app id and video right so
462:33 - all you have to do i think um i don't
462:36 - remember correctly you go to settings
462:38 - and you will take your server access
462:40 - token this is the one that you want to
462:42 - take
462:43 - all right so just copy and paste that
462:45 - copy and keep it for now at least
462:48 - then let's go to our slack so
462:51 - slack
462:52 - i'll have to go to
462:57 - dot com api.slack.com apps
462:59 - and here
463:00 - uh
463:02 - if you have done my previous uh slack
463:05 - bot tutorials which there are plenty of
463:07 - you have built all these bots with me
463:09 - and today we are building another bot
463:11 - from scratch
463:12 - and we'll call it the youtube
463:15 - demo app all right and i'll select all
463:18 - tech as my space
463:23 - so it's called youtube demo and you have
463:26 - to switch on the socket mode so that it
463:28 - can catch up messages in real time so
463:30 - we'll say enable
463:32 - and we'll call it the socket token
463:37 - generate
463:39 - and you need to save this somewhere and
463:41 - keep it
463:43 - and but i'll come back for all of these
463:45 - api keys uh you know but you can keep
463:47 - them somewhere safe if you want
463:50 - and then we'll go to our event
463:52 - subscriptions
463:53 - we'll have to switch these on and we'll
463:55 - have to give it some events to subscribe
463:57 - to so we'll say app mention because
463:59 - we'll mention our bot
464:02 - and then we'll say message.im
464:09 - so these are the events that the bot
464:10 - will subscribe to so that it comes to
464:12 - know when something is happening so like
464:13 - let's let's say somebody mentions the
464:15 - bot and sends it a message it will come
464:17 - to know right
464:18 - so i'll just say
464:19 - message.groups as well
464:22 - and
464:23 - i will say
464:26 - messenger npm i am
464:30 - and i think that is about it i don't
464:32 - need to add any more
464:34 - uh events
464:37 - so always the trick with the slack is
464:40 - add more events than you think you'll
464:41 - need and add more oauth permissions so
464:43 - we'll come here and we'll add some oauth
464:45 - permissions so for now i'll just save
464:46 - these chinese changes
464:48 - exchange is saved let's go to oauth
464:50 - permissions
464:51 - and
464:53 - here we have to
464:56 - add some more scope so these scopes were
464:58 - added based on the events that we
464:59 - subscribe to but we have to add more
465:01 - scopes right so again with scopes the
465:03 - trick is to take more scopes from your
465:06 - from oauth of slack than you need so for
465:08 - example i need uh this one here
465:12 - called channels read and
465:14 - chat
465:15 - right
465:17 - because i wanted to be able to write to
465:18 - a channel right
465:19 - and i will say
465:23 - i am read and i am right instant message
465:25 - i am basically stands for instant
465:27 - message
465:30 - and i'll say mpm i am an npm read and
465:32 - write as well
465:36 - i might not need most of these
465:38 - permissions but i'm just going to keep
465:39 - them anyways like i said you know you
465:41 - uh they're so if you've seen one of my
465:43 - like my previous videos of slack you
465:45 - know that a lot of uh errors happen
465:48 - because you don't have enough
465:49 - permissions and slack the problem with
465:51 - slack is it won't even give you errors
465:53 - uh the right errors right so you'll keep
465:54 - struggling with the error for a long
465:56 - time and you won't know what happened
465:57 - because you won't get the right error so
465:59 - and most of them are to do with uh
466:01 - permissions
466:02 - in the sense your bot just won't work
466:03 - and you won't come no why it's not
466:04 - working
466:05 - so i think i have all the permissions
466:07 - that i needed and
466:09 - that is about it for me and i'm going to
466:11 - install it to my workspace
466:13 - and asks me
466:15 - if i can give it these permissions i
466:17 - said allow
466:19 - so now it's given me a bot user token so
466:22 - this is important and in our
466:24 - basic information the slack the socket
466:26 - token educated and that's that's
466:27 - important right
466:29 - so it's called the youtube demo just
466:30 - remember that so we'll have to
466:32 - uh
466:35 - refer it right
466:37 - we'll have to mention it in our slack
466:38 - channel
466:39 - so if we go to our slack channel and i
466:42 - say
466:44 - youtube
466:45 - demo
466:49 - so uh it's his youtube demo is not in
466:52 - this channel yet so do i want to add it
466:55 - i'll say yes add channel so add youtube
466:57 - demo to this channel
466:58 - only then we'll be able to
467:00 - interact with it right
467:02 - now
467:03 - what we'll do is we'll actually start
467:04 - creating that project
467:06 - so i'm not sure if you can yeah i think
467:08 - you can see my power shell so even if
467:11 - you're on windows or uh which is which
467:13 - is i am i'm in windows and i'm using
467:15 - powershell even if you're on ubuntu and
467:17 - using terminal or mac using terminal the
467:19 - commands will be exactly the same
467:21 - so what i'll do is i'll say
467:25 - mkdir
467:27 - and youtube
467:28 - demo
467:30 - nlp
467:32 - all right
467:33 - so i'll just
467:34 - go inside that
467:35 - and here i'll say go mod in it and
467:38 - github.com
467:44 - and it'll be what
467:47 - so uh the mod file is initiated like
467:50 - this so if you're from a javascript
467:51 - background this is very similar to npm
467:52 - in it so it creates a mod file which
467:55 - contains all the package that we'll be
467:56 - using in this project
467:59 - and this is the direct
468:01 - the absolute link that we'll use to
468:03 - access other files in our project so i'm
468:05 - not sure why the enter is not working on
468:07 - this maybe something to do with my
468:08 - internet
468:15 - yeah so it has created a mod file let me
468:17 - just check
468:18 - now what we have to do is we have to
468:20 - start getting our packages that we need
468:22 - the external packages
468:24 - that we'll be using in our project
468:26 - so you can give these in commas or you
468:28 - don't if you even if you don't give them
468:29 - it's not a problem so you'll say
468:30 - github.com
468:32 - slash
468:38 - uh if you're from a javascript
468:40 - background this is exactly the same as
468:43 - npm install and this is the name of the
468:44 - package and this is the github link for
468:46 - it
468:49 - so
468:49 - like you have uh the npm library the npm
468:52 - website nbmjs.com where all these
468:54 - packages decide uh golang doesn't have
468:56 - something like that so you have to get
468:58 - everything from github.com
469:00 - right
469:01 - and
469:03 - what we'll also do is we'll get go get
469:05 - github.com
469:09 - slash
469:11 - dot env
469:16 - and when you also get go get
469:20 - github.com
469:22 - slash
469:24 - uh the
469:29 - the slacker
469:30 - slack bot uh library that we need
469:35 - and we need
469:37 - the g json the one that allows us to
469:39 - query
469:40 - json with golang
469:47 - json
469:49 - sorry you have to write go get in front
469:51 - of it
469:54 - and then the last one we need is
470:03 - [Applause]
470:06 - vidco
470:07 - the one created by alex
470:09 - so we have all the packages in place
470:12 - and all we have to do is
470:15 - open up our vs code
470:16 - and start writing the project
470:18 - right
470:19 - and here obviously the file that you'll
470:21 - create is main.go
470:23 - on top you'll write package main
470:27 - you'll write import and import all the
470:28 - packages that you need
470:32 - and here you'll have to
470:34 - write the main function so we'll say
470:37 - funk main
470:40 - and the funk main will have
470:42 - quite a bit of a code
470:45 - and at the same time
470:47 - we will have our dot and b file
470:50 - in the dot envy file you'll have four
470:52 - things one is
470:55 - slack
470:57 - bot token
470:59 - then you have your slack app token
471:03 - then you have your bit
471:04 - ai
471:05 - token
471:07 - and your wolfram
471:12 - app id
471:14 - right
471:16 - so volfam app id have shown you how to
471:18 - get it right from where to copy it
471:20 - i already have it copied in some place
471:22 - in my laptop so i'm just going to come
471:23 - and paste it here
471:25 - with ai token i've already shown you
471:26 - where to get it from
471:29 - copy and paste it here
471:33 - and then we have our slack bot and slack
471:35 - app token
471:36 - for the slack
471:39 - bot token you'll get that in your
471:42 - oauth and permissions you'll get your
471:43 - slack bot token and in your basic
471:45 - information
471:48 - you'll get your slack app token here in
471:51 - socket token that we created the one
471:53 - that starts with xapp is your slack app
471:55 - token the one that starts with xp is
471:56 - your slack bot token all right
471:59 - so now that that's clear i'm going to
472:01 - copy and paste my
472:03 - uh
472:05 - sorry i forgot to copy my
472:07 - tokens so i'll just copy this i'll say
472:09 - copy
472:11 - and
472:13 - this is my slack app token
472:16 - and slack what token
472:19 - i have to go back
472:21 - to oauth and permissions
472:25 - and copy it
472:32 - so our environment file is ready
472:35 - now we will have to import some packages
472:38 - that i know we'll use when we
472:41 - will use context
472:45 - and coding slash json
472:48 - we'll use fmp to print out stuff
472:51 - and json to you know work with json log
472:56 - and os for our environment variables
472:59 - and as of now i need
473:03 - slash shoho slash
473:05 - go dot environment
473:08 - right
473:09 - we we need uh other packages as well
473:11 - with for working with slack and wolfram
473:13 - and width but i'll
473:14 - introduce them one by one
473:18 - so
473:19 - in our funk main
473:21 - the first thing that we write is go
473:24 - dot environment
473:27 - and here we'll use the load function to
473:29 - load
473:30 - the environment file
473:33 - okay
473:35 - then we'll create a bot
473:37 - so we'll say bot
473:40 - is equal to so here we have to create a
473:43 - new client for our slack bot
473:45 - and that can only be done
473:48 - if you have the slacker
473:52 - package so we'll say github.com
474:02 - okay so let's create our bot
474:04 - the bot basically will have
474:06 - slacker dot
474:09 - new client
474:11 - os
474:12 - dot get environment
474:16 - and slack bot
474:18 - token
474:21 - comma os
474:22 - dot get environment
474:27 - slack
474:28 - app
474:29 - token
474:31 - so these are the two things required for
474:33 - our bot
474:35 - so let me see if the brackets have been
474:37 - properly closed
474:38 - so we have
474:41 - we have an extra packet here by mistake
474:43 - to remove that
474:46 - and there's one more extra bracket here
474:47 - by mistake so we have to remove that as
474:49 - well
474:50 - so all the squiggly lines have gone away
474:52 - and uh there's a squig line here with
474:54 - bot it's saying
474:55 - it's declared but not used but we'll use
474:57 - it soon so you do not worry about that
474:59 - and then there are squiggly lines with
475:00 - all these packages
475:02 - you will be using all these packages
475:03 - soon
475:04 - so you don't have to worry about them as
475:05 - well
475:06 - okay
475:08 - now uh since we are in the process of
475:10 - creating these
475:12 - different variables
475:14 - i think it's uh a good time to create
475:16 - our with ai client and our
475:19 - wolfram client as well
475:21 - or
475:21 - [Music]
475:24 - maybe i'll do that after a while anyways
475:26 - so
475:28 - one thing that i have to do is i have to
475:30 - create a
475:31 - function
475:32 - called print command
475:36 - events
475:38 - if you followed my other
475:39 - slack tutorials as well slack slack bot
475:42 - tutorials then you know that
475:44 - this function is simply to print out the
475:47 - events
475:48 - that the bot uh
475:50 - subscribes to so whenever we put a
475:53 - give a command to a bot
475:55 - uh it acts as an event and it uh
475:56 - publishes to the
475:58 - command line we want it to be open to
475:59 - the command line so that we come to know
476:01 - what's happening so we'll create this
476:02 - function now
476:04 - so this function will be created above
476:06 - funk main
476:08 - and as you know we'll call it print
476:11 - command events
476:17 - so in one of the previous videos i've
476:19 - already
476:20 - explained
476:21 - uh the inner dynamics of this function
476:23 - basically your
476:25 - passing command event here
476:33 - and we'll save for event
476:36 - we'll just range over this analytics
476:38 - channel
476:42 - and we'll
476:44 - print the
476:45 - timestamp
476:46 - of the command the command itself
476:49 - the parameters that it received
476:51 - and the event name
476:54 - so let's say fmt dot
476:57 - println
477:00 - we'll say command
477:03 - events
477:06 - and fmd dot
477:08 - println again
477:11 - event dot
477:12 - timestamp
477:15 - fmt dot
477:16 - print ln again
477:19 - say event dot
477:21 - command
477:23 - fmg dot brilliant render
477:25 - and event dot
477:28 - parameters like i said
477:30 - and the event itself
477:34 - [Applause]
477:38 - and just an empty line
477:44 - so our
477:50 - print command events function is ready
477:52 - now i had a couple of packages here and
477:54 - when i pressed
477:55 - save
477:56 - since i'm using this uh
477:59 - golang
478:00 - plugin it removes all the packages that
478:02 - i'm not using the code right
478:05 - so by mistake don't press ctrl s because
478:08 - it will remove all the packages that we
478:09 - had uh you know written here but it's
478:11 - not a problem so what this uh golang
478:13 - plugin does also does is that when i use
478:15 - a package here it also adds it here on
478:17 - top so it's a two-way street
478:21 - anyhow so we have written our command
478:23 - for printing the uh the events the
478:25 - command events
478:27 - and now we'll start working on our
478:29 - uh
478:32 - pod.com function which basically handles
478:34 - the command that we'll send to the bot
478:37 - but before that we just have to write in
478:39 - some code
478:40 - that will help us
478:43 - stop the program and we wanted to so
478:44 - we'll say context dot
478:47 - with
478:48 - cancel
478:50 - again this is standard code that we've
478:51 - written in
478:52 - all of our previous
478:54 - uh
478:55 - slack bots right slackbot codes
479:00 - so in case you're new to this channel
479:01 - there are hundreds of i won't say
479:03 - hundreds with here at least tens of uh
479:06 - slackbot tutorials do check take a look
479:08 - to check them out
479:10 - is equal to bot dot listen
479:13 - ctx
479:15 - and if there is an error that means
479:18 - error not equal to nil
479:22 - we will say log dot
479:24 - fatal
479:26 - and we log out the error all right
479:28 - so like i said this is standard code
479:31 - and i'm using the log package here and
479:33 - now it's installed the package for me
479:34 - it's imported that right
479:37 - earlier it was giving this quick line
479:38 - here
479:40 - so we have uh the
479:42 - outlines of our function ready and now
479:44 - comes the main part which you need to
479:45 - pay a lot more focus to
479:47 - attention to sorry it's the bot.command
479:50 - function which basically helps us to
479:53 - uh
479:54 - you know understand the commands
479:56 - that we give to the slackbot and then
479:58 - work with that so we'll say bot dot
480:01 - command
480:04 - and here we'll uh you know put the
480:06 - command that we'll send to the plot
480:08 - and here we'll say slacker dot command
480:11 - definition
480:13 - and inside command definition is where
480:14 - all the magic will happen
480:16 - all right
480:17 - so
480:18 - this function obviously the command
480:20 - function is part of the slacker library
480:23 - and this is the syntax
480:26 - the requirements of the function itself
480:28 - and it has
480:30 - uh
480:32 - a description
480:33 - so we'll say let's say
480:35 - send any question to wolfgram
480:40 - and has an example
480:42 - again like i said you know this is
480:43 - coming all coming from the slacker
480:45 - library it's not something that we are
480:46 - building up
480:47 - uh all these are requirements of the
480:50 - slacker library
480:53 - so this is an example right example
480:55 - question
480:59 - these are uh both are static variables
481:02 - these are just the description and the
481:03 - example of how the spot will be used
481:05 - right these are not dynamic
481:08 - so we'll say handler handler is our
481:10 - function that helps us to
481:12 - work
481:13 - with the bot or with the
481:16 - different uh you know commands and when
481:18 - i pressed enter it
481:20 - it filled in all these things for me
481:22 - automatically
481:24 - so in case you're not using a golang
481:26 - plugin and it's not filled in these for
481:27 - you just make sure you
481:29 - get this right otherwise this code will
481:31 - also be on
481:32 - github and you can easily pick it up
481:33 - from there
481:35 - so we'll say query
481:37 - which is a variable and we'll say
481:39 - request
481:41 - so handler functions if you've seen my
481:44 - rest api videos of golang you know that
481:46 - you have
481:48 - requested response objects right so
481:51 - request is what the user is sending to
481:53 - this function to our golang program
481:55 - and in the request you will have
481:57 - parameters if you've ever worked with
481:59 - rest apis you know what parameters are
482:01 - so the parameter that you're looking for
482:04 - let's say it's called a message right
482:06 - and here that means we have to uh give a
482:09 - query something like that so we'll say
482:11 - query for
482:13 - bot
482:13 - right put a dash here
482:16 - and to pass a param in a function
482:21 - uh to to slack when you pass a param you
482:24 - have to pass it like this so we'll say
482:26 - message
482:27 - and so what you're
482:28 - telling to go language is that in the
482:30 - request there'll be param called message
482:34 - so when we
482:35 - send a command to our slack bot it'll be
482:37 - like query for bot and then we'll put a
482:38 - dash and we'll put the actual uh
482:41 - statement and the statement itself will
482:42 - be captured inside query
482:44 - and then this query is
482:46 - going to be sent to
482:48 - uh you know
482:50 - wherever like uh wit ai and wolfram
482:54 - now there is a
483:05 - there seems to be an issue here i think
483:07 - we have to put a comma that's what the
483:11 - vs code is telling me so i've put a
483:13 - comma here and the
483:14 - squiggly lines have gone away
483:16 - so everything looks good and query
483:18 - there's a squiggly line here because it
483:19 - says it's declared but not used right
483:23 - now
483:23 - what we'll do is
483:26 - we'll come here we'll say
483:30 - client
483:31 - dot parse
483:33 - now client is going to be our with ai
483:35 - client which we have not we've not
483:37 - created till now
483:40 - so i think before i create my client
483:42 - what i'll do is i'll show you what the
483:44 - query looks like
483:46 - in
483:47 - the
483:48 - uh command line so i'll say fmd dot
483:52 - print line and i'll say query
483:56 - so when we send this uh query to the bot
483:59 - it's just going to print it out
484:01 - and then let's also
484:05 - keep a response here
484:09 - and the response will be very simple
484:10 - just be
484:12 - received all right
484:15 - now reply gives us a squiggly line
484:18 - because
484:19 - r has to be capital
484:21 - and now everything works
484:23 - except for this i don't know i could not
484:26 - import this package
484:28 - i think we'll have to just run go more
484:30 - tidy and
484:31 - reinstall it back again
484:33 - so i'll just go to my
484:35 - terminal and i'll say go mod
484:38 - diary even i have if i had installed the
484:40 - package i don't know why it wasn't
484:42 - recognized here
484:45 - so anyhow
484:46 - uh
484:49 - this is what uh
484:52 - the code looks like as of now and there
484:54 - seem to be no errors so what we'll do
484:56 - now is we'll start this program
484:59 - so we'll say
485:01 - go run main.go and let's see what
485:04 - happens
485:07 - okay now we'll head over to our slack
485:10 - and
485:12 - to our youtube demo app we'll say
485:15 - query for bot
485:17 - and we'll say
485:18 - what is the capital of india
485:23 - so all we need to know is
485:26 - that yes it was able to
485:28 - get the message so message now is what
485:30 - is the gavel of india so it's able to
485:31 - read it it's also able to print it out
485:33 - right
485:34 - so everything works as expected
485:38 - and
485:41 - this means we can
485:42 - now start writing the code
485:45 - so now we'll create our with ai client
485:49 - to do that you need to create a variable
485:51 - called client
485:52 - out here
485:55 - so let's say client
485:58 - and the walrus operator and then we'll
485:59 - save it ai
486:02 - we don't have ati in our project so
486:04 - let's get fit ai in our project so we'll
486:06 - save it
486:08 - ai
486:10 - and the package will be github.com slash
486:14 - weight ai slash
486:16 - wait go
486:18 - slash v2
486:21 - now we had installed this package but
486:23 - there's a possibility that uh
486:27 - golang wasn't able to get it it's okay
486:28 - we'll again run go mod id no problem
486:32 - so coming back here
486:35 - we'll save it ai
486:37 - dot
486:38 - new client
486:40 - we'll say os dot
486:42 - get
486:44 - environment
486:46 - and with
486:48 - ai token
486:50 - now again the reason that
486:52 - why
486:53 - golang is not able to get this for us is
486:55 - because
486:58 - because there's some issue with my go
487:00 - path obviously
487:02 - and since this is my windows laptop i
487:04 - won't try to fix it
487:06 - i use my linux laptop most of the times
487:08 - so just bear with me when i run go mod
487:10 - in it
487:10 - uh don't worry it'll install it back
487:12 - again for us
487:14 - so here we have our client with ai
487:16 - and it uses the vti token in our
487:19 - environment file all right
487:21 - so so far so good
487:23 - now it's giving us a sweet line here
487:25 - because we have not used our client
487:26 - package and that's what we'll be using
487:28 - here so we'll say
487:30 - client.parse
487:35 - and inside parts we'll write
487:37 - with ai ampersand with ai sorry in small
487:43 - what's wrong with my caps
487:46 - wait a i dot
487:48 - message request
487:51 - and side message request
487:55 - you will have to send a query
487:59 - and the query will be
488:01 - what you get from here from
488:03 - uh your slack bot so let me show you the
488:05 - diagram again all right
488:07 - you the user sends a message it goes to
488:08 - slack slack gives it to golang server
488:11 - and now we have to send it to it right
488:13 - so slack has given it to
488:16 - golang which is query and query has to
488:18 - be passed to vdi
488:20 - so i hope everything makes sense now
488:23 - and here we're going to print this out
488:25 - so we'll come here and we'll
488:29 - take these values in a variable called
488:31 - message
488:33 - comma blank
488:37 - and we'll print out the message here
488:42 - so now we'll run that program again and
488:44 - i'll show you why i've done this
488:46 - uh i'm not sure why it's telling me to
488:51 - get this package when i
488:53 - need the v2
488:56 - and if i say command s and i run go more
488:59 - tidy i'll just stop this program for now
489:02 - i'll say go mod
489:04 - tidy
489:06 - and it has got the v2 for us
489:09 - right so everything works now no errors
489:11 - here
489:12 - so we'll run the program again
489:14 - oh yes sorry sorry sorry sorry
489:17 - i'll run the program again i'll say go
489:22 - go run main.go
489:31 - and
489:34 - here we'll say
489:37 - at youtube demo
489:40 - query for pot
489:45 - what is
489:47 - the capital of india
489:53 - and it's able to get the message
489:56 - and now this is the reply that's coming
489:58 - from
490:00 - vta
490:01 - this needs to be structured i'm sure you
490:03 - agree with me that this needs to be
490:04 - structured because this is not something
490:05 - that
490:07 - world ram will be able to understand
490:08 - so we'll stop this program here
490:12 - and i'll just open up
490:14 - the vs code editor
490:17 - again
490:20 - so
490:22 - the message that's now in msg
490:25 - we have to do something about it right
490:28 - so we'll say
490:33 - we'll create a variable called data
490:35 - we'll put a dash here
490:37 - and the walrus operator and we'll say
490:38 - json dot
490:40 - marshall indent
490:43 - basically want to convert that whatever
490:44 - response that you saw you want to
490:45 - convert that into json
490:48 - so this adds the right
490:52 - spaces and everything
490:57 - so about four spaces is the right
491:00 - one two three four
491:02 - all right
491:05 - and uh this will add those uh if you've
491:08 - seen json objects you'll you'll see that
491:09 - all of the
491:11 - key value pairs they're covered in these
491:13 - type of
491:15 - inverted commas right so that's what
491:17 - the double inverted comma sorry
491:19 - so that's what the indent function does
491:22 - so json is giving a squiggly line here
491:25 - so if i put ctrl s that should give me
491:27 - the encoding.json package yes so i get
491:29 - that so there's only one error left
491:32 - which is data which is basically saying
491:33 - that i'm not using
491:35 - data
491:36 - and i'll create another variable called
491:37 - rough and i'll say
491:43 - convert whatever data i get into string
491:46 - format
491:47 - and we're going to print out
491:50 - basically
491:51 - this rough variable
491:55 - now let's see what happens
491:58 - we'll run the program again
492:05 - and here we'll say at youtube
492:09 - demo
492:11 - uh query for bot
492:14 - what is the capital
492:16 - of india
492:20 - it does says it'll say received and here
492:22 - we can see that we get a nice json
492:24 - object that now we can work with
492:26 - and uh the thing that you need access to
492:28 - is basically inside entities inside this
492:31 - wolf ram search query
492:33 - and inside that array inside that object
492:35 - inside the array and inside
492:38 - value
492:39 - that's what you need
492:41 - the
492:42 - reference to right
492:44 - and this value this is the thing that we
492:47 - need to send to
492:48 - wolfram now there is also a confidence
492:51 - score which is of 92 percent so
492:54 - uh 92 divided by 100 is 0.92 so so it
492:56 - gives us a range between zero and one so
492:58 - anything above 80 percent or even 70 is
493:00 - good
493:01 - and we could have
493:03 - you know taken our program further and
493:05 - we could have uh checked the confidence
493:07 - score and then uh given the query to
493:09 - wolfram but it's not a problem since we
493:11 - have not trained our bot to understand
493:13 - these queries as of now we won't uh and
493:16 - and our vita ai is directly going to
493:18 - forward these queries to voltram we
493:19 - don't have to worry about the confidence
493:21 - score right now okay
493:22 - so you'll stop this program now
493:27 - and it does give a little error a
493:29 - problem time to you know stop it
493:32 - and here you'll come back here again
493:36 - and
493:38 - uh
493:40 - now like you know you need access to
493:42 - this thing right
493:43 - inside entities inside this inside the
493:45 - area inside the
493:46 - object inside
493:48 - value now to get access to this ngo line
493:51 - is very difficult it's not like
493:52 - javascript you just you know start
493:53 - accessing this uh working with this
493:55 - object directly because golang does not
493:57 - have native support for json
493:59 - because json is javascript object
494:00 - notation so only javascript has
494:03 - native
494:04 - access to it
494:06 - so what we'll do is
494:07 - we'll create a variable called value
494:09 - because we need that value right inside
494:10 - entities
494:12 - and we'll use our package the json
494:14 - package
494:15 - and with the json package you can just
494:17 - run these get queries to get whatever
494:19 - you want so we're
494:20 - going to run the get get query on this
494:22 - variable called ref
494:24 - and
494:26 - we want to say entities so i want access
494:29 - to my entities
494:30 - and i want access to this width dollar
494:33 - wolf ram search query
494:35 - and uh you know colon wolfram search
494:38 - query right
494:39 - so let me write that here with
494:42 - dollar
494:44 - wolf ram
494:47 - search
494:48 - query
494:50 - colon
494:52 - wolf
494:55 - ram
494:58 - search
494:59 - query
495:02 - okay so just check if the spelling of
495:04 - wolfram is okay looks good
495:06 - and now we want to access
495:09 - the first value of this array right this
495:12 - is an array so we have access to this
495:14 - now we want access to this first value
495:16 - of the array so we do that in an array
495:18 - do that by dot zero right because that's
495:20 - the first value so with this package
495:22 - with the help of this package you can
495:23 - easily access
495:24 - the values inside an array so you'll see
495:26 - dot zero and dot
495:27 - value so let me show it to you again
495:30 - so dot zero which is this object and
495:33 - inside that is dot value and you'll have
495:34 - access to what is the capital of india
495:36 - it's just as simple as that
495:38 - now what we'll do is we'll actually
495:40 - print out this value so that
495:43 - you'll see exactly what i'm talking
495:44 - about and now we'll go here again we'll
495:46 - start the program again
495:49 - okay so it's telling me to get this
495:51 - package so
495:52 - let me go back here
495:55 - okay again i'll run go mod id
496:02 - and we'll run the program again
496:05 - [Music]
496:09 - okay
496:10 - and here we should say
496:13 - again the same query
496:16 - query for pot
496:18 - what is the
496:19 - capital of india
496:25 - here you can see
496:26 - we got the value the exact
496:29 - string that we want to send to our
496:30 - wolfram we have it here we were able to
496:32 - access it
496:33 - using
496:35 - our
496:37 - uh
496:38 - gjson package
496:39 - makes sense
496:42 - so uh with the help of uh this bot right
496:44 - we'll be able to send it send these kind
496:46 - of questions like who's the president of
496:47 - u.s who's the president of india who's
496:48 - the president of the u.s what is the
496:49 - capital of india who's the governor of
496:50 - china it'll give us the exact right
496:52 - answers
496:53 - uh because wolfram has the ability to
496:55 - process that kind of information give
496:56 - the right answers
496:58 - so let's see how it does that
497:04 - now create another variable called
497:06 - answer
497:08 - and this basically converts
497:12 - the value that i just received here into
497:14 - string
497:15 - okay because string is what we have to
497:17 - send to our
497:18 - voltron client
497:20 - now that means we'll have to create our
497:21 - world front grant right so we'll come
497:23 - here we'll say
497:25 - wolf ram client
497:29 - is equal to
497:31 - ampersand
497:33 - wolfram dot client
497:39 - inside that here in this case there will
497:41 - be these quickly brackets
497:44 - and we'll say
497:45 - app
497:46 - id
497:49 - os dot
497:50 - get
497:52 - environment
497:54 - and we'll say wolf
497:56 - ram app id
498:01 - all right so
498:03 - it doesn't our golang program doesn't
498:05 - have access to this
498:06 - so let's fix that
498:08 - so it's added that already actually
498:11 - good
498:12 - and then it's giving me error here
498:17 - okay i think i'll have to create a
498:19 - wolfram
498:20 - uh
498:21 - client actually
498:23 - a variable call voltron client so this i
498:26 - have to make sure the cs capital
498:30 - c has to be capital here
498:32 - and here i'll have to create a constant
498:41 - wolf ram
498:44 - plant
498:46 - and wolf ram
498:48 - dot
498:52 - client
498:54 - all right and the wolfram client comes
498:56 - from here
498:58 - everything looks good
499:07 - right
499:08 - now there seems to be an error here i
499:10 - don't know why
499:13 - missing constant value syntax
499:15 - sorry it has to be a variable actually
499:18 - or a constant
499:20 - so it's a variable
499:23 - and
499:27 - here so it has an error here it has an
499:29 - error here in this place
499:32 - and it has an error here
499:34 - because we are declaring it but not
499:36 - using it
499:38 - so now i'll come here
499:41 - to answer actually before that let me
499:43 - just
499:44 - stop this program
499:45 - and
499:47 - go more tight again so that we get the
499:49 - word from package
499:51 - and now the errors mostly have gone away
499:54 - except for
499:56 - these two errors right the word from
499:58 - clients so this the volume 10 we have to
499:59 - use right now
500:01 - so i have the answer here in a
500:04 - which is
500:05 - basically string in
500:07 - the value in string format and i'll say
500:11 - world ram client
500:13 - dot
500:14 - get
500:16 - spoken answer query
500:19 - now there's uh there's a confusion here
500:21 - that many people have is that
500:23 - uh the person who's created this library
500:26 - it should have said get spoken on
500:27 - security but it says get spoken in t
500:29 - there's a small t here so just make sure
500:31 - you write that t otherwise
500:33 - you will face a lot of problems
500:36 - so here we'll pass
500:39 - the answer
500:43 - comma the answer that we get here
500:46 - and wolfram
500:48 - dot metric
500:50 - comma 1000
500:52 - all right
500:53 - and we'll assign this to two different
500:54 - things one is the response and one is an
500:57 - error
500:59 - and
501:00 - if there's an error which means if error
501:02 - not equal to nil
501:05 - we will print out
501:11 - there
501:12 - is
501:14 - an error
501:17 - and the response
501:19 - we will send our
501:21 - response object
501:23 - rds right
501:26 - and to me everything looks okay
501:32 - and there seems to be no error as of now
501:37 - but only when we run the program we'll
501:38 - come to know
501:41 - so yeah everything looks good
501:43 - and what we'll now do is uh let me check
501:46 - if there's any uh
501:48 - more packages to be installed i don't
501:50 - think so
501:52 - okay so let's run this code go mod sorry
501:54 - go run main.go
502:01 - and
502:03 - to our youtube bot
502:06 - we'll say query for bot
502:09 - what is the capital of india
502:17 - so it can reply to us the capital of
502:18 - india is new delhi india
502:21 - and youtube
502:22 - bought query for bot
502:26 - what is the
502:28 - capital of china
502:35 - it takes a while because it goes to wait
502:36 - and then goes to voltram see colossians
502:39 - beijing china so as you can see our bot
502:42 - can understand anything you know it's
502:43 - really really powerful
502:45 - so let's say query for bot
502:48 - who
502:50 - is
502:53 - president of
502:55 - india
503:01 - at youtube
503:03 - query for pot
503:05 - who is the president
503:08 - of brazil
503:15 - so as you can see
503:17 - our bot can do anything
503:19 - it can basically
503:20 - uh find the answers for all of these
503:22 - very difficult questions uh that and uh
503:25 - difficult in the sense not for human
503:26 - beings or sometimes even for human
503:28 - beings because i didn't know the
503:29 - president of brazil is right so yeah you
503:32 - can get all of these answers from using
503:34 - your wolfram
503:36 - api
503:37 - so i hope uh you learned a lot in this
503:39 - video today and you built something
503:41 - really exciting and this is a very very
503:43 - powerful bot so if you're by the way if
503:45 - you're somebody who's looking for a job
503:46 - in golang uh i don't think there's a
503:49 - project that's better than this to show
503:50 - off your skills right because you're
503:52 - using golang you're using slack you're
503:53 - using
503:54 - uh and these all these awesome packages
503:56 - right environment packages and the json
503:58 - package
503:59 - and you're using um vid you're using
504:03 - wolfram and then the sky is the limit
504:04 - with it right you can i didn't show you
504:06 - how to train your vid bot but you can
504:08 - you know you can basically watch any
504:10 - other video on vid uh there are many
504:12 - videos on that focus on just how to use
504:13 - fit and you can
504:15 - actually you know scale this spot up to
504:17 - a whole new level right
504:19 - so
504:20 - i hope you learned a lot in this video
504:22 - and
504:23 - uh
504:24 - we built a board that can basically do
504:25 - anything right it's an nlp what and it's
504:27 - connected to wolfram so it can
504:29 - understand anything it can do anything
504:32 - so i won't say you can sign anything
504:33 - because we are not trained of it with
504:34 - api
504:35 - but if you trained it really well it
504:38 - would be able to do anything