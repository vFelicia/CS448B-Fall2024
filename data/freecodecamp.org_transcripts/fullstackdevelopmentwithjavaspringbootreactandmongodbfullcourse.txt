00:00 - In this course, you will learn
how to create a full stack
00:02 - application using MongoDB for
the database, Java and Spring
00:07 - Boot for the back end and react
for the front end. Farhan Hasin
00:11 - Chaudry teaches the back
end section of this course. And
00:15 - Gavin Lon teaches the front end
section of the course. Both
00:18 - these instructors are very
experienced and have created
00:21 - many popular courses. The
project featured in this course
00:24 - is a great example of the
creation of a separation of
00:28 - concerns between the client code
and the server code. By
00:32 - implementing a loosely coupled
architecture. These two parts
00:36 - implemented using different
technologies can evolve in
00:40 - parallel and independently from
one another. So let's start
00:43 - learning from Farhan. Hello,
everyone. Welcome to the Java
00:47 - with MongoDB course on the freeCodeCamp YouTube channel.
00:52 - I am for Han has ensured three
one of the instructors in this
00:55 - course and I will teach you all
about developing a back end API
00:59 - using Java EE Spring Boot, and
MongoDB. The other half of the
01:04 - course will be taught by
Katherine lOn. Hi, I'm Gavin
01:07 - lOn. I'm a full stack developer
and have over 20 years
01:11 - experience working as a software
developer. In this course, I'm
01:15 - going to be playing the role of
a front end developer. And my
01:18 - responsibility will be to
demonstrate building a front end
01:22 - using React js. The Spy
application that we are going to
01:26 - create will use HTTP GET
requests to appropriately
01:30 - retrieve data from a remote
server through communicating
01:34 - with the relevant API's
endpoints. And HTTP POST
01:38 - requests will also be made to
the relevant endpoints to
01:41 - appropriately save data on the
server side. Of course, our data
01:46 - will be stored within a MongoDB
database on the relevant remote
01:50 - server. So without further ado,
let's jump in and start working
01:55 - on our API. In the beginning of
the course, you will have to
01:58 - download two new software's from
the internet. The first one
02:02 - being Java Development Kit, or
JDK. If you already have JDK
02:07 - installed on your system, you
should be good to go with that.
02:10 - But just in case you do not have
it installed, I'd suggest you
02:14 - navigate to
oracle.com/java/technologies/downloads
02:20 - The link will be in description.
Once you have landed on the
02:23 - download page for Java, you may
find multiple versions of JDK
02:28 - available as of the recording of
this course there. The latest
02:32 - version is Java 19. And the
latest LTS version is Java 17.
02:37 - lts C stands for long term
support and JDK 17 will receive
02:42 - updates until September 2020 For
02:48 - JDK 19 On the other hand, will
receive updates only until March
02:52 - 2023 and will be superseded by
JDK 20. In many cases, when you
02:57 - are deploying a Java application
on a production server, it's
03:00 - suggested that you use LTS
release for better stability.
03:05 - And for this course I will stick
to Java 17 Since that's the
03:09 - latest LTS. Now depending on
when you're watching this
03:13 - course, there may be a new LTS
release so feel free to download
03:17 - and install that. So I've
switched to Java 17 And since I
03:20 - am on Windows, I will go to
windows and the 64 bit
03:24 - installer. As you can see, it's
only 150 2.85 megabytes and
03:29 - depending on your internet
connection, you it may take a
03:32 - few minutes to download.
03:34 - Once you have downloaded the
installer, make sure you have
03:36 - installed it on your system like
any other software you have done
03:40 - before. And since the
instruction is so
03:42 - straightforward, I will not
spend a lot of time showing you
03:46 - the entire process.
03:49 - After you have finished
installing JDK on your computer,
03:52 - open up your terminal window and
write Java C space double dash
03:59 - barsha.
04:01 - And if you don't get any errors
from this command, this is a
04:05 - positive sign and as it says
Java C 17 point 0.5 which
04:10 - indicates that I have
successfully installed seven
04:14 - point 17 point 0.5 version of
the JDK. Now Java C is the short
04:18 - for Java compiler which you may
or may not have already guessed.
04:22 - Apart from this command, you can
also use Java double dash
04:26 - version to check the version of
your Java Runtime Environment
04:30 - and as you can see it says 17
point 0.5 lts which means we are
04:35 - good to go.
04:37 - Since you have successfully
installed the jdk on your
04:40 - computer Next up you will need a
good code editor or IDE. When it
04:46 - comes to Java, there are plenty
of options out there. You can go
04:49 - into Eclipse or maybe configure
Visual Studio code. But I would
04:54 - suggest that you go with
IntelliJ IDEA. Now the people at
04:59 - Jet
05:00 - Ian's are known for making
really good IDE s and when it
05:03 - comes to Java IntelliJ IDEA is
pretty much the industry
05:07 - standard.
05:09 - Although the ultimate version
can cost you some money, there
05:12 - is also a free version available
by the name of Community
05:16 - Edition. Or to download IntelliJ
IDEA, navigate to
05:20 - jetbrains.com/ideas/download.
Again, the link could be in
05:25 - description and look for the
Community Edition. This is the
05:29 - flag download button here. And
depending on your platform, ie
05:33 - Windows, Mac OS or Linux, you
may get a different format. For
05:37 - example, if you're on Mac OS,
you will get a DMG image. And if
05:42 - you're on Linux, you will get a
tar file. So I'm on Windows and
05:46 - I want to download the exe
installer and not the zip one.
05:49 - So I'll select exe, and then hit
download. Now the IDE is a bit
05:56 - larger than the JDK in size at
649 megabytes. But again,
06:02 - depending on your internet
connection, it may take a few
06:04 - minutes to download. Once you
have downloaded the software,
06:07 - please go ahead and install it
like any other software that you
06:10 - have done before.
06:14 - Congratulations on you're
getting the JDK and IntelliJ
06:18 - IDEA getting installed. Next up,
you will need an account at
06:23 - MongoDB Atlas. Now you may or
may not already know that
06:27 - MongoDB Atlas is a platform from
MongoDB themselves that allows
06:32 - you to spin up MongoDB servers
on the cloud.
06:38 - So in order to use MongoDB
Atlas, you will have to maybe
06:41 - get to
mongodb.com/atlas/database.
06:46 - Again, the link will be in
description and use the Sign In
06:49 - button.
06:54 - Once in the sign in page, you
can either use your Google or
06:57 - GitHub account to log in or you
can sign up with your other
07:01 - email addresses for a new
account. Now, I already have an
07:05 - account on MongoDB Atlas. So I
will just use those credentials
07:09 - to log into my account off
screen. As you can see, I have
07:13 - successfully logged into my
account. And For first time
07:17 - users, you may have to set up a
new organization of sore just
07:22 - just put any name as the
organization name and you should
07:26 - be good to go. Since we are
using these for just our
07:29 - development purposes, it's okay
to just use any data that you
07:33 - have. So once you have set up
your organization, you can
07:38 - create new projects. So I will
hit the New Project button here.
07:44 - And I have to give my project a
name. Now since you are creating
07:48 - an API that is related to movie
I'll just call my movie API. And
07:55 - hit Next
07:57 - I will just go ahead and create
project since I don't have any
08:01 - other member to add.
08:13 - Extra now we are inside our
movie API project. And we are
08:18 - ready to create a new database.
So you can use the builder
08:22 - Database button here to create a
new MongoDB database on MongoDB
08:26 - Atlas. So just go ahead and
click this button.
08:30 - And there are three different
categories there is server list
08:34 - there is dedicated and there is
shared. Now for development
08:38 - purposes, our shared server
should be fine and it's
08:41 - completely free. But if you're
working on an application that
08:46 - that has some user and have some
real life usage, you may go with
08:51 - dedicated Serverless is
something else and maybe we can
08:54 - talk about it in a different
course some other day. So select
09:00 - Share, and hit create.
09:05 - Okay, next up, they will ask you
about which provider you want to
09:09 - use, I always go with AWS. Since
AWS has a server on Mumbai,
09:14 - which is near Bangladesh and has
the lowest ping for me, but if
09:19 - you like you can go with Google
Cloud or Azure. Now select
09:24 - whatever region is the nearest
to you to make sure that you are
09:28 - getting the lowest amount of
being possible. Next, you can
09:33 - choose a dear.
09:35 - Again, for free usage, we use
the aim zero sandboxed here it
09:41 - will give us 512 megabytes of
RAM which is more than enough
09:46 - for our usage we will have a
very small amount of data to be
09:50 - honest. And then next step there
are additional settings you
09:54 - don't have to touch them and the
cluster name. Now you can
09:58 - customize the cluster name if
you
10:00 - Wish but I will just leave it as
cluster zero since I like it
10:04 - that way, then hit Create
cluster
10:11 - Okay, next up, you will have to
create a new user for this
10:15 - cluster. You can also use an SSH
certificate, but I will just go
10:20 - with the old trusty username
thing. So I will name my
10:25 - usernames Solid Snake since I'm
a Metal Gear Solid fan, but you
10:30 - can name it anything you want.
Now, when it comes to password,
10:34 - make sure you are always
choosing a very strong password
10:37 - and not ones that are easy to
remember. Use a password manager
10:43 - maybe but always use hard to
guess passwords. So I will just
10:47 - use the auto generated secure
password.
10:50 - And I will also make sure that I
am copying my password to the
10:54 - clipboard, since I will be
needing this later on. But then
10:57 - hit the Create User button.
11:02 - It shows Solid Snake and the
password.
11:06 - And finally, you will have to
set up some IP access list. So
11:11 - the way it works, once you have
set up a new database, you will
11:15 - have to allow a set number of IP
addresses that can access that
11:19 - server. You know opening up a
database server to the world is
11:24 - not a good idea. Security wise,
so you should always use your
11:29 - current IP address here.
11:32 - But since this is just a course,
and we are using this database
11:36 - for development, I will open up
the server for all the IP
11:40 - addresses out there. And to do
that, you can write 0.0 dot 0.0
11:45 - slash zero and in the
description, you can just write
11:52 - a view
11:54 - and hit Add Entry. See that
that's there. And then click on
11:59 - finish and close.
12:01 - Okay, they will congratulate you
and whatnot Hi quickstart guide
12:05 - Yes, go to database
12:10 - disclose it.
12:13 - Excellent. Now we have a
database up and running on
12:17 - MongoDB Atlas. And we can use
this database ganache to eat
12:21 - read and write data from and to
eat.
12:24 - And using just like a local
database that you may have used
12:28 - in your computers, you see
MongoDB Atlas is a very
12:31 - beautiful service. I have used
it for development as well as
12:35 - for production in the past and I
have never had any bad
12:40 - experiences with it.
12:43 - So next up, you can use some
sort of database client to
12:47 - connect to this database, maybe
something like MongoDB compass,
12:52 - so you can go ahead and click on
Connect.
12:57 - And MongoDB will give you
multiple options that you can
13:00 - choose from. So first, you can
connect to your database server
13:04 - using MongoDB shell, you can
connect to the MongoDB server
13:07 - using your application that
you're working on right now, you
13:12 - can connect to MongoDB server
using MongoDB compass which is
13:17 - MongoDB own graphical user
interface for working with
13:20 - databases and I will just show
you that. Finally you can also
13:25 - connect using VS code. And let's
be connect using MongoDB compass
13:29 - for now.
13:32 - And I do not have MongoDB
compass on my computer. So I
13:37 - will be Windows 64 bit
13:44 - and I will just hit download
compass.
13:49 - Once you have downloaded and
installed MongoDB compass on
13:52 - your computer, you can start the
software from your start menu or
13:57 - desktop. Once you start MongoDB
compass it looks something like
14:01 - this where they are giving you
the option to connect to a new
14:06 - database by using this kind of
URI. Now where do you get this
14:13 - URI. If you come back to MongoDB
Atlas, you will see that they
14:19 - are actually giving that URI
right here.
14:23 - Just use this copy button to
copy the entire URI and go back
14:29 - to MongoDB compass. Now remove
this localhost URI from here and
14:35 - paste it yours. Now as you can
see it says MongoDB plus SRV
14:40 - Benue username, followed by a
colon and then it's looking for
14:46 - a password right. So what we are
going to do, we will use the
14:51 - password that we created earlier
and paste it in here. And then
14:56 - we'll leave everything as is and
we
15:00 - He can say Save and connect. You
can name it anything. So I'm
15:05 - naming it V Avi,
15:08 - you can change its color if you
want to, and say Save and
15:11 - connect.
15:14 - Okay, so it took a few seconds.
And as you can see, we have
15:18 - successfully connected to our
moving API cluster. Now, as you
15:22 - can see, there are two
databases, one of them is called
15:26 - admin. And the other one is
called Local. Now, we do not
15:30 - have to do anything with these,
these come by default with all
15:35 - the clusters out there. So just
leave them be and we will create
15:40 - new databases very soon. To
create a new database, you can
15:44 - always go and click this plus
sign.
15:48 - And inside database name,
15:52 - let's put b
15:56 - What really, let's call it
movie,
16:00 - API deep.
16:03 - And inside collection them. Now
if you're new to databases, like
16:09 - like MongoDB, or document based
database, you may or may not
16:14 - know that collections are like
tables in case of relational
16:20 - database systems. So in
something like MySQL, or Oracle
16:25 - database system, you have
databases, and inside those
16:29 - databases, you have tables. Now,
in case of MongoDB, and other
16:36 - non relational databases, you
have the database name first,
16:40 - and then collections. For
example, in our cases, we will
16:46 - have a collection of movies
where we will save information
16:51 - about different movies. So we
can say movies and in create
16:58 - database. So as you can see, we
have a new database sitting here
17:03 - movie API dv, and there is a
collection called movies. So
17:07 - right now, there is no data at
all.
17:13 - Now in order to work with our
API, it would be convenient if
17:16 - we have a bunch of data in our
collections. And if you navigate
17:21 - to github.com/ach, si n ch y,
which is my username and slash
17:27 - movies, you will get the entire
code for this API already
17:32 - written. And inside that
repository, you will see a
17:35 - folder that says underscore
data. Now inside this folder,
17:40 - there is a JSON file that you
can use as a source of data for
17:45 - the collection we have just
created. So I would suggest you
17:50 - go into this JSON file, then
select raw,
17:55 - and then hit CTRL S and say this
JSON file somewhere on your
17:59 - computer.
18:02 - So once you have downloaded the
file, you can then import it to
18:06 - your collection. To do so, come
back to MongoDB compass. And
18:12 - while you have the movies
collection selected, you can
18:16 - click on this Import Data button
or this Add Data button. Then
18:21 - select Import File. And our
format is JSON. And we'll select
18:27 - the file from our downloads and
movies dot JSON. And you can
18:32 - also take a stop on errors, then
hit import, wait a few moment.
18:38 - It done. And viola, we have the
information of n different
18:44 - movies on our database. So as
you can see,
18:48 - each of this movie is a document
Okay, as it as it says documents
18:55 - then. So inside the collection,
each of this movie are a single
19:01 - document. And what do we have
inside these documents? Well, we
19:06 - have an ID we have the IMDB ID
for this title whose inputs, we
19:12 - have the release date, which is
a string, we have the link for a
19:16 - trailer on YouTube. Then we have
an array of genres. So this
19:22 - particular movie belongs to five
genres. Then we have a link to
19:28 - our poster.
19:31 - We have linked to end backdrops
that will be later utilized in
19:36 - the front end application as you
can see, finally, we have an
19:41 - empty array for review IDs. Now,
this will come into play later
19:46 - on in this course, so just be
patient with me for now.
19:51 - Okay, so one thing that I'd like
to mention right here I am using
19:56 - the tmdb.org API for this
20:00 - images are TMDb is an excellent
website. And they provide a free
20:06 - to use API for developers as
long as you are giving them
20:10 - credit. So I do, so I will be
using the API for portraying the
20:16 - images. So now that we have
created a new database on
20:20 - MongoDB. Plus, we have set up a
new collection, we have imported
20:25 - some data into it, it's time for
us to start working on our API
20:31 - code.
20:35 - Now the first step to writing
our API using Spring Boot, is to
20:39 - initialize it first. To do that,
navigate to start.spring.io.
20:45 - Again, links will be in the
description. And let's start
20:48 - initializing our project. First,
we'll have to pick a programming
20:53 - language, which is going to Java
in this case. But if you're
20:56 - familiar with groovy or Kotlin,
you may go with them, then we
21:01 - will have to pick a project
autumn build automation tool.
21:05 - And the initializer supports
both Gradle and Maven which are
21:10 - not the most popular build
automation tool for Java, I am
21:13 - doing with Maven, simply because
I have more experience working
21:17 - with this then Gradle. Next up,
picking up the Spring Boot
21:22 - version 3.0. Point one is the
latest stable version. And we
21:26 - will be using that throughout
the course. But if you would
21:30 - like to try out some more
bleeding edge features, you can
21:33 - use the snapshots once you have
become more familiar with the
21:37 - framework.
21:40 - After that, we will have to fill
up the project metadata.
21:45 - Now the group is usually written
in reverse domain format. So for
21:50 - example, my website is Farhan
dot Dev. And I would like to
21:56 - name my group date dot for her.
So if you do not have a domain
22:02 - of yourself, you can name it
anything you like, as long as
22:07 - that package group is not
referring to someone else's
22:11 - project
22:14 - nextra that artifact name, the
artifact name is simply the name
22:18 - of the project. So in this case,
I will be putting movies in
22:23 - here, but feel free to call in
something else if you feel like
22:28 - that.
22:29 - Next there is a description
field and you can put something
22:33 - like
22:41 - after that, we will have to pick
up packaging for now java is a
22:45 - very popular packaging format
for Java and it stands for Java
22:50 - archive wire. On the other hand,
it stands for web archive. And
22:55 - you may think that will wire is
more suited for this project
22:59 - since it's going to be a web
application, right? Maybe yes,
23:03 - but since jar is more widely
used than where I will be going
23:08 - with.
23:10 - Next speaking the Java version,
obviously, I'm going to pick 17,
23:14 - since we just spent quite some
time setting up Java 17 on our
23:19 - computers. Once you are done
with the left column, let's
23:23 - focus on the right column. In
this one, you will have to pick
23:28 - the dependencies that you would
like to use in your project. So
23:32 - use this add button, and you
will be presented with a long,
23:37 - very long list of dependencies.
And the first one that we are
23:40 - going to use in our project is
Lombok, it's an additional
23:45 - library that saves you from
writing a lot of boilerplate
23:49 - code. And you will see what I
mean in action very soon. So
23:54 - please be patient. Since we are
going to pick multiple
24:00 - dependencies, you will have to
keep pressing either Ctrl on
24:06 - Windows or Linux and command on
Mac. In fact, it says here,
24:11 - right on the right corner press
Control to multiple apps. Okay
24:15 - for multiple ads, so I'm
pressing down on control and I
24:18 - will pick Lombok
24:21 - Lombok has been picked. Next up
spring web.
24:26 - And finally,
24:30 - let's see.
24:32 - No nada SQL under no SQL, we
will need Spring Data MongoDB
24:40 - Yeah, that's that's pretty much
it. You can also search for
24:45 - things here, for example, dev
tools, and let's add that as
24:50 - well. Once done, you can exit
out of this selector by pressing
24:54 - Escape on your keyboard and have
a look at the list of
24:57 - dependencies and make sure you
have the
25:00 - Everything. Now there are other
dependencies that you may learn
25:04 - about later on, such as the
reactive web,
25:09 - or Graph QL, or rest
repositories or something like
25:14 - maybe spring security, which can
be used for authentication and
25:18 - authorization. There is more to
client if you're into auth, and
25:22 - things like that. But since we
will not be getting into
25:25 - authentication and authorization
in this course, we will stay out
25:29 - from the
25:31 - get go. Once you are happy with
the configuration in this
25:34 - initializer to go ahead and
click Generate.
25:41 - It will take a few seconds to
generate the SIP archive, and it
25:45 - will start downloading
automatically. Once downloaded,
25:49 - you have to extract these movies
dot zip or whatever you have
25:53 - named your artifact dot c file
to somewhere in your computer
25:59 - easily accessible.
26:03 - After you have extracted the
downloaded zip file somewhere on
26:07 - your computer, you can go ahead
and open it in your favorite IDE
26:12 - or code editor. In my case, it's
IntelliJ IDEA and I have
26:17 - extracted my project on my D
drive.
26:20 - So I will go ahead and click on
open first.
26:25 - Then come to the folder where I
have extracted the project and I
26:32 - will pick it up.
26:34 - Okay, so IntelliJ IDEA will ask
whether you actually just this
26:39 - project or not. This is a safety
feature to save you from
26:42 - malicious code from running on
your computer. So since we are
26:45 - writing it ourself, I just pick
trust project.
26:52 - And give ideas some time for
resolving all the dependencies.
26:58 - And once it's ready, you are
free to go.
27:05 - Let's try to understand the
project structure first. So
27:09 - ignore the dot env and folder,
it's managed by Maven. So you
27:13 - don't have to worry about it
right now. There is the src
27:17 - folder, which is short for
source. And it will contain your
27:22 - program source code as well as
the test code. So we are not
27:25 - going to write any tests. So
let's jump into the main folder.
27:29 - So inside main there is Java and
resources, we will have to work
27:34 - inside both of these
directories. So let's go inside
27:37 - Java. And as you can see, here
is the name of our project after
27:41 - 400 movies, it it may be
different in your computer
27:45 - depends on what you have chosen
in the initializer. But it
27:49 - should be something similar.
27:51 - Then there is a class that
represents your applications
27:55 - names. So since I have named my
artifact movies, it says movies
28:00 - application, which is pretty
appropriate to be honest.
28:06 - In other movies application
class contains around 10 lines
28:10 - of code minus spaces in between.
So let's try to understand what
28:15 - it's doing. The first line is
actually declaring a package
28:20 - which is pretty self
explanatory. Next, there are two
28:25 - input statements. The first one
is a class called Spring
28:29 - application. Now this particular
class contains a method called
28:35 - Run. And to start your Spring
application, you actually have
28:40 - to call this run method, and
then pass your application class
28:45 - to it. And then you can also
pass some command line arguments
28:50 - which we are not going to touch
28:53 - the second import a statement
imports like the Spring Boot
28:57 - application annotation. So
annotations in Java are usually
29:02 - used to let the compiler know
about what this class does.
29:08 - So other than this class, there
is more or less nothing inside
29:13 - this package. So let's try to
run our application and see if
29:18 - we can we can have anything on
our browser. Okay.
29:23 - So you can actually click on
this play button, besides the
29:27 - main method to run the program
or this class play button, or
29:33 - this play button at the top.
Let's use this one.
29:39 - Okay, so if your IDE says Lombok
requires enabled annotation
29:44 - processing, just go ahead and
click on Enable annotation
29:47 - processing and it should be
fine.
29:50 - Now, if you look at the
terminal, you will see that
29:54 - there is a nice arc that says
the spring the springs version
29:57 - and there's bunch of logs and
30:00 - There is an exception. That
exception states that the
30:04 - application is failing to
connect to any MongoDB database
30:07 - at all. Which is true, since we
have not let the application
30:12 - know about our, our cluster, our
username, our passwords and
30:17 - things like that application
cannot connect to our MongoDB
30:20 - database. Now, it's fine if you
want to leave this error here.
30:24 - Or if you want to get rid of
this error,
30:28 - you can just first stop that
application.
30:34 - Open the POM dot XML file, which
contains a list of all the
30:39 - different dependencies that we
are using.
30:42 - And then look for
30:46 - MongoDB.
30:52 - It should be here somewhere
yeah, there you go. Dependency
30:55 - artifact the Spring Boot starter
data MongoDB. So just highlight
30:59 - the entire thing. And press ctrl
and the forward slash which will
31:05 - comment this out.
31:08 - Then right click on form dot XML
31:12 - and then go to Maven
31:15 - and go to reload project
31:23 - now try to run the application
once again.
31:32 - No your whatsoever.
31:35 - So if you look at the logs, it
will say that Tomcat started on
31:39 - port 8080 Tomcat is actually an
web server that will serve as
31:46 - the web server the development
web server for our application.
31:50 - Now, you'd have to switch to a
web browser to see the
31:53 - application in action. So let's
do that.
32:06 - And then you can navigate to
localhost
32:14 - 88080.
32:18 - There you go. Now it says
whitelabel error page, that's
32:21 - fine. At least we know that the
application is booting up and we
32:26 - are actually hitting the API
itself. And not just some other
32:30 - page when what is zero states is
that there is no endpoint at
32:35 - all. So although we have an API,
there is no API to hit. I hope
32:40 - that makes sense. Now let's go
back to our code and try to
32:44 - write our first endpoint.
32:47 - But after where it says the
Spring Boot application,
32:52 - we will say
32:55 - Rest Controller.
32:57 - It's another annotation that
lets
33:01 - the framework note that this
class is actually a REST API
33:04 - controller and not just another
class. Then inside this class,
33:09 - you will have to say
33:13 - get mapping.
33:16 - And next we'll have to create a
new method called public. And
33:20 - the return type will be string.
And the name of the method can
33:23 - be anything but let's just call
it API index for now. Because
33:28 - this is the
33:30 - route endpoint or or list, let's
call it API route.
33:36 - And we can say return.
33:42 - Have no or
33:45 - I know have our programs are
boring, but it's essential, you
33:49 - know.
33:51 - So this gate mapping and
notation to each, what it does,
33:55 - is that it lets the framework
know that this method right
34:00 - here, API route, is a good
endpoint. So if I put a bracket
34:07 - right here, and then inside,
I'll say slash just a forward
34:11 - slash. Let's stop our
application and run it again.
34:18 - Let's see if there are any
errors.
34:22 - looks fine to me. Let's switch
to our web browser
34:26 - and do a refresh. As you can
see, it says hello world. Let me
34:30 - just increase the zoom level a
bit. So you can
34:35 - tell alright.
34:37 - Now instead of putting a forward
slash here, if I say for say
34:42 - slash route,
34:44 - rerun the application
34:53 - you will see that the whitelabel
error page is back. But if you
34:57 - navigate to slash route, you
will see
35:00 - Hello world. I hope this makes
sense. Although DCS are valid
35:05 - eight point, we are not going to
make our API like this, we will
35:09 - actually divide our application
into separate layers, there will
35:13 - be a service layer, there will
be a data access layer, and
35:16 - there will be an API layer. So
let's go forward and get rid of
35:20 - this code and restart to put
together our movies API.
35:33 - Now, in my opinion, the first
logical step would be to
35:38 - configure the database for our
application so that we can
35:42 - successfully connect to the
MongoDB cluster that we have set
35:45 - up previously, and talk to it.
35:49 - To do so, open up the src folder
right here, go inside main,
35:55 - go inside resources, and open
the file that says application
36:01 - dot properties.
36:03 - Now, in this file, you will have
to write the different
36:08 - application properties that is
related to your project. For
36:13 - example, right now, we are
trying to configure our MongoDB
36:18 - dependency.
36:22 - And to do that, you will have to
write
36:26 - spring dot data dot Mongo DB dot
database
36:35 - equals to the name of the
database. I hope you remember
36:38 - that we named our database
something like movies API dB. So
36:46 - we will write movies API dB,
36:49 - and next spring
36:53 - dot data dot Mongo DB dot URI.
Now in here, you will have to
37:01 - actually write that URI to your
MongoDB cluster like you did
37:06 - with Compass.
37:10 - I have my URL already copied to
my clipboard. And I hope that
37:16 - you have saved it somewhere
safe. Like I said in the
37:19 - beginning of the course that I
will just go ahead and paste it
37:21 - right there.
37:24 - And you can get rid of this
slash test thing. And the last
37:29 - slash, and it should be fine.
Okay, so
37:34 - our application should be able
to connect to our database. Now
37:37 - to test it out. Let's go back to
POM dot XML. Let's remove the
37:43 - comments.
37:49 - And then let's start our
application.
37:54 - Oh, see, we have forgot to
reload our project. And the IDE
37:59 - is actually suggested me to load
the map and changes. So I can
38:04 - just click this button or you
can go ahead and right click and
38:08 - go to Melbourne and reload
project. Let's use this button
38:12 - and see if it works fine or not.
38:15 - Of course it does. Let's run the
application.
38:25 - And now the Euro is called. And
actually it says some things
38:30 - about the MongoDB driver
cluster. And this is a positive
38:33 - sign. If it failed to connect to
the database itself, it would
38:37 - have screamed at us and whatnot.
But thankfully, it's fine.
38:48 - Now, if you have worked with any
applications, specifically web
38:53 - applications in the past, you've
may already know that putting
38:57 - sensitive data like this in a
file that's going to be in your
39:01 - GitHub repository is not safe at
all.
39:06 - Instead, what you should be
doing is putting all these
39:09 - things in a dot env file. So we
can right click on Resource, go
39:15 - to new and create a dot env file
for ourselves.
39:22 - And we can write down a few
properties here.
39:28 - Mongo database, then Mongo user,
39:35 - then Mongo
39:38 - password,
39:39 - finally, Mongo
39:42 - cluster.
39:44 - Now you can go back to the
properties file, and you can
39:48 - start moving these values one by
one to your env file. So this is
39:54 - going to be the Mongo database.
39:57 - Next up the Mongo user name
which is
40:00 - Solid Snake in my case, good
among but then Mongo password.
40:10 - Finally, the cluster.
40:17 - And I sometimes like to put them
inside quotes, this makes sure
40:22 - that if one of the passwords or
username or clusters contain
40:27 - some special characters in them,
it would not
40:31 - disturb the order of things. So
I like to put this quotation
40:38 - marks around each fabs. Okay,
now we have our env file ready
40:43 - to go, what I would suggest that
you create another env file,
40:49 - simply called dot env, dot
example,
40:55 - for later reference references
41:06 - then make sure you open up the
dot Git ignore file. And as you
41:10 - can see, the Initialize project
actually comes with a pretty
41:14 - good Git ignore file already.
But we'll have to add a few
41:18 - things for ourselves, right. So
you will say, you can actually
41:23 - copy this thing from here and
paste it and say,
41:27 - in the white.
41:31 - Yeah. And then you say.in With
this will make sure that you do
41:36 - not accidentally commit that dot
env file into your repository
41:41 - and open up your database to the
word.
41:46 - Now, the only problem with this
spring is that spring doesn't
41:50 - support reading dot env files
out of the box.
41:56 - So what we'll need is we
actually need to install
42:05 - a new dependencies to our
project. And I would like to
42:09 - take this opportunity to show
you how you can add new
42:14 - dependencies to the project
later on. So I'll switch back to
42:19 - my browser. I'll open up a new
tab and I will search for
42:28 - Maven
42:32 - dependencies, something like
that. Yeah. And here is Maven
42:37 - repository.
42:40 - Then let's search for something
along the line spring. Dog
42:46 - Ian's.
42:51 - Yeah, I am referring to this one
by Paul Suarez. I apologize if I
42:57 - have pronounced his name wrong.
43:01 - Let's select this one. And we
can see that it says this spring
43:07 - plugins 1.0. And it says Central
and whatnot. Okay, so the name
43:11 - of the thing is made up Paul
Torres spring dot EMV. So as you
43:16 - can guess this is his group,
group name and thesis, the name
43:19 - of the artifact or the or the
project itself. So we can go
43:24 - back to our code. Let's open up
POM dot XML. And inside the
43:30 - dependencies bar, make sure you
are inside dependencies and not
43:34 - outside somewhere here. After
the last dependency, we will
43:39 - create a new one.
43:42 - So it is a dependency.
43:45 - And the ID helps us by auto
completing this. And we will say
43:51 - that the group ID is mi dot
43:56 - Paul
43:57 - is he h, w A are set just to
make sure you can always copy
44:04 - from here.
44:08 - No one's going to judge you for
that. And then name of the
44:12 - artifact which is spring dot E
and
44:17 - now it's not strictly necessary
to define a version as well. But
44:22 - you can do so by saying
44:25 - version and then put maybe the
latest from two point 5.4
44:31 - by one. Yeah.
44:34 - So that's it, let's reload
Maven.
44:41 - And yet now our project has the
ability to use the spring dot
44:45 - env artifact and three dot env
fights. Let's go back to our
44:49 - application properties and
replace these hard coded values
44:52 - with our dot env references. To
do so open up the resources and
44:59 - we need the
45:00 - env so Mongo database Mongo user
Mongo password, okay?
45:05 - So you will first have to get
rid of this value and then start
45:09 - with $1 sign
45:11 - and curly braces. And inside the
set of curly braces, you will
45:15 - see say e NV dot
45:19 - Mongo.
45:21 - What do they call it? Database?
45:26 - Yeah, Mongo database, and you
can kind of copy it from here
45:30 - then
45:32 - replace Solid Snake by Mongo
user.
45:40 - And then they should be Mongo
password.
45:45 - But sore tricked.
45:48 - Yes. And finally a cluster.
45:59 - Cluster Yes. Does this mean?
Okay, we can ignore this typo.
46:04 - And if you want Singapore, you
can actually come to this
46:07 - problem step and have a look at
what are what's the ID is
46:11 - complaining about. So the
annuals property, let's just
46:14 - ignore them from now.
46:17 - Which ones per year? Yeah. Okay,
let's ignore these for now. And
46:22 - the typos. Okay, Mongo is not a
typo.
46:26 - Except let's try running our
application once again and see
46:29 - if our env file has taken any
effect or not.
46:40 - So as it turns out, our MongoDB
connection is fine, which means
46:45 - the end file has been read
successfully. And we have
46:49 - successfully secured our
confidential information from
46:54 - going out into the world. Now
you, you don't have to write
46:58 - everything inside an env file,
you can actually use this en v
47:03 - dot name of the variable
notation to access any
47:08 - environment variable variable in
your operating system. But I
47:12 - will not get into that anymore
since we don't need it. Let's go
47:17 - ahead and get along with our
project.
47:21 - Now in our application, there
are two types of data that we
47:24 - are going to work with. First
there are the movies and then
47:28 - there are the reviews. So we
will need to first create two
47:32 - separate classes for
representing these two entities
47:36 - in our application. So first,
let
47:41 - left click on your project name
new and Java class let's call it
47:46 - movie.
47:49 - And inside this movie, we will
first have to annotate this
47:54 - class as a document.
47:58 - This will let the framework note
that this class sheet presents
48:03 - each document in the movies
collection.
48:07 - And we will also define the name
of the collection here movies.
48:13 - Then inside here we will have a
bunch of private data. So
48:19 - private
48:21 - object ID ID this will represent
the ID of this movie and private
48:29 - IMDb ID sorry,
48:34 - string
48:36 - IMDb ID which will represent the
IMDB ID of this movie. And
48:42 - preferred
48:45 - string, title,
48:49 - private string
48:52 - release date
48:55 - for private string
48:59 - Schadler link this will be a
link to the YouTube page for the
49:03 - trailer
49:05 - private is string poster a link
to the image on the internet
49:12 - private list string this will be
the genres because there can be
49:20 - multiple genres of a single
movie. And these lists class
49:25 - need to be imported
49:27 - at Java util
49:30 - by any private list string
49:36 - and
49:39 - this will be the backdrops now
this backdrop images will
49:43 - actually be used in the front
end application as you will see
49:46 - later. Let's just quickly jump
to MongoDB compass and make sure
49:52 - that we have indeed written all
the necessary properties for
49:57 - this class.
49:59 - So as you can
50:00 - Let's see we have written high D
IMDb ID title yes released a
50:04 - trailer link genres poster,
backdrops, air review ID. So you
50:09 - you, we will add review IDs, a
few moments later.
50:14 - Now, we will have to also
annotate this ID field
50:26 - as an actual ID, this will lead
50:32 - the framework know that
50:35 - this property should be treated
as the unique identifier for
50:40 - each movie inside the database.
Okay, apart from this we will
50:45 - also need getters setters that
do is string methods and some
50:51 - constructors. So instead of
writing out getters setters to a
50:55 - string for each of these private
properties, we can just say
51:02 - at the read data, and this is
one of the annotations that
51:05 - comes from the Lombok project.
And it takes care of all those
51:10 - different gators setters and two
string methods. Next, we'll also
51:15 - add all args constructor, this
is basically an addition for
51:22 - creating a constructor that
takes all this private field as
51:27 - argument finally, no args
constructor, which means another
51:32 - constructor that takes no
51:36 - parameters whatsoever.
51:39 - Okay, next, let's create the
reviews. So Java class
51:44 - reveal,
51:46 - it's the same deal.
51:49 - So this will be document
51:52 - and the collection name will be
G fields. Now, we haven't
51:56 - created this collection yet. But
the application itself has the
52:02 - ability to create new
collections. So we don't have to
52:04 - worry about that. We'll add data
just like before.
52:09 - All
52:11 - args constructor, Nords.
constructor, and then
52:17 - there will be two private
properties for a strong private
52:22 - object ID.
52:26 - ID, this will be the ID in this
case.
52:31 - And then private
52:36 - review body
52:39 - just just body string body.
52:44 - Okay, so as you may have already
seen in the database design,
52:48 - that each of these movies has an
array of this review, and we
52:52 - haven't yet added this this area
of reviews to the movie model
52:57 - yet. So to do that, we will go
back to the movie class,
53:02 - go near the end and say
53:06 - private
53:09 - least
53:11 - review.
53:14 - Review IDs. Okay, so it matches
this name review IDs, and the
53:21 - hall that our names are matching
as well. Yes. Now if you write
53:26 - it like this, this will be an
embedded relationship. So all
53:31 - the reviews that are related,
this movie will be added to this
53:37 - list of reviews. Now this is
completely fine. In fact, if you
53:41 - are modeling a one to many
relationship, such as one movie
53:45 - can have many reviews, this is
the way to go. But since I'm
53:51 - trying to demonstrate some of
the features of Springboard
53:56 - MongoDB data, I will show you a
nifty annotation right here. So
54:00 - I will say
54:02 - document reference.
54:05 - So this will cause the database
to store only the IDs of the
54:11 - review. And the views will be in
a separate collection. So this
54:17 - is called
54:19 - manual reference relationship.
And there are some other ways to
54:23 - create relationships in MongoDB.
I would suggest that you search
54:27 - them up on Google or MongoDB
sufficient documentation and
54:31 - read about them on your leisure.
It will give you a lot of
54:34 - context. So now that we have our
movie and review models ready to
54:40 - go, we can go ahead and start
writing on controllers. So I'd
54:46 - right click on
54:48 - my packet then a Java class.
This will be called Movie
54:55 - controller.
54:57 - And this is our first official
day
55:00 - API controller that we are
writing in this API. Previously,
55:03 - we wrote a simple controller in
our movies application class,
55:09 - but this time, it's going to be
a bit different. So first, we
55:12 - will need to annotate this class
as a Rest Controller.
55:18 - And instead of mapping it to
localhost 8080, I want to make
55:25 - it sorry.
55:27 - Mapping request mapping, I want
to make it map to slash API
55:34 - slash v1 slash movies. So any
requests to slash API slash v1
55:41 - slash movies endpoint will be
handled by this particular
55:46 - controller. Next, I will create
a new gate method. So I will say
55:52 - get mapping. And then
55:56 - public.
55:58 - Let's return string for now.
56:03 - All movies,
56:06 - and then we can return
56:09 - all movies.
56:14 - OK, let's try to run our program
and see if it works or not.
56:18 - Let's hit the play button.
56:26 - Okay, it's compiled fine. Let's
go back to our browser. And here
56:32 - localhost 8080 slash route.
56:36 - We will get rid of fruit and say
slash API, slash V one, slash
56:43 - movies.
56:45 - And it works. Now although it's
okay to return these strings
56:51 - from this endpoint, it's better
to return a response
56:58 - entity I'll show you why in a
minute. So this is a generic
57:02 - pipe. So we'll say string.
57:05 - And then instead of returning or
returning, and instead of
57:10 - returning all of this like this,
we will say,
57:14 - new response entity of type is
String. And this is the value.
57:24 - Then HTTP status dot O.
57:30 - HTTP status dot okay means 200.
57:33 - Let's read on this program.
57:44 - Refresh, and it works just as
expected. Now, you may not see
57:49 - any difference there. But if you
go back to your terminal
57:54 - and say, curl, I HTTP localhost
8080 slash API slash v1 slash
58:01 - movies, you will see we are
indeed returning the 200
58:05 - response code.
58:08 - This comes in handy when working
on a front end application and
58:13 - any REST API out there should
return proper status codes.
58:19 - Since we have the movie model
right here,
58:23 - let's try to use it and pull
some data from the database.
58:29 - For that, we will need a service
class as well as a repository
58:35 - class. So let's create the
repository first, because that's
58:39 - the shorter one. So it's a Java
class. And we'll select
58:43 - interface because repositories
are of type interface. And then
58:47 - we'll say movie in repository.
58:55 - Yeah, now this interface will
extend
58:59 - Mongo repository. This is the
generic type. And we will have
59:05 - to let it know what type of data
we are dealing with. So movie,
59:10 - and we'll also need to let it
know what type of ID we're
59:13 - dealing with, which will be
object
59:18 - ID, there you go. That's all for
this interface, you will need to
59:25 - unnoted this interface as a
repository. So that framework
59:30 - knows that this is a repository.
59:34 - And then let's create a service
class which will be movie
59:39 - service.
59:42 - And this class will not extend
anything, you will just need to
59:46 - annotate as service.
59:51 - Now, inside this class, we will
write the database access
59:56 - methods. So the first one will
be public
60:03 - Get on movies.
60:08 - Let's just name it all movies.
And let's just change our
60:13 - controller method name to get on
this because since it's a get
60:19 - mapping, we're saying get all
modes.
60:22 - And the return type will be list
60:29 - of what will return a list of
movie from this method.
60:35 - Now, inside the service class,
you will need a reference of the
60:39 - repository to do that you will
say
60:44 - movie repository
60:47 - it will be a private field.
60:51 - And its name will be movie
repository.
60:55 - Now if you know Java, you may
know that you will have to first
60:59 - initialize this bit of code, you
will either have to initialize
61:05 - it using a constructor, or you
can just use auto wire an
61:13 - audition what this will cause it
will let the framework know that
61:18 - we want the framework to
instantiate this class here for
61:23 - us, okay.
61:26 - Let's go inside the method now.
And we will say return
61:31 - move the repository dot find all
61:36 - these find all method is
described inside the Mongo
61:41 - repository class. As you can
see, it says right here find all
61:47 - and it will return and least of
the data type that we have
61:51 - passed right here certainly
stock movie. So that's our
61:55 - service class right there. And
then let's go back to our
61:58 - controller, we will need a
reference to our service class.
62:05 - So we will say private
62:08 - movie service movie surface. And
just like we did in the service
62:14 - class, we will auto wired the
service class. Since it has the
62:18 - service and audition right here,
we will set auto wire.
62:23 - Excellent. And it's also
62:26 - now inside the good old movies.
Instead of returning a response
62:32 - entity of type string
62:37 - change it to list
62:42 - so we are returning a response
entity of type list movie.
62:48 - Then inside the method, we will
have to write return
62:54 - movie service.of movies
63:03 - new response entity
63:07 - of type list
63:11 - movie
63:13 - and inside movie service drug
called movies comma HTTP status
63:18 - dot okay.
63:22 - Yeah, let's take a look at our
repository. Once again, it's all
63:25 - set up.
63:27 - Services fine, the controller is
fine. Let's cross our fingers
63:33 - and see if this works or not.
63:41 - Going to go back to our browser
and hit refresh.
63:48 - And the reason behind this
problem lies in my EMV file. So
63:56 - as you can see,
63:59 - we have called our database
movie API dB.
64:04 - But in our configuration, we
mistakenly put an S right here.
64:09 - So we'll get rid of the s.
64:13 - Res restart the application and
hope for the best.
64:27 - And yeah, it works. As you can
see, there are 10 movies in this
64:32 - list. Since it starts at zero
and ends at nine. There are 10
64:36 - movies in this list and the code
is perfectly fine. Now let's go
64:41 - back to the code and let me re
iterate on what we have done so
64:46 - far. So in rest API's, usually
there are multiple layers. So
64:53 - one of the layers is the API
layer, which is this controller
64:57 - and it will only concern itself
65:00 - have about the task of getting a
request from the user and
65:05 - returning a response and nothing
else. And that's what it's
65:09 - doing. All it's doing is it's
using a service class and
65:14 - delegating the task of fetching
all the movies from the
65:17 - database. And give me giving it
back to the API layer. So it
65:24 - calls the all movies method
inside
65:30 - the service, gets the list of
the movie and returns them with
65:35 - HTTP status. Okay, it doesn't
know what's going on inside the
65:41 - service class. Now, when we come
back to the service class, this
65:45 - is where most of our business
logic will go.
65:50 - For now, there is nothing to be
worried about in this classes.
65:54 - But soon, we will work with a
little bit more complex business
65:59 - logic in this API. So the
service class does is it uses
66:04 - the repository class, and talks
to the database, get the list of
66:08 - the movies and returns to the
API layer. Finally, the
66:13 - repository layer is kind of the
data access layer for our API II
66:19 - does the job of actually talking
to the database and getting the
66:24 - data back.
66:26 - I hope that makes sense. Now,
since we have a list of all the
66:31 - movies in our databases, let's
complicate it a bit more by
66:37 - trying to access a single movie.
Now, we will begin by creating a
66:42 - new get mapping.
66:45 - And that is
66:48 - get mapping and this will
actually take an parameter.
66:54 - And we will have this a slash
that inside a pair of curly
66:58 - braces will say ID. So we are
trying to search a movie by its
67:04 - ID.
67:06 - So we can set public
67:09 - response entity. This time, we
will return a single movie.
67:16 - And we'll say get single
67:20 - movie. Sorry for the type book.
67:26 - We'll close
67:28 - the pair of parentheses
67:36 - and we'll start our method.
67:40 - Now inside the pair of
parentheses, we'll have to say
67:44 - PATH variable, which lets the
framework know that we will be
67:50 - passing the information we got
in the mapping as a path
67:54 - variable. Or we will be using
the information passed in the
68:00 - PATH variable
68:02 - as a string,
68:06 - or just object.
68:09 - Id ID.
68:13 - So what this does is it lets the
framework know that whatever we
68:17 - are getting through this path
variable, we want to convert
68:21 - that to an object ID called ID.
68:25 - And then we can say
68:29 - return first we'll have to go
back to our service layer and
68:34 - write a new method here.
68:36 - Public
68:38 - movie single movie
68:43 - and we will say return
68:47 - movie repository dot
68:50 - find by ID
68:54 - and we will get that ID right
here.
69:00 - And it goes here it
69:04 - David and the squiggly line it
says that whichever option okay?
69:10 - So the thing here is that the
find by ID method may not find
69:16 - any movie at all, maybe the ID
you have passed doesn't exist.
69:22 - So in those cases, you it will
have to return now, so we'll
69:27 - have to let Java know that it
may return null by saying
69:31 - optional
69:34 - movie
69:36 - and we will just import the
optional class
69:42 - we will also have to fix our
response entity movie will say
69:48 - optional.
69:51 - Movie
69:56 - optional has been imported nice
and then
70:00 - We can say return new response
entity
70:06 - optional
70:09 - movie. And inside there we can
say movie service
70:15 - dot single movie, we will pass
the ID that we have received
70:20 - comma
70:22 - HTTP status dot. Okay.
70:27 - Let's restart the application
70:38 - let's go to our MongoDB compass
inside the movie collection and
70:43 - copy one of the object IDs right
here let's copy
70:48 - for Roald Dahl's Matilda the
musical. Let's copy the object
70:53 - Id
70:58 - go back to our browser.
71:03 - And we can say movies, slash and
then the object ID.
71:09 - As you can see, we have found
Roald Dahl's Matilda the
71:12 - musical. Now, the problem is
that I do not want to expose the
71:17 - object IDs of my collection
entities to the public. Instead,
71:23 - what I want to do is use this
IMDb ID to search for new
71:29 - movies.
71:31 - So let's see if we can find a
way to do that.
71:36 - Now although the repository
comes with built in methods for
71:42 - searching with ID, it doesn't
come with methods for searching
71:46 - with IMDb ID so what we'll have
to do is we'll have to implement
71:52 - that method ourselves. And it's
really easy because there is
71:58 - something called automatic
queries that lets you
72:03 - farm where it is dynamically
from.
72:10 - property names so we will say
optional.
72:16 - Movie because it may return null
once again, we'll have the input
72:22 - optional
72:24 - movie and we will call it
72:27 - find movie
72:31 - by
72:33 - in dB ID and it takes a string
72:40 - I am DB ID.
72:43 - Now just by naming this method
find movie by IMDb ID
72:49 - MongoDB data Spring Data MongoDB
will understand what we are
72:55 - trying to do. It's that much
intelligent. So now we can go
73:01 - back to our service class.
73:04 - We are no longer getting an
object ID but we are getting a
73:08 - string
73:10 - IMDb ID
73:13 - and instead of find by ID we
will say
73:18 - find a movie by IMDb ID, IMDb ID
73:24 - and that's it.
73:26 - Let's go back to controller.
73:29 - We'll change this from ID to
IMDb ID by the way you do not
73:34 - have to name the ID IMDb ID
exactly in this method. It's
73:39 - It's just that I know what I'm
doing in a later date. So we
73:44 - will replace object ID by string
73:50 - IMDb ID
73:53 - and then response entity
optional movie. This is fine.
73:57 - Yeah IMDB.
74:00 - So technically, this should do
our job. Let's check it out
74:13 - let's see seems like there has
been a mistake.
74:18 - Let's go up
74:35 - it looks like there is a
problem. Let's go back to
74:41 - our movie repository.
74:59 - And the music
75:00 - It is it should be IMDb and not
IMBD. So as you can see, the
75:07 - framework is clever enough to
see that I have misspelled
75:12 - the property name right here.
75:15 - So let's run the program once
again and see if you're trans or
75:18 - not
75:20 - fine tuned by cannot find
75:25 - up here, I have to correct
terrorism,
75:30 - DIA. And yeah, it shouldn't be
fine
75:41 - let's go back to our browser.
And as you can see API slash var
75:46 - slash movies. And then I have
used the IMDB ID for this movie.
75:52 - Hit enter, and it works just
fine. We can use the IMDB ID to
75:57 - search for movies.
75:59 - Now, you can actually form
dynamic queries like this using
76:04 - any property name in your model
class.
76:09 - As long as they're unique,
because if that's not unique,
76:12 - you will get multiple
76:16 - movies with the same ID or same
name. Okay.
76:23 - Now that we have our movie
controller sorted out, let's
76:27 - start working on our review
controller, where we will let
76:31 - the user send us review. And we
will add those under a movie
76:37 - name.
76:39 - So let's first create a new
repository.
76:45 - View
76:47 - posit Ori
76:50 - and it spends Mongo D. B,
76:57 - Mongo repository and the die
will be revealed.
77:02 - And object ID is our type. Yeah,
77:08 - yeah, that's their
77:13 - next let's create a new service
class. Oh, I almost forget to
77:19 - enter this as repository.
77:23 - So, create a new class called
77:27 - the views service.
77:31 - And this will be a service
class. So I'll go service
77:37 - here I will say public
77:42 - then
77:44 - this method will create a new
reviews so it will return a new
77:47 - review then here she view
77:52 - by
77:58 - creative
78:03 - then this method will take two
parameters. The first one will
78:08 - be a string
78:10 - which will be the reveal body
and the since
78:16 - the second one will be string
IMDb ID so what we are trying to
78:21 - do here we will first look for
the movie with the given IMDb
78:26 - ID. And then we will create a
new review and associate that
78:32 - review with the found movie. So
let's first create a new review.
78:41 - Review
78:45 - few quotes from new review.
78:48 - Now you may
78:52 - now you may remember that in the
review class, we have an pol
78:57 - arcs constructor and an aurochs
constructor. But since IDs are
79:01 - auto generated, we cannot pass
an ID to this class. So what we
79:06 - will do we will also generate a
custom constructor that takes
79:09 - only the body. Now in IntelliJ
IDEA you can right click inside
79:14 - a class go to generate and then
constructor and we only need the
79:20 - body part of this class. So
that's
79:25 - now let's go back to our service
class and new review and we will
79:30 - pass the review body
79:33 - Excellent.
79:36 - Now that we have a new review,
we will have to associate these
79:42 - to one of the movies
79:54 - now that we have a new review
object, we will have to insert
79:58 - it to the database and for
80:00 - After that, we will need
80:03 - a reference to our
80:06 - review repository.
80:10 - So review repository view
repository and needs to be auto.
80:16 - Fine. And we will say,
80:20 - review repository
80:24 - dot insert, and review.
80:28 - X. And that's the review taken
care of now we can have to
80:32 - associate with this with one of
the movies, right? To do that,
80:37 - we
80:39 - need a few things. Now the first
thing that we need is called a
80:45 - template to create a template
with set private Mongo template,
80:52 - Mongo template. Now, you have
already learned about
80:57 - repositories as one of the ways
to talk to the database. The
81:00 - other way is using a template.
You see there are times when a
81:05 - repository just doesn't cut it,
maybe you have an operations so
81:11 - complex that it cannot be
implemented within a repository,
81:16 - or even if you can implement it
within a repository, it will be
81:22 - not
81:23 - suitable. So what we need, we
need a
81:28 - template, you can use this
template to form up a new
81:32 - dynamic query and do the job
inside the database without
81:38 - using the repository. So we will
alter this.
81:45 - And then down here, we will say
81:49 - Mongo template
81:52 - dot update, since it's an update
operation, and we need to say
81:58 - which class to you do we want to
update. So we want to update all
82:03 - of the movies.
82:07 - And then come to the second line
and put a dot here. And then as
82:12 - you can see, there are multiple
operations that we can perform.
82:16 - So we want the match.
82:19 - Now inside the matching of
version, we will need a new
82:23 - criteria. So we'll set criteria
82:29 - dot fire.
82:32 - And inside where we will say
IMDb ID, make sure it's matching
82:38 - up with the column name or the
property name inside the
82:41 - database
82:44 - then.is the IMDB ID that we have
got.
82:52 - Then come to the next line and
put a dot once again and then
82:55 - we'll say Apply.
82:59 - We'll say new update. This is
called an update definition
83:06 - dot push
83:16 - review IDs
83:21 - and then dot
83:24 - value
83:26 - sheet view.
83:28 - See, that's pretty much it.
Okay, so what we are doing is we
83:34 - are using the template to
perform an update call on the
83:37 - movie class. Because I hope that
you'll remember that each movie
83:42 - in our collection contains an
empty array of review IDs. So
83:48 - what we need to do,
83:50 - what we need to do is we need to
update this array and push a new
83:56 - review ID into this.
84:00 - So we are saying movie dot class
then we have to perform the
84:03 - matching. So which movie are you
updating? We are updating a
84:08 - movie where the IMDB ID of the
movie in the database matches
84:14 - the IMDB ID that we have
received from the user. Okay,
84:19 - then we want to apply this
update. To do so we call apply.
84:25 - And then we create a new update
definition which does the job of
84:30 - making the change inside the
database. So we say Update, push
84:37 - and review IDs. So we want to
update the review IDs in this
84:42 - found movie and the value of
this movie will be revealed. So
84:46 - that review that we have just
created it will be pushed inside
84:50 - the review IDs array okay.
84:55 - Now, finally, we will have see
the
85:00 - First, to make sure that we are
getting a single movie and we
85:04 - are updating that. Now one thing
that I have done, which I
85:08 - shouldn't have is we cannot new
up a review like this.
85:14 - Rather, what we need to do is we
will just save the review on
85:22 - insert, because when you call
insert, it actually returns the
85:27 - data you just pushed inside your
database. Okay?
85:31 - First, finally, we can return
85:36 - that view we just created.
85:40 - So let's review the Create
review method. We are taking a
85:45 - new Mongo template, we are using
it to update the movie with the
85:48 - new review, we just pushed using
the repository.
85:53 - So likely say sometimes you will
have to code up complex business
85:58 - logics by yourself. And as you
grow as a software engineer and
86:02 - an web developer, you will start
to understand all these things
86:06 - all by yourself.
86:08 - So let's go back to our review
service. Yeah. So I mean, our
86:14 - review
86:17 - is is fine. If you're in
positions where you feel
86:19 - service, yeah. Now let's create
a new review controller.
86:27 - And inside this controller, we
will have only one post method.
86:35 - But you may think, why only a
single post method? How are we
86:39 - going to get all these reviews
that are associated with a
86:43 - movie, I'll show you how.
86:46 - Now let's begin by annotating it
as a Rest Controller.
86:53 - And then of course, we will have
input request mapping
86:59 - which is
87:02 - slash API slash v1 slash
87:07 - mobile movies
87:13 - Okay, since
87:16 - the review form will be inside a
movies Details page, or in the
87:21 - page where you are viewing a
single movie so we can make the
87:25 - requests to the movies and point
instead of creating a new if we
87:29 - use NS N bar. Now when it comes
to creating endpoints like this,
87:34 - it really depends on the on the
developers preferences, you may
87:39 - you may choose to organize your
API differently from what I am
87:45 - doing here. And in a real life
project I maybe I will do
87:50 - something different but since
it's just for learning, and we
87:54 - are just getting started, I
think it's fine.
88:00 - Inside the controller, we'll
first need our service. So we'll
88:03 - say private
88:06 - reveal Service Review service
and we will auto add this
88:14 - nice
88:17 - then we'll create a new post
mapping
88:28 - and then a new method of Lake
will again return a response
88:33 - entity and this will be of type
review. And we will call it
88:39 - create review method.
88:42 - Inside this pair of parentheses
we will say
88:48 - request body
88:51 - then map
88:56 - string, comma string
89:01 - and we will call it payload
89:04 - so we'll import map.
89:07 - So, what we are saying to the
framework here that whatever we
89:11 - get as the request body we would
like to convert it to a map of
89:17 - the key string and value string
and we want to name this map as
89:22 - payload you will see why this is
89:27 - then we will say
89:30 - return new response entity.
89:33 - And yeah we can say review this
review
89:38 - and then it says Service Review
service dot create review and we
89:44 - will pass two tests. First one
payload dot get
89:53 - is the review body
89:57 - and the second one will be
payload
90:00 - Don't get
90:05 - IMDb ID Okay.
90:09 - Finally we say
90:13 - comma
90:15 - HTT be
90:18 - status dot created, it will be
201. Since we are creating a new
90:24 - review, we want to send 201
instead of the plane 200 Because
90:29 - this means created and that
means okay. So now that we have
90:33 - the post mapping done, we need
our REST client a separate risk
90:39 - flying to test our test out our
code. But before that, I can see
90:45 - that there is this squiggly line
underneath the view controller.
90:47 - So I will just go to problems
and see what's wrong. cannot
90:51 - resolve symbol IMDb ID Okay,
let's see where I missed a typo
90:56 - here. So it should be inside a
pair of quotation mark. And
91:00 - that's gone. See, this is the
beauty of IntelliJ IDEA. It
91:04 - helps you a lot. Now let's
restart our program. And I will
91:09 - use postman to test out our API.
91:20 - In fact, I just thought instead
of mapping the reviews request
91:25 - to API slash API slash movies,
let's just go with reviews.
91:31 - Because that sounds more
appropriate. Now let's start our
91:35 - application
91:42 - and let's jump to postman.
91:47 - So inside postman first, I'll
create a new collection. And
91:51 - I'll call the movies API.
91:56 - Then let's create a new GET
request get all movies
92:04 - so it would be localhost 8080
slash API slash VLANs slash x.
92:15 - So it works out just fine. Let's
copy the IMDB ID from one of
92:24 - these movies so that we can test
out our next request
92:31 - which will be
92:33 - get a single movie
92:39 - and we should be able to carry
everything from the previous
92:43 - request
92:45 - will host slash view and slash
movies slash then the IMDB ID.
92:52 - Let's execute and the works just
fine.
92:56 - Finally, let's try to create a
new review here to review.
93:08 - And let's say v1 slash reviews.
93:14 - Okay, that's I set that because
by mistake so it has to be post
93:19 - inside body I would say raw data
in JSON format.
93:27 - So I will say review
93:33 - body will be I really enjoyed
the movie with
93:41 - I.
93:43 - Yeah. And then I will say IMDb
ID,
93:50 - column and timed ID. Now you
have to make sure that the name
93:55 - or the key in this JSON data
review body and IMDb ID
94:06 - exactly matches the two keys
inside the payload which is
94:11 - review body and IMDb ID. So what
will happen is this endpoint
94:16 - will receive a JSON data from
the user and then convert it to
94:20 - a map where the keys are extreme
and the values are history. Then
94:25 - from this map, we'll be able to
access the review body which is
94:29 - a string and the IMDB ID, which
is another string. And then
94:34 - through the service layer, we
can create a new review on the
94:38 - database, update the movie to be
associated with that review, and
94:44 - then return the review. And of
course, there's a repository
94:47 - that works as the intermediary
layer
94:52 - between the service class and
the database to let's let's go
94:58 - let's come back
95:00 - postman, and let's see if it
actually works on
95:06 - here. So we have got 201
created. So theoretically, we
95:11 - should have created a new review
for the movie boosting boards.
95:16 - And let's go back to get a
single movie it sent,
95:21 - come down to review ideas. And
of course, we have the new
95:25 - review associated with this
movie.
95:29 - That's how we can get the list
of review ideas, they will be
95:34 - embedded with the data of the
movie they're referred to.
95:42 - So in terms of the API, that's
it, I know, it's a pretty simple
95:46 - API. But the goal of this
course, or the first half of
95:50 - this course, was to give you
some idea about how you can
95:54 - create a new back end API.
Powered by Spring Boot and
95:58 - MongoDB. I hope that you have
understood the basic concepts.
96:03 - using MongoDB. And Spring Boot
together, you can go ahead and
96:08 - further your study by learning
about how to implement
96:12 - authorization and
authentication. You can also
96:15 - learn about more complex
relationships, and maybe try to
96:19 - build a bigger API with Gillette
and ports and other kinds of
96:24 - requests. I will be leaving this
stretch right now. And from now
96:29 - on Gavin long will teach you how
you can create a React
96:34 - application that can go with
this API. So take care, I will
96:39 - maybe see you in another course
in the future. Now that you've
96:43 - learned how to develop the back
end, Gavin will teach you how to
96:46 - develop the front end using
React. Just a quick note before
96:50 - we get started, this will not be
a deep dive into React. My only
96:54 - goal here is to demonstrate how
we can interface with a remote
96:58 - API from a front end application
created using React through
97:02 - which we are able to retrieve
data from a MongoDB database
97:06 - hosted on a remote server, as
well as posting data to our
97:10 - MongoDB database. Now, any data
that we retrieve from the server
97:16 - will be in JSON format. JSON
formatted data may be pleasing
97:21 - to some people. But most users
of application I think would
97:26 - much prefer something like this.
So we're going to transform the
97:30 - data passed to us in a JSON
format into an aesthetically
97:34 - pleasing front end display.
React and associated
97:37 - technologies provide an
efficient way to create both
97:40 - aesthetically pleasing front
ends, as well as help us
97:44 - developers to facilitate a great
UX user experience. I'd like to
97:49 - give a shout out to the movie
db.org All the movie poster
97:53 - images and backdrop images that
we are going to use in the React
97:57 - application that we are going to
build in this course, come from
98:00 - the movie db.org Right, let's
get into it. Let's start by
98:04 - launching VS code.
98:11 - And let's create a working
folder on our local machines.
98:21 - I'm going to name my folder
98:24 - movie client.
98:30 - Let's open our working folder
like this from within VS code.
98:39 - So we are going to use the
Create dash react dash app
98:43 - command to generate our React
projects infrastructure. You of
98:47 - course, must have Node js,
preferably the latest version
98:51 - installed on your local machine
as a prerequisite before
98:55 - creating a React application.
98:59 - If you don't have no JS
installed, you can navigate to
99:03 - this URL to install the latest
release of node j s. So from
99:08 - within VS code, let's launch the
terminal window so that we can
99:12 - create our React project
infrastructure using the Create
99:15 - dash react dash app command.
99:19 - You can launch the terminal
window from within VS code by
99:22 - pressing Ctrl and the tilde
character.
99:27 - Great.
99:29 - So the current directory
reflected at the terminal prompt
99:34 - should be the working directory
that we have just created. my
99:38 - working directory is named movie
client.
99:41 - Then at the terminal prompt,
let's type in MPX space create
99:47 - dash react dash app followed by
the name we'd like to call our
99:52 - React project. So I'm going to
name my react project movie dash
99:57 - gold dash v one
100:02 - Then let's press the enter key.
And the Create dash react dash
100:06 - app command generates the React
project infrastructure, which
100:10 - includes all the relevant node
modules that contain components
100:14 - that we are able to import into
our React application. This
100:19 - process can take a while to
complete.
100:34 - And we can see the process on my
local machine has now completed.
100:38 - So at this stage, we don't
really need the movie client
100:41 - folder. Opened within VS code,
we only want the folder
100:45 - containing the files for our
React project. So at the
100:49 - terminal, let's use the cd
command and then enter the name
100:54 - of the React application that we
created using create dash react
100:59 - dash app. So I'm going to type
cd space movie dash gold dash v
101:05 - one, and press the Enter key. So
once we have made the folder
101:09 - containing the files for our
React projects infrastructure,
101:14 - we can launch another instance
of VS code by typing and code
101:18 - space dot and then pressing the
Enter key. This command opens
101:22 - another instance of VS code,
where we are now directly within
101:26 - the folder that contains the
files for our React projects
101:29 - infrastructure.
101:31 - We can now close down the first
instance of VS code, because we
101:35 - only need the instance that we
have just launched.
101:39 - So we are almost ready to create
our React application.
101:43 - We won't be using some of the
files that the Create dash react
101:47 - dash app commands generated for
us. So let's delete the
101:51 - following files from within the
SRC directory. Let's delete the
101:55 - setup tests dot j s file, the
report vitals dot j s file and
102:01 - the app dot test dot j s file.
102:12 - We must also delete a setting
from within the package dot json
102:16 - file, which has to do with
linting. We don't need this
102:20 - linting setting in our project.
102:25 - Let's save our changes.
102:27 - Lastly, let's open the index.js
file and remove the code related
102:32 - to the report web vitals
functionality like this.
102:39 - Let's save our changes
102:48 - and let's move on to installing
a few NPM packages that contain
102:53 - components that we are going to
integrate into our application.
102:56 - If your project terminal is not
available within VS code at the
103:00 - moment, you're able to launch
the terminal by pressing Ctrl
103:05 - and the tilde character.
103:07 - The next package we are going to
install is Axios Axios will make
103:12 - it easy for us to make HTTP
requests from our React client
103:17 - to the relevant API hosted on a
distant remote machine. So that
103:23 - we can retrieve relevant movie
data from the MongoDB database
103:26 - also hosted on the relevant
distant remote machine through
103:30 - HTTP GET requests.
103:33 - We will also be able to add
movie reviews to the relevant
103:37 - Mongo DB database through the
use of HTTP POST request, which
103:44 - will be facilitated on our React
client through the use of Axios.
103:49 - We'll implement this
functionality later in this
103:52 - video.
103:54 - So to install Axios, we can type
this command at the command
103:58 - prompt NPM space install space
Axios.
104:05 - And let's press the enter key.
104:14 - Great, so let's install our next
NPM package
104:19 - which will enable us to use
Bootstrap for layout and styling
104:22 - purposes from within our React
project. So let's type the
104:26 - following at our command prompt
104:29 - NPM space install space
Bootstrap.
104:39 - Note that in order to integrate
bootstrap into our project, we
104:43 - must include this import
statement within the index.js
104:48 - file.
104:53 - Let's save our changes.
104:56 - The next NPM package that we
must install
105:00 - allows us to use Bootstrap
related components for layout
105:03 - and styling purposes. So let's
install react dash Bootstrap.
105:09 - For this purpose, we can install
react dash bootstrap by typing
105:14 - NPM space I space react dash
Bootstrap.
105:25 - And of course, follow this by
pressing the Enter key.
105:31 - Great. The next NPM package that
we are going to install enables
105:37 - us to easily install font
awesome icons within our React
105:42 - application. The first font
awesome related package can be
105:46 - installed by typing in npm space
I space at Fort dash awesome,
105:52 - forward slash react dash Font
Awesome.
105:57 - So make sure you type at Fort
dash awesome here and not at
106:02 - font stash awesome, which I know
is a little bit confusing. So
106:07 - it's add 14 Awesome dash, react
dash and then Font Awesome.
106:15 - Great.
106:17 - Let's install the second font or
some related package by typing
106:20 - in npm space I space at Fort
Awesome forward slash free dash
106:28 - solid dash SVG dash icons.
106:35 - And let's Of course, press the
enter key.
106:40 - Excellent.
106:42 - To play movie trailers from
within our application, we're
106:46 - going to use the React player
component. So let's install the
106:50 - appropriate NPM package. So that
we can integrate react player
106:55 - into our React application. So
let's type npm space I space
107:01 - react dash player
107:08 - and press the Enter key.
107:17 - Great in order to declare the
paths where our components will
107:23 - reside, in order to map the
routes to our components as it
107:26 - were, we are going to use
relevant components from the
107:30 - React dash router dash DOM NPM
package. So in order to install
107:36 - the React dash router, dash DOM
NPM package, let's type in this
107:41 - command npm space I space react
dash router dash DOM.
107:50 - And of course, press the enter
key.
107:59 - Great.
108:02 - On our homepage, we want to
display relevant movies in a
108:05 - carousel.
108:08 - We can easily implement a
carousel using material UI. So
108:13 - in order to do this, we must
install three material UI NPM
108:16 - packages. So we can install the
relevant three NPM packages by
108:21 - typing the following NPM space
install space at Nui forward
108:27 - slash material space at emotion
forward slash react space at
108:33 - emotion forward slash styles.
108:40 - And let's press the enter key.
108:48 - Excellent.
108:50 - In order to use the material UI
carousel component, let's
108:53 - install the material UI carousel
NPM package. We can do this by
108:59 - typing in npm space install
space react dash material, dash
109:05 - UI dash carousel
109:11 - and press the Enter key.
109:27 - Great,
109:29 - and we have now installed all
the NPM packages we need in
109:32 - order to integrate the
functionality we want to include
109:36 - within our React application.
109:39 - Excellent. Let's get started
with writing the code for our
109:42 - React application. So the first
thing I'd like to do is set up
109:46 - Axios. So to do this, let's
create a folder within the src
109:51 - folder
109:59 - and
Let's name our folder API.
110:03 - Let's create a file within the
API folder named Axios config
110:09 - dot j s.
110:17 - We can import Axios into our
project with this line of code.
110:27 - So we can configure and export
the Axios object that we will
110:31 - use to make HTTP requests to the
relevant remote API through this
110:35 - code.
110:54 - Notes the settings that have
been included here,
110:57 - we have the base URL setting,
which provides the base address
111:02 - of the API endpoints that our
client react application will be
111:06 - calling. So you'll see later on
when we use Axios. To call an
111:10 - endpoint, we won't need to
repeat the base URL with each
111:16 - HTTP request within our code, we
will only need to include the
111:21 - additional path information
required to target a specific
111:24 - endpoint. If this isn't clear,
at the moment, it will become
111:29 - clear. When we write code to
make a HTTP request to the
111:34 - relevant remote endpoint. This
setting here is necessary.
111:39 - Because during the development
phase, the technology that the
111:42 - remote machine is using to
expose the relevant API
111:46 - endpoints is called ngrok.
111:50 - I won't go into the specifics of
N grok. But we need to include
111:54 - this setting in order for our
client HTTP requests to not be
111:59 - blocked by cause I won't go into
the details, of course, but it
112:04 - stands for cross origin resource
sharing. So all we need to know
112:09 - is that because the relevant web
API is running in a different
112:12 - domain, or origin, that cause
may block our access to the end
112:18 - point. The server code has
included settings in order to
112:24 - overcome the restrictions
imposed by cores. And we are
112:28 - including this setting in the
HTTP headers of our requests
112:33 - from the client, so that we can
overcome the restrictions
112:37 - imposed by cause IE, so that we
are able to access the resources
112:42 - made available through the
relevant API endpoints. Great,
112:47 - so we have now set up Axios.
Let's open the app.js file and
112:52 - write code to call an endpoint
that will return an array of
112:57 - movie data.
113:05 - Let's write code to import our
Axios object from within our
113:09 - Axios config.js file.
113:18 - Let's import the use state hook
and the use effect hook from
113:23 - react.
113:31 - Let's return a D structured
array from the use state hook.
113:39 - The first item in the de
structured array is named movies
113:43 - and will store an array of movie
data returned from a call to the
113:48 - relevant API endpoint.
113:52 - The second item in the array is
a function that can be used to
113:56 - change the state of the movies
variable.
114:00 - When the state of the variable
tracked by react through the use
114:04 - state hook is changed the
component is re rendered by
114:07 - react. So in this case, the app
component will be re rendered
114:12 - when the state of the movies
variable changes. Let's create a
114:16 - function that will handle a HTTP
get request to an endpoint that
114:21 - returns an array of movie data.
Once the movie data is
114:25 - successfully returned, this code
that changes the state of the
114:28 - movies array is executed.
114:40 - You can see here we are passing
the additional path information
114:44 - to the get method. This path
information is appended to the
114:49 - base URL setting that we created
when setting up the
114:52 - configuration for Axios.
114:56 - We are using async await for
asynchronous thread management
114:59 - functionality
115:00 - to the client, I won't go into
detail explaining async await
115:04 - and promises. But this
functionality can be effective
115:08 - in ensuring that the UI is not
blocked. When potentially long
115:13 - running operations, like for
example, a remote API call are
115:17 - processed, the UI thread will
not be blocked, and therefore
115:23 - the use of screen will not, for
example, freeze, the use the
115:27 - screen will still be responsive,
while a potentially long running
115:30 - IO bound operation is
processing. Once the relevant
115:34 - task has completed, the code
directly below the code that
115:38 - kicks off the awaited process
will be executed. So it's like a
115:44 - promises made to return to the
appropriate line of code. Once
115:47 - the task potentially long
running IO bound task, for
115:51 - example, has completed.
115:55 - As explained, this async await
functionality is useful in order
115:59 - to ensure a better UX user
experience. In case something
116:05 - goes wrong during the execution
of our HTTP request, let's wrap
116:09 - the relevant code in a try catch
block. And let's include code in
116:14 - the catch block to log the
relevant exception to the
116:16 - browser console window. So you
could be more thorough here in
116:21 - your code and check the HTTP
status code. For example, if the
116:25 - HTTP status code returned from
the server is 200. This
116:29 - indicates that the operation
performed on the server was
116:32 - successful.
116:35 - I'm not going to include this
functionality in this course, in
116:37 - order to keep the code fairly
basic for our HTTP requests that
116:42 - we are executing from the
client.
116:50 - Let's implement the use effect
hook so that the get movies
116:54 - function is executed when the
app component first loads.
117:04 - Let's also write code to log the
results returned from the call
117:08 - to the relevant endpoint to the
browser console window.
117:17 - Let's use the npm start command
to run our React application.
117:26 - Let's look at the browser
console window to see if our
117:29 - results have been returned from
the server.
117:34 - Excellent our HTTP get request
made through the use of Axios
117:39 - executed successfully.
117:47 - So the next step is to start
implementing our routing
117:51 - functionality or routing
functionality.
118:04 - Let's create a React component
named layout dots Jas.
118:14 - Let's open the layout.js file
and import the outlet component
118:19 - from the React Router DOM NPM
package to generate boilerplate
118:25 - code for our layout component,
we can type ra F C E and press
118:30 - the Tab key like this.
118:33 - Let's rather use semantic HTML
here and include main tags
118:37 - instead of div tags. Within our
main tags, let's include a
118:42 - reference to the outlet
component.
118:50 - Let's go back to the app.js file
and write code to import the
118:54 - layout component that we have
just created.
119:01 - Right, so I'm going to create a
components folder within the src
119:06 - folder, and move the layout.js
file into the components folder.
119:23 - Let's write the code to import
the layout component into the
119:26 - app component.
119:30 - Let's write code to import the
routes component and the route
119:34 - component from the React Router
DOM NPM package
119:46 - in the return part of the app
component, ie where JSX code is
119:50 - returned from our component,
let's write code to establish
119:53 - the route mappings as it were
for our applications React
119:56 - components. So let's first add
the routes.
120:00 - elements here
120:09 - within the root element, let's
include a parent root element.
120:13 - It's a parent root element
because child root elements will
120:16 - be included within this parent
root element. Like, for example,
120:20 - a child route component that
points to the home component we
120:24 - will write the home component in
a bit, will be a child of the
120:28 - parent route component that
points to the layout component.
120:32 - So the layout component
referenced through the outlet
120:35 - element in the layout.js file
denotes the components pointed
120:40 - to by the child root component
references that will include
120:45 - within the parent root element
here, we'll include the relevant
120:50 - child root elements as we
progress with the development of
120:54 - our React application. The next
step is to open the index.js
120:59 - file and write code to import
the browser router component,
121:04 - the routes component and the
route component into the index
121:09 - component.
121:32 - Let's include code to establish
the relevant route mapping for
121:36 - the app component.
121:46 - Great, let's create our home
component. Let's first create a
121:50 - folder within the components
folder named home. Let's ensure
121:54 - that the first letter in our
home folder name is lowercase.
122:04 - Let's add a file named home with
an uppercase H to our home
122:09 - folder. Let's type in ra f c e
followed by pressing the tab key
122:14 - to generate boilerplate code for
the home component.
122:21 - Let's simply type in the text
welcome so that we can test our
122:25 - route functionality.
122:27 - We'll create the code for our
home component in just a bit
122:38 - let's create the code for the
route element that points to our
122:41 - home component within the app.js
file.
123:03 - Oops, I can see a little bug in
our code. This reference to
123:08 - layout
123:10 - is not correctly formed. Let's
include the layout element
123:13 - properly within our code here.
123:17 - Let's type in npm. Start at our
command prompt and press Enter
123:21 - to launch the application
123:28 - Great.
123:41 - So let's create a component that
will be a child component of the
123:45 - home component. We will name
this component hero. This
123:50 - components denotes the hero
section of our home page that
123:54 - will display items in a carousel
that are representative of
123:58 - movies to the users of this
application. So let's create a
124:02 - folder within the components
folder named hero.
124:13 - Within the hero folder, let's
add a file named hero dot j s.
124:28 - Let's also add a file to the
hero folder named hero dot css
124:33 - where we will of course include
CSS code for our hero component.
124:49 - Let's write code to import the
hero dot css file into our hero
124:53 - component.
124:56 - Let's import the carousel
component from the relevant man
125:00 - Terrio UI NPM package
125:22 - let's import the paper component
from the relevant material UI
125:26 - NPM package
125:39 - let's write code to destructure.
The props passed into this
125:43 - component, only one destructured
value containing an array of
125:48 - movie data needs to be included
here
126:00 - let's implement the carousel
functionality. Let's include the
126:04 - carousel element like this.
126:15 - Within the carousel element,
let's write code to map each
126:19 - item in the movies array to an
item displayed in the carousel.
126:33 - The pay per element encapsulates
each movie item displayed in the
126:38 - carousel.
126:56 - Let's include div tags, so that
the movie poster is displayed,
127:01 - as well as the movie title is
displayed for each carousel
127:04 - item.
127:23 - As you can see, I've included
CSS class references in the
127:27 - relevant div tags, we'll style
our components in the hero dot
127:31 - css file in a bit,
127:34 - where we will implement the
appropriate CSS properties for
127:37 - these CSS classes.
127:41 - Oops, let's make sure that we
are importing the hero dot css
127:45 - class correctly here.
127:49 - Let's open the home.js file and
include the hero element in the
127:54 - part of the code that is
returned as JSX code from the
127:57 - home component.
128:09 - Let's make sure that we are
importing the hero component
128:13 - into our home component.
128:24 - Let's write code to ensure that
the movies array is being passed
128:28 - down from the app component to
the home component and
128:32 - subsequently the hero component.
128:48 - And that's great. We are
displaying the relevant data
128:51 - from the JSON data returned from
the relevant API's endpoint. But
128:56 - let's customize the styling of
our carousel through CSS code.
129:05 - We can position our Vyas code
editors to a pane on the left
129:09 - side of our screens. And we can
position our browsers to a pane
129:13 - on the right side of our screens
like this. In this way, we can
129:18 - watch the effects of our CSS
code changes in real time. I'm
129:23 - not going to go into a lot of
detail regarding the CSS code.
129:26 - The code will be available on
GitHub, where you can examine it
129:29 - in more detail if you'd like.
129:34 - Let's first update the CSS code
in the app dot css file. This
129:38 - CSS code effects all components
that are child components of the
129:43 - app component.
129:45 - And you're able to observe the
effects of the CSS code on the
129:49 - browser in real time as the CSS
code evolves.
129:59 - So let's import
130:00 - quicksand font from Google with
this line of code
130:20 - let's set up the box sizing and
font family properties for all
130:24 - elements
130:34 - let's set the body elements
padding and margin properties to
130:37 - zero.
130:50 - Let's style the App class. Note
that all of our components are
130:54 - children of the app component.
131:19 - Let's remove this code from the
index dot css file because it is
131:24 - not needed
131:29 - let's style the carousel
component that has been
131:32 - implemented within our hero
component. So let's include our
131:36 - CSS code in the hero dot css
file.
132:00 - And we are able to watch the
effects on the carousel
132:03 - displayed in our browsers in
real time as the relevant CSS
132:06 - code evolves.
132:15 - And we don't actually want the
post image to take up the
132:18 - carousel display. As it is at
the moment, we want an
132:22 - appropriate backdrop image a
larger image to fill the
132:25 - background for each item in the
carousel.
132:45 - I want to include a gradient
that fades from dark to light
132:48 - from the bottom of each carousel
item to where the title is
132:52 - displayed. In order to
dynamically reference the
132:55 - background image URL for each
carousel card,
133:00 - I'm going to use a CSS custom
variable.
133:05 - So we can do this by including
an inline style within the div
133:09 - element that references the
movie dash card CSS class. And
133:14 - within that inline style, assign
a variable to the property that
133:19 - we wish to reference within the
relevant CSS file. So here, we
133:24 - are naming our custom CSS
variable image.
133:32 - We are setting the CSS URL value
to the CSS background dash image
133:36 - CSS property from the backdrops
property of each movie in the
133:40 - movies array returned from the
server. Note that the backdrops
133:44 - property returned from the
server is an array containing
133:47 - pause to movie backdrop images.
In this code, I'm choosing to
133:52 - reference the first backdrop
image path in the backdrops
133:55 - array returned from the server.
Each backdrop points to an image
133:59 - that we want displayed as a
background image appropriately
134:03 - for each movie item in the
carousel. We can now reference
134:07 - each background image from
within our CSS class and style
134:10 - the background appropriately.
134:46 - So we are assigning the
background dash image CSS
134:50 - property or gradient that fades
from light to dark?
134:58 - This is just a stylistic choice.
135:00 - For our front end display, you
can see here in our CSS code how
135:05 - we are using the dash dash image
custom CSS variable to link the
135:11 - URL property value referenced in
the JSX code in the hero
135:16 - component to the background dash
image CSS property in the hero
135:19 - dot css file. You can see that
the poster image is looking
135:24 - distorted so let's style the
poster and the title
135:28 - appropriately.
135:49 - Great and we have used absolute
positioning and the CSS Flexbox
135:54 - to style our poster and handle
where it appears in the layout
136:11 - let's style the title
appropriately.
136:49 - Great, and our carousel is
looking pretty good. Let's
136:53 - create the components to house
our navigation display. Let's
136:57 - create the header component. So
let's create a folder within the
137:01 - components folder named header.
Let's create a file within the
137:05 - header folder named header.js.
137:13 - Let's import the appropriate
font awesome components
137:27 - let's import the appropriate
bootstrap components.
137:48 - And let's use React bootstrap
components to create a
137:51 - responsive layout for our
navigation menu which will be
137:55 - displayed at the top of the
screen. This is one of the huge
137:59 - advantages of using Bootstrap it
can save us a lot of time in
138:02 - creating responsive layouts.
138:22 - We are using the FA video flash
font awesome icon for our logo
138:27 - that will be displayed in the
top left corner of our screen
138:30 - within the navigation bar that
we are creating within the
138:34 - header component.
138:57 - The login and registration
buttons are being included here.
139:00 - Superficially, they are purely
cosmetic indicating that we
139:05 - could extend the functionality
of this application to include
139:09 - login and registration
functionality at a later stage.
139:11 - For example, if we wanted to
enable users to create their own
139:15 - list of favorite movies or a
watch list, the watch list link
139:19 - here is also there purely for
cosmetic reasons. We won't
139:24 - implement a watch list component
in this course.
139:28 - So above the routes
functionality within the app.js
139:33 - file, let's reference the header
component
139:44 - let's go back to the header.js
file and make sure that our
139:47 - imports are correct.
139:54 - Let's run the code
140:02 - Excellent, our navigation bar,
and our logo looks pretty good
140:15 - the next step is we want to be
able for a user to click a play
140:20 - button icon on each carousel
item. And for an appropriate
140:24 - movie trailer to play will
enlist the help of the React
140:28 - player component for this
purpose. Let's first create a
140:32 - folder named trailer within the
components folder.
140:42 - Let's create a file named
trailer dot j s within the
140:46 - trailer folder. Let's also
create a file named trailer dot
140:50 - css within the trailer folder.
141:01 - Let's create the relevant input
code in the trailer.js file.
141:07 - Let's import the use params hook
into our code from the React
141:11 - Router DOM NPM package, a
YouTube video ID will be passed
141:16 - into this component as a
parameter. So we are going to
141:19 - use the use params hook to
extract the relevant parameter
141:22 - value from the relevant URL. The
relevant parameter will contain
141:28 - a YouTube video ID which will
allow us to play a YouTube
141:33 - video, which is a trailer of the
relevant movie to the user.
141:43 - Let's import the React player
component.
141:50 - Let's import the trailer dot css
file.
141:55 - Let's create the boilerplate
code for our trailer component
141:58 - by typing in our AFC E and
pressing the tab key. Let's
142:03 - create a div container in which
our React player components will
142:06 - reside
142:13 - let's assign the Paston
parameter value to a const named
142:17 - key
142:23 - then we can include the React
player component appropriately
142:26 - like this
142:33 - we want the player to include
controls. So here we can set the
142:38 - controls property to true we can
set the playing property to true
142:42 - so that the relevant video plays
as soon as the trailer component
142:45 - loads
142:47 - and lastly, and most
importantly, we can set the URL
142:51 - property to the relevant video
on YouTube so we can append the
142:56 - relevant YouTube video ID stored
in the key const to the base
143:01 - YouTube address to point react
player to the YouTube video that
143:06 - will be played within react
player great
143:17 - let's go to the app.js file and
include the relevant route
143:21 - information for the trailer
component
143:28 - notice how we are able to let
React Router DOM know as it were
143:32 - about the YouTube video ID
parameter then our code within
143:36 - the trailer component must
access
143:53 - let's include a play button icon
provided by font awesome within
143:57 - our carousel.
144:55 - Okay so the play button icon is
present, but it needs to be
144:58 - appropriately style
145:00 - Okay, as it is tiny at the
moment, let's go to the hero dot
145:03 - css file and style the play
button icon appropriately.
146:16 - Great, let's include a media
query so that our carousel
146:20 - adapts to smaller screens
146:33 - Great, let's go to the trailer
dot css file and create CSS code
146:39 - so that the React player takes
up 90% of the viewport height.
146:56 - Lastly, we need to create the
link so when the play button
146:59 - icon is clicked, that the
trailer component is invoked,
147:02 - and the appropriate parameters
passed through to the trailer
147:05 - component.
147:19 - So the trailer link property
retrieved from the server
147:23 - contains the entire URL to the
YouTube video, we only want to
147:28 - pass the ID of the YouTube video
to the trailer component from
147:32 - the hero component. We can
extract the YouTube video ID by
147:37 - using the JavaScript substring
method to extract the last 11
147:42 - characters from the trailer link
property like this
147:53 - let's run the code.
148:16 - Excellent. The last component we
need to create is the reviews
148:20 - component. The reviews component
will enable users to view
148:24 - reviews from other users as well
as add reviews for movies into
148:28 - the system, ie, which entails a
HTTP POST request being made.
148:33 - From our React component to the
relevant remote API endpoints
148:37 - carrying the review data entered
by the user and the server side
148:41 - Java code will then save the
review data appropriately to the
148:44 - MongoDB database. Firstly, let's
create a component named review
148:49 - form. This component will
contain a form component that
148:53 - contains a text area control
where the user can enter text
148:57 - that denotes a movie review. a
submit button will also be
149:01 - included so that the user can
click this button in order to
149:05 - submit the user's movie review.
So let's create a folder named
149:09 - review form.
149:13 - Let's create a file named review
form dot j s within the review
149:17 - form folder.
149:22 - Let's include the code for the
functionality we have just
149:25 - discussed.
150:01 - Let's create the reviews
component that will be a parent
150:05 - component of the review form
child component. Let's create a
150:09 - folder named reviews.
150:14 - Let's include a file within the
reviews folder named reviews dot
150:17 - j s
150:23 - let's include the appropriate
import code at the top of the
150:27 - reviews.js file.
150:55 - Let's generate the appropriate
boilerplate code for the reviews
150:58 - React component by typing in RFC
E and then pressing the tab key.
151:12 - Let's use the use ref hook to
reference the text area control
151:16 - within the review form. Let's
use the use params hook so that
151:21 - we can extract the movie ID
parameter value from the
151:24 - relevant URL.
151:35 - This movie ID is actually the
IMDB ID of the movie that we
151:41 - have retrieved through the API
call that is made to retrieve
151:44 - the array of movie data from the
server. The IMDb ID value, of
151:49 - course, is used to uniquely
identify a specific movie.
152:02 - So when our component first
loads,
152:06 - we want to call a method that is
passed in as a prop to our
152:10 - component in order to retrieve
the appropriate data for the
152:14 - relevant movie that the user
wishes to review. So we can use
152:19 - the use effect hook like this
for this purpose.
152:29 - Let's use React bootstrap
components for example, the row
152:32 - and col components to create an
appropriate layout for the
152:36 - reviews component, we want to
display the poster for the
152:40 - relevant movie in the left part
of the screen and the reviews in
152:45 - the right part of the screen we
can use the row and col
152:48 - components appropriately to
achieve this.
153:15 - Let's include the review form
element here like this.
154:01 - Let's create a method named add
review and create the relevant
154:05 - HTTP POST request functionality
for adding a review to the
154:09 - MongoDB database which resides
on a remote server.
154:43 - And let's write code to update
the state of the reviews array
154:47 - on the client side.
optimistically meaning that we
154:51 - are not using data returned from
the server ie data that is saved
154:54 - to the database for updating the
state of the reviews array. We
154:58 - are updating the array
155:00 - directly from the data entered
on the client.
155:04 - We also want to include code
that clears the relevant text
155:07 - area control. Once the user has
successfully submitted a review,
155:12 - we are updating the state of the
reviews array on the client
155:15 - through the use of the set
reviews method that will be
155:18 - passed as a prop from the app
component.
155:33 - Let's go to the app.js file and
create a method that uses Axios
155:39 - to make a get request for data
pertaining to a single movie
155:49 - so an IMDB ID value will be
passed into this method to the
155:54 - movie ID parameter and HTTP get
request. Using the movie ID
155:58 - value appropriately in the URL
will be made to retrieve data
156:03 - for a single movie from the
remote server.
156:25 - So let's set the state for the
movie variable.
156:31 - And to make our code clearer,
let's extract the reviews array
156:34 - from the movie data and track
the state of the reviews array.
156:58 - Let's make sure that the
appropriate props are being
157:00 - passed down to the reviews
component.
158:22 - We are now able to create
reviews for the movies retrieved
158:25 - from the remote server
ultimately from a MongoDB
158:29 - database that stores our movie
data. So we are adding reviews
158:33 - to our MongoDB database through
an appropriate HTTP POST request
158:38 - to inappropriate endpoint
Excellent.
159:55 - One thing we must do whenever we
implement a list of uniquely
159:58 - identifiable AI
160:00 - items in our JSX code like this
160:04 - is appropriately includes the
key property for each list item.
160:08 - to uniquely identify each item
in the carousel, we can set the
160:12 - key property for each movie item
displayed within the carousel to
160:18 - the appropriate IMDb ID value
for each movie. This value has
160:23 - been passed down to us with the
movie data array that we
160:27 - retrieved from the remote server
using the appropriate HTTP get
160:32 - request. I hope you've enjoyed
building this front end using
160:36 - React. And I hope you feel that
you have benefited from this
160:40 - course.
160:42 - If you've got to the end of this
course you've done exceptionally
160:44 - well. Thank you and take care