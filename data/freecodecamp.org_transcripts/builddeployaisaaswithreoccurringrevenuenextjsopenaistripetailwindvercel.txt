00:00 - In this course, you will learn everything you need to do to start your own software as a service company.
00:06 - You will learn how to build and deploy a full stack AI SaaS from the ground up.
00:12 - You'll even learn how to charge subscription fees using Stripe.
00:14 - The app you will develop uses Next.js, OpenAI, TypeScript, and Tailwind.
00:19 - Elliot Chong created this course.
00:21 - He specializes in creating comprehensive tutorials to build AI-powered applications.
00:27 - What's poppin'? I'm Elliot, a software developer from Singapore,
00:30 - and today I'm going to showcase what I've built here, which is a chat with PDF SAS product.
00:35 - I'm going to teach you how to build it from scratch.
00:37 - So this is a SaaS platform that is a clone of an original product called chat.pdf itself,
00:43 - and how it works is really simple.
00:45 - You can basically drop any PDF you want here, and you're able to use OpenAI to interact with the PDF.
00:50 - So for the first example, let's just take my own resume here.
00:54 - I'm going to upload my own resume.
00:56 - This is going to upload the file into Amazon AWS S3,
01:00 - and then within a few seconds here, we can see that it's hosted on Vercel,
01:03 - and you can see that a chat is created with my resume,
01:06 - and we're able to see it updated on the platform.
01:09 - And the magical part is here.
01:11 - I can ask any question, and it will have the context of this entire PDF.
01:15 - So let's say I ask a question like, where did Elliot intern at?
01:21 - So I'm going to zoom in a little so you can see.
01:23 - So when I press enter, we can see that there will be a streaming response back from OpenAI itself.
01:28 - And he says that Elliot intern at Relu8 technologies.
01:31 - And this is correct.
01:32 - If you see up in the PDF, I did intern at this company called Relu8 Technologies.
01:36 - So it's able to get the context of this entire PDF and feed it into OpenAI itself.
01:41 - And usually we can't do that because if you try to feed in the entire document,
01:45 - it might exceed the token count for GPT, like chat GPT.
01:49 - If you try to paste this entire PDF into it, it might overflow and it won't be able to respond to you.
01:54 - But in this case, it's able to take in the context.
01:57 - So let's ask here another question like, what are some projects that he did?
02:06 - So I send it and we'll be using Vercel AI SDK for this streaming AI effect.
02:10 - So it's able to list out the PDF, and all of these chat logs are saved into the database.
02:16 - So let's take another example on how this platform can actually be potentially useful.
02:22 - So one good use case for this PDF function is, let's say I come to any documentation site.
02:27 - So let's say I'm in the Vercel documentation, I have this picture, but I don't read through it.
02:32 - And I actually want to ask GPT to interact with this.
02:35 - Because the issue is that chat GPT, if you go to the chat GPT website, the information are outdated,
02:40 - meaning that whatever you ask, the chat GPT has only been trained on data up to,
02:44 - I think it was 2021, September or something.
02:47 - So it doesn't have updated information about the updated technology documentation.
02:53 - So if I were to ask about a new feature of Vercel, chat GPT won't be able to answer that accurately.
02:57 - It will hard-listen it.
02:58 - So what I can do is I come down to that documentation, I press Command P, I can save this entire file,
03:03 - look, I can save this entire file into a PDF.
03:06 - I'm going to press Save.
03:08 - Okay, and I'm able to upload this PDF onto my chat PDF platform.
03:13 - So I'm going for it to save, and after that I can come here.
03:16 - I'm going to upload my CDS Edge runtime Vercel docs, I'm going to upload it onto the platform,
03:21 - and it will basically allow me to interact with the latest information from whatever document I want.
03:27 - So I can ask like, what is the Vercel Edge runtime about?
03:33 - So I'm going to send this and you can see that this information here is pulling directly from the document itself.
03:41 - So it does not hard-listen it.
03:44 - So that's another good thing about this entire platform here.
03:48 - So we're able to see that it's able to pull in the latest information.
03:51 - So not only is this a really useful platform, it's a very useful platform.
03:55 - I'm going to teach you how to build this entire thing from scratch.
03:58 - And actually what there's one more feature on the showcase is that by default,
04:02 - we can actually limit this platform so that users, when they sign in, they can only upload three PDFs.
04:07 - And then we'll be able to teach you how to integrate the Stripe API.
04:11 - So we can see Manage Subscription.
04:13 - We're able to use Stripe to allow them to pay a monthly subscription, $20 a month,
04:19 - and they're able to use this platform unlimited.
04:22 - So I'm going to be teaching you how to do the Stripe integration,
04:24 - and you're actually able to deploy this sales product and eventually make a business on it
04:28 - if you want to improve on this platform.
04:30 - So we'll be allowing a lot of things today.
04:32 - So there's two main parts of the tech stack.
04:34 - The normal tech stack for the full stack we'll be using next year is 13.4.
04:38 - We'll be using a click authentication.
04:40 - So it's a new authentication library that makes Google authentication,
04:44 - all types of authentication, super easy.
04:47 - We'll be using Drizzle ORM and NeonDB.
04:50 - So NeonDB is a new, not new, but it's a serverless post-grace database.
04:55 - So we'll be using that instead.
04:57 - And we'll be using the newest kit on the block Drizzle ORM.
05:00 - So this is in comparison to PrismaDB.
05:05 - Prisma is now ORM, but this I'll be using Drizzle.
05:07 - And I'll actually explain why we'll use Drizzle later on.
05:10 - Then obviously we'll be using Stripe API for the assessed product integration.
05:14 - And lastly, we'll be uploading all our files to AWS S3.
05:17 - So I'll teach you how to use the S3 bucket also.
05:20 - This is for the file storage.
05:22 - For the AI tech stack, I'll be teaching you how to use PyConDB,
05:25 - LangChain, OpenAI, and the new Versailles AI SDK.
05:28 - So I'll be going in depth on how to actually use these tools
05:31 - to actually create that custom context PDF thing.
05:34 - And so PyConDB is a DB to store a vector embeddings of all documents.
05:40 - LangChain is what ties together the OpenAI and the PyConDB.
05:43 - And OpenAI is obviously the GPT model
05:46 - that actually creates the last language model for us to use.
05:49 - So I'll explain a lot more in depth later on.
05:51 - So we just need to know that I'll be teaching you how to use this tech stack.
05:55 - So the new main concepts that I want to teach in this video
05:58 - is the H runtime environment.
06:00 - So what's H runtime?
06:02 - The H runtime is if you come back to exactly the Versailles docs
06:06 - that we saw just now.
06:07 - So the H runtime is in comparison to the normal Node.js environment.
06:12 - So H runtime is, let me draw it by this explanation.
06:15 - So imagine this whole thing is the globe, is the whole world, right?
06:18 - And let's say I have these two continents, Asia and America.
06:20 - Obviously, they're not to scale and there are other continents,
06:23 - but I'll demonstrate something.
06:24 - So let's say when you deploy a normal function,
06:27 - a normal endpoint to Versailles or a normal server,
06:30 - the server will leave somewhere in the world that you choose
06:33 - that is closest to your users.
06:34 - So let's say a lot of your users are close to Asia.
06:37 - You ideally set up your server in Asia
06:39 - so that whoever makes requests to the server
06:42 - will be able to quickly get the response back
06:44 - so to ensure the best user experience.
06:46 - However, what if the someone from America
06:49 - wants to make a request to your server?
06:51 - It's to travel all the way down to Asia and then get the response back.
06:54 - So you make the whole experience very slow.
06:57 - So that's the traditional serverless environment thing.
07:02 - So what the H runtime does is instead of packaging up
07:07 - and deploying the server to only one location,
07:09 - it actually is able to duplicate the code
07:12 - and actually deploy the execution environment onto CDNs.
07:17 - So CDNs are content delivery networks,
07:19 - meaning they are small machines
07:21 - that is distributed all around the world, right?
07:24 - And basically it allows for a very fast user experience.
07:27 - So whenever, wherever your users are,
07:30 - they are able to find a CDN that's closest to them.
07:33 - And so when they make the request,
07:34 - no matter where you are in the world, it's going to be super fast.
07:37 - So why the trade-off of being able to deploy all around the world
07:40 - and making it super fast,
07:42 - the trade-off is that H runtime usually have a smaller package size.
07:46 - Meaning, let's say we come back to the H runtime.
07:49 - Let's look at that trade-off.
07:50 - So H functions run on H runtime, right?
07:53 - So the H runtime does not expose all the node APIs.
07:56 - Meaning, right, the power of node.js is that it has a lot of packages on NPM, right?
08:00 - So you're able to use all the NPM packages on a normal serverless environment, right?
08:05 - But if you're using the H runtime,
08:07 - you're sacrificing the speed for,
08:09 - you're sacrificing the packages for the speed.
08:11 - So there will be a lot of restriction in terms of the APIs that you're able to use.
08:16 - But if you sacrifice that and you use the supported APIs
08:19 - like the fetch API and the request response, all these,
08:22 - if you're able to sacrifice that,
08:23 - you're able to get a very, very fast response time for your application, right?
08:28 - So the reason why I brought up the H runtime is because
08:32 - today I'll be teaching you how to deploy all your AI services on the H runtime.
08:37 - So OpenAI has actually created a lot of initiatives
08:40 - and a lot of these are different packages,
08:42 - especially the Versailles AI SDK.
08:44 - They have started a lot of initiatives to move these AI packages up to the H,
08:49 - to make it H compatible.
08:50 - Meaning that a lot of these AI applications will be able to run on the H, right?
08:54 - Furthermore, the reason why we chose Drizzle Rm is because Drizzle Rm is compatible on the H, right?
09:00 - So I don't think Prisma DB is still compatible on the H,
09:04 - therefore we are not able to use Prisma for this project.
09:06 - So I'll be teaching you how to use Drizzle Rm to interact with your database.
09:11 - Then the second new concept down the check is the retrieval augmented generation.
09:15 - So this is a... So RAG, retrieval augmented generation,
09:21 - is a concept within a large language model.
09:24 - It's an AI framework for retrieving facts from an external knowledge base
09:28 - to ensure that the large language model has accurate information.
09:32 - So instead of the chat GPT just hallucinating up information,
09:36 - we're able to give it a certain context, in this case the PDF,
09:39 - such that it's able to generate accurate up-to-date information.
09:42 - So that's what a retrieval augmented generation is within the context of this project.
09:46 - So I'll be going much more in-depth on how to build the proper RAG framework for our application.
09:53 - Alright, so with that, let's actually begin the development of this platform.
09:57 - So the first thing here I'm going to do is I'm going to come out and open up our terminal
10:02 - and thus initialise a new Next year's project by doing MPX create-next-app at leaders with a TypeScript flag.
10:10 - So let's press enter, and it's going to ask us for the project name.
10:13 - So let's call it Chats-PDF.-youtube.
10:19 - So we'll be using ESLint, Terwin CSS, we're going to be using the source directory,
10:24 - and this is the new 13.4 app router.
10:27 - We're going to leave everything as a default and we can wait for it to install and then we'll come back soon.
10:30 - Okay, so after we have initialised the project, let us actually cd into the chat-pdf-youtube,
10:36 - and let us open up in our code editor by doing code.
10:39 - We should open up in VS code.
10:42 - Okay, so the first thing here what I'm going to do is let me open my terminal and let's just do npm run dev
10:48 - so that we can make sure that the project is up and running.
10:50 - So when we come back to our browser, I'm going to open up localhost 3000.
10:55 - So I'm going to try to develop it alongside here, I'll move it to the right of the screen
11:00 - and open up my VS code here.
11:02 - Okay, awesome.
11:04 - So right now we have our Next year 13.4 project up and running.
11:07 - Okay, so the first step I'm going to do is I'm going to come down to my directory.
11:11 - So under the source, we can see that there's a new app folder here,
11:14 - and how the routing works within Next year 13.4 is that under the app router,
11:20 - this page.tsx is a special file.
11:22 - Whenever you name the page.tsx, you can look at the file structure of it and determine the root layout.
11:27 - So right now this page.tsx lives at the root app folder, therefore it is mapped to this slash root.
11:36 - So this app.tsx actually corresponds to this page.
11:40 - So what I'm going to do is I'm going to delete everything here,
11:43 - and let me just return a normal h1, right, that says hello world.
11:50 - And let's give you a class name of text rate 600 to test out Tewin CSS.
11:56 - So if we save it, we can see that now it works.
11:59 - Alright, that's good.
11:59 - So now that Tewin CSS is set up, let us actually set up a shad cn.
12:04 - So shad cn is a component library that's built on top of Tewin CSS.
12:09 - So it's based on radix UI, which is a accessibility library.
12:13 - So if we come to radix UI, we can see that it is a component library that gives you the accessibility features out of the box.
12:23 - But these are unstuck.
12:24 - That means that by default radix UI is not stuck component.
12:28 - So to add a plaster on it, that's where shad cn comes in.
12:31 - So shad cn uses Tewin CSS to style those accessible components for us to use.
12:36 - Alright, so to actually start using shad cn, we'll come down to open a new terminal instance.
12:41 - So I'll split the terminal here.
12:43 - And let me just move this to the side.
12:45 - And let us do mpx shad cn-ui-ui at latest, we're going to do init.
12:51 - So it's going to initialize the configuration for our styling.
12:55 - So we'll be using TypeScript, we'll be using the default style.
13:00 - We'll leave the base color as a slate.
13:03 - And for globals.css, if we come down to our directory, we can see that under this app, we got this globals.css, right?
13:11 - I'm going to delete this.
13:12 - So because we want shad cn to control our styling needs, I'm going to delete this globals.css.
13:19 - Then I'm going to come down to my terminal and I'm going to enter, it's asking where's my globals.css?
13:25 - So I'll do slash source, slash app slash globals.css.
13:29 - So it's going to replace the globals.css that we have.
13:32 - So we'll be using CSS variables and our tailwind.config, we can see that it leaves at the root here, tailwind.config.ts.
13:39 - So let's just enter tailwind.config.ts.
13:43 - And lastly, we'll leave the import alias for components and utilities as it is.
13:48 - I'll be using React server components and proceed to write the file, the configuration to components.json.
13:54 - OK, so let me just refresh the page.
13:57 - OK, so right now we can see that everything's working fine.
14:00 - OK, so let me close it down.
14:02 - So shad cn has created a components.json here that contains all configurations for our shad cn components.
14:11 - It has also created our globals or CSS, which includes the tailwind styles and also the shad cn default CSS variables here.
14:19 - And lastly, we can see that it created a new lib folder and under it has created utils.ts for us.
14:25 - And this is just a tailwind utility class function so that we can actually use conditional tailwind styling much more easier.
14:33 - So I'll go through how to use this function on later on.
14:37 - And lastly, it has created a component folder for us.
14:41 - So to begin using shad cn, let's render out the button.
14:44 - So to install the button, how it works is you have to come down to your terminal and whenever you want to use a new component from shad cn,
14:51 - you have to do mpx shad cn-ui add latest add button.
14:56 - So you have to add the individual components.
14:58 - So this ensure that whatever components that you don't need from shad cn will not be installed.
15:03 - So I can press Y to install the components into our folder.
15:07 - If I come back to my directory, we can now see that under the components folder, I have a new UI folder.
15:12 - This UI is going to contain all the shad cn components.
15:16 - So this is where shad cn defines the button for us.
15:18 - We don't need to, as you will touch this file, we just need to know that it exists and we can use it.
15:23 - So how do I actually use this button from shad cn?
15:26 - So let's come back to our page.
15:27 - So instead of returning a hello world, I'm going to return a button.
15:31 - So we can see as we type out, the button will be imported from components slash UI slash button.
15:35 - So I can press enter to auto import and I can just say click me.
15:40 - Then I'm going to save it and now we can see that the shad cn is properly configured.
15:43 - So that's excellent.
15:45 - Alright, next up, let's set up clock authentication.
15:47 - So in our original application, we can see that this or the authentication is handled by clock.
15:54 - So I can sign out and it is managed.
15:56 - And if I want to actually log in, I can press log in to get started.
16:01 - So then this will lead us to the clock signing page.
16:03 - So I can sign up with GitHub or Google.
16:05 - So in this case, I'm going to sign in, continue with GitHub.
16:07 - Then basically it will lead me back to my homepage and I'll be able to get my user information.
16:11 - And then we can see that he has brought us back to the original application.
16:18 - So to set up clock, let us go to this search clock auth.
16:22 - And then it should be the first link.
16:24 - So clock.com, I'm going to move this to the site first.
16:27 - So the first step here is let us actually log in.
16:29 - So if you have not created an account, please do.
16:31 - So after you have done that, we can actually come to our, let's just zoom out.
16:37 - And then we can go to the console, the dashboard.
16:39 - So let's press the dashboard and then we can come in and create a new application.
16:45 - So click on add application.
16:46 - And in this case, let's name it to chat.pdf-youtube-youtube.
16:54 - So you can choose how your users will sign in.
16:56 - In this case, I'm going to toggle off email address, right?
16:59 - So we just want to allow them to use Google or GitHub.
17:04 - So you can add whatever you want, you can add Microsoft, whatever you want.
17:07 - So I'm going to just choose this tool for demonstration purposes.
17:10 - Then we'll click on create application.
17:12 - So let me just split my screen again.
17:15 - So now that we've got a publishable and secret key,
17:21 - we have to copy these two environment variables into our.env file.
17:26 - So come back to your directory and at the base of the directory,
17:29 - let's create a new.env file to store all our environmental variables, right?
17:34 - So one more thing, just in case we forget,
17:36 - let's go into our gitignore and then let us enter our.env.
17:40 - So we don't want git to actually track our.env file,
17:43 - so we don't want to push these environment variables up to GitHub.
17:46 - So save the git.gitignore and now we can copy these two lines of code into the environment.
17:53 - So these will define the two clerk API keys for us to use.
17:57 - So let's save the.env and we'll close it up.
17:59 - Now let's press continue in doc so that we can follow that instruction.
18:02 - So we'll be using clerk with Next.js so we can just follow this.
18:05 - So let me just close this out.
18:07 - So the first step here is actually to install the package.
18:10 - So let's npm install add clerk-next.js.
18:16 - So let's install that.
18:17 - So then the second step is to put the environment keys,
18:20 - which we have already done.
18:21 - So now the third step is actually to mount this clerk provider.
18:25 - So what I'm going to do is, once it has finished installed,
18:27 - I'm going to come out to my layout.tsx.
18:30 - All right, so under my layout.tsx, I am going to basically put in the clerk provider.
18:37 - So here I'm going to do a few things first.
18:39 - So right now we can see that it has finished installing.
18:42 - So in my layout.tsx, this file is the one that wraps my entire application.
18:48 - So you can see this children.
18:49 - This children represents my entire application.
18:52 - So whatever metadata here we can add, we can wrap this entire application here.
18:57 - So for this metadata, I'm going to delete the description.
18:59 - So for the title here, this corresponds to whatever title you see on the tab itself.
19:04 - So I'm going to name it to chatspdf youtube.
19:09 - So if I save it, now we can see that the tab title has updated.
19:13 - Then under here, I'm going to add the click provider, right?
19:15 - So the first thing I'm going to do is, let me see if I can auto import.
19:18 - So I'm going to import clerk provider.
19:20 - So it doesn't auto import.
19:21 - So let's just manually import the click provider from add clerk slash next.js.
19:28 - So clerk provider, and then I'm going to wrap my entire application with this clerk provider.
19:37 - Okay, then I'm going to save it.
19:39 - So after adding this clerk provider, so let's see what else we need to do.
19:44 - So we have wrapped the entire clerk provider.
19:47 - And last thing here is we need to protect our application.
19:49 - So we need to create this middleware.ts file.
19:52 - So come down to our folder, and under in our root directory, in our source folder,
19:58 - so under source, create a file called middleware.ts, right?
20:03 - So this middleware.ts is a special file, right?
20:06 - Such that in here, we can define code that will run before every routes, right?
20:10 - So let's say you navigate to a route to slash home or slash api slash chat, right?
20:15 - Before you hit the endpoint, the code within this middleware file will run first.
20:19 - So let's just copy in the code from, we'll copy in.
20:24 - So let me explain what it does.
20:25 - So this config, right, that specifies the matches.
20:29 - So this matcher is basically a bunch of regex to specify when this middleware should run.
20:35 - So it will run whenever we're hitting a slash endpoint,
20:39 - or whenever we hit like slash api with a star character.
20:42 - So this array will basically dictate when this code will run.
20:46 - And then here, this is the auth middleware that's imported from clerk, right?
20:50 - So this code here will actually then run the necessary logic to protect our routes.
20:56 - So by right now, all the routes are private.
20:58 - So I cannot even access the slash.
21:03 - So now if I save it here, and I refresh the page,
21:05 - we see that it should redirect me to the clerk page because it's a protected route.
21:09 - And in this case, it does.
21:11 - So we can see that it's redirected to their hosted domain, right?
21:15 - And it's asking us to sign in to our chat PDF there's YouTube, right?
21:19 - So we actually want to make the slash route into a public route.
21:23 - So what I'm going to do then is I'm going to come down here into our auth middleware.
21:28 - So within this auth middleware, I can pass in some options.
21:30 - So one of the object is the public route.
21:33 - Public route is an array.
21:35 - So I can define what routes I want to be public.
21:37 - In this case, I'm going to just specify the slash route to be public.
21:40 - So then when I come back here to my local host 3000,
21:43 - instead of kicking me to the sign in page, I'll be authorized to visit this route.
21:47 - So this is a public route.
21:49 - So I don't have to be logged in in order to view this page.
21:52 - Okay, so now that we have set up a clerk,
21:55 - let's actually begin creating the homepage here.
21:58 - All right, so I'm going to just start out the diff.
22:02 - So the first thing here is actually to mark it async.
22:04 - So this async will make sure that it's a server component.
22:07 - So this entire code block is going to run once on the server to generate the HTML code.
22:11 - Then this HTML code is going to be directly sent back to the client for it to be rendered.
22:15 - So this is a server component.
22:17 - So I'm going to just return a few return.
22:21 - The first thing here is to create the upper the outer diff.
22:24 - It's going to have a width of a screen and the minimum minimum height of a screen.
22:30 - And also, let's create a bit the background gradients.
22:33 - So I search up tailwind CSS bg gradient.
22:37 - And basically, I found this website called hyper color that basically gives you all these
22:41 - options for gradients and you have to customize it and copy the tailwind CSS to your file itself.
22:47 - So I've already found one that I like.
22:49 - So I'm going to paste it in here.
22:50 - So it's going to be bg-gradient2, right?
22:55 - From rows 100 to 100.
23:03 - So if we save it, now we've got this nice background going on here.
23:06 - So within this diff, let us create an outer diff that centers everything in the center.
23:10 - So we'll do absolute position absolute.
23:13 - We'll give you a top of half, left of half and offset it back by negative translate half
23:20 - and negative translate y of half.
23:24 - So this will center anything within it into the center of the screen.
23:28 - So that's nice.
23:29 - So now let's actually create the text.
23:31 - So within this diff, let's have a new diff called flex column.
23:37 - So we'll have items of center and text of center.
23:44 - Within this diff, let us create a diff with a class name of flex and items that center.
23:51 - Within here, we'll have a h1 that says chat with any PDF.
23:56 - So let's save it first.
23:58 - We give this h1 a class name of margin of three, text of five excel and font of semi bold.
24:05 - So let's save it and now we have a nice title showing up here.
24:09 - Below the h1, I'm going to show the user button.
24:11 - So now we can see that there's this user button whenever I'm signed in
24:15 - that shows my information and I can manage my account.
24:18 - And this is a component provided by clerk itself.
24:20 - I can sign out also.
24:22 - So this component is called user button, right?
24:24 - I can import it from a clerk slash next to yourself, right?
24:28 - So we'll import that and we can pass in one option for after sign out URL.
24:33 - So whenever they click sign out, we're going to redirect them too.
24:36 - So I'm going to redirect them back to the original URL.
24:39 - So it's the same page basically.
24:41 - So let's save it.
24:42 - So right now we can see that nothing shows because we're not signed in.
24:44 - So this user button will only show when you're signed in.
24:47 - Okay, so that's normal.
24:48 - So then below this diff that shows a chat with any PDF,
24:53 - let's create another diff called flex and give your margin top of two.
24:58 - All right, we here will show a button that says go to chats.
25:07 - So let's save it first, right?
25:09 - So this button will show so that they're able to go to their chats if they're signed in.
25:14 - So actually, how do we check whether they're signed in?
25:16 - So actually, clerk also provides us with another very nice utility function called
25:20 - auth.
25:21 - So we can import this auth function from clerk, right?
25:23 - We'll invoke it.
25:24 - So we have to await the call here first.
25:27 - And we'll be able to get back a user ID.
25:30 - So I'm able to get back a lot of different things, right?
25:32 - But one of these things is the user ID.
25:34 - So if the login, this user ID will resolve to a string, right?
25:38 - Is it a string or no?
25:39 - But if it's no, that means they are not authenticated.
25:42 - So again, bind it to a variable called isAuth.
25:46 - This would be double negational user ID.
25:50 - So if it is not now, if it is now, this will turn it into a Boolean.
25:54 - And this isAuth now is a Boolean itself.
25:57 - It is a Boolean.
25:57 - So it's whether they are logged in or not.
25:59 - So underneath here, we actually want to only show this
26:03 - if they're authenticated.
26:05 - So if they're authenticated, then we let them go to the chats page.
26:09 - So right now, we're not authenticated.
26:10 - Therefore, it is hidden.
26:12 - OK, so that's good.
26:14 - So then underneath this div, let us have a paragraph tag that just says,
26:19 - join millions of students, researchers, and professionals
26:27 - to instantly answer questions and understand research with AI.
26:36 - So let's save that.
26:37 - It shows a nice tagline below it.
26:39 - So let's give this paragraph tag some styling.
26:42 - So we'll give you a max width of Excel,
26:43 - a margin top of 2, tags of large, and tags slates of 600.
26:50 - So if we save that, we got a nice styling here.
26:52 - So actually, just let me change it to margin top of 1,
26:56 - because I think it's a bit too big right now, margin top of 1.
26:59 - OK, that's good.
27:00 - Then underneath the paragraph tag,
27:03 - so we're still just above the tree closing tags.
27:06 - Let's have a new div that is a width of 4 and margin top of 4.
27:11 - OK, so this part here is going to be what is going to be the file upload page.
27:18 - So I'm going to just check if it's off.
27:21 - So if they're authenticated, then it makes sense for me to show a file upload component.
27:28 - So I'm going to create a file upload component later.
27:31 - However, if they're not authenticated,
27:32 - let us actually link them to the sign-in page.
27:35 - So I can import this link from next slash link.
27:37 - And within this link, let us just have a button,
27:42 - a button that says log in to get started.
27:47 - So this link component is going to have a hitref to slash sign in.
27:53 - So let's save it.
27:54 - So I still haven't created this sign-in route.
27:56 - So I'm going to create that soon.
27:57 - And this sign-in page is basically a click page
28:00 - so that they're able to see and log in with their Google or GitHub.
28:04 - So log in to get started.
28:05 - And let me just add an icon just below this button.
28:11 - So within this button, let me add a component called log in.
28:17 - So for the components, let us actually download the package
28:24 - called npm install lucid-react.
28:27 - So this lucid-react is basically a React package
28:31 - that gives us a lot of nice icons for us to use.
28:33 - So let me just do log in again.
28:35 - So let me just import it manually.
28:38 - So import from lucid-react.
28:44 - Okay, and then there should be a log in component here, log in icon.
28:49 - So let me just import it log in and let's save this.
28:55 - And right now we can see that there's a nice button here.
28:58 - So let me just dial it a little.
28:59 - So let's give you a width of 4, height of 4,
29:02 - and a margin left of 2.
29:06 - So now it looks much nicer.
29:08 - So then finally, underneath this div, we can add an image.
29:13 - So in case you want to showcase your application product,
29:16 - you can just add a screenshot of your image down here.
29:18 - So just in case for demonstration, I won't add it here,
29:20 - but it's a very simple function to add.
29:23 - So now let's actually create the log in route.
29:25 - So one more thing we need to add is if we come back to our.env
29:32 - file, we can actually define a few things for kirk to take into consideration.
29:36 - So let's come back to kirk.com and let's actually view the documentation again.
29:41 - So I'm going to come back to my console.
29:44 - So I'm going to expand this out a little bit more.
29:46 - So come back to our dashboard.
29:49 - Let me expand this.
29:50 - So dashboard and come back to our kirk-pdf-youtube.
29:56 - And let's come down to our continuing docs.
30:02 - So we have already set up the provider.
30:04 - We protect our application.
30:06 - So last thing here is actually to create the environment variables
30:10 - to define where I will sign in and sign up pages are.
30:13 - So I'm going to copy these four variables into my.env file over here.
30:18 - So I'm going to copy it just below here.
30:22 - So let me just add a comment that says this is for the kirk.
30:26 - Kirk environment variables.
30:28 - So we list four variables.
30:31 - So it defines where our sign in page is, where our sign up page is,
30:34 - and where to go after we have signed in and signed up.
30:37 - So we'll just leave it as default.
30:38 - So even to change it, let's say you want to bring them to a dashboard after they have signed in,
30:42 - you can just easily change it to a slash dashboard.
30:44 - And then whenever kirk signs you in,
30:47 - it will automatically navigate you to dashboard.
30:50 - So let's save it.
30:51 - So how do we actually create these sign in files?
30:53 - So if you come up to our first step here,
30:56 - we can build our own sign in and sign up pages.
30:59 - So let's come down to our directory.
31:01 - So the first step is come down to our app folder,
31:03 - and let's create a folder called sign-up.
31:07 - Within this sign up, create another folder called
31:11 - double square brackets dot dot dot sign-up.
31:14 - Then within this folder, let's create a page.tsx.
31:18 - Then this page.tsx, we can just import the sign up component from kirk itself.
31:22 - So this sign up component has the pre-style from kirk itself.
31:26 - So let me save that, and let us do the same for the sign in page.
31:29 - So come down to our app, and let us create a new folder called sign-in.
31:34 - Within it, let's create the dot dot dot sign in wow card,
31:39 - and then let's create page.tsx.
31:42 - So page.tsx is a special file name.
31:45 - So we'll do the same for the sign in.
31:46 - We'll import it from kirk itself and just return it.
31:49 - Okay, so now that everything is completed,
31:52 - if you come back to our YouTube,
31:54 - and we can see that when we hover over it,
31:56 - we can see that it's being brought us to our sign in page.
31:58 - So let me click on it, and by right,
32:00 - it should bring us to our slash sign in,
32:02 - and it's basically showing us this default component from kirk.
32:08 - So let me just center this component in the center.
32:11 - So I'm going to just return a wrapping div with a position absolute.
32:17 - Okay, so I'm going to wrap this into sign in.
32:20 - So let us have this custom of absolute top of half,
32:25 - left of half, and the div translates x of half,
32:29 - and the div translates y of half.
32:31 - So let me save it,
32:33 - and now we can see the sign in page is brought to the bottom.
32:36 - So I'm going to delete this semicolon.
32:38 - So then we can press continue with GitHub,
32:39 - or we can go to the sign up page.
32:41 - So if we come back to the sign up page,
32:43 - we have shown the sign up screen here.
32:45 - So I'm going to do the same.
32:46 - I'm going to copy over this div to our sign up page.
32:48 - Right, so I'm going to just wrap this entire thing,
32:53 - and then within here, let me just close this div,
32:58 - and then now it's also centered.
32:59 - So I'm going to sign in with my just Google account,
33:02 - continue with Google,
33:04 - and we can choose which account you're going to sign in with,
33:06 - and by right, this should navigate us back to our slash page.
33:10 - So now we can see that we have been signed in.
33:14 - Right, so now we can see that our user button being shown here,
33:17 - and we can see that since we're logged in,
33:18 - the file upload component is being shown.
33:21 - So that's perfect.
33:22 - Okay, so now that we have set up Cluck,
33:24 - we can see that we can manage our account and even sign up.
33:27 - So all these functionalities are provided by Cluck
33:30 - in a very simple to use API.
33:32 - Okay, so the next step here is actually let us set up our database.
33:35 - So for the database, we'll be using a Neon DB.
33:38 - So come down to Neon DB.
33:41 - Right, we can see that Neon is a serverless,
33:43 - branchable postgres database.
33:45 - I'm going to open it here a bit more.
33:47 - So to actually create the database,
33:49 - so you have to sign up or sign in.
33:51 - So I have to sign up with my GitHub account,
33:54 - so I can sign in.
33:55 - So underneath the project,
33:56 - you get one free project for this database.
33:59 - So you just have to come down and press create new project.
34:02 - So for the name, let me just name it as chat PDF-usual.
34:06 - For just postgres version, just leave it.
34:09 - And for the region, choose one that is nearest to you.
34:11 - In this case, I'm going to choose Singapore.
34:12 - For the rest, just leave the configuration as default
34:15 - and just press create project.
34:17 - So now we can see that the project has been created
34:20 - and the database has also been created for us really quickly.
34:23 - So now we're going to save this string
34:27 - to our environmental variables.
34:29 - So copy whatever database URL you have here.
34:33 - Come down to your VS code.
34:35 - Come down to your.env file.
34:37 - And below here, let me just initialize this variable called database
34:41 - and let's just paste it in.
34:48 - So make sure there's no white lines
34:49 - and make sure there's no white spaces behind.
34:52 - Okay, so one more thing here you might need to add
34:54 - is come down here at the end.
34:56 - Right, you need to add a config called SSL require.
35:03 - So let me just check here.
35:05 - So we're going to add one question mark
35:07 - and just do SSL mode equals to require.
35:10 - So this is so that our connection is secure
35:13 - and so that our Drizzle ORM is able to connect
35:16 - to our neon database.
35:18 - So after you're done, just save it and close it back out.
35:21 - Okay, so now that we have our neon setup,
35:23 - let's close the tab.
35:25 - We don't need it anymore.
35:26 - And now let's actually set up the Drizzle ORM.
35:29 - So if we are not sure what Drizzle is,
35:33 - Drizzle ORM is a TypeScript object relational mapper.
35:37 - So what's an object relational mapper?
35:39 - It's just a way for you to interact with our database
35:42 - without using SQL.
35:44 - So it also gives us that type safety
35:46 - and makes dealing with database cost much easier.
35:49 - And why we chose Drizzle ORM over Prisma
35:51 - is that Prisma is known to be much slower
35:54 - and also Prisma is not edge compatible.
35:56 - And in this case Drizzle ORM is a new ORM
35:59 - that is edge compatible.
36:00 - So let's actually set up Satya.
36:02 - So go under your file directory
36:06 - and we need to create a new library for this.
36:09 - A lib.
36:09 - So come under your lib and let's create a database folder.
36:13 - So name it db
36:14 - and within this db folder in the lib folder,
36:17 - create a new file called index.ts.
36:20 - Okay, so this is where we can set up our Drizzle ORM.
36:23 - So the first thing here,
36:24 - we need to actually install the Drizzle packages, right?
36:27 - So let me just close it and open our terminal
36:29 - and let's install the Drizzle by doing npm install
36:33 - a Drizzle dash ORM.
36:36 - Okay, and then we need one more thing.
36:38 - We need the npm install at neon database slash serverless.
36:45 - So this is for the adapter between the neon
36:48 - and also our Drizzle ORM.
36:50 - So while we're waiting for that to deploy to install,
36:54 - let's come down to our index.ts.
36:55 - So the first thing here is actually let's import
36:58 - a few things from at neon database slash serverless.
37:01 - So we need the actual neon function
37:03 - for the connect to our database.
37:05 - And then also we need a neon config.
37:08 - So we can set neon config dot fetch connection
37:12 - cache equals to true
37:13 - so that it caches the connections that's being set.
37:17 - And then underneath that, let's actually check.
37:19 - So if we do have a database URL,
37:22 - so if not process dot env dot database underscore URL,
37:28 - we can just throw an error,
37:31 - a new error that says a DB database URL is not found.
37:36 - So if we have a database URL,
37:39 - then we can connect the SQL server using the neon function
37:43 - and we can connect it to our process dot env dot database URL.
37:47 - Okay, then underneath here, we can just do export cons DB.
37:52 - So this DB variable is what is going to be used
37:55 - to interact with our database.
37:57 - So we can call functions like select database URL
38:01 - select star from whatever table you want.
38:03 - So this DB will be calling drizzle.
38:06 - So this drizzle is imported, so import.
38:09 - So I'll just move it down here.
38:11 - So import from drizzle ORM slash neon HTTP.
38:19 - Okay, so we need to just import a drizzle function.
38:22 - So this drizzle is going to take in SQL
38:25 - and then we need a schema file.
38:26 - So we need a schema
38:27 - because the schema defines the shape of our database.
38:30 - So let me save this index.ts.
38:32 - Come down to your folder again.
38:34 - We need this DB file.
38:36 - Let's create a schema.ts.
38:39 - Okay, so this schema.ts is going to where our table definitions are going to go.
38:45 - Right.
38:45 - So the first thing is I'm going to import a few things from the drizzle ORM dash PG core.
38:52 - So PG core sends for Postgres core.
38:53 - So it's going to contain a lot of different utilities from Postgres database.
38:58 - So it contains things like integer or like a PG table.
39:02 - So we need a PG table function.
39:04 - And we also, let's actually create a, let's actually start creating the tables.
39:10 - So for the data model, right, we need, first thing we need is a chat.
39:14 - So a chat table, the chat table is going to contain this individual stuff.
39:20 - So if you go to chats, we can see that each chat is an individual row within the database.
39:25 - So when we go into chats, we can see that we have all these chats, right?
39:27 - 10 plus chats.
39:28 - Each chat is going to be one row within a database.
39:31 - So each chat will contain the name of the PDF, the URL to the PDF,
39:35 - the user ID related, whoever created the chat, and also whatever chats that is going to hold.
39:42 - So let's create that.
39:43 - So the first thing here is we can export cons, a chats, right?
39:47 - It's going to be a new PG table, a new Postgres table.
39:51 - It's going to have a chats, a name within the database itself, right?
39:55 - And then for the second function, the second parameter,
39:58 - here's where we can define the columns for this Postgres table.
40:01 - So this is just how the user ORM works.
40:03 - So we're going to have ID, right?
40:05 - This is going to be a serial.
40:07 - So we can import serial from a PG core, right?
40:10 - Make sure it's imported from PG core, right?
40:13 - We'll have a column name of ID and we'll make this a primary key.
40:17 - Okay.
40:18 - Then we'll have a PDF name, right?
40:20 - So this PDF name is what is shown here in the sidebar, right?
40:23 - This is going to be, let's put it as a text.
40:27 - So this text also comes from a PG core.
40:31 - It's going to be named PDF name and we'll set it as not now.
40:35 - So make sure that this name cannot be now.
40:38 - We have a PDF URL, which is also mapped to a text of PDF URL.
40:43 - And we make sure this is not now also.
40:44 - We have a creator add view, right?
40:46 - This is going to be a timestamp view from PG core itself.
40:50 - And we'll just make sure it is not now.
40:52 - And also we can default to now.
40:55 - So whenever we create, it's going to default this column to the timestamp now.
41:00 - Then lastly, we need a user ID view.
41:02 - So this user ID will be pointing to the clerk user ID.
41:06 - So let's just put it as var char.
41:09 - So this var char also from PG core.
41:11 - So let's name it as user ID.
41:13 - We can give you a length of let's say 256 characters
41:16 - and make sure that this is not now also.
41:18 - So lastly, we need a file key.
41:22 - A file key, which is going to be just a text view.
41:27 - And we'll name it file key and make sure it's not now.
41:29 - So this file key is for when we are retrieving the file from S3.
41:34 - So you can see that we have this PDF thing, right?
41:37 - So this PDF maps to a resource within the S3 bucket.
41:40 - So we can use this file key to actually ID the file within S3.
41:45 - So after we have checked, let's also create a messages.
41:48 - So we can see that each message,
41:51 - let's say I come down to our var cell docs.
41:55 - We can see that each message here will be saved to a database.
41:58 - So we can also create that table.
42:01 - So let's export a cons messages.
42:04 - It's going to be a Postgres table.
42:07 - Let's name it messages within the database.
42:09 - And then for the columns, we'll have an ID,
42:11 - which will be a serial of ID and the sentence primary key.
42:15 - Okay, then we have chat ID.
42:18 - So each message will belong to a chat.
42:20 - So this is how we form the one-to-many relations.
42:24 - So this is going to be an integer.
42:26 - So this is from pg-core itself.
42:29 - We'll name it chat ID.
42:31 - And then it's going to have dot references.
42:33 - So this is how we use the references variable within visual RM.
42:38 - So what is the reference?
42:39 - It's taking a callback function and it just returns the chat's ID.
42:43 - So this is how we make sure that this chat ID
42:46 - actually does a foreign key reference back to this chats.id.
42:51 - Okay, and make sure that it's not now also.
42:54 - And then we have a content.
42:55 - So this is a message content.
42:57 - Let's name it as text.
43:00 - Name it content and make sure that it's not now.
43:04 - Okay, then two more things.
43:07 - We need the created ad.
43:08 - So it's going to be the same up here.
43:10 - So it's going to be a timestamp, not now,
43:11 - and also defaults to the current timestamp.
43:13 - And lastly, we need a row.
43:15 - So this row can either be a user or a system.
43:19 - So we want to create a enum for that.
43:21 - So to create enum, we actually come up here and do export cons.
43:25 - User system enum.
43:29 - So this can be a pg enum from pg-core itself.
43:32 - Right?
43:33 - So we're going to name it user underscore system dash enum.
43:36 - So this is going to be the mapping within the database itself.
43:39 - And here we can pass in an array of what we want the enum to be.
43:42 - So this will log in the field,
43:44 - so that it can either be from a system or from the user.
43:47 - So if the row here is a system,
43:50 - that means that this message is being sent by GPT.
43:53 - If the row here is user, right?
43:55 - Then we know it's a user message.
43:56 - So we can just make this type more type safe
43:58 - by creating an enum within it.
44:00 - So for this row, you'll just be a user system enum.
44:04 - Name it row, right?
44:05 - And then we'll set it as not now.
44:07 - Okay. You can also set a default value, right?
44:10 - We can see that it gives us the intellisense to either system or user.
44:13 - Okay.
44:13 - So now that we have all this, we can just save the file.
44:17 - Okay.
44:18 - So now that we have saved the file,
44:19 - how do we actually make sure that this schema here is pushed up to the neon database, right?
44:25 - So for that, we actually need another tool from Drizzle.
44:28 - It's called Drizzle kit, right?
44:30 - So there's two things.
44:31 - There's two parts to Drizzle, right?
44:32 - There's the Drizzle ORM package itself.
44:35 - This Drizzle ORM is what is interacting with our database,
44:38 - but there's also a Drizzle kit, a package.
44:42 - This Drizzle kit provides us with utility functions to create migrations
44:45 - and to make sure that all our database is synced up with this schema here.
44:49 - Okay.
44:50 - So with that, let's actually install the Drizzle kit.
44:53 - So npm install drizzle-kit.
44:57 - So let's install that.
44:59 - So this Drizzle kit will allow us to push it up.
45:01 - So one more thing that we need is that in our folder here,
45:07 - in our root folder, let us actually create that.
45:11 - Actually, let's save this schema first.
45:13 - And then in our root folder, let's create a drizzle.config.ts.
45:20 - So this config.ts is going to hold the Drizzle configuration
45:23 - on how we want to tell Drizzle where our schema file lives in.
45:27 - So the first thing here is, let's import a type called from Drizzle kit itself.
45:34 - So this type will import as config.
45:36 - So it gives us some type annotations for the configuration object.
45:39 - Okay.
45:40 - Okay.
45:40 - Then after here, we need to export a default configuration object.
45:46 - And we can see that satisfy config, right?
45:49 - So this object makes sure that it will satisfy config.
45:53 - And if we press control space, we get all these different type annotations
45:58 - as to what configurations are available.
46:00 - So the first thing we need is the driver.
46:02 - The driver is going to be PG Postgres, right?
46:06 - The second thing here is we need the schema.
46:09 - So this variable will tell this Drizzle kit where the schema actually lives in.
46:15 - So that whenever we push our schema, right?
46:17 - So eventually we can run a command within our terminal called mpx Drizzle-kit-push-pg.
46:25 - So this will take a look at our schema and then make sure that our database
46:28 - in neon is synced up with our schema.
46:30 - So to tell it the schema, let us actually do the slash source.
46:34 - So it's taking from the current path itself.
46:36 - So it's going to go into our source folder, come to the source folder,
46:40 - come to our lib folder into db to schema.ts.
46:43 - So make sure that whatever file here matches your file structure.
46:48 - So it will be under slash source lib slash db slash schema dot ts.
46:54 - And then lastly, we need the db credentials.
46:57 - We need these db credentials, right?
46:59 - We have a connection screen, a connection string,
47:02 - and this one we want to get it from process.env dot database URL.
47:06 - Okay, so Next.js actually doesn't provide this env here right now
47:11 - because right now, I want to observe that you see inside this source,
47:16 - all the files within this source folder will have access to the env variable.
47:20 - However, any files that's outside this source folder
47:23 - will not have access to the process.env database URL that's defined within.env, right?
47:29 - So to actually load this.env, we actually need to install our package called npm install.env.
47:35 - So with this.env package, we can load the env file into our process.env.
47:40 - So let's just import star as.env from.env.
47:45 - Then we'll call.env.config, right?
47:49 - We'll pass the path to be.env.
47:52 - So busy what this does is you will look at this.env file
47:55 - that lives in the same directory here.
47:57 - So you can see.env.
47:58 - It's going to load all these variables, including this process.database URL.
48:02 - It's going to load it into this file,
48:04 - and then we can access this process.env.database URL.
48:08 - So now that we have completed everything,
48:09 - let's save it.
48:11 - Okay, now we can actually do the pushing of the schema up to the neon database.
48:16 - So I'm going to do, just do mpx drizzle-kit,
48:21 - drizzle-kit.
48:22 - We can do push and then specify your database.
48:26 - So bpg send for Postgres.
48:28 - So let's press enter and hopefully this will read in our,
48:31 - you see it's able to read in our drizzle config.ts, right?
48:35 - And it's going to try to push.
48:37 - So one more thing I forgot.
48:38 - We actually need to come into our TS config, right?
48:42 - Sorry.
48:43 - So we need to come into our TS config.
48:46 - So we see this target.
48:47 - Instead of ES5, we have to move it to ES6 instead.
48:51 - So let's save it.
48:53 - And with that, let's actually try again.
48:54 - So let me just drizzle-kit push and now we can see changes applied.
48:59 - So while it's saying that it has actually pushed our tables,
49:02 - so it has run our commands at create table
49:04 - and it has pushed it up to our neon.
49:06 - So to make sure that it has worked, right,
49:08 - I can actually come out to the terminal
49:11 - and I can do mpx drizzle-kit studio.
49:15 - So this will open up in a studio itself.
49:17 - So pg is not imported.
49:20 - So we need to install this pg package also.
49:23 - So npm install pg.
49:26 - So this drizzle-kit studio will open up
49:28 - a in browser database client for you.
49:31 - So let's try again.
49:32 - So let's open the studio.
49:33 - And now we can see that the studio is up and running on this port.
49:38 - So let's open this port.
49:39 - Okay, let's open it here.
49:41 - Open in our browser.
49:43 - And we can see that it has a nice interface
49:47 - for us to interact with our user models.
49:49 - So if you come down here,
49:50 - we can see that the chats and messages table has been created.
49:53 - So these chats and messages,
49:54 - we can see that the schema, this chat ID content created at
49:57 - is coming from our schema.ts.
50:00 - So we have made sure that all our schema
50:02 - has been properly migrated up to the neon database.
50:05 - So that's perfect.
50:05 - Yes, everything's up and running and we are good to go.
50:09 - So let me just close this drizzle studio
50:11 - and then we can continue working on the other parts.
50:15 - Okay, so that's excellent.
50:17 - So now that we have set up drizzle in our database,
50:19 - let's actually create the file upload component that we see here.
50:23 - This drop PDF function here.
50:25 - So I'm going to explain it a little bit here.
50:27 - Let me just collapse our terminal, clear up everything.
50:29 - So let's actually create a new component,
50:33 - come down to our components.
50:36 - Let's create a new component called file upload.tsx.
50:42 - So this is going to house our file upload component.
50:45 - So I'm going to initialize it by doing TSRAFCE.
50:50 - So this snippet is from extension.
50:55 - So let me search out the extension.
50:56 - I think it's called ES7, EN7 snippets or something, ES7 React Snippets.
51:04 - ES7 React Redux Snippets.
51:06 - So this snippet give us the ability to just type in TSRAFCE
51:11 - and generate the React component for us.
51:14 - Okay, so for this file upload here,
51:17 - isn't it not going to take in any props, right?
51:21 - And this is going to be a client component.
51:23 - So let's put this use client.
51:25 - So if you're not sure,
51:27 - so this for any component that requires interactivity,
51:30 - like unclick function on a button,
51:32 - or let's say you're trying to drag in a file
51:34 - that basically renders on the client
51:36 - and then it requires use state.
51:39 - So let's say if you're using a component
51:42 - that requires the use state function from React,
51:46 - then we have to convert this into a client component.
51:49 - So that this component will be rendered on the client.
51:52 - So to actually create this styling,
51:53 - so we need to install a library called npm install react dropzone.
52:01 - So this will create that file upload drop utility for us.
52:07 - So with that dropzone installed, let's actually import it.
52:10 - So import use dropzone from react-dropzone.
52:19 - Okay, so let's actually create a styling for this, right?
52:22 - So for this, I'm going to just return a normal div
52:26 - with a class name of padding of two,
52:29 - background of white and rounded-xl.
52:31 - So let me save it first
52:32 - and let's actually import the component into our page.
52:36 - So come back to app.tsx.
52:38 - So whenever we see this file upload,
52:40 - I'm just going to import the file upload, sorry,
52:43 - upload file, is it file upload?
52:46 - Okay, it's file upload, so import it from our components.
52:50 - So let's save it
52:51 - and now we can see that we have a component that's showing up here.
52:53 - So right now it's this bgwhite that is showing.
52:56 - So within this div, let's actually install it properly.
52:59 - Okay, so we'll have another div.
53:03 - Within this div, we can actually store our file input.
53:07 - So we'll have an input variable here, input component.
53:11 - And then actually let us also destructor a few things
53:14 - from the react-dropzone so that we can properly style it.
53:17 - So we actually need to destructor a few things
53:20 - from use-dropzone itself by calling it.
53:22 - So why is it going to return?
53:24 - It's going to return us with two things,
53:26 - get-root-props and also get-input-props.
53:28 - So these two props, we have to pass into our input field
53:32 - and also our div field such that you have the proper props
53:35 - to handle the file upload.
53:38 - Okay, so within this inner div,
53:42 - so we have this inner div,
53:43 - let's pass in the dot dot dot, get-root-props,
53:47 - just invoke it.
53:48 - And for this input, we assume you pass in dot dot dot,
53:51 - get-input-props, invoke it, and save it.
53:55 - So right now it doesn't show up yet,
53:57 - but let me try pressing on it.
54:00 - Okay, it doesn't show up.
54:01 - So for this div, for this get-root-props,
54:03 - let's pass in an object.
54:05 - We can pass in more attributes.
54:07 - Let's say class name.
54:08 - So we can properly style this div properly.
54:11 - So let's give you a border of a dash.
54:14 - So it has the dash border look, border dash two,
54:17 - rounded XL, cursor, pointer.
54:21 - That's why we hover over it, right?
54:22 - bg agree of 50, padding one of eight.
54:27 - Let's give you a flex, justify center, items, items dash center.
54:35 - And then let's give you a flex call.
54:40 - So let's save it.
54:41 - And now we have this nice input box here.
54:43 - So when we hover over it, you can see it turns our cursor
54:46 - out, our cursor into this cursor pointer.
54:49 - And if you click on it by right,
54:51 - by right it should show this input view.
54:52 - Okay, so it opens up our file explorer, which is good.
54:55 - Okay, so then underneath the input here,
54:58 - we want to show a thing here.
55:02 - So let us create a fragment and let us upload a inbox.
55:07 - So this inbox icon from Lucid React,
55:10 - let's give you a style of width of 10, height of 10, text blue of 500.
55:15 - Text blue of 500, and below the inbox,
55:18 - let's just have a paragraph tag that says drop PDF here.
55:23 - Let's give you a class name of margin top of two,
55:27 - text of small and text dash late dash 400.
55:31 - So if we save it, now we got this drop PDF here showing up properly.
55:34 - Okay, so that's good, that's good.
55:37 - So now let us actually add the file upload feature.
55:42 - So for this use drop zone,
55:44 - for this use drop zone, right,
55:46 - we can pass in an object.
55:47 - So we can pass in some parameters we need to tell how to behave.
55:51 - So we can accept.
55:52 - So we're asking what type of files do you want to accept from the users?
55:55 - Right, so it's going to accept an application slash PDF.
56:00 - Right, it's going to accept an array, which is only says p dot PDF.
56:04 - So this is the syntax to make sure that users can only upload dot PDF files.
56:09 - Okay, and then we're going to pass in max files of one.
56:13 - So they can only upload one file, one file, a maximum.
56:16 - And then we can pass in a callback, right?
56:18 - So we can pass in a on drop.
56:20 - So whenever they drop a file or when they pass in a file,
56:23 - we can actually get the accepted files.
56:27 - And let us for now, let's just console dot lock accepted files.
56:32 - So let me save it.
56:33 - So let me open, just expand it a little bit bigger.
56:36 - So I'm going to open up my console here.
56:38 - Right, so open up my console.
56:39 - So let me just clear that out.
56:41 - So let's say now we drop, press drop PDF.
56:44 - And let's drop, so you can see that only PDF files are allowed.
56:47 - So I'm going to edit this.
56:49 - And whenever we drop it, we can see now that we have this array of files.
56:52 - So this is what the accepted files, a variable shows.
56:55 - So it's going to be an array of files.
56:57 - So the file that we want is living in the first index
56:59 - and just contains all the information like the name, the path, the size of it,
57:04 - and so the type.
57:05 - So later we'll be using this file object to upload this file onto our AWS S3.
57:12 - All right, so now that we have the files set up,
57:15 - let's actually upload it to AWS S3.
57:18 - So to set up the AWS S3 account, come to your, just search AWS, right?
57:23 - And then just go into Amazon web service, right?
57:26 - So cloud computing service and you want to create an account
57:29 - and log into the console dashboard.
57:31 - So just press sign in the console or sign up for the console if you haven't.
57:34 - So you can sign up with email, right?
57:37 - So after you have signed in, you have to log in as a root user
57:40 - and you come back to the console home.
57:42 - So come down to the search bar and just search for S3.
57:45 - So S3 stands for simple storage service.
57:47 - So SSS S3.
57:49 - So click into it.
57:51 - And what we want to do is create a new bucket.
57:53 - Okay, so come down here and just press create bucket.
57:55 - So for the bucket name, just name it whatever you want,
57:57 - but it has to be unique globally.
57:59 - So let's just name it chatpgf-youtube.
58:03 - Okay, the region, choose one that is closest to you
58:08 - and make sure you remember which region you chose.
58:10 - So for me, I'm going to choose Singapore here, AP South is one.
58:14 - So remember this AP South is one.
58:17 - And then object ownership, just choose ACS, ACL disabled.
58:25 - Come down to choose, uncheck this.
58:29 - So we don't want to block all public access.
58:31 - So uncheck it and come down here, just acknowledge.
58:35 - Bucket version name just disabled
58:37 - and then everything else can be disabled.
58:41 - Yeah, so advanced setting just leave it as blank, as default.
58:45 - And so everything just leave it as default.
58:47 - So now it successfully created a bucket.
58:49 - So for now, we still need to change something.
58:52 - So we need to actually make all the objects to be public.
58:55 - So come to chatpgf-youtube, permissions, not probabilities,
58:59 - permissions, block public access.
59:02 - So right now it's off, right?
59:04 - Under this bucket policy, I need to press edit.
59:07 - So this is a JSON configuration to make sure that,
59:11 - is to tell people who can access the files that start in this bucket.
59:15 - All right, so for this policy,
59:17 - you want to make sure that everyone can edit, not edit,
59:20 - but everyone can access this.
59:22 - So just set up an object in here.
59:24 - So they'll have a version,
59:26 - right, this version will be 2012-10-17, okay?
59:32 - And then for the statesman, statesman, right?
59:38 - This will be an array, right?
59:40 - And the first item in the array will be another object, right?
59:44 - So this object will have SID of public read get object.
59:51 - Okay, then you have an effect of allow.
59:56 - They have a principle of star.
60:01 - And then we have an action of S3, get object.
60:07 - So make sure you got the spelling and all the capitalization all correct.
60:10 - And lastly, we have this resource.
60:12 - This resource will have ARN colon EWS.
60:20 - ARN colon S3, then three colons.
60:23 - Then you have to enter the name of your bucket.
60:26 - So this is chat.pdf-youtube slash star.
60:29 - Okay, so with that, make sure that everything looks correct.
60:34 - So this has to be resource.
60:36 - Okay, so after you have saved that,
60:38 - just come down here, scroll down and press save changes.
60:42 - Okay, so now our bucket policy has been updated.
60:45 - So we have a bucket policy.
60:47 - Come down to course.
60:48 - So this course object is important
60:50 - so that we can actually upload files from our local host
60:53 - or from our vessel URL.
60:57 - So this course, we have to go and edit it.
60:59 - And so this another JSON object to tell EWS
61:03 - who can actually upload files.
61:04 - So this is going to be an array actually.
61:07 - So it's going to be an array.
61:08 - We need the first item in the array, right?
61:11 - Let us put in allowed headers.
61:16 - This is going to be an array.
61:17 - And let's put star.
61:19 - So we can allow all the headers.
61:21 - Then we need the allowed methods
61:26 - to be an array of put, post, delete, and lastly get.
61:35 - Okay, so let's style this properly.
61:39 - And then under the allowed methods, we need allowed origins.
61:43 - So this is to make sure that we can allow different URLs
61:46 - to upload to the EWS S3.
61:48 - So let's put star so that all the URLs is able to upload.
61:51 - And then we have lastly expose headers.
61:56 - Just leave it as an empty array.
61:57 - So this to make sure that, okay, so this get has this code.
62:03 - So after saving this, let's press Save Changes.
62:07 - So this course is important
62:08 - so that we can properly allow our website
62:11 - to actually upload files to EWS S3.
62:16 - Okay, so now if we come back to our buckets, okay.
62:19 - So now that we have set up EWS S3,
62:21 - let's actually create a function
62:23 - that accepts the local file input and uploads to S3 itself.
62:28 - Okay, so let me expand this back up here.
62:31 - So come down to your folder and let's create, under your lib,
62:34 - let's create a new S3.ts.
62:37 - So this S3.ts is going to contain the function
62:40 - to actually load in the S3 configuration, all right?
62:44 - So first we need to install the actual S3 package.
62:47 - So for that will be NPM install EWS SDK.
62:51 - So we make sure that we can interact with the EWS S3 buckets.
62:55 - So import EWS from EWS SDK, okay.
63:02 - Then we want to actually just initialize the S3 bucket, right?
63:09 - To initialize S3 function itself.
63:13 - So let's export async function, call upload to S3.
63:22 - Okay, so this upload actually will accept a file of this file input.
63:25 - So this is a standard web API file type, right?
63:29 - So we can accept this file.
63:31 - So later we pass in this file.
63:33 - So right now if you come to file upload,
63:35 - we can see that this accept files is an array of file.
63:38 - So we eventually call this upload to S3
63:41 - on this accepted file's input, okay.
63:45 - So what we're going to do is we're going to put it in the try catch block, okay.
63:49 - So first we can initialize AWS.config.update, right?
63:55 - We need to pass in two things.
63:56 - We need to access key id, access.
63:59 - For the update we need to access key id, right?
64:02 - And also we need a secret access key, right?
64:12 - So how do we actually get this AWS secret access key and access key id?
64:16 - So come back to your S3 console, right?
64:20 - Come back to your console, right?
64:21 - Come up to services, right?
64:24 - You need to search for something called IAM.
64:26 - So this stands for Identity and Access Management.
64:30 - So come under the IAM service.
64:32 - So this is separate from S3 service that we have export within the AWS console.
64:36 - All right.
64:37 - So come down to the IAM console.
64:39 - Now we need to add a new user.
64:42 - So this user is going to give us that access to actually access the S3 bucket.
64:46 - So then we can create a key pair for this user
64:49 - and the key pair will be what is used for this access key id and secret access key, all right.
64:53 - So come to the sidebar and click on users, right?
64:56 - Right now we can see that we can create a new user.
64:59 - So just press create user
65:01 - and name it whatever you want.
65:02 - You can just chat bdf-youtube-s3, right?
65:06 - So this user will be able to access the S3 bucket, right?
65:09 - So we don't want to provide user access
65:11 - because we are just trying to provide the console access to a,
65:15 - just to get the key value.
65:16 - We're not trying to give the access to a person.
65:18 - So uncheck it, then press on next.
65:21 - Then just have to attach policies directly.
65:23 - So search for S3 and basically want to give it Amazon S3 full access, right?
65:29 - Amazon actually full access.
65:31 - So check on that box.
65:33 - Then lastly, just press next.
65:35 - Okay, so now that we have granted the full access, we can create the user.
65:40 - So after created the user, come into the user itself
65:44 - and now we can access the key pairs.
65:47 - So come down to our security credentials
65:52 - and let us actually do access key.
65:54 - So create access key.
65:56 - So I want you to choose your,
65:58 - just choose local code for the use case, right?
66:01 - And then press understand the confirmation and press next.
66:05 - So then you can just give a description tag if you want.
66:07 - In case you can just leave it blank and create access keys.
66:11 - So right now we can see that we can just press show.
66:13 - So these are two things are what is needed for the S3 access key ID.
66:18 - So come down to your.env.
66:20 - Let's actually paste it in.
66:21 - So we'll create a new section called AWS S3.
66:25 - Okay, so we need the AWS S3. Let us do next public.
66:33 - Next public AWS S3.
66:36 - Sorry, we just put AWS, just name it over one.
66:38 - Next public S3 access key ID.
66:44 - So I'm gonna paste in this access key ID here.
66:47 - Okay, and then for the next line, let's name it next underscore public underscore S3
66:54 - underscore secret access key.
66:58 - Right, then paste it in here.
67:01 - So the reason why it has to be prefaced with next public
67:04 - is because we'll be accessing these environment variables from our client.
67:07 - Right, because when we drop the PDF,
67:09 - we'll be uploading the PDF directly from the next S3 up to S3.
67:14 - Therefore, we need these two variables to be public to our client component.
67:19 - And so after we have done that, we can just come back to our code here.
67:25 - So save the env.
67:27 - And so we need these two variables, right?
67:28 - So just copy these two variables and make sure that you paste it in correctly.
67:32 - So for the access key ID, make sure it's next public S3 access key ID.
67:36 - And for the secret access key, let's copy this in here also.
67:40 - So then paste it here.
67:42 - So this is a secret access key.
67:43 - So make sure the variables match and make sure you have it
67:45 - properly configured within the.env.
67:49 - So let's save it.
67:51 - So after configuring the aws object, now we can actually get the S3 object.
67:55 - So const S3 equals to new aws new aws.s3.
68:03 - Okay, and then under here, we can actually pass in this params object.
68:08 - These params allow us to configure our bucket.
68:10 - Right, so remember the bucket name that we have created?
68:12 - We can just store this in a variable itself.
68:15 - So let me just copy this and let us create a new env variable.
68:19 - So next, public S3 bucket, bucket name.
68:27 - So just name it as whatever you have created in the S3 console.
68:31 - In this case, it would be, for me, it's chat.spdf-youtube, right?
68:34 - So let me save that.
68:36 - Then in here, I can just access it.
68:38 - So next public S3 bucket name, make sure that it matches.
68:41 - So I'll copy it just in case.
68:43 - Okay, so after configuring the params,
68:46 - you need to pass in, under the params, pass in the region, right?
68:50 - So this region, for me, is ap-southeast-1.
68:54 - So remember the region that you created the bucket in.
68:57 - So just put it in here, this region configuration.
69:00 - Okay, now lastly, we want to define, we can actually upload it.
69:05 - So we can do cons upload equals to S3 dot puts object.
69:12 - Okay, this put object take in a params.
69:15 - So let's actually define the params here.
69:17 - Cons params is going to be an object of the bucket.
69:21 - So the bucket will be the S3 bucket name.
69:24 - And then we need the key.
69:26 - So this key will be the name of the file.
69:29 - So this key will be uniquely identified,
69:32 - fireable to the file, right?
69:34 - So we have this file key here.
69:36 - And then lastly, we have a body, right?
69:38 - With this actual file that is passed into this function.
69:42 - So for this key variable, let's actually create a file key variable, right?
69:46 - So that let's name it uploads slash plus dates dot now dot to string.
69:54 - So this to make sure that the file key is uniquely ID.
70:00 - Lastly, we'll do file dot name dot replace, replaced a space with an empty with a hyphen.
70:08 - So this file key, basically we want to upload to an uploads folder within AWS S3.
70:13 - So we can organize it properly.
70:15 - And then we just want to append the date dot now to make sure that it's properly ID,
70:19 - uniquely identified.
70:21 - And then we'll just replace the file name.
70:23 - If there's any blank space, we just replace it with a hyphen.
70:26 - And then this file key we can use instead of this file name directly.
70:30 - So just put in the file key.
70:32 - Okay, that's perfect.
70:34 - So now we can actually upload these params, right?
70:37 - So after these params, we can do dot.
70:41 - So right now these params is complaining because the bucket could be undefined.
70:45 - So we are ensured that this exists.
70:47 - So we'll just put a bang.
70:49 - So to reassure that AWS S3 that the bucket name will actually be defined.
70:53 - Okay, so then after we put objects with the params, let's do on.
70:57 - We can do a HTTP upload progress, right?
71:03 - Then we can access a event.
71:05 - So whenever as it's uploading, let's say it's a big cloud.
71:09 - Let's say you're uploading like 10 megabytes of PDF, right?
71:12 - As it is uploading, uploaded to AWS S3, this callback function will be called.
71:17 - And then you're able to monitor the process and it's able to give us back like the progress.
71:21 - Then you're able to create a UI to create a progress bar
71:25 - to show that the file is being uploaded to S3.
71:28 - So for now, let's just do console.log uploading to S3, dot, dot, dot.
71:35 - And let us just do parse int.
71:39 - So we can actually get a progress by doing, let's just do events.loaded, right?
71:47 - Divided event.loaded times 100, divided by events.total, right?
71:54 - And then this parse int, we can actually call the,
71:55 - dot, sorry, call the dot, dot to string, sorry, dot to string.
72:05 - Sorry, this should be here.
72:07 - Okay, so we basically, let me save this file so that it's easier to see.
72:11 - So we'll take the env.loaded times 100% so that we can get it in terms of the percentage
72:17 - divided by the total file size.
72:20 - We'll convert it to to string so that we can properly parse it as an integer.
72:24 - So we don't want to have floats.
72:25 - Then lastly, we can just show the percentage sign.
72:28 - So we console.log out this entire percentage string.
72:32 - We can see in the console later on.
72:34 - Then finally, after this upload, let's just do dot promise, right?
72:38 - So we can actually just convert it to a promise and we can just do,
72:42 - this promise will allow us to convert this whole upload process into a promise.
72:47 - Then we can just do await upload dot then.
72:51 - So we can just take the data.
72:54 - So this callback function will be called whenever the upload is completed.
72:58 - So when it's completed, we're just going to just say console.log success,
73:05 - success, fully uploaded to S3, exclamation mark.
73:14 - And there's also console.log out the file key itself.
73:19 - Then we can just do, after that, we can just do,
73:23 - all right, then finally, under this await, we can just return promise dot resolve.
73:28 - So we want to resolve this promise, right?
73:30 - Because this is the async function, right?
73:31 - So after we've uploaded, we resolve the promise.
73:34 - And we just want to return two things.
73:36 - We want to return the actual file key itself and return the file name,
73:40 - which is file dot name.
73:41 - So make sure we return the file key and file name.
73:43 - So we'll be using these two parameters to save it to our database later.
73:47 - So let's save this function, okay?
73:49 - And let's come down here and let's create one more utility function.
73:52 - So this is the last function that's going to be created in this file.
73:55 - So we're going to export function, get S3 URL.
73:59 - So this function is going to take in a file key of string
74:02 - and basically return us with a publicly accessible S3 URL
74:06 - so that we're able to embed the PDF within our chat screen later.
74:10 - So just do cons URL equals to https colon slash slash, right?
74:17 - Put in your process dot env dot next underscore public underscore S3 bucket name, right?
74:29 - And then here we can just do dot S3 dot ap south east one dot amazon aws dot com slash file key.
74:43 - So that's actually a special formatting for the AWS.
74:46 - So the AWS will always live on the bucket name dot S3 dot region.
74:52 - So this is what your AWS region is.
74:54 - So it might be different from mine.
74:55 - And then it will be lived at Amazon AWS
74:58 - and you're able to access it to the file key here.
75:01 - And then we just want to return this URL.
75:04 - So this is a utility function so that we can actually access the S3 URL
75:08 - just from the file key itself.
75:10 - Remember this file key is actually created here at this line here.
75:14 - So now that we save it, let's actually try it out.
75:17 - So come back to your file upload component, right?
75:21 - So whenever we actually, we don't do just console dot log, right?
75:26 - We actually want to upload to S3 itself.
75:28 - So to actually create a function, let us just get the file.
75:31 - So cons file equals to accepted files index zero.
75:37 - Okay, I'm gonna take the first file and then we can just first check.
75:40 - So if file dot size is bigger than 10 times 1024 times 1024.
75:48 - So if this is bigger than 10 megabytes, we don't need to upload to S3, right?
75:53 - This is bigger than 10 MB.
75:56 - So let's just, let's just show an error.
75:59 - So let's just alert, please upload a smaller file than this return.
76:07 - Okay, but if it is smaller than 10 MB,
76:10 - then let's actually create and upload the Amazon S3 file.
76:14 - So let's do cons data equals to await upload to S3.
76:22 - So we import it from our lib.
76:24 - So because we're using await, let's actually also convert it into an async function.
76:29 - Okay, async function.
76:32 - Although, await upload to S3, I will pass in the file, right?
76:35 - So this file comes from the accepted files,
76:37 - and then you will pass into our upload file function that we've created in S3.ts.
76:43 - And then this data, we can see that it will return us with the file key and the file name.
76:47 - Okay, so this is if it works, right?
76:49 - If it doesn't work, right, let's actually put it into a try catch block.
76:54 - So if there's any error, let's just do console.lock error.
77:00 - Okay, so await upload to S3, and then let's just do console.lock data.
77:09 - So let's try it out.
77:10 - So I'm going to save it.
77:11 - Okay, now I'll move the console here.
77:14 - And let's actually try uploading, okay?
77:16 - So I'm going to open up my console within it.
77:18 - Sorry, it's not that very responsive, but it's okay.
77:20 - Just for this video, you'll be fine.
77:22 - So let me just drop a PDF here.
77:25 - So let me just, so let's say we upload these eight runtime docs.
77:29 - If I press on it, we can see that uploading to S3, 100%.
77:33 - So it says that successfully uploaded to S3 and we get back the file key.
77:37 - So we can see the file key is created by having this uploads folder
77:40 - and then the random time followed by the actual name of the file.pdf, right?
77:46 - And we get the file name also.
77:48 - So if you come back to our S3, so come back to your S3 bucket within AWS console, right?
77:55 - Access your chat.pdf-youtube bucket.
77:58 - We're able to see now that this is uploads folder created.
78:01 - And we can see the PDF that is being accessed here, right?
78:05 - So we can see that now the function works and we are able to successfully upload files
78:09 - onto AWS S3.
78:11 - So that's excellent.
78:12 - Okay, so now that we have gotten to a decent point within the project,
78:16 - now I want to explain to you what exactly is retrieval augmented generation
78:19 - and how we can actually get the PDF to be fed into a chat.gbt
78:24 - so that it's able to give us that result such that chat.gbt is able to chat with us
78:28 - with the context of the document, right?
78:31 - So the first thing you have to understand here is two things.
78:35 - One is what is a vector and embeddings, okay?
78:40 - So a vector is just an array of numbers, right?
78:43 - A vector is just like an arrow, right?
78:45 - So a vector is an arrow.
78:47 - So in this case, this arrow is a two-dimensional vector,
78:50 - meaning that it has an x-coordinate and a y-coordinate.
78:54 - So here we can see that this x-coordinate is the length here
78:57 - and the y-coordinate is the height, right?
78:59 - So in this case, this vector can be actually represented
79:02 - as an array of let's say two numbers of let's say one and two.
79:06 - So one being the width and two being the height.
79:09 - So in the case just for proportion, this looks more like two and one.
79:12 - So it will have a length of two and a height of one.
79:15 - So this vector can be represented in an array of two and one.
79:20 - But what if we have a vector of three dimension?
79:23 - Imagine you have an arrow that's pointing out towards me.
79:25 - I mean, obviously, because we are on the screen, we can represent that.
79:28 - But to represent a 3D vector, we can just have three dimensions, right?
79:32 - x, y, and z components.
79:34 - So maybe it can be one, two, and four, right?
79:36 - So this will be the x component, this two is the y component,
79:40 - and this four is the z component, which means how much is pointing towards me,
79:43 - towards the screen, right?
79:45 - So this is what vectors are, right?
79:48 - So why is this vector important?
79:50 - So embeddings are very similar to vectors, right?
79:52 - So how this is going to work is we have a function.
79:56 - So this function is able to take in a piece of text, a piece of string, right?
80:01 - So let's say we have a string of I like cats, all right?
80:05 - And let's say we take in another string here.
80:07 - Let's say I say cats are the feline species.
80:13 - And then lastly, I have another text that says dogs are upper zits of cats, all right?
80:23 - We can see that all these three texts, all three strings are kind of similar
80:27 - in the sense that they're all talking about related to cats.
80:30 - But how do we actually properly define which text are most similar to each other?
80:34 - So this is where the function comes in.
80:36 - There's actually a function within AI
80:38 - that allows you to convert this piece of text into a vector, right?
80:43 - Meaning that we have a function, let's call it get embeddings, right?
80:47 - This will take in a text, a piece of string.
80:50 - And the input of this string, and it will output lists an array of vectors.
80:56 - So this array is going to be like a multi-dimension vector.
81:01 - So it's a vector in the dimension of let's say up to thousands of dimensions.
81:06 - So it's not just one, two dimensions, or even three dimensions.
81:09 - It could be a vector in 1,536 dimensions, right?
81:13 - So the bigger the dimension, the more information it can actually represent, right?
81:18 - So this vector, so let's just take, for example, this I like cats.
81:22 - Let's say that this embedding creates a vector of this direction, right?
81:28 - Just for the sake of argument, right?
81:30 - So this I like cats, right?
81:31 - So if we embedd it, we get a vector of this shape, right?
81:35 - So the vector will actually represent the semantic meaning of the sentence itself, right?
81:40 - So that's what is amazing about it.
81:42 - So if you take the second sentence and we embed it, so we convert it into a vector,
81:46 - maybe this function will return us with a vector of this one.
81:50 - We can see that it's kind of similar because it's pointing in the direction,
81:53 - it's a similar direction.
81:55 - And then let's say if we look at this, dogs are composed of cats.
81:58 - Obviously, this is a little more different, right?
82:00 - So actually, maybe a better example will be, let's say we talk about
82:03 - our React is a JS framework, right?
82:08 - So if you embed this string into a vector, it might look something like this, right?
82:14 - So we can see that the direction of the arrow or the vector
82:17 - is actually dependent on the meaning of the actual sentence, right?
82:21 - So how they actually create the embedding will be using
82:24 - opening eye to create those embeddings for us.
82:27 - So why is this useful?
82:29 - Now that we have these vectors, what we can do is,
82:31 - let's say now I'm trying to ask a question.
82:33 - So I'm going to ask a question regarding like, what are cats, right?
82:39 - I'm going to basically create this vector.
82:40 - I'm going to create this query.
82:42 - So this is going to be a query itself.
82:44 - I'm going to create this query into a vector in itself.
82:47 - So maybe this vector will turn out something like this
82:50 - because it's similar to the cats, right?
82:52 - It has the semantic similarity to cats, right?
82:56 - So it will obviously be very similar to these two vectors.
82:58 - Then using mathematical notation, using math,
83:01 - we can actually find the cosine distance, right?
83:07 - So this cosine similarity, we can see is a measure of similarity
83:10 - between two nonzero vectors defined in their product space,
83:14 - meaning that there's actually a method to find how similar two vectors are.
83:18 - So if we actually basically look through all the vectors
83:20 - and find out which one is the most similar.
83:22 - In this case, the most similar vector will be this second sentence.
83:26 - So using pure mathematics and vectors,
83:28 - we're able to get this piece of text
83:31 - and see that this text will obviously
83:34 - will most likely contain the answer to my query
83:37 - just by how similar their vector representations are.
83:40 - So with this vector that is after we found the most similar vector,
83:45 - we can actually convert this vector back into the text, right?
83:49 - So we store this text in the metadata of this vector, right?
83:52 - So this vector will contain a few things.
83:56 - It will contain the embedding, right?
83:59 - It's going to be an array of numbers, right?
84:01 - So however dimension this is, might be in the thousands.
84:04 - And it also contains a metadata.
84:06 - So this metadata will contain the actual text content, right?
84:09 - This text content will be whatever you have here.
84:12 - I like cats.
84:13 - Cats.
84:14 - Let me just save it here.
84:16 - So I hope that this makes a little sense, right?
84:19 - What we are trying to do here.
84:21 - So we can see that each vector contains the embeddings itself,
84:24 - which is the array of numbers.
84:25 - And it can also contain metadata.
84:27 - So after we have found the most similar vector,
84:30 - we can extract out the text content.
84:32 - And then with this text content,
84:33 - we can actually fit the content into OpenAI
84:37 - so that it's able to generate context for us.
84:39 - So let's see how this ties into the PDF,
84:41 - a function that I'm talking about.
84:44 - So let me just explain this so that we have a more space
84:46 - to explain how this embedding works.
84:48 - All right.
84:49 - So imagine you have a PDF here, right?
84:51 - So let me just expand this a little bit bigger
84:54 - so that you will see.
84:55 - So let me just expand it more.
84:58 - Okay.
84:58 - Imagine you have this PDF.
84:59 - It's going to be a page.
85:00 - So there could be multiple pages to the PDF, right?
85:03 - So let's just take, for example,
85:04 - we have a single page,
85:05 - and there may be a paragraph, multiple paragraphs.
85:08 - So let me just align it to the top,
85:10 - and let's start typing.
85:11 - So imagine we have this one paragraph,
85:13 - then we have another paragraph, right?
85:15 - Then lastly, we have the last paragraph that is a bit longer.
85:19 - Okay.
85:19 - So within this page, we have these three paragraphs.
85:22 - So what the vector embedding is going to do is,
85:24 - what our backend is going to do is,
85:26 - we're going to take each page within the document.
85:29 - We're going to segment it into internal documents.
85:33 - So when we talk about documents right now,
85:34 - we're not talking about PDF documents.
85:36 - We're talking about a segment of the PDF, right?
85:39 - So this paragraph could be one document by itself.
85:42 - This paragraph could be another document by itself,
85:44 - and this paragraph might be another document.
85:47 - So we're splitting the PDF into small chunks of documents.
85:51 - So each chunk will contain maybe like two or three sentences, one paragraph, right?
85:56 - So now that we have segmented into a few documents,
85:59 - so let me just press it out here.
86:01 - Document, doc1, doc2, doc3.
86:06 - So we're going to take in the PDF,
86:07 - we're going to segment it into a lot of documents.
86:09 - So each document will contain like the metadata,
86:13 - so it could be the page content itself, right?
86:15 - So this page content will be whatever this paragraph shows, right?
86:20 - Then what we're going to do is,
86:21 - the second step is to convert each document here into a vector.
86:25 - So remember, we have a function in OpenAI
86:27 - that allows us to take a document and convert it into a vector itself.
86:32 - So this will then become a vector.
86:34 - So it's going to be a vector embedding.
86:38 - So now that we have converted all our docs,
86:41 - so there could be maybe 20, 30 documents within one PDF,
86:44 - depends on how we segment it.
86:46 - So then we have 20 vector embeddings here.
86:49 - Then what we're going to do with these vector embeddings
86:51 - is we're going to store all these individual vectors
86:54 - into a vector database.
86:56 - And that's exactly where PineconeDB comes in.
86:59 - So PineconeDB is a vector database
87:01 - exactly for long-term memory for AI, you see?
87:05 - So this is what PineconeDB is for,
87:07 - is to store vector embeddings.
87:08 - So all of this will then go inside of PineconeDB.
87:14 - So that's it.
87:16 - So what happens now when we actually want to do this?
87:18 - When we actually want to search for, when we type in the chatbot,
87:21 - how does he actually get access to the document?
87:24 - So imagine now I come back to my interface
87:26 - and I search for, let's say, where did he intern at?
87:33 - So imagine this is the document about my resume.
87:37 - And maybe imagine this first paragraph
87:39 - was talking about something about I interned at Reluvate company here.
87:47 - So what it's going to do is it's going to vectorize,
87:50 - it's going to embed this search query,
87:53 - it's going to turn it into a vector.
87:55 - So this is going to turn into another vector embedding.
87:59 - Then it's going to go through all the current vectors within my PineconeDB.
88:04 - It's going to look for the vector that's more similar.
88:07 - So in this case, the vector that's more similar
88:09 - will contain the paragraph that says I interned at Reluvate
88:12 - because they are similar within Semantic,
88:15 - in terms of the meaning.
88:17 - So let's say this vector embedding,
88:19 - the third vector embedding contains the paragraph that says this.
88:23 - So it contains the original paragraph.
88:25 - So what it's going to do is it's going to pull out this original vector.
88:28 - Then it's going to take out the metadata from it.
88:31 - It's going to extract out the metadata.
88:34 - Then we're going to feed in this metadata into chatbot
88:38 - so that we can create a prompt,
88:40 - so that we can then ask chatbot to take in context of the metadata
88:44 - and also the question,
88:45 - and then it can generate the answer based on these vectors.
88:49 - So these are very high overview on how we do it.
88:53 - So I hope you have a better understanding of
88:55 - how retrieval augmented generation actually works.
88:58 - So let me just break it down once again, two steps,
89:01 - so that we can actually code it out.
89:02 - So the first step is actually obviously to obtain the PDF.
89:07 - The second step is to split and segment the PDF
89:13 - into smaller documents.
89:16 - Then the third step is to take the documents
89:17 - and then factorize and embed individual documents.
89:27 - So after embedding different documents,
89:29 - we can then store the embeddings,
89:32 - store the vectors into Pinecone DB.
89:38 - Then lastly, whenever we want to search,
89:40 - so when we're trying to search, we're trying to check with the chatbot,
89:45 - we can first embed the query, so turn it into a vector.
89:50 - Then we're going to query the Pinecone DB for similar vectors.
89:56 - Then we're going to extract out the metadata of the similar vectors.
90:06 - And then finally, after we extract out metadata,
90:09 - we can then feed metadata into the OpenAI prompt
90:21 - to generate the proper output with context of the PDF.
90:26 - So that's the main step for it.
90:29 - So where does Lang chain actually comes in?
90:31 - The Lang chain will actually help us with the splitting
90:33 - and the segmenting of the PDF.
90:35 - So I'll show you how to actually code the app in the code very, very soon.
90:39 - Okay, so before we actually set up the Pinecone
90:42 - and make sure that we can embed all the documents,
90:45 - let's actually make sure that we can send the file name
90:48 - and the file key back to our backend whenever we upload to S3.
90:52 - So underneath here, I'm going to go to your Explorer,
90:56 - come down to your app, create a new folder called API.
90:59 - Under here, create a folder called create-chat.
91:03 - And here we can create a root.ts.
91:05 - So this is a special root.ts is a special file name within the app router.
91:09 - So that whenever we can see that there's this file structure
91:12 - of slash API slash create-chat,
91:13 - this will map to the rest endpoint for this endpoint.
91:16 - So this will actually map to slash API slash create-chat.
91:22 - Then in the front end, we can hit this endpoint
91:23 - and this function here will be called.
91:25 - So let's export an async function called post.
91:30 - Right, so we are setting a post endpoint here.
91:32 - So whenever they hit a post endpoint to this endpoint here,
91:36 - this code here will run.
91:37 - Okay, so for now, we're going to just take in the request
91:42 - to be a request object and response to be a response object.
91:48 - Response, okay, that's good.
91:50 - So I'm going to try catch block.
91:53 - So if there's any error, let's just console dot error,
91:55 - and then we'll return the next response dot JSON error,
92:04 - internal server error, and let's pass in status of 500.
92:11 - Let's save it, okay.
92:13 - So for now, we're going to get the body from a weight request dot JSON.
92:17 - So we want to get the request body.
92:20 - And for now, I'm going to expect there's two things from the body itself.
92:23 - So we're going to expect the file key and the file name, okay.
92:28 - So this file key and the file name is going to come from this data.
92:31 - So remember, after we upload to S3,
92:33 - the data that it returns will be two things, file key and file name.
92:36 - We're going to take these two variables
92:38 - and then send a request back to our backend here
92:40 - so that we can actually do the pine cone vector embedding stuff.
92:44 - Okay, so to do the hitting of the API,
92:47 - I'm using React query to manage that.
92:49 - So at install and PM install at 10 stack slash React dash query.
92:56 - So this React query library makes it very easy to handle mutations
93:00 - and data querying from local to server state, server endpoints basically.
93:06 - Okay, so after we have done that, we need to come back to our folder.
93:12 - And let's actually wrap our entire app in a React query provider.
93:15 - So come on to your components and let's create a provider.
93:19 - So we'll do tsrefc to create a snippet.
93:27 - So this will be a client component.
93:30 - And what we want to do is import a few things from at 10 stack slash React query.
93:37 - So we need the query client provider and also the query client itself.
93:43 - So we'll initialize cons query client to be a new, sorry,
93:50 - cons query client equals to new query client.
93:55 - And then for this props, we'll take in the React children.
93:58 - So this is going to wrap our entire application.
94:00 - So we'll take in the children to be a React dot React node.
94:05 - Then we can destructure the children from the props itself.
94:07 - Okay, then here we can basically wrap our query client provider, passing our client here.
94:16 - And then we'll just wrap the children in this provider.
94:20 - Save it.
94:21 - Then now let's actually wrap our layout.
94:23 - So come back to our layout.tsx.
94:26 - So inside this click provider, okay, within this click provider,
94:29 - let's actually wrap our providers.
94:31 - So providers.
94:35 - Okay, let's wrap the HTML tags.
94:36 - Okay, so now that we have wrapped this entire provider,
94:40 - we can actually start using React query.
94:42 - So the reason why we actually have to wrap these providers is that,
94:46 - because React query does a lot of caching, right?
94:48 - So imagine we have one endpoint that gives us back some data.
94:51 - So imagine we have these slash API says messages data.
94:54 - Whenever we hit this endpoint, it returns us with a list of messages from the database.
94:59 - And then we navigate to another page and it makes the exact same call to this endpoint.
95:03 - React query will be able to detect that,
95:05 - oh, look, you're making the same call to the endpoint,
95:08 - but I did have the data from a few seconds ago.
95:11 - So instead of making that call back to the backend, which might waste some resources,
95:15 - why not I just cache the data and then return you immediately?
95:19 - So then with this, it creates a more efficient workflow
95:22 - when you're fetching data from the server.
95:24 - And that's why we need this provider,
95:26 - such that every component within our application has access to the data cache.
95:31 - Okay, so now we have this React query.
95:33 - Let's actually create the function to call the backend API
95:36 - to actually create the chat room.
95:40 - Okay, so come back to your, what's this called?
95:43 - A file upload component here, file upload here.
95:47 - So above these use dropdown, let's actually create a mutation.
95:51 - So mutation is just a function that allows you to hit the backend API.
95:55 - So cons mutate, so actually just cons,
95:58 - let's destructure from use mutate mutation from React query, right?
96:02 - We can see that it actually returns us with a few things,
96:05 - returns us with a lot of things like each loading state, error state, even the mutate.
96:11 - So this function will be called.
96:12 - So for this use mutation, we'll pass in a few things.
96:15 - We'll pass in the query key.
96:18 - Sorry, not query key, not query key.
96:20 - It's just a directly mutation function.
96:23 - So this mutation function will be an async function, right?
96:26 - So let's actually install axios,
96:27 - because we need axios to actually make that API call to the backend.
96:30 - So npm install axios, so do cons response equals to awaits axios.
96:38 - So import axios, import axios from axios.
96:44 - Axios.post, we want to hit a slash API slash create chat, right?
96:49 - So this create chat will hit this endpoint here.
96:52 - And then we want to pass in two things.
96:54 - We want to pass in the file key and the file name from the body, right?
96:58 - So how do we get this, we can get it by destructuring here from file key and file name.
97:06 - So this will be destructured from here, file key, which is a string,
97:11 - and file name, which is also a string.
97:14 - Save this.
97:15 - So later on, we'll pass this file key and file name into this mutate function,
97:19 - which will be, we can access it here.
97:22 - So then we'll pass in file key and file name.
97:25 - Okay, awesome.
97:28 - Then after we have made that call, we can just return response.data.
97:32 - Okay, so how do we actually call this mutate function, right?
97:36 - So this mutate, we can just come down here.
97:38 - So after we have uploaded to S3, right, we get this data,
97:42 - we get a check if not data.fileKey or not data.fileName.
97:49 - So if for some reason there's no file key and file name,
97:51 - we know that something has went wrong.
97:53 - So let's actually alert something went wrong and return.
97:56 - If not, we can actually call the mutate function.
97:58 - So you see this mutate function comes from this top here, right?
98:02 - And then we define this mutate function within the property.
98:06 - This will take in two things, file key and file name.
98:09 - And right now, if I come down to file, mutate, right,
98:13 - and I pass in the object, we can see that we need this file key and file name.
98:17 - So we can just pass in this data,
98:19 - because this data is ensured to have the file key and file name.
98:21 - So we can see that it matches the data type here,
98:24 - matches whatever we expect from this mutation function.
98:28 - Then this data, this data file key and file name
98:32 - will be passed up to our backend endpoint.
98:36 - Okay, so then for the mutate,
98:38 - the second object will contain a few things, a few callbacks for onSuccess.
98:42 - So it gives us this onSuccess.
98:44 - So if it's successful, right, we get back the data from the backend endpoint.
98:49 - So let's console.log data.
98:50 - In case there's any error, let's just take the error.
98:54 - Let's just console.log error.
98:57 - So let me just add one more toast thing.
99:00 - So I'm going to add this library called react-hot-toast.
99:05 - So it's just for nice alerts, right?
99:07 - So if you come back into this library,
99:09 - we can see that we can have this nice toast alert to notify
99:12 - whenever something is happening, right?
99:14 - So let's install that library.
99:17 - So come down here and do npm install,
99:19 - react-hot-toast, okay?
99:23 - So to use this react-hot-toast,
99:25 - we need to come down back to our layout.tsx.
99:29 - Import, we need to import this toaster from react-hot-toast.
99:34 - What do we need to import?
99:35 - We need to import the toaster component.
99:38 - Then underneath the HTML, let's just import the toaster here.
99:42 - So this is why it's actually used to actually create the alerts.
99:45 - So save it, come down here.
99:47 - So we will just replace all these alerts with a toast.
99:51 - So we can see that this toast, we can import from react-hot-toast, right?
99:55 - toast.error, file to large, okay?
99:58 - So let's save it.
99:59 - Okay, so come back to your layout.
100:03 - So this toaster should be within the HTML tag.
100:05 - So make sure it's within the HTML tag.
100:07 - So now let's save this and then let's refresh the page
100:10 - and hopefully I'll take it back.
100:12 - Okay, that's good.
100:13 - So we can do toast.error.
100:15 - So this will create a nice pop-up notification, right?
100:18 - Then we do have this alert.
100:19 - Then for this alert here, we can also do toast.error, something went wrong.
100:26 - Return this and lastly here, we can just toast.error,
100:34 - error creating chat.
100:38 - Okay, so let's save this and now everything looks perfect.
100:41 - So basically what will happen is whenever we drop the file,
100:45 - it's going to upload to S3, right?
100:47 - So whenever we upload a file, it's going to call this upload to S3 function, right?
100:52 - It returns us with the file key and the file name.
100:55 - Then we'll basically call this mutate passing in the file key and file name.
101:00 - This mutate will then take the file key and file name
101:03 - and pass it back to our endpoint create chat.
101:05 - So by right now, if we upload a file,
101:09 - it will then be able to console.log out the file key and the file name.
101:15 - So let me save this and let's actually try it out.
101:17 - So this will obviously be logged out in the server
101:19 - because this is running on the backend.
101:21 - So it will work on the terminal.
101:22 - So let's try it out.
101:23 - So I'm going to press job PDF and let me just upload these 8 runtime docs.
101:28 - So if I press this by right here, we can see that the create chat is being run
101:33 - and then hopefully it's able to tell us that.
101:35 - Okay, so now right now there's an error.
101:37 - Okay, so obviously we didn't return anything from this.
101:40 - That's for a string error.
101:42 - But right now we can see that it's working.
101:44 - We can see that this file key and the file name is being logged out.
101:47 - So this is the file key and this is the file name
101:49 - and it's being logged out within the backend.
101:51 - So we know that this is working.
101:53 - So one more thing here for the file upload, right?
101:56 - So other than the mutate function,
101:57 - remember it also gives us that it's loading state, right?
102:02 - For this is loading state,
102:03 - we can actually use that to display a loading component while it's uploading.
102:07 - So I'm going to just come down to our file upload here.
102:11 - I'm going to define one more state.
102:13 - I'm going to call it uploading, then set uploading.
102:17 - So it's going to be a new state, React.useState.
102:20 - So by default, it's going to be false.
102:23 - Then whenever we actually upload a file here,
102:26 - whenever we upload a file on drop,
102:27 - we're going to first do set uploading to be true.
102:34 - Then underneath here, finally.
102:35 - So whether it's failed or whether it succeeded,
102:38 - we're going to set uploading to false.
102:42 - So then we have these two variables, right?
102:45 - We got this is loading and uploading.
102:46 - So if any of these are true,
102:48 - let's display a loading screen.
102:51 - So if you come down here for this input, right?
102:53 - Below the input right now,
102:54 - we are still showing this drop PDF
102:56 - no matter whether it's loading or not.
102:58 - So to create a better experience,
103:00 - let's do if it's uploading or is loading, is loading.
103:09 - So this uploading variable will be true
103:13 - when I'm uploading to S3.
103:15 - And this is loading variable will be true
103:16 - whenever I'm sending the Falcon founding back to my backend.
103:20 - So if any of these are true,
103:23 - I'm going to show a loading state.
103:25 - I'm going to show a loading state, right?
103:28 - But if any of these are, if both of these are false,
103:31 - then it's fine if I show the drop PDF box here.
103:34 - So I'll move this up.
103:35 - Sorry, can I move this up here?
103:37 - Then for this here, I'll go show a React fragment.
103:41 - Okay, so here I can actually show my loading state.
103:45 - For the loading state, let me just show a, sorry,
103:47 - let me just show a loader too from Lucid React.
103:51 - So let me give a class name of height of 10, width of 10.
103:54 - And we'll do text blue of 500.
103:57 - And then finally, animate spin below the loader too.
104:02 - Let me show a P tag that says a spilling T to GPT dot, dot, dot.
104:09 - We'll give you a class name of margin top of two, text SM,
104:15 - text slate of 400.
104:17 - And let's save it.
104:19 - So let's try out right now.
104:20 - So this root.ts, if this is successful,
104:24 - if this is successfully, I'm gonna do a return.
104:28 - Next response dot JSON message of success.
104:35 - So let's save this.
104:37 - And let's see if it works, okay.
104:38 - So if it works here, instead of console logging the data,
104:41 - I'm gonna do toes dot success.
104:43 - I'm gonna do data dot message.
104:47 - So let me just save it.
104:49 - And let's try out.
104:49 - So I'm gonna press drop PDF.
104:51 - I'm gonna drop the same PDF here and see it's loading.
104:55 - Then after it's loading, it's sent to the backend.
104:58 - If it sends to the backend, we can see that a success message pops up.
105:02 - So everything is perfect.
105:03 - Everything is working well.
105:04 - So now we can actually start working on converting the PDF
105:07 - into vector embeddings and storing within Python code.
105:11 - All right.
105:11 - So let's actually now create the Python feature.
105:14 - So come back to your root.ts on the create chat feature.
105:17 - So eventually with this file key and file name,
105:20 - we want to execute the steps, right?
105:23 - So obtain the PDF, split and segment the PDF,
105:27 - factorize and store the vectors into pinecone DB.
105:30 - So first thing here is actually create a account for pinecone.
105:34 - So come down to pinecone DB, then just go to that pinecone DB.io.
105:38 - So you can either log in or just sign up for free.
105:41 - So in this case, I have the account, so I'm gonna log in.
105:43 - Okay.
105:43 - So once you log into the app.pinecone.io, the dashboard,
105:48 - right, come down to create index. So we'll first create an index.
105:51 - So index within pinecone is just like one is a database within like a normal SQL database.
105:57 - So it's a place to store all your different vectors, right?
106:01 - So let me explain this, the terminology within pinecone.
106:04 - So pinecone terms, okay.
106:10 - So we have index.
106:12 - An index is just a database to store all your different vectors, right?
106:17 - Then within index within pinecone, there's nothing called namespace.
106:20 - So a namespace is like a table.
106:23 - So imagine we'll have a different namespace for each PDF.
106:27 - So it's two segment PDF vector spaces.
106:32 - So basically, each PDF will have its own namespace.
106:36 - And then each namespace will contain its own vectors.
106:39 - Then basically, we can query whenever we query, we can pass in a namespace parameter.
106:44 - So then you will only query vectors of query for similar vectors within that specific namespace.
106:49 - Yeah, so that's how it's going to work.
106:51 - So come down to the name.
106:52 - So give it anything you want.
106:53 - I'm going to call it Chats PDF dash YouTube.
106:57 - Then for this index, for the dimensions, put 1536.
107:00 - So it can have up to 1500 dimensions, right?
107:04 - For the magic, leave it in cosine.
107:06 - So we're using cosine similarity for the algorithm comparison, right?
107:10 - So you can then see this distance metric to use for measuring similarity between the vectors.
107:15 - Then just choose starter and then leave everything as default.
107:17 - So it's a three-tier index.
107:19 - Just press create index.
107:20 - So in this case, I already have an index, right?
107:22 - And because I'm on the three-tier, it only allows me to have one index.
107:24 - But it's okay.
107:25 - You just create an index and you're still able to follow along.
107:28 - So after you have created the index, you should be able to come in
107:31 - and you're able to see different information about it.
107:33 - So in this case, we can see that right now I have 578 vectors within my database, right?
107:38 - So later on, when we start inserting, it will increase also.
107:41 - So now what you need to do is come down to your API key section.
107:44 - Okay, so just create a new, come down here and create a new API key
107:48 - and name it whatever you want.
107:49 - Just name it, I'm going to name it chatPGF YouTube.
107:53 - So create a key.
107:55 - So as it's waiting, we will need two things from it.
107:57 - We need a pinecone environment and we also need a pinecone API key.
108:02 - Okay, so after you created the key, it needs to have a name in YouTube.
108:05 - We need two things.
108:06 - We need the environment, we also need the API key itself.
108:08 - So we need these two things.
108:10 - So come down to your.env, right?
108:13 - We're going to create a new section just for the pinecone.
108:17 - Pinecone.
108:18 - Okay, so we need the pinecone environment.
108:24 - So copy in the environment here, it's the location of where it's located.
108:28 - We also need a pinecone API key.
108:32 - API key.
108:33 - So let me copy in this here.
108:35 - Copy and paste it here.
108:37 - So let's save it.
108:38 - And then we can just quit out of this pinecone console for now.
108:42 - Okay, so come down to your directory.
108:45 - Let's go under your lib folder and let's actually create a pinecone.ts
108:48 - to store all our functions for pinecone, pinecone.ts.
108:53 - Okay, so the first thing here I'm going to do is I'm going to declare
108:57 - a let pinecone to be a pinecone.
109:00 - Actually, let's install the pinecone first, right?
109:02 - So let's install npm install at pinecone data-based slash pinecone.
109:10 - So let's install that.
109:11 - So we'll be installing a few things also.
109:15 - Okay, one more thing we need to install is, actually, let's install it as we go
109:20 - as long as we need it.
109:21 - So let's import the pinecone first.
109:23 - pinecone at pinecone data-based slash pinecone, right?
109:33 - This pinecone, so here pinecone client, right?
109:38 - So this pinecone variable here will be a type of pinecone client or now.
109:47 - So this is going to be a global variable here.
109:50 - After this, we're going to do, we can export a cons function, a cons get pinecone client
110:00 - equals to it async function, right?
110:03 - So this is going to help us initialize the pinecone.
110:04 - So if not pinecone, so if we have not already set the variable,
110:08 - what we're going to do is we're going to call pinecone equals to new pinecone client, right?
110:13 - Then we'll do await pinecone dot init.
110:17 - So init, we need to initialize it with our API keys, right?
110:21 - So for the environment, we do process dot env dot pinecone environment.
110:28 - So it's what you have copied in from the dot env here, okay?
110:32 - So make sure it exists, and then we also need the API key.
110:36 - So this will be process dot env dot pinecone API key.
110:42 - Make sure it also exists.
110:44 - So put the exclamation mark to ensure that TypeScript that it will always exist.
110:48 - Then in the end, we just want to return the pinecone.
110:53 - Pinecone, excellent.
110:55 - Okay, that's good.
110:57 - So now let's actually create a function to load S3 into pinecone, right?
111:00 - So right now we can see that we have a few things that we need to do.
111:03 - Let me find the proper stuff here.
111:06 - So we got a few steps, right?
111:07 - We need to obtain the PDF, split and segment, vectorize and store it.
111:11 - So we have four steps here.
111:12 - So let's see how we can map it into a function.
111:14 - So we can export an async function called load S3 into pinecone.
111:21 - So this thing is going to take in a file key.
111:23 - It's going to take in a file key which is a string.
111:25 - So this file key will be what is being passed from this root.
111:29 - So let's actually call this function right here already.
111:31 - So let's just do a save this file, and let's call await load S3 into pinecone,
111:38 - and let's pass in the file key.
111:39 - Okay, so what this function is actually going to be the bulk of this project, right?
111:44 - So I'm going to go through it line by line and let's see how it works.
111:47 - So the first step is, number one is obtain the PDF.
111:53 - So how do we actually download the S3 file key into our local directory
112:00 - so that we can read the text from the PDF, right?
112:02 - So within this obtain PDF, we actually need to download and read from PDF.
112:09 - Okay, so to do that, let's actually create a S3 function for this.
112:14 - Come down to your directory, right?
112:17 - Under our lib, right?
112:18 - Instead of this s3.ts, let's create another function called s3-server.ts, right?
112:24 - So this will make sure that this file will only run on the server.
112:27 - Okay, so come down to your s3-server.ts,
112:29 - let's create a function, export async function, download from s3.
112:38 - Okay, so this download from s3 will obviously take the file key
112:42 - and then download the s3 file onto our local computer.
112:51 - So it's going to take in the file key, which is going to be a string.
112:53 - Okay, so what we're going to do,
112:56 - we're going to first import the AWS from AWS SDK.
113:03 - So it's right similar to what we did just now.
113:05 - So we'll do a try catch block.
113:07 - So if there's any error, let's just console.error, just return now.
113:13 - Okay, so we're going to do aws.config.update.
113:19 - So it's the same thing just now.
113:21 - access key id will be process.env.next underscore public s3 access key id,
113:30 - make sure it exists.
113:32 - Then we'll also need the secrets access key, right?
113:36 - It'll be the same thing here.
113:37 - So after configuring the AWS object, right?
113:40 - So actually we can just copy from s3, right?
113:42 - We don't need to type this out.
113:43 - So the copy up here, copy this.
113:46 - So we're just trying to initialize the s3 bucket here.
113:49 - Okay, now that we have that, let us do cons params equals to the,
113:56 - we need the, what's this called?
113:59 - We need the bucket to be process.env.next public s3 bucket name.
114:06 - And then for the key, for the key, we need a file key, right?
114:12 - So with this params, we can actually obtain the s3 from that.
114:15 - So we do cons object equals to await s3.get object, passing the params.
114:21 - So these params, because it contains the file key,
114:24 - is able to extract out the unique id, unique file from s3.
114:30 - So we'll convert it to a promise, right?
114:32 - So we await the promise.
114:33 - So this object now contains the actual file object.
114:38 - Then all we need to do is, let's import the import FS for file system from FS.
114:43 - So we need this FS to actually download the file to our system.
114:47 - So we just need to do FS.writes file sync, right?
114:54 - Give me a file name, and we'll just do object.body as buffer.
115:00 - Okay, so let's declare this file name.
115:02 - So this file name is where do we want to install it in our local,
115:05 - how do we, where do we want to download it to our local folder, right?
115:09 - So we'll just download it to slash temp slash PDF, dash,
115:16 - let's actually create this into a template string, dates dot now, dot PDF.
115:26 - So it's just going to download it to our temp directory,
115:28 - a temporary folder with a unique PDF with a date dot now, and just name it PDF.
115:33 - So then we'll just download it into our file system.
115:36 - Okay, then we want to return the file name.
115:39 - Okay, so that's all we need to do.
115:41 - So this function will actually take in a file key and just download it to our folder
115:45 - and return the file name to where the folder is located,
115:48 - where the file is actually downloaded to.
115:50 - So let's save this, and let's come back to our pinecone.ts.
115:54 - So with this function, with the S3 function, we can actually use that, right?
115:58 - So let's just do console dot log, downloading S3 into a file system.
116:07 - So we can call cons file name equals to await download from S3 passing the file key.
116:14 - So this is from the S3 server that we are importing, right?
116:19 - Okay, then the second step is to actually get the PDF.
116:25 - So how do we actually get the text from the PDF?
116:28 - So of course the PDF is a dot PDF, right?
116:30 - How do we get all the text format from the PDF itself, right?
116:34 - So what we can do is, let me just, we need to install one other thing.
116:38 - We need to install, let me see.
116:42 - I think we need to install lang-chain.
116:43 - So the lang-chain provides us with a nice PDF loader,
116:48 - such as we would convert PDF into text strings.
116:51 - So let's npm install lang-chain itself.
116:54 - So lang-chain gives us a lot of utilities to actually do a lot of AI
116:59 - and machine learning utility functions.
117:03 - So what we need from lang-chain, we need from lang-chain slash documents underscore loaders,
117:12 - loaders slash FS slash PDF.
117:16 - So this will give us a PDF loader class, right?
117:21 - So this from file system PDF.
117:23 - So this PDF loader will be able to read from the file system
117:26 - and give us the text of that PDF file.
117:29 - So we can just use this.
117:31 - So we'll do cons loader equals to new PDF loader, right?
117:37 - And we pass in the file name that we got back after we've downloaded it here, right?
117:41 - So if something goes wrong, so if not file name,
117:44 - so maybe there's some error downloading here.
117:47 - So if there's no file name,
117:48 - let's just throw a new error saying that we could not download from SG.
117:51 - So that by the time we get to this line, we're guaranteed that there is a file name here.
117:55 - Okay.
117:56 - So what I'm going to do here is I'm going to stop here for now
117:59 - and I'm going to just console dot lock.
118:05 - Let me see.
118:05 - I'm going to get cons pages equals to loader dot load.
118:08 - So we can call, to get the pages, we can do loader dot load.
118:14 - So this loader dot load will then look at this.
118:16 - You will read the buffer content and metadata based on the type and call the parts.
118:20 - So basically what this does is it will return us with all the pages within the PDF, right?
118:25 - So what I'm going to do is I'm going to just return the pages.
118:28 - So we're going to see what happens when we load this in.
118:33 - So I'm going to save it.
118:35 - I'm going to save this file first and then come back to our root, right?
118:38 - Remember that we call this load actually into pine code.
118:41 - So right now, it will return us with a bunch of pages, right?
118:48 - So we can see these pages is a type of document.
118:51 - So there's a lot of documents, right?
118:53 - So let me just await this loader dot load, okay?
118:56 - So then finally here, we can see that it's going to be an array of documents, right?
119:00 - So this is exactly what I mean by splitting and segmenting the PDF.
119:04 - So let me save it, come back to our root, and let's just return the cons pages equals to,
119:11 - let's just console dot lock the pages.
119:13 - So let's see actually what we actually get back here, okay?
119:16 - So I'm going to come back to my file upload.
119:22 - So instead of just a toast or success, also let's do console dot lock data.
119:28 - So just delete this.
119:30 - Okay, so now hopefully if we did everything correctly,
119:33 - we're able to see the documents being loaded from the backend.
119:36 - So clear your output here, okay?
119:39 - Then let's press drop PDF, right?
119:43 - So I'm going to drop the H1 time docs, right?
119:46 - So right now we can see that it's uploaded as three,
119:48 - and then it's going to hit the backend.
119:50 - The backend is going to load the PDF into our file system and then read.
119:53 - Okay, so this is normal to be expected, right?
119:56 - So we actually need one more library for the PDF parts, right?
119:59 - So this internal dependency of the Lang chain PDF loader,
120:03 - right?
We need this PDF parts library so that Lang chain is able to properly parse the PDF for us.
120:10 - So let's refresh it and let's actually try again.
120:12 - All right, let me just refresh the page.
120:14 - Hopefully everything is...
120:15 - Okay, so there's one more of this very common error
120:18 - that I actually faced while developing this app
120:20 - is you see this weird stuff here, and eventually you will say,
120:24 - let me look for the error.
120:25 - Okay, reach heap limit allocation field, right?
120:28 - JavaScript heap out of memory.
120:29 - So what I did was I copied this and I searched up stack overflow.
120:33 - So apparently this error is about my Node.js running out of memory
120:37 - trying to run this application, right?
120:39 - We can see that this stack overflow solution
120:42 - is trying to see that a JavaScript heap run out of memory.
120:47 - So what to do is actually we want to allow Node.js
120:50 - to actually use more memory than what is allowed by default.
120:54 - So what you want to do is come down to your package or JSON, right?
120:59 - So whenever you do npm run dev, next dev, right?
121:03 - We can actually set one more thing up here.
121:05 - We can do...
121:06 - Okay, so we do...
121:07 - So here next dev, we do export node underscore options, right?
121:13 - So we want to pass in a variable so we can do here.
121:19 - So what options do we want?
121:20 - We want to do that's just maxed o space size equals to 8192, right?
121:29 - So we're going to basically export a variable,
121:32 - an env variable called max go space size to be 8 gigabytes of RAM.
121:38 - So we allow it to use 8 gigs of space size,
121:41 - and then after that we can run the normal next dev.
121:44 - So this ampersand sign allows you to run two commands in one npm script.
121:51 - Okay, so I think for Windows, if you're using Windows,
121:53 - I think instead of export, it should be set, right?
121:56 - So I think you have to play around to see how you set your environment variables
122:00 - based on your operating system.
122:01 - So for Windows, I think it's set, but for Mac OS and Linux, we could be used export.
122:06 - So let's save this and let's press npm run dev again.
122:10 - And this time we can see that it's exporting this configuration for Node.js to use more
122:16 - a memory before running the actual dev server.
122:19 - So after we have solved that issue,
122:21 - let's actually now try running the server again.
122:23 - So I'm going to refresh the page and hopefully now it will work this time.
122:27 - Okay, so I'm going to collapse this a little bit more.
122:31 - So it's going to compile the page.
122:33 - So let's wait for it to compile.
122:35 - Okay, so now let's actually drop a PDF here.
122:39 - I'm going to do, upload this.
122:41 - I'm going to open up my console.
122:43 - So you can see that it is uploaded to S3
122:45 - and hopefully now it's going to hit our backend.
122:47 - It's going to download the S3 file into our system.
122:50 - Then it's going to use LinkedIn to read the PDF into text
122:53 - and it will return us with a list of documents.
122:56 - So let's wait for that to actually work.
122:58 - And okay, now it works perfectly.
123:00 - So we can see that it has returned from the backend.
123:03 - So we console out the data.
123:04 - So this data comes from this pages here, look S3 into pinecone.
123:08 - So let's inspect it.
123:10 - So within this, we can see that this pages is an array of 13 objects.
123:15 - So within this object, you can see that there's a page content.
123:17 - And this is exactly what we are looking for.
123:19 - This is the text representation of the PDF.
123:23 - So each object here will have page content and also the metadata.
123:26 - So page content is the actual stuff,
123:29 - but here the metadata is what's interesting.
123:31 - The metadata will give us the location.
123:33 - So which document is, so that's one page.
123:37 - So for now, the default function will basically segment the PDF into singular pages.
123:43 - So you will have 13 pages, therefore segments into 13 objects within the array.
123:48 - So each page will have its own page content and its own page number.
123:52 - So if we come down to the second object here,
123:53 - we can see that the page content is the second page.
123:57 - And the metadata will say that its page number is 2.
124:00 - Okay, so that's perfect.
124:02 - So with that now, we can continue working on the pinecone feature.
124:05 - Okay, so I just want to make sure that everyone's on the same page as what we're actually doing.
124:11 - So now that we understand that this function, this pages variable is going to be a record of
124:18 - page content and also the metadata.
124:23 - So what I'm going to do here is I'm going to define my own custom type.
124:26 - So above here, outside of the function,
124:29 - I'm going to export a type of PDF page.
124:35 - So this PDF page, remember just now we saw in the console,
124:37 - it has a page content, which is a string, and also it has metadata.
124:43 - Within the metadata, I have the location,
124:46 - which contains a page number, which is a number.
124:49 - So this is what I got just by looking into the console and looking at what this console.logs out.
124:55 - Okay, so now that we have that, let's actually just do,
125:00 - let's wrap this here and just do as PDF page here.
125:04 - So then we have properly type it.
125:05 - So right now we can see these pages is now properly a PDF page.
125:09 - So it has the type annotations.
125:11 - Okay, so that's perfect.
125:12 - So now let's actually move on to the next few steps.
125:16 - So okay, so now we actually need to split and segment the PDF, right?
125:20 - So right now, how it does the splitting is that it splits the PDF by pages.
125:24 - So if the PDFs have 13 pages, it's going to split it into 13 pages.
125:28 - But the thing is that's not very ideal for vectorizing
125:32 - because we want each vector to contain only a very small paragraph.
125:37 - So maybe two to three sentences.
125:39 - So we don't want each vector to contain the whole page content.
125:42 - That's not very good for vectorization.
125:44 - So what we're going to do is we're going to use another function from,
125:48 - I think it's from pinecone.
125:51 - So pinecone gives us a function called recursive character text splitter.
125:55 - So it helps us with the text splitting into a smaller paragraph.
125:59 - So we can be doing that right now.
126:01 - So let me just close this terminal and let's continue working on the function.
126:05 - So now we're talking about the second step.
126:06 - So now we have these pages, right?
126:08 - We can move on to a second step.
126:09 - Number two, which is split and segment the PDF into smaller documents.
126:20 - So right now these pages is an array of documents,
126:23 - but the documents are still too big.
126:24 - So within the 13 objects within the array, we want to split it even further.
126:29 - So what we're going to do is we're going to write a function.
126:31 - I'm going to write a function just called a function called async function.
126:40 - I'm going to call it prepare document.
126:43 - All right.
126:43 - This is going to take in a page of PDF page,
126:47 - and then it's going to take in a splitter.
126:50 - Sorry, a splitter.
126:52 - Sorry.
126:53 - So it's going to take in a PDF page, just a PDF page.
126:55 - And what this function does is it takes in a singular page.
126:58 - So remember just now a page is one of the objects within the array of 13 pages, right?
127:03 - So we're going to look at the page content and then split it up even further.
127:07 - So to get the splitter, how to actually split it,
127:10 - we need to install a more package from pinecone database itself.
127:16 - So npm install add pinecone database slash doc splitter.
127:25 - So this is another package within pinecone database
127:27 - that gives some utility function to help split our documents.
127:30 - So let's import that function for us.
127:33 - So import a few things from at pinecone database slash doc splitter.
127:40 - So we need two things.
127:41 - Many, many, the document type, the document class,
127:44 - and also a recursive character text splitter.
127:49 - So let's come down a prepare document.
127:52 - So let's actually do the splitting here.
127:53 - So the first thing here we need to do is we can export a few things from the page itself.
128:03 - So remember this page, we defined this PDF page, our custom type here.
128:06 - So we can destructure the page content and also the metadata.
128:10 - Okay, then what we want to do is page content.
128:13 - We want to just replace page content dot replace.
128:17 - Replace, let's do a regex for the slash, sorry,
128:26 - how do we actually do the regex?
128:28 - It will be slash n slash g.
128:31 - So just replace it with an empty string.
128:34 - So this is just a regex to replace all the new line characters with an empty string.
128:40 - Then finally, we split the docs.
128:43 - So we do const docs equals to await, so how do we get the splitter?
128:49 - We can do const splitter equals to new recursive character text splitter.
128:55 - Then we'll do splitter dot spits documents.
129:01 - So when the spits the documents, so this document is going to be an array, right?
129:05 - But in this case, we only have one PDF page.
129:07 - So inside here is only going to have one document.
129:10 - So each document is like one page within this function.
129:14 - So we'll pass in a new document.
129:16 - So this new document is defined from what we've just imported here, right?
129:21 - So this document will contain a few things.
129:23 - So the page content will be the same, right?
129:25 - So this page content comes from the PDF page here.
129:28 - However, the metadata, we can actually specify our custom metadata.
129:33 - So we can pass in a page number to be the metadata dot location dot page number.
129:38 - And also let's pass in a text.
129:40 - So this text will actually contain the original text of it.
129:44 - So because this document will be vectorized and stored in pinecone,
129:49 - this text might be too long for pinecone to handle.
129:53 - So let's create another function for this.
129:57 - So export const truncate string by bytes.
130:03 - So this is going to take in a string and also take in a number of bytes.
130:08 - So what I'm going to do is just const encoder.
130:14 - Sorry, this should be an error function.
130:17 - Const encoder equals to new text encoding, new text encoder.
130:22 - And we just want to do return new text encoder.
130:28 - Sorry, text decoder.
130:30 - I mean text decoder, right?
130:32 - Text decoder.
130:34 - Pass in the UTF-8.
130:36 - So we'll just give you a UTF-8 and then decode it.
130:39 - So what do you want to decode?
130:41 - We want to decode the encoding of the string, right?
130:45 - And then after the encoding, we want to slice from 0 to bytes.
130:52 - So this will make sure that the string that we pass in is within the byte,
130:55 - within the size, the proper size.
130:58 - So I think pinecone only accepts strings.
131:03 - The metadata text to be up to 36,000 bytes.
131:09 - Therefore, we'll pass in the 36,000 to make sure that it truncates off properly
131:12 - so that it doesn't cause any errors when we actually insert into pinecone.
131:16 - Then last thing, after we have split up, so this splitter will take in the original document
131:22 - and you split up into smaller documents, then we can just return the docs.
131:25 - So now these docs, what it does is it takes in one single page
131:29 - and splits up into multiple docs.
131:30 - So it can be split up into five, six paragraphs for a single page, all right?
131:36 - So now let's actually call this prepare document, okay?
131:38 - So for this, before we don't return the page,
131:41 - what we actually want to do is we do cons documents equals to await promise.all, right?
131:49 - We want to pass in pages.map.
131:52 - So for each page, we just want to, for each page,
131:56 - we actually want to call the prepare document on the page itself, right?
132:02 - So this can actually be short-handed into just prepare document.
132:05 - So what this does is, so once you have loaded in all the 13 pages from the PDF document,
132:11 - we can call the prepare document function on the single page.
132:15 - So then it's going to split up into even smaller chunks.
132:18 - So maybe like, let's say pages was an array of 13 elements, array of 13 pages.
132:25 - After calling these prepare documents on these array of 13 pages,
132:28 - these documents could be like maybe array of like even 100.
132:32 - So it takes in the single page and splits up even further.
132:35 - So now that we have all these documents, right,
132:38 - we can then vectorise and embed the individual documents, right?
132:41 - So that's the third step now.
132:42 - So we're doing well.
132:43 - So I hope that you are still following on.
132:46 - So now we actually want to vectorise and embed in the virtual documents.
132:52 - Okay, so let me just create another function here called embed document.
132:59 - So async function embed document.
133:04 - So before that, let's just comment this out first.
133:08 - Let's actually use the openAI function to actually get the embeddings of a single string, right?
133:14 - So come down to our, let me see where did I put it.
133:19 - Okay, come down to your file structure.
133:21 - Come down to your lib.
133:22 - Let's create a new file called embeddings.ts.
133:26 - Okay, so for this embeddings.ts, we need to install the openAI package, right?
133:32 - So npm install, store openAI-h.
133:37 - So this openAI-h is an alternative package to the normal openAI package that's edge compatible.
133:42 - So this package allows us to run this pinecone thing on the edge.
133:46 - So after we have done that, let us import a few things from openAI-h.
133:53 - So we need the openAI API and also the configuration object.
133:57 - So the first thing here we need to do is const config equals to new configuration, passing in the API key.
134:04 - So how do we get the openAI API key?
134:06 - So let's come down to our browser.
134:10 - So just come down to openAI API.
134:14 - Okay, come down to the API and then look for the API key.
134:19 - So I'm going to just zoom out a little so that it doesn't, okay.
134:22 - So come to the menu and search for the API and just go to our overview.
134:29 - So get started for developers.
134:31 - Okay, so you see this GPT, it allows us to generate embeddings that can be used for tasks
134:37 - like text classification.
134:39 - So we want the embeddings API.
134:41 - So just log into the account, right?
134:43 - And then you can actually read more about embeddings within the docs here.
134:47 - So come down to your view API keys.
134:49 - Okay, so for this create new secret key within the API, just name it wherever you want.
134:53 - I'm going to name it chat PDF-youtube, create a secret key and then I want you to copy in this secret key.
135:00 - And let's close this tab.
135:02 - So come back to your.env file.
135:04 - So let's just put a openAI API, sorry, openAI API key, just paste it in here, save it.
135:15 - Let's close it.
135:16 - So now we have this openAI API key in our configuration.
135:20 - Okay, then let's just do cons openAI equals to a new openAI API passing in the config object.
135:27 - So now let's actually export an async function called getEmbeddings.
135:32 - This is going to take in a text of a text with a string.
135:37 - So this function purely converts a text into a vector, right?
135:41 - So let's do a try catch block, right?
135:43 - So if there's an error, let's just go to the log, error calling openAI embedding API passing the error.
135:52 - Okay, then actually just throw the error.
136:04 - Okay, so let's just do the cons response equals to await openAI dot create embedding, right?
136:13 - So passing in the model.
136:15 - So for the model, we actually want to choose the text dash embedding, embedding, sorry,
136:23 - make sure you're spelling it correctly, embedding dash ada dash 002.
136:27 - So this is the model that actually helps us do the embeddings.
136:30 - So it's fast and also efficient and also capable enough that we're passing the input,
136:35 - right, just do input, sorry, the input will be text dot replace.
136:41 - So just replace all the new line characters with an empty string here, empty space here.
136:47 - Then lastly, we just want to return.
136:50 - We want to do cons result equals to await response dot JSON.
136:57 - And we can just do return results dot data index zero dot embedding S number.
137:05 - So it's going to be a vector.
137:06 - So this embedding is merely a vector of multi dimensional numbers, so this is a vector itself.
137:13 - So let's close this embedding file, then we can actually use it in our pinecone.ts.
137:18 - So once basically remember when to embed the documents, right embed the individual documents.
137:23 - So for the embed documents, let's take in a doc as a document type.
137:27 - So these from the pinecone, pinecone type annotation.
137:30 - So this is going to, let's just do try catch, put in a try catch a block.
137:38 - So if there's an error, let's just do console dot lock,
137:41 - error embedding documents and passing the error.
137:46 - Then we'll just throw, throw the error.
137:49 - Okay, so what we're going to do.
137:52 - So first we're going to do we get embedding embeddings equals to await get embeddings.
137:57 - We imported from the embeddings file that we just did just now.
138:00 - So doc dot page content.
138:02 - So we want to basically convert the page content into the vector.
138:05 - Then we want to get hash of the page content.
138:10 - So for the hashing function, we'll MPM install MD5.
138:15 - So this is help us ID make sure that we can ID the embedding ID the vector within pinecone.
138:23 - Right, so let me just import, import MD5 from MD5.
138:30 - Right.
138:30 - So I think we need to install the types for this to MPM install at types for MD5.
138:36 - Okay, so let's save the file.
138:38 - Come down here.
138:39 - So for the hash for the unique ID, we'll just do MD5 passing the doc dot page content.
138:45 - Then lastly, return the return.
138:49 - We want to return a vector, right?
138:51 - So this is going to return a vector.
138:52 - So the vector type, so how do we get the vector type?
138:56 - The vector type actually comes from the pinecone database.
139:01 - So you see this at pinecone database, right?
139:04 - We can actually import the vector type.
139:06 - Okay, so come down here.
139:08 - So this can return this as a vector.
139:11 - So then here, we can actually do that.
139:14 - We can get the type annotation.
139:16 - So we need the ID.
139:18 - So this ID is going to be the hash.
139:19 - We need the values, the values to be the embeddings.
139:25 - So these actual embeddings within the vector.
139:28 - And then we can pass in the metadata for the vector that is going to be stored within pinecone.
139:33 - So we can store the text will be doc dot metadata dot text dot text, right?
139:39 - And then for the page number, we can page number.
139:42 - We can do doc dot metadata dot page number.
139:45 - So this doc dot metadata dot text actually comes from here.
139:49 - Remember, we put the metadata here.
139:50 - We put in page number and text.
139:52 - So now what we're doing here, we are accessing it here.
139:55 - So the metadata dot text, here metadata dot text here.
139:59 - Okay, so I hope everything's still clear.
140:03 - So then we just return the vector.
140:05 - Okay, so right now, we can see that now, basically, this takes in a document
140:08 - and returns a promise of a vector.
140:11 - So now that she vectorized and embed the individual data,
140:14 - it's an embed the individual documents.
140:16 - So we do the same, very similar to just now, we just do cons vectors equals to await promise dot all.
140:24 - We do document, we do documents dot flat.
140:28 - So we flatten the document first, then map to it.
140:31 - And then for each document, we call the embed document on that function.
140:35 - So then these will then give us back a real vectors, right?
140:40 - So if you come back to our XCALI drawer, we can see that we are now on this step.
140:44 - We have already broken down into each document, a small document.
140:48 - Then we have created into vector embeddings.
140:50 - So then now the last step is just to put these vector embeddings up to pinecone DB.
140:56 - Okay, so we're doing really good.
140:57 - We're doing excellent.
140:58 - So now we have the last step.
141:00 - So the first step here is upload to pinecone.
141:05 - Okay, so let's just get the client first.
141:09 - So cons client equals to await, get pinecone client, right?
141:13 - So this pinecone client is what we have written up just now here.
141:16 - So it just returns us to the pinecone with the initial, the config, the API key configs.
141:21 - So to get the pinecone index, right?
141:24 - So this index is the name of the database, right?
141:26 - So we want to do await client dot index.
141:31 - So what is the name of the pinecone index?
141:34 - So for me, just now I name it chat BDF, right?
141:37 - So if you come back to your pinecone app dot pinecone dot IO, right?
141:47 - So for me, I name it chat PDF.
141:49 - So the pipe, the index name has to be chat PDF.
141:51 - Okay, so that's good.
141:53 - So after we have gotten the pinecone index, we can then let's just say,
142:00 - let's do console dot lock.
142:02 - Let's just put a debug lock that says
142:04 - is inserting vectors into pinecone.
142:11 - And then we can just get the namespace, cons namespace.
142:14 - So remember, we have a different namespace for each document.
142:17 - We can get the file key, right?
142:19 - So this file key is being passed up.
142:21 - Okay, so there's a bug that I faced just now where
142:24 - if the file key was not in all ASCII characters,
142:27 - right, then obviously it does going to be true and error within pinecone.
142:31 - So we need to write another function that actually converts the file key into ASCII characters.
142:36 - So come down to your folder, come down to your utils, your utils or TS,
142:43 - and then let us create a function called convert to ASCII.
142:48 - So export function, convert to ASCII.
142:53 - Okay, this is going to take in the input string of type string.
142:56 - All we're going to do is remove any non ASCII characters.
143:03 - So this is all the function does.
143:04 - So we do cons ASCII string equals to input string dot replace and put these regex in.
143:13 - So I just got this from chat GPT, honestly.
143:17 - Yeah, so you can just copy whatever I have here.
143:21 - We can just copy whatever I have here within the code base.
143:24 - So let me just actually copy my own version within my code base
143:28 - so to make sure that everything is correct.
143:29 - Okay, so make sure you're putting in this regex.
143:32 - So this I think it just takes any non ASCII characters and just replace it with an empty string.
143:37 - So the last thing we just want to return the ASCII string.
143:40 - So let's save it.
143:41 - We can close it off.
143:43 - So remember for the file key, we want to convert to ASCII.
143:53 - We want to import a function from utils, right?
143:58 - So we're passing this file key to make sure that the namespace is ASCII compatible.
144:03 - Then lastly, what we can just do is we can just call.
144:08 - So one thing we want to import from pinecone database is the utils function, right?
144:14 - So when you rename the utils as pinecone utils,
144:18 - right, so this is a renaming of the utils function that's exported.
144:23 - Within these utils, pinecone utils, there's a function called chunkedupset.
144:32 - So it will just help us update and push the vectors into the pinecone index.
144:36 - So we're passing the pinecone index first.
144:39 - Then we're passing the vectors.
144:40 - There on the insert in the pinecone, passing the namespace, which is this convert ASCII.
144:45 - And lastly, you can see the last function here is the chunk size.
144:50 - So I'm going to just enter a 10.
144:52 - So I experimented around and just found 10 was a nice number to use for this.
144:58 - Then let's just return the documents in index zero.
145:02 - So we'll just return the first document, right, just for the sake of it.
145:06 - So this is the bulk of this whole retrieval augmented generation.
145:11 - So if you're able to understand the concept and able to implement it like here,
145:15 - then we are actually really good to go.
145:17 - So let me just save the file.
145:19 - So if you come back to our root.ts, right, remember that we call this load S3 into pinecone.
145:27 - So we got this, let me just recap everything, right.
145:29 - We call the file key.
145:31 - We downloaded S3 into the file system.
145:33 - Then we loaded it and then we split into the individual,
145:37 - we split and segment the PDF into smaller documents.
145:40 - We vectorized and embedded documents.
145:42 - Then we finally uploaded to pinecone.
145:45 - Okay, so now that we have that all set up for us,
145:51 - we can just call this so we are not actually getting anything back,
145:55 - any useful information back, right.
145:57 - So we just need to await load S3 into the pinecone.
146:02 - And now here is actually where we create a new chat.
146:05 - So we want to remember, create a new chat within our database, right.
146:09 - So actually let us do that.
146:10 - So to use GZORM to create a chat, let us do const, sorry, let us do await, sorry, await db.
146:21 - So this db is from our adlib slash db, right.
146:25 - So we do insert.
146:27 - So we want to insert into the chats.
146:30 - So we can import this chat from our db slash schema.
146:33 - So insert into chats, we want to insert, we want to insert the values of,
146:38 - we can see there's some type annotations, right.
146:41 - So all these type annotations comes from the schema here that we have defined.
146:46 - So that's a very useful feature for ORMs.
146:49 - So we'll pass in the, sorry, we'll pass in the file key to be the file key itself.
146:55 - We'll pass in the PDF name to be the file.name, file name.
147:01 - Then we'll pass in a PDF URL, right.
147:05 - So remember, we wrote a function within our S3 that helps us get back the, sorry,
147:11 - this S3, we wrote a function that helps us get back the S3 URL from the file key.
147:16 - So we can actually use that.
147:17 - So we get S3 URL, pass in the file key.
147:21 - And lastly, we need the user ID.
147:23 - So how do we get the user ID?
147:25 - So what's that called?
147:27 - Clerk actually also provides us with an auth function, right.
147:31 - Remember, we used the auth function just now.
147:32 - So we can do await auth from a clerk says next.js, right.
147:39 - So this will return us back with the current user ID.
147:42 - So just in case here, just in case user ID doesn't exist.
147:47 - So if not user ID, that means they're not authenticated.
147:50 - We just return a next response.json saying that the error is unauthorised
147:56 - and passing a status of 401.
147:58 - So now everything works fine.
147:59 - Everything works perfectly, right.
148:00 - We can see that we're able to get the user ID from clerk to protect our API.
148:06 - We're also able to get insert into our database.
148:10 - So actually want to return, we want to return the inserted chat ID.
148:14 - So we can do returning, returning, right.
148:17 - We pass in the, want to return the inserted ID if we change the ID.
148:24 - So with here, we can actually destructure the cons chat ID equals to this.
148:32 - Okay, so this chat ID over then will give us back this inserted ID.
148:39 - So we can just return, finally, we can just return next response.json, right.
148:46 - We want to pass in the chat ID to be chat ID index zero dot inserted ID, right.
148:54 - Because how it works is that this DB dot insert of values, right,
148:57 - this returns an array of all the inserted values.
149:00 - But in this case, we only inserted one value.
149:02 - Therefore, we want to index into zero and then we want to get this inserted ID,
149:06 - which is what we return from here.
149:08 - So this is how we actually get the chat ID from Drizzle or AMP.
149:12 - Then we can just pass in the status of 200 to make sure that,
149:18 - to tell the front end that, okay, everything is going fine.
149:21 - Okay, so I think everything looks perfect.
149:23 - Everything looks perfect.
149:24 - And then, so we have created this create chat root.
149:28 - So now finally, let's go back to our file upload and finish up the function
149:32 - to actually create and upload the pine cone vectors.
149:36 - Okay, so if you come back to our file upload for here,
149:40 - so remember this data, this data will now contain this chat ID.
149:45 - So let us destructure this chat ID from this on success.
149:50 - So if it successfully returns, if the function runs successfully,
149:53 - then we're ensured that there's a chat ID here, right?
149:56 - So if there's a chat ID, what do you want to do?
149:59 - We're going to redirect them to the chat page,
150:03 - to that particular chat ID that has been created.
150:06 - So I'm going to do those are success first.
150:08 - I'm going to see that, okay, chat has been created.
150:10 - And then I'm going to push them there, push the router to the chat page.
150:16 - So take a cons router equals to use router.
150:20 - So import this from not next slash router, right?
150:23 - It's not next slash router, it should be imported from next slash navigation, right?
150:29 - So make sure you're importing new router from next slash navigation
150:32 - and not from next slash router.
150:36 - So after we have this router, we can come down here on success,
150:40 - we just do router dot push slash chat slash chat ID.
150:45 - Okay, then everything is perfect.
150:47 - Let's just console dot error if there's any errors.
150:51 - And let's save it.
150:52 - And I think that's it for this page.
150:54 - And then I think we're good to go.
150:56 - So I think everything will work now.
150:57 - So let's actually test it out and make sure that everything is working.
151:00 - So open up my console.
151:02 - So I'm going to monitor what was happening here.
151:05 - So I'm going to actually come back to my app.pinecone.
151:10 - App.pinecone.io.
151:13 - Do I have it here?
151:14 - So I'm going to go into my chat PDF pinecone index.
151:18 - So right now we can see that I have 578, sorry, 578 vectors.
151:23 - So if everything goes well, and I upload a new file,
151:26 - the vector counts should increase because I'm pushing new vectors into the database, right?
151:30 - So I'm going to come down to my chat PDF YouTube.
151:32 - I'm going to go to, I'm going to drop my PDF here.
151:35 - And let's pray to God that it works.
151:37 - So I'm going to upload my edge runtime for cell docs.
151:40 - It's going to be spilling the tea.
151:41 - So right now we can see that it's hitting the create chat endpoint.
151:44 - So let's look at the console logs to make sure that everything is working fine.
151:48 - So let's hope that it works.
151:57 - So now we can see that it says inserting vectors into a pinecone.
152:02 - So you saw just now inserting vectors into pinecone.
152:06 - So then everything is working perfectly, right?
152:09 - So if I come back here, I should see that it has now increased to 591.
152:15 - So that means it works perfectly.
152:17 - And we have created the chat and has been pushed into the database.
152:21 - So that works perfectly.
152:22 - Everything is going really smoothly.
152:23 - So in the next part, we'll be creating the chat page.
152:27 - All right, so now that we've completed the pinecone uploading,
152:29 - let's actually work on the chat pages.
152:32 - So I think from here onwards, it's going to be much easier.
152:35 - So if you're able to understand the first part here,
152:37 - I think from now on, it will be much more fun.
152:40 - Okay, so to create a chat page, come down to your app, right?
152:44 - Come down to your app, and we'll be creating a new folder called chat, right?
152:51 - And this chat will have a wildcard that says chat ID.
152:54 - And reading this chat ID will have a page.tsx.
152:58 - So this is a special wildcard within the app browser,
153:00 - so that this maps to like slash chat slash whatever here.
153:04 - So we're able to get this ID from the URL.
153:09 - So we'll do tsrefce, right?
153:11 - So that we can get the, can we get the arrow function?
153:15 - Let's do a chat page.
153:17 - Okay, I'm going to save this file.
153:19 - Then I'm going to close the sidebar.
153:21 - Okay, so now let me refresh the page.
153:24 - And right now we'll be showing the chat page here.
153:26 - Okay, that's perfect.
153:28 - So how do we actually get the ID, the chat ID from the params?
153:32 - So within the props, right, next is actually provides us with the params within the props.
153:38 - So we'll get the params object.
153:40 - And then within it, we'll have a chat ID, which is a string.
153:44 - So this chat ID will come from whatever is in the square bracket.
153:47 - So whatever you name here has to match this chat ID.
153:50 - Then with that, let's actually just display the params, right?
153:54 - Within the params, we can actually obtain the chat ID.
153:57 - So let me just display the chat ID here.
154:00 - So if I save it here, I should show a index of ID of one.
154:05 - So if we go to like, let's say ID of four, then we can see it is four, right?
154:10 - So in this case, only chat ID of one exists.
154:12 - So let's actually do the starting for this.
154:15 - So the first thing here I'm going to do is I'm going to try to get the const user ID from the auth,
154:23 - await auth from clerk slash next-years.
154:27 - So to use these, we have to convert this into a server component.
154:30 - By marking it as async.
154:32 - So we'll do const user ID.
154:35 - Then we're going to check if not user ID.
154:37 - So if they are not authenticated, we don't want them to be here.
154:40 - So we're going to just return redirect.
154:42 - So this redirect comes from next slash navigation, redirect them to slash sign in.
154:49 - Then we can try to get all the chats that the user has, right?
154:54 - So because we want to show like the sidebar, the chat sidebar,
154:57 - we can see it shows the chat sidebar with all the chats, right?
155:00 - All these chats, let's actually get that page.
155:02 - So we'll do const and just call chats equals to await DB, right?
155:09 - DB from our DrizzleRM dot select from the chats which imports from the schema, right?
155:19 - Let me just put this aside a little bit more.
155:21 - We're going to do equal.
155:25 - So this equal comes from DrizzleRM.
155:27 - So equal when chats dot user ID equals to user ID, right?
155:33 - So this is very similar to a normal SQL statement.
155:36 - So select from chats where chats dot user ID equals to user ID.
155:41 - So make sure that you can see the difference between these chats and these underscore chats.
155:45 - These chats actually come from the schema.
155:47 - So if we press and see, this is the schema that we have defined, right?
155:51 - That's why we're able to access the user ID here.
155:53 - Whereas this underscore chats is the list of all the chats that return from the database, okay?
155:58 - So with that, we can check if not chats.
156:01 - So if basically there isn't any chats, which is return redirect to slash, okay?
156:09 - But then the thing is, if within the chats, there isn't a valid chat ID, right?
156:14 - That means we couldn't find the chat ID within the owner's chats.
156:18 - Then obviously something is wrong again.
156:19 - So if not underscore chats dot find, right?
156:23 - Chat where chats dot ID equals to chat ID.
156:27 - So if you can't find a valid chat ID, right?
156:30 - So what's the issue here?
156:31 - Right now this, let me see, this chat ID is an integer, is a number.
156:36 - So we actually want to parse this into an integer.
156:41 - So parse int here.
156:44 - So if I can't find anything, I'm going to do the same return redirect to slash.
156:49 - Okay, so with that, let's actually start styling it.
156:52 - Let's do return and I have a upper div, a very big div here.
156:57 - There's a class name of flex max height of screen and overflow of scroll.
157:05 - Of scroll, okay.
157:08 - Then within this div, let's actually have this another div.
157:14 - This div will have the class name of also facts width of full max height of screen also as well as overflow scroll.
157:28 - Okay, so then within the big div, we have a smaller div.
157:33 - So we'll speed it up in three sections.
157:37 - Let me just label it so that we can see it properly.
157:39 - So we have a chat sidebar.
157:40 - Chat sidebar, then we have the main PDF viewer.
157:45 - And then we have the chat component for them to chat with chat GPT.
157:51 - Okay, so within the first div here, let's give you a class name of flex dash one.
157:59 - So it's going to take up one unit of space.
158:01 - We give you a max width of XS and then we'll just create a chat.
158:07 - We want to have a chat sidebar component.
158:12 - So we'll create this component later.
158:14 - For the PDF viewer, for this div, we'll give you a class name of max height of screen, padding of four, overflow of scroll as well, and then flex of five.
158:26 - So it takes up five units of space instead.
158:28 - So we have a PDF viewer here.
158:32 - So we create that component later.
158:33 - For this chat component, lastly, for the div that's wrapping it, we'll give you a class name of flex dash three.
158:40 - So it takes up three units of space, border left of four and border left of slate 200.
158:49 - Then we'll have the chat component.
158:54 - Okay, so let's create a chat sidebar first.
158:57 - So come down to your components folder.
158:59 - Let's create a component called chat sidebar dot TSX.
159:07 - So TSRAFCE to create the sidebar itself.
159:11 - Okay, so this sidebar is going to take in a few props.
159:15 - It's going to take in the list of chats and the active chat ID.
159:19 - So we want to have all the chats here, but also to know which chat is the active one.
159:23 - So for this, we want to take in the chats.
159:26 - So be a list of chat, but how do we know where this chat was?
159:31 - What's the type of the chat, right?
159:32 - How do you get the type of the chat?
159:35 - If you come back to our schema.ts, we can actually export the type out from the schema, right?
159:40 - So we can actually do, how do we get this?
159:44 - Okay, so in order to get the type of these chats, we can export a type called a drizzle chat.
159:53 - And we can do type of chat dot dollar sign, a dollar sign infer select.
160:00 - So this will give us the proper type of chat.
160:02 - So we get all this type script here.
160:04 - So let's save this.
160:06 - And then now let's go back to our chat sidebar.
160:09 - So this chat will be a list of drizzle chats.
160:13 - So we import it from our schema, right?
160:16 - And then obviously we have the chat ID, which is going to be a number.
160:25 - So with that done, let's actually style the chat sidebar.
160:29 - So we can obtain a few things.
160:31 - We obtain the chat as well as the chat ID.
160:35 - So for the chat sidebar, let's actually just make it into a client component.
160:43 - So later on, cause we want to have a striped subscription, right?
160:47 - So the button that triggers a striped subscription requires the client component.
160:52 - So let's do a wrapping diff.
160:55 - So this diff will have a class name of width of full, height of screen, padding of four,
161:03 - text gray of 200, and also background of gray of 900.
161:08 - So we have a darker background.
161:09 - Now within this diff we have a link from next slash link, next slash link, sorry.
161:18 - So this will lead us to, it will lead us to href slash, right?
161:25 - So this will contain a button, sorry, button from UI slash button.
161:30 - It will create a new chat, create a new chat.
161:36 - So when they click on this button here, here, if you see in that example,
161:40 - it brings them back to the homepage.
161:41 - Okay.
161:42 - So within this button, let's just style it a little nicer.
161:46 - So we have a plus circle icon from a Lucid dash react, but just plus circle.
161:52 - And then we'll give you a styling of, let's say margin of two, width of four and height of four.
161:59 - So let's see that.
162:00 - And right now we have a, we actually need to import the sidebar.
162:05 - So let's go to page dot TSX.
162:07 - So let's import the, the chat sidebar.
162:10 - Okay.
162:11 - So let me just move this down here, uncomment this.
162:14 - So let me import this chat sidebar.
162:16 - So it needs a few things, right?
162:17 - It needs the chats.
162:19 - So these chats will come from this underscore chats.
162:22 - And for the chat ID will come from pass in of the chat ID.
162:28 - So I mean, save this and hopefully something will show up right now.
162:32 - Okay.
162:32 - So, okay.
162:34 - So now I have a button that shows new chat.
162:37 - Okay.
162:37 - So the way I'm going to do this, I'm going to expand this screen so that we will see the whole screen,
162:41 - because it's supposed to be a big layout, right?
162:43 - So I'm going to come back to my VS code instance and we'll keep coding.
162:48 - Okay.
162:49 - So the next step here is for this button, let us actually give you a class name of,
162:54 - sorry, let's give you a class name of width of four border dashed.
163:00 - Uh, let's give you a border of white and border.
163:05 - So if we save this, right, we can now see that hopefully it will have a nicer styling with a
163:11 - dash border around it.
163:12 - Okay.
163:13 - That's perfect.
163:14 - Okay.
163:15 - So then, uh, below this link, let's actually map to the, map to the different chats.
163:20 - So we'll enclose this entire chat array into a flex dot flex call.
163:25 - So it'll be a flex column and we'll give you a gap of two and margin top of four within this
163:31 - diff.
163:31 - Let's actually map to the chats.
163:33 - So chats dot map.
163:35 - So for each chat, let's see what we want to return.
163:38 - So we're going to return a, uh, we're going to return a link itself.
163:43 - So this link will have a key of chat dot ID, but also a href of, uh, slash chat slash
163:50 - chat dot ID.
163:52 - Right.
163:53 - Okay.
163:54 - So within this link, let us have a diff, right?
163:57 - This diff will contain a class name of rounded LG large.
164:05 - Uh, then within this diff, let's actually put a P tag.
164:10 - That is the chat dot PDF name.
164:14 - Okay.
164:15 - Above the P tag, let us put a new nice message circle, uh, icon from Lucy react.
164:20 - Let's start it.
164:22 - Margin of two.
164:23 - So let's save it.
164:24 - And then if you come back here right now, it's going to look kind of weird because
164:29 - we only have one chat and also it's not properly stopped.
164:32 - Okay.
164:32 - But at least something is, is happening.
164:34 - Right.
164:35 - So let's start this paragraph tag.
164:36 - Okay.
164:37 - So this paragraph tag, we're going to give you a class name of, uh, with a full overflow of
164:43 - hidden, uh, text SM truncate.
164:47 - So if it's too long, we want to, uh, truncate it and we'll do white space,
164:52 - no rep and also text ellipses.
164:56 - Okay.
164:57 - Uh, for this, uh, upper diff with the rounded large, uh, rounded large, right?
165:04 - Actually I'm going to just convert this, remove this.
165:06 - I'm going to wrap it into a JSX and I'm going to call the CN function.
165:10 - So remember this CN function from the, from a shared CN that you created for us?
165:15 - We can use that right now.
165:16 - So the first thing here, let's put a rounded large.
165:20 - Let's give it a padding of three text late of 300 and also flex and items center.
165:27 - Okay.
165:28 - Then we're going to add a second parameter in the object.
165:31 - So I'm going to put BG blue of 600.
165:33 - So if it's the active, uh, chat, so I'm going to put if the chat ID equals to chat ID.
165:39 - So if it's an active chat, I'll give you a background blue and give you a text of white.
165:45 - Right.
165:45 - But if it's not the chat ID, then I'll put hover text white.
165:49 - And we'll just put the negation of that.
165:52 - So if I save it, so if it's the active chat, it should be blue.
165:56 - So right now, because it is active chat, it should be blue.
165:59 - So let's wait for it to reload.
166:01 - Let's see.
166:01 - Okay.
166:02 - So perfect.
166:02 - Now it's working.
166:03 - So it's blue color right now.
166:05 - Okay.
166:06 - So everything's working fine.
166:08 - So let's now comment of the, let's come out of this diff, uh, come out of this
166:13 - diff that reps the flex call.
166:16 - Right.
So let's collapse it.
166:17 - So below the, just above the closing diff, let's have a, let's actually put some text here.
166:24 - So let's put a diff, uh, that has a custom of position absolute bottom of four and left of four.
166:35 - And we'll have a diff, another diff that reps our links.
166:41 - So this link can just, uh, just link back to like home.
166:46 - Right.
166:46 - Or then we have a hs of just slash and then we can maybe have another diff to like whatever
166:52 - source code you want.
166:53 - Just put source and any logos that you want to put here.
166:56 - Right.
166:56 - So later here, we'll be putting our stripe button.
167:01 - Right.
So then we allow them to upgrade their account by pressing this button.
167:05 - So I'm going to give you a little styling.
167:07 - So for this, a wrapping diff here, let's give a style of flex items,
167:11 - dev center, um, gap of two, text of SM, text slate of 500 and flex wrap.
167:23 - So let's save this.
167:24 - And hopefully there's a nice icon.
167:26 - There are nice texts that shows up in the bottom left corner.
167:28 - So we're just waiting for it to reload and hopefully it reload.
167:32 - And now we can see that it just brings us to the home and the source page.
167:35 - Okay.
167:36 - So I hope everything is clear and understandable to you for now.
167:40 - Okay.
So we have completed the chat sidebar.
167:42 - Okay.
167:43 - So now that we have completed the chat sidebar, let's actually go on to
167:46 - create the, uh, PDF viewer, uh, PDF viewer here.
167:49 - Okay.
167:50 - So I'm going to come back down to our VS code instance.
167:55 - So come down here and let's create a new component called PDF viewer dot TSX.
168:01 - Okay.
168:02 - So for the PDF viewer, it's going to be a very simple component, right?
168:06 - Uh, let's just do the same, the same thing.
168:10 - So we'll do TSRAFCE to create the TypeScript component for us.
168:16 - So it's going to take in a prop, right?
168:18 - It's going to take in the PDF URL.
168:20 - So it's going to be a type of string.
168:21 - So let's just destruct right here.
168:22 - PDF URL.
168:24 - So we're going to return just an iframe, a normal iframe, right?
168:28 - This iframe is going to have a source of the, so we're going to be basically using
168:34 - Google, uh, I think Google provides us with a free, I don't know if it's free.
168:38 - I don't know how it works, but it's, uh, it allows us to use Google Docs, uh,
168:43 - uh, PDF viewer to show our SG PDF.
168:46 - So for the source, you just put HTTPS, colon, slash, slash, docs, dot,
168:50 - google.com slash G view, right?
168:54 - And you pass in the URL to be our PDF URL.
168:58 - And then lastly, we want to do, uh, make sure that embedded, it goes to true.
169:02 - Right?
169:03 - Then we'll give you a class name of, uh, with a full and height of full.
169:07 - That's, that's all there is to here.
169:09 - So let me just, sorry, height of full.
169:12 - So save it, come back to our page dot TSX here and remember this PDF viewer.
169:18 - Let's uncomment it out, imported from our components, passing the PDF URL to be the,
169:23 - uh, so how do we actually get the, uh, sorry, how do we actually get the PDF URL?
169:30 - Uh, let me see.
169:32 - So to get a PDF URL, we must get the current chat.
169:35 - So let me, let's get the current chat.
169:37 - So we do cons current chat equals to, uh, chat dot find, sorry, find chat where chat
169:46 - dot ID equals to pass in chat ID.
169:51 - So we're just looking through the, the chats that we get back from the database
169:55 - and we just find the one that is matches the chat ID in the URL.
169:58 - So then for the PDF URL, we can just pass in current, uh, chat dot, uh, PDF URL.
170:06 - So this, this might be now, right?
170:08 - So then we can just do, if it doesn't exist, we'll just pass in an empty string.
170:12 - So let's save this and hopefully we're able to see the runtime docs.
170:18 - So I'm going to just refresh the page and then we'll be able to see the, the PDF embedded being shown here.
170:25 - So let's wait for you to load.
170:26 - I think VS codes are low. My, my computer is running a little slow here.
170:31 - Okay. And so, yeah, it works.
170:32 - So now we can see that the docs is being embedded into our iframe,
170:37 - which is being imported into our component here.
170:40 - Okay. So that's for the PDF viewer.
170:42 - All right. So, uh, now that we have completed the chat sidebar and the, the,
170:47 - basically the main PDF viewer, let's actually work on the chat component here
170:50 - so that we able to ask any question we want.
170:52 - And we have that nice, uh, streaming effect back from a chat GPT, right?
170:57 - So we'll be using, uh, Versailles AI SDK for this.
171:00 - So if you search for your AI SDK, it's a very new SDK that is just released in, uh, June.
171:06 - Yeah. In June 15th.
171:08 - So I did a video just yesterday about this library.
171:11 - So yeah, a bit of, uh, we're working you through how we actually create that,
171:15 - this whole, uh, chat GPT effect from, uh, from scratch with the help of this library.
171:20 - So this library actually abstracts away a lot of the, the knowledge needed to create a proper UI
171:25 - and to actually integrate different last language models into our application.
171:29 - So I'll be working you through that.
171:30 - And I'm going to show you how easy it is to actually create that chat GPT effect.
171:34 - So the first step here is to actually, uh, let us create that chat component.
171:38 - So right now here, we can see that we have this chat component.
171:40 - So let's come down to our components folder and let's create that chat components.tsx.tsx.
171:47 - Let's go TS array FC for the, uh, uh, component.
171:53 - So let's save that first, come back to our page.tsx and now we can just import the chat component.
172:01 - Okay. So with that chat component, let's actually begin, uh, begin the thing.
172:06 - Okay. So, uh, let me, for now, I'm going to go into my chat component.
172:10 - I'm going to make this into a client component.
172:13 - Okay. So another thing I need to do is I'm going to come down to my terminal and install, uh,
172:19 - let me just move this here. So we'll see it. NPM install AI.
172:24 - So my face is broken, but here, so it's just a very simple command.
172:28 - So this AI is the Versailles SDK.
172:31 - So let's install it and then let me move myself back here.
172:35 - Okay. So I'm going to collapse this.
172:37 - So we're going to first, um, set up the UI for this.
172:40 - Okay. So within this, uh, check component, let's return a diff with a class name of, um,
172:50 - relative, um, max height of screen and overflow of scroll.
172:58 - Within the diff, uh, let us have another diff.
173:02 - So this is for the header, right? So let's put here, uh, a hit three that says chat, uh,
173:11 - give, we'll give this class name of sticky. So it will stick to the top.
173:14 - We'll give you a top of zero. So it sticks to the top or so, and also insert X of zero.
173:19 - So this is a shorthand for basically putting left of zero and right of zero.
173:23 - And then, uh, let's say we give it padding of two, background of white and height of fit.
173:28 - Fit. Okay. So this history, let's give you a class name of text dash XL and font of bold.
173:37 - So if we save this right now, uh, we just have this, uh, check component and it should show,
173:42 - it should show the, the chat, uh, message here soon.
173:46 - If we wait for it to compile and load. So I mean, just let's give you a second.
173:50 - So I'm going to refresh the page and hopefully it shows up here.
173:53 - Sure. Okay. So the check is shown here.
173:56 - So we make sure that everything is working and the PDF still loads.
173:59 - Okay. That's good. So below this diff here,
174:03 - I'm going to have a create another component just for the message list.
174:07 - Okay. So I'm going to create a component later, but below that, let's actually create a form,
174:13 - a form within this form will have an input, right? So this input, let's actually install the
174:18 - input from set cn. So we'll do MPX set cn UI at latest at input. Okay.
174:25 - So then we can, uh, able to download the input component from set cn press enter and press,
174:30 - uh, yes, when it prompts you to, so it installs it to our local system.
174:35 - Okay. So here, let me just import the input component from our CUI library.
174:41 - So let me just format this. Oops. Format. Okay.
174:44 - Okay. So let me just destructor a few things from, uh, the Versailles SDK.
174:50 - So import a few things from AI slash react. So actually we only need one thing.
174:57 - It's called use chat. So this use chat actually gives us a lot of functionality to create that
175:02 - streaming UI for chat GPT experience. So let's destructor a few things from this,
175:08 - uh, use chat feature function.
175:10 - So we actually mainly need four things. We need, um, the input and also the handle input change.
175:19 - Okay. So for this input, let us pass in the value to be input and the unchanged to be
175:25 - handle input change. So all these two things are doing is, is giving control to Versailles,
175:32 - is giving control to GPT to control the input here. And then for the form, so whenever we submit
175:38 - on submit, right, we can actually destructor one more function here for handle submit.
175:42 - So it just helps us like deals with all the different submit, uh, submit, um,
175:47 - functionalities for us. Okay. So then, uh, with this form completed, right, let's, let's go into
175:54 - the input. I start with a little better. So we give a placeholder of ask any question and let's
176:01 - give you a custom of with full. Okay. So, uh, for this, uh, for this form, uh, let's actually give
176:10 - you a few classrooms. Uh, we give you a sticky. So when the stick to the bottom of the screen,
176:15 - so bottom of zero, inset X of zero, padding X of two, padding Y of four and background of white.
176:22 - Okay. Below this input, let's have a button, uh, this button from us button. Let's just put a
176:30 - send icon, send, sorry, send icon from Lucy dash react. We give you a custom of height of four and
176:37 - width of four. The bottom of a custom of BG blue of 600 and also margin level of two. So I'm going
176:45 - to save this and okay. So right now is it has an input showing up. So we'll wait for the, the
176:50 - styles to update and then it will show up in the UI. So while this happening, okay. So what this
176:56 - use chat function does for us is that it actually gives us back one more lasting is the messages
177:02 - array. So this is where the magic happens. This messages array is a array of messages. And basically
177:07 - what it does is it just, uh, it allows us to look through these messages and display it in our front
177:12 - end however we like. So if you actually inspect, uh, these messages, so let's just do messages
177:18 - index zero, and we do dot, we can see that the content, we can even see the row, right? So this
177:24 - content is like, uh, the text content of it, but the row here, we can see that it can either be
177:29 - assistant or user, right? So assistant is like the AI reply and the user is whatever we send to
177:35 - the GPT. So based on whether it's assessor or user, we can render different, uh, styles for our
177:40 - messages. So this is exactly what we're going to do for the message, this component. So what I'm
177:45 - going to do here is going to come down to, uh, come down to my component and for other component,
177:50 - let's create the message, uh, list dot TSX. Let's do T-S-R-A-F-C. Okay, so create a component.
178:02 - So the first thing is I save this and let's actually import the message list,
178:06 - message list component from our component. And remember when we pass in the messages,
178:12 - when we pass in these messages from the use chat hook that we got from Versio AI SDK.
178:17 - Okay. So let me just go into message list. Okay. For the message list, for the props,
178:23 - let us actually get the messages. It's going to be type of message. So this message type will come
178:30 - from AI slash react, which is perfect. So it's going to be an array of messages. So let's actually
178:35 - destructure the messages. So then let's do the styling. So, uh, I'm going to do if not messages,
178:44 - I'm going to just return an empty fragment. So other than that, if messages do exist,
178:50 - let's do a create div with a custom of flex, flex dash call, gap of two and padding x of four. Okay.
178:59 - So, uh, yes, yes, yes. Okay, cool. Then within here, within this div, let's actually map through
179:08 - the messages. For each message, let us just return a div with a key of message.id. So let's close this
179:22 - div off. Okay. Within this div, let's actually give you a few class names, class name. Okay.
179:30 - So we're using a CN function from utils. So for now, it's going to be flex box, right? But the
179:36 - thing is, uh, we're going to justify it to the end and if the message dot row equals to user.
179:46 - So why this is saying is that if it's a user message, I'm going to push the message all the
179:50 - way to the, uh, right of the screen, right? So let me just show you how it would look like.
179:55 - So if it comes to the original here, we can see that because it's a user message, I push it,
180:00 - I align the message to the right. If it's an AI message, I push it to the left. So right now,
180:05 - why is this button here misaligned? So let's, let's look at why that is check component.
180:10 - So I think what I did here was I forgot to wrap it in another, uh, flex box, right? Yep. So here
180:19 - inside this form, I should wrap it into a flex box that wraps the input and the button so that
180:24 - it aligns together. So in the meantime, we'll pass in the messages into the message list.
180:30 - Okay. So let's save it. So now let's go back to coding. Okay. So if, if it's an AI message,
180:40 - let's actually just do justify dash start if the message dot row equals to assistant. Okay.
180:48 - So let's add one more style here. We're going to give you a padding left of 10 and padding
180:53 - right of 10 below here. So within this div, we can actually display the message content.
180:58 - Um, so we have a div, uh, which will have a class name of rounded of large. Okay. Within the,
181:09 - uh, rounded large, let's actually create a paragraph tag that shows the message dot content.
181:17 - Okay. And then here, actually for this div, uh, instead of putting into a string, let us
181:24 - put in JSX cause you want to use the CN function. So first thing we're going to have the, uh, rounded
181:30 - that's large. That doesn't change, but for the second object, we actually want to color it blue
181:35 - if the message row is user. So, um, we'll do bg sorry, bg dash blue dash 600 and tags of white.
181:45 - If the message row equals to user, right. So for the other than rounded large,
181:50 - let's give you some more style. So padding X of three, tags SM, padding Y of one,
181:56 - shadow of medium, ring one, ring dash gray dash 900 divided by 10. Right. So let's save this.
182:05 - And that's, uh, that's it for the message list. Okay. So that's good. That's good. So right now,
182:11 - obviously we will not be able to see anything cause we do not have any messages showing up.
182:16 - Right. So how do we actually do the messages? So how it works is that if you come back to this
182:21 - check component, we can see that this use chat, right by default, let's see, we can show you,
182:25 - we can actually add some more configuration into object so we can pass in a lot more data, like,
182:30 - uh, the API. So this API is going to default to slash API slash chat. Okay. So we have to actually
182:37 - create this endpoint so that, uh, whenever we hit enter, it will send the message to our chat GPD
182:44 - endpoint and then it will return us with the streaming output from chat GPT. So let's create
182:49 - this endpoint. So I'm going to save it, come down to our app, right under our API, let's create a
182:54 - chat folder and inside, let's press root.ts. Okay. So the root.ts is going to be pretty simple. Right.
183:04 - So first here is import. Let's import from open AI H. So cause we're using the open AI model.
183:11 - So open con or import configuration and also open AI API. So we do the same thing, right? We'll do
183:20 - cons config equals to new configuration, right? Passing in the API key to be process.env to open
183:30 - AI API key. So we already got the API key just now, so we can leave it there. Then we'll do cons
183:35 - open AI equals to new open AI con API passing the config. So one more thing here is I'm going to do
183:41 - export cons runtime equals to H. So these were the H runtimes comes in, right? Because we're using
183:47 - the open AI H, we actually mark this function as a H. So H function so that you make this
183:54 - a function much faster when we actually deploy it to Vercel. Okay. So now let's actually export
184:00 - a async function called post. We're going to take in request to be the request.
184:07 - So how this works is we're going to first get the body. So we're going to do a try catch block.
184:13 - So we didn't try it as get the body equals to await request.json. Okay. So in the body,
184:20 - we can actually destructure a few things. We'll destructure the messages array. So whenever the
184:24 - check component, right, this will handle all the logic for us. Whenever we press a submit on the
184:29 - input, it's going to send the current messages into our slash API says chat, which we will receive
184:36 - in this messages request body. Okay, then once we have the message, right messages array, let us do
184:43 - we ask open AI for streaming comp check completion. So we do cons response,
184:48 - sorry, cons response equals to await open AI, sorry, await open AI dot create chat completion,
184:58 - right, passing three things, we need a model. So the model will be using GPT-3.5-turbo. So it's
185:06 - a very fast model, but it's also very competent. Then we'll set we're passing the messages array.
185:13 - So this comes from the request body. And lastly, we want to set streaming to be true. So because
185:18 - we want like token to come back one by one. So what streaming means is that let's say I send a
185:24 - request to open AI, instead of waiting for it to generate the whole response, and then sending it
185:29 - back at once, and we have to wait for maybe a few seconds. The moment that it starts generating
185:33 - tokens one word by one word, it will start sending the one word by one word back to me,
185:37 - and able to display on the front end. Okay, so to actually create a streaming effect, all right,
185:43 - Versailles AI actually gives us utility functions to create this to get the response stream and
185:48 - convert it to a normal stream to our front end. So let's import two things from the AI library
185:54 - itself. So this AI is from the Versailles AI SDK. So we need to open AI stream and also the streaming
186:00 - text response utility function here. So first, let's get the stream to, we basically call the
186:08 - open AI stream function, open AI stream and passing the response. Then lastly, we can return a
186:15 - return a new streaming text response passing in the stream. So it will take the streaming response
186:25 - from open AI and passes it back to our front end. Then let us save this, come back to our check
186:31 - component, right, and look at the magic here, right, and believe it or not, this is all it takes for
186:36 - you to create to create chatgbt, right. So now if I try to answer any questions, so right now,
186:42 - let me ask like, hello, I send it, right. We should be able to see the chatgbt
186:48 - slowly answering back. So let's wait for the check. I can see, look, it works and that's incredible,
186:52 - like we didn't really write any like custom code. All we need to do was call some functions from
186:57 - the Versailles AI SDK is able to create that chat streaming effect for me. So I can ask like,
187:03 - how is, sorry, explain JavaScript runtime to me. So we can see that there's a streaming effect from
187:12 - a chatgbt. So what it does is it hits the backend, it hits the SAS API SAS chat, then it creates that
187:18 - streaming effect and then basically sends it to the front end and then it updates the messages
187:23 - array, right. So remember here, these messages that we got from this huge chat, right, you update
187:28 - the messages, then we pass it to the message list and then we look through the message list and
187:32 - depending on whether it was the AI responding or the user responding, we're able to create this
187:36 - beautiful, this beautiful response, right. So the issue right now is that, yes, although we have
187:42 - a nice chatgbt interface going on, this chatgbt has no idea about the PDF, right. It doesn't know
187:48 - any idea about what the PDF is talking about. So in the next part here, we're going to start
187:52 - trying to fit the context of the PDF into the chatgbt response so that it has context of the PDF.
187:59 - Okay, so, so now that we have this chatgbt interface, right, the issue right now is that
188:04 - it doesn't have context about the PDF. So let's go back to the escalator to see what we're going to do
188:10 - next. So remember now that we have all these vector embeddings documents stored within our
188:15 - pinecone DB, right. So how do we actually get the relevant vector embedding for whenever we ask a
188:22 - question? So let me, let's say the second part, right, see this search part. So the first step here
188:27 - is to embed the queries, then we can query the pinecone DB for similar vectors. So then we're
188:32 - going to take maybe like the top five similar vectors, we're going to extract out the metadata
188:37 - of the similar vectors. So we're going to take out the text content of the five, top five similar
188:41 - vectors, and then we'll feed the whole paragraph of context into the OpenAI prompt. So if you come
188:47 - back to the, if you come back to our function here in within the, the chat root, right here,
188:55 - whenever we do this, we get the create chat completion, right. For these messages, right,
189:00 - we can actually get another prompt. So we can have an additional prompt such that we're able to give
189:06 - the OpenAI context of the PDF. So that's what we're going to do next. So let's just open our
189:12 - directory and let's create that function to get the context. So close up everything and come down
189:17 - to our lib and let's create a new file called context.ts. So this context.ts is going to mainly
189:25 - have two functions, right. So it's going to have two functions. The first function is going to be
189:32 - actual async function get context. So this is the actual function to get the context of the query.
189:41 - So we'll take in the query, which is a string, right. So this query is, is basically why it's
189:45 - being passed whenever we ask a question like in this chat box here. Okay. And the second thing is
189:52 - we want to have the file key, right. So remember why we need a file key because we need a namespace.
189:58 - So remember I introduced you, I introduced the time we talked about we need this namespace.
190:04 - So not just now, whenever we push vectors within the pine cone, we actually add a namespace prop,
190:11 - right. So now we need to get the correct namespace so that we search the vector DB for the correct,
190:16 - within the correct namespace, so that we're not searching for information from other PDFs,
190:20 - right. So therefore we need, we also need this file key to get the correct namespace.
190:25 - So then to do this, let us first, so we also need a function export.
190:33 - Let me see. So this second function will be called get matches from embeddings. So this step,
190:42 - this function will take in embeddings. So it's a vector, so it's an array of number,
190:47 - and also the file key with a string. So this function is going to basically take the query
190:54 - vector, it's going to search through the pine cone for the top five similar vector,
190:58 - and then it's going to return me with the top five similar vectors. So I'm going to write out
191:03 - the code and then we'll see what it means. All right. So the first thing here I'm going to do is
191:08 - for these get matches from embeddings, so I'm going to be querying pine cone, right. So I need
191:11 - the pine cone client. So I'm going to do cons pine cone equals to new pine cone client, right.
191:18 - Then we'll do await a pine cone dot init, right. So we need the API key which is pine cone API key
191:26 - ensure that it exists. And we also need the environment, right. This environment is going
191:31 - to be the pine cone environment. So make sure you have this within your env here, right. So we did
191:37 - it just now, so it's fine. So make sure this exists. So this should be environment. Okay.
191:43 - So after initializing pine cone, let's get the index, right. The pine cone index, we do await
191:48 - pine cone dot index. So the index, remember what you name it, I name it uh chat PDF, right. So it's
191:54 - the one that corresponds to within your pine cone console chat PDF. Okay. So now that we got this
192:00 - index, let's do a try catch block. So if it fills, let's just do console dot lock, error querying
192:08 - embeddings, then we just pass in the error. Then we just throw the error back to the caller.
192:17 - Throw error. Okay. So what did I try? So first we get the namespace. So remember the namespace,
192:23 - we have to convert the file key into ASCII characters. So we import that from utils and
192:28 - we pass in the file key. And then we want to initialize a const query request, right. So,
192:39 - sorry, query result. So this query result is going to be the function is going to get back from this
192:45 - function called index dot query. So pine cone index actually has a function called query,
192:51 - right. So if we go into the object, we can see that we need a query request object.
192:55 - So within this query request object, we can pass in a lot of other vectors that we want to search
193:01 - for. So this top key basically tells, is asking pine cone how many vectors we want to return.
193:09 - So if you put top key as five, it's asking, it's saying that we want to return us with the top five
193:14 - similar vectors that matches the query embedding. Then we pass in the vector that we actually want
193:19 - to query against, which is the embedding that's passed into this parameter. And then we want to
193:25 - include metadata so that we can get back the text, the original text from the query, the similar
193:31 - vectors. And we pass in the namespace, which is from the convert to ASCII. So this query result,
193:37 - you can see that it's going to be a query response. So we can then return query result dot matches
193:44 - else and empty array. So these matches are going to return us with a top five SCOT vector. So it's
193:51 - going to be an array of five vectors because we put in top key as five, right. So then we're going
193:55 - to return this. If not, we just return empty array. Okay, so now that we have this function,
194:00 - we can actually call these get matches from embedding within this get context function here.
194:05 - So I'm going to do cons query embeddings equals await get embeddings. So we've
194:13 - written this function using OpenAI, right, then we pass in the query string, right. And then now
194:18 - we can actually call this upper function. So we do cons matches equals to await get matches
194:24 - from embeddings, pass in the query embeddings and the file key. Okay, so these matches will be
194:31 - returned from this query result of matches. Then we can do cons qualifying docs equals to
194:40 - matches.filter. So for each match, for each match, we're going to return the return if
194:53 - match.score exists, we're going to return match.score bigger than 0.7, right. So what this does is
194:59 - basically it will look through all the matching matching vectors. So if the score matches more
195:04 - than 70%, then we return it. So if it's less than 70%, it's probably irrelevant. So we just
195:09 - want to ignore that. Okay, then lastly, we can type the metadata. So remember the metadata type
195:17 - metadata, we have a text, which is a string, and as well as a page number, which is a number. Okay,
195:25 - so with that, we can then do let docs equals to matches.map matches. Sorry, we can actually do
195:35 - qualifying docs.map for each match. We can do match.matterdata as metadata. So we customly type it
195:48 - .text. So what it does is, if we go through these docs, right, then because remember we added the
195:53 - metadata before pushing into pinecone, then we can just get back the text. Then lastly,
195:58 - we just want to return docs.join, sorry, docs.join a slash n. So basically, let's say we get back
196:08 - five vectors, right. The five vectors we can basically take the five paragraphs from each
196:13 - the five vectors, then we just join it together. Then that's going to be the context block in which
196:18 - we feed into OpenAI prompt. Then we're going to substring it to 0 to 3000. So in case that the
196:25 - docs exceeds 3000 characters, we'll just cut it off because we don't want to feed too much
196:30 - information into OpenAI because then the token limit might be reached, right. So let's save this.
196:36 - So we've actually completed this function. Okay, so then let's come back to our chat's
196:43 - root. So now within here, we can actually get the context. We didn't get the context here.
196:49 - Okay, so the first thing here, what we're going to do is we need the file key, right. So remember
196:55 - what we want to do is we want to get the last message. Con's last message equals to messages
197:00 - or message.length minus one. So the last message is the message that is sent in by the user. So this
197:06 - last message is the query itself. So how do we get the context? So context equals to a way it gets
197:12 - context, right. We import it from our library context. So we get last message, right, which is
197:19 - a query. But how do we get the file key, right. Right now, we can't get a file key from this
197:23 - request body, right. So this file key has to actually come from the chat itself, right. So
197:28 - to get that file key, we actually need to go back to our chat component, right. So underneath this
197:34 - use chat, right, there's another parameter that we can pass in, which is the body, right. So these
197:40 - additional objects that can be passed back to our backend here, whenever we make the call. So we can
197:46 - pass in a chat ID, right. So how do we get the chat ID? We can get it from props. So let me just
197:51 - type it out first, and then we're able to explain how the entire flow works. So we need the chat ID.
197:57 - So if you come back to our page.jsx, we need to pass in this chat ID to chat ID. In parse int
198:08 - chat ID. Okay, that works. Then save it. So from our page.jsx, we pass in the chat ID to our chat
198:16 - component. We receive it in props. And basically this use chat, we pass it into the body so that
198:21 - we can destructuate from the request body at the backend here, chat ID. So I hope you get the flow
198:29 - of it. Okay, so how do we get the file key from the chat ID? We can query the database for this,
198:35 - right. So we do const underscore chats equals to await DB. So this from drizzle or m dot select
198:43 - dot from chats. Where? So this chats have to import from schema also, where equals chat.id equals to
198:55 - chat ID. Okay, yep. So then we're gonna check if chats.length not equals to one. So if there's
199:07 - not exactly one chat, something went wrong, we're gonna return a return a next, next response.
199:16 - dot JSON. Sorry, let's import this saying that error chat not found passing in a status of 404.
199:31 - Okay, so everything looks good. Okay, so now that we got the chats, right, we can obtain the chat.
199:38 - So const file key equals to underscore chats index zero, because we're basically getting back a list
199:46 - of all the chats that fulfill these requirements, right. So we do underscore chats dot file key. So
199:53 - this how we obtain the file key. Okay, then we can just pass in the file key into our context. So now
200:00 - this context should return us with a whole paragraph of relevant vectors and their pitch content.
200:04 - So with that, we can actually now feed it into the response. So I'm gonna just do const prompt
200:13 - equals to an object where the row will be a system. So this is us now feeding the context
200:20 - into chat GPT. So I'm gonna copy paste this prompt because I didn't write it out but I got
200:26 - it from somewhere. I got it from the Versailles AI docs, right. So I'm gonna paste this in. Let me
200:32 - just, let me just work. Okay, so basically what it does is it tells us the row is a system and tells
200:37 - it the content is telling the AI that is a powerful human-like AI. And basically what it does is it
200:44 - passes the context block, right. So this context we can see that it templates it in within a prompt
200:48 - and tells it that AI assistant will take into account any context block that is provided in
200:53 - the conversation. Yeah, so I'll post this prompt into the description below so you don't have to
201:00 - manually write it out yourself. Okay, so now that we have this prompt, we can now feed it into
201:05 - the response of this create chat completion. So for these messages, right, other than just passing
201:11 - in the messages from the request body, I'm also going to map through. I'm gonna pass in the prompt
201:17 - itself as well as all the messages, all the messages dot filter message dot a message dot
201:31 - row equals to user. So this message will have a type of message which comes from ai slash react.
201:40 - So let me import that from ai slash react. Okay, so what this does is basically for these messages
201:47 - array that is being passed into OpenAI, I pass in the prompt which is this entire context block,
201:53 - right. It contains all the relevant documents as well as I pass in all the messages that only
201:59 - belongs to the user, right. So we only care about what the user is asking. So if the messages
202:03 - contains any assistant messages, we just block it out so that we can save some context, sorry,
202:10 - we save some token space where we create the chat completion. So I hope you understand. And then
202:15 - lastly, I think that's pretty much it we completed. So then we can save this file, come back to chat
202:20 - component, right, come back to chat component and let's see if anything else is required. Okay, so
202:27 - one last thing here down to add is, let me see here, let me see, let me see, let me see. So
202:34 - whenever the message is being sent, right, is being basically entered, I want to scroll down,
202:42 - scroll all the way down, right. Because if not like, let's say I answer as a question, right,
202:46 - it does not automatically scroll down for me. So to do that, what I can do is I'm going to come back
202:51 - up to a, let me see, let me see, message. Okay, under our chat component. So for our
202:59 - wrapping div here, I'm going to give you an ID of message container, then I'm going to add a react.use
203:06 - effect, right. So basically, every time the message change, messages change, I'm going to do document
203:15 - message container equals to document dot get element by ID, right. So I'm going to get the ID
203:22 - of this div, then if the message container exists, right, then I'm going to do message container dot
203:29 - scroll, scroll to, sorry, scroll to the top should be message container dot scroll height, and
203:38 - behaviour should be smooth. Okay, so this will basically automatically scroll us down to the
203:44 - bottom of the message whenever there's a new message that comes in. So if we save everything,
203:49 - right, and let's hope that it works. So I'm going to just refresh the page right now. Okay,
203:54 - so I'm going to try everything from scratch to make sure that everything is still working as
203:58 - intended. So I'm going to press a new chat, and I'm going to wait for you to bring me back to the
204:04 - homepage. So now I'm going to upload my own custom document and let's test if it works.
204:09 - Okay, so I'm going to do drop PDF here. So let me select a relevant PDF, let's say I ask about
204:15 - my resume, because at least that's something I know will work. So it's going to be uploading
204:21 - to chat, you upload to S3, then you upload to pinecone. So let's wait for a while because it's
204:28 - running locally, it's going to be a little slower. But when we push it up to Vercel, this process is
204:33 - going to be really, really fast. So let's wait for it to load. So let me see if everything is
204:38 - working fine. Okay, so chat has been created, we can see that the resume has been uploaded.
204:43 - I can see my resume here. And so by right, if I ask the question, it should take into context my
204:48 - my PDF. So let me ask what school did I get a 10? Question mark. So let's wait for it to respond,
204:59 - and hopefully, it's able to give me something insightful. Something is breaking. So let's look
205:06 - at the error. Okay, cannot read undefined. Text.replace is not a function. Error calling OpenAI
205:14 - Embeddings API. So let's see why that is the issue. Ah, okay, so I see the issue. Right now,
205:19 - we can see the last message is this is an object itself, right? But then we should be really
205:25 - getting the message.content, right? Instead of passing the whole last message. So let's pass in
205:30 - the message.content. So let's save this. So hopefully that explains the error. So yeah,
205:37 - I'll be debugging like this. Okay, so this should work now. So I can ask, where did I get a 10
205:43 - school? Question mark. So if I send this, hopefully, if everything goes right, okay, yes,
205:49 - that's awesome. So it's able to see that it has gotten out of the context from my education
205:53 - vector within my PDF is able to give me an insightful answer. Okay, so let me ask like,
206:00 - let's see how many projects did he do? So we save that. And okay, so, okay, so I mean, obviously,
206:09 - it's not perfect, but it's able to get in context within the PDF. And that's, that's really exciting
206:15 - for me here. Okay, okay, so the issue right now is that everything is working perfectly. However,
206:19 - the moment I refresh, right, you can see that the chat log doesn't get saved, right? Because we're
206:23 - not saving the chat store database. So how to actually save the chat store database is a really
206:28 - simple thing. And that's why I really love about the Versailles AIS decay. So if you come back to
206:33 - our, you see this open AI stream, right? It actually accepts a second parameter, which is an
206:40 - object. And within this object, it gives us a lot of hooks and callbacks. So we can see that on start.
206:48 - So basically what this function, this callback does is that whenever the query has started,
206:55 - it's going to give us that prompt, right? It's going to give us the, it's going to tell us that
206:59 - it started and then we can save the prompt into our database, right? That means we can save the
207:03 - user's message within our database. So what we're going to do is, on start, we're going to save
207:08 - user message into DB, right? Then the second one is on completion. So whenever the AI, AI
207:15 - finished responding, it's going to give us the completion and then we can then save this into
207:22 - our database. So then save AI message into DB. So let's do that. It's a very simple call. So we just
207:28 - do await DB dot insert, right? Insert into our messages, sorry, messages. So we can see that
207:37 - messages right now is importing from the request body, but actually we want the messages from our
207:44 - drizzle schema. So let's get that. So instead of this chat, let's also import the messages
207:50 - and we can rename it to underscore messages so that the naming doesn't collide. Okay,
207:55 - so we can insert into messages dot values, right? It's going to take an object so we can see the
208:01 - different attributes we need. So we need first, we need a chat ID. So we have that from the request
208:06 - body. So that's perfect. Then we also need the content. So we can get that from last message
208:12 - dot content. So this is the user query. And then we can do the row, which is a user. Okay, then
208:18 - whenever it has completed, so that we can save the AI message into our database, we do this, write
208:23 - something very similar. So for this content, it's just literally completion. So completion is just
208:28 - a normal string. Okay, then that's pretty much it. So we have successfully saved the message into our
208:35 - database. Okay, so how do we actually access the messages whenever we first load here? Okay,
208:41 - that's a very simple thing to do. Let's also create let's create a new route within our API
208:47 - called get dash messages. Sorry, let's create a folder called get dash messages.
208:54 - We'll create a route dot TS underneath here. Okay. So inside this route is a really simple
209:01 - function, we just want to return all the messages for a given chat ID. Okay, so we'll do export
209:07 - const post equals to an async function. This will take in the request object. Okay, so it's just
209:18 - gonna, we're gonna get the body from await request dot JSON. So we're gonna destructure the chat's
209:25 - ID from the request body. And then we'll just do const messages equals to await DB. So we import
209:33 - this DB from adlib. And then we can do dot select dot from messages. So these messages can be import
209:44 - from schema dot where equals message messages dot chat ID equals to the chat ID pass into the request
209:52 - prep. So it really is like SQL. So drizzle. I am is cool in this in this sense. So actually, we can
209:59 - also mark this export const runtime equals to H to make this function faster when we deploy it
210:05 - because drizzle is compatible to H runtime. That's how we can do this. Then we just want to return
210:11 - next response dot JSON pass in the messages. Okay, so let's save this. So now we got to call
210:21 - this function, call this route from the front end, right. So this check component, we can see that
210:26 - for this use check, right, there's one more thing that we actually pass into this check component.
210:32 - Within our object here, we can pass in a other than the body here, we can pass in an initial message
210:40 - messages, which can be an array, right. So how do you get back these initial messages,
210:44 - we can just do a call to our endpoint just now. So we'll do that from a use query. So this from
210:50 - React query again, use query. Okay, we're passing the query key, right. So this key is to uniquely
210:57 - identify this query made to the back end, right. So query the chat ID. And then so this can be
211:05 - anything, right, this is not important, the query key doesn't make much of a difference. So the
211:09 - query function is what is being called to get the messages. So we'll do const response equals to
211:17 - await axios.post to slash API slash get messages, right. We can pass in the chat's ID, right. And
211:28 - then we can pass in a generic so that this will always ensure that it's going to be a message
211:34 - array. So then this message array that we get back here, this response.data. So let me just return
211:40 - response.data. We can see that this response.data will have a type of message array, then we can
211:47 - just pass in this data. So let's destructure the data from here. This data will have the message
211:52 - array, right. And with this initial message, we can just pass it here, data, if not passing the
211:58 - empty array. Yeah, that's all there is, right. So one more thing here is, let us save that first,
212:06 - and let's make sure that it works. Okay, so I'm going to refresh the page, refresh the page,
212:11 - and then I'm going to wait for it to load. And then I'm going to ask the question, and hopefully
212:16 - it saves my query to the database. Okay, so I'm going to ask you a question like, where did he
212:23 - intern at? Okay, so it should return me with the response, then if I refresh the page, hopefully
212:31 - this chat will, okay, so it works. So when I refresh the page, you can see that it gets the
212:36 - messages that stop within the database, it passes it passes the array into the use message hook,
212:41 - so that it renders the initial messages. That's good. So one more slight UI improvement that I
212:47 - just want to make a very simple one is just to while I'm fetching the data is loading, so I get
212:53 - is loading from this use query, I'm gonna pass it into my message list. So pass is loading to
213:01 - is loading. Okay, I'm going to go into my message list, I'll accept this as props is loading,
213:06 - it's gonna be a Boolean. Okay, then I just want to, if it's loading, I just want to show a loading
213:12 - spinner. That's pretty much what I want to do. So I'm gonna show if is loading. So let's
213:18 - distract it from the props itself is loading. I'm gonna return a div. Sorry. So I'm gonna return
213:29 - a div with position absolute, right, we'll give you a custom of top of half, left, sorry,
213:36 - left of half, negative translates x of half, negative translates y of half, then inside here
213:43 - I'm going to put a loader, a loader to imported from Lucid React. Let's give you a custom of width
213:49 - of six, height of six and emit spin. So this is just that when it's loading the initial messages,
213:55 - it will, there's a nice loading effect, refresh the page again. Okay, so I guess there's a side
214:03 - flash of the loader if you can see carefully. But yeah, so that's, that's pretty much what we need
214:08 - to do to get the database to save the chat logs. Alright, so we're almost basically done with the
214:15 - project, like the main functionality of the chat to BGF has been finished. We have been fully
214:20 - implemented by now. So the last part here is I'm going to teach you how to implement Stripe into
214:24 - this product to really make it into a software as a service for you to market it and improve on it.
214:29 - Okay, so the first step to integrating Stripe is let's install the Stripe package. So we do npm
214:36 - install Stripe. Okay, then let us come down to, let's actually clear out all the files here so
214:42 - that we start fresh. Okay, so come down into your schema.ts here, we can create a new user
214:48 - subscription schema to store records of whether a user has paid for the pro subscription or not.
214:54 - Okay, so within your schema.ts, we can export a new, sorry, export a new table called user
215:03 - subscription. So export cons user subscriptions equals to a pg table, user sub, sorry, user
215:13 - subscriptions. Right. And then for within the object, the columns will have ID. So the serial ID,
215:21 - which is a primary key, we have a user ID, which is a var char of a user ID. And let us just give
215:28 - you a length of 256 characters. Okay. Then we'll have a sorry, we'll have to make this not now,
215:38 - as well as this issue has to be unique. Sorry, unique. Okay. Then for the user ID, we have a
215:48 - Stripe customer ID, right? This will be a var char as well. We'll give you a Stripe customer ID.
215:57 - And then we'll have a length of also 256. Okay, this has also not to be not now as well as unique.
216:04 - Okay, then we'll have a Stripe subscription ID. There's gonna be a var char of Stripe subscription
216:14 - ID. Let's give you a length of 256. However, this time, this few could be now. So yeah,
216:23 - but we still want it to be unique. Then we have a Stripe price ID, a var char map to Stripe price
216:30 - ID within the database. We'll give you a length of 256. And this could be now also. Then lastly,
216:37 - we have a Stripe current period n. Let's give you a timestamp of Stripe current period n.
216:46 - And let's make this nullable. So with that, out of the way, let's save this file. So we have created
216:52 - this user subscription table. So now let's actually push it to our database. So we'll do the same thing,
216:57 - mpx drizzle-kit-push-pg. So let me move myself out of the way, mpx drizzle-kit-push with a
217:06 - pg command. So we have already done this before. So with that, let's just press enter and hopefully
217:10 - that it works. Okay, so changes has been applied. So perfect. So the migration has worked. So now
217:16 - let's close the terminal. So now a new table has been created within the neon database.
217:20 - Okay, so come on to your folder. Come on to your lib. Let's create a Stripe.ts. So this is going
217:28 - to contain our initialization of the Stripe library. So the first thing here is let's import
217:35 - Stripe from the Stripe package that we installed from npm. Then let's export const Stripe. It goes
217:43 - to a new Stripe. Stripe passing in the process.env.stripe-api-key as string. And then the second
217:55 - object, the configuration will pass in the API version. Right, to be whatever they ask you to
217:59 - enter and type script to be true. Okay, so let me just spell this right const and save it. Alright,
218:08 - so to get the API key, let's come down to our browser. Go to Stripe console. Just search for
218:16 - Stripe console within Google and come down to the first link here, Stripe login, the dashboard.
218:22 - And what you can do is you can create a Stripe account if you have not. If you have, you just
218:26 - log in. So in this case, I have already signed in. Right. And the first thing you want to do is
218:30 - come down to the top left hand corner. So I'm going to zoom in a little. And then I need to
218:35 - create a new account and name this wherever you want. So I'm going to name it chat PDF-youtube.
218:42 - Country of operation, choose the one that you are based off, then create account.
218:46 - So you might need to enter your password sometimes to access the new part of the dashboard.
218:51 - So after creating the account, you should be able to be led to the developers page.
218:56 - Right. So come to press developers and you should be able to see your API keys.
219:00 - Okay. So this is the secret key. So we need a secret key. So review the secret key and just
219:07 - click to copy to your dashboard, to your admin, your clipboard. Then we have to come back to our
219:12 - env.env. So let me just come down here and let's do Stripe. So just enter Stripe API key.
219:21 - Let's enter it here. Just the SK test. Let's save it and let's close the file.
219:27 - Okay. That's good. So now when you come down to our folder, come down to our API and let us create
219:37 - a new folder called Stripe. Within that, let's create the root.ts. Okay. So this will map to
219:44 - slash API slash Stripe. So we don't be calling this backend, right, to actually create the
219:49 - payments and create the billing accounts. Okay. So with this, let's actually start writing a
219:56 - code for this Stripe endpoint. All right. So the first thing I want to do is export a async
220:03 - function called get. So it'll be a get request. So we'll do a try catch block. So the first thing
220:09 - we want to do is we want to get the authenticated user awaits auth. So this comes from Next.js.
220:15 - So we've done this before. We'll get a user ID. Okay. So now that you have the user ID, we can
220:20 - check for the user. Cons user equals to await a current user. So this is also a function from
220:28 - clerk slash Next.js. Then we're going to check if not user ID. That means they're not authenticated.
220:35 - Let's return a new next response telling you that is unauthorized and passing a status of 401.
220:44 - So if they are authenticated, let's actually check for the user's application. Have they
220:49 - subscribed to the account? So if they have subscribed to the pro account, that means they're
220:54 - trying to cancel the account or change their subscription. But if they have not subscribed,
220:58 - that means if there's no role within the database, that means we know that they are trying to
221:02 - subscribe for the first time. So let's get the cons user subscriptions. It goes to await DB
221:10 - from drizzle dot select dot from user subscriptions. So this comes from schema dot where equals so we
221:21 - check the user subscriptions dot user ID equals to the user ID pass in from clerk here. Okay,
221:30 - so if user subscriptions at index zero, right, and the end user subscriptions at index zero
221:39 - dot stripe customer ID. So if the customer ID exists within the database, that means they are
221:44 - subscribed, they miss they are trying to cancel, trying to cancel at the billing portal. Thus we
221:52 - gotta do get const stripe session equals to await stripe. So these from our libstripe dot billing
221:59 - portal dot sessions dot create, right, passing the customer to be user subscriptions index zero
222:06 - dot stripe customer ID. And then the return URL, let's just let's actually make that into a variable
222:14 - up here. So cons return URL to be process dot env dot next public URL. Sorry, this can be named
222:23 - to next base URL. So let's create that env variable. So let's put under here next base URL.
222:30 - So this is where we want it to redirect to if they cancel or if they finish the transaction in
222:35 - stripe. So for now would be HTTP localhost 3000. Then when we deploy the versatile, obviously we
222:40 - want to put it as the versatile URL. Okay, so let's save this. So this will be next base URL
222:46 - plus slash, right, so when to return it to the return URL. Okay, then after that, we can just
222:54 - return a next response dot JSON, passing the URL to be striped session dot striped session dot URL.
223:05 - Okay. However, if this is not the first, if this is not the case, that means is the users
223:10 - first time trying to subscribe. Okay. So if that's the case, let us do
223:17 - cons stripe session equals to await stripe dot checkout dot sessions dot create. So for the
223:27 - success URL, we can pass in just a return URL. Okay, for the cancel URL, we're still gonna pass
223:35 - in the return URL. Then for the payment method, payment method types, we're just passing one type
223:44 - which is the cart, which is an accept cart. Then for the mode, you'll be subscription,
223:50 - subscription. For the billing address collection, let's put it to auto. For the customer email,
223:58 - customer email will pass in a user dot email addresses. So one user might have a lot of email
224:04 - addresses. Index zero, we take the first one dot email address. Okay, then we will do line items.
224:12 - So this is a list of items you want to buy. So in this case, there's only one item, right,
224:15 - which is the subscription. So it will be price data, right, this could be object, the currency,
224:22 - let's put it as USD, like USD for the product data. So product data is going to be object,
224:30 - the name will be chat PDF pro with the description being unlimited PDF sessions. Then outside of the
224:44 - product data, outside of the product data, let us put unit amount to be 2000, which represents
224:51 - $200, not $200, $20 a month, then recurring will set to object of the interval, meaning the month.
225:01 - Okay, so you'll recur every month. So that's how the subscription works. And then outside of the
225:06 - price data, right, outside of the price data, we'll put the quantity as one. Okay, then finally,
225:15 - outside of the line items, right, so outside of line items within this array, right, we'll pass
225:22 - the metadata, right, passing the user ID. So we need this user ID because later on, whenever we
225:29 - finish this transaction, right, Stripe is going to send a webhook back to our API endpoint again.
225:35 - And within the endpoint, we need to be able to access who actually did the transaction. That's
225:39 - why we need this user ID metadata here. So lastly, after this Stripe session has been created,
225:44 - let's just return a next response dot JSON passing the URL to be Stripe session dot URL. Okay,
225:52 - so if there's any errors, let's just console dot lock a Stripe error, passing the error,
225:59 - and we'll just return a new return renew next response, saying that internal server error
226:09 - with a status of 500. Okay, so let's save this first. Okay, so let's actually try writing out,
226:18 - try using this endpoint in our web application. So if you come down to our chat sidebar,
226:29 - right, let's come down to our chat sidebar, chat sidebar, right, we have a button below here,
226:35 - below the strike button here, that actually displays our strike button. So what I'm going
226:42 - to do here is I'm going to wrap this entire thing into a, sorry, I'm gonna move this strike button
226:49 - outside of this. And let me give it a button. Okay, of class name of margin top of two.
226:57 - Okay, this button will have a class name of text white and bg slate 700. Okay, and then
227:09 - it's gonna say upgrade to pro. Okay, so then let's create a function for the work what happens
227:20 - when we click on the button. So cons handle subscription, right, what happens is we want to
227:27 - make it an async function. Right, we're gonna do a try cat. So let us have a sorry, what's the issue
227:35 - here? Okay, here should be like this. So we'll have a state for the loading state, right, when
227:41 - it's loading the back end. So first we will do set loading to be sorry, set loading to be true.
227:47 - Then finally, we want to set loading to be false. Okay. So what we're gonna do is new cons response
227:56 - equals to await axios.get slash API strike. So this will hit the endpoint that we set up here,
228:08 - root.ts, right. And remember, it's gonna return us with a URL. So whether it's URL from here or
228:12 - URL from here, we are ensured that there is a URL. So we're gonna do window.location.href equals to
228:19 - response.data.url. So this is gonna redirect us to the strike page. So if there's an error, let's
228:26 - just console.error the error. So let's save this and let's go back to our page. So I'm gonna refresh
228:34 - the page. And let's hope that the subscription button shows up and then it is able to show us
228:39 - a subscription. Okay, so we can see this upgrade to pro button working. So what I'm gonna do here is
228:46 - I'm gonna disable this button. Disable when it's loading. Okay, so I'm gonna save it.
228:53 - So then let me just refresh the page again. So I think it's just my computer being slow right now.
228:59 - So hopefully this will work. Okay, so let me just refresh the page. All right. So when I
229:05 - press upgrade to pro, I should disable and then show me and eventually lead me to the
229:10 - strike checkout page. So I'm gonna upgrade to pro. Okay, so right now obviously nothing is happening
229:15 - because I haven't bounded the onclick handler. So let me just do onclick. I'm gonna do handle
229:23 - sub description. So let me save this. So whenever I click on this button, I want to actually call
229:29 - this function up here to redirect me to the strike checkout page. All right, so let me just
229:34 - refresh the page again. So wait for next year's load. So then once he has loaded. So if I click
229:42 - on this button, it should lead me to the strike checkout page. So click on it. So now it's disabled.
229:46 - So it's loading the backend. Then it's going to create the strike checkout sessions and return
229:50 - me with a URL. Then it's gonna redirect me and replace this whole page with a strike checkout.
229:55 - So let's wait for the next year's route to come back. So then okay, see it works. So we can see
230:02 - that it's asking us to subscribe to chat PDF pro. And here we can enter all details. So once we
230:07 - enter it, right, it's actually gonna help us send a webhook back to our application. So let's set
230:12 - up the webhook. Okay, so I'm gonna come back here. Come back to our VS code. Come back to our directory.
230:19 - We need our app. Let's create another folder called webhook. Inside here, let's do routes.ts.
230:26 - Okay, so this route.ts will be the webhook that strike is going to send back to us whenever
230:36 - the transaction succeeds or whether it failed. Alright, so let us just do export async function
230:45 - post. It's going to take the request body. So this request is going to be made by strike
230:52 - myself. So that get the body equals to await request text, right, then we do const signature.
231:00 - So let's verify that the webhook is indeed coming from strike itself. So we take headers. So this
231:06 - headers function will be imported from next slash headers. So headers, so invoke it, then we'll do
231:16 - do caters.get, stripe, signature, string, right, then we'll initialize an event, let event to be a
231:29 - stripe.event. Okay, then let us do a try catch block. So event equals to stripe.webhook. So let's
231:43 - import the stripe from our lib folder. Stripe.webhooks.construct event, right, we're passing
231:55 - the body, the sick nature, sorry sick nature, as well as the process.env.stripe.webhook-secret.
232:07 - So I'll show you how to get the webhook secret in just a bit. Let's just code it out first,
232:11 - fstring. Okay, so we construct this event and save it to the event variable here.
232:18 - Okay, so if there's any errors, that means then the struct signature didn't come through, that means
232:23 - is something suspicious going on. So let's just return a new next response, right, that says webhook
232:32 - error, passing the status of 400. Okay, then lastly, we just need to come out of this. So
232:43 - we can check for the, we can check for the session, const session equals to event.data.object
232:50 - as stripe.checkout, checkout.session. Okay, so we need to check. So if the new subscription
232:59 - is created, we'll do, we'll save it to the database. So if event.type equals to checkout.session.completed
233:09 - okay, so if the checkout is completed, we can take const subscription equals to await stripe.subscriptions
233:19 - dot retrieve. Okay, what do you want to retrieve? We want to retrieve the session.subscription
233:25 - as string. Okay, then we'll do we check if not session dot metadata dot user ID. So remember
233:36 - this metadata user ID is what we pass in to the, to this metadata here. That's why we need it to
233:43 - show here. So if the user ID does not exist, what we gotta do is we're gonna say that, okay,
233:50 - something's invalid, we'll do return new next response, saying that no user ID. Okay, then
233:59 - if everything passes, we'll just insert into database. So in await DB dot insert user subscriptions
234:07 - from the schema dot values. So we want the user ID to be the session dot metadata user ID.
234:16 - Right, then stripe subscription ID will be the subscription ID, stripe customer ID will be
234:27 - subscription dot customer as string, then stripe price ID will be subscription dot items dot data
234:38 - index zero dot price dot ID. And then lastly, we have the stripe current period n, which will be
234:44 - a new date and we'll initialize it to subscription dot current period n multiplied by 1000. Okay,
234:53 - so we've inserted into the database, right? So if it's not the subscription created, that means
234:57 - the payment has succeeded. So we gotta check if events dot type equals to invoice dot payment
235:06 - succeeded. Right. So if this is the case, we do const subscription equals to await stripe
235:13 - dot subscription dot retrieve, we're gonna retrieve succession the subscription as string.
235:20 - Okay, then we're gonna do await DB dot update user subscriptions, right? We're gonna set,
235:28 - we're gonna set the stripe price ID to be subscription, sorry,
235:34 - sorry, subscription dot items dot data index zero dot price dot ID. Then we set the
235:44 - stripe current period n to the new date subscription or current period n times 100. So it's the same
235:50 - thing as above, but we're just updating the current row. Right, we want to update it where
235:54 - the user ID, sorry, the user subscription dot stripe, stripe subscription ID equals to the
236:07 - subscription ID. So we're basically, we're gonna look at the subscription and we're gonna update
236:12 - the database based on the where cost here. Okay. Then finally, this is the most important part when
236:18 - the return a new next response, right, of now and 200, sorry, and the status has to be 200.
236:27 - So the status has to be 200 so that the webhook knows that it has finished its job. So if you
236:32 - don't return this status of 200, start noting that something is went wrong and you keep sending
236:37 - your sending messages to your endpoint until it gets a success back. So that's what the status
236:41 - 200 is for. Okay, so now that we got this, let us actually add one more thing. So come back to
236:48 - your middleware.ts. We need to add one at this root to the, we need to add this middleware slash
236:54 - epa slash middleware to the public root because stripe will be the one that's hitting this
236:59 - middleware. So we need to be public. So let's save it. And lastly, let us go into our
237:06 - stripe, stripe endpoint, stripe console here. Come up to webhooks, come up to webhooks here,
237:13 - and you will need to be able to test it here. So what's the, what's the issue here? So let's
237:18 - cancel this. So I'm just gonna stop my Next.js server for right for now because it's getting
237:25 - really slow. So come back to your stripe, stripe console. Okay, so what we're gonna do is come down
237:32 - to webhooks. We're gonna test, test in local environment. Okay, so the first step here is to
237:40 - download the CLI. So you can follow the instructions depending on whether you're on Windows, or you're
237:45 - on Mac, or you're on Linux. So for me, I'm on Mac, so I did brew install, right? If you're on Mac,
237:50 - you can just follow the instruction here, Windows. So after you have installed the stripe CLI,
237:56 - come down to your terminal and do stripe login. So come back to your VS code instance,
238:03 - and just do stripe login. So it will ask you to open this link within the browser
238:08 - to verify that you are trying to test your stripe webhook. Then just click on allow access.
238:16 - So then you are logged in within the command line. So see that the CLI is configured.
238:22 - The next step here is stripe listen too. So let me copy this command when you modify it. So it's
238:28 - saying that which, where is our API, where else was webhook listening on? So we're listening on
238:32 - localhost port 3000 slash API slash webhook. So this corresponded to our webhook here. So
238:39 - then I'm going to press enter, and basically it's going to set up a local testing environment for
238:43 - our stripe. So you can see this, it has given us our webhook signing secret. So I'm going to copy
238:49 - this whscc all the way to the end, copy it, come out to our.env, right, and then just paste it here.
238:56 - So next, sorry, it should be stripe webhook signing secret, paste it in here. So make sure
239:09 - this variable is here, and then we'll come down to our webhook. So we can see that we have this
239:15 - stripe webhook secret right here, right? So make sure that whatever variable here corresponds to
239:20 - whatever you have within the.env. So then once you have that, let us save the file, and then we can
239:26 - actually test out the webhook signing. So I'm going to come up, I'm going to open the terminal up
239:32 - bigger, I'm going to start my dev server running again. So what this is going to do is once we
239:39 - complete the checkout on the stripe page, it's going to send a webhook to our API, it's going to
239:43 - send a webhook to our endpoint, then we're going to create a row in the database, and then based
239:48 - on that, we can then check whether the user is subscribed to us. So come back here and refresh
239:53 - the page, wait for next year to compile for me. Okay, so S is compiling. Okay, so everything is
240:04 - up and running again. So I'm going to press upgrade to pro, it will then lead me to the stripe checkout
240:11 - page. Okay, so then I'm going to enter test credit card. So because we are testing, I can enter
240:18 - something like 42, 42, 42, all the way. The same here, I'll just give it my name. And let's press
240:28 - subscribe. And I need to look carefully as what happens to the backend. So if everything goes well,
240:33 - we should see 200 requests. Oh, 401. Okay, so my mistake, I made a mistake here. This should be
240:40 - access API slash webhook, right? It's not API slash middleware, so that's my mistake. So let's save
240:45 - this and let's try again. So this 401 error is unauthorized, right? So let's try again. So I'm
240:51 - going to go to my, the go to chat is not finished implemented. So let's just manually go to our
240:57 - slash chat slash one, right? Then what I'm going to do is come down to our subscription. Okay, so
241:04 - let's try again. So I'm going to press upgrade to pro, then it's going to send me to the stripe
241:08 - checkout page. And I'll try again, right? So four, two, four, two, four, two, all the way. My name,
241:16 - subscribe. So by right, if everything goes well, now we can see, we should be able to see 200
241:20 - requests coming in. Oh, 404 still 404. Okay, there's yet another very, very silly mistake,
241:28 - right? So we can see that, uh, let's actually, let me save my ENV file here. So the silly mistake
241:34 - that I've made here is that you can see that, uh, this webhook, right, it has been placed in the
241:39 - roots app folder, whilst this, uh, webhook, uh, folder should actually be placed within the API
241:45 - folder. So I'm going to move it up here, move it up into the slash API folder, uh, move it up,
241:51 - this should be placed in the API folder, not in the app folder. So I hope you didn't make the same
241:54 - mistake as me here. So I'm going to put it in. Okay, so, uh, because it is file based routing,
242:02 - right? So this webhook has to be placed within the slash API folder. So let me try one last time.
242:10 - So hopefully this time everything will work. So let's go to, okay. So let me just upgrade to pro.
242:19 - All right. So let me test one last time. Hopefully this time it will work.
242:22 - So four two, four two, four two, four two, four two, four two. Subscribe. So if you look at the
242:33 - backend, this time it should return us with 200 response. And let's see if it works. Let's wait
242:40 - for a while. So it's combined. Okay. Yeah, it works. So now it returns with 200. That means
242:46 - everything is worked. Everything works perfectly. And now if we go look into our database, we should
242:51 - be able to see the, um, we should both see the role. So right now let's create a utility function
242:57 - to check whether a user is subscribed to the pro account. So come under to your, uh, come under to
243:04 - your, I see, uh, your lib folder and let's create a file called subscription.ts. Okay. So for this
243:15 - subscription.ts, uh, it will, we have to check whether the row exists within the database. So
243:21 - what we're going to do is first, uh, export a function called check sub description. It's going
243:28 - to be an async function. Okay. So the first check, if they're logged in, away it's off.
243:37 - So this is from a clerk, right? This is from the clerk itself. Uh, that's imported slowly.
243:49 - Then we'll get a check, uh, get a user ID out of it. We got to check if not user ID,
243:56 - we got to return false. So if they're not in, obviously they're not a pro user.
244:00 - Okay. Then we'll get all the current, we get the user subscriptions. So user subscriptions from
244:09 - await DB dot select. So this DB comes from our lib slash DB as usual. Dot select. Dot from
244:17 - user subscriptions. This one will come from our schema where equals to the user,
244:25 - correct. So I'm looking at user subscriptions dot user ID equals to user ID. So let's save this.
244:37 - So this just merely checks for whether the row exists. So if not user subscriptions index zero,
244:47 - right? Then we know obviously is false. That means they are not, they do not have a record
244:52 - database. So they're not subscribed. Okay. So let's get the actual user subscription from, uh,
244:59 - underscore user subscriptions index zero. Okay. Uh, and then we can do cons is valid.
245:07 - It's going to be user subscription dot stripe price ID. So they must have a price ID that exists
245:15 - as well as the user subscription dot stripe current period n dot get time, right? Plus a plus,
245:29 - let's define one, one variable up here called cons day in milliseconds. So how many milliseconds
245:35 - are in the day? 1000 times 60 times 60 times 24. So if the current period n plus one day in, in
245:42 - milliseconds, so give them a one day buffer, if it is bigger than date dot now, that means it is
245:48 - still valid, right? So if it's valid, if both of these, uh, statements are valid, right? So if
245:53 - the stripe price ID exists and they still have, they're not, their expiration is not over, then
245:57 - we want to return not, not is valid. So this converts it into a Boolean. Okay. So this function
246:04 - is exist now for us to actually check whether the user is subscribed to a chat PDF pro. So the last
246:11 - step here is to actually, let's come back down to our app dot TSX. So the main page here. So above
246:18 - here, remember here, we asked to put the, this go to chat here. So, uh, underneath here, uh, underneath
246:27 - here, let's add the subscription button. Okay. So let's actually get the, whether they are pro
246:32 - account first. So we can check is pro is pro equals to await check subscriptions. Okay. So this
246:41 - subscription obviously is imported from our, a, our check subscription file. Then we could create a
246:48 - new, uh, component called sub script button dot TSX. Okay. So this subscription button is going to
246:58 - take in a few things. So we do T S R A F C first. So it's going to be a client component.
247:08 - All right. So this will take in, uh, this is pro. It's going to be a Boolean, right? We're going to
247:14 - check, uh, we're going to have a loading state for this, right? So we can return a button,
247:20 - right? Imported. Just disable when it's loading. That's going to say that if, if props.is pro,
247:31 - right, we're going to show manage subscriptions. Otherwise we're going to ask them to get pro
247:38 - account. Okay. So then cons handle subscription. So we can copy this code, uh, cons handle
247:46 - subscription from the, uh, chat sidebar, right? We can see that we have this handle subscription.
247:52 - So let me copy this and let me paste it in here. So it's the same code here. So then we just,
247:58 - whenever they click on this button, we just want to handle, subscribe, handle subscription,
248:04 - right? And those sub script. All right. That's pretty much it. So let me save this. So let's
248:11 - import axios also, save it. Then we can come back to our page.tsx, right? We can then, uh,
248:18 - just import it. So underneath this go to chats button, uh, under this go to chats, let us put
248:25 - the subscription button. So we have a div that says margin left of three, and we have the
248:32 - sub script subscription button from our components and we'll pass in the is pro pro is pro passing
248:42 - the is pro. So this comes from a check subscription function call. Okay. So, uh, if everything goes
248:50 - well, right, we can now see that there should be a subscription button that shows up here.
248:56 - So let's wait for it. So in the meantime, let's talk about how do we implement this go to chats
249:01 - feature. So we need to, when you get the first chat within, uh, database, right? So we're going
249:08 - to get ID of the first ever chat and then we'll link it there, link it them there. So how do we
249:14 - get the first check, right? We're going to check, uh, let's first chat. We're going to check if
249:20 - user ID exists first, then we'll do first, uh, chat equals to await DB dot select dot from chats
249:33 - for these from unit user schema dot where the equals where chats dot user ID equals to user ID.
249:43 - Okay. Then if first chat exists, they want to set first chat to be first chat index zero. So this
249:54 - variable here returns us with an array with a list, but we want to get the first element here. So the
249:58 - first check they have of what this user, then we got to check here. If, if it's off and the first
250:05 - chat exists, okay, then we can show this button that goes to chats. However, this button will
250:13 - wrap it in a, uh, H ref tech, a link tech. So let me just do here, like here. So let me just import
250:21 - the link component, uh, link component. I'll wrap the button in here. Okay. So wrapping this button
250:31 - here, this link will obviously go to, uh, sorry, such chat slash first chat dot ID. So it leads us
250:44 - to the first chat ID. So let's save this file and then let's come back to our thing. So right now
250:50 - I see these go to chats. So let me just add one more thing. Let me add one icon to make it look
250:54 - nicer. So for the icon, I'm going to choose the arrow, right icon. So let's get the arrow
251:01 - right icon moving. Oh, it's really lagging really bad in here now. So, uh, arrow, right.
251:12 - So import the arrow, right icon from Lucid dash react. Let's give you a styling of, um,
251:21 - uh, margin of two. So let's save it. Uh, let me just remove this. Okay. Save it. And hopefully
251:30 - there should be an arrow that pops up and then we'll be able to start it properly. Right now,
251:33 - if you go to, go to chats, it will lead us to the chat page, right? So let me go back here and
251:39 - right now, because we are pro, you ask us to manage subscription, right? So right now if we press this,
251:44 - there is going to be an error, right? Let's look at the error and I'm going to explain how to fix
251:48 - the error. So the error is that, uh, we need to enable the billing, uh, test, test website.
251:56 - So let's look at, look at the console for the error. So, okay. So this error, so scroll up to
252:02 - the error. They should, they should tell you that, uh, you can create a portal session in the test
252:08 - mode until you save your customer portal session. So just click on the link here that goes to test
252:12 - settings, uh, billing slash portal, open it in your, uh, in your browser. So it opened on my
252:19 - other browser here. I'm going to bring it up here. Uh, okay. And then all you need to do is just,
252:26 - uh, enable the billing portal by clicking the button activate test link. Okay. So that's all
252:33 - that you need to do. Then close it off. All right. Then just come back to your thing here. And if you
252:39 - click on manage subscription, this time it should work properly. So it will link me, it will lead
252:44 - me to the billing portal where I can manage my subscriptions. Okay. So that's also working
252:49 - perfectly. So everything is working fine. So here is where they can manage their subscription,
252:52 - like canceling and yeah. So let me just return to chat PDF. So the go to chat function will also
253:00 - work. So I think that's pretty much it. So the last part here is just to, for this upgrade to
253:04 - pro account in our chat sidebar. So let me close this off, come back to my chat sidebar. Okay.
253:10 - So for the chat sidebar, I'm going to do the same for my, uh, for this button here. Uh,
253:18 - I'll wait to pro. Uh, yeah, that's pretty much it. That's pretty much it. So for this button,
253:26 - I can actually replace it with my, uh, subscription button imported from my component.
253:32 - So we pass is pro. So how do we get the is pro prop? Uh, we can get the is pro prop from the
253:42 - prop here. So let's just do, uh, is pro. This will be a Boolean. Then let us destruction is pro.
253:53 - Okay. Uh, then let's come down here. I'll pass this is pro into this component. So for this
254:03 - subscription button, this is pro, we need to go back to our page or TSX in our chat ID, right?
254:08 - This is where we are rendering this chat sidebar component, right? So now we require a, uh, is pro
254:14 - prop here, uh, is pro. So let's get back to is pro by doing cons, uh, is pro equals to await check
254:23 - subscription. Okay. So let's import this from our subscription dot TS a lip file.
254:32 - So let's wait for it to load, check subscription and invoke it. Then we can pass the is pro prop
254:39 - into the chat sidebar. So then we save it and then that's it for the progress. Okay. So I think
254:51 - that works perfectly. Everything is done. So that's it. So all right. So we are complete down
254:57 - with the project. And so now I'm going to teach you how to deploy it. All right. So come down to
255:02 - your, come with, let's go make a new gate repository from this repo. So come down to your terminal.
255:08 - So I'm going to stop everything that's running first. I'm going to stop the server, stop this
255:12 - or so exit. So I'm going to do, uh, let me just do this. Let's do get status. So we can see that
255:19 - we are going to try to comment all these files here. So let's do get at dot gets comment dash
255:25 - am initial comment. All right. Come down to your browser, go to github.com slash new. So let's,
255:33 - let's create a new repository together. So here you just name it wherever you want. I'm going to
255:38 - name it, uh, chats, PDF dash YouTube. Okay. Uh, just put it as public and create the repository.
255:46 - So you just need to follow the steps that GitHub ask you to do. So we have already added and
255:50 - committed, right? Rename your branch and then go to copy the remote origin. So let's add the origin
255:57 - and finally let us push it up to min. So git push dash new origin min. So that will push up all our
256:04 - code to the GitHub repo. So now if we refresh, uh, this page, we can see all our, uh, this, we can
256:10 - see that all our code is being pushed up. So now all we need to do is come down to, uh, resale,
256:15 - resale.com. Add a new project. So add new project and what you can do is import your chat,
256:23 - uh, chat PDF dash YouTube for the project name. And for this environmental variables,
256:29 - come back to your.env file. Okay. So I need to copy up everything except for this next base URL
256:36 - right here. So copy from all the way here, all the way up, copy this. Okay. Then paste it into my
256:45 - in V variables. So the last thing here is I need to add, uh, sorry, I need to add this, what's it
256:51 - called next base URL. So let's copy this. So let me add the next base URL and this will be later on
256:58 - will be changed on, this will be later changed to whatever versatile gives you. All right. So
257:03 - let me just delete this so that we can deploy first. So for now we do have to add that URL,
257:07 - but later when we deploy, once we get the versatile URL, we can just place it back there.
257:12 - So I think that might be an error, but let's see as it builds.
257:17 - Okay. So the project has been deployed successfully. All right. So let us go to the
257:22 - continue dashboard and let us actually try out ourselves. So I'm going to visit this domain. So
257:29 - this is the URL that we need to place into our next base URL later on. So for now, let us actually
257:35 - log in to get started. So I'm going to click on it, log in. It will bring us to the, the clerk page.
257:41 - So I'm going to log into my, with my Google account and just log in with my here. And so
257:45 - it will lead me back to my, to the homepage where of hopefully I'll be logged in. Okay. So that's
257:52 - good. So right now I can see that my chats are great. So let me go to the chat page so you can
257:57 - see the chats being shown here. So let me create a new chat by dropping a new PDF here. So let me
258:03 - drop back in the edge runtime docs to make sure everything's working. So hopefully that this will
258:11 - work. So I'm going to show you how to actually add one more configuration to your versatile app
258:16 - later, but let's see if this works. All right. So it works check created and we can see that the
258:20 - runtime works. The PDF is here. And let's ask a question. Let's ask how to use the edge runtime
258:29 - question mark. So this should give me a response in, in regards to the PDF. Okay. So correct. These
258:36 - are all pulling directly from the versatile docs. You can see that it says versatile in it. So we
258:40 - know that things works and everything is perfect. So the last thing here is let us change the
258:46 - environmental variables for stripe and for the base URL. So come back to your, uh, versatile dashboard.
258:54 - Okay. Come down to your settings, come down to your functions, right? Choose a function that is
258:59 - nearest to you. So choose for me in this case will be Singapore. Okay. Save it. So this is where
259:06 - all my serverless functions will execute. So obviously you want to choose one that's nearest
259:09 - to you and your users so that the response time will be fast. Okay. So with that out of the way,
259:15 - let us come back to our general, come back to our environmental variables, right? So we need, uh,
259:22 - so remember that we have this next base URL. So let's fill that in right now. So let us add a
259:28 - URL called next base URL. So this we can just copy from the base URL URL here. So copy here
259:35 - and let us just paste in the value here. Okay. So I'm going to save this file. Okay. And also
259:43 - for the, for the strike webhook, I need a secret. Come back to our dashboard here. Okay. Come back
259:50 - to webhooks. All right. We want to now add an endpoint. So this endpoint will be at our
259:55 - versatile URL slash API slash webhook. Right. And we want to select events to listen on. So what
260:03 - events are we listening on to our webhook? So remember we are listening for checkout section
260:08 - completed and invoice payment succeeded. So let's add these two endpoints. So first will be, uh,
260:14 - checkout dot sessions dot, dot completed. Right. And also we have a invoice dot payment succeeded
260:22 - invoice dot payment dot succeeded. Sorry, invoice dot payment underscore succeeded. Okay. So it's
260:32 - just these two, uh, these two, uh, events that we're listening on. Then we'll add the events and then,
260:38 - uh, that's pretty much it. Then you can just add the endpoint and everything will work perfectly.
260:43 - So now we will get this signing secret, which we'll have to, this is the actual official one.
260:48 - So copy this, come into our in-view variables, come into our, uh, strike webhook signing secret
260:56 - and let us edit this. So just replace it with the one that you pasted in, copy it, press it, save.
261:03 - Right. And one more thing I want to change here is now the button looks kind of ugly within the
261:09 - chat here. See this menu subscription. So I'm going to just change that by going into our
261:13 - subscription button. So I'm going to change this, um, button to a type variant of, sorry,
261:19 - variant of outline. So I'm going to save it and I'll push the code up to my repository. So I'll
261:26 - just put change button, commit and push. So whenever I push, uh, results automatically going
261:33 - to detect, there's a new changes. It's going to redeploy the entire application for me.
261:38 - So we come back to our original Versailles application, right? Come back to our deployments
261:42 - and we're able to see it has detected that we have a new, uh, commit code change button.
261:46 - So if we come into our, click onto it in here, we're able to see the deployment status, the
261:52 - commit change, right? And let us click into it so that we can see what's happening. Okay.
261:59 - So now we just have to wait for it to deploy and then everything should be up and running
262:02 - and ready to go. Okay. So now that it has finally deployed, let us receive the original page.
262:09 - So let me just go back to our original, uh, homepage and everything should work fine. Yes.
262:13 - So now we have, we changed the button. So we go to chat, at least a button doesn't look, uh,
262:18 - that ugly anymore. So I mean, you can start it further, but in this case, I'll just leave you
262:21 - up to you. So yeah, we have completed this whole project. I'm very happy and very proud of you
262:26 - for staying all the way to the end and falling true with this project. And yeah, you feel free to
262:32 - continue improving on this project and eventually turning it into a real-sense product where you
262:35 - can be really making money off of this. So I hope you have learned something from this video. So
262:40 - today I taught, um, I taught mainly about AI, right? How to use a retrieval augmented generation
262:46 - to feed in proper context into a chat GPT, right? So I hope that this has been helpful to you. And
262:52 - if you have learned something new today, uh, please do like comment and subscribe on this video
262:56 - because I put it, I mean, apparently a lot of effort. I hope that you actually learned something
263:00 - and I provide a value to you. So with that, thank you for watching and have a good day.