00:00 - Learn how to build a platformer game in Python.
00:03 - This game will have collisions, gravity, animated characters, and much much more!
00:08 - Tim with Tech with Tim teaches this course. Tim has one of the most subscribed software channels on YouTube.
00:24 - In this video, I'll be sharing with you
how to build a platformer game in Python.
00:28 - This game will have pixel
perfect collision.
00:30 - It will have an animated character,
as you can see here.
00:33 - It will have single and double jumping.
00:35 - It will have all kinds of different
animations for falling, jumping,
00:39 - colliding with obstacles.
00:41 - For example, you can see here, when I hit the fire, I kind of go into this hit state.
00:44 - I will show you how to generate different
objects, how to scroll the background. And really, at the end of this video,
you will have a solid, fundamental
00:51 - understanding of how to build
a platformer game in Python.
00:54 - And you can go and extend this and build
really anything that you can think of.
00:58 - I will even include a ton of free assets for you
that allow you to change your character,
01:03 - change the terrain, change the background,
and do all of that extremely easily.
01:07 - In fact in this tutorial alone, I will show you how to use
four different characters.
01:11 - Let me show you those characters
before we continue.
01:13 - So this is the second character here. This is being referred to as mask dude.
01:17 - This is the third character. I'm calling this guy
the ninja frog, as you can see.
01:23 - And finally, we have this character here,
which is called Pinkman. 
01:27 - Now in this tutorial, you will learn
how to use all of these characters
01:30 - and you can swap them out
with a single line of code.
01:33 - All right. So let's
go ahead and get into it now.
01:35 - Since this is a long video,
I do want to spend a minute here
01:37 - just talking about who
this video is designed for
01:40 - exactly what you're going to learn
and what you can expect to see.
01:43 - Don't waste your time
if you don't want to go through it.
01:45 - So this video is really designed
for people that have a bit of experience
01:49 - with Python.
01:49 - Ideally, you are an intermediate
or a Python programmer.
01:52 - You understand the syntax,
you know, for loops, you know, functions,
01:55 - you know all of that.
01:56 - If you don't feel free to follow along.
01:58 - But I'm not going to be explaining
those basic concepts.
02:01 - Now, this video will teach you
how to build exactly what you see here.
02:04 - So by the end of the video
you will have exactly this.
02:07 - And if you're not interested in waiting
until the end of the video,
02:09 - then you can download the code
from the GitHub repository
02:12 - that I will leave in the description.
02:14 - That's also
where all the assets are going to be.
02:16 - So regardless, you're going to have
to download the code from GitHub.
02:19 - Again, I will leave that description,
download that,
02:22 - open up the folder and kind of
we could start working from there.
02:25 - Now really what I'm going to be showing
you here mostly is sprite sheet animation,
02:29 - pixel perfect collision using
what's called masks,
02:33 - and then how you can do
the scrolling background
02:34 - generating objects,
all of that kind of stuff.
02:37 - That is really the hard part when it comes
to generating a platformer game.
02:41 - Once you have all of that down, it's
very easy to extend this, to add levels,
02:45 - to add like, you know, a finishing flag,
to add coins, to add, you know, lives.
02:50 - You can turn this game
into anything you want.
02:52 - And that's how I've designed this, is
that you have the base and then you can go
02:55 - and make it kind of a full fledged game
and work off of that.
02:58 - So that said, I will stop talking now.
03:01 - I think this game looks really good.
03:02 - I'm excited to share this with you guys.
03:04 - So let's get into actually building it.
03:10 - So right now
I have Visual Studio code open.
03:12 - Obviously we're doing this in Python
and I already have high game install.
03:17 - Now the first thing we're going to have to
03:18 - do is install PI game, which is the module
we're going to be using.
03:22 - So to do that, go to your terminal
and type pip install PI game.
03:27 - If that doesn't work for you, you're
going to try pip three install PI game.
03:31 - If that doesn't work,
try python hyphen m pip instal pi game.
03:35 - If that doesn't work, try python three
hyphen m pip install pi game.
03:38 - If none of those work, I'll leave
03:40 - two videos on the screen
that show you how to install that module.
03:43 - Now, once you have PI game installed,
03:44 - I'm going to assume that you've downloaded
the GitHub repository.
03:48 - Go to GitHub.
03:49 - There's a little button that says Click
to download, download the folder extracted
03:54 - to your desktop and then open it
in this code or whatever editor you want.
03:57 - So you have something that looks like
this.
03:59 - You should have an assets directory
inside of assets, you should have a bunch
04:03 - of different folders.
04:04 - Then you should have a main python file
that contains all of the finished code.
04:09 - Now obviously
04:09 - we're going
to write the code from scratch, but
04:11 - you can either work off that existing code
or you can kind of clear the file
04:15 - and type along with me,
whatever you want to do.
04:16 - I quickly want to run through the assets
folder and then we'll get into the code.
04:20 - So in assets we have a ton of stuff.
04:21 - We're not going to use most of this,
04:23 - but I wanted to include all of it
so that you could kind of continue
04:26 - the game later if you want.
04:27 - So we have, for example, backgrounds.
04:29 - These are a bunch of background tiles,
04:30 - so you can change kind of the theme
or color of the background very easily.
04:34 - I'll show you how to do that.
04:35 - We have items like boxes,
checkpoints, fruits, etc.
04:39 - We're not going to use any of those.
04:40 - Then we have main characters.
04:42 - For main characters,
we have a bunch of sprite sheets
04:45 - inside of here and I'll show you how
we can split these sprite sheets apart
04:49 - and use all of the different
kind of animations inside of your right.
04:52 - So we have that for my stud
ninja frog, Pink Men and Virtual Guy.
04:56 - All of the file names are the exact same.
04:59 - Okay, then we have menu.
05:00 - We're not going to be using anything
from there.
05:02 - We have other, we have terrain.
05:04 - We are actually going to be using terrain
specifically.
05:06 - We're going to pull out
this kind of block here.
05:09 - But you could change the block again
if you want to do that.
05:11 - And then we have traps
and we are going to be
05:13 - using the fire trap,
wherever that is right here
05:17 - that has kind of an animation right
where the fires go.
05:19 - But again,
you can add all of this stuff later on.
05:22 - I'll show
05:22 - you kind of the based on how to do it and
then you'll be able to extend from there.
05:26 - Okay.
05:26 - Now that we understand the assets,
I apologize for such a long introduction.
05:30 - Let's get into writing the code.
05:31 - I also need to plug the idea of the course
programing expert.
05:34 - So if you guys want to get better
at Python,
05:36 - check that out from the link
in the description.
05:41 - Okay. So let's start at the top.
Our program here.
05:44 - By importing everything we need, we're
going to import LS, we're going to import
05:47 - random, we're going to import
math, we're going to import PY game.
05:52 - We're going to say from OS import
list directory
05:58 - and we're going to say from OS stop path
06:02 - import is file and join.
06:04 - Now the reason I'm doing all this OS stuff
06:07 - is because we are going to be dynamically
loading all of the sprite sheets
06:11 - and the images
06:12 - so we don't have to manually like type
out the file names that we want.
06:15 - I'll show you how we write a function
that just loads
06:18 - these folders here, kind of splits
the sprite sheets automatically
06:21 - and gives us all of the images
that we're interested in.
06:24 - Okay.
06:25 - After we do that,
06:25 - we're going to say py game dot net,
we need to initialize the py game module.
06:29 - Then we're going to go down here, we're
going to set a caption for a display.
06:32 - I'm going to say py game
dot display dot set underscore caption.
06:37 - If you're unfamiliar
with what this is doing,
06:38 - the setting the caption
at the top of the window,
06:41 - I'll try to explain most the PY game stuff
as we go through the video.
06:44 - I also have a ton of videos
umpire game on my channel
06:47 - if you want to check out something
a little bit more basic.
06:49 - Okay.
06:50 - Now what I'm going to do
is define a few global variables
06:53 - that we're going to be using here.
06:54 - The first one is going to be
the background color.
06:57 - Now we'll use this for now
until we implement our own background.
07:01 - And for the background color,
07:02 - I'm going to make this white,
which is going to be 255 to 50
07:05 - 5 to 55, all of our colors
and py game are going to be in rg.
07:09 - B Okay, so red, green, blue, that's
what we have for our background color.
07:12 - We're going to define the width
and the height of our screen.
07:16 - For some of you,
07:17 - you're going to have to make this smaller
if you're on a smaller display.
07:20 - For me, I'm on a2k monitor,
so I'm going to go with a thousand by 800.
07:24 - But if you're on again a smaller screen,
07:26 - you might want to make this
just a bit smaller
07:28 - so that it works for you,
although it doesn't really matter.
07:31 - Make it whatever size you want.
07:32 - Next I'm going to say my focus,
which is my frames
07:35 - per second, is going to be equal to 60
07:37 - and I'm going to define my player
velocity equal to five.
07:41 - And this is going to be the speed at which
my player moves around the screen.
07:45 - Okay.
07:46 - Now that we've done that,
we need to set up a game window.
07:49 - So I'm going to say PI game,
dot display, dot set underscore mode,
07:53 - and I'm going to pass the width
and the height
07:55 - to this window argument
here, this mode argument.
07:59 - And this is going to kind of create
the PI game window for us.
08:02 - I'm going to store that
in the window variable and there we go.
08:05 - We have kind of our global variables
created.
08:08 - Now I'm going to make a main function
and I say to find main,
08:13 - this main function is going to be
what we run to kind of start the game.
08:17 - So inside of here, I'm
going to take a window and at the bottom
08:20 - my program, I'm going to say if
underscore, underscore, name, underscore,
08:23 - underscore is equal to underscore,
underscore, main, underscore, underscore,
08:27 - then call the main function
and pass the window argument.
08:33 - Okay?
08:33 - So hopefully you can see kind
of the structure of our program already.
08:36 - The reason I have this line right here
is so that we only call the main function.
08:40 - If we run this file directly,
if we don't run this file directly,
08:44 - say we imported something from it,
then we won't run the game code.
08:47 - Okay.
08:48 - So that's why I have this inside of
Main is where we're going to write
08:51 - kind of our event loop.
08:53 - The event loop will be what's handling,
08:55 - say, the collision and moving
our character, redrawing the window,
08:58 - all of that kind of stuff.
08:59 - This kind of good practice
to have your event loop in one place.
09:03 - So inside of the main function,
we need to set up a few things.
09:06 - The first thing we need is a clock.
09:08 - So we're going to say clock is equal
to pi game time, dart clock.
09:12 - We also need to define what is it a while
09:16 - loop that's going to continually loop
and act as our event loop.
09:19 - So I'm going to say run is equal to true.
09:22 - I'm going to say wild, true
or well run string
09:25 - and then the first thing I'm going to do
is say clocked tick.
09:28 - Yes. Now FIPS members are variable right
here.
09:31 - What this line does
is ensures that our while loop
09:34 - is going to run 60 frames per second.
09:37 - Okay, so no more than 60 times per second.
09:40 - That's what this ensures.
09:41 - If you're on a really slow
09:42 - computer, chances are you could be running
less than 60 frames per second.
09:46 - But in my case,
I'm on quite a fast computer,
09:48 - and if I didn't put this year,
09:49 - then you'd see that my game
would be like way faster than yours.
09:52 - So we need to do this to regulate
the frame rate across different devices.
09:56 - Okay, now that we have that,
we're going to say for event
10:00 - in game dot, event docket
10:04 - and the first event that we're going to
check for is if the user quits the game.
10:07 - If they quit by quitting, I mean they hit
the red ax in the top right hand corner.
10:11 - Then we need to stop the event loop
and exit our program.
10:14 - So I'm going to say if event type
10:17 - is equal to per game, don't quit.
10:22 - Then we're going to say run
10:24 - is equal
10:24 - to false
and we can break out of this loop.
10:28 - Then we can go down here
and we can say hi game talk, quit notice.
10:32 - This is outside of the wall loop
10:34 - and then we can put quit, which
will actually quit the Python program.
10:37 - Okay, so now we have our basic event loop
10:40 - and what should happen if I run the code
now is a plug in window should pop up.
10:44 - Nothing should be on the screen.
10:46 - And if I hit the red arrow,
it should close.
10:47 - So let's try this and see what we get.
10:49 - K Notice it says platformer
and then I hit X and it closes.
10:53 - Perfect.
10:54 - We're well on our way
to creating the platformer game.
11:00 - All right,
11:00 - so now that we've done that,
I actually think that
11:02 - the first thing we can do
is generate our background.
11:04 - Then once we have the background,
11:06 - we can create a basic player
that we can move around the screen.
11:09 - And once we have that,
we'll start doing all of the animations.
11:11 - And then later in the video, once
we've got kind of the bulk of the stuff
11:15 - done, we'll handle the collision
and all of the movements.
11:18 - Right? Okay.
11:19 - So I need to make a function here
11:21 - and I'm going to call
this get underscore background.
11:24 - Now before I dove into this, let's
have a look at our assets folder again.
11:28 - Now, what I want to do
is use these tiles, right?
11:31 - They're just tiles.
11:32 - I believe they're sizes 64 by 64,
32 by 32, something along those lines
11:37 - anyways, we want to use these tiles
and tile, the whole background.
11:41 - So what I need to do is essentially create
11:44 - a whole grid of these tiles
based on the size of my screen.
11:48 - So the way I'm going to do
that is by using a folder here.
11:51 - This folder is going to return to me.
11:53 - So not this folder,
right about this function.
11:55 - This function is going to return to me
a list that contains
11:58 - all of the background tiles
that we need to draw.
12:01 - So that's we're going to do here
with get background.
12:03 - Now what we want to take
is the name sorry.
12:06 - As I was saying,
12:07 - the name is going to be
the color of our background
12:09 - and that's going to allow us to change
what background that we're using.
12:12 - So the first thing we need to do
here is load this background image.
12:15 - Now it's very important
that when you run this file,
12:18 - you run it from the directory
that the file exists.
12:22 - Now, the reason I'm saying that right now
12:23 - is because the way I'm going to load
this image relies on the fact
12:27 - that you're running this code
from the directory that it exists in.
12:31 - So see here
that I'm in desktop Python platformer
12:34 - and then notice tutorials
inside of that directory.
12:37 - That's why this is going to work
if you try to run this code
12:40 - from a different
directory, says see the desktop
12:42 - and then I tried to run this,
then I'm going to get an issue.
12:44 - So just make sure you're
in the correct directory.
12:46 - I just want to say that
before we even get into this.
12:48 - Okay, so I'm going to load my image
and the image
12:51 - is equal to py game dot image, dot load.
12:55 - And then what I'm going to do
is join the assets path
12:59 - which is directly in the directory
this files in with the background
13:05 - path here, if I spell background correctly
and then with the name
13:09 - which is going to be the file
name that I want to load,
13:11 - which is really
just the color of the background.
13:13 - Okay.
13:14 - Now that I have that, I want to get
the width and the height of this image.
13:16 - So I'm not guessing what it is.
13:18 - So I'm going to say
underscore, underscore width.
13:20 - Height is equal
13:23 - to image.
13:24 - Don't get underscore rect.
13:25 - Now when you do this,
it will give you the x y width, height.
13:30 - I don't care about the x y.
13:31 - So I've just put two underscores here
denoting
13:33 - noting
that I don't care about these values
13:35 - and then I'm able to grab the width
and height.
13:37 - So now that I have the width
in the height, I'm going to say tiles
13:41 - is equal to an empty list
and then I'm going to loop through
13:46 - essentially how many tiles I need
to create in the X and the Y direction.
13:50 - So going to say four, I'm in range
13:54 - and then I'm going to take my width,
I'm going to integer,
13:56 - divide this by the width of my tile
and I'm going to add one
13:59 - and I'm going to do the same thing
for my height here.
14:02 - So I say four Jain range height
over the height of my image plus one.
14:07 - Okay, so notice width
here is the width of the screen.
14:10 - Height is the height of the screen.
14:11 - I'm integer
dividing this by the width of my tile
14:14 - and that tells me approximately
how many tiles I need
14:17 - kind of in the x direction
to fill the whole screen.
14:20 - Then just to make sure
that I don't have any gaps, I add one
14:24 - and I do the exact same thing for height
in the y direction.
14:28 - Then what I'm going to do is say,
actually, yeah, I'm going to say rect
14:33 - is this rect snow where I say
pause is equal to
14:35 - I multiplied by the width and j
14:39 - multiplied by the height.
14:41 - And this is going to denote the position
of the top left hand
14:44 - corner of the current tile that I'm adding
to this Tiles list in PI game.
14:49 - When you draw something on the screen,
you draw it from the top left hand corner.
14:53 - So what I'll be doing
is continually moving the positions
14:56 - based on
how this for loop is going, right?
14:58 - So for every I, for every j
and multiplying it by the width
15:02 - and multiplying it by the height,
and that gives me the accurate position.
15:05 - I need to place
every single tile in on the screen.
15:08 - Hopefully that makes a bit of sense,
but that's how this is working.
15:12 - And then I'm going to set to start
append my position
15:15 - and then I'm going to return my tiles.
15:18 - I'm also going to return the image
so that I can know
15:21 - what image I need to use
when I'm drawing all of these tiles.
15:24 - Okay.
15:25 - Now that I have my background,
I'm going to go into main,
15:27 - I'm going to say
my background is equal to get background.
15:32 - And for the name I'm going to reference
here in the background
15:35 - folder any of these images
so we can use anyone we want.
15:38 - I don't really matter.
15:39 - I kind of like the blue one,
so I'll go with blue.
15:42 - Feel free to change
this though on your end. And
15:46 - there we go, if I can type this correctly.
15:48 - Okay. So going to say background comma,
15:51 - BGP, image like that.
15:54 - And now I want to set up something
that's going to draw my background.
15:57 - So I'm going to make a function here
and I'm going to say draw.
16:00 - This is going to take in a window and
for now it's going to take in a background
16:03 - and later it'll take in everything else
you want to draw inside of here.
16:07 - I say plugin, dot display, dot update.
16:12 - And before I do that, I'm
going to draw my background.
16:14 - So I'm going to say four
and this is going to be tile
16:18 - in background like that.
16:21 - And then I'm going to say window doublets
16:25 - and actually
I need to take my BG image as well.
16:29 - So let's take that
16:31 - and I'm
going to draw the background image.
16:34 - And then what I need to pass
here is the position I want to draw it at,
16:38 - which is going to be tile.
16:40 - So what I can actually do
is just convert this to a tuple.
16:43 - Notice
the tile is going to be a list, right?
16:45 - Tile is going to contain
kind of my X-Y position.
16:49 - You can see that here. Right?
16:50 - We're appending pause,
which is a list of x, Y,
16:53 - and now that I think of it,
so make it easier.
16:54 - Let's just make this a tuple directly
and now we don't need to convert it.
16:59 - Okay.
16:59 - So in case anyone's confused,
17:01 - what we're doing here is looping through
every single tile that we have,
17:04 - and then we're going to draw
our background image at that position,
17:07 - which will fill the entire screen
with background images.
17:11 - Then what we're going to do
is update the display,
17:13 - the reason we update it so that every
single frame we kind of clear the screen.
17:17 - Right.
17:17 - And we don't have old drawings
still on the screen.
17:20 - You'll see what I mean in a second.
17:21 - But this draw function is where
we're going to do all of our drawing.
17:24 - For now, the only thing we need to draw
is the background.
17:26 - Later it will be the player,
the blocks, the obstacles, etc.
17:29 - okay, so
now I'm going to go inside of my wallet.
17:32 - I'm going to call this draw function
that we just created.
17:35 - I'm going to pass window
and then of course,
17:37 - I'm going to pass my background
and my BG image.
17:41 - Okay.
17:41 - Now this reminds me that I no longer need
this background color.
17:44 - We're not going to use that
so I can get rid of that there.
17:47 - Okay.
So at this point,
17:48 - assuming I've loaded the image correctly,
17:49 - we're now going to see this
tiling the entire screen.
17:52 - So let's save and run and notice
that we get it right.
17:56 - Styling
the entire screen looks pretty good to me
17:58 - and we can quite easily change this
if we want by just going here
18:02 - and saying okay, rather than blue,
I want yellow.
18:05 - And we say yellow
and now we get a yellow background.
18:08 - Great.
18:08 - So that's kind of the advantage
of how I've done this here.
18:10 - You can change the background to any color
you want.
18:12 - Well,
given that's in the background directory,
18:18 - now that we have our background,
what should we do next?
18:20 - Well, we probably want to put a player
18:23 - on the screen and start
seeing some images for that player.
18:27 - Now, the player itself is the most
complicated aspect of this program.
18:30 - There's a lot of movement
going on with it.
18:32 - So we'll start by
just creating like a block for our player,
18:34 - kind of move
the block around, have a jumping around.
18:37 - Then once we do that,
we'll do all of the sprites and animations
18:40 - just so that we can get some more progress
before we dove into that
18:43 - because it is a bit of work.
18:44 - Okay, so let's go
here and let's say class player,
18:49 - we're going to use a class for our player.
18:50 - It kind of makes sense here.
18:52 - And this class is going to inherit
from page game,
18:55 - dot sprite, dot sprite.
18:57 - Now I don't typically use sprites
when I'm working in pie game,
19:01 - but I'm going to use them
in this tutorial.
19:02 - And the reason for that is that
it makes it very easy to do pixel perfect
19:06 - collision when we have two sprite objects
which we're going to have
19:10 - because we're inheriting from the pie game
sprite class, we can use a method
19:14 - that tells us if the sprites
are colliding with each other.
19:18 - So just understand, that's
why I'm doing this inheritance.
19:20 - You don't have to understand
exactly what the Sprite is,
19:23 - but it kind of denotes
that we have some properties on our class
19:26 - and then it allows
these special paging methods
19:28 - to use those properties
to handle the collision for us
19:31 - so we don't have to write anything
19:32 - too complicated
when it comes to the collision,
19:34 - although we still do
need to handle it a bit.
19:37 - Okay, so what we're going to do here
is define our initialization area,
19:41 - taking a self, an x, y, width and height.
19:45 - Now the width and height
19:46 - will really be determined by the image
that we're using for our player.
19:51 - But for now, since we're going to have
19:52 - like a block for our player,
19:53 - and so we add that image,
we're going to have a width and height.
19:56 - Now that reminds me that I just need
to set a color for my player.
19:59 - So I'm going to say color is 250 500.
20:02 - I'm making this a class variable
just so it's the same for
20:05 - all of my players and I have access to it
just right on the class.
20:09 - Okay.
20:10 - Now what I'm going to do is say self-doubt
racked is equal to pi game dot rect
20:15 - and then pass my x y width and height.
20:19 - So rather than representing
all of these values individually,
20:22 - we're just going to put them
on the rectangle.
20:25 - And this is going to make it
a little bit easier for us to kind of move
20:28 - the player around and do collision
and all of that.
20:31 - So really, it's just a couple that's
storing for individual values.
20:35 - When I make it party game direct,
it means we can use it
20:38 - in some kind of special equations
and whatnot.
20:41 - Okay, now for our player,
we're going to have to have a few values.
20:46 - The first thing we're going to have, I'm
getting a bit ahead of myself here,
20:49 - but is going to be the x velocity and
the next is going to be the Y velocity.
20:53 - Now the x and
y velocity is going to denote
20:58 - what we call it
20:59 - here, how fast we are moving our player.
21:02 - Every single frame in both directions.
21:05 - Right.
21:05 - So the way the will actually move
our player
21:08 - is we'll just apply a velocity
in a direction and then it'll just
21:12 - keep moving in that direction
until we remove that velocity.
21:15 - Now this will be great, for example,
for something like gravity or jumping,
21:19 - and you'll see what I mean in a minute.
21:21 - Okay. Now, do we have that?
21:24 - We need to add something known as a mask.
21:27 - For now, I'm
going to say the mask is equal to none.
21:31 - And then I think that's
all we need for right now.
21:35 - So now that we have
21:36 - that, let's add our first function here,
which is going to be the move function.
21:39 - So MOVE is going to take in a displacement
21:42 - in the X direction
and a displacement in the Y direction.
21:45 - And it's going to say the self direct X
plus equals
21:49 - the direction x or displacement
x, sorry and self director y
21:54 - plus equals the displacement y.
21:56 - Now if we want to move up
or down or left or right, we just change
21:59 - the sign of this d x or d y right?
22:03 - Okay. So now we have move next.
22:06 - What we want to do is create
two functions, one for moving to the left.
22:11 - And this is going to take in the velocity
you want to move in the left direction
22:16 - and the next is going to be moving
in the right direction.
22:19 - Again, this is going to take in self
and vel now to move left.
22:24 - What we're going to do
is say R self-taught x velocity
22:27 - is equal to and then
this is going to be negative velocity.
22:31 - And then to move to the right, we're going
to say self that exfil is equal to VEL.
22:35 - Now the reason we use negative velocity
here is because if we want to go left,
22:39 - we have to subtract from our exposition
in PI game.
22:43 - Remember our coordinate system
22:44 - is that zero zero is the top left
hand corner of the screen.
22:48 - So if I want to move down
I add to my y coordinate.
22:51 - And if I want to move to the right,
I add to my x coordinates.
22:54 - If I want to go up, I subtract y.
22:56 - If I want to go left, I subtract x.
22:59 - So that's why
I'm putting a negative value here.
23:01 - I know it seems a bit weird
how I've just done move
23:03 - and now I'm saying move left here
and I have negative.
23:05 - Don't worry,
you'll see how this works in a second.
23:07 - Next I'm going to say if self
23:10 - direction does not
equal left, then self-taught
23:17 - direction is equal to left.
23:20 - And I'm going to say self-taught animation
count is equal to zero.
23:23 - Now, we're not going to use these
right now, but I just want to add them in
23:27 - for now at least,
and you'll see why in a second.
23:30 - Now, I'm also going to say up here,
self-taught direction is equal to left.
23:34 - And the reason I'm adding this direction
is because I need to keep track of what
23:37 - direction my player's facing.
23:39 - So later, once I have my sprites, I know
if I'm showing the animation to the left
23:44 - or I'm showing the animation to the right
now, the animation count.
23:48 - I were resetting that
when we change directions.
23:51 - And the reason we're doing
that is so that the animation doesn't look
23:54 - all wonky when we go from going
left to right, we need to kind of reset
23:57 - the count that we're using to change
the animation frames.
24:01 - Again, you're going to see that later
as we go through the tutorial.
24:04 - Now I've just added up here.
24:05 - Softer animation can equal zero
24:07 - just to make sure we don't get any weird
errors later.
24:09 - So now I have my direction. I'm animation.
24:12 - Perfect.
24:13 - Okay, now I'm going to copy this.
24:15 - I'm going to put the same thing
in move right.
24:17 - And I'm going to change the
direction here to say right
24:20 - and then right.
24:21 - So now we know what direction
we're facing at all points in time.
24:25 - Okay, perfect.
24:27 - Next, what we need to do is we need to
have some kind of draw function.
24:32 - And we also need to have
what I'm going to call the loop function.
24:34 - And in fact,
let's do the loop function first.
24:37 - So I'm going to say, fine loop.
24:39 - And inside of here
I'm going to take in self and focus.
24:43 - Now what loop is going to do
is be called once every frame.
24:49 - When I say frame, that's
really one iteration of the while loop.
24:52 - And this is going to move our character
in the correct direction
24:56 - and handle things
like updating the animation and
24:59 - all of the stuff that we constantly need
to do for our character.
25:02 - So for right now, I only care about moving
in the right direction.
25:06 - We'll handle the jumping later.
25:08 - So what I'm going to do
is just say self, don't move.
25:11 - And I'm going to say
25:12 - that we're going to move
based on our x velocity
25:16 - and our Y velocity.
25:19 - Now notice
25:19 - we're updating our x velocity here
when we move left or we move to the right.
25:23 - So now if we call loop
and we have some velocity in the
25:25 - X direction is going to move our character
to the left or to the right.
25:29 - Okay.
25:29 - Again, all this will start to make sense
as we get through the tutorial.
25:33 - There is a lot of stuff
25:34 - I need to do kind of upfront before
I can just show you instantly.
25:37 - So hopefully you guys are following along.
25:39 - But I just want to note we eventually
of course will see how all of this works.
25:42 - I'll walk through the code, so no worries
if it's a bit confusing right now.
25:45 - Now what else do we need to do
inside of loop?
25:47 - Well, we need to update something
25:49 - known as The Mask,
which I'm going to get to in a second.
25:51 - But before we can do that, we need to
define what's known as our image.
25:55 - So I'm going to say define
and this is going to be draw
25:58 - and this is going to be the function
that handles drawing on the screen.
26:01 - And for draw,
26:02 - we are going to take in our window,
which I'll just represent with Will.
26:07 - Now what we'll do for now
is we'll just say Pi, game,
26:11 - dot, draw, dot, rectangle
26:13 - will draw the rectangle on the window,
which is the first argument here.
26:16 - It's where we're drawing it.
26:18 - The second argument is the color
which is going to be self-taught color.
26:21 - Then the last is directing.
26:24 - So I'm going to say
that is self-taught self-correct.
26:27 - Now notice the rect here, right?
26:29 - Has our x y with height
and when we move we're updating the x
26:32 - and y of the rectangle, which will then
change where we're drawing it.
26:35 - If I can find it here on the screen.
26:38 - Okay, so that's what we need for drawing
26:41 - now, actually, for now,
I think that's okay.
26:46 - We will add to this obviously in a second,
but I think we can generate a player,
26:51 - draw the player,
see it moving and then go from there.
26:54 - So let's do that.
So let's go to Main here.
26:57 - I'm going to create a player.
26:59 - I'm going to say players equal to player.
27:00 - I need to pass an X,
Y and a width and height.
27:03 - So I'm going to pass, let's say 100, 100
27:07 - and let's make him 50 by 50.
27:09 - And then what we can do now
27:11 - is pass our player to the draw function.
27:16 - We can then take player inside of here
27:19 - and we can say, player don't draw
and we can pass the window.
27:24 - Okay, so I will move the player in 1/2,
but for now, let's just
27:26 - see if this is working,
if it's going to show up on the screen.
27:29 - So let's run the code and notice
that now we have a red rectangle
27:33 - in the top left hand corner.
27:34 - Obviously nothing's happening right now.
27:36 - We're not moving it around the screen.
27:37 - We could see it showing.
27:42 - So we have our player we're
drawing the player on the screen now.
27:44 - We want to start
27:45 - using some of these methods right, moving
left, moving right, etc..
27:49 - So I want to separate my movement
into a function.
27:52 - So I'm going to say define handle,
move like this.
27:55 - And for this right
now, we'll just take in the player.
27:59 - Now instead of handle move.
28:00 - What we're going to do
28:01 - is essentially check the keys
that are being pressed on the keyboard.
28:04 - If you're pressing left
or you're pressing right,
28:06 - then we'll move the character to the left
or to the right.
28:08 - Eventually, we will check for collision
and we'll do all of that.
28:11 - So I'm going to say
key is equal to pi game dark keys
28:17 - actually
28:17 - not key squeaks get underscore pressed.
28:20 - This tells you all of the keys on the
keyboard that are currently being pressed.
28:23 - And I'm going to say
if and actually this is going to be key
28:27 - really we should call this keys, though,
because this makes a bit more sense.
28:31 - We're going to say if keys and this is pi
28:34 - game dot k underscore left.
28:37 - This is the left arrow key
if you want it to use the a key
28:40 - then you would use a like that.
28:43 - Yeah,
actually I'll go with left arrow kicks.
28:44 - That's what I usually do.
28:45 - But you can use a
or swap it however you want.
28:48 - And then I'm going to say
if this is the case, then player dots move
28:53 - underscore left
and how much do I want to move
28:56 - the player likes
we have to pass the velocity.
28:58 - Well this is going to
be my player velocity. Right.
29:01 - Okay.
29:01 - Next I'm going to say if keys
and this is PI game.
29:04 - Okay, underscore right.
29:07 - Then I'm going to say player dots
move underscore right again same thing
29:12 - I going to move this by my player
velocity.
29:14 - Now it's important that before I do this,
29:17 - I set my player velocity to be zero.
29:21 - Now the reason this is the case is because
if I don't do this, what will happen
29:25 - is as soon as I move left,
this is going to set my player velocity
29:29 - right, which you can see here, my XFL,
it's going to set the X velocity.
29:33 - Now, once
I set that, I'm going to continue moving
29:36 - in that direction
until it gets set back to zero.
29:39 - So if you wanted to make it
so, when you press a key,
29:41 - you just continually move in that
direction until you press a different key.
29:45 - Then you could omit this bonus case.
29:47 - We only want to move
while you're holding down the key.
29:50 - So I'm going to say player to Excel equals
zero.
29:52 - There's a lot of other ways
to go about doing this,
29:54 - but I just want to stay consistent
with our movement
29:56 - because of
how we're going to do the gravity.
29:58 - So for now, just bear with me.
30:00 - We essentially set the velocity to zero
and then if we are moving left or right,
30:04 - so for pressing these keys,
30:05 - then we change the velocity to be,
you know, the negative player velocity
30:09 - or the positive player velocity
based on the direction we're moving in.
30:13 - Okay.
30:14 - That's actually all we need
for handling the movement.
30:16 - So let's put the handle movement function
30:19 - where we're going to put this
we're going to put this before we drop.
30:23 - So it's a handle move
when a passed my player.
30:26 - All right now I need to make sure
before I do this that
30:29 - I call my loop function okay
and I pass my ops.
30:33 - And the reason I need to call loop
30:35 - is because loop
is what actually moves my player, right?
30:39 - If you look at loop, it's
moving my player in the x velocity
30:42 - and y velocity direction.
30:44 - Every single frame.
30:46 - So if I set the x velocity,
well then I continue moving again.
30:49 - If I said the y velocity,
I move in that direction.
30:51 - But that only works if we're continually
calling this loop function.
30:55 - Okay, good.
30:56 - So we've made great progress so far.
30:58 - Let's see if we can move our player
30:59 - where if I've made a mistakes,
which are very likely.
31:02 - So let's run the code and let's see.
31:05 - Okay, so I'm going to hit my right key.
31:07 - You can see I can move to the right
and I can move to the left.
31:09 - Obviously, if I wanted to go up and down,
I could implement that.
31:12 - But we want to have a jumping,
which I will show you in a second.
31:16 - But we kind of need collision
before we can do jumping.
31:22 - Very good. All is looking great so far.
31:25 - Now let's implement gravity
so we kind of fall down.
31:29 - Then we can do kind of the sprite sheets,
31:32 - then we can do the collision
because the collision makes more sense.
31:35 - I guess once we have the
the sprite sheets done.
31:37 - So let's implement gravity.
31:38 - Now gravity is a little bit complicated
because we want to have
31:42 - like kind of a realistic gravity, right,
that actually implement
31:45 - some basic physics.
31:47 - What I mean by that is, rather than just
having a constant velocity,
31:50 - we want to actually have an acceleration
for our gravity.
31:53 - So as many of you know,
if you're in physics gravity,
31:56 - the acceleration is -9.8
meters per second squared.
32:00 - I believe that's what the acceleration is.
32:02 - Anyway, in our game
we want to emulate something similar
32:04 - to that where it feels like the longer
you're falling, the faster you fall.
32:08 - You're not falling at a constant speed
that makes the game
32:10 - just feel like really, really unrealistic.
32:13 - So the first thing we need to do is pick
some value that we want our gravity to be.
32:17 - And this is the acceleration of gravity.
32:19 - So keep that in mind.
32:21 - So for this, I'm going to make a variable
in my player class because it's
32:23 - the only place we need it right now,
I'm going to say is equal to one.
32:27 - So gravity is equal to one.
32:29 - If you want gravity to be faster,
obviously you increment this value, right?
32:32 - Make it large.
32:34 - Okay, now inside of loop, this is where
we need to handle our gravity.
32:39 - So every single frame in our loop,
32:42 - we're going to increase the Y velocity
by our gravity.
32:47 - However, how
we know how much to increase the velocity
32:51 - by varies
on how long we've been falling for.
32:56 - Yeah, I know this seems really weird,
but we essentially need to keep track
32:59 - of how long we've been falling
so that we know how quickly we should be
33:03 - increasing our velocity or how quick
we should be accelerating downwards.
33:08 - So that means that I need to create
a variable here called self-taught count
33:12 - and given we should really call a song
better, I'll call it fall count.
33:16 - And this will essentially tell us, okay,
how long have we been in the air for?
33:20 - How long have we been falling?
33:21 - And we'll use this value to determine
how much we increment our velocity by.
33:27 - So I'm now I'm going to say myself
the y underscore velocity and I'm
33:31 - going to add to this the minimum of one
33:35 - or and I'm going to take myself not count.
33:38 - And this is my fall count
divided by the frames per second,
33:42 - multiplied by the self-taught gravity.
33:45 - Now, this isn't truly
what the acceleration would be, but
33:49 - this will give us a kind of somewhat
realistic looking gravity in the game.
33:54 - So just bear with me.
33:55 - So what we're doing, we're taking our full
count, we're dividing it by FBC.
33:58 - The point of this is that
if I want this value to be in seconds,
34:02 - then I need to take whatever
34:03 - my count is, which I'm going to increment
every single loop.
34:06 - In fact, we'll do this right now,
34:08 - plus equals
one and I divide it by EPS with my FBC 60.
34:11 - As soon as this is 60
that I've been falling for 1/2,
34:14 - I take that amount time,
I multiply it by my gravity
34:18 - and then that tells me how much I'm
going to increment my y velocity by.
34:22 - However, this is going to start out
34:23 - being really, really small, just like
fractional decimal decimal amounts.
34:27 - So just to make this a bit easier for us
when we do our collision,
34:30 - I'm going to increment this
by the minimum of one or this value.
34:34 - So every frame we're moving at least one
pixel down and it doesn't take us
34:38 - like a full second before we really start
feeling any effect of gravity.
34:42 - Hopefully that makes a bit of sense.
34:44 - You guys are understanding me here,
but just bear with me.
34:46 - I've experimented with these numbers
quite a bit,
34:48 - so I think this should be fun.
34:50 - Okay, so now that we have this,
what should happen when I just
34:53 - click Run here is I should just start
falling immediately on the screen.
34:57 - And obviously
34:57 - until we have some platforms, a collision,
we can't really stop falling
35:00 - if we have gravity.
35:02 - But let's have a look
and let's see how it works right now.
35:06 - Okay.
35:06 - So you can see that I fall and notice
I'll do this again,
35:09 - that I start falling slowly
and then it picks up the pace.
35:12 - Right?
35:12 - So this is somewhat realistic
to how gravity would actually work.
35:16 - And that's what I was trying to implement
when I did this.
35:21 - Now that we have done
35:22 - that, it's time to move on
and have some kind of sprites or images.
35:26 - I was going to do this later,
but I realized that we can't really do
35:29 - the collision, which is going to be pixel
perfect collision
35:31 - until we have some kind of images.
35:33 - That's that's really
all we need. We need our sprites.
35:36 - So what we need to do here first
is examine what our sprites look like
35:39 - for our characters.
35:40 - Now, remember all these characters
pretty much the exact same.
35:43 - They just look different.
35:44 - But in terms of their movements,
their animations, the number of images,
35:47 - they're identical.
35:48 - So whatever I show you for one of
these is the same for all of them.
35:50 - Hence
why we can just kind of swap them out.
35:52 - So when I go to Mask dude
here, let's zoom in.
35:54 - You can see that
we have, for example, double jump.
35:56 - I just picked a random sprite.
35:58 - She now this sheet has six different
animations or six different frames
36:02 - which represent what this guy
is going to look like while he's
36:05 - kind of jumping
or double jumping in the air.
36:07 - So what we need to do
is we need to split this one image
36:11 - into the six individual images
and then loop through those images
36:16 - at some frequency or some time
so that we can show them on the screen
36:20 - and show an animation. Right.
36:21 - We need to kind of manually do this.
36:23 - Now, some of these are single frames
36:25 - like falling is a single frame
that's easy hit.
36:28 - Okay?
36:28 - This is like,
you know, the guy disappears for a second,
36:32 - kind of expands, goes back.
36:34 - You get the point.
36:34 - We want to loop through these
animations, idle single frame.
36:38 - Actually,
no, idle. It's not a single frame.
36:39 - It's a bunch of frames.
36:40 - This guys arms
it kind of wagging up and down.
36:42 - We have jump a single frame,
run a bunch of frames and then watch them.
36:47 - Now notice here with these images
that they're in different directions
36:53 - or let's say
they're all kind of facing, right?
36:56 - So another thing we're going to have to do
is rotate
36:59 - this image to face left
when our character is facing left.
37:03 - So that's another thing
we have to handle that not only do
37:05 - we just have to split these images up,
we also have to get a rotated version
37:09 - of them so we can show
you moving in a different direction.
37:12 - Same with jumping and with being idle.
37:14 - Like whatever direction you're going.
37:16 - We need to show
the image flipped in that direction,
37:19 - so don't rotate or flip.
37:21 - That's what we're going to do.
37:22 - Okay, so let's do this
first thing I will do
37:26 - actually, is I'll write the function
that will flip our image.
37:30 - So I'm going to say flip sprites.
37:32 - This is going to take in a list of sprites
and I'm going to return
37:37 - pie game, dot transform,
37:39 - dot flip and this is going to be sprites
37:43 - true false notice as it says here,
37:46 - this is indicating what directions
you want to flip in when I past.
37:49 - True, this means flip in the extraction
when I pass false.
37:52 - This means don't flip in the y direction.
37:54 - If you want to flip both, you'd past
true twice, but we don't want to do that.
37:58 - So I have pie
game to transform the flip sprite
38:00 - and then this is going to be for sprite
in sprites
38:05 - really I could call this image
but you get the point because we have flip
38:09 - now we're going to write a
function which is load sprite
38:14 - sheets
38:15 - and should we call it sheet or sheets?
38:18 - I think sheets is fine
38:19 - and what this is going to do is load
all of the different sprite sheets
38:22 - for our characters.
38:24 - So it's going to give us a spreadsheet
for double jumping,
38:26 - for hitting, for falling.
38:28 - And then within our character we can pick
what sheet we want to be using,
38:31 - what animations we want to loop through.
38:33 - So I'm going to take in directory
one, in directory two.
38:36 - And the reason I'm doing
this is so that I can load other images
38:40 - that aren't just my characters
and this will be very dynamic.
38:43 - I also want to take in the desired width
and height of my image
38:47 - and if we need to load multiple directions
38:51 - so I'm going to say direction equals
false is the default parameters
38:54 - so that we only load like the left
and the right side
38:57 - images like we flip the images
if you passed this equal to true.
39:01 - Okay, now the first thing we need to do
39:03 - is determine the path to the images
we're going to be loading.
39:06 - So I'm going to say join assets
dir one, dir two.
39:11 - Notice I can use join
because I imported this from oh stop path.
39:14 - Okay, now I'm going to get
all of the images in this directory.
39:18 - Now the way I do
that, as often as the images is equal to
39:22 - and this is going to be f for F in list
directory again notice I can use that.
39:27 - So import here.
39:28 - We're going to list all of the things
that are inside of this path directory
39:33 - and then we're going to say if
39:36 - is file and then this is going to be join
39:39 - path and F
39:42 - so what this for loop is going to do here
this I forget what you actually call
39:46 - this when you write a for loop in a list
anyways but this line is going to do
39:49 - here is load every single file only file
39:52 - that is inside of this directory.
39:56 - So again,
we're just going to get every single
39:57 - one of these file names
and then once we have this file names,
40:00 - we can load that image
and we can then split that image up
40:03 - into the individual images
that we want to get.
40:06 - So we have images now I'm going to say
all sprites is equal to a dictionary.
40:11 - And what I'm going to do with this
dictionary is have key value pairs
40:14 - where the key is the,
let's say, animation style
40:17 - and the value is all of the images
in that animation.
40:21 - Okay.
40:21 - So all sprites
now I'm going to say for image in images
40:26 - and I'm going to say that my sprite sheet,
40:28 - so the individual sprite sheet
I want to load here is going to be equal
40:32 - to pie game dot image default load
and then this is going to be join
40:38 - path and image and then dot convert alpha,
40:42 - which is essentially going to allow me
to load a transparent background image.
40:46 - Okay.
40:47 - So we are loading the image
40:50 - which is just one of the files
that we found right from this path.
40:53 - And we just need
to append the path to it, right?
40:56 - So whatever the path to the directory is,
plus the image name.
41:00 - Okay, we're going to load that in.
41:01 - We're going
to get the transparent background.
41:03 - Now that we have this, we need to get
all of the sprites in this image.
41:07 - So going to say sprites is equal to
and now it's going to be a list okay.
41:12 - So again, the processes load
all of the different files.
41:15 - Okay, we have all the files,
these are sprite sheets.
41:17 - Now we need to get all the individual
images from the spreadsheet
41:20 - and load those, get some going,
say for I in range
41:25 - and then this is going to be sprite sheet
get underscore width
41:30 - integer divided by the width of the image
that we're loading now.
41:35 - Width is going to be the width
of an individual image
41:38 - inside of our animation
or inside of our spreadsheet.
41:41 - So if I know this is say 32 pixels,
I pass 32
41:45 - and then it gives me a bunch of images
that are 32 pixels white.
41:49 - That's how I'm doing the loading.
41:50 - So that's why it took width
and height here. Okay.
41:53 - Now that we have that,
we're going to say surface is equal to
41:58 - game dot surface
42:01 - and then this is going to be width
42:05 - height.
42:06 - We're going to pass py game dot s
42:09 - c which allows us to load again
transparent images.
42:13 - And then I'm going to pass 32 here,
which is the depth.
42:16 - Don't worry about that.
42:17 - But this just
what we need to load these images
42:20 - and now we need to create a rectangle
which is going to tell us where
42:24 - in this image, an image
being the sprite sheet that we want
42:28 - to take, an individual image
from and bullet it onto the surface.
42:32 - I know this seems really weird,
42:33 - but what we're doing
is we're going to create a surface
42:35 - that's the size of our desired individual
animation frame.
42:39 - We're then going to grab that animation
frame from our main, main image.
42:43 - We're going to draw it onto the surface
and then we're going to kind of export
42:46 - that surface.
That's the way that we have to do this.
42:49 - So I'm going to say
rectangle is equal to PI game
42:53 - dot rect.
42:55 - And for the rect this is the location
on our original image
42:58 - that we want to grab this new frame from.
43:01 - So I'm going to say this is
I multiplied by my width and then zero
43:05 - and then the width
and the height of my image.
43:08 - Okay, now that I have that, I'm
going to say surface dot bullet.
43:11 - Bullet really means draw
and I'm going to draw my sprite sheet,
43:16 - but I'm going to draw this at zero zero
and I'm only going
43:20 - to draw the portion of it
which is my rectangle.
43:22 - So notice this is my source,
this is the destination,
43:25 - and this is the area of my source
that I'm drawing.
43:29 - So in position zero zero,
which is the top left hand
43:31 - corner of my new surface,
I'm drawing my sprite sheet,
43:35 - but I'm only drawing the frame
from my sprite sheet that I want.
43:39 - Okay, then I'm going to say Sprite,
start, append,
43:41 - and I'm going to append my surface,
but I'm going to make my surface
43:45 - two times larger
because that's what I want to do.
43:48 - I want this to be bigger
than the default size.
43:50 - So I'm going to say pie game dots
43:53 - transform dot scale to x
43:56 - and then I'm going to scale to X
my surface.
43:59 - Okay.
44:01 - Again,
I know this seems a bit complicated, but
44:03 - now we have essentially stripped out
all of the individual frames.
44:07 - We've just scaled them up
to be double their size.
44:09 - So if they're 32 by 32,
we've made them 64 by 64.
44:12 - That's what scale to X does.
44:14 - And now we need to handle the directions.
44:17 - Okay, so now we need to say
44:21 - if direction,
44:23 - then all underscore sprites
and this is going to be image
44:28 - dot replace, it's going to be dot PG,
it's going to be an empty string
44:33 - plus underscore, right
is equal to our sprites.
44:38 - Now we're going to copy the same thing,
44:41 - copy this and put it here
and now this is going to be underscore
44:44 - left is equal to
and this is going to be flip
44:50 - sprites.
44:52 - So what we're saying here is
if you want a multidirectional animation,
44:56 - then we need to add two keys
to our dictionary here
44:59 - for every single one of, our animations.
45:00 - So for falling, for hit, for idle,
we need a left and a right side.
45:04 - So the right side
is the one that we already have.
45:06 - So we're going to say,
okay, all sprites at and then we're just
45:09 - going to strip off the dot page
from whatever the name of our base image
45:13 - was that's going to give us run, jump,
idle, hit whatever the name of our files
45:17 - and then we're going to spend
on her school right or underscore left
45:20 - now for underscore right, that's
our basic sprites for underscore left.
45:23 - We need to flip all of those sprites
and we already wrote the function that did
45:28 - now otherwise
45:29 - then what we'll do is say all
45:32 - underscore sprites at image dot replace
45:36 - dot pinky with an empty string.
45:39 - This just removes that up pinky and
then it's going to be equal to sprites.
45:44 - Okay then we can return
45:48 - all of our sprites.
45:50 - All right.
45:51 - Probably one of the most complicated
aspects of the code that we need to write.
45:54 - So don't worry, we are done now
with loading images at least.
45:58 - Well, we'll have to load our block,
45:59 - but that's going to be a lot easier
than loading our sprite sheets.
46:02 - So this now will load
a spreadsheet for us.
46:05 - Now that we've load our sprite sheet,
we actually want to start using this.
46:08 - So inside of player
we are going to grab our images.
46:12 - So I'm going to say my sprites is equal to
and it's going to be load
46:17 - spreadsheets and now I need to pass
what I want to load.
46:21 - So now I need to pass the main character
directory.
46:25 - And actually this is main characters.
46:28 - Okay, so have a look here.
46:29 - So inside of assets, right?
46:32 - Yes. So we're joining assets with Dir
one in dirt two.
46:35 - So the first directory I pass
is main characters
46:37 - and then I pass the second directory,
which is the name of the character
46:40 - I want to load.
46:41 - So mask dude,
46:42 - ninja frog Pinkman or Virtual Guy,
you can pick whatever one you want.
46:46 - I'm going to go with mask dude for now.
46:48 - Now for width and height.
46:50 - Be within the height of this,
going to be 32.
46:52 - So make sure you do this 30 to 32 and
then you pass through because we want a
46:57 - sprite.
46:58 - So both the left and right side
animations, that's what we want.
47:01 - Okay.
47:02 - Now that we have that,
we are going to change our draw here
47:06 - so that we're drawing our Sprite
now for for now, we're just going to draw
47:11 - like one simple sprite
to see how it looks on the screen.
47:14 - Then I'll go through animating the Sprite
and showing you how that works.
47:17 - Okay.
47:17 - So rather than pong
game, do draw out rect.
47:20 - I'm going to say self
that sprite is equal to
47:23 - and then this is going to be self-taught
sprites at idle.
47:29 - Now Idle is one of the name
for our animations, right?
47:32 - So if we go here
you can see we have idle jump etc.
47:34 - So I'm accessing the key
from my dictionary
47:37 - and then I'm going to access
the first frame of this key, which is zero
47:40 - because every single key
is a whole sprite, right?
47:43 - So now that I have my Sprite, I'm
going to say window applet
47:47 - and then this is going to be self
doubt sprite and I'm going to bullet
47:49 - this at self-taught rect on x
47:52 - and self doubt rec dot
y, which is the position on the screen.
47:56 - And then if we want, we can just
turn off the gravity for right now so
47:59 - we can kind of see it on the screen
and it doesn't just disappear.
48:02 - Okay, let's try this out.
48:03 - Let's just
make sure it actually loaded correctly.
48:05 - So let me run this and we are there.
48:08 - Okay,
so let me see what error we got here.
48:11 - Run this again.
48:14 - It said key key error idle.
48:16 - Okay.
48:17 - So the issue here is that since we load
a directional sprite,
48:20 - we need to reference either
idle right or idle left.
48:23 - So we can actually do this
by saying idle underscore plus self
48:28 - direction.
48:29 - And then so long as we set the direction
which we did here to left,
48:32 - this should work.
48:33 - So now it'll change
based on if we're going left or right.
48:35 - So actually you'll see that it should swap
as we change directions.
48:38 - Okay, let's try this now.
48:41 - All right,
so now we have this guy facing left.
48:43 - If I go right,
he turns right, left, right.
48:47 - Perfect.
48:48 - Now we want to see him animated.
48:53 - So as I was saying,
let's get into the animation.
48:56 - Now, this actually can be pretty easy
48:58 - because we've already loaded
in all of the frames that we need.
49:02 - So I know that
we don't have a ton to show right now,
49:03 - but a lot of the hard stuff
is done for this video,
49:06 - so just make you aware
that all this time has not gone to waste.
49:09 - What we need to do is we need to come up
with something that has a way
49:14 - to kind of update our Sprite or update
what we're showing on the screen.
49:17 - So I'm going to write a function here
49:19 - called Update Sprite,
and I'm going to take itself
49:25 - and I'm going to say Sprite sheet
49:27 - is equal to idle.
49:29 - Now, this is the default spreadsheet.
49:32 - If we're not moving, if we're not jumping,
if we're not falling,
49:34 - if not being attacked, we use idle.
49:37 - However, if we are running
49:38 - or we're doing something else,
then we use the other sprite.
49:40 - So now I'm going to say if my self-taught
49:43 - x velocity does not equal zero,
49:47 - then my sprite sheet
is going to be equal to run.
49:50 - So if I have some velocity in the x
direction, then I'm running, right?
49:54 - So then I want to change this
to the run spreadsheet.
49:57 - So I'm going to say my sprite sheet
name is equal to and this is going to be
50:03 - my sprite sheet plus and then underscore
50:08 - and then plus the self support direction.
50:12 - Perfect.
50:12 - So now we just change the main sprite
sheet name so it'll run, jump, whatever,
50:17 - we add the direction to it.
50:18 - And this tells us,
you know what exact sprite sheet we want.
50:22 - Okay, now that we have that,
what we're going to do is say the sprite
50:26 - that we could be using for this
animation is equal to self dot sprites
50:30 - and this is in all capitals
at the sprite sheet name.
50:35 - All right.
50:35 - Now that we've done that,
we need to essentially iterate
50:38 - through these sprites
and every few seconds change
50:41 - the sprite that we're showing
so that it looks like we're animating.
50:44 - So we need to add a variable here
that is going to account
50:47 - for the amount of delay
between changing sprites.
50:50 - So I'm going to call this the animation
50:53 - delay and make this equal to five.
50:56 - Okay.
50:57 - Now I'm going to come here
and I'm going to say that my Sprite index,
51:02 - which essentially is Sprite
that I want to be using here,
51:04 - is equal to my self dot animation count,
which we're going to increment
51:08 - the second integer divided
by my self-taught animation
51:12 - delay modulus by the length of the sprites
that I'm using.
51:17 - Now, let's just put some parentheses
here for order of operations
51:22 - and let me explain what we're doing.
51:23 - So we have an animation delay
that's every five frames.
51:26 - So every five frames
51:27 - we want to show a different sprite
in whatever animation we're using.
51:31 - So if we're running left, if we're idle,
whatever, it doesn't matter.
51:34 - We want to show a different one.
51:35 - So we take the animation count,
we divide it by five,
51:38 - and then we mod
whatever the line of our sprites is.
51:41 - So if we have five sprites,
then when we're on, say, animation,
51:44 - count ten,
we're showing the second sprite right?
51:47 - You get the idea.
51:47 - So this is dynamic.
51:48 - This will not work for any single sprite.
51:51 - So hopefully you guys understand how
this animation count is kind of working.
51:54 - But we're trying to pick a new index
every animation frames
51:58 - from our sprites,
but we want this to be dynamic.
52:01 - So we're using the length of the sprites.
52:03 - And again, it's just it's dynamic work
for any single sprite sheet we have now.
52:08 - We need to select our sprites.
52:09 - We say self-doubt
52:10 - Sprite is equal to the Sprite,
so we have access to at the Sprite index.
52:15 - Then we update our animation count by one.
52:18 - Now what we can do
is remove this here from draw
52:22 - and we just need to now call the self dot
52:26 - update sprite from our loop.
52:29 - Okay.
52:29 - So now that we've done that,
we'll call this, we'll update our Sprite
52:33 - every single frame and then we'll draw
that updated sprite on the screen.
52:38 - Okay, let's run
it and let's see what we get.
52:41 - Notice, we have idle notice.
52:43 - I can run to the right
and I can run to the left.
52:47 - Now, if you think this is too slow
52:48 - and some of you may argue that it is,
then you just make this number smaller.
52:51 - So make this three.
52:54 - Okay.
52:55 - And now it looks like
we're running a little bit faster.
52:57 - So it's completely up to you
how you want to animate this.
53:00 - I'll do two for now
and let's see if this looks better.
53:05 - So actually,
53:06 - I think three was a pretty kind of happy
medium here since go back to three again,
53:10 - you guys can change this. It's up to you
how you want it to look.
53:12 - Okay, now that we have that, we're
almost ready to start doing collision.
53:16 - However, we need to introduce
something known as a mask.
53:20 - So I'm going to make another method
here and say, define update.
53:25 - Now what we need to do here
is essentially update the rectangle
53:30 - that bounds our character
based on the sprite that we're showing.
53:34 - So it's different
like kind of sizes to the sprites, right?
53:38 - Some are a little bit taller,
some are little push
53:40 - the left or pushed to the right.
53:41 - And the rectangle that we have,
we want to be essentially the same
53:45 - as the sprite that we have.
53:48 - Again, I know this seems a bit weird,
but we're going to do this
53:51 - are going to say self
direct is equal to self dot
53:55 - and then it's going to be sprite
get underscore rect.
53:59 - And we're going to say
that the top left of this rectangle
54:02 - is equal to the self direct dot x
54:07 - and these self-correct dot y.
54:09 - Now pretty much what's going to happen
here is depending on what Sprite we have,
54:13 - if it's slightly smaller, slightly bigger,
whatever,
54:15 - we're going to constantly
adjust the rectangle
54:18 - specifically we're going to adjust
the width and the height of it,
54:21 - but we're going to use the same
x and Y position that we've had
54:24 - for this rectangle.
54:25 - If you don't understand that, it's fine.
54:27 - It's not a massive deal.
54:28 - This line is not crazy important,
but it's just trying to make sure
54:31 - that the rectangle we're using
to kind of bound our character is
54:34 - constantly adjusted
based on the sprite that we're using.
54:37 - Now, what's more important
is this line, which is updating the mask.
54:40 - We're going to say self,
that mask is equal do pi game dot mask
54:45 - dot from the surface
and it's going to be self-taught sprite.
54:50 - Now let me quickly explain this.
54:51 - A mask is essentially a mapping of all
of the pixels that exist in the Sprite.
54:57 - So whenever we draw
something on the screen,
54:58 - we're really drawing a rectangle, right?
55:00 - But the rectangle may not have
nontransparent pixels, right?
55:05 - So only part of the rectangle
is actually filled in.
55:08 - Hence why we get kind of a circular image,
a dynamic image, whatever.
55:12 - So what this mask tells us
is where there's actually images
55:15 - or where is not
where there's actually pixels. Sorry.
55:17 - And this mask allows us to perform
pixel perfect collision
55:20 - because we can overlap it with another
mask and make sure that we only say two
55:25 - objects collide if pixels are colliding,
not if the rectangular box is colliding.
55:31 - If we did rectangular collision,
then it constantly looks like
55:33 - we're hitting something
even when we're not.
55:36 - Because the rectangle for
55:37 - our character is larger than where
all of the pixels for our character are.
55:41 - You've probably seen this
in a lot of games before,
55:43 - but what the mask does is solve
that problem for us
55:45 - and allow us to do this
kind of pixel perfect collision.
55:48 - It's very important,
though, that you call this mask.
55:51 - If you don't do that, this
collision is not going to work properly.
55:54 - It needs to be mask because the sprite
that we inherited from here
55:58 - uses this rectangle and uses this
mask property when it does the collision.
56:04 - All right.
56:04 - So now that we've done this,
I just need to call this function.
56:07 - So I'm going to go here
and say self-deport update
56:10 - and now we're done
with most of what we need
56:12 - for the player.
56:17 - So what we want to do now is
we want to start
56:18 - adding blocks onto the screen
and then letting a player fall, collide
56:23 - with those blocks
and then be able to jump.
56:24 - Because obviously we can't really jump
until we have something to jump off of.
56:28 - Otherwise, jumping in thin air
doesn't make a ton of sense.
56:32 - All right.
56:32 - So let's create another class here.
56:35 - And this class I'm going to call object.
56:38 - And this will be a base class that we use
for essentially all of our objects,
56:42 - just so that the collision will be uniform
across all of them.
56:45 - So again, we're going to inherit
from the Sprite class from PY game
56:48 - and we're going to define
our initialization.
56:51 - So define a net.
56:53 - We're taking self x, y, width
56:56 - and height and name
56:58 - which for now is going to be equal to none
but could be equal to something.
57:02 - Or they're going to say
super dot underscore underscore init
57:06 - which will
57:06 - initialize the superclass,
which is this one right here.
57:10 - Now the reminds me we need this as well
in our constructor for player.
57:15 - So let's put that in player.
57:17 - Okay, now we need to define a rectangle
and say self.
57:21 - That rectangle is equal to py game
dots rect
57:26 - and then this is going to be x, y,
57:29 - width and height.
57:32 - We're going to say
self-taught image is equal
57:35 - to py game
57:38 - dot surface
and then this is going to be width height
57:43 - and then we're going to say py game
dot source
57:47 - alpha like that
if we spell py game correctly.
57:50 - Again, this just supports transport
transparent images for us.
57:54 - My apologies.
57:55 - And then we're going to say
self-taught width equals width.
58:01 - Self-taught height
58:03 - is equal to height and self-taught name
58:08 - is equal to name.
58:09 - Where I'm going to say define draw,
58:13 - I'm going to say self and window like this
58:17 - and then we're going to say win doublets.
58:21 - And this is going to be self-taught image
58:23 - and then we're going to split this
at the self dot rect
58:28 - dot x and he's self-correct
58:31 - dot y okay I know I went fast.
58:34 - Essentially, this is just a base class.
58:36 - We're not actually going
to instantiate this, but this just defines
58:39 - all of the properties
that we need for a valid sprite.
58:42 - So we have a rectangle, we have our image,
58:45 - we are drawing the image
and then in a class.
58:48 - So we're about to use,
we're going to inherit from this
58:49 - and it will just save us from rewriting
58:51 - a bunch of functionality
that we don't need.
58:53 - So the idea here
is that all we do is modify this image.
58:57 - When we change the image now,
the draw function will automatically draw
59:00 - it accurately on the screen for us.
59:02 - And all these other properties
59:04 - we're just saving
in case we need them from our child class.
59:08 - So I'm going to make a class now
called BLOCK.
59:10 - This is going to inherit from object.
59:13 - Now we're going to say define init
59:16 - around second self, x, y
and the size of our block.
59:19 - Now since the block is a square,
we just need one dimension not too right.
59:24 - We're going to say super
59:26 - dot underscore underscore init.
59:28 - We're going to pass X-Y
59:30 - size size.
59:32 - So notice
this constructor requires four arguments.
59:34 - We have to pass four here.
59:35 - We just duplicate size because
it's the same for the width and height.
59:39 - Then we're going to say
block is equal to load block,
59:43 - which is going be a function that we write
in a second that will take a size.
59:47 - We're going to say self, image, doublet.
59:51 - Imagine that this is going to give us
an image, okay, which it will in a second.
59:54 - When we write it, we're going to hit
the block at position zero zero
59:59 - and then we're going to say
the self dump mask is equal to py game
60:04 - don't masked from surface
60:07 - we're going to take our self that image
60:10 - and there you go we have our mask
which we need for collision.
60:13 - Okay, again,
I know this is a little confusing.
60:16 - It'll make more sense in a second,
but we're using this object
60:19 - which now has this draw function
built in for us.
60:21 - It also defines
60:22 - subtract, it defines the width and height
and all of that stuff.
60:25 - Here, what we do
60:25 - is we get the image that we need,
which we're going to write this in 1/2,
60:29 - then we bullet this image to our image,
which is a pie game surface.
60:34 - And then we say self-doubt mask
60:36 - you you'll do piling up to mask
the from surface self-doubt image.
60:38 - We also could just say self
60:39 - that image is equal to the block,
but let's do it this way for now.
60:44 - Okay,
so let's now write our get block function,
60:46 - which I'm going to do beneath
our get sprite sheet or load spreadsheets.
60:50 - I'm going to say get
60:53 - and I'm going to take in a size.
60:55 - Now what I need to do here
is essentially find the block that I want
60:59 - in my train folder.
61:00 - So I'm going to say path is equal to join
61:04 - assets and
then this is going to be terrain like so.
61:09 - And then we're going to use the terrain
dot PNG file.
61:13 - So if I go here, you could see that
we have terrain, terrain
61:16 - and then what
we want to do is load this block,
61:19 - which I'll be showing you
how to load in 1/2.
61:23 - Okay.
61:24 - Now that we have done that, now
that we have our path, we're going to say
61:26 - the image is equal to py game
dot image, dot load and we're going to say
61:32 - path again to convert alpha
so that we get a transparent background.
61:36 - We don't really need it for this one.
61:37 - But just in case later we load string
does have transparency.
61:40 - We will and we're going to say surface
is equal to pi game dot surface.
61:46 - And for the surface we're in a past size
size which is the width
61:50 - and the height of our surface and past
pi game dot source alpha with a
61:56 - depth sorry of 32
61:58 - we're going to say
rectangle is equal to pi game dot rect
62:03 - and then this is going to be 96
zero size size.
62:08 - Now let me slow down for 1/2.
62:09 - If we go to terrain, we can see that
we want to load this guy right here.
62:15 - Now, I've already done the math.
62:16 - This image starts
96 pixels from the top of the screen.
62:21 - So that's the reason I'm putting 96 there
because I want to start at 96.
62:24 - So 96 zero is my position
and then I want to load the size of this,
62:28 - which I think is going to be either 96
or 64 or something along those lines.
62:33 - Anyways, if I wanted to load, say, this
train image, then I would still have 96.
62:37 - But my y position would be different.
62:39 - In fact, the Y position would probably be
a little bit less than 96.
62:43 - It might be 80, it might be 85.
62:44 - I'd have to experiment with it
to see exactly where this image starts.
62:48 - But I just want you to understand that
what I'm passing here,
62:51 - when I say something like 96 zero,
I'm passing the position
62:54 - that I want to load the image
from from the image, right?
62:59 - So I'm picking out a part of this image
and this is like 96 zero.
63:03 - That's where I am picking it right here.
63:05 - Hopefully you guys understand that.
63:07 - But if you want to load
a different train image,
63:09 - then you have to adjust these
to be the starting position, the top left
63:12 - hand corner of whatever image it is
you want to load here.
63:16 - And if yeah,
63:17 - I was going to say
we can load different one,
63:18 - but I don't want to waste time guessing
which one it is.
63:21 - So you guys can mess with that
if you want.
63:22 - But let's just load this top one,
which I already know works.
63:25 - Okay,
now that we have that ran, it's a surface
63:28 - dump blitz
and we're going to blitz the image
63:33 - and again,
we're going to blitz it at zero zero,
63:36 - but we're only
63:37 - to hit the area of it
which is represented by the rectangle.
63:40 - Then we are going to return high game dot
63:43 - transform dot scale to x surface.
63:49 - Okay, so we've passed what size
we want our block to be.
63:55 - Then we create an image
that is of that size.
63:58 - Okay.
63:58 - We then say rectangle is equal to 96
zero size size.
64:02 - Right?
64:03 - And then we blitz
this image onto our surface,
64:06 - which will be the image that we return.
64:08 - And we return this scaled up by two times.
64:10 - So it just doubles the size that we pass
here.
64:12 - You don't have to scale it
if you don't want,
64:13 - but I want it to be larger
so I am scaling.
64:16 - Now I understand again, Spike,
64:18 - if using this size is going to be
the dimension of this block,
64:22 - so you want to pass
64:23 - whatever the size from this sprite sheet
is that you want to get.
64:26 - In our case, I think it's going to be 64
or something along those lines.
64:29 - So that's what size will be.
64:32 - You guys can mess around with this,
but really
64:34 - what you're going to be changing
is these two values and the size.
64:37 - That's what you're going to change
64:38 - when you want to load a different image
for your block.
64:41 - Okay, so now for block,
we have to block or load block.
64:45 - I call it load block or get block.
64:47 - I called it get block.
64:48 - Okay,
so let's change this to be get block.
64:52 - All right.
64:53 - So now have a block.
64:54 - Let's create a block.
64:56 - Let's draw a block on the screen and let's
do some collision with our blocks.
65:01 - Okay?
65:01 - So let's go here to Main
65:04 - and let's say blocks is equal to and let's
just start by creating a single block.
65:09 - So for our block, let's
just put it kind of randomly
65:12 - on the screen for now
where do I want to put this?
65:15 - Let's go with something like
65:20 - actually, I'm going to create
a variable first, say block size.
65:23 - Let's put this at zero height
65:26 - minus the block underscore size.
65:30 - BLOCK size is going to be equal to 96.
65:32 - Okay.
65:33 - And then for the size we're going to pass,
block size.
65:38 - Okay.
65:39 - So the size of our block is actually 96.
65:41 - I lied.
65:41 - It is not 64. It's going to be 96.
65:45 - So we're going to create a block
65:46 - that's going to be positioned at zero
height, minus block size,
65:48 - which is going to put it
at the bottom of the screen.
65:51 - And then the size is this.
65:53 - Now we need to draw blocks.
65:54 - So I'm going to pass
blocks to my draw function.
65:57 - Okay.
65:58 - And I'm going to go here
and actually let's call this objects
66:03 - and we're going to say form objects
66:06 - or for objects in objects.
66:09 - If we could type this correctly,
66:13 - object dot draw.
66:15 - I'm struggling here with the typing
and we will draw this on the window.
66:19 - Okay, so we have our block now.
66:22 - Let's quickly look at this again right.
66:23 - We load her image.
66:24 - Okay, we got a block,
we have her size now.
66:26 - We create the block down here
and then we put it on the screen.
66:31 - Let's run it and see if we get a block.
66:33 - And of course, we got an error.
66:35 - What's it say here?
66:36 - I need to run this again.
66:39 - I take zero positional arguments,
but one was given.
66:42 - Okay, so let's go to our player class here
66:45 - and we can see update.
66:46 - I forgot to add the self parameter, so
let's add that in and that should fix it.
66:51 - Okay.
So now you can see that we have a block.
66:54 - So now what we can do is create a whole
floor of blocks if we want to do that
66:57 - and then we'll implement gravity
and then collision with the blocks so that
67:00 - you can see that you can land on the block
and we can jump off of the block.
67:04 - All right, so let's make a whole floor.
67:06 - So to make a floor,
we can do this instead.
67:09 - Floor is equal to we're going to say.
67:12 - BLOCK It's going to be high
67:15 - times.
67:17 - BLOCK Size.
67:21 - It's going to be height,
minus block size, block size
67:25 - for I in range.
67:29 - And I'm going to say a negative width
67:31 - with times two.
67:34 - And we're going to divide this
67:37 - by the block size
67:39 - and by block size.
67:42 - Then for my
67:44 - blocks, let's actually just
67:47 - replace this
and instead we'll just pass for
67:50 - okay, what I've done here with this
for loop is I've said I want to
67:54 - create blocks that go kind of to the left
and to the right of the screen.
67:59 - So I don't want to just fill
the current screen
68:01 - because we're going to have scrolling
68:01 - background in the second,
which will implement in a minute.
68:04 - Anyways, I want to have some kind of go
into the left and some going to the right.
68:06 - So I'm taking my negative
with over the block size,
68:10 - which is how many blocks
I want to the left side of the screen.
68:13 - And then I'm taking my width times
two and I'm integer
68:16 - dividing that by the block size again.
68:18 - That's how many
I want to the right of the screen.
68:21 - Then I'm taking I, I'm multiplying it
by my block size, which is telling me
68:25 - the x coordinate position
that I want my block to be on.
68:30 - And then
68:31 - this is always going to be same because I
want it to be at the bottom of the screen
68:35 - and then for my block size, well,
I want that to always be the same.
68:38 - Okay.
So let's run this now and see what we get.
68:41 - And now we get a bunch of blocks.
68:43 - So now that we have these blocks, let's
make it so we can collide with the blocks.
68:47 - And so we have gravity
and we actually fall onto those blocks.
68:54 - So the collision all right.
68:56 - Collision is a little complicated, but
68:59 - let's write it and let's see how we can
how we can get it going here.
69:04 - So inside of Handle Move is where
we're going to handle our collision,
69:07 - which means
69:07 - we need to have a list of objects
that we can potentially be colliding with.
69:12 - Now, we are going to write a function here
called
69:15 - Handle Vertical Collision
69:18 - because we need to handle the vertical
and horizontal collision differently.
69:22 - For now,
we'll just start with vertical orientation
69:25 - player objects and the displacement
in why that we just moved
69:30 - now we're going to have collided
underscore is equal to a list
69:34 - I'm going to say for object in objects.
69:38 - These are all the objects
we could be colliding with.
69:40 - I'm going to say if my game
69:44 - dot sprites, dot collide mask
69:48 - and then we're going to pass our player
69:52 - and our object.
69:55 - Now, remember, I told you
Collision was going to be simple.
69:57 - Well, there you go.
69:59 - This is all you need to do to determine
if two objects are colliding.
70:01 - The reason we can do this
is because our objects we've inherited
70:05 - from the Sprite class and on them
we have a mask.
70:08 - So we're going to use this mask property
as well as the rectangle property.
70:11 - When we collide with the mask.
70:13 - So I passed my player,
I passed my object and this will tell me
70:16 - if I am colliding with my object.
70:19 - Perfect.
70:20 - Now if I am, I'm going to do some stuff
differently
70:24 - depending on what direction
I'm colliding in.
70:25 - So if I'm hitting the top of the object,
70:27 - it's going to be different
than if I'm hitting the bottom.
70:29 - So we need to handle that here.
70:31 - So I'm going to say if my displacement
Y is greater
70:34 - than zero, really,
this should be velocity.
70:37 - But this fine, then
what I'm going to do is place my character
70:42 - on top of the object it collided with,
so I'm no longer colliding with it.
70:47 - Now, what this is saying
is if I'm moving down on the screen,
70:51 - so if I'm moving down,
70:52 - then that would mean I was colliding
with the top of this object.
70:55 - So if I am, I'm going to take the bottom
of my player
70:58 - rectangle, which is my bottom,
my players feet essentially.
71:01 - And I'm going to make it equal
the top of the object.
71:05 - I'm colliding with this.
Another advantage of using rectangles.
71:08 - You can use this kind of bottom
and top property and avoid having to do,
71:11 - you know, add the height
and that kind of stuff.
71:13 - So that's what I'm going to do now.
71:15 - Otherwise I'm going to say
71:16 - if my display so y is less than zero
and I suppose this can be an elf,
71:20 - then what I will do
71:22 - is say my player direct top
71:25 - is equal to the object rect bottom
because if I'm moving up,
71:29 - which means I have a negative velocity,
then I am hitting the bottom of an object.
71:34 - So I need to make my top
be equal to the bottom.
71:37 - Okay.
71:37 - This just makes it so you don't like, say,
stay inside of the object.
71:41 - Excuse me?
71:41 - You go outside of it
71:43 - and it looks like you collided,
but you didn't go through the object.
71:46 - Now, one thing we also need to do here
is need to call the method player
71:50 - down landed and player dot hit head,
which I've not yet created.
71:54 - And we're going to write these to handle
what happens when we land on a block
71:58 - and when we hit our head on a block.
72:00 - Okay, then we're going to say collided
objects, dot append
72:03 - and we're going to append our object and
we're going to return our collided objects
72:08 - just so that we know what objects
we collide with so that we can check
72:12 - if we collided with like fire or a certain
special object or something like that.
72:17 - Okay, so let's handle vertical collision.
72:19 - Now we need to write the landed
and hit head method.
72:24 - So let's go to player and let's do this.
72:27 - So I'm going to say let's do it here.
72:30 - Landed
72:32 - Self.
72:33 - Now what do we do if we landed?
72:36 - Well, if we just landed, then we need to
reset our gravity, our fall counter.
72:41 - So we're going to say self
dot fall count is equal to zero.
72:46 - So that way we stop like adding
gravity, right?
72:50 - Okay.
What else do we need to do if we land?
72:52 - We need to say that our y velocity
is equal to zero.
72:55 - If we let it on a block, stop
moving us down and I'll add this in.
73:00 - Now we're going to say our self,
that jump count is equal to zero.
73:03 - We're going to do something
with jumping that involves double jumping.
73:06 - So we'll have a jump counter.
73:07 - I'll just put this here now
and then we'll use it later.
73:10 - Okay, so that's if we landed.
73:11 - Otherwise I'm going to say
define hit head for self.
73:16 - I'm going to say self doubt count equals.
73:19 - If we hit our head,
I want to reverse our velocity
73:22 - so that now we move down
because we're moving up, right?
73:25 - So I'm going to multiply my velocity
by negative ones that when I hit my head,
73:28 - I kind of bounce off the block
and go downwards.
73:30 - That's what's going to look most natural.
73:32 - Okay, so that's all we need for right now,
for hitting the head.
73:34 - Now we can add our gravity back
and when we add our gravity back,
73:38 - what's going to happen is will fall.
73:40 - We'll hit the block,
we'll move us to the top of the block,
73:43 - and then we should just build a move
on top of the block.
73:45 - Let's see if that's going to work, though.
73:47 - Although it's not going to work
if we don't add the function call.
73:51 - So let's add
the function call here in handle move.
73:55 - We're going to say
73:57 - handle vertical.
73:59 - We'll pass the player,
the objects and the player y velocity.
74:04 - And the y velocity is essentially
how much we just moved right.
74:09 - Okay, very good.
74:11 - Now let's make your handle move.
74:13 - We need to pass our floor,
so let's do that.
74:17 - All right, let's run the code.
74:19 - Let's see what we get.
74:21 - And boom, look, we land on a block
74:24 - and we can now run on top of the block
74:27 - and everything is looking very good to me.
74:31 - Okay, so that's pretty good.
74:32 - Now that we're on top of a block,
74:33 - we can jump
and then we can deal with hitting blocks.
74:37 - What do you call this?
74:38 - Horizontally, right?
74:39 - So that we can't, like, run into a block
and we'll also make the background scroll
74:43 - and then we'll be pretty good.
74:45 - We'll have a lot of this tutorial
finished.
74:51 - I want it to make us jump. Yes,
let's make a jump.
74:53 - Okay.
74:53 - So let's go to our player
and let's create a variable here.
74:57 - Self-taught jump
underscore is equal to zero.
75:01 - Now, based on the way of coded,
this jumping is actually quite easy.
75:04 - I can say define jump self
75:08 - and when we jump all we're going to
75:11 - do is say self doubt
y underscore velocity is equal
75:15 - to the negative of self dog
gravity multiplied
75:18 - by whatever factor you want in
terms of the speed of your jump.
75:21 - So I'm going to multiply gravity by eight.
75:23 - The reason I'm doing this negative
is that I jump up in the air, right?
75:27 - So now that I've done this will happen
is as soon as I hit the jump key,
75:31 - I'll jump up into the air.
75:32 - It's pretty straightforward.
75:33 - And the reason that's going to happen
is because my y velocity will change
75:37 - and what will bring me down
is the fact that inside of my loop,
75:41 - if I go to where loop is, I'm constantly
applying downward gravity.
75:45 - So what I'm doing is changing
75:46 - my velocity to go upwards
and then I'm letting gravity take me down.
75:50 - So that's kind of the benefit
of how we've quoted this.
75:53 - Jumping is very easy.
75:54 - Now I'm also going to reset my animation
count to zero.
75:57 - I'm going to say my jump count
plus equals one.
76:00 - I'm going to say
if the self-taught jump underscore count
76:08 - is equal to
one, this means that I'm double jumping.
76:11 - So if the jump counts equal to one
76:13 - when I hit jump, that means it's
just going to be equal to two.
76:16 - Now, let me take this.
76:18 - Sorry and put this down here.
76:20 - Then I will say self
76:22 - account is equal to zero.
76:26 - Yeah, I think so.
76:28 - That makes sense.
76:31 - No, I want to do it this way, sir.
76:33 - Okay, so what I'm trying to do here
is make it so that as soon as I jump,
76:36 - I essentially get rid of any gravity
I've already obtained.
76:40 - So let's say I was, like, falling.
76:42 - And then I landed and then I jumped.
76:44 - There would be some gravity on me
keeping me on the ground.
76:47 - So I want to remove that gravity
so that when I jump up,
76:50 - it's in the factor,
like it's not taking into account
76:53 - and then I'll start applying the gravity
after I jump.
76:56 - Hopefully that makes a bit
of sense, but this should say
76:59 - fall count.
77:01 - So as soon as I jump, I'm resetting
the fall count to be equal to zero
77:04 - so that any gravity
I've accumulated I'm removing.
77:08 - But I'm only doing that
if this is the first jump I'm making.
77:12 - Because for the second jump
77:13 - I want you to have to time it based on
like when you're jumping, right?
77:17 - So if you jump a second time close
to when you jump the first time,
77:22 - you will jump higher than if you jumped at
77:23 - like the peak of your jump
when you're gravity would be the highest.
77:26 - Okay. I don't know if that makes sense,
but just just fall along here.
77:29 - This I mess with this before this works,
trust me.
77:33 - All right.
77:33 - So we have jumping now.
77:34 - I think that's all we really need.
77:37 - Jumping? Yeah, that seems good to me.
77:40 - So now if we want to jump, let's make it.
77:42 - So when we hit space, we jump
so we can do that inside of handle move.
77:46 - Actually, I'm not going to do it.
77:47 - Handle, move.
I'm going to do it here in the event loop.
77:50 - And the reason for this
is that if I do it in handle move,
77:53 - what's going to happen
is if I press the jump key
77:55 - and I hold the jump key down, I'm
going to keep jumping a bunch of times.
77:59 - I don't want to do that.
78:00 - I just want to jump
once when I hit the key
78:02 - and then I have to release the key
and press it again to jump.
78:05 - This tells me if I'm holding down the key,
78:07 - what I'm going to do in here
tells me if I released the key.
78:10 - Yeah, you'll see.
78:12 - Yeah, this is the dude.
78:13 - So I'm going to say if event type is equal
to PI game dot key down,
78:19 - then we say
if events dorky is equal to pi game.
78:25 - Okay, underscore space and
78:29 - my player dot jump count is less than two.
78:33 - So I'm going to allow
double jumping. Right.
78:35 - So I'll have two jumps
then I'm going to say player dot jump.
78:40 - Okay,
that should be all we need for jumping.
78:43 - So let's try it out
and let's see if this works
78:47 - and I can jump
78:49 - and notice I can kind of run and jump
at the same time.
78:52 - Now what I'll do now is add
like falling and jumping animations
78:56 - because obviously it looks kind of weird
right now when I'm jumping,
79:00 - but there you go. We can jump. Nice.
79:02 - Okay, so let's add the the animations now.
79:05 - So if we go to update Sprite,
all we need to do here is we'll say if
79:11 - self dot and actually
79:15 - I need to refer to my cheat sheet here
because this is a bit more complicated.
79:18 - I thought, I mean to say if not self if
self doubt y underscore velocity does not
79:22 - equal zero, then what I will do is say if
79:26 - self-taught jump count equals equals one,
79:31 - then I'm going to say
my sprite sheet is equal to jump.
79:36 - I'm going to say self, self
79:38 - don't jump count equals equals to.
79:41 - Then my spreadsheet is equal to double.
79:47 - Now this is actually going to be
79:48 - if my velocity is less than zero,
which means I'm moving up.
79:52 - Now, the next one that I want to add
is I want to say if
79:55 - and actually these are all going to be LFS
79:58 - Well not that one,
but this one I'm going to say f myself.
80:02 - The y underscore
vowel is greater than zero this means.
80:05 - I'm moving down, then my spreadsheet
should be equal to fall.
80:11 - Okay,
80:12 - so this
is handling regular jump and double jump
80:15 - and this is telling me
if I'm falling, let's try it now
80:19 - and let's see what happens when I jump.
80:22 - Okay,
so it's kind of glitching a little bit.
80:24 - The reason this is happening,
I believe, is
80:26 - because we are applying gravity
even while we're on the ground.
80:31 - So my y velocity
is always greater than zero
80:35 - and something greater than zero
that's greater than zero again.
80:38 - So I will show you how to fix this.
80:40 - All right.
80:41 - So actually, the way that I'm going to fix
80:42 - this is a bit of a hack,
but it's it's going to be good.
80:46 - No work here.
80:47 - So I'm actually going to say if my self
the Y velocity is greater than self,
80:53 - dot's gravity times two.
80:58 - Now the reason I'm going to do this for
fall is so that I don't immediately
81:02 - start glitching into this false state
when I have a really low amount of gravity
81:06 - being applied to me
81:07 - when I've gone off the block
and then I've fallen down to the block.
81:11 - So let me show you what I mean by
just kind of running the code here.
81:13 - So You can see that
what happens is when I hit the block,
81:16 - when I collide with it, it's
going to reset my gravity count
81:19 - and then I'm going to kind of spawn
to the top of the block.
81:22 - So when I'm on the top of the block, going
to be slowly falling down to the block.
81:26 - Then I'm going to hit the block.
81:27 - When I hit the block, it's going
do the same thing.
81:28 - It's going to bring me to the top, reset
my gravity count.
81:31 - So what was happening before is that
we would go to the top of the block
81:35 - and then our gravity would increase
a tiny bit, right, to increase
81:38 - to be one pixel
per second or something along those lines,
81:41 - which would mean we were falling.
81:42 - So then we were falling.
81:43 - We hit the block and then it reset it so
it kept glitching between the two states.
81:47 - So what I've done is just made it.
81:48 - So we have to have a significant amount
of gravity
81:50 - before it starts showing that false state.
81:52 - So now it doesn't look glitchy on the
screen as I'm jumping around.
81:57 - And you
can see that what actually happened is
81:58 - when I jump
and I get to the peak of my jump,
82:00 - you can see that
it starts the falling state
82:03 - because right now
my velocity is change directions.
82:06 - Right now I'm going down.
82:08 - Okay, so now we have jumping,
now we have running around
82:11 - and colliding with blocks
then quite a bit actually.
82:13 - The next thing I want to do is make it
so that objects move on the screen.
82:17 - Then we will do our horizontal collision
and then we will pretty much be done
82:22 - after I add kind of that
like fire state, right?
82:24 - Or that let's call it a trap,
something like that.
82:30 - Okay.
So we want to do scrolling background.
82:32 - Scrolling
background is actually fairly easy.
82:34 - The way that we do a scrolling background
is we simply offset
82:37 - every single thing that we're drawing
on the screen by a certain amount.
82:41 - So any object that we have,
we don't change its position at all.
82:44 - We just change
82:45 - how we're drawing it on the screen
so it doesn't affect any of our collision.
82:49 - All it affects is what's seen, right?
82:51 - So what's happening in
82:52 - the background is we may be colliding
at a really far position to the right.
82:55 - We're showing the position
currently on the screen.
82:59 - You see what I mean?
83:00 - But what this involves
83:02 - is having some offset
X, which I'm going to say is equal to zero
83:05 - now the way that I want to have it
and I'll just illustrate here,
83:08 - is that when I'm on the screen,
83:10 - I only start scrolling the background
when I get close to the edge.
83:13 - So like here, right?
It would start scrolling.
83:15 - Whereas if I'm in the middle
and I'm kind of moving like this,
83:18 - don't want it to scroll the background
until I get to the edge.
83:21 - Oh, also notice you can double jump here.
83:22 - I kind of forgot to mention that part,
83:25 - so I'm going to implement that where
essentially once
83:28 - we reach a certain boundary,
then the screen will start scrolling.
83:32 - All right, so how do we do this?
83:33 - Well, we can do it
just directly inside of our loop here.
83:37 - We're going to do it here.
83:39 - We're going to say if B player dot rect
83:43 - dot x minus the offset x
83:47 - plus the player direct dealt with.
83:50 - And actually,
now that I think of this, we're
83:52 - just going to do this, we're going to say
if the player dot rect dot right
83:56 - which will account for the width minus
83:59 - the offset x is greater than or equal to
84:04 - the width
84:07 - minus a variable
84:08 - that I'm going to write in a second,
which is scroll area
84:11 - width and any Blair dot
84:14 - x underscore
velocity is greater than zero.
84:19 - Then we
are going to say offset underscore x
84:24 - and this is going to be plus
84:26 - B player x velocity.
84:30 - All right, let me just write this variable
then I'll explain how this works,
84:33 - because we also have to do the other side.
84:35 - So as I scroll area with is equal to 200.
84:38 - What that means is that
when I get to 200 pixels on the left
84:41 - or 200 pixels on the right of the screen,
I start scrolling,
84:44 - okay, so here what I'm doing is
I'm checking if I am moving to the right.
84:48 - That's what this checks.
84:49 - If my x velocity is greater than zero,
that means I'm moving to the right
84:53 - and this is checking
if my character is right on the screen,
84:59 - like if it's crossed a specific boundary.
85:02 - So I take whatever
the right position of my player is,
85:05 - which could be very far off the screen.
85:08 - I subtract
whatever offset we currently have.
85:12 - So if we're offsetting everything
by 100 pixels, for example,
85:16 - I subtract that so I know where
I'm actually
85:18 - showing the character on the screen
and I say if that's greater than the width
85:22 - minus the scroll area width,
which means I'm at say 700 pixels,
85:25 - something like that on the right side
of the screen, then I'm going to offset
85:30 - the screen by whatever the velocity was
that my player just moved to.
85:34 - Right?
85:34 - So that will make it look like I'm
scrolling.
85:37 - Now we can say or and do
the exact same thing for the left side.
85:41 - So I'm going to say if player dot rect
85:45 - dot left
85:47 - and this is actually going to be
is going to be plus the offset.
85:51 - I'm going to check
if it's plus or if it's minus.
85:52 - No, it's going to be minus again. Minus.
85:54 - The offset x is less than or equal
to the scroll area width
85:59 - and my player dot
86:01 - x underscore value is less than zero.
86:05 - Then I want to do this now.
86:06 - Let's move this down on the screen a bit.
86:09 - I'm just going to add some parentheses
that my condition is
86:13 - correct.
86:17 - Okay. So I think that should be good.
86:18 - Again, I'm checking to the left
and to the right side.
86:21 - If I'm moving to the left,
I want to check if I'm at that boundary,
86:24 - if I'm checking to the right,
or if I'm moving to the right.
86:26 - So I want to check if I'm at that boundary
and then I increment my offset X.
86:30 - Now, all I have to do to account for
this is add an offset X
86:34 - to my draw function and draw
every single object offset by this x.
86:38 - So I'm going to go
here, let's say offset, underscore x.
86:42 - And now just to all of my draw
functions, I'm going to pass
86:48 - offset x,
86:50 - offset underscore x,
86:52 - I'm going to go to all my draw functions
and I'm going to add this
86:57 - offset X
86:58 - and what I'm going to do is just subtract
the offset X from the exposition.
87:02 - I'm drawing everything out
since it minus offset x
87:06 - and we'll take in the offset underscore x.
87:09 - Okay.
87:09 - Now the reason this works,
if I move to the left,
87:12 - my offset x is going to be negative,
87:14 - which means everything
is going to push to the right side
87:16 - because we're adding to the position
for it.
87:18 - If I move to the left side or sorry
if I move to the right side,
87:21 - the offset X is going to be positive,
87:23 - which means everything
going to move to the left.
87:25 - So it has a scrolling background effect.
87:28 - Let's just run it though
and see if it works.
87:30 - Then I can fix it if it doesn't.
87:33 - Okay, so I start running here.
87:35 - You can see that now
the floor is going to start going with me
87:37 - once I reach this boundary.
87:39 - However, on this side, right, like what
I'm in the middle is not doing anything.
87:43 - I have to get to a certain boundary
which is kind of invisible on the screen,
87:46 - and then it starts scrolling with me,
which is what I wanted to do.
87:50 - And then notice if I jump here, boom,
I fall off the platform.
87:56 - Let's do collision with blocks
in the horizontal direction.
88:00 - So to do that,
I'm just going to add a block here.
88:04 - So I'm actually going to make a list.
88:06 - Let's say
objects is equal to Asterix Floor.
88:10 - Now, if you ever seen like kind of dot,
dot, dot in JavaScript,
88:14 - that's what this does in Python.
88:15 - It just essentially breaks this floor
into all its individual
88:18 - elements
and passes them inside of this list.
88:22 - So imagine it
if me just writing this here,
88:24 - that's what it's doing,
and then I'm going to pass another block.
88:28 - And for this block,
I'm going to place this
88:31 - at let's do zero.
88:35 - And then for the why,
this is going to be the height
88:38 - of the screen
minus the block size times two.
88:43 - Now the reason I am multiplying
88:44 - this by two is so that I get it a bit
higher on the screen
88:49 - so that we can kind of run into it
horizontally.
88:51 - And I'm going to pass my block size.
88:54 - So just see, now I want to go
and rather than drawing my floor,
88:59 - I want to pass objects
89:02 - and same here
with handle move on to pass objects.
89:05 - So let me run this.
89:06 - So now you can see that
I have that block there right
89:10 - now. Notice that when I hit the block,
I kind of go to the top of it.
89:13 - And the reason I go to
the top of the block
89:15 - is because right now
I'm only handling my vertical collision.
89:18 - So when I hit the block,
89:20 - I a little bit of gravity
because remember,
89:22 - there's always some gravity on me
when I'm on the floor.
89:24 - And so it thinks that
89:25 - I've hit the top of the block,
so it spawns me on the top, the block.
89:28 - So we need to make it now
so that when you hit the block
89:30 - in the horizontal direction,
it kind of pops you off of it
89:33 - so that it doesn't think you're
hitting the top of the block
89:35 - or the bottom of the block, alternatively,
which you'll see in a second.
89:38 - And in fact,
let me add one more block to show you.
89:41 - Hitting our head on the block.
89:43 - So let's add another block.
89:45 - Let's make this at
89:47 - same block size multiplied by.
89:51 - And then for the heights, it's
two times four.
89:55 - Okay, now we have another block.
89:57 - Let's see where this guy is.
89:59 - Now I can show you that
I can hit my head on the block. Right.
90:01 - And I can't kind of go above it.
90:06 - Okay, anyways, we have that.
90:07 - Let's do our horizontal collision.
90:09 - So the horizontal collision
90:12 - is a bit weird to implement.
90:15 - The idea behind this is that since
we're using our Sprite Collide mask,
90:21 - we want to make sure that if we collide
with a block horizontally,
90:24 - we move ourselves off of that block
so that it doesn't think
90:28 - that we're colliding with it
in the vertical direction.
90:30 - Now, you just saw that happen.
We hit the block.
90:33 - It thought that we were hitting it
like the top of the block.
90:36 - So it put us on the top of the block
because that's what this line does right
90:39 - here.
90:39 - So in our horizontal collision,
we essentially need to check, okay,
90:44 - by moving in this direction,
are you going to hit the block?
90:47 - If you are going to hit the block,
we want to prevent you
90:49 - from moving in that direction
so that you don't
90:53 - hit it, collide with it,
and then we like spawn to the top of it.
90:56 - So let me write it
and I'll explain to you how it works.
90:59 - But it's just very important that we check
the horizontal collision first.
91:02 - Then once we check that,
we check the vertical collision
91:05 - because we only want to check
vertical collision
91:08 - if we are not colliding with a block
horizontally
91:12 - or if we haven't already handled
or if we have already handled
91:15 - the horizontal collision.
91:17 - Again, the idea is
we don't want to be thinking that we're
91:20 - hitting the block on the top when really
we hit it on the left or the right side.
91:23 - So we've got to check that first.
91:25 - So I'm going to make a function
you say define collide mean it's a player
91:30 - objects a displacement X like that.
91:34 - Now I'm going to say player dot move
91:37 - and I'm going to move my player
91:39 - in the displacement
X direction and zero in the Y direction.
91:42 - The reason I'm doing this is
I want to check
91:45 - if with the current velocity
that my player has, if
91:49 - now the reason I'm doing this is
I want to check
91:51 - if my player were to move to the right
or if they were to move to the left,
91:56 - would they hit a block? That's that's
what I'm
91:58 - checking essentially
by moving the player preemptively.
92:01 - So now what I need to do
is say player to update.
92:04 - Now the reason I need to call the update
and let's go here to update
92:07 - is because I need to update the rectangle
in the mask before I check for collision.
92:11 - So again, what I'm doing is I'm
preemptively moving my player
92:14 - to where they would be moving
if they're going left or right.
92:17 - I'm updating their mask
and their rectangle and then I'm going
92:20 - to say for object
92:23 - in objects, if pie game
92:26 - dot, sprite dot collide mask
92:30 - and then I'm passing player and my object.
92:34 - So this is why I needed to update my mask
in my rectangle.
92:37 - So I move my player,
I update it and then using that updated
92:40 - mask, I check what I be colliding
with an object.
92:43 - Now I'm going to say collided
92:46 - object is equal to none.
92:51 - I've got to spell colliding correctly.
92:53 - If I am, then I'm going to say collided
92:56 - and this is just going to be object
92:59 - is equal object.
93:03 - Then I'm going to break.
93:04 - Okay, then I'm going to say, player,
don't move
93:07 - and I'm going to move them back
93:10 - and then I'm going to say player
dot update.
93:15 - Okay.
93:16 - And then I'm going to return the collided
object.
93:19 - Okay.
93:20 - So what I'm doing right, I'm
moving my player,
93:21 - I'm updating the mask, I'm checking
if they would with something.
93:25 - If they were to move in that direction,
then if they did.
93:28 - Okay, I get that collide object.
93:30 - It doesn't matter if they do
or they don't.
93:31 - After I check this collision,
I have to move them back
93:34 - to where they originally were.
93:35 - Stuff to reverse the movement
and then update the mask again.
93:40 - Then I return collide object.
93:42 - Okay then moving checking
if we had anything either way.
93:46 - Moving back to where we were before.
93:47 - This is preemptively checking
before we allow them to move into a block.
93:52 - All right.
93:52 - Now what we need to do, use this function
R to allow us
93:57 - to move left or right or to disallow us
from moving left or right.
94:01 - So I'm going to say collide,
underscore left is equal to collide
94:05 - player objects and then negative player.
94:09 - Well, then I'm going to say collide
underscore right
94:13 - is equal to collide player
94:16 - objects and then player
94:19 - and then I'm going to say
and not collide left
94:24 - and not collide right again.
94:27 - What we're doing here is we're checking
if we should be able to move left
94:31 - or if we should be able to move right
based on our current position.
94:35 - That's
why I make that preemptive movement.
94:37 - And then here
I only let you make the movement
94:39 - if that movement does not cause you
moving into a block or colliding with one,
94:44 - now that we have that,
that should actually handle
94:46 - our horizontal collision,
that's actually all we need.
94:49 - All right.
94:49 - So let me run this code
and let's see some here.
94:53 - Okay. Obviously, that's still working.
94:55 - And you can see that
I can't go through the block now.
94:58 - Let's go here.
94:59 - And actually, I'm
getting a bit of a bug on the right side.
95:03 - Okay.
95:03 - So that time it worked,
but it's a little bit glitchy
95:06 - and I have a feeling
it has to do with the animation count
95:09 - of me running because it's only some times
95:12 - when I'm running and I hit the block
that it spawns me up here.
95:15 - So I'm just going to do
another little hack here
95:18 - and I'm just going to multiply
this by two.
95:21 - Both of them here.
95:22 - The reason for this being
that I'll just make it
95:24 - so there's a little bit of space
between the block and that way.
95:28 - Me changing
the sprite isn't going to affect.
95:31 - I collide with the object or not,
because remember the sprites
95:34 - kind of shift to the left
or to the right a little bit.
95:36 - So just by adding this multiplied by two,
95:39 - it should make it so that I'm never going
to be colliding left or right.
95:42 - It will make it. There's a bit of space.
95:43 - See how there's a bit of space
between the block now.
95:45 - But that's okay because now
I'm never going to have that collision bug
95:50 - where it's going to spawn me to the top.
95:52 - And really
you could just add one or two pixels,
95:55 - but you can see that
that kind of fixed it right there.
95:58 - Okay.
So now we have collision with blocks,
96:01 - we have a scrolling background,
we have double jumping.
96:04 - I think that the last thing
96:07 - that we need to add
here is the fire thing, right?
96:11 - Kind of got trap or you hit it
and you kind of flash
96:13 - and then once we've done
that, we'll pretty much be done.
96:15 - The tutorial.
96:19 - All right, so let's write our class
for representing our fire.
96:24 - So I'm going to say class fire.
96:27 - This is going to inherit
from object as well.
96:29 - And this is going to be animated.
96:32 - We're going to have animated fire.
96:33 - So this will take a bit more work,
but I think it'll be worth it.
96:36 - It looks pretty cool on the screen.
96:37 - So I'm going to take X, Y width and height
96:41 - and then I'm going to call
my super initialize.
96:43 - So super
96:46 - underscore, underscore net
96:47 - self x, y, width and height.
96:54 - Okay.
96:54 - And then for the name of this,
I'm actually going to call it fire.
96:57 - Remember that we can pass a name.
96:58 - The reason I'm adding a name to the object
97:00 - so that I can determine
when I collide with the object.
97:03 - If it's fire and if it's fire,
then I want to do something right.
97:07 - Okay.
So for self fire,
97:08 - I'm going to use our load
sprite sheets function for directory one.
97:12 - This is going to be traps and for
directory two, this is going to be fire.
97:17 - Now if we go here to traps,
you can see that
97:19 - fire is one of our traps
we have hit off on.
97:23 - Okay.
97:23 - Now there's also a bunch of other traps,
right?
97:25 - So you can
you can pick a different trap if you want.
97:28 - You could pass this blink one or whatever.
97:30 - The thing with these ones
is that they have some more animations.
97:34 - So there's a bit more logic
you need to handle for them.
97:36 - So that's why I'm going with fire,
because it's a pretty simple one to do
97:39 - now up here for fire.
97:40 - I'm again going to have my animation
delay, so let's make that equal three
97:47 - and now let's specify our image.
97:49 - So Let's say ourself
that image is going to be self.
97:51 - The fire off.
97:53 - We're going to start with it off
and then zero.
97:57 - Okay, then I'm going to say self
mask is equal to pi game
98:02 - masked from surface self-taught
98:06 - image like that.
98:08 - Okay then I need to set an animation.
98:10 - So I'm going to say
my animation underscore
98:13 - count is equal to zero
just like we did for our player.
98:16 - And I need to set myself
dot animation underscore
98:20 - which for now is going to be equal to off.
98:23 - Okay,
now I'm going to make a few functions.
98:25 - My first function is going to be on
my first method and I can say
98:28 - self-taught animation name is equal to.
98:31 - And if we look at fire
we see we have hit off
98:34 - on, we're not going to use hit,
we're just going to use off and on.
98:38 - Okay.
Now we're going to have off
98:40 - self self-taught animation
98:43 - name is equal to off.
98:46 - Okay and then we'll
our loop we'll say define loop self.
98:51 - And inside of our loop
we're going to do a very similar thing
98:54 - to what we did
inside of our player loop in fact.
98:57 - So somewhere that I can copy
pretty much all of this right here.
99:01 - So let's copy all that
99:03 - and let's paste that.
99:04 - Yeah.
99:05 - Now for update rather than actually
just calling it update method, we'll
99:10 - just copy the stuff from the update method
here and just paste it down.
99:15 - Okay.
99:16 - And rather than self that sprite,
we're going to change this to image.
99:20 - And I actually think that once
we remove the direction here,
99:24 - this is all that we need for our.
99:30 - All right,
so now we just need to make a few changes.
99:32 - We're going to get rid of this sprite
sheet name and rather than Sprite sheet
99:35 - name, we're going to say
it's self dot animation name.
99:40 - And now we should actually be good
to just use this.
99:43 - So let me space this out a bit.
99:45 - We get our sprites, okay?
99:47 - This is it going to be self.
That's sprites.
99:50 - No it's going to be self. That's right.
It's going to be self. Doubt fire.
99:52 - Which is this.
99:54 - Okay.
99:55 - Really, I should call this something else,
but fire is going to represent
99:58 - all of our fire images.
100:00 - Okay, so I'm using this
to get my different animations.
100:04 - I'm getting the animation name that I'm
currently playing, either on or off.
100:08 - And then I'm saying my sprite index
is equal to self done animation count
100:12 - divided by the self.
100:13 - That animation delay mod the amount
of sprites, same as what we have before.
100:18 - My image is equal
100:18 - to sprites at sprite index
and then I increment the animation count,
100:22 - update my rectangle and update my mask,
which is important for the collision.
100:26 - And I'm good.
100:27 - Now last thing I want to do here is
I want to just check
100:31 - if my self-taught animation
count is greater than if this divided
100:37 - by myself, that animation
delay is greater than the line of sprites.
100:43 - Now the reason I want to
100:44 - do this is so that my animation count
doesn't get too large.
100:47 - Now you'll notice in my player class
I actually didn't do this.
100:50 - Now that was intentional
because if you do this,
100:53 - then it kind of messes up
how the double works.
100:56 - You can do it if you want, but you'll see
that it kind of messes with things.
100:59 - And with our player,
we're constantly resetting
101:02 - the animation count when we jump
or when we go left or when we go right.
101:05 - So that value doesn't
really get too large.
101:07 - But here for our fire, since it's just
static, like it's just sitting forever,
101:11 - what will happen is the animation count
if we never change it back to zero,
101:14 - we'll get to an extremely large number
which can kind of lag our program.
101:18 - So what I want to do
is just make it smaller, right?
101:21 - So if it goes beyond
what the actual animation,
101:25 - what do you call it,
this is the line of the Sprite start.
101:27 - Then I want to set this to zero.
101:29 - It's important
I divide it by the animation
101:31 - delay, though,
because if I'm dividing it here,
101:33 - I need to divide it here before
I set it back to zero.
101:37 - Okay, so now we have fire
and that's actually all we need for fire.
101:40 - So now we just need to add it
to our objects.
101:42 - So let's create it. Let's say
101:46 - fire.
101:47 - So you go to fire and what do we need
to pass for fire in x, y, width and height
101:51 - so we can pick where we want to put this?
101:55 - Where do I want to put my x and Y?
101:58 - Okay,
for now let's go hundred and let's go.
102:02 - Height minus the block size.
102:05 - And then I don't know
how tall my fire's going to be.
102:09 - I've got to see how big
I want to make this.
102:11 - Let's make it say 60
102:14 - and then we'll go 30 to 64 here.
102:18 - Okay. So if we look at fire, it's quick.
102:20 - We have a look here and go to off example
or on
102:25 - the size of this is 32 by 64.
102:29 - Okay, that's what the size is
and you need to pass that correctly
102:32 - to the fire class, otherwise
it won't load the image properly.
102:36 - So we take our height minus our block
102:39 - size, -64,
which will put us on top of a block.
102:43 - Now I will put this at.
102:44 - Yeah, 100 is fine
for now for the X and yeah.
102:47 - 32 width, 60 for height.
102:49 - There we go. We have our fire now.
102:51 - I was going
102:52 - say fired up on I'm just going to turn it
on, we'll just leave it on forever.
102:55 - You can turn off programmatically
if you want.
102:58 - And then inside of objects,
all this place, my fire.
103:01 - Now that I've done that.
103:02 - It should just show up on the screen
when I run my car.
103:05 - So I got an issue.
103:06 - Let's see what the bug is here.
103:08 - Of course,
the output is not showing up correctly.
103:10 - This is an it takes from 5 to 6 plus positional arguments which seven were given.
103:17 - Okay,
103:19 - I see the issue here.
103:21 - Let's go back to our fire.
103:24 - And we don't want to pass self.
103:26 - Let's remove self.
103:28 - Okay, let's run this
103:30 - list index out of range
so that fire off zero.
103:34 - Hmm. Okay.
103:35 - I'm wondering why that's
giving us an issue we have off here.
103:39 - So that should have been.
103:40 - Okay, so let's go here and let's print
self-taught fire
103:45 - and let's see why it's giving us this
this bug here.
103:48 - All right.
103:48 - So I have determined the issue,
and the issue is
103:51 - that I passed the incorrect size here.
103:53 - It's actually 16 by 32.
103:56 - So it's passing too large of a size.
103:58 - And that's why it wasn't giving us
the correct number images.
104:01 - So let's change this now and run.
104:03 - And now we should be okay.
104:04 - And there we go. Now we have fire.
104:06 - But however it is off now
the reason it's off is because we didn't
104:10 - call the loop method on fire.
104:12 - So let's fix that
104:13 - and also get rid of the print statement
that I put here that I don't need anymore.
104:18 - Okay, so let's go
104:19 - down to Main
and where we have player out loop.
104:22 - Let's call fire
dot loop and is asking for the piece.
104:27 - I don't know if I took that in my loop
here.
104:32 - No, I don't need the props for that.
104:33 - So let's get rid of that.
104:35 - Okay. Now let's call it
and it should start
104:38 - being on fire
object has not shoot sprites.
104:41 - Okay, let's go fix that error.
104:43 - My apologies.
104:45 - Fire.
104:46 - We have Sprite somewhere here
that we don't want self.
104:48 - That Sprite is going
be self thought image and self-taught
104:53 - image. All right, start with that.
104:56 - Let's run it now. And there we go.
104:59 - We now have a moving fire.
105:00 - And notice that I can kind of be
on top of the fire, right?
105:04 - So I can collide with it.
105:05 - And it's like pixel perfect collision
pretty much when I'm hitting it.
105:12 - So now the last thing we need
is to just make it
105:13 - so we go into that kind of hit state.
105:15 - When we do hit the fire,
that's actually pretty easy to do.
105:18 - We just need to add a kind of state
to our player to know if we're hit or not.
105:23 - So we're going to say self-deport.
105:24 - Hit is equal to false.
105:27 - We also want to hit counts
105:30 - because we're going to only be flashing
for a certain amount of time.
105:33 - Then we're going to have a method here
to fine hit
105:38 - self.
105:40 - Self to hit equals true
105:44 - in self that hit count
105:46 - is equal to zero.
105:48 - Then we're going to go in loop
and before our update sprite, we're
105:52 - going to say if self-taught hit,
105:55 - then self-taught hit count
plus equals one.
106:00 - And then we're going to say
if self-taught hit count
106:04 - is greater then
and we can just pick some value.
106:07 - But let's say f-pace multiplied by two,
which is going to be 2 seconds,
106:11 - then the self taught hit
is equal to false.
106:17 - Then we go here into our update sprite
106:20 - and we say actually at the
top here, if self-doubt hits,
106:26 - it's important
you put this at the top, by the way.
106:27 - So I'm actually buddy here.
106:29 - Then we are going to say the sprite sheet
106:32 - is equal to hit.
106:36 - Great.
106:37 - Then we want to now determine
if we actually got hit.
106:40 - So we do that from our collision functions
which are going to be here.
106:46 - All right.
106:47 - So we have collide left.
We have collide, right.
106:49 - And we're going to have
106:51 - vertical
106:54 - collide.
106:55 - Now, what we're going to do
is we're essentially going to loop through
106:58 - all of these objects
and we're going to see if we hit fire.
107:03 - Now, the way we'll know if we hit
107:04 - fire is by looking at all
the objects that were returned here.
107:07 - And it will tell us, well,
if we hit fire or not.
107:10 - Right. Because we can
look at the name of the object.
107:13 - And if the name of the object is fire,
then we know we have fire.
107:15 - So I'm going to say
107:18 - to check is equal to
107:21 - collide left, collide right
and asterisks vertical collide.
107:26 - Now I realized that inside of here
I only returned one object, whereas
107:29 - inside of here I returned all the objects
I was colliding with vertically.
107:33 - Really, we should probably be returning
all of them from here as well,
107:36 - but I think this is still going to work.
107:37 - So we'll just leave it
how it is for right now.
107:40 - So I to say, for object
in to underscore check
107:45 - these are all the objects
we collided with.
107:46 - Remember I'm going to say
if to underscore, check and to underscore
107:52 - check dot name is equal to fire
107:57 - then player dot hit
108:00 - is able to trip.
108:01 - Okay that is all we need.
108:03 - And actually
I'm going to say player to hits
108:05 - I want to call the method
I don't want to set it equal to true.
108:08 - So what we're doing here
is looking through all the objects
108:09 - we collide with, if any of them are fire,
then we will put hit on the player.
108:14 - The reason I'm doing this first,
108:16 - if to check, is
because these could be none, right?
108:19 - We could have no objects we collide with.
108:21 - So I need to make sure I handle that case
108:22 - before I try to access name on an object
that isn't defined.
108:26 - All right,
let's run the code and let's see.
108:29 - And player has no object, no attribute hit
count.
108:32 - Okay, so let's go to player
108:36 - and let's go to hit count
and let's make that equal to zero.
108:39 - I guess I forgot to assign that.
108:41 - All right, let's try this.
108:42 - Now, list object has no attribute name.
108:44 - Okay, interesting.
108:48 - Let's see here.
108:52 - Okay.
108:53 - All right, so I'm using to check
when I need to be checking object.
108:57 - So let's fix that.
108:59 - And the code
109:02 - blue object is not callable.
109:03 - Okay, player dot hit.
109:05 - Aha. So let's call this make hit.
109:09 - It's because I have an attribute
with the same name as my method.
109:12 - So it's accessing the attribute
when it should be accessing the method.
109:16 - So I'm just going to say
make underscore hit.
109:18 - And now that should
fix the problem for us.
109:21 - Run the code and there we go.
109:23 - Now it looks like
I'm always being hit right now.
109:29 - That, of course, is a bug.
109:30 - So hit is equal to false.
109:33 - Let's let's check our hit count.
109:35 - It's because if self-doubt
hits off the hit count plus, it goes one
109:39 - if self the hit count is greater
than self-tan equals false.
109:44 - Maybe we need to reset our hit
count as well.
109:47 - Okay.
109:48 - And there's probably a bug
109:51 - here.
109:53 - Let's scroll down,
109:55 - keep scrolling with our
so we have to check if okay
110:00 - you would be a name equals
it goes fire player don't make hit
110:05 - okay I'm
110:07 - not sure what the bug is.
110:08 - Let me run this again.
110:11 - And yeah, it seems like
we start out in the hit state,
110:14 - so maybe it's an issue in here.
110:18 - Let's have a look here. If self-taught hit
110:22 - spreadsheet equals hit.
110:23 - But we are we hit right away for some
reason it's making us hit immediately.
110:29 - Okay. Let me have a look here. Yes.
And I'll be right back.
110:31 - All right. So I've realized
I made a silly mistake here.
110:34 - I actually have this collided
objects append outside of this
110:38 - if statement and that was causing
all kinds of bugs and issues for me.
110:42 - I think I was doing some print debugging,
so let me get rid of that here.
110:45 - Anyways, I just moved it back now.
110:47 - So that is in the correct location.
110:48 - So now if I rerun this
now we should see that
110:53 - when I hit the fire
it puts me into kind of this hit
110:55 - state last 2 seconds and then it ends.
110:59 - All right. So that's it, guys.
111:01 - I think that's pretty much going
to wrap up this video.
111:04 - This showed you
how to create a platformer,
111:07 - how to do animations, how to be sprites,
how to do a scrolling background.
111:10 - Obviously, there is a ton of stuff
that could be added to this game,
111:13 - but I really want to leave that to you.
111:15 - Obviously, I could spend hours,
days, months working on a game like this,
111:20 - but I think this is a solid enough base
to really give you guys
111:23 - a good foundation to go out there
and create something pretty cool.
111:26 - Obviously There's all kinds of assets
that I would leave in the GitHub
111:29 - that you can use.
111:30 - I have all kinds of other PI game
tutorials that you may want to reference.
111:34 - If you want to learn
about Menu's sound effects
111:38 - points,
scoring, all of that kind of stuff.
111:41 - You guys go
my channel search pie game tutorial.
111:43 - You will see a bunch of them.
111:45 - Those will show you how to do a
111:46 - ton of other things that you know
you may want to add to this game.
111:50 - So I hope you enjoyed this.
This was a ton of work.
111:52 - As always,
the code will be in the description
111:55 - if you did enjoy make,
surely they like subscribe to the channel.
111:58 - Consider supporting me by purchasing
something like programing expert
112:02 - and I hope to see
you in another YouTube video.