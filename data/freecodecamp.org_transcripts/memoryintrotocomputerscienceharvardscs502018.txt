00:00 - [MUSIC PLAYING]
00:49 - [VIDEO PLAYBACK]
00:53 - is not how computer science works.
00:55 - And indeed, by the end
of today, we'll make
00:57 - clear exactly what's right,
what's not right about that,
01:00 - and hopefully give you some pause any
time you watch TV or movies hereafter
01:05 - and notice these little things
that all too many writers seem
01:08 - to take for granted.
01:10 - So recall that last time, we took a look
lower level at what compiling actually
01:14 - is.
01:15 - And recall that it was a few things,
these four steps of pre-processing
01:18 - and compiling and
assembling and linking,
01:20 - so that when you start
with their source cod,
01:22 - that might look like this code
that we have written in the past,
01:25 - you first have to preprocess it, and
the first step in pre-processing was
01:28 - converting all of those
processor instructions--
01:31 - anything starting with a hash at the
beginning-- to their equivalents.
01:34 - So opening the files and effectively
copying and pasting the contents
01:37 - there so that programs and the
compiler know what get_string
01:40 - is and know what printf is.
01:42 - The next step that came
after that was actually
01:44 - compiling, whereby compiling
technically means taking that source
01:47 - code, once it's been preprocessed,
and printing and generating
01:50 - this very cryptic-looking
stuff called assembly code.
01:53 - And those assembly codes or assembly
instructions are really what the CPU--
01:58 - the brain of your computer--
actually understands,
02:00 - although technically the computer
understands them only in the form
02:03 - of 0's and 1's.
02:05 - And so when you "assemble-- step three--
02:08 - that assembly code, you actually
get out those 0's and 1's.
02:10 - But even that simplest of programs where
we just prompt the user for a string
02:14 - and then print out their name
still involved a couple more files.
02:18 - There was not only cs50.h
and stdio.h at the top,
02:23 - somewhere in the computer system
there's probably files called cs50.c,
02:28 - and in the case of stdio, printf.c,
in which actually the code is
02:33 - for those two functions, those
two have to get compiled down
02:36 - to 0's and 1's, and then we need
to link everything together,
02:39 - merging those 0's and 1's so that
the computer has access to your code
02:43 - and to printf's code and to the
cs50 library's code And so forth.
02:47 - But all of that we can just generally
wrap up in the descriptor of compiling.
02:51 - And so that's one of the
looks we took last week.
02:53 - And we also have introduced, last
week and previously, a few tools.
02:57 - And odds are, you're having as
many frustrations perhaps already
03:00 - with the p-sets as you
are accomplishments
03:02 - and sense of satisfaction.
03:03 - And that's normal, and rest assured
that the scales will eventually tip more
03:07 - toward happiness and away
from sadness, but we'll
03:09 - give you indeed more tools today
than these for actually finding
03:13 - problems or shortcomings in your code.
03:15 - help50, recall, helps
you with what process?
03:18 - When you instinctively
consider using help50?
03:22 - When you see error
messages on the screen.
03:23 - Something you don't understand
that's the result of some mistake you
03:26 - probably made but you don't quite
understand what the computer is telling
03:29 - you, run help50, and then that
same command and we, the staff,
03:32 - with our code will try to
understand the message for you
03:34 - and provide you with feedback.
03:36 - style50 does exactly that.
03:38 - It helps you see with red and green
color coding exactly what spaces should
03:42 - be there, shouldn't be there--
it just helps you pretty
03:44 - your code so that you can read it
better and other humans can as well.
03:47 - And then printf, which is kind of like
the coarsest tool in your tool box,
03:52 - this is just helping you see not
only messages you want to see,
03:55 - but just the values of variables.
03:57 - You can print ints and
strings, whatever you want,
03:59 - and then you can delete
those lines of printf
04:02 - once you're confident
your program's working.
04:03 - But that gets a little tedious, and
honestly, as our programs get bigger,
04:07 - we're going to want more powerful tools
than like manually printing things
04:10 - out, recompiling, rerunning, it
very quickly it gets tedious.
04:12 - And the goal of programming is not
to be tedious, but to be empowering,
04:15 - and that's where we'll
step to today via this.
04:18 - So CS50 IDE is sort of
fancier version of what
04:22 - you've been using called CS50
Sandbox, and in turn, CS50 Lab.
04:26 - Now recall that both of those
tools, the Sandbox and the Lab,
04:29 - have a terminal window
where you can type commands,
04:31 - they have a code editor where
you can actually write your code,
04:37 - and then they have a file
browser with icons and such
04:39 - where you can actually see
your files and folders.
04:42 - So it turns out that CS50 IDE is
another tool that at first glance
04:46 - is very, very similar, even though
it's laid out a little differently,
04:49 - but it has as many features as the
Sandbox and the Lab, but some more.
04:53 - More features that actually help
you solve problems in your code
04:57 - and even collaborate come final project
time with others if you would like.
05:01 - So this we'll see is
this is the CS50 IDE.
05:02 - It comes with the
so-called night mode so you
05:04 - can make everything a little darker on
your screen, especially if p-setting
05:06 - at night, and let's
actually take a look then
05:08 - at what you can do
with this kind of tool.
05:12 - When you log into this tool for the
very first time in the next problem set,
05:16 - you'll see an interface that's
almost the same as before.
05:18 - The colors are a little different,
the font sizes are a little different,
05:21 - but at the bottom by default, you
have your so-called terminal window,
05:24 - though instead of the
dollar sign now, you'll
05:25 - see a little more detailed
workspace, but more on that in a bit.
05:29 - Up here you just have
the code editor window,
05:31 - nothing's really going on there.
05:33 - And then we have the added
feature of Ceiling Cat
05:35 - in the top right-hand corner.
05:37 - And we'll also see some
other features along the way.
05:39 - So let's actually write a program
in CS50 IDE, which, to be clear,
05:43 - is just another web-based programming
environment that also gives you
05:47 - access to your own cloud-based server.
05:50 - It, too, is running Ubuntu Linux, which
is a popular operating system that
05:54 - is not macOS and it's not Windows.
05:55 - But unlike the sandbox environment
where you don't even log in
05:59 - and you lose your files
eventually, as you
06:01 - may know from when your cookies
are lost or something goes wrong,
06:04 - the IDE saves everything.
06:05 - And you'll log in with
your account, and whatever
06:07 - you put there last week is going
to be there this week and next week
06:10 - and beyond.
06:11 - So let me go ahead up to File, New File,
or I could just click this little plus
06:15 - icon in the top right-hand corner, and
let me go ahead and preemptively hit
06:18 - Control-S or Command-S
or go to File, Save--
06:21 - you should find the interface very
similar to any Mac or PC program--
06:25 - and let me go ahead and
save this file as follows.
06:28 - I'm going to call this hello.c.
06:31 - And it's important to
mention the file extension,
06:33 - otherwise the IDE, like
the Sandbox and the Lab,
06:35 - won't know what type of
program you're writing.
06:37 - And then let me go ahead and just
write my simplest of programs.
06:40 - So let me go ahead and include
stdio.h, int main void.
06:45 - Let me go ahead and open
my curly braces, printf--
06:48 - hello, world, backslash
n, and a semi-colon.
06:51 - So you'll notice that almost
everything is the same.
06:54 - The colors are a little
different, perhaps,
06:56 - and you might see some
different assistive
06:58 - features as you're typing your code,
but the end result is the same.
07:01 - And the color coding you just
get for free because it's helping
07:03 - draw your attention to
different parts of the code.
07:05 - Let me go ahead now and--
07:07 - oh notice this.
07:08 - There's one difference.
07:09 - The IDE is a more powerful tool,
but as such, it's a more manual tool
07:13 - and it's not just going to
auto-save your code for you.
07:15 - Nice as that's been with the
Sandbox, such that you'd never
07:18 - actually had the hit
Command-S or Control-S--
07:20 - and if you were, you
didn't need to be, the IDE
07:22 - is only going to save things when
you want it to so that nothing
07:26 - will happen magically anymore.
07:28 - So what I'm going to have to do is go
back up here, File, Save, or Command-S
07:32 - or Control-S, you'll
see a little green dot
07:34 - briefly, and now and back at my prompt.
07:37 - I'm going to go ahead now and type my
familiar command, make hello, Enter,
07:41 - and you'll see pretty much the
same cryptic-looking client
07:44 - command as before because the IDE is
configured quite like the Sandbox.
07:48 - And if I want to go ahead and run
this now, how do I run this program?
07:52 - Quick check?
07:54 - ./hello, it's exactly
the same as before.
07:56 - ./hello, and there we
have it, hello, world.
07:59 - So long story short, the user interface
thus far is a little different,
08:02 - but functionally it's the same.
08:04 - We're just going to now start
to see some more features.
08:06 - So what are those features?
08:07 - And let's introduce new some
capabilities that were actually
08:10 - possible in the Sandbox, we just didn't
really introduce them at the time.
08:13 - If I click this folder icon at top left,
you'll see all of my files and folders.
08:17 - And today for lecture I have
a lot of pre-made examples
08:20 - that are already on the course's
website, some of which we'll look at,
08:22 - some of which we'll
refer to the website,
08:24 - but these are just
familiar files and folders.
08:26 - And you can see that
everything in my account
08:29 - is apparently in something
called Workspace, which
08:31 - is just a folder, name, or a directory.
08:34 - Here's my sc3 directory,
which again, comes
08:36 - from the website for
today's lecture, lecture 3.
08:38 - And then here's the file I just
compiled in the program and the file
08:41 - that I wrote, hello.c.
08:43 - You'll notice too that there's
this funky symbol here, tilde,
08:46 - that you might not have occasion
to write often in English,
08:49 - but in Spanish in other languages
you might use this character.
08:52 - This is actually a shorthand notation
for what's called your home directory.
08:56 - In this environment, CS50 IDE, you
have your own home directory, which
09:00 - means your folder of files and other
folders that you get to create,
09:03 - you own, and that persists every
time you log in-- you're not
09:07 - going to lose the contents therein.
09:08 - So this just means that in your
home directory, a.k.a. tilde,
09:13 - there is a folder called workspace
in which I'm currently working.
09:17 - And that's just one folder in which
all of my work is going to be done,
09:20 - because there's so many other files
and folders in this cloud environment,
09:23 - just like there are in your
Mac and PC, we just generally
09:26 - don't care what they are.
09:27 - But notice what we can do at this
terminal window besides compile
09:33 - and run code.
09:34 - There are other commands.
09:35 - For instance, this blue text here,
similarly to the file browser up top,
09:41 - indicates now not just that this
is my prompt per the dollar sign,
09:45 - but that in my home directory's
workspace directory.
09:48 - So that means I can be
elsewhere even though I haven't
09:52 - specified where I want to go yet.
09:54 - And in fact, I can do
this. ls stands for list,
09:57 - it's just shorthand notation for that.
09:59 - And now I see a textual version
of my file tree, so to speak.
10:04 - So you'll see here, sc3
is a folder, and you
10:07 - can tell as much because there's
a slash at the end of it.
10:09 - hello.c is of course the
file I wrote a moment ago.
10:12 - And then hello in green is my
program that I compiled, and the star
10:16 - or asterisk there is just--
10:18 - it's not the name of the file,
it's just indicating to me
10:20 - visually that that is executable.
10:22 - That's a program I can run
just so I know what's compiled
10:25 - and what maybe is source code.
10:27 - So when you're running ./hello, the
reason all this time this has been
10:31 - working is because in dot, your current
folder, there is a file called hello,
10:36 - and when you hit Enter, you
are running that program there.
10:40 - So if after today you go back onto
CS50 Sandbox or CS50 Lab and type ls,
10:44 - you'll see exactly the same thing
as you might by the little folder
10:47 - icon in those programs as well.
10:49 - But suppose I want to
go into a directory.
10:52 - In macOS or Windows or even
the IDE, I could, of course,
10:56 - go my File icon, and then
per the little triangle
10:59 - here, which might seem
intuitive, you just click it
11:01 - and you can see what's going
on inside, not surprising.
11:04 - But how do you do that textually?
11:05 - At a command prompt, well
it's not all that hard.
11:08 - You just need to change your directory.
11:10 - So if I do cd space sc3, Enter,
nothing seems to happen quite yet
11:16 - except that my prompt changed.
11:18 - Here's the indication that-- this
is my prompt, but to the left of it
11:21 - you see in blue that I'm now in my
home directory's workspace folder,
11:25 - in my sc3 folder there.
11:28 - So it's just a text-based version of
the GUIs, the Graphical User Interfaces
11:31 - that all of us have
certainly come to take
11:33 - for granted in the world of
macOS and Windows thus far.
11:37 - Well, suppose that I'm a little
done with my hello program
11:41 - and I want to delete it.
11:42 - Well in the IDE, like in the Sandbox,
you can actually go up here and you can
11:45 - click on it, and then you can
typically right-click or control-click,
11:49 - and you'll get a whole menu of other
options, one of which is Delete--
11:52 - and feel free to tinker like
that in your own environment.
11:54 - But what about the command line?
11:56 - If I zoom in down here and I
want to remove hello, you're
12:00 - not going to type remove because
that just feels a little verbose
12:03 - and humans decades ago decided
that's too tedious to type,
12:06 - let's just call this command rm--
12:08 - for remove-- hello, you're going
to see a somewhat cryptic prompt.
12:12 - rm-- remove regular file 'hello?'
12:15 - This is more arcane than it needs
to be, but it's just asking,
12:17 - are you sure you want to delete 'hello?'
12:19 - Then it's just waiting for you.
12:20 - And here you can type y or yes
or sometimes other commands too,
12:26 - now I've confirmed that
my intentions were yes.
12:28 - If I type ls again, I--
whoops, in the wrong folder.
12:31 - If I type ls again after doing hello--
12:35 - no-- after doing hello
and do ls, now I'll
12:39 - see just those two
things-- sc3 and hello.c.
12:42 - What if I want to make a folder?
12:44 - Well notice this.
12:45 - If I type at the bottom
here, make directory--
12:49 - mkdir-- test just to
make a test folder, I'm
12:53 - about to hit Enter, but watch
the top left-hand corner
12:56 - where I currently have those other
files and folders, and when I hit Enter,
12:59 - now I have a test folder.
13:01 - So these things are identical.
13:02 - One is graphical, one is command
line, and there's even other commands
13:05 - if I decide I don't want that.
13:07 - rmdir is remove directory,
and it just goes away
13:10 - because it's empty and thus safe.
13:12 - Any questions then on
any of those commands
13:14 - or just the overall layout of
what it is we're looking at?
13:19 - All right, so don't get hung
up on any of those commands,
13:21 - and the problem set
and beyond will always
13:23 - remind you of those kinds of features.
13:24 - The point for now is just that
we're in a somewhat new environment,
13:27 - but it's fundamentally still the
same, it has the same capabilities.
13:31 - So what are other tools we looked at?
13:32 - So you might have heard rumors about
a tool called check50, and indeed,
13:36 - this is a tool that the staff use to
evaluate problem set 1 and problems set
13:39 - 2 to evaluate the correctness of them
so that we ourselves don't have to type
13:43 - ./mario or ./caesar again and again
and again to test students' code.
13:49 - But starting this week, you, too,
have access to the same program.
13:52 - check50 is a command from the staff
that checks the correctness of your code
13:56 - just like style50 checks
the style of your code.
13:59 - And in fact, if I go
back over to my IDE,
14:02 - let's try to use this for the first
time by making the same version of hello
14:05 - that you did perhaps for
your first problem set.
14:08 - So if I go ahead and include
not just stdio, but cs50.h,
14:12 - and I go ahead and get
a string from the user
14:15 - with get_string, prompting them
for their name, and then go ahead
14:18 - and print not just hello, world,
but hello, percent s comma name,
14:23 - this I believe was the same
program you yourselves probably
14:25 - wrote, or some variant thereof.
14:28 - So if I go ahead now
and test this myself--
14:30 - make hello, Enter, seems OK, ./hello.
14:34 - I'm going to go ahead and type in
my name, and voila, hello, David.
14:37 - Now suppose you're feeling
pretty good, you're
14:38 - pretty confident that
your code is correct,
14:40 - and most importantly, you have
tested your code yourselves.
14:44 - It's not sufficient to
rely on our tool alone
14:46 - to test your code because it,
too, might not be exhaustive.
14:49 - So once you've tried a few inputs,
not just David, but perhaps
14:53 - Veronica's name as well, seems to work.
14:55 - Brian's name as well, seems to work.
14:57 - No name at all, doesn't
seem to work, maybe?
15:00 - But we'll have to look
back to the problem set
15:02 - to see if that's actually a problem.
15:04 - Let me go ahead now and run check50.
15:06 - check50 expects a special
slug, so to speak.
15:10 - Just a unique identifier for the
problem that you want to check.
15:13 - And you would only know
this from reading a problem
15:15 - set or a documentation online.
15:17 - I just happened to recall that the
command that the staff had been using
15:20 - to grade and evaluate hello
is just cs50/2018/fall/hello.
15:26 - And the slash is to just kind of
visually distinguish those words,
15:29 - this isn't a folder or files or
anything like that in your own account.
15:32 - So I'm going to run check50
cs50/2018/fall/hello in the same
15:37 - directory that hello.c is in.
15:39 - Enter.
15:40 - It's going to go ahead and connect
to GitHub, which is the backend,
15:43 - recall, that we use
for storing your code.
15:45 - It's authenticating me now, which means
what's your username and password?
15:48 - I'm going to go ahead and
use one of my test accounts.
15:51 - And now it's prompting
me for my password,
15:53 - and I'm going to go
ahead and type that in.
15:55 - You'll notice you're seeing stars
like you see bullets in a website
15:57 - just so that someone looking over your
shoulder can't see what you're typing.
16:00 - Now I'm going to go ahead
and watch the progress.
16:03 - It's preparing, let me
go ahead and zoom in.
16:06 - Dot-dot-dot.
16:07 - It's looking at my code, it's
getting ready for submission,
16:11 - it's now uploading it to GitHub.com,
and once it's on the servers,
16:15 - then it's going to tell CS50 server,
here is so-and-so's submission,
16:19 - go ahead and run a few
automated tests on it,
16:22 - checking therefore its correctness,
and hopefully we're about to see some
16:25 - green, happy smiley
faces, and voila, yes,
16:29 - it looks like this check50
command for this problem--
16:32 - or slug, so to speak--
16:34 - checked that hello.c exists, because
if I forgot to write the file
16:37 - or if I misnamed it,
nothing's going to work.
16:40 - We checked that it
compiles successfully,
16:41 - so that, too, is a happy green face.
16:43 - Then it apparently checked--
16:45 - what if we type in Veronica?
16:46 - Do we see hello, Veronica?
16:48 - Apparently yes.
16:49 - What if we typed in another word, Brian?
16:50 - Yes, apparently we say hello, Brian.
16:52 - And so with high
probability, we're going
16:54 - to conclude, based on those four tests,
that your code is, in fact, correct,
16:57 - at least with respect to those inputs.
16:59 - And there's often some more
detail via URL at the bottom
17:02 - where you can actually see
more graphically just more
17:04 - feedback on your code.
17:05 - Of course, the first time, second time,
third time maybe you run this command,
17:09 - you might not see some
green happy faces,
17:11 - you might see some red unhappy
faces or some yellow flat faces,
17:14 - which just means we couldn't even run
the checks because something else is
17:17 - wrong.
17:18 - But over time, this will help you feel
more comfortable and more confident
17:22 - that your code's correct before you
actually use submit50 and submit.
17:26 - Going into it you'll feel a little
better or a little frustrated
17:29 - to know in advance-- wait a minute,
I'm about to submit this but nope,
17:32 - it's not yet correct.
17:33 - So realize it's a two-edged sword.
17:36 - Any questions about check50 or
any of these commands thus far?
17:42 - Anything at all?
17:44 - No?
17:45 - All right.
17:46 - So let's take a look at
the final and most powerful
17:49 - tool now available to you
in the IDE environment.
17:53 - Built in to CS50 IDE, which
stands for Integrated Development
17:57 - Environment, which isn't a CS50 thing--
this is a common term in industry
18:00 - for tools that make it
easier to write code,
18:02 - it turns out that there's some other
feature besides the cat over here.
18:06 - Namely, one, you can
share your workspace
18:08 - with teaching fellows
and course assistants
18:11 - so they can perhaps help you in real
time a la Google Docs, even chatting
18:14 - with you in real time.
18:15 - But it also provides you with
what's called a debugger.
18:17 - A debugger, as the name
suggests, removes bugs--
18:20 - or rather, helps you
remove bugs from your code
18:23 - by allowing you to not
just resort to printf--
18:25 - printing out ints and
strings and whatever
18:27 - is good that's going on your
program, it kind of automates
18:30 - that very tedious process for you.
18:32 - And it lets you walk
through your code one
18:34 - line at a time at your
own comfortable pace
18:37 - and see along the way all of the values
of your variables in that program.
18:42 - To activate this debugger, I'm going
to go ahead and do the following.
18:44 - I'm going to compile my code
as always with make hello.
18:47 - It has to compile,
otherwise I might want
18:50 - to use help50 and figure
out why it's not compiling,
18:52 - but it does seem to have compiled.
18:54 - And now I'm going to go ahead
and run debug50, space, and then
18:58 - the name of the program
I wanted to debug.
19:00 - And the name of the program I
wanted to debug at the moment
19:02 - is the current directory's
file called hello.
19:04 - Let's assume that there's
perhaps something wrong with it.
19:07 - The first time I run this
command, though, debug50
19:09 - is not going to be happy with
me because it's going to say,
19:11 - it looks like you haven't
set any breakpoints.
19:14 - Set at least one breakpoint by
clicking to the left of a line number
19:17 - and then rerun debug50.
19:18 - Well what is a breakpoint?
19:20 - Well as the name kind
of suggests, it allows
19:22 - you to break or pause the running
of your code at any of your lines.
19:27 - And all this time for
the past few weeks,
19:29 - your code been
automatically line-numbered.
19:31 - And this is useful because the most
interesting line in this program,
19:35 - once it really gets going,
isn't this stuff at the top,
19:37 - it's not int main void, right?
19:39 - That's all copy-paste
from past programs.
19:41 - It's really the sixth line here where
I actually have some logic of my own.
19:45 - And so in CS50 IDE,
what you can now do is
19:49 - click to the left of one
of these line numbers,
19:51 - a little red light like a stop
sign is going to appear saying,
19:54 - break or pause my
program on this line so
19:57 - that I can poke around my actual code.
20:00 - Sandbox and Lab cannot do this.
20:02 - So now I'm going to go ahead and rerun
debug50 in exactly the same way, hit
20:06 - Enter, but now I have one breakpoint.
20:09 - And you'll see on the right-hand
side a fancier menu just popped up
20:13 - by the cat that provides me
with a bunch of features.
20:15 - And at first glance, frankly,
it's a little overwhelming
20:18 - because there's a lot going on
here, but you'll notice first,
20:21 - and most importantly, there's
some mention of my name variable.
20:25 - I don't quite understand 0x0 or
whatnot, but I do understand string.
20:29 - And so what the debug50 program has
realized is oh, on this line and below,
20:34 - you have a variable called name.
20:36 - It doesn't seem to have a value yet.
20:37 - 0x0, it turns out, is just going
to mean empty or null or 0.
20:41 - But that's good, because now,
when I actually execute this line,
20:45 - hopefully it's going to take on the
name David or Veronica or Brian.
20:49 - So let's see what happens.
20:50 - Notice that it's highlighted in
yellow, line 6, which means it
20:54 - has not yet executed this line of code.
20:56 - My code has paused at this point
because I set that breakpoint.
21:00 - And then notice kind of like a music
player up here, there's a few icons.
21:05 - The Play button is just going
to say, ah, play my program,
21:07 - run it all the way through the end, kind
of like scratch with the green flag.
21:11 - But more powerful is this.
21:12 - You can step over this line,
therefore executing it just once.
21:17 - If it's a function, you
can step into this line
21:20 - and actually look inside of a function
that you're using, like get_string,
21:23 - or you can step out of another
function, but more on that another time.
21:27 - So what I'm going to do is this.
21:28 - And the button I'm going to click most
commonly when trying to understand
21:31 - how my program is working is this--
21:33 - Step Over.
21:34 - So it's the second icon from the
left, right next to the triangle.
21:39 - So once I click this, watch
what's going to happen,
21:42 - even though it's a little small, on the
right-hand side for my name variable.
21:46 - Notice that I'm being prompted to
type in my name because the program
21:49 - is still running in my terminal
window, but when I hit Enter now,
21:52 - providing my own name, automatically
you see on the right-hand side
21:57 - that this name variable has a
value now of, quote-unquote,
22:01 - "David" of type string.
22:03 - There's this 0x1083010-- more on
that later, just a little cryptic,
22:07 - but I didn't have to use printf now,
I can actually see what's going on.
22:10 - Now you can see that
line 7 is highlighted,
22:12 - because I set a breakpoint above
it, so now I'm on the second line
22:15 - because I just stepped into it.
22:16 - Let me go ahead and click
Next again, and you'll
22:19 - see that in my terminal window,
hello, David just got executed.
22:22 - And now if I just keep going, it's
going to go ahead and run to the end
22:25 - and close the debugger.
22:26 - So not all that useful for this
program because frankly, I'm
22:29 - pretty sure this is correct, but the
power of debug50 and a debugger more
22:33 - generally is that it lets you, whether
you're less comfy or more comfy,
22:36 - walk through your own code at your pace
just like a TF or a CA might say, OK,
22:41 - what is this line doing?
22:42 - What is this line doing?
22:43 - You don't have to resort to printf,
you can just very methodically
22:46 - walk through your code and find that
damn bug that's been bothering you
22:49 - for minutes or even hours.
22:51 - So henceforth, any time you have a
bug in your code that is compiling
22:55 - but it's just logically incorrect--
the pyramid in Mario isn't quite right,
22:59 - your encryption of Caesar isn't
quite right, or something else,
23:01 - your first instinct now should be,
let me compile it, run debug50 on it,
23:06 - and just step through the code,
setting a breakpoint wherever I want,
23:09 - so you focus on just a few
lines, not the whole thing--
23:12 - like I just did--
23:13 - and see if you can figure out logically
when a value is not what you expected,
23:16 - then oh--
23:17 - go ahead and just click
Resume, fix the bug, and retry.
23:21 - Such a powerful tool.
23:23 - Any questions?
23:25 - Yeah?
23:27 - What is it?
23:27 - AUDIENCE: What does it look
like when there is a bug?
23:29 - DAVID MALAN: What does it
look like when there is a bug?
23:32 - So the debugger won't find your bugs
and it won't show you your bugs, per se.
23:36 - It's going to let you see
what line is executing,
23:39 - it's going to let you
see what's outputting,
23:40 - it's going to let you
take input, but all it's
23:42 - going to do on that
right-hand side is just show
23:44 - you the values of things along the way.
23:46 - It's up to you to infer
from that information what
23:50 - it is that's going wrong, just like
if you're using printf in past weeks
23:54 - to see what's going on in your program.
23:56 - Other questions?
23:58 - And let me save this too.
24:00 - It is so easy to get into the habit,
especially when so many things have
24:03 - been new over the past few
weeks of just saying, ah,
24:05 - this is just yet another thing to learn.
24:07 - This is hands down the
kind of tool that if you
24:10 - spend a few extra minutes this
week and next week just using it,
24:13 - get a little more
comfortable with it, it
24:15 - will save you potentially
hours in the long run,
24:17 - because all the time you've
been spending manually
24:20 - trying to fix your bugs or
posting questions online
24:22 - trying to understand
things, this is a tool
24:24 - that if you invest those
minutes upfront will just
24:26 - help you understand everything
going on inside of your program,
24:29 - and will absolutely over the next few
weeks save you more and more time.
24:35 - All right, any questions? yeah?
24:38 - AUDIENCE: So you have a for
loop that ran [INAUDIBLE] times,
24:42 - [INAUDIBLE] separate break statements
so you don't have to [INAUDIBLE]..
24:46 - DAVID MALAN: Ah, good question.
24:47 - If you have something like a for
loop or a while loop, something
24:50 - that's happening a lot, can you
set a breakpoint in such a way
24:53 - that it only breaks so that you don't
have to walk through it 100 times
24:57 - just to see that value?
24:58 - Short answer, yes.
24:59 - And let me defer to section and
online resources for just a few
25:02 - of these features, but one,
you can actually watch values,
25:05 - and you can have what's
called a watch expression.
25:07 - You can say show me this value
if only when x is greater than 50
25:11 - or something like that.
25:12 - Or you yourself can just
add some lines of code.
25:14 - You could add a, if x equals-equals
50, then print out something,
25:19 - and you can set a breakpoint
on that new, if temporary line,
25:22 - so there's a couple of ways to do that.
25:23 - Good question to anticipate.
25:24 - Yeah?
25:25 - Behind.
25:26 - AUDIENCE: If you run
debug50, aren't you adding
25:30 - another arugment with the [INAUDIBLE]
in your main method at line 4?
25:35 - DAVID MALAN: Really good question.
25:36 - If you're running
debug50, aren't you adding
25:38 - another argument-- argv-- per our
discussion last week of command line
25:41 - arguments?
25:42 - Short answer, no, because
debug50 corrects for that,
25:44 - so you don't have to worry about that.
25:46 - It will not shift
things over numerically.
25:48 - Really good thought.
25:49 - Other questions?
25:51 - All right, so with that said, let's
now take some training wheels off.
25:58 - So the only reason I bought
these training wheels years ago
26:01 - is to make this very dramatic point
of now taking the training wheels off
26:05 - today.
26:07 - OK, so what does this mean?
26:09 - Well worth the trip to Target.
26:11 - So what does this mean?
26:12 - For the past few weeks, we
have been using a whole bunch
26:15 - of functions from CS50's library.
26:17 - All of these were meant to just make
it pretty easy, relatively speaking,
26:20 - in the first few weeks to
get input from the user.
26:22 - Because it turns out,
as we'll see today,
26:24 - it's actually a kind of a pain in the
neck to get input from users in C,
26:28 - and frankly, even in other
languages reliability.
26:31 - Because you'll recall that get_string
and get_int and all of these functions
26:35 - take on the burden of like re-prompting
the user if they don't actually
26:38 - give you an an int or
don't give you a float
26:40 - or don't give you a char that
you're expecting, they'll re-prompt,
26:42 - they're using a while loop or
a do-while loop or the like,
26:45 - so there's just a lot of error
detection built into these functions.
26:48 - But, most importantly--
and most misleadingly,
26:52 - has been the last one on this list.
26:54 - Recall that we introduced a couple
weeks ago now the notion of a string.
26:58 - And a string is in English what?
27:01 - An array of characters, good.
27:02 - It's a sequence of characters, and we
learned last week that a sequence can
27:05 - be implemented in an array,
which is just a chunk of memory
27:07 - back-to-back-to-back-to-back.
27:09 - So string, though, is not quite
like any of those other data types.
27:14 - It turns out that it's not quite like
int or char or even bool or float,
27:18 - and we can start to see
that now as follows.
27:21 - I'm going to go ahead and
go into the IDE today--
27:23 - and henceforth we're going
to just start using the IDE,
27:25 - but you're welcome to keep using the
Sandbox for quick and dirty programs,
27:28 - but for anything you
want to keep around,
27:30 - your instinct should
now be to open your IDE.
27:32 - I'm going to go ahead
and create a new file,
27:34 - and I'm going to call it compare0.c from
my first example of comparing things.
27:39 - And I'm going to go ahead and
whip up a relatively short program
27:42 - that you would hope would
work right out of the box.
27:45 - So I'm going to go ahead and
include the familiar cs50.h.
27:48 - I'm going to go include stdio.h.
27:50 - I'm going to go ahead
and do int main void.
27:52 - I'm going to go ahead and in here--
27:54 - let me a variable called i
using get_int from the user,
27:57 - and just prompt them for i.
27:59 - Let me go ahead then and prompt
the user for another get_int.
28:03 - We'll call it j and get that from them.
28:05 - And then let's just
compare these things.
28:07 - So if i equals-equals j,
then go ahead and print out
28:11 - with printf same and a new line.
28:13 - Then go ahead and print out the
opposite, which is different.
28:18 - So the only place I think I
could have screwed up, perhaps,
28:21 - is if I did this, which is
kind of reasonable if you
28:24 - come in knowing what an equal sign is.
28:25 - But again, in code, we
typically need two equal signs
28:28 - because that compares two values.
28:29 - So I didn't make that mistake, I'm
feeling pretty good about this.
28:32 - Let me save it with Command-S
or Control-S or via File,
28:36 - Save; go to my prompt
and run make compare0.
28:39 - Good, everything compiled.
28:41 - And let me go ahead and run
compare0, Enter, and I'll type in 50,
28:46 - and I'll type in 50, and
they do seem to be the same.
28:50 - Let me go ahead and do that
again, let's type in 42 and 13,
28:54 - and they are different.
28:55 - And I should probably test a few more,
maybe some negative values, maybe some
28:58 - 0's, positive values
and the like, but I'm
29:00 - feeling pretty good about
the correctness of this code.
29:02 - All right.
29:03 - So let's change this program a bit.
29:05 - Let me go ahead and
create another file, which
29:07 - I can do with the little green
plus or via File, New File.
29:10 - I'm going to go ahead save
this one as compare1.c.
29:12 - And for the moment I'm going to go
ahead and just paste in that code
29:16 - from before, but I'm going
to make some changes now.
29:19 - I'm going to go ahead and rename
and retype my data types as strings.
29:24 - So give me a string called
s, and will prompt the user
29:26 - for that using
get_string, then I'm going
29:29 - to go ahead and change
this 1 to string t,
29:31 - and I'm going to go
ahead and get get_string.
29:33 - I, of course, need to now
compare s and t, not i and j.
29:38 - And s is a common variable name
for a string. t just comes after s,
29:41 - so that's pretty reasonable too, but I
should of course update that as well.
29:44 - And so I think everything's
now the same logically.
29:47 - I just changed my data
types and my variable names.
29:49 - So I've saved this.
29:50 - Let me go ahead and run make compare1.
29:53 - Good, everything's correct.
29:55 - Let me go ahead and do ./compare1.
29:59 - Let me go ahead and type
in Brian and Veronica.
30:04 - And of course, those are different.
30:06 - Now let me go ahead and type in
David, let me type in David again,
30:09 - and those of course are different?
30:13 - Huh.
30:14 - Maybe it's because I just hit
the Spacebar or something.
30:16 - So let's try Erin.
30:19 - Her name's a little shorter.
30:20 - Hmm.
30:21 - OK, let's try-- oh, what's her name?
30:24 - TJ.
30:25 - OK, even shorter, perfect.
30:27 - TJ, can't go wrong.
30:29 - Different.
30:29 - I mean, what is going on?
30:31 - Let's just say i, i.
30:33 - Different?
30:35 - So where's the logical
bug in this program?
30:42 - What is it that's going on?
30:44 - Yeah, what do you think?
30:45 - AUDIENCE: Is it
comparing integer values?
30:47 - DAVID MALAN: Is it
comparing integer values?
30:48 - Well maybe.
30:49 - I mean, thus far when
we've used equal-equals
30:51 - we've probably used it mostly
for comparing integers,
30:53 - so maybe I'm just misusing it, sure.
30:55 - Other thoughts?
30:56 - AUDIENCE: [INAUDIBLE]
30:59 - DAVID MALAN: Oh, that's a big word
that we'll get to in just a little bit.
31:02 - But correct, correct-- but
for very similar reasons.
31:06 - So something's going on
logically involving comparison,
31:10 - because I'm using equal-equal, but maybe
I'm using it for the wrong data types?
31:14 - I mean, it's clearly broken for strings.
31:17 - So why might that actually be?
31:19 - Well it turns out that
strings don't actually exist.
31:24 - So a string that we know is
just a sequence of characters
31:27 - or an array of characters
is not an actual data type.
31:30 - int is, float is, double is,
long is, bool is, and even more
31:35 - are actual data types.
31:36 - String is kind of a
little white lie we've
31:38 - been telling for a few weeks that's
implemented only in the CS50 library.
31:43 - Now the word string is
super common in programming.
31:45 - Like every programmer out there will
know what you mean when you say string.
31:48 - That is not a CS50 word, but our
use of it in C is CS50-specific.
31:52 - Because in that file
called cs50.h, in addition
31:55 - to declaring functions like
get_string and get_int and get_float
31:58 - and a bunch of other things, we
also have a special line that says,
32:01 - create a data type called string.
32:05 - But what does it actually do
or what does it actually mean?
32:08 - Well let's go ahead and consider what
might be going on underneath the hood
32:12 - here.
32:12 - So if I go ahead and draw
the program that we just
32:16 - ran, that program compare1
gets a string s from the user,
32:20 - then gets a string t from the
user, and then compares them.
32:23 - So we know from last week what
a string is, it's just an array.
32:26 - So when I run that first line of
code and get a string from the user--
32:30 - for instance, Brian, I'm going
to go ahead and see a B-R-I-A-N,
32:36 - which we know from last week to actually
be an array of memory that might look
32:41 - pictorially like this-- and this,
too, is a bit of a white lie,
32:44 - there's something else.
32:45 - AUDIENCE: The null.
32:46 - DAVID MALAN: Yeah, the null
character, so to speak, and ul,
32:49 - which we typically just write with a
backslash 0, which is just all 0 bits.
32:53 - And it turns out, you might recall from
the debugger earlier, you saw this--
32:57 - that's the even more cryptic way
of expressing the null character,
33:00 - backslash 0.
33:01 - Just different programs
display it in different ways.
33:03 - So when I get_string and type in Brian,
this is what's allocated in memory.
33:08 - And when I type Veronica, I
can see a V-E-R-O-N-I-C-A.
33:13 - I'm going to get that
right preemptively.
33:15 - Backslash 0.
33:16 - That, too, is a chunk of memory,
which I'll draw like this.
33:20 - 1, 2, and split these up into
interval characters or bytes.
33:25 - And recall from last time that these
bytes just come from my memory,
33:28 - and that memory just has a bunch of
bytes in it, maybe millions or even
33:31 - billions these days.
33:32 - And so honestly, if you
just have that many things,
33:34 - any human or computer can
certainly number them.
33:37 - Like this is byte 1, 2, 3, 4.
33:39 - So let's just assume for
the sake of discussion
33:42 - that out of context of
my computer's hardware,
33:44 - Brian just ended up at location 100, and
location 101, and 102, 103, 104, 105.
33:54 - So this is the 100th
byte in my computer,
33:57 - this is 105th byte in
my computer, and Brian
33:59 - is using that many characters in total.
34:01 - Veronica, she ended up somewhere else.
34:03 - Maybe she ended up farther away just
because at location 900, 901, 902, 903,
34:10 - 904, 905, 906-- a lot more
memory, 907, and 908--
34:17 - but you can see even more visually
now that the length of Brian's name--
34:22 - strlen of Brian is what?
34:26 - AUDIENCE: [INAUDIBLE]
34:29 - DAVID MALAN: I hear five and I hear six.
34:30 - The length of Brian's name--
34:32 - Brian, how long is your name?
34:33 - AUDIENCE: Five.
34:34 - DAVID MALAN: OK, it is
definitively five characters, that
34:36 - is the length of Brian's
name, but you have
34:39 - to appreciate that in the computer,
Brian's five-character name does indeed
34:43 - take up six bytes.
34:44 - So both answers are kind of correct,
but the length of the string henceforth
34:47 - is always the number
of actual characters.
34:49 - The amount of space it takes up is
that plus 1 for the null character.
34:53 - So you can actually see why Brian's
name takes up six bytes in this picture
34:57 - rather than just the actual
length, which is five.
35:00 - So when you call get_string
now, and when you call
35:03 - get_string and get another string--
35:05 - Brian and Veronica respectively,
what is actually being handed back?
35:09 - A couple weeks ago, Erin
came up and she kind of like
35:12 - handed me back a string, a
student's name from the audience.
35:15 - On that piece of paper we
thought was the student's name.
35:19 - But it's not.
35:21 - It turns out that when a
function returns a value,
35:23 - it can pretty much only return
a 1 byte or maybe 2 or 4 bytes.
35:28 - It can't return an arbitrary number of
bytes, like six for Brian or 1, 2, 3,
35:33 - 4, 5, 6, 7, 8, 9-- it cannot
return 9 bytes for Veronica.
35:37 - And if you even type a whole
paragraph or page of text,
35:40 - it can't return all of that text,
it can only return a single value.
35:45 - So to your instinct
earlier, what might actually
35:48 - be getting returned by
get_string when the human has
35:52 - typed in a name like Brian or Veronica?
35:55 - AUDIENCE: [INAUDIBLE]
35:57 - DAVID MALAN: The memory location.
35:58 - Indeed, an integer, or as
you called it, a pointer,
36:01 - which we'll introduce more
formally in just a moment.
36:03 - So when get_string string
returns "Brian," quote-unquote,
36:06 - it's actually not returning B-R-I-A-N
backslash 0, it is just returning 100.
36:13 - And when get_string returns Veronica,
it's not returning her name,
36:16 - it's returning 900.
36:18 - And so if you realize
that now, when you do does
36:21 - s equal-equal t, what question more
mundanely are you actually asking?
36:27 - Yeah.
36:28 - Memory location and memory
location-- does 100 equal 900?
36:32 - And obviously not.
36:33 - And so that is why Brian's
name, Veronica's name,
36:36 - my name, TJ's name-- every word I
typed in was of course different,
36:40 - because each input was ending up
at a different location in memory.
36:44 - And even if I typed the same word like
David twice, one David was going here,
36:48 - one David was going somewhere
else, they were ending up
36:50 - at different memory locations.
36:52 - Maybe 100, maybe 900,
maybe something else,
36:54 - but they were ending up in
different locations in memory.
36:56 - So equal-equals does
compare values, but dammit
36:59 - if it isn't comparing the wrong values.
37:02 - Yeah?
37:02 - AUDIENCE: Well what if
you use some char*s?
37:04 - DAVID MALAN: Ah, so
we'll come back to that.
37:06 - Let me come back to
that in just a moment.
37:08 - char* is actually intricately related.
37:10 - More on that in a moment.
37:11 - Yeah?
37:12 - AUDIENCE: If you add
two integers in memory--
37:14 - DAVID MALAN: Uh huh?
37:14 - AUDIENCE: Wouldn't they be in
different places in memory?
37:17 - So you would return--
37:19 - so you need a different value.
37:20 - DAVID MALAN: OK, really good question.
37:22 - So wait a minute, this same logic that
I'm returning the address of something
37:27 - surely applies to integers as well
or floating point values as well?
37:31 - Because if I type in
the number 50 like I
37:33 - did earlier, that, too, is somewhere
in memory-- like a box in memory,
37:37 - and that, too, has an
address somewhere in memory,
37:40 - but it turns out, for reasons that
you just alluded to, actually,
37:44 - ints are returned as their values.
37:46 - Chars are returned as their values.
37:48 - Bools are returned as their values.
37:50 - Floats are returned as their values.
37:51 - Strings are different.
37:53 - Strings are returned by their address.
37:56 - And those addresses, it turns out,
are ultimately going to be called
38:02 - char*'s, which we'll
see in just a moment.
38:04 - So how do we go about then
fixing this fundamentally?
38:07 - Like even if you have no idea how
to code this yet, just intuitively,
38:11 - if I do actually want to delete--
38:14 - if I do actually want to compare--
38:17 - sorry.
38:21 - OK.
38:22 - If I do want to go ahead and compare
Brian and Veronica for equality,
38:27 - what do I want to do intuitively?
38:29 - I can't just compare their addresses.
38:31 - What do I need to do?
38:33 - Isolate the characters and
then do what with them?
38:35 - AUDIENCE: [INAUDIBLE]
38:38 - DAVID MALAN: Good.
38:39 - Yeah, good instincts.
38:40 - Use a for loop, use a while loop--
any kind of looping structure.
38:43 - And intuitively, compare
the first characters,
38:45 - and if they're different, well then we
know we don't have to go any further.
38:48 - B is not a V, so surely
these names are different.
38:51 - But what about in my case?
38:52 - If it was David and David, you
would compare the first two.
38:54 - D and D are the same.
38:56 - Compare the second two,
A and A are the same.
38:58 - V and V, I and I, D and D, and
then what am I going to hit last?
39:03 - Null character.
39:04 - And should I keep going
beyond the null character?
39:06 - No.
39:07 - So this is the beauty of that
super simple design for a string.
39:10 - Insofar as strings are identified by
their starting address, just the byte
39:15 - at which they start,
you still need to know
39:18 - how long they are, because otherwise
how do where one word begins and ends
39:22 - and another word begins?
39:24 - And so the simple decision we made
last week-- as did humans decades ago--
39:28 - to terminate all strings with backslash
0 or all 0's is a super handy trick,
39:33 - so that if I tell you
that Brian starts at 100,
39:36 - you can infer that he ends where?
39:41 - At byte number 105 or 104, if you will,
however you want to think about it,
39:45 - because all you need
to do in linear time,
39:48 - if you will, left or right, is
check-- backslash 0, backslash 0-- ah!
39:51 - Backslash 0, now I know
how long Brian's name is.
39:54 - So let's consider for a moment
this program called string length.
39:57 - How does strlen actually work?
40:00 - When you pass to strlen, a variable
containing a string, like Brian,
40:05 - what is sterling probably doing?
40:08 - AUDIENCE: [INAUDIBLE]
40:10 - DAVID MALAN: Exactly.
40:11 - It's looking at that
null character's address
40:13 - and subtracting the start
address and the end address,
40:17 - figuring out what the difference
is, and actually returning
40:20 - that minus 1 the total count.
40:22 - And more mechanically,
we'll see in a moment,
40:24 - it's probably doing exactly
the same thing I did,
40:27 - which is, is this backslash 0?
40:28 - Is this backslash 0?
40:29 - Is this, is this, is this?
40:30 - I asked that question five
times before I saw backslash 0.
40:33 - strlen is just a function
some human wrote years ago
40:37 - that probably just has a simple
for loop and an if condition,
40:39 - and then that's it.
40:41 - Because that person
understood before we even
40:43 - did how strings are
actually implemented.
40:47 - Any questions then?
40:49 - All right, so let's
actually implement this.
40:50 - Let me go ahead and into my editor
here, and make one other example here
40:54 - that I'm going to call compare2.
40:56 - I'm going to go ahead and do
include cs50.h and include stdio.h,
41:03 - and then I'm going to do
int main void, and I'm
41:05 - going to quickly now grab my code
from before where I got strings
41:11 - and I compared them, but I have
to obviously fix that comparison.
41:14 - So here's my code from before.
41:16 - I'm going to do this the right way.
41:18 - I'm going to call a function called
compare_strings passing in s and t.
41:22 - Because as you proposed,
we need to do some logic.
41:24 - We don't have to pass it to
a function, but we could.
41:26 - We could just do a
for loop here, but I'm
41:28 - going to go ahead and implement
compare_strings as follows.
41:31 - If I want to write a function that
returns a yes/no answer, what data type
41:36 - should it return?
41:37 - A bool.
41:38 - So we've not necessarily
done this yet, but you
41:40 - can return a bool just like you can
int or a char or something else.
41:44 - I'm going to call this
function compare_strings.
41:46 - It's going to take in one string
called a and another string called b,
41:50 - but I could call those anything I want.
41:52 - And now what's the
easiest thing to check?
41:55 - If I pass two strings, a and
b, or Brian and Veronica,
41:58 - what's the easiest question you can
ask and just immediately say, nope,
42:01 - these are different?
42:03 - String length, right?
42:04 - Like if the B-R-I-A-N is not of
the same length as Veronica's name,
42:08 - we don't need to do any
logic whatsoever beyond that,
42:10 - we can just quit and say false.
42:12 - So let me just do that.
42:13 - If the strlen of a does not equal
the strlen of b, you know what?
42:18 - Let's just go ahead and return
false and get out of here.
42:21 - OK, but now, if we get past
that gateway, so to speak,
42:25 - that check, that question,
that Boolean expression,
42:27 - now I have to compare things
character by character by character.
42:31 - So I can do this in a bunch of ways,
but I like the suggestion of a for loop.
42:34 - So for int i at 0, n for
efficiency-- actually,
42:38 - let's do i is less than
the string length--
42:41 - should I do the string length of a or b?
42:44 - And it doesn't matter, right?
42:46 - So let's go with a.
42:47 - And frankly, had I
been smart early on, I
42:49 - could have stored the value in
a variable and then reused it,
42:52 - but we'll just keep going ahead for now.
42:53 - Then i plus-plus, but I remember
from last time-- this is correct,
42:56 - but this is not good design.
42:57 - Why?
43:00 - Yeah, I keep calling strlen again and
again, because remember, in a for loop,
43:03 - this condition is
checked again and again
43:06 - and again-- you're just
wasting your own time.
43:08 - So let me go ahead and actually do this.
43:10 - n or any variable equals the strlen
of a, then just compare i against n,
43:17 - because now i is getting
incremented, but n is never changing.
43:20 - So now let me go ahead and
implement this for loop.
43:23 - So if-- how about the i-th character
of a does not equal the i-th character
43:29 - of b, I can immediately conclude--
43:32 - nope, these strings can't be the
same, because some letter, like a B,
43:36 - is not the same as another, like a
V, or whatever letter we're actually
43:39 - comparing.
43:40 - And then I think that's it.
43:42 - If I get through these
gauntlets of questions--
43:45 - are yours lengths different?
43:46 - Are your characters different?
43:48 - And I still haven't said false,
what should I return by default?
43:53 - Yeah.
43:53 - Like if you make it through all of
those questions and all is well,
43:57 - then D-A-V-I-D must indeed equal
D-A-V-I-D or whatever the user actually
44:02 - typed in.
44:02 - Now I'm not quite done yet.
44:04 - When I've implemented a
function or a helper function
44:06 - like this, because it's
helping me do my work,
44:09 - what else do I have to add to the file?
44:10 - Oh?
44:11 - AUDIENCE: I've got a logical question.
44:12 - DAVID MALAN: Sure.
44:13 - AUDIENCE: In a computer, couldn't you
just type in David with a capital D
44:16 - and then david with a lowercase d,
you're going to run [INAUDIBLE],,
44:19 - they're not going to sync because
your first character's not
44:20 - the same character.
44:21 - DAVID MALAN: Correct.
44:22 - So this is a feature,
not a bug at the moment.
44:25 - My program at the moment
is case-sensitive.
44:28 - If I type in DAVID and all
caps, that is a different string
44:30 - I claim for now than
david in all lowercase.
44:33 - If you want to tolerate
uppercase and lowercase,
44:35 - you're going have to add more logic.
44:37 - But for now that's a design
decision that I intend.
44:40 - All right.
44:40 - What else do I need
to add to the program?
44:44 - Yeah, the prototype at top.
44:46 - You can literally copy and paste--
this is the only time copy and paste is
44:49 - probably a legitimate thing to do--
44:51 - at the top, and then semi-colon--
don't re-implement it.
44:53 - But I do need one other header file.
44:56 - I'm using a function that's
not in cs50.h or in stdio.h.
45:02 - String length?
45:04 - Where was string length?
45:06 - Yeah, string.h.
45:07 - So I just need this,
include string.h, save.
45:11 - Now this I think is correct.
45:13 - We'll see if I eat the word in a moment.
45:16 - But realize that if you're
writing this code yourself,
45:18 - like this is not a natural thing to
be writing a program in office hours
45:21 - or at home in your dorm and just
getting it right the first time.
45:24 - This is after like 20 years of doing
this, so realize we happen to be--
45:27 - and I also have a cheat
sheet right here--
45:29 - we happen to be doing
this correctly often,
45:31 - but realize that's not
going to be the common case.
45:34 - So with that reassurance
in mind, let's see
45:36 - if I have to now take all
that back. make compare2.
45:41 - OK-- phew.
45:41 - 20 years worked out.
45:42 - So now I'm going to go
ahead and ./compare2.
45:45 - Let's type in Brian,
let's type in Veronica.
45:48 - Those are indeed still
different hopefully.
45:50 - Now let's try myself, David and David.
45:53 - Phew!
45:54 - Those are the same.
45:55 - And to your point, David in
capitalized and David in all lowercase,
46:00 - different, but that's what I expect now.
46:04 - Any questions on compare2?
46:06 - Yeah?
46:06 - AUDIENCE: [INAUDIBLE]
46:09 - DAVID MALAN: OK.
46:10 - AUDIENCE: [INAUDIBLE] string
in the program and in general.
46:14 - DAVID MALAN: OK.
46:15 - AUDIENCE: Would that
still work [INAUDIBLE]
46:18 - DAVID MALAN: If you were
to hard code the strings?
46:20 - Short answer, yes,
that would still work.
46:22 - If you for whatever reason did
not do this and using get_string,
46:27 - but you did David, and here, for
instance, David, that would work too.
46:33 - And whatever your error is, if you
can recreate it, just let us know.
46:36 - AUDIENCE: It seems to be like a
string that would be increased
46:39 - for a set that was [INAUDIBLE] only?
46:41 - And it was having issues
in the little [INAUDIBLE]..
46:44 - DAVID MALAN: I'd have to see it to
be sure, but happy to chat after.
46:47 - All right, so let's see
if we can't now clean this
46:50 - up just a little bit as follows.
46:53 - Let me go ahead here and reveal
what it is that's actually going on.
46:59 - So indeed, there is no
such thing as a string.
47:02 - And indeed, as you
pointed out a moment ago,
47:03 - it actually goes by a different name.
47:05 - String is just a synonym
for what's called a char*.
47:09 - Now what does that even mean?
47:10 - So char is the same as it's always been.
47:12 - It's a single character.
47:13 - Star in a program written in C
could of course mean multiplication,
47:17 - we have seen that.
47:18 - This is another use of the star.
47:20 - Whenever you see it after
a data type like char,
47:23 - this means that the data type
in question is not just a char,
47:27 - it's the address of a char.
47:29 - So the star just means the address of
whatever the data type is to the left,
47:33 - and this is, as you
pointed out earlier, what
47:35 - we're going to start calling a pointer.
47:37 - A pointer is, for all intents
and purposes, an address.
47:40 - It's just a buzzword
to describe an address.
47:42 - This data type here, char*, means I want
a variable that doesn't store a char,
47:48 - it stores the address of a char.
47:50 - The number 100, the number 900.
47:53 - But that address is just
going to be called a pointer.
47:56 - A pointer variable is a variable
that stores the address of something.
48:00 - A char or even other data types as well.
48:02 - So with that in mind, let me actually
quickly create compare3.c, paste this
48:08 - in, and save it as compare3.c,
and let me take off, if you will,
48:13 - those training wheels.
48:14 - It turns out that when you
get a string with get_string,
48:18 - it doesn't return a string,
per se, because again,
48:20 - that word doesn't exist in C,
it actually returns a char*.
48:24 - And when I call it again here and
return another string, it, too,
48:27 - returns a char*.
48:29 - Now technically the star
can have spaces around it.
48:32 - Some people write it like this,
but the sort of right way to do it
48:35 - or the default way should just be to
put the star next to the variable name
48:38 - for clarity.
48:39 - So I have to make a few other changes.
48:41 - This should change too, because
there is no more string as of today.
48:45 - I'm going to change this to a char*;
and then I also need to change it here,
48:49 - char*; and then here, char*;
and that is actually it.
48:57 - And honestly, the only reason we didn't
introduce this like two weeks ago
49:01 - is because it just looks cryptic.
49:03 - Like no one wants to program the first
time they're ever touching a keyboard
49:06 - and writing code and see char* and
need to worry about what that means,
49:09 - it's just a string conceptually.
49:11 - But the only change I technically need
to make to take those training wheels
49:14 - off is just change all mentions
of string as data types to char*.
49:19 - And that just means
that you know what-- a?
49:20 - Yes it's a string, but more technically
it's the address of a string.
49:25 - Or more precisely, it is the address
of the first byte of the string,
49:29 - like 100 for Brian or 900 for
Veronica, and I'm not even
49:33 - going to tell you where the string
ends because you, the programmer,
49:36 - can figure that out by calling
strlen or just by using a loop
49:40 - and figuring out where that
backslash 0 actually is.
49:43 - So that is enough information
to pass it around.
49:46 - So if go ahead now and
compile this, make compare3,
49:49 - and then I go ahead and do ./compare3,
let's go ahead and type in Brian
49:55 - and Veronica, those are
indeed still different.
49:57 - Now let me go ahead and type in David
and David, those are in fact the same.
50:01 - So the training wheels are off,
there is no such thing as string,
50:04 - henceforth it's a char*.
50:05 - Let's go ahead and take a quick
break here for five minutes,
50:08 - and we'll come back and dive in more.
50:10 - All right.
50:11 - So we are back, and let's go
ahead and simplify this now,
50:14 - as our tendency has been.
50:15 - It's kind of a bunch
of code, but I think
50:17 - we can make this a little tighter.
50:18 - But rather than type
this one out manually,
50:20 - let me go ahead and just open
one of our pre-made examples
50:22 - from today, which is all in the
course's website, called compare4.
50:26 - And you'll see in compare4, that's it.
50:29 - I only have a main function this time.
50:31 - I've gotten rid of my compare_strings
function because you know what?
50:34 - I seem to be using something instead.
50:37 - What function did I apparently deploy?
50:41 - Yeah, S-T-R-C-M-P, or
someone with pronounce it,
50:43 - just str compare or strcmp.
50:45 - So this, like strlen,
also succinctly named,
50:49 - is just a function
that's actually declared
50:51 - in one of our familiar
libraries up top, string.h,
50:54 - and it turns out if you look
in the man page, so to speak,
50:57 - by typing man strcmp, or if you
go to CS50 reference and actually
51:01 - look at the less comfortable
description of the function there,
51:03 - this is just a function
whose sole purpose in life
51:05 - is to compare strings for you.
51:07 - But it's a little different
in behavior because it's
51:09 - a little fancier than
the one I just wrote.
51:11 - Let me zoom in on this, and
you'll see that line 14 here, I'm
51:15 - not quite treating it in the same way.
51:19 - My logic is ever so slightly different.
51:22 - What am I actually checking for in
my Boolean expression this time?
51:28 - AUDIENCE: [INAUDIBLE]
51:29 - DAVID MALAN: Yeah,
which is a little weird.
51:31 - I'm checking explicitly-- if strcmp's
return value equal-equal to 0.
51:36 - Before I just said, if
compare_strings s comma
51:41 - t, because I was expecting back a bool--
true or false. strcmp, kind of weird,
51:46 - acts the opposite way.
51:48 - It turns out that strcmp
doesn't return true and false.
51:51 - If you read its documentation, it
returns 0 if the strings are equal,
51:56 - but super conveniently, it
returns a positive value
52:00 - if s is supposed to come before
t, and it returns a negative value
52:04 - if s is supposed to come
after t alphabetically.
52:07 - So it turns out that you can use strcmp
not just to compare for equality,
52:11 - but inequality--
52:12 - less than or equal--
52:13 - less than or greater than,
so to speak, alphabetically,
52:16 - or in ASCII order, so to speak.
52:18 - It will actually compare character
by character the ASCII values,
52:21 - and that will make sure
that B comes after A,
52:24 - and C comes after B, and so forth.
52:26 - So you can actually use strcmp
to like sort a dictionary,
52:28 - or to sort the contacts in your
iPhone or your Android phone.
52:32 - So long story short, this
is a function we can use,
52:35 - we don't have to reinvent this
wheel, and thus, we have no more code
52:38 - even after this.
52:38 - We just have to use it correctly,
and there, the documentation
52:41 - is your friend.
52:42 - So if I run this program it's
going to work exactly the same way,
52:45 - but let me go ahead and
point out some flaws.
52:48 - It turns out all this time, I've been
a little lazy with my error checking--
52:52 - checking for errors.
52:54 - There's a whole bunch of things
that can go wrong in week 1 of CS50
52:57 - that we just kind of turn a blind
eye to, because it would just
53:00 - bloat our code, make it longer and sort
of less interesting and fun to write
53:04 - and less comprehensible.
53:05 - But today, now that we know
what's actually going on,
53:07 - we can begin to ask some
additional questions
53:09 - and make our code
stronger, more robust so
53:12 - that nothing does, in fact, go wrong.
53:13 - Turns out, if you read the documentation
for get_string in the man page
53:16 - or in CS50 reference,
turns out get_string
53:19 - does return a string-- uh, not really.
53:22 - It returns the address of a string.
53:23 - Uh, not really.
53:24 - It returns the address of the first
byte of a string, technically.
53:30 - But if something goes wrong, it returns
a special character called null.
53:34 - Not to be confused with NUL, it
returns a special address called null--
53:40 - left hand wasn't talking
to right hand decades ago.
53:42 - So null, N-U-L-L, just means the address
0, which nothing should ever live at.
53:49 - It's just a bogus, invalid address.
53:52 - Insofar as get_string returns the
address of a string in memory,
53:57 - like 100 for Brian or 900 for
Veronica, if get_string ever
54:01 - runs into a problem and just something
goes wrong with the computer,
54:04 - if it ever returns 0,
specifically 0, a.k.a.
54:09 - null-- N-U-L-L, then you can detect
that something has gone wrong.
54:15 - So to do that, and it's going
to get a little tedious,
54:18 - but it's nonetheless
the right thing to do,
54:19 - I need to be a little more defensive.
54:22 - If s equals-equals null, otherwise
known as 0, otherwise known as 0x0,
54:29 - but I'll write it
conventionally like this,
54:31 - I'm going to go ahead and
return 1 as my exit code.
54:35 - If t equals-equals null, I'm going to
go ahead and return 1 as my exit code,
54:40 - or I could return 2 or 3--
54:42 - I just need to return some
value to signal to the computer
54:44 - that something went wrong,
but by default we'll
54:46 - just return 1 whenever something
goes wrong, but if all went well,
54:51 - I'm going to go ahead and return 0.
54:52 - So recall again from last week, and
we didn't spend a huge amount of time
54:55 - on this--
54:56 - main itself can return values.
54:58 - By default, ever since week 1,
if you don't return anything,
55:01 - main is automatically and secretly
returning 0 for you because 0 is good.
55:06 - The reason for 0 is because there's
only one 0 in the world, obviously,
55:10 - but there is an infinite
number to the left
55:11 - and there's an infinite number of
the right, negative and positive.
55:14 - That's great, because as you've already
experienced in the past few weeks,
55:17 - it feels like there's an infinite number
of things that can go wrong when you're
55:19 - writing even the shortest of programs.
55:21 - So that means we have a lot of
numbers we can assign to error codes,
55:25 - so to speak.
55:26 - Now I don't really care
what the error codes are,
55:28 - so I'm just going to adopt the
human convention at the moment--
55:31 - if anything goes wrong,
returns anything other than 0.
55:35 - And so I'm going to return 1 up here,
but if nothing goes wrong, return 0.
55:39 - The point here is that by adding
these three lines here and these three
55:44 - lines here, I'm going
to avoid what's called
55:46 - a segmentation fault or
segfault. Did any of you
55:50 - encounter this cryptic error?
55:51 - OK.
55:52 - So a decent number of you, and if you
probably had no idea what that means,
55:54 - but starting today you will a bit
more, and in the weeks to come,
55:57 - you'll understand even more.
55:58 - Segmentation fault means you
touched memory you should not have.
56:02 - Or something went wrong
and you did not detect it.
56:06 - It's kind of a catch-all phrase
for memory-related problems.
56:09 - This helps ward off
those kinds of errors.
56:11 - It's not the only way,
but it's one such way.
56:14 - So starting today with problems
set programs and anything
56:17 - you write in the course, you
always want to be thinking about,
56:20 - even if you go back and add
it later, could this go wrong?
56:22 - Could this go wrong?
56:24 - And just add some
additional ifs and else-ifs
56:26 - and handle those situations so that
your program doesn't just crash on you
56:29 - or segfault or surprise someone
who's actually using it.
56:33 - All right, let's take a
look at one final example,
56:36 - because frankly this
is a little tedious.
56:38 - I'm going to go ahead and open up--
56:40 - and this file can be
found in compare5.c.
56:42 - Let me go ahead and save this
so that we have it-- compare5.c.
56:47 - I'm going to make one
final comparison example.
56:49 - I'm going to save this as compare6.c.
56:51 - Turns out that humans
like their succinctness.
56:54 - And null, because it is
technically the 0 address,
56:58 - you can actually be a little clever.
57:00 - If not s and if not t is a sufficient
way to express those same things.
57:07 - Because what does the bang do?
57:08 - The exclamation point
in code if you recall?
57:12 - It inverts something.
57:13 - So like if this is saying, if s is not
0, a.k.a., if s not null, or rather--
57:23 - if-- now I'm getting confused.
57:26 - Yes.
57:26 - If I had just said, if s,
then it's a valid address
57:29 - and I should go on with my business.
57:31 - But if it's not s or
if s is null, I want
57:36 - to go ahead and return 1 because
there's an error, and down here too.
57:39 - So any time you're checking
whether something equals null,
57:41 - you can make it more succinct by
just saying if not s; if it's null,
57:45 - return 1.
57:46 - If it's null, return 1.
57:47 - It's just syntactic shorthand.
57:50 - Phew!
57:51 - I had to think about that one.
57:53 - Any questions?
57:53 - AUDIENCE: Why does [INAUDIBLE]
will store some [INAUDIBLE]
58:01 - DAVID MALAN: Correct.
58:02 - You are storing an address,
but if that address is 0.
58:06 - Saying if it's not 0, 0 is like
false, so not false means true,
58:12 - and so it has the effect
of inverting the logic.
58:16 - That's all.
58:16 - Anytime you use a bang or exclamation
point, it changes a 0 to non-0--
58:20 - AUDIENCE: [INAUDIBLE], but even--
58:22 - I don't understand why [INAUDIBLE]
implies that it's [INAUDIBLE]..
58:28 - DAVID MALAN: So you can
think about it this way.
58:30 - If s-- previously we had this.
58:32 - If s equals-equals null is like
saying if s literally equals 0.
58:38 - And you can kind of think
of that informally as
58:40 - if s doesn't have a valid pointer--
58:42 - 0 is not a valid point or it's
not a valid address by definition.
58:46 - 100 is valid, 900 is valid, 0 is not
valid just by a human convention.
58:50 - So this is like saying, if s does
not have a value, that's valid.
58:54 - So the way to succinctly
say that, if not s,
59:00 - and it's just shorthand for that
is another way to think about it.
59:03 - All right, so let's take a look
at a very different program,
59:06 - but that reveals the same
kind of issue as follows.
59:10 - I'm going to go ahead and
open up an example called
59:13 - copy0, whose purpose in life
hopefully is to copy a string.
59:17 - So notice that in my
program here, which I
59:19 - wrote in advance, I'm getting a
string from the user on line 11,
59:23 - and I'm storing it in a string called s.
59:25 - I could change this to char*
now, but we know what it is.
59:28 - And I'm going to go ahead and copy
the string's address from s into t.
59:32 - And then I'm going to say, if the
length of t is greater than 0,
59:37 - then go ahead and just
capitalize the first character.
59:39 - So it's a little cryptic,
but you might have
59:40 - done something kind of like this
with Caesar and with recent string
59:43 - manipulation.
59:43 - This is just making sure, do
I have at least one character?
59:46 - And if so, first character is
t bracket 0, as you recall.
59:50 - toupper is a function in
ctype.h from last week
59:53 - that just capitalizes this letter.
59:54 - So this one line of code, 19,
just capitalizes the first letter
59:58 - in t, that's it.
59:59 - And then at the very end we just print
out what s is and print out what t is.
60:02 - That's all.
60:03 - So this program just copies s into
t, capitalizes t, and that's it.
60:07 - So let me go ahead and make copy0.
60:10 - This is in our code from today.
60:11 - So I'm going to do cd sc3, because I
already wrote it in that directory.
60:15 - make copy0.
60:16 - Went well. ./copy0.
60:20 - Let's go ahead and type
in tj again in lowercase.
60:25 - Enter.
60:26 - Huh.
60:27 - TJ, TJ-- both are capitalized.
60:29 - All right, maybe it's just
a weird thing with initials.
60:32 - So let's just do
Veronica, all lowercase.
60:36 - Huh, that's definitely capital.
60:38 - Let's do even more obvious
difference, Brian where
60:40 - the B's really going to look different.
60:43 - Yet I'm only capitalizing t.
60:46 - Well let's consider what's
actually going on here.
60:48 - In this case, when I'm getting a string
from the user, s and t, and I type in,
60:54 - for instance, brian in all lowercase,
backslash 0, this, of course,
60:59 - is just an array underneath the hood.
61:02 - This is taking up six bytes here.
61:04 - And when I store in s, s is a string.
61:06 - So you know what?
61:07 - We didn't do this before.
61:08 - Let me actually create a variable, a
chunk of memory for s and call it s.
61:13 - And suppose Brian is just
where he was before--
61:15 - 100, 101, 102, 103, 104, and 105.
61:21 - So if I do s equals get_string
and get_string returns Brian,
61:26 - what do I write in the box called s?
61:29 - Yeah, just 100, right?
61:30 - This is all that's been
going on all this time
61:32 - even though we didn't talk
about it at this level.
61:35 - And actually, it turns out-- pointer
actually can be used pictorially.
61:38 - If you actually prefer to think
about a pointer as being an address
61:42 - or like kind of a map that leads
you somewhere, another way a human
61:45 - would typically draw a
pointer-- because honestly,
61:48 - who really cares that
Brian is at address 100?
61:49 - Like that is way too low
level, that's week 0 stuff.
61:53 - He's just pointing there.
61:54 - So s is a pointer to
that chunk of memory.
61:57 - It happens to be 100, whatever, the
arrow is how you would literally
62:00 - point at the chunk of memory if you
were drawing this on some notes.
62:04 - So that, too, is correct.
62:05 - So the problem arises here
with that line of code.
62:08 - When I actually try to copy s and store
in t, think about what's going on.
62:15 - The right-hand side is just s's
value, which happens to be 100.
62:18 - The left-hand side is just
saying, hey computer, give me
62:21 - another variable, first
string, and call it t.
62:24 - So that's like saying, hey, computer,
give me another chunk of memory,
62:27 - call it t, and then store s in it.
62:30 - But what does it mean to store s?
62:32 - Well what is s's value
at this point in time?
62:35 - It's the pointer to Brian,
or it's technically--
62:38 - I'll write both just for thoroughness--
it's literally the number 100.
62:42 - So if you do t equals s, that is
like saying put 100 there too,
62:47 - and pictorially that's like saying this.
62:50 - So at this point in the
story, when I copy s into t,
62:54 - the computer took me literally.
62:56 - It did copy s into t, but what is s?
62:59 - It's just the address.
63:00 - It is not B-R-I-A-N backslash
0, it's just the address.
63:04 - So when I then say, t
bracket 0 gets toupper--
63:08 - so let's look at this line of code.
63:10 - The one line of code
here that's highlighted,
63:12 - when I say go to the 0th
character of t and store
63:15 - the uppercase version of that same
character, you just follow the arrows.
63:19 - If you ever played chutes
and ladders as a kid,
63:21 - you just kind of follow the
arrow, see where you end up.
63:24 - t bracket 0 is this location
here, because again,
63:27 - if this is a chunk of memory,
per last week it's an array,
63:30 - so you can also think of this as
being bracket 0, this is bracket 1,
63:34 - this is bracket 2, and so forth.
63:38 - So it's just an array.
63:39 - So t bracket 0 is lowercase
b, and toupper of lowercase b,
63:44 - of course, changes this
little b to a B. But now
63:48 - both s and t are still pointing
at the same chunk of memory,
63:51 - so of course s and t are both
going to be Bryan capitalized,
63:55 - or TJ too in my first example.
63:59 - Any questions then on what we
just did and why that happens?
64:05 - All right, so intuitively
what's the fix?
64:07 - Doesn't matter if you've
no idea how to code it,
64:09 - like what do we have to do to
fundamentally copy a string, not
64:12 - an address?
64:14 - AUDIENCE: [INAUDIBLE]
64:16 - DAVID MALAN: Create a new what?
64:18 - AUDIENCE: Basically
create the [INAUDIBLE]..
64:20 - DAVID MALAN: Yeah.
64:21 - Create the same string
in a new chunk of memory.
64:23 - What I really need to do
is allocate or give myself
64:25 - a bunch of more memory
that's just as big as Brian,
64:29 - including his backslash 0.
64:32 - And then logically I just need to
copy every character into that.
64:36 - So if I go back to my original
when it was a lowercase b,
64:39 - I need to make a copy logically by
using a for loop or a while loop
64:42 - or whatever you prefer--
64:43 - B-R-I-A-N backslash 0, so that when I
copy the string and then store it in t,
64:51 - It's not actually copying literally s.
64:53 - And let's suppose that he ends up
at location 300 just arbitrarily--
64:57 - just making up easy numbers.
64:59 - t now stores 300, points here.
65:02 - So when I execute this line in this
version of the story, t bracket 0
65:07 - gets toupper, what am I actually doing?
65:10 - I'm following a
different arrow this time
65:12 - because I gave myself a different chunk
of memory, capitalizing this Brian,
65:16 - thereby hopefully fixing the
bug, albeit verbally only.
65:21 - So how do we do this in code?
65:22 - We need to do exactly that.
65:24 - We need to give ourself
some more memory,
65:26 - so let's introduce one other
feature of C. In copy1.c,
65:31 - we see the solution to this problem.
65:33 - Notice at the top I'm doing things a
little lower level-- oop, surprise.
65:39 - Notice in this version
of the code, copy1.c,
65:41 - see I've started off almost the
same, but just to be super clear,
65:45 - I'm just using char*.
65:47 - I don't want any magic,
so there's no string,
65:49 - there's no training wheels here.
65:50 - But this logically is the
exact same as before--
65:53 - plus the error-checking.
65:54 - This line is new.
65:55 - And it looks a little funky,
but let's see what's going on.
65:59 - And this line of code
here, what am I doing?
66:02 - The left-hand side, that's shorter,
let's start with the easier one.
66:05 - Char* t, just in layman's terms,
what does that expression do? char*?
66:10 - Hey computer, do what?
66:14 - What's that?
66:15 - AUDIENCE: [INAUDIBLE]
66:16 - DAVID MALAN: Not quite yet.
66:17 - Different formulation.
66:22 - Hey computer, give me--
66:25 - not quite.
66:25 - Be more precise?
66:27 - AUDIENCE: An array?
66:29 - DAVID MALAN: Not quite
an array, just this part.
66:31 - So let me hide all this.
66:33 - If the star wasn't there--
66:35 - I can't really do this very well.
66:36 - So this-- yeah?
66:37 - AUDIENCE: [INAUDIBLE] character?
66:39 - DAVID MALAN: Good, I'll take that.
66:41 - So hey computer, give me
a pointer to a character.
66:43 - Or even more low level,
hey computer, give me
66:45 - a chunk of memory in which I can
store the address of a character.
66:49 - I mean, it is that mundane.
66:50 - Draw a box on the screen,
call it s-- or rather,
66:54 - call it t, but just give me
space for a pointer, as you said.
66:57 - So that's all that's doing.
66:58 - It's drawing a box on the screen and
calling it t, and it's currently empty.
67:02 - Now let's look at the scarier
part on the right-hand side.
67:04 - malloc, new function today.
67:06 - Stands for memory allocates.
67:08 - It's very cryptic-sounding, but it
just means give me a chunk of memory.
67:11 - It says exactly what you
said in functional terms.
67:13 - Then it just needs you
to answer one question--
67:16 - OK, how much memory do you want?
67:17 - How many bytes do you want?
67:19 - And now maybe the math, even though
cryptic at first glance, makes sense.
67:23 - Get the string length of s,
add 1, and then multiply it
67:27 - by the size of a character.
67:29 - And we've not seen this before.
sizeof literally does that.
67:31 - It tells you how many bytes is a char.
67:34 - Happens to be 1, and in
fact, that's defined.
67:36 - So if we simplify this in C,
the char is always 1 byte,
67:40 - so this is equivalent to
just multiplying by 1.
67:43 - And obviously mathematically
that's a waste of time,
67:45 - so we can whittle this
down to be even simpler.
67:47 - I was just being thorough.
67:49 - So now, hey computer, allocate
me this many bytes of memory.
67:53 - Why is it plus 1?
67:54 - AUDIENCE: You need the null character.
67:56 - DAVID MALAN: I need that null character.
67:58 - Brian is 1, 2, 3, 4, 5 as he said, but
I need the sixth for his null character,
68:02 - and I just know that's
going to be there.
68:04 - So at this point in the
story, what has happened?
68:07 - All that malloc does is it
gives me this box of memory
68:12 - containing room for as many
bytes are in Brian's name.
68:15 - But it doesn't fill them just yet.
68:17 - Now I need to logically fill those
bytes with Brian's actual name.
68:21 - So if we scroll down
to my for loop here,
68:23 - we can actually copy the
string into that space.
68:26 - And it's a little long, the
expression, but nothing new here.
68:29 - Initialize i to 0, n to the length
of s, i is less than or equal to n--
68:36 - we'll come back to that, i++.
68:38 - So it's just a pretty standard for loop.
68:40 - Then copy the i-th character of
s into the i-th character of t.
68:44 - The only thing that's making me a little
nervous honestly is this thing here.
68:48 - Like I feel like every time
we do less than or equal to,
68:51 - we create a bug like last week.
68:53 - But this is correct, why?
68:58 - Why do I want to go up to and
through the length of this?
69:02 - AUDIENCE: Is it the null
character that adds--
69:04 - DAVID MALAN: Exactly.
69:05 - Because of the null character.
69:06 - I actually don't want to stop at the
strlen of s, so I could change this.
69:10 - If you're just more comfortable
using less than, because you just
69:12 - got your mind wrapped around why we do
that in the first place, that's fine,
69:16 - we just need to do this instead.
69:19 - So this is mathematically-- if you
go to strlen plus 1, the same thing
69:24 - as not doing that math but
just going one step further.
69:26 - Just whatever you want to
think about it is fine.
69:28 - However you want to
think about it is fine.
69:30 - OK, and then lastly, just a
quick check, is the length
69:33 - of t at least one or more characters?
69:35 - Because otherwise there's
nothing to capitalize, and if so,
69:37 - go ahead and do it.
69:39 - So if I now run this example,
make-- oop, let me save it.
69:42 - make copy1, that compiled.
69:45 - ./copy1, now let's type in tj,
tj in lowercase comes back,
69:50 - but now t is capitalized.
69:52 - And let's go ahead and do Brian's name
in all lowercase, only one of them
69:57 - is now capitalized.
69:59 - So does that make sense
what's now happened?
70:02 - All right.
70:02 - So where can we go with this?
70:05 - Well it turns out-- let me
open up one final example here,
70:08 - because honestly, that's
incredibly tedious,
70:10 - and no one's ever going to
want to copy strings if you
70:12 - have to go through all of that work.
70:13 - Turns out that store copy exists.
70:17 - So when in doubt, check the man page.
70:19 - When in doubt, check CS50 reference.
70:20 - Does the function
exist somewhere related
70:23 - to some keywords you have in mind?
70:24 - Like string copy, see
if something comes back.
70:26 - And indeed, we've had strlen, we've
had strcmp, we now have strcpy,
70:30 - and if you read the documentation, this
is deliberately reversed like this.
70:33 - The destination is this variable,
the source or the origin string
70:38 - is this one, and it copies
from one end to the other,
70:40 - and then I don't need that for loop.
70:43 - It just saves me a few lines of code.
70:45 - All right.
70:46 - So let's take off one other detail here.
70:49 - Oh, and you'll notice, actually,
let me make one fix, one fix here.
70:54 - It turns out that what I'm
doing here is a little lazy.
70:58 - It turns out that malloc
does have an opposite.
71:02 - So anytime you allocate
memory, technically
71:05 - you should also be freeing that memory.
71:07 - And so C allows you to ask the computer
for as much memory as you want,
71:10 - but if you never give it back, have you
ever experienced on your own Mac or PC,
71:14 - like after your computer's
been running a while
71:16 - or using some new or bloated
program like a browser,
71:18 - it gets slower and slower and slower?
71:21 - And in the worse case it just
freezes or hangs or something?
71:24 - It is quite possible that that
program simply-- was made by humans,
71:27 - of course--
71:28 - just has a memory leak.
71:29 - So some human wrote one or more
lines of code that uses malloc
71:33 - or some equivalent in another language
that just kept allocating memory
71:36 - for the user's input.
71:37 - You're visiting one web
page, two web pages,
71:39 - that requires memory
whatever the program is.
71:41 - And if that human never calls the
opposite of allocate-- deallocate,
71:45 - otherwise known as free, you're
never giving the memory back
71:48 - to the operating system.
71:49 - So it gets slower and slower because
it's running lower and lower and lower
71:53 - on memory, and it might have
to move some things around
71:55 - to make room for things, that's
what's called a memory leak.
71:58 - And so indeed, in this program, I should
actually improve this a little bit.
72:02 - If I go back into this version
here and line 18, recall,
72:06 - I allocated this memory
just to make my copy,
72:09 - the very last thing I should
actually do in this program
72:12 - is this line here-- free.
72:13 - You don't have to tell the computer
how many bytes you want to free,
72:16 - it will remember for you so long as
you're just pass in the pointer--
72:20 - the variable that's storing the
address of the chunk of memory
72:24 - that you allocated.
72:26 - All right.
72:27 - So let's now see why we've
been using get_string,
72:31 - since it's not just to
kind of simplify the code,
72:33 - it's also to defend against
some very easy problems.
72:36 - Here is a program called scanf0--
72:39 - scanned formatted text, another
arcane-sounding function,
72:43 - but it's pretty straightforward.
72:44 - This program simply gets in
from the user using scanf.
72:47 - Up until now for the past three
weeks, you've used get_int.
72:50 - So this is an alternative
to get_int that you could
72:53 - have started using a few weeks ago.
72:56 - Give me an int called x,
print out x colon whatever--
72:59 - that's just the prompt to the user.
73:01 - scanf %i, &x;, whatever that is, and
then print out x's value using %i.
73:09 - So what's going on here?
73:10 - Now today we can actually start to wrap
our minds around what get_int actually
73:14 - does.
73:14 - This is effectively get_int.
73:15 - If you actually look at the source code
for get_int, it's a little fancier.
73:19 - But in essence, what get_int does
is it declares a variable called x,
73:22 - and it doesn't put anything
there, because that's
73:24 - supposed to come from you, the human.
73:25 - It then prompts you for whatever
string you pass to get_int,
73:28 - so those are the first two lines.
73:30 - And this is the only weird-looking one.
73:32 - Scanf is like the opposite of printf.
73:34 - You still use a formatted
string-- %s, %i, %f or whatever,
73:39 - but you're not going to output this,
you're going to input this from
73:43 - the human's keyboard.
73:45 - And %x is the opposite of--
73:49 - is the special symbol in C that says,
go ahead and get me the address of x.
73:57 - So don't pass in x, give
me the address of x.
74:00 - Now why is that?
74:01 - We'll see, but this is the way
where you can tell the computer,
74:04 - I've made a variable for you
called x, here is where it is.
74:07 - It's a treasure map that leads you
to x, go put a value here for me.
74:11 - And so the end result is that we
do, in fact, end up getting an int.
74:14 - If I do make scanf0, and then
./scanf0, I'll type in 42, all right?
74:21 - It's not an interesting program,
it just spits back out what I got,
74:24 - but that's literally all
that get_int, of course,
74:26 - is doing if you then
print out the value.
74:28 - So if I stipulate this is correct, this
is how you get an int from the user,
74:32 - but honestly, the reason we don't do
this in week 1 of the course is like,
74:35 - my God, we just took the fun out of even
getting a simple number from the user
74:39 - by using these lines of
code and whoever knows
74:41 - what this symbol is-- we don't
want you to think about that,
74:43 - we want you to just get an int.
74:44 - But today those training
wheels are off, but we're
74:47 - going to run into a problem super fast.
74:50 - Let's try the same thing with a string.
74:52 - If I were to do this, you would
think that the result is the same.
74:57 - Or let's just do it as char*.
75:00 - But there's going to be one tweak.
75:02 - If I go ahead and give myself space
for the address of a character,
75:07 - I don't need to use the
ampersand now, because scanf
75:09 - does need to be told where
the chunk of memory is,
75:12 - but it's already an address, so
I don't need the ampersand here.
75:16 - Recall earlier, I declared
int x, which was just an int.
75:19 - %x gets the address of that int.
75:22 - Here, I'm saying from the get-go,
get me the address of a char.
75:27 - I don't need the ampersand cause I
already have the address of a char
75:30 - by definition of that star symbol.
75:32 - So what's going on here?
75:34 - Let me see now.
75:35 - If I run scanf1, what happens?
75:38 - So make scanf1 and--
75:41 - oh, let's see.
75:42 - Here's a warning I'm getting.
75:43 - Variable s is uninitialized
when used here.
75:45 - All right, that's fine.
75:46 - It wants me to initialize it because
this is a very common mistake.
75:49 - Those of you who alluded
to segmentation faults
75:51 - earlier might have encountered
something similar in spirit to this.
75:54 - So that squelched that error.
75:55 - Let me go ahead and run scanf1.
75:57 - All right, here we go, TJ.
75:59 - Hmm.
76:00 - That is not your name, but OK.
76:02 - It didn't crash at least,
it's just a little weird.
76:05 - David.
76:06 - Null, OK, that's a little weird.
76:07 - Let's go ahead and do this again.
76:09 - Let's type in a really long name.
76:14 - Enter.
76:15 - Dammit, that didn't work.
76:17 - So let's try an even longer name.
76:24 - I'm hitting paste a lot.
76:27 - OK-- dammit.
76:29 - Too many times.
76:31 - Command not found, that's
definitely not a command.
76:34 - Wow, OK.
76:38 - Well that's interesting.
76:40 - Oh, there it is.
76:40 - Null, same thing.
76:41 - OK, so what's actually going on?
76:44 - Well null, which is all
lowercase here, which
76:46 - is this kind of an aesthetic
thing, well it's not working.
76:49 - It's not working.
76:50 - Well what am I actually doing?
76:52 - In that first line of code, when
I say give me s to be a char*,
76:57 - otherwise known as a string, all
that's doing is allocating this.
77:00 - And it's technically
the size of a pointer.
77:02 - A pointer, we never mentioned
this before, but now we can.
77:05 - Turns out it is 64 bits or 8 bytes.
77:10 - 8 bits is 1 bytes, so a pointer is
by definition on many computers these
77:15 - days-- most of your Macs, most of your
PCs, the IDE, the Sandbox, the Lab--
77:19 - is 64-bit.
77:20 - So that just means there's 64 bits
here, but we initialized it to null,
77:24 - so that just means there's
64 0's here, dot-dot-dot.
77:28 - But when I get a string
using scanf, what
77:32 - I'm telling the computer to do
with this line of code here,
77:34 - notice, is hey computer, go to that
address and put a string there.
77:39 - So what's actually happening?
77:42 - It turns out that there's just
not enough room to type in TJ.
77:45 - There's not enough room--
77:46 - that's a bit of a white lie,
because we could fit you in 64 bits,
77:49 - but there's not enough room to type in
the long sentence or paragraph of text
77:53 - I did, right?
77:54 - What did we not do?
77:55 - We didn't allocate any space over here.
77:57 - All we allocated space
for was the address.
77:59 - And so every time I use scanf saying,
get me a string and put it here,
78:03 - there's nowhere to put it.
78:05 - And so the value just very
defensively says, no, like no,
78:08 - cannot store this anywhere for you.
78:11 - So I actually need to be a
little smarter about this.
78:13 - I actually need to get myself some space
so that I can actually store something
78:18 - in the right place.
78:19 - Let's do that.
78:20 - Let me go ahead and
create a new program.
78:23 - I'm going to go ahead
and call this scanf2.
78:29 - We need a little secret
code to remind me of that.
78:33 - Oh, wrong file name.
78:35 - So I'm gone ahead and
create a file called scanf2.
78:38 - scanf2.c.
78:40 - And I'm going to quickly recreate
this stdio.h, int main void,
78:45 - and then down here I'm going to
go ahead and-- you know what?
78:47 - Instead of a string s, which
I know today to be a char* s,
78:52 - what is this string really?
78:53 - Well you said it earlier.
78:54 - What is this string?
78:56 - It's an array of characters.
78:57 - Let me take you literally.
78:59 - Just give me an array of
let's say five characters.
79:02 - The D-A-V-I-D, or one more, that's
fine, just enough for my backslash 0.
79:06 - Let me just create a
string-- really low level,
79:09 - but this time give myself
the chunk of memory.
79:11 - I don't want just the
address of a character,
79:13 - I want the actual characters themselves.
79:16 - Let me go ahead and just prompt
the human for their string with s,
79:19 - just like before.
79:20 - Then let me call scanf and get a string
from the user using %s and then pass
79:24 - in s.
79:25 - And here's a little trick.
79:26 - It turns out that because a
string is really just an array,
79:30 - but a string is also just a
pointer, you can actually treat
79:33 - an array as though it is a pointer--
79:36 - an address.
79:37 - And so even though this is
a char* array, this is OK.
79:41 - This is the equivalent in this context
to being just the address of a string.
79:45 - Because strings are arrays, arrays
can be treated as pointers as of now.
79:49 - And then let me go ahead and just
print out whatever the human typed in.
79:52 - S is actually this.
79:54 - Pass in s;, save.
79:57 - Yeah?
79:58 - AUDIENCE: So [INAUDIBLE] char*?
80:00 - DAVID MALAN: At this point it
would be redundant to do char*,
80:03 - because I literally want for
this story six characters.
80:06 - I want space, rather,
for six characters.
80:09 - So this is kind of week 2 stuff
now, there's no pointers involved.
80:13 - But again, just showing the
equivalence of these ideas for now.
80:16 - So if I now go into this, and this is
in my other directory at the moment,
80:20 - make scanf2, Enter, ./scanf2,
s is going to type in--
80:27 - I'll type in my name, I know I can
fit that, we're back in business.
80:30 - Like now it's working because I didn't
just create the address for a string,
80:34 - I created the space for the string.
80:35 - But let me get a little dangerous--
80:39 - David Malan?
80:40 - OK, that kind of worked out OK.
80:43 - David Malan or some
really long other name?
80:48 - OK, that worked out too.
80:50 - Let me go ahead and run it again.
80:52 - Let me try that really long
string again, see what happens.
80:56 - I know this didn't work
very well last time.
80:57 - All right, done.
80:59 - Ooh, OK.
81:01 - So now I'm in the club of those of
you who have had segmentation faults.
81:05 - So let's understand
what's going on here.
81:07 - Segmentation fault a
moment ago I claimed
81:09 - was touching a segment, a chunk
of memory that's not your own.
81:13 - So just happened?
81:14 - Well with this simple program, I
told the computer, hey computer,
81:17 - give me room for six
characters, give me six bytes.
81:21 - With the scanf line, I'm telling
the computer, put the following user
81:26 - input at that location, in
that array of characters.
81:30 - D-A-V-I-D backslash 0 fit.
81:32 - David Malan didn't really, but
it didn't seem to be a huge deal.
81:35 - David Malan or some really long other
name, also didn't crash the computer.
81:41 - But that's because unbeknownst to us,
usually when you ask for six bytes,
81:44 - the computer is kind of sort of--
it's giving you a few extras.
81:47 - It's not safe to use them,
but it gives you enough
81:49 - that you're not going to necessarily
see a problem like a segmentation fault.
81:52 - But it only allocates a
few extra bytes typically,
81:55 - so if you really keep pasting in
long, long, long, long lines of text,
81:59 - eventually you're going
exceed not only those six
82:01 - bytes, but well past the special--
82:03 - the secret bytes that you got back
that you shouldn't be using anyway,
82:06 - and that point the computer
just gives up and says,
82:08 - you are touching memory
you shouldn't, a.k.a.
82:11 - segmentation fault.
82:12 - AUDIENCE: [INAUDIBLE] if
the computer gives you
82:14 - a few extra bytes, then why isn't
it printing any of the other stuff?
82:18 - After you said [INAUDIBLE]
it just printed David.
82:22 - DAVID MALAN: Really good question.
82:23 - So even though I'm getting
these sort of extra bytes,
82:26 - why am I not seeing
them after D-A-V-I-D?
82:28 - I'm probably getting lucky.
82:29 - Long story short, when
you first run a program,
82:32 - much of the memory that your program
has access to is by default initialized
82:36 - to 0's.
82:37 - 0 is the same thing as backslash
0, and so I'm getting lucky.
82:41 - When I had D-A-V-I-D and then
excess space in that array,
82:45 - a lot of them are
initialized as 0's already,
82:47 - and the string is getting
secretly terminated for me.
82:51 - Or the better answer is,
it's undefined behavior.
82:54 - Like you should not touch
memory that is not your own.
82:57 - What happens after that
is your risk alone.
83:00 - But that's a conjecture as
to why that's happening.
83:03 - All right, so what is the
fundamental feature than get_int
83:06 - is providing for us?
83:07 - All of this time get_int
has actually been dealing
83:10 - with all of this headache for us.
83:12 - I mean honestly, even I'm getting
bored like thinking about, talking
83:15 - about how you just get a
damn string from the user,
83:17 - because you need to figure out,
well how many bytes do you need?
83:20 - And what if the human types in one
more bite than you were expecting?
83:23 - Then you need to do a
switcheroo and get more memory.
83:25 - get_string is doing all
of this headache for us.
83:28 - And that's not to say you
need to use it forever,
83:30 - there are indeed training
wheels, but that's
83:31 - just because when you're using C
or a lot of programming languages,
83:35 - the computer will only do
what you tell it to do.
83:37 - And it turns out that even
asking the user for input,
83:39 - if you don't know how many
characters he or she is
83:42 - going to type in from the
get-go, you have to deal with it.
83:45 - And so underneath the hood-- and you're
welcome to take a look at the source
83:48 - code for CS50's library, which I'll
post on the home page later today,
83:52 - it turns out that with the way we're
doing get_string is taking baby steps.
83:56 - We literally like get
one character at a time
83:58 - from the user, kind of
building the road as we go.
84:02 - And if we don't have enough
space, we ask the computer,
84:04 - give me some more bytes
so I can get more bytes,
84:06 - and we just get one
character at a time so
84:09 - that we can handle the user maliciously
or accidentally typing in way
84:12 - more input than we actually expect.
84:16 - So let's contextualize all of this then.
84:18 - Recall that we've been drawing these
pictures the past couple of weeks.
84:20 - Let's just make this super clear
as to what's been going on.
84:23 - This is a memory module in a computer.
84:25 - It's just a green board, it's
way blown out of scale here,
84:28 - it's easily like yea big inside of
your Mac or PC laptop or desktop,
84:32 - though can vary in size.
84:33 - One of these black chips is
the actual memory or the bytes
84:36 - to which we've been referring.
84:37 - And if we zoom in on that,
recall that I proposed last week
84:40 - that you can just think about
this as like a grid, an array.
84:43 - And it doesn't have to be rectangular,
this is just an artist's rendition,
84:46 - but each of those squares
represents, we claimed, a byte.
84:49 - And each of those bytes can be
addressed in some way with a number.
84:52 - And that number is just its location,
otherwise known as an address.
84:57 - We can actually see this,
it turns out, as follows.
85:00 - Let me go ahead and open
up this example here.
85:02 - Or actually, you know, let's
just write this one from scratch.
85:05 - Let me write a program
called addresses.c.
85:09 - And that's going to use our old friends,
the CS50 library and stdio.h and int
85:17 - main void.
85:19 - And let me go ahead and just do this.
85:21 - I'm going to go ahead and get a string--
85:23 - you know what?
85:23 - No more string. char* from the user,
get_string, ask the user for s.
85:29 - And we get another string, a.k.a.
85:31 - char*, get_string, call
it t from the user.
85:34 - And then, I want to print out not the
strings, which I used to do like this,
85:39 - printing out s.
85:40 - I want to print out the pointer that
s really is, that is the address.
85:45 - Turns out %p for pointer will print out
not the string at that memory location,
85:50 - it will print the actual
memory location for you of s.
85:53 - And I can do the same thing here,
%p, backslash 0, paste in t.
85:58 - And just so I know which is
which, let me just prefix it
86:00 - with some text-- s colon and t colon.
86:03 - Let me go ahead now down
here and do make addresses.
86:06 - Oh, I messed up, missed a semi-colon.
86:10 - Let me do this again.
86:11 - make addresses.
86:15 - And get rid of this.
86:17 - That compiled OK,
./addresses, and here we go.
86:22 - Let's type in-- let's do Brian
and Veronica like before.
86:26 - Enter.
86:26 - And this is a little funky, but
it turns out the IDE in your Macs
86:31 - and your PCs have a lot of memory.
86:33 - So this is the address.
86:34 - It's not quite as small as 100,
it's not quite as small as 900.
86:38 - It's actually kind of big.
86:39 - It's 2331010 with this weird 0x.
86:44 - Well it turns out, this is
just a human convention.
86:46 - In week 0 we talked about
decimal and all of us
86:48 - grew up with decimal,
10 digits from 0 to 9.
86:51 - Talked a little bit
about binary 0's and 1's.
86:54 - Turns out there's an infinite
number of base systems--
86:56 - decimal/dec, binary/bi are just two of
those infinite number of possibilities.
87:01 - Turns out there's another one that's
super common called hexadecimal.
87:05 - Hexa meaning 16 in this case.
87:07 - So base-16 actually has 16
letters in its alphabet.
87:11 - 0, 1, 2, 3, 4, 5, 6, 7,
8, 9, a, b, c, d, e, f.
87:19 - So it turns out that base systems that
need to count higher than 10 characters
87:24 - just start using letters of
the alphabet by convention.
87:26 - Humans just decided this.
87:27 - So we're getting just
numbers in this case,
87:30 - but if these addresses
were even bigger, we
87:32 - might actually see some alphabetical
letters between a and f there.
87:38 - And frankly I don't know
what address this is,
87:40 - but Google's usually
pretty good at this stuff,
87:42 - so let me actually open
up another browser window.
87:47 - So Google is your friend
when it comes to this stuff,
so let me actually open
up another browser window.
87:47 - So Google is your friend
when it comes to this stuff,
87:49 - or any number of calculators.
87:50 - 0x2331010 in decimal please.
87:55 - And Google has translated that.
87:56 - So Brian, I-- kind of
under a bit earlier.
87:59 - He is not at address
location 0, he's actually
88:02 - in the 36 millionth byte
inside of my computer
88:06 - right now, location 36,900,880.
88:10 - So a little higher address than 100.
88:13 - And then Veronica, if you really
want to get into the weeds here,
88:17 - we can say "in decimal," let
Google translate that for us.
88:20 - She's at location 36,900,944.
88:24 - Why?
88:24 - Who cares?
88:25 - The computer is managing all of this
for us, but when get_string used malloc,
88:30 - these are literally the numbers
that were being returned saying,
88:34 - you may use this chunk of memory.
88:36 - And why did humans use hexadecimal?
88:38 - Like it's just slightly more compact
to say 0x2331050, then 36900944--
88:47 - like you just save a few digits,
so it's just conventional.
88:49 - That's all, there's no magic there.
88:51 - But, recall earlier.
88:52 - Do you recall that when I had
the debugger open earlier,
88:55 - you saw next to my name variable
a value that was cryptically 0x0?
88:59 - Then there was another
value that I don't recall--
89:01 - 0x-something?
89:03 - That was just the numeric address
of my name in hexadecimal.
89:08 - And 0x0 is just the technical
address being used by null.
89:14 - Yeah?
89:14 - AUDIENCE: You said the address printed
out was [INAUDIBLE] x of the variable s
89:20 - and--
89:21 - DAVID MALAN: Sorry,
could you say that again?
89:21 - AUDIENCE: You said the address
printed out on the screen was an x,
89:25 - but x is [INAUDIBLE]
89:28 - DAVID MALAN: Ah, I should've clarified.
89:29 - 0x, humans years ago decided
anytime you see anything
89:33 - with 0x, that means whatever
comes next is hexadecimal.
89:37 - Just the convention.
89:38 - It's also common too if it starts with
a 0, it's an octal, which is base-8.
89:43 - If you see a lowercase b at
the end, it means binary.
89:45 - So humans have just
come up with symbology
89:47 - as to kind of communicate
this to readers, that's all.
89:49 - Not part of the value.
89:50 - So turns out that we can
actually do this math ourselves.
89:53 - And we won't really get
into the weeds of this
89:55 - because it's not a
particularly useful life
89:58 - skill, to be able to convert
to various base systems,
90:00 - but let's just do one example
so that we've seen it.
90:02 - Just to make clear that
there's no magic here,
90:04 - it's just a different way of thinking
about numbers versus grade school.
90:07 - So if back in the day we
had three decimal numbers--
90:09 - 255, 216, and then another
255, if we rewound to week 0,
90:14 - we could go through the math
of converting that to binary.
90:17 - And even if it might take you a little
while, this is the binary equivalent.
90:20 - And frankly, the first
and last are kind of easy.
90:23 - 255 is kind of a special value
because with 8 bits, all of which
90:27 - are 1, that's what gives you 255.
90:29 - So the only hard one is actually this.
90:31 - But who cares about the math today.
90:33 - We know from weeks ago that we
can do this if we really tried.
90:36 - But notice that bytes are eight bits,
and of course, eight is a pair of four,
90:43 - if you will.
90:44 - Well what's really nice about
hexadecimal is that it starts at 0
90:48 - and ends at f.
90:49 - And that's 0, 1, 2,
3, 4, 5, 6, 7, 8, 9--
90:54 - wait-- yes, that's 10.
90:55 - OK.
90:56 - And then a, b, c, d, e, f.
90:59 - I just held up 16 fingers in
total, hence, hexadecimal.
91:02 - What's nice about base-16 is that how
many bits do I need to count from 0 up
91:08 - to--
91:10 - one, two, three, four--
91:11 - 15?
91:13 - Just 4, right?
91:14 - So if I have all 0 bits, that's 0.
91:17 - And if I have 4 1-bits, that's--
91:21 - let's see.
91:21 - This is an 8 plus 4 plus
2 plus 1 gives me 15.
91:26 - So long story short, hexadecimal's
super convenient because 0 through f
91:30 - maps wonderfully cleanly to 4 bits.
91:33 - So it's just a nice way of thinking
about the world not in units of 8
91:36 - but in 4 instead.
91:37 - So all I did here was I
took my values and I just
91:39 - added a little bit of
whitespace to make clear
91:41 - that 8 bits is like a pair of 4 bits.
91:43 - It turns out now that 1 1 1 1 is f
for the reasons I enumerated earlier.
91:48 - All 1's is f, otherwise known as 15.
91:52 - All 1's is again f,
otherwise known as 15.
91:55 - If we did the math, 1 1 0 1 is d, 1 0
0 0 is 8, and then all 1's is f and f.
92:03 - So long story short, there is
a way to convert from decimal
92:06 - to binary, to hexadecimal, to
any number of other base systems.
92:09 - It all just boils down to
what digits you care about.
92:11 - And the way you write this,
to your question earlier,
92:13 - is by human convention.
92:14 - Not just FFDAFF, but
0xFF0xD80xFF just because.
92:20 - Then it's clear to the user what it is.
92:22 - So a little levity now.
92:24 - I'm sorry to do this to you,
but now you will all hopefully
92:27 - understand this famous comic.
92:34 - OK, welcome to that club of people
who understand things like this.
92:37 - So let's now stumble upon
just one last problem,
92:42 - and we'll take it home by
putting into the context
92:44 - a very sexy field of forensics
where all of these building blocks
92:49 - will come into play.
92:50 - But first let's start with a problem.
92:51 - Suppose I want to implement a function
here called swap whose purpose in life
92:55 - is just to swap two values, a and b.
92:57 - I just want to do a switcheroo.
92:58 - Let's first do this with a sort
of mid-lecture snack for at least
93:02 - one person.
93:03 - Would anyone be up for--
93:04 - OK, that was fast.
93:05 - Volunteering, come on up.
93:08 - What's your name?
93:09 - Kelly, all right.
93:10 - Thank you for volunteering so suddenly.
93:15 - Kelly, David, nice to meet you.
93:17 - OK, so very simple task at hand.
93:19 - I have here two empty cups,
and we have some orange juice.
93:27 - OK, put this in here.
93:30 - And we've got some milk over here.
93:34 - That should stand out,
very different colors.
93:37 - OK, I would just like you, Kelly,
if you could, swap those two values.
93:42 - Orange goes into milk, milk
goes into orange please.
93:50 - That is cheating, OK?
93:52 - No, I mean literally the cups.
93:53 - I put them in the wrong
cup, I prefer my milk
93:55 - in the other cup and my orange
juice in the other cup, I'm sorry.
94:01 - AUDIENCE: Pour it back in.
94:02 - DAVID MALAN: No, that is
not available to you, OK?
94:04 - [LAUGHTER]
94:05 - OK, so you're struggling.
94:07 - Why are you struggling?
94:08 - KELLY: Because I'm going to mix them.
94:09 - And then it won't be the same.
94:11 - DAVID MALAN: Right.
94:11 - So I mean obviously, this is
kind of a losing proposition.
94:14 - You can't really do this.
94:15 - What would make this easier for
you besides putting them back
94:17 - in the bottles?
94:18 - KELLY: Having another container.
94:18 - DAVID MALAN: Yeah.
94:19 - So you need like a temporary
storage space for this.
94:22 - You know, let me--
94:23 - Tara, can we get some
more cups over here?
94:26 - Ah, this will make it easier.
94:28 - OK, so if I get you
some temporary space--
94:30 - here you go-- could you
solve the problem now please?
94:36 - Ah, very nice.
94:38 - A little contamination, but that's OK.
94:43 - But I need that temporary
cup back for Tara.
94:45 - Yeah, OK.
94:46 - Thank you.
94:47 - All right, a round of applause
if we could for Kelly here.
94:50 - [APPLAUSE]
94:52 - Well here we go.
94:52 - I'm guessing you don't want
warm milk, but orange juice?
94:55 - OK.
94:55 - Thank you so much.
94:56 - All right, so what's the point here?
94:58 - This is pretty easy.
94:59 - Like once you have
some temporary storage
95:01 - space-- a variable, if you will, like
it's no problem to swap two values.
95:05 - So let me go ahead and
do that as follows.
95:08 - I'm going to go ahead and just
implement this swap function
95:10 - and see exactly as Kelly
ultimately just implemented it.
95:13 - If the goal is to swap a and b, I
can't just do a complete switcheroo,
95:17 - it seems.
95:18 - I need to put one of those values,
like the milk, in another container,
95:21 - and then swap and then swap.
95:23 - So it takes three steps, not just one.
95:25 - All right, so I could call
this extra variable or cup
95:27 - that Tara gave us
anything we want-- tmp.
95:30 - So I'm just going to put a in tmp.
95:33 - Then I'm going to put b in
a, because a is now empty.
95:36 - Then I'm going to put tmp in
b, and then I don't really
95:39 - care what happens to tmp-- indeed,
it's just still sitting there,
95:41 - but the job is now done.
95:43 - So let's go ahead and see this program
in action, because obviously this
95:47 - should be pretty straightforward.
95:49 - So let me go ahead and
open up this program
95:52 - in the context of a main function
so we can actually run it.
95:55 - In this code here, I'm going
to demonstrate it as follows.
95:59 - Here's my main function.
96:00 - I'm going to call variable x,
give it 1, call variable y,
96:03 - give it 2, go ahead and just print
out just for a quick sanity check--
96:06 - x is this, y is that.
96:08 - Then I'm going to call this
super simple swap function, x, y.
96:12 - Then I'm going to print the exact
same thing-- x is this, y is that,
96:16 - just so I can see in those variables--
96:17 - I could also use debug50, but this
is meant to be a complete solution,
96:20 - I want to see it on the screen.
96:21 - Here is swap.
96:22 - I copy-pasted that from before.
96:24 - This feels like a no-brainer,
super straightforward,
96:26 - let's go into my directory and compile
this program, which, slight spoiler,
96:31 - noswap is the name.
96:34 - ./noswap.
96:37 - Oof.
96:40 - Let's zoom in.
96:41 - Nope, that is not what
I intended, right?
96:43 - I really intended milk to
become OJ, OJ to become milk,
96:46 - or x become y, y become x,
this doesn't seem to work.
96:49 - And again, the only magic
is this one call to swap.
96:52 - All right, maybe it just
works some of the time.
96:54 - So nope, nope-- OK.
96:57 - Now it's time for the debugger.
96:58 - I don't understand what's
going on in my program,
97:00 - printf is not really illuminating here.
97:02 - So let me go ahead and
run debug50 ./noswap.
97:06 - The little debugging panels
get opened on the side,
97:08 - but wait, I need a breakpoint.
97:10 - I'm going to start a breakpoint at the
very top, the first line I care about.
97:13 - I don't really care about all
the stuff at the super top.
97:16 - Now I'm going to go ahead and
rerun debug50 ./noswap, all right?
97:20 - Now I see over here, the
first line 9 is highlighted.
97:23 - Notice on the right-hand
side, and this perhaps
97:25 - answers by example
your question earlier.
97:27 - x and y conveniently, but just
because we're initialized to 0--
97:31 - not by me, I shouldn't necessarily
trust this in all contexts,
97:34 - but that's why they had values.
97:36 - They're otherwise known as garbage
values, but I got lucky with 0's here.
97:39 - Let me go ahead and step over that
line, and if you watch, albeit small,
97:42 - on the right-hand side, x should
suddenly take on a value of 1.
97:47 - And if I step over one more line,
y should take on a value of 2.
97:51 - OK, so I'm pretty confident the
program is thus far correct.
97:53 - I'm going to go ahead
and step over printf.
97:56 - And notice the blue terminal
window, I see one output.
97:59 - Now things get interesting.
98:01 - If I continue stepping over lines,
it's just going to finish running
98:04 - and that's not enough.
98:06 - So notice this time I'm going to
hover over this third icon, Step Into.
98:09 - Now I can kind of go
down the rabbit hole,
98:11 - so to speak, and go into the
swap function, and notice,
98:15 - the debugger jumps into
that other function.
98:17 - So here now, the context changed.
98:19 - My local variables are now a, b,
and tmp, and this is really weird.
98:23 - A is 1, b is 2, as expected,
because I passed an x, y.
98:29 - And in the context of this function
I'm just calling them a, b because.
98:33 - But why is tmp 32,767?
98:37 - It's just because it can't be
trusted, it's a garbage value.
98:39 - If you just give yourself a temporary
value, who knows what's in there?
98:43 - We got lucky and Tara did not
have anything in this cup,
98:46 - but it could have had a garbage
value, maybe it had some Pepsi,
98:49 - and then we would have had to
replace that value somehow.
98:52 - So to be clear, when you
declare variables in a program,
98:55 - quite often they have garbage
values, just bogus values--
98:58 - the 0's and 1's that are there
underneath the hood in that chip,
99:01 - but that you didn't set yourself.
99:03 - But that's OK, because I'm explicitly in
this next line setting tmp equal to a.
99:07 - So it doesn't matter what its original
weird value was, so if I click Next,
99:12 - tmp is now 1, a.k.a.
99:14 - a.
99:15 - Now notice a is going to become b
if you watch the right-hand side.
99:19 - Now I seem to have a is 2, b is 2, which
is a little worrisome but not as bad,
99:23 - because I have that separate variable
tmp, so I still have the one around.
99:26 - So now b is about to become 1,
and I've done the switcheroo.
99:30 - OK, at this point in the story,
line 22, my code seems correct.
99:35 - b has become a, a has become
b, and the values are swapped--
99:38 - and the debugger is confirming
that for me visually.
99:42 - So now, let's do a step and--
99:47 - dammit.
99:50 - Lost.
99:52 - What is going on?
99:53 - Intuitively?
99:54 - Even if you've never seen or done this
before, like clearly there's a bug.
100:01 - What is that bug?
100:03 - What must be happening?
100:04 - Yeah?
100:05 - AUDIENCE: [INAUDIBLE]
a new value [INAUDIBLE]
100:09 - doesn't have the same
address for the first one?
100:11 - DAVID MALAN: Yeah.
100:12 - What seems to be happening here
is yes, you're passing in x and y
100:15 - and calling it a and b, but a and b
would seem to be copies of x and y.
100:20 - And I am very successfully,
very correctly swapping a and b,
100:24 - but because they're copies, it has
no effect on the original x and y.
100:28 - So our metaphor here of
juice isn't quite apt
100:30 - because I didn't pass Kelly
copies of the OJ and milk,
100:35 - I handed her the actual OJ and milk
and she was able to change the values.
100:39 - But in the context of C and code,
when you pass arguments to a function,
100:43 - you're passing copies of those
arguments to the function.
100:46 - So intuitively, what is the solution?
100:48 - We clearly cannot pass from one function
to another copies of the values if we
100:52 - expect the function swap, or a.k.a.
100:55 - Kelly, to make some
useful change for us.
100:58 - What do we have to pass to the
function or to Kelly instead?
101:03 - The addresses of those values, right?
101:05 - I told her where the milk and OJ were.
101:07 - I didn't give her copies of them,
I told her, here's the milk,
101:10 - here's the OJ, swap those.
101:12 - In this version of the
code, I've just said,
101:14 - here's a copy of x, here's a copy of
y, you can call them a and b-- um-mmm.
101:18 - We need to now use the ampersand or
something like that to pass in a map,
101:22 - if you will.
101:23 - The treasure map to those values so that
swap can change the original values.
101:28 - And the way we do this is
a little weird-looking,
101:30 - but all we're going to have to
do is make a little addition here
101:35 - that looks as follows.
101:37 - It's got to look like this instead.
101:41 - So this is the broken version.
101:43 - Or broken in that it doesn't have the
effect we intend even though it works.
101:47 - This is what we need to do
instead, and it's the last piece
101:49 - of new symbology for today.
101:51 - We've seen star in a
couple of different places
101:52 - before, now we're using
it in one final context.
101:55 - When you specify a star here and here
in the arguments to a function, that
102:01 - is just the way you
tell the computer, I'm
102:03 - expecting not an int, but
the address of an int.
102:05 - I'm expecting not an int here,
but the address of an int.
102:08 - So two pointers, two
addresses of integers.
102:11 - Down here, tmp is still just an int.
102:13 - I don't need to over think
tmp, that's just an empty cup.
102:16 - Give me an integer
called tmp from week 1.
102:19 - But, what do I want to store in tmp?
102:22 - Both a and b in this
version are addresses.
102:25 - Do I want to remember the
address a and the address b?
102:30 - No, I want to remember the
volume of OJ, the volume of milk,
102:33 - I want to remember 1 and 2, I don't
care where in memory they are.
102:37 - So star in this context, when
there's no mention of a data type,
102:42 - there's just a star and a variable name.
102:45 - That variable is a pointer
and it's not multiplication,
102:47 - there's no math going on.
102:48 - That star is the dereference operator
that says, go to this address
102:54 - and get the value there.
102:56 - So if this address a is at location,
I don't know, 100 like Brian was,
103:00 - and this address b is at
location 900 like Veronica was,
103:03 - *a means go to the 100th byte in memory
and get me that value, which is 1.
103:09 - This means, down here, go to the address
b, get me that value at address 900,
103:14 - which is 2.
103:15 - And go ahead and store 1 in tmp.
103:18 - Go ahead and go to that
address and put whatever's
103:21 - at b's address-- so get that address
and put it over-- get that address,
103:25 - get the value, and put it over
at that address by dereferencing.
103:28 - And then lastly, go to b in memory, like
over there, put the tmp value there.
103:34 - So whereas ampersand in
our previous example means,
103:36 - tell me what the address is of a
variable, star is the opposite.
103:40 - When you have an address,
it says, go to that address.
103:43 - Follow the treasure map, X marks
the spot at that location in memory,
103:47 - and get at its value.
103:48 - So what is the net effect here?
103:50 - If I actually now open up not
this example, but swap.c--
103:54 - spoiler, this one is
going to actually work.
103:58 - If I open up swap.c, we're going
to see now the following instead.
104:03 - The code is almost the same,
except that I pasted it
104:06 - in this new green
version of the function.
104:09 - And notice here, this had a change.
104:11 - Why am I typing in %x now and
%y instead of just x and y?
104:19 - AUDIENCE: [INAUDIBLE] address
[INAUDIBLE] functions [INAUDIBLE]..
104:25 - DAVID MALAN: Exactly.
104:26 - The swap function now,
the new improved version
104:28 - is expected two addresses-- stars.
104:30 - Each star, a.k.a.
pointers, not just values.
104:33 - So this means I know x and y are
actually integers from week 1.
104:37 - Now I need the address
of x and the address of y
104:40 - so that swap can follow
those treasure maps,
104:43 - so to speak, and go to those addresses.
104:45 - So now, when I run this program, this
is more like the metaphor with Kelly
104:50 - where I told her where
the milk and OJ were.
104:52 - Now swap and go to those
locations as follows. make swap.
104:56 - Let me go ahead and
then do ./swap, Enter--
104:59 - ah!
105:00 - Now it seems to be working.
105:02 - And we can see as much
even with the debugger.
105:04 - Even though it doesn't seem to
be buggy, I can still use debug50
105:07 - to see and understand my
program, if not obvious-- oh,
105:11 - I still need a breakpoint.
105:12 - Let's set a breakpoint as before.
105:13 - Let's rerun debug50.
105:15 - The right-hand panel will
open automatically for me.
105:19 - And let's go ahead and see,
if I start stepping over this,
105:22 - now I see that x is 1, y is 2,
printf prints as much on the screen.
105:31 - Now I'm going to go
ahead and step into swap,
105:33 - and now notice, it's a
little weird-looking,
105:36 - because now a is an address
and b is an address,
105:40 - but tmp is still an int with a
garbage value, but I can fix that.
105:44 - Now tmp is 1, but notice, a and
b's values are not changing,
105:49 - but what is clearly
changing per the code?
105:54 - So notice, this is weird and cryptic.
105:56 - a is this 0x value.
105:58 - That's a big hexadecimal address,
like that is where in memory a is.
106:02 - But you know what?
106:03 - If I click the little triangle,
I can kind of follow that pointer
106:06 - and go to it.
106:07 - The debugger is smart like that.
106:09 - So *a, go to a is 2; and *b at the
moment is 2, but if I keep going,
106:14 - now I've done a switcheroo, and you
can see that these values have changed.
106:19 - And again, we don't care
what these addresses are,
106:21 - I don't care what the
actual addresses are.
106:23 - I do care that it gives me this
functionality, because now when
106:25 - I return up here in print,
now the values have indeed
106:28 - changed as I expected this whole time.
106:31 - All right.
106:32 - That was complex, but hopefully clear
as to why it now works even though we've
106:38 - made this code look more cryptic.
106:41 - If not, any questions are welcome.
106:43 - Yeah?
106:43 - AUDIENCE: Is that from
the spot where [INAUDIBLE]
106:47 - DAVID MALAN: Uh huh.
106:48 - AUDIENCE: [INAUDIBLE] the
star [INAUDIBLE] pointers?
106:52 - DAVID MALAN: Good question.
106:54 - Do we really need to have these
ampersands here because we already
106:57 - have the stars here?
106:58 - Short answer, yes, for symmetry.
107:00 - This is telling the function
what to expect on the way in;
107:03 - this is what's telling the
computer actually what to send in.
107:08 - So what are the actual
inputs to that function?
107:11 - It has to be symmetric.
107:13 - Yeah?
107:13 - AUDIENCE: [INAUDIBLE] value
is swapping addresses.
107:19 - DAVID MALAN: We are swapping
what is at the addresses.
107:24 - AUDIENCE: So what if you change
the address of [INAUDIBLE]
107:32 - DAVID MALAN: OK.
107:33 - AUDIENCE: And would we swap the
addresses saying 2 is at 200 and 1
107:37 - is at [INAUDIBLE] that could change.
107:39 - DAVID MALAN: Short answer, you
cannot for the following reason.
107:43 - So technically, when you do %x and
%y, these are converted to the address
107:49 - of x, the address of y.
107:50 - Technically swap is getting copies
of something, C has not changed.
107:54 - But C is now getting
copies of the address
107:57 - of x, copies of the address
of y, calling them a and b.
108:01 - So sure, you could swap the addresses,
but for the same reasons as before,
108:05 - it's going to have no
fundamental effect.
108:06 - The difference here is because
I'm passing in a map, so to speak,
108:09 - to x and y, their addresses.
108:11 - And again, an address is like--
108:12 - we are at 45 Quincy
Street I think right now--
108:16 - Cambridge, Massachusetts 02138, USA.
108:18 - That uniquely identifies the building.
108:20 - These 0x hexadecimal numbers uniquely
identify locations in memory.
108:23 - So this is like saying now, get me the
address of x, get me the address of y,
108:27 - and I'm technically passing in copies of
those addresses, but it doesn't matter,
108:30 - because now with the star notation,
I'm saying go to those addresses
108:33 - and swap who is physically in
this building and some other.
108:38 - All right.
108:39 - So let's just put this now
into the context of what else
108:42 - your computer actually
has just that you've
108:44 - seen some nomenclature around
this computer's memory.
108:47 - So this is the chip with a
grid laid out on top of it
108:49 - just to communicate that there's
bytes here, and we could number them.
108:52 - But let's think about
this now more abstractly,
108:55 - and let me just reveal that it
turns out that the computer treats
108:57 - different bytes, different squares
in different ways just by convention.
109:01 - It turns out that in
your computer's memory--
109:04 - and this is all just an
artist's representation--
109:06 - at the top of that chip
of memory, so to speak,
109:09 - is the so-called text of your program.
109:11 - This is a fancy and
non-obvious way of saying
109:13 - the 0's and 1's that your code
have has been compiled into.
109:17 - The text of a program is the
code you wrote in binary,
109:20 - that's where it's loaded from memory.
109:22 - So in macOS and Windows,
you double-click an icon,
109:24 - that program is loaded into
memory I said last week.
109:26 - It's literally loaded into the top of
your computer's memory conceptually.
109:30 - What else?
109:31 - Well the heap is the fancy name given
to the chunk of memory in which memory
109:37 - is coming from when you call malloc.
109:39 - So when I called malloc earlier to get
a bunch of space for some characters,
109:42 - it was just coming from this
big open area called the heap.
109:45 - And that's what get_string is
using and other functions as well.
109:49 - Well it turns out that the reason
for the problem we just ran into
109:52 - is because the bottom part of
memory is what's called the stack.
109:56 - The stack is the area of memory that
functions use when they are called.
110:00 - And this is actually relevant to that
very simple noswap example as follows.
110:05 - If we now assume that anytime you
call a function, the memory it uses
110:09 - comes from the bottom of
that big block of memory,
110:12 - where you can draw that, for
instance, here on the screen,
110:15 - because it turns out that anytime you
call a function, that function gets
110:18 - a slice of its own memory.
110:20 - So for instance, main is always
the first program a function calls,
110:23 - and so it gets the first slice of
memory at the bottom of the screen here.
110:28 - And so if main had two variables
x and y, that's like saying,
110:33 - OK, give me a chunk of memory
called x and put the value 1 in it;
110:37 - give me another chunk of memory,
call it y, put a value in it here.
110:41 - But remember, from the first noswap
example, the swap function was called.
110:46 - This is a stack in the literal sense.
110:48 - You go into a dining hall, a cafeteria,
one tray for food, goes on another,
110:52 - goes on another, goes on another
so that the humans can take it
110:54 - and put food and plates on it.
110:56 - Well similarly in this model,
when you call a function,
110:59 - it gets its own slice of memory,
but literally above, conceptually,
111:03 - the existing frame on the stack.
111:06 - So this is the swap function's
own chunk of memory,
111:09 - and it, too, gets some space.
111:11 - It gets some space for
a variable called a.
111:14 - It gets some space for
a variable called b.
111:16 - And guess what goes inside
those of that first example?
111:19 - A copy of x and a copy of y.
111:23 - And you know what?
111:23 - It had a temp variable, so that's
got to have some space here.
111:27 - So I'll call this tmp.
111:28 - And recall that I set tmp
equal to a, so that got 1.
111:32 - And then what happened?
111:33 - Well then I did what--
111:35 - what did I?
111:38 - Let me get this right.
111:41 - We had a gets b.
111:44 - So what happened there?
111:46 - So in this example here, a gets
the value b, so that changed.
111:51 - And then what happens here, b got
the value of 10, so that changed.
111:54 - So swap was working in the sense
that it was swapping values,
111:57 - but the problem is, when a function
returns, this chunk of memory that it
112:01 - was previously using gets reclaimed
so that someone else can now use it,
112:06 - another function.
112:07 - So we did all that hard work and
no swap, and we did it correctly,
112:11 - we just did it in the wrong place.
112:13 - So by contrast, this next example
that we did, which was swap.c,
112:19 - just treated the memory
a little bit differently.
112:21 - Main this time still had two
variables called x, and this was a 1,
112:26 - and then another one
called y, and this was a 2.
112:29 - And then one swap was
called this time, it again
112:31 - had a variable called
a and a variable called
112:34 - b, but what was stored in a and b?
112:37 - Well now they're addresses.
112:38 - And I don't know what it is, but let
me just arbitrarily say that this
112:42 - is location 100, this is location--
112:45 - let's say 104.
112:47 - But it could be anything, we
just don't care at this point,
112:49 - it would have 0x technically if
the computer were showing us.
112:52 - What's going in a here is 100,
what's going in b here is 104.
112:57 - And those are the addresses
of x and y, and the code
113:02 - we had using all of those
new stars was saying,
113:04 - go to address 100 and store
whatever is at address 100 in tmp.
113:12 - Then go to the address
that's in b, or 104,
113:15 - and store that at the location
int *a, whatever is there.
113:20 - Then it was saying, go get
that 10th value, by the way,
113:23 - and go ahead and put that
here, so that now we did
113:28 - different work in a different place.
113:31 - So now when swap is
done running, it doesn't
113:33 - matter if its memory disappears
because it has now mutated or changed
113:39 - the other memory.
113:40 - That it was passed in just like
Kelly changed or mutated the cups
113:43 - I actually pointed her at
rather than copies thereof.
113:47 - Now as an aside, there's other chunks
of memory that are actually used.
113:51 - If you have global
variables in a program,
113:53 - turns out that in between
the text and the heap
113:56 - memory are your global variables,
if they're initialized with values
113:59 - or they're not initialized with values,
as would happen with the equal sign,
114:02 - but we don't care too much
about that for today's purposes.
114:04 - And if you've ever heard of
environment variables, which
114:06 - we will when we get to web
programming, they, too,
114:09 - are stored elsewhere in memory.
114:10 - But the most interesting
chunks of memory
114:12 - are stack and heap,
as in this case here.
114:15 - But unfortunately it's so
easy for things to go awry--
114:18 - I mean, some of you experienced
segmentation faults already,
114:21 - and let's consider
why that might happen.
114:23 - So here's a contrived example
of code that is by design buggy,
114:26 - but let's just talk it through in
English what these lines are doing.
114:29 - This line here, int *x,
is saying, hey, computer,
114:33 - give me a variable that will
store the address of an integer.
114:39 - So give me a pointer to an int is
the more casual way of saying it.
114:42 - Hey computer, give me
another variable that's
114:45 - going to store the address
of an int and call it y.
114:48 - So x and y, that's it.
114:50 - This line is new-ish.
114:52 - Hey computer, allocate enough
space that will fit an int.
114:56 - So sizeof int is the new syntax we
saw earlier for just figuring out
114:59 - how many bytes is an int.
115:00 - Odds are this is going to come back
as 4 or 32 bits in most computers.
115:04 - So this just says, hey browser,
give me 4 bytes of memory
115:07 - and store that in this location.
115:10 - Or rather, store that in this
variable, store that this variable.
115:14 - So maybe it's going to say, OK,
here's four bytes at location 100,
115:17 - or here's four bytes at location 900.
115:19 - Or wherever, we don't care, we're
just remembering that address in x.
115:23 - *x says, go to that address--
115:26 - 100 or 900, whatever it is,
put the number 42 there.
115:30 - This next line says, go to the address
in y and put the unlucky number-- hint,
115:34 - hint--
115:35 - 13 there.
115:38 - Well what is the address in y?
115:43 - I haven't allocated it yet.
115:44 - What's the address in x?
115:46 - It's wherever malloc
told me to use space.
115:49 - That's safe, that was like 100,
900, whatever the value was,
115:52 - but did I allocate space for y?
115:54 - So what kind of value does
it contain, so to speak?
115:57 - A garbage value.
115:58 - Maybe it's 0, maybe it's
like 32,000-- we don't know,
116:01 - because if you don't
specify the value, it
116:03 - is not safe to trust it
or do anything with it.
116:07 - This is going to give me probably
one of those segmentation faults.
116:10 - And indeed, if I run
a program like this,
116:12 - I'm quite likely going to see
exactly that kind of problem.
116:16 - It's perhaps better, though,
to see this in a way that
116:18 - will paint a more memorable picture,
and for that, thought we'd take--
116:22 - in our 10 minutes remaining,
use a few of these minutes
116:24 - to take a look at something
our friends at Stanford
116:26 - put together with a bit of claymation.
116:28 - It's about three minutes
long, well worth it
116:30 - to paint a picture of
exactly what goes wrong
116:32 - when you don't use memory correctly.
116:35 - If you could dim the lights.
116:37 - [VIDEO PLAYBACK]
116:37 - [MUSIC PLAYING]
116:40 - - Hey, Binky.
116:41 - Wake up!
116:42 - It's time for pointer fun!
116:44 - - What's that?
116:45 - Learn about pointers?
116:47 - Oh goody!
116:49 - - Well to get started, I guess we're
going to need a couple of pointers.
116:52 - - OK.
116:53 - This code allocates two pointers
which can point to integers.
116:56 - - OK.
116:57 - Well I see the two pointers, but they
don't seem to be pointing to anything.
117:00 - - That's right.
117:01 - Initially pointers
don't point to anything.
117:03 - The things they point
to are called pointees,
117:06 - and setting them up to a separate step.
117:08 - - Oh right, right.
117:08 - I knew that.
117:09 - The pointees are separate.
117:11 - So how do you allocate a pointee?
117:13 - - OK.
117:14 - Well this code allocates
a new integer pointee,
117:17 - and this part sets x to point to it.
117:20 - - Hey, that looks better.
117:22 - So make it do something.
117:23 - - OK.
117:24 - How do you reference the pointer x to
store the number 42 into its pointee?
117:29 - For this trick, I'll need my
magic wand of dereferencing.
117:32 - - Your magic wand of dereferencing?
117:35 - That-- that's great.
117:38 - - This is what the code looks like.
117:39 - I'll just set up the number and--
117:41 - [POP]
117:42 - - Hey look!
117:43 - There it goes.
117:44 - So doing a dereference on x follows
the arrow to access its pointee.
117:49 - In this case, to store 42 in there.
117:51 - Hey, try using it to store the number
13 through the other pointer, y.
117:56 - - OK.
117:57 - I'll just go over here to y
and get the number 13 set up,
118:02 - and then take the wand of
dereferencing and just--
118:06 - [BUZZING] whoa!
118:07 - - Oh hey, that didn't work.
118:09 - Say, Binky, I don't think
dereferencing y is a good idea,
118:13 - cause setting up the
pointee is a separate step
118:16 - and I don't think we ever did it.
118:18 - - Mmm, good point.
118:20 - - Yeah.
118:20 - We allocated the pointer y, but we
never set it to point to a pointee.
118:25 - - Mmm, very observant.
118:27 - - Hey, you're looking good there, Binky.
118:29 - Can you fix it so that y points
to the same pointee as x?
118:32 - - Sure.
118:32 - I'll use my magic wand
of pointer assignment.
118:35 - - Is that going to be
a problem like before?
118:37 - - No, this doesn't touch the pointees.
118:39 - It just changes one pointer to
point to the same thing as another.
118:43 - - Oh, I see.
118:44 - Now y points to the same place as x.
118:46 - So wait, now y is fixed.
118:48 - It has a pointee.
118:49 - So you can try the wand of
dereferencing again to send the 13 over.
118:54 - - OK.
118:55 - Here goes.
118:56 - - Hey, look at that.
118:58 - Now dereferencing works on y.
118:59 - And because the pointers are sharing
that one pointee, they both see the 13.
119:03 - - Yeah, sharing, whatever.
119:05 - So we going to switch places now?
119:07 - - Oh look, we're out of time.
119:09 - - But--
119:10 - [END PLAYBACK]
119:10 - DAVID MALAN: All right.
119:11 - So hopefully that puts a little more
visual behind some of these ideas,
119:15 - but let's now contextualize
this in a domain that's perhaps
119:20 - more familiar in a couple of ways.
119:21 - So one, some of you might
already know, especially
119:24 - if you've had prior programming
experience, of a very popular website
119:26 - called Stack Overflow
where lots of programmers
119:28 - post questions and hopefully answers
to common technical problems.
119:32 - If you ever wondered why
it's called Stack Overflow,
119:34 - it turns out it reduces
to this picture here.
119:37 - This was not a mistake that I drew
one arrow from the heap pointing down,
119:41 - and one arrow from the stack growing up.
119:42 - As you malloc, malloc,
malloc more and more space,
119:46 - starts up here, so to speak, and
you just get more and more space
119:49 - that's going this direction.
119:50 - But the more functions you
call-- function after function
119:53 - after function after a
function, each of them
119:55 - gets its own slice or frame of
memory, that, too, is growing up.
119:58 - So this feels like a pretty bad design,
but honestly, it's not really avoidable
120:02 - because if you have a
finite amount of memory,
120:04 - you can't avoid each other forever.
120:06 - And so there's this fundamental
risk of overflowing the stack,
120:11 - or even overflowing the heap
in the reverse direction.
120:14 - So Stack Overflow is an allusion
to, for instance, calling too
120:17 - many-- many, many, many, many,
many, many, many, many functions,
120:20 - so many so that it overlaps other
chunks or segments of memory,
120:23 - thereby inducing a segmentation
fault, and buffer heap overflow
120:27 - is in the reverse direction,
and these are more
120:29 - generally known as buffer overflows,
and we'll see more of these in the weeks
120:34 - to come.
120:35 - But now that we have the
ability to discuss pointers,
120:37 - let's introduce one final
feature and then a familiar face.
120:41 - So it turns out that you can actually
come up with your own custom variables
120:46 - kind of like we did with string, but
even more sophisticated than that.
120:50 - For instance, if I wanted
to implement a program that
120:54 - involves multiple students, I
might do something like this.
120:57 - Ask the user what is the enrollment
in a class, then go ahead
121:00 - and give myself an
array of strings, a.k.a.
121:03 - char*s today of that size, and then I
could also have another array of dorms.
121:07 - And I could have two arrays containing
one for the students' names,
121:11 - one for the students' dorms, and
I can keep track of other things.
121:14 - Another array for emails,
another array for phone numbers--
121:16 - but this gets messy quickly,
because you can imagine,
121:19 - if I need names and dorms
and emails and phones,
121:23 - that starts to become
a lot of copy-paste.
121:25 - And I just have this design where
I have lots and lots of arrays
121:28 - where each bracket location--
like bracket 0, bracket 1
121:32 - presumably refers to the same student
across all of these arrays, like mmm!
121:36 - Messy, messy, messy design.
121:38 - So with a wave of my
hand, let me actually
121:40 - fix that immediate problem out of the
gate by introducing a new feature.
121:44 - I can invent my own data types.
121:46 - Let me just go ahead
and declare an array
121:48 - called students with this many
students, but of data type student.
121:54 - C comes with float, bool, char, int,
not string, and definitely not student.
121:59 - So you can make your
own custom data types,
122:02 - and you can put them in your own header
files, which we've not done either.
122:05 - But I can look, and you'll see more
of this in the next problem set.
122:08 - So not to worry if
this feels quite brief,
122:10 - it's just meant to be a teaser here.
122:12 - And struct.h is how you declare
or define your own type.
122:17 - The keyword is literally typedef
struct for structure, or data structure
122:21 - to be more complete.
122:22 - The name of the data structure comes
at the end after some curly braces.
122:26 - And then inside the curly
braces you just specify,
122:28 - well what do you want a student to have?
122:30 - I want them to have a name, a
dorm, maybe a phone number, maybe
122:33 - an email address, anything I want.
122:35 - I can just add here.
122:36 - So that now in my actual code, I can
have an array of actual students,
122:42 - and I can just access them with
this new notation like this.
122:45 - You know that you can index into
an array with bracket notation.
122:49 - What you didn't know until now,
perhaps, is that if at that location
122:53 - is a structure, a.k.a.
122:54 - struct, you can get at the name, the
dorm, or the phone, or the email,
122:59 - or anything else there just by
using a dot-notation, which is
123:02 - our last piece of new syntax for today.
123:04 - Everything else is the same.
123:06 - I can write a program that says so
and so is in such and such a dorm
123:09 - by just saying get the i-th student's
name and the i-th student's dorm.
123:13 - And I can be even fancier, and if I
don't want to just print those values,
123:17 - I can even, now, that I see
no understand pointers--
123:21 - or I've seen pointers and
we'll soon understand them
123:23 - by way of problem sets and
practice, I can actually do this.
123:27 - This is just a little sneak
preview of a line of code
123:29 - that uses a new function called fopen.
123:31 - fopen this file open, and it takes
in the name of the file to open.
123:35 - You might know of CSV files,
they're like simple spreadsheets,
123:37 - comma separated values.
123:39 - And quote-unquote "w" means write.
123:41 - So this says open the file called
students.csv in write mode,
123:45 - so I can write to this file.
123:46 - Because in this example, as
you'll see in the days to come,
123:48 - I want to write out to a file.
123:50 - But it turns out to use files, I
need to know what a pointer is,
123:53 - and it's a little weird
that it's all caps,
123:55 - but there is a data type in C
called "file," and it's a pointer.
123:59 - So long story short, what you're
going to see in the next problem set
124:02 - as we explore the world of
forensics is the ability
124:04 - using pointers and a few new
functions to open files and get back
124:08 - the address of that file in memory
so that you can go to that address,
124:12 - change the contents of a
file, and save it back out.
124:15 - All of us take for granted these days
that you can go to File, Open and File,
124:18 - Save, but what's actually
happening, pointers are involved,
124:21 - stuff's getting loaded into
memory, and the computer
124:23 - is dereferencing or
going to those addresses
124:25 - and changing what's at
those locations in memory.
124:28 - Now why might you want to do this?
124:30 - Well here, of course,
is Zamila-- you might
124:31 - recall from some of the problem
sets and the walkthroughs.
124:34 - Turns out we could try to enhance
this picture of her by zooming in,
124:38 - and here's about as much
fidelity as it is in her eyes.
124:41 - Like I do not see the glint
of any criminal's logo
124:46 - on his or her jacket in
the glint of Zamila's eyes.
124:48 - If you zoom in on an image, and
an image, recall, from week 0
124:51 - is just a grid of pixels or
dots, that's all you get.
124:55 - And you can maybe smooth it out a
little bit or clean up the colors,
124:58 - but you can't just
"enhance," quote-unquote,
125:01 - and see more of the
glint in Zamila's eye,
125:03 - because an image at the end of
the day is just a bitmap, a map--
125:07 - top-down, left-right-- of pixels.
125:09 - For instance, here's a smiley face.
125:11 - If you kind of take a look back and
you can kind of see a black smiley
125:14 - face against a white backdrop.
125:16 - And if we just decide as humans,
let's represent white dots
125:19 - with 1's and black dots with 0's,
this might be what's in the file,
125:23 - this is what the human sees.
125:24 - So if we have the ability to open
that from a file, store it in memory,
125:29 - and then using pointers go
to those locations in memory,
125:32 - we can even change the smiley face to an
unhappy face, for instance, or color it
125:35 - or do any number of things to it.
125:38 - Now at quick glance, there's
a lot going on in files,
125:40 - because what a file is is a set
of conventions that humans decided
125:45 - on where humans years ago
just decided in a bitmap file,
125:48 - BMP file-- so an older but still
popular file format for images, humans
125:52 - just decided that, like, we're going
to put a bunch of special values
125:56 - at the first bytes of
the file, then some more
125:58 - special values than the actual RGB
pixels in the rest of the file.
126:04 - So this is meant to look
cryptic at first glance,
126:06 - and the next homework assignment
will walk you through this,
126:08 - but all it is is a convention
of what the 0's and 1's mean
126:12 - in these different locations.
126:13 - And indeed, the challenge ahead is
going to be to do a number of things.
126:16 - One is to first and
foremost figure out--
126:18 - who done it?
126:19 - A sort of murder mystery in which
there's a clue hidden in an image,
126:22 - but an image that's a
little noisy and you're
126:24 - going to have to figure out what
secret messages in the image
126:26 - by loading that image in, tweaking
it, putting a sort of red filter
126:30 - on top of it and seeing the secret
message, but all digitally; two,
126:33 - actually resizing images and
taking this many pixels in this big
126:37 - of a smiley face or something
else and making it bigger,
126:40 - or if more comfortable,
making it even smaller
126:42 - and figuring out how
to make that workout;
126:44 - and then lastly, we've been taking
some photographs of all CS50 staff
126:47 - in Cambridge and New Haven.
126:49 - Unfortunately we accidentally
corrupted or lost the memory card,
126:53 - but we made a forensic image of it, a
copy of all of the 0's and 1's with all
126:57 - of the staff photos,
and we're going to need
126:58 - you to write code that actually
recovers all of the JPEGs
127:01 - or photographs from that
digital card by opening a file,
127:05 - reading in those 0's and 1's,
understanding what they are
127:08 - and where they are,
and just writing them
127:09 - back out to disk using functions
we'll introduce you to in the problem
127:13 - set itself.
127:14 - But of course, all of this takes
for granted that we can do this,
127:17 - and you can only do so much.
127:18 - And indeed, this week is as much
about solving those problems
127:21 - as it is realizing the
limitations of computers,
127:24 - and so we thought we'd end with
the final few seconds of this very
127:27 - real example from Futurama.
127:29 - [VIDEO PLAYBACK]
127:30 - - Magnify that death sphere.
127:35 - Why is it still blurry?
127:36 - - That's all the resolution we have.
127:38 - Making it bigger
doesn't make it clearer.
127:40 - - It does on CSI Miami.
127:42 - - Ugh.
127:43 - [END PLAYBACK]
127:43 - DAVID MALAN: And that's it for
CS50, we'll see you next time.