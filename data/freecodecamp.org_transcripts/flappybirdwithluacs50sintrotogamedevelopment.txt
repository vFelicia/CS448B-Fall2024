00:00 - [Music]
00:16 - hi everybody my name is colton ogden
00:19 - this is gd 50 lecture one
00:21 - and today we'll be covering flappy bird
00:24 - so uh last year we are last week sorry
00:26 - we covered pong which was uh just you
00:28 - know basic shapes and colors today we'll
00:30 - actually be diving into sprites as we
00:32 - can see here we've got some pipes and a
00:34 - bird and we're covering a few other
00:35 - concepts such as gravity and more
00:39 - today the topics that we'll be covering
00:41 - are in a nutshell images and sprites as
00:43 - i just said so loading images from
00:44 - memory from our hard drive and actually
00:46 - drawing them to the screen instead of
00:48 - just uh you know rectangles and whatnot
00:50 - uh we'll be covering infinite scrolling
00:52 - so seeing things like and if you've
00:54 - played the game pipes are infinitely
00:56 - going from right to left how to actually
00:58 - get that going infinitely so that we're
00:59 - not using up also infinite memory
01:02 - we'll be discussing how games and in the
01:04 - similar vein are illusions in the sense
01:07 - that um a lot of the perceived vastness
01:10 - and perceived complexity of games is
01:12 - often just due to camera trickery and
01:14 - more
01:15 - because of limited hardware
01:17 - we'll be covering procedural generation
01:19 - which ties also into infinite scrolling
01:21 - procedures generation is a topic that
01:23 - i'm actually very interested in and
01:24 - we'll be touching on it throughout the
01:26 - course in several locations but in the
01:28 - cons or in the context of today's
01:29 - lecture we'll be using it uh for the
01:31 - pipes because the pipes they spawn from
01:33 - right to left and flappy bird as you're
01:35 - infinitely going through the level but
01:36 - they can spawn at various heights and
01:38 - the gaps are shifting as a result of
01:41 - that therefore creating this sort of
01:42 - infinite level
01:44 - we'll be talking more in detail on state
01:46 - machines so last week we covered state
01:47 - machines in a very abstract sense we
01:49 - used a just basically a string as a
01:51 - variable and then used if conditions
01:52 - today we'll be actually using a state
01:54 - machine class replete with various
01:56 - methods that allow us to transition in
01:58 - and out of these states
01:59 - very cleanly and allow us to break out
02:01 - all of this logic that we previously had
02:03 - in our update and render functions and
02:05 - then put them separately into their own
02:07 - state classes
02:09 - and then lastly we'll also be touching
02:10 - on mouse input and a point that i forgot
02:13 - to mention here whoops is
02:17 - also
02:18 - we'll be talking about music which is
02:19 - just basically sound which we did last
02:20 - week but we'll add that as a polishing
02:23 - touch
02:24 - if you guys want to download the demo
02:25 - code we have a repo up
02:27 - right now on github slash games 50
02:30 - 50 bird that's our take on flappy bird
02:34 - a couple of things i've been asked a
02:35 - couple of times whether we have reading
02:37 - materials for the course uh and there
02:39 - are no formal reading materials but
02:40 - there are a couple of resources that i
02:42 - really enjoyed reading especially as i
02:44 - was getting more into lua and love2d
02:46 - they are two books uh one is an online
02:49 - book actually they're both online books
02:51 - but the latter of which has a physical
02:53 - form as well the four first of these is
02:55 - how to make an rpg by dan scholler which
02:57 - is actually completely written in lua
02:59 - he uses a custom game engine very
03:01 - similar to love2d but it's handwritten
03:03 - by him but a lot of the same ideas apply
03:06 - and it's a great opportunity it's how i
03:08 - cut my teeth on lua and i would
03:09 - encourage you to take a look at that if
03:11 - that's something you're interested in or
03:12 - if you like rpgs
03:14 - and then also game programming patterns
03:16 - by robert nystrom is a very great
03:18 - general purpose game development book
03:20 - that talks about a lot of these sort of
03:22 - more abstract high-level concepts with
03:23 - large-scale game development but yeah
03:25 - beyond that no formal reading those
03:27 - aren't formal reading either those are
03:28 - just if you're curious and you want to
03:30 - read some resources that i found very
03:31 - interesting feel free to do so today's
03:33 - goal is to implement what looks like
03:35 - this this is a this is our version of
03:37 - flappy bird
03:38 - we didn't use the same exact sprites for
03:40 - copyright purposes but we note that we
03:42 - have a bird in the middle of the screen
03:45 - this bird on click or on space bar will
03:48 - jump up and down and your goal is to
03:50 - prevent the bird from touching either
03:52 - the pipes or the ground itself
03:55 - every time you make it past a pair of
03:56 - pipes you will score a point as soon as
03:59 - you touch a pipe or hit the ground game
04:00 - is over and
04:02 - that's that
04:03 - so
04:04 - today we'll be covering uh i'll doing a
04:06 - little bit more live coding so the very
04:08 - first example that i want to cover is
04:10 - the day zero update
04:11 - for flappy bird and a important function
04:14 - that is going to be probably the most
04:15 - noticeable the most visibly obvious
04:17 - function we'll be using throughout this
04:19 - lecture is
04:21 - love.graphics.new image which takes a
04:23 - path
04:24 - this function
04:25 - all it does is load a image file from
04:27 - your disk you specify it as a string
04:30 - and you can then use it as an object and
04:32 - draw anywhere you want at an x y
04:34 - coordinate and we'll see this in
04:36 - practice here so i'm going to go ahead
04:38 - if you're looking in the repo all of
04:39 - these examples are covered 0 through 12.
04:44 - i'm going to start from scratch in a new
04:47 - folder that i've created i'm going to
04:48 - create a brand new
04:50 - main.lua completely fresh
04:53 - and
04:54 - first thing i want to do is because we
04:56 - are
04:57 - going to use a virtual resolution just
04:59 - like we did last week so that we have a
05:00 - more retro aesthetic i'm going to go
05:01 - ahead and require the push library so
05:03 - push equals require push just like that
05:06 - i've pre put push lua into this
05:08 - directory it'll just load by default in
05:11 - the same directory the current working
05:12 - directory of your script when you run
05:15 - love
05:16 - next thing i'm going to do i'm going to
05:17 - define some constants so window width
05:19 - should be 1280 and then window height is
05:21 - going to be
05:22 - 720. those are our physical window
05:25 - dimensions but then we also need a
05:27 - virtual width
05:28 - and we're going to use 512 by 288 this
05:31 - is a
05:32 - resolution that i found worked pretty
05:33 - well for the assets we'll be using today
05:36 - but you can make this most anything you
05:37 - want to
05:38 - as long as it's somewhat in that range
05:40 - it is a 16x9 resolution as well so that
05:42 - it fits comfortably on um
05:45 - modern widescreen 16x9 monitors um what
05:48 - we're going to do is the first goal that
05:50 - we have today is to sort of
05:52 - draw
05:53 - two images to the screen
05:55 - we want a foreground and a background
05:57 - because notice if we go back to the
05:58 - slides we can see in the very background
06:01 - we have a
06:03 - sort of hill
06:04 - landscape and then on the bottom we have
06:07 - a
06:07 - ground and there the two of those are
06:09 - going to eventually scroll at different
06:11 - rates it's going to be called parallax
06:13 - scrolling but just for our very first
06:15 - example we have something very basic i
06:16 - just want to draw two images to the
06:17 - screen so we're going to go ahead and do
06:19 - that here by setting a local variable
06:22 - remember local means that it's just
06:24 - defined to the scope that it's in rather
06:26 - than being global which means we cannot
06:27 - access this variable outside of this
06:30 - file
06:31 - local background gets love.graphic
06:34 - image the function that we just talked
06:36 - about let me go ahead and hide this
06:37 - inspector here so we can have more room
06:39 - to code
06:40 - and then it's just going to take a
06:42 - string so background.png
06:44 - and i realize i actually didn't include
06:45 - those files in the directory so i'm
06:47 - going to need to do that as well
06:49 - same thing for the ground exact same
06:51 - function love.graphics.new image except
06:53 - ground.png
06:55 - and before i forget let's go ahead and
06:56 - do that right now
06:59 - i have the
07:00 - files here ground and background and
07:03 - copy those from the
07:05 - repo the distro repo into my bird zero
07:08 - directory that i'm currently developing
07:10 - in right now
07:12 - and so as soon as we're done with that
07:13 - we're going to go ahead and we're going
07:14 - to define love.load which is the
07:16 - function lov2d calls at the beginning of
07:18 - your program execution
07:20 - in there because we don't want these
07:22 - images to
07:24 - look blurry when they get loaded and
07:26 - upscaled we want to go ahead and set our
07:28 - default filter to nearest on min and mag
07:31 - which means on upscale and downscale
07:33 - apply nearest neighbor filtering which
07:34 - means
07:35 - no
07:36 - blurriness no interpolation of the
07:38 - pixels
07:40 - and then
07:42 - one thing that
07:43 - is just a small little touch
07:46 - love.window.set title 50 bird because uh
07:50 - is gd50 and then we're going to go ahead
07:52 - and set up our screen here with our
07:55 - virtual width
07:56 - virtual height window width
08:00 - window height
08:01 - it's getting a bit long
08:03 - and then it takes in a table
08:05 - recall tables just take in keys
08:08 - like so unlike in python where you might
08:11 - use a colon we use an equal sign in love
08:14 - or in lua i should say
08:16 - resizable to true
08:19 - and that is the end of our
08:23 - load function now does anybody recall
08:24 - how
08:25 - we if we want to resize so notice i said
08:28 - resizable to true do we know how we want
08:30 - how we can send a message to push to
08:32 - resize our screen for us
08:37 - so love 2d defines a function called
08:39 - love.resize which takes in a width and a
08:42 - height
08:43 - and in there all we're going to do is
08:45 - defer
08:46 - that call to push recall the exact same
08:48 - function on push it takes a width and a
08:50 - height and that will take care of
08:51 - dynamically
08:52 - re-scaling the canvas it uses internally
08:55 - it renders to a texture and it's going
08:57 - to render to the texture that we set as
08:58 - the virtual width and virtual height and
09:00 - it's going to scale it to fit our screen
09:02 - and it needs to know our physical screen
09:04 - dimension so that it can actually
09:06 - properly scale that internal canvas
09:08 - appropriately
09:10 - does anybody remember the function that
09:12 - we use to get input from the user
09:17 - so function.love.keypressed
09:20 - recall it takes in a key love is going
09:23 - to call this automatically every time we
09:25 - press a key and that's going to be
09:27 - we're going to have access to that key
09:29 - and we can do any sort of logic that we
09:31 - want
09:32 - on
09:33 - that key or using that key and we're
09:36 - just going to call love.event.quit
09:38 - because i don't like to press command q
09:40 - or click the red x i just want to hit
09:41 - escape be done with it
09:44 - and then what's our render what's love's
09:46 - render function called
09:49 - it's called love.draw
09:52 - so call love.draw
09:55 - and then uh
09:56 - because we're using push does anybody
09:58 - remember what we need to actually do to
09:59 - get push to render our screen to a
10:01 - virtual resolution
10:06 - so recall
10:09 - that there's actually two ways we can do
10:10 - it we can call push start and push
10:13 - finish
10:14 - which we didn't cover last week
10:16 - or we can call and that's actually the
10:18 - new
10:19 - like sort of de facto way to do it
10:21 - or we can do push apply
10:24 - start which is the deprecated way to do
10:26 - it
10:27 - but
10:28 - starting from here on out we're just
10:29 - going to call push start
10:31 - and push finish
10:34 - and then last we have our images we've
10:37 - allocated them as objects up here we
10:40 - have a background and a ground
10:44 - all we need to do now is just draw them
10:46 - to the screen
10:47 - so this is a new
10:48 - function or it's actually uh
10:51 - not a new function it is a new function
10:53 - actually
10:54 - love dot graphics.rectangle is what we
10:56 - used last week for all of the draw calls
10:59 - in this case we want to draw a graph a
11:01 - image object a texture object that we
11:03 - have in memory so we're going to call
11:05 - love.graphics.draw and it takes a
11:07 - drawable which means anything that love
11:09 - has defined as something that can be
11:11 - drawn in this case images are drawables
11:13 - they can be drawn and they can be drawn
11:15 - at any given position that you specify
11:18 - so if we wanted to draw it at the top
11:19 - left corner we would just say
11:21 - love.graphics.dropbackground at zero
11:23 - zero and it has that effect and we're
11:25 - gonna do the exact same thing with our
11:29 - ground
11:30 - the only difference being that obviously
11:32 - we don't want to draw at the top left
11:33 - corner we want to draw at the bottom of
11:34 - the screen so
11:38 - we just call
11:39 - virtual height minus 16 which happens to
11:41 - be the height of our image so if you run
11:43 - this i'm going to go ahead
11:45 - and make sure i'm in the right directory
11:48 - i'm not in the right directory so i'm
11:49 - going to go into
11:51 - a directory i wrote 50 bird
11:53 - scratch going into bird zero
11:56 - and if i run this i should theoretically
11:58 - have
11:59 - just two images layered on top of each
12:01 - other
12:02 - which i do not
12:06 - so
12:07 - let me make sure that it gets saved
12:10 - remember to always save your work
12:12 - and
12:14 - there we go
12:15 - so all we're doing now is it looks
12:17 - infinitely better than last week already
12:19 - but it's very simple very few lines of
12:21 - code all the effort that we've put into
12:22 - it has been in our sprite editor of
12:24 - choice and you can use most any
12:25 - application you want to do this sort of
12:27 - stuff i use a program called a sprite i
12:29 - like a lot but you could do this in
12:31 - which is free you could do it in
12:32 - photoshop you could do it in microsoft
12:34 - paint if you wanted to
12:36 - um
12:37 - godspeed if you do
12:39 - um
12:40 - but yeah so that's that's as simple as
12:42 - it is just to draw images to the screen
12:43 - so we've already made quite a lot of
12:45 - progress in a very short period of time
12:47 - in terms of the visual aspect of our
12:49 - game but it's not interesting to look at
12:52 - beyond the initial sort of honeymoon
12:53 - period of now we have colors on the
12:55 - screen we want to actually get
12:57 - scrolling
12:58 - because the game
13:00 - recall is a scrolling game and actually
13:03 - would anybody be willing to volunteer to
13:05 - come up and play flappy bird just so we
13:07 - can see it live on the stage
13:13 - david do you want to come up and play oh
13:15 - doesn't volunteer
13:18 - stephen you want to come up and play
13:23 - thank you for volunteering
13:30 - i guarantee you're better at this game
13:32 - than i am so
13:34 - i'm going to go ahead and cd into uh
13:37 - bird
13:38 - bird 12
13:39 - in the directory which is uh the final
13:42 - version of the game complete so i'm
13:44 - going to go ahead and hit enter
13:47 - so already we can see
13:49 - the uh
13:51 - parallax scrolling that i referred to
13:52 - before which is the floor and the
13:54 - background are scrolling at different
13:56 - rates and we'll see this very shortly in
13:57 - the next example
13:59 - we have a prompt we have text we've
14:00 - already used this before with a font so
14:02 - go ahead if you press enter
14:04 - you're going to get a countdown so space
14:06 - is to jump
14:08 - so we have our bird jumping in the
14:10 - middle of the screen we have a score at
14:11 - the top
14:12 - goal is to avoid hitting the pipes
14:16 - oh i got a score of one we'll try again
14:22 - [Music]
14:23 - so it keeps track of his position and
14:25 - every time he gets past the right edge
14:27 - of a pair of pipes as you can see that's
14:29 - when he gets a point
14:32 - so if you recall from last week
14:35 - what do we think is what what's what's
14:37 - detecting the collision if you remember
14:38 - last week what's the term
14:40 - anybody remember
14:42 - access a bound a a b b collision
14:44 - detection access a line bounding box is
14:46 - the same thing that we did with pong
14:48 - except now we're doing it we have
14:49 - graphics but that's the same same as
14:51 - that concept we're just using
14:53 - rectangles and when one rectangle
14:55 - overlaps with another rectangle we
14:57 - trigger
14:58 - depth
15:02 - so one last iteration i think and then
15:04 - we'll
15:04 - oh
15:06 - we'll let you try one more time
15:08 - go ahead i'll give it a shot all right
15:11 - i'm gonna lose on purpose yeah okay here
15:12 - we go
15:14 - so to be to be unfair i i got plenty of
15:17 - practice while i was developing this but
15:18 - we'll see if that actually holds true
15:20 - here
15:22 - all right so notice also the pipes
15:25 - there's their the procedure generation
15:26 - that i oh i lost three points
15:28 - let me explain a little bit more i guess
15:30 - we'll do one more iteration but the
15:32 - pipes themselves every time we start
15:34 - they're spawning at a different location
15:35 - this is procedural generation
15:38 - pretty much the most simplest way
15:40 - possible
15:41 - um and notice that the pipes are
15:43 - shifting gradually so this is sort of
15:45 - like the makeup of our level
15:47 - um and it's just generating bit by bit
15:50 - uh due to some simple algorithm that we
15:52 - have that just says hey respond to the
15:53 - pipe here shift it by some amount
15:55 - and
15:57 - this very simple approach allows us to
15:58 - have an infinite level over and over
16:00 - again it's very efficient we only ever
16:02 - have as many pipes on the screen and as
16:04 - we'll see soon
16:06 - we only have as many pipes in memory as
16:08 - we can see on the screen at one time
16:10 - despite the fact that this level could
16:11 - theoretically go on infinitely
16:14 - and so it's very cost efficient
16:16 - so bird one uh is the example it's the
16:18 - parallax update so parallax scrolling is
16:20 - an important concept in 2d
16:23 - and also 3d but 2d game development it
16:26 - refers to the illusion of movement given
16:29 - two
16:30 - two frames of reference that are that
16:32 - moving at different rates so if you're
16:33 - driving on the highway and you see a
16:35 - fence next to you
16:37 - and you see mountains in the distance
16:38 - you're observing parallax scroll by
16:40 - seeing how fast the fence moves relative
16:42 - to the mountains the mountains are going
16:43 - to move a lot more slowly than the fence
16:45 - is right next to you and we accomplish
16:47 - the same exact illusion in our game by
16:50 - ref by using this sort of uh graphical
16:52 - illusion
16:54 - and so i'm going to go ahead in my
16:56 - directory here
16:57 - in bird one which is a unpopulated
17:01 - direct it's populated with the contents
17:03 - of bird zero the complete contents of
17:05 - bird zero
17:06 - your the version that you'll see will
17:08 - have uh all of the code but i'm gonna go
17:11 - ahead and
17:12 - if we run bird
17:14 - zero
17:15 - uh in that directory so i think right
17:17 - now i'm still in the
17:18 - full distro so let me go ahead go into
17:21 - 50 bird scratch again
17:26 - oops where am i
17:31 - and then i'm gonna go into bird one and
17:33 - run it
17:34 - and i get the exact same image that we
17:36 - had last time so everything is there
17:37 - from before just two images nothing
17:39 - moving no parallax that we can observe
17:41 - i'm gonna go ahead and start
17:42 - implementing
17:44 - the uh basics of this parallax
17:47 - so if i go ahead in my main
17:51 - so i'm gonna go down here to
17:54 - where we have our background so we need
17:56 - a couple of new things
17:58 - so along with our background image we
18:00 - need to keep track of how much it's
18:01 - scrolled because we're going to start
18:03 - drawing this image to the screen but if
18:05 - we're going to scroll it that means that
18:06 - we need to shift its x offset we need to
18:08 - instead of drawing it at 0 0 if we want
18:10 - it to scroll we have to draw it at some
18:12 - negative value instead
18:15 - over time this will have the effect of
18:16 - it moving right to left so i'm going to
18:19 - go ahead and keep track of a i'm going
18:20 - to use a variable to keep track of the
18:22 - scroll amount for both of these images
18:24 - and we're going to call them background
18:25 - scroll and ground scroll and set them to
18:26 - zero so this is going to have the effect
18:28 - of no x offset so i could use this
18:31 - variable right now
18:32 - in this draw call down here which i'm
18:34 - actually going to do i'm going to go
18:36 - ahead and go to
18:38 - i'm just going to find that that is
18:39 - correct i'm going to go ahead and set
18:42 - that to
18:43 - negative
18:45 - background scroll whoops
18:49 - and here i'm going to set this to
18:51 - negative ground scroll so this is not
18:53 - going to change anything yet it's going
18:55 - to be the exact same thing because
18:56 - they're both 0 they were 0 before
18:58 - but
18:59 - we're going to change them over time
19:02 - and in order to do this i'm going to go
19:04 - ahead and go into
19:10 - are
19:12 - uh
19:13 - up here uh one thing before we before we
19:15 - do that actually uh we need to set a
19:16 - speed for this this is going to happen
19:18 - over time but
19:19 - since they need to occur at different
19:20 - rates the background needs to go at a
19:22 - slower rate than the foreground so that
19:23 - we do get this parallax effect we need
19:25 - two separate speed variables
19:28 - generally the
19:30 - norm for something that is not going to
19:31 - change is to write it in caps with
19:34 - underscores this is constant notation
19:35 - this is frequently seen in most
19:37 - programming languages we'll use it here
19:39 - i'm going to set a variable called
19:40 - background scroll speed and i'm just
19:41 - going to set that to 30.
19:43 - i'm going to do the same thing ground
19:45 - scroll speed
19:48 - does this need to be higher or lower
19:49 - than the background scroll speed
19:54 - the ground is going to move the so the
19:56 - background needs to move slower than the
19:57 - ground does
19:59 - so this is going to be higher so we're
20:00 - just going to set it to 60. you can set
20:02 - it to whatever you want to get the
20:03 - effect that you want but this will
20:04 - already be quite noticeable the ground
20:06 - is going to move twice as fast as the
20:07 - background
20:09 - and so what we're going to do also
20:12 - is
20:14 - if we just so what's going to happen if
20:15 - we just let our
20:18 - image scroll infinitely what's going to
20:19 - happen at a certain point
20:22 - it's going to run out of image so
20:24 - how do we fix this problem
20:27 - loop it exactly so we're going to go
20:29 - ahead and set a looping point so
20:32 - another
20:32 - constant background looping point
20:35 - and we're going to set this to 413 which
20:38 - you kind of have to look at your image
20:40 - and determine you you sort of have to
20:42 - set your images up if you want to
20:43 - achieve this effect by having them be a
20:46 - looping image so have either two copies
20:48 - of the exact same thing that's their
20:50 - screen with or just copy the same chunk
20:52 - over and over again there's many ways to
20:54 - do it in this case the looping point of
20:56 - the image of our our background is 413
20:58 - on the x-axis so we're going to set that
21:00 - to
21:00 - 413.
21:02 - and then we're going to go ahead the
21:04 - next step is we actually have to start
21:05 - uh changing the value so in our our
21:08 - update function which is where this is
21:09 - going to happen
21:12 - i'm going to go ahead and define
21:13 - love.update which recall lov2d will call
21:15 - for you but you must define it yourself
21:19 - i'm going to go ahead and set background
21:21 - scroll to
21:32 - so what this is going to do background
21:33 - scroll gets
21:35 - background scroll to itself plus the
21:37 - speed we set before times delta time so
21:40 - it stays frame rate independent
21:43 - um
21:45 - that'll have the effect of adding the
21:47 - speed to our image but we need to reset
21:49 - it we need to actually perform the reset
21:50 - and to do that we'll just be using
21:52 - modulus which recall from languages like
21:56 - c
21:57 - simply
21:58 - divides basically sets that value to uh
22:02 - the remainder of that division so in
22:04 - this case so
22:06 - 10 modulo
22:08 - 5 would be 0 but 10 modulo
22:13 - 9 would be
22:15 - 1 effectively because we have 0 left
22:18 - over once we divide 10 by 5 we have 1
22:20 - left over once we divide 10 by 9.
22:26 - so i apologize if that concept is uh
22:29 - not new
22:30 - but
22:31 - we're going to do the same exact thing
22:33 - for our ground
22:40 - only we're going to modulo by the ground
22:43 - or uh
22:44 - of our virtual width in this case
22:47 - i did not set a looping point i do in
22:49 - later examples but the our ground image
22:51 - is very uh it's consistent enough such
22:53 - that you don't even notice it when it
22:54 - loops without using a with just uh
22:57 - without just using the virtual width so
22:58 - we're just gonna use the virtual width
22:59 - in that case it's very
23:01 - um patterned and very small
23:04 - um and aside from that yeah we already
23:06 - have the off the background scrolls here
23:09 - in our render or draw functions so when
23:11 - we run this code we should theoretically
23:13 - have
23:15 - scrolling background
23:17 - so does the images have to be twice the
23:20 - width
23:21 - they do at least twice the width yes
23:23 - there's ways you could effectively tile
23:25 - your image
23:27 - and do it that way to save memory on on
23:29 - a texture size if you have like maybe
23:31 - something that's a quarter of the screen
23:33 - size that you want to loop over and over
23:34 - again you don't want to have that as one
23:35 - big image you'll just draw four copies
23:38 - of that image to fill your screen and
23:39 - then just shift all of them or maybe
23:41 - five actually so you have a little bit
23:42 - beyond the edge of the screen and then
23:44 - just put all of them back to
23:48 - the bottom line the zero is
23:51 - you you wouldn't know
23:52 - if you
23:53 - just restarted showing the image but the
23:56 - the larger background you would have to
23:57 - worry about
23:59 - the mountain getting cut in half when
24:00 - you replaced it right exactly
24:03 - so like we could uh we could actually i
24:05 - could show you right now what that'll
24:06 - look like so if we just take out the
24:08 - looping point here
24:10 - or we set it to some like value that's
24:12 - completely inaccurate like 270
24:15 - and then we run it
24:17 - after a while
24:23 - should just cut yep right there so are
24:26 - you stacked so are you drawing it twice
24:28 - really like one after another when it
24:29 - runs out
24:30 - no the image is so wide that it always
24:33 - will fill the screen even after it's
24:35 - been uh set back to even after it's gone
24:37 - past the looping point i forget how
24:39 - large the texture is
24:40 - it is
24:42 - yeah 1157 pixels wide so it's more than
24:44 - twice the screen width actually i think
24:46 - it is exactly twice the screen width um
24:48 - no it's not exactly how the screen is
24:49 - but it's more than twice the screen
24:51 - width so that when the amount the 413
24:53 - pixels has elapsed it's still plenty
24:55 - past the right edge of the screen and
24:57 - the looping part
24:59 - it'll be the exact same
25:01 - appearance on the texture but it's
25:02 - completely been shifted back to the
25:04 - right so that zero zero is now at zero
25:06 - the zero zero of our image is now at
25:08 - zero zero in our screen space
25:13 - it's just taking it your image is here
25:15 - moving and then just instantly back to
25:17 - the beginning and then and moving back
25:19 - to it that's why and the setting it back
25:21 - to zero or however technically how many
25:23 - pixels has gone past the edge of the
25:25 - screen
25:27 - because using modulo
25:31 - yep
25:32 - it's a translation it's an instant
25:34 - translation it takes place over one
25:35 - frame so you don't notice it your human
25:36 - eye can't see it because it literally
25:38 - happens in one frame and it the exact
25:40 - the the image data is the exact same at
25:42 - those two points
25:43 - because we have a texture we've
25:45 - pre-created a texture that has the exact
25:47 - same data so that you have that effect
25:49 - you have to have a texture that allows
25:51 - you to do this or smartly draw four of
25:54 - the same images keep track of all four
25:56 - of them or actually eight of them so
25:58 - that you can move them to the left and
26:00 - then shift them all back to the right
26:11 - when we get to super mario brothers
26:12 - we'll be talking about a concept called
26:14 - tile mapping which is where we take a
26:16 - sprite sheet and then you uh
26:18 - basically chop it up into pieces have a
26:21 - map in that is basically numerical so
26:23 - that a brick is uh like one the value
26:26 - one and then you look through this giant
26:27 - two-dimensional array that you have and
26:29 - then go over it iterate over it and then
26:31 - draw a tile like give at an offset based
26:33 - on your index into that map
26:35 - so it's a little bit more complicated
26:37 - and you actually a lot more memory
26:38 - efficient but
26:40 - slightly different slightly different
26:42 - implementation
26:48 - okay so
26:51 - we have parallax scrolling now
26:53 - um i want to take a moment to
26:55 - because we've touched on we've sort of
26:58 - this is this is a very sort of
26:59 - introductory way of demonstrating that
27:00 - games our illusions by using parallax
27:02 - scrolling we've all we've done really is
27:04 - just set two things to scroll at
27:06 - different rates and this has made us
27:07 - feel like we have depth in our scene but
27:09 - all we're doing we have two images we're
27:10 - scrolling them at different rates um
27:13 - but this is a common theme in game
27:15 - development is taking trying to devise a
27:18 - scene that maybe is very elaborate
27:20 - but doing it on very resource intensive
27:22 - devices uh like your iphone or like you
27:25 - know old consoles like the nintendo 64
27:27 - these sort of illusions are all over the
27:29 - place and a youtube channel that i um
27:34 - that i recently found that i really like
27:37 - is it's called the name of the channel
27:39 - is she says but the actual show that
27:41 - they have is called boundary break and
27:42 - what they do is they take a camera
27:45 - that it goes beyond what the game
27:47 - developers allowed it to do was they
27:49 - basically hacked the game camera so you
27:51 - can see in places where you weren't
27:52 - supposed to see before and you can see a
27:54 - lot of really cool trickery um i'm about
27:57 - to show you a couple of video clips but
27:59 - here's the youtube url if you're curious
28:00 - to see the exact video it's about 33
28:03 - minute video um it's on zelda ocarina of
28:06 - time for the n64
28:07 - uh and
28:09 - i'm i extracted a couple of particularly
28:11 - noteworthy clips that i thought were
28:12 - kind of interesting and also humorous
28:15 - i'm gonna go ahead and show the clip now
28:16 - so if we could dim the lights
28:20 - i'll go ahead and start this is a the
28:22 - first example
28:24 - okay so there's a lot to talk about with
28:25 - the shop owners in ocarina of time so
28:27 - i'm gonna just condense it down to the
28:29 - most interesting and the first one we're
28:30 - going to talk about is the bizarre shop
28:32 - owner in hyrule now in majora's mask
28:35 - this very same character is actually
28:37 - shown with legs but in our current time
28:40 - he did not have those in fact he looks
28:43 - extremely hilarious
28:45 - without his legs
28:50 - so this is a
28:52 - do we do does anybody have an instinct
28:53 - as to why they might have done this this
28:55 - way
28:57 - exactly and beyond that also just saving
29:00 - on
29:00 - memory right like not having to load a
29:02 - character model the vertices and
29:03 - textures associated with it
29:05 - on a such a memory constrained device
29:07 - like the n64 i forget how many how much
29:09 - memory it had like four megabytes of
29:11 - memory i think less than that um and so
29:14 - they were obviously cutting however many
29:15 - corners they could in this case by
29:17 - literally using
29:18 - the illusion of looking at not the
29:20 - illusion but just sort of like the fact
29:21 - that you only could see over the counter
29:24 - and sort of giving you the illusion that
29:25 - there's a fully living talking
29:27 - shopkeeper there but it's just a half a
29:28 - model
29:30 - and another example here uh is more to
29:33 - show how uh ocarina of time used its
29:36 - limited memory the n64 limited memory to
29:39 - give you the sense of being in a very
29:40 - large level when you might not actually
29:42 - have been so if you get in the lights
29:43 - one more time i'll go ahead and show
29:45 - this
29:46 - so this one was apparently a hot
29:48 - suggestion
29:51 - which is free camera on death mountain
29:53 - including our friend big goron
29:56 - the smoke halo looks sort of weird
29:58 - against the black sky
29:59 - and here you can see a nintendo fuldas
30:02 - it's not a full mountain only the cliff
30:04 - face is actually rendered
30:06 - that's the path leading towards the fire
30:07 - temple
30:09 - and if we zoom out we can see the scale
30:11 - of the whole map
30:12 - bigger than i thought it'd be actually
30:15 - the battle music's not quite fitting for
30:16 - an epic panning shot though
30:19 - same idea here really just limited
30:22 - memory space so let's load you know as
30:24 - much as we could possibly ever see from
30:26 - the perspective the camera of link
30:29 - and it's actually very similar to how i
30:31 - guess people
30:32 - create stages in real life to make you
30:34 - feel as if you're in a when you go to a
30:36 - play feel like you're actually in a
30:38 - scene but you know they've clearly cut
30:41 - as many corners as possible but it works
30:42 - in the game you can't tell and that's
30:44 - very common in game development and
30:46 - something
30:47 - if you're trying to achieve a
30:48 - particularly grand effect is something
30:50 - to think about is how can i make it seem
30:52 - like i'm doing something but i'm
30:54 - actually not how can i make it seem like
30:56 - i'm a bird flying through an infinite
30:58 - series of levels but i'm actually not
31:01 - we have a lot of
31:03 - sort of more of that to show coming up
31:05 - soon we have uh so so far we have
31:09 - our background but we don't have the uh
31:12 - title character of our game
31:14 - in the in this case uh 50 bird so i'm
31:16 - going to go ahead and
31:18 - illustrate how we can get a bird
31:20 - actually rendering on the screen
31:23 - so i'm going to go ahead into my
31:25 - bird 2 directory here that i've created
31:28 - note again bird 2 in your directory if
31:30 - you've loaded the code is going to have
31:31 - the complete implementation
31:34 - but in main
31:37 - i'm going to do a couple things so
31:38 - actually first thing i'm going to do
31:39 - we're going to notice that i've included
31:42 - actually i haven't included the
31:44 - class um
31:47 - file so i'm going to do that right now
31:49 - so in bird one or sorry i'm gonna take
31:52 - from bird three the class.lua i'm gonna
31:53 - go ahead and put it into bird two
31:56 - because we're gonna make a bird class
31:57 - recall from last week a class is just a
31:59 - way of taking several variables that we
32:01 - might once have had disparate from one
32:02 - another putting them in together in a
32:04 - package putting functions associated
32:06 - with those variables together so that we
32:08 - can call
32:09 - we we can sort of think of our world our
32:10 - game world more abstractly
32:13 - and more compartmentalized and cleaner
32:15 - so i'm going to go ahead and now i have
32:17 - in bird 2 the class.lua that's just the
32:19 - library we're using to get classes in
32:21 - love2d in lua i'm going to go ahead and
32:24 - i'm going to create a new file
32:25 - this one's called bird.lua so remember
32:27 - the trend is for classes capitalize them
32:30 - to differentiate them from
32:32 - functions and variables
32:35 - this one i'm going to go ahead and just
32:38 - go ahead and
32:39 - use my cheat sheet here
32:47 - poetry
32:51 - my sheets are sticking together
32:53 - okay
32:55 - so this bird class is actually fairly
32:56 - simple uh recall that all we have to do
32:59 - to create a class is just use the class
33:00 - library the capital c with the brackets
33:03 - there to initialize it
33:05 - we're going to go ahead and define our
33:06 - init function so every
33:08 - class has an init function which
33:10 - initializes the object that it's going
33:13 - to refer to later
33:16 - in this case we're going to need a few
33:17 - things so we're going to need an image
33:19 - for our bird because we want to draw to
33:21 - the screen and so what we need to do
33:23 - same thing that we did before
33:24 - love.graphics.new image i'm going to go
33:26 - ahead and hide this really fast and then
33:29 - bird.png
33:31 - simple easy
33:33 - we want the
33:34 - width and the height of our bird
33:37 - so i'm going to go ahead and
33:39 - set that too so uh
33:41 - every image has a
33:43 - set of functions associated with it that
33:45 - love implements for us the image that we
33:47 - get back from love.graphics.new image is
33:50 - itself sort of a class which has a
33:52 - function called get with so this will
33:55 - allow us to achieve the width
33:56 - dynamically of whatever
33:58 - class we
34:00 - whatever image file we happen to
34:02 - allocate and create an object from
34:05 - and then we're going to go ahead and set
34:06 - our x and y because recall we have to
34:08 - draw it somewhere we want to draw our
34:09 - bird in the middle of the screen so
34:11 - we're going to go ahead and just
34:13 - calculate this based on our virtual
34:14 - width so we're going to do virtual width
34:16 - divided by 2. so it's halfway in the
34:18 - middle of the screen but
34:19 - since it draws from the top left corner
34:20 - we want to shift it to the left so we're
34:22 - going to use our width that we just uh
34:27 - instant error we just initialized from
34:29 - the image data
34:30 - and then we're going to call it our do a
34:32 - self.width divided by 2. so we're going
34:34 - to divide the width by 2
34:36 - shift that to the left on our x-axis
34:38 - that's going to put us in the middle
34:40 - horizontally vertically it's the exact
34:42 - same thing
34:43 - except we're using height instead of
34:45 - width and that's pretty much it except
34:48 - for one last
34:50 - bit here we want to be able to render
34:52 - our bird pretty important so we're going
34:54 - to do love.graphics.draw
34:57 - um our image
34:59 - and then at self.x self.y
35:03 - and so this is uh all we really need
35:05 - just to get a very simple sprite onto
35:07 - the screen now it's not going to do
35:09 - anything because this sort of lives in a
35:11 - vacuum at the moment what we need to do
35:13 - is in our main file we're going to
35:15 - require bird
35:17 - which is going to actually put it into
35:18 - our allow us to use it in our code
35:22 - we're going to
35:28 - create a local
35:31 - bird variable we're just going to call
35:33 - it bird
35:35 - we're going to after that
35:39 - simply
35:44 - render to the screen like that
35:47 - and if all
35:48 - is done and well
35:49 - and if i'm in the right directory
35:54 - uh it did not work
35:58 - make sure make sure you save your work
36:00 - again
36:02 - uh oh i
36:05 - did not require class my bad so also we
36:08 - need to do
36:10 - this since we added that to our
36:12 - directory
36:14 - uh i did not include the bird.png as
36:17 - well so i'm gonna go ahead and do that
36:19 - i'm gonna borrow that from the next
36:20 - directory
36:21 - that should be all we need to do and
36:25 - uh
36:26 - attempt to call method render a nil
36:28 - value
36:29 - interesting
36:32 - did i not save bird i did not save bird
36:36 - there we go we did it
36:38 - so uh not particularly interesting but
36:40 - it's sort of you know we're making steps
36:42 - remember to save your work
36:44 - yes
36:44 - we can see i do not
36:47 - um but we're making progress we have we
36:49 - have our our entity that we will control
36:52 - so uh you know we have visually we have
36:54 - we're getting very close but a lot of
36:56 - important details are missing
36:59 - what
37:01 - should be the next step do we think
37:10 - and we'll do that with the help of a
37:12 - notion that's common in platformers and
37:14 - a lot of games really but gravity how do
37:16 - we how do we think we can simulate
37:17 - gravity in the context of 2d game
37:19 - development
37:22 - just by default fall at a constant rate
37:25 - we could do that certainly um and that's
37:27 - effectively what we will be doing we'll
37:29 - be using
37:30 - something that we used last week which
37:32 - was
37:33 - velocity delta y
37:36 - and applying that velocity
37:38 - uh
37:39 - to our
37:41 - bird's y frame by frame and that will
37:43 - give it the illusion
37:46 - of falling now falling at a constant
37:48 - rate isn't accurate to what gravity
37:50 - actually does what we want to do
37:52 - probably is some gravity
37:54 - over and over again increment our
37:55 - gravity by some sort of constant value
37:58 - so that just like in real life things
38:00 - fall faster and faster
38:02 - and then we want to we want to add that
38:03 - to our y value
38:05 - so i'm going to go ahead and start
38:06 - implementing that now in bird three uh
38:08 - wrong repo so bird three
38:12 - we have everything that we had from
38:14 - before
38:16 - um except now
38:18 - i'm going to go ahead and in main.lua
38:25 - in our
38:31 - update function
38:34 - this is where we're actually going to
38:35 - want to
38:36 - perform the update logic
38:39 - for
38:41 - making the velocity apply to the bird
38:44 - we're going to defer that to the bird
38:45 - class we're going to assume that we have
38:46 - a method called update in our bird class
38:48 - which we're going to implement shortly
38:53 - and that's actually all we need to do in
38:55 - our main class it's sort of the beauty
38:57 - of having classes that you can delegate
39:00 - all this work to your main file though
39:03 - it's still getting quite large it's 108
39:05 - lines
39:06 - it's not
39:07 - two 300 400 you know thousands of lines
39:10 - of code because we're able to break out
39:11 - this code and sort of
39:14 - encapsulate it elsewhere
39:16 - so i'm going to remember to save it this
39:17 - time and then i'm going to go into the
39:20 - bird.lua file
39:23 - in that directory which is the same
39:25 - with comments because i loaded it from
39:27 - the official repo
39:29 - the same bird code that we wrote before
39:33 - i'm going to go ahead and do a couple of
39:34 - things so the first thing that i'm going
39:36 - to do
39:37 - is define a constant so
39:39 - i mentioned gravity before
39:42 - gravity is going to be a constant value
39:44 - just like it is in real life
39:47 - i'm going to define it to 20. or just
39:49 - some arbitrary value this is the value
39:50 - that i decided felt right but you can
39:53 - tune this however you want there's no
39:54 - right or wrong way to do it the less the
39:56 - gravity is the slower it'll fall and the
39:59 - more you'll feel like you're sort of in
40:00 - outer space or on the moon or whatnot
40:05 - we're going to also
40:06 - go ahead and
40:08 - define recall that we need some way to
40:11 - keep track of how our
40:13 - position is or how our bird is falling
40:15 - we want a velocity a y velocity this is
40:18 - going to update our position each frame
40:20 - and it's going to make it feel like
40:20 - we're falling so we're going to set our
40:23 - initial velocity to zero the burst is
40:24 - going to be in the middle it's not going
40:25 - to be falling yet
40:26 - what we want to do is apply this
40:29 - velocity
40:31 - so remember in our main file we had an
40:33 - up we assumed that we had an update
40:35 - function but we haven't actually
40:36 - implemented it yet so we're going to do
40:38 - that right now we're going to say
40:40 - word update dt it's going to we're going
40:42 - to pass it in the same dt that we use in
40:44 - our main file
40:47 - and we're going to go ahead and just say
40:50 - our velocity is equal to
40:53 - our current velocity
40:56 - plus
40:58 - gravity times delta time we're just
40:59 - going to scale gravity by delta time so
41:01 - it'll move the same amount no matter
41:04 - whether we're running at 10 10 frames
41:05 - per second or 60 frames per second
41:07 - and then we're going to go ahead
41:09 - we have a velocity but it's not actually
41:10 - changing our y value the y value is what
41:13 - ultimately moves us on the screen so we
41:14 - need to apply that uh our new delta y to
41:17 - our y so we're going to go ahead and
41:18 - just do
41:20 - that self.y gets self.y plus self.delta
41:23 - y d y
41:26 - and so if i go back into
41:28 - bird three
41:30 - assuming i saved everything we should
41:32 - just fall straight to the screen which
41:34 - we do not terribly useful
41:37 - but notice it it's kind of it's slightly
41:39 - hard to tell maybe but it does move
41:41 - faster and faster frame by frame because
41:43 - that delta y is increasing as well as
41:45 - our y and that that delta y is getting
41:48 - applied to our y frame by frame i'll do
41:50 - it one more time just let's find a look
41:51 - at all right so we have basic gravity
41:54 - super super basic computation just keep
41:56 - track of some gravity constant a delta y
42:01 - increase that and apply that to your y
42:03 - and that gives you gravity
42:05 - but flappy bird can jump so we need to
42:07 - define a way to defy gravity so we're
42:10 - going to do the in bird 4 we're going to
42:12 - call this the anti-gravity update and
42:14 - we're going to
42:16 - uh
42:17 - talk about how we can actually get that
42:19 - going so i found this diagram which i
42:20 - thought was pretty apt um and it also
42:22 - covers a few of the other concepts we're
42:24 - talking about today but see here this
42:26 - gravity that's the constant we just
42:28 - defined before the 20 or whatever and
42:30 - this gets applied at whatever value you
42:32 - want it to be this gets applied frame by
42:34 - frame to your y
42:36 - what we want is this this vector here
42:38 - this jump velocity
42:40 - we want some value
42:41 - to sort of counteract this gravity that
42:45 - we've been accumulating so how do we
42:47 - think we can go about doing this
42:51 - we can set gravity to some
42:54 - perhaps negative value a high value
42:56 - and that'll have the effect of
42:58 - frame by frame if we if we go from you
43:00 - know some positive value which is taking
43:02 - us down on the y-axis and we go to a
43:04 - negative value it's going to start frame
43:06 - by frame it's going to say let's say we
43:08 - start at negative 5 or we set its
43:10 - velocity to negative five
43:12 - it's going to set y to negative it's
43:14 - going to set it to plus negative 5
43:16 - pixels plus negative 4.9 pixels 4.8
43:19 - pixels it's going to shoot us up pretty
43:21 - fast in a series of pixels but since
43:23 - we're applying gravity frame by frame
43:25 - this value that we set before 20
43:28 - it's going to have the effect 20 times
43:30 - delta time so it gets effectively
43:31 - divided by 60.
43:33 - it's going to counteract this again so
43:36 - we're going to shoot up pretty fast but
43:39 - gravity is going to start taking hold
43:40 - immediately after and we're going to
43:41 - start getting
43:43 - the effect of our bird jumping and then
43:45 - falling down to the ground
43:47 - a couple of other things that this
43:48 - diagram shows which i thought were
43:49 - pretty cool
43:51 - this pipe gap or
43:53 - pipe gap distance here something that
43:55 - we'll be talking about pretty shortly
43:56 - because this needs to be defined so that
43:58 - we can offset our pipes
44:00 - pipe separation that's another thing
44:01 - we'll be talking about and also pipe
44:03 - width which is just an intrinsic value
44:04 - characteristic of the pipe sprite we'll
44:06 - be using but i thought it was a very apt
44:09 - nyu did a a nice little article if you
44:11 - want to look at this about exploring
44:12 - game space they computationally
44:14 - determined uh what would make a flappy
44:16 - bird level difficult or not and rated
44:18 - flappy bird levels that were dynamically
44:20 - generated based on some sort of scale so
44:22 - if you're curious it's in the slides but
44:24 - i thought it was a cool find as i was
44:26 - putting together this lecture
44:28 - so what we need to do is then simply add
44:31 - some negative
44:32 - value to gravity negative sort of
44:35 - anti-gravity so we're going to go ahead
44:36 - and do that so in bird four
44:39 - of the
44:40 - little mini ripa that i have here
44:46 - we're going to go ahead in main first
44:55 - one thing that we want to do
44:58 - is
44:59 - because another part of this is taking
45:01 - input from the user being able to jump
45:04 - we want to be able to
45:05 - detect whether they've pressed space
45:08 - but if we
45:09 - want to
45:10 - detect input for every single entity
45:13 - that we ever like in a game in an
45:15 - instance like this it's not terribly
45:17 - important
45:18 - but let's say we have like
45:20 - 20 or 30 different kinds of entities and
45:22 - they all have their own input handling
45:25 - we don't want to clobber maine with that
45:26 - necessarily so we can dedicate that
45:30 - delegate that i should say to another
45:33 - section of the code in this case we can
45:35 - sort of put our bird's input handling
45:37 - together with our bird class
45:39 - right and sort of expand up upon the
45:41 - model of the class or taking control of
45:44 - the code and data for that particular
45:47 - object in our scene
45:49 - so what we're going to do
45:52 - is
45:56 - in our
45:58 - love dot load
46:01 - i'm gonna go ahead and do
46:03 - something here i'm gonna go ahead and
46:04 - set i'm gonna go ahead and set
46:07 - love.keyboard.keys pressed equals a
46:09 - table and what i'm doing is just adding
46:12 - on
46:13 - to a table that love defines called love
46:16 - dot keyboard i'm adding my own value
46:18 - into it called keys pressed
46:20 - and i'm assigning it to an empty table
46:22 - so what we're going to do this is part
46:24 - of this is now part of what love gives
46:26 - us
46:27 - as part of its sdk but
46:30 - it's something that we've created
46:31 - ourselves and you can do this because
46:33 - in lua basically everything beyond basic
46:36 - variables or just tables and you can
46:38 - manipulate tables however you want in
46:40 - this case love.keyboard is a table i'm
46:42 - just adding a new key called keys press
46:43 - and i'm assigning it to an empty table
46:44 - of my own
46:46 - and we're going to see
46:47 - how this is actually used in just a
46:49 - moment
46:50 - so i'm going to go ahead in our key
46:52 - pressed function
46:54 - here
46:58 - this function gets called every time a
47:00 - user presses a key in the game but
47:04 - i'm going to use it
47:06 - because this because it does that
47:08 - i can go ahead and just do something
47:09 - like this
47:11 - love.keyboard.keys pressed
47:14 - key
47:15 - gets true
47:17 - and what that means is in this table
47:19 - that we've just defined we've created
47:20 - ourselves
47:22 - anytime the user presses any key because
47:24 - love.keypressed gets called for you
47:27 - we can safely rest assured that this is
47:28 - going to get populated no matter what
47:30 - key they've pressed because it's just
47:31 - something that love2d takes care of you
47:33 - but it's not getting stored until now
47:35 - now we're actually going to keep track
47:36 - of it in our own table
47:39 - for reasons that will become apparent
47:41 - very shortly
47:43 - the next part of this code
47:46 - is defining a custom function
47:49 - so the the impetus for this is
47:53 - love defines a couple of functions it
47:55 - defines a function called uh
47:58 - love.keyboard.isdown which takes in some
48:00 - key value and you can use it to test for
48:02 - continuous input which we did in the
48:04 - last
48:05 - the last lecture we're saying hey if up
48:08 - is down right now or down is down then
48:10 - we need to update our y velocity
48:12 - accordingly
48:13 - but it doesn't have a mechanism like
48:15 - this for let's say we want in some file
48:17 - other than main to check for if key was
48:19 - just pressed one time
48:21 - um it has this function love.keypressed
48:24 - which takes a key and that will trigger
48:25 - it but we can't access this outside of
48:28 - this function because if we define this
48:29 - function in bird.lua it's going to
48:32 - overwrite this implementation
48:34 - and we don't necessarily want to have to
48:36 - worry about other files overriding these
48:38 - functions because who knows if you're on
48:40 - a team especially who knows who's
48:41 - overwritten love.keypressed and what
48:43 - module and what order does it get loaded
48:44 - in and what function's actually valid
48:47 - we're going to take care of this problem
48:48 - by
48:49 - giving ourselves the ability to test for
48:51 - whether a key has been pressed on the
48:53 - last frame
48:54 - by
48:56 - implementing a function that we are also
48:58 - adding to the keyboard namespace the
49:00 - keyboard table ourselves called was
49:03 - pressed it's going to take a key
49:06 - and all it's going to do
49:08 - is check that table that we created
49:10 - before it's going to say if
49:12 - love.keyboard.keys pressed
49:14 - key then
49:18 - return true
49:21 - else
49:22 - return false and you could actually just
49:24 - return
49:25 - love.keyboard.keys pressed key and it'll
49:27 - be the exact same thing
49:29 - and so what this has the effect of doing
49:31 - is saying okay because on the update
49:34 - which we're about to see actually i
49:36 - should probably do that before so this
49:38 - all gets tied together
49:40 - um
49:41 - love dot at the end of love.update we're
49:44 - gonna do one last thing and that's reset
49:45 - that table
49:47 - because we wanna just check frame by
49:48 - frame
49:50 - so
49:52 - we have we have a table a global table
49:54 - that we've created to check for whether
49:56 - a key is pressed we have a callback
49:58 - function that love2td gives us that
49:59 - allows us to do that so every time a key
50:01 - gets pressed we're going to just add
50:03 - that key to that table and set it to
50:05 - true
50:07 - now we can just simply query that table
50:09 - anytime we want to with this function
50:10 - that we've created called
50:11 - love.keyboard.was pressed key which
50:14 - means on the last frame was that key
50:16 - pressed
50:18 - basically return whether it's true or
50:19 - false now the only problem is we're not
50:21 - flushing it we're not ever setting that
50:23 - to false that is the effect of if we
50:26 - just press all the keys in our keyboard
50:27 - those will always be false always be
50:29 - true
50:30 - until we reinitialize the table to some
50:33 - empty value which is what we do here on
50:35 - the update which takes place after all
50:37 - inputs been detected
50:39 - we're going to just set that table
50:42 - to an empty table again and on the next
50:45 - frame
50:46 - it's going to whatever keys we pressed
50:48 - those will get set to true and then we
50:50 - can just query that table here as needed
50:52 - and any update henceforth
50:55 - so does anybody anybody have any
50:57 - questions as to how this is operating
51:02 - and so the ultimate
51:04 - driving factor for us as to why we want
51:07 - to do this we want to put in the work to
51:08 - sort of keep track of this global input
51:10 - table
51:13 - is uh
51:14 - so that we can actually
51:16 - query input single key input
51:19 - based on
51:21 - or based in other files outside of
51:23 - main.lua because currently all we can do
51:25 - to check for single key presses is look
51:28 - in main.lua but that's not what we want
51:29 - to do
51:30 - we're going to go ahead
51:32 - and go to our bird.lua
51:36 - and in our update function this is where
51:39 - we actually get to use our efforts
51:42 - and say if love.keyboard.was pressed
51:47 - space
51:49 - which is the key that we want to
51:51 - actually allow us to jump
51:54 - go ahead and set self d y to what should
51:56 - we set self dot d y to when we press
51:58 - space bar
52:01 - should be a positive or a negative value
52:05 - a negative value
52:06 - we'll say it's negative five
52:08 - and we should probably define this as an
52:10 - anti-gravity constant up here but just
52:12 - for the sake of speed we'll say self.dy
52:14 - gets negative five
52:18 - and so
52:19 - and i did save that right i did save
52:21 - that i'm gonna go ahead and go into bird
52:23 - four
52:25 - go ahead and run this example
52:28 - and look at that
52:31 - we're jumping
52:32 - but we can still fall through the ground
52:34 - and we don't have any real gameplay but
52:36 - we've come a long ways now we've taken
52:38 - input single key input that we otherwise
52:41 - didn't have the ability to do in love2d
52:43 - and we've made it possible by just
52:44 - keeping track of our global input state
52:46 - and flushing it every update
52:49 - so does anybody have any questions as to
52:51 - how that works
52:53 - okay
52:55 - so
52:56 - the other big major visual component of
52:59 - flappy bird are these pipes that we see
53:01 - here on the screen we have
53:03 - two pipes there but the screen is filled
53:05 - with infinite pipes
53:07 - so
53:09 - does anybody have any instinct as to how
53:11 - we can implement this
53:16 - well we'll see before long but
53:18 - suffice to say we'll need a new sprite
53:22 - we'll need some sort of way of keeping
53:25 - track of when to spawn them
53:27 - because they sort of spawn you know
53:30 - after a period of time
53:32 - and that'll be sort of our gap
53:34 - and then what happened will happen if we
53:35 - just let it spawn forever and ever
53:42 - we do because if we don't do that after
53:43 - a certain period of time we're
53:44 - allocating memory for each of these
53:46 - pipes not a ton of memory
53:48 - um just you know essentially an x a y
53:51 - width and a height but
53:52 - because they all reference the same they
53:54 - will reference the same sprite image but
53:56 - given enough time eventually you're
53:58 - going to allocate a certain number of
53:59 - bytes that will exceed your computer's
54:01 - memory or the amount of allocated memory
54:03 - and you'll either hang infinitely or
54:05 - crash
54:06 - and so we want to destroy them as they
54:08 - go as well
54:11 - so we're going to go ahead and look at
54:14 - sort of the final live coded example
54:16 - just because from here on out it's going
54:18 - to be a little bit much i'm going to go
54:20 - ahead and go to
54:24 - main.lua first
54:30 - so
54:32 - just get my notes in order
54:35 - the first thing we want to do
54:37 - oh i'm actually in the wrong repo too i
54:38 - apologize i was in the district repo i
54:40 - want to be in the scratch repo
54:43 - so i'm going to go ahead go into main
54:50 - i'm going to require pipe now we don't
54:53 - have a pipe yet but this is a perfect
54:55 - example of how we can sort of
54:57 - keep abstracting our game we have
55:00 - a bird class but we should also probably
55:02 - have a pipe class because a pipe is a
55:04 - distinct type of entity in our game
55:05 - world we can sort of model it as a unit
55:08 - we can give it functions we can give it
55:09 - data and think about it in terms of it
55:12 - being a pipe not being a set of
55:14 - x y with height you know etcetera
55:17 - whatever whatever data you want to
55:19 - ascribe to it we can abstract that out
55:21 - and think in more abstract terms
55:23 - which will allow us to scale a little
55:24 - bit better so we're going to go ahead
55:26 - and assume that we have a pipe class i'm
55:28 - going to go ahead and go ahead and add
55:30 - it to our folder here right now so
55:32 - do a new file
55:35 - pipe.lua
55:38 - and i'm going to go ahead and reference
55:40 - my notes here for just a second
55:49 - go ahead
55:50 - and
55:52 - so the pipe class is actually quite
55:54 - simple
55:56 - just like the bird class was initially
55:59 - we don't need to keep track of a lot of
56:00 - data but we do want to keep track of a
56:03 - few things so the bird
56:06 - there's only ever going to be one bird
56:08 - out at once
56:09 - but with the pipes we're going to be
56:10 - spawning them over and over again and so
56:13 - if we allocate them
56:15 - out for each
56:16 - pipe that we instantiate if we allocate
56:18 - a new image
56:19 - this is probably not super efficient
56:21 - right we're using the same exact data we
56:24 - have a bunch of pipes we only really
56:25 - need one sprite
56:28 - so outside of the init function so just
56:31 - below where we're declaring that pipe is
56:33 - a class
56:35 - we're going to go ahead and create a
56:36 - local variable that is still scoped to
56:37 - this file
56:39 - but there's only ever going to be one
56:41 - copy of this object
56:44 - we're going to go ahead and call it
56:46 - say that we have pipe.png in this folder
56:50 - and this is sort of separated out from
56:51 - the functions that we're going to be
56:52 - defining in here but this has the effect
56:54 - of sort of creating a semi global
56:58 - graphics object even though it's
56:59 - contained within this this class file
57:02 - it's not accessible outside of this
57:03 - class file because we don't need it to
57:04 - be but it's also not being instantiated
57:07 - every single time because recall if we
57:09 - look at bird.lua
57:13 - here
57:15 - we're just setting it as self.image gets
57:19 - love.graphics.newimagebird.png this will
57:20 - have the effect of allocating a new
57:23 - image every time we create a bird object
57:25 - but we only ever create one bird object
57:27 - so it's not really an important design
57:29 - consideration for us to say maybe we
57:31 - should create a you know
57:33 - global semi-global
57:35 - image up here it's not
57:37 - it's not important in this in this
57:38 - context probably good style to do so
57:40 - anyway for larger projects but um just a
57:43 - consideration for here not really
57:45 - something we need to worry about but yes
57:47 - definitely
57:49 - try to take an asset and reference it as
57:52 - reference it rather than allocate it as
57:55 - many times as possible
57:57 - um
57:58 - we want our pipes to scroll so we need
58:01 - some sort of value just like we did with
58:02 - the backgrounds we need some value that
58:04 - keeps track of whether these pipes are
58:06 - scrolling and it can be a constant value
58:08 - we're going to directly call it negative
58:10 - 60 this time and not sort of negate it
58:12 - when we add it to our
58:15 - position later on
58:18 - so
58:19 - pipe scroll negative 60 we can just add
58:21 - it directly to our
58:22 - x or to our
58:24 - well yeah in this case just to our x and
58:26 - then we'll have the times delta time of
58:27 - course
58:28 - and
58:29 - that'll have the effect of shifting it
58:30 - left because it's a negative number
58:33 - we'll define the init function here so
58:35 - pipe init
58:37 - within the init function we're gonna do
58:39 - a couple of things so uh it's x where
58:43 - should the x be
58:45 - what should the x be set to
58:47 - let's say if we want the pipe to spawn
58:49 - beyond the right edge of the screen
58:52 - yep
58:55 - virtual width
58:57 - and you could you could also say virtual
58:58 - width plus some number if you wanted to
59:01 - because it's set to zero zero uh it's
59:03 - going to have the you won't see it on
59:05 - the frame that it gets instantiated
59:07 - but
59:08 - yes virtual width or virtual width plus
59:10 - some constant value or some value that
59:12 - you've uh allocated ahead of time we'll
59:14 - just set it to virtual width so as soon
59:16 - as the pipe gets initialized it will be
59:17 - invisible but it's going to be right on
59:19 - the right edge of the screen
59:22 - what about our y value
59:24 - first of all let's take a look at what
59:26 - the image looks like so we can
59:28 - see
59:29 - it's going to be in our
59:31 - i don't think i have the actual image in
59:33 - that directory so i'm going to come here
59:35 - when i grab the pipe this is what the
59:36 - pipe looks like
59:38 - let's see if i can expand it a little
59:39 - bit
59:44 - so it's kind of tall where should we
59:46 - probably place it if we want it to look
59:49 - sort of similar to flappy bird
59:54 - probably towards like the lower end of
59:56 - the screen
59:57 - we can get fancy with it too and we can
59:59 - even maybe make it randomized
60:02 - just like flappy bird so we'll go ahead
60:03 - and do that i'm going to go ahead and
60:04 - copy this
60:05 - and put it into our scratch folder here
60:10 - back in the init function i'm going to
60:11 - go ahead and set self.y too
60:14 - because
60:15 - we want to talk about procedural
60:16 - generation this will be sort of our
60:17 - first foray into how we randomize this
60:19 - we'll be using the function that we used
60:22 - last week and this is a ubiquitous
60:24 - function you'll see this everywhere and
60:25 - any framework or game engine you use
60:29 - math.random
60:31 - we want it to be
60:32 - the lower half of the screen so let's
60:34 - say
60:35 - virtual height divided by 4 is the upper
60:37 - bound and maybe virtual height minus
60:40 - 10. as the upper bound
60:44 - so that'll have the effect of setting it
60:46 - to
60:46 - roughly a quarter of the screen or sorry
60:49 - virtual height divided by 4 is towards
60:51 - the top end of the screen
60:53 - and then virtual height minus 10 is the
60:54 - lower end of the screen so it's actually
60:55 - going to cover
60:56 - anywhere from the first quarter below
60:58 - that down to about 10 pixels from the
61:00 - bottom
61:04 - i do it in main so in this file i
61:07 - am not sure if i did it for this
61:10 - demonstration it is definitely set in
61:12 - the repo
61:14 - the
61:16 - i don't think i said it in this example
61:17 - but yes you would set the random seed
61:19 - here if you wanted to run every time oh
61:21 - sorry and the question was do we uh
61:24 - should we set the random seed in the
61:26 - bird file or should we set it in
61:27 - main.lua typically you want to set it at
61:30 - the top level of your application so
61:32 - we're going to set it in um
61:36 - we're going to go ahead and set it in
61:37 - the
61:39 - in main
61:41 - and the
61:43 - function itself
61:45 - is
61:52 - here and i think it's starting in bird
61:53 - six onwards so it'll be
61:58 - uh
62:00 - did i not set it i may not have set uh
62:02 - the random seed until later in the repo
62:04 - let's check bird 12.
62:09 - so yes math.randomseed and then
62:11 - seedbyos.time as we used last week in
62:14 - class
62:16 - um i won't
62:18 - i'll set it here um
62:20 - probably will only run it once but it'll
62:22 - it'll have the effect now we can run it
62:24 - several times just to see the the
62:25 - difference in the pipes
62:27 - let's go back to
62:29 - our
62:30 - pipe.lua here
62:34 - and we have the x we have the y so those
62:37 - are set accordingly
62:39 - we also want to set the width does
62:41 - anybody recall uh
62:43 - what the function is to get a the width
62:45 - of a graphics object
62:50 - and the syntax for that
62:53 - so we have our image up here
62:55 - pipe image
62:56 - love.graphics.new image pipe.png
63:03 - exactly so we're going to go ahead and
63:04 - set this to pipe image colon get width
63:08 - and that will become our new that'll
63:10 - allow us to start with for when we um
63:13 - we will use it later
63:17 - um
63:18 - and then we need a few other functions
63:20 - so the pipe will spawn but it won't move
63:23 - because we haven't applied any sort of
63:25 - scrolling to it we have the scrolling
63:27 - variable up on line five but we need to
63:29 - actually apply it to our pipe so we're
63:31 - gonna go ahead and create an update
63:32 - function
63:35 - and then in that update function very
63:37 - similar to what we've seen before
63:39 - already
63:40 - pipe scroll times delta time
63:43 - and then lastly we want to render our
63:45 - pipe so we're going to go ahead and call
63:49 - function that we've seen already today
63:50 - love.graphics.draw we're going to use
63:52 - the pipe image
63:53 - up above
63:56 - and then we're going to go ahead and uh
63:59 - use self.x
64:01 - and self.y and that's all we need for
64:04 - our pipe
64:07 - and
64:08 - let me make sure that that's all we
64:09 - really need so in main.load we got to go
64:11 - back to main.lua too because we actually
64:12 - have to start spawning pipes
64:15 - um
64:17 - so let's go ahead and go to
64:21 - pull up my
64:22 - code here one more time
64:26 - in
64:27 - maine so on line
64:29 - 59 or sorry you won't see it you'll see
64:32 - it line 59 in the actual distro code but
64:34 - um
64:35 - for me it's going to be different
64:36 - slightly different
64:38 - we're going to go ahead and create a new
64:40 - table to keep track of all the pipes
64:42 - that we want to spawn
64:43 - because we need a way to store them in
64:44 - memory we can't just set you know one
64:46 - variable to
64:48 - basically a dynamic almost like a
64:49 - dynamic array in this case
64:51 - but we're going to or a linked list
64:53 - rather we're going to use this table
64:55 - just to hold them we're not going to
64:56 - give them keys we're just going to
64:57 - insert them like we would do with just a
64:59 - linked list like in python for example
65:03 - we're going to go ahead and
65:07 - what do we need to do if we want to
65:10 - sort of have them spawn after a certain
65:12 - period of time
65:16 - probably want to like have some sort of
65:18 - timer we want to like keep track of how
65:20 - much time has passed and maybe have some
65:22 - sort of amount of time that's our like
65:24 - trigger to spawn up a pipe let's say
65:26 - maybe like two seconds
65:28 - so
65:29 - if we set a timer to zero it's gonna
65:31 - start just at zero but we can add to
65:34 - this frame by frame we can just increase
65:36 - this timer by delta time whatever that
65:39 - is frame by frame it'll be about a 60th
65:41 - of a second
65:42 - so um
65:45 - after 60 frames have passed we'll get
65:46 - one second after 120 frames of pass
65:49 - we'll have two seconds at that point we
65:51 - can then decide okay now it's time to
65:53 - spawn a new pipe let's go ahead and do
65:54 - that
65:56 - so i'm going to go ahead and
65:57 - [Applause]
65:59 - in our
66:01 - update function
66:06 - we want to
66:08 - handle
66:10 - the actual
66:11 - increasing of this timer so
66:14 - it's as simple as
66:16 - make sure that i called it spawn timer i
66:18 - don't i just called it timer let's go
66:20 - ahead and call it spawn timer be a
66:21 - little more uh specific about what we
66:23 - want here so our spawn timer and then
66:26 - we're going to go ahead in our update
66:27 - and set spawn timer equal to
66:30 - spawn timer plus delta time
66:34 - and then
66:37 - what we need to do is then check
66:39 - is our spawn timer
66:41 - greater than because it keeps track of
66:43 - time in seconds delta time will give you
66:44 - a fractional amount in seconds so it'll
66:46 - be at .013 or something like that
66:49 - we want to keep track of whether spawn
66:50 - timer's gone past two
66:53 - right so if spawn timer
66:57 - is greater than two
67:00 - we want to
67:01 - add a new pipe does anybody remember the
67:03 - function for how to add to a table in
67:05 - lua
67:09 - so it's table dot insert
67:12 - so table dot
67:13 - will take in a table so in this case we
67:16 - want the pipes table that we allocated
67:18 - before
67:19 - and then we're going to put in a new
67:21 - pipe object we're going to call this is
67:23 - how you instantiate an object or call
67:25 - parentheses
67:26 - that will have the effect of now our
67:28 - pipes
67:29 - table
67:30 - is going to every time we call this it's
67:31 - going to get a new index so it's going
67:33 - to start at 1. lua tables are indexed at
67:35 - 1.
67:37 - first time it happens index 1 is going
67:39 - to be equal to a new pipe object which
67:42 - is going to start its x y at the edge of
67:44 - the screen
67:45 - then
67:46 - index 2 will be the exact same thing a
67:48 - new pipe that's at the edge of the
67:49 - screen and so on and so forth every time
67:52 - we call table.insert
67:56 - once our spine timer has exceeded two if
67:58 - we want this to not spawn a pipe every
68:01 - frame here after
68:03 - which would quickly clog up our uh our
68:05 - world we want to reset our spawn timer
68:07 - to zero so this will have the effect of
68:08 - now it's going to wait another two
68:10 - seconds
68:11 - and then this condition will be true
68:12 - again and then we can add a new pipe to
68:14 - the scene
68:18 - let's go ahead and look at
68:22 - a we're going to need to add a new um
68:27 - set of logic here actually i'm going to
68:29 - put all of this above
68:32 - the bird dot update
68:38 - and then below that i'm going to go
68:40 - ahead and do
68:42 - i'm not sure if we've covered this
68:43 - already don't think we have but if we
68:44 - want to iterate over a table there's a
68:47 - function that lua gives you called pairs
68:48 - it will give you all the key value pairs
68:51 - of a table
68:52 - that you can then use while you're
68:54 - iterating over it similar to enumerate
68:56 - and python if familiar except this will
68:58 - actually give you the keys
69:00 - rather than just the indices so we can
69:02 - do for k pipe in pairs of pipes
69:06 - do
69:10 - some body of code and then we have
69:12 - access to the key and the pipe within
69:14 - this we can just iterate over it and use
69:16 - it
69:17 - so first thing we want to do is we want
69:18 - to update our pipe
69:20 - so for each pipe update it give it the
69:22 - delta time of the current frame
69:26 - and then what was the other important
69:28 - feature so this will have the effect of
69:30 - scrolling it now it's going to get its x
69:32 - shifted but what was the other important
69:33 - thing we need to do with every pipe in
69:35 - our scene
69:42 - yes
69:43 - that is exactly true so what we're going
69:45 - to do is if
69:47 - pipe.x
69:49 - is less than
69:50 - so if we did less than zero
69:53 - what do we think would happen
69:57 - it would have it would we would see it
69:59 - instantly disappear because it's
70:01 - they're based on the top left coordinate
70:03 - so what we need to do is keep track of
70:06 - its width so what we'll do is we'll just
70:08 - say if pipe dot x is less than
70:11 - negative pipe dot width
70:14 - which will allow the pipe to go all the
70:15 - way past the edge of the screen
70:19 - we'll call a function called
70:21 - table.remove which takes a table in this
70:23 - case pipes
70:24 - and then it takes a key and the key we
70:27 - have access to up above on line 124 we
70:29 - can just say
70:30 - k and that'll have the effect of
70:32 - removing that pipe from the scene
70:36 - and then as soon as that's done uh
70:39 - we're good to go the last thing that we
70:41 - need to do
70:42 - is currently we're not actually drawing
70:43 - the pipes to the screen so
70:45 - down below in our render function we're
70:48 - going to go ahead and up above before we
70:51 - do the ground
70:52 - because if we do it normally if we do it
70:55 - after we we render the ground it's going
70:57 - to the pipes are going to look like
70:58 - they're just kind of like layered on top
70:59 - of the ground we want it to look as if
71:01 - they're sticking out from the ground so
71:03 - what we want to do
71:04 - is have a correct render layer a render
71:07 - draw order to the screen we draw the
71:08 - background we draw the pipes then we
71:10 - draw the ground and this will have the
71:12 - effect of looking as if the pipes are
71:13 - sticking out of the ground so what we'll
71:15 - do is we'll do the exact same thing we
71:17 - just did up above
71:19 - by saying for k
71:20 - comma pipe in pairs of pipes
71:24 - do
71:29 - uh pipe and then the render function
71:31 - that we defined in pipe and also the
71:33 - effect of iterating through all the
71:34 - pipes in our scene every draw call
71:37 - and drawing them before it draws the
71:39 - ground and before it draws the bird and
71:41 - that should be all that we need to
71:43 - illustrate this example make sure
71:45 - everything is saved i'm going to go
71:46 - ahead and go into bird five
71:50 - if i did everything correctly this
71:52 - should
71:54 - after a certain period of time
71:56 - draw pipes to the screen that are
71:58 - scrolling and they're randomized their y
72:00 - value is getting set to
72:02 - some value between the top quarter of
72:04 - the screen so about starting right about
72:06 - right where flappy bird is right now
72:08 - down to about 10 pixels above the width
72:11 - of the screen which actually that looks
72:12 - like 10 pixels above so that's a slight
72:13 - bug should probably be something along
72:15 - the lines of 30 or 40.
72:17 - we won't encounter that in the final
72:19 - distro because they're not set to spawn
72:21 - that low
72:22 - but you can see how this is sort of the
72:25 - beginning of our procedural level
72:27 - generation system
72:28 - and we have most all the components of
72:30 - our scene now
72:32 - we get normally in flappy bird we have
72:34 - two pipes we have a pipe that's above
72:37 - and then a pipe that's below and they're
72:38 - sort of in pairs and the next example
72:41 - we're actually going to start
72:41 - illustrating this we're going to have
72:42 - pairs of pipes that are joined together
72:45 - which scroll together that once you fly
72:47 - through them you score a point
72:51 - but for now we sort of have all the
72:52 - pieces that we need in order to get uh
72:55 - you know
72:55 - sort of have the basic visual
72:58 - uh sense of the game completed we're
73:00 - going to take a like a five minute break
73:02 - now and then once we come back we'll
73:04 - actually dive into how we can get pairs
73:06 - of pipes into our scene and may start
73:08 - getting into scoring and some other fun
73:09 - things like music so
73:13 - all right welcome back so the next part
73:16 - so before we establish the
73:18 - bird the background the pipes we have
73:20 - all the visual aspects of our game
73:22 - sorted ready to go
73:23 - the next important piece of the puzzle
73:25 - to really solve is how can we start
73:26 - scoring
73:28 - our game and also how can we get the
73:29 - pipes matching the way that they are
73:31 - implemented in the actual game which
73:33 - recall they're
73:35 - normally in pairs as illustrated here
73:38 - and we also see on the right hand side
73:40 - as we've covered already so far we have
73:41 - the spawn zone for our pipes and on the
73:43 - left we have what i've labeled the dead
73:45 - zone where pipes are sort of
73:46 - de-instantiated
73:48 - once they've gotten past the negative
73:51 - width of themselves but pipes come in
73:53 - pairs they get shifted and the once the
73:56 - bird flies between these gaps is
73:59 - ultimately when they've scored a point
74:00 - and so we need a way to pair pipes
74:02 - together and sort of
74:04 - uh define this sort of logic for how can
74:07 - we tell whether the bird has gone past
74:09 - the the gap and whether or not
74:12 - the pipes have been de-instantiated so
74:15 - we're going to go ahead and i'm going to
74:17 - probably stop live coding for the rest
74:19 - of the demonstrations because they're
74:21 - going to be a little bit more complex
74:23 - but
74:25 - i believe my code editor is over here
74:28 - i'm going to go ahead and open up
74:30 - oh this is my other editor okay so in
74:33 - the base repo now we're going to go
74:35 - ahead and look at the full example so in
74:37 - bird six which is the pair uh pipe pair
74:40 - update our current subfolder that we're
74:42 - looking at
74:44 - we're going to start in main so on line
74:46 - 33
74:49 - in main
74:51 - we can see that we're requiring pipe
74:53 - pair which is a new class we're defining
74:55 - we're taking the pipe that we had before
74:58 - and we're sort of creating a new
74:59 - composite class we're going to take a
75:01 - class that sort of encapsulates two
75:03 - pipes together a pair of pipes and we're
75:05 - going to use this to think about our
75:07 - problem more abstractly than we already
75:09 - are and this sort of layering of
75:11 - abstractions is a very important um
75:13 - concept in computer science generally
75:14 - speaking but especially in games where
75:16 - you might have objects that are
75:18 - composites of objects that are
75:19 - composites of objects and these abstract
75:21 - hierarchies are sort of what keeps
75:23 - programmers sane when dealing with such
75:24 - um you know large levels of i mean you
75:27 - have thousands of lines of code sort of
75:28 - the only way you can really make sense
75:30 - of it
75:32 - so on line 65 if we look now instead of
75:36 - a table that's called pipes where we've
75:37 - renamed it to pipe pairs we're no longer
75:39 - going to store individual pipes in our
75:41 - scene we're going to sort of take these
75:42 - pipe pairs that we're going to create
75:44 - and store them
75:46 - in our table as well as whole as like
75:48 - individual units
75:51 - on line 71 we need a variable to keep
75:54 - track of the uh we're calling it last y
75:58 - the purpose of this variable is so that
76:00 - we can keep track of where the last set
76:02 - of pipes sort of spawned their gap right
76:04 - because we if we made our gaps
76:06 - completely random
76:07 - it will have the sort of effect of
76:11 - not looking continuous for one and also
76:13 - potentially being impossible to beat we
76:15 - want some sort of
76:16 - smooth
76:18 - so contour to our gap so that we can fly
76:20 - through them reasonably and that it
76:21 - looks as if it was almost pre-made and
76:23 - smooth so we're going to keep track of a
76:25 - variable called last y we're going to
76:27 - start it off at negative pipe height
76:30 - so
76:31 - up past the top of the screen plus some
76:33 - sort of value
76:35 - between
76:36 - between 1 and 80 and 20. so it's going
76:38 - to be it's going to be roughly towards
76:39 - the top of the screen
76:42 - and this is important because last y is
76:45 - going to be we're going to end up
76:47 - flipping our sprite and
76:49 - a
76:50 - flip on the y-axis has the result of the
76:53 - sprite sort of looking as if it's gone
76:56 - its whole
76:57 - height above where its actual y is and
76:59 - we'll see um in more detail shortly why
77:02 - this ends up working the way it does
77:05 - we're going to go down to line 132
77:12 - and in our sort of condition if our
77:15 - spawn timer is greater than two
77:18 - um what we're going to do is this is
77:20 - where we spawned our pipes before but
77:22 - now we're spawning pairs of pipes
77:26 - so
77:26 - we're going to set a local variable y
77:29 - it's going to be
77:31 - this is the the clamp operation that we
77:32 - talked about sort of last week using
77:34 - math.max and math.min to sort of com
77:36 - like apply some sort of operation in
77:38 - this case we're going to add a random
77:40 - value between negative 20 and 20 to
77:42 - whatever our last y value was which is
77:44 - going to shift the gap effectively by
77:46 - negative 20 or 20 pixels
77:49 - we're going to clamp it between negative
77:50 - pipe height plus 10 so about 10 pixels
77:54 - from the top of the screen
77:56 - and then uh
77:57 - we're gonna set the upper bound to
78:00 - virtual height minus 90 minus pipe
78:03 - height and this minus pipe height is
78:05 - only because we're doing a flip
78:07 - operation on our y-axis for our sprite
78:09 - i'll go into it in a little bit more
78:11 - detail sort of try to
78:13 - make it clear as to why we're doing it
78:14 - and maybe i'll take out
78:16 - some codes to illustrate what it looks
78:17 - like without that operation applied
78:20 - but basically it has the effect of 90
78:22 - pixels from the bottom is where the pipe
78:24 - could
78:25 - the gap could spawn
78:26 - so basically the pipe at the very bottom
78:29 - recall that this gap is where the this
78:31 - uh value is where the the gap itself
78:34 - begins not necessarily where the pipe
78:35 - starts
78:38 - it'll be between negative pi pipe plus
78:40 - 10
78:41 - between negative basically effectively
78:44 - between 10 pixels from the top of the
78:45 - screen between negative or between 90
78:48 - pixels from the bottom of the screen
78:50 - and then we're going to apply
78:52 - a random
78:54 - permutation of this value we're going to
78:55 - add some value between negative 20 and
78:57 - 20 and that will sort of give us a
79:00 - contour and it'll be sort of a
79:02 - randomized contour
79:06 - line 136 we have pipe pairs table insert
79:10 - into that instead of pipes and we're
79:12 - just adding a new pipe pair and we're
79:14 - setting it to uh that the value y
79:17 - and then this the pipe pair takes in a y
79:20 - value and that'll be where the start of
79:22 - the gap is and what what this will have
79:25 - the effect of doing is it's going to
79:26 - flip a sprite above the gap so that we
79:30 - have a pipe right above where the gap
79:31 - starts and then it's going to draw
79:33 - another pipe unflipped about 90 pixels
79:36 - below that and that will be how it sort
79:38 - of puts the two together
79:42 - line
79:43 - 144
79:46 - is a loop that just updates our pairs
79:48 - instead of our pipes so we've just all
79:49 - we've done here is just renamed it from
79:51 - pipe to pair and we've instead of pipe
79:54 - instead of pipes we're using pipe pairs
79:57 - we're doing the same exact thing here
79:59 - one on line 153
80:01 - we've done 4k pair in pairs of pipe
80:03 - pairs
80:05 - and then line 150
80:08 - sorry line 175
80:10 - is where we are or sorry 170 is where we
80:13 - are rendering each
80:15 - pair instead of each pipe and so if we
80:18 - open up
80:19 - pipe pair here
80:22 - we can take a look at this class from
80:24 - scratch so it's a new class we're going
80:26 - to set our gap height to 90 pixels and
80:29 - so this is just some arbitrary value
80:30 - that i felt was like a pretty fair value
80:33 - in terms of size but you could tune this
80:34 - to whatever you want you could set this
80:36 - to
80:37 - if you want to be really cruel you could
80:38 - set it to something like 50 or if you
80:40 - wanted to be really generous to the
80:42 - player you could set it to something
80:43 - like 150 and make it fairly easy for
80:45 - them to get through or as part of the
80:47 - assignment you could randomize it so
80:49 - that the uh
80:50 - so that it varies uh you know pair by
80:53 - pair and you get more of an organic
80:55 - looking obstacle course still shifted by
80:57 - negative 20 to 20 pixels but now your
80:59 - gap varies and you can also randomize
81:02 - the shift amount if you wanted to as
81:03 - well let's say you wanted maybe the
81:05 - maybe you want the gaps to be
81:07 - up to 40 pixels difference instead of 20
81:10 - pixels difference on negative and
81:12 - positive value you could easily do that
81:13 - as well
81:17 - on line 18 we're just setting our x to
81:20 - just like we did before virtual width
81:21 - plus 32 so we're setting it to the uh
81:24 - actually before we just set it to
81:26 - virtual width now we're setting it to
81:27 - virtual width plus 32
81:29 - both are
81:30 - pretty much equal this will just give it
81:32 - a little bit of a delay before it ends
81:33 - up going onto the screen but you could
81:36 - effectively just do this virtual width
81:40 - the on the next line 24
81:44 - this is where we sort of bundle together
81:47 - the pipes that we're going to end up
81:49 - actually rendering and updating to the
81:51 - screen instead of having just one pipe a
81:54 - pipe pairs two pipes we can easily put
81:56 - this together in a table so we'll just
81:58 - create self.pipes we'll set it to a
82:00 - table that has two keys upper and lower
82:03 - and the upper pipe is just a pipe
82:06 - and notice one thing is different about
82:08 - pipe now before it took no arguments it
82:10 - was just a regular pipe pipes had their
82:12 - own logic they set their own x and y
82:15 - they didn't need any sort of you know
82:17 - parameterization beyond that it was all
82:19 - taken care of for them randomly
82:22 - now they take a string
82:24 - so this top string means that this would
82:26 - be a top pipe so that means that if this
82:29 - pipe is a top pipe there's probably
82:30 - going to be logic and pipe that now
82:33 - checks to see whether it's top or bottom
82:35 - if it's top
82:37 - then we need to render it upside down we
82:39 - need to flip it along the y axis
82:42 - and then we're going to set it to self.y
82:46 - and recall that we set self.y we passed
82:50 - in
82:50 - self.y in main actually i'm not sure if
82:53 - i touched on that let's go back to main
82:55 - here so if we go to
83:02 - figure out where i actually instantiate
83:05 - by the pipes
83:07 - here on line 136 after we've calculated
83:10 - where we want the gap to be for this
83:12 - pipe pair we're going to go ahead and
83:13 - insert
83:15 - into pipe pairs a pipe pair at y why was
83:18 - the calculation um between we basically
83:20 - took the last um
83:24 - y value the last gap that we
83:26 - instantiated and then shifted it by some
83:28 - negative 20 to 20 pixels randomly and
83:31 - made sure it didn't go above or beyond
83:33 - above or below the edges of the screen
83:36 - the
83:38 - back and pipe pair
83:40 - we're going to go ahead and look at
83:43 - line
83:45 - 30 or sorry actually we'll let's take a
83:47 - look a little bit more closely here at
83:49 - line 26.
83:50 - so upper gets top and self.y that's
83:53 - where the gap is and that's the sprite's
83:55 - going to be flipped upon that
83:58 - value
83:59 - the lower value is going to be a shift
84:02 - of that so the lower sprite needs to
84:04 - spawn
84:05 - below
84:07 - the top pipe by the gap amount so that
84:10 - the two are sort of you know top to
84:12 - bottom but there needs to be that space
84:13 - between the two of them so we need to
84:15 - take that pipe shift it down and then
84:16 - draw the next pipe so we're going to
84:19 - take self.y
84:21 - plus pipe height
84:22 - plus gap height
84:25 - and that'll have the effect remember gap
84:26 - height was 90 pixels
84:29 - the pipe height is a result of sort of
84:32 - flipping the uh the y ax the y-axis and
84:36 - having to shift it down the actual um
84:38 - position
84:40 - so if we go back to
84:43 - um
84:47 - line 30.
84:49 - so this is a
84:51 - this is an interesting sort of
84:53 - uh
84:55 - illustration of what happens when you
84:57 - edit a table while you're iterating over
84:59 - a table and i'll show you this in detail
85:01 - shortly but basically on line 30 we're
85:03 - setting a flag called remove to false
85:05 - and what this is going to do
85:06 - is before we were just destroying the
85:08 - objects whenever it got past the edge of
85:10 - the screen we just destroyed it but if
85:12 - we're iterating over a table of values
85:15 - let's say a table of pipe pairs
85:18 - when you do a removal in
85:22 - most programming languages in lua when
85:24 - you do a removal of a table of a table
85:26 - value and it's non-indexed or it's
85:29 - non-keyed which means that it's indexed
85:30 - by
85:31 - you know numerical indices this will
85:33 - shift every other value down and so when
85:36 - you're iterating it and you shift
85:38 - everything down the value you are
85:40 - currently manipulating let's say it's
85:41 - equal to one
85:43 - if you remove that value you shift
85:46 - everything beyond it down by one
85:48 - but then you're going to increment up to
85:50 - two and you're skipping over what was
85:52 - previously just two and is now one
85:55 - so you see effectively skipping over one
85:57 - of your entries and that has buggy
86:00 - behavior and a lot of
86:01 - scenarios in this case it causes the
86:03 - graphics to sort of glitch a little bit
86:06 - because it doesn't apply a uh a pixel
86:08 - shift on one frame and so
86:11 - as pix as whenever a pipe gets removed
86:14 - and i can actually show this visually uh
86:16 - the first pipe left after that table of
86:19 - that pipe gets removed ends up moving a
86:21 - little bit to the right and so you get
86:22 - weird pipes shifting to the left of the
86:24 - bird on each frame so
86:26 - whenever you edit a table in place
86:29 - make sure not to delete while you're
86:30 - iterating over it it's going to cause
86:32 - buggy behavior
86:34 - and like i said i'll show you i'll
86:36 - illustrate this for you
86:38 - very shortly
86:40 - on line 36
86:42 - we are
86:44 - performing the update logic now a pipe
86:46 - pair has two pipes each with their own
86:49 - render components and their own
86:51 - positions we we're using the code that
86:53 - we wrote before for pipe and we're going
86:55 - to try to expand upon it a little bit so
86:57 - we want to defer we still want to defer
86:59 - a lot of that code to
87:02 - uh the pipe class and we want to update
87:05 - the pipes based on um
87:09 - whether they we want to still keep track
87:11 - of their own x and their render
87:12 - functions and so we're going to see if
87:15 - uh basically if our
87:17 - pipe pair x
87:19 - is greater than negative pipe width
87:20 - which is the same exact logic that we're
87:22 - using before
87:24 - set our own x
87:26 - to
87:27 - um
87:29 - the
87:31 - that minus pipe speed times delta time
87:33 - which is the same operation we were
87:34 - doing before but we are also
87:37 - editing the x of our self.pipes lower
87:41 - and upper and this will allow us to on
87:44 - line 46 render the pipes just as we were
87:47 - doing before because they're getting
87:48 - their x values updated just as they were
87:50 - before so we're effectively deferring
87:53 - the render phase to our pipes and not
87:55 - really needing to add any additional
87:57 - logic for that in our code
88:01 - if we've made changes to pipe.lua as
88:03 - well so i'm going to go ahead and open
88:05 - up pipe
88:08 - here
88:10 - whoops
88:14 - and
88:17 - we've set the height and width of it as
88:19 - constants here so pipe height gets 288
88:22 - and that happens to be about the size of
88:23 - the screen
88:24 - pipe width gets 70.
88:28 - on 31 we're setting self.orientation
88:31 - gets orientation notice our init
88:32 - function which was previously just empty
88:35 - it took no parameters now takes an
88:36 - orientation and it takes a y value the
88:38 - orientation is going to be going to
88:41 - allow us to say to ask
88:43 - basically is our code a top pipe or a
88:45 - bottom pipe and if it's top pipe we need
88:47 - to flip it draw it and shift it
88:49 - if it's a
88:51 - bottom pipe we're just going to draw
88:52 - normal and not perform any sort of fancy
88:55 - you know sprite flipping or anything
88:57 - like that
88:58 - down here on the render function is
88:59 - where this actually happens
89:01 - so on line 39 we're drawing the pipe
89:04 - image as usual at x but
89:07 - at y
89:08 - because
89:10 - when you flip a sprite it ends up
89:13 - completely uh
89:15 - flipping the white but it basically
89:16 - performs a mirror on it but it not at
89:18 - zero zero it it basically
89:21 - shifts it up by pipe height amount we
89:24 - need to keep track of that and draw it
89:27 - at
89:28 - self.y plus pipe height because if we
89:30 - draw it at just self.y
89:32 - because it's going to be mirrored and
89:34 - it's going to get shifted by pipe height
89:36 - amount it's going to be beyond the top
89:37 - edge of the screen and we we need to
89:39 - account for that account for the fact
89:41 - that we're flipping it on the y-axis and
89:43 - bring it down
89:47 - the code where we the question is
89:48 - where's the code where we flip it so
89:49 - that's actually here on this line
89:52 - on this condition we're saying
89:54 - if self.orientation is equal to top
89:57 - then we want to so the parameters here
89:59 - i'll comment this just for clarification
90:05 - it does uh and i'll show you here so
90:07 - this is zero we've added a few new
90:08 - parameters to our love.graphics.draw
90:11 - function 0 is rotation we're not going
90:13 - to rotate it at all this is the scale on
90:16 - the x axis so x scale and this is the
90:19 - scale on the y-axis so if we apply a
90:22 - scale operation of one it's the same
90:24 - thing as applying no scale like doing no
90:27 - scale at all it's just gonna draw it on
90:29 - the x-axis it's just gonna draw it
90:30 - normally but
90:32 - if it's top
90:34 - if where if this pipe has been set to an
90:36 - orientation of top
90:38 - we need to we're going to set the scale
90:40 - to negative one when you set a sprite
90:43 - its scale factor to negative one it
90:46 - flips it along that axis effectively
90:48 - and so that's how you get mirroring in
90:51 - most engines that allow you to sort of
90:53 - apply scale operations to 2d textures or
90:55 - 2d sprites a negative operation on an
90:58 - axis will mirror it on that axis and so
91:01 - that's what we're doing here so we're
91:02 - mirroring it
91:03 - um if it's a top pipe and we're also
91:06 - shifting its draw location as well
91:08 - because when we mirror it it's going to
91:10 - at 0 0 it's going to do the same it's
91:12 - going to
91:13 - basically draw the same exact thing but
91:15 - mirror it on the y-axis so it's going to
91:17 - need if we want to draw at a given
91:19 - location flipped like still draw it at 0
91:21 - 0 but have it be flipped we need to
91:23 - account for that flip and shift it
91:25 - downwards if that makes sense
91:29 - so that's essentially all that's
91:31 - involved there
91:33 - and i think that's pretty much all of
91:36 - the
91:37 - code so we have our
91:39 - pipes now that are being uh when it's
91:41 - flipped if it's a top pipe it's going to
91:42 - get drawn shifted it's going to have its
91:45 - other pipe shifted down by that amount
91:47 - and set to negative or set and increased
91:50 - uh
91:51 - its y-axis is going to be increased by
91:53 - the gap height so that it gets drawn you
91:54 - know 90 pixels however many pixels you
91:56 - want to set below that pipe so we're
91:59 - going to go into
92:01 - demonstrate this go up to
92:06 - 50 bird the actual repo now and the
92:08 - actual distro code i'm going to go into
92:11 - bird six
92:12 - and i'm going to run it
92:14 - whoops
92:16 - and now we have pipes that are actually
92:17 - rendering
92:19 - but
92:20 - we're missing a couple of important
92:22 - things
92:24 - foremost among them being that now we
92:26 - don't have we don't have collision
92:27 - detection yet so we can just fly through
92:28 - this course you know infinitely but
92:30 - notice that they're being shifted by you
92:32 - know random value between negative 20
92:34 - and 20 pixels
92:37 - it looks more or less like it's being
92:39 - generated
92:40 - with some sort of goal in mind it's it's
92:43 - not you know haphazard it's not all over
92:44 - the place but you could easily find ways
92:46 - to tweak this such that you know maybe
92:49 - the gap height is some value between you
92:51 - know 60 and 120 and so you have
92:54 - easy and difficult pipes or maybe you
92:56 - have
92:57 - i think i'm so far below the screen that
92:59 - i can't even get back up anymore but
93:01 - uh
93:02 - oh okay i just that's
93:04 - physics error and when you when your
93:06 - value gets to a certain point i think
93:08 - that's actually uh what it's doing is
93:10 - actually overflowing the value and
93:12 - setting it to a negative or underflowing
93:14 - it and saying it to a negative value and
93:16 - then uh incrementing it
93:18 - because it's gotten so large
93:19 - but
93:20 - the uh but you could easily
93:23 - modulate parameters such as the width
93:25 - between the pipes as we saw on the
93:26 - diagram before or the or the height or
93:29 - even the speed at which they move and
93:31 - find ways to you know tune it to
93:33 - make gameplay that actually
93:35 - works
93:37 - for whatever goal you have in mind
93:38 - making it easier or more difficult and
93:40 - that's actually a topic that they talked
93:41 - about in that article that i linked to
93:42 - before where they generated levels
93:44 - programmatically and then tested them
93:45 - programmatically to determine what makes
93:47 - a level in flappy bird difficult or easy
93:50 - and so
93:51 - basically that's
93:54 - those are the parameters you need to
93:55 - sort of weigh as you're thinking of
93:57 - procedural generation and procedure
93:58 - generation ultimately is just taking
94:00 - values that you construct your scene
94:02 - with and just finding ways to just
94:03 - manipulate them
94:04 - randomly math.random some value and
94:07 - that's how you make random levels
94:09 - in a nutshell
94:11 - making good random levels is another
94:14 - question
94:14 - but
94:15 - uh
94:18 - he did he did there was a big
94:20 - controversy around this game back in
94:21 - 2013 but
94:24 - uh i didn't know if i read too much into
94:26 - that but i i was doing a little bit of a
94:29 - little bit of research and was reading
94:30 - about some of that stuff but i mean got
94:32 - to give them props for you know banking
94:34 - on that
94:37 - but yeah that's you know now we have
94:39 - pipe pairs that's arguably the most
94:40 - complex part of the program because
94:44 - going forward now
94:45 - as we get into collision and some more
94:47 - concepts collision is actually something
94:49 - that we touched on last week and it's
94:51 - all basically the same stuff
94:54 - so if we go into bird seven
94:57 - uh the next iteration of our application
95:00 - i'm going to go ahead and open up
95:01 - main.lua
95:07 - and then we're going to go to
95:09 - line
95:12 - 74. and um in order to test collision
95:17 - we don't we don't have scoring in place
95:18 - yet but we need some way to just to
95:20 - determine oh we we collided with the
95:22 - pipe we need some sort of feedback so
95:24 - what we're going to do is
95:26 - i've just decided we should just pause
95:27 - the game so once we once we collide with
95:30 - the pipe let's just pause instantly so
95:32 - we know immediately oh we collided with
95:33 - a pipe so i'm going to set some variable
95:35 - called scrolling at the top of the
95:37 - program in main to true it's going to
95:39 - we're scrolling we're going to start
95:40 - scrolling
95:41 - but when i don't want to scroll anymore
95:43 - when i want to pause the game this
95:44 - should get set to false
95:47 - so
95:48 - on line 120
95:52 - if scrolling
95:53 - then do all of this update logic that we
95:56 - did before
95:58 - and then at the very end of that we're
95:59 - resetting our input table so we can
96:01 - still take input but no updates will
96:03 - take place if scrolling is set to false
96:05 - all of this stuff is within this
96:08 - if excuse me if scrolling then so very
96:11 - simple just encapsulate it all within
96:12 - some variable that we can turn on and
96:14 - off
96:16 - and then on 152
96:19 - within that chunk of code that is being
96:23 - sort of contained within that if
96:24 - condition we're just doing a very simple
96:27 - iteration
96:28 - for each pipe
96:30 - it should be for l pair in pairs of uh
96:33 - oh no sorry for every pipe in
96:36 - the pairs of
96:38 - uh it's a nest it's a nested for loop in
96:41 - this case so basically within the the
96:42 - loop that looks over every single pair
96:45 - to update it
96:46 - we're doing another loop that's looping
96:48 - through with the pipes in that pair so
96:49 - it's only a loop of two iterations with
96:52 - the upper and the lower pipe we could
96:53 - just also say if bird collides with
96:57 - upper
96:58 - basically if pair dot upper pair dot
96:59 - lower or peridot pipes upper paired up
97:01 - pipes down lower but this is a little
97:03 - cleaner it's more scalable we can add
97:05 - more pipes if we want to even though it
97:06 - wouldn't happen
97:07 - but for every pipe in peridot pipes
97:11 - we have a function here that we haven't
97:12 - defined yet called bird collides so if
97:15 - bird collides pipe so it takes in a pipe
97:18 - so is going to return a true or false
97:20 - value we know that
97:21 - set scrolling to false so we collide
97:24 - scrolling set to false
97:25 - update logic is going to get shut off
97:27 - completely so we're going to have the
97:28 - effect of pause in the game
97:31 - we're going to go into
97:32 - bird.lua right now we're going to
97:34 - actually see how we implement this and
97:36 - it's going to look very familiar
97:38 - to what we did last week so in bird.lua
97:44 - this function here
97:46 - from 29 down to 45 it's just an aabb
97:48 - collision detection test that we did
97:50 - last week we're just checking to make
97:52 - sure any edges are you know right edge
97:55 - make sure that is
97:57 - to the left of the right edge of the
97:59 - second box bottom edge of box one should
98:02 - be our bottom edge of box one should be
98:03 - above bottom edge or top edge of box two
98:06 - if all these things hold true
98:08 - then return true
98:10 - else return false which means we have a
98:11 - collision
98:12 - and notice that i've shifted everything
98:14 - here by
98:16 - a couple of constant values does anybody
98:18 - have any instincts so why i'm saying
98:20 - self.x plus 2 instead of just self.x or
98:24 - self.with minus 4 why we're checking for
98:27 - that offset for the bird in this case
98:30 - when it is compared with the pipe
98:34 - it's not quite half it's a few pixels
98:36 - smaller do we know why we want to do
98:38 - this why we want to like we're basically
98:40 - shrinking the box why would we want to
98:42 - shrink the box
98:49 - so not quite so there isn't an actual
98:52 - gap between the drawing it's more of a
98:54 - question of
98:55 - how much do we want to frustrate how
98:57 - much do we want to frustrate our users
98:59 - right if if we're pixel perfect
99:02 - colliding with the pipes
99:04 - you know there's there's no give and
99:05 - take it's like you you collide and even
99:08 - if it might even look as if you're not
99:09 - even colliding with the
99:11 - pipe and you're still getting a
99:12 - collision your users are thinking well
99:14 - that's not fair that's really harsh
99:16 - we're shrinking our box so that you know
99:18 - even if they're just like a pixel off
99:19 - they'll still get a little bit of leeway
99:21 - and it'll be a little bit
99:23 - less strict in terms of the collision
99:25 - and this is a very common thing in games
99:27 - when you have
99:28 - characters whose sprites may not
99:30 - necessarily fill the entire box that
99:32 - you've allocated for them even though
99:34 - you're doing box collision just give
99:35 - your users a couple pixels
99:37 - deep however however many you want and
99:40 - they can overlap with whatever they're
99:42 - colliding with just a tiny bit before it
99:44 - actually
99:44 - triggers a true on the collision and it
99:46 - makes your game feel more forgiving and
99:48 - then also more fun as a result of that
99:51 - so that's why we have where instead of
99:53 - testing directly on x0 of that box we're
99:56 - testing x plus two and then self.with
99:58 - minus four because when we shift we add
100:01 - width to a plus two value we need minus
100:03 - four so that we get two off the right
100:05 - edge and same thing goes for the height
100:07 - and the y value
100:09 - and so this just performs aabb collision
100:11 - detection
100:13 - expects a pipe which
100:15 - means that we need to ensure that that
100:17 - pipe has an x and a y a width and a
100:19 - height which it does actually just a
100:21 - constant here we're just checking pipe
100:23 - width and pipe height we probably
100:24 - shouldn't do that it should be pipe dot
100:27 - width pipe dot height in that case
100:29 - because then this couldn't necessarily
100:30 - just be a pipe it could be anything in
100:32 - our scene that has a xy a width and a
100:34 - height it could be a general purpose
100:36 - collision and actually something you can
100:38 - also do if you wanted to is just write a
100:40 - function called collides that takes in
100:43 - two two things that you know have
100:45 - bounding boxes and will allow you to
100:46 - perform closing detection on anything in
100:48 - your scene any between any two entities
100:50 - that would be a
100:52 - more
100:52 - scalable way i guess of dealing with it
100:54 - rather than necessarily having it
100:56 - specifically defined as birds and pipes
100:59 - being the colliders but in this case
101:00 - this is the only thing we're really
101:01 - colliding with except from the ground
101:03 - but when you collab with the ground all
101:04 - you need to do is just check to see
101:05 - whether your y position plus uh your
101:09 - height has gone below the edge of the
101:11 - screen
101:12 - so
101:13 - any questions as to how that
101:20 - so the question was why did we add 2 and
101:23 - subtract 4 instead of just subtract 2
101:26 - because
101:29 - when you add a because we're doing
101:31 - self.x plus two basically we're shifting
101:34 - the whole box essentially here in this
101:36 - part so self.x plus two
101:39 - brings the beginning of the box that
101:40 - we're that we're colliding with two
101:42 - pixels to the right
101:43 - but if we just do two pixels minus two
101:46 - then the boxes x
101:49 - right edge is still the right edge of
101:50 - the box we want it to be shifted inwards
101:52 - by two by two pixels
101:54 - because we've shifted at the start of
101:56 - our box the x position two pixels over
101:59 - we need to shift it four pixels inwards
102:02 - because that will give us the um that'll
102:04 - have the effect of our box having being
102:07 - uh two pixels uh into the right edge
102:10 - does that make sense
102:16 - okay so i think that's everything for
102:18 - bird seven
102:20 - um
102:23 - we're gonna go ahead and run bird seven
102:25 - now
102:28 - and
102:29 - recall if we hit a pipe we should
102:31 - instantly pause
102:34 - so balancing bouncing bouncing
102:36 - i'm gonna go through one pair of pipes
102:38 - here
102:39 - and then i'm gonna hit this one on
102:40 - purpose oh we paused and notice that we
102:43 - have a little bit of leeway we got a
102:44 - couple pixels there just to give us you
102:46 - know in case we accidentally uh and also
102:48 - it takes into consideration you could
102:49 - move because of your velocity a couple
102:52 - pixels beyond the uh necessarily the
102:54 - strict hard edge of what you're
102:56 - colliding with based on how many you
102:58 - know how many frames have passed and
102:59 - what you're dealt with you're basically
103:01 - essentially what your velocity is and
103:02 - what your position is
103:04 - in this case i think it looks like we're
103:05 - actually like three or four pixels above
103:07 - the edge because our velocity was so
103:08 - high because we jumped
103:11 - but
103:12 - as soon as it detected the collision as
103:13 - soon as we were
103:15 - on that frame where our position was
103:16 - such that we did trigger true for our
103:18 - collision detection it paused the game
103:20 - looping was set to false we no longer
103:22 - ran any update logic and this is our
103:25 - basic way of getting feedback about that
103:27 - however
103:29 - it's not particularly compelling
103:31 - gameplay wise and so
103:34 - we want to get into scoring
103:37 - before we get into scoring though
103:39 - and also associated with that different
103:41 - states of our game so if we get into
103:43 - scoring clearly we want to have a screen
103:44 - that tells us when we lost and how what
103:46 - our score was we should also probably
103:48 - have a title screen because we're just
103:50 - jumping right into the game gameplay we
103:51 - want a screen that lets us play through
103:53 - the game and um as we'll see in a little
103:56 - bit a screen that also gives some time
103:58 - to uh once we start the game to sort of
104:00 - count down sort of say oh three two one
104:03 - go rather than just oh go and oh i don't
104:05 - know what i'm doing i'm bewildered so
104:07 - this is a sort of a diagram that sort of
104:09 - models the state flow that we're going
104:11 - to be using in our program here our game
104:14 - we're going to assume that we start on
104:16 - some sort of title screen state so going
104:18 - left to right a title screen state will
104:20 - transition to the countdown state and
104:22 - then
104:23 - we can define however we want those
104:25 - transitions to be in this case let's
104:27 - just say we press enter title screen
104:28 - state goes to countdown state once
104:30 - countdown state has
104:32 - once the transition is triggered for
104:34 - that
104:35 - we should go to the play state
104:36 - and then once the transition triggers
104:38 - for play state we're going to go down to
104:39 - the score state and then score state
104:41 - should go back into countdown state and
104:43 - this models our entire
104:46 - applications flow uh you know sort of
104:48 - top to bottom left to right
104:50 - chronologically
104:52 - so let's go ahead and take a look at
104:54 - some code as how we're going to
104:55 - accomplish this last week i alluded to
104:57 - taking us and actually earlier in
104:59 - lecture us going from sort of this
105:01 - string based approach to keeping track
105:03 - of our state with if conditions to a
105:05 - class-based approach and that's what
105:06 - we're going to illustrate today so i'm
105:08 - going to go ahead and open up bird eight
105:10 - and in bird eight i'm going to go ahead
105:12 - and start with maine
105:14 - so in main
105:16 - on line
105:18 - 36
105:20 - we're acquiring a new class called state
105:22 - machine and a few other classes that
105:24 - we're defining called base state play
105:26 - state and title screen state and these
105:29 - are the components of our state machine
105:31 - and they've now instead of being just
105:33 - blocks of code in our update function
105:34 - they're separate blocks separate modules
105:37 - that have their own logic their own
105:39 - update and render logic and we'll see
105:40 - that very shortly
105:41 - on line 78
105:43 - if you go down here
105:45 - separate from that i'm also
105:46 - instantiating a bunch of fonts we did
105:48 - this last week so love.graphics.new font
105:51 - takes in a file and then a size i've
105:53 - created a few different fonts here
105:54 - because we have a few different ways of
105:56 - giving
105:57 - feedback to the user we want a small
105:58 - font for displaying you know uh press
106:00 - enter to start or something like that we
106:02 - want a medium font for to display the
106:04 - name of the game perhaps or i think
106:06 - actually flappy font's responsible for
106:08 - that medium font i think was for score
106:10 - huge font for our countdown we want a
106:12 - big font right in the middle of the
106:13 - screen that says three two one and then
106:15 - we start and then we're just going to
106:16 - start off by setting it to flappy font
106:18 - which is our gonna be our title font so
106:20 - nothing really new but uh the beginning
106:23 - of our ui so to speak
106:25 - on line 92
106:27 - this is new and actually this is a
106:29 - demonstration of a type of naming
106:32 - convention you'll see often in game code
106:34 - bases we haven't used it yet but we will
106:36 - start using it in the future we prefix a
106:39 - global variable with a lowercase g this
106:42 - lets you know when you're digging
106:43 - through a bunch of files that oh this is
106:45 - a global variable okay so i should
106:47 - probably know um it's probably not
106:49 - defined in this
106:51 - module maybe it is but i know it's
106:53 - global
106:54 - other things you might see are lowercase
106:56 - m for member which means that this is a
106:59 - sort of a member uh function or a field
107:02 - of a class
107:03 - and you can instantly see it at a glance
107:06 - and know okay if i want to find the
107:07 - definition for this it looks like it's a
107:09 - member function so it's probably in this
107:11 - class here at some line you can easily
107:13 - find it
107:15 - and so
107:16 - in future lectures we'll be using more
107:18 - of this sort of g lowercase g for global
107:20 - variables that we use module to module
107:22 - in this case we're instantiating a state
107:24 - machine
107:25 - so we're using the class that we've that
107:28 - we will take a look at in a second the
107:29 - state machine takes in a table with keys
107:32 - that map to functions that will return
107:35 - our states
107:36 - so we can just call
107:38 - change some
107:40 - some value and it'll have in our state
107:43 - machine it'll basically reference that
107:45 - key in this table here
107:48 - and it'll call
107:49 - that function based on it'll basically
107:51 - set current uh the current state of that
107:54 - state machine to whatever
107:56 - state gets returned by the function at
107:59 - that key so in this case
108:01 - change is going to trigger
108:03 - return new title screen state and we're
108:05 - going to get the state machine is going
108:06 - to be set to the title screen
108:07 - effectively and we'll take a look at
108:09 - what the title screen looks like
108:10 - momentarily
108:12 - on line 96 yep we're changing to title
108:15 - screen on line 134 notice that we don't
108:19 - really have much update logic in this
108:20 - application anymore we're still updating
108:22 - the scrolls
108:24 - because this is behavior we want across
108:26 - all our states no matter what state
108:27 - we're in we want to make sure that
108:29 - our background and our ground scroll so
108:31 - that we have movement we don't need to
108:33 - duplicate this behavior state to state
108:35 - this is a global feature of our game so
108:37 - we're just
108:38 - keeping track of it here just as we
108:40 - would before but
108:41 - anything else in our game that needs to
108:43 - be updated can now be deferred to our
108:45 - state machine class
108:47 - and when we call g state machine update
108:50 - delta time it's going to look and see
108:52 - what's our current state
108:53 - and it's going to update that state
108:55 - and that's going to basically be that
108:57 - chunk that if chunk do this logic that
109:00 - we were doing from before last week when
109:02 - we had a sort of prim more primitive
109:03 - state machine
109:05 - line 46 same exact thing
109:08 - between the background and the ground
109:09 - because those will always render scene
109:11 - to scene we want to render our current
109:14 - active state using our state machine
109:16 - render function
109:18 - and so let's go ahead and just look
109:20 - briefly at our state machine library
109:23 - it's a very simple
109:24 - code it's actually taken from the book i
109:27 - alluded to earlier in the lecture how to
109:29 - make an rpg they give you the state
109:31 - machine which sort of um really cleanly
109:34 - i think handles a state transition
109:37 - basically takes an init and then a
109:38 - series of states
109:40 - sets it has a an empty
109:43 - uh class or empty table so all of these
109:45 - are just empty
109:48 - um
109:50 - if there is no this is a a thing you can
109:52 - do in lua which just lets you initialize
109:54 - a variable if it's not given a value in
109:57 - your function
110:01 - so self.states gets states or some value
110:04 - which means that if states is equal to
110:06 - like a falsie value is equal to nothing
110:08 - just set it to this empty table so it's
110:10 - just a shorthand for instead of saying
110:12 - you know if states equals nothing then
110:14 - set states to empty table
110:17 - self.current is just an empty
110:20 - class
110:21 - so our empty
110:23 - state so this is basically what a state
110:24 - is it's just a set of methods a render
110:27 - update enter and exit function that's a
110:28 - state and then you define all of the
110:31 - behavior in each of these functions and
110:32 - that compiles your state more or less
110:36 - our change function takes in a name and
110:37 - then also some optional parameters that
110:39 - we can use to enter that state
110:41 - um when we set the
110:44 - when we change the state set whatever or
110:46 - call the exit
110:47 - function of whatever state we're in so
110:49 - exit that state maybe your function
110:51 - needs you to de-allocate some memory
110:53 - set the current equal to taking that
110:55 - name and then call whatever function's
110:57 - there so it's going to return in that
110:59 - case we saw earlier it's going to return
111:00 - a new title screen state
111:02 - so that's going to be what current is
111:04 - with self.current we're going to then
111:06 - enter
111:07 - that state machine so we're going to
111:09 - call the enter function that we've
111:10 - defined there with whatever enter
111:12 - parameters we pass into change which are
111:15 - optional
111:16 - and then here state machine update just
111:19 - updates whatever the current
111:21 - state is and render updates whatever the
111:24 - current uh
111:25 - state is as well
111:26 - and so
111:28 - i'm going to start going a little bit
111:29 - quickly just because running short on
111:30 - time base state is a all it does is just
111:34 - implements empty methods so that you can
111:36 - just
111:37 - inherit this state and you can choose
111:39 - which methods you want to define without
111:40 - throwing any errors because it blindly
111:42 - will call all these functions not
111:44 - checking to see whether they're actually
111:45 - implemented and so this is a way for you
111:47 - to just quickly uh avoid
111:50 - a lot of boilerplate code essentially
111:52 - the title screen state here
111:55 - uh this is your way of with the class
111:58 - function class
111:59 - library just including
112:02 - everything that belongs to bay state so
112:04 - inheriting if you're familiar with other
112:06 - languages that use inheritance take an
112:08 - object
112:09 - copy everything from that object or that
112:10 - class
112:11 - put it into this one and then add new
112:13 - stuff to it that's basically what
112:14 - inheritance is we're inheriting from
112:16 - base state so it has all the functions
112:17 - base state has and then on top of that
112:20 - we're defining an update function
112:22 - so if we press enter return
112:25 - change the state machine the global
112:26 - state machine to the play state and then
112:28 - for the render we're just going to
112:30 - render 50 bird and press enter halfway
112:33 - in the middle of the screen and then the
112:34 - play state essentially to some basically
112:36 - what the play state is is all of the
112:38 - code that we ran before
112:40 - only now we're just putting it in the
112:42 - update function here and the render
112:44 - function here
112:46 - and
112:47 - making bird pipe pairs timer and last y
112:50 - member fields of this
112:52 - sort of state object so we'll go ahead
112:54 - and run this really fast
112:59 - and then we have uh this is our title
113:01 - screen state so we at the very beginning
113:03 - we change to title screen state all it
113:05 - does is render and then the scrolling
113:07 - behavior is throughout all classes all
113:09 - states so we'll see that no matter what
113:11 - once you press enter it'll trigger
113:12 - change to play which will return a play
113:15 - state
113:16 - and then now we're back where we were
113:18 - before and we're
113:20 - seeing the difference now and having a
113:22 - couple of different states
113:24 - so
113:24 - quickly i'll go through the score update
113:27 - so this is a little bit
113:29 - um more
113:31 - complicated than the last example but to
113:32 - summarize
113:34 - in uh bird oh sorry we're in bird nine
113:38 - so in bird nine
113:40 - if we go
113:42 - here
113:43 - we're going to go to main so
113:46 - notice that
113:47 - in main down where we define our state
113:49 - machine we're going to go ahead and also
113:52 - note that we require a new score state
113:54 - because now we want to display a score
113:56 - screen
113:57 - down on line
113:59 - 96 score gets a function where we return
114:03 - a score state object so now we can
114:06 - change to score and it'll return that
114:08 - state and we can define all the behavior
114:10 - within a score state that we need
114:14 - to display a score
114:16 - in
114:17 - pipe pair
114:19 - we have a
114:21 - new variable called self.scored
114:24 - set it to true or false we're going to
114:26 - set it to true if the bird has gone past
114:27 - the right edge of the of the pair of
114:30 - pipes that'll have the effect of
114:33 - us scoring a point effectively because
114:34 - all we need to do is just make sure the
114:36 - bird's gone past that pair of pipes
114:38 - because otherwise it'll have collided
114:39 - with it if it does go past it uh
114:42 - set it to true and then add a point to
114:44 - our score and in our play state we can
114:47 - see
114:48 - that we've added a point
114:52 - so if we go to
114:54 - uh our play state 26 is where we
114:57 - actually keep track of our score
114:58 - self.score gets zero in our play state
115:00 - we're going to go ahead and go down to
115:02 - line 56 so for every pair if it's not
115:05 - been scored yet
115:06 - because we don't need to calculate this
115:08 - if it's already been scored it should we
115:09 - should ignore it in terms of scoring
115:10 - once it's been scored
115:13 - if
115:14 - the x plus width
115:16 - is less than our bird.x
115:19 - meaning our bird is beyond the right
115:20 - edge of the pair of pipes increment our
115:23 - score and set that pair to true we will
115:25 - then thereafter because of this
115:26 - condition ignore it and we're also going
115:28 - to increment our score so it's going to
115:30 - be kept track of
115:33 - on 83 notice that if we're colliding
115:35 - with a pipe we should transition to our
115:37 - score state now so and we're also
115:39 - passing in
115:40 - scoregetself.score as a table because
115:42 - remember we can pass in parameters when
115:44 - we call change and this will be passed
115:46 - into our enter function in our state and
115:49 - then score is going to equal self.score
115:51 - we'll have access to the score within
115:53 - that score state we don't have to keep
115:54 - track of it as a global variable to see
115:56 - it in both locations
116:00 - 93 the same exact thing this is
116:02 - collision to check whether we've
116:04 - collided with the bottom of the screen
116:05 - if our y is greater than virtual height
116:07 - minus 15 do the exact same thing
116:09 - transition to the score state and pass
116:11 - it in our current score so
116:13 - another death condition and then 104
116:15 - we're just going to set flappy font and
116:17 - then we're going to render our score at
116:19 - the top left of the screen at 8 8 and
116:21 - that'll have that effect and so
116:24 - lastly here our score state is pretty
116:26 - simple
116:29 - all it is is we're going to get from
116:30 - those parameters we passed in by a
116:32 - change self.score equals params.score
116:35 - we're going to when we press enter go
116:37 - back to play and then we're going to
116:38 - render
116:40 - you lost
116:41 - and the score which we have access to
116:42 - self.score and then press enter to play
116:44 - again changing fonts along the way and
116:46 - so if we go back to bird9 and then we
116:49 - run this
116:51 - notice that now we have a score in the
116:52 - top left
116:54 - and
116:55 - i'm going to get one point
117:00 - and then die and we go to our score
117:02 - screen now it just remember we passed
117:04 - score into it from uh our play state we
117:07 - passed it as parameters and then
117:12 - we can press enter again go back to
117:14 - playstate and when we fall to the ground
117:16 - we do it as well so we're just taking a
117:18 - look at how to add scoring to our game
117:21 - but what if we want to add a countdown
117:23 - screen maybe we want the users to be
117:25 - prompted three two one before the actual
117:28 - game starts you know throwing pipes at
117:30 - them give them the time to you know sort
117:31 - of get acclimated we're going to go
117:33 - ahead and take a look at how we might do
117:35 - this using another state very similar to
117:37 - the last example we're going to add a
117:39 - new state called countdown state which
117:41 - is shown here on line 38.
117:44 - we're also going to down in our state
117:46 - machine add a new key which returns one
117:49 - of the new countdown states just as
117:51 - before and then we're going to go ahead
117:52 - and take a look at our actual countdown
117:54 - state here
117:56 - so
117:56 - in our countdown state dot lua which is
117:59 - in our states folder
118:01 - as the others
118:03 - it includes from base it uh inherits
118:05 - from base state we have initialized the
118:07 - countdown time to 0.75 this is time in
118:09 - seconds one second is a little long so i
118:12 - made it 0.75 seconds we're going to
118:14 - initialize a count to three and a timer
118:16 - to zero the count is going to start it's
118:18 - going to use a timer once the countdown
118:20 - time has elapsed
118:22 - right here as this logic shows increase
118:24 - the timer once the timer has gone past
118:26 - countdown time we want to go ahead and
118:28 - set it to uh we're in a modulo by
118:30 - countdown time so loop it back to zero
118:32 - plus whatever amount beyond the count on
118:34 - time we went so that we have a smooth
118:36 - track of time
118:38 - we're going to set
118:39 - self.count minus itself by one so that
118:42 - we go three two one and then if our
118:45 - count is zero which means that we've
118:46 - gone all the way down in our account
118:48 - we're going to go ahead and use our
118:49 - state machine and change to the play
118:50 - state and here we're setting our font to
118:52 - a font that we've set huge font and then
118:55 - we're just to string a little function
118:57 - that takes a string or it takes a number
118:59 - converts to a string we're displaying
119:00 - self.count at 0 120
119:03 - and then our ver it's printf so we're
119:06 - basically starting at 0
119:08 - y120
119:09 - virtual width alignment and then we're
119:11 - centering it so
119:12 - the one last piece of that that we need
119:14 - to change is in our title screen state
119:18 - instead of going straight to a play
119:20 - state here on line 15 we're going to a
119:22 - countdown state and what this has the
119:24 - effect of doing if we go into
119:27 - bird 10
119:29 - is when we press enter notice that we're
119:31 - going 3 2 1 then going into our play
119:35 - state not just going straight into the
119:37 - place as before giving our user a little
119:38 - bit of time to sort of catch their
119:40 - breath and then if we die we go to our
119:42 - score state but once we press enter
119:45 - notice we're doing that as well
119:48 - so in our score state we also are
119:49 - changing to the countdown state
119:53 - so that was how to make a countdown
119:54 - state probably my favorite part of many
119:56 - of these examples and of this example as
119:58 - well is adding audio to our
120:01 - application music and sound effects
120:03 - which really sort of tie everything
120:04 - together so we're going to go ahead and
120:05 - take a look at this it's very simple
120:08 - very similar to what we learned last
120:10 - week when we even when we just did pong
120:12 - so in maine da lua of bird 11 which is
120:15 - what we're going to look at now
120:18 - we're going to take a look at
120:20 - a table of sounds that we've initialized
120:23 - on line 88 we've given them all keys
120:26 - jump explosion hurt score these are all
120:28 - sound effects that i've generated with
120:30 - the bfxer program that we used last week
120:32 - if you recall and then a music track
120:34 - that i found online on free sound which
120:36 - is free to use
120:38 - the link is here if curious uh just a
120:40 - nice sort of happy sound track uh that i
120:44 - found for this
120:45 - game on line 99 to 100 we're going to
120:48 - take do one additional step before we
120:49 - start the music we're going to set
120:51 - looping on that to true because in games
120:54 - that are sort of infinite like this we
120:55 - don't want our music to just go and then
120:57 - stop abruptly we want to you know have
121:00 - it loop so
121:02 - play it after set looping to true
121:04 - initially actually begin the play of
121:06 - that music outside of any of our states
121:08 - because it's going to be a global music
121:10 - track
121:11 - and then
121:13 - that's the music we also need sound
121:14 - effects
121:16 - so if we do
121:17 - in our if we look in our bird file here
121:20 - on line 45 which is where we have the
121:24 - logic for jumping we're also playing a
121:26 - sound of the jump sound effect that
121:28 - we've generated
121:30 - additionally in our play state if we
121:32 - take a look there
121:33 - we can go ahead and see in our states
121:35 - folder here go to playstate and take a
121:38 - look at line 58
121:41 - this is where we score a point so we
121:43 - should play our score sound effect here
121:45 - simply put and then the same thing on
121:47 - line 80 to
121:49 - collide the sound effect here which is
121:52 - we're actually layering two sounds on
121:53 - top of each other which is a common
121:54 - thing
121:55 - to do in sound design and game design
121:57 - one sound often isn't all you need to
122:00 - accomplish a particular effect so i have
122:02 - an explosion sound which is kind of a
122:03 - white noise effect and then a hurt sound
122:05 - effect is kind of like a
122:06 - sort of like a downward uh like sine
122:09 - wave type of sound we're doing the exact
122:11 - same here on 95 to 96.
122:14 - once we put all these pieces together
122:15 - we're going to run bird 11.
122:18 - we get music
122:19 - [Music]
122:24 - we get a jump sound effect
122:28 - and when we score a point
122:30 - [Music]
122:33 - another sound effect
122:34 - and then if we hit a pipe notice that we
122:37 - have the sort of
122:38 - and a white noise there explosion effect
122:41 - layered together
122:42 - so
122:43 - that sort of brings everything together
122:45 - creatively and artistically as an
122:47 - exercise to the viewer
122:49 - in bird 12 in the github repo we have
122:52 - some code that allows you to actually
122:53 - add mouse clicks to the flappy bird in
122:55 - order to make it a little bit more like
122:57 - the actual game which was an ios game so
122:59 - it relied on taps
123:01 - the function that you might want to use
123:02 - is love.mouse pressed xy button and i
123:06 - would encourage you to think about how
123:07 - we took input and made it global in the
123:09 - context of the keyboard
123:11 - in one of our earlier examples so that
123:13 - we can call this sort of was the mouse
123:15 - just pressed in our bird.lua file as
123:17 - opposed to the
123:19 - as opposed to the main file
123:22 - and so next time we're going to be
123:23 - covering a few new concepts so sprite
123:25 - sheets so taking a large file of images
123:28 - and sort of taking out chunks of that so
123:30 - we don't have to have a million graphic
123:32 - files procedural layouts uh this will be
123:34 - in the context of the game breakout so
123:36 - we want to lay out uh all the bricks in
123:38 - our game sort of procedurally the way
123:39 - that in the sort of the same way that
123:41 - we've procedurally created
123:42 - a sort of pipe level in this game we'll
123:45 - be talking about separate levels and
123:47 - having them stored in memory as opposed
123:48 - to just one continuous level
123:50 - we'll be talking about health we'll be
123:52 - talking about particle systems which is
123:54 - spawning little mini graphics to
123:55 - accomplish various effects that are
123:57 - otherwise difficult to capture in a
123:59 - simple sprite animation
124:01 - a little bit fancier collision detection
124:03 - based on input so that we can sort of
124:05 - drive ball behavior the way we want to
124:07 - and then also persistent save data how
124:09 - can we take a high score and not have it
124:11 - refreshed to zero every time we run the
124:12 - application but rather save it to disk
124:15 - so that every time we run the program
124:16 - thereafter we can see what we've gotten
124:19 - scored in days past the first assignment
124:22 - or rather the second assignment
124:23 - assignment one
124:24 - is going to be a little bit more
124:26 - complicated than last week's but still
124:27 - fairly doable make pipe gaps slightly
124:30 - random being the first component of this
124:31 - so before pipe gap is set to a constant
124:33 - value maybe make it some sort of random
124:35 - value pipe intervals as well so we're
124:37 - spawning every two seconds maybe we want
124:39 - to change that up make pipes spawn a
124:40 - little differently a little more
124:42 - sporadically
124:43 - uh the more complicated aspect of this
124:45 - assignment is going to be awarding
124:47 - players a medal based on their
124:48 - performance so have like a maybe a
124:50 - bronze a silver and a gold medal an
124:52 - image that you display in the score
124:53 - screen in addition to just their score
124:55 - just to give them a little bit of
124:57 - personal feedback and sort of make them
124:59 - feel rewarded for their effort and make
125:00 - them strive to sort of get that last
125:02 - that last medal and then lastly you
125:04 - implement a pause feature which we
125:06 - talked about in class so that when you
125:07 - press for example to keep p the game
125:10 - will stop but unlike that example when
125:12 - we press p again the game should resume
125:14 - just as it was in its prior state
125:16 - so that'll be it uh for flappy bird i'll
125:19 - see you guys next time thanks a lot