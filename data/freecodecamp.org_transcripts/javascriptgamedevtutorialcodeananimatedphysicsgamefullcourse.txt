00:00 - Frank dwark is back with a new
00:02 - JavaScript game tutorial featuring
00:04 - interesting physics and AI mechanics
00:06 - he's included custom-made royalty-free
00:09 - assets for you to use and they'll guide
00:11 - you step by step to create a polished
00:13 - and responsive browser-based game
00:17 - [Music]
00:20 - what makes a perfect game detailed
00:23 - handcrafted visuals fantasy environments
00:25 - and a wide variety of animated
00:27 - characters or is it more about the game
00:29 - mechanics physics for interactions and
00:32 - AI to make the creatures feel alive what
00:35 - is this special ingredient in game
00:36 - development recipe in this class we will
00:39 - dive deep into the secrets of JavaScript
00:41 - web animation and front-end web
00:43 - development let's try to discover what
00:45 - makes a great game and how we can build
00:48 - it from start to finish using just our
00:51 - own JavaScript code with no Frameworks
00:53 - and no libraries this class is for
00:55 - beginners but some basic knowledge of
00:57 - front-end web development is required to
00:59 - get them maximum value let's go
01:05 - I'm giving Olay a ton of free game art
01:08 - with this class I hope you like it we
01:10 - will control the blue ball its job is to
01:13 - protect hatching eggs from waves of
01:15 - hungry enemies player can position all
01:18 - the game objects by pushing them around
01:20 - we can push the ax and hatchlings to
01:23 - safety or we can push the enemies out of
01:25 - the way while building this project I
01:27 - will show you how to use HTML CSS and
01:30 - plain vanilla JavaScript to implement
01:32 - many important web animation and game
01:35 - development techniques we will apply
01:37 - physics to make game objects interact
01:39 - with each other we will learn how to
01:41 - restart our game by pressing a button
01:43 - how to control FPS of the whole game how
01:46 - to trigger periodic events we will apply
01:49 - Mouse controls learn how to manage and
01:51 - animate 8-directional Sprite sheets we
01:54 - will trigger and animate particles when
01:56 - a certain event happens and much more
01:58 - let's take it step by step to make sure
02:00 - we really understand the code and by the
02:02 - end of this class you will have all the
02:04 - skills you need to build your own games
02:06 - and animation projects I create an IMG
02:09 - element with an ID of overlay
02:12 - The Source will be overlay.png you can
02:15 - download all project art Assets in the
02:17 - resources section below there are
02:19 - individual images and Sprites as I'm
02:21 - using them in this class as well as a
02:23 - bonus folder with source files where
02:26 - each game object comes split into high
02:29 - resolution pieces you can edit and
02:31 - animate so if you want you can mix and
02:33 - match combine them with art I gave you
02:36 - for other classes where we are using
02:38 - this mushroom Forest theme and you can
02:40 - create your own unique game environments
02:42 - all the art in this class is copyright
02:44 - free feel free to download them modify
02:47 - them and reuse them in your own projects
02:50 - in any way you want I'm already giving
02:52 - you all art you will need to follow this
02:54 - course but for those of you who want to
02:56 - take it further if you have a graphics
02:58 - editor like Photoshop you can for
03:00 - example color shift the images to create
03:03 - even more visual variety character
03:05 - source files can also be raked and
03:07 - animated in 2D Sprite tools like dragon
03:10 - bones or spine check out the source
03:12 - files and use them however you want it's
03:14 - my gift to you as a thank you for
03:16 - spending your time with me so we have a
03:18 - basic setup in index.html and style CSS
03:22 - canvas defaults to this small size of
03:24 - 300 X 150 pixels if I set its size with
03:28 - CSS I would be setting only its element
03:30 - size and that would stretch my drawings
03:33 - HTML canvas has actually two sizes
03:36 - element size and drawing surface size
03:39 - that can be set independently I want
03:42 - both sizes to be the same to prevent any
03:45 - distortions so I will size my canvas
03:47 - with the JavaScript here I wrap
03:50 - everything inside load event listener
03:52 - because we will use a lot of art assets
03:54 - and I wanted to make sure all my images
03:56 - are fully loaded and available before
03:59 - any JavaScript code runs first we need
04:02 - to point JavaScript towards our canvas
04:04 - element using get element by ID we save
04:07 - that reference in this custom variable I
04:10 - call for example canvas then I take that
04:13 - variable and from it I call build in get
04:15 - context method passing it 2D as context
04:19 - type argument this will initialize a
04:22 - built-in object that holds all canvas
04:24 - properties and drawing methods we can
04:26 - now call them from this CTX variable so
04:29 - as I said before I want to set canvas
04:32 - size both element size and drawing
04:35 - surface size to the same value we can do
04:38 - it like this canvasa dot width is 1280
04:42 - pixels and canvas height is 720 pixels
04:46 - now the full background artwork I
04:49 - prepared for you is revealed perfect
04:53 - [Music]
04:58 - I wanted to ride this game as
05:00 - object-oriented code base to make it
05:02 - more modular we will have a class for
05:04 - player and another class for game to
05:07 - manage all the game logic the main brain
05:09 - of this code base we will also need
05:12 - animation Loop to draw and update our
05:14 - game over and over to create an illusion
05:16 - of movement
05:19 - game class Constructor will expect a
05:21 - reference to Canvas element as an
05:23 - argument like this
05:25 - inside we convert it into a Class
05:27 - Property
05:28 - and
05:30 - we will need with property and the value
05:32 - will be this dot canvas from line 15 DOT
05:36 - with like this this will give us 1280
05:40 - pixels as we set it up on line four
05:43 - we do the same thing for this dot height
05:45 - we are taking a reference to Canvas
05:48 - element and we are setting the width and
05:50 - height of our game to be the same as the
05:53 - width and height of canvas we will
05:55 - finish this setup by connecting this
05:57 - canvas argument to this canvas variable
05:59 - a little bit later when we create an
06:01 - instance of our game class using the new
06:04 - keyword we will get there soon I'll show
06:06 - you
06:07 - before we do that I also need the player
06:09 - to have access to width and height
06:11 - properties of our game because the
06:13 - player needs to know for example when it
06:15 - moves outside the game area and so on I
06:18 - will give it access to the entire game
06:20 - class and all its properties and methods
06:23 - by passing it a reference to this game
06:25 - class as an argument like this inside we
06:29 - convert it to A Class Property keep in
06:32 - mind that I'm not creating a copy of
06:34 - game object when I create player objects
06:36 - in JavaScript are so called reference
06:38 - data types so this dot game here on line
06:41 - 9 doesn't create a copy it just points
06:43 - to a space in the memory where our main
06:45 - game object is stored all the code
06:48 - inside a class Constructor gets
06:50 - triggered when we create an instance of
06:52 - a class using the new keyword we will do
06:54 - that in a minute I want our code base to
06:57 - automatically create player when we
06:59 - create an instance of our main game
07:01 - object so I can do this inside the class
07:03 - Constructor I create a property called
07:06 - this dot player and I set it to new
07:08 - player like this I can see that player
07:11 - class Constructor on line 8 expects game
07:14 - as an argument so I pass it this keyword
07:17 - since here we are inside that game class
07:19 - this keyword here refers to the entire
07:22 - game object here on line 18 we are
07:25 - creating an instance of player class and
07:28 - we are saving it as a desktop player
07:30 - property on the game class structuring
07:33 - our code like this will automatically
07:34 - create player when we create game we
07:37 - create an instance of game object like
07:39 - this custom variable I call for example
07:41 - game and I set it equal to new game
07:46 - on line 14 I can see that the game class
07:48 - Constructor expects canvas as an
07:50 - argument so I pass it canvas variable
07:52 - from Line 2. This variable will get
07:55 - converted to a class property and the
07:57 - width and height of the game area will
07:59 - be extracted from it as we plant let's
08:02 - check if everything worked by console
08:04 - login this game variable
08:06 - nice I can see the correct width and
08:08 - height properties and we have an
08:09 - instance of player class in there as
08:11 - well this is one of the ways how you can
08:13 - organize and connect your objects in an
08:16 - object-oriented JavaScript code base
08:18 - keep in mind that the order in which we
08:20 - Define the classes matters Javascript
08:22 - file is read line by line from top to
08:25 - bottom JavaScript classes are hosted but
08:27 - they are not initialized until that
08:29 - particular line is right so player class
08:32 - needs to be defined before it's used a
08:35 - very good idea would be to split our
08:37 - JavaScript into individual modules and
08:39 - Import and Export our classes between
08:41 - files as needed for this project I will
08:44 - write all the code in a single
08:45 - Javascript file to keep it as beginner
08:48 - friendly as possible using JavaScript
08:50 - modules would require us to run this
08:52 - code through a local server it wouldn't
08:54 - run The Code by simply opening index
08:56 - HTML file in a web browser anymore if
08:59 - you are more experienced it will be very
09:00 - easy for you to finish the project with
09:02 - me and then if you want you can split
09:04 - individual classes into separate modules
09:07 - yourself this class is for beginners so
09:09 - let's focus on object oriented
09:11 - principles and animation techniques
09:14 - [Music]
09:19 - a function that sits on an object is
09:22 - called a method player will need a draw
09:24 - method to draw and animate it it will
09:27 - expect context as an argument to specify
09:29 - which canvas we want to draw on we will
09:32 - connect this context argument to our CTX
09:35 - variable from line 3 when we call this
09:37 - draw method a little bit later I will
09:39 - show you
09:40 - I wanted to draw a simple Circle at
09:42 - first representing our player to draw a
09:45 - circle on canvas we take context and we
09:48 - call begin path to tell JavaScript we
09:50 - want to start drawing a new shape and we
09:52 - want to close previous shape if there
09:54 - are any then we call built-in Arc method
09:57 - which expects at least five arguments it
10:00 - expects X and Y coordinates of the
10:02 - center point of the circle its radius
10:05 - start angle in radians measured from the
10:08 - positive x-axis and end angle where the
10:11 - arc ends again in radians measured from
10:14 - the positive x-axis there is an optional
10:16 - sixth argument for counterclockwise if
10:19 - we don't Define it it will default to
10:21 - false which means that the arc will be
10:23 - drawn clockwise so start angle is zero
10:25 - radians and end angle is mastered pi
10:28 - times two it's a full circle
10:30 - now we can choose to call fill to fill
10:33 - the shape with color or stroke just to
10:36 - outline the shape or we could use both
10:38 - we will do that soon how do we actually
10:40 - draw the player on canvas now on the
10:43 - game class I create a method I call for
10:45 - example render this method will draw and
10:47 - update all objects in our game it
10:50 - expects context as an argument inside I
10:53 - take this dot player from line 23 and
10:56 - through this reference we access the
10:58 - draw method on player class we just
11:00 - defined from Line 11. This method
11:03 - contains the code to draw a circle
11:05 - representing the player I can see it
11:08 - expects context as an argument so I pass
11:10 - it along this context we passed to the
11:13 - render method now I can take this game
11:16 - variable that holds an instance of the
11:18 - entire game class and from there I call
11:20 - render
11:21 - and I pass it to CTX
11:25 - from line three
11:27 - that CTX will be assigned a variable
11:29 - name context here and it will be passed
11:32 - along to draw method on player class
11:35 - we are drawing a black circle
11:37 - representing the player it's here maybe
11:40 - you can't see it so let's give it
11:41 - different X and Y coordinates to move it
11:44 - instead of hard coding all these values
11:46 - I want to create properties on the
11:48 - player class and then use those here
11:51 - we will need X and Y coordinates for
11:53 - player position but because in this
11:55 - class we are learning about position and
11:57 - hitboxes and character images that can
12:00 - have very different shapes and sizes I
12:02 - will have to create property for X and Y
12:04 - position of player hitbox and I will
12:07 - need to have a different X and Y
12:08 - property for player Sprite sheet image
12:11 - it will make more sense as we build it I
12:14 - want to be very explicit with my
12:15 - variable names to make it absolutely
12:17 - clear which value is the position of the
12:19 - Collision box and which value is the
12:21 - position of a Sprite sheet so instead
12:24 - naming these properties just X and Y I
12:27 - will name them Collision X and collision
12:29 - Y X and Y position of the Collision
12:31 - hitbox of the center point of the
12:34 - Collision Circle all objects in our game
12:36 - today will have circular hitboxes
12:38 - because I wanted to show you how to make
12:40 - them push and slide along each other I
12:43 - want the starting position of the player
12:44 - to be exactly in the middle of the game
12:46 - area so Collision X will be this dot
12:49 - game from line 9 and from that property
12:51 - I will extract with from line 23.
12:55 - and in the middle so terms of 0.5
12:59 - Collision y will be the same this Dot
13:01 - Game dot height times 0.5
13:04 - now I can use these values as X and Y
13:07 - arguments but to Canvas Arc method like
13:10 - this
13:11 - now we can move the player around by
13:13 - changing values of collision X and
13:15 - collision y properties
13:17 - we will also need a property called
13:19 - Collision radius which will Define the
13:21 - size of this circular player hitbox
13:24 - I use it here inside the arc method as
13:27 - well
13:28 - default fill color is always black I can
13:31 - override it here by setting canvas fill
13:33 - style property to White like this
13:36 - instead of filling the shape with color
13:38 - we could also just stroke it
13:41 - Again by default line width of stroke is
13:44 - one pixel and the color is black I set
13:47 - the line with 2 3 pixels and I set
13:51 - stroke style to White notice I'm
13:54 - defining these canvas properties outside
13:56 - of any class or method I do that on
13:59 - purpose because this code will only run
14:01 - once on the initial page load you can't
14:04 - always do that if you have multiple
14:06 - objects with different fill Styles and
14:08 - stroke colors in that case you would
14:10 - have to Define these properties inside
14:12 - the draw method and switch between them
14:14 - over and over the problem with that is
14:16 - that the draw method will be called 60
14:18 - times per second and change in kind of a
14:20 - state like this could get performance
14:22 - expensive it's a good idea to structure
14:25 - your code in a way where you change kind
14:27 - of a state as little as possible and
14:29 - when I say canvas State I mean anything
14:31 - from transforms to changing colors of
14:34 - fill style and stroke style that's why I
14:37 - put this code here instead of placing it
14:39 - directly inside the draw method to make
14:42 - it run as little as possible while still
14:44 - applying the colors and settings as I
14:46 - need them
14:47 - I can also call Phil here so now we are
14:50 - filling and stroking the same path
14:52 - defined by Arc method I want the fill to
14:55 - be white but I want it to be slightly
14:57 - transparent canvas has a global Alpha
15:00 - property to set opacity of the shapes we
15:03 - are drawing the problem is that when I
15:05 - set Global Alpha to a different value
15:07 - everything drawn after that will be
15:09 - semi-transparent I want the transparency
15:12 - to only apply to the fill color of
15:15 - player Collision Circle to limit certain
15:17 - kind of a settings only two specific
15:19 - draw calls we can wrap that drawing code
15:22 - between save and restore built-in canvas
15:25 - methods then if I set Global Alpha to
15:28 - 0.5 it will affect only that specific
15:32 - draw in action in our case it will only
15:34 - affect the fill of this circle so save
15:38 - method creates a snapshot of the current
15:40 - canvas State including its fill style
15:43 - line width opacity as well as
15:45 - Transformations and scaling if we are
15:48 - doing that then I can do any changes to
15:51 - that kind of a state I want in this case
15:53 - I just set opacity to 0.5 this fill call
15:57 - will be affected by that changed opacity
15:59 - and then we call Restore restoring all
16:03 - canvas settings to what they were when
16:05 - we first called its Associated save
16:07 - method for that reason this stroke will
16:10 - not be affected by reduced opacity save
16:13 - and restore methods allow us to apply
16:15 - specific drawing settings only to
16:18 - selected shapes without affecting the
16:20 - rest of our canvas drawings
16:25 - [Music]
16:29 - I want to move the player around using
16:32 - Mouse we already know that the code
16:34 - inside the game class Constructor will
16:36 - be executed at the point where we create
16:39 - an instance of this class using the new
16:41 - keyword
16:42 - we are taking advantage of that by
16:44 - automatically creating an instance of
16:46 - player class here we can actually run
16:48 - any JavaScript code in here
16:51 - I can even put event listeners here to
16:53 - make sure they are automatically applied
16:55 - when I create an instance of game class
16:57 - I create an event listener for Mouse
17:00 - down event when Mouse button is clicked
17:03 - the code inside this callback function
17:05 - will run I test it by just console login
17:08 - the word Mouse down
17:11 - if I save changes because I'm already
17:13 - instantiating this class online 46 this
17:16 - event listener is automatically applied
17:18 - now when I click on canvas control lock
17:21 - is triggering nice
17:23 - callback function on event listener also
17:25 - generates an event object that contains
17:28 - all kind of information about the event
17:30 - that just happened to get access to that
17:33 - object we just need to give it a
17:34 - variable name you can name it whatever
17:36 - you want but the convention is usually
17:38 - event or E let's consolock this event
17:43 - I click on canvas and I see it here
17:46 - I inspect it you can see it contains a
17:49 - lot of information about that Mouse
17:51 - click for example we see X and Y
17:53 - coordinates of that click here there are
17:55 - many other properties that tell us which
17:57 - Mouse button was pressed and many other
18:00 - things I want to take the coordinates of
18:02 - the click and save them as properties on
18:04 - the main game object and from there we
18:07 - will be able to access them from our
18:09 - player object as well
18:10 - I create a new property on game class
18:12 - called this.mouse it will be an object
18:15 - with X property with default value of
18:18 - this dot width times 0.5 and Y will be
18:22 - distal height times 0.5 so the middle of
18:25 - canvas horizontally and vertically
18:28 - we will also want to monitor when the
18:30 - mouse button is pressed down initially
18:33 - it will be set to false
18:35 - if I consolok e.x and e.y you can see we
18:38 - are getting X and Y coordinates as we
18:41 - click around canvas the problem is that
18:43 - the coordinates are from the top left
18:45 - edges of the browser window I would like
18:47 - to measure the click coordinates from
18:49 - the top left corner of canvas instead so
18:52 - when we click here in the top left
18:54 - corner of canvas we get X and Y 0 0. for
18:58 - that we can use a different property on
19:00 - this auto-generated event object called
19:02 - offset X which will give us horizontal
19:05 - coordinate of the click on the target
19:07 - node in our case the target node the
19:10 - target of the click is canvas element
19:12 - now you can see the values get very
19:14 - close to zero as I click close to the
19:16 - edge of canvas
19:22 - I could also add the event listener just
19:25 - to the canvas element itself rather than
19:27 - the entire browser window object
19:37 - if I click closer to the top left corner
19:39 - we are getting values close to zero zero
19:42 - perfect probably it would make sense if
19:45 - I use this dot canvas property here from
19:47 - line 31 instead since we are inside a
19:50 - class and we have the reference to
19:52 - Canvas available here
19:55 - so now we are getting coordinates of the
19:57 - click measured in pixel distance from
19:59 - the top left corner of canvas
20:02 - we resize the browser window this is
20:04 - working well I want to save these click
20:07 - coordinates inside our custom Mouse
20:09 - property so that they are available to
20:11 - other objects in our code base such as
20:13 - the player
20:14 - inside the mouse down event listener I
20:17 - take that this.mouse.x property from
20:20 - line 36 and I set it equal to e dot
20:23 - offset X
20:25 - this.mouse.y will be e dot offset y
20:29 - I create another console log and I will
20:31 - log these newly updated Mouse properties
20:37 - when I click on canvas we get an error
20:39 - that says cannot set properties on
20:41 - undefined setting X on line 43. it's
20:44 - telling me that I can't set X property
20:47 - on something that is undefined for some
20:50 - reason this.mouse is undefined when
20:52 - accessed from inside event listener it
20:55 - is because when this callback function
20:57 - on event listener runs it forgot it was
21:00 - originally defined inside this game
21:02 - class Constructor it forgets what this
21:04 - keyword stands for this is expected to
21:08 - make the event listener remember where
21:10 - it was first defined where it sits in
21:13 - the lexical scope of our code base we
21:15 - can simply use es6 Ro function here
21:18 - instead one of the special features of
21:20 - es6 Ro functions is that they
21:23 - automatically inherit the reference to
21:25 - this keyword from the parent scope Arrow
21:28 - functions remember where in the code
21:30 - base they were originally declared
21:32 - lexically and they adjust their disk
21:35 - keyword to point to the correct object
21:37 - to the parent object now this.mouse.x
21:41 - and this.mouse.y are correctly updating
21:44 - to the new values making the current
21:46 - Mouse coordinates available all over our
21:49 - code base whenever they might be needed
21:51 - later
21:52 - I delete the console logs when Mouse
21:55 - down event happens I set pressed from
21:58 - line 38 to true
22:00 - I copied this event listener
22:04 - this one will be for Mouse up event
22:06 - when the mouse button is released
22:08 - everything here will stay the same and
22:11 - reset pressed to false
22:13 - I also create an event listener for
22:15 - Mouse move event
22:17 - let's console log it to check
22:20 - yeah that's working let's make the
22:23 - player move
22:25 - [Music]
22:29 - I create a custom method I call update
22:32 - inside I set Collision X from line 14 to
22:35 - the current Mouse exposition
22:38 - and collision y will be the current
22:41 - Mouse y position like this to run this
22:44 - code we actually need to call the update
22:46 - method
22:47 - I will call it from inside render down
22:50 - here
22:52 - I delete this console log
22:55 - if we want to see any Movement we need
22:57 - to be calling render over and over so
22:59 - let's put it inside the animation Loop
23:01 - here
23:02 - I call built-in request animation frame
23:04 - a method which sits on the browser
23:06 - window object but we can also call it
23:09 - directly like this if we want
23:11 - I pass it animate the name of its parent
23:13 - function to create an endless animation
23:16 - Loop now I need to call animate to
23:18 - actually start the animation
23:21 - when I move Mouse over canvas we get
23:23 - Trails I only want to see the current
23:25 - animation frame so between every loop I
23:28 - use built-in clear rectangle method to
23:31 - clear the old paint I want to clear the
23:33 - entire canvas area from coordinates00 to
23:37 - canvas with canvas height
23:41 - now the player sticks to Mouse as we
23:43 - move it around canvas perfect I want to
23:46 - create a line between Mouse and the
23:48 - player to clearly show the direction in
23:51 - which the player will move inside the
23:53 - draw method on player class we start a
23:55 - new shape by calling begin path move 2
23:58 - method will Define starting X and Y
24:00 - coordinates of the line in this case I
24:03 - wanted the line to start from the
24:04 - coordinates of the player object
24:08 - line 2 method will set the end in X and
24:11 - Y coordinates of the line in this case
24:13 - it would be X and Y coordinates of the
24:15 - mouse
24:16 - then we call stroke to actually draw the
24:19 - line
24:22 - this works but since the player is
24:24 - always able to catch up with mouse
24:26 - cursor so fast we can barely see the
24:28 - line let's give player speed speed X
24:31 - horizontal speed initially I set it to
24:34 - zero
24:35 - speed y vertical speed also initially
24:37 - sets to zero
24:39 - inside update method we will calculate
24:42 - speed X first I set it to hard-coded one
24:45 - pixel per animation frame and I increase
24:47 - player Exposition by horizontal speed
24:51 - that worked
24:54 - I also do it for vertical position
24:58 - there are two ways we can make player
25:00 - follow the mouse
25:02 - one way would be to Simply take the
25:04 - difference between the current Mouse
25:05 - position and the player position on
25:08 - horizontal x-axis
25:11 - and set that difference as horizontal
25:14 - speed and we also do that for vertical
25:17 - movement
25:21 - now the player position is correcting
25:23 - for the difference by the entire amount
25:25 - of that distance so it makes the
25:27 - movement instant what if I make it move
25:29 - only by the 120th of the difference
25:32 - between player and mouse position per
25:35 - animation frame horizontally
25:38 - and also vertically
25:47 - I create class properties for DX this
25:50 - stands between Mouse and player
25:52 - horizontally and Dy vertical distance
26:09 - I replace those values here
26:12 - it's easier to read this way
26:15 - I don't want the player to follow all
26:17 - the time as we move Mouse over canvas I
26:19 - won't only when we click somewhere or
26:22 - when we hold Mouse button down and move
26:24 - around
26:26 - inside Mouse move event listener I say
26:28 - only update X and Y Mouse position if
26:31 - Mouse is pressed
26:35 - now I can click around to make the
26:37 - player move to that location or I can
26:40 - drag that point around while holding
26:42 - Mouse down perfect
26:44 - the problem with this technique is that
26:46 - the speed is not constant player moves
26:48 - very fast at first because 1 20th of the
26:51 - distance is at first a big chunk when
26:53 - they are far apart but as they get
26:55 - closer 1 20th of that distance becomes
26:58 - smaller and smaller amount of pixels to
27:00 - be traveled per animation frame you
27:03 - might want this particular motion for
27:04 - your project but for the game we are
27:06 - building today I wanted the player to
27:08 - move at a constant speed we will have to
27:11 - use the second technique for that
27:13 - inside update method I calculated the
27:15 - distance we already have DX the distance
27:18 - between Mouse and the player
27:20 - horizontally we also have DUI the
27:23 - distance between Mouse and the player
27:25 - vertically we want to calculate the
27:27 - distance between these two points we can
27:30 - do that by calculating hypotenuse the
27:33 - longest side of this imaginary right
27:35 - triangle we can use Pythagoras Theorem
27:38 - formula or in JavaScript we have this
27:40 - built-in mastered hypotenuse method this
27:43 - method will calculate the length of the
27:46 - longest side for us if we pass it to
27:48 - other sides of the triangle as arguments
27:50 - keep in mind it expects DUI first and DX
27:54 - second which might be a bit unexpected
27:56 - if you never saw this before
27:58 - horizontal speed is the ratio between DX
28:01 - horizontal distance between Mouse and
28:04 - the player and the actual distance
28:06 - same with speed y it will be the ratio
28:09 - between the distance on vertical y-axis
28:12 - and the actual distance between the two
28:14 - points as a backup when some of these
28:17 - values are undefined at first we say or
28:20 - zero like this
28:22 - we are dividing horizontal and vertical
28:24 - distance these sides by the actual
28:27 - distance represented by the longest side
28:29 - of a right triangle DX and d y is always
28:33 - a smaller number than the distance
28:35 - because the distance is hypotenuse the
28:38 - longest side for that reason the values
28:40 - we get as speed X and speed y will be
28:43 - somewhere between 0 and 1. that will
28:46 - give us the correct direction of
28:48 - movement at a constant speed there is
28:50 - much more to be said about this
28:52 - technique but for now this is all we
28:54 - need to know I'll get back to this now
28:56 - the player is moving at a constant speed
28:58 - towards the mouse I can have a speed
29:01 - modifier I set it to 5 for example I use
29:05 - it down here and I multiply speed X
29:08 - and speed y by that modifier after we
29:12 - add the speed modifier the player Circle
29:14 - will actually never stay still anymore
29:16 - it will be swinging back and forth in
29:19 - this case by 50 pixels because the speed
29:21 - modifier pushes it too far in both
29:24 - directions
29:28 - I can fix it by saying only move the
29:31 - player when the distance between Mouse
29:33 - and the player is more than speed
29:36 - modifier
29:39 - else set speed X to Zero and speed y to
29:44 - 0 as well
29:49 - this works perfect so we covered one
29:52 - simple and one more advanced technique
29:54 - to make the player move towards the
29:56 - mouse now it's time to add solid
29:58 - randomized non-overlapping obstacles
30:04 - [Music]
30:11 - I create a class I call obstacle
30:14 - [Music]
30:17 - Constructor will expect the game as an
30:19 - argument and inside I convert that
30:22 - reference to a class property
30:24 - same as before it will be pointing
30:26 - towards the main game object and we need
30:28 - it here because through this reference
30:30 - we have access to game width and height
30:32 - Mouse positions and some other
30:34 - properties we will be adding later
30:37 - we will have access to all these values
30:39 - from inside obstacle class through
30:42 - this.game reference from line 54. as I
30:45 - explained before all the objects in our
30:47 - game will have a circular collision
30:49 - hitbox and a separate rectangular Sprite
30:52 - sheet for that reason I will be calling
30:55 - these properties with a very descriptive
30:57 - names to make sure it's very clear
30:58 - what's happening when we are moving and
31:01 - animating everything later Collision X
31:04 - the center point of collision circle of
31:07 - each obstacle will be a random value
31:09 - between 0 and the width of the game that
31:12 - width is coming from line 62 here and we
31:15 - are accessing it through this Dot Game
31:17 - reference we created online 54. we will
31:20 - also need Collision y vertical center
31:22 - point of collision area Circle it will
31:25 - be a random value between 0 and game
31:28 - height this value
31:30 - Collision radius will be 60.
31:33 - we will also need a draw method that
31:35 - expects context as an argument I want
31:38 - that Circle that represents hitbox area
31:40 - of each obstacle to look the same as the
31:43 - circle representing the player so I take
31:45 - the drawing code from up here
31:48 - just for the circle so this code block I
31:51 - copied and I paste it down here this
31:53 - code will work here because the same as
31:55 - with the player we gave our obstacles
31:57 - properties called Collision X Collision
32:00 - Y and collision radius
32:02 - we will also need the same naming on all
32:05 - these properties between different
32:06 - object types in case we want to have a
32:08 - reusable Collision detection function I
32:11 - will show you how to use that one later
32:12 - it's simple anyway here we have a code
32:15 - to draw a circle with a radius of 60
32:17 - pixels with 50 opacity wide fill and
32:21 - white fully visible full opacity stroke
32:25 - this obstacle class here is a blueprint
32:27 - we will use it to create individual
32:30 - obstacle objects the actual logic to
32:32 - create and manage these objects will be
32:34 - down here inside the main game class
32:36 - which is the main brain of our code base
32:39 - I create a property called this dot
32:42 - obstacles it will be an array that holds
32:44 - all currently active obstacle objects it
32:47 - will start as an empty array at first
32:49 - the number of obstacles will be for
32:52 - example 5.
32:56 - I create a custom method on our game
32:58 - class I call for example init initialize
33:01 - its job for now will be to create five
33:04 - randomized obstacle objects and put them
33:06 - inside obstacles array we just defined
33:09 - inside I create a for Loop it will run
33:12 - five times because we set number of
33:14 - obstacles to 5 up on line 76.
33:19 - each time it runs it will take this dot
33:22 - obstacles array from line 77 and on it
33:25 - it will call built-in array push method
33:28 - push method adds one or more elements to
33:30 - the end of an array and it Returns the
33:33 - new length of the array I will pass it
33:35 - new obstacle like this the new keyword
33:38 - will look for a class with the name
33:40 - obstacle and it will trigger its class
33:42 - Constructor
33:44 - up online 53 I can see that obstacle
33:46 - class Constructor expects the game as an
33:48 - argument
33:49 - down here init method sits inside that
33:53 - game class so I pass it this keyword
33:55 - which here represents the entire game
33:57 - object with all its properties and
34:00 - Associated methods making all of these
34:02 - available from inside obstacle class
34:05 - now icons look a game and I can see
34:07 - obstacles array is completely empty to
34:10 - fill it all I have to do is call init
34:12 - method we just wrote like this now I can
34:16 - see the array contains five obstacle
34:18 - objects I double check to make sure all
34:21 - properties have values if you see
34:23 - undefined in any of these it means there
34:25 - is a problem in your code base all is
34:27 - good here same as I'm drawing and
34:30 - updating the player from inside game
34:32 - render method here I would like to draw
34:34 - all five obstacle objects on canvas
34:37 - I take obstacles array from -77 we
34:40 - already know that it contains five
34:42 - objects and that each of these objects
34:44 - was created using our custom obstacle
34:46 - class from ion 52 so they all have
34:49 - access to this draw method we defined on
34:51 - line 59 so here inside render I take
34:55 - that obstacles array and I call built-in
34:57 - array for each method the for each
35:00 - method executes a provided function once
35:03 - for each array element first we need to
35:05 - Define a variable name which will be
35:07 - used within this for each method to
35:10 - refer to individual objects in that
35:12 - array I will call each object obstacle
35:15 - so for each obstacle object in obstacles
35:18 - array I call their Associated draw
35:20 - method from line 59. on line 59 I can
35:23 - see that it expects a reference to
35:26 - context as an argument to specify which
35:29 - canvas element we want to draw on
35:32 - it's along this context that was passed
35:34 - to the parent render method
35:37 - nice we are drawing one player and one
35:40 - two three four five randomly positioned
35:42 - obstacles
35:43 - I go
35:45 - up here and I make the obstacles a bit
35:48 - larger every time I refresh browse the
35:50 - window they get positioned randomly
35:52 - somewhere within the canvas area because
35:54 - that's how we Define their position on
35:57 - lines 55 and 56. what if I want to make
36:00 - sure that the obstacles never overlap
36:03 - like this and maybe to take it even
36:06 - further since these will be solid
36:08 - obstacles that player can't move through
36:10 - and has to walk around them I would also
36:13 - like there to be a minimum spacing
36:15 - between them and also between the edges
36:17 - of the game area just to make sure all
36:19 - the creatures that will soon be crawling
36:21 - here don't get stuck and can eventually
36:24 - find their way automatically around each
36:27 - obstacle it's actually easier to
36:29 - implement all of that than you might
36:31 - think but we have to take it step by
36:33 - step and explain a couple of Tricks we
36:35 - can use here to achieve that
36:37 - [Music]
36:42 - inside init method we are simply adding
36:46 - five randomly positioned obstacles right
36:48 - now
36:49 - I have to delete this
36:51 - we will need to structure this code a
36:52 - bit differently here so first I want to
36:55 - make sure the obstacles don't touch that
36:58 - they don't overlap like this we could
37:00 - also adjust the number of obstacles to
37:02 - be the maximum number of circles
37:04 - possible that can fit into a certain
37:06 - area without any two of them overlapping
37:09 - sometimes we call this circle back in so
37:12 - let's write a very simple Circle backing
37:14 - algorithm here I will use the basic
37:16 - technique where you just try to place
37:18 - circles at random positions many times
37:21 - and only those that don't collide with
37:23 - already existing circles will actually
37:25 - be turned into obstacle objects and
37:28 - drawn this is also called a Brute Force
37:30 - algorithm it's not very smart it just
37:33 - tries over and over many many times I
37:36 - will create a lead variable called
37:37 - attempts it will be my safety measure we
37:40 - will count how many times we tried to
37:43 - draw a circle and we will give up after
37:45 - a certain number of attempts the
37:47 - Assumption being that there must have
37:49 - already been enough opportunity entities
37:51 - to place the obstacles
37:53 - I will use a while loop you have to be
37:56 - careful with this one if you create an
37:58 - infinite while loop you will slow down
38:00 - your browser and you will need to
38:02 - restart it very old computers might even
38:04 - freeze if you use while a loop wrong new
38:07 - browsers can usually deal with it my
38:09 - goal here is to randomly Place circles
38:11 - over and over and before we actually
38:13 - turn that circle into obstacle object we
38:16 - check if it overlaps with existing
38:18 - circles only if it doesn't overlap we
38:21 - add it into the obstacles array I want
38:24 - this while loop to run as long as
38:26 - optical's array length is less than
38:29 - number of obstacles less than five
38:32 - we defined that array here and number of
38:35 - obstacles was defined here as a backup I
38:38 - also set a secondary condition only
38:41 - continue running this while loop as long
38:43 - as attempts is less than 500. this is
38:46 - important because if I set radius of an
38:49 - obstacle to be a very large number or I
38:52 - set number of obstacles to be so large
38:54 - that they can't physically fit into the
38:56 - available area we would get an endless
38:58 - while loop but with this secondary
39:00 - condition JavaScript will just try 500
39:03 - times and if by that time they couldn't
39:05 - find placement for all the obstacles it
39:08 - will give up
39:09 - think 500 attempts is more than enough
39:11 - every time the loop runs we have to
39:13 - increase attempts by one for our safety
39:16 - backup plan to work every time this
39:18 - while loop runs we create a temporary
39:20 - object I call for example test obstacle
39:24 - it will be equal to the new obstacle and
39:26 - I pass it again this keyword as an
39:28 - argument as we did before let's
39:30 - consolock this test obstacle
39:33 - nice we have 500 test obstacles in
39:36 - console now you can see they have
39:38 - Collision X Collision Y and collision
39:40 - radius properties as they should my goal
39:43 - now is to take this temporary test
39:45 - obstacle object and compare it against
39:47 - every other obstacle in obstacles array
39:50 - of course at first this array is empty
39:53 - so the first obstacle should always be
39:55 - placed without issues the second test
39:57 - obstacle will compare itself with the
40:00 - first one that's already in the array
40:02 - and so on so for each obstacle in
40:05 - obstacles array I will run a circle
40:07 - Collision detection formula Circle
40:10 - Collision detection in JavaScript is
40:12 - quite simple we basically need to
40:14 - calculate the distance between the two
40:16 - Center points of those two circles then
40:19 - we compare the distance between two
40:21 - Center points with the sum of the radii
40:23 - if the distance is less than radius of
40:26 - circle 1 Plus radius of circle 2 they
40:28 - overlap if it's exactly the same the
40:31 - circles are touching if the distance is
40:34 - more then the sum of radii there is no
40:36 - Collision we already did this when
40:39 - measuring the distance between player
40:40 - and mouse this time the two points we
40:43 - want to measure the distance in between
40:45 - is the center point of obstacle Circle
40:47 - one and center point of obstacle Circle
40:50 - 2. so again we are creating this
40:53 - imaginary right triangle where DX is the
40:56 - difference between two points
40:57 - horizontally Dy is the difference
41:00 - between the two points vertically and
41:02 - the actual distance is the hypotenuse of
41:04 - that triangle so here we use Pythagoras
41:07 - Theorem formula or a built-in method
41:10 - hypotenuse method passing it to DUI
41:12 - first and DX second so now we know what
41:16 - is the distance between the two Center
41:18 - points sum of radii is a radius of
41:20 - circle one in this case radius of test
41:23 - obstacle
41:27 - and the second one is the radius of
41:29 - whatever obstacle object inside
41:31 - obstacles array we are currently cycling
41:33 - over
41:35 - as we said if the distance is less than
41:38 - sum of radii
41:39 - how will I do this outside the for each
41:43 - method I create a flag a lead variable I
41:46 - call overlap and initially I set it to
41:48 - false if the distance is less than sum
41:51 - of radii we set overlap to true because
41:54 - Collision was detected
41:56 - outside the for each method if overlap
41:59 - is still false after we created test
42:01 - obstacle and after we compared it using
42:04 - Collision detection formula with every
42:06 - other existing obstacle in the array if
42:09 - it doesn't collide with any of them and
42:11 - overlap a variable is still false after
42:13 - all these checks only then we take
42:15 - obstacles array and we will push this
42:18 - test obstacle that passed our checks
42:20 - into the array now when I refresh the
42:23 - game five obstacles will be randomly
42:25 - positioned and they will not be
42:27 - overlapping because those that do
42:30 - overlap are discarded and only
42:32 - non-overlapping circles are used because
42:35 - I have my safety measure here on line
42:37 - 108 and we always stop this while loop
42:41 - when we reach 500 attempts I can
42:43 - actually go up here and I can set the
42:46 - number of obstacles to a large number
42:48 - that I know will never fit our code will
42:50 - just place as many obstacles as possible
42:53 - and then it will stop trying we know
42:55 - this is working because if I keep
42:57 - refreshing my project over and over we
43:00 - never see overlap in circles I mean no
43:02 - obstacles overlap with each other player
43:04 - can overlap at this point with obstacles
43:07 - we don't care about that right now I set
43:09 - the number of obstacles to 10.
43:13 - [Music]
43:18 - now let me show you how we will be
43:20 - attaching images to the circular
43:22 - collision hitboxes and how to position
43:25 - the image in relation to the hitbox so
43:28 - that it makes Visual sense and creates
43:30 - an illusion that this is not flat canvas
43:33 - but a three-dimensional environment
43:34 - where the player can actually walk
43:36 - around these obstacles you can download
43:39 - all project art Assets in the resources
43:42 - section Below in index.html I create
43:44 - another image element with an ID of
43:47 - obstacles and Source will be
43:49 - obstacles.png that image is a Sprite
43:52 - sheet we will randomly cut out one of
43:55 - these frames for each obstacle object I
43:58 - don't really want to draw the actual
44:00 - image element so I hide it with CSS
44:03 - inside obstacle class Constructor I
44:06 - create a new property I call this dot
44:08 - image I point it towards that obstacle
44:10 - Sprite sheet using get element by ID
44:13 - like this
44:15 - let's set the number of obstacles to one
44:19 - for now
44:20 - inside the draw method on obstacle class
44:22 - I call built-in canvas draw image method
44:25 - this method needs at least three
44:28 - arguments the image we want to draw so
44:30 - this dot image from line 58
44:33 - and X and Y coordinates where to draw it
44:36 - I will draw it at this dot Collision X
44:38 - and this dot Collision Y at first doing
44:41 - this will simply draw the entire image
44:43 - Sprite sheet and the top left corner of
44:46 - this Sprite sheet will be starting from
44:48 - the center point of obstacle Circle
44:50 - because this is how by default images
44:52 - and circles are drawn on HTML canvas
44:56 - if I refresh the project our new
44:58 - obstacle is positioned randomly
45:00 - somewhere on canvas I created this
45:03 - Sprite sheet for you so I know that
45:05 - individual frames are 250 pixels wide I
45:08 - save that value as Sprite width variable
45:11 - Sprite height will also be 250 pixels if
45:15 - you are using a different spreadsheet
45:16 - you can get the width by dividing the
45:19 - width of the entire Sprite sheet by the
45:21 - number of columns and the height is
45:23 - height of the Sprite sheet divided by
45:25 - the number of rows
45:27 - in case we want to add scaling later I
45:30 - will also create independent width and
45:32 - height properties for now they will be
45:34 - equal to Sprite width and Sprite height
45:37 - because I sized the Sprite frames to the
45:40 - exactly same size as I want them to be
45:42 - drawn in the game
45:44 - draw image can also accept optional
45:46 - fourth and fifth arguments defined in
45:48 - the width and height the entire image
45:50 - will be squeezed or stretched to the
45:52 - area we defined by these values
45:55 - it will look like this
45:57 - what I actually want to do is to crop
45:59 - out one of these 12 obstacles and draw
46:01 - only that one at the size of 250 times
46:05 - 250 pixels for that I need to use the
46:08 - longest version of draw image method
46:10 - that expects 9 arguments those nine
46:13 - arguments are the image we want to draw
46:15 - Source X Source y Source width and
46:19 - Source height of the area we want to
46:21 - crop out from the source image and
46:24 - destination X destination y destination
46:27 - with and destination height to Define
46:29 - where on destination canvas I want to
46:32 - place that cropped out piece of image
46:34 - onto so if I pass it 0 as a source X and
46:38 - 0 as Source height and Sprite with
46:41 - Sprite height like this as Source width
46:44 - and Source height I need to spell width
46:47 - correctly so now we are drawing the top
46:50 - left frame in our Sprite sheet as I said
46:53 - before I will set separate X and Y
46:55 - position for the Sprite sheet there are
46:57 - multiple different ways to do this I can
47:00 - just simply position the image directly
47:02 - on top of collision X which is the
47:04 - center point of collision Circle minus
47:07 - the width of the image times 0.5 this
47:10 - will Center the image horizontally
47:11 - exactly over the Collision Circle
47:14 - to actually apply this I need to use
47:16 - Sprite X as destination X property
47:19 - passed to draw image method here be
47:21 - careful when passing arguments to draw
47:23 - image method the order in which you pass
47:25 - these arguments is very important okay
47:28 - if I refresh the page I can see it's
47:30 - been correctly centered horizontally I
47:33 - do the same thing for sprite y
47:35 - and I use it as destination y property
47:39 - passed to draw image method
47:41 - now the spreadsheet is directly on top
47:43 - of the Collision Circle I set Collision
47:46 - radius to a smaller value I want this
47:49 - small Collision area to be positioned at
47:51 - the base of the plant where the stone is
47:53 - because that will be the solid area
47:56 - that's touching the ground that our game
47:58 - characters will have to walk around
47:59 - since our Sprites are set size of 250
48:03 - times 250 pixels I can actually use a
48:06 - hard-coded value here plus 40 we'll move
48:10 - it up
48:12 - minus 40.
48:14 - minus 50.
48:17 - minus 60
48:20 - minus 70. yes this seems all right I
48:24 - said that the number of obstacles to 10.
48:28 - [Music]
48:32 - what if I want to make sure that not
48:35 - obstacles so don't overlap but also that
48:38 - there is a additional minimum 100 pixel
48:40 - space in between so that they are more
48:43 - evenly spaced out around the available
48:45 - game area as well as allowing enough
48:47 - space in between the obstacles so the
48:50 - game characters can easily walk around
48:52 - them I create a helper variable I call
48:55 - for example distance buffer and I set it
48:58 - to 100 pixels like this
49:01 - then I include the distance buffer here
49:04 - in sum of radii to apply this buffer in
49:07 - between obstacles when we are placing
49:09 - them
49:10 - nice to make sure this is working I
49:13 - increase distance buffer to 150 pixels
49:16 - that should make it even more apparent
49:18 - yeah so this is how we can easily
49:20 - control obstacle spacing
49:23 - I also want to make sure that obstacle
49:25 - Sprite images are entirely drawn within
49:28 - the game area and not partially hidden
49:30 - behind the edges I could have done this
49:33 - inside obstacle class Constructor when
49:35 - defining these values initially or I can
49:38 - also just do it here since we are not
49:40 - drawing that many obstacles and their
49:42 - positions are calculated only once on
49:44 - the first page load anyway I make sure
49:46 - the left edge of obstacle Sprite sheet
49:48 - is more than zero so it's not hidden
49:50 - behind the left edge of canvas at the
49:53 - same time I make sure that the right
49:55 - Edge is not hidden so Sprite X must be
49:58 - less than the width of the game area
50:00 - minus the width of the obstacle
50:04 - nice when I refresh the page I can see
50:06 - horizontally obstacles are always fully
50:09 - visible for vertical position I want to
50:11 - check the image but at the center point
50:14 - of collision a circle more than zero
50:16 - vertically will not be enough I want to
50:18 - Define an area that is reserved for this
50:21 - background artwork I don't want to Grant
50:24 - obstacles to appear over this area I
50:26 - create a property called top margin
50:29 - I guess a desktop area is around 260
50:32 - pixels of height
50:34 - let's check here
50:36 - yes 260 looks alright because I want to
50:39 - make sure the base of the obstacles
50:40 - doesn't overlap with this top area but I
50:43 - don't mind if the top of the obstacle
50:45 - Sprite sheets overlaps like this because
50:47 - this looks like the obstacle plant is
50:49 - standing in front of the background
50:52 - Forest View so this is fine
50:55 - I will also check if the center point of
50:57 - obstacle Collision area circle is less
50:59 - than the height of the game area
51:02 - I want some margins I can for example
51:05 - create a helper variable that's equal to
51:08 - Collision radius of the test obstacle
51:10 - times two
51:12 - I replaced this hard-coded value with
51:14 - this.top margin property we defined plus
51:18 - I want to give it some additional top
51:20 - margin so that characters and special
51:22 - enemies can squeeze in between obstacles
51:24 - and game boundaries when walking across
51:27 - the game field horizontally from right
51:29 - to left
51:30 - I will also account for the margin from
51:33 - the bottom of the game area to create
51:34 - some space there
51:36 - we wrote code that automatically places
51:38 - obstacles in our game World these
51:41 - obstacles never overlap and their
51:43 - correlation areas are placed to allow
51:45 - enough space in between them this will
51:47 - make the next steps much easier because
51:49 - we need enemies and friendly NPCs to be
51:52 - able to automatically walk around them
51:54 - using very simple artificial
51:55 - intelligence
51:57 - we have different images for obstacles
51:59 - but right now we are drawing only the
52:01 - first top left frame at coordinate 0 0.
52:04 - we can crop out different areas from the
52:07 - obstacles Sprite sheet horizontal crop
52:09 - area will start from the position we
52:11 - pass as Source X argument to draw image
52:14 - method here zero times Sprite width is
52:17 - this Frame one times Sprite width will
52:20 - be this Frame two is this one three is
52:24 - this one back to zero to select from
52:27 - which row we are cropping we use Source
52:30 - y argument here again we multiply row
52:32 - number by the actual height of
52:34 - individual Sprite frames so zero times
52:37 - Sprite height is this one times Sprite
52:40 - height is this now we are on Row 2 and
52:44 - there is no Row 3 because we start from
52:46 - row zero images are drawn and cropped
52:49 - from the top so instead of hard coding
52:52 - these values that are currently set to 0
52:54 - 0 let's turn them into class properties
52:57 - for cloud Authority and easy control
52:59 - this.frame X will determine which column
53:02 - we are on in our obstacle Sprite sheet
53:04 - if I do a random number between 0 and 4
53:07 - this will not work there is no column
53:10 - 1.74 for example we need integers
53:13 - numbers without decimal points so I wrap
53:16 - it in my third floor to round the random
53:19 - value generated by Mazda random to the
53:21 - closest lower integer this code will
53:24 - give me either 0 or 1 or 2 or 3. so one
53:29 - of our Sprite columns
53:30 - when we multiply these integers by the
53:33 - width of a single Sprite frame and we
53:35 - pass that value as a source X argument
53:37 - to draw image method we are defining
53:40 - horizontal cropping coordinate
53:43 - that worked perfect I will do the same
53:45 - for frame Y which will determine Sprite
53:48 - row we have only three rows this line of
53:51 - code will give me integers either 0 or 1
53:54 - or 2 corresponding to the number of rows
53:56 - we have available in our obstacle Sprite
53:59 - sheet now we can replace this hard-coded
54:01 - 0 with this dot frame y so Source y
54:04 - argument passed the draw image method
54:06 - will be this dot frame y times this dot
54:09 - Sprite height I will do that in a second
54:12 - random values in frame X and frame y
54:15 - combined will give us random image out
54:17 - of these 12 available obstacles each
54:20 - obstacle object will have random frame
54:22 - from this Sprite sheet assigned to it I
54:24 - will finish this a bit later
54:27 - [Music]
54:32 - on the main game object I create a
54:35 - method I call check Collision I want
54:37 - this to be a reusable utility method
54:39 - that takes object a and object B and it
54:43 - will compare them and check if they are
54:45 - collided or not we will be able to use
54:48 - this all over the code base wherever
54:50 - Collision detection between two circles
54:52 - is needed
54:53 - the way I'm building my game all
54:55 - characters and objects will have a
54:57 - circular Collision area which will be a
55:00 - solid base that nothing can walk through
55:02 - and everything will react and walk
55:04 - around everything using this we can also
55:06 - push things around I will show you to
55:09 - check collision between two circles we
55:11 - have Circle A and A Circle B here we
55:14 - need to check DX first the distance
55:17 - between the center point of Circle A and
55:20 - the center point of Circle B on
55:22 - horizontal x-axis this reusable method
55:25 - will work only if all objects involved
55:27 - have properties with same name and
55:30 - conventions so we will make sure we name
55:32 - X and Y positions on each object as
55:35 - Collision X and collision y
55:37 - I'm using this overly descriptive
55:39 - property names so that it's very clear
55:41 - when X and Y coordinates relate to
55:43 - Collision area Circle and when they
55:46 - relate to image Sprite sheet positions
55:48 - this is a tutorial so I want things to
55:50 - be very clear and easy to understand
55:52 - [Music]
55:53 - we will also need a DUI the difference
55:55 - between the center point of Circle A and
55:58 - the center point of Circle B on the
56:00 - vertical y-axis
56:04 - then we want to know the distance
56:06 - between these two Center points so
56:08 - hypotenuse the longest side of this
56:11 - imaginary right triangle right angle 90
56:14 - degrees is here and this is the distance
56:17 - Pythagoras Theorem formula or
56:19 - alternatively built-in method hypotenuse
56:22 - method and we pass it Dy first and the X
56:25 - as the second argument
56:28 - to determine whether or not there is a
56:30 - collision We compare distance between
56:32 - these two Center points with radius of
56:34 - Circle A Plus radius of Circle B I will
56:38 - save this value as a custom variable I
56:40 - call for example sum of radii
56:43 - so if this tense is less then sum of
56:46 - radii we know the circles Collide if the
56:49 - distance is the same as the sum of radii
56:51 - circles are touching if the distance is
56:54 - more than the sum of radii we know there
56:56 - is no Collision this function will
56:58 - simply return true if there is collision
57:00 - and false if there is no Collision
57:04 - let's use our custom check Collision
57:06 - function
57:07 - up here inside update method on player
57:10 - class we check for collision between
57:11 - player and obstacles we have a one
57:14 - player object and multiple obstacle
57:16 - objects so to compare all we will call
57:18 - for each on obstacles array which holds
57:22 - all currently active obstacle objects I
57:25 - will call each object in the array with
57:27 - a helper variable name obstacle and I
57:29 - will console log check Collision method
57:31 - we just defined we know it expects
57:34 - circular object a and circle object b as
57:37 - arguments to compare the distance of
57:39 - their Center points to the sum of their
57:41 - radii so I pass it this which means this
57:45 - player object as Circle 1 and obstacle
57:48 - we are currently cycling over with this
57:50 - for each method as Circle B
57:53 - keep in mind that this reusable check
57:56 - Collision method can only compare
57:58 - objects that have Collision X Collision
58:00 - Y and collision radius properties
58:03 - defined in their class Constructor
58:06 - so I will make sure I keep the same name
58:08 - and conventions for all objects in the
58:10 - game we are building today as the player
58:13 - moves we are getting false and true in
58:15 - the console seems like this is working
58:17 - let's actually only console log the word
58:19 - Collision when collision between player
58:22 - and obstacle is happening now it's even
58:24 - easier to see that our code is working
58:26 - perfect
58:36 - inside render method I will draw
58:39 - obstacles first so behind and player
58:42 - after it so it will be drawn on top what
58:45 - if I want to also resolve our collisions
58:47 - what I mean is if player collides with
58:50 - an obstacle I don't want it to be able
58:52 - to walk through it like this I want the
58:55 - player Circle to be pushed one pixel
58:57 - back away from the obstacle Circle in
59:00 - the direction that points directly away
59:02 - from the center point of the obstacle
59:05 - this simple thing will make the obstacle
59:07 - solid and the player will actually slide
59:10 - around the obstacles and it will create
59:12 - nice physics let me show you
59:15 - I'm already calculating everything I
59:17 - need for that inside our custom check
59:19 - Collision method but this function
59:21 - currently returns only true or false I
59:24 - need this reusable method to return more
59:27 - values so that we can use them inside
59:29 - player class to calculate Collision
59:31 - resolution Vector functions and methods
59:34 - in JavaScript can return one value like
59:37 - this but they can also return an array
59:40 - that contains multiple values I want to
59:42 - return true or false Collision status as
59:45 - the first element in the array element
59:48 - with an index of zero we also want to
59:51 - return the distance we are calculating
59:53 - on line 127
59:56 - we will also need some over ADI from
59:58 - line 128 and we will need DX and Dy from
60:03 - lines 125 and 126. so now our custom
60:08 - check Collision method not only checks
60:10 - if Collision is happening or not it also
60:13 - gives us other values from calculations
60:15 - that happened along the way it's
60:17 - important that we remember the order in
60:19 - which we are returning these values
60:21 - element with an index of 0 is Collision
60:23 - status true or false element with an
60:26 - index of 1 is the distance sum of radii
60:29 - is index 2 DX is index 3 and d y is
60:32 - index 4. I will just copy that array
60:35 - that gets returned here and I comment it
60:38 - out just so I can see it as a helper
60:40 - reference
60:41 - now I want to take each of these values
60:43 - and save them as separate variables so
60:46 - that we can use them to calculate
60:47 - Collision resolution here and push to
60:50 - player in the correct direction away
60:52 - from the obstacle it's currently
60:54 - colliding with I will use something
60:56 - called restructuring assignment let's
60:58 - just write it and I will explain it when
61:00 - we see the whole thing
61:03 - I say let variable is this array
61:07 - and it is equal to check collision
61:10 - between this player object and the
61:14 - obstacle that for each method is
61:16 - currently cycling over
61:18 - I have to replace this first expression
61:21 - with a variable name I want to call it I
61:23 - want to call it Collision
61:26 - it will be that true or false value
61:28 - depending on the distance between Circle
61:30 - Center points so if this is true there
61:32 - is Collision if this is false there is
61:33 - no Collision
61:35 - the structuring assignment syntax is a
61:37 - JavaScript expression that makes it
61:39 - possible to unpack values from arrays or
61:42 - properties from objects into distinct
61:45 - variables I'm basically saying here
61:47 - create five variables for me the first
61:50 - variable called Collision is the array
61:52 - returned when we call check Collision
61:55 - method between displayer and obstacle
61:57 - index 0 distance variable is that array
62:01 - index 1 and so on the structuring
62:04 - assignment does this automatically
62:06 - behind the scenes it creates these five
62:09 - variables and pairs them with the values
62:11 - that sit at these indexes in the array
62:14 - returned by check Collision method
62:18 - this might be a bit strange if you never
62:20 - saw it before JavaScript destructuring
62:23 - is a good thing to get familiar with
62:24 - modern Frameworks use it a lot I'm
62:27 - basically just taking the array returned
62:29 - by check Collision method and I'm
62:31 - assigning each value to its separate
62:33 - variable name so that I can use them
62:34 - here
62:36 - so here we are inside update method on
62:38 - player class we are cycling through
62:40 - obstacles array comparing player with
62:43 - each obstacle object if there is
62:46 - collision between player and obstacle if
62:48 - Collision variable is true we consolock
62:51 - AAA
62:53 - this works I want to create a vector
62:56 - kind of a small line between 0 and 1
62:59 - pixels in length that line will point in
63:02 - the direction in which we want the
63:03 - player to be pushed to resolve the
63:06 - circle Collision to make sure that
63:07 - colliding player and obstacle repel each
63:10 - other causing the player to slide along
63:13 - the radius of the obstacle rather than
63:15 - going directly through it horizontal
63:17 - Vector will be the ratio between DX
63:19 - distance between player and obstacle
63:21 - center point on the horizontal x-axis
63:24 - and the actual distance between these
63:27 - two points we calculated before using
63:29 - check Collision method because DX will
63:33 - always be less than distance because
63:35 - distance is hypotenuse it's always the
63:37 - longest side of the imaginary right
63:39 - triangle unit X will always be a value
63:41 - between a 0 and 1 because we are
63:44 - dividing smaller value by a large value
63:46 - unit y will be the ratio between d y the
63:49 - distance between Center points on the
63:51 - vertical y-axis and they are actual
63:54 - distance between the two Center points
63:55 - again it will be a value somewhere
63:58 - between 0 and 1. this could also be
64:00 - negative values depending on how our
64:02 - objects sit in relation to each other on
64:05 - horizontal and vertical axes so actually
64:08 - unit X and unit y will be a value
64:10 - between -1 and plus 1.
64:15 - if I consulate unit X and unit y we can
64:18 - see these values the combination of
64:21 - these two values being added to players
64:23 - horizontal and vertical position for
64:25 - each animation frame will make it move
64:27 - in a certain direction and certain speed
64:30 - away from the center point of the
64:32 - obstacle
64:34 - I do that by taking player Collision
64:36 - Exposition the center point of players
64:39 - Collision Circle
64:41 - to push it outside the radius of the
64:43 - obstacle it is colliding with I move it
64:46 - horizontally to the position of center
64:48 - point of obstacle circle plus the sum of
64:52 - radii of player Circle and the obstacle
64:55 - circle plus one additional pixel outside
64:58 - times that unit X ratio to give it the
65:02 - right direction away from the obstacle's
65:04 - center point
65:06 - we do the same thing vertically center
65:09 - point of player Collision Circle will be
65:11 - moved to the position of collision
65:13 - center of obstacle circle plus sum of
65:16 - radii of obstacle and player circle plus
65:19 - 1 pixel times unit y to give it the
65:23 - right direction of the push I am trying
65:25 - to explain this in a very beginner
65:27 - friendly way but don't worry if it's
65:30 - still a bit unclear this is an important
65:32 - technique and every time you use it you
65:34 - will feel more and more familiar with
65:36 - this code eventually it will click for
65:38 - you how it works all you have to
65:40 - understand here is that this code is
65:43 - pushing the player one pixel outside the
65:46 - Collision radius of the obstacle in the
65:48 - direction away from the center point
65:52 - this is how you create very simple but
65:54 - very effective physics simulation in
65:57 - your game try to move the player around
65:59 - this feels very good doesn't it suddenly
66:02 - our obstacle circles turned into solid
66:04 - impossible objects well done if you
66:07 - followed all the way here this is the
66:09 - main trick we are using today for our
66:11 - physics game
66:12 - I adjust the speed modifier to a smaller
66:15 - value we learned how to make the player
66:18 - move towards a mouse or towards a
66:20 - specified point in a 2d space and how to
66:23 - make it navigate its way automatically
66:26 - around solid obstacles this is a
66:28 - powerful technique and you can do with
66:30 - it more than you can imagine we will
66:32 - explore some of that today hope you're
66:34 - having fun
66:39 - [Music]
66:44 - I prepared a special 8-directional
66:47 - player Sprite shoot for this class you
66:49 - can download it in the resource section
66:51 - below
66:52 - I will include some alternative colors
66:54 - probably mine is blue too much to
66:56 - mushrooms in my game art
66:58 - I will hide it with CSS here
67:01 - inside player class Constructor I create
67:04 - a reference to that image using get
67:06 - element by ID and I save it as
67:08 - this.image property
67:10 - inside our custom draw method I take
67:13 - context and I call built-in canvas draw
67:16 - image method that we already used before
67:19 - we already said that the draw image
67:21 - method needs at least three arguments
67:22 - the image we want to draw and X and Y
67:26 - where to draw it this will just draw the
67:29 - entire Sprite sheet
67:31 - we can pass it width and height to
67:33 - squeeze the entire Sprite sheet into
67:35 - that specified area
67:37 - we actually don't have these properties
67:40 - defined Sprite with the width of a
67:42 - single frame will be 255 pixels Sprite
67:46 - height is 255 as well then we create
67:50 - separate width and height properties to
67:52 - allow the potential if we want to
67:55 - introduce it later now we are squeezing
67:58 - the entire Sprite sheet into the area of
68:00 - one Sprite frame you probably already
68:02 - know that we will need the longest
68:04 - version of draw image method where we
68:06 - add Source X Source y Source width and
68:10 - Source height these values will first
68:12 - crop out a portion of the image in our
68:15 - case a single Sprite frame after that we
68:18 - draw that frame at the position defined
68:21 - by the last four arguments
68:24 - to draw the top left frame at coordinate
68:26 - 0 0 is simple we just did it with
68:29 - obstacle Sprite sheet
68:31 - Source X Source y 0 0 to define the
68:34 - beginning of cropping rectangle and
68:37 - Sprite width and Sprite height as Source
68:39 - width and Source height arguments to
68:42 - Define its size now we see only one
68:45 - frame
68:46 - I will calculate position of sprite
68:48 - sheet image in relation to Collision X
68:50 - and collision Y coordinates of player
68:52 - hitbox in these two separate properties
68:54 - just for clarity so keep in mind these
68:57 - properties Define the center point of
69:00 - player Collision Circle these two
69:02 - properties will Define the top left
69:04 - corner of sprite sheet frame image we
69:07 - are currently drawing to represent the
69:09 - player
69:11 - on canvas Circle coordinates are from
69:14 - the center point rectangle and image
69:16 - coordinates are from its top left corner
69:18 - and image and rectangle goes towards
69:21 - right bottom depending on its width and
69:23 - height from there
69:24 - we have to consider this when writing
69:26 - the following code
69:28 - Sprite X will be positioned in relation
69:30 - to Collision area it will be Collision X
69:33 - the center point of collision Circle
69:35 - minus half of the width of player frame
69:38 - like this
69:41 - I need to use Sprite X inside the draw
69:43 - image method as destination X argument
69:46 - here
69:50 - and for this to work we need to
69:52 - recalculate this value every time
69:54 - Collision X updates so I need to put
69:57 - this inside the update method here and I
70:01 - also do it for sprite Y which will be
70:03 - Collision y minus the half of player
70:06 - height
70:07 - I can delete it here
70:16 - and I use Sprite y property here as a
70:19 - destination y argument past the draw
70:21 - image method
70:22 - now it's positioned on top I actually
70:25 - want this Collision Circle to match the
70:27 - little shadow on the ground below the
70:29 - player as closely as possible because
70:31 - that's the contact point we will use
70:33 - when interacting with other objects in
70:36 - our game since the player is fixed pixel
70:38 - size I can offset it by a hard-coded
70:41 - value if we were scaling our characters
70:43 - in this game I would use a relative
70:45 - value here minus 100 moved the player
70:49 - image up
70:50 - so this is all right for now
70:53 - [Music]
70:59 - same as we did with obstacles Sprite
71:01 - sheet I want to navigate within our
71:03 - Sprite sheet by swapping from frame to
71:06 - frame horizontal navigation is handled
71:09 - by multiplying Sprite width by an
71:11 - integer representing the column in the
71:13 - Sprite sheet passed as Source X argument
71:16 - here when we cycle through this we will
71:19 - animate individual directions
71:21 - individual animation Loops to swap
71:24 - between directions in the spreadsheet
71:26 - the way our specific Sprite sheet is
71:28 - organized today we have to multiply
71:30 - Sprite height by an integer representing
71:33 - Sprite row you can see row 0 is player
71:36 - facing upwards away from us Row 1 is top
71:40 - right two is the player facing right
71:43 - three is bottom right 4 is facing down
71:46 - towards the camera Row 5 in our Sprite
71:49 - sheet is the player facing bottom left 6
71:52 - is facing in left I think you get the
71:54 - idea I put these integers into class
71:57 - properties
71:58 - frame X for horizontal Sprite navigation
72:01 - frame y for vertical I replace these
72:04 - hard-coded values with my new variables
72:06 - and now I can change what frame we are
72:09 - currently cropping out from the player
72:11 - Sprite sheet by giving different values
72:13 - to frame X and frame y
72:17 - I want to change frame y the row we are
72:20 - currently animating from the Sprite
72:22 - sheet which will determine where the
72:24 - player is facing I want that to depend
72:27 - on the current angle between Mouse and
72:30 - the player on the position where they
72:33 - are currently in relation to each other
72:35 - for this we have a built-in method
72:37 - called mass.atan2
72:38 - [Music]
72:42 - returns an angle in radians between the
72:45 - positive x-axis and a line projected
72:48 - from 0 0 towards a specific point we
72:52 - will use it to calculate the angle
72:54 - between the player and mouse cursor and
72:57 - based on that angle we will select which
72:59 - Row in the Sprite sheet we want to
73:01 - animate so that the player is always
73:03 - facing in the direction it is moving
73:05 - towards the mouse cursor we will need DX
73:09 - and d y so I move them up here
73:12 - so these values calculated the distance
73:15 - between the player and mouse cursor
73:17 - horizontally and vertically keep in mind
73:20 - that it makes a difference if you use
73:22 - Mouse first or the player first in this
73:24 - calculation I already wrote this code
73:27 - here before without thinking we would
73:28 - use it for this so we might have to
73:30 - adjust to it a bit I will show you
73:33 - exactly what I mean Master datan 2
73:35 - expects DUI first and DX as the second
73:39 - argument
73:44 - I will consult angle we are calculating
73:47 - and I can see it is changing and the
73:50 - values are from a minus 3.14 minus Pi 2
73:55 - plus 3.14 plus pi this checks out
73:59 - because we know that full circle is 2 pi
74:02 - approximately 6.28 radians which
74:05 - converts to 360 Degrees I will repeat
74:09 - that method A10 2 returns an angle in
74:12 - radians between the positive x-axis and
74:15 - a line projected from 0 0 towards a
74:19 - specific point because I'm using Mouse
74:21 - first and the player position second
74:24 - when calculating DX and d y I'm getting
74:27 - values from a math.a time to where the
74:30 - current Mouse position represents point
74:32 - zero zero and player position is the
74:35 - point we are projecting a line towards
74:38 - for the purposes of a nice visual it
74:40 - would work much better if player was the
74:42 - static 0 0 center point but I will leave
74:44 - with others and from the values I'm
74:47 - getting in the console I will create
74:48 - this graph with breakpoints in radians
74:51 - it was actually easy to make because I
74:53 - just needed one value as an anchor and I
74:56 - knew the whole area is from -3.14 to
75:00 - plus 3.14 and we have eight player
75:03 - directions so each slice was 6.28
75:07 - divided by 8. anyway you don't
75:10 - necessarily have to understand all of
75:12 - this right now when we have the full
75:13 - code you can play with the values which
75:15 - will hopefully bring more clarity it
75:18 - took me a while of using math but atan 2
75:20 - before I fully understood so if this is
75:23 - your first time seeing it don't put too
75:25 - much pressure on yourself
75:28 - if I pause the screen this is the point
75:31 - zero zero this is the line projected
75:33 - towards another point and master data
75:37 - and 2 gives us an angle in radians
75:39 - between this positive x-axis and this
75:42 - line so by using this console log to get
75:46 - an anchor point so that I can see which
75:48 - angle values we are getting I
75:50 - constructed this helper visual which I
75:52 - will now use to correctly swap player
75:54 - rows in our Sprite sheet to make the
75:56 - player always face the mouse
76:04 - if angle is less than -1.17 set frame y
76:09 - to zero
76:10 - I will copy this a few times
76:16 - minus 0.39 is frame y 1 plus 0.39 is
76:23 - frame Y2
76:26 - 1.17 radians is frame Y3
76:32 - 1.96 is frame y4 let's see hmm
76:37 - so far this is working great I think we
76:39 - got it I can delete the console log
76:44 - 2.74 is frame 5. this area is a bit
76:48 - weird as the circle ends and starts I
76:51 - have to say if angle is less than minus
76:54 - 2.74 or if angle is more than plus 274
77:00 - I want to use frame Y6
77:05 - if angle is less than minus 1.96 frame Y
77:09 - is 7. pay attention to brackets here
77:12 - minus and plus values and less than
77:14 - operators if you are getting any
77:16 - unexpected Behavior make sure all of
77:18 - this code is the same as mine it's easy
77:20 - to make a small mistake here and break
77:23 - your code accidentally
77:25 - for this to work for all directions I
77:27 - have to adjust it a bit I can for
77:29 - example take these lines and put them
77:31 - here because with else if statement it
77:34 - matters which one is checked first
77:36 - sometimes
77:41 - I reduce the player speed modifier to 3
77:44 - so we can clearly see how it turns while
77:46 - destined
77:48 - now we can turn the player in all eight
77:50 - directions perfect we will learn more
77:53 - about sprite animation later in the
77:55 - class for now I'm happy with this
77:58 - [Music]
78:03 - physics game where we are placing
78:05 - Collision areas at the base of each
78:07 - object we want to be able to quickly
78:10 - swap between the view where these
78:12 - Collision areas are visible and
78:14 - invisible it will help us to tweak the
78:16 - physics and gameplay elements as we are
78:19 - developing them while giving us an easy
78:21 - way to check how the changes we just
78:23 - made will be visible for the player who
78:25 - will not see these hitboxes I want to
78:27 - create a debug mode by pressing letter D
78:30 - on the keyboard we will toggle all
78:32 - helper Collision elements on and off on
78:35 - the main game class I create a property
78:37 - called this dot debug and initially I
78:39 - set it to
78:41 - true
78:42 - down here where we placed our event
78:44 - listeners I create another one we will
78:47 - listen for key down event
78:57 - let's just console event object when I
79:00 - select canvas by clicking on it and then
79:02 - I press any keyboard key we get this
79:05 - Auto generated keyboard event object
79:07 - inside we have a property called key you
79:11 - can see I pressed letter R so the key
79:14 - that was pressed sits inside e.key
79:17 - property
79:18 - I say if e dot key is a d set debug
79:21 - property from line 123 to its opposite
79:25 - value so if it's currently true set it
79:27 - to false if it's false set it to true
79:30 - this way pressing the same key letter D
79:33 - will toggle debug mode on and off
79:37 - I tested by console login this dot debug
79:39 - I press D over and over and in console I
79:43 - see it switches between true and false
79:45 - perfect I remove the console log
79:48 - up here inside the draw method on
79:50 - obstacle class I say if this dot
79:52 - game.deback is true only then draw the
79:55 - Collision area Circle
80:01 - now I can press letter D to show and
80:03 - hide them that works well
80:09 - I want to do the same for the player if
80:11 - this dot game.deback is true only then
80:14 - draw the Collision Circle and also the
80:17 - line between the player and the mouse in
80:19 - this case positioning and size of the
80:22 - hitboxes is not perfect yet but we do
80:24 - have all the logic in place now great
80:26 - job I can make a collision radius of
80:29 - each obstacle smaller to better match
80:31 - the part where it touches the ground
80:34 - we have different obstacle types here
80:36 - the mushroom and this big carnivorous
80:38 - plant should probably have different
80:40 - Collision circles which can easily be
80:42 - done but for now I'm happy with this you
80:45 - can see that the Collision formula we
80:46 - wrote before is all we need to give the
80:49 - player very simple path finding ability
80:51 - it will just walk around obstacles
80:54 - automatically and since we placed
80:55 - obstacles in a way that there are always
80:58 - spaces in between it's unlikely that the
81:00 - player will get stuck
81:03 - I can also see I'm only getting the
81:06 - first four obstacle images which reminds
81:08 - me to go here to line 108 and include
81:11 - randomized frame y value as Source y
81:14 - argument in obstacle draw image method
81:16 - now I'm randomly getting one of all 12
81:19 - obstacle images you can play with this
81:22 - end position and size your hitboxes
81:24 - differently if you want I'm happy with
81:26 - what we did so far
81:32 - [Music]
81:36 - I wanted to make sure the player can't
81:39 - walk so high that it's above this
81:41 - background artwork area let's create
81:43 - some horizontal boundaries first
81:49 - point of player Collision circle is less
81:52 - than x coordinate 0 plus Collision
81:55 - radius set it to zero plus Collision
81:58 - radius so when the left edge of the
82:00 - circle is touching the left edge of
82:02 - canvas area don't allow it to go any
82:04 - further left
82:09 - I want to do the same thing for the
82:11 - right Edge
82:13 - of course we can delete this zero plus
82:15 - here and here
82:18 - if the center point of player Collision
82:19 - circle is more than the width of the
82:22 - game minus the radius of player
82:24 - Collision Circle
82:28 - make sure it can't go any further right
82:37 - nice
82:40 - vertical boundaries
82:45 - if Collision Y is less than vertical
82:48 - coordinate zero plus top margin we
82:51 - defined to be 260 pixels from the top
82:54 - plus Collision radius
82:57 - make sure that the player can't go any
82:59 - more up
83:05 - that works nice
83:07 - this is what I wanted
83:11 - again we can delete 0 plus here and here
83:20 - bottom boundary
83:22 - that's simple if Collision Y is more
83:24 - than the height of the game minus
83:27 - Collision radius
83:31 - make sure it stops there like this
83:41 - that works if I make player Collision
83:43 - radius smaller than obstacle radius
83:46 - because of the margin we defined while
83:48 - positioning obstacles there will always
83:50 - be a place for a player to squeeze
83:52 - between obstacles and the edges of game
83:55 - area
83:56 - there is not so
83:59 - down here I increase that margin
84:03 - they should do it you can compare your
84:05 - code with in progress source code I will
84:08 - include to download in a project section
84:10 - Below in multiple points during this
84:13 - class as we progress with our project
84:21 - [Music]
84:25 - I can see the bottom of the Sprite sheet
84:27 - is being cut off on the lower rows it's
84:30 - because the height of a single frame is
84:32 - actually 256 pixels
84:35 - now it's fixed
84:39 - in Visual Studio code editor I select
84:42 - the view word wrap to make the code
84:44 - break to another line if it cannot fade
84:46 - if it's too long I want to set FPS for
84:50 - the entire game because with my previous
84:52 - project a lot of you mentioned that
84:54 - games run too fast on your game in high
84:56 - refresh rate screens request animation
84:59 - frame a method we are using here will
85:01 - automatically adjust itself to screen
85:04 - refresh rate so for normal screens that
85:06 - would be around 60 frames per second but
85:09 - on some of the new gaming screens that
85:11 - people use that speed would be double or
85:14 - maybe not exactly double but much faster
85:16 - we will calculate Delta time the amount
85:19 - of milliseconds that passed between each
85:21 - call of request animation frame and we
85:24 - will only allow the game to serve the
85:26 - next animation frame when a specific
85:29 - number of milliseconds has passed
85:33 - we can calculate the Delta time down
85:35 - here inside our custom animate function
85:37 - first I Define last time outside the
85:41 - function like this initially I set it to
85:44 - zero this variable will always hold a
85:46 - reference or
85:48 - the amp from the previous animation Loop
85:50 - so that we can compare it with the
85:52 - current timestamp and the difference
85:54 - between them will be Delta time request
85:57 - animation frame has two special features
85:59 - as we said it will automatically try to
86:02 - adjust itself to the screen refresh rate
86:04 - in most cases 60 frames per second
86:08 - it will also automatically generate a
86:10 - timestamp for us that we can use and it
86:13 - will pass that timestamp as an argument
86:15 - to the function it calls in our case
86:18 - animate imagine it's passing the
86:20 - timestamp here like this automatically
86:23 - it's Auto generated all we have to do to
86:26 - use it is to assign it a variable name
86:28 - here I will call it timestamp spelled
86:31 - like this be mindful of Laurel and
86:33 - uppercase letters when defining your
86:35 - variable names in JavaScript it matters
86:37 - let's just console log this
86:39 - auto-generated timestamp variable that
86:41 - request animation frame is giving us
86:43 - just to see what format it is in you can
86:47 - see it gives us milliseconds since the
86:49 - first animate was called one second is a
86:52 - thousand milliseconds so here I can
86:54 - literally see that the game started 9 10
86:57 - 11 12 13 seconds ago I delete this
87:02 - console log we know we have access to
87:05 - the current timestamp so let's use it to
87:07 - calculate Delta time it will be the
87:09 - difference between the timestamp from
87:11 - this animation Loop and the timestamp
87:14 - from the previous animation Loop Delta
87:17 - time is the number of milliseconds it
87:19 - took our computer to serve the next
87:21 - animation frame once we used last time
87:24 - to calculate Delta time we assign it to
87:27 - the current timestamp this way the
87:29 - current timestamp can be used in the
87:31 - next animation loop as the old timestamp
87:34 - for the very first animation Loop last
87:36 - time will be zero but after that it will
87:39 - always hold the value of the tab step
87:41 - from the previous animation frame so
87:43 - that we can compare it with the value of
87:45 - timestamp from this currently running
87:47 - animation frame and that difference
87:50 - between them is Delta time
87:54 - so let's consolow Delta time to see if
87:57 - it worked my Delta time is around 16.6
88:01 - milliseconds thousand milliseconds
88:03 - divided by 60 is 16.6 so this checks out
88:07 - I wonder how many of you got the same
88:09 - Delta time and how many of you got a
88:11 - different number if you have a high
88:13 - refresh screen your Delta time will be a
88:16 - much smaller number if you have an old
88:18 - computer that is struggling to animate
88:20 - our game your Delta time might be much
88:22 - higher if you have a second to write
88:24 - your Delta time in the comments so we
88:26 - know if most people get the same or very
88:28 - different values than me it will help me
88:30 - to better optimize my future courses
88:34 - if I scroll up in the console to the
88:36 - very first timestamp you can see that
88:38 - the first two values of Delta time are
88:41 - none not a number it is because the very
88:44 - first timestamp is undefined because
88:46 - only on the second Loop this timestamp
88:48 - value gets Auto generated by request
88:51 - animation frame the first Loop is not
88:53 - triggered by request animation frame
88:55 - it's triggered by this line so in the
88:58 - beginning when we say that Delta time is
89:01 - undefined minus 0 here we get none not a
89:04 - number it automatically fixes itself as
89:07 - the loop runs but these two initial not
89:09 - a number of values could break your code
89:11 - that depends on Delta time unless you
89:14 - account for it with some kind of or
89:16 - statement for example the easiest way to
89:18 - fix this is to pass 0 here as the
89:21 - timestamp for the first animation loop
89:23 - from the second Loop the value will
89:25 - become the auto generated downstamp
89:27 - because after that animate will be
89:30 - called by request animation frame as you
89:32 - can see we get numbers here and there
89:35 - are no non-values anymore perfect
89:38 - I delete this console log
89:43 - so let's use Delta time to set frame
89:46 - rate of our game we will need some
89:48 - helper variables FPS frames per second
89:50 - will be for example 20. timer will count
89:54 - over and over from zero towards a
89:56 - specific value when it reaches that
89:59 - value it will trigger the next animation
90:01 - frame and it will reset back to zero
90:03 - interval will be that breakpoint value
90:06 - that when reached will reset timer
90:09 - it will be a thousand milliseconds one
90:12 - second divided by FPS this will give us
90:15 - the amount of milliseconds needed to
90:17 - achieve this specific FPS
90:20 - we will manage this Frame handling logic
90:22 - down here inside render method if timer
90:25 - is more than interval do something
90:29 - at the same time keep increasing timer
90:31 - by the value of delta time over and over
90:34 - so when timer accumulated enough Delta
90:37 - time enough milliseconds that its value
90:39 - is more than interval we will animate
90:42 - the next frame we will also reset timer
90:45 - back to zero so that it can count again
90:47 - for the future frame update
90:50 - I will take all this code and I put it
90:52 - inside the if statement like this
90:58 - we are using Delta time value on line
91:01 - 173 that value will be passed as an
91:04 - argument to render method up here
91:07 - and
91:09 - inside animation Loop we are calculating
91:11 - Delta time here
91:13 - and we will pass it to render like this
91:22 - okay so something is happening the
91:25 - reason everything is blinking is that we
91:27 - are deleting old paint all the time but
91:30 - only redrawing our game when timer
91:32 - reaches interval
91:34 - cut this clear rectangle from here so
91:37 - now we are not clear in old paint at all
91:39 - and everything is animating at 20 frames
91:42 - per second and everything is leaving
91:44 - trails
91:46 - and I will clear old paint only when we
91:50 - are ready to redraw the next updated
91:52 - game frame here so context clear
91:56 - rectangle from chlorine at 0 0
91:59 - two distort with desktop height to clear
92:02 - the entire game area one optimization
92:05 - would be to draw our game on multiple
92:06 - canvas elements and only clear the
92:09 - portions of cannabis that actually
92:10 - updated that way we wouldn't have to
92:13 - redraw everything all the time for now
92:15 - this will work fine you should be able
92:17 - to see a slow down in-game animation
92:19 - speed because we are setting FPS here to
92:22 - 20 to make it even more obvious maybe I
92:26 - only want to animate 5 frames per second
92:29 - 30.
92:34 - 40.
92:37 - 50.
92:41 - 60. I'm setting fps to 60 frames per
92:45 - second but we are not actually animating
92:46 - our game at 60 FPS because every time I
92:49 - reset timer back to zero there is some
92:52 - leftover Delta time I am not accounting
92:54 - for so even though I say 60 the actual
92:57 - FPS is a bit lower I can go down and I
93:01 - can account for that leftover Delta time
93:03 - but maybe I want to keep this code base
93:05 - lightweight maybe I don't want to make
93:07 - JavaScript to do even more calculations
93:09 - over and over so while keeping this in
93:11 - mind I will know that I have to set fps
93:14 - to a slightly higher value here to
93:17 - actually get something around 60 FPS if
93:20 - I set this to 70 I think we get smooth
93:22 - enough movement and we are not making
93:24 - JavaScript calculate leftover Delta time
93:27 - which would slightly increase how
93:28 - performance demanding our game is I just
93:31 - thought of this now I'm not sure which
93:33 - is a better solution I will leave my
93:35 - code like this for now but I guess the
93:37 - right solution here will be up to
93:39 - everyone's personal preference feel free
93:41 - to discuss this in the comments I will
93:43 - consider your feedback in my future
93:45 - projects now that we know how to control
93:47 - animation speed of our game using Delta
93:51 - time the game will run at a similar
93:53 - speed on every machine even for those of
93:55 - us who are using High refresh rate
93:57 - screens
94:00 - [Music]
94:05 - I want to add eggs that can be pushed
94:08 - around to include even more physics in
94:10 - our game those eggs will be hatching
94:12 - into creatures after a specific timer
94:14 - has passed and player's job will be to
94:17 - protect the creatures that hatch the
94:20 - eggs can be pushed around by enemies but
94:22 - they won't be destroyed the challenge
94:24 - for the player is when they hatch
94:26 - enemies will eat the hatchlings so
94:28 - player's job in our game will be to
94:31 - position the X to protect them or to
94:34 - push enemies away from the path of the
94:36 - newly hatched creatures The larva that
94:39 - comes from each egg will always try to
94:41 - crawl into safety and hide in the bushes
94:44 - inside the mushroom Forest at the top
94:47 - this will introduce a lot of player
94:49 - choice and player options into our game
94:51 - while using physics we implement it I
94:53 - got an idea for this game a mechanic
94:55 - while watching a nature documentary
94:57 - where little baby turtles are hatching
94:59 - on the beach and trying to get to the
95:02 - Sea for safety in our game we control
95:04 - the Blue bull its job is to protect the
95:07 - hatchlings by pushing eggs larvas and
95:10 - enemies around this game is all about
95:12 - physics and positioning
95:15 - I will have a custom class I call for
95:18 - example egg Constructor will expect a
95:20 - reference to the main game object as
95:22 - usual to make sure EK class has access
95:25 - to many important properties held on the
95:28 - game object
95:29 - X will be part of the game physics so I
95:32 - need to make sure I Define separate X
95:35 - and Y coordinates for Collision Circle
95:37 - Center Point and for the Sprite sheet
95:39 - let's start with Collision X property it
95:42 - will be a random value between 0 and the
95:45 - width of the game area
95:47 - Collision y will be between 0 and game
95:49 - height like this
95:51 - Collision radius for example 40 pixels
95:57 - this dot image will be
95:59 - document.getelementbyid and the ID is
96:02 - act
96:03 - in index.html I actually have to create
96:06 - that image element as always images can
96:09 - be downloaded in the resources section
96:11 - below
96:12 - I hide it with CSS here I'm keeping the
96:15 - same name and conventions across my
96:17 - objects it's a good practice so Sprite
96:19 - width will be 110 pixels and Sprite
96:22 - height is 135 width and height will be
96:26 - set to these same values
96:29 - in our game every object has Collision X
96:32 - and collision y properties that
96:34 - represent the center point of collision
96:36 - area Circle even player and obstacles
96:39 - have the properties named like this so
96:42 - that we can use reusable Collision
96:44 - detection method to implement our
96:46 - physics to everything same goes for
96:49 - sprite X and Sprite y properties those
96:51 - represent the top left corner position
96:54 - from which the object's image will be
96:56 - drawn Sprite X of egg image will be
96:59 - Collision X plus half of the width of
97:01 - the egg image to Center the image over
97:04 - Collision Circle horizontally
97:07 - Sprite y will be Collision y plus half
97:10 - of image height
97:12 - we might have to adjust this a bit later
97:15 - because vertically we want the Collision
97:17 - area to be at the base of the egg not in
97:20 - the middle we'll get to that soon draw
97:22 - method will expect context as an
97:24 - argument as usual we call draw image and
97:28 - this time we just need three arguments
97:31 - the image we want to draw and X and Y
97:33 - coordinates where to draw it
97:36 - if we were scaling we would also include
97:38 - optional width and height arguments like
97:40 - this but I'm giving you all the images
97:42 - in the same size we are drawing them in
97:45 - game so it's actually not necessary
97:48 - as with all game objects we are not only
97:50 - drawing the image representing the
97:52 - object we are also drawing Collision
97:54 - Circle if debug mode is active since we
97:57 - are keeping the same naming conventions
97:59 - for properties all over our code base we
98:02 - are making our life easier I can just
98:04 - copy this entire code block and use it
98:07 - here so we are drawing X image and if
98:10 - debug mode is on we are drawing
98:13 - Collision area
98:14 - yes probably it's a good idea to put
98:16 - this code in a reusable method since we
98:19 - are using the same code to draw
98:20 - Collision circles for everything I might
98:22 - do that later for now I want to create a
98:25 - method that will periodically add a new
98:27 - egg into our game on the game class we
98:30 - will have an array that will hold all
98:33 - currently active egg objects
98:36 - I will also have another property called
98:38 - number of eggs
98:40 - or Max X describes it even better
98:43 - we will only be adding new x to the game
98:46 - until the total is less or equal to Max
98:49 - x value
98:53 - [Music]
98:56 - inside render method here we will handle
98:59 - the logic to add X periodically we
99:02 - already did it we did periodic event in
99:05 - this code base where we use the Delta
99:07 - time and triggered new game frame only
99:10 - when a certain interval value was
99:12 - reached we will actually do the same
99:14 - thing here we will need some helper
99:16 - variables for that egg timer will go
99:19 - from 0 to X interval value then it will
99:23 - add a new egg and it will reset so that
99:26 - it can count again we are operating with
99:29 - Delta time so milliseconds I want to add
99:31 - a new X let's say every 500 milliseconds
99:37 - down here I will check if egg timer is
99:40 - more than egg interval
99:45 - we add a new egg by calling this method
99:48 - from line 220.
99:51 - inside there I just take the X array I
99:55 - call built-in array push method and I
99:57 - will push one new instance of our custom
100:00 - egg class in there as usual we know that
100:03 - the egg glass expects the game as an
100:06 - argument so
100:07 - I pass it this keyword because we are
100:10 - inside that game object here
100:13 - so if egg timer is more than egg
100:15 - interval we call add egg we will also
100:18 - reset egg timer back to zero so that it
100:21 - can count again towards the next egg
100:23 - else we keep increasing egg timer by
100:26 - Delta time which we are already passing
100:28 - here to render method from before
100:31 - I console log this.x to see if the
100:34 - objects are being added
100:36 - sorry this will just create an endlessly
100:38 - growing array I need to create
100:40 - additional condition here only add new X
100:42 - as long as the length of X array is less
100:46 - than Max X that's better
100:50 - I inspect one of the egg objects
100:53 - I need to make sure all the properties
100:55 - have values if for example I have
100:57 - undefined as Collision x coordinate my X
101:01 - wouldn't be drawn on canvas because
101:02 - JavaScript wouldn't know where to draw
101:05 - them I see values on everything this
101:07 - looks great
101:09 - inside render method I would also like
101:11 - to draw my X I just copy this line and I
101:15 - adjust it for each element in X array we
101:18 - will call it egg and we will call draw
101:21 - method on it perfect now we are getting
101:24 - some visuals which will make it even
101:26 - easier for us to tweak the details and
101:28 - polish it the first thing I notice is
101:30 - that all the eggs are added almost
101:32 - instantly even though I said I want one
101:34 - egg every 500 milliseconds if I increase
101:37 - egg interval to one second here I can
101:40 - see that something is wrong with my code
101:42 - I know the problem must be inside this
101:45 - code block and
101:47 - it's because egg timer is more than egg
101:49 - interval and only then add a new egg we
101:53 - need to use this comparison operator
101:54 - here sorry about that typo you probably
101:57 - noticed it already before now it works
102:00 - we get one New Egg add it every one
102:03 - second as long as we have less than 10x
102:06 - I can also see that the egg images are
102:09 - positioned outside the Collision circles
102:11 - I change this plus to minus here and
102:15 - also here
102:16 - now that's better I want to adjust the X
102:19 - Sprite sheet in relation to its
102:21 - Collision circle plus 35 will move it up
102:25 - minus 35 will move it down minus 30. I
102:30 - want it to match the bottom of the image
102:32 - as closely as possible but also I don't
102:35 - want the Collision Circle to be too tall
102:37 - because I want the player to be able to
102:40 - walk behind the egg without pushing it
102:42 - to have this illusion that our game area
102:45 - is in 3D and that it has some depth even
102:48 - though in reality it's just a flat
102:51 - surface we will do more to enforce this
102:53 - in a moment now I want to create a
102:55 - margin to make sure the X appear certain
102:58 - minimum distance from the edges of the
103:00 - game area so that we can get the player
103:03 - between the egg and the edge to push it
103:05 - anywhere we want
103:07 - I want the margin to be let's say
103:09 - Collision radius times 2.
103:16 - the initial X position of collision
103:19 - Circle will be a random value starting
103:21 - from left from that margin value we just
103:24 - defined and game width minus that margin
103:31 - down here I set X interval to 100
103:34 - milliseconds and I want 50x
103:38 - just to get a better idea where they can
103:41 - possibly spawn in our game
103:43 - we have that left margin I wanted but I
103:46 - can see that the eggs are too far to the
103:48 - right Edge so here I increase that right
103:51 - margin like this
103:53 - yeah I'm happy with this the eggs are
103:55 - now always fully visible horizontally
103:57 - with some extra space left and right
103:59 - between the edges of the game area
104:01 - vertically I will do something similar
104:04 - but the random position needs to start
104:06 - below the top margin area we defined
104:09 - earlier I don't want any X in front of
104:11 - this background artwork the way Master
104:14 - random works I just pushed the range
104:16 - from here to here I also need to narrow
104:19 - the range down by reducing the span of
104:22 - random values we get so game height
104:25 - minus top margin
104:28 - now X can appear from here to here
104:33 - I will reduce the randomized value by
104:36 - margin to give it some space at the
104:38 - bottom like this
104:39 - perfect if you are a beginner math at
104:42 - random can be unintuitive it's actually
104:44 - very simple it can just take some
104:46 - practice so here I'm saying set
104:49 - Collision y property to a random value
104:51 - starting from Top margin here
104:54 - because we're going from the top and the
104:57 - range of random values is game height
104:59 - minus that margin minus this other
105:02 - margin so X can appear anywhere between
105:05 - here and here vertically
105:08 - I set interval to 500 milliseconds and
105:11 - Max X to be for example 10 for now this
105:15 - means we will get an egg appear every
105:17 - half second until the total count is 10.
105:20 - this is a physics game so we wanted the
105:22 - player to be able to push the X around
105:24 - to move them out of the way of incoming
105:27 - enemies or to position them
105:28 - strategically to give the larva that
105:31 - will hatch from it the best chance of
105:33 - survival in this game I choose that X
105:36 - will be indestructible enemies will just
105:38 - push the X out of the way if they
105:40 - Collide but the larva that hatches will
105:43 - be eaten if anime catches it so
105:45 - positioning and pushing the X around is
105:48 - very important let's give the X some
105:50 - Physics
105:52 - [Music]
105:56 - I give each egg an update method inside
106:00 - we will create a temporary helper array
106:02 - called Collision object this will
106:05 - contain all objects in our game that X
106:07 - will interact with
106:09 - we will check for collision between each
106:12 - egg and this object so we will need
106:14 - player here this dot game.player like
106:17 - this and of course we need the solid
106:19 - obstacles in here I want all these
106:21 - elements to be on the same level in
106:23 - Collision object array we have player
106:26 - object here and we will spread obstacles
106:28 - array into Collision object array using
106:31 - spread operator like this
106:34 - spread operator allows us to quickly
106:36 - expand elements in an array into another
106:39 - array
106:41 - I will actually call this Collision
106:42 - object with an s
106:44 - I will call for each on it for each of
106:47 - these objects so in this case for player
106:50 - and all individual obstacles we have
106:53 - here I want to use this check Collision
106:55 - method we defined on line 225. if you
106:59 - remember it takes object a and object b
107:02 - as arguments and it returns an array
107:05 - that gives us true or false for
107:07 - Collision this stands between two
107:10 - Collision Circle Center points some of
107:12 - their radii and horizontal and vertical
107:15 - distance between the two Center points I
107:18 - copy this array
107:20 - I paste it up here and again we will use
107:23 - the structuring to quickly Define these
107:26 - five variables using a single line of
107:28 - code
107:29 - I need a variable name here so I will
107:31 - call the first one Collision true or
107:33 - false whether the echo lights with
107:35 - player or any obstacle we did this
107:37 - before I want these to be lead variables
107:40 - and they will be equal
107:42 - to
107:43 - this.game.check collision between this
107:45 - egg because we are inside update method
107:48 - on egg class and one of the objects in
107:51 - collisions object array
107:53 - so as the for each method runs we are
107:55 - running check Collision method between
107:57 - this egg and each element in this array
108:00 - and we are getting five variables that
108:02 - tell us more details about position and
108:05 - collision of these two objects we are
108:07 - comparing
108:10 - if Collision is detected we will
108:12 - actually use all these values to
108:14 - calculate how far and in which direction
108:16 - we want to push the egg
108:21 - horizontal direction of the push will be
108:23 - the ratio between DX the horizontal
108:26 - distance between the two Center points
108:28 - and the distance hypotenuse of that
108:31 - imaginary right triangle because DX is a
108:34 - side of that triangle and the distance
108:36 - is hypotenuse the longest side we are
108:39 - dividing a smaller value by a large
108:41 - value because of that unit X will be
108:44 - something between -1 and plus one DX can
108:48 - be positive or negative
108:52 - unit y vertical push direction will be
108:55 - the ratio between d y and distance now
108:59 - we will use this to move the egg we are
109:01 - inside a code block that will only run
109:03 - if egg is colliding with player or any
109:06 - of the obstacles so when Collision
109:08 - happens we take Collision X of the egg
109:10 - and we push it one pixel outside of the
109:13 - radius of the object it is colliding
109:16 - with so Collision X of the object the
109:19 - center point plus one extra pixel to
109:21 - move the egg outside of collision area
109:24 - so this is how far and the horizontal
109:27 - direction of that move will be defined
109:29 - by multiplying it by unit X which as we
109:32 - said can be positive or negative
109:35 - we also need to move the colliding egg
109:38 - vertically collision center point Y of
109:40 - the egg will be Collision y of the
109:43 - object it's colliding with Plus radius
109:46 - of egg Plus radius of the object plus
109:49 - one extra pixel so that in the next Loop
109:51 - Collision is false terms vertical
109:54 - Direction defined by unit y notice that
109:58 - here we are detecting collision and I am
110:01 - a moving Collision X and collision y of
110:03 - the egg based on the position of the
110:05 - obstacle this is just my choice and
110:08 - doing this will make the egg move and
110:10 - all these elements will be solid in that
110:12 - interaction when interaction happens egg
110:15 - will move player and obstacles will
110:17 - remain solid they will not be pushed by
110:20 - the egg
110:21 - down here we call draw method on each
110:24 - egg we also want to call this new update
110:26 - method we just wrote
110:34 - Let's test it
110:36 - we are pushing Collision circle of this
110:38 - egg I need to make sure that Collision
110:40 - area and Sprite stick together the
110:44 - simplest way would be to take this code
110:46 - that positions Sprite X and Sprite Y in
110:49 - relation to Collision X and collision Y
110:51 - and I will call it inside update method
110:55 - I can remove the values here and now we
110:58 - can push the X using player and they
111:01 - will also Collide and slide around our
111:03 - mushrooms and plants around the solid
111:06 - obstacles the eggs don't interact with
111:09 - each other this is just my choice I want
111:11 - the X to overlap so that a skilled
111:14 - player can push multiple eggs kind of
111:16 - hurt them together and push all of them
111:18 - at the same time this choice will also
111:21 - keep our code simpler because we are
111:23 - learning
111:26 - [Music]
111:32 - we are drawing everything on a single
111:34 - canvas element so the draw order of our
111:36 - game objects what is drawn behind and
111:39 - what is up front will depend on the
111:42 - order in which we call draw methods on
111:44 - each object from inside render method
111:46 - here right now I draw obstacles so
111:49 - mushrooms and plants then I draw X so X
111:53 - are drawn on top of obstacles as you can
111:55 - see here and then we draw the player
111:58 - player is drawn on top of everything
112:00 - else if I take the X and draw them first
112:03 - they will always be drawn behind the
112:06 - obstacles and behind the player and here
112:09 - we can see that it doesn't really make
112:11 - visual sense I wanted to create an
112:13 - illusion of depth fake 3D or maybe two
112:16 - and a half D objects that are low should
112:19 - be up front as we move up objects drawn
112:22 - on that vertical Baseline should be
112:23 - drawn behind for example this egg should
112:26 - be drawn in front of this plant not
112:29 - behind find it we can't really achieve
112:31 - that if we draw all X then all obstacles
112:34 - and then the player we need to adjust
112:36 - our code a little bit I will have to put
112:39 - all these objects into a single array
112:41 - and I will sort that array based on
112:43 - vertical coordinates let me show you
112:45 - what I mean I create a new property on
112:48 - the main game class I will call it game
112:50 - object at first this will be an empty
112:53 - array
112:54 - in a side render method I will take a
112:56 - game object and I will use spread
112:58 - operator to expand the entire X array
113:02 - inside
113:05 - I will also expand the entire obstacles
113:08 - array in here and I will add the player
113:10 - now we are holding all the game objects
113:13 - in a single array this array will be
113:15 - recreated every time render method ticks
113:18 - good optimization tip here would be to
113:20 - only do this operation when vertical
113:22 - coordinate of any element changes or
113:24 - when we add or remove an egg I will
113:27 - repurpose this code block and instead of
113:30 - calling for each method on X array I
113:33 - will call it on this new game object
113:35 - array for each element in the array I
113:38 - will assign it a temporary variable name
113:40 - for example object for each object in
113:43 - game objects array call their Associated
113:46 - draw and update methods for this to work
113:50 - it's important that all objects we add
113:52 - into game objects array online 217 have
113:56 - a draw and update methods defined on
113:58 - their classes otherwise the code would
114:00 - break because JavaScript wouldn't be
114:02 - able to find that method
114:04 - so we are calling draw and update on all
114:07 - game objects on all X on all obstacles
114:09 - and on the player that means I can now
114:12 - delete these lines of code
114:17 - typo here I spell the game objects with
114:20 - an s now we draw the first obstacle and
114:23 - then we get an error we call the draw on
114:26 - the first obstacle and when we try to
114:28 - call update on it we get a type error
114:31 - that says object dot update is not a
114:33 - function I go to my obstacle class and
114:36 - you can see as I said we have draw
114:38 - method here but there is no update
114:40 - method we are asking JavaScript to call
114:43 - a method that doesn't exist on this
114:45 - object I will create an update method
114:47 - here inside that method we could for
114:50 - example animate Sprite sheets of these
114:52 - plants and mushrooms every time the
114:54 - player collides with them or something
114:56 - maybe I will add some interactive
114:58 - obstacles later for now we will leave
115:00 - this method empty now it's working and
115:03 - we are calling draw and update on all X
115:06 - all obstacles and on the player
115:08 - alternatively I could have also solved
115:11 - the lack of update method on obstacles
115:13 - by some kind of if else statement down
115:16 - here there are always multiple ways to
115:18 - do something feel free to discuss how
115:20 - you would approach this different clay
115:21 - maybe we will get some better Solutions
115:23 - in the comments that I might use in
115:26 - future classes I appreciate when you
115:28 - give me feedback on my code and when you
115:30 - suggest improvements
115:32 - okay so now we are calling draw and
115:34 - update as we cycle through game objects
115:37 - which means X are drawn first obstacles
115:40 - are on top of X and player is drawn last
115:43 - on top of everything if I change the
115:46 - order of these elements here the player
115:48 - is drawn behind now then X and obstacles
115:52 - are on top of everything so now we can
115:55 - understand how the layering works it
115:57 - depends on the order in which we call
115:59 - draw method on each object to draw our
116:02 - game objects in the order that makes
116:04 - Visual sense I can now sort game objects
116:07 - array based on each object's vertical
116:09 - position I take game object array and I
116:13 - call built-in array sort method this
116:15 - method sorts the elements in an array
116:18 - and it Returns the same array now sorted
116:21 - by default if we call it without passing
116:24 - it any arguments it will just convert
116:26 - array elements into Strings and it will
116:29 - sort them based on their Unicode values
116:31 - we don't really want that so we will
116:33 - pass it an argument this optional
116:35 - argument we can pass to array sort
116:38 - method is a compare function a custom
116:40 - function that defines some logic it
116:43 - defines some specific sort order we want
116:46 - this special function will take two
116:48 - arguments element a and element B all
116:51 - elements in the array in our case in
116:54 - game objects array will be represented
116:56 - by this A and B and used in this logic
116:59 - we Define here
117:00 - I can do return like this and I want to
117:03 - sort the elements in ascending order
117:06 - based on the value of each object's
117:08 - Collision y property so we are sorting
117:11 - based on the vertical center point of
117:13 - collision circle area alternatively we
117:16 - could also sort by the bottom of sprite
117:18 - image which would be sorted by the value
117:20 - of sprite y plus Sprite height
117:23 - sort method can be complicated to
117:25 - understand if you are a beginner all you
117:27 - have to understand here is that I'm
117:29 - putting all my elements into game
117:31 - objects array then I'm calling built-in
117:34 - sort method on that array and I'm
117:36 - organizing these elements based on their
117:38 - vertical position
117:41 - it doesn't work now because I'm creating
117:43 - array I'm drawing and then I'm sorting I
117:46 - need to sort the elements after I
117:48 - created the array but before I draw them
117:51 - so like this
117:55 - perfect now this egg is drawn in front
117:58 - of the plant but if I use the player to
118:00 - push it up the X vertical position
118:02 - becomes less than the vertical position
118:04 - of the plant now the egg is drawn behind
118:07 - the plant this is one simple way how you
118:10 - can draw elements in a 2d game in a way
118:12 - that makes more visual sense it is a
118:15 - very powerful technique to add to your
118:17 - coding toolkit do you have any questions
118:18 - leave a comment
118:24 - you don't have to do the following thing
118:27 - I will do now I set X interval to 20
118:30 - milliseconds and Max X will be 150 just
118:34 - testing if there are any problems we
118:36 - need to solve as I move through them the
118:38 - physics seems very good it's all working
118:40 - well having so many eggs for testing
118:43 - also gives me a pretty good idea
118:45 - where they might potentially spawn they
118:48 - appear in the area we specified with
118:50 - large top margin and smaller margin from
118:53 - left bottom and right
118:56 - we got X nice job coders
119:02 - I set interval to thousand milliseconds
119:04 - one egg every second and Max X will be
119:08 - 20. since we have this Collision formula
119:11 - in place
119:12 - If egg appears on top of obstacle or the
119:14 - player it gets automatically pushed
119:16 - outside its Collision radius
119:19 - I remove this control lock on line 237
119:22 - we have our game world we have
119:25 - randomized solid obstacles we have Mouse
119:27 - controlled player character that can
119:29 - move in eight directions and we have X
119:32 - that spawn in specific interval on top
119:35 - of that everything collides and reacts
119:38 - to everything we can make so many
119:39 - different games with this let's add
119:41 - enemies
119:44 - [Music]
119:53 - I create a custom class I call for
119:56 - example anime as usual Constructor will
119:59 - take a game as an argument and we
120:01 - convert that reference to a class
120:03 - property we do that to get an easy
120:06 - access to all properties sitting on the
120:08 - main game class from inside anime class
120:10 - through this.game reference we need to
120:13 - keep the same name and conventions here
120:15 - so Collision radius 30 pixels Collision
120:18 - X Center Point of collision Circle will
120:21 - be the right edge of canvas
120:23 - this.game.width a collision y will be a
120:26 - random value between 0 and the game
120:28 - height value coming from
120:30 - here speed X horizontal speed will be a
120:34 - random value between 0.5 and 3.5
120:38 - you can download anime image in the
120:40 - video description at first we will start
120:42 - with a static single frame ID will be
120:45 - told Source will be told.png
120:53 - I hide it with CSS because we want to
120:55 - draw it with the JavaScript on canvas
120:59 - this dot image property will be get
121:01 - element by ID and the ID we gave it was
121:04 - told
121:08 - Sprite with in this case 140 pixels and
121:13 - Sprite height is 260. I will also create
121:16 - width and height properties
121:25 - and we will Define Sprite X and Sprite y
121:28 - positions of the Sprite sheet image
121:30 - which will be positioned in relation to
121:32 - Collision Circle coordinates raw method
121:35 - will take context as an argument
121:38 - built-in draw image method and because
121:41 - the image file I'm using is already the
121:43 - same resolution as the size I want to
121:45 - display it in the game I only need to
121:48 - pass it three arguments the image I want
121:50 - to draw and X and Y where to draw it
121:54 - I will also copy Collision Circle visual
121:57 - that will appear only when debug mode
121:59 - property is set to True only when debug
122:02 - mode is active
122:03 - I just copy and paste it here since that
122:06 - code is the same for all our objects
122:12 - update method in there I want enemies to
122:15 - move to the left in the minus Direction
122:17 - on horizontal x-axis by speed x a value
122:21 - we defined online
122:23 - 179
122:26 - so we are moving enemies to the left if
122:30 - the right edge of the Sprite sheet is
122:31 - hidden behind the left edge of canvas we
122:34 - can set its X position back to game
122:36 - width so that it can walk left across
122:39 - the screen again we will also randomize
122:41 - its vertical y position to get the
122:43 - enemies walking in different Lanes so I
122:46 - will have enemies that walk from right
122:48 - to left and then they reset and walk
122:50 - again alternatively I could have also
122:53 - created new anime objects over and over
122:55 - and Destroy them discard them when they
122:58 - move off screen the code would be simple
123:00 - but reusing objects by resetting their
123:03 - position rather than creating new ones
123:05 - and discarding them later is a good
123:07 - optimization technique always reuse your
123:10 - objects and reset their positions if you
123:12 - can rather than creating new ones using
123:15 - the new keyword to create a new object
123:16 - is more expensive than resetting
123:18 - existing object
123:20 - on the main game class I create a custom
123:22 - method I call for example at enemy up
123:25 - here we will have an array that will
123:27 - hold all currently active anime objects
123:32 - whenever add enemy runs it will push new
123:35 - anime object into enemies array
123:43 - upon line 174 I can see that anime class
123:47 - Constructor expects game as an argument
123:49 - so I pass it this keyword because here
123:52 - we are inside this game class doing this
123:55 - I'm just passing a reference that points
123:57 - to a space in memory where game object
123:59 - is stored I'm not creating a copy of
124:02 - game object each time I create a new
124:04 - enemy
124:05 - init method will run just once to
124:08 - initialize our game and set everything
124:10 - up inside we are already creating
124:13 - obstacles we will also create enemies in
124:15 - here for Loop that will run let's say
124:18 - three times and each time it runs it
124:21 - will call add enemy method we just
124:23 - defined icons to lock this dot enemies
124:25 - and
124:28 - as expected it contains three anime
124:30 - objects I inspect one of them just to
124:33 - make sure nothing is undefined which
124:35 - could be a problem
124:36 - all is good here I can delete the
124:38 - console log it's a good idea to always
124:41 - check your objects and arrays with
124:43 - console logs as you build your project
124:45 - step by step to catch potential bugs and
124:47 - typos in time to draw and update enemies
124:51 - I just have to expand enemies array into
124:53 - game objects using the spread operator
124:56 - we did that before
124:58 - I see only Collision hitboxes I need to
125:01 - give some values to Sprite X and Sprite
125:04 - y so that the JavaScript knows where to
125:06 - draw the images
125:08 - position of the Sprite will be moving as
125:11 - Collision circles move so I put that
125:13 - code inside update method let's first
125:15 - center it then we offset it Sprite X is
125:19 - Collision x minus half of sprite width
125:22 - like this
125:23 - Sprite Y is Collision y minus half
125:26 - height
125:30 - I want the Collision circles to match
125:32 - the shadow on the ground below our
125:34 - floating enemies as closely as possible
125:36 - we need to adjust image positions
125:39 - vertically
125:41 - minus 40.
125:45 - minus 60
125:47 - what about minus height
125:53 - Plus 40.
125:55 - I can enable and disable debug mode to
125:58 - show and hide hitboxes by pressing
126:00 - letter D we have enemies coming from
126:03 - right to left and then reset in I want
126:06 - them to reset all the way behind the
126:08 - right Edge so we don't see them just pop
126:10 - into existence so we reset them to
126:13 - game.width plus width of anime
126:16 - and on top of that another game with
126:18 - times 0.5 to give each one A different
126:22 - random delay
126:24 - why is this here I delete that
126:29 - just for testing let's increase the
126:31 - speed
126:36 - resetting them at a random offset behind
126:39 - the right Edge works well
126:40 - maybe that's a bit too fast
126:45 - I need to restrict their vertical
126:47 - positions let's say start from the top
126:49 - margin
126:53 - and from there a random range between 0
126:56 - and game height minus top margin
127:06 - I copy this value to be used as the
127:08 - initial Collision X position inside the
127:10 - Constructor and I take this new
127:13 - Collision Y and I use it inside reset
127:16 - check in update method
127:26 - this will not work because up here on
127:29 - line 176 I'm using this dot width but
127:32 - it's not defined until later here on
127:34 - Line 183
127:37 - the order here matters
127:40 - I just take these two lines and I put
127:42 - them here
127:43 - now we have enemies walking from right
127:45 - to left in a correct Corridor and reset
127:48 - in behind the right Edge this way we can
127:51 - reuse the same enemies over and over
127:52 - unless I decide we want to add some
127:55 - other features like allowing player to
127:57 - destroy enemies or something like that
127:59 - we will see
128:01 - again you don't have to do this part I'm
128:03 - just testing our code
128:05 - so I create 30 enemies
128:07 - having so many enemies gives me a better
128:09 - idea how they reset and I can spot any
128:12 - potential issues faster
128:14 - everything seems to be working well
128:17 - this would be a very dangerous Forest
128:19 - luckily for our hatchling creatures the
128:22 - final game will not have swarms of
128:23 - enemies like this unless you want to
128:25 - create a periodic wave of enemies like
128:27 - this as one of the gamer mechanics the
128:30 - player has to prepare for and avoid we
128:33 - can do so many things in terms of game
128:34 - design here I'm just giving you the
128:36 - tools and techniques and showing you
128:38 - some of my ideas feel free to expand
128:40 - this game with your creative ideas when
128:42 - the course is finished let's go back to
128:44 - three enemies
128:45 - right now the enemies are just flying
128:48 - through the forest without interacting
128:50 - with anything first I want them to react
128:52 - to solid obstacles and the player we
128:56 - already have code that does that inside
128:58 - update method on egg class I can
129:00 - literally use the same code block and
129:02 - put it inside update method on anime
129:04 - class this will make enemies treat
129:06 - obstacles and player as solid impossible
129:09 - objects and they will slide around them
129:12 - we are inside update method on enemy
129:15 - class and we are passing anime as object
129:17 - a and player and obstacles as object B
129:20 - and here we are saying adjust position
129:22 - of a based on position of B player and
129:25 - obstacles will be solid and dominant in
129:28 - this interaction and enemies will be
129:30 - pushed around them this simple Collision
129:32 - check-in will also create a very basic
129:34 - artificial intelligence as you can see
129:36 - enemies are walking from right to left
129:38 - across the game area and they are
129:41 - automatically slide in and avoiding
129:43 - obstacles and the player
129:45 - because they avoid the player in this
129:47 - way we can also use the player to push
129:49 - enemies around same as we can push the
129:51 - ax around I adjust enemy speed
130:00 - if I add X into Collision objects array
130:04 - on anime class X will also become solid
130:07 - impossible obstacles for the enemies and
130:09 - enemies will have to walk around them
130:17 - it might be a good thing depending how
130:19 - you're designing your game but the way I
130:21 - want my game to be I actually want to
130:23 - remove the X from here
130:27 - instead I go up to egg class and inside
130:30 - update method I will add enemies to
130:33 - Collision objects here
130:36 - this will make the X object a passed to
130:39 - check collisions method and enemies will
130:42 - be solid impossible object B enemies
130:45 - will push the X around if I do it this
130:47 - way we implemented a lot of features so
130:50 - I will leave the source code from this
130:51 - stage in the resources section below you
130:54 - can download it and compare it with your
130:56 - files if you are coding along hope
130:59 - you're having fun
131:04 - [Music]
131:08 - I go down here between egg and enemy
131:11 - classes and I create a new class I call
131:13 - for example larva I want eggs to have a
131:17 - hidden timer and after a certain time
131:19 - interval each egg will hatch into a
131:22 - smaller larva that larva will try to
131:24 - hide in the forest and our job as a
131:27 - player is to protect it by pushing it
131:29 - closer to the safety zone or by pushing
131:32 - enemies away from it Constructor on
131:34 - larva class will be a little bit
131:36 - different because I want each larva to
131:38 - appear at the same position as the egg
131:40 - it hatched from so we will pass it a
131:43 - reference to the main game object as
131:45 - usual but also we pass it X and Y
131:48 - coordinates now I convert all these
131:50 - arguments into class properties I need
131:53 - to name these X and Y coordinates
131:55 - Collision X and collision y these
131:57 - variables will be involved in Collision
131:59 - detection so we need to name them the
132:01 - same as we did other objects in our
132:03 - physics game so that we can use our
132:05 - reusable check Collision method on these
132:07 - as well and involve these larva
132:09 - hatchlings in the game physics Loop we
132:12 - will also need Collision radius here
132:14 - let's say 30 pixels for now you can
132:16 - download larva image in the video
132:18 - description
132:20 - I added here with an ID of larva and
132:23 - Source larva.png it's a Sprite sheet
132:26 - with two frames
132:28 - on this row we have a bold larva and
132:31 - this one has some fluff behind the neck
132:32 - just to give it some visual variety the
132:35 - fluff makes more sense if you know what
132:37 - these hatchlings turn into when they are
132:39 - adults I bring the larva image into the
132:42 - project using get element by ID like
132:44 - this
132:46 - width and height of a single frame now
132:48 - Sprite width is 150 pixels Sprite height
132:51 - is 150 pixels as well if you are a
132:54 - beginner I strongly suggest you follow
132:56 - my code exactly and use the same images
132:58 - I'm using when the project is complete
133:00 - it will be easier to make your own
133:02 - custom changes changing the code as you
133:04 - go while following this tutorial is not
133:06 - a good idea unless you are an
133:08 - experienced JavaScript developer making
133:10 - your own changes before the project is
133:12 - complete will make it harder to debug
133:16 - we will also need Sprite X and Sprite Y
133:18 - coordinates of the Sprite sheet image
133:21 - each larvae will need to draw and update
133:23 - methods as usual
133:27 - draw method will take context as an
133:29 - argument
133:33 - inside we call built-in draw image and
133:36 - we pass it image we want to draw and and
133:38 - why coordinates where to draw it
133:42 - I want each larva to be moving up
133:44 - towards the safety of the mushroom
133:46 - Forest this open area is full of enemies
133:49 - and it's very dangerous speed y vertical
133:52 - speed will be a random value between 1
133:54 - and 2 for example
133:58 - we defined Sprite X and Sprite y
134:00 - properties that determine where the
134:03 - Sprite sheet will be drawn but because
134:05 - they will have to move every time larva
134:07 - moves I need to be updating them over
134:09 - and over from inside update method
134:11 - Sprite X will be Collision x minus half
134:14 - the width
134:15 - Sprite y will be Collision y minus half
134:18 - the height
134:24 - I hide this image with CSS we give it an
134:27 - ID of larva
134:31 - [Music]
134:35 - so we have a class we can use as a
134:38 - blueprint to create a larva every time
134:40 - an egg hatches let's write egg hatching
134:42 - logic we will need two helper variables
134:45 - hatch timer will go from zero to hatch
134:47 - interval it will count milliseconds so
134:50 - let's say I want the egg to hatch after
134:52 - 5 000 milliseconds after 5 Seconds
135:00 - Insight update method we handle
135:03 - collisions in this area and down here we
135:05 - will handle hatching
135:09 - if hatch timer we just defined is more
135:12 - than hatch interval we do something
135:18 - else we keep increasing hatch timer by
135:21 - Delta time counting and accumulating
135:23 - milliseconds Delta time will be passed
135:26 - to update method up here on line 159.
135:30 - this update method will receive it here
135:33 - inside render
135:35 - we calculated Delta time value before
135:37 - inside animation Loop Delta time
135:40 - contains the number of milliseconds that
135:42 - happened between this animation frame
135:44 - and the previous animation frame so
135:47 - hatch timer is accumulating this Delta
135:49 - time milliseconds between frames if
135:52 - hatch timer is more than hatch interval
135:54 - we will delete the egg and we will
135:57 - replace it with a larva hmm
136:00 - up here I create a property called
136:02 - marked for deletion
136:10 - down here we set marked for deletion to
136:12 - true
136:13 - I can be checking and removing the smart
136:16 - for deletion objects for every animation
136:18 - frame but it might be a little bit more
136:20 - efficient to only restructure our arrays
136:22 - when something gets actually marked so
136:25 - here we will call a custom method I will
136:27 - call for example remove game objects
136:34 - down here on the main game class I will
136:36 - Define that method
136:39 - so far we are only marking X for
136:42 - deletion so whenever this method runs I
136:44 - will take the entire X array and I will
136:47 - call built-in array filter method on it
136:50 - array filter method will just create a
136:52 - copy of this array but that new filtered
136:55 - array will only contain elements that
136:57 - pass the check provided in the Callback
137:00 - function the check in this case will be
137:02 - I only want X array to contain elements
137:05 - that have marked for deletion property
137:07 - set to false if anything has marked for
137:10 - deletion set to true it will be filtered
137:13 - out of the X array
137:15 - this is so-called es6 fat Arrow function
137:19 - syntax I'm saying take elements in X
137:21 - array one by one assign each one a
137:24 - temporary variable name object and on
137:27 - each of these egg objects check if they
137:29 - are marked for deletion property is
137:31 - false exclamation mark means false if
137:34 - marked for deletion on this egg is true
137:36 - that egg will be filtered out of this
137:39 - new array and this new filtered array is
137:42 - assigned to the original X array and it
137:45 - overrides it
137:46 - hmm am I over explaining again
137:49 - let's consolock this.game.x to see if x
137:53 - are being removed and added
137:57 - yes this is working perfect
138:01 - when we are in debug mode I want the
138:03 - hatch timer to be visible as a number
138:05 - floating above each egg inside the draw
138:08 - method here I call built-in fill text
138:10 - method this method needs at least three
138:12 - arguments text we want to draw and X and
138:16 - Y coordinates where to draw it
138:21 - I need to change font size rather than
138:24 - changing font size every time draw
138:25 - method runs on each egg I will set it up
138:28 - here on line 10 on the first page load
138:30 - this is a powerful optimization
138:32 - technique font is a part of kind of a
138:34 - state and frequent changes to Canvas
138:36 - State can affect performance define
138:39 - canvas properties such as fill style
138:41 - line width stroke style and font in a
138:44 - code block that runs as little as
138:46 - possible ideally don't do this in a
138:48 - method that runs 60 times per second on
138:51 - multiple objects at the same time
138:52 - although in some cases it might be
138:55 - unavoidable all I'm saying here if you
138:57 - can set canvas properties on the first
139:00 - page load like this all this code will
139:02 - run only once I set canvas font to 40
139:05 - pixels helvetica I could have also
139:08 - defined canvas font here in this draw
139:10 - method but as I said that line of code
139:12 - would run 60 times per second on each
139:15 - active egg that's a lot of operations
139:17 - that can be easily avoided by doing what
139:19 - I just said hatch timer is this
139:21 - ridiculous number with so many digits
139:23 - after the decimal point let's clean this
139:25 - up I create a helper variable called
139:28 - display timer in here we will format
139:31 - that number a bit before we draw it I
139:33 - can for example take hatch timer and
139:36 - call built-in to fixed method JavaScript
139:39 - to fixed method converts a number to a
139:41 - string and it rounds the string to a
139:44 - specified number of decimals I actually
139:46 - want 0 decimals I just want to see the
139:49 - milliseconds
139:50 - I used a display timer variable here to
139:53 - actually draw it
139:58 - I can adjust vertical position of the
140:00 - text Maybe by Collision radius like this
140:07 - up here I will set text align to Center
140:09 - this will align the timers and X
140:12 - horizontally
140:15 - nice I want to push the timers even
140:18 - further up above the eggs
140:20 - maybe even more
140:25 - let's go with 2.5
140:30 - instead of milliseconds I just want to
140:32 - see the seconds so I close hatch timer
140:35 - in Brackets and multiply it times 0.001
140:39 - now this is more readable we can see
140:42 - number of seconds above each egg
140:44 - let's make each egg hatch after three
140:46 - seconds nice when the egg hatches it
140:49 - gets removed by the filter method
140:57 - on the main game class I create a
140:59 - property called hatchlings and at first
141:01 - I set it to an empty array whenever an
141:04 - egg hatches we will push new larva into
141:07 - this array up here on line 190 I can see
141:11 - that larva expects game and X and Y
141:14 - coordinates so when an egg hatches I
141:17 - take this to the game.hatchlings array
141:20 - and I push new larva inside
141:26 - I pass it this Dot Game and I pass it X
141:29 - and Y coordinates of this egg that it
141:32 - hatched from
141:38 - I removed this console log
141:43 - inside render method I use spread
141:45 - operator to expand hatch links into game
141:48 - objects array so that they can be sorted
141:50 - drawn and updated perfect we are making
141:54 - progress
141:55 - now that we can see what our hatchlings
141:57 - look like we can go up to larva class
141:59 - and clean this up
142:04 - first we will check if the larva moved
142:06 - to safety
142:08 - they are safe as soon as they reach this
142:10 - mushroom and bushes area where they can
142:12 - hide so if Collision Y is less than this
142:16 - dot game.top margin if larva moved past
142:19 - this point we can set marked for
142:22 - deletion on it to true we will delete
142:24 - that larva because we don't want to draw
142:26 - it anymore and we will call remove game
142:29 - objects
142:36 - online 350 inside remove game objects
142:39 - method I do the same thing we did for x
142:42 - filter the hatchlings array and if any
142:45 - larva object in this array has marked
142:48 - for deletion properties set the true
142:49 - filter it out
142:52 - just to check I will console log game
142:54 - objects every time we remove a neck or a
142:57 - larva
143:02 - I get an error and it's because this
143:04 - needs to be
143:05 - this.game.removegame objects because
143:07 - that method sits on our main game class
143:10 - I want to draw Collision circles on
143:13 - hatchlings I copy this code block from
143:15 - enemy class
143:23 - and I just paste it here
143:25 - because our classes have the same name
143:28 - and conventions on their properties it's
143:30 - easy to reuse code like this
143:32 - right now we are drawing the entire
143:34 - Sprite sheet for each larva I want to
143:36 - crop out just a single frame from coding
143:39 - at 0 0 2 this.spruit and this dot Sprite
143:44 - height
143:46 - and we want to draw that cropped out
143:49 - image at position Sprite X Sprite Y and
143:52 - we need to give it width and height like
143:54 - this nine arguments
144:03 - I want to position a larva Sprite sheet
144:05 - image in relation to its Collision
144:07 - Circle
144:08 - I try minus 50.
144:11 - yes that will work I want the Collision
144:14 - Circle to align with the bottom of its
144:16 - body I think that will make the most
144:18 - visual sense when interacting with game
144:20 - environments and characters
144:22 - I remove this console log on line 362.
144:29 - [Music]
144:34 - larva Sprite sheet has two frames but we
144:37 - are drawing just the top one let's
144:39 - randomize that frame y will be a random
144:42 - value between 0 and 2 and since there is
144:45 - no row 1.5 for example we need integers
144:48 - whole numbers without decimal points
144:51 - so I wrap this in mastered floor
144:54 - this line of code will give us either 0
144:57 - or 1 because my other floor will round
144:59 - the value down to the nearest lower
145:01 - integer
145:04 - frame X will be always zero until later
145:06 - in the class where I give you Advanced
145:08 - Sprite sheet for animation
145:11 - we will use frame x times Sprite width
145:14 - here as Source X argument passed to draw
145:16 - image method and we also need to Define
145:19 - source y Source X and Source Y
145:22 - coordinates combined will determine
145:24 - which area of the Sprite sheet we are
145:26 - cropping from
145:27 - Source y will be frame y times Sprite
145:31 - height
145:36 - nice since frame Y is randomized to be
145:39 - either 0 or 1 some hatch links use
145:42 - Sprite image from row 0 and some use the
145:45 - other one from row 1.
145:54 - collision between hatch links and game
145:56 - objects will be handled here
145:59 - I go up here inside update method on egg
146:02 - class and I copy this code block we will
146:05 - make some changes to it but most of it
146:07 - will be the same so we might as well
146:09 - copy it so we don't have to write all of
146:11 - that again
146:12 - I paste it down here inside update
146:14 - method on larva class
146:16 - I will remove enemies from Collision
146:18 - objects because enemies will have a
146:20 - different type of interaction so larva
146:23 - will automatically avoid player and
146:25 - obstacles and we can also use the player
146:27 - to push larva around
146:29 - like this which will be an important
146:31 - game mechanic
146:43 - collision with enemies will be handled
146:45 - down here
146:47 - I take enemies array and I call for each
146:50 - on it
146:51 - for each anime object I will call them
146:53 - anime for example for each one of them
146:56 - call this callback function
146:59 - basically I want to say if this larva
147:01 - and this anime we are currently cycling
147:03 - over with this for each method collide
147:05 - one way to easily check if two game
147:08 - objects Collide is to use our custom
147:10 - check Collision method again I want to
147:12 - check collision between this larva we
147:15 - are inside larva class and each
147:17 - individual enemy as this for each method
147:19 - runs we know that our custom check
147:21 - Collision method returns an array of
147:23 - values it gives us Collision distance
147:26 - sum of radii DX and Dy here I only want
147:30 - the first argument Collision which will
147:33 - be true or false depending on whether or
147:35 - not this larva and this anime Collide
147:37 - check Collision returns an array and I
147:40 - want Collision status true or false I
147:42 - want the first element in the array so
147:44 - index 0 like this
147:47 - so here we are using destructuring to
147:50 - extract all five individual variables
147:52 - from check Collision method here I am
147:55 - directly accessing just the first value
147:57 - with index 0 because I don't need the
147:59 - other ones
148:01 - the reason I don't need these other
148:02 - values when larva and enemy Collide is
148:05 - because there will be no pushing around
148:06 - and no physics The larva will just get
148:09 - eaten so I set marked for deletion on
148:12 - this larva object to true
148:14 - I will also call remove game objects to
148:17 - filter that larva out of the hatchlinks
148:19 - array I will also keep track of how many
148:22 - hatchlings we lost in this custom
148:24 - variable this.game that lost touch links
148:27 - will be increased by one
148:30 - and here where we check if larva moved
148:32 - the safety of the mushroom Forest we
148:35 - increase score by one so if we protect
148:37 - larva by positioning X pushing enemies
148:40 - away or by pushing larva towards the
148:43 - forest if larva successfully hides in
148:46 - the bushes we get one score point if
148:49 - larva gets eaten lost touch links
148:51 - variable will increase by 1. down here
148:54 - on our main game class we created these
148:57 - properties score will be initially set
148:59 - to zero and lost hatchlings also
149:02 - initially set to zero
149:07 - [Music]
149:12 - I can use console logs or something like
149:15 - that to check if the code we just wrote
149:18 - works but we need that text displayed to
149:21 - the player anyway so down here we will
149:23 - draw game status text
149:25 - again we will use built-in canvas fill
149:28 - text method which expects the text we
149:31 - want to draw and X and Y coordinates
149:33 - where to draw it I want to draw the word
149:36 - score at coordinates 25 horizontally and
149:39 - 50 vertically
149:41 - problem we have right now is that I want
149:43 - this text to be left aligned and if you
149:47 - remember the text above X the timer is
149:50 - Center aligned I will have to isolate
149:52 - this fill text call by wrapping it
149:55 - between save and restore built-in canvas
149:57 - methods then I can set text align to
150:01 - left and I call Restore
150:03 - save and restore methods work together
150:06 - and we use them when we want to apply
150:08 - specific settings only to a certain draw
150:11 - call on canvas without affecting the
150:14 - rest of our project I save canvas State
150:17 - I set text align to left which will
150:20 - affect only this fill text call where we
150:22 - draw score and then restore method will
150:25 - reset all canvas settings to what they
150:27 - were when save was called in this case
150:30 - it will only revert text the line back
150:33 - from left to Center I hope that makes
150:36 - sense this is a very useful technique
150:38 - especially if you want to scale and
150:40 - rotate your canvas drawings I do that in
150:42 - some other classes for example in my
150:44 - creative code in fractal class if you
150:47 - want to know more about it now score is
150:49 - left aligned and timers above X are
150:52 - Center aligned perfect
150:55 - I adjusted the text to draw I want to
150:58 - say score colon space in quotes plus
151:01 - this dodge core variable to make it
151:03 - Dynamic now as hatchlinks move to safety
151:06 - and height in the forest we can see our
151:09 - score increases in debug mode I also
151:12 - want to be able to see lost touch links
151:14 - so if this.game.deback is true I copy
151:18 - this line of code text will say lost
151:20 - plus this dot lost touch links variable
151:29 - actually we are inside game class here
151:31 - so I need to say just this dot debug yes
151:34 - I change vertical coordinate here and
151:37 - now while in debug mode we are also
151:40 - keeping track of how many hatch links
151:41 - were eaten how many hatchlings collided
151:44 - with enemies
151:47 - [Music]
151:52 - sometimes the larva hatches quickly and
151:54 - is eaten too fast or sometimes larva
151:57 - disappears very close to the top Edge
151:59 - while enemy is nearby so it might not be
152:02 - 100 clear if it managed to get to the
152:05 - safety or if it was eaten
152:07 - I would like to add an additional visual
152:09 - effect that will help us to make our
152:11 - game clear and easy to read I want to
152:13 - add two types of particle effects when
152:16 - the larva hides in the bushes it will
152:18 - interrupt a swarm of fireflies that were
152:21 - sitting on the branches and they will
152:23 - fly up in the air when player sees those
152:26 - fireflies they know that larva is safe
152:28 - if larva gets eaten I will try to come
152:31 - up with a different very distinct
152:33 - particle motion so if there are many
152:35 - game objects in the same area we can
152:37 - still tell what's going on by seeing
152:39 - what type of particles are flying from
152:41 - there
152:43 - I will also use this opportunity to talk
152:45 - about subclassing in JavaScript we will
152:48 - have a parent particle class that will
152:50 - contain all properties and methods
152:52 - shared between all particle types this
152:55 - is a so-called parent class also called
152:57 - a superclass
153:00 - Firefly extends this particle class this
153:03 - is a child class also called a subclass
153:07 - we will also have a class I call spark
153:10 - that extends particle class like this we
153:13 - have one parent class and two child
153:16 - classes child classes will automatically
153:18 - inherit properties and methods from the
153:21 - parent class which will save us some
153:22 - called repetition let's write the code
153:25 - and talk about it a bit more as we go
153:27 - along
153:28 - the parent particle class Constructor
153:30 - will expect game X and Y position
153:33 - because fireflies and Sparks will always
153:35 - fly out from the position where the
153:37 - larva disappeared and let's add one more
153:40 - for example color here maybe I want one
153:43 - particle type to be gold and another one
153:45 - blue depending on where in our code base
153:47 - was that particle created I will show
153:50 - you what I mean
153:51 - I convert all these arguments into class
153:54 - properties as usual I'm saying take
153:57 - color that was passed as an argument
153:59 - here and save it as color property on
154:02 - this instance of particle class you know
154:04 - how this works by now radius will be a
154:07 - random value between 5 and 15 but I wrap
154:10 - it in Master Floor to only allow
154:12 - integers so no decimal points if we are
154:15 - creating many particles you will notice
154:18 - a big difference in performance when we
154:20 - are using randomized values like this
154:22 - compared to the setting the initial
154:24 - radius to a fixed value of let's say 10
154:27 - pixels for all particles randomizing
154:30 - object values when creating many object
154:32 - is very performance expensive you can
154:35 - improve your game's performance by
154:37 - trying to avoid Master random as much as
154:39 - possible if you know you will be
154:41 - creating many copies of that particular
154:43 - object I know we will be creating many
154:45 - particles we only have one player object
154:47 - so there it doesn't really matter it
154:50 - gets created once but over the course of
154:52 - our game we will probably create
154:54 - thousands of particles
154:55 - one way to avoid this would be a
154:57 - technique called object pooling you
155:00 - create a pool of particle objects and
155:01 - only draw them and use them when needed
155:04 - when it comes to Performance that would
155:06 - be much better than constantly creating
155:08 - new ones and deleting them
155:10 - speed X will be a random value between
155:12 - -3 and plus 3. this means some particles
155:16 - will move to the right in the positive
155:17 - direction on the horizontal x-axis some
155:21 - particles will move to the left if their
155:23 - speed X is a negative value for vertical
155:26 - speed it will be a random value between
155:28 - 0.5 and 2.5 pixels per animation frame
155:34 - I want to use a little bit of
155:36 - trigonometry to make the particles
155:38 - rotate float and swirl around so we will
155:41 - need an angle value initially I set it
155:43 - to zero VA velocity of angle will
155:47 - determine how fast is that angle value
155:49 - increasing I will show you exactly how
155:52 - to use this in a minute don't worry the
155:54 - a will be a random value between these
155:56 - two very small numbers
155:58 - we will delete particles that moved off
156:01 - screen initially I set their marked for
156:03 - deletion to false
156:05 - draw method will be on the parent
156:07 - particle class as well so it will be
156:10 - shared for all fireflies and all Sparks
156:13 - I want to make sure that changes to kind
156:15 - of a state we make here remain isolated
156:18 - to this particular particle so I wrap
156:20 - the drawing code between save and
156:22 - restore built-in canvas methods
156:25 - we set fill style to this dot color from
156:27 - line 303
156:31 - I call begin path to start a new shape
156:38 - built-in Arc method will take horizontal
156:41 - Center Point vertical Center Point
156:43 - radius
156:46 - start angle and end angle I want you to
156:50 - draw a full circle so from 0 to math.pi
156:53 - times two method pi times 2 is a value
156:56 - in radians and it converts to 360
156:59 - degrees it's a full circle we have to
157:02 - use values in radians here when passing
157:05 - them to Arc method then I call fill to
157:08 - fill the path with color and I will also
157:11 - stroke it because in our game everything
157:13 - has this Vector art style with block
157:16 - outlines I want the particles to match
157:18 - it
157:19 - glass Firefly will contain only update
157:21 - method same for spark later when we call
157:25 - draw method on Firefly class since this
157:27 - class extends particle JavaScript will
157:30 - automatically look for draw method and
157:33 - for Constructor on the parent particle
157:35 - class doing this will save us code
157:37 - repetition I don't have to Define
157:38 - Constructor and draw method twice if
157:41 - it's shared for fireflies and for Sparks
157:44 - we can only Define it once on the parent
157:46 - class and the JavaScript will find it it
157:49 - will be inherited fireflies will have
157:52 - unique motion I'm thinking floating up
157:54 - and swaying left and right which is very
157:56 - easy to implement first we will be
157:59 - increasing angle by VA angle velocity
158:02 - for each animation frame then we will
158:05 - increase Collision X by speed X since
158:08 - speed X can be positive or negative they
158:11 - can start going left or right randomly
158:14 - Collision y will be minus equals speed y
158:17 - because I want them to float up in the
158:19 - negative Direction on the vertical
158:21 - y-axis if a firefly moves all the way up
158:25 - and it's hidden above the top edge of
158:27 - game area so if it's Collision y center
158:30 - point is less than 0 minus its radius we
158:34 - set its marked for deletion to true and
158:37 - we will call remove game objects
158:42 - on the main game class I create a
158:44 - property called particles it will be an
158:46 - array and it will hold all currently
158:49 - active particle objects
158:51 - I expand particles into game objects so
158:54 - that they can be sorted drawn and
158:57 - updated
158:59 - inside remove game objects I add one
159:01 - more line of code to filter out particle
159:04 - objects with marked for deletion
159:06 - properties set to True like this
159:11 - let's try to create some particles I
159:14 - will create them up here on larva class
159:16 - in this code block that runs when larva
159:19 - hides in the forest we get a score point
159:22 - and I want a swarm of fireflies to fly
159:24 - out of the bushes
159:26 - I take this.game.particles array and I
159:29 - push one new Firefly inside
159:33 - I remember that particle class
159:34 - Constructor expects four arguments a
159:37 - reference to the main game object as
159:39 - usual so I just pass it this Dot Game
159:41 - along from larva Constructor
159:44 - initial start in X and Y of this
159:46 - particle will be the last X and Y
159:48 - position of the larva we just deleted
159:50 - and color will be red for example just
159:54 - to test it
159:56 - nice we have red particles with white
159:58 - outlines if I want more than one I just
160:01 - create a for Loop let's say I want three
160:04 - fireflies each time
160:06 - foreign
160:10 - color to Yellow
160:13 - let's see what that looks like
160:16 - nice particles need black stroke I can
160:19 - set it inside the draw method on each
160:21 - particle but in this project I'm not
160:23 - using a stroke on many other things I
160:25 - can just set a stroke to Black globally
160:28 - here on line 9. This will be more
160:30 - performance efficient it will also give
160:33 - black Strokes for Collision circles
160:35 - while we are in debug mode but I don't
160:37 - really think it's a problem it might
160:39 - look even better like this
160:43 - [Music]
160:48 - fireflies have a very basic left and
160:51 - right upwards motion we are not using
160:53 - that angle we are increasing endlessly
160:55 - on line 327. easy way to make something
160:58 - cycle back and forth is to pass ever
161:01 - increase in angle value to master sign
161:04 - or method cosine method
161:10 - when your code is like this VA by how
161:13 - much angle increases for each animation
161:15 - frame will determine the speed of
161:17 - swaying and this dot speed X will
161:20 - determine the curve the radius how far
161:22 - left and right the motion goes
161:25 - perfect whenever larva successfully
161:28 - hides in the forest we get a score point
161:30 - and we get confirmation by seeing this
161:33 - Firefly effect
161:34 - I want Sparks to look different so that
161:37 - in case that larva and Anime are
161:39 - obscured behind obstacles or something
161:41 - you can still see that the larva was
161:43 - eaten based on the particle effect that
161:46 - happens there
161:48 - in here I will Define a different update
161:50 - method with different code inside so
161:53 - Firefly and Spark are both child classes
161:56 - of the parent particle class they both
161:58 - inherit code in particle class
162:00 - Constructor and they both share its draw
162:03 - method but each one will have a unique
162:05 - update method where we handle motion
162:08 - I will increase angle by angle velocity
162:11 - VA again but I will slow it down so
162:14 - times 0.5
162:17 - horizontal Position will be minus equals
162:19 - Mass DOT cosine we pass it this ever
162:22 - increase in angle value to map it along
162:24 - a cosine curve and we Define the radius
162:27 - of that curve using speed X
162:30 - Collision y will be minus equals method
162:32 - sine and I pass it the same angle value
162:35 - and radius of the curve is speed y value
162:42 - we go back up to larva class and here if
162:46 - larva collides with an enemy we delete
162:48 - it and I want to create a swirl of
162:51 - particles I will just copy this code
162:53 - block we used to create three fireflies
162:55 - and I copy it here in this case we want
162:58 - to create three Sparks and color will be
163:01 - blue
163:06 - how do I do this now I need to push the
163:09 - larva in front of anime to see what
163:11 - happens when it gets eaten
163:14 - nice we get blue Sparks and some kind of
163:17 - circular motion just for testing
163:19 - purposes I will create Sparks even when
163:21 - larva hides in safety so that the
163:23 - animation happens automatically more
163:25 - often without me having to chase them
163:27 - around
163:28 - I need to see it so that I can adjust
163:30 - the movement
163:34 - what can we do with this I love
163:36 - particles you can do so many different
163:38 - movement patterns so easily for example
163:40 - let's make them shrink if you try to
163:43 - draw a circle using Arc method that has
163:45 - radius less than zero you will get an
163:47 - error so we have to be very careful here
163:49 - I say if radius is more than 0.1 keep
163:53 - reducing radius by a small value that
163:56 - value needs to be less than 0.1 to make
163:59 - sure we can't get below zero also if you
164:02 - remember we are only removing old
164:04 - particles if they move past the top edge
164:06 - of canvas and these swirling particles
164:09 - never do so I need another condition
164:10 - here if radius is less than 0.2 just to
164:15 - be safe set it's marked for deletion the
164:17 - true and call remove game objects method
164:31 - nice this looks interesting I want them
164:34 - to kind of explode to both sides I
164:36 - haven't mentioned it before because it's
164:38 - not necessary to fully understand
164:40 - trigonometry for this course sine and
164:43 - cosine work together to map a circular
164:45 - path if we give them the same values
164:48 - look what happens if I swap sine and
164:50 - cosine
164:53 - all you have to understand about sine
164:55 - and cosine for animation purposes is
164:58 - that if you pass them ever increase in
165:00 - angle value and when you attach these
165:03 - values to vertical and horizontal
165:05 - positions of your object you will get a
165:08 - circle movement the best way to get some
165:10 - clarity is to play with the values try
165:12 - to break it adjust the code and see what
165:15 - happens don't worry about fully
165:17 - understanding trigonometry today it can
165:19 - be complicated for beginners and it
165:21 - takes a while to master
165:23 - I'm drawing 30 particles here to give me
165:26 - a better idea about the motion that
165:28 - happens and if we get any edge cases
165:30 - appear that needs to be accounted for
165:32 - you don't have to do this I recommend
165:35 - using only three particles each time for
165:37 - performance reasons you can see the
165:39 - Sparks are kind of swirly explosions I
165:42 - like it the motion is very different
165:44 - from fireflies I give them yellow color
165:47 - here and I will go back to using
165:49 - fireflies
165:51 - let's see what that looks like so we
165:53 - know how to extend JavaScript class to
165:56 - avoid code repetition we created a
165:59 - parent particle class and two child
166:01 - classes Firefly that indicates to the
166:04 - player that larva managed to hide in the
166:07 - forest by disturbing a swarm of glowing
166:09 - bugs that float away upwards and when
166:12 - larva is eaten by an enemy it will turn
166:14 - into a swirl of magical Sparks that
166:17 - slowly shrink and disappear
166:21 - I will go back to three fireflies here
166:24 - and down here let's create three Sparks
166:28 - or maybe five because they shrink so
166:30 - fast and often they are obscured by
166:32 - obstacles and other game objects we want
166:35 - to make sure they get noticed when they
166:37 - appear
166:38 - I would also like to allow the player to
166:40 - move the eggs to the forest to get score
166:42 - Point immediately I want X to instantly
166:45 - hatch when we push them high enough into
166:47 - the safe area that egg will
166:49 - automatically turn into larva and into
166:52 - fireflies instantly and we will get a
166:55 - score point I can do that up here on
166:58 - line 179 where we check if Hutch timer
167:01 - is more than hatch interval to turn egg
167:03 - into a larva I want this code block to
167:06 - also run if the egg was pushed to safety
167:09 - zone if vertical position Collision Y is
167:12 - less than this dot game.top margin
167:15 - to test it maybe I should increase Hajj
167:18 - interval otherwise these eggs hatch too
167:20 - fast
167:25 - I see an egg here no here and I push it
167:28 - leave me alone okay now here we go it
167:33 - hatched instantly while hatch timer was
167:35 - only 7 seconds I try again with this egg
167:38 - and yes this works and we are also
167:40 - getting score points for that perfect
167:47 - [Music]
167:51 - I prepared many different enemies for
167:53 - you you know how we have a single image
167:55 - file with multiple obstacle types I also
167:58 - prepared many different toad skins for
168:01 - you that will play the role of enemies
168:03 - in our game I had a lot of fun making
168:05 - different variations and imagining what
168:08 - types of special abilities and special
168:09 - moves they could have
168:11 - let's say for performance reasons we
168:13 - want to use just a set of static images
168:15 - for enemies we will also animate this
168:17 - later if that's what you want in the
168:19 - final version of the game everything
168:21 - will be animated all the project images
168:23 - can be downloaded from the resources
168:25 - section below as usual I'm giving you
168:28 - all this premium game art for free this
168:30 - course is designed to give you the
168:31 - maximum value possible feel free to use
168:33 - these art assets for your own projects
168:35 - if you want so I bring this Sprite sheet
168:38 - with four frames 4 enemy types into the
168:40 - project ID is told and source is
168:44 - toads.png I hide it with CSS as usual
168:51 - in script.js inside enemy class
168:53 - Constructor we create two helper
168:55 - variables that will help us navigate
168:57 - around the Sprite sheet and crop out one
169:00 - random frame for each enemy object frame
169:03 - X will navigate around the Sprite sheet
169:05 - horizontally and it will be initially
169:07 - set to zero frame y will navigate
169:10 - vertically and it will also start at
169:13 - zero I will need the longest version of
169:15 - draw image method to Define what image I
169:18 - want to draw Source X Source y Source
169:21 - width and Source height to specify which
169:24 - rectangular area I want to crop out from
169:26 - the source image and destination X
169:29 - destination y destination width and
169:31 - destination height to Define where we
169:34 - put that cropped out piece of image on
169:36 - destination canvas 9 arguments in Total
169:39 - Image to draw cropping area and where to
169:43 - put that cropped image let's start by
169:46 - cropping just the top left frame so we
169:48 - crop from coordinates 0 0 to code
169:51 - coordinates Sprite with Sprite height
169:57 - this Sprite sheet has only one column so
169:59 - frame X will stay at zero I want to crop
170:03 - out one vertical frame at random so
170:06 - Source y of the cropping area will be
170:08 - Sprite height pushing the start of the
170:10 - cropping area here giving us this Frame
170:13 - to actually see it I need to use the new
170:15 - image with an ID of toads
170:21 - so to be clear 0 times Sprite height
170:23 - will give us this Frame 2 times Sprite
170:26 - height will crop out this Frame the
170:29 - value we pass is Source y to draw image
170:31 - method will determine where do we start
170:33 - cropping from vertically
170:35 - instead of this hard-coded value we can
170:38 - use frame y now when I give frame y a
170:41 - different value it gives us different
170:43 - enemy types
170:48 - I want each anime object to be randomly
170:51 - assigned to one of these images when
170:53 - it's created so we have four rows math
170:57 - at random times four and if I wrap it in
171:00 - method floor frame y will be either 0 or
171:03 - 1 or 2 or 3. I will also replace Source
171:07 - x with a dis.frame x times Sprite width
171:10 - this will become relevant a bit later
171:12 - when I give you the next Sprite sheet
171:14 - for now let's leave frame X at zero it
171:17 - would also be nice to randomly reassign
171:19 - the image every time enemy moves off
171:22 - screen and resets so we make use of all
171:24 - available images I just randomized frame
171:27 - y here like this to achieve that
171:31 - to quickly test this I increase enemy
171:33 - speed to a random value between 5 and 8
171:36 - pixels per animation frame
171:39 - enemies are resetting and images are
171:42 - randomly changing every time they reset
171:44 - perfect
171:47 - let's go back to a lower speed
171:53 - I set max X to 5. since we are using
171:57 - static images for enemies at this stage
171:59 - drawing them is very cheap in terms of
172:01 - performance maybe I could increase the
172:03 - number of enemies to 5 as well this is
172:06 - starting to look really good
172:09 - [Music]
172:14 - I want to display a winning and losing
172:17 - message on the main game class I create
172:19 - a property I call for example winning
172:21 - score for testing purposes I set it to
172:24 - 5. we will draw winning and losing
172:26 - message down here
172:33 - if score is more or equal to winning
172:35 - score hmm
172:41 - I will wrap it in save and restore to
172:44 - restrict some drawing settings we will
172:46 - use now only to that win or lose message
172:49 - I want to draw a semi-transparent layer
172:51 - to indicate the game is over and also to
172:55 - make the message more contrasting
172:57 - against the background so I set fill
172:59 - style to block zero zero zero and 0.5
173:02 - opacity then we will draw that black
173:05 - semi-transparent rectangle over the
173:07 - entire canvas from coordinate 0 0 to the
173:11 - width and height of the game area
173:18 - let's run this code to test it when we
173:22 - reach score 3 we should get that
173:24 - semi-transparent layer yes after that
173:27 - rectangle is drawn I will change fill
173:29 - style to White to make sure the text is
173:32 - contrasting against the dark background
173:34 - I set text align to Center
173:37 - we will have a main message in large
173:39 - letters and a secondary message in
173:41 - smaller font I will just Define them
173:43 - like this as lead variables and the
173:46 - values these messages get will depend on
173:49 - how well we played in any case this
173:52 - message will only display after score is
173:54 - more or equal to winning score but let's
173:57 - say if we played well and we lost only 5
173:59 - or less hatchlings we will get a winning
174:01 - message
174:04 - if we lost more than 5 we will get a
174:06 - losing message the goal of the game is
174:08 - pushing X hatchlings and enemies around
174:11 - to make sure we protect as many as
174:13 - possible so if we play well message 1
174:16 - will say hmm let's play with words a bit
174:19 - you can write anything you want as a
174:21 - winning and losing message here so if we
174:23 - win the main message in large letters
174:26 - across the screen will say Bullseye and
174:29 - some exclamation marks the secondary
174:31 - smaller message will say you bullied the
174:33 - bullies
174:40 - if we lose the main message will say
174:43 - bollocks
174:45 - [Music]
174:49 - secondary smaller message will say you
174:52 - lost plus we will display Dynamic
174:55 - variable value to show how many
174:56 - hatchlings got eaten
174:59 - plus hatchlings comma don't be a
175:03 - pushover this is a physics game about
175:05 - pushing things around we need to learn
175:07 - to push better I'm using a good old
175:09 - string concatenation to construct this
175:12 - Dynamic message even better would be to
175:14 - use template literals here if you are
175:16 - familiar with modern JavaScript syntax
175:19 - now we actually want to draw these
175:21 - messages the large message one will be
175:24 - for example 130 pixels helvetica
175:30 - fill text method will take the text we
175:32 - want to draw message one and X and Y
175:35 - coordinates will be the middle of canvas
175:37 - horizontally and vertically like this
175:43 - the second message will be smaller 40
175:45 - pixels helvetica
175:51 - fill text will draw message 2 in the
175:53 - middle of canvas as well
176:04 - one more full text call that will say
176:07 - final score space plus we will display
176:09 - the final score value there plus full
176:11 - stop to end the sentence and another
176:14 - sentence will say press R to butt heads
176:17 - again I want to show you how to
176:19 - implement a very simple restart
176:20 - functionality whenever we press letter r
176:23 - on the keyboard I will also draw it in
176:26 - the middle of canvas vertically and
176:28 - horizontally now I have to space those
176:30 - messages out so they are not drawn on
176:32 - top of each other I adjust the vertical
176:35 - position of message 1 by -20 pixels
176:38 - moving it up in the negative Direction
176:41 - on the vertical Y axis message 2 will be
176:44 - plus 30 pushing it down
176:46 - message 3 will be plus 80. let's see
176:49 - what that looks like yes this spacing is
176:52 - much better we have our winning message
176:58 - when score is more than winning score we
177:00 - set the game over to true
177:09 - on the main game object I Define a game
177:11 - over property and initially I set it to
177:14 - false
177:18 - the simplest thing we could do here is
177:20 - to freeze animation when game over
177:22 - happens I can do it for example down
177:24 - here I say only serve the next animation
177:27 - frame if game over is false when the
177:31 - game over becomes true the game will
177:33 - freeze
177:34 - I said winning score to 1 just for
177:37 - testing
177:39 - and it will display winning or losing
177:41 - message and it will freeze like this
177:44 - I go down to line 519 and I delete this
177:49 - bit I would like the game to keep
177:51 - running but we will make new X stop
177:53 - appearing and I will prevent enemies
177:55 - from resetting so they just flow off
177:57 - screen and stay there so whenever game
178:00 - over happens the objects that are
178:02 - already in the game area will just
178:04 - finish the action they are doing but new
178:06 - objects will no longer appear the game
178:08 - will just finish playing out behind the
178:10 - winning or losing message but new X will
178:12 - no longer appear and enemies will stop
178:14 - coming
178:16 - player will still be interactive and we
178:18 - can still move it around in the empty
178:20 - game world
178:21 - how do we implement this it's simple
178:23 - first of all let's say winning or losing
178:25 - message appears and we still have some
178:27 - eggs hatching on larva class we will
178:30 - make sure that we get score points only
178:32 - if game over is false when game over
178:35 - happens hatchlinks will still appear
178:37 - from the remaining X but whatever
178:39 - happens will no longer affect our score
178:41 - points
178:42 - on the enemy class I only want the
178:44 - enemies to reset if game over is false
178:46 - like this when the game over happens
178:48 - enemies will finish their movement
178:50 - across the game area but they will no
178:53 - longer reset to the right so new enemies
178:55 - will stop coming
179:02 - down here we only want to add new X into
179:05 - the game if game over is false when
179:08 - winning or losing message appears the
179:10 - existing X will still finish hatching
179:12 - but new X will stop appearing
179:15 - Let's test it
179:21 - I have a winning message
179:24 - I have some leftover eggs but these
179:26 - hatchlings no longer increase our score
179:28 - we have some remaining enemies but they
179:31 - just slowly move off screen and don't
179:33 - come back again player remains
179:35 - interactive and we can still move it
179:36 - around perfect I want to test the losing
179:39 - message rather than intentionally
179:41 - pushing hatchlings in front of enemies
179:43 - to get eaten I will just manually set
179:45 - lost touch links to 10 here on line 380.
179:53 - yes we get our losing message this is
179:55 - great I set lost touch links back to
179:58 - zero
180:06 - adding a custom font is easy you can
180:09 - choose any font you want I will go to
180:10 - Google fonts they have thousands of
180:12 - fonts available there I want to use this
180:15 - comic book inspired font called bangers
180:17 - I click here to select the font and I
180:20 - click up here which will generate some
180:22 - code I can use to include this font in
180:24 - my project I copy these three link tags
180:27 - and I paste them up here in the head tag
180:30 - in my index HTML file ideally before my
180:33 - custom style sheet so the font is
180:35 - available from there
180:42 - then I copy the CSS rule I use it here
180:46 - in the case of this project I can just
180:48 - apply that font family to all elements
180:50 - you might want to be more specific and
180:52 - only apply it to the canvas element for
180:54 - example now the font is available in our
180:57 - project so up here on line 10. I said
181:00 - canvas font to 40 pixels bangers this
181:03 - will affect the text that the displays
181:05 - score and timers above hatching eggs we
181:09 - also want to set bangers here and here
181:11 - if we want to use it for game over
181:13 - messages
181:15 - let's quickly win the game
181:17 - yes this looks better doesn't it because
181:20 - we use safe and restore here everything
181:22 - I do in this area will remain restricted
181:25 - to game over messages canvas Shadows are
181:28 - performance expensive and some browsers
181:30 - don't deal with it well but if I limit
181:33 - them to this piece of text we will be
181:35 - okay let's try it we need to Define
181:37 - horizontal distance between shape and
181:40 - the shadow it can be a positive or A
181:42 - negative value depending on if you want
181:44 - the shadow to be to the left or to the
181:46 - right Shadow offset y can also be
181:49 - positive or negative it will determine
181:51 - vertical position of the shadow in
181:53 - relation to its parent shape
181:55 - Shadow color will be black we can also
181:58 - Define Shadow blur if we want that one
182:00 - is optional so I will leave it on
182:02 - default 0 which means no blur keep in
182:05 - mind that canvas shadows will only be
182:07 - drawn if Shadow color is set to a
182:09 - non-transparent value and if at least
182:12 - one of the properties Shadow blur Shadow
182:14 - offset X or Shadow offset Y is set to a
182:18 - non-zero value Shadows give the text a
182:21 - nice highlight and make it stand out
182:23 - from the background a bit more
182:25 - I set lost touch links to 10 again just
182:28 - to see the losing message what it looks
182:30 - like with new font and shadows nice this
182:33 - looks great I set close touch links back
182:35 - to zero
182:41 - [Music]
182:45 - we have this message here that says
182:47 - press R to butt heads again which means
182:50 - press R to restart the game what I'm
182:52 - about to show you is the simplest way
182:54 - you can Implement restart game
182:55 - functionality on the player class I
182:58 - create a custom method I call for
183:00 - example restart inside I want to set
183:03 - player properties to what they are when
183:06 - a new game starts
183:07 - let's have a quick look what we have
183:09 - here I want the player to move to the
183:12 - initial position
183:13 - we will reset Collision X and collision
183:15 - y
183:16 - we will also make sure that Sprite image
183:19 - moves along with the Collision Circle so
183:21 - I will need these two lines of code so
183:23 - play restart method will move player
183:25 - Collision area and player Sprite sheet
183:28 - back to its starting position
183:32 - we go down here to the main game class
183:35 - and here inside key down event listener
183:37 - I say if key that was pressed is R call
183:41 - restart method on game class
183:43 - like this
183:50 - I defined that method down here and in
183:53 - here we will set all properties to their
183:55 - initial State this will be different
183:57 - from Project to project we just wrote
184:00 - this code base so we are familiar with
184:02 - it and we understand what needs to be
184:04 - changed to restart the game back to its
184:07 - initial State first we will call restart
184:09 - method we just defined on the player
184:11 - class Let's test it I move the player
184:14 - and when I press letter r on the
184:16 - keyboard player will move back to its
184:18 - starting position so far so good we
184:21 - could use a similar technique to give
184:23 - the player an ability to rewind time for
184:25 - example where we just set State and
184:27 - position on X enemies and Hutch links to
184:30 - what it was let's say five seconds ago
184:32 - that might give us some interesting
184:33 - gameplay anyway we wanted to restart the
184:36 - game so up here in the Constructor I
184:39 - check what needs to change I know I will
184:41 - have to reset the contents of my arrays
184:44 - I take obstacles X enemies hatchlings
184:48 - and particles and I set all these back
184:51 - to empty arrays like this
184:53 - I test it
184:55 - okay so when I press R now this happens
184:58 - I need to run init method again to
185:01 - recreate enemies and obstacles since we
185:03 - deleted them
185:08 - yes now when I restart obstacles get
185:12 - regenerated at random positions and we
185:15 - also generate new enemies I can see I
185:18 - also need to reset the current Mouse
185:19 - position
185:21 - I take this.mouse and I set it to
185:25 - these starting values actually so I can
185:27 - just copy this
185:30 - I also resetted this score back to zero
185:32 - and also lost touch links
185:37 - I also need to set game over to false to
185:40 - make sure X keep appearing and enemies
185:42 - keep resetting
185:43 - Let's test it I play
185:47 - I win the game I press R to reset I play
185:54 - I win I reset
185:57 - I play
185:58 - I win seems to be working alright I set
186:01 - winning score to 30.
186:16 - okay I spent some time testing the
186:18 - gameplay and there are a couple more
186:20 - things we can adjust as you know we can
186:23 - enable and disable debug mode by
186:25 - pressing letter d
186:26 - I'm here on our custom larva class I
186:29 - would like our larva Hutch links to
186:31 - interact with X inside update method on
186:34 - larva class I use spread operator to
186:36 - expand X into collisions objects array
186:39 - doing this will make the eggs solid
186:42 - impossible obstacles and hatchlings will
186:44 - have to crawl around them this will make
186:47 - the game a bit more difficult and player
186:49 - will have to get more involved to get
186:51 - the X out of the way to make sure the
186:53 - hatchlings reach safe area as fast as
186:55 - possible sometimes hatchlings can even
186:58 - get stuck between multiple eggs and
187:00 - obstacles and if we don't free them in
187:02 - time they will get eaten by enemies
187:05 - alternatively I can remove X from here I
187:08 - go up to the egg class
187:14 - and inside update method on egg class I
187:17 - will expand hatch links into Collision
187:19 - objects array this on the other hand
187:21 - will make a game easier because not only
187:23 - will the hatchlings be able to push the
187:25 - X out of the way they will also
187:28 - sometimes push the eggs in front of them
187:30 - closer to the safety zone you can choose
187:32 - what you want to do here yourself
187:34 - depending on if you want your game to be
187:36 - easy or more challenging at this point
187:39 - you know this code base well enough so
187:41 - if you want you can take some freedom
187:43 - and adjust the gameplay however you want
187:49 - I also want the Collision circles on
187:52 - hatchlings to better match the Sprite
187:54 - sheet
187:55 - -40 here will work well I think to
187:57 - better align the bottom of collision
187:58 - circles with the bottom of bodies of the
188:01 - hatchlings I want these Collision areas
188:03 - to match the artwork as closely as
188:05 - possible we are in debug mode now but
188:08 - keep in mind that the game is meant to
188:10 - be played with Collision circles hidden
188:11 - when debug mode is Switched Off you can
188:14 - use the same technique to better align
188:16 - Collision circles on enemies with the
188:18 - little shadow on the ground below each
188:20 - enemy I will do that in a minute because
188:22 - the next lesson we will focus on adding
188:24 - new enemy types I will also give you all
188:26 - the character sprite sheets and we will
188:28 - add a lot of animations to this project
188:31 - I had so much fun designing these
188:33 - creatures and making them move I hope
188:35 - you like it
188:37 - I noticed one small Edge case bug when
188:39 - we get game over message and leftover
188:41 - enemies eat some leftover hatchlings
188:43 - lost touch links variables still
188:45 - increases we need to make sure that lost
188:47 - touch links value stays the same after
188:49 - game over message is displayed so I will
188:52 - only run this code block if game over is
188:54 - false this will also make the hatchlings
188:57 - invulnerable under the game over screen
188:59 - if you don't want that you can apply
189:02 - this if statement only to one line of
189:04 - code that increases those hatch links if
189:06 - game over is false lost touch links plus
189:09 - plus
189:11 - in the extended version we will add more
189:14 - features we will animate the player
189:16 - hatchlings and enemies I will give you
189:18 - static and animated Sprite sheets for
189:20 - all these characters you will also get
189:22 - the full source code but not only the
189:24 - final source code but multiple stages as
189:26 - we progress with the project from the
189:28 - base game to the complete fully animated
189:30 - version if you followed along and watch
189:33 - this far you should be really proud of
189:34 - yourself you can let me know by saying I
189:37 - did it in the comment section below I'm
189:39 - looking forward to see what projects you
189:41 - come up with when you combine your
189:42 - knowledge and your creativity I hope you
189:45 - got maximum value today time is the most
189:47 - valuable resource we have thank you for
189:49 - spending your time with me I'll see you
189:51 - soon