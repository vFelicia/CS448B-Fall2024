00:00 - Hi, welcome to amigos code. My name is Nelson. 
And in this crash course, I'm going to teach  
00:04 - you everything you need to know about Spring 
Boot Spring Boot. It's an amazing framework for  
00:09 - building Java applications very fast. Recently, 
Netflix just announced that they'll be switching  
00:16 - their entire back end to Spring Boot. And this 
is because Spring Boot is so solid, that there's  
00:24 - no need for you to reinvent the wheel. So they 
provide things such as connectivity to databases,  
00:30 - jetty servers, metrics configuration, and pretty 
much instead of you having to configure the low  
00:39 - level code to get up and running, you can simply 
use Spring Boot and get off the ground very  
00:45 - quick. So first, I'm going to show you exactly 
how to use Spring Boot dependency injection,  
00:50 - and how to implement to an interface where we will 
have an in memory database, and then I'm going to  
00:56 - show you exactly how to connect to a real database 
running on Docker. So without further ado,  
01:04 - let's get started. Alright, amigos, welcome to 
amigos code. In this video, I want to teach you  
01:11 - exactly how to use Spring Boot 2.0. Spring 
Boot is by far one of the best frameworks  
01:17 - for building applications in the Java world. So 
if you want to build an enterprise application,  
01:23 - you can use Spring Boot, or if you want to 
prototype an idea and see whether you know,  
01:30 - it works that you can use Spring Boot because 
it makes it very easy to build applications. And  
01:35 - basically, Spring Boot provides you a platform for 
building back end applications. And not only that,  
01:42 - you can also build web applications as well. So in 
this video, let's go ahead and build this awesome  
01:48 - API, where any client can submit a request. So 
these requests could be a get request, post,  
01:58 - delete, and put. And then we're going to take 
that request, and within the API layer or control  
02:06 - layer, so this is where we receive the requests, 
we're going to send that to the service layer. And  
02:12 - basically, the service layer is responsible to 
handle all the business logic that you may have  
02:17 - within your application. After you perform some 
business logic, then you might decide to use a  
02:25 - database to perform some various CRUD operations. 
And basically, so this layer right here,  
02:32 - so this layer is responsible to connect to any 
database of your choice. So the cool thing about  
02:39 - Spring Boot and dependency injection is that you 
can start with an implementation. And then if  
02:45 - you want to switch to a different database, you 
simply have to change one line of code. And I'm  
02:50 - going to show you exactly how to do that with the 
pendency injection. So after you submit the actual  
02:59 - request from any clients, so the clients could 
be an iOS app, a react or even an Android app,  
03:06 - the request will go through all these layers, and 
then go back with a response to the client. So the  
03:14 - response could actually be, for example, a JSON 
payload, or an image, or a status code of 200 500,  
03:22 - so on and so forth. So if you want to learn the 
best framework for building Java applications,  
03:28 - stick to this video, because there is a lot to 
cover. And I'm pretty sure that after this video,  
03:33 - you will be very comfortable building back 
end applications with Spring Boot. So let's  
03:40 - go ahead and get started. So the very first 
thing that I want you to do is to navigate  
03:45 - to this website start.spring.io. And basically, 
this website, you can see that it's it's titled  
03:53 - spring initializer. And basically allows 
you to bootstrap your application by picking  
03:58 - dependencies and configuring the actual project. 
So go ahead and generate a project with Maven,  
04:05 - we can see that you can be Gradle. And then 
you have the option to code with Java kotlin  
04:12 - or groovy. So I'm gonna stick with Java. And then 
for the actual version, make sure that it is above  
04:18 - 2.0. So I've got a video on 1.5. And basically, 
I just want to make sure that you guys have the  
04:26 - latest version, so that you can use it within 
your latest projects. So then go ahead and click  
04:36 - on this link right here. So switch to the full 
version, basically, right here, you can, you know,  
04:41 - configure your project metadata. So go ahead and 
change these according to your company or project  
04:47 - name. But for this tutorial, I'm going to leave 
everything as is apart from the Java version.  
04:53 - So I'm going to pick Java 11, because I do have 
it installed. But if you don't have Java 11 go  
04:59 - ahead and pick Java eight because it will also 
work. Then, if you scroll down, you can see that  
05:05 - right here you have a bunch of dependencies. And 
this is why springboard is pretty much one of the  
05:12 - best Java frameworks for building applications. 
So they give you a lot of flexibility with these  
05:19 - dependencies, which simply means that you can 
install one of these dependencies and start coding  
05:26 - right away instead of you having to configuring 
and you know, setting up things. So basically,  
05:31 - you just have to install these dependencies, 
and then start implementing whatever you want.  
05:37 - So you can see that we have a bunch of sections 
right here. So web server web applications with  
05:44 - spring MVC, and Tomcat at jersey WebSockets, 
template engines, security, so they make it very  
05:51 - easy for you to configure security within your 
applications. So you know, it saves you the hassle  
05:57 - of having to implement security the right way. 
So basically, they're doing the difficult job,  
06:03 - which is implementing the security, and then 
giving you this nice package that you can just  
06:08 - plug in play. And then you have SQL, so my sequel, 
h2 JDBC, Postgres flyway for database, migrations,  
06:17 - Mongo, and then you can scroll down, you can see 
that they have a lot of great things. So for this  
06:24 - video right here, let's go ahead and focus on 
picking this dependency right here. So web server  
06:32 - web applications with spring receipt and Tomcat. 
So I'm going to take that and then generate a  
06:38 - project. So right here, you see that I've got 
this demo zip, which I'm going to open in my  
06:43 - desktop. There we go. So now I'm going to click on 
this zip folder. And if I delete the actual zip,  
06:56 - you can see that now I have this folder right 
here. So for this video, I'm going to be using  
07:01 - intelligence, which is by far the best ID. And if 
you want to learn about intelligence, go ahead and  
07:07 - check my video on YouTube, which I show you how to 
download, install and configure IntelliJ properly.  
07:14 - And if you are using NetBeans, or Eclipse, this 
will also work. So inside of IntelliJ. So I  
07:22 - actually recommend you to download and install 
IntelliJ if you don't have it to follow along,  
07:27 - and I'm pretty sure that you're going to learn 
great things with IntelliJ throughout this video.  
07:31 - So what I'm going to do now is pretty much click 
on open. And then navigate to desktop, and then  
07:40 - open up this demo folder, and then open up the 
actual POM dot XML. So I'm going to open that up,  
07:48 - and then open as project. So I'm going to allow 
and just give you a second, Maven is resolving  
07:57 - the dependencies for this project. There we go. 
So that's nice and done. So let's go ahead and  
08:05 - explore this project. So open up demo. And inside 
demo, you can see they have couple of folders,  
08:12 - but the ones that we really care about are 
the palm dot XML. So if I open that up,  
08:17 - and see that this is what you saw when configuring 
the project with spring initializer. So you saw  
08:25 - the group ID artifact, name, and then version. 
So this is the version right here. And then this  
08:35 - is Java 11. Basically, the actual dependency 
that we picked was this one right here. So  
08:41 - Spring Boot starter web. And by default Spring 
Boot ships with Spring Boot starter tests for  
08:48 - writing unit and integration tests. So go ahead 
and close this because we don't need it. And open  
08:57 - up the source folder. So open up source, and 
then main. And you can see that you have Java,  
09:04 - and then inside you should have a class called 
demo application. And inside of this class,  
09:13 - you have this public static void Main method. 
And this is how you pretty much just run your  
09:20 - spring application. And if I play so make sure you 
play this. Just give me a second. You should see  
09:30 - that I have spring up and running and you can see 
that it says that Tomcat started on port 8080. So  
09:39 - right here, we could change this port but this is 
the default port for Tomcat. So I'm going to stop  
09:45 - this and you can see that everything is up 
and running fine. I'm gonna stop this and then  
09:51 - collapse this. And then inside of resources, you 
have static templates and application properties.  
09:58 - So start is where all the web resources 
live for web applications. And then you  
10:06 - have templates. And this is where you have all the 
templates for your web application. So usually,  
10:12 - you would use something like mustache or ej s. And 
then you have this application that properties.  
10:18 - So this is where all the properties for your 
application do live. And the cool thing about  
10:24 - properties is that you can define properties for 
different environments. So you could have a demo  
10:30 - environment, a test environment and a production 
environment with different values for the actual  
10:36 - properties. So it's pretty cool. So I'm going 
to cancel out of that. And now that you know  
10:43 - the actual structure and make sure that you can 
start the application, you've successfully managed  
10:50 - to start a Tomcat server with Spring Boot. So 
now let's go ahead and implement our API with  
10:58 - all of those resources, controllers, services, 
and defining a database as well. So if I go back  
11:07 - to this diagram, so remember that I said we had 
the API layer controller, or controller layer,  
11:19 - and then we have service layer for business logic, 
and then database for data access. So let's go  
11:26 - ahead and start things right here. So we're going 
to start right here. And in fact, this I mean, put  
11:32 - a dot right here, so you know what we're doing. So 
if I remove that, basically, let's put just a.so,  
11:41 - we know where we are, with things. So right 
here. And then if I collapse that, so basically,  
11:51 - we're going to implement this section first, 
and then move our way up. So basically, we're  
11:58 - going to implement one step at a time, and then 
see everything working fine, and then implement  
12:05 - some other functionality. So let's go ahead and 
go back to IntelliJ. And the first thing that I  
12:14 - want you to do is to create a package. So let's 
go ahead and create a package. And right here,  
12:22 - simply call it API. So this is where the API 
will live. Go ahead and create a second package,  
12:30 - and simply say, model, go ahead and create 
a third package, call it service, go ahead  
12:39 - and create a fifth package or actually a fourth 
package and call it so we need the actual da Oh,  
12:47 - and I think this is it. So we have API d o model 
and service. And basically these packages are  
12:58 - representing this diagram. So if I go back, and 
perhaps you haven't seen me, like right clicking,  
13:09 - so new, and then a package. So basically, I tend 
to use a lot of keyboard shortcuts. And this is  
13:16 - how I am productive with IntelliJ. So if I press 
Ctrl, and then enter, you can see the keyboard  
13:23 - shortcut down below. And basically, then that 
gives me the ability to create a new package.  
13:29 - So the same if I, for example, create a variable. 
So if I say var, and then ELO equals to two. And,  
13:42 - and then if I press Command, and then why you can 
see the keyboard down below, right? So I've just  
13:50 - deleted that line. So also, let me go ahead and 
say, Okay, so now what we need to do is actually  
13:57 - define our model. So what is the actual model for 
this application? So if I go back to this diagram,  
14:05 - so let's go ahead and define a model. So I'm going 
to copy this stereotype. And you can grab this  
14:12 - diagram, you can find the link in the description 
below where you can download and see exactly,  
14:16 - you know, everything that we're doing here. So 
basically, the actual model, so oops, so the model  
14:23 - for this tutorial will be a person. And basically 
a person will have an ID. So when ID. And let's  
14:33 - keep things simple and have like, let's say a full 
or actually name, just like that. So obviously,  
14:41 - you could have more properties. But I want 
to keep it simple for you see exactly what's  
14:45 - happening. And so things you know, become really 
obvious to you. So we have this model right here  
14:53 - called person. Let's go ahead and define this 
in actual code. So go back to IntelliJ and in  
14:59 - side of the model package, go ahead and create 
a new class and simply call this person. Right,  
15:08 - so the kind it's a class, and then press enter. 
So now simply go ahead and say private final, and  
15:15 - then the ID will be of type U ID. And simply call 
the Id go ahead and simply save private final,  
15:24 - and then string. So this is the actual name. And 
then I'm going to add these two constructors. So  
15:31 - you can see I'm using keyboard shortcuts again, 
and then the getters. So just like that, and there  
15:38 - we go. So now we have a model that we can work 
with. So if I go back, so now we have to define  
15:46 - the actual database section right here, right, so 
let's define the actual interface that will allow  
15:54 - us to have any implementation for our database. So 
inside of the DA, Oh, go ahead and create a class,  
16:02 - and then simply save person and then the A Oh, 
so instead of like class, change this to an  
16:09 - interface. And this is the actual interface where 
we're going to define the operations allowed,  
16:16 - or the actual contract for anyone that wishes to 
implement this interface. And the cool thing about  
16:24 - it is that we can then use dependency injection 
to switch between implementations with just one  
16:31 - line of code. So let's go ahead and define our 
very first method. So for our database, we want  
16:37 - to insert a person into the actual database. So 
we will simply return an integer. And basically,  
16:46 - we're going to mock a database using like a 
list. And basically, we will return zero or one  
16:51 - depending whether the actual data is persisted to 
the actual database. So let's simply go ahead and  
17:00 - say insert, and then person. And this will take 
a user ID, which is the actual ID, and then a  
17:10 - person just like that, and that with semicolon. 
Now, let's also go ahead and create a default  
17:18 - method. And basically, this will be the same 
thing, or actually sorry, this will be integer.  
17:24 - So it will be the same thing. And let's simply 
call this ad and then person. And right here,  
17:32 - we will simply take person, right. And what this 
allows us to do is to actually generate the you  
17:40 - IDs, ourself, or the actual ID, so you would, and 
then let's call the ID equals two, and then UAT,  
17:48 - dot and then run the mu ID, and then simply say, 
return. And then insert person passing the ID, and  
17:58 - then the actual person. Yep. So basically, we have 
two methods, one that allows us to insert a person  
18:06 - with a given ID, and the other one without an ID. 
And the ID is simply randomly generated. Now let's  
18:14 - go ahead and create a class that will implement 
this interface. So open up the DA o package,  
18:22 - and then simply create a class and call it person 
and call it fake. And then person data, access,  
18:32 - and then service. And then this guy implements 
and then person, da, oh, just like that, and then  
18:42 - implement the methods. And we need to implement 
insert person, right. So right here, let's go  
18:52 - ahead and define our list. So private, and then 
static. And then and then list. And this will be a  
19:01 - list of person, simply quality b equals to a new, 
and then array list just like that. Or, in fact,  
19:13 - we could even initialize this inside of a static 
clock, if we wanted. So now to insert a person,  
19:20 - all we have to do is simply add to this database 
right here. So for the sake of this, simply go  
19:29 - ahead and say dB, dot and then add, and then new 
and then person and simply take the actual ID,  
19:38 - and then simply say person, dot and then get name. 
Right. So And finally, let's simply go ahead and  
19:45 - return one. So we know that it always works. So 
the insertion always works. So now let's go ahead  
19:53 - and actually define the actual service. So inside 
of the service package, go ahead and create a new  
19:59 - class. And then simply call it person and then 
service. And right here inside of this class,  
20:06 - let's see if we have a method to insert a new 
person. So simply go ahead and say public,  
20:13 - and then int, and then and and then person. And 
basically, this will take a person. And what we  
20:23 - want to do is simply say return. And right here, 
we need to actually get a reference of the actual  
20:31 - person, da Oh, so let's go ahead and simply say, 
private, and then final, and then person, da, oh,  
20:38 - and make sure that you get the actual interface 
and not the concrete class. So don't get the  
20:44 - actual fake person data access service, because 
I want to show exactly how to use dependency  
20:50 - injection. So then what we need to do is added to 
the constructor. And now we can simply say person,  
20:58 - da, O dot, and then insert, and then person. So 
remember, we had two methods. And if I go back  
21:05 - to my interface, so person to you, oh, and in 
fact, I need to call this the same. So let's be  
21:13 - consistent. So person, so insert person, actually. 
So now you can see that the error went away. So  
21:18 - basically, we have the option of providing the ID 
or not. So in this case, let's go ahead and have  
21:24 - it, you know, randomly generated, because we don't 
care. But if you need to generate the ID yourself,  
21:31 - you know that you can do it. So now that we have 
the service done, let's go ahead and implement  
21:37 - the actual API. So inside of the API package, go 
ahead and create class, and simply call it person.  
21:45 - And then resource. Or actually, let's go ahead and 
save controller. So in Spring Boot world, we tend  
21:52 - to name these as controllers. So and then simply 
say, OK, and then let's go ahead and also have  
22:00 - a reference to the actual service. So private, 
final, and then person service. And then right  
22:08 - here, we need to add this to the constructor. And 
then let's simply go ahead and have a method that  
22:15 - adds a person, so public, and then simply say, 
void, so we don't want to return an integer in  
22:21 - this case. So we want to, so we want to return 
a status code of 200. Or if anything fails,  
22:28 - we can pretty much throw an exception. So or 
you could also have your custom exceptions,  
22:34 - if you wish. So let's go ahead and simply say add, 
and then person. And this will take a person, so a  
22:42 - person just like that. And then what we need to do 
is actually say person service, dot and then add  
22:50 - person, just like that. So up to this point, we 
simply have normal Java classes. And to be honest,  
22:58 - we're not even using spring framework at this 
point. So let's go ahead and configure everything  
23:05 - to start using spring framework. So let's go ahead 
and open up the actual da Oh, so fake person data  
23:15 - access service. And you'll see right here inside 
of the actual service, we have a reference to it.  
23:21 - So person, da O. And basically, we are trying to 
use dependency injection. So if I was to run this,  
23:28 - this would wouldn't work because this person 
deal is not instantiated. And you know,  
23:37 - there's no way for this constructor to know about 
it, right. So this is where we use annotations to  
23:45 - instantiate beans. So open up the fake person 
data access service. And the way that we tell  
23:53 - spring that this class needs to be established, 
created as a beam so that we can inject it  
24:00 - in all the classes is simply by saying act and 
then repository. Right. So you could also say add,  
24:07 - and then component. So this is the exact same 
thing. But repository makes it obvious that this  
24:14 - class is served as a repository. Right. So now 
that we have a repository, let's go ahead and  
24:21 - configure the actual service. So for service, 
you might take a guess. So this will be add and  
24:27 - then service. Right. And you could also use a lead 
component if you wish. But I usually prefer to be,  
24:34 - you know, specific. So anyone looking up my code, 
know exactly that this is a service. So now that  
24:43 - we pretty much annotated the actual data access 
service, and right here we are injecting right  
24:51 - so we are injecting into the actual constructor. 
So the way that we inject is simply saying add and  
24:59 - then auto wired. So basically, we are auto wiring 
into this interface, right. So now, because we can  
25:09 - have multiple implementations of this interface 
right here, we must have a way to distinguish  
25:15 - between them, right. And this is when use at 
and then qualifier, right? So add qualifier.  
25:22 - And then right here, you can give it a name, so 
fake and then da O. And basically, I need to go  
25:30 - back to my fake person that access service. And 
then right here, I'm going to name this as fake.  
25:36 - And then da O. And what this allows me to do is 
to have multiple implementations. And basically,  
25:44 - all I need to do is for example, if I have, for 
example, a Postgres or a MongoDB implementation,  
25:50 - I simply say Mongo, just like that, and then 
I don't have to change anything. So let's go  
25:58 - ahead and use the fake da Oh, and now this is why 
it's correctly. So finally, let's go ahead and  
26:05 - open up the actual API package. And then personal 
controller. Let's also go ahead and simply say,  
26:12 - at an auto wired, basically, springboard injects 
the actual service into this constructor. And  
26:20 - if you want to learn more about dependency 
injection, go ahead and check my channel,  
26:23 - I made a video specific on dependency injection, 
and why it's important for you to know about it.  
26:30 - So now, remember that I said that this class right 
here, so the API, if I go back to our diagram,  
26:38 - is this one right here. And right here, we 
can specify HTTP methods. So get post, delete,  
26:46 - and put. So these clients right here, right, so 
they have to issue some requests to our back end.  
26:55 - So right now, there is no code that tells that 
this method right here will be served as a post  
27:03 - or put or get or delete. And also, this class is 
not available as a rest controller. So to do that,  
27:13 - we need to use a special annotation and simply 
say, add, and then rest controller, right. So  
27:19 - this is a rest controller class, that we can have 
some methods, and then expose some endpoints that  
27:25 - clients can consume. So in our case, what we 
want to do is have this method right here to  
27:35 - be served as a POST request. So basically gets is 
for retrieving data from your server posts is to  
27:45 - adding a resource to your server, put modifying, 
and then delete for deleting a resource,  
27:51 - a resource from your server. So to tell spring 
that this method will be used as a POST request,  
28:01 - we'll simply use the annotation at and then post 
and then mapping. And this is all we have to do  
28:08 - now. So obviously, we want to add a person from my 
client, right? So go ahead and download postman.  
28:20 - So postman allows you to pretty much just serve 
as a client, because we don't have, for example,  
28:26 - a react application or an Android app, or you 
know, you we don't have any, any any client,  
28:33 - right. So we can use postman as our client, right. 
So go ahead and download postman, it's an amazing  
28:42 - client. And what we need to do is actually send a 
person to our server. So before we do that, so let  
28:51 - me actually clear everything here. And basically, 
go ahead and say post, and then this will be local  
29:00 - host, column, and then AD AD. And then for slash, 
and then simply say API, forward slash, and then  
29:08 - v1, and then person, right. So after you define 
the actual endpoint, go ahead to the actual body,  
29:17 - and then simply say raw, and then instead of text, 
go ahead and send a JSON. So we want to send a  
29:27 - JSON payload to the actual server. And remember, 
we have name, and let's say that this is James  
29:34 - and then bond. So basically, we want to send James 
Bond to the server. So in order for us to do that,  
29:42 - we have to do few things. One is we have to define 
these properties in our pojo so that when we send  
29:52 - this JSON spring knows to take this property and 
then convert that into a jar. Have a class, right.  
30:01 - So in order for us to do that, what we need to do 
is open up person. So inside of the model package,  
30:07 - open a person. And then you'll see right here in 
the constructor, let's go ahead and define some  
30:14 - properties. So JSON property, and this will be 
the ID. And then right here, so if I put this on  
30:23 - your line art, and then Jason property, and this 
will be the actual name, right? So you could also  
30:30 - define more properties. But as I said, Let's keep 
this simple so that you understand exactly what's  
30:37 - going on. So if I open a postman again. So right 
here, you see that name. So this name right here  
30:46 - matches the property that we have in our class 
person. And if we wanted to send the ID, so we  
30:54 - would simply say ID and then pass, you know an 
ID, but we are generating the ID from the server,  
31:03 - therefore, we don't need to send it. Now what I 
need to do is actually tell that we are receiving  
31:12 - this JSON payload from the actual body. So inside 
of person controller, go ahead, and you see right  
31:22 - here where you add a person. So right here, simply 
annotate this with ADD, and then request. And then  
31:30 - body, right. So we are simply saying that we 
want to take the request body, and then shovel  
31:37 - that inside of this person. And then because we 
have, so right here, so because we have these,  
31:45 - this property right here, we will simply turn 
this JSON object into a person. That's what  
31:52 - we're saying. And the final thing that we have 
to do is actually define this path right here,  
31:57 - right? So right here before rest controller simply 
say at and then request. And then mapping. And the  
32:09 - actual mapping will be API, v1, and then person. 
So this is all you need to do in order to create  
32:17 - your very first endpoint with Spring Boot. Now, 
what we need to do is actually test it. So let's  
32:23 - go ahead and simply play the application. So as 
you can see, Tomcat started on port 8080. Now,  
32:35 - if I open up postman, and then simply send this 
request right here, you can see that we have a  
32:46 - 200 status code. And this means that the request 
went through fine. Now, obviously, we don't have a  
32:55 - way of testing this, right, because we don't have 
an endpoint to retrieve people from our database.  
33:03 - So let's go ahead and define the functionality 
to get people from our database. So let me go  
33:10 - ahead and open up the IntelliJ. And if I collapse 
that, so go ahead and open up the person da Oh,  
33:18 - and let's go ahead and say that this will return 
a list of person and say, select all people. And  
33:29 - then let's go ahead and open up the person data 
access service. So we need to implement that. And  
33:38 - then right here, what we need to do is very simple 
within the actual database, and open up service.  
33:46 - So right here, simply create a method public. And 
then list of person, get, and then all people and  
34:02 - then this will return person, the Oh, don't and 
then select all people. So now we need to define  
34:11 - the actual resource or the actual method that will 
serve as the get request. So simply say public,  
34:19 - and then a list of and then person and then get 
all people and then what we're going to return  
34:32 - is the actual person service dot and then get 
Oh people, right. So now we need to tell that  
34:40 - this method will be served as a get request. 
And the way that you do it is simply by saying  
34:46 - add and then get and then mapping. So you see 
that everything has the same pattern at the post  
34:54 - mapping at getting mapping. Now, let me go ahead 
and pretty much just restart the server There we  
35:05 - go. So the actual server started on port 8080. So 
open up postman. And then let's actually try and  
35:17 - send the actual same request. So we're going to 
send James Bond can see that worked. And now let's  
35:26 - go ahead and try and perform a get request to our 
server. So the exact same URL, send, and there we  
35:34 - go. So you can see that we have an array with one 
person that comes from our database. So this is  
35:41 - awesome. Now let's go ahead and perform a nother 
post. So so right here, so change this to Nelson,  
35:50 - and then Mandela, you can change this to whatever 
name you want to be honest, I'm going to send that  
35:56 - you can see that it's 200. And then simply change 
this to Anna, and then Jones, send. And now if I  
36:07 - perform a get request to our server, you can see 
that we have three people. So James Bond, Nelson,  
36:16 - and Anna Jones. So as you see, springboard is 
just incredible. It's super fun. And as you saw,  
36:25 - like, it didn't take us long to implement this 
functionality, right, we're just using annotations  
36:30 - to drive our implementation, which is awesome. 
And we can pretty much deliver results very fast,  
36:38 - using Spring Boot. Now, let's go ahead 
and implement the other two HTTP methods,  
36:44 - the ability to update a person, as well as 
deleting a person. So open up IntelliJ. If  
36:52 - I collapse this, and then open up the actual 
da Oh, and let's define the actual interface,  
36:58 - or actual method. So right here, simply say int, 
and delete, and then person by ID. And right here,  
37:08 - we need to pass the actual ID, so you ID and then 
ID. And let's also define a couple of things. So  
37:15 - let's also define that we want to update a person. 
So this will return an integer, and then simply  
37:22 - say, update. And then person by ID. So right 
here, we're going to pass the actual ID and the  
37:34 - actual new person that we want to update, right, 
so person. And also, let's define one more method.  
37:43 - And this will be an optional of and then person. 
And then simply say, select person by and then ID,  
37:55 - and then simply pass the actual ID inside. And 
there we go. So now let's go ahead and open up  
38:03 - the fake person data access service. And we have 
to implement all of those methods. So I'm pressing  
38:08 - Alt, and then enter, and then implement methods. 
And you can see that we have these two methods  
38:14 - that we need to implement. Okay, and error is 
gone. So in fact, let's go ahead and implement,  
38:21 - select the person by the first. So to implement 
this method, what we need to do is actually search  
38:29 - within our database and see whether we have a 
person with the given ID so this one right here,  
38:35 - so the way we do it is simply by streaming our 
database. So let's go ahead and use Java streams,  
38:42 - dot and then stream. And if you want to learn 
more about streams, go ahead and check my video  
38:48 - on Java streams where I cover this. So let's 
go ahead and simply say filter. And right here,  
38:56 - we get a person. And then let's simply say that 
person dot and then get ID dot equals to ID,  
39:04 - right. And then what we want is dot and then 
find, and then first. And there we go. So now  
39:13 - let's go ahead and open up the actual service, 
and then simply implement the same method here,  
39:20 - so public, and then this will be an optional, and 
then person, and then get person by ID, and then  
39:32 - simply pass the actual ID. And you can see that 
it's almost the same thing that we're doing right  
39:39 - here return and then person do dot and then get 
or actually select person by ID, and then pass  
39:49 - the ID and then open up the controller. So person 
controller, and this will be a get so basically  
39:59 - We went to public. So this will be person and then 
get in then person by ID. And then we're going to  
40:11 - pass the ID, and I'm going to show you exactly how 
do we get that. So Id, and then what we want to do  
40:17 - is simply say return. And then person service dot 
get person by ID, lowercase ID, and then.or. Else,  
40:29 - and then no. So right here, you could actually 
have a custom message or a custom exception,  
40:36 - or a custom code thrown to the actual client. So 
for example, a 404, with a message saying, user  
40:44 - not found, but for this video, let's go ahead and 
keep it simple and simply return now. Right? So  
40:51 - now what we want to do is, if I open up postman is 
you see this ID right here, right? So I want to be  
40:58 - able to copy the ID, and then simply say, forward 
slash, and then pass the ID. And then when I send  
41:07 - the request, I should get that person back. Right. 
So the way that we get the ID from the path is by  
41:15 - simply using an annotation, and the annotation is 
called. So this one is at, and then path and then  
41:24 - variable. And the PATH variable that we want, is 
an ID. So Id, just like that. And basically, this  
41:35 - is a type right here. So now let's go ahead and 
define the actual mapping. So this will be add,  
41:41 - and then get and then mapping. And now because we 
want to have the actual ID in the path, so inside  
41:51 - simply save path. And then what you want is double 
quotes, and then curly brackets, and then pass ID.  
41:59 - So basically, this will allow you to have forward 
slash and then some ID. And then right here,  
42:07 - you're simply grabbing the ID, and then turning 
that into a unit. Right. So let's go ahead and  
42:15 - test this. So if I pretty much just restart 
the actual server, there we go up and running.  
42:26 - So if I open up postman, now we need to issue 
some requests. So you can see that, you know,  
42:35 - every time that we restart the server, we lose 
everything from our list. That's a disadvantage  
42:40 - of having an in memory database. But for this 
video, you can see exactly how everything works.  
42:46 - So let's go ahead and send a POST request there. 
And then let's get everyone so remove the actual  
42:55 - you with there. So send. So we have knelson, right 
there. And basically now we can grab Nelson's ID,  
43:07 - and then do a forward slash, and then paste that. 
Right. So now if I send, you can see that we  
43:16 - have only one object, right? It's not It's not an 
array, but it's an object. And if I was to change  
43:23 - the ID for something that doesn't exist, send, you 
can see that actually, it's a bad request. Because  
43:32 - the you with it's completely wrong. So it's not 
valid you with that I've just sent to the server,  
43:38 - but you get the idea. So if I go ahead, and 
let's go ahead and add Anna Jones. So send,  
43:47 - and then let's get everyone, and let's grab 
Anna Jones ID right there. And then Ford slash,  
43:56 - send that. In, see that works. Right. And in fact, 
let me go ahead and say you wait generator, and  
44:07 - let me generate the unit. So I want one unit here. 
And if I grab this, and then go back to postman,  
44:16 - and then perform a get request with that up there. 
So if I delete everything, and then paste that  
44:26 - yo ID and then send you see that it's a 200. But 
we have nothing in our database without your ID.  
44:38 - Right? So as I said, so you shouldn't be throwing 
a 404 with a custom exception. But in this video,  
44:47 - you can see exactly that we are returning nothing 
because there is no one without you it against our  
44:52 - database. So let's go ahead and implement the 
remaining methods. So if I collapse this, so  
44:59 - Let's go ahead and implement everything in one go 
now. So open up the actual fake person data access  
45:06 - service. And to delete a person, what we need 
to do is simply get the person if the person is  
45:15 - there, delete it, otherwise, return zero. So let's 
go ahead and simply say select. And then person by  
45:25 - ID, we're going to grab the ID. And remember, this 
returns an optional, so person, and then maybe,  
45:32 - and right here, I'll simply say, if, and then 
person may be dot, and then is empty. So if it is  
45:42 - empty, we want to return zero. Otherwise, what we 
want to do is actually remove from the database,  
45:53 - right, so if it's there, we want to remove so DB 
dot and then remove, and then person, maybe dot  
46:03 - and then get just like that. And then return one, 
right, so we know that we did delete this person.  
46:12 - Now let's go ahead and implement update person. 
So what we're going to do is simply say return and  
46:19 - then get or actually select person by ID, we're 
going to pass the ID. And then what we want to  
46:27 - do is say dot and then map. So right here, we get 
a person, let's call it P. So P. And as I said,  
46:37 - if you want to learn about, you know Java streams, 
maps, operations filtering, go ahead and check my  
46:44 - YouTube video where I teach all of this. So now 
let's go ahead and try and get the actual index  
46:50 - of this person. So int, and then index of and 
then person to delete equals to and then DB dot,  
47:01 - and then index of and then pass the actual 
person, right. So now we have an index. So I'm  
47:08 - going to say if the actual index to the leat and 
I'm missing a knee right there. So if the index  
47:16 - to delete is greater or equal to zero, what we 
want to do is actually set the actual person, so  
47:26 - we means that we found someone, right, so let's go 
ahead and say DB dot and then set and then index  
47:33 - of the person to delete, and then simply pass the 
actual person, right. And now what we can do is  
47:41 - simply return one right here. So otherwise, so 
else, or we can simply say return and then zero.  
47:51 - And then right here, so because we need to return 
an integer, simply say don't, and then Or else,  
47:59 - and then zero. Right. So basically, if I format 
this, so basically, I'm saying select the person,  
48:07 - and then map that person to something else, 
right. And if the actual index of that person  
48:17 - is greater or equal to zero, we know that we 
found that person, and then set the contents  
48:24 - of that person to the new person that we've just 
received from the client, and then return one,  
48:29 - everything is fine. Otherwise, return zero. Or 
if select person by the is not present, we don't  
48:38 - do anything and simply return zero. So this is 
what it means. So now let's go ahead and simply,  
48:45 - you know, feed this through the service, as well 
as controller and then test it. So let's go ahead  
48:51 - and simply open up pass and service. So let's 
go ahead and save public and then ain't delete,  
48:58 - and then person. And then right here, we're going 
to take the actual ID, so Id, and then this will  
49:08 - be very simple. All we need to do is simply say 
return, and then person do that. And then the lead  
49:15 - by ID pass the actual ID, and we're done. To 
update a person, sorry. So if I close that, so to  
49:24 - update a person, what we need to do is simply say, 
public, and then ENT, update, and then person. So  
49:32 - we're going to take the actual ID, so you ID and 
then ID and then this person is the new person,  
49:41 - so new and then person. Right? And then what 
we need to do, I simply say return personally,  
49:50 - oh Don and an update, and then Id right. So you 
can see that I don't have much logic going on  
49:59 - here. Here. And this is because, you know, 
I'm just teaching you exactly how to use,  
50:03 - you know, Spring Boot to to create an API. But 
essentially, you know, inside of this service,  
50:10 - you will have whatever logic your application 
requires, right. So I'm just making this simple  
50:17 - for you to understand exactly. So you don't 
have a lot of code going on. Basically, you see  
50:22 - the entire process of what we're doing. So now, 
let me go back to the actual person controller,  
50:29 - and simply expose those to a REST API. So the 
first one is update, or actually delete. So let's  
50:39 - go ahead and say delete, so public, and then 
void, and then delete, and then person by ID,  
50:48 - we simply pass the ID, and pretty much the same 
thing at and then PATH variable. And then this  
50:57 - will be the ID. And then we want that to be 
a u ID, ID. And then return, Oh, actually,  
51:09 - there's no need to return here, because this is 
void. So simply say person service dot, and then  
51:16 - the lead person passed the ID. Now this has to be 
guess what at, and then remember, we are deleting  
51:24 - a resource from the server. So delete, and then 
mapping. So now inside, we have to have the path,  
51:33 - and then the actual ID, right, so this ID is this 
one, right here, which we can pass down to the  
51:43 - service. So let's also go ahead and implement 
the actual update. So the update will be act,  
51:50 - and then put, and then mapping, and public. And 
then Floyd, and then update person. And then this  
52:06 - will take a person from the request body. So 
art, and then request body will take a person  
52:15 - to update. There we go. And now simply say person 
service dot and then update. And in fact, we also  
52:27 - need the actual path. So the path will include the 
actual ID. So Id, and let's go ahead and say that,  
52:37 - and then path and then variable. And that will 
contain the ID. And this will be a user ID,  
52:51 - and then call it ID. And there we go. So now we 
can pass ID and then person to update. Right.  
53:01 - And to be honest, this is all we have to do to 
implement our REST API. So let's go ahead and test  
53:10 - it. So I'm going to pretty much just restart the 
server. So let me go ahead and open up postman. So  
53:19 - let's start with one person. So let me send this 
request. And then let me get everyone. So send,  
53:29 - you see that we have Nelson Mandela. So let's go 
ahead and change Nelson's name to something else.  
53:37 - So go ahead and simply create a new request. So 
go ahead and change this to a put and the body.  
53:50 - So instead of saying, Nelson Mandela, let's simply 
say that this is Alex. And inquiring, right. And  
53:59 - now let's go ahead and simply pass Nelson Mandela 
right here. And basically, we're just changing his  
54:08 - name. So if I go ahead and send, you can see that 
the request did work. And now if I get everyone  
54:17 - from our database, so if I perform a get request, 
and then send, you can see that that didn't work.  
54:26 - And let's go ahead and debug this in a second. 
But for now, let's go ahead and pretty much try  
54:33 - and delete this person. So Nelson Mandela. So 
if I put forward slash and then the actual ID,  
54:40 - and then delete, and then send, we got 200. If we 
get everyone, you see that Nelson is not there,  
54:52 - and it's been deleted. So we had a bag. So if 
I post let's go ahead and Post, Anna Jones. And  
55:02 - basically, we couldn't update the actual name. So 
if I get an A Jones, get the actual ID, and then  
55:12 - perform a put. And this will be Anna Jones Id just 
like that. And then body. And then let's, let's  
55:30 - simply say update and then update, send. Still a 
200. But if we get everyone, you see that still  
55:41 - Annie Jones, so we have a bank. So let's go 
ahead and try and find out why exactly this is  
55:47 - happening. So, let me go back to IntelliJ and then 
close this and then open up the actual data access  
55:57 - service. And now this is the actual method. So 
we are selecting the person mapping. And then so  
56:08 - basically, so right here we have index of person 
to delete. So this would be actual update. So to  
56:17 - update and DB index of person. So basically, 
yes, so this is the error. So so right here,  
56:30 - so you see that we have, so this person right 
here. So this is what we want to update. So right,  
56:36 - so let me rename this to update, right, so the 
index of person to update, you know, it's minus  
56:45 - one. So this will always return zero. So what 
we want is actual p, so P is the actual person,  
56:53 - in fact, just I mean, rename this to person. So 
we want this person that we found. So person,  
57:00 - and then this should return the actual index. And 
then if it's bigger or equal to zero, what we want  
57:08 - is Neal, so because this update doesn't contain 
the actual ID, so we need new person, and then  
57:17 - pass the ID, and then simply update dot and then 
get name. So yeah, I think this makes more sense.  
57:27 - So let's go ahead and restart the server. There 
we go. So now if I open up postman and then pretty  
57:43 - much just get so let's start from scratch. So no 
one in the database. Let's go ahead and post Anna  
57:50 - Jones. And now we have to get let's go ahead and 
get so we get the actual uod of Anna Jones. And  
58:00 - then right here, let's go ahead and perform a put 
to this endpoint and simply pass Anna Jones you  
58:12 - ID or ID. And then in the actual body. Let's also 
change this to Anna, and then Montana, just like  
58:21 - that. And then if we send, so we got 200. And now 
this should work. So go ahead and send. And that.  
58:30 - So you can see that this now works. So you see 
that we pretty much just managed to implement  
58:38 - all of the methods defined in our API. So it is 
nice to have like tests for everything right here.  
58:47 - And basically I wrote tests for this class. So 
go ahead and download the repo down below. And  
58:54 - you can run all the tests and see that this works 
as expected. So I've got unit tests around all of  
59:01 - this. So one last thing that I want to mention 
is that you see inside of this person controller  
59:09 - right here. So this person controller, we 
can have, you know, some annotations that  
59:16 - enforce null ability in our application. So we can 
pretty much just use one, attach some annotations,  
59:25 - and enforce that this object right here is always 
present, and also valid. So go ahead and open up  
59:34 - person model. And then right here, what we can 
do is actually say that this field right here,  
59:42 - so the actual name, this cannot be blank, so act 
and then not and then blank, right? So the reason  
59:51 - why I'm not saying that no, is because if you have 
an empty string, it's not No, but if you have an  
59:58 - empty string, it's actually blank. So basically, 
we don't want that to be blank, right? So then go  
60:04 - back to the actual controller. And now you can say 
that the request body. So this has to be. So add  
60:12 - and then valid, right? And then we can also say 
that this must not be no. So we could also do the  
60:20 - same here. So we can enforce that this is valid, 
and also add and then not know, right? So now if I  
60:29 - pretty much restart the server, so you see exactly 
what we're doing. So basically, we want to fail as  
60:36 - soon as possible instead of having to deal with 
nullability inside of our code. So now let's go  
60:43 - ahead and open up postman. And then let's go 
ahead and pretty much try and post someone  
60:52 - to our database. So right here, so you see that 
we have Anna Jones, but if we send for example,  
60:58 - blank, so send, you'll see that we get an error. 
And basically, this is working as expected,  
61:06 - as expected. So you see that it's a bad request. 
And it's pretty much saying that validation fail  
61:13 - for object person right here. So this is awesome. 
And you can see the actual default message,  
61:19 - which says that the field name must not be blank. 
So now if I go ahead and add the correct payload,  
61:28 - so right here, so let's go ahead and say, john, 
and then Jones. And then send, you can see that  
61:39 - we have a 200 status code. And if I go ahead and 
get everyone in, see that we have john Jones. So  
61:48 - this is it to be honest. So now you should be 
familiar with Spring Boot and writing API's for  
61:57 - your application. So now the cool thing about it 
is that you can have a client API, and then do  
62:03 - all kinds of things depending on your application. 
So one more thing, actually, that I forgot to show  
62:09 - you is dependency injection, right? So let's say 
that we want to have a Postgres implementation,  
62:17 - right, another database or connecting to a 
different database. So how do we change that  
62:23 - without changing pretty much anything apart 
from one line of code. So to do that, what we  
62:30 - need to do is open up the actual do package, and 
then simply create a new class. And right here,  
62:37 - simply call it for example. person listening 
was call it person. And then data, access,  
62:49 - and then service, right, let's simply call it 
that. So this is a real thing now. So okay,  
62:55 - implement and then person, da, oh. And then 
implement all the methods. And then right here,  
63:06 - so when we select everyone, I simply return 
list, dot, and then all of and then new,  
63:17 - and then person, your weird dot random mu ID. And 
then, let's simply say from Postgres dB, right? So  
63:28 - now what we need to do is annotate this with ADD, 
and then repository, and then simply say that this  
63:36 - is a Postgres implementation, right? And then to 
change our implementation, right, all we have to  
63:46 - do is grab this name right here, and then go where 
you inject the actual interface, which is inside  
63:53 - of the service, right? So person service. So now 
instead of fake do simply use Postgres, like that.  
64:01 - Now, if I restart the actual server, and then 
open up postman now if I perform a get, you can  
64:16 - see that we pretty much switched our database, 
we just one line of code. And you can see that  
64:22 - this now is coming from a Postgres database. So 
I'm actually planning to do a video on you know,  
64:30 - connecting to a real Postgres database. But go 
ahead and check my channel because I've got a  
64:36 - video on how to spin up a Postgres container using 
Docker, and also an example with Spring Boot. So  
64:42 - go ahead and check my video on that. But I'm gonna 
make a second part on this video connecting to a  
64:48 - real database. So the last thing that I'm going 
to show you exactly how to spin up everything.  
64:56 - So go ahead and stop your server. Now what I want 
to show you is actually how to spin up the actual  
65:03 - jar. So this is the, the the jar that you can 
deploy to a server and have your application up  
65:10 - and running. So I'm going to simply collapse that. 
And then inside of Maven, so go ahead and open up  
65:18 - this tab right here. So Maven, and you should 
see a target folder. So if you don't see that,  
65:24 - so if I delete that, simply go ahead and open up 
lifecycle, and then simply say, install. There we  
65:39 - go. So this is actually running some tests. And 
there we go, you see that we have a target folder  
65:44 - right here. So inside of the target folder, go 
ahead and simply right click, and then open in  
65:52 - Terminal. So you should see that we have this demo 
001 snapshot dot jar, the jar, and this is what  
66:02 - we can pretty much just run on the actual server, 
right? So when you deploy this to any environment,  
66:09 - so just to show you, so if I open a post, man, 
so if I send a request, you see that the server  
66:17 - is not up and running. So to kick off this jar, 
all you have to do is simply say Java, and right  
66:25 - here. So if I scroll up, you can see that so if 
I scroll up, you'll see that we can say Java,  
66:32 - and then minus jar, and then pass the actual 
jar. So go ahead and simply say Java, minus,  
66:38 - and then jar, and then the actual job. So the job 
name is demo. And then if I press tab, you'll see  
66:47 - that we get auto completion. And then all I have 
to do is press Enter. And you can see that now we  
66:55 - are starting our server. So right here, Tomcat 
started on port 8080. And what I'm going to do  
67:02 - now is simply open up my web browser. And this is 
the actual API that you would use, so localhost,  
67:09 - and then 8080, and an API, and then v one, and 
then person, and then enter. There we go. So  
67:20 - you see that we have a JSON that we can consume. 
And basically, you can distribute this and have  
67:27 - 1000s of clients consume your API. So I hope you 
had fun implementing this application or this API  
67:37 - with Spring Boot. And basically, we achieved 
everything. So we have, you know, a client.  
67:43 - So in our case was postman, we implemented get 
post, delete, and pull requests. Through the  
67:50 - actual controller layer, we had a service layer 
data access layer for a database, you saw how  
67:57 - to implement an in memory database. And then you 
saw how easy it was to switch from databases. And  
68:04 - then we return the actual response to the actual 
client, which is what you see right here. So as  
68:12 - I said, I'm going to do a second part on this 
video, I really want to add value by connecting  
68:18 - to a real Postgres instance, which to be honest, 
is not going to be a lot of work, as you saw,  
68:24 - it's just switching one line of code and then 
implementing the actual connectivity to Postgres.  
68:39 - So now, let's actually go ahead and pretty much 
just use, we're actually connected to a real  
68:49 - database. The database engine that we're going 
to be using for this second part of this crash  
68:55 - course, is this amazing database engine called 
Postgres. So if you want to learn more about  
69:02 - Postgres, you can go ahead and check my website, 
where I've got this PostgreSQL Crash Course,  
69:08 - or actually, it's a course about four hours long, 
and it's absolutely free. So you can see the  
69:14 - roadmap right here, and a cover the essentials 
that you need to know, in order to be familiar  
69:20 - with Postgres. And by far, actually, by far, both 
price is the best database out there. So go ahead  
69:28 - and check it out, go ahead and enroll. And it's 
absolutely free. So if I go back to the diagram,  
69:33 - so you can see that right here, we have this 
data access layer, and instead of talking to a  
69:39 - fake database, we're going to connect to a real 
database, which will be Postgres. So for this  
69:47 - database, what I'm going to be using his Docker, 
so I'm going to use Docker and simply say Postgres  
69:53 - and go ahead and click on this very first link 
and Basically, if you don't know about Postgres  
70:02 - and Docker or Docker, go ahead and check my video. 
So I've got this video right here, where I cover  
70:09 - about where I covered Docker and Postgres in about 
10 minutes. So everything I'm going to teach you,  
70:16 - you can find on this video. So if I close that, 
and basically is really straightforward. So you  
70:24 - can see that they have some description on what 
is Postgres. And basically, this is how you start  
70:31 - an instance, once you have Postgres installed. 
So let me go ahead and simply grab this command  
70:39 - right here. So let me just grab this command, and 
then go ahead and open up your terminal iterm, or  
70:47 - command line. So go ahead and simply open that up. 
And what I'm going to do is simply paste that in.  
70:55 - So actually, I didn't copy that. So let me just 
grab this. And then paste that in, basically what  
71:04 - we're doing here, so just let me explain so so 
let's start from the very first command. So Docker  
71:10 - run, so this is the Docker command. And then I'm 
going to name this container as so let me simply  
71:18 - rename this to, let's say, post grass, and then 
dash, sprink. And then right here, so dash E is  
71:27 - the environment variable. So we need that to set 
the actual password. So let's simply keep things  
71:34 - simple and simply have a very weak password. So 
password, and then minus d, Postgres. And this is  
71:42 - the actual image and go ahead and simply change 
this to Postgres, and then Alpine. So this is  
71:49 - the smallest version. And then what we need to do 
is also expose a port. So we're going to take the  
71:56 - port that is running inside of that Docker 
container. So 5432, and then expose that  
72:02 - to the outside world, as 5432. So basically, what 
we're doing, and so basically, this minus D is in  
72:14 - detached mode. So as soon as I press enter, then 
we can carry on doing all the things. So go ahead  
72:20 - and check my video if you don't quite understand 
this, because I teach you all of this. So go ahead  
72:25 - and simply press Enter. And there we go. So now 
if I go ahead and simply say Docker, and then PS,  
72:32 - you can see that we have this container right 
here. And the name is Postgres spring. So go  
72:39 - ahead and simply say Docker, and then port, and 
then post, an Ingress dash spring. And you can  
72:49 - see that we are exposing the container port to 
the outside world, on localhost, and then 5432.  
72:57 - And by the way, 5432. This is a default port for 
Postgres. So now that we have a database, so we  
73:06 - can log into it, and then perform various things. 
So I want to show you exactly how to SSH into this  
73:13 - box in a second. But for now, you have a container 
running and exposing a port 15432. So now what we  
73:22 - need to do is actually go and open up IntelliJ. 
And let's actually connect to this database. So  
73:28 - what I want to do is first revert this because I 
want to connect to Postgres. And what we need to  
73:35 - do is if I actually stopped that, and then close 
that, so open up the resources. And by the way,  
73:43 - I didn't mention that we have some tests right 
here. So if I open up tests, so you can see that  
73:50 - I even took some time to write some tests to 
make sure that everything works. So let me go  
73:56 - ahead and close this. And then what we're going to 
do is open up this application dot properties. So  
74:03 - application application dot properties, this is 
where you define the connection details to your  
74:11 - database. So go ahead and pretty much just delete 
the application properties. So go ahead and delete  
74:19 - application dot properties. And inside what I want 
really is a file and simply call it application  
74:28 - dot and then yamo wash that could have simply 
renamed that to yamo. But it's fine. So okay,  
74:36 - and not for now, I'm going to commit this in a 
second so you can have everything on a branch.  
74:43 - So now inside of this application dot yamo. This 
is where we define all the connection details to  
74:51 - our database. But before we do that, what we 
need to do is actually add some dependencies  
74:56 - that will allow us to connect To databases have 
the drivers and then also give us the ability to  
75:06 - write SQL commands against our database. So for 
that, what we need to do is open up palm dot XML.  
75:14 - And just let me collapse this for a second. And 
you can see some information about this project,  
75:24 - I'm using Java 11. The version of Spring Boot 
is 2.13 release. And then you can see that we  
75:32 - have some dependencies right here. So this is the 
actual dependency for Spring Boot starter web. So  
75:39 - this gives you the ability to have a Tomcat server 
up and running and write some API's using Spring  
75:45 - Boot MVC, so on and so forth. And then we have 
this one right here. So Spring Boot starter test  
75:52 - for writing tests. And then we have this set for 
j, which is pretty much an assertion library for  
75:59 - writing unit tests. So the dependencies that we 
need are the following. So go ahead and simply add  
76:05 - a new dependency. So I'm going to press Enter. And 
you can see that now we can add a new dependency.  
76:11 - So the first one that I need is from all dot 
spring framework dot boot, so it's me grab that,  
76:19 - and then paste that in. And then the artifact ID 
that we need will be spring, and then dash and  
76:28 - then boot, dash, and then Stata and then dash 
JDBC. So let's actually duplicate this. And then  
76:42 - what we need is org dot and then post and then 
dress keywell. And then the artifact ID is simply  
76:52 - PostgreSQL. So just let me grab that. So that will 
be that. And then what we need is simply have a  
77:01 - scope. And then this will be only at runtime. 
And finally, we need a net of dependency. And  
77:08 - this time, this will be org, dot and then fly way. 
And I'm gonna explain this in a second. And then  
77:19 - dB. And then what we need is simply fly. And then 
way, and then core, wash the dash, and then core,  
77:30 - just like that. So all of these dependencies will 
allow us to connect to a database. And basically,  
77:38 - this is what allows us to write, or actually it 
gives us an awesome API that we can execute some  
77:46 - statements against our database. This is for the 
actual driver, so PostgreSQL. And in this flyway,  
77:54 - db is for database migrations, and you will see 
this in a second. So now let me simply go ahead  
78:00 - and open up the project tab. And then if I open 
up the demo application, and then press play, you  
78:16 - should see that we have an error. And the error 
simply says that failed to configure data source  
78:23 - URL attribute is not specified, and no embedded 
data source could be configured. So basically,  
78:30 - what we need to do now is simply to create a data 
source, and inject the URL, username and password.  
78:38 - And then pretty much allow us to add an image that 
will allow us to connect to our database. So let  
78:46 - me go ahead and simply collapse this. And what we 
need to do first is simply go ahead and create a  
78:52 - new package. So package, and then simply call 
it as data and then source. And then go ahead  
79:04 - and press OK. And inside of this package, let's 
go ahead and simply create a new class, and then  
79:13 - simply say, post, grass, and then data and then 
source. Press OK. And don't ask me again, I will  
79:24 - add all of this later on. So this class will be 
served as a configuration. So add configuration.  
79:31 - And what we're going to do inside of this class 
is simply return a data source, so public,  
79:40 - and then it carry data source. And let's simply 
go ahead and name it as the current data source.  
79:47 - And what we're going to do here is simply return a 
data source of builder. And inside let's simply go  
79:57 - ahead and say dot and then create Then right here, 
simply go ahead and say, and then simply go ahead  
80:03 - and say dot and then type. And the type for this 
will be e curry data source dot and then class,  
80:13 - and then dot and then build. So you can see that 
now we have this data source. And what we need  
80:21 - to do is simply say add and then being. And what 
we need to do also is say configuration and end  
80:28 - our properties. And then what we're going to do 
is simply have app dot and then data, and then  
80:38 - source. So, basically, we are instantiating, this 
Ikari data source as a bean. And then what we're  
80:46 - going to do is create some configuration file 
that will contain the username, URL, password,  
80:52 - so on and so forth. So let's go ahead and simply 
open up the application dot properties. And inside  
80:59 - of application properties, what we need to do 
is simply do the following. So let's go ahead  
81:05 - and have an app and property. And inside of this 
app property, we have data and then source. And  
81:13 - then inside of data source, what we need is JDBC 
dash URL. And this will be JDBC. Colon post grass  
81:25 - qL colon forward slash localhost. And then the 
port will be 5432. And then Ford slash, and then  
81:40 - we need to connect to a database. So we're going 
to create a database in a second. But for now,  
81:46 - let's simply name this as spring and then boo. And 
then dash and then post grass dashDB. long name,  
81:59 - but you get the point. So now we need a username. 
So the default username that ships with Postgres,  
82:06 - it's called post press, we need the password. 
So password. And remember, the password that  
82:12 - we chose was password. And we can also define a 
pool size. So basically, this is the number of  
82:22 - connections that we can have actively, instead of 
having to create a new connection to the database,  
82:30 - every time that we want to execute a query, 
every time we want to execute a query against our  
82:36 - database. So simply go ahead and add 30. And that 
should be it. So you can see that we have App Data  
82:44 - Source. And inside of this data source package, 
we have this Postgres data source. And basically,  
82:52 - it's just grabbing all the dependencies from 
this app, and then data source. So just let me  
83:00 - go ahead and start this because I want you to see 
the errors, and you see exactly what is going on.  
83:04 - So if I start the application. There we go. So now 
it says that cannot find migrations in location,  
83:18 - class, path, db, and then migration. So what 
we need to do is to create a folder called dB,  
83:27 - and then another one called migrations and then 
have our database migrations inside it. So what  
83:35 - flow and this is basically flyweight, right? So 
flyway allows us to manage our database schema  
83:42 - as we evolve. So go ahead and pretty much 
just learn about flyweight, right here. So  
83:48 - flyway. And basically, you can read through the 
documentation, but it is straightforward. So just  
83:57 - follow along and you will understand exactly 
what I'm doing. So if I close Oh, actually, I  
84:03 - just have to keep that open. So if I go ahead and 
simply close this or actually clear that and then  
84:12 - I've got this terminal right here. So I'm going 
to open this terminal. And if I do pwd, you can  
84:19 - see that I'm inside of desktop Spring Boot YouTube 
Crash Course. So what I'm going to do is simply CD  
84:26 - into SRC, and then main and then inside of core 
resources. So inside let me go ahead and make a  
84:36 - folder. So make and then there. And what I need 
is dB, CD into dB, and then make another folder.  
84:47 - So make dir and then migrations. There we go. 
Enter. And basically, you could simply come here  
85:04 - and pretty much just right click, and a new, and 
then directory, and then DB dot migrations. But  
85:11 - I prefer to use terminal. And you should also get 
used to it. So inside of dB migrations, let's go  
85:18 - ahead and create a file. And this file will be as 
follows. So version one, underscore, underscore,  
85:27 - and then person, table dot SQL. So make sure 
that this is as follows. Because otherwise he  
85:37 - won't work. So version one, underscore, underscore 
person, table dot SQL, enter. Now, let me ignore  
85:46 - this extension. So this is where we can write 
some SQL. So let's go ahead and simply create  
85:51 - table person. And then inside of this person, we 
have an ID. So Id, and this is of type EU ID. And  
86:02 - then this will be not and then no, primary, and 
then key. And then we also have, so if I open  
86:10 - up the person class, we have the actual name. So 
if I go back, so this will be name. And then this  
86:20 - is a VAR, char. So let's go ahead and simply 
add 100. Not Know. So this is enough. So now  
86:31 - we have a table called person with the following 
columns ID and Name. So what I need to do now is  
86:39 - actually go ahead and create our database. So if 
I open up the applications, or yamo, so remember,  
86:47 - so right here, we have this database called Spring 
Boot, Postgres dash dB. So you can get a better  
86:54 - name. But you know, I'm just giving this name so 
that you know exactly what we're doing. So what we  
87:00 - need to do now is actually, so if I open up the 
terminal, and this is where I've got, you know,  
87:08 - I've typed some Docker commands. And you saw that 
how we pretty much just launched this container,  
87:14 - which is running and also exposing this port. So 
5432. So this is the port that we are connecting,  
87:21 - right, so localhost 5432. So let's actually go 
ahead and bash into this container and create  
87:30 - a database. So simply go ahead and say Docker. 
And then exec, and then dash, and then it for  
87:39 - interactive. And then what we want is actually, 
if I grab this container ID, and then simply say,  
87:48 - bin, forward slash, and then bash, Enter. And you 
can see that now we are inside of that box, or  
87:56 - actually. And you can see that now we are inside 
of this container right here, which we can simply  
88:04 - now run some commands. So go ahead and simply 
say p SQL. And you can see that we have p SQL  
88:13 - working. And now we can write some p SQL commands. 
Again, if you have missed my course on p SQL,  
88:22 - or actually Postgres, so on my website, so this is 
where I teach everything that you see me typing.  
88:29 - And to be honest, you should learn Postgres. It's 
amazing. And a lot of companies are using it. And  
88:36 - you can also use it for your personal project. So 
let me go ahead and simply go back to my terminal,  
88:42 - and simply go ahead and say p SQL, dash, and then 
capital U, for post grass. So remember, so this is  
88:53 - the actual username, and then enter. And there we 
go. So you can see that now we are inside. So if I  
89:04 - pretty much type backslash, and then l. So if I 
clear the screen, backslash L, you can see that  
89:13 - I do have three databases. So you can see a list 
of databases, we have Postgres template zero and  
89:21 - template one. So let's go ahead and create a new 
database with this main. So let me grab this. And  
89:28 - then if I tried to create So, caps, so create 
table or actually database and then paste the  
89:40 - name and that with semicolon, enter. Oh, okay. So 
we cannot have dash. So let me simply pretty much  
89:54 - rename this to demo dB. Right? So demo And then 
dB, Enter. And you can see that worked backslash  
90:06 - L. And we have demo DB right here. So let's go 
back to IntelliJ. And let's simply rename this  
90:16 - to demo dB. And now all we need to do is actually 
connect to this database. So let me connect  
90:26 - inside. So backslash, C, and then demo dB, Enter. 
And you can see that I'm connected to demo dB. So  
90:35 - if I do backslash, and then D, so to describe what 
we have in here, so backslash, D, we haven't got  
90:43 - anything backslash dt, you can see that there is 
no relations. So these are everything. And then  
90:50 - dt is for tables only. So now what I'm going to 
do is go back to IntelliJ. And let's go ahead and  
91:00 - simply start our application. So let's actually 
go ahead and click on this icon right here,  
91:06 - edit configurations. And let's go ahead and simply 
say that we only want one single single instance  
91:13 - running at a time. So if you press play multiple 
times, it means that you will only get the same  
91:22 - process and not get two processes. And then you 
get like one error saying that the port is already  
91:29 - in use, so we don't wander. So go ahead and simply 
now play. And we have an error, and it says cannot  
91:39 - find migrations in classpath DB migration. And 
thus, because I've misspelled migration, I've  
91:49 - typed migrations instead of migration. So just let 
me rename that. So migration, and then refactor,  
91:56 - there we go, and install the application. And 
there we go. So you can see that everything  
92:05 - started fine. And basically right here, you can 
see that we have a curry pool started and then  
92:13 - completed. And then we have database demo database 
right here. And you can see that we have migrating  
92:24 - schema. So person tables. So basically, that was 
executed. So our command was executed correctly.  
92:30 - And you can see that the migration was applied. 
And now we have the server running on port 8080,  
92:38 - which is awesome. So now, so if I pretty much go 
back to my terminal. So I just want to show you  
92:47 - something first. So remember, previously, we 
type backslash, D, and backslash dt. And that  
92:53 - wasn't working. Well actually, it was working, 
but we didn't have any relations. So if I type  
92:59 - the same command, so backslash d t, you can see 
that now we have two tables. So this one is for  
93:08 - flyway specific, which you shouldn't care at 
this point. But you can see that we have this  
93:14 - table right here called person. And if I go ahead 
and describe a person, so backslash d ln person,  
93:22 - you can see that we have this table called person 
inside of the public schema. And then the ID is  
93:31 - of type you will not know. And then we also have 
name, and then it's a character varying. And then  
93:38 - this is 100. So this is the length. And it's 
also not no, and this is awesome. So if I go  
93:46 - ahead and simply say select, and then start from 
and then person and with semicolon. And you can  
93:55 - see that we have zero rows. So let's go ahead and 
simply insert someone. So because I know I need to  
94:04 - install an extension to be able to to generate the 
Jew IDs and also I cover this on my free course,  
94:13 - I need to install an extension. So what I want to 
do basically is this, so select and then you ID  
94:20 - and then generate and then v4 as a function. And 
you can see that no function matches. So what we  
94:32 - need to do is create extension. And then this will 
be u ID. Dash o s SP. So w ID dash o s SP and now  
94:48 - it's semicolon. And you can see that worked. Now 
if I pretty much select you with generate vision  
94:56 - for and you can see that now we can generate you 
It's so If I go ahead and simply say insert, into,  
95:02 - and then person. And then we have ID, and a name, 
and then values. And then we want to generate a u  
95:18 - ID. So generate, and then v4, and then the actual 
name. So let's simply say that this is Maria,  
95:28 - and then Jones. And then end with parentheses, 
and enter. You can see that Maria Jones does not  
95:42 - exist. And last, because that has to be single 
quotes, and not double quotes. So Marie Jones,  
95:49 - like that, enter, and you can see that worked. 
So let me go ahead and add Tom, and then Smith,  
95:58 - enter. Now if I select star from person, you 
can see that we have two people inside of our  
96:08 - database. And this is awesome. So we've managed to 
connect to our database using Spring Boot. And we  
96:17 - have a database up and running with a table. And 
now what we need to do really is just write some  
96:26 - code to retrieve data from our database using 
Spring Boot. Oh, actually, we're actually using  
96:33 - Java and Spring Boot and their API basically. So 
let me go ahead and collapse this, and inside of  
96:41 - the person data access service. So let's go ahead 
and write some code that will retrieve as everyone  
96:47 - from our database. So what we need to do is to 
use this class right here, so private, final,  
96:56 - and then JDBC template. So what we're going to do 
is add this to constructor, and then auto wire. So  
97:06 - this is dependency injection, we don't have to 
do anything spring, no Spring Boot knows how to  
97:12 - initialize correctly this class for us, so that we 
can write some code against our database. So now,  
97:21 - instead of saying select all people, and then 
return a list, so basically this fake list,  
97:29 - what we're going to do is use JDBC template API. 
So simply go ahead and say JDBC template dot,  
97:37 - and you can see that they have various methods. So 
the one that we want is query. So we want to query  
97:45 - and the query takes two things. So we can pass 
s, so we can pass an SQL statement. And then we  
97:55 - have to pass a row mapper. So basically, the row 
mapper is how we take the values that we retrieve  
98:02 - from our database, and then transform that into a 
Java object. So let me go ahead and simply simply  
98:12 - define a string. So string, and let's go ahead 
and make this final, not needed, but why not.  
98:19 - So SQL equals to select. So basically, the same 
thing that we had, so select name, or actually,  
98:28 - this is ID, name. And then from and then person, 
not the same. So previously, we simply said select  
98:38 - star. So right here, so select star, so select, 
and then Id, name from person. And this is the  
98:50 - same thing. So I prefer to use the actual column 
names instead of the instead of star. So now let's  
98:59 - go ahead and simply pass the SQL query. So SQL, 
and now we have to pass this row mapper. So this  
99:09 - row mapper is a lambda that has access to the 
result set to the result set, as well as the  
99:15 - index. So what we're going to do inside here, so 
let's simply go ahead and say return. And then  
99:25 - we need to return a person object. So person, 
so this is our model, and inside of our person,  
99:32 - we need to pass what we need to pass the uod. 
So they should be new person, just like that.  
99:41 - So inside you can see that we have to pass a u 
ID and also a name. So inside of the result set,  
99:48 - we can get the string so get string, and then you 
can see that we can pass the column label. So I  
99:56 - know the column label is so basically ad. And also 
we can get the actual name. So resolve set dot,  
100:06 - and then get string. And then this will be 
named. So if I put this this on a new line,  
100:12 - and you can see exactly what we're doing. So right 
here, you can see that we have an error. And this  
100:19 - is because this result set Daguerre string 
is a string basically. And what we need is  
100:25 - a unit type. So let's simply go ahead you ID and 
then from string. And then we need that. So that  
100:35 - will work. So you can see that now this works, 
let's end with semicolon. And what I like to do  
100:43 - is actually to extract this way variable. So all 
of that actually. And then this will be ID. And  
100:50 - then this will be name, so you see exactly what's 
happening. And we can remove that. And also that,  
101:00 - and then that and then format everything. So 
now I don't need to return the list of pretty  
101:09 - much just fake people. So this from Postgres 
DB is not named, and we are retrieving from  
101:16 - a database. So you can see that I still have an 
error. And this returns a list of people, right.  
101:25 - So you can see that it's a list of people. So I 
can either say return, and then people whoops,  
101:35 - so people just like that. Or I can simply return 
that in line, so refactor. And there you go. So  
101:45 - you can see that I'm returning that in line, 
which is awesome. So this is it. So if I now  
101:53 - restart the application. So let me go ahead and 
simply say stop, and we run. There we go. It's  
102:04 - up and running. And if I open up Chrome, and 
then remember, so right here, we previously add  
102:13 - an empty list. And this is because he was coming 
from our fake database. So now, if I refresh this,  
102:22 - there we go. So you can see that now, this is 
coming from our database. And this is awesome,  
102:30 - guys. So you can see the power of Spring Boot. 
Basically, you can just write code, you know very  
102:37 - fast, and they give you these tools so that you 
can focus on writing what matters instead of you  
102:43 - having to configure things. So there we go. So let 
me go ahead and simply add someone else into this  
102:50 - table. So let's go ahead and simply, say, Tomcat, 
we're actually not Tomcat. Let's simply say, Anna,  
103:01 - and then Jamil and an editor. So if I refresh 
this, you can see that now we have Anna Jamil.  
103:14 - So there we go. If I collapse this, you can see 
that this is only one implementation of our API,  
103:25 - right? So we have a bunch of other methods. So 
select person by ID, you actually let's go ahead  
103:31 - and implement this one quickly. So you see exactly 
how this is done. So what you want is to pass,  
103:38 - or actually select ID name from person. And then 
here you can see where in an ID equals to question  
103:49 - mark. And then what you want is to take the exact 
same thing here, and then simply return that back  
103:58 - instead of query because query it returns you a 
list, what you want is query for and an object.  
104:05 - And query for object takes the SQL. But we also 
need to pass the arguments. So new object, so this  
104:16 - must be an array. So just like that, and you can 
see that So currently, this is empty, right? But I  
104:26 - need to pass this ID that comes from the client. 
So Id and then this, let's rename this because  
104:34 - it's already in scope. So person, and then ID. And 
let's rename that to person ID as well. Just like  
104:42 - that, and let's actually change this. So this will 
be a person, right? But what we want really is to  
104:53 - return so return optional.of nullable, because 
that can be no Then pass person, just like that.  
105:02 - So basically, it's the same thing. But we have 
this question mark, and then query for object,  
105:10 - we pass the ID right here. So if I put this on a 
new line, so you can see exactly what we're doing.  
105:16 - So in that, that, so we passed the SQL, the ID. 
And basically, if you had more item arguments,  
105:25 - you'd simply pass him right here. So we have the 
ID, and then this is the row mapper, as you saw  
105:31 - before, so right here. And then we simply return 
the optional of nullable of person, because,  
105:37 - you know, we might not find a student with a 
given ID. So if I restart this, and then open  
105:49 - up Chrome. So if I refresh, you can see that this 
still works. But you find out take this ID, and  
105:58 - then pretty much to Ford slash and then Id remove 
the quotes there, Enter. And you can see that now  
106:08 - we only get one person. And this is awesome. So 
there we go. So you can see that we managed to  
106:16 - connect to a database using Docker, Postgres, 
flyway, spring JDBC. And you can see that this  
106:26 - was pretty much, you know, very straightforward. 
And we even managed to use a carry. So I didn't  
106:31 - even explain what you carry was, but you carry is 
the actual recommended data. So if I you should be  
106:38 - using for a Spring Boot, because it's very fast, 
reliable. And yeah, it's just one of the best  
106:45 - ones out there. So there we go, guys, if you have 
any questions on this, and basically, I'm gonna  
106:53 - let you implement the rest of the logic. So insert 
person, the same with delete, and then update. But  
107:03 - basically, it is straightforward using some SQL. 
So go ahead and pretty much just subscribe to my  
107:11 - channel to get more videos like this, if you want 
to learn more about all of this and more. So I've  
107:17 - got a Spring Boot full stack, web development 
course where I teach all of this and a lot  
107:24 - more. And also creating user interface for this 
using react, reacts and hooks. And pretty much,  
107:32 - it's a lot of content packed into one course where 
I'm pretty sure that once you learn that you will  
107:40 - be able to build applications on your own. And 
also apply for jobs because a lot of companies  
107:46 - are looking for a Spring Boot developers or, you 
know, Java developers. But Spring Boot is used  
107:53 - quite a lot in the industry. And once you know 
all of these skills, so dependency injection,  
107:59 - connecting to databases, writing tests, writing 
integration tests, writing user interface for it,  
108:06 - I'm pretty sure that you will be able to get a 
job. Okie dokie. As you saw throughout this crash  
108:14 - course, springboard is amazing. So we really just 
scratched the surface. And the next step for you  
108:22 - is to check out my full stack web development, 
Spring Boot and react. And in that course,  
108:29 - I'm going to teach you everything you need 
to know about Spring Boot. So we're going to  
108:34 - cover essential topics that you need to know as 
a software developer. And the cool thing about  
108:40 - this course, is that whatever you learn, you 
will be deploying it into a real server using  
108:47 - Amazon Elastic Beanstalk. And upon completion, 
the skills acquired in this course, it will help  
108:55 - you apply for jobs because it will help you with 
a lot of great important concepts that a software  
109:01 - engineer should know. Also, you can start your 
own projects, university projects, and pretty  
109:07 - much if you are a developer, you should be aware 
of this awesome framework and how to use it inside  
109:15 - out. This is all for now. Go ahead and check out 
my YouTube channel where I've got more content  
109:22 - similar to this. It was a pleasure teaching 
you and I'll catch you in the next one. See ya