00:00 - hey this is andrew brown your cloud
00:02 - instructor exam pro and i'm bringing you
00:04 - another complete study course and this
00:05 - time it's the kubernetes and cloud
00:08 - native associate made available to you
00:10 - here on freecodecamp so this course is
00:12 - designed to help you pass and achieve
00:14 - cncf issued certification and the way
00:17 - we're going to do that is by going
00:18 - through lecture content doing follow
00:20 - alongs in our own account we've got a
00:22 - full free practice exam so you can
00:23 - simulate the real exam and we've got
00:25 - cheat sheets on the day exam that you
00:27 - can go and print out and cram that last
00:29 - minute knowledge so that you can pass
00:31 - that exam and prove on your resume and
00:33 - linkedin you have that kubernetes
00:35 - knowledge and get that cloud job or that
00:37 - promotion you've been looking for so i'm
00:39 - your instructor andrew brown i was
00:40 - previously the c2 of multiple tech
00:42 - companies 15 years experience with five
00:45 - years specializing cloud i'm a nativist
00:47 - community hero and i've published many
00:48 - many free cloud courses just like this
00:51 - one and if you ever want to be buy me a
00:52 - drink coconut water is what i like so i
00:56 - just want to take a moment to thank you
00:58 - the viewers for making this free course
01:00 - possible because it's you who buy our
01:02 - additional study materials that allows
01:04 - us to produce these large free courses
01:07 - and if you want to support more courses
01:09 - like this one the best way is to sign up
01:12 - on
01:13 - exampro.comforce kcna to get that
01:16 - additional study notes flash cards
01:18 - quizlets downloadable lecture slides
01:20 - downloadable cheat sheets practice exams
01:22 - ask questions get learning support and
01:24 - more and just by signing up for free
01:26 - you're going to get that free practice
01:28 - exam and cheat sheets with no credit
01:30 - card required and no trial limit
01:33 - so
01:34 - if there are updates of this course the
01:35 - best way is to look on the youtube and
01:37 - to see if there has been an update if
01:39 - you click that that's where you're going
01:40 - to see things like corrections additions
01:42 - modifications to make sure you are using
01:45 - the latest version of this course and to
01:47 - keep up to date for upcoming courses the
01:50 - best way is to follow me on twitter
01:52 - andrewbrown and if you do pass the exam
01:55 - or you'd like to know or would like to
01:56 - suggest what course to be produced next
01:59 - you can go tell me that on twitter and
02:01 - it's time to jump into the course
02:04 - [Music]
02:08 - hey this is andrew brown from exam pro
02:10 - and we're asking the most important
02:11 - question first which is what is the
02:13 - kcna's the kca stands for kubernetes and
02:15 - cloud native associate and it's the
02:17 - entry level uh cncf certification so
02:19 - cncf is the organization that is issuing
02:23 - this certification
02:25 - and so this certification is going to
02:26 - teach you the landscape of cloud native
02:28 - technologies a close look at the core
02:30 - kubernetes components a quick look at
02:32 - the vast amount of cncf projects and
02:33 - cloud native tooling a general overview
02:36 - of security deployment monitoring the
02:37 - structure and governance of cncf and the
02:40 - community around cloud native so the
02:42 - course code here is the kcna um and it
02:45 - doesn't have like versioning like other
02:47 - certifications like aws or azure where
02:50 - azure would be something like the az300
02:53 - and then go 301 302 for the next
02:55 - versions um and a bus would have like
02:57 - co1 co2 co3 on the end and so they just
03:00 - don't do that's the only way you know
03:01 - what version you're on is you'd have to
03:03 - go to an obscure github page and see the
03:05 - curriculum version there but we are on
03:07 - version one uh for this so consider this
03:09 - version one kcna um and kubernetes is
03:12 - one of the hottest technologies being
03:14 - adopted in the world it's in the top
03:16 - four there with aws azure then
03:18 - kubernetes and terraform so definitely
03:20 - worth it to add to your journey
03:23 - so uh who is a certification for well
03:26 - considering taking the kcna if you are
03:28 - new to cloud native in kubernetes and
03:30 - need to learn the fundamentals you are
03:31 - an executive management or sales level
03:33 - and need to acquire strategic
03:34 - information about cloud native for
03:36 - adoption or migration you are a senior
03:38 - cloud engineer or solutions architect
03:40 - looking to quickly add kubernetes and
03:41 - cloud native to your skill set and so
03:44 - notice that we have um three asterisks
03:47 - up here and the reason why is that um
03:50 - unlike other fundamental certifications
03:52 - this one feels like it was made by
03:54 - engineers people that want to use
03:55 - kubernetes as opposed to people that
03:58 - are from the business perspective and so
04:00 - it's missing things like uh adoption
04:02 - frameworks uh cost like total cost of
04:04 - ownership shared responsibility model um
04:07 - uh migration paths so
04:10 - for that i you know i kind of fill in
04:11 - the gaps best i can but it's not on the
04:14 - exam and it's kind of a misstep of a
04:16 - fundamental certification in my sense
04:19 - so if you are in the executive
04:20 - management sales level and expecting to
04:22 - have a lot of that stuff you're going to
04:23 - be a bit disappointed to find out it's a
04:26 - lot more code than you'd like but that
04:28 - doesn't mean you shouldn't take it just
04:29 - means that you might not want to sit the
04:31 - exam because it might not be worth it
04:33 - because you'll fail because you're not
04:35 - really trying to become someone who can
04:37 - code in kubernetes as opposed to just
04:39 - understanding it from a managerial
04:40 - perspective but for anyone that is like
04:43 - wants to be an engineer like a
04:45 - kubernetes engineer this is the right
04:46 - course for you
04:48 - so the kcna is a difficult uh exam for
04:53 - entry level and you're going to need
04:54 - both hands-on and broad conceptual
04:57 - knowledge of the kubernetes cloud native
04:59 - projects and i really stress hands-on
05:02 - now this certification is multiple
05:04 - choice so technically you could do
05:05 - without hands-on but to contextualize a
05:08 - lot of the questions or even to go to
05:09 - the next step of certifications you're
05:11 - going to be in bad shape if you don't do
05:13 - hands-on so for technical implementation
05:15 - roles like kubernetes engineer or cloud
05:17 - native engineer
05:18 - this might not be enough to get you that
05:21 - role
05:22 - if you already have prior experience
05:24 - like you work a tech job then yes it is
05:27 - a good addition uh and it can get you a
05:29 - role as a kubernetes engineer but if
05:31 - you're just like from starting from zero
05:33 - then you might need a bit more work or
05:34 - go further down
05:36 - the uh road the roadmap there
05:38 - so when you complete the certification
05:40 - you'll be able to deploy a simple
05:42 - application into a kubernetes cluster
05:44 - understand uh various kubernetes
05:46 - components but not enough to deploy a
05:48 - production ready application so really
05:49 - missing those complex production setups
05:52 - like for deployment security
05:54 - uh like working with a lot of different
05:56 - microservices and things like that
05:58 - so let's take a look at our roadmap here
06:00 - so we have suggested prequels uh
06:02 - prerequisites and kubernetes track
06:04 - now the thing is i never ever ever
06:07 - ever at a fundamental have to recommend
06:09 - suggested prerequisites so this should
06:11 - tell you something about the difficulty
06:12 - of this exam
06:14 - you will really just say i have
06:16 - everything inclusive you can go ahead
06:17 - from
06:18 - day zero and and get into the cloud
06:21 - right but this one uh you're gonna need
06:23 - some linux knowledge you're gonna need
06:24 - some uh
06:25 - linux networking knowledge it networking
06:27 - cloud networking whatever
06:29 - or a associate level cloud certification
06:32 - if you can pass one of these then you
06:34 - probably have the knowledge for the ones
06:36 - above there i'm not saying go sit all of
06:38 - these i'm just making suggestions of one
06:40 - of those categories here
06:43 - and then from there i then i would
06:44 - recommend to proceed the casing a you
06:46 - can do the kcna without doing all this
06:47 - prerequisite stuff you just
06:49 - might be a bit more confused than
06:52 - expected okay
06:54 - and so after that i would generally
06:56 - recommend the ckd because once you are
06:59 - done the the fundamental knowledge of
07:02 - being able to work with clusters
07:03 - usually people want to deploy them and
07:05 - so
07:06 - uh you know there is the
07:08 - kca which i recommend next but that one
07:10 - the kca administrator is more about like
07:13 - managing nodes and self-deployment of
07:16 - clusters where the kc ad feels more
07:18 - practical and it says application
07:20 - developer but it's really not
07:22 - you're not building out apps per se it's
07:24 - more like stuff around them
07:26 - and so since a lot of providers are
07:28 - managed this feels like a better fit
07:31 - for for most people after that you can
07:33 - go with the cks
07:35 - but if you really want to call yourself
07:36 - a kubernetes engineer you're going to
07:38 - have to at least make it to
07:39 - this stage right either one or the other
07:42 - depending on or both depending on what
07:44 - you do
07:45 - but generally like once you're once you
07:47 - go beyond the kcna all these things are
07:49 - pretty much like the kcad
07:52 - seek cks and cka they're all the same
07:55 - kind of difficulty just in different
07:56 - kind of areas and honestly i feel like
07:58 - they should have been like a pro cert
08:00 - you should have just studied them all
08:01 - together
08:02 - um because it's like not that much work
08:04 - to do the extra ones the key difference
08:06 - here is that this here is multiple
08:09 - choice these are all hands-on and so
08:12 - that's why i say that i have to spend
08:14 - extra time with you doing hands-on
08:16 - because i'm preparing you for the next
08:18 - level if you don't do those you're going
08:20 - to really struggle the next step so
08:22 - doing those hands-on is very important
08:23 - how long should you study to pass well
08:26 - um for this beginner i have 50 hours at
08:28 - one end so if you've never done linux
08:30 - networking or cloud you're going to be
08:32 - doing it outside of this course but
08:33 - trying to find to fill that knowledge if
08:35 - you've never written a code or held a
08:37 - technical role it's just going to be a
08:38 - lot of work for the experienced if you
08:40 - have worked with a csp like a bus as
08:42 - your gcp linux and linux networking
08:45 - you're looking at 20 hours um that's
08:47 - still a little bit long normally i would
08:49 - suggest like
08:50 - 14 hours and the course is like the
08:52 - video content is not even
08:54 - um
08:55 - uh you know like 20 hours but the thing
08:58 - is is that you're going to have to spend
08:59 - a lot of time doing hands-on labs and
09:02 - you have to factor in the time that
09:03 - you're going to be doing practice exams
09:05 - so it is of course longer there the
09:07 - average time i would say is 30 hours um
09:09 - so 50
09:10 - lectures in labs 50 practice exams and
09:13 - we're recommending a couple hours a day
09:16 - for three weeks out uh normally like i
09:18 - would say two weeks for a fundamental
09:20 - sometimes even a week like in the old my
09:22 - old clf c01 this uh it was certified
09:25 - club petitioner we would recommend like
09:27 - literally like book it the next week um
09:29 - but this one is really hard so you're
09:31 - going to need a bit more uh time to get
09:34 - there okay
09:35 - what does it take to pass the exam we'll
09:36 - watch the video lectures memorize the
09:38 - information do hands-on lab this one is
09:41 - especially important we call them
09:42 - follow-alongs but um i strongly strongly
09:46 - strongly strongly recommend doing these
09:48 - within your own account and when i say
09:49 - that
09:50 - like we're going to be doing all in aws
09:52 - on cloud nine and uh there are sandboxes
09:55 - out there and they are an option if you
09:56 - do not have money and you do not have a
09:58 - credit card but
09:59 - um
10:00 - if you can please do them in cloud nine
10:03 - and follow along because if you do sand
10:05 - boxes they're abstracting away a lot of
10:08 - things that you that could go wrong and
10:10 - that's the parts that you you need to
10:13 - actually become a kubernetes engineer
10:15 - dealing with those hard bits so you are
10:18 - cheating yourself if you use sandboxes
10:20 - but i understand why people want to use
10:21 - them because they're just
10:22 - they want to kind of have that okay so
10:25 - do paid online practice exams the same
10:27 - with the real exam the great thing is
10:28 - that um
10:30 - if you sign up in exam pro today no
10:31 - credit card require kcna i got a full
10:34 - free practice exam for you extremely
10:36 - generous uh and if you want you can
10:39 - definitely sign up with a credit card to
10:41 - get access to the rest of the practice
10:42 - exams all the rest of the lyric content
10:44 - cheat sheets and more would greatly
10:46 - appreciate it so we can produce more
10:47 - free video content our content outline
10:50 - is out of five domains so each has its
10:52 - own weighting that's going to determine
10:54 - how many questions so we have
10:55 - fundamentals container orchestration
10:58 - container native architecture cloud
11:00 - native observability cloud native
11:02 - application delivery you'll know some
11:03 - say like between
11:05 - x like 27 20 questions it's because if
11:07 - you do the math you end up with like a
11:10 - decimal point for how many questions
11:11 - there are so that means that they could
11:13 - have one
11:14 - additional or one less on certain ones
11:16 - there
11:18 - and most of it's fundamental so
11:20 - fundamentals is strongly focused on
11:22 - kubernetes components
11:25 - so where do you take this example either
11:27 - in person at a test center or online for
11:29 - the convenience of your own home um
11:31 - for these which is through the linux
11:33 - foundation uh i know it's cncf but like
11:36 - cncf is part of the linux foundation and
11:38 - so you'll go to linux foundation to sign
11:40 - up for this and this uses the psi
11:42 - network of test centers and online
11:43 - proctor exam systems so it'll look like
11:46 - linux foundation has their own thing but
11:47 - then you'll end up on psi
11:50 - and if you can please take it in person
11:52 - because
11:54 - online it's so stressful you know like
11:56 - your dog could bark your kid could cough
11:57 - someone could knock on the door
11:59 - um you know the internet could go out
12:02 - and the check-in process is always
12:03 - painful it's not psi it's any of them
12:06 - and uh you know if you want to just be
12:08 - less stressed
12:09 - i would
12:10 - suggest in a person if that is an option
12:12 - for you if it's not then you have to do
12:13 - online
12:14 - um i think psi they're the more strict
12:17 - ones so pearson vue
12:18 - uh i prefer pearson vue
12:21 - but psi like you can't even have
12:23 - anything on the desk so like for me i
12:24 - like to have a
12:26 - box on the desk in the middle of the
12:27 - room to prop up my laptop they won't
12:29 - even let you have that box to prop up it
12:30 - up so
12:31 - just make sure you're really comfortable
12:33 - and you have a table that's a good eye
12:34 - level for that if you don't know what a
12:35 - proctor is it's a supervisor or person
12:37 - who monitors students during an
12:39 - examination
12:40 - so let's take a look here at grading so
12:42 - the passing score would be about 75
12:44 - percent i say about or around because it
12:46 - might use scaled scoring usually the
12:49 - exam takers will point that out that
12:52 - just means that um the system isn't
12:55 - exact and so it's possible to fail with
12:57 - the 75 percent
12:58 - um and since it's on psi i just assume
13:01 - that it's following like what all the
13:02 - other providers are doing so always aim
13:04 - for you know more at least one percent
13:06 - above there but you probably can pass at
13:08 - 75 percent
13:10 - always aim 10 above there are 60
13:12 - questions and as far as i can tell there
13:15 - are no unscored questions unscored
13:17 - questions happen on exams for many
13:19 - reasons uh
13:21 - so like eight of us has like 15. i think
13:23 - it's like 15 or 10 no it's 10 i think
13:25 - it's 10 unscored questions
13:27 - and um you know they're just oddball
13:29 - questions to help
13:30 - detect cheaters to see if they want to
13:33 - introduce new questions things like that
13:35 - they don't do this here with the kcna
13:38 - so every question is scored
13:40 - and there are some eyeball ones in there
13:41 - so that's why i thought there would have
13:43 - been some but there's not you have about
13:44 - 15 questions you can get wrong
13:47 - there is no penalty for wrong questions
13:49 - the format of the questions is multiple
13:51 - choice multiple answer when i take exams
13:53 - i remember the number that i get wrong
13:55 - and actually count in my head like okay
13:57 - i think i got this one wrong i'm okay
13:59 - you know what i mean um the duration you
14:01 - got 1.5 hours so that means 1.5 minutes
14:04 - that's 90 minutes uh your seat time
14:06 - would be 120 minutes see time refers the
14:08 - amount of time you should allocate about
14:10 - the time that you're sitting the exam
14:12 - this includes time to review the
14:13 - instructions show online proctor your
14:15 - workspace read and accept nda complete
14:18 - the exam provide feedback at the end
14:22 - um and
14:23 - really checking online is super super
14:25 - super stressful because every time i've
14:28 - done it something's gone wrong you know
14:29 - what i mean like they don't like my card
14:31 - they make me check the whole room again
14:34 - there's a lighting issue or i'm taking
14:36 - i'm trying to take a photo but it's
14:37 - saying like it's blurry but it's not
14:40 - so you know just make sure you have
14:41 - ample time there and uh even if you do
14:44 - do that like sometimes they start the
14:46 - exam early just because you're ready um
14:48 - so it might not be exactly the time that
14:50 - you take it but um
14:52 - and it's similar to in person as well if
14:53 - you sometimes show up early they'll just
14:54 - say hey you can go
14:56 - um and so this exam is valid for three
14:58 - years or 36 months before
15:00 - recertification i don't think you can
15:02 - sit in an exam uh if you have one active
15:04 - that's usually the the thing there you
15:07 - get two attempts to pass so if you fail
15:09 - you get another try by rescheduling a
15:10 - future date i actually failed my first
15:12 - attempt because when i went in i just i
15:14 - knew i had two attempts and so i i sat
15:16 - it without a single like a study and i
15:18 - got 74
15:20 - which is pretty good to show like how
15:21 - much cloud knowledge carries over um but
15:24 - i you know i would say that uh you know
15:27 - you're paying for two you should take
15:28 - two so
15:29 - uh you know if you want to uh fail it
15:32 - and go sit it that's totally fine
15:33 - because then you kind of get a sense of
15:35 - like okay i need to brush up on some
15:36 - areas that i don't know
15:38 - um but uh you know it's up to you but
15:41 - there you go
15:42 - [Music]
15:46 - all right let's take a look here at the
15:47 - kcna so i just typed in kcna into google
15:50 - and it made our way here and so there's
15:52 - a register for the exam here at the at
15:54 - the current cost at least for me it says
15:56 - 250 and we can see the five domains but
15:59 - that doesn't really tell us a lot so
16:00 - there's a handbook down below if you
16:02 - click that it gives you
16:05 - way too much information on
16:07 - how like taking the exam works so they
16:09 - have a lot of information here to me
16:11 - it's a bit overkill but
16:13 - um if you need to know anything it's
16:15 - it's in this handbook and this is
16:16 - generalized for any of the linux
16:18 - certifications and you're thinking well
16:21 - isn't this the cncf well yeah but
16:23 - the certification is through the linux
16:25 - foundation because cncf is a
16:27 - uh sub-organization of the linux
16:29 - foundation so you can roll this way
16:31 - notice they have a bundle for a course
16:33 - for 50 bucks more i can't really speak
16:35 - to the quality of the course um
16:38 - so i'm not sure
16:39 - it kind of looks like it's pieced
16:40 - together with other content
16:43 - so i mean that's going to be your
16:45 - decision if you want to do that um there
16:46 - are always a way to get kind of a
16:48 - discount 250 dollars is pretty steep
16:51 - um and so if you try to reach out to
16:53 - like maybe like a cncf
16:55 - um community ambassador maybe they'll
16:57 - know where a coupon code is but try not
16:59 - to pay full price because i didn't i got
17:01 - a code somewhere but here you can see
17:03 - the breakdown again for uh the different
17:06 - kinds of categories here we'll just
17:07 - expand it here
17:09 - and another place to look is the
17:10 - curriculum and i wouldn't call these
17:12 - curriculums they call them exam guides
17:14 - curriculums are very detailed but this
17:15 - is what i'm talking about where we see
17:16 - the versioning right and so here they
17:18 - say kcna and they might have some
17:21 - resources here and i'm sure that they
17:23 - will add my resources here soon enough
17:26 - because i just have yet to publish my
17:28 - course but i could see mine being on the
17:30 - top there very soon um
17:33 - but yeah so this is the curriculum here
17:35 - so we'll open enough and give it a
17:37 - moment if we scroll on down here are our
17:40 - categories so not very detailed compared
17:43 - to other other ones but let's just take
17:45 - a look here so under kubernetes
17:46 - fundamentals we have resources
17:48 - architecture api containers scheduling
17:51 - and really this is knowing the
17:53 - components of kubernetes okay there's a
17:55 - lot of different components and we'll go
17:57 - through that
17:58 - then we have container orchestration so
18:01 - this is understanding uh run times what
18:03 - is an orchestration system the basics of
18:06 - security like the four c's of security
18:08 - networking and cluster networking uh
18:10 - very little knowledge we need a little
18:12 - bit knowledge on service match how does
18:14 - storage persistent volumes uh go into
18:16 - play the network cloud native
18:17 - architecture we have uh the fundamentals
18:20 - auto scaling serverless community and
18:22 - governance personas now personas is
18:24 - weird because
18:25 - it doesn't really show up on the exam
18:28 - like there's a page about personas um
18:31 - that talks about all the different kinds
18:32 - of customers that could use it but
18:34 - really the only personas you really see
18:36 - are sres
18:37 - and there might be like one or two
18:39 - questions so if you do see something
18:40 - asking like what kind of roles whatever
18:42 - it's probably going to be sre
18:45 - so that was kind of weird one open
18:46 - standards like all the types of
18:49 - interfaces that can be used telemetry
18:51 - and observability so
18:53 - things like open telemetry prometheus
18:55 - grafana
18:56 - cost management that's another squishy
18:58 - one where uh they don't really have a
19:01 - good definition of cost anywhere maybe
19:03 - it's in that paid course by them but
19:05 - it's definitely nowhere else online so i
19:07 - had to kind of piece that together and
19:08 - they only ask you like one
19:10 - pricing question and it's such a bizarre
19:12 - question that uh you know it's just what
19:15 - it is uh then underneath we have
19:16 - application delivery so like uh git ops
19:19 - ci cd
19:20 - things like that you should just know
19:22 - generally the different types of
19:23 - deployment tools uh for get ops but you
19:26 - don't really have to know how to deploy
19:28 - i mean you technically do but not like
19:30 - with a pro like not with like flux or
19:32 - not with argo nothing super complicated
19:35 - but you do need to know the different
19:36 - types of deployment strategies so
19:38 - hopefully that gives you kind of idea
19:40 - of what you're going to be dealing with
19:42 - here but there you go
19:44 - [Music]
19:49 - hey this is andrew brown and what i want
19:50 - to show you here is just where you can
19:52 - access that praxis exam on the exam pro
19:55 - platform so once you sign up for your
19:57 - account there if you scroll on down this
20:00 - is where the prax exams will be you
20:02 - generally should not attempt your
20:03 - practice exam until you've gone through
20:05 - all the lecture content and done the
20:06 - follow alongs because you know once you
20:08 - see those questions once you're you
20:10 - might prime your mind in order to uh
20:13 - remember them and so uh you know i
20:15 - always say try to take it like a serious
20:17 - attempt now right now the time of i only
20:19 - have one and two in here on the
20:21 - publication of this course we should
20:22 - have all three in and there will be a
20:24 - free one so if you're on the free tier
20:27 - you'll see that shown up at the top
20:29 - there but really what i want to do is
20:30 - just show you what some questions look
20:32 - like so here you can see i have one uh
20:34 - running uh prior so i'll just go there
20:36 - and resume and so i just kind of want to
20:39 - you know click through a few questions
20:40 - and just talk about how these questions
20:42 - are maybe different from other exams and
20:44 - how they're formatted so one thing i
20:46 - noticed for the official exams is the
20:49 - questions are very short at the top they
20:50 - get right to the point um and you may or
20:53 - may not like that but that just means
20:55 - that usually um the choices are a lot
20:58 - more complex and as you can see in this
21:00 - example it is actually asking uh little
21:03 - code things like cube ctl commands and
21:06 - for the exam they absolutely will ask
21:08 - you technical things um even though this
21:11 - is a fundamental course they made it
21:13 - it's written by engineers so they're
21:15 - really testing your knowledge and so you
21:18 - can expect to see those kind of
21:20 - questions there
21:22 - sometimes questions are as simple as
21:23 - choosing the right service or product or
21:26 - tool so here you know it's just a list
21:29 - of things and so you'd have to know uh
21:31 - which thing to choose there as well
21:34 - and then you will see conceptual
21:35 - questions where
21:36 - there's not a lot of these usually
21:38 - everything is tied to something
21:39 - technical uh practical but you'll see
21:42 - conceptual questions like here where
21:44 - they say what architecture automatically
21:46 - optimizes for cost in kubernetes and so
21:50 - for that one i would choose serverless
21:52 - because serverless can scale to zero but
21:54 - that generally gives you an idea that
21:55 - the questions aren't um hard to parse
21:59 - but they can be tricky based on the
22:00 - choices and um
22:02 - there was ones where you know if you
22:05 - knew too much about kubernetes and you
22:06 - were doing this
22:08 - you might know that there is a more
22:09 - right answer but always go with the
22:10 - answer that seems the most obvious even
22:12 - if you know of those technicalities and
22:14 - you will do very well on the exam so
22:17 - hopefully that gives you an idea of what
22:19 - those questions look like again don't
22:20 - tempt these until you go through the
22:22 - whole uh course material first and and
22:25 - practice your flash cards and things
22:27 - like that but uh hopefully that gives
22:28 - you an idea of what to expect so there
22:30 - you go
22:31 - [Music]
22:35 - hey this is andrew brown from exam pro
22:37 - and we are asking the most important
22:39 - questions first which is what is cloud
22:41 - native so cloud native describes an
22:43 - architectural approach that emphasizes
22:45 - application workloads that are portable
22:48 - modular and isolate between different
22:50 - cloud deployment models and cloud
22:52 - service providers so that's my own
22:55 - definition because when i looked up
22:56 - cloud native and as i understood it it
22:59 - was a little bit more complicated than
23:01 - that and the context seemed to change
23:03 - depending on who was using the term so
23:06 - one example is with cloud service
23:07 - providers and so a cloud service
23:09 - provider would be something like aws
23:11 - azure or gcp and when they would use the
23:13 - term cloud native and this is my first
23:15 - introduction to cloud native when i was
23:17 - using aws
23:18 - was it meant everything built on top of
23:20 - the cloud service provider
23:22 - and so what i learned was that this is
23:24 - more
23:25 - uh meaning cloud first so where um you
23:29 - know you could start on premise like in
23:30 - your own data center but if you choose
23:32 - to build all in the cloud provider that
23:34 - is a cloud cloud-first approach and so
23:36 - that's where that term kind of got a bit
23:38 - muddy and so that's why i redefined it
23:40 - up here to say something that you can
23:42 - take you can build and you can move it
23:44 - to anabus azure gcp
23:47 - in theory
23:48 - there's also kind of these like diagrams
23:50 - online that talk about the components
23:52 - that go into cloud native and so the
23:54 - idea here is that they'll say modern
23:56 - design automation micro services
23:59 - containers and backing services so the
24:03 - idea when they say modern design modern
24:04 - design would be using a modern
24:06 - architecture which below is
24:08 - microservices and containers uh or
24:11 - serverless architecture and then
24:13 - automation which is just a component of
24:15 - it and then backing services meaning
24:17 - like okay most of it
24:19 - is going to be probably portable modular
24:21 - isolate but you might leverage
24:23 - backing services like
24:25 - closer providers services or other cloud
24:27 - native services that run anywhere so
24:30 - some describe uh
24:32 - cloud native being four key principles
24:34 - so you can just see there's variations
24:36 - on this micro services containerization
24:38 - continuous delivery and devops so it
24:41 - really depends in the context and so the
24:43 - context of this course cloud native will
24:45 - mean technologies like kubernetes and
24:47 - the cncf projects which we'll talk about
24:50 - this course that are both distributed
24:52 - and agnostic to any cloud service
24:54 - provider and just to really uh be very
24:58 - specific i found this definition by the
25:00 - cloud native computing foundation it was
25:02 - in one of their documents um
25:04 - somewhere so i don't know who wrote it
25:06 - but it is by them and their definition
25:08 - was cloud native technologies empower
25:11 - organizations to build and run scalable
25:13 - applications in modern dynamic
25:15 - environments such as public private and
25:16 - hybrid clouds
25:18 - containers services meshes microservices
25:20 - immutable infrastructure declarative
25:22 - apis
25:24 - for that approach these techniques
25:25 - enable loosely coupled systems that are
25:28 - resilient manageable observable combined
25:30 - with robust automation they allow
25:32 - engineers to make high impact changes
25:35 - frequently and predictably with minimum
25:38 - toll the cloud native foundation seeks
25:40 - to drive adoption of this paradigm by
25:42 - fostering and sustaining an ecosystem of
25:44 - open source vendor neutral projects we
25:47 - democratize the state of the art
25:49 - patterns to make these innovations
25:51 - accessible for everyone and so what i
25:54 - get from that when i read it is that the
25:56 - cncfs approach is that it's democratized
25:59 - right so if you are using a classical
26:01 - provider like database azure gcp you're
26:03 - really
26:04 - buying into that whole system but the
26:06 - idea is that you buy into cloud native
26:08 - you have more uh portability
26:10 - and uh you know there's a bunch of
26:12 - people that are involved to make sure
26:14 - that you aren't uh
26:16 - you know being sucked into a gravity
26:17 - well of a particular managed provider so
26:20 - you know hopefully that gives some
26:21 - context it is again a squishy term but
26:24 - uh you know we have to kind of define it
26:26 - okay
26:26 - [Music]
26:31 - hey this is andrew brown from exam pro
26:33 - and we are looking at cloud native
26:34 - versus cloud service providers because
26:36 - sometimes people get these really mixed
26:38 - up
26:39 - and so i just kind of wanted to spell it
26:40 - out here so a cloud service provider
26:42 - also known as a csp is a collection of
26:45 - cloud services with strong application
26:48 - integration and their synergy between
26:50 - those services they utilize metered
26:53 - billing and they're under a single
26:55 - unified api so examples would be aws
26:59 - gcp
27:00 - azure ibm cloud and there's a few others
27:03 - there and so this is my definition
27:05 - because you know you kind of have to
27:07 - piece it together and just know over the
27:08 - years what it means um but really the
27:11 - important thing to know is a cloud
27:12 - service provider is useful because of
27:14 - those synergies between services so they
27:16 - don't always have
27:18 - the best in class service sometimes they
27:19 - do sometimes they don't but the idea is
27:21 - that by utilizing a collection of them
27:24 - uh and the synergies between them it
27:26 - outweighs anything like a v a single
27:28 - cloud platform with a single cloud
27:30 - service that's trying to have the best
27:32 - one specific service metered billing
27:34 - means like you pay on the hour on the
27:37 - minute on the second single unified api
27:39 - means that it's just very easy to work
27:41 - with all the services pragmatically in
27:43 - the same way
27:44 - okay so on the other side we have cloud
27:47 - native and this is a workload
27:48 - application or system that is designed
27:50 - to run on cloud services and take
27:53 - advantage of cloud offering and when i
27:55 - say cloud services really we're just
27:56 - talking about compute right because
27:59 - that's all you really need is
28:02 - a place to run your virtual machines
28:05 - your containers your kubernetes cluster
28:08 - and then cloud native can integrate with
28:10 - some
28:12 - cloud service provider application or
28:14 - services very common like for databases
28:16 - or their load balancer but you know
28:18 - they're not necessarily taking advantage
28:21 - of the cloud service provider they're
28:22 - taking advantage of cloud offerings like
28:24 - cloud computing and that's a key thing
28:27 - to point out is that cloud native
28:28 - workloads cannot take advantage of all
28:31 - or the full advantages of a cloud
28:33 - service provider because a cloud service
28:36 - provider intentionally has
28:38 - proprietary technology to encourage you
28:40 - to use their managed services that have
28:42 - exclusive integrations
28:44 - with other services and so um you know
28:48 - that's just the nature of it i mean you
28:50 - know if you're a cloud service provider
28:51 - you'd obviously prefer them to use your
28:54 - services over the cloud native solution
28:56 - but both of these exist in the same
28:57 - ecosystem and all cloud service
28:59 - providers um you know offer support for
29:02 - cloud native
29:03 - and so you know hopefully that is clear
29:06 - [Music]
29:10 - so no fundamental uh cloud certification
29:13 - would be complete without a shared
29:15 - responsibility model and for the kcna
29:18 - they don't actually ask you any
29:20 - questions about a shared responsibility
29:21 - model which to me is a bit disappointing
29:24 - but
29:25 - for your own benefit i thought it was
29:26 - very important that we go find one and
29:28 - so the cloud native shared
29:30 - responsibility model is a little bit
29:32 - hard to define because uh you don't have
29:34 - like a large organization defining it
29:36 - and the cncf isn't defining it um and so
29:40 - what i had to do is find a community
29:41 - member's one and then look at and say is
29:43 - this good and i thought yeah it's pretty
29:45 - good and i want to show it to you so
29:47 - this is the
29:49 - shared responsibility model that i found
29:51 - it's made by lachlan
29:53 - white and i did ask them and say hey can
29:56 - i use this model to show off in the
29:57 - course and they're very happy to say yes
29:59 - go for it and so the idea is a shared
30:02 - responsibility model is the
30:04 - responsibility of the customer or the
30:06 - team or of the organization for the
30:08 - types of workloads and so the comparison
30:10 - here is we have traditional it
30:13 - hybrid it and then cloud native it
30:16 - and i know it's really small but if you
30:18 - look down the list here we have
30:20 - applications data runtime middleware os
30:22 - virtualization server storage networking
30:24 - pretty common for shared responsibility
30:26 - models
30:27 - but what's interesting here is who is
30:30 - responsible on the team
30:32 - and there's a big word here that you'll
30:34 - see
30:35 - that says
30:36 - get ops and get ops can be a little bit
30:38 - hard to define i have a
30:40 - very practical definition to get it up
30:42 - so we'll get into the course but i just
30:44 - want to emphasize that when you're
30:46 - working with cloud native there is a
30:48 - larger emphasis on git ops and so you
30:50 - are seeing things like network engineers
30:52 - security engineers solutions architect
30:54 - sres
30:55 - platform engineers data engineers and
30:57 - developers whereas in the traditional
31:00 - sphere used to have like your
31:01 - infrastructure team your your middleware
31:04 - team
31:05 - and then some specialized things so
31:08 - there's not really much to say here
31:09 - other than i just wanted to point out
31:11 - that there's git ops
31:13 - and that it is core to
31:15 - cloud native and so that is really all
31:18 - there is to share here okay
31:20 - [Music]
31:24 - hey this is andrew brown from exam pro
31:26 - and before we can talk about the cncf we
31:29 - need to talk about the lf
31:31 - which stands for the linux foundation so
31:33 - this is a non-profit technology
31:36 - consortism founded in 2000 is a merger
31:39 - between the open source development labs
31:42 - and the free standards group to
31:44 - standardize linux support its growth and
31:46 - promote its commercial adoption and so
31:49 - the linux foundation is supported by a
31:51 - variety of technology companies so
31:53 - there's a lot of big names here and this
31:55 - isn't the full list this is just a
31:58 - handful of them like anabes should be
32:00 - there and all sorts of things but the
32:02 - idea behind the lynx foundation is it's
32:04 - just a non-profit thing to make sure
32:07 - linux uh keeps running right and um that
32:12 - that there is a community behind it that
32:13 - is kind of steering its future growth
32:16 - and so that is the premise of the linux
32:18 - foundation
32:19 - [Music]
32:23 - all right so let's take a look at the
32:25 - cncf also known as the cloud native
32:28 - computing foundation and if you ever get
32:31 - the initialism wrong or can't remember
32:32 - the name that's okay i mess it up all
32:34 - the time but i want to tell you right
32:36 - now that this will be a question on the
32:38 - exam for the kcna if you know what the
32:41 - cncf stands for so take a look here
32:44 - very carefully and it is cloud native
32:47 - computing foundation okay
32:49 - uh
32:50 - very very very easy for me to forget i
32:53 - think when i took the exam even though
32:55 - i've said it a hundred times i forgot
32:56 - what it was
32:57 - so the cncf is a linux foundation
33:00 - project that was founded in 2015 to help
33:03 - advance container technology and project
33:06 - is a funny word because it's not always
33:08 - what you think it means
33:10 - uh but it's used a lot in um like
33:13 - technology stuff and a good example
33:14 - would be like oh wasp where it's called
33:16 - the like the
33:18 - open web
33:19 - security project and then it's an
33:21 - organization but they call it a project
33:23 - so the cncf operates as an independent
33:26 - nonprofit organization from its parent
33:29 - organization which is the linux
33:30 - foundation
33:32 - and it has all this structure and stuff
33:35 - underneath of it so it has
33:37 - board members that meet to decide on
33:40 - things like the budget and marketing
33:44 - um the cnf cncf has its own global tech
33:47 - conferences like cloud native con plus
33:50 - kubecon and you'll see this it's always
33:52 - the same conference we'll talk about
33:53 - that when we get to that uh later in the
33:55 - course
33:56 - the cncf has its own cloud native
33:58 - certifications which is the one you are
34:01 - studying for right now the kcna
34:04 - and the cncf has its own collection of
34:06 - projects so it's funny that it's called
34:08 - a project
34:09 - but it's really an organization but then
34:11 - within it it actually has
34:13 - technical projects and so projects here
34:15 - would be kubernetes which is
34:18 - the key project that we are focused on
34:20 - in this uh certification course
34:23 - prometheus
34:26 - at c or etcd contain container d and a
34:29 - lot more and we will go look at them all
34:32 - okay so that's the cloud native
34:34 - computing foundation
34:36 - [Music]
34:40 - all right so i just wanted to show you
34:42 - where these websites are so we have the
34:43 - linuxfoundation.org and then the cncfio
34:47 - and if you go here you can go to
34:48 - projects and you can see all sorts of
34:51 - different projects if you scroll on down
34:53 - here you can just drop on down to
34:55 - anything like networking and edge and
34:57 - you might see something that you know so
35:00 - there is a lot
35:02 - like
35:03 - a lot of projects um for the linux
35:06 - foundation
35:07 - but uh they also have their own training
35:10 - so you go here and that's where you get
35:12 - like linux foundation certifications for
35:14 - learning linux then if you go over here
35:16 - to the cncf
35:18 - the cloud native computing foundation
35:21 - uh you can learn more about it scroll on
35:23 - down here and look at the cnscf projects
35:25 - and so these we're going to be spending
35:27 - a lot of time here but not right now
35:29 - we'll get to it later okay
35:31 - [Music]
35:36 - hey this is andrew brown from exam pro
35:37 - and we are taking a look at the cloud
35:39 - native landscape so this is an
35:42 - interactive map developed by the cncf to
35:44 - showcase all the available cloud native
35:46 - technologies and to help identify the
35:49 - category to which they serve so we just
35:51 - got to go to landscape.cncfio
35:55 - and you can see the projects here and
35:57 - there's a bunch of rich filters but just
35:59 - to give you kind of a preview of all the
36:00 - categories i extracted them out for you
36:02 - we got app definition and development
36:05 - orchestration and management
36:07 - runtime provisioning
36:10 - there's special ones like uh
36:13 - certified service providers or training
36:15 - partners maybe one day i'll be a
36:17 - training partner who knows um
36:19 - observability and analysis and then
36:21 - there's these sub landscapes so we got
36:24 - members serverless and the cd foundation
36:27 - the landscape so not all of these are
36:29 - tech projects per se they could be like
36:31 - things that um are
36:33 - professional services but we will take a
36:36 - look at it and see you know what the
36:38 - landscape looks like okay
36:40 - [Music]
36:44 - all right so we're back on the
36:46 - cloud native computing foundation
36:48 - website and if you go to projects here
36:50 - um
36:51 - it should be projects there will be a
36:52 - thing that says cloud native landscape
36:55 - and that will open up this interactive
36:57 - landscape where we have all these uh fun
37:00 - little boxes and these are all different
37:02 - kinds of cloud native technologies so
37:05 - here you can see kubernetes it's right
37:06 - here i can click to it i can get a rich
37:09 - information about this project
37:12 - we can go to card mode here
37:16 - and so this is a little bit easier to
37:17 - consume
37:19 - go back to landscapes here
37:21 - and we can even filter it based on
37:23 - category these filters should be working
37:25 - i guess we have to choose based on the
37:26 - projects we'll say cncf projects so
37:28 - these are projects by the cncf right
37:31 - and so you kind of get the idea there
37:33 - it's nothing super complicated but there
37:35 - are um some uh
37:38 - landscapes within landscapes like this
37:39 - serverless landscape so you go over here
37:41 - and that's one this apparently is a
37:43 - landscape the members people that are
37:45 - participating or um
37:47 - providing sponsorship so you know we
37:50 - didn't show aws as a logo
37:53 - um
37:54 - in the linux foundation but you can see
37:56 - these are all the people that are
37:57 - putting money into this oh and is
37:59 - utilizing cloud native technology so
38:00 - there's a lot
38:02 - of people
38:03 - here
38:04 - all right so you know hopefully that
38:05 - gives you an idea there's also this
38:07 - guide up here if i just click guide
38:10 - and we'll give it a moment to load and
38:12 - so there is some kind of prescriptive
38:14 - stuff here that talks about like
38:16 - buzzword this is so bizarre they say
38:18 - buzzwords infrastructure is a code
38:20 - declarative configurations those aren't
38:22 - buzzwords
38:24 - so whoever wrote that i don't know but i
38:26 - mean i guess they kind of define things
38:28 - like container registry security
38:30 - compliance
38:31 - key management these are like um
38:34 - bare-bones stuff around these categories
38:36 - to kind of help you understand based
38:38 - concepts but i'm not really worried
38:40 - about going through that with you i
38:42 - don't think that's necessary but i just
38:44 - wanted to show you the interactive
38:45 - landscape
38:46 - [Music]
38:51 - hey this is andrew brown from exam pro
38:52 - and we are taking a look at the cloud
38:54 - native trail map so the trail map is a
38:56 - recommended path to adopting cloud
38:58 - native architecture and so it's pretty
39:00 - much a glorified pdf and so the idea is
39:03 - that they set out a path of saying okay
39:05 - the first thing you're going to do is
39:07 - you are going to take your application
39:08 - and you are going to containerize it and
39:10 - then once it's containerized then you
39:12 - can add ci cd to automate that and then
39:15 - now you have a containerized application
39:17 - um you'll want to be able to orchestrate
39:20 - it and deploy it to something like
39:21 - kubernetes and then you'll want
39:23 - observability analysis analysis and get
39:25 - data and then you'll want to uh put
39:27 - something rich on top like a service
39:30 - mesh uh because you know if you want to
39:32 - build up microservices that will be
39:34 - useful you'll care about uh security
39:36 - making sure things are secure then
39:38 - you'll need databases storage etc so the
39:41 - idea is they just have this big old list
39:43 - here and then they have like these abcs
39:45 - along the side so if you look here you
39:47 - can get my pen out here just says help
39:49 - along the way so training certification
39:51 - which is me by the way
39:54 - consulting help or joining the cncf as
39:56 - an end user community and i just want to
39:59 - point out that the path order will vary
40:02 - based on your use case they're just
40:03 - trying to give you something so that
40:05 - when you go to your team to your
40:07 - stakeholders
40:08 - to the executive level you say look we
40:10 - have a road map we have a plan but um
40:13 - you know the idea here is that you just
40:15 - do what you need to do because a lot of
40:18 - these later ones are just going to be in
40:19 - the order that you need them right it's
40:21 - not necessarily a strict
40:23 - guide okay
40:25 - [Music]
40:29 - all right so let's go see where we can
40:31 - find that trail map so i'm on the cncf
40:33 - website i go to projects then you go to
40:35 - cloud native trail map and that will
40:37 - bring up a github repository and you can
40:40 - scroll on down until you see it and
40:42 - there it is so you can pretty much you
40:44 - know click into it probably and expand
40:46 - it here i'm just waiting for it to load
40:49 - it's a big old png
40:51 - and it's way too big but you know the
40:53 - idea here is that you can read it and uh
40:56 - it will have suggestions around that
40:58 - stuff and so if you want to use more
40:59 - than what's just listed here that's
41:01 - where you go back to the landscape and
41:03 - you'd filter based on
41:05 - those categories so
41:06 - nothing super fancy here
41:09 - and by the way
41:10 - if you look in the bottom left corner
41:14 - okay this is where i got my cloud native
41:16 - definition
41:17 - when i was talking about the cncf
41:19 - earlier in the course it was from this
41:20 - document there you go
41:22 - [Music]
41:27 - all right so let's take a look at
41:28 - virtual machines also known as vms
41:31 - compared to containers because the idea
41:34 - behind kubernetes and cloud native stuff
41:37 - is that
41:38 - there are virtual machines involved but
41:40 - you're generally working with containers
41:42 - not virtual machines
41:44 - so the idea is that we'll have a virtual
41:46 - machine and the example says ec2
41:48 - instance that is just amazon's name for
41:50 - virtual machines
41:52 - so just think virtual machine there and
41:54 - so a virtual machine will have a host
41:56 - operating system
41:58 - installed on it could be windows
42:01 - could be linux and then on top of that
42:03 - it's going to have a hypervisor and that
42:05 - hypervisor
42:06 - is what allows you to run a virtual
42:09 - machine on a real physical machine
42:12 - and so the virtual machine
42:14 - has its own guest operating system which
42:17 - is here and that is ubuntu as an example
42:20 - and that's where you can install
42:21 - libraries packages binaries then from
42:24 - there you'd have your workload like
42:26 - let's say you have a django app you have
42:28 - your database you have your queuing
42:31 - uh and so the thing with vms uh
42:34 - is that they're great because they allow
42:36 - you to run
42:37 - multiple workloads on a single machine
42:40 - so you are best utilizing uh that
42:42 - physical machine to the best of its
42:44 - ability
42:46 - but the problem with virtual machines is
42:48 - that they're still going to be wasted
42:49 - space
42:50 - because you have to
42:52 - um
42:53 - you know provision a virtual machine to
42:55 - be a particular size and so that's where
42:59 - you're always going to be over
43:00 - provisioned and it wouldn't be really
43:02 - nice if you know this part if we're only
43:05 - just paying for this much and anything
43:07 - that was not being utilized would not
43:09 - cost us anything or could be used like
43:12 - something to be slotted in there and so
43:14 - that's where um containers come into
43:17 - play so containers are very similar uh
43:20 - initially so you have they run on a
43:21 - virtual machine it has a host operating
43:24 - system like linux or windows and then it
43:26 - has
43:28 - what we call
43:29 - a container runtime now i have docker
43:31 - daemon because docker uh is a very
43:33 - popular uh container runtime um
43:37 - so it could be like container d now i
43:38 - suppose but the idea is you have a
43:40 - container run time and so each container
43:44 - would have its own uh guest operating
43:46 - system that would run on and then in
43:49 - that
43:50 - container would be it the workload so
43:53 - the django app with its own libraries
43:54 - and stuff and then each container is
43:56 - extremely isolated and so the advantage
43:59 - here
44:00 - about having these like isolate
44:02 - workloads is that you know you are best
44:05 - utilizing the space on the physical
44:07 - machine
44:08 - and the other thing is is that you get
44:10 - isolation so when you're looking at this
44:11 - virtual machine over here if the django
44:14 - app does something to consume more
44:15 - resources
44:17 - it could take away from mongodb or
44:19 - rabbitmq where these ones you can just
44:21 - say okay you're only allowed to use x
44:23 - amount of space and so conceptually
44:26 - um instead of thinking of this
44:28 - additional space as wasted it's
44:30 - available because if you were to use
44:32 - something like
44:33 - amazon ecs elastic container service
44:36 - that space would be able to be used by
44:38 - another customer right where when you
44:41 - launch a virtual machine you're always
44:43 - over provisioning so virtual machines do
44:45 - not make the best use of space apps are
44:48 - not isolated which could cause config
44:50 - conflicts security problems resource
44:52 - hogging containers allow you to run
44:54 - multiple apps which are virtually
44:56 - isolated from each other
44:57 - launch new containers configure os
44:59 - dependencies per container there you go
45:02 - oh and by the way just think container
45:03 - run time here so i just kind of patched
45:05 - that graphic there for you
45:07 - [Music]
45:11 - all right let's talk about micro service
45:13 - architecture and to understand that we
45:15 - need to compare it against
45:17 - monolithic architecture so monolithic
45:19 - architecture is one app which is
45:21 - responsible for everything and the
45:23 - functionality is tightly coupled so
45:25 - imagine you have a repository that
45:27 - contains everything uh the the database
45:30 - caching load balancing the marketing
45:32 - website the front end stuff the api the
45:33 - orm
45:35 - background jobs everything and generally
45:37 - monoliths are installed on virtual
45:39 - machines they don't utilize containers
45:42 - and the issue here is that when you have
45:45 - so much stuff running on a single
45:48 - machine
45:49 - what happens
45:51 - when uh your load bouncer runs into a
45:53 - problem it's not like you can just
45:55 - replace it uh and so this is where
45:57 - microservices come into play so the idea
46:00 - is you have multiple apps which are each
46:02 - responsible for one thing and the
46:04 - functionality is isolate and stateless
46:07 - and so here
46:09 - the idea is that we are using
46:11 - the cloud service provider load balancer
46:12 - we're using the cloud service provider
46:14 - caching the cloud service provider
46:16 - database the queuing
46:18 - for cloud native you might be spinning
46:20 - these up in your cluster so you might
46:21 - not be using cloud service provider
46:25 - services
46:27 - as these isolate apps but they would be
46:29 - an isolate on your cluster and so the
46:31 - idea is that you can easily remove or
46:34 - add any of these components
46:36 - and manage them and so that's the
46:39 - key part about microservices now the
46:42 - trade-off here is that when you have
46:43 - microservices
46:45 - you end up with a lot more uh effort
46:48 - between communicating between all these
46:50 - different little apps whereas in a
46:52 - monolith
46:53 - they're all the same place and so that
46:55 - is one of the key advantages but that's
46:57 - just something we have to overcome when
46:58 - we are using microservice architecture
47:01 - so there you go
47:02 - [Music]
47:07 - hey this is andrew brown from exam pro
47:09 - and we are taking a look at kubernetes
47:10 - this is the reason why we're here for
47:12 - this technology so it is an open source
47:14 - container orchestration system for
47:16 - automating deployment scaling and
47:18 - management of containers originally
47:20 - developed by google and now maintained
47:22 - by the cloud native computing foundation
47:24 - the cncf as a cncf project and we are
47:27 - going to touch on google cloud i'm going
47:29 - to show you how to deploy
47:31 - uh your cluster there and you're going
47:33 - to find that google cloud is actually
47:34 - the easiest of out of all the managed
47:36 - providers because i use them all in this
47:38 - course
47:40 - kubernetes is commonly called k8s or k8s
47:43 - on the 8 represents the
47:45 - letters between the k and the s
47:47 - generally if you see k8s you can say k8s
47:50 - or kubernetes the advantage of
47:52 - kubernetes over docker because docker is
47:54 - what people always think when they think
47:55 - of containers is ability to run
47:57 - container apps distributed across
47:59 - multiple virtual machines or as we'll
48:02 - call them in the course nodes now i have
48:05 - a double asterisk there and that's just
48:06 - to remind me to tell you that uh this is
48:09 - a gross gross gross growth
48:10 - simplification docker is not as simple
48:13 - as uh like an apples to or it's like an
48:16 - apples to oranges comparison docker is a
48:18 - suite of things it's a run time it can
48:20 - have docker swarm which is an
48:21 - orchestration tool so technically a
48:24 - better comparison between kubernetes and
48:26 - docker swarm but i'm just trying to keep
48:27 - it simple here for you all right
48:30 - uh a unique
48:31 - component of kubernetes art pods and a
48:34 - pod is a group of one or more containers
48:37 - where shared storage network resources
48:39 - and other shared
48:41 - settings so the idea here i'm just
48:43 - getting my pen out here is we have a
48:45 - node which is a virtual machine and
48:46 - another one here and you got pods
48:48 - running across them
48:51 - now
48:51 - and pods contain containers in them
48:53 - that's where the containers are now
48:56 - as we look at pods throughout this
48:58 - course you're going to find out that
49:00 - basically
49:01 - most components that we run kubernetes
49:03 - are pods so that's why pods are so uh
49:07 - front and center because basically
49:08 - everything is a pod kubernetes is ideal
49:11 - for micro service architecture
49:13 - where a company has tens to hundreds of
49:16 - services they need to manage
49:19 - and so a service
49:21 - um would be something like a
49:24 - containerized application and the thing
49:27 - is is that when you have a containerized
49:29 - application you're very likely going to
49:31 - be running more than one of them all
49:33 - right even like redundant ones so here
49:35 - we have pods and a pod would run a
49:38 - specific application so let's say it's a
49:40 - ruby on rails application
49:43 - and i mean you could count this all as
49:44 - one service or you could count each of
49:46 - these as redundant services and so it's
49:48 - very quick uh or easy to get into the
49:51 - tens so kubernetes can be used uh quite
49:54 - early on but it's going to be really
49:56 - dependent on your use case
49:59 - [Music]
50:03 - hey this is andrew brown from exam pro
50:05 - and we are looking at the kubernetes
50:07 - component overview so what i'm going to
50:09 - do is give you a top
50:11 - simplification on a lot but not all of
50:15 - them but a lot of the kubernetes
50:16 - components because there's just too many
50:18 - it'd be
50:19 - too much to go through all of them but
50:21 - these are all the ones that we are going
50:23 - to be spending a lot of time with and
50:26 - you definitely will need to know them
50:28 - all and you will know them all because
50:30 - we deep dive on a lot of these and
50:32 - you'll get to see them again and again
50:34 - and again in the course so at the top of
50:36 - our list is the cluster and this is a
50:39 - logical grouping of all the components
50:42 - within a cluster so mostly everything
50:45 - that follows after this
50:46 - is generally inside of a cluster there
50:49 - are some exceptions uh the next is a
50:52 - namespace so this is a named logical
50:54 - grouping of kubernetes components within
50:55 - a cluster and it's used to isolate
50:58 - different workloads on the same cluster
51:00 - i like to think of it as a slice of pie
51:03 - so when you look at the icon and i made
51:05 - all these icons by the way because i do
51:06 - not like the ones
51:08 - that are provided right now in the
51:10 - community so i just made my own but i
51:12 - made it look like a slice coming out of
51:14 - that cluster so you can remember what
51:16 - that is
51:17 - then you have nodes so this is a virtual
51:19 - machine or it could be a serverless
51:22 - container because some providers like
51:24 - google and aws lets you run it on their
51:27 - service container platform but either
51:29 - way it's just the underlying compute the
51:31 - underlying server and there are two
51:34 - types of nodes we have control plane and
51:36 - worker nodes so worker nodes is where
51:38 - your application or workloads run and
51:40 - the control plane node manages worker
51:43 - nodes so it does a lot of stuff like
51:44 - that
51:46 - then you have pods and pods are the
51:48 - smallest unit in k-8s it's an
51:50 - abstraction over containers it generally
51:53 - defines an application workload but
51:54 - basically
51:56 - lots of these components are just pods
51:58 - and we'll see that again and again when
52:00 - we list out pods because i list them all
52:01 - the time to show you under cube ctl
52:04 - namespace
52:06 - what is running they're always pods
52:08 - so the next is service so a service is
52:11 - something that we use with a pod to give
52:13 - it a static ip address or a dns name
52:17 - for a set of pods so the idea here is
52:20 - that if a pod dies because pods get
52:23 - dynamic ips but we want them to have
52:25 - static ips and so that's the purpose of
52:27 - a service but the service is also
52:29 - utilized as a load balancer
52:32 - and i'm going to point out that them
52:34 - calling this a service is really
52:36 - confusing because a lot of times a
52:38 - service when we're talking about
52:40 - containers means a
52:42 - workload or application that is
52:44 - continuously running right so if you've
52:46 - ever used aws uh
52:48 - ecs uh you have the option to run a task
52:51 - or a service which are just containers
52:53 - and based on how long they run but for
52:55 - whatever reason that's what they wanted
52:56 - to name it
52:58 - the cncf decided to name it or
53:00 - kubernetes project named it i don't
53:02 - think it's a great name but that's what
53:03 - it is ingress is also not a great name
53:05 - but that's a name they gave it but
53:07 - ingress is used to translate https rules
53:11 - to point to services
53:13 - but what we'll really see is that it's
53:15 - commonly used and this is the hardest
53:17 - component that we are going to learn
53:19 - throughout this course but it's used for
53:21 - getting a load balancer like an external
53:24 - load bouncer on a bus gcp azure to a
53:27 - road traffic
53:28 - to our
53:30 - pods okay
53:32 - then you have the api server the api
53:34 - server allows users to interact with
53:36 - kubernetes components using the cube ctl
53:39 - or by sending http or s requests
53:42 - probably put an s on there because
53:44 - probably everything
53:45 - uh is encrypted in translate transit i
53:48 - really doubt that they would have it so
53:49 - that it's just http
53:51 - and i like to think of the api server
53:54 - as the backbone of communication for
53:56 - kubernetes and you will see that
53:59 - uh in a future diagram where it looks a
54:02 - little bit like uh like um
54:04 - like the backbone okay
54:05 - uh then there's cubelet so cubelet is an
54:08 - agent installed on the nodes cubelet
54:10 - allows users to interact with a node via
54:12 - the api server and cube ctl and again
54:15 - that is a simplification it actually
54:16 - does more than that but we will dig
54:18 - deeper into that we have cubectl it's a
54:21 - command line interface that allows users
54:24 - to interact with the cluster and
54:26 - components via the api server so the ctl
54:29 - stands for
54:30 - i think controller and ctail is very
54:33 - very common
54:34 - to put after a name for some kind of
54:36 - tool that's used for controlling things
54:38 - via cli
54:40 - and we spend so much time
54:43 - tons and tons of time
54:45 - with the cube ctl so you will know
54:47 - cubectl inside and out by the end of
54:49 - this course
54:50 - you have cloud controller manager this
54:52 - allows you to link a csp like aws azure
54:55 - gcp to leverage cloud services
54:57 - i
54:58 - never had to provision one in throughout
55:00 - this course i never even noticed one i
55:02 - think like when you launch a managed
55:04 - service that's already there for you and
55:06 - it replaces i believe the controller
55:08 - manager
55:10 - but i'm just saying it's there but we
55:11 - don't really ever have to think about it
55:14 - so we have the controller manager and
55:16 - this is a control loop that watches the
55:18 - state of the cluster and will change the
55:20 - current state back to the desired state
55:22 - so it's basically state management but
55:24 - it's also
55:25 - you could think of it as the brain
55:27 - of kubernetes because it's doing all the
55:30 - controlling
55:32 - we have a scheduler so it determines
55:34 - where to place pods on nodes and places
55:37 - them in a scheduling queue so that's why
55:39 - we have this little crane here because
55:41 - it's picking them up and putting them
55:42 - where they need to be
55:44 - you have cube proxy so an application on
55:46 - worker nodes that provides routing and
55:49 - filtering rules for ingress or incoming
55:51 - traffic uh to pods
55:54 - you have a network policy these act as a
55:55 - virtual firewall
55:58 - it says as but at
56:00 - sorry at the namespace level or the pod
56:02 - level so it just
56:04 - um
56:05 - puts restrictions around how pods or
56:07 - namespaces stuff in namespaces can
56:09 - communicate with each other because by
56:11 - default everything just can talk to
56:14 - everything within a cluster
56:16 - you have config maps so this allows you
56:18 - to decouple environments a specific
56:20 - configuration
56:21 - from your container images so that your
56:23 - applications are easily portable it's
56:25 - used to store non-confidential data in a
56:28 - key value pair so this is just
56:31 - application uh configuration uh details
56:34 - okay
56:36 - then you have i'm not sure what's not
56:38 - showing up there we go then you have a
56:40 - secret so this is a small amount of
56:42 - sensitive data such as a password a
56:43 - token or key it's basically config map
56:46 - with the option to encrypt it
56:50 - then you have volumes so volumes
56:53 - are basically
56:55 - well there's some variations here but
56:57 - they're basically mounting storage so
56:59 - locally on a node
57:00 - or remote to cloud storage then you have
57:03 - stateful sets we do not do stateful sets
57:06 - in this course because they are just too
57:08 - hard to do but we definitely talk about
57:10 - them in great detail so these provide
57:12 - guarantees about the ordering and
57:14 - uniqueness of
57:16 - the pods so think of databases where you
57:18 - have to determine reads and writes in
57:20 - order or limit the amount of containers
57:23 - staple sets are hard when you can host
57:26 - use a database externally from the
57:28 - kubernetes cluster so like if you have a
57:30 - relational database put it on rds right
57:32 - or put it on cloud google cloud spanner
57:35 - but say the sample sets just basically
57:37 - give you a guarantee
57:38 - that you're going to send traffic to a
57:40 - very particular pod
57:42 - you have replica sets so maintain a
57:44 - stable set of replica pods running at a
57:47 - given time it can provide a guarantee of
57:49 - availability
57:51 - so this is just saying like take a pod
57:53 - and run copies of it so that we have
57:55 - redundancy there
57:57 - and we generally do do not
57:59 - launch replica sets directly we do them
58:01 - through a deployment and this is also
58:04 - how paws are deployed so deployments
58:06 - deploy a replica set and the replica set
58:08 - deploys pods so a deployment is a
58:10 - blueprint of a pod so think like an ec2
58:13 - launch template or something
58:15 - that just templates up
58:17 - what should be launched
58:24 - [Music]
58:29 - hey this is andrew brown from exam pro
58:30 - and we are talking about manifest files
58:32 - in kubernetes so when i was studying for
58:36 - the kcna and i sat it i was just seeing
58:39 - uh conflicting terms about what they
58:40 - call their configuration files because i
58:43 - couldn't understand if there were
58:44 - variants if they meant different things
58:46 - but then i kind of settled on the
58:48 - knowledge that they're actually all
58:50 - manifest files and that's why
58:52 - this slide is here for you or slides i
58:54 - should say so let's describe what a
58:57 - manifest is using
58:59 - non-technical terms so a manifest file
59:02 - is a document that is commonly used for
59:04 - customs so like going over the border
59:06 - from canada us to list the contents of
59:08 - cargo or passengers it's an itemized
59:11 - list of things
59:13 - so what is that in the context of
59:14 - kubernetes well a manifest file is a
59:17 - generalized name for any kubernetes
59:19 - configuration file that defines the
59:22 - configuration of various kubernetes
59:24 - components and the name will change
59:27 - sometimes they'll call it a pod spec
59:29 - file sometimes they'll call it a
59:30 - kubernetes configuration file but
59:32 - they're all manifest files right if
59:34 - you're listing these this is yaml stuff
59:37 - in a uh uh with kubernetes components
59:39 - they're all manifest files and these are
59:42 - all masked
59:43 - files with specific purposes like i was
59:44 - just saying deployment file
59:46 - pod spec file network policy file and
59:49 - manifest files can be written either in
59:51 - yaml or json now i've never seen
59:54 - a json manifest file but taking my
59:58 - terraform knowledge i bet the reason why
60:00 - there's json is if you are pragmatically
60:03 - creating them the same thing with aws
60:05 - with cloud formation templates whether
60:07 - yaml and json um you probably would
60:09 - never write
60:11 - a json file by hand but it can take it
60:14 - and probably it's being generated by
60:16 - another app so here's an example of it
60:19 - in yaml and here's an example of it in
60:21 - json
60:22 - so a manifest file can contain multiple
60:26 - kubernetes components which makes sense
60:28 - because we said manifest is an itemized
60:30 - list of things so it can uh definitions
60:33 - configuration so
60:35 - here is an example of one and in yaml
60:37 - they have the syntax which is the three
60:39 - hyphens which allows you to define uh
60:42 - basically an array so like we have two
60:44 - different things here and once we have
60:46 - all of our um
60:48 - oh how what whichever amount of um
60:51 - kubernetes components we want to define
60:53 - in a manifest file we're going to be
60:55 - using cube ctl and writing apply and
60:58 - this is something that we use a lot in
61:00 - this course we're doing cube ctl apply
61:02 - hyphen f etc you will absolutely know
61:04 - this by the end of the course inside and
61:06 - out uh and resource configuration files
61:08 - is sometimes used to describe multiple
61:10 - resources
61:12 - in a manifest file which is confusing
61:14 - because manifest by definition
61:17 - means
61:18 - an itemized list multiple things
61:21 - but that's just the terminology
61:22 - throughout the documents throughout the
61:24 - ecosystem there i just wanted to clear
61:26 - that up for you okay
61:27 - [Music]
61:32 - hey this is andrew brown from exam pro
61:34 - and we are taking a look at control
61:36 - plane nodes versus worker nodes so
61:38 - control plane nodes were formerly known
61:40 - as masternode and the only reason i'm
61:42 - mentioning this is because
61:45 - a lot of documentation out there like
61:46 - tutorials and stuff are completely out
61:48 - of date and they're not using the new
61:50 - inclusive term so i'm sorry for
61:52 - mentioning uh this term here but i just
61:54 - have to because you need to know
61:56 - what it is when you are looking up
61:58 - information out there even the
61:59 - kubernetes.i o website still has some
62:01 - outdated stuff mostly in the graphics
62:04 - not so much uh in the text so they seem
62:07 - to fix that so you know a few years out
62:08 - and i think we'll all be moved over to
62:10 - the new terminology there and then you
62:12 - have worker nodes
62:14 - so control plane node manages processes
62:16 - like scheduling restarting nodes and
62:18 - then the worker node does the work as
62:20 - the name implies it runs your apps it
62:22 - runs your jobs and it's running pods and
62:25 - containers they're both running pods and
62:26 - containers but when we think of pods and
62:28 - containers we're thinking about more of
62:30 - the worker nodes because the other ones
62:32 - even though they are pods we're thinking
62:34 - them as distinct uh components okay
62:37 - and so let's take a look at the the
62:40 - components that are involved here
62:42 - so the first thing
62:44 - is the api server
62:46 - and notice how i remember i said it was
62:48 - the backbone of communication well look
62:50 - at it it looks like a big long line here
62:52 - and everything communicates along it so
62:54 - that's what i mean by backbone of
62:56 - communication
62:57 - and the way you are talking to stuff is
62:59 - generally going to be through the cube
63:02 - ctl
63:03 - okay or there's the api i guess they
63:05 - don't have a graphic for the api
63:07 - i guess it is the api server so that
63:09 - would be you sending um like https
63:12 - requests directly to it so i imagine
63:15 - that's like how um
63:17 - managed cloud service providers are
63:18 - talking to it
63:20 - but anyway so that's the api server then
63:22 - we'll have the scheduler so this
63:23 - determines where to start a pod on
63:26 - worker nodes we have the control manager
63:28 - so the detect states change it so like
63:30 - if the pod crashes it it tells it to
63:32 - restart you have xcd or etcd however you
63:37 - want to call this is a key value store
63:38 - that stores the save the cluster so
63:40 - controller manager highly relies on etsy
63:44 - and you have cubelet so this allows
63:46 - users to interact with the node via the
63:48 - cube ctl because cubelet no matter if
63:51 - it's a worker node or control plane node
63:53 - it's on both of them and so you know
63:56 - generally
63:57 - all of these are in the cube system i
64:00 - really should have wrote this in the
64:01 - course but they're in the cube system
64:03 - namespace
64:05 - and uh the components that can be in the
64:07 - control play node slightly vary so maybe
64:10 - instead of the control controller
64:12 - manager you'd have the cloud controller
64:14 - manager if you're using something like
64:16 - k3s they probably have slightly
64:18 - different control plane um components
64:21 - inside of them but you generally need to
64:24 - know for the exam what is in a control
64:28 - plane so know know what these all are
64:30 - and know that they are in the control
64:32 - plane and not in the worker nodes
64:34 - all right so now onto the worker nodes
64:37 - the worker nodes will have cubelet so
64:39 - all
64:40 - all nodes will have a cubelet for
64:42 - communication
64:43 - and that's the way it will talk to
64:45 - container runtime we'll talk about the
64:46 - second and then you'll have a proxy
64:49 - and so we'll have container runtimes
64:51 - pods and containers so just kind of an
64:54 - illustration there so
64:56 - why is there a proxy and why is there a
64:58 - cubelet
64:59 - well the proxy
65:01 - actually you know what i don't think i
65:02 - have it here but
65:04 - what's missing over here
65:06 - is core dns okay so generally we'd also
65:09 - have i can't believe i have it missing
65:12 - but you'd have core dns i have it in
65:14 - another slide so it's not a big deal so
65:15 - we should really have that here as well
65:18 - but i suppose it doesn't talk directly
65:19 - to the api server but
65:21 - proxy is
65:23 - what is used when you have incoming
65:25 - traffic right so i'm a user i use your
65:28 - website and how am i reaching that pod
65:30 - well it's going to be through the dns
65:32 - service coordinates or
65:34 - cube dns and then that's going to go
65:36 - through the proxy the proxy is going to
65:37 - go through ip tables which we'll talk
65:39 - about in this course and it will reach
65:41 - the application around the container if
65:42 - we're trying to interact with our
65:44 - container programmatically through cube
65:46 - ctl it's going to go through cubelet and
65:49 - that's going to go through the container
65:50 - runtime into the container
65:52 - so again if it doesn't click right now
65:54 - it's okay we're going to cover this in
65:56 - different variations here and you will
65:58 - know it but there you go
66:03 - [Music]
66:04 - hey this is andrew brown from exam pro
66:06 - and we are taking a look at probably the
66:08 - most important component
66:10 - pods so pods are the smallest unit in
66:12 - kubernetes and pods abstract away the
66:15 - container layer so you can directly
66:17 - interact with kubernetes layer in my
66:19 - mind the smallest unit really is
66:21 - containers but
66:23 - i guess they're talking about like
66:25 - newly defined components that are part
66:27 - of kubernetes
66:29 - okay
66:30 - and so here is that graphic there uh and
66:33 - so a pod is intended to run one
66:35 - application in multiple containers so
66:38 - notice down below that we have one two
66:40 - three four containers
66:42 - they're all running the same app like
66:44 - the same app over and over again
66:46 - now uh so that the idea here is a pod
66:48 - would be a database pod a job pod a
66:52 - front app pod a back-end pod pod um and
66:56 - what we could say is is if we use the
66:58 - term service like the way we're supposed
67:00 - to a service would define a continuously
67:03 - running
67:04 - type of application so you could say
67:07 - database service job service front-end
67:10 - service we talked about microservices
67:11 - that's how we describe it but that's the
67:12 - idea there you can run multiple apps in
67:15 - a pod but those containers will be
67:17 - tightly dependent i don't even know how
67:19 - to do that but the idea is if you wanted
67:20 - these all to be slightly different you
67:22 - could but
67:23 - i i again i have no idea how to do that
67:25 - i don't know why you would do that
67:28 - so each pod gets its own private ip
67:30 - address so look up here there's an ip
67:32 - address
67:33 - and containers will run on different
67:35 - ports so nodes here 3000 3001 8080 81
67:40 - containers can talk to each other via
67:42 - local host so if you have a container
67:45 - i will just clear on out this uh eraser
67:48 - stuff if container one wants to talk to
67:50 - container two all it has to do is talk
67:52 - to it on its port number on its own
67:54 - localhost and that is how simple
67:56 - communication is from container
67:57 - container communication which we'll talk
67:59 - about because we have a whole section on
68:02 - different types of cluster communication
68:05 - each pod can have a shared storage
68:07 - volume attached all containers will
68:09 - share the same volume so the idea here
68:12 - is you see this line here drawn to the
68:13 - pod to a persistent volume apv
68:17 - and we talk about persistent volumes and
68:19 - persistent volume claims we'll get to
68:22 - that later when the last remaining
68:24 - container dies or maybe crashes in a pod
68:26 - so does the pod
68:29 - but when replacement pods is created the
68:31 - pod will have a
68:32 - new ip address that will be assigned so
68:35 - ip addresses are a
68:37 - i never can say that right efferent
68:40 - or temporary for pods so they don't
68:44 - by default persist and that's why we're
68:47 - going to need kubernetes services which
68:49 - we will talk about in this course so to
68:51 - get pods and show their ip addresses
68:54 - it's very common you'll type in get pod
68:56 - get pods and then doing this hyphen o
68:59 - wide
69:00 - okay
69:01 - [Music]
69:06 - hey this is andrew brown from exam pro
69:07 - and we're taking a look at the api
69:09 - server now we saw a graphic of it
69:11 - uh when we were looking at the control
69:13 - plane versus worker nodes so we don't
69:14 - need another graphic here and i think a
69:16 - lot of this text i grabbed direct from
69:18 - kubernetes.io because i'm just trying to
69:19 - get you through the key points of it um
69:23 - so this part's a little bit boring but
69:24 - let's get to it so the core of
69:25 - kubernetes control plane is the api
69:27 - server the api server exposes http api
69:31 - that lets the end users different parts
69:32 - of your cluster external components
69:34 - communicate with one another
69:36 - cube api lets you query and manipulate
69:38 - the state of api objects and kubernetes
69:41 - like pause namespaces config maps events
69:44 - the api server is a component of
69:45 - kubernetes control plane that exposes
69:47 - the kubernetes api the api server is the
69:50 - front end of the kubernetes control
69:51 - plane the main implementation of
69:53 - kubernetes api is cube api server cube
69:56 - api server is designed to scale
69:57 - horizontally that is it scales by
69:59 - deploying more instances you can run
70:01 - several instances in cube api server and
70:04 - balance traffic between those instances
70:06 - everything has to go through the api
70:09 - server you can interact in the uh with
70:11 - the api server in three ways so the ui
70:13 - api and a cli like cube ctl now i put an
70:16 - asterisk on ui because i don't know what
70:18 - they're talking about there the only
70:20 - thing you have is the kubernetes
70:21 - dashboard which is something that is
70:23 - optional to launch
70:25 - and um i mean you can't really launch
70:28 - resources in the kubernetes dashboard
70:31 - so i don't know what they're trying to
70:34 - say there but technically if you are
70:36 - interacting with kubernetes
70:38 - uh via the api server it's going to go
70:40 - to the api so i guess in that sense it
70:43 - is
70:44 - in terms of like how it scales and stuff
70:47 - i don't really know i don't know how to
70:48 - observe that directly in there but
70:49 - apparently it just does it and hopefully
70:52 - that gives you an idea a little bit more
70:53 - information about the api server
70:59 - [Music]
71:00 - hey this is andrew brown from exam pro
71:02 - and we are looking at deployments in
71:04 - kubernetes so a deployment provides
71:06 - declarative updates for pods and replica
71:09 - sets so deployment controller
71:12 - changes the actual state to the desired
71:14 - state of at a controlled rate and the
71:16 - default deployment controller can be
71:18 - swapped out for other deployment tools
71:20 - like argo cd flux and jenkins so
71:24 - what i'm saying there is that uh
71:27 - deployment is built in to kubernetes so
71:30 - you don't have to install a third-party
71:31 - tool but generally you want to because
71:35 - the the tool there is very limited it
71:37 - doesn't do git ops and so that's why
71:40 - you'll want things like argo flux and
71:42 - jenkin x which we will talk about more
71:44 - when we get to our deployment section of
71:46 - this course
71:47 - notice at the top here i say pods and
71:50 - replica sets but in reality a deployment
71:53 - is always deploying a replica set and so
71:56 - even if you're just deploying one pod
72:00 - it's going to be a replica set of one
72:02 - so here
72:03 - is the actual
72:05 - manifest file of doing a deployment
72:07 - you're going to be seeing a lot of these
72:08 - manifest files through the course it's
72:10 - going to be kind and then the type right
72:12 - so deployment and then generally i think
72:14 - usually yeah then no i guess spec is
72:17 - just for deployments but uh and pods and
72:20 - things like that and so here spec is our
72:22 - pod spec file which we'll talk about
72:23 - later here it says replicas so it's
72:25 - going to create a replica set with three
72:28 - pods in it
72:29 - and then down below here you can see uh
72:31 - the container that we are going to be
72:33 - deploying
72:36 - for these three pods so we'll end up
72:38 - with three containers so here is a
72:40 - graphical example
72:42 - or architectural diagram of the
72:44 - deployment controller and so this one in
72:47 - particular is using flux okay and so the
72:50 - idea here is you have deployment it goes
72:53 - to the deployment controller the default
72:54 - one or whichever one you install deploys
72:57 - your replica set
72:58 - and that's how you get your pods
73:01 - so a deployment defines the desired
73:03 - state of replica sets and pods a
73:05 - deployment will create and manage a
73:07 - replica set
73:09 - a replica set will manage replicas of
73:11 - pods so there you go
73:13 - [Music]
73:17 - hey this is andrew brown from exam pro
73:19 - and we are taking a look at replica sets
73:22 - so replica set is a way to maintain a
73:25 - desired amount of redundant pods
73:27 - replicas to provide a guarantee of
73:30 - availability so here's a replica set and
73:33 - inside of it we have multiple pods or
73:36 - you could say replica pods one could be
73:38 - the main pod just who knows right
73:40 - because when you distribute traffic to
73:42 - them like with a service it's just
73:44 - random where it goes so they're
73:46 - basically all replica pods here is the
73:48 - manifest file notice that it's called a
73:51 - replica set and it looks just like a
73:54 - deployment you specify the replicas
73:57 - you're specifying the containers
74:00 - okay
74:01 - the pod field metadata owner references
74:03 - determines the link from a pod to a
74:05 - replica set
74:07 - uh so
74:09 - that we would have to observe that on
74:10 - the pod itself so if we went
74:13 - using the cube ctl and we said cube ctl
74:15 - describe pod in the pod name we would
74:18 - see that metadata there and that's how
74:19 - we would know that it's linked to that
74:21 - replica set
74:22 - it is not recommended to directly create
74:25 - replica sets so you can
74:27 - but instead a deployment can create and
74:29 - manage replicate sets for you the idea
74:32 - here is that if you launch a replica set
74:34 - and then you delete it it's gone now if
74:37 - you delete a replica set i believe that
74:39 - a deployment will say hey your replica
74:41 - set's gone it will spin up another one
74:43 - okay same thing like if you have a
74:45 - replica set and you have three pods in
74:47 - it you delete
74:49 - your pods then your pods might reappear
74:52 - okay so horizontal pod autoscaler can be
74:55 - used to auto scale replica sets
74:58 - and we'll talk about that when we get to
75:00 - hpa okay
75:03 - [Music]
75:07 - hey this is andrew brown from exam pro
75:08 - we're comparing stateless versus stathal
75:10 - very important concept we need to know
75:12 - in kubernetes but also just when
75:14 - building applications when we're running
75:16 - them in more than a single
75:18 - virtual machine or compute because we
75:20 - might want to
75:22 - have a version of our application in
75:24 - multiple um data centers across multiple
75:27 - regions
75:29 - and so how do you handle that when a
75:31 - user goes to the website
75:33 - but then it goes to a another server how
75:36 - does it knows the same same person or
75:38 - does that matter so
75:41 - we're talking about stateless the idea
75:42 - here is that every request so like a web
75:44 - request to the server
75:46 - does not care it forgets about the
75:48 - previous or current state that's what we
75:50 - mean by stateless so think of a goldfish
75:52 - that you know
75:54 - has poor memory then uh the idea with
75:56 - staples every request relies on state
75:58 - data to remember uh so very uh a good
76:02 - example would be a database a database
76:04 - you have to know who it is every time uh
76:07 - like if you were to
76:08 - have 10 requests in a row accessing data
76:11 - uh it has to go to the same um database
76:14 - the same place so that we know who it is
76:16 - so think of
76:18 - an elephant okay so for web applications
76:21 - it's not that they don't have a state
76:23 - it's just that the state is stored
76:24 - outside the context of the web app
76:26 - running on the virtual machine and so
76:28 - that state will be pushed to something
76:29 - like a database or cookies which are
76:32 - are stateful but the web apps themselves
76:34 - are stateless so those http requests
76:36 - come to the servers uh the server does
76:39 - not uh know if it's from the same person
76:42 - this time around or other it just does
76:43 - not matter
76:45 - now that's not to say that web apps
76:47 - can't be stateful
76:49 - they are if they are on a single machine
76:51 - and so the problem with a lot of people
76:53 - with monoliths is that when they build
76:55 - them they do store the state on a single
76:58 - machine they might store it in memory
77:00 - and that's where we run into problems
77:02 - because then it makes it really hard to
77:04 - scale out to multiple machines so that's
77:06 - a pattern that we generally want to
77:07 - break so that we can move into a
77:09 - microservice architecture or at least
77:12 - an architecture where we can run our
77:13 - monolith on more than one machine so
77:16 - when we're talking about stateful
77:18 - imagine you have a database so you have
77:19 - a primary database and then you have a
77:22 - second version of your database but it's
77:24 - only for read replicas the state here
77:26 - has to remember
77:27 - who can do writes and reads and who can
77:29 - do reads right because in the primary
77:31 - database you can always do writes but
77:33 - the rewrite only do reads and so it has
77:34 - to remember that state data so hopefully
77:38 - that makes sense but anyway the weight
77:41 - ties to kubernetes
77:43 - is
77:44 - stateless is where we will use replica
77:47 - sets as that's where you would launch
77:48 - your applications with and stateful sets
77:51 - is where you would use things for like a
77:54 - database if you wanted to run it in
77:55 - cluster okay
78:01 - hey this is andrew brown from exam pro
78:02 - and we are looking at stateful sets now
78:05 - this is one of the few things in this
78:07 - course that i'm not doing
78:10 - a follow along with i'm not showing you
78:11 - it hands-on because it's so hard to do
78:14 - and it's out of the scope of the kcna
78:16 - and generally it's recommended not to
78:19 - run your databases
78:20 - uh in cluster but using managed service
78:23 - so for those reasons i'll just provide
78:25 - the information here so you generally
78:27 - have uh the know-how now that doesn't
78:30 - mean that you will never have to do it
78:31 - there might be some cases
78:33 - but again it's just out of the scope of
78:35 - this course so stateful sets are used
78:38 - when you need traffic to be sent to
78:40 - specific pods and the thing with staple
78:43 - sets is they will always have a unique
78:45 - and predictable name and address
78:48 - ordinal index numbers assigned to each
78:50 - pod like zero one two three four five
78:53 - a persistent volume attached with a
78:55 - persistent link from pod to storage
78:57 - if a pod is rescheduled the original
79:00 - persistent volume will be mounted to
79:01 - insert data integrity consistency
79:03 - because that's how you ensure state
79:06 - stateful set pods will always start in
79:08 - the same order and terminate in reverse
79:11 - order
79:12 - so that's really important
79:14 - now in order to implement stateful sets
79:17 - it will require to use a headless
79:19 - service
79:20 - to manage identities headless services
79:22 - were really really really confusing i
79:25 - can't tell you how much time i spent to
79:26 - try to make sense of them but what i
79:28 - figured out is that
79:30 - headless services
79:32 - are generally
79:33 - used because of stateful sets so there
79:36 - is a headless server service used to
79:38 - maintain the network identity of the
79:40 - pods and another service that provides
79:42 - read access to the pods and i have an
79:44 - architectural diagram we'll walk through
79:45 - it so here's an example of a stateful
79:48 - set i'm going to get my pen out here you
79:49 - can see there's a lot going on here but
79:51 - we have stateful set at the top
79:54 - okay and then there it kind of looks
79:55 - like a deploy so you have a match
79:57 - selectors to
79:58 - match to something the replicas like how
80:00 - many do you want to run
80:02 - um and where it kind of varies is that
80:06 - it has a mounted volume so it's not like
80:09 - you can't mount a volume to
80:11 - a um
80:13 - you know a deployment replica set what
80:15 - have you but staple sets would have a
80:19 - volume because they're usually for
80:21 - databases so you definitely would want
80:23 - uh to have a volume attached there so
80:26 - that here is my big fancy
80:29 - diagram and so i have some accompanying
80:32 - text here that is from the documentation
80:35 - and so what i'll do is read it up to you
80:36 - and then try to figure out how it
80:38 - matches up to the diagram so the first
80:40 - thing is when we're looking about staple
80:42 - sets we have a dns host name for rights
80:45 - so rights will be i'm sorry i got to set
80:48 - up this scenario here if you look here
80:50 - what we have is a stateful set and it's
80:52 - a postgres database
80:55 - being deployed in cluster okay
80:58 - so
80:59 - the first thing is for our
81:01 - staple set of a pro square database is
81:03 - that rights will be directed to the main
81:06 - pod
81:07 - by its dns host name which is identified
81:09 - by the headless service so uh
81:12 - you know you have in your web
81:13 - application someone wants to write to
81:15 - the database so the idea is that in
81:18 - order for us to know where this main pod
81:20 - is we need this headless service so that
81:22 - we get a dns record and so here's it
81:24 - says main.psq
81:26 - because we can't rely on ip address we
81:29 - need to rely on that domain name or that
81:32 - dns record so that's what it will do to
81:35 - help it get there
81:36 - then the idea is we have cluster ip for
81:38 - read so for read traffic it can be
81:41 - redistributed or distributed to all the
81:44 - reading pods using the cluster ip
81:46 - service now this part of the course we
81:48 - haven't covered all the different
81:50 - service types so when you
81:52 - if you find this confusing what you
81:53 - should do is watch the whole services
81:55 - section when you get to it and then come
81:57 - back to this and look at this because it
81:58 - is pretty darn complicated to be honest
82:00 - um but anyway so
82:02 - the idea here is that when we want to do
82:04 - a read
82:05 - we use a um
82:07 - a regular service like we would cluster
82:09 - ip that's the default one and that by
82:11 - default uh does load balancing at random
82:16 - so here it doesn't matter because both
82:17 - the pods uh can read and so you'll
82:20 - either go to the main pod or the read
82:22 - replica
82:24 - then you have the headless server so the
82:25 - headless service is a service with
82:27 - cluster ip set to none
82:30 - and it does not provide load balancing
82:32 - it doesn't it does not provide a static
82:34 - ip address a headless service is used to
82:36 - identify specific pods by signing them
82:39 - dns records that's all it does it gives
82:41 - a nice dns record so that we can
82:44 - identify uh what pod to send to okay
82:48 - i have those services required in order
82:50 - to uh for a stable set to work and i've
82:52 - said that a few times here then we have
82:54 - our pvc and our pv so
82:57 - persistent volume claim and persistent
82:59 - volume again we haven't reached that
83:01 - section yet of the course but we will
83:03 - but the idea is that
83:05 - we do need to have some kind of storage
83:08 - because it is a database
83:11 - and we said earlier in the previous
83:12 - slide that
83:14 - you'd want to retain that information so
83:16 - if this main pod was destroyed and then
83:18 - a one was to take its place this same
83:21 - volume here would get matched up it
83:23 - wouldn't match up to some other random
83:25 - volume it would ensure that this one
83:28 - matches with the main pod so there you
83:30 - go
83:34 - [Music]
83:35 - hey this is andrew brown from exam pro
83:37 - and we are looking at kubernetes
83:39 - namespaces so a namespace is a way to
83:42 - logically isolate resources within a
83:44 - kubernetes cluster and so namespaces can
83:47 - be organized based on project department
83:50 - or any user defining group and so if
83:52 - we're using cube ctl it's cube ctl get
83:54 - namespace or ns for short but you
83:58 - generally get the idea with these get
83:59 - commands it's always get whatever you
84:01 - want kubernetes starts with four initial
84:04 - namespaces there's the default one so
84:06 - this is just where your stuff is going
84:07 - to end up
84:08 - if you create anything without
84:09 - specifying a namespace you have cube
84:11 - public these are for resources that are
84:13 - publicly visible and readable you have
84:16 - cube system this is a namespace that
84:18 - stores objects
84:19 - stores objects created by the kubernetes
84:22 - systems or we say objects it's pretty
84:23 - much pods
84:25 - okay
84:27 - and so engineers deploying applications
84:29 - are not supposed to touch this namespace
84:30 - we say not supposed to
84:33 - let's say we're using adabus eks to
84:36 - deploy our managed kubernetes cluster
84:38 - over there they might tell you to
84:41 - if you want to have an ingress
84:43 - controller and use
84:46 - the load balancer with aws you would
84:48 - then
84:49 - for that one case
84:51 - create a controller ingress or
84:55 - ingress controller for aws in that
84:58 - namespace so it's not that it's it never
85:00 - happens but it rarely should it be done
85:03 - and the cube system namespace is one
85:05 - we'll see throughout this course because
85:07 - every opportunity when we use a new
85:09 - managed
85:10 - kubernetes provider or a different
85:13 - lightweight distribution i will always
85:15 - look at all the stuff and show you
85:17 - what's q in cube system so you have an
85:19 - idea what's running on the cluster then
85:21 - you have cube node lease so this holds
85:24 - lease objects associated with each node
85:26 - it's used to detect node failures by
85:28 - sending heartbeats and so you can create
85:30 - your own name sources by doing cubectl
85:33 - create namespace and the namespace here
85:35 - would be we're calling it production so
85:37 - in clusters with a small amount of
85:38 - resources namespaces aren't necessary
85:41 - but it's up to you if you want to use
85:43 - them you can use them
85:44 - but the great thing about namespaces is
85:46 - that you can apply um like network
85:48 - policies and other kind of uh
85:50 - permissions so if you have role-based
85:52 - access controls you can say only give
85:53 - access to stuff in this
85:55 - namespace so um for me i would probably
85:57 - always just create a namespace but they
85:59 - say you don't have to might complicate
86:00 - things so names of resources you need to
86:03 - be unique with a namespace but not
86:05 - across namespaces
86:08 - they're talking about objects themselves
86:09 - so like if you have a pod it um and you
86:12 - call it
86:13 - my app it can be my app in a bunch of
86:16 - them right
86:18 - namespace based scoping is applicable
86:20 - only for namespace objects so deployment
86:23 - services things like that
86:25 - uh but not for cluster-wide objects
86:27 - storage class nodes persistent volumes
86:30 - so what we're talking about is there's
86:32 - um certain objects we're saying objects
86:34 - we're talking about components
86:36 - i don't know sometimes the docs say
86:37 - components sometimes the doxate objects
86:40 - but the idea is that certain kubernetes
86:42 - components
86:43 - can be namespace and some of them can't
86:45 - be so that's something that we need to
86:46 - know so there are
86:48 - objects or components kubernetes
86:50 - components that can only reside in a
86:52 - single name space there's ones that are
86:54 - multi-name space so there's ones that
86:56 - are clustered wide so they can never
86:58 - live in a namespace so example of single
87:00 - namespace objects are config maps and
87:03 - secrets they cannot be shared across
87:05 - namespaces they exist in one okay so
87:07 - config maps and secrets then you have uh
87:10 - services and pods which can belong to
87:13 - multiple namespaces
87:15 - um and then for cluster wide we have
87:17 - volumes and nodes they do not exist in
87:21 - namespaces they are just in the cluster
87:23 - now i don't know the exhaustive list of
87:26 - all the objects are there's probably
87:28 - some way to look it up i never did but
87:30 - these are the ones that you need to
87:32 - remember and just realize that there are
87:34 - three different kinds of buckets okay so
87:36 - you can apply a system quota
87:38 - restrictions on namespaces to avoid
87:40 - overusage like memory compute so that's
87:42 - an example of
87:44 - leveraging namespaces to put limitations
87:46 - uh like security restrictions things
87:48 - like that if you don't provide a
87:50 - namespace for a component it will end up
87:51 - in the default namespace as we already
87:53 - said but there you go
87:55 - [Music]
87:59 - hey this is andrew brown from exam pro
88:00 - and we're going to talk about entry
88:02 - versus outreach so these were terms that
88:05 - i kept on seeing when i was looking up
88:07 - different um
88:09 - cncf projects
88:11 - and uh the term varied so there was no
88:14 - consistency with the way this term was
88:16 - used and so i'm kind of imposing my own
88:19 - terminology to help us understand what
88:21 - it is uh and i can tell you right away
88:23 - like i was talking to some kubernetes
88:25 - folks and they were dead set that it
88:27 - meant one particular thing but i just
88:30 - couldn't reconcile it because i was just
88:31 - seeing it used in different ways so just
88:34 - understand that this is my own personal
88:36 - opinion it's a way to help you just kind
88:37 - of contextualize it even if it's not
88:39 - perfectly accurate
88:41 - so in cloud native projects you'll hear
88:42 - the term entry in out tree so
88:45 - here is a little uh forest here to i
88:47 - don't know have a visual but entry the
88:49 - way i describe it is plugins components
88:51 - or functionality that are provided by
88:53 - default or
88:55 - or doesn't mean they have to but or they
88:58 - reside in the main repository so think
89:00 - of entry as internal plug-ins things
89:03 - that come by default with the project
89:06 - then you have out of tree so plugins
89:08 - components or functionality that must be
89:11 - installed manually and extends or
89:13 - replaces the default behavior so think
89:16 - of out of tree as external plug-ins and
89:19 - again this is my own definition that
89:22 - some people are not going to agree with
89:23 - me on um but this is the best way i
89:26 - understand it
89:27 - um but yeah we'll maybe we'll take a
89:29 - look at something where you know i see
89:31 - this in trio tree stuff okay
89:33 - [Music]
89:37 - hey this is andrew brown from exam pro
89:38 - and we're just trying to find the
89:40 - example of entry versus out tree and so
89:42 - i remember seeing this under coron dns
89:44 - it's for a variety of projects but if
89:46 - you go to core dns which we cover in
89:48 - this course it's a gns server that comes
89:51 - by default with kubernetes which
89:52 - replaced uh cube dns i believe and so if
89:56 - you were click to if you were to click
89:58 - through to the website you almost the
89:59 - top it says plugins and then external
90:02 - plugins
90:03 - okay and if we go to github and that's
90:05 - not always the case but sometimes when
90:08 - you are in a github repository and this
90:11 - is where i consider the repository to be
90:13 - a tree because um it's a nest of folders
90:17 - or you could say it's a directory tree a
90:20 - folder tree so within our
90:22 - folder tree here we have plugin and here
90:24 - is a bunch of plugins that would be
90:26 - considered
90:27 - in tree for this
90:29 - project so if we go back to core dns
90:31 - things that are out of tree are external
90:33 - plugins
90:35 - which to me those are just plugins but
90:38 - um you know these are all plugins that
90:40 - are not part of the repository again
90:43 - entry doesn't mean it has to be in the
90:44 - repository it just means that it ships
90:46 - with it by default and these do not ship
90:48 - by default you have to do extra things
90:51 - to get them in
90:52 - uh so hopefully you know that helps you
90:55 - with that definition or where i'm coming
90:56 - with that again we could find tons of
90:58 - examples of this but this is the one i'm
91:00 - just showing you okay
91:02 - [Music]
91:06 - hey this is andrew brown from exam pro
91:08 - and we are taking a look at endpoints
91:10 - and endpoint slices so endpoints track
91:12 - the ip addresses of the pods assigned to
91:16 - a kubernetes service if that's confusing
91:18 - just give us a moment we got a graphic
91:20 - okay so
91:21 - when a service selector matches a pod
91:23 - label the pod ip address is added to the
91:26 - pool of endpoints so pods expose
91:28 - themselves to services
91:30 - via endpoints okay so
91:34 - here's the graphic that i'm talking
91:35 - about so the idea here is that we have a
91:37 - service right and
91:39 - we learned that services are used to
91:43 - load balance to multiple pods
91:46 - but the question is how does a service
91:49 - link to a pod and that answer is
91:51 - endpoints all right so remember each pod
91:54 - has a dynamic ip address so the idea is
91:57 - that you are storing the dynamic ip
91:59 - address in endpoints okay
92:01 - and they exist in like this endpoint
92:04 - pool
92:05 - all right so it's the connection between
92:06 - services and pods and
92:09 - rarely rarely do you ever have to
92:11 - manipulate these or do anything with the
92:13 - end points okay but if you want you can
92:15 - do cube ctl and get those endpoints
92:18 - now there's this concept of endpoint
92:21 - slices so endpoint slices break up
92:23 - endpoints into smaller manageable
92:26 - segments and each endpoint slice has a
92:28 - limit of 100 pods
92:30 - so
92:32 - why like why do we care about endpoints
92:34 - and endpoint slices well according to
92:36 - the documentation it it's when you're
92:39 - scaling out uh there is a cap on
92:42 - endpoints like the amount of endpoints
92:43 - you can have in a service and so that's
92:45 - where you run into scaling issues and
92:47 - then
92:48 - that's why you need endpoint slices
92:50 - and also the term endpoint just comes up
92:53 - in the documentation all the time and
92:54 - endpoints is a general term
92:57 - meaning uh like when we talk about apis
92:59 - an endpoint would be like you
93:01 - point your request your http request to
93:04 - an address or an ip address and that
93:06 - could be called an endpoint i just kind
93:07 - of wanted to clear that up so that you
93:09 - knew that endpoint was a very particular
93:12 - thing in kubernetes and we're not just
93:13 - saying the general word endpoint okay
93:16 - [Music]
93:20 - hey this is andrew brown from exam pro
93:22 - and we are looking at jobs and cron jobs
93:24 - and before we can describe that we need
93:26 - to describe what is a background job so
93:28 - a background job is a one-off task that
93:32 - is used to run a piece of code or a
93:34 - function
93:35 - and they're commonly used to perform
93:36 - maintenance or to trigger a
93:38 - computational workload so an example
93:40 - could be to back up the database every x
93:43 - minute so like every 30 minutes delete
93:45 - all users who not have not confirmed
93:47 - their email basically you could trigger
93:49 - any kind of code but the idea is that uh
93:52 - you know
93:53 - they're in jobs right
93:55 - so a job creates one or more pods that
93:57 - will continue to retry execution of the
94:00 - pods until a specified number of them
94:03 - successfully terminate so an example
94:05 - here would do cube ctl create job we're
94:07 - saying the job's named hello
94:10 - and we are using busybox which is
94:12 - something we will talk about in this
94:13 - course
94:15 - to just do an echo hello a cron job is
94:18 - just like a job but it executes based on
94:20 - a repeating schedule and so a cron job
94:23 - uses um this
94:24 - uh kron tab expression or cron
94:27 - expression so this i'm not sure what it
94:30 - says maybe every minute
94:32 - this will run every hour i'm terrible
94:34 - chronic branches
94:36 - quran expressions
94:37 - but a very very common um
94:40 - use case for jobs is that you want it
94:42 - for long running tasks
94:44 - so it doesn't hang up your main
94:46 - application and a very common use case
94:48 - is sending off emails so you wouldn't
94:51 - hang the main thread of your main app
94:53 - you would run it in an isolate job
94:56 - there okay
95:01 - hey this is andrew brown from exam pro
95:03 - and i just want to talk about the
95:04 - kubernetes dashboards the kubernetes
95:06 - dashboard is an open source application
95:08 - you can deploy to your cluster to
95:10 - provide a ui to view kubernetes
95:13 - components and so it looks like this so
95:16 - when i was first using kubernetes i was
95:18 - doing it on aws and i launched up um a
95:21 - cluster on amazon eks or aws cks
95:24 - whatever they want to call it
95:26 - and uh there i couldn't see anything i
95:28 - was just like where's all the stuff
95:29 - where's the ui
95:31 - um and so i was kind of disappointed i
95:33 - thought maybe it was offering wasn't
95:35 - very good or maybe kubernetes just
95:36 - doesn't have an interface but then i
95:39 - realized um that they just have this ui
95:42 - thing and you can launch it on any
95:43 - provider that you want and it's very
95:46 - easy it's like a one-liner but even with
95:48 - um lightweight distributions like um
95:50 - minicube or micro k8 s you can literally
95:54 - just write like enable dashboard you'll
95:56 - get one
95:57 - and so you can click around and you can
95:59 - see
96:00 - um all the kubernetes components that
96:02 - are running in your cluster and i just
96:04 - noticed that there's like this create
96:06 - button here at the top because i was
96:07 - when i'm going through the follow alongs
96:09 - i
96:10 - can't seem to find a way to create
96:11 - resources so that it's possible that you
96:14 - can create stuff there and also when we
96:15 - were talking about earlier um
96:18 - about api server it says interacting
96:20 - with the ui and i and i was saying like
96:23 - renee's bat dashboard doesn't let you
96:24 - create stuff so maybe i just haven't
96:27 - noticed this button here so maybe it is
96:28 - uh able to create resources there but i
96:30 - want you to to know about it and it's
96:32 - part of the kubernetes project
96:35 - so it's not like it's a third party it's
96:37 - totally safe to install
96:39 - and use but there you go
96:40 - [Music]
96:45 - hey this is andrew brown from exam pro
96:47 - and we are taking a look at selectors so
96:49 - selectors are a way of selecting one or
96:51 - more kubernetes objects remember objects
96:54 - could be pods
96:55 - objects is also could be generalized as
96:58 - meaning kubernetes components so in
97:00 - kubernetes there are three types of
97:01 - selectors so we have label selectors so
97:04 - selects kubernetes objects based on the
97:07 - applied label and so this is the example
97:10 - or the type of selector we're going to
97:12 - heavily focus on
97:13 - in this course but the idea here is that
97:16 - you have your selector and we're saying
97:18 - match on
97:19 - all pods that have the key environment
97:22 - with the with the
97:24 - value
97:26 - production and so then it selects only
97:28 - those pods you have field selectors so
97:30 - select kubernetes object space on the
97:32 - object data like metadata or status we
97:35 - have node selectors so select nodes for
97:38 - very specific plot placement let's take
97:41 - a look at what we do when we apply
97:44 - labels so labor select label selectors
97:47 - to find labels as key value pairs
97:49 - probably have a slash there under
97:51 - metadata in the manifest file so notice
97:54 - here it says metadata and then there is
97:56 - our label this is the key this is the
97:58 - value as you can see we can have
98:00 - multiple
98:03 - multiple
98:04 - [Music]
98:06 - labels okay so on the worker node here
98:09 - we have
98:10 - for example
98:12 - this one says env prod and then it says
98:15 - app engine x web just to kind of match
98:17 - up what that means there so you can use
98:19 - the hyphen show labels to see all labels
98:22 - so here's an example for pods and this
98:24 - will work for a variety of different
98:27 - kubernetes objects you can apply labels
98:29 - with the label command
98:32 - so you can do cube ctl label pods apache
98:35 - web owner equals devops so you can do it
98:38 - here in the manifest file or you can do
98:40 - it here on the fly
98:41 - i always do it in the manifest file i
98:43 - never do it on the fly
98:45 - um but you know i just want to make sure
98:46 - you are aware of all those options
98:49 - okay
98:50 - [Music]
98:54 - let's take a look at recommended labels
98:56 - so these are recommended labels that
98:57 - should be applied to every single
98:59 - resource or resource object and so i say
99:02 - should in parentheses
99:04 - because in practicality most people
99:07 - aren't doing this
99:08 - so let's take a look at what is
99:10 - recommended so we have name
99:12 - instance version component part of
99:15 - managed by created by their
99:16 - self-explanatory
99:18 - um
99:19 - and so just note
99:22 - that the prefix of the the
99:25 - key here has this
99:27 - app.kubernetes.io and then name so this
99:30 - is the key right so remember there's a
99:31 - key and a value for labels and so labels
99:34 - can have forward slashes and they can
99:36 - have dots in them so just be aware that
99:38 - they can get kind of funky there
99:41 - but if you had a label without a prefix
99:44 - like the app.um kubernetes.io
99:47 - then these are considered private to
99:50 - users okay so just understand
99:53 - that one caveat so here is what it would
99:55 - look like if you applied all of those
99:58 - labels and again i've never seen that
100:01 - happen
100:02 - i mean i'm sure it happens that people
100:03 - are like packaging things for like helm
100:05 - and stuff like that
100:07 - because people are going to be ingesting
100:09 - them and people are
100:10 - usually are a bit better about that but
100:12 - when you're building your own stuff you
100:13 - might not be doing that at all okay but
100:15 - one i definitely do said is the name so
100:17 - that's something that i will do quite
100:19 - often
100:23 - [Music]
100:25 - so we looked at applying labels but how
100:27 - do we actually select labels
100:29 - so kubernetes objects like
100:32 - services or replica sets can target pods
100:34 - based on label selectors you have to use
100:37 - them otherwise it doesn't know
100:39 - uh like a service will not know what pod
100:41 - to associate with same with replica sets
100:44 - and so here we have an example where
100:47 - we're doing selector and then it's the
100:49 - key and the value on a service and then
100:52 - this one is for a replica set notice
100:54 - that the selector syntax varies for
100:57 - different templates or we could say
100:59 - different kinds of kubernetes objects so
101:01 - this one says match labels and this one
101:03 - doesn't have it just has a selector like
101:05 - that
101:06 - um you can use the selector in the cube
101:09 - ctl as well so you just do hyphen hyphen
101:12 - selector or use its alias hyphen l so
101:14 - here is an example where you are
101:17 - selecting all the pods or things like
101:19 - that so it's not necessarily that it has
101:21 - to be for a service or replica set you
101:23 - can even do it uh that way if you're
101:25 - just trying to
101:26 - grab resources that have labels and and
101:29 - see them okay
101:35 - let's talk about annotations which seem
101:37 - very similar to labels but they're not
101:39 - they're something else so kubernetes
101:41 - annotations allow you to attach
101:43 - arbitrary non-identifying metadata
101:46 - to objects
101:48 - so clients like tools or libraries can
101:51 - and may require this annotation
101:53 - in order to work
101:54 - a good example here is ingress so this
101:57 - often uses annotation to communicate
101:59 - ingress controllers
102:01 - so here we have
102:03 - um
102:04 - an ingress
102:06 - kubernetes ingress and so it needs to
102:08 - communicate to an ingress controller and
102:10 - this one is specifically for nginx and
102:13 - so it always expects this rewrite target
102:15 - thing in here
102:17 - when you look at different ingress
102:19 - controllers like aws they have some
102:21 - different ones
102:23 - and it just varies
102:25 - so that's the only use case i've seen
102:27 - for annotations i'm sure they show up
102:28 - somewhere else but that's all i've seen
102:30 - okay
102:31 - [Music]
102:35 - hey this is andrew brown from exam pro
102:37 - and we are taking a look at a pod spec
102:39 - file so pod spec is a configuration file
102:42 - that describes
102:43 - a pod so that seems pretty clear
102:47 - remember all files are manifest files
102:49 - especially if they look like yaml for
102:51 - kubernetes
102:52 - but here is an example of us
102:55 - defining a pod but notice that it says
102:59 - spec down here below
103:01 - so the spec section is what we care
103:03 - about and that's what makes it a pod
103:05 - spec file and i want you to know that
103:08 - this spec thing can show up in a service
103:12 - or sorry a component that is a
103:15 - kind of pod or deployment or a replica
103:18 - set
103:19 - uh probably also a stateful set so just
103:22 - realize that's what i mean when i say
103:23 - pod spec file we're talking about
103:25 - this section here
103:27 - so
103:28 - the idea is you can define multiple
103:30 - containers and you'll have the name of
103:32 - the container the image here which is
103:35 - nginx
103:36 - the command to run on startup could be
103:38 - an option it's not shown here
103:40 - the port the container will operate on
103:43 - the restart policy which again we don't
103:45 - have it displayed here
103:47 - and a variety of other things so you can
103:50 - directly deploy a pod with cube ctl
103:52 - apply command as we see here so it's
103:55 - showing a pod but in practice you won't
103:57 - directly deploy pause instead you'll use
103:59 - deployments or job as the kind
104:04 - so in some um uh follow alongs you will
104:08 - see people deploy pods just because they
104:09 - just don't want to deal with deployment
104:11 - because they want to be able to delete
104:13 - the pod and the pod not to spin back up
104:15 - again
104:16 - um but yeah you rarely ever would
104:19 - never would ever make sense to deploy
104:20 - pod without deployment okay
104:23 - [Music]
104:27 - hey this is andrew brown from exam pro
104:29 - we are looking at grpc
104:32 - uh before we understand what grpc is we
104:34 - need to know what our pc is so that
104:37 - stands for remote procedure call and
104:39 - this is a framework of communication in
104:41 - distributed systems it allows one
104:44 - program on a machine to communicate
104:47 - with a program on a remote machine
104:48 - without knowing that it's remote and the
104:51 - concept of rpc has been around since the
104:53 - 1970s so grpc is
104:57 - much newer it's a modern open source
104:59 - high performance rpc framework that can
105:02 - run in any environment and grpc was
105:05 - initially created by google
105:08 - so you can kind of think of grpc as an
105:10 - alternate method of communication
105:11 - instead of rest or graphql
105:14 - and it can connect services in and
105:16 - across data centers with plugable
105:18 - support for load balancing
105:20 - tracing health checking authentication
105:23 - uh and probably more
105:25 - so let's try to take a look at how this
105:27 - actually works so the idea is you'll be
105:30 - installing a grpc library
105:32 - for your program you'll be defining a
105:35 - protobuf file that describes the data
105:37 - structure
105:38 - and those files usually have a dot
105:40 - proto extension you'll be writing code
105:43 - that works with grpc
105:45 - so distributed systems like kubernetes
105:47 - uses grpc for pod communication and so
105:50 - that's kind of the example and honestly
105:52 - i was a bit lazy here with grpc because
105:55 - i probably could have showed you code
105:56 - examples and stuff like that but with
105:58 - kubernetes you're never really touching
106:00 - grpc it's just there
106:02 - um and my experience with grpc is i used
106:05 - it when i was using something called
106:06 - nats
106:07 - n-a-t-s
106:09 - not to be confused with nat network
106:11 - address translation that's is a
106:14 - an event bus that
106:17 - requires grpc these protobuf files but
106:19 - you know even though i don't have it
106:21 - here the idea is that
106:23 - you would have a file it's it has its
106:25 - own syntax but it's a file that defines
106:28 - the structure of communication
106:30 - and then you implement
106:33 - in your chosen language like ruby or
106:35 - android
106:37 - how to
106:38 - um uh
106:40 - like you load that structure into a like
106:43 - using your standard library so you can
106:45 - read it so it basically
106:47 - you define
106:48 - the payload
106:50 - in a structure and then you have files
106:52 - that read it um but anyway if you ever
106:55 - use an event bus you come across these
106:57 - things
106:58 - um and there's something kind of similar
107:00 - to it it might be g you might be using
107:01 - protobuffer but
107:03 - uh it is like an aws um the abs event
107:05 - bus with
107:06 - um to remember what's called eventbridge
107:09 - so that's something that's similar there
107:11 - but you know for this i'm not going to
107:13 - get into those examples and show you
107:15 - because you're never going to touch it
107:17 - at least
107:18 - i've never seen anyone have to touch
107:19 - unless you're developing something for a
107:22 - project but there you go
107:24 - [Music]
107:28 - hey this is andrew brown from exam pro
107:29 - and we are taking a look at cubelet so
107:31 - cubelet is responsible for pod internal
107:34 - api communication via the api server and
107:38 - cubelet is a node agent that runs on
107:40 - every single node
107:41 - that includes both control plane and
107:43 - worker
107:44 - nodes
107:45 - and i know this because i took extra
107:47 - care to know because i wasn't sure for
107:49 - quite a while if it actually ran on the
107:51 - control plane but it does so what is an
107:54 - agent well an agent is a program
107:56 - installed on a server to obscure what
107:59 - occurs for specific programs and to
108:01 - communicate information externally or
108:03 - trigger actions to be performed sounds
108:06 - kind of uh very interesting um so
108:10 - here's an example of a cube
108:13 - where is it cubelet so here's our
108:15 - cubelet and notice that it's on inside
108:17 - of our worker node
108:19 - so cuba performs the following tasks it
108:21 - watches for pod changes
108:23 - uh configures container runtimes to pull
108:25 - images create namespaces and run
108:27 - containers and cubelet uses podspec
108:30 - files to determine what images to pull
108:33 - and containers to run so notice we have
108:36 - this pod spec file there and then it
108:38 - knows to deploy that container into that
108:40 - container runtime but we are going to go
108:43 - even a bit deeper so we can see this
108:45 - because i have another
108:46 - diagram that i created here uh to try to
108:48 - make it even more clear and interesting
108:50 - and now you'll see why we covered grpc
108:52 - so here's grpc in a few different places
108:55 - to show that that's where that
108:57 - communication is happening so for pods
108:59 - cubelet will continuously monitor pods
109:01 - for any kind of changes okay that's how
109:03 - we know something's happened in the pods
109:05 - is because of cubelet cubelet will send
109:07 - back https requests to the api server
109:11 - containers
109:12 - sorry container logs and execution
109:14 - requests so the logging information from
109:16 - your pods uh cubelet's the one that
109:19 - sends that stuff along
109:20 - um for storage cubelet can interact with
109:22 - storage through the container storage
109:25 - interface csi using grpc uh very few
109:28 - diagrams were actually show off um cloud
109:31 - storage interface cloud runtime
109:33 - interface and cloud networking interface
109:35 - so this is the this is the very
109:38 - important diagram showing you those
109:40 - integrations between all that stuff
109:42 - and notice it's communicating using grpc
109:46 - cubelet can interact with the container
109:47 - runtime interface
109:49 - also using grpc
109:52 - and so remember we said that a pod spec
109:55 - file
109:56 - is deployed to um
110:00 - a container and has to go through the
110:01 - container runtime and the reason i show
110:03 - uh the container networking interface
110:05 - over here is just to show you that it's
110:08 - not cubelet this is just another route
110:09 - into the container runtime okay so there
110:12 - we go
110:13 - [Music]
110:17 - hey this is andrew brown from exam pro
110:19 - and we are taking a look at cubectl
110:21 - probably the most important thing when
110:24 - we're learning kubernetes because we use
110:26 - it so much so cubectl is a command line
110:29 - interface tool that lets you control
110:31 - kubernetes clusters so the idea is
110:33 - cubectl is a program where you run you
110:36 - write in commands into your
110:39 - bash bash terminal and it will send http
110:42 - request to the api server onto the
110:44 - kubernetes components or objects if you
110:47 - prefer to call them that and cubectl
110:49 - looks for a file named config in the
110:51 - home directory so notice it says dollar
110:54 - sign home
110:55 - so that's usually the same thing as
110:57 - writing a tilde in linux if you write a
110:59 - like cd tilde it usually goes to home
111:02 - okay
111:03 - and that will be in the dot cube
111:05 - directory and then even though it
111:06 - doesn't show here be like forward slash
111:08 - config
111:09 - and we cover config in a very
111:13 - uh granular detail in this course uh but
111:15 - that's during follow alongs i don't know
111:17 - if i actually make a slide on it so cube
111:19 - ctl has the following syntax
111:22 - the idea is we have cube ctl then we
111:23 - have command type name and flags so
111:27 - let's cover all of these
111:29 - parts okay so the first is command so
111:32 - command is the operation you want to
111:34 - perform
111:36 - and so here you can see example where
111:38 - we're doing copy
111:40 - so the available commands we have is
111:42 - annotation so key value data that can be
111:44 - applied to resources
111:46 - apply so executes manifest files to
111:48 - create and modify kubernetes resources
111:51 - this one we use a lot
111:54 - we have auth so inspect
111:56 - if you are authorized to perform an
111:57 - action and we do show you this one in
112:00 - the course when we're doing role-based
112:01 - access controls to say am i allowed to
112:04 - perform these actions under a particular
112:06 - user when we're setting up their
112:07 - permissions
112:08 - auto scale so it creates an autoscaler
112:10 - that automatically chooses the set
112:12 - number of pods that run in a cluster we
112:14 - definitely covered that in this course
112:16 - cp copy files directories to and from
112:18 - containers actually we didn't do that in
112:20 - this course in the in the labs but
112:23 - it's not too hard to figure out how to
112:24 - do that
112:26 - create so
112:27 - create specific kubernetes cluster level
112:29 - resources
112:31 - most times we're using apply because it
112:33 - creates and modify but in some cases you
112:35 - just never modify particular objects so
112:37 - i guess in some cases we use create but
112:39 - a lot of times you can you just use the
112:40 - word apply instead
112:42 - delete so delete resource files uh file
112:45 - names
112:47 - s-t-a-s-t-d-ins resources and names by
112:49 - resources and label selects we use
112:51 - delete all the time describe show
112:53 - details of specific resources we use
112:55 - that one a lot as well diff
112:57 - the online configuration with local
112:59 - configs i don't think i've never ran
113:01 - that once but uh yeah so there you go
113:03 - for commands oh wait there's more
113:06 - we got edit so edit resource from the
113:08 - default editor
113:11 - execute so execute command with a
113:12 - container we definitely use that one a
113:14 - lot expose expose a resource as a
113:16 - kubernetes service that one we use a lot
113:18 - too get so generally used to get the
113:20 - status of an existing kubernetes
113:22 - resource similar to describe but
113:25 - not as detailed
113:26 - cause to my so print a set of api
113:28 - resources generated from instructions to
113:31 - customization yaml we don't do that in
113:33 - this course but we we do
113:35 - cover what customizes
113:38 - label so update labels on a resource
113:41 - logs so print the logs of a container in
113:43 - a pot or a specific resource patch so
113:46 - update fields of a resource using
113:47 - strategic merge patch a json merge patch
113:50 - or json patch
113:53 - and i mean you can do this i just never
113:55 - patch i would just update a file and
113:57 - then do an apply port forward we
113:59 - definitely use that quite a few times in
114:01 - this course so forward one or more local
114:03 - ports to a pod
114:04 - proxy creates a proxy server between
114:06 - local localhost and the kubernetes api
114:08 - server
114:10 - i'm just going to wipe a bit of this
114:12 - away here run so create and run
114:14 - a container image in a pod scale so
114:17 - setting new size of a deployment replica
114:19 - set replication controller staple set we
114:21 - cover scale when we do auto scale
114:23 - then we have our type so type is the
114:26 - resource type you want to command so
114:29 - this could be deployments
114:30 - resource types can have abbreviations
114:34 - so you might type in deployments or you
114:36 - might just type and deploy same thing
114:38 - with persistent volumes might be pv
114:41 - pods might be p o
114:43 - uh and i think it will also take pod as
114:45 - well so a lot of times i'll just forget
114:47 - to write it with the s on pod and it
114:49 - still seems to work so here is the same
114:52 - example this and this is identical and
114:55 - i'm pointing this out because when i was
114:57 - doing the exam for the kcna
115:00 - i would see
115:01 - code and you do see
115:03 - cube ctl commands we have to pick the
115:05 - right one
115:06 - and i got mixed up because i thought
115:08 - maybe like deploy wasn't an actual
115:11 - command because i just kept seeing
115:12 - deployment when i watched
115:14 - tutorials and i learned stuff
115:17 - so just realize that
115:19 - if you see a word and you know that
115:20 - there's an object like
115:22 - a persistent volume you see pv
115:25 - uh you know you can pretty much guess
115:26 - that it is it exists i don't think in
115:29 - the exam they would just
115:31 - make up a term like try to trick you up
115:33 - by taking a name and like dropping the s
115:36 - and
115:37 - having to guess okay
115:39 - there are over
115:40 - 50 plus resource types so here you can
115:43 - see them all
115:45 - they don't all have a abbreviations
115:48 - but you pretty much learn the ones you
115:49 - need to learn so like ing is a common
115:52 - one
115:53 - sc storage class pv
115:56 - pvc
115:57 - i never write pod to just write the full
116:00 - thing there
116:01 - um so yeah there's a lot of them but you
116:03 - just learn the ones you need to learn
116:04 - okay
116:06 - then you have the name so the name
116:08 - specifies the name of the resource so
116:11 - here we have pod and notice we can
116:13 - actually provide not just one but two so
116:16 - sometimes they take multiples these are
116:18 - case sensitive so just be aware of that
116:21 - if the name is omitted details for all
116:24 - the resources are displayed and very
116:28 - common
116:30 - it's very common like if i only have
116:32 - a single resource so if i create a
116:34 - single pod i know a single pod a lot of
116:35 - times i'll just write cubesat till get
116:37 - pods or describe pods because for
116:40 - describe because i know it's only going
116:41 - to show the one and i do that a lot in
116:44 - this course
116:45 - but often when you have a lot more
116:47 - you'll be specifying the name
116:50 - flags
116:51 - specify optional flags um a flag is a
116:54 - concept for commit like command line
116:57 - interfaces you see them all the time
116:59 - it's this double hyphen followed by
117:00 - something here now you don't have to
117:03 - provide an equals between um the flag
117:05 - and its value
117:06 - um but sometimes i do sometimes i don't
117:09 - when i do and don't it's just random but
117:11 - you'll see me do that throughout the
117:12 - course some command line interfaces are
117:15 - sensitive
117:16 - cube ctl is not you can either have
117:19 - equals or not
117:21 - flags generally start with two hyphens
117:24 - and i know you can't see but there are
117:26 - two hyphens here it's just the font uh
117:28 - group them together
117:29 - sometimes flags have abbreviations with
117:31 - a single hyphen so double double or
117:34 - sorry a hyphen hyphen server is the same
117:35 - as hyphen s
117:37 - and so you know some people just don't
117:38 - want to type as much so they'll use the
117:40 - abbreviated ones
117:41 - available flags will vary based on
117:43 - commands uh sometimes flags can be
117:45 - assigned values
117:47 - uh or do not expect a value at all okay
117:50 - so
117:51 - um yeah
117:52 - there you go oh just one more thing for
117:54 - cube ctl there is really good
117:56 - documentation it isn't uh
117:59 - straightforward how to find it so i just
118:01 - had to point it out that you go to
118:03 - kubernetes i o four slash docs four
118:05 - slash reference four slash generator
118:06 - four slash coupe ctl cube ctl commands
118:09 - uh if you google cube ctl
118:13 - uh kubernetes
118:15 - it's usually the second link and so what
118:16 - i do when i'm looking at google is i
118:18 - just like carefully look for this one
118:21 - underneath because if you get here it
118:22 - has so many examples it's really really
118:24 - useful okay
118:26 - [Music]
118:30 - all right just because it's so tricky to
118:32 - find the cube ctl documentation i just
118:34 - wanted to show you so i typed in cube
118:36 - ctl commands
118:37 - and if you were to click the first one
118:39 - you would end up at the cheat sheets and
118:41 - the cheat sheets are kind of okay
118:43 - but what's a lot better are the commands
118:45 - and now if i go this one i don't know if
118:47 - it goes oh it does right there but
118:49 - usually i'll click on this one here to
118:50 - get to it
118:52 - okay but for whatever reason the cheat
118:53 - sheets are above the commands
118:56 - and the commands show you
118:58 - everything so
119:00 - if i want to
119:03 - apply something
119:04 - we could click apply might have some sub
119:07 - ones there
119:09 - you can go and see a bunch of different
119:10 - examples here
119:12 - so
119:13 - that will help you out quite a bit when
119:16 - figuring out how to use cube ctl
119:18 - [Music]
119:23 - all right let's take a look here at mini
119:24 - cube so it sets up a local single node
119:27 - kubernetes cluster on mac os linux
119:29 - windows for learning purposes and in
119:32 - particular minicube is actually setting
119:34 - up a virtual machine and then running a
119:36 - control plane and worker processes uh
119:39 - within docker as the container
119:42 - layer so um that's one key thing is that
119:45 - it runs in a virtual machine where we'll
119:47 - see other ones they uh operate a little
119:49 - bit differently but minicube is very
119:51 - popular because it's just super super
119:54 - easy to use it's not my favorite i like
119:56 - micro k8s but let's talk about some of
119:59 - the benefits so supports the latest
120:00 - kubernetes release cross platform
120:02 - deploys as a vm a container or on bare
120:04 - metal multiple container run times a
120:07 - docker api endpoint for blazing fast
120:08 - image pushes advanced features such as
120:10 - load balancer file system mounts
120:12 - feature gates add-ons for easily
120:15 - installed kubernetes applications
120:16 - supports common ci
120:18 - environments so continuous integration
120:21 - and so that's kind of example of
120:22 - starting up a mini cube and you can see
120:25 - it's kind of pretty so it gives you an
120:27 - idea how easy it is to use
120:30 - [Music]
120:34 - all right let's talk about another
120:35 - lightweight distribution uh k3s and k3d
120:39 - so k3s is a lightweight tool designed to
120:42 - run
120:42 - production level kubernetes workloads
120:44 - for low resource and remotely located
120:47 - iot and edge devices and bare metal uh
120:50 - it was originally created by rancher it
120:52 - is a sandbox cncf project um so you know
120:56 - like you can use it for testing if you
120:58 - want there's no reason uh you can't
121:01 - but it is a little bit more work uh to
121:03 - utilize um but it's just considered a
121:05 - lightweight distribution right so
121:08 - a few differences is that
121:11 - k3s does not use cubelet but it runs
121:14 - cubelet on the host machine and uses the
121:17 - host scheduling mechanism to run
121:19 - containers k3s uses cube proxy to proxy
121:22 - the network connection to nodes as
121:24 - opposed to k uh kubernetes which uh uses
121:28 - q proxy to proxy network connections of
121:29 - an individual container uh k3s has a
121:32 - tighter security deployment than uh
121:34 - kubernetes because of their small attack
121:37 - plane surface
121:38 - and also one point the only way you'd
121:40 - have a backing store was with sql lite
121:43 - but now apparently you can use
121:45 - a like a miniaturized version of fcd um
121:48 - so the idea is that um k3s has some
121:52 - advantages but comes with some
121:53 - limitations you'll need to investigate
121:55 - for yourself whether it makes sense to
121:56 - use k3s for your use case we're talking
121:59 - about production use case but for
122:01 - testing and development you can use it
122:03 - but just understand that you are
122:04 - developing on a different distribution
122:07 - okay it's not it's not going to be
122:08 - similar uh to um
122:11 - full-blown kubernetes okay so then
122:14 - there's k3d and so this is a platform
122:17 - agnostic lightweight wrapper that runs
122:20 - uh k3s in a docker container because the
122:23 - one above runs in virtual machines and
122:26 - so if you want to run this in a docker
122:27 - container use k3d it helps run scale
122:31 - run and scale single or multi-node k3s
122:33 - clusters quickly without further setup
122:35 - while maintaining a high availability
122:38 - mode right i guess i said virtual
122:39 - machines above but really the above one
122:41 - is actually bare metal i suppose you're
122:42 - like right on a machine not necessarily
122:44 - even with a virtual machine so i really
122:46 - should have said that instead
122:48 - straight onto hardware but that is k3s
122:50 - and
122:52 - k3d
122:53 - [Music]
122:57 - hey this is andrew brown from exam pro
122:59 - and we are taking a look at kind and so
123:01 - kind is another lightweight distribution
123:04 - but it's primarily designed to test
123:06 - kubernetes uh and it helps you run
123:08 - kubernetes clusters locally in a cic ci
123:12 - pipeline using docker's container as
123:14 - nodes so it looks very similar
123:16 - to minicube but you know the key
123:18 - difference here is that it's using
123:21 - docker containers so it is an open
123:23 - source cncf certified kubernetes
123:27 - installer that supports highly available
123:29 - multi-node clusters and builds
123:31 - kubernetes release build from its source
123:35 - um and so you know some people like mini
123:37 - cubes some people like kind i personally
123:39 - like micro
123:40 - kubernetes but it's just another tool
123:42 - and we will give it a go and you'll see
123:45 - it in action
123:46 - um in the fall lungs okay
123:48 - [Music]
123:52 - hey this is andrew brown from exam pro
123:54 - and we are looking at micro kubernetes
123:56 - or micro k8s uh depending on how you
123:59 - like to say it so um before we talk
124:01 - about that let's talk about a few other
124:03 - things like ubuntu so ubuntu is a linux
124:06 - distribution based on debian i'm going
124:08 - to explain why this makes sense here in
124:09 - a moment it seems like a deter but it's
124:11 - not so ubuntu is known for
124:13 - lots of linux programs pre-installed uh
124:16 - one of the easiest links distributions
124:18 - to use more frequent updates more
124:21 - progressive on new linux programs and
124:23 - systems and so here's an example of
124:27 - ubuntu the desktop edition uh but of
124:30 - course you know we would probably be
124:31 - using server or core because we'll be
124:34 - utilizing it for running uh
124:37 - servers right
124:38 - and if you do not know ubuntu is
124:40 - produced by canonical and this is the
124:42 - company behind ubuntu
124:44 - and another project that canonical makes
124:47 - is called snap so snap is a package
124:50 - manager by canonical that can be
124:51 - installed on many different
124:53 - distributions of linux and so here's an
124:55 - example of installing ruby and a lot of
124:57 - times you'll see this classic flag
125:00 - and so this allows access to your
125:01 - system's resources in much the same way
125:03 - a traditional package so without the
125:05 - flag snaps runs in complete isolation it
125:08 - just depends on the state of your
125:11 - uh environment but um sometimes you have
125:13 - to use the flag sometimes you don't
125:15 - so let's talk about micro kubernetes so
125:17 - micro kubernetes or micro k8 as i say
125:20 - mostly throughout this course is created
125:22 - by canonical and is installed using snap
125:24 - that's why we're talking about those two
125:26 - things so you do like a pseudo snap
125:28 - install micro k8s um and
125:31 - i think this is the major reason why we
125:33 - haven't seen as major adoption like
125:35 - minicube as micro kubernetes because of
125:38 - snap and snap is actually really great
125:40 - but just the idea of having to install a
125:42 - package manager manager people go
125:44 - i don't want to do it you know what i
125:45 - mean so
125:46 - and also it's like the only time people
125:48 - do it is that they spin up ubuntu but
125:50 - ubuntu is very popular on all cloud
125:52 - servers providers so it's pretty easy to
125:53 - get a hold of so it is a kubernetes
125:56 - distribution designed to run fast
125:58 - self-healing and highly available
125:59 - kubernetes clusters it is optimized for
126:02 - quick and easy installation of single
126:04 - node multi-node clusters on uh on
126:07 - multiple operating systems including mac
126:09 - os linux and windows as long as you have
126:11 - snap
126:12 - it is ideal for running kubernetes in
126:14 - the cloud local development environments
126:16 - and edge and iot devices you could
126:19 - devices you could use it for production
126:20 - use cases but you probably want to use a
126:22 - managed service for that
126:24 - and if you did use it you'd be using it
126:26 - for um
126:27 - you know a self-hosted right uh so micro
126:30 - kubernetes is a modular design uh you
126:33 - start with nothing and uh you can enable
126:35 - add-ons to quickly use exactly what you
126:37 - need and nothing more uh so i feel like
126:40 - this is like
126:41 - the best way of learning and so we do
126:43 - end up gravitating towards this
126:46 - lightweight distribution when we are
126:47 - doing our fall longs but there you go
126:50 - [Music]
126:54 - okay so we looked at a few different
126:56 - lightweight uh kubernetes distributions
126:58 - and i just want to do a quick comparison
127:00 - here so you can kind of understand the
127:02 - differences
127:03 - of of these things so the first is mini
127:05 - cube which runs in a virtual machine
127:08 - it's intended just for development
127:09 - purposes very easy to use very very
127:12 - popular uh probably the easiest one to
127:15 - utilize okay
127:17 - then there's kind it's designed to run
127:19 - anywhere containers run so anywhere
127:23 - docker is running you can run kind in
127:25 - it's intended just for development
127:26 - purposes it has faster startup times
127:29 - than minicube since it's not spinning up
127:31 - a virtual machine so you have one that
127:34 - runs in a virtual machine you have one
127:35 - that runs in
127:36 - containers then we have a
127:38 - k3s and k3d which are kubernetes
127:42 - distributions by rancher uh they're
127:45 - slightly different in terms of what they
127:46 - start out with like how they work
127:48 - they are still cncf certified all these
127:50 - are cncf certified kubernetes
127:53 - but these ones can be used for
127:54 - production use case the difference
127:56 - between k3s and k3d is this one is
128:01 - basically installed on bare metal
128:03 - or embedded systems and then k3d runs
128:05 - wherever docker runs anywhere that is
128:08 - similar to what kind does it's designed
128:11 - for embedded edge devices or limited
128:12 - resources and we did cover that there
128:15 - are uh some uh design choices that make
128:18 - uh these things limited compared to
128:20 - other
128:21 - things for production use case you have
128:23 - to make a trade on that then we have a
128:25 - micro kubernetes or micro k8s
128:28 - this is created by a canonical the same
128:30 - company that publishes ubuntu you need
128:34 - snap to install it if there is another
128:36 - way it's probably pretty hard to do
128:38 - it's a modular starts with nothing
128:40 - installed restarts everything if there's
128:42 - a crash
128:43 - well suited for
128:44 - self-hosted production use cases so
128:47 - everything here is great for production
128:49 - everything here is great for development
128:50 - but technically you can use all of these
128:53 - for development and even myself i prefer
128:56 - to use micro kubernetes for development
129:00 - and i think it's great because then you
129:01 - know if you do do self-hosted we better
129:03 - reflect that production environment but
129:06 - it's up to you what you want to use
129:08 - and it's going to be depending on what
129:10 - resources you can find so
129:11 - there you go okay
129:13 - [Music]
129:17 - all right let's take a look here at
129:19 - manage kubernetes providers and so these
129:21 - could be something like a cloud service
129:23 - provider or a cloud platform that
129:25 - abstracts away the effort of setting up
129:27 - maintaining like such as updating
129:28 - patching and cluster and they can easily
129:31 - uh perform auto scaling as well
129:34 - so
129:35 - um i mean that's going to vary the auto
129:37 - scaling part but um you know
129:40 - mostly this is how people are setting up
129:41 - the kubernetes they're going to be using
129:43 - a managed provider very common to use a
129:45 - public cloud
129:47 - but we'll talk about the ones that i
129:49 - know about i'm sure there's ones outside
129:50 - of this but these are probably the most
129:52 - popular ones especially if you are used
129:55 - to using csp so the first is google
129:57 - kubernetes engine gke and in my
130:00 - experience this was the easiest to use
130:02 - with the richest amount of features
130:04 - built into the ui right so when i wanted
130:06 - to set up an ingress controller
130:08 - and we did this in the course or
130:10 - or set up a service that goes ingress it
130:12 - was so easy to do
130:15 - um and it just had a really great
130:17 - experience out of all the the big csps
130:20 - next i would probably put amazon elastic
130:22 - kubernetes service um it does have a
130:25 - very difficult uh ui so
130:28 - um
130:29 - aws is like you know sometimes you'll be
130:31 - setting something up and it'll be like
130:33 - you need this thing and so you have to
130:35 - go to this other place and create it
130:36 - first and then go back and so there is a
130:39 - bit of running around however they do
130:42 - have a
130:43 - a cli
130:45 - called
130:47 - eks ctl i believe and it really does
130:51 - make it a lot easier so uh you know it's
130:53 - not really recommended to use the ui and
130:55 - a lot of people doing kubernetes you get
130:58 - used to using cli because because of
130:59 - cube ctl but the real reason i think
131:02 - that amazon elastic community service i
131:04 - put it second is just because it's worth
131:06 - it for the integrations with other awes
131:08 - services because uh you know maybe uh
131:11 - eks is a bit clunky but all the stuff
131:13 - around each of us and that's what you
131:14 - want to be integrating with like your
131:16 - managed database and and your persistent
131:19 - storage and things like that it's just
131:21 - such a great ecosystem that that's why i
131:23 - put it second but google's really really
131:25 - good
131:26 - for cloud native you have azure
131:28 - kubernetes service this was fairly easy
131:30 - to use um you know like its interface
131:33 - wasn't as good as gke but you could
131:36 - basically accomplish things it has some
131:37 - unique offerings like i've seen like
131:39 - debugging live containers which is
131:41 - really cool
131:42 - um and they have good tutorials so like
131:45 - the thing is is that you know even
131:46 - though they're clunky um their
131:48 - instructions are a lot better than aws's
131:51 - and so uh you know works a little better
131:53 - but this is like if you
131:54 - are bought into that microsoft ecosystem
131:57 - so you know all three are are pretty
131:58 - decent i put these at the top three
132:01 - nexus ibm
132:02 - uh cloud kubernetes service also known
132:05 - as iks
132:07 - it's easy to use um beautiful beautiful
132:09 - ui out of all the uis that i saw
132:12 - it wasn't as feature-rich as i was
132:14 - expecting to be and it was very very
132:16 - expensive
132:18 - and so like ibm likes to say it is cost
132:21 - effective because they actually do allow
132:23 - you to spin up a free kubernetes tier so
132:26 - technically
132:27 - um you know for 30 days or or what have
132:30 - you you can actually have a free cluster
132:33 - and this is actually a great way to test
132:34 - out a managed service but the only
132:36 - problem is that the nodes are so darn
132:39 - expensive and so you don't play for the
132:41 - control plane on uh icast or ibm
132:45 - ibm cloud community service but the cost
132:49 - gets so expensive so fast it's like
132:50 - using heroku where it's like it's free
132:52 - entry um the small sap is um
132:56 - uh you know like very inexpensive but it
132:58 - gets super expensive
133:00 - super fast so i generally probably
133:02 - wouldn't recommend unless you are
133:04 - already using ibm and you like using
133:05 - bare metal and you're used to paying
133:07 - those kind of costs okay you have oracle
133:09 - container engine for kubernetes um
133:12 - oracle is known for being highly cost
133:14 - effective out of all these other
133:16 - providers
133:17 - i don't think they charge you for the
133:18 - control plane but honestly their ui is
133:21 - really really bad and they even default
133:23 - it to bare metal when you start to spin
133:25 - it up and if you do that it'll cost you
133:27 - like thousands of dollars so it's easy
133:29 - to make a mistake when setting it up and
133:31 - costing a lot of money
133:33 - and um
133:35 - you know support on oracle is not very
133:38 - good
133:39 - so if you do have a problem and there's
133:41 - a high chance you will you know just
133:43 - being cost effective is not going to
133:45 - help you one thing i remember about ibm
133:47 - cloud was that when i set it up it was
133:49 - really good at estimating the cost and
133:50 - making it very clear what things cost so
133:53 - kudos to ibm for that but even still
133:55 - like still really expensive you have
133:57 - digitalocean kubernetes so d-o-k-s
134:00 - very easy to use predictable spend
134:03 - beautiful ui
134:04 - um
134:05 - and i mean the only thing was that it
134:07 - was a bit like everything was beautiful
134:09 - but it was a bit clunky to use where i
134:11 - was like
134:12 - like you know the experience is like the
134:14 - ui so good but then like the technology
134:16 - kind of fails to deliver the same kind
134:18 - of reliability and so it kind of feels
134:20 - like there's this beautiful ui and then
134:22 - things are a bit clunky behind the
134:23 - scenes that's how digitalocean felt to
134:26 - me but but it was very simple to use
134:28 - you're not going to get that whole
134:29 - ecosystem that a cloud service provider
134:31 - is going to provide you but it is very
134:33 - simple and easy to manage if you're a
134:34 - startup this is a very safe bet for you
134:36 - to use use digital ocean kubernetes so
134:39 - it's not terrible but um
134:41 - uh digitalocean
134:42 - is very very very very good with uh
134:45 - tutorials
134:46 - um and they had some stuff there but for
134:50 - kubernetes i'd say it's probably the
134:52 - weakest i've ever seen them for
134:54 - instructional content they even had a
134:56 - dead link that i had to point out be
134:57 - like hey this goes nowhere so i think
134:59 - it's more of a newer service for them
135:01 - and uh you know as they continue to
135:03 - build up the resources around it it'll
135:04 - be good
135:06 - then you have
135:07 - um it's the most cost effective they
135:10 - don't charge for the control plane
135:12 - um i wouldn't say the ui is beautiful
135:14 - but it's extremely simple so if you
135:16 - don't know what you're doing when you
135:17 - enter there you might be a little bit
135:19 - frustrated at the start
135:20 - um but uh like if you've used it lotion
135:22 - then you'll know how to use sevos um and
135:25 - they do have a nice like labs like
135:27 - instructional content within sivo um but
135:30 - it really is just a cloud platform but
135:32 - different from digitalocean it is
135:33 - specialized just for kubernetes right so
135:35 - they technically do have vms and other
135:37 - stuff on there
135:38 - but it's just it's more focused on
135:40 - kubernetes than any other cloud platform
135:43 - um and so you know there's a lot of
135:45 - trade-offs there you just got to decide
135:46 - what you'd want to use for me i'd be
135:48 - going with eks just because
135:50 - my primary workloads are already there
135:52 - but i really did enjoy a google
135:54 - kubernetes engine for sure but there you
135:55 - go
135:56 - [Music]
136:01 - all right let's take a look here at
136:02 - management layers there's a lot of
136:04 - management layers for kubernetes and
136:07 - some of these might kind of be their own
136:08 - distributions with a platform on top of
136:10 - them
136:11 - so it's really hard to kind of
136:13 - put them in a box but i try to group
136:15 - them separate from distributions as best
136:17 - i could that were pure distributions so
136:20 - management layers are for running
136:22 - kubernetes on other platforms or allows
136:24 - you to extend your control plane to
136:27 - multiple platform and when i say other
136:28 - platforms i mean like
136:30 - um
136:31 - you know like adabus has eks and that is
136:34 - their kubernetes as a service offering
136:36 - but i'm saying like there is no as a
136:38 - service you're just like setting it up
136:40 - on maybe either virtual machines or
136:42 - things like that so let's go walk
136:43 - through them the first is weave
136:45 - kubernetes platform
136:46 - wkp now if you go to the website right
136:48 - now you can't find this exactly it's
136:50 - kind of weird they might have rebranded
136:51 - this as like weave
136:54 - core or something like that but um
136:56 - i just stuck with this name because i
136:58 - preferred it so all of weaves open
137:00 - sources tools packaged as a platform so
137:02 - you can build out a git ops enabled
137:04 - cluster and so what it looked like to me
137:08 - was that they had a lot of ci cd stuff
137:10 - and
137:13 - the idea is like you could set up a
137:15 - cluster relatively easy
137:17 - uh most places and have good governance
137:20 - over them good
137:21 - way of being very uh agile and just
137:23 - start to get to work
137:25 - so that was kind of interesting
137:27 - then there is rafae
137:30 - no idea if that's the correct branch
137:32 - nation but
137:33 - similar to openshift and we'll talk
137:35 - about openshift in a moment but with a
137:36 - larger focus on governance and get ops
137:38 - based management for any kubernetes
137:41 - clusters running on anything including
137:43 - openshift so when you go to the rayfay
137:45 - website uh they'll have this picture of
137:48 - like showing that they can manage
137:49 - anything from anywhere and so the idea
137:52 - is if you buy into their system
137:54 - um you know you just need to learn one
137:55 - interface as opposed to a bunch of them
137:57 - and so that could be very attractive
137:59 - then there's vmware tanzu so wherever
138:01 - vsphere runs you can manage you uh you
138:04 - can manage and deploy and monitor
138:07 - kubernetes cluster
138:09 - my knowledge of vmware is not that
138:11 - strong like i kind of know what vsphere
138:14 - is like it's a thing that you install on
138:16 - your virtual machines it has to do with
138:18 - virtualization so i think of it like
138:22 - you go on aws and i would assume that
138:24 - you install this on bare metal probably
138:26 - that's what you do so imagine you have
138:27 - like bare metal like machines that don't
138:29 - have virtualization installed on it so
138:30 - you install vsphere you press a button
138:32 - that sets a vsphere and you install your
138:34 - license but anywhere there's vsphere is
138:37 - anywhere you could install kubernetes
138:38 - cluster
138:39 - um and then you could emanage it from
138:41 - tanzu so like it makes it it's like a
138:44 - management layer uh anywhere so kind of
138:46 - similar to ray faye but rafe is actually
138:49 - leveraging
138:51 - the actual as a service um offerings so
138:54 - like it will actually leverage eks it's
138:56 - not like
138:57 - uh it's a vm you know what i mean like
138:59 - it's a custom install
139:01 - so there's kind of a difference there
139:03 - then you have these things that are
139:05 - multi-cluster management so first is
139:07 - azure arc and so this allows you to
139:09 - govern compute such as kubernetes like
139:11 - and also virtual machines or sql servers
139:14 - across more than a single cloud service
139:16 - provider on premise or on the edge so
139:18 - it's not kubernetes specific but it is
139:20 - very often used for kubernetes and the
139:23 - idea is we are extending our control
139:25 - plane so we have one interface uh to
139:27 - govern uh compute other places right um
139:30 - and
139:31 - that's really useful i feel like from a
139:33 - compliance standpoint so like let's say
139:34 - you want to run stuff on a bus or
139:37 - somewhere else um but uh you know like
139:39 - it just becomes a lot more complicated
139:41 - if if uh you know from a governance
139:43 - standpoint so it's really nice to have a
139:44 - single tool
139:45 - uh for that okay we have google anthos
139:48 - so this is also multi-cluster management
139:50 - this one in specific
139:52 - is just kubernetes and as far as i
139:54 - understand it's gke so google kubernetes
139:56 - uh um
139:58 - engine but it's extending the uh the
140:00 - cluster to be managed on other
140:03 - uh cloud service providers so like i
140:06 - believe aws i don't think they have
140:07 - azure for some reason or on premise but
140:10 - basically um it takes over vms as far as
140:13 - i understand and then installs uh
140:15 - whatever it installs on that and that
140:17 - allows you to manage everything from
140:18 - anthos um and so
140:20 - you know from kubernetes productive i
140:22 - think it has an edge over azure arc
140:25 - um but it doesn't talk about like
140:26 - governance and stuff like that so maybe
140:28 - for like a security or like compliance
140:30 - standpoint azure
140:31 - might be better but not as nice to use
140:34 - then you have platform nine so this is
140:36 - similar to rayfay but relies more on
140:39 - third party tooling whatever that means
140:40 - but as far as i understand it doesn't
140:42 - leverage native functionality from cloud
140:44 - service providers so it's not using gke
140:46 - or it's not using eks uh it is using
140:50 - some other thing that might be installed
140:52 - on virtual machines to kind of like
140:54 - simulate maybe what google anthos is
140:56 - doing stuff like that um so you know
140:59 - there's the idea there so this is this
141:01 - stuff and then there's two that i kind
141:03 - of want to give a little bit more
141:04 - attention to because they're bigger
141:06 - deals like rancher and openshift so red
141:09 - hat has openshift and it's a platform as
141:11 - a service for kubernetes
141:13 - and so cr openshift is just kubernetes
141:16 - like it's not
141:17 - it's a distribution but the idea is that
141:19 - it is just a commercial platform with
141:22 - kubernetes installed on it and then
141:23 - they've extended like
141:25 - a platform around it to make it really
141:26 - easy to use
141:28 - and what's interesting like when i saw
141:30 - an ibm cloud you could actually launch
141:31 - openshift in ibm cloud and you can
141:34 - probably do in other cloud service
141:35 - providers
141:37 - so the idea here is that they uh they
141:39 - extend cube ctl so they have their own
141:41 - called oc which stands for
141:44 - open shift you think it'd be os but it's
141:46 - oc
141:47 - cli and so it has some additional
141:50 - functionality that makes conveniences
141:51 - easier like rbac which is kind of a pain
141:54 - to set up and they make that a lot
141:55 - easier and things like that you quickly
141:57 - deploy local code to a remote openshift
142:00 - cluster via odo so that's another
142:03 - cli tool they have that makes things
142:04 - easier
142:05 - they have quality assurance pipeline
142:06 - built into the platform so that saves
142:08 - you some time there fixing critical bugs
142:10 - earlier instead of waiting for next
142:12 - kubernetes release that red hat is known
142:14 - for
142:15 - being very very very very good in the
142:17 - enterprise for um rolling up bugs fixes
142:20 - very quickly right because they're used
142:21 - to managing their red hat distribution
142:25 - um and so you know that's really the
142:26 - reason people pay for it is just to make
142:28 - sure that everything's patched and good
142:29 - uh their platform utilizes red hat core
142:32 - os
142:33 - and this is an opera operating system
142:35 - optimized for running containers
142:37 - so that's kind of interesting operators
142:40 - hub is an automated installation tool
142:41 - for one click marketplace other
142:43 - providers like gke is a one-click
142:44 - marketplace so i'm assuming that's even
142:46 - more integrated because it's so
142:48 - opinionated about even like the
142:50 - operating system that it must be really
142:51 - easy to set up um it has a graphical ui
142:55 - for developer consoles that's really
142:56 - nice code ready workspace this was
142:58 - really interesting so like
143:00 - developer environments
143:02 - and we used one in the course cloud nine
143:03 - and we look at uh google's for a bit but
143:06 - um this one is specific for kubernetes
143:09 - right the only thing is like i didn't
143:11 - use it because um
143:13 - red had such a pain to sign up for like
143:15 - i tried signing up for openshift and it
143:17 - couldn't take my canadian postal code
143:19 - and it broke and i waited like a week
143:20 - for them to fix it and they were asking
143:21 - for so much information
143:23 - it was i was not happy about it but like
143:25 - they do have like a 30-day trial but i
143:27 - don't know i thought it was better use
143:28 - cloud9 in that case
143:30 - but it's just very impressive to see
143:32 - that there's a cloud developer
143:33 - environment for kubernetes because like
143:35 - you can't do it on git pod
143:37 - and on any of us we do it because we're
143:38 - running a virtual machine but i mean
143:40 - this one's more optimized for it
143:43 - we have rancher kubernetes engine
143:45 - rke and uh i don't know the logo is not
143:48 - there probably shows up at the end here
143:49 - but it runs entirely within docker
143:51 - containers um rancher is the one that
143:54 - built k3s i don't think it's k3s in
143:56 - particular it's their own just it's
143:58 - another distribution because i would
143:59 - imagine that you'd want the full power
144:00 - of kubernetes it works on bare metal and
144:03 - virtualized servers rk solves the
144:05 - problem of installation complexity a
144:07 - common issue in the kubernetes community
144:09 - installation operation kubernetes is
144:11 - both simplified easily automated it's
144:14 - entirely independent of the operating
144:15 - system and platform you're running as
144:17 - long as you can run a supported version
144:18 - of docker you can deploy and run
144:20 - kubernetes with rke so as far as
144:22 - understand you can bring our key
144:24 - anywhere you want so it's like oh you
144:26 - want to run on aws great make sure you
144:28 - have something like a vm that runs
144:30 - docker right go to google check box
144:32 - docker and uh use that thing and so that
144:34 - gives you a bit more ability there but
144:36 - you know these are the two big ones i
144:37 - would say
144:38 - and that's why i gave them a lot more
144:39 - detail but there you go
144:41 - [Music]
144:45 - so something you're going to keep
144:46 - hearing is a term that is cncf
144:50 - certified kubernetes what does it mean
144:52 - when a distribution has been certified
144:54 - by the cncf well they have this page
144:56 - called software conformance
144:58 - and the idea is that
145:00 - they have this kind of test that you can
145:03 - run
145:03 - that gives a guarantee that your
145:05 - kubernetes does what it says it does
145:07 - that it meets
145:09 - very specific requirements in order to
145:12 - conform
145:13 - uh to
145:14 - what is expected with the open source um
145:17 - kubernetes and so here you can see that
145:20 - there is a lot of distributions like
145:21 - even here it says like 60
145:23 - something i think they say that there's
145:24 - 80 plus
145:27 - over 90 over 90 certified kubernetes
145:30 - offerings but the idea is that if they
145:32 - all are certified then more or less they
145:34 - will work
145:35 - pretty much the same
145:37 - with the expectation of what they are
145:38 - asking
145:39 - and uh there is like a landscape for it
145:42 - here so like i clicked the link
145:43 - somewhere here and it's just another way
145:45 - of opening up and seeing pretty much the
145:47 - same stuff in the cloud native landscape
145:50 - and the way it works is um they have a
145:53 - bunch of instructions here to run the
145:54 - conformance tests and it looks like
145:58 - um it uses this tool called sano buoy
146:03 - and so this is a diagnostic tool that
146:05 - makes it easier to understand the state
146:07 - of kubernetes cluster so this checks for
146:09 - the state
146:10 - and then you actually have the tests
146:12 - which probably reside
146:14 - uh somewhere in here they probably
146:15 - explain that there
146:17 - so just kind of give you an idea what we
146:19 - mean when we say cncf
146:21 - certified distribution okay
146:24 - [Music]
146:27 - all right let's take a look here at
146:29 - container runtime interfaces and to
146:30 - understand that we need to understand uh
146:33 - what's um on top of it and what's below
146:36 - it so the first thing uh when we think
146:38 - about um
146:40 - uh this kind of this kind of layered
146:42 - approach is orchestration so you would
146:44 - have something like either docker or
146:46 - kubernetes and so these orchestration
146:47 - systems will use a container
146:50 - runtime interface now at one point in
146:52 - time docker just meant containers right
146:56 - um but there was work to be had where
146:58 - they started separating out all these
147:00 - components and this is basically where
147:02 - we see container runtime interfaces and
147:04 - container runtimes underneath which are
147:06 - the actual containers
147:07 - and so the idea here is that um
147:10 - you know kubernetes would be utilizing
147:13 - something like either container d um or
147:16 - it would be using something like crio so
147:18 - when we talk about container runtime
147:20 - interface you'll notice that's why i
147:21 - never had an icon
147:23 - uh earlier in the course when we were
147:25 - talking about container time interface
147:27 - because the runtime interface is one of
147:29 - these two okay so container runtime
147:31 - interface allows you to run a variety of
147:34 - different container runtimes and so the
147:37 - cri actually is doing things like
147:38 - pushing and pulling images and
147:40 - supervising examiners it's not the thing
147:42 - that creates and
147:43 - runs the containers what does that is
147:45 - the container run times
147:47 - and the containers that we care about
147:49 - are oci compliance so from the open
147:51 - container initiative
147:53 - and we have two types native runtimes
147:56 - and sandbox slash virtualize runtimes
147:58 - and the major difference between these
148:00 - two types of runtimes between native and
148:03 - virtual is isolation so for virtualized
148:06 - it can provide security benefits through
148:08 - isolization because it's virtual so you
148:10 - can have more controls around it
148:13 - um so you know hopefully that helps make
148:15 - sense that you have an orchestration and
148:18 - that's going to choose a container
148:20 - runtime and then from there it's going
148:22 - to choose
148:24 - a uh interface and then from there it's
148:26 - gonna choose a run time but i think by
148:28 - default when we use kubernetes most
148:30 - times what it's going to be using it's
148:32 - gonna be kubernetes it's gonna be
148:34 - container d and it's gonna be run c and
148:36 - there used to be a lot more container
148:38 - run times but i had to look at each one
148:41 - and i found so many were like
148:43 - no longer maintained and so i think that
148:45 - this is like the new list that you'll
148:47 - mostly see is like run c
148:50 - nabla and
148:51 - uh cata okay
148:53 - [Music]
148:57 - all right let's talk about container d
148:59 - and with these container runtime
149:01 - interfaces
149:02 - um they don't really tell you a lot
149:05 - about how they work internally
149:07 - i tried so hard to find some kind of
149:09 - visual
149:10 - and i just couldn't find anything and so
149:13 - you know if i can't find it then you
149:15 - don't have to worry about it so
149:16 - container d is an industry standard uh
149:19 - container runtime with an emphasis on
149:21 - simplicity robustness and portability
149:23 - and the way it started was it was part
149:25 - of docker and they extracted out their
149:27 - container runtime into the project we
149:29 - know now is container d and then
149:32 - gave it to the cncf
149:34 - so this includes docker functionality
149:36 - for executing containers handling low
149:38 - level storage managing image transfers
149:41 - and container d makes it easier for
149:42 - projects like kubernetes to access the
149:44 - lover docker elements they need instead
149:47 - of actually using docker so when you're
149:49 - building images you uh you aren't
149:51 - actually building uh
149:52 - docker images you're building open
149:55 - container initiatives which has been
149:57 - standardized
149:58 - um for the container industry
150:01 - okay
150:02 - [Music]
150:07 - let's take a look at crio so ciro is an
150:10 - implementation of the kubernetes cri
150:13 - interface to enable oci
150:17 - compatible runtime so the cri stands for
150:20 - container runtime interface and the o
150:22 - stands for
150:23 - oci okay so that's the logic there and
150:28 - it's just an alternative to container d
150:30 - so it's a lightweight alternative to
150:32 - using docker container d as a runtime
150:33 - for kubernetes it allows kubernetes to
150:36 - use oci compliant runtime as the camera
150:38 - runtime for running pods today it
150:40 - supports run c and cathode containers i
150:42 - didn't look at what container d supports
150:44 - for runtimes underneath but that's where
150:45 - you know if you need particular runtimes
150:47 - you might have to choose a runtime
150:49 - interface
150:50 - that you can use
150:52 - and when you use managed providers they
150:54 - might lock you into very particular
150:55 - container runtime interfaces that you
150:57 - cannot swap out so that is something
150:59 - that might matter to you but it really
151:01 - is more like a security and performance
151:03 - thing uh and not so much like
151:04 - functionality wise because things don't
151:06 - seem to be much different
151:08 - um so that's the idea there but yeah so
151:12 - cro is just an alternative container d
151:13 - and you know i wish there was more to
151:15 - say about these container runtime
151:16 - interfaces but that's all i have to find
151:19 - okay
151:20 - [Music]
151:24 - so let's talk about container run times
151:26 - and again there's not a lot to get into
151:28 - detail about container run times but a
151:31 - key thing to understand is difference
151:33 - between virtualized and uh ones that are
151:36 - native runtimes that are utilizing uh
151:39 - the machine directly and so
151:42 - from cata containers they have this nice
151:44 - graphic that makes it very clear
151:46 - visually what the difference is so
151:48 - virtualized runtimes uses lightweight
151:50 - vms for isolation
151:52 - and then native runtimes are
151:54 - on the machine and they're using c
151:56 - groups
151:57 - shared kernels and other things for
152:00 - isolation
152:01 - so
152:02 - you know in that sense when everything
152:04 - is in a lightweight vm you can put a lot
152:06 - more restrictions around it
152:08 - and so that is something that makes it a
152:10 - lot better from a security perspective
152:12 - it confuses me because like i would
152:14 - imagine that um
152:16 - you know like you can run can you run a
152:19 - lightweight vm inside of a vm i don't
152:20 - know um so i don't know if like you just
152:23 - replace the hypervisor with something
152:25 - like lxc which is something we actually
152:27 - do talk about
152:28 - um in the section of this course is like
152:30 - um linux containers
152:32 - um where it's not full virtualization
152:34 - it's lightweight virtualization so i
152:36 - imagine that's probably the difference
152:38 - but i just couldn't find definitively if
152:40 - that was the truth um so let's just talk
152:43 - about run c which is a native container
152:45 - runtime so it's a low level container
152:46 - runtime that creates and runs containers
152:49 - and it would be used alongside container
152:50 - d or crio that's all i could really tell
152:53 - you about it um so imagine you have
152:55 - container d and remember container d or
152:58 - cri
152:59 - basically similar
153:00 - it's a daemon process that manages and
153:02 - run containers pushes and pulls images
153:04 - managing storage and networking
153:05 - supervises the running of containers and
153:07 - then you have your container run time
153:09 - like let's say run c which creates and
153:10 - runs containers so just reiterating that
153:13 - i know we said it like three times but
153:14 - just make sure you know the difference
153:16 - between a container runtime interface
153:18 - and a container time okay
153:20 - [Music]
153:25 - hey this is andrew brown from exam pro
153:27 - and we are taking a look at c groups so
153:30 - what is a c group well we have to answer
153:32 - what is a process first so a process is
153:34 - an instance of a running program on
153:37 - linux so then what is a c group well c
153:40 - group stands for control groups and
153:42 - allows you to group processes to apply
153:45 - different kinds of limitations
153:48 - so limitations could be things like
153:50 - resource limiting so groups can be set
153:53 - to not exceed a configured memory limit
153:55 - which also includes file system cache
153:57 - prioritization so some groups may get a
154:00 - larger share of cpu utilization or disk
154:02 - input output throughput
154:04 - accounting so measures a group's
154:06 - resources usage which may be used for
154:09 - example like billing purposes controls
154:12 - so freezing groups of processes
154:16 - so they're checkpointing and restarting
154:17 - so think of c groups as a way to limit
154:20 - programs on linux from overusing cpu
154:23 - membrane storage
154:25 - and the reason we're learning about c
154:27 - groups is because of linux containers so
154:30 - the primary goal uh design goal of c
154:32 - groups was to provide a unified
154:34 - interface to manage processes or whole
154:37 - operating system level virtualizations
154:39 - including linux containers and um you
154:42 - know i came across c groups
154:44 - even recently when i was using git pods
154:47 - because i wanted to run kubernetes on
154:49 - git pods but i found out that uh at the
154:51 - time and probably still that
154:54 - they're using docker with a version
154:56 - that is using c groups version one and
154:59 - so to support
155:00 - uh kubernetes the run within docker
155:02 - which is kind of weird running docker
155:04 - inside kubernetes to run docker um
155:07 - uh it needed version two so c groups is
155:09 - something you definitely will come
155:10 - across and so that's why i mention it to
155:14 - you here
155:15 - [Music]
155:19 - hey this is andrew brown from exam pro
155:21 - and we are talking about linux
155:22 - containers so linux containers is an os
155:25 - level virtualization technology that
155:27 - allows creation and running of multiple
155:29 - isolated linux virtual environments on a
155:32 - single
155:33 - control host and so the idea is that
155:36 - linux containers or
155:38 - virtual environments in particular are
155:40 - paired against virtual machines quite
155:43 - often because
155:45 - i mean the idea is virtual environments
155:47 - are more lightweight so why would you
155:48 - use one over another so virtual
155:50 - environments there is no pre-loaded
155:53 - emulation manager software as a virtual
155:56 - machine in a virtual environment the
155:58 - application or os is spawned in a
156:01 - container and runs with no added
156:03 - overhead except for
156:05 - a usually minuscule virtual environment
156:08 - initialization process there is no
156:10 - hardware emulation which means that
156:12 - aside from the small memory
156:14 - uh
156:15 - small software penalty
156:17 - lxc so linux containers will boost bare
156:20 - metal performance characters because it
156:22 - only packages the needed application and
156:25 - uh ves i didn't capitalize e on that
156:27 - cannot be easily managed via neat
156:30 - gui management consoles and they don't
156:33 - offer some neat features of virtual
156:35 - machines such as infrastructure as a
156:37 - service setup and live migration so i
156:41 - definitely didn't rework this text
156:42 - wherever i got it from
156:44 - that's what it is plain but i just
156:46 - wanted to mention linux containers
156:47 - because
156:48 - you know
156:49 - uh it is a
156:51 - type of virtualization for containers
156:54 - um
156:54 - uh it's quite popular there and i came
156:57 - across it somewhere in the course and so
156:59 - i just had to figure out what it was
157:00 - okay
157:05 - hey this is andrew brown from exam pro
157:07 - and we are taking a look at container
157:09 - storage interface also known as csi
157:12 - and what csi does is it standardizes how
157:16 - container orchestrator system so cos
157:20 - access to various source providers now i
157:23 - don't find
157:24 - that this is a very common initialism
157:27 - but
157:28 - i found it so i just put it in there so
157:30 - a container orchestrator system is on
157:32 - one side on the other side we have our
157:34 - storage providers and in between we have
157:37 - our cloud storage interface so container
157:40 - orchestrator systems could be things
157:42 - like mesos
157:43 - kubernetes and docker swarm so we know
157:46 - what kubernetes is mesos was like um
157:49 - a very early orchestrator system
157:52 - very modular and things like that
157:55 - i think it's still kind of in use but i
157:58 - don't know
157:59 - if they'll stay around for long because
158:01 - a lot of people moved over to kubernetes
158:03 - and then docker swarm is
158:05 - kind of like a competing thing for
158:06 - kubernetes because docker
158:09 - didn't really do orchestration the same
158:10 - way that kubernetes did but now it came
158:12 - with docker swarm so storage providers
158:14 - would be things like azure disk aws
158:17 - elastic block storage
158:19 - netapp trident uh openstack uh
158:22 - cinder google cloud storage there's over
158:25 - a hundred plus storage and plug-in
158:28 - drivers
158:30 - and so um
158:31 - you know the csi is
158:34 - uh essentially what we're using when we
158:37 - are using persistent volumes okay
158:39 - because persistent volumes are pretty
158:41 - much dealing with block storage and
158:44 - um you know most of these plugins are
158:46 - block storage i'm sure there's object
158:48 - storage in there as well
158:50 - and the cloud search interface is not
158:52 - something you really have to worry about
158:53 - because it's kind of abstracted away but
158:56 - if you were to develop a
158:58 - uh your own search provider then you
158:59 - would have to know how the container
159:01 - storage interface worked because you
159:03 - have to make it compatible with it in
159:04 - order to provide your um your volume
159:08 - okay
159:09 - [Music]
159:13 - hey this is andrew brown from exam pro
159:15 - and we are looking at kubernetes backing
159:16 - store and fcd so components of
159:19 - kubernetes clusters including pods nodes
159:21 - control planes volumes
159:22 - all sorts of things need a level
159:24 - protection in case of disaster we need
159:26 - to store the state of what our stuff is
159:29 - in case we need to recover it so what
159:31 - kubernetes does is it uses or it stores
159:35 - the state data inside something called
159:38 - at cd which is a key value star which
159:40 - we'll talk in a moment but it is
159:42 - possible to uh back
159:45 - or use a different backing storage like
159:47 - mario db i have no idea how but i know
159:49 - that it's possible and so application
159:51 - data is stored in persistent volumes for
159:54 - applications running on clusters
159:56 - but understand that the the resources um
159:59 - are like the state of those are stored
160:01 - in a key value store so fcd is a
160:04 - strongly consistent distributed key
160:06 - value store that provides a reliable way
160:08 - to store data that needs to be accessed
160:10 - by its distributed system or clusters of
160:13 - machines and xcd resides in the control
160:16 - plane node and you need to know that's
160:18 - where it is
160:19 - so
160:20 - lcd is not just used
160:23 - for the backing storage it's used by
160:26 - some
160:27 - other projects so obviously the
160:29 - kubernetes cluster uses it because of
160:31 - the control plane core dns uses it
160:34 - rook uses it
160:36 - but you don't see it used for other
160:37 - things it's a key value store and it
160:39 - serves its purpose
160:40 - like in these cases okay
160:42 - [Music]
160:46 - hey this is andrew brown from exam pro
160:48 - and we are looking at min io and rook
160:51 - and the reason i want to look at them is
160:53 - because
160:54 - uh you might see them as options on the
160:56 - exam and if you know what they are it's
160:57 - going to really help you determine what
160:59 - the right answer is
161:01 - rook and midnight
161:02 - are two things that we do not cover in
161:04 - the fall longs because they're a little
161:06 - bit too complex to set up
161:08 - and they're interesting because
161:10 - like
161:11 - they are basically
161:13 - um
161:14 - i would say like special types of
161:15 - storage
161:17 - um but we'll talk about what they are so
161:18 - you kind of understand so rook turns
161:21 - distributed storage systems into
161:22 - self-managing self-scaling self-healing
161:25 - storage
161:26 - services it automates the task of the
161:29 - storage administrator so deployment
161:30 - bootstrapping configuration provisioning
161:32 - scaling upgrading mitigation disaster
161:34 - recovery monitoring and resource
161:37 - management
161:38 - and it can use things like cipher fs i
161:41 - believe and things like that but
161:43 - basically as it says it's distributed
161:46 - storage systems okay so we think of pods
161:49 - pods are generally backed by block
161:51 - storage
161:52 - but this kind of stuff is not attached
161:55 - to a specific pod it's just
161:57 - distributed storage that you'd use
162:00 - maybe this would be for like data
162:02 - pipeline workloads or things like that i
162:04 - don't know i didn't i haven't deployed
162:05 - rook but i just know that i've seen the
162:08 - word on the exam so i wanted to point
162:10 - out kind of what it was
162:12 - min i o is a lot more clear to me its
162:14 - use case so it offers high performance
162:16 - s3 compatible object storage so it's
162:19 - essentially object storage um and it has
162:22 - a
162:23 - um
162:24 - it says s3 compatible basically works
162:26 - just like s3 so it's native kubernetes
162:29 - so mini o is the only object storage
162:30 - suite available in every public cloud
162:33 - uh i i mean anywhere that you can deploy
162:36 - kubernetes basically uh you can use it
162:38 - so min io is software defined 100 open
162:41 - source under uh new apgl version 3. so i
162:46 - really like the idea of min io it's i
162:48 - really like s3 so
162:50 - midio is an easy sell for me
162:52 - but yeah that's all those two things are
162:54 - okay
162:55 - [Music]
162:59 - hey this is andrew brown from exam pro
163:01 - and we are looking at volume so
163:02 - kubernetes supports many types of
163:04 - volumes and a pod can use any number of
163:07 - uh volume types
163:09 - simultaneously so let's talk about the
163:11 - different types we've got persistent
163:12 - volume so these this is when you're
163:14 - attaching external storage to a pod and
163:17 - the data will persist even if the pod is
163:19 - terminated we have a fearable
163:22 - i i have looked this up before but i
163:24 - just can't remember how to say
163:26 - ephermal volumes so volume that only
163:29 - exists as long as the pod exists
163:32 - intended for temporary data storage so i
163:35 - mentioned here but we don't actually use
163:38 - it in the kcna
163:40 - as an example projected volume so maps
163:43 - several existing volume sources into the
163:44 - same directory and volume snapshots so
163:47 - archiving
163:48 - a volume configuration and it's data for
163:51 - roblox or
163:53 - backups so uh yeah in the kcna i don't
163:57 - show follow along on doing volume
163:59 - snapshots but they're not that
164:00 - complicated they're not covered in the
164:02 - exam
164:04 - and one thing that's not here is pvc we
164:06 - cover it in the course i'm just not
164:07 - messing it here because it's not a
164:09 - volume it's a way of claiming a volume
164:12 - now these are
164:13 - types of volumes but there's also types
164:16 - of volumes that are supported that you
164:17 - can
164:19 - be backed by right so the idea is
164:21 - persistent volume attaches to a storage
164:23 - class and
164:24 - um you know it has to be something right
164:27 - so here we have elastic block store
164:29 - azure disk azure file cepher i think
164:31 - that's how i pronounce the stuffer
164:33 - cinder config maps
164:36 - um
164:37 - maybe local storage nfs
164:40 - secrets
164:41 - we have the persistent volume claim
164:43 - so
164:45 - you know there's a lot of stuff there
164:48 - and you don't need to remember the whole
164:49 - list but you will in practicality
164:52 - understand when we use um a storage
164:55 - class and we have a persistent volume
164:57 - and we have it attached to something
164:58 - okay
165:03 - hey this is andrew brown from exam pro
165:05 - and we are taking a look at persistent
165:07 - volumes so a persistent volume or pv is
165:10 - a piece of storage in the cluster
165:12 - that has been provisioned by
165:14 - administrator or dynamically provisioned
165:16 - using storage classes so here is my
165:19 - diagram and so a pv is similar to a node
165:22 - in that it's a cluster
165:25 - resource okay
165:27 - so um when i say that
165:29 - a persistent volume does not reside
165:32 - within a node or a pod
165:34 - um
165:35 - and i want to point out that this
165:37 - diagram here is technically not accurate
165:40 - i just had it as a simplification and
165:42 - also while i was learning kubernetes um
165:46 - it wasn't clear to me that you had to
165:48 - have a persistent volume claim
165:50 - and only when i did the follow-alongs do
165:53 - i realize that you always 100 have to
165:55 - have one
165:56 - um but there are diagrams out there that
165:58 - don't show the pevc so um i thought this
166:01 - was accurate at the time that i made it
166:02 - but i still left the sense just so i
166:03 - could say that this was technically not
166:05 - accurate and that sometimes you'll see
166:08 - um diagrams that do not have a pvc okay
166:12 - and we'll talk about pvc in the next
166:13 - slide so don't worry if it doesn't make
166:15 - sense right now or future slides here so
166:18 - uh persistent volumes are volume
166:20 - plug-ins like volumes but have a life
166:22 - cycle independent of any individual pod
166:26 - that uses the persistent volume so the
166:29 - idea is if the pod goes down the
166:31 - persistence persistent volume
166:33 - can still rebate
166:36 - it really depends on your reclaim
166:39 - type or uh yeah how you want to reclaim
166:41 - it so the api objects captures the
166:43 - details of the implementation of the
166:44 - storage
166:46 - be that nfs
166:47 - iscsi or a cloud provider specific
166:50 - storage system mounting persistent
166:52 - volumes directly to a pod is not allowed
166:55 - and is against the kubernetes design
166:56 - principles it would cause tight coupling
166:59 - below the pod volume and the underlying
167:01 - storage that's why we need a persistent
167:03 - volume claim to ensure decoupling so
167:06 - there you go
167:08 - [Music]
167:12 - all right let's take a look at storage
167:14 - classes so a storage class is a way of
167:16 - defining a class of storage that is
167:17 - backed by a provisioner and so here's an
167:20 - example diagram
167:22 - that we have here and just notice that i
167:24 - don't have pvc in here because again
167:28 - some diagrams online do not show the pvc
167:31 - but they are always always there and we
167:34 - will address that when we get to the pvc
167:35 - which probably is the next slide
167:38 - and so to set up a storage class the
167:41 - idea here
167:42 - is um we need to define a few things so
167:45 - we need to define the provisioner so who
167:47 - is this from
167:49 - uh so this is from aws so it's going to
167:52 - elastic block store
167:54 - parameters what type of storage so to
167:57 - use so in this case we are saying use
167:59 - the gpu type of elastic block store on
168:01 - aws
168:02 - you have the reclaim policy so
168:05 - you know if the pod is deleted it should
168:09 - retain the persistent volume it should
168:11 - not
168:12 - vanish
168:13 - notice the storage class is just like uh
168:16 - defined and then it's um associated with
168:19 - a persistent volume
168:21 - so it can be
168:23 - that way there but notice that a storage
168:26 - class doesn't define one volume but it's
168:29 - just saying like okay persistent volume
168:31 - you're going to be using elastic block
168:33 - and you're going to be using the elastic
168:34 - block but they have their own
168:37 - block storage for each of those okay
168:41 - [Music]
168:45 - okay so we kept on mentioning persistent
168:46 - volume claims and here we are pvc so a
168:49 - persistent volume plane is used to
168:51 - decouple persistent volumes from pods
168:53 - and a pvc
168:55 - uh will ask for a type of storage and if
168:58 - a persistent volume meets that criteria
169:00 - it is matched and the persistent volume
169:03 - is then claimed and bound
169:06 - okay
169:07 - so
169:08 - what does that mean well if we go down
169:09 - below here the idea is we have our
169:12 - persistent volume claim and we're saying
169:14 - i want
169:15 - um i want a elastic block store and it
169:19 - has to be at least
169:21 - uh 500
169:23 - megabytes and then the persistent volume
169:25 - says oh well i have a 30 gigabyte one
169:27 - here so match up to me that's the idea
169:29 - there so
169:31 - pvcs are similar to a pod requesting
169:33 - resources from a node so pods consume
169:36 - node resources so a persistent volume
169:39 - claim consumes persistent volume
169:40 - resources pods can request specific
169:43 - levels of resources like compute and
169:45 - memory as i was describing here and a
169:47 - persistent volume claim can request
169:49 - specific sizes and access modes
169:52 - uh and here's an example of a persistent
169:54 - volume claim
169:55 - uh notice that the storage class is
169:58 - mentioned sometimes i see it there
169:59 - sometimes i don't
170:01 - um
170:02 - sometimes i see it with like a double
170:05 - quotation
170:06 - so
170:07 - you know just be aware there are some
170:09 - variants there not something super
170:11 - important to understand
170:13 - right now
170:14 - um but yeah i mean that should be clear
170:17 - uh yeah there's also the storage type so
170:19 - this one would match on the storage type
170:20 - and the access mode to
170:23 - find it so there you go
170:25 - [Music]
170:29 - hey this is andrew brown from exam pro
170:31 - and we are taking a look at config maps
170:33 - so config maps is an api object used to
170:35 - store non-confidential data in key value
170:38 - pairs for pods
170:39 - pods can consume config maps as
170:41 - environment variables command line
170:43 - arguments configuration files in a
170:45 - volume and so here is an example of one
170:48 - and we do use this one in the follow
170:50 - along uh but the idea here is that you
170:53 - have a section i mean you define the
170:55 - config map you define your data uh and
170:59 - notice that you can have a key and a
171:01 - value and then for some uh there's ones
171:04 - that are multi-line that get interpreted
171:05 - a particular way when you parse them
171:08 - so
171:09 - here's an example of config map and just
171:11 - notice that you can use a config map
171:13 - for more than a single pod
171:16 - a config map allows you to decouple
171:17 - environment specific configuration from
171:19 - your container images so that your
171:20 - applications are easily portable so yeah
171:23 - you are passing along basically
171:25 - environment variables or things to
171:28 - provide application configuration
171:30 - [Music]
171:34 - hey this is andrew brown from exam pro
171:36 - and we are taking a look at kubernetes
171:38 - services so kubernetes services allow
171:41 - you to attach a static ip address and a
171:43 - dns name for a set of pods and a
171:46 - kubernetes service allows you to persist
171:48 - an address for a pod even if it dies and
171:51 - the service also acts as a load
171:54 - balancer and i kind of regret not having
171:57 - like something that looked a little bit
171:59 - more like a load balancer by like having
172:01 - a second
172:03 - uh lined a drag layer to show load
172:04 - bouncing but
172:06 - i mean that's the way i designed the
172:08 - icon but here you can see
172:11 - we have a service we have endpoints so
172:13 - that's basically um the storing of the
172:16 - public ip address
172:17 - so that we can map the service to the
172:19 - pod
172:20 - and you can see that this will have i
172:22 - mean i didn't write it in here but this
172:24 - would actually have a static ip address
172:25 - that never changed and then it would
172:27 - randomly distribute to the ones there a
172:30 - pod without a service will have a
172:31 - dynamic ip address so when the pod dies
172:34 - so does the ip address so that is the
172:37 - reason we want a service so that doesn't
172:39 - happen kubernetes services have the
172:41 - following service types we have cluster
172:43 - ip this is the default if you don't
172:45 - specify a type it will be a cluster ip
172:48 - it randomly forwards traffic to any pod
172:50 - set with the target port you have
172:52 - headless sends traffic to a very
172:54 - specific pod when you have stateful uh
172:57 - pods like a database and we covered
172:59 - headless
173:02 - in the stateful set section there where
173:04 - it doesn't assign a static ip address it
173:06 - doesn't do load balancing it just gives
173:08 - you
173:09 - like a dns hostname resolution so you
173:12 - can specify the pod that way
173:15 - we have node port so external service
173:17 - that allows you to use a
173:19 - worker node ip address so it's a way of
173:22 - exposing
173:23 - um
173:24 - the node like with like opening a port
173:26 - on the node because generally a cluster
173:28 - ip you know it's internal so you have to
173:31 - access it within the cluster but we'll
173:33 - talk about that when we get to
173:36 - that slide there we have load bouncer
173:38 - similar to no port except leverages
173:39 - cloud service providers load balancers
173:42 - and then we have external names so a
173:43 - special service that does not have
173:45 - selectors and uses dns names instead and
173:48 - this is uh used when let's say you had
173:50 - you have a database
173:53 - um like a managed database like from aws
173:55 - rds or google cloud spam or something
173:57 - like that
173:58 - and you can't point to an ip address and
174:01 - you need to point to a dns name so use
174:02 - an external name to point to external
174:04 - resources
174:06 - [Music]
174:10 - all right let's talk about traffic
174:11 - policies for services so a service
174:14 - allows you to set a traffic policy to
174:15 - determine how ingress traffic is routed
174:18 - there are two types of traffic policies
174:20 - external traffic policies so how traffic
174:23 - from external sources is routed and has
174:25 - two valid values cluster so route
174:28 - traffic to all the ready endpoints
174:30 - local so
174:32 - only route to ready node local endpoints
174:35 - we have internal traffic policy so how
174:38 - traffic from internal sources is routed
174:40 - and has the same values above cluster
174:42 - and local so if the traffic policy is
174:44 - local then there are no node local
174:46 - endpoints then then q proxy
174:49 - uh does not forward any traffic for rel
174:52 - relative servants uh relative relevant
174:54 - services we do not cover this in the
174:57 - fall along traffic policies we do not
174:58 - need to create one
175:00 - but i just wanted to point it out
175:02 - because i think i saw the term on the
175:03 - exam and it wasn't an answer but i just
175:06 - saw it and i just wanted to include that
175:08 - so you knew what it was
175:10 - [Music]
175:15 - let's take a look at the cluster ip
175:16 - service type so cluster ip is the
175:18 - default service type so if you don't
175:20 - specify one this is what you're going to
175:21 - get it is used for internal traffic
175:24 - external traffic will not reach the
175:26 - service so traffic will be randomly
175:29 - distributed to any targeted pod so
175:31 - here's an example where we have internal
175:33 - traffic it goes to proxy um which goes
175:37 - to our cluster ip to your pods so
175:39 - traffic originating from within the
175:41 - cluster will pass through
175:42 - the nodes kubernetes proxy and then onto
175:46 - the kubernetes service that's where it's
175:47 - using something like iptables or stuff
175:50 - to do
175:52 - the load balancing but we can use that
175:54 - or ipvs which we do cover in this course
175:57 - if you emit the emit the type it will be
175:59 - cluster ip but here i am explicitly
176:02 - specifying it a service can span
176:05 - multiple worker nodes for cross node
176:07 - pods
176:08 - and that is not just specific to
176:12 - cluster ip that's all of them which i
176:14 - should have mentioned in the service
176:15 - section there but just taking a look
176:18 - here over on the right hand side
176:20 - we have our port and our target port so
176:22 - our target port is
176:23 - the port that we want to target on the
176:25 - pod so if we're running a web
176:27 - application on port 8080 that would be
176:29 - the target pod and if we wanted to um
176:34 - send traffic
176:36 - to a particular port like port 80 it
176:38 - would ford over to the 8080 port okay
176:43 - so hopefully uh that is pretty clear so
176:47 - when would you use the cluster ip well
176:49 - for debugging testing internal traffic
176:53 - internal dashboards but honestly like
176:55 - when i was doing the follow alongs there
176:56 - were cases where there were there were
176:58 - ways of
176:59 - um
177:01 - there were there was lots of use cases
177:02 - for a cluster ip but this is what
177:05 - kubernetes tells us that it's used for
177:07 - so that's what i wrote there okay
177:09 - [Music]
177:14 - let's take a look at node port service
177:16 - so notepad allows you to expose a port
177:18 - for a virtual machine a node running
177:20 - pods that the service is managing and so
177:23 - the idea is this is what a way we can
177:25 - get external traffic and it's the
177:27 - easiest way to get a traffic in but not
177:30 - necessarily the recommended way for
177:32 - production use cases
177:34 - and over here this looks a lot similar
177:36 - to our cust or cluster ip manifest file
177:39 - but here we're specifying node port and
177:42 - now it has
177:43 - this target port so there is no external
177:46 - load bouncer so node port is intended
177:48 - for single community service and for
177:50 - non-production workloads um and since i
177:53 - have the diagram here i'm just going to
177:54 - quickly explain how these three ports
177:55 - work and then we'll go and look at a
177:57 - more verbose text description so that we
178:00 - just are we're very familiar with these
178:02 - three numbers so node port is the port
178:04 - that you're exposing the node on the
178:06 - machine so that the traffic can reach it
178:09 - to
178:10 - port is the service port so the port
178:13 - that you have to hit internally to reach
178:16 - the pods and the target port is the port
178:18 - here that uh is our application is
178:21 - listening on so i write 8080 but this
178:23 - one says 80. okay
178:25 - so just to reiterate because it is kind
178:27 - of confusing and i just want to give it
178:29 - some extra attention
178:31 - port port exposes the kubernetes service
178:33 - on the specified port within the cluster
178:35 - other pods within the cluster can
178:37 - communicate with the service on the
178:39 - specified port target port is the port
178:42 - on which the service will send requests
178:44 - to
178:45 - that the pod will be listening on your
178:48 - application
178:49 - in the container will need to be listing
178:51 - on this port also node port no port
178:54 - exposes a service externally to the
178:56 - cluster by means of the target
178:58 - target node's ip address and node port
179:01 - node port is the default setting if the
179:03 - port field
179:05 - is not specified so there you go
179:08 - [Music]
179:12 - all right let's take a look at the load
179:14 - balancer service type this allows you to
179:16 - use an external load bouncer and the
179:18 - external load balancer handles the
179:20 - routing and traffic distribution logic
179:22 - so the idea an external load bouncer
179:24 - could be something like the aws network
179:26 - load bouncer which would be managed by a
179:28 - third
179:29 - party cloud service
179:31 - and so the example here is we are
179:33 - specifying type load balancer
179:35 - and then the status here the load
179:37 - balancer is we're specifying the ingress
179:39 - so like the ip address i suppose of the
179:42 - load balancer
179:43 - and then sometimes we have to specify
179:45 - the cluster ip
179:47 - i'm a bit confused about this because
179:51 - in the follow alongs we generally use
179:53 - ingress
179:54 - instead of load balancer and ingress
179:56 - seems to utilize um
179:59 - the load balancers of a
180:01 - like a cloud service provider
180:03 - so
180:04 - probably people don't use load balancer
180:08 - often or at all
180:10 - and then when i do see them in the
180:12 - documentation they're describing
180:14 - level three or four load balancers
180:17 - so
180:18 - this isn't at the application layer so
180:21 - maybe there is a case for it maybe
180:22 - ingress came later and then this just
180:25 - became kind of mute but it is a type of
180:28 - service so we do learn how to do it uh
180:30 - load balancer type is well suited for
180:31 - production workloads generally it's
180:33 - recommended to use the kubernetes
180:34 - ingress as i just said here
180:36 - [Music]
180:40 - let's take a look at the headless
180:42 - service type and we've already had
180:44 - exposure to this a couple times but
180:45 - let's talk about one more time a
180:47 - headless service is a service with no
180:49 - cluster ip address a headless service
180:52 - does not provide load balancing or proxy
180:54 - proxying
180:55 - so the idea is you have a cluster
180:58 - you have a kind which is cluster so even
181:01 - though we don't specify it is still a
181:03 - cluster ip kind but we are specifying
181:06 - cluster ip none okay so that's what
181:09 - makes it
181:10 - headless
181:11 - so head lists are useful when you are
181:13 - dealing with a stateful application so
181:15 - like reads and rights and you need the
181:16 - rights to go to a specific pod
181:19 - so here is a diagram that is different
181:21 - from the one that we saw earlier but
181:23 - makes the point clear where you have the
181:25 - headless service
181:27 - it's pointing to a pod and the way it
181:29 - works is the naming is based off of
181:32 - um the pod and the service if you have
181:36 - pod one it's called that
181:38 - and then uh the server the headless
181:40 - service called h serve that's gonna be
181:41 - the dns record that you use how the
181:44 - services need to manage network identity
181:45 - for uh for or of the stateful pods by
181:49 - signing a dns record teach pod so you
181:51 - can route traffic to a dns hostname so
181:55 - there you go
181:56 - [Music]
182:00 - hey this is andrew brown from exam pro
182:02 - and we are looking at the external name
182:05 - service type so external name services
182:07 - is the same as a cluster ip service with
182:09 - the exception of instead of returning a
182:11 - static ip it returns a cname record so
182:14 - what is a c name record
182:16 - well stands for
182:18 - canonical name
182:20 - record and it's a dns record that maps
182:22 - one domain name an alias
182:25 - to another one a canonical name
182:28 - and so an idea here would be
182:31 - a cname would be like
182:32 - mydatabase.example.com
182:36 - which would point to like if you had um
182:39 - a pod that was trying to call out to
182:42 - that um
182:43 - domain name the cname would route it to
182:45 - the external service
182:47 - and
182:48 - that's how that would work though here
182:50 - i'm showing pods so
182:53 - um
182:55 - i mean maybe it would make more sense if
182:57 - the arrows went this way
182:59 - but anyway the point is is that it's
183:02 - used for
183:04 - routing things to external services so i
183:07 - don't show it here but imagine you have
183:10 - rds okay rds you cannot sign an ip
183:14 - address it has like
183:16 - a a fancy dns host name so you would put
183:18 - rds host name here
183:20 - and so when the pod
183:23 - in your application code would hit this
183:24 - address it would go to the external
183:26 - service
183:27 - and that's how it would know where to go
183:30 - all right so really this should be
183:32 - pointing to this i suppose okay
183:35 - but you know hopefully that is clear it
183:37 - is very clear in the follow alongs
183:38 - because we talk about it a few times
183:40 - okay
183:42 - [Music]
183:46 - hey this is andrew brown from exam pro
183:48 - and i want to point out a very
183:50 - particular command for cube ctl
183:52 - that has strong relationships to
183:54 - deployments to services and this is the
183:56 - exposed command so expose is used to
183:59 - quickly create
184:00 - kubernetes services for deployment so
184:03 - here it is and uh we do it quite a few
184:05 - times where we'll type cube ctl expose
184:08 - then the deployment then the app
184:10 - sometimes the documentation will show it
184:12 - like this we'll say deployment
184:14 - forward slash my app again that's just a
184:17 - alternative syntax that you can use you
184:19 - can definitely use spaces you could say
184:21 - deploy and then the app probably works
184:23 - with replica sets as well but honestly
184:25 - you should always be using deploys
184:26 - anyway
184:27 - but the idea here is that it just allows
184:29 - you to quickly create a service and
184:31 - attach it
184:32 - so that it points to the pods of a
184:34 - particular deployment so here what you
184:36 - can see is that we are setting up one
184:39 - that is a node port service we're
184:41 - setting the name the port the target
184:43 - port the node port i'm assuming i got
184:45 - that right and i wasn't supposed to put
184:46 - a hyphen in between there or something
184:48 - um and there is another command where
184:50 - it's like cube ctl create service and so
184:53 - those can have kind of a bit of an
184:55 - overlap but the idea there is that if
184:56 - you create a service
184:58 - um it still has to link to something so
185:01 - most cases it doesn't make sense to do
185:02 - that there's probably some edge cases
185:04 - and i feel like cube ctl exposed does a
185:07 - little bit more like i thought maybe
185:09 - like it added a proxy or did something
185:11 - but i just could not find that
185:13 - documentation and i found it somewhere
185:15 - online wasn't official docs so it
185:17 - definitely does a little bit more but i
185:19 - don't fully understand that extra bit to
185:21 - explain it to you but i just know that
185:23 - we will use it
185:25 - and uh if you always can use manifest
185:27 - files to create your services
185:30 - but this is just really good for a quick
185:31 - way to expose
185:33 - kubernetes or like a kubernetes pods
185:36 - okay
185:37 - [Music]
185:42 - hey this is andrew brown from exam pro
185:44 - and let's talk about busybox so busybox
185:46 - combines tiny versions of many common
185:48 - unix utilities in a single small
185:50 - executable it's basically the swiss army
185:52 - knife of embedded linux as the single
185:54 - executable replaces basic functions of
185:56 - more than 300
185:58 - common commands
186:00 - and so busybox can be used to
186:02 - interactively debug services to ensure
186:04 - they are working
186:05 - um i'm pretty sure on the
186:08 - the ck ckd you will use busybox
186:12 - for things and in this course we use
186:14 - busybox
186:15 - uh so that is something that we can do
186:18 - there usually it's going to be something
186:19 - like cubectl run
186:21 - dot i t so interactive t i don't know
186:24 - what the it stands for but i remember
186:26 - doing it many times but this is an
186:28 - example of running busy box that
186:31 - is continuously running and you can sh
186:33 - into it
186:34 - and then use its many commands one
186:36 - command it does not have which is very
186:38 - frustrating is curl because i really
186:40 - prefer curl over wget so even though
186:42 - that's 300 it doesn't have curl
186:44 - but i guess you can't have all the
186:46 - commands you want but it is still very
186:48 - useful
186:49 - [Music]
186:53 - hey this is andrew brown from exam pro
186:55 - and we are looking at kubernetes ingress
186:57 - probably the hardest
186:59 - service to deal with not because ingress
187:02 - is super hard to write but you have to
187:04 - deal with ingress controllers and
187:05 - configuring those can be kind of
187:07 - difficult
187:08 - and in the follow alongs we definitely
187:10 - have a bit of a struggle there but we do
187:11 - get through it
187:12 - uh and we do it multiple times but let's
187:15 - talk about ingress so ingress exposes
187:16 - http and https routes from outside the
187:19 - cluster to the service within the
187:21 - cluster and traffic routing is
187:22 - controlled by rules defined on the
187:24 - ingress resource
187:25 - so here is our diagram here the reason
187:28 - we use kubernetes ingress is so we can
187:30 - translate a custom domain on an ssl to a
187:32 - service running within our kubernetes
187:34 - cluster
187:36 - in order for ingress to work you need to
187:37 - have an ingress controller something
187:39 - like abs gces uh load balancer
187:43 - uh or i guess ingress controller they're
187:45 - called english controllers or nginx
187:46 - ingress controller generally those are
187:48 - coupled to
187:50 - um
187:51 - uh particular load balancers right
187:54 - for those providers which you'll see so
187:56 - ingress enables you to consolidate the
187:58 - traffic routing rules into a single
188:00 - resource and run as a part of the
188:02 - kubernetes cluster so getting out my pen
188:04 - tool here
188:06 - just making sure we're in the same place
188:07 - we have our traffic it reaches our
188:09 - ingress controller this one is nginx and
188:12 - from there it goes to our ingress
188:13 - service which
188:15 - defines the routes and then it goes to
188:19 - the routes to the service and the
188:20 - service will reach our pods so there you
188:23 - go
188:24 - [Music]
188:28 - hey this is andrew brown from exam pro
188:29 - and we are looking at dns so dns stands
188:32 - for domain name systems
188:34 - and uh i mean the way i'm
188:36 - conceptualizing it is that it's a
188:37 - service that is responsible for
188:39 - translating resolving a service name to
188:41 - its ip address so this is in the context
188:43 - of kubernetes because dns stuff is um
188:47 - complicated uh
188:49 - so to say um and we could spend i don't
188:52 - know like a micro course just talking
188:53 - about dns but i just want to focus on
188:56 - the last part translating or resolving a
188:58 - service so kubernetes service name to an
189:01 - ip address and so for um
189:04 - a domain name system it's not uncommon
189:06 - to have like a table of things that
189:08 - point to things so we would have a
189:10 - service registry and so in the context
189:13 - of kubernetes this would be the service
189:15 - name and this would be uh the static ip
189:18 - address that is assigned to it so
189:20 - um
189:21 - you know the idea is that if you were to
189:24 - use that service name or registry like
189:26 - with an http request
189:29 - or just use a a tool that allows you to
189:32 - look up dns records like if you're
189:34 - trying to resolve where
189:36 - front name would go that it should
189:37 - result to that ip address so now we need
189:40 - to know about core dns so coordinates is
189:42 - the default dns server for kubernetes
189:44 - in the documentation you might see
189:46 - something that's called cube dns and
189:48 - that was the default prior to that uh
189:50 - and it was replaced because it wasn't
189:53 - that modular or had great plug-in
189:54 - support and so core dns is the current
189:56 - default you can swap it out this is the
189:58 - one you'll want to use because it's
189:59 - pretty good
190:01 - and it ensures that pods and services
190:04 - have fully qualified domain names fqdns
190:08 - and without core dns the cluster
190:10 - communication would cease to work
190:11 - because it just would not know
190:13 - how to resolve things to things
190:15 - and you might ask what is a fully
190:17 - qualified domain name so it's a domain
190:19 - name that specifies its exact location
190:22 - in the tree hierarchy also known as an
190:24 - absolute domain probably a visual would
190:26 - help there but you know it's not that
190:28 - important what's important to remember
190:29 - is that we have this table of service
190:31 - registry and there's a way to look up
190:34 - dns
190:35 - and of course there is dns like let's
190:37 - say you're using an aws and you had
190:39 - route 53 which is um a dns service
190:43 - that allows you to register domain and
190:45 - then forward that domain making record
190:47 - sets to point to stuff and so you know
190:49 - that is like again another level of dns
190:52 - and it can integrate into core dns and
190:54 - things like that but
190:56 - this dns is just for stuff within the
190:58 - cluster okay
190:59 - so uh let's look at the functionality
191:01 - that is provided by core dns because
191:03 - there are entry plugins internal plugins
191:05 - and then
191:06 - out of tree plugins so things you can
191:08 - add on and so this will give you an idea
191:10 - of the things that core dns can do other
191:13 - than just resolving
191:14 - uh you know a domain name to an ip
191:17 - address so we have acl so enforce access
191:19 - control policies on source ip and
191:21 - prevents unauthorized access to dns
191:23 - servers
191:24 - any so
191:25 - any given minimal response
191:28 - to
191:29 - this anything azure so enable server
191:32 - zoning data from microsoft azure dns
191:34 - that's what i'm talking about those
191:35 - integrations with those cloud service
191:37 - providers cache enables a front-end
191:39 - cache health enables a health check
191:42 - endpoint something that you'd be very
191:44 - common with if you were again roughly
191:46 - three they have health checks built in
191:47 - so now is at the um cluster level log so
191:51 - enable query logging to standard output
191:53 - and many more such as like i think aws
191:56 - would be in there like web 53 and things
191:58 - like that so out of tree plugins get
192:00 - alias uh redisk so enabled cache uh
192:04 - using redis uh cuber not
192:07 - tie
192:09 - serve multiple uh kubernetes within a
192:12 - server and many more so
192:14 - you know hopefully that gives you kind
192:15 - of an idea of how robust this thing is
192:18 - and how modular it is let's just talk
192:20 - about some tooling that we should know
192:22 - especially if we're debugging this stuff
192:24 - not something that we really need to do
192:26 - at in the kcna level but uh it's just
192:28 - practically very good to know so
192:31 - coordinates pods are abstracted by a
192:33 - service object called cube dns remember
192:36 - everything kubernetes is pods so
192:38 - coordinates are pods that run in the
192:40 - cube system
192:42 - and um i don't know if i wrote this
192:43 - anywhere but it's very important to
192:44 - remember that core dns
192:47 - or whatever dns thing that you want to
192:49 - use lives in the control plane node when
192:52 - we were looking at a diagram that was
192:54 - the one thing i forgot to put in there i
192:56 - didn't have to get update the graphics
192:57 - i'm just reiterating on that again each
192:59 - pod
193:00 - and not just
193:02 - any pod uh
193:04 - like sorry when i say each pod we don't
193:05 - just mean coordinates pods we mean any
193:07 - single pod has this resolve.com file to
193:10 - help with dns resolving now this isn't
193:13 - a kubernetes specific thing this is just
193:14 - a linux thing where um you will have
193:17 - this file on your i don't know if it's
193:19 - in virtual machines but it's definitely
193:20 - in containers but if you were to cat it
193:22 - out like print the contents of it so
193:24 - here we're logging into that pod that
193:26 - container sorry and
193:28 - we do that it's going to show the name
193:30 - server so what we are in terms of the ip
193:33 - address and then
193:35 - you know the domain names that would
193:37 - resolve to
193:39 - this
193:40 - um pod okay so notice it says default
193:43 - svs cluster local things like that
193:46 - and another really useful tool is using
193:48 - ns lookup so let's look up name server
193:50 - lookup is a way that we can discover uh
193:53 - or see where things resolve so like
193:55 - remember i said there's a service
193:57 - registry that contains a service name
193:59 - and a um
194:01 - and a uh ip addresses so we could dump
194:03 - an ip address in here and then it would
194:05 - hit the core dns and be like what'd you
194:07 - find and this is what i found right or
194:09 - you could supply the service name or the
194:11 - full service name because this is just
194:13 - like a part of the name right the real
194:15 - name would be like really long like this
194:18 - okay
194:19 - so just notice like how long it is and
194:21 - like how short that is um but again you
194:23 - know a little bit outside the scope of
194:25 - the kcna but good to know um
194:28 - you know in general okay
194:30 - [Music]
194:34 - hey this is andrew brown from exam pro
194:36 - and i want to talk about load balancing
194:37 - because we see load balancing in a
194:39 - variety of different ways in kubernetes
194:42 - and it can get kind of confusing so i
194:43 - just wanted to describe the different
194:45 - types of load balancing that we'll come
194:46 - across but let's define what load
194:48 - balancing is first load balancing is a
194:50 - networking component where traffic flows
194:52 - through the load bouncer and the load
194:53 - balancer decides how to distribute
194:55 - traffic to the multiple targets such as
194:58 - compute nodes or other different kinds
195:00 - of targets based on a set of rules so
195:02 - examples of this would be ingress and
195:06 - the service kubernetes service both have
195:08 - load balancing but there's more than
195:10 - that so we have external load bouncers
195:12 - uh we have ingress we have service and
195:15 - then we have internal load bouncing like
195:17 - ip tables and ipvs which technically is
195:21 - what service is using
195:23 - so for external load bouncers um the
195:25 - load balancing is controlled by third
195:27 - party service think of elastic
195:32 - it's weird like uh i know application
195:34 - load balancer elastic load balancer by
195:36 - aws or nginx or things like that then
195:39 - you have um ingress so that is the
195:42 - actual service itself
195:44 - um so the idea is you have load
195:46 - balancing algorithm back-end weight
195:48 - schemes
195:49 - you have service which will persist
195:51 - sessions uh will have dynamic weights
195:54 - and then in the internal uh turn load
195:56 - bouncing the load bouncing to the
195:57 - containers with the pods which is
195:59 - randomly distributed so just understand
196:02 - that there's more than one level of load
196:03 - bouncing
196:05 - and don't get too overwhelmed with that
196:07 - okay
196:08 - [Music]
196:12 - hey this is andrew brown from exam pro
196:14 - and we are taking a look at probes so
196:15 - probes are used to detect the state of a
196:17 - container and we have three types uh
196:20 - liveness probe
196:22 - readiness probe and startup probe um and
196:26 - in the kca i think you need to know how
196:29 - to set up probes and we do actually use
196:32 - um a type of probe
196:36 - i think uh readiness probe yeah we use a
196:38 - readiness probe um in this course but we
196:41 - you know we don't go super deep into the
196:43 - probes but we do get some exposure to
196:45 - them so let's talk about the liveness
196:47 - probes the liveness probe is
196:49 - used to know when to restart a container
196:54 - okay and so for example liveness probes
196:57 - could be could catch a deadlock where an
196:59 - application is running but unable to
197:01 - make progress so restarting a container
197:03 - in such a state can help to make the
197:05 - applications
197:06 - more available despite bugs
197:09 - okay
197:10 - then we have
197:12 - the readiness probe to know when
197:15 - a container is ready to start accepting
197:17 - traffic so pod is considered ready when
197:19 - all of its containers are ready and once
197:22 - uh one use of this uh one use of this
197:25 - signal is to control which pods are used
197:27 - as back ends
197:28 - for services so when a pod is not ready
197:31 - it is removed from the services load
197:33 - balancer
197:35 - then we have start probe so this is
197:37 - where we know when a container
197:39 - application is started so if such a
197:41 - probe is configured it disables liveness
197:44 - and readiness checks until it succeeds
197:46 - making sure those probes don't interfere
197:47 - with the application startup this can be
197:50 - used to adopt liveness checks on slow
197:52 - starting containers avoiding them
197:53 - getting killed by cubelet before they
197:56 - are up and running so there you go
197:58 - [Music]
198:03 - hey this is andrew brown from exam pro
198:05 - we are looking at net filters so net
198:06 - filter is a project that enables packet
198:09 - filtering network address translation
198:11 - and port translation so nat or napt so
198:16 - knapped
198:17 - not to be confused with nats which is an
198:19 - event bus that uses grpc
198:22 - it can be used in microservices uh
198:25 - translation packet logging user space
198:27 - packet queuing other packet mangling and
198:30 - the net net filter hooks are a framework
198:33 - inside the linux kernel that allows
198:35 - kernel modules to register callback
198:37 - functions at different locations of the
198:38 - linux network stack the registry
198:41 - callbacks functions is used when called
198:44 - back from every packet that traverses
198:46 - the respective hook within the linux
198:48 - network stack so projects that build on
198:51 - top of netfl filter that's why we're
198:52 - talking about it is iptables this is a
198:55 - generic firewall
198:56 - software that allows you to define rule
198:58 - sets nf tables so this is the successor
199:01 - to iptables ipvs so this is specifically
199:04 - designed for load balancing and uses
199:07 - hash mapping as its means
199:09 - so um
199:11 - when we are using a service it can be or
199:14 - sorry proxy i suppose it can be backed
199:17 - by either iptables or ipvs and nf tables
199:21 - is just not in the mix for whatever
199:22 - reason
199:23 - um and probably in the future kubernetes
199:26 - will default to ipvs and just not use ip
199:28 - tables but right now at least when i'm
199:30 - making this course and video iptables is
199:33 - still the default but we'll talk about
199:35 - that and we'll talk about ib tables in
199:37 - greater detail
199:39 - [Music]
199:43 - all right let's take a look here at ip
199:45 - tables but before we do let's define
199:47 - what a user space is so user space
199:50 - for modern computing operating systems
199:51 - segregates virtual memory into kernel
199:54 - space and user space so kernel space is
199:56 - reserved for running a privileged
199:58 - operating system kernel kernel
199:59 - extensions and device drivers user space
200:02 - is the memory area where applications
200:04 - software and some drivers execute so now
200:07 - what is ip table so iptables is a user
200:10 - space utility program that allows a
200:12 - system administrator to configure the ip
200:14 - packet filter rules for the linux kernel
200:17 - firewall so we have iptables which is
200:20 - for ipv4 and ip6 tables which is for
200:23 - ipv6 but generally it's just iptables
200:25 - here and
200:27 - iptables is simply a virtual firewall on
200:31 - linux
200:32 - and it's very common uh like on linux to
200:36 - have to experience ip tables so it is a
200:38 - common skill and really worth to know um
200:42 - so
200:44 - an example would be like let's say you
200:46 - wanted to restrict access based on ports
200:48 - and protocols
200:49 - you could
200:51 - add or update to the ip tables saying
200:53 - like okay the destination port is 80 the
200:55 - protocol is tcp
200:57 - and we will accept traffic open that up
200:59 - if we list them out hyphen l we can see
201:02 - what is open what is not what is blocked
201:04 - and things like that
201:06 - and again iptables is at least when i'm
201:08 - making this the default for
201:11 - cube proxy and you can change it out to
201:14 - ipvs which we'll talk about next
201:16 - [Music]
201:20 - all right let's talk about ipvs which
201:22 - stands for ip virtual server which uses
201:24 - the net filter framework and also
201:27 - incorporates virtual linux server lvs
201:31 - so the reason we use ipvs is because
201:34 - when using ip tables it can struggle to
201:37 - scale to tens of thousands of services
201:39 - as iptables is bottlenecked at 5000
201:41 - nodes per cluster ipvs is uh
201:44 - specifically designed for load balancing
201:45 - and uses more efficient data structures
201:47 - so hash tables i think i might have
201:49 - called it hash mapping earlier but it
201:50 - was i supposed to say hash tables on the
201:52 - right hand side here allowing for almost
201:55 - unlimited scale under the hood if you've
201:57 - never heard of hash tables um
202:00 - we describe it in crypto uh
202:02 - cryptographical stuff like imisc 900
202:05 - course we talk about it there
202:07 - in the future q proxy will default to
202:09 - ipvs
202:11 - i really wanted to get like a nice
202:12 - diagram to show how it works but i
202:14 - really just couldn't find anything and
202:17 - the point is is that you're just going
202:18 - to end up using in the future and it's
202:20 - used because of the limitations i'd be
202:22 - table so that's really all you need to
202:23 - know okay
202:24 - [Music]
202:28 - hey this is andrew brown from exam pro
202:30 - and i want to talk about the various
202:31 - proxies that we will encounter in
202:33 - kubernetes because there's more than
202:34 - just one and it can get confusing if you
202:36 - just don't know that there's more than
202:37 - one so what is a proxy well is a server
202:40 - application that acts as an intermediary
202:42 - between a client requesting a resource
202:45 - and the server providing that resource
202:47 - so here's an example i got this nice
202:49 - little graphic from a wikipedia but the
202:51 - idea is that once it asks them the
202:53 - current time it goes to the proxy the
202:55 - proxy says hey what's the current time
202:57 - it says the time it sends it back to the
202:59 - person so the idea is that they are in
203:01 - the middle
203:02 - um
203:03 - uh between the communication of two
203:05 - resources many or more so there are many
203:08 - uh kinds of proxies you'll encounter
203:10 - kubernetes and so we'll talk about all
203:12 - the kinds here so the first we have is
203:14 - cube ctl proxy so proxies from a local
203:17 - address to the kubernetes api server
203:20 - then you have an api server proxy so a
203:22 - bastion built into the api server
203:24 - connects a user outside of the cluster
203:26 - to cluster ips which otherwise not might
203:28 - not be reachable cube proxy so runs on
203:31 - each node and used to reach services
203:34 - proxy load bouncer in front of api
203:36 - server so acts as a load bouncer if
203:37 - there are several apis
203:39 - cloud load balancers so for external
203:41 - cluster traffic to reach pods and in
203:44 - particular the ones that we will notice
203:46 - will be cube proxy and cube ctl proxy i
203:49 - know when i was learning uh kubernetes
203:51 - getting mixed up because i thought maybe
203:53 - this proxy and this proxy were the same
203:55 - thing and they absolutely weren't
203:56 - because they weren't
203:58 - prefacing it with cube ctl
204:01 - but just understand there's a lot of
204:02 - different proxies and just to give more
204:05 - general information about proxies
204:06 - there's the concept of a forward and a
204:09 - reverse proxy so ford proxy which is the
204:11 - default proxy when we just say the word
204:12 - proxy is a bunch of servers egressing
204:15 - traffic to uh have to pass through the
204:18 - proxy first so imagine i'm going to just
204:21 - draw a little boxes here you have three
204:23 - servers and in front of it there is a
204:25 - proxy and the idea is that they're going
204:27 - to all go through
204:29 - this proxy all right and that kind of
204:31 - acts as a way of filtering or doing
204:33 - things with their requests then you have
204:34 - a reverse proxy so this is ingress
204:36 - traffic trying to reach a collection of
204:38 - servers and this is what we will see
204:41 - quite often especially with web
204:42 - applications
204:44 - is it is that you have let's say three
204:46 - versions of your web app running and in
204:48 - front of it you have a proxy and the
204:49 - proxy is going to
204:52 - send the traffic to those
204:54 - and in a sense you basically have load
204:56 - balancing so hopefully that makes it
204:59 - very clear uh and there you go
205:01 - [Music]
205:06 - hey this is andrew brown from exam pro
205:07 - we are looking at kubernetes proxy so
205:10 - kubernetes proxy also known as just as q
205:12 - proxy is a network proxy that runs on
205:14 - each node in your cluster and it's
205:16 - designed to load balance
205:18 - uh notice i have the word load bounce
205:19 - there traffic to pods so down below this
205:22 - is the diagram from the docs i probably
205:24 - should have made one here but i also
205:26 - kind of wanted to show it to you because
205:28 - often they have permutations of this or
205:30 - it can be really confusing i just want
205:32 - to kind of clarify it up that you have q
205:34 - proxy here
205:35 - and uh you have a cluster ip and you
205:38 - have the ip tables but they'll put it
205:39 - like they always put iptable somewhere
205:41 - else but where it goes is it's a program
205:44 - running on the virtual machine the node
205:45 - so it's really over here
205:47 - okay and the idea is that cluster ip and
205:50 - q proxy
205:52 - can be both using it all right um and so
205:55 - that to me is a lot more clear because
205:57 - that is the thing that is driving the
205:58 - rules to say okay how do we load balance
206:01 - how we how do we filter traffic and
206:02 - stuff like that and these things
206:04 - leverage it and this is a program
206:06 - running on the node
206:08 - so cube proxy maintains network rules so
206:10 - that's going to be in this case iptables
206:12 - these network rules allow network
206:14 - communication to your pods for network
206:16 - sessions inside or outside of your
206:17 - cluster q proxy uses the operating
206:20 - system packet packet filter laying if
206:22 - there is one and it's available
206:24 - otherwise q proxy forwards the traffic
206:26 - itself q proxy runs in three modes we've
206:28 - got iptables which is the default uh
206:31 - suited for most use cases ipvs probably
206:33 - going to be the future default because
206:35 - it's so good and suited for thousands of
206:37 - plus services but it's fine for simple
206:39 - use cases as well and then user space
206:42 - this is legacy and not recommended for
206:44 - use so hopefully that gives you an idea
206:46 - of q proxy it is installed on all nodes
206:49 - not just the worker nodes because you
206:51 - need a proxy to
206:52 - move that traffic around but um
206:54 - you know hopefully that gives you an
206:55 - idea there and there you go
207:01 - hey this is andrew brown from exam pro
207:03 - and we are taking a look at container
207:04 - networking interfaces cni so cni is a
207:07 - specification or open standard for
207:08 - writing plugins to configure networking
207:10 - interfaces for linux containers and so
207:13 - down below here uh imagine this is the
207:15 - uh container networking interface which
207:17 - again is a specification for writing
207:19 - plugins and then there are plugins there
207:22 - are built-in plugins that ship with it
207:23 - and there are third-party plugins i
207:25 - would imagine
207:27 - i would imagine this is where we say
207:29 - entry and out of tree uh but maybe not
207:32 - um but you know that's the way i'm
207:34 - thinking about it and so you might
207:36 - recognize some things here like bridge
207:38 - and flannel and then on the side we have
207:40 - calico cilium and weave which are all
207:43 - very popular third-party
207:45 - uh things to install uh and definitely
207:48 - you'll need these you'll need one of
207:50 - these in order to do network policies
207:53 - okay so this is just the interface that
207:55 - um is used so that containers can
207:58 - leverage these uh plugins right it goes
208:00 - to the container network interface just
208:01 - a standard way to do it so it will run
208:03 - through the container run time to reach
208:05 - the containers uh and so that's the idea
208:07 - is like if you want to
208:08 - interact with calico
208:10 - right it's going to have to go through
208:11 - this path right same thing with any of
208:13 - these things like if it's a bridge it's
208:15 - going to be going through here so
208:16 - hopefully that
208:18 - helps make sense okay
208:24 - hey this is andrew brown from exam pro
208:26 - and we are talking about service meshes
208:28 - so a service mesh manages service to
208:30 - service communication for microservice
208:32 - architectures a service meaning an
208:34 - application not a kubernetes service
208:37 - component so this is where um you know i
208:40 - said how service is a confusing name
208:42 - this is where we get that confusion so a
208:44 - service mesh is an infrastructure layer
208:46 - that can provide the following
208:48 - reliability traffic management retries
208:50 - load balancing observability some
208:52 - metrics and traces security so tls
208:55 - certifications and identity
208:57 - uh and so the idea is that you'd have a
208:59 - service control uh service mesh control
209:01 - plane so the installation of the proxies
209:04 - into pods as well as the proxies
209:05 - capabilities is managed by the service
209:07 - mesh control plane and a service mesh
209:10 - uses a side card pattern carefully
209:13 - listen to this because this is super
209:14 - important and will probably show up on
209:16 - the exam but a side card pattern
209:19 - basically is a proxy container that is
209:21 - installed on each pod
209:23 - and
209:25 - the apps container must pass the proxy
209:27 - before leaving the egressing pod so the
209:29 - idea is that
209:31 - you when you install a service mesh
209:34 - this proxy or sidecar as it will as it
209:37 - will say will will sit beside it and so
209:39 - the idea is the container will pass
209:40 - through it and the proxy can do all
209:43 - sorts of stuff all these things here
209:45 - above
209:46 - there is a lot of different service mesh
209:48 - implementations you don't have to run a
209:50 - service mesh but in most production use
209:52 - cases there's no reason not to and i
209:55 - forgot the e there maybe it turned into
209:57 - a hyphen for some reason um but
210:00 - available service messages for
210:01 - communities are istio so this is
210:03 - currently the most popular service mesh
210:05 - but some people might debate me here for
210:07 - kubernetes due to its highly
210:08 - configurable nature seo uses envoy as
210:11 - its proxy istio is not a cnn safe
210:14 - project so when we talk about the
210:15 - sidecar
210:17 - um you know like like there's the
210:19 - control plane and then there's the
210:20 - actual proxy the sidecar that you
210:22 - install and so seo says it uses envoy
210:25 - for that istio is not a cncf project
210:29 - but envoy is and so envoy is an open
210:31 - source edge and service proxy multiple
210:33 - service meshes use envoy as it's a proxy
210:35 - envoy is a graduated cncf project
210:38 - you have kuma this is also a cncf
210:41 - project but it's in sandbox mode that
210:43 - uses envoys at proxy i'm not sure if
210:45 - it's competing with istio
210:48 - since it's not a cncf project sometimes
210:50 - that's what you see you see projects
210:52 - that are competing like they're not
210:55 - for whatever reason they're not a
210:58 - cncf project and so then a csv project
211:00 - spins up to kind of compete with it or
211:02 - fill some kind of edge cases and it can
211:05 - get kind of confusing because there's
211:06 - some sometimes a lot of overlap on
211:08 - certain stuff you have linker d which is
211:11 - actually what we use or we attempt to
211:13 - use in the fall longs it's a graduated
211:15 - project known for having strong security
211:17 - and it just works liquor d does not use
211:20 - envoy instead it uses a simple ultra
211:22 - ultra lightweight microproxy called
211:24 - linker
211:25 - d to proxy and then if we're talking
211:28 - about like a third-party service like uh
211:30 - hashicorp console so console's an open
211:32 - source service mesh by hashicorp it's
211:34 - not a cncf project console is offered by
211:36 - hashicorp as a managed cloud service
211:39 - mesh so there you go
211:41 - [Music]
211:46 - all right let's take a closer look at
211:47 - envoy which is a self-contained process
211:49 - that is designed to run alongside every
211:51 - application server
211:53 - envoy can be installed on a virtual
211:55 - machine or as a container so you don't
211:56 - have to have a control plane
211:58 - with envoy but
212:00 - that's generally what you'd want so
212:01 - you'd want something like sd or
212:02 - something to
212:04 - communicate or gather the information
212:06 - that passes along through your sidecar
212:09 - which is the envoy proxy and voice
212:11 - supports a wide range of functionality
212:13 - so l3 l4 filter arctic architecture
212:16 - l7 filter architecture so l7 is the
212:19 - application layer 3 and 4 is like
212:22 - packets like tcp udp things like that
212:25 - first class http 2 support and http 3
212:30 - http 3 support
212:32 - uh it has
212:34 - layer 7 so that's the application layer
212:36 - routing grpc support service discovery
212:39 - dynamic configuration health checking
212:41 - advanced load balancing front edge proxy
212:43 - support best in class observability and
212:46 - in practice you will likely not install
212:49 - and manage to configure envoy you would
212:50 - allow a service mesh control plane to
212:52 - install into your pods a service mesh
212:55 - will or may cont come with a ui
212:58 - configuration files to configure your
213:00 - envoy so there you go
213:05 - [Music]
213:07 - all right let's talk about network
213:08 - address translation not to be confused
213:10 - with nats
213:12 - which is a event bus service that is
213:14 - used with microservices and grpc but is
213:17 - not the same thing
213:19 - so
213:20 - what is network address translation well
213:22 - it's a method of mapping an ip address
213:23 - space into another by modifying network
213:25 - address information in the ip header of
213:28 - packets while they're in transit across
213:30 - a traffic writing device
213:32 - okay but what does that mean
213:34 - well it's practical use case is imagine
213:38 - that you have a server
213:39 - it's a public server right
213:41 - publicly accessible via the internet
213:44 - and you need to communicate
213:46 - uh with a private network and so we have
213:49 - two different private networks private
213:50 - network one private network two
213:52 - and uh they have their own address
213:54 - spaces so this is in the 10.0.0.0
213:57 - and this one also has it right so if
214:00 - these are the same and they were to talk
214:01 - to each other
214:03 - that wouldn't make any sense right
214:04 - because they have overlapping addresses
214:06 - so a nat can translate one in another
214:09 - by mapping or translating
214:13 - uh there's this is like a nat table that
214:15 - will um uh store
214:18 - uh like it will say like okay 100.1 goes
214:21 - over here but we will then give it a new
214:23 - ip address and we'll remember that so
214:25 - that if anybody talks to us we'll know
214:28 - to send things back through that path
214:30 - okay
214:31 - because a uh two private
214:33 - two private networks that have
214:35 - conflicting address spaces are gonna
214:37 - have an issue there
214:38 - and um
214:40 - when you send a packet over here if you
214:42 - send 10.0.0.1
214:44 - to the server and it sends it back it
214:46 - has no idea what 10.0.01
214:48 - is
214:49 - so it really needs to be mapped to
214:51 - something else and so that is the idea
214:53 - behind network address translation okay
214:56 - [Music]
215:00 - let's talk about ethernet 0 and network
215:03 - namespace so first we need to know what
215:05 - an ethernet device is so an ethernet
215:07 - device is a software or hardware
215:09 - technology that allows a server to
215:11 - communicate on a computer network so a
215:13 - network interface card a nic
215:15 - are commonly used to establish a wired
215:17 - connection to a network it's the thing
215:20 - you plug the internet into
215:22 - a cloud service provider
215:24 - such as aws or azure gcp
215:27 - have virtual nics for your virtual
215:29 - machines uh and you can actually manage
215:32 - them too
215:33 - a lot of times they're created for you
215:34 - to connect to your virtual network so
215:37 - what is a network namespace well
215:40 - ethernet 0 represents the first ethernet
215:43 - interface an ethernet device attached to
215:46 - your virtual machine and a network
215:49 - interface is an abstraction on top of
215:51 - the ethernet interface to provide a
215:54 - logical networking stack with its own
215:56 - routes firewalls rules and network
215:58 - devices linux by default has one network
216:00 - namespace called root
216:03 - and network namespace and this is what
216:05 - programs we'll use by default so the
216:07 - idea is you have your linux virtual
216:09 - machine
216:10 - you have your root
216:12 - network space and then you have uh
216:14 - ethernet 0 so the
216:17 - these the first there's ethernet zero
216:19 - and there's unit one but one is the
216:21 - second device if you have one
216:23 - but either zero is
216:25 - primarily how things are getting outside
216:27 - that virtual machine okay
216:29 - [Music]
216:34 - so now the question is how would you
216:36 - observe these things uh so if you were
216:38 - to log into your virtual machine and i
216:40 - actually did this on aws what you can do
216:42 - is you can
216:43 - observe
216:44 - uh the type of devices that are attached
216:46 - to your virtual machine by typing in
216:48 - ifconfig i don't know what ifconfig
216:51 - stands for but i know that it'll list
216:53 - out things like
216:55 - zero so there that's the way that you
216:57 - can see it
216:59 - and there's other things so i guess down
217:01 - below we have lo i can't remember what
217:02 - that stands for but you might see other
217:04 - things like bridge as well so all sorts
217:07 - of networking devices
217:09 - and you can
217:11 - create and modify your own network
217:13 - namespace so we said there's a root name
217:15 - space but you can create your own
217:17 - um
217:18 - here so are we showing yeah so here this
217:20 - goes pseudoip
217:22 - net
217:23 - ns which stands for network namespace
217:25 - add namespace one so i created a custom
217:28 - one there you type in
217:29 - ipnetness and there is that namespace so
217:32 - there you go
217:33 - [Music]
217:38 - hey this is andrew brown from exam pro
217:40 - and we're onto cluster networking which
217:42 - is an extremely important section
217:44 - for kubernetes because if you don't
217:46 - understand the networking for it
217:48 - um it can be really hard to use and it
217:51 - will kind of show up on the exam
217:53 - indirectly not directly but you will
217:56 - have questions which should be like hey
217:57 - if you talk this way to that thing what
217:59 - can talk
218:00 - um and this is where i say as a
218:03 - prerequisite why you need to know linux
218:05 - and why you need to know
218:07 - cloud networking or sorry linux
218:09 - networking because this stuff is tricky
218:13 - but
218:14 - kubernetes has the following opinions
218:16 - about cluster networking all pods can
218:18 - communicate with all other pods without
218:20 - using a nap network address translation
218:22 - all nodes can communicate with all pods
218:25 - without using a nat
218:26 - the ip that a pod sees itself as is the
218:30 - same ip as it sees
218:32 - it as and even though i'm saying uh you
218:35 - know without using a nat without using a
218:38 - nap gnats are and can be used in
218:40 - kubernetes even though
218:41 - the bub is a contradiction there are
218:44 - four broad types of network
218:46 - communication for clusters we have
218:47 - container to container pod to pod pod to
218:50 - service external to service
218:52 - and um beyond what i'll show you if you
218:56 - really want to go deep on this stuff
218:57 - there's like a long form medium article
219:00 - but there's also a really good talk and
219:02 - it's a cncf tech talk called a life of a
219:05 - packet by michael rubin for uh so if you
219:08 - want very detailed cluster networking
219:10 - knowledge
219:11 - uh if the stuff is just not clicking or
219:12 - you just want to get more that's on
219:14 - youtube and i strongly recommend
219:16 - watching that as an additional thing if
219:18 - it interests you
219:20 - [Music]
219:24 - all right let's take a look here at
219:25 - container to container networking so
219:27 - containers all in the same pod have the
219:30 - same ip address and the port space and
219:32 - containers can communicate with each
219:34 - other via the local host via different
219:36 - ports so to help this make a little bit
219:38 - more sense i have a visualization here
219:41 - so here we have a worker node and pods
219:44 - run in worker nodes or nodes in general
219:47 - and here you can see that we have an ip
219:49 - address and so that is a dynamic ip
219:51 - address meaning that if this pod is
219:53 - destroyed
219:55 - and it spins up a new one then there
219:56 - will be a new ip address and so down
219:59 - below we have multiple containers here
220:02 - and all these containers are
220:04 - communicating on local host so if you
220:06 - log into this container here and you
220:08 - were to local host on port 3000 you
220:10 - would reach this container
220:12 - uh and that's kind of the story there so
220:15 - it's not too
220:16 - complicated in terms of the
220:19 - configuration so here is a deployment
220:20 - file and in the pod spec part of it the
220:23 - spec part uh if we go down below to the
220:26 - template and then into the containers
220:28 - here you can see we are setting the
220:29 - container port so see where it says port
220:31 - 80 here that would pretty much be the
220:33 - same thing where we are setting it here
220:35 - on the container in the graphic
220:38 - obviously not the same port number but
220:40 - that's the idea there so hopefully that
220:42 - is pretty clear
220:44 - pods can
220:45 - all the containers in a pod communicate
220:47 - on a local host
220:48 - and
220:49 - you just access them via the ports
220:51 - [Music]
220:55 - all right before we go any further into
220:57 - more cluster networking we need to
220:59 - understand what is a virtual ethernet
221:02 - device also known as vet so these
221:04 - devices they can act as a tunnel between
221:07 - network name spaces to create a bridge
221:10 - to a physical network device in another
221:12 - name space but can also be used as a
221:15 - standload network device uh packets on
221:18 - one device in the pair are immediately
221:20 - received on the other device so here is
221:22 - our visual we have two different network
221:24 - name spaces notice where it says net ns
221:27 - that's just kind of like the short form
221:29 - uh you could write to say network
221:31 - namespace but of course you can name
221:32 - your network namespaces whatever you
221:33 - want and so that devices are always
221:36 - created in interconnected pairs so
221:39 - i know it's a bit gray i don't know why
221:40 - i made it so dark or so light there but
221:42 - it says veth pear and the idea is that
221:44 - these um
221:46 - two parts of it uh include the pear
221:51 - and i'm just going to wipe a little bit
221:52 - away here uh so you can use the iplink
221:56 - command to create beth pairs so here you
221:59 - type in iplink add a net ns
222:03 - uh and in practicality of course you're
222:05 - never doing this but i just wanted to
222:06 - show you uh in case you had never
222:09 - you were just wondering how those links
222:10 - are established in linux so there you go
222:14 - [Music]
222:18 - let's take a look here at pod to pod
222:20 - communication because we just saw how
222:22 - simple
222:24 - containers can communicate with other
222:26 - containers within a pod just on the
222:27 - local host pod pod's a bit different and
222:29 - also it can be a little bit more tricky
222:31 - because you have pods that can be on the
222:34 - same note or you can have pods that are
222:36 - across nodes on different nodes and so
222:38 - it's kind of the same but a little bit
222:40 - different um so i have this big fancy
222:42 - diagram that we'll use as a reference as
222:44 - we talk through our information here so
222:46 - for pod depod communication on the same
222:50 - node
222:51 - virtual ethernet devices is used to
222:53 - communicate from the pod network
222:55 - namespace to the root network namespace
222:57 - that's why we were talking about uh
223:00 - virtual ethernet devices to connect two
223:02 - namespaces together notes and named it
223:04 - here like ef0 ef1 it's still virtual
223:08 - it's just that you can name them
223:09 - whatever you want and so some people
223:10 - just do that to simplify it where
223:12 - they'll just call this one uh f0 and
223:14 - that's zero here but this could have
223:16 - been one and two we could name them
223:18 - whatever we want um but i mean this is
223:20 - done for you right so you don't
223:22 - you don't set this up manually it's just
223:24 - happening but i'm just talking about if
223:26 - you were to
223:27 - set up
223:28 - a vet pair yourself you can name
223:30 - whatever you want
223:31 - um so in the root network namespace a
223:34 - bridge is used to allow all pod network
223:36 - namespaces to talk to other pods so
223:38 - that's a networking component that is
223:40 - set up for you here the br0 represents
223:42 - the bridge pods can see all of their
223:44 - pods and communicate using their ip
223:46 - addresses so notice that they both have
223:48 - two distinct ip addresses in the same
223:52 - network namespace or address namespace
223:54 - and so if you were logged into a
223:56 - container here and you were to
223:58 - ping this ip address you would reach
224:00 - that pod
224:02 - and you could then also hit the port
224:04 - number and hit a very specific container
224:07 - if you wanted to i just want to
224:08 - distinguish between uh routing and
224:10 - bridging because
224:12 - a lot of people might be thinking you
224:13 - know isn't a bridge just a router but
224:15 - they're not so routing allows multiple
224:17 - networks to communicate independently
224:19 - and yet remain separate using a router
224:22 - so bridging connects two separate
224:24 - networks as if they were a single
224:26 - network using a bridge so just under
224:28 - standard bridge is a bit simpler and
224:30 - treats everything on the same network
224:32 - which is what it does right because
224:34 - they have the same address space at the
224:35 - top there at the 10.0.0
224:38 - idea there now let's take a look at
224:40 - across node so here's our diagram looks
224:43 - pretty similar and just so you know
224:46 - there is a thing that's missing here
224:48 - that goes in between and i just don't
224:50 - have it there because we're going to be
224:51 - talking about it uh when we look at
224:53 - services so just be aware that this is
224:55 - an incomplete diagram on purpose but so
224:58 - pods can communicate to other pods
224:59 - running on other worker nodes how pods
225:02 - can communicate uh
225:04 - pods on other nodes is network specific
225:07 - okay okay so it's gonna be specific to
225:09 - the scenario and will vary based on your
225:12 - provider
225:13 - so in the case of aws they have their
225:15 - own implementation of the container
225:16 - networking interface cni
225:18 - and
225:20 - it's called amazon vpc container network
225:22 - interface plugin for kubernetes which
225:25 - allows you
225:26 - uh to have no intimidated communication
225:28 - uh via the aws virtual private cloud so
225:31 - if you've used aws which is a virtual
225:33 - private cloud basically it's gonna
225:35 - communicate on there so
225:37 - your vpc
225:38 - like
225:39 - it's pretty straightforward right so the
225:41 - idea is like i can't really show you
225:42 - that in granular detail because we'd be
225:45 - really digging into aws specifics or any
225:47 - cloud service specifics but the point
225:49 - that you need to know is that every
225:51 - provider has some kind of solution and
225:52 - when you set up on a managed provider
225:54 - it's going to already be installed there
225:55 - and so it's just going to work and
225:57 - you're going to have to do the research
225:58 - uh for each of those but it's always
226:00 - probably going to be happening with uh
226:02 - the container networking interface it's
226:03 - always going to be some kind of plug-in
226:05 - for that okay
226:06 - [Music]
226:10 - all right let's take a look at pod to
226:13 - service networking so here's our diagram
226:14 - looks very similar but the the key
226:17 - difference here is we have this element
226:18 - called iptables and this is being uh
226:21 - linked via a service now the way we can
226:24 - represent this um as an architectural
226:26 - diagram varies and you're gonna see in
226:28 - the next slide when we're talking about
226:30 - ingress egress that i've
226:32 - done it slightly different and it's
226:33 - because i looked at so many
226:35 - architectural diagrams and there's just
226:36 - no consistency so i figured i'd do some
226:39 - variation here just so that you can
226:40 - conceptually still understand what is
226:42 - going on and the placement of things so
226:45 - when a pod dies its ip address changes
226:47 - and this
226:48 - can make communication hard if you're uh
226:51 - relaying
226:52 - relying on the ip address for
226:54 - communication right so if uh you know
226:57 - this pod dies the ip address is gonna
226:59 - change right
227:00 - so a service creates a virtualized ip a
227:03 - static ip so over here
227:06 - and then uses iptables so iptables is
227:08 - over here which is installed on the node
227:11 - right so it lives on the node not in a
227:13 - pod
227:15 - to do nat so network address translation
227:17 - and load balancing to other pods and
227:20 - that's pretty much all there really is
227:22 - to it
227:23 - um so you know
227:25 - that's that's all there is okay
227:28 - [Music]
227:32 - all right let's take a look here at
227:33 - ingress egress from an internet cluster
227:34 - and here uh we are reaching the pinnacle
227:37 - of very complex diagrams and notice i
227:39 - told you that um
227:41 - the
227:42 - uh the representation of service is
227:44 - slightly different here so notice that
227:46 - service is having a dotted line that
227:47 - goes around iptables now i didn't double
227:50 - check but i'm not sure
227:52 - this could be a fault on my diagram but
227:54 - i'm not sure if the service
227:56 - lives in the control plane or the worker
227:58 - node
227:59 - it could live on the worker node i just
228:01 - didn't double check to be honest um but
228:04 - anyway
228:05 - what is clear and the reason i put it
228:07 - over here is because it has to talk to
228:08 - the
228:09 - um the cloud controller manager so to me
228:12 - that made a little bit more sense but i
228:14 - did tell you that it represents service
228:15 - slightly different uh like from the
228:17 - prior diagram here so let's talk about
228:19 - egress so egress is how uh pod traffic
228:22 - exit to the internet so the idea is you
228:24 - have a pod up here a container and it's
228:26 - flowing out this way it's leaving the
228:28 - pod and even though i don't have the
228:29 - diagram what it would do is it would go
228:31 - through the container networking
228:33 - interface
228:34 - um and the container networking
228:35 - interface
228:37 - it uh it can we have a diagram with
228:40 - cubelet and so cubelet shows that um it
228:43 - talks to the container runtime and so
228:46 - the idea is that you would have uh the
228:48 - the plugin so in aws's case it's their
228:52 - amazon vpc container networking
228:54 - interface so that would let you talk to
228:56 - uh vpc and from vpc you could then go
228:59 - talk to aws's internet gateway and
229:01 - that's how you'd get out to the internet
229:03 - and so you know i'm just running out of
229:04 - space on this diagram and that's why i
229:07 - didn't kind of do that variation for
229:08 - egress for ingress and i swear i
229:12 - i remembered it to put a double s on
229:14 - there but i guess i forgot but it's two
229:17 - s's and i digress that i made a mistake
229:19 - smelly ingress
229:21 - it's for traffic to reach a pod so it's
229:23 - going in this way okay
229:25 - and so the idea is it has to travel to a
229:27 - service so from a service it could be
229:30 - using a kubernetes service with a type
229:32 - load balancer this will work with a
229:35 - cloud controller manager to implement a
229:36 - solution that works with a t4 load
229:38 - balancer something that does udp tcp
229:41 - um but the other option is ingress
229:43 - kubernetes ingress and so it will use an
229:45 - ingress controller to work with a cloud
229:47 - service provider load bouncer
229:49 - i believe
229:50 - it's specifically for um t7 because any
229:53 - time i use ingress it's always using um
229:55 - like kubernetes it's using the
229:56 - application load bouncer can use it with
229:58 - a t4 i'm not sure that might be
230:00 - inaccurate so i would probably say it's
230:01 - just c7 but um
230:04 - you know uh the key thing is is that you
230:07 - can either use one or the other okay
230:10 - um but you know hopefully that makes it
230:11 - clear this stuff is probably the hardest
230:14 - stuff to understand in kubernetes
230:16 - they're not going to push you too hard
230:18 - on the exam to know this stuff for the
230:20 - kcna uh there's a lot of videos out
230:22 - there that go into
230:24 - super technical detail but honestly it's
230:27 - very hard to remember it all and you'll
230:29 - be okay if you just generally understand
230:31 - that
230:32 - for ingress we have a type load balancer
230:34 - of the service or kubernetes ingress and
230:36 - then for egress it's going to use the
230:38 - container network interface plug-in to
230:40 - uh get to access stuff and they might
230:42 - probably won't even ask that the egress
230:44 - one but there you go
230:49 - [Music]
230:50 - hey this is andrew brown from exam pro
230:52 - and we are looking at the four c's of
230:54 - cloud native security which is cloud
230:56 - clusters containers and code and that
230:58 - order does matter because each layer of
231:01 - cloud native security models builds upon
231:04 - the next outmost layer and so we could
231:06 - describe uh this generally just as depth
231:09 - and defense so you know the four c's is
231:12 - just kind of a um
231:14 - a framework or a mental model to think
231:17 - about cloud native security but it just
231:19 - really is the general idea of depth of
231:21 - defense which you might see if you're
231:23 - looking at the security of data centers
231:24 - but it is a series of defensive
231:26 - mechanisms that are layered in order to
231:28 - protect valuable data and information so
231:31 - the idea is that you have a malicious
231:32 - actor and they're trying to make it to
231:34 - your data so what layers are they going
231:36 - to be going through so first we have the
231:38 - cloud layer so that would be something
231:39 - like aws you have your cluster layer
231:41 - like something like kubernetes mesos
231:44 - docker swarm containers so maybe your
231:48 - runtime is container d or you could just
231:49 - say docker in that sense uh and then
231:52 - your your code and and there there could
231:54 - be your code and
231:55 - your data or information i probably
231:57 - should have made a nice little like uh
232:00 - data file there to indicate what they
232:02 - were looking for but i didn't
232:04 - but yeah those are the four layers and
232:06 - you absolutely need to know the order
232:09 - now how much do you need to know about
232:10 - the interior or how they actually like
232:13 - what uh defensive mechanisms right that
232:16 - you need to implement which would be
232:17 - here at the border of uh passing into it
232:21 - um
232:22 - not too sure for kcna i didn't see too
232:24 - much stuff but we are going to walk
232:25 - through each layer and look at what it
232:27 - takes to secure them so that we just
232:29 - round out our security knowledge for
232:32 - kubernetes and cloud native workloads
232:34 - okay
232:34 - [Music]
232:38 - all right let's take a look at the first
232:40 - layer which is the cloud layer and this
232:41 - is also known as the base layer because
232:43 - it's the basis for all the other layers
232:45 - you have to pass through the cloud layer
232:47 - before you can go to any of the other
232:48 - layers so security at this layer is
232:50 - going to vary based on managed or
232:53 - self-managed infrastructure
232:55 - so the idea here is we have
232:57 - the managed infrastructure so
232:59 - infrastructure as a service as we would
233:01 - know
233:02 - from our cloud service provider
233:03 - knowledge
233:04 - or self-managed so for managed
233:07 - infrastructure you can think of any
233:09 - cloud service provider bus azure gcp
233:12 - oracle oracle ibm cloud or a cloud
233:15 - platform so think something like civo
233:18 - and so the main difference between a csp
233:20 - and a cloud platform is a cloud platform
233:22 - it's kind of like a precursor to a cloud
233:24 - service uh provider same thing as like a
233:27 - virtual private server it's just that um
233:29 - they might not have all the elements of
233:30 - it maybe they don't have a lot of
233:32 - services um or they're just a
233:36 - highly focused on just a very specific
233:39 - thing just like just giving you
233:41 - kubernetes and just a load balancer and
233:43 - things like that so security is going to
233:45 - greatly vary based on the provider and
233:47 - you'll have to do independent research
233:49 - to determine what you'll need to do so
233:52 - if you're on aws and
233:54 - you're deploying to eks which is what
233:56 - you'd use elastic kubernetes service
233:58 - you're going to have to research what
233:59 - the best security practices for eks
234:02 - because when you're using managed
234:03 - infrastructure the responsibility
234:05 - infrastructure is the cloud provider so
234:08 - um
234:09 - maybe all of it is taking care of you
234:11 - and but there might be some things you
234:13 - still have to worry about but let's take
234:14 - a look at self-managed so self-managed
234:16 - would be um code located servers so
234:19 - think of equinix
234:20 - i don't know if that's how you pronounce
234:22 - it properly i've never said it out loud
234:23 - before
234:24 - or corporate data centers so basically
234:26 - you have the machines you have the
234:28 - office space or you're renting out an
234:29 - office space and you're directly working
234:31 - with the machines and you don't you
234:33 - don't have a cloud layer or you're
234:34 - installing your own cloud layer onto
234:36 - um
234:38 - those uh those servers so security is
234:40 - going to be based on the infrastructure
234:42 - security such as network access to api
234:44 - servers the control plane network access
234:46 - to nodes kubernetes access to cloud
234:49 - provider apis access to fcd lcd
234:52 - encryption um
234:55 - and so you know hopefully that gives you
234:56 - kind of an idea of infrastructure
234:59 - security there of course if you can go
235:01 - with managed it's going to be a lot
235:02 - easier but kubernetes is flexible so you
235:04 - can use it anywhere you want
235:06 - it just depends on how much
235:07 - responsibility you want to have
235:13 - [Music]
235:14 - all right let's take a look here at the
235:16 - cluster layer and there are two parts of
235:18 - cluster layer security you have
235:20 - components of the cluster and components
235:23 - in the cluster and remember a cluster
235:24 - could be
235:26 - um and i mean we're talking about
235:27 - kubernetes in particular so you think
235:29 - they'd just say this is uh
235:31 - kubernetes uh security but um no matter
235:34 - if you're using kubernetes mesos or a
235:37 - docker swarm which are orchestration
235:39 - tools that set up clusters um this stuff
235:42 - kind of applies but everything in the
235:44 - context here is kubernetes so for
235:46 - components of the cluster we're securing
235:48 - configurable cluster components for
235:51 - components in the cluster we're securing
235:54 - applications running within the cluster
235:56 - so one is focused on the components and
235:58 - one is focused on the applications so on
236:01 - the component side there's a lot of
236:04 - things you can do so let's go through
236:06 - this list and it is huge but we will uh
236:08 - do it anyway so we have controlling
236:10 - access to cube api using tls for api
236:14 - traffic api authentication api
236:17 - authorization controlling access to
236:20 - cubelet controlling capabilities of a
236:22 - workload or user runtime limiting
236:24 - resources usage on a cluster controlling
236:27 - what privileges containers run with
236:29 - preventing containers from loading
236:31 - unwanted kernel modules restricting
236:34 - network access restricting cloud
236:36 - metadata api access controlling which
236:38 - nodes pods may access protecting cluster
236:41 - components from compromise restrict
236:44 - access to fcd enable audit logging
236:46 - restrict access to alpha or beta
236:48 - features rotate infrastructure
236:50 - credentials frequently review
236:52 - third-party integrations before enabling
236:55 - them encrypt secrets at rest
236:58 - receiving alerts for uh security updates
237:00 - and reporting vulnerabilities so that is
237:02 - a big old list but it gives you an idea
237:05 - that there's a lot of work on the
237:06 - cluster side
237:08 - and i would think and i don't know but i
237:10 - would think that using something like
237:11 - k-native which uh basically takes a
237:14 - strong opinion on how to set everything
237:16 - up for you might reduce some of that
237:18 - burden um but i mean this is what you
237:20 - get when you use kubernetes you have uh
237:22 - full access of all the components
237:24 - underneath so you have more of an
237:26 - obligation to secure those let's talk
237:28 - about in the cluster securing the
237:30 - applications running within the cluster
237:32 - so rbac authorization authentication
237:36 - application secrets management ensuring
237:38 - the pods meet the pod security standards
237:41 - quality of assurance network policies
237:44 - tls for kubernetes ingress so you can
237:46 - see there's a huge difference of
237:48 - responsibilities here between of the
237:50 - cluster and in the cluster
237:52 - [Music]
237:57 - all right let's take a look at the
237:58 - container encode layer now these are
237:59 - separate layers but there wasn't a lot
238:02 - for me to say about each one without
238:03 - going super deep on particular
238:06 - ways of implementing them so i just
238:08 - group them together here
238:10 - so we have container layer and the code
238:12 - layers the container layer
238:13 - things that we can do at this layer to
238:15 - protect the container would be container
238:16 - vulnerability scanning or os dependency
238:18 - securities image signing and enforcement
238:21 - disallowing privileged users using the
238:23 - container runtime with stronger
238:25 - isolation
238:26 - okay and that could be choosing
238:28 - like virtualized container runtimes
238:30 - which we talked about in our runtime
238:32 - section right
238:33 - for the code layer the application code
238:35 - is one of the primary tax services over
238:37 - which you have the most control so um i
238:40 - mean you know you have a lot of options
238:42 - here but we don't list a whole lot here
238:44 - so access over tls only so make sure you
238:46 - use https for your application limiting
238:49 - port ranges of communication so like if
238:51 - it's a database maybe don't make it
238:52 - public facing or limit it to only your
238:54 - ip address third-party dependency
238:56 - security so like if you're installing
238:58 - like
239:00 - node.js modules make sure that they are
239:02 - up to date and safe or use a tool like
239:04 - sneak that will detect and tell you
239:07 - whether there's a problem with it or not
239:09 - static code analysis
239:11 - which you know is kind of similar to
239:13 - third party it actually looks it's not
239:15 - just saying like hey we know that
239:16 - there's a history of problems with these
239:18 - things but we'll actually look at the
239:19 - code and tell you if we find a problem i
239:21 - think like it was devops guru does that
239:23 - but you have to use particular languages
239:25 - like python or java dynamic probing
239:27 - attacks so you know pen testing
239:29 - basically for your application um you
239:32 - know and then for the code layer you
239:34 - know you follow all the good wasp rules
239:36 - so aus has like a top 10 for application
239:38 - defense it's going to be the same here
239:40 - but there you go
239:42 - [Music]
239:45 - all right let's talk about
239:46 - infrastructure security we actually did
239:48 - kind of cover this in a brief earlier
239:51 - when we were talking about managed cloud
239:52 - service providers because they take care
239:54 - of all the stuff
239:55 - for you but these are the suggestions
239:57 - for securing infrastructure in a
239:59 - kubernetes cluster the first is network
240:01 - access to the api server which is your
240:02 - control plane so
240:04 - all access to the kubernetes control
240:06 - plane is not allowed publicly on the
240:07 - internet and is controlled by network
240:09 - access control lists restricted to the
240:11 - set ip addresses needed to administer
240:13 - the cluster so pretty clear don't make
240:15 - it publicly available
240:17 - network access to nodes nodes should be
240:19 - configured to only accept connections
240:20 - from the control plane
240:22 - on the specified ports and accept
240:24 - connections for services and kubernetes
240:26 - to uh of a type node port or load
240:28 - balancer
240:30 - and you know just put a load balancer in
240:32 - front of that and you should be a-okay
240:35 - like you know like a cloud one or
240:37 - something like that kubernetes access to
240:38 - a cloud provider api
240:40 - so each cloud provider grants a
240:42 - different set of permissions so now
240:44 - we're talking about cloud providers to
240:45 - create control planning nodes it's best
240:47 - uh to provide the cluster with cloud
240:49 - provider access that falls the principle
240:51 - of lease privilege so p-o-l-p
240:54 - that's the initialism for that for the
240:55 - resources it needs to administer so this
240:57 - is just like imagine you're on aws and
240:58 - you make a
241:00 - a role just make sure that role is given
241:02 - to somebody that should have it or you
241:05 - know just limit that kind of stuff there
241:07 - access to fcd so access that cd the
241:09 - database store for grace should be
241:11 - limited to control plane only depending
241:13 - on your configuration you should attempt
241:14 - to use xd over tls more information can
241:17 - be found in the std documentation
241:20 - xcd encryption so whenever possible it's
241:22 - a good practice to encrypt all storage
241:23 - at rest and send lcd holds the state of
241:26 - the entire cluster including secrets it
241:28 - disks should especially be encrypted at
241:30 - rest again if you're using cloud service
241:32 - providers they'll usually integrate with
241:35 - the provider so like on aws it would use
241:37 - kms for
241:39 - azure and use um vault store and
241:41 - sometimes it's like just a check box
241:43 - during the setup so you know it makes
241:45 - that things a lot easier for you so
241:47 - there you go
241:48 - [Music]
241:52 - all right let's talk about the concept
241:53 - of the three a's authentication
241:54 - authorization accounting framework for
241:56 - identity management systems so it's just
241:58 - a a security concept that is good to
242:01 - know um and so let's talk about the
242:04 - first one authentication this uh deals
242:06 - with your identity so this is how do we
242:08 - know who you are and so this could be
242:11 - utilizing a static password you enter
242:13 - password and therefore must be you
242:14 - a one-time password so we send you
242:18 - um maybe we do the password but we also
242:20 - send you a one-time password to your
242:21 - phone you enter it in to make sure
242:24 - double check that you are who you say
242:25 - you are
242:26 - uh we know this is multi-factor
242:28 - authentication ufa
242:30 - digital certificates would be another
242:32 - way so remember the identity is in the
242:34 - certificate um
242:35 - and so
242:36 - if it's self-signed i don't know if we
242:38 - can trust it but if it is signed by
242:41 - some kind of certificate authority then
242:43 - they say yes we attest to this person is
242:45 - we are and we because we issued it to
242:47 - them right
242:48 - basic auth could be something um like
242:50 - trying to get access to um an
242:52 - application so we apply basic auth
242:55 - there as well we have authorization so
242:57 - to get permission so we know who you are
242:59 - but what do you get to access and in
243:01 - kubernetes this is going to be role
243:02 - based access controls rbac
243:05 - for other things like azure um you know
243:08 - they and it's still role-based access
243:09 - controls but they might have risk
243:10 - adaptive based policies so they might
243:12 - factor in a bunch of smart information
243:15 - about your location the time of day the
243:17 - device things like that to determine
243:20 - what you get access to but for
243:21 - kubernetes it's just rbac okay then we
243:24 - have accounting or auditing to audit to
243:27 - login audit trails so in kubernetes
243:30 - there's something called audit policy so
243:31 - i suppose that's just like
243:33 - uh i can't remember but they have other
243:35 - policies and they have audit back ends
243:37 - so that's where the logs will be stored
243:39 - um so you know it's not super important
243:42 - for the exam but the concept of the aaa
243:44 - is something that uh you should know uh
243:47 - in terms of security because sometimes
243:48 - they mention it especially in the
243:50 - kubernetes space so i just wanted to
243:51 - make sure you knew the three a's okay
243:53 - [Music]
243:58 - hey this is andrew brown from exam pro
243:59 - and we're taking a look at role-based
244:01 - access controls also known as rbac or
244:04 - some people like to say are back and and
244:06 - role-based access controls is not a
244:08 - concept
244:09 - just limited to kubernetes
244:12 - but it is something that kubernetes can
244:14 - do and is very popular among cloud
244:16 - service providers it is a way of
244:17 - defining permissions for identities
244:19 - based on a organizational role so rbac
244:22 - authorizations use the rbac
244:25 - authorizations k-8 io api group
244:29 - to drive authorization decisions
244:31 - allowing you to dynamically configure
244:33 - policies through the kubernetes api and
244:36 - when i show you things like this it's
244:38 - because i want you to remember them just
244:39 - in case you see them on the exam when i
244:42 - point out these random things but i
244:43 - don't always describe them in detail
244:46 - because i just don't think it matters um
244:48 - but to enable rbac start the api server
244:50 - with the authorization mode flag so if
244:53 - you're starting one up you'd use cube
244:54 - api um server i can remember what the
244:57 - one like in the ckd or ck that use ck
245:00 - they do like cube add adm or whatever to
245:02 - start up clusters but you do have to
245:04 - specify the mode if you are using
245:07 - a lightweight distribution like micro k8
245:10 - you can just enable it by adding the
245:13 - add-on rbac and it basically be doing
245:15 - this underneath if you're using managed
245:17 - services like aws azure tcp it might be
245:20 - turned on by default you might just have
245:22 - to hit checkbox because you're not the
245:24 - one starting up the cluster but you need
245:27 - to know this
245:28 - it might show up on the exam so that's
245:29 - why i'm showing to you
245:31 - not that we would ever have to provision
245:32 - our own server
245:34 - in the kcna but you might want to need
245:35 - to know that flag so with kubernetes
245:38 - rbac there are only allow rules and
245:40 - everything is denied by
245:42 - default so if you were to create a new
245:44 - user they would have access to nothing
245:46 - you'd have to give them a role with
245:48 - permissions to be able to do something
245:50 - okay
245:52 - [Music]
245:56 - all right so the rbac api declares four
246:00 - kinds of kubernetes objects we have
246:01 - roles role binding cluster role cluster
246:03 - role binding so here is the diagram uh
246:06 - that we see here and so we have roles
246:09 - which is a set of permissions for a
246:11 - particular namespace and then cluster
246:13 - role which is a set of permission across
246:15 - all namespaces there are some kubernetes
246:17 - components that cannot be named space so
246:19 - i would imagine that if you had to
246:22 - give them permissions they'd have to be
246:23 - in cluster rule or there are um
246:26 - components that can be uh in more than
246:28 - one name system at the same time so
246:30 - again maybe that's where
246:32 - cluster rule might play a part
246:34 - so that's the reason for the two
246:36 - different ones in order for um
246:40 - roles or cluster roles to be bound to a
246:44 - subject that's where you're going to
246:45 - need um a binding and so for a role you
246:49 - have a role binding for a cluster role
246:51 - you have a cluster role binding and so
246:55 - those are going to attach to subjects
246:56 - which are just essentially identities
246:58 - like a user account which would be a
247:00 - single user a service account which
247:02 - represents a machine user to be used by
247:04 - an application service a group which is
247:07 - a group of users or services service
247:09 - accounts and just notice here that for
247:12 - both we do have this this binding in
247:14 - between each one
247:16 - and the thing is is that when you're
247:17 - using cloud service providers or other
247:19 - things with rbac you usually don't have
247:21 - to worry about that component but in the
247:23 - world of kubernetes where everything is
247:25 - decoupled and you can see all the
247:26 - components underneath um you know we
247:29 - have to manage that component
247:30 - so it's not too hard to use
247:33 - and just to kind of tell you a little
247:35 - bit about machine user just because this
247:36 - one that's a service kind of threw me
247:38 - off but then when i realized it was a
247:40 - machine user it made sense but if you
247:41 - don't even know what a machine user is
247:43 - um that's like let's say you are on
247:46 - github and
247:48 - or like you have a project that you want
247:49 - to deploy to a server but you need to
247:51 - have access to github so you go and you
247:54 - can use your main
247:55 - uh github account but that might have
247:57 - access to all your repositories and
248:00 - that's just too much
248:02 - permission so what you do is you create
248:03 - a new user with the intent to be just to
248:06 - be used for deployment so it only has
248:08 - access to the repo and permissions to
248:10 - read and things like that and so that's
248:12 - the idea behind a machine user it's for
248:14 - the usage of service it's not tied to a
248:16 - specific person okay
248:19 - [Music]
248:23 - all right let's take a look at the role
248:24 - configuration example and so
248:27 - i mean there is the role and cluster
248:29 - role but they're very similar
248:31 - but the key thing is that uh the role
248:34 - sets a namespace so here it says
248:35 - namespace default where with a cluster
248:38 - role you're not worried about namespaces
248:41 - so here you can change the kind to role
248:43 - or cluster role then you have your rules
248:45 - or permissions of actions this role is
248:48 - allowed to perform so we have api groups
248:51 - and we do this in the cube ctl extras
248:54 - where i list out the api resources which
248:56 - is a command that you definitely will
248:58 - need to know for the exam that shows you
249:00 - all the possible groups so if you just
249:02 - leave it blank there like that then it's
249:03 - going to consider all core api groups um
249:06 - and i imagine that you can do a comma
249:08 - and it's just say the exact groups that
249:10 - you want then the resources of that
249:12 - group
249:13 - and then you have verbs so get watch
249:16 - list things would be other things like
249:19 - patch delete update
249:21 - create things like that but the exam
249:23 - doesn't really test you on that kind of
249:24 - stuff but this is just practical
249:26 - knowledge you should know
249:27 - of course you would have to create a
249:28 - rule binding we do all that stuff in the
249:30 - follow along so even though we're not
249:32 - seeing a lot here we will do a practical
249:34 - example but we're not going to do a
249:35 - cluster rule just because it's a lot of
249:37 - work and outside the scope of the kcna
249:39 - but this gives you kind of an idea of
249:40 - what you'd have to do
249:42 - [Music]
249:46 - hey this is andrew brown from exam pro
249:48 - and we are looking at secrets management
249:50 - so a secret is similar to a config map
249:52 - with the exception that they can be
249:54 - encrypted so here's an example um i mean
249:57 - it's very simple but
249:58 - just imagine instead of having config
250:00 - map now we have secret um and the
250:03 - configuration is pretty similar but what
250:06 - you're going to have is a type
250:08 - of secret so this one says basic auth
250:10 - and then the idea is we have string data
250:13 - so based on the type is going to be
250:15 - uh different on what you ingest here um
250:18 - so basic basic auth is a way of gaining
250:20 - access to a website so and it will
250:22 - prompt you with a very ugly box saying
250:25 - enter your username and password so it
250:26 - makes sense that that's what that does
250:28 - there so by default secrets are
250:31 - unencrypted in scd school uh store and
250:34 - anyone with access to the fcd store has
250:36 - access to the secrets so anyone who has
250:39 - access to pods within namespaces uh will
250:42 - have access to the secrets used by that
250:45 - pods so it's very important to
250:46 - understand by default
250:49 - they're unencrypted okay and you have to
250:50 - do a bit of work
250:52 - to
250:54 - make them encrypted or make sure that
250:55 - they are secured and so those steps
250:58 - would be
250:58 - to enable encryption at rest for secrets
251:01 - enable or configure rbac rules that
251:04 - restrict reading data in secrets use
251:06 - mechanisms such as rbac to limit which
251:09 - principles are allowed to create new
251:11 - secrets or replace existing ones and you
251:14 - know for the exam you just need to know
251:16 - what a secret is
251:18 - i just thought it was important that you
251:19 - understand that they're unencrypted um
251:21 - and they're pretty much just like
251:22 - configmap but just slightly different
251:24 - and they have a bunch of different types
251:26 - okay
251:27 - [Music]
251:31 - hey this is andrew brown from exam pro
251:33 - and we are looking at network policies
251:34 - so network policies acts as virtual
251:36 - firewalls for pod communication and pod
251:39 - communication can be restricted based on
251:41 - the following scopes pod to pod name
251:44 - spaces or specific ips so just to kind
251:46 - of visualize it if you have a network
251:48 - policy the idea is that you can control
251:50 - the ingress and you can control uh the
251:53 - egress um is that the right thing is
251:55 - that sorry you know what one second here
251:57 - i think the thing is
252:00 - i mean like they both are pointing
252:01 - ingress actually so this these are both
252:03 - going in
252:04 - right but you can also say what's going
252:06 - out and so i guess this graphic could
252:07 - have been a little bit better but you
252:09 - get the idea there's ingress and there
252:11 - are egress but we actually do set up a
252:13 - network policy so you'll see in the
252:15 - follow along now selectors are used to
252:17 - determine to select resources with
252:19 - matching labels for the network policies
252:21 - to be applied to except with the
252:23 - exception of specific ips
252:25 - um and the network plug-in you are using
252:27 - must support network policies so if you
252:30 - don't have a network plug-in installed
252:33 - like calco weave net psyllium i have no
252:35 - idea if that's how you say it um it's
252:37 - just not going to work right so you can
252:39 - create a network policy but if you test
252:42 - it out without having one uh a plug-in
252:45 - installed it just won't do anything
252:47 - it'll be like the policy doesn't exist
252:49 - and we do actually cover that edge case
252:51 - in the fall long so you can see uh but
252:53 - calico and weave net are pretty popular
252:55 - uh but there you go
253:01 - hey this is andrew brown from exam pro
253:02 - and we are taking a look at calico so
253:04 - calico is an open source network and
253:06 - network security solution for containers
253:08 - vms native host space workloads and
253:10 - something we absolutely need if we're
253:11 - going to be working with network
253:12 - policies so calco supports a broad range
253:15 - of platforms including kubernetes
253:17 - openshift mirantis kubernetes engine no
253:20 - idea what that is but sounds cool open
253:22 - stack bare metal services
253:25 - and calico gives you a choice of data
253:27 - planes so you can use
253:29 - berkeley packets that's what
253:31 - ebpfs are
253:33 - standard linux
253:34 - hns on windows so there's a few
253:37 - different data planes for that
253:39 - and data planes is just like the mo the
253:41 - means of communication okay
253:43 - uh calico network policies extend the
253:45 - base functionality of network policies
253:46 - so i say
253:48 - in the network policy section that if we
253:50 - do not install something uh our network
253:52 - policies will either work or
253:54 - do very little okay so
253:56 - um calculate network policies um do a
253:59 - few things it will make policies that
254:01 - could be applied to any object uh the
254:03 - rules it's not he
254:05 - it's just the
254:06 - the t is missing there so
254:08 - the rules can contain um uh the specific
254:11 - action you can use ports port ranges
254:14 - protocols ip subnets selectors on the
254:16 - rules you can control traffic flows via
254:19 - dnat
254:20 - um i think that's destination network
254:22 - address translation i think that's the
254:23 - ds4 settings and policies for traffic
254:26 - forwarding
254:27 - so really without it you're not gonna
254:28 - like without it you're just not gonna
254:30 - have good network policies uh calico can
254:32 - perform better than alternatives like
254:34 - flannel
254:35 - uh there should be comma here psyllium
254:37 - and weave nets so because i was looking
254:39 - up like what what does calico do you
254:41 - know what i mean like why would you use
254:42 - it over other ones and basically it's
254:44 - just performance
254:46 - uh like in terms of resources it's using
254:48 - and and its flavor of network policies
254:50 - that's the major reason why
254:52 - and uh calico is what we use uh in the
254:55 - course okay
254:57 - [Music]
255:00 - all right let's take a look at the
255:02 - autonomy of a network policy file so
255:05 - these are the files that we would create
255:07 - um because once you install calico and
255:08 - we're using them
255:10 - um and i think that when you install
255:12 - different ones it might change the
255:13 - syntax slightly of this but i'm not 100
255:16 - sure on that um but anyway so the idea
255:20 - is i'm just trying to get my pen tool
255:21 - out here um
255:23 - is that you know
255:25 - in this network policy you're either
255:27 - going to specify a pod selector or a
255:28 - namespace selector because network
255:30 - policies are either scoped on the
255:32 - namespace or the pod or you're selecting
255:34 - very specific ip addresses and there's
255:37 - two policy types ingress and egress and
255:39 - you can have them both in the same file
255:41 - so ingress defines traffic that's
255:43 - permitted
255:44 - to enter the pod and then you have uh
255:47 - traffic that egress that can exit the
255:49 - pod and you even say like ingress
255:52 - is allowed specifically from this
255:53 - namespace specifically from these pods
255:56 - and block these ip addresses right and
255:58 - the traffic has to be on this port
256:00 - okay so that kind of gives you an idea
256:02 - of it but we are going to write a
256:03 - network policy so uh we'll get hands on
256:06 - there and that's where we will really
256:07 - learn what we're doing okay
256:09 - [Music]
256:13 - all right let's talk about in transit uh
256:15 - versus at rest encryption so in transit
256:17 - is data that is secure when moving
256:19 - between locations like algorithms tls
256:22 - and slssl and then encryption at rest is
256:25 - data that is secure when residing on
256:27 - storage within a database or
256:30 - even something like block store like a
256:32 - volume so you see algorithms like aes
256:35 - ras and so
256:37 - uh two protocols or algorithms we should
256:40 - really talk about is tls and ssl because
256:42 - they are very popular and they can be
256:45 - easy to mix up so tls is an encryption
256:48 - protocol for data integrity between two
256:50 - or more communication
256:52 - computer applications so tls 1.0 and 1.1
256:56 - are
256:57 - deprecated
257:00 - and i use this
257:01 - wrong a lot of times but i'm pretty sure
257:02 - it's deprecated and so now the current
257:04 - practices uh 1.2 or 1.3 is the current
257:07 - best practice but at one point it was
257:09 - ssl you know so um you know an
257:12 - encryption protocol for data integrity
257:14 - between two or more communications uh
257:17 - computer application like 1.0 two and
257:19 - three so it goes back and forth um i
257:22 - think we're on tls now but you'll still
257:25 - see us talk about ssl as if we're using
257:27 - it but probably we're using tls
257:30 - um you know in the context of kubernetes
257:33 - when you are communicating uh traffic
257:35 - inbounds you want to be
257:37 - using https which would underneath be
257:40 - using
257:40 - that encryption transit like tls and
257:42 - then your volumes which are going to be
257:44 - on
257:45 - uh most likely managed providers like
257:48 - elastic block store or
257:50 - azure disk and you're going to be using
257:52 - whatever encryption method they use for
257:54 - that but that generally gives you the
257:56 - idea okay
257:57 - [Music]
258:02 - hey this is andrew brown from exam pro
258:03 - and we're looking at certificates in tls
258:05 - so kubernetes provides an api called
258:07 - certificate kubernetes io which lets you
258:10 - provision tls certificates signed by
258:12 - certificate authorities cas that you
258:14 - control the ucas and certificates can be
258:17 - used by your workloads to establish
258:18 - trust uh and even though like in my
258:20 - 15-year career i just never can remember
258:24 - what these things are like i know what
258:25 - they are but i just mean like the
258:27 - specification and all the settings
258:28 - underneath so if you find them like a
258:31 - little bit uh daunting or confusing just
258:33 - understand that i've been doing for a
258:34 - long time and even i don't remember so
258:37 - what is public key infrastructure so pki
258:39 - so pka is a set of rules policies
258:41 - hardware software procedures needed to
258:43 - create manage distribute
258:45 - use store and revoke digital
258:47 - certificates and manage public key
258:49 - encryption so it sounds like a very
258:51 - fancy system for managing public keys
258:54 - what is x 509 certificate because we
258:58 - hear this a lot in the web
259:01 - it's a standard defined by the
259:02 - international telecommission uh union
259:04 - itu for public key
259:07 - certifications if you've ever had to
259:09 - open up like an ssl certificate i
259:11 - believe it follows the 509
259:14 - standard here so these certificates are
259:16 - used in many internet protocols so as i
259:18 - said ssl tls and https that's where you
259:20 - most commonly see it or the pro probably
259:23 - the first time you ever saw it if you've
259:25 - been in the uh in
259:27 - the cloud or web development for quite a
259:29 - few years signed and encrypted emails
259:32 - code signing or document signing so like
259:34 - when you submit code to your repo you
259:36 - can sign it to be like yes this code
259:37 - came for me um a certificate contains an
259:40 - identity like a hostname organizational
259:42 - individual so like who is the
259:44 - certificate we're signing on the behalf
259:45 - of a public key so these are algorithms
259:48 - like rsa dsa ecda and you can use a
259:51 - variety of different ones so kubernetes
259:54 - requires pkp pki for the following
259:58 - operations client or client certificates
260:00 - for the cubelet to authenticate to the
260:02 - api server server certificate for the
260:05 - api server endpoint
260:07 - client certificates for administrators
260:09 - for the cluster to authenticate to the
260:11 - api server
260:12 - client certificates for the api server
260:14 - to talk to cubelets
260:15 - client certificates for the api server
260:17 - to talk to xcd
260:19 - client certificates cubeconfig for the
260:21 - controller manager to talk to the api
260:23 - server it's always talking to somebody
260:25 - here client certificate cube config for
260:28 - the schedule is to talk to the api
260:29 - server client and server certificates
260:32 - for front proxies most of these are
260:34 - going to be stored in
260:36 - etc for close communities pki it's going
260:39 - to vary for lightweight distributions
260:40 - like micro kubernetes we'll place them
260:42 - somewhere else minicube will place them
260:44 - somewhere else
260:45 - and when you create a cluster generally
260:46 - it creates one for you like a key but
260:48 - there's actually a bunch of keys for a
260:50 - bunch of different things
260:52 - we will come across this when we need to
260:54 - um
260:56 - do our back roll uh roll base access
260:58 - controls because we will want to have a
261:00 - user and we'll have to generate a
261:02 - self-signing key like we are the
261:04 - authority for it and we'll have to sign
261:06 - it against
261:07 - keys from the cluster and so that's
261:09 - going to be our exposure
261:11 - to this stuff and i always find it kind
261:13 - of hard but you know what we do have to
261:14 - learn it and it's not too bad okay
261:16 - [Music]
261:21 - hey this is andrew brown from exam pro
261:23 - and we are looking at kubernetes
261:24 - security best practices and i got these
261:26 - from aqua security so it's just a a
261:30 - summary of
261:31 - what aqua has on one of their websites
261:34 - and if you don't know aqua security they
261:36 - are a really well-known security company
261:39 - that has products and services
261:41 - um and so the recommendations here is
261:43 - enable kubernetes role-based access
261:45 - controls uh because as soon as they're
261:47 - enabled that means that all users by
261:49 - default
261:50 - do not have access and then you have to
261:52 - give them permission and that's a great
261:54 - idea
261:55 - use third party authentication for api
261:57 - server so um authentication could be
262:01 - octa
262:02 - maybe cognito
262:04 - any kind of decentralized authentication
262:06 - system azure active directory again i
262:09 - don't know how those would integrate but
262:10 - using a third party authentication is
262:12 - just generally a good idea protect xcd
262:15 - with tls firewall and encryption so that
262:18 - sounds like a good idea i thought tls
262:20 - was just on by default so i'm not
262:23 - exactly sure um about that but uh i mean
262:26 - it sounds like a good suggestion it did
262:28 - come up
262:29 - when we were talking about
262:30 - infrastructure security in the or
262:33 - uh cloud cloud layer of security and
262:35 - infrastructure security
262:37 - so isolate kubernetes nodes so maybe
262:40 - isolation or sorry nodes so yeah uh i
262:43 - mean if you want to isolate workloads
262:45 - that's using namespaces but i suppose
262:48 - isolating nodes is a different story
262:51 - monitor network traffic to limit
262:53 - communication so
262:55 - maybe that's installing a service mesh
262:58 - uh just ha like holding on to kubernetes
263:01 - logs i'm not sure
263:02 - uh there but i mean monitoring is always
263:04 - a good idea use process white listing so
263:08 - you know if you have a machine like a
263:10 - linux machine and it's running
263:11 - particular processes only allow certain
263:14 - processes and and everything else should
263:16 - be denied turn on audit logging sounds
263:18 - like a good idea
263:20 - logging the idea is that if you have
263:22 - logs make sure that no one is tampering
263:24 - with your logs keep kubernetes versions
263:26 - up to date with managed kubernetes
263:29 - providers a lot of them will do that for
263:30 - you so that's one advantage of using
263:32 - something like
263:34 - google cloud's
263:36 - google kubernetes engine
263:38 - and we have a lockdown cubelet so you
263:40 - know some of this advice we saw in
263:43 - the layers section but it's generally
263:45 - good advice here i just wanted to share
263:47 - it again
263:48 - [Music]
263:52 - hey this is andrew brown from exam pro
263:54 - and we are looking at auto scaling so
263:56 - what is auto scaling well in computing
263:57 - auto scaling is when systems without
263:59 - manual intervention adjust capacity the
264:01 - amount of cpu and ram to meet the demand
264:03 - uh traffic from users by adding or
264:05 - removing resources commonly triggered by
264:06 - events uh so for pod based scaling uh we
264:10 - have two things we have the horizontal
264:12 - pod
264:12 - scaling so that's the horizontal pod
264:15 - auto scaler which is what we'll create
264:16 - when we create a manifest file which
264:18 - adds more pods to meet the demands and
264:20 - then we have vertical pod scaling so the
264:22 - vertical pod auto scaler which right
264:24 - size pods for optimal cpu and memory
264:26 - resources then there is node base or
264:28 - cluster based scaling depending on the
264:30 - way you want to call it and so this is
264:32 - where we have the cluster auto scaling
264:34 - and so its implementation because this
264:36 - is more reliant on um uh managed
264:39 - providers or things like that the
264:41 - solution is uh uh kind of like
264:44 - third-party or integrated so we have
264:45 - cluster auto scaler and then we have
264:47 - carpenter and this will add or remove
264:49 - nodes uh based on the demand
264:52 - and then there's the cluster api so this
264:55 - is a declarative api and tooling to
264:57 - simplify provisioning upgrading and
264:59 - operating multiple kubernetes clusters
265:01 - the cluster api can be extended to
265:03 - support any infrastructure and bootstrap
265:05 - or control plane providers so i don't
265:08 - know for sure if cluster autoscaler is
265:11 - using cluster api i think it is i just
265:13 - can't remember um but you know my guess
265:16 - would be you know maybe carpenter and
265:19 - auto scaler leverages cluster api but
265:22 - these are all kind of components that
265:23 - are involved here for the case dna uh
265:26 - we're not going to even uh notice
265:28 - cholesterol is going this is really
265:29 - complicated and vertical pod scaling no
265:31 - but horizontal plot autoscaler is easy
265:33 - to learn and use and so we will do that
265:35 - one okay
265:37 - [Music]
265:41 - hey this is andrew brown from exam pro
265:43 - and we are looking at scale versus auto
265:45 - scale so the scale command is used to
265:47 - update the amount of replicas in the
265:49 - state of a deployment object and perform
265:51 - a deploy so here we have a scale we
265:55 - specify the amount of replicas and
265:57 - what that will do is just update the
265:59 - amount of replicas in the state of the
266:01 - deployment object and perform a deploy
266:03 - it's almost like opening up the manifest
266:04 - file of your deployment file just
266:06 - changing the number and redeploying the
266:08 - only difference is that
266:09 - that obviously won't persist in the
266:10 - manifest file so you're doing it on the
266:12 - fly
266:13 - to those components there
266:16 - then there's auto scale so this command
266:18 - is used to create a horizontal pod auto
266:20 - scaler of course you can create a
266:21 - manifest file and that's what i
266:22 - recommend but if you are making one
266:24 - really quickly there that's all you got
266:26 - to do so this one's doing a replication
266:27 - controller which is really old we don't
266:30 - do those anymore but i guess i just
266:31 - didn't swap that out in time
266:33 - but here this could be i suppose a
266:34 - replica set a deployment it would be a
266:36 - deployment and you'd specify the min the
266:38 - max the cpu percent that's not the only
266:41 - fields you can provide but just
266:43 - understand this one is actually just
266:44 - changing the current capacity this one
266:47 - will actually set up rules to auto scale
266:50 - okay so there you
266:53 - [Music]
266:56 - go hey this is andrew brown from exam
266:59 - pro let's talk about k-e-d-a so k-e-d-a
267:03 - stands for kubernetes event-driven
267:05 - auto-scaling and it's a project that
267:06 - allows you to scale based on event data
267:10 - uh it's not gonna show up on the exam
267:11 - but it's just important to know because
267:13 - it is another
267:14 - component to scaling
267:16 - it allows you to
267:18 - access a wide range of scalars that you
267:20 - normally would not have access to so you
267:23 - might recognize some of these things if
267:24 - you're using cloud service providers so
267:27 - or particular types of open source um
267:31 - tools or projects so like we have kafka
267:33 - active mq
267:35 - aws services like kinesis sqs
267:39 - tons for azure tons blob storage event
267:41 - hub log analytics monitor pipelines
267:43 - application insights service bus
267:45 - storage queue cassandra which is um a
267:49 - it's kind of like it's a it's a
267:50 - column-wide database
267:52 - all sorts of things datadog
267:53 - elasticsearch uh
267:56 - google clouds pub sub ibm mq mongodb
268:00 - mysql new relic post sql prometheus
268:05 - um
268:06 - redis and a whole bunch more so uh you
268:09 - know it is a very powerful tool to have
268:11 - if you need event driven auto scaling uh
268:14 - and i just didn't know what it was and i
268:16 - just felt like we should know in general
268:18 - uh that this thing exists okay
268:25 - hey this is andrew brown from exam pro
268:26 - and we are looking at open standards for
268:28 - cloud native or in particular kubernetes
268:32 - so what is open standard or open
268:34 - standards this is when multiple
268:35 - organizations or technologies adopt a
268:38 - specific technical standard and a
268:40 - standard is considered open when a
268:42 - public facing community can participate
268:44 - on the development maintenance and
268:46 - future changes
268:48 - to that standard and so we have a lot in
268:51 - our cloud native kubernetes sphere so
268:54 - let's take a look at it the first one is
268:55 - the open container initiative so this
268:58 - defines industry standards around
269:00 - container image formats and run times to
269:03 - make sure that all container run times
269:05 - could run images produced by any build
269:08 - tool and so the container open
269:10 - initiative
269:11 - commonly initialized as
269:14 - oci or oci compliant images
269:17 - was created by docker because
269:19 - um you know we needed a way to just kind
269:21 - of standardize container image formats
269:24 - then there's cni container networking
269:26 - interface
269:27 - so this is a specification and libraries
269:29 - for writing plugins to configure network
269:31 - interface in linux containers so we're
269:34 - going to see a lot of these like
269:35 - container x
269:37 - interface like container network
269:38 - interface runtime interface and
269:40 - kubernetes has a lot of these because
269:43 - um and it's not just kubernetes it's
269:45 - just these are designed for
269:48 - any kind of orchestration system that
269:49 - wants to adopt it adopt it because if
269:51 - you buy into these uh container
269:53 - interfaces
269:54 - um then uh you know anyone that's
269:57 - building out these products that are
269:58 - compatible with these plugins
270:00 - can be utilized for any orchestration
270:02 - system okay so it's kind of like a
270:04 - middle layer
270:06 - and it really just makes our ecosystem a
270:08 - lot more rich
270:09 - you have container runtime interface so
270:11 - this plug-in interface which enables
270:13 - cubelet to use a wide variety of
270:15 - container runtimes without the need to
270:17 - recompile
270:19 - so crio is an implementation of
270:21 - kubernetes cri to enable using oci
270:24 - compliant runtimes as an example
270:27 - and i just list that one there just
270:29 - because this is a cri and this is crio
270:31 - and there's no graphic
270:33 - beside it you notice there's no icon
270:35 - it's because it's going to really be
270:36 - dependent on the runtime that you
270:38 - install so they just don't have a
270:39 - general graphic for that you have the
270:41 - container storage interface so a
270:43 - standard for exposing arbitrary block
270:45 - files and storage systems to
270:46 - containerize workloads
270:48 - on container orchestration systems cos
270:52 - sometimes the i guess i should have
270:54 - capitalized the s there but that's fine
270:55 - like kubernetes and then there's open
270:57 - telemetry a collection of tools apis and
271:00 - sdks to instrument generate collect and
271:03 - export telemetry data like metrics logs
271:05 - and traces so these are all the open
271:08 - standards there could be more that i'm
271:09 - not aware of but these are the ones that
271:11 - we care about
271:12 - and hopefully that gives you kind of an
271:13 - idea there okay
271:15 - [Music]
271:20 - hey this is andrew brown from exam pro
271:22 - and we are looking at the cncf
271:24 - governance structure so uh it's
271:27 - important to know this because it does
271:28 - kind of show up on the exam and also
271:30 - just to
271:31 - understand uh uh the whole body of the
271:34 - cncf and how they operate so that you
271:37 - can really trust um the cloud native uh
271:40 - projects
271:42 - and the ecosystem in general so the cncf
271:44 - is composed of three main bodies we have
271:47 - the governing board uh initialized as gb
271:51 - and they're responsible for the
271:52 - marketing and other business oversights
271:55 - and budget decisions and so the gb
271:58 - has the marketing committee as uh one
272:01 - component in the governing board then
272:03 - there's the technical oversight
272:04 - committee known as toc and they're
272:09 - responsible for defining and maintaining
272:11 - technical vision for the variety of
272:13 - projects under the cncf
272:15 - and in that they have special interest
272:17 - groups sigs or sigs then we have end
272:21 - users so euc which i don't really see
272:23 - people ever using um the initialism very
272:26 - often but end user community and there
272:28 - to provide feedback from companies and
272:30 - startups to improve cloud native
272:32 - ecosystems they actually are the
272:33 - companies and startups and so they have
272:36 - their own sigs
272:38 - and then they have user groups a user
272:39 - group would be
272:41 - like a a meetup you know like maybe in
272:43 - toronto
272:44 - there's a cloud native meetup and so
272:47 - they're considered end users
272:49 - and memberships are composed of
272:51 - different tiers platinum gold silver end
272:53 - user academic
272:55 - non-profit members and we will talk
272:57 - about how membership plays a role in
273:00 - terms of what positions you can have and
273:03 - uh what money is involved uh in this
273:06 - structure for the cncf
273:08 - [Music]
273:13 - all right let's take a look here at
273:14 - memberships so the top tier for the cncf
273:16 - memberships is platinum members and this
273:19 - gives you the ability to appoint one
273:21 - representative to the cncf governing
273:23 - board
273:24 - you can appoint one representative as a
273:26 - voting member in any subcommittees or
273:29 - activities of the governing board
273:31 - i enjoy most prominent placement in
273:33 - displays of memberships including on the
273:35 - website
273:37 - most these tiers it's all about the
273:39 - governing board and again um the real
273:42 - power is really being held by the toc
273:44 - because they're making technical
273:46 - decisions on the projects at least
273:48 - that's the way i feel about it
273:50 - because as you uh we read about there
273:52 - the governing board is doing things like
273:53 - marketing and things like that
273:56 - um but you know we gotta get people to
273:57 - pay so that's just how it works we have
273:59 - the gold members so a point one
274:02 - representative to the cncf governing
274:04 - board per every five gold members up to
274:06 - three maximum gold representatives
274:08 - for the silver members the point one
274:11 - representative to the cncf governing
274:12 - board per ten silver members up to three
274:15 - maximum
274:16 - silver representatives we have end user
274:19 - members so participate in end user
274:21 - advisory community
274:23 - as described so nominate one
274:25 - representative to the end user technical
274:27 - advisory board
274:29 - um and i should state that all the tiers
274:31 - above i just didn't want to cram this
274:32 - slide together but if you are
274:34 - uh end user and you're in one of the
274:36 - other tiers you get both benefits
274:38 - for academic and non-profit members
274:40 - participate in limited to academic and
274:43 - non-profit institutions respectively and
274:45 - requires approval by the governing board
274:48 - entitled to identify their organization
274:51 - as members supporting the mission of the
274:53 - cncf to any other rights or benefits as
274:56 - determined by the governing board
274:58 - so we got a bunch of tiers here but
275:00 - where's the money what are people paying
275:02 - to get these memberships
275:04 - and
275:05 - it's expensive you'll see here in a
275:07 - moment so for the platinum members
275:10 - 370 000 usd at three year minimum
275:14 - contracts so companies like aws
275:16 - grafana new relic apple so and there
275:20 - might be more i don't know if i grabbed
275:21 - all the graphics here because we're just
275:22 - limited on space but you get the idea of
275:25 - like what's the spend here for gold
275:27 - members 120 000 annually so we got
275:30 - salesforce american express equinix hcl
275:34 - for silver members it's kind of like on
275:35 - this sliding scale depending on how many
275:38 - employees you have uh the more you have
275:41 - the more you pay so
275:43 - here we just see a bunch of recognizable
275:45 - names hashicorp mastercard accenture
275:48 - digital ocean i thought hashicarp would
275:50 - have been
275:51 - a little bit more up there just because
275:53 - they focus on multi-cloud and cloud
275:55 - native is uh
275:57 - pretty keen on that but that's just
275:58 - where they are uh then for academic and
276:00 - non-profit members a thousand dollars so
276:03 - mitre
276:04 - wikimedia cloud foundry internet2 and
276:07 - then end user members there is no cost
276:10 - so um really the question is what kind
276:13 - of powers does the governing board have
276:15 - and so we'll look at that next
276:20 - [Music]
276:22 - all right let's take a look here at the
276:23 - governing board and see what kind of
276:25 - powers they do have so governing board
276:27 - is responsible for marketing and other
276:29 - business oversights and budget decisions
276:30 - for the cncf and so here's the graphic i
276:33 - pulled from
276:35 - the website so you can see some of the
276:36 - members there and the governing board
276:38 - does not make technical decisions for
276:40 - the cncf other than working with the toc
276:43 - to set the overall scope of the cncf so
276:46 - what can they do well they can approve a
276:48 - budget and that's a lot of power so
276:51 - they're not making technical decisions
276:53 - but uh you know if you want if you need
276:55 - money for it you're gonna have to go
276:56 - through them in order for it to get
276:58 - approved so directing the use of funds
277:00 - raised from all sources of revenue to be
277:01 - used for technical
277:03 - marketing or community investment that
277:05 - advance the mission of the cncf they can
277:07 - elect a chair of the governing board to
277:09 - preside over meetings authorize
277:11 - expenditures approved by the budget and
277:13 - manage any day-to-day operations and
277:15 - there's about 30 governing board members
277:18 - and they meet about three to five times
277:20 - a year
277:21 - uh so just to kind of expand it's we
277:23 - covered the most important ones but
277:25 - let's just go through them all so that
277:26 - we can see what they do so approve a
277:28 - budget which we just said
277:30 - elect a chair of the governing board to
277:31 - preside over meetings authorized
277:34 - expenditure approved by the budget so
277:36 - when they say like preside over meetings
277:38 - i'm assuming like any kind of meeting
277:40 - not just ones on the governing board
277:42 - vote on decisions or matters before the
277:44 - governing board define and enforce
277:46 - policies regarding intellectual property
277:49 - direct marketing evangelism efforts
277:51 - through events press analyst outreach
277:53 - web social and other marketing efforts
277:55 - oversee operations and qualification
277:57 - efforts establish and oversee
278:00 - any communities created to drive the
278:01 - mission of cncf establish and execute a
278:04 - brand compliance program
278:06 - if any based on the cncf requirements
278:08 - which may include a certification test
278:10 - to use the brand marks established by
278:12 - the toc
278:13 - adopt guidelines or policy for use of
278:15 - trademark provide financial governance
278:19 - overall so
278:20 - you know they approve a budget right
278:22 - like that's what i'm going to remember
278:23 - from it um and they they can preside
278:25 - over meetings but of course there's a
278:27 - lot of stuff here
278:28 - but you just have to generally remember
278:29 - that they're they're not making
278:30 - technical decisions and they're
278:31 - approving budgets okay
278:36 - [Music]
278:38 - all right let's take a look here at the
278:40 - technical oversight committee also known
278:42 - as the toc and they provide technical
278:44 - leadership to the cloud native community
278:46 - and they're not a really big team this
278:48 - is the representatives here even though
278:50 - they're cut off it's really a small team
278:51 - and there's lots of contributions but
278:53 - this is the main team
278:56 - and their responsibilities include
278:58 - things like um
279:00 - defining and maintaining the technical
279:01 - vision of the cloud native computing
279:03 - foundation approving new projects and
279:05 - creating a conceptual architecture for
279:07 - the projects aligning projects and
279:09 - removing or archiving projects accepting
279:11 - feedback from end user committee and
279:13 - mapping to projects aligning interfaces
279:16 - uh yeah interfaces to components under
279:18 - management so code references
279:19 - implementations before standardizing and
279:22 - defining common practices to be
279:24 - implemented across the cncf projects so
279:27 - there you go
279:28 - [Music]
279:33 - all right let's take a look here at
279:34 - special interest groups sigs because we
279:37 - did see them in the overall uh
279:39 - organizational structure so special
279:42 - interest groups are specialized
279:43 - committees that work under or report to
279:45 - the toc and there can be like end user
279:49 - sigs but we're talking about the ones
279:51 - that are in the scope of the tfc right
279:52 - now so sigs include things around
279:55 - traffic observability governance app
279:58 - delivery core applied architecture
280:00 - security and when i say around i mean
280:02 - like literally there's a sig for each
280:03 - one
280:04 - right it's not like they cover all these
280:06 - things they're specialized and even at
280:07 - the time this is being drafted so this
280:09 - list might change but this is generally
280:11 - what they're thinking right and sigs are
280:14 - long lived groups so they're not just
280:15 - temporary groups that spin up for a
280:17 - particular use case and then spin down
280:18 - they are sticking around uh and they're
280:20 - led by uh recognized and relevant
280:22 - experts so you know if it's like
280:24 - observability it's gonna be something
280:26 - like people that specialize in service
280:27 - mesh or something like that
280:29 - and so things that are going on here
280:31 - that uh you know they're supposed to be
280:33 - doing is strengthening the project
280:35 - ecosystem to meet the needs of end users
280:37 - and project contributors identify gaps
280:39 - in the cncf project portfolio find and
280:41 - attract projects to fill these gaps
280:43 - educate and inform users with unbiased
280:45 - effective practical use useful
280:47 - information focus attention to resources
280:49 - on helping foster project maturity
280:51 - systematically across cncf projects
280:54 - clarify relationships between projects
280:56 - cncf project staff and community
280:58 - volunteers engage more communities and
281:00 - create an on-ramp to effective toc
281:02 - contribution recognition reduce some
281:04 - project workload on toc while retaining
281:07 - executive control and tonal integrity
281:09 - with elected body avoiding creating a
281:11 - platform for politics between vendors so
281:15 - hopefully that gives you an idea of what
281:16 - sigs can do and yes there are end user
281:19 - sigs we're not really covering them here
281:20 - but this is the sig that i want you to
281:22 - know is the the technical ones okay
281:25 - [Music]
281:30 - hey let's take a look here at end user
281:31 - community also known as euc or if you
281:34 - want to attempt to say uke but i'm just
281:36 - going to say end users so end users in
281:38 - the cncf are individuals or
281:40 - organizations that use cloud native
281:42 - technologies but they do not sell
281:45 - cloud native services so examples of not
281:48 - end users would be vendors consultancies
281:50 - training partners telecos
281:52 - but
281:53 - i kind of feel like the line's a bit
281:54 - uh blurred there because when you read
281:56 - the charter and how some end users can
281:58 - be promoted to
282:00 - roles outside the end user stuff i just
282:02 - get really mixed up okay so um i think
282:05 - that uh it's it's kind of a soft line
282:08 - okay um the uc acts as a feedback loop
282:10 - between those using cloud native and
282:13 - those maintaining and building cloud
282:14 - native solutions um but not just being a
282:17 - feedback loop you know you're not just
282:19 - there to to give them answers
282:21 - as a customer but the idea is that the
282:23 - end user community is an ecosystem of
282:26 - finding cloud data of talent finding
282:27 - local user groups uh meeting project
282:30 - maintainers contribute to the cncf
282:32 - technology radar um there is a class to
282:35 - be like there it's free to be an end
282:37 - user but then there's membership tiers
282:39 - but it's confusing because like if eight
282:41 - of us is a
282:42 - uh like a platinum member
282:45 - are they an end user because they have a
282:47 - service but
282:49 - um i think this is just kind of a
282:50 - mistake in terms of the marketing pages
282:52 - where um you have end users and then
282:55 - things beyond that and
282:56 - it gets confusing but anyway end users
282:58 - if you are paying a particular
283:00 - membership you don't have to then you
283:02 - get access to things like educational
283:04 - resources and um either cheaper or free
283:08 - tickets uh to the cloud native
283:10 - conference so that will vary there but
283:12 - uh there you go
283:18 - all right let's take a look at the end
283:19 - user technology radar so technology
283:22 - radar is an opinionated guide to set a
283:24 - uh
283:25 - of a set of emerging technologies and
283:27 - basically looks like this um and so the
283:29 - cncf end user technology radar is
283:32 - intended for a technical audience who
283:34 - want to understand what solutions end
283:36 - users using cloud native and which they
283:38 - recommend so basically they do a survey
283:41 - and they ask what are you using what do
283:42 - you trust and then they kind of have
283:44 - this little radar diagram and this is an
283:47 - original idea from uh cncf and they
283:49 - admit that too that this is something
283:51 - that a lot of companies like to do like
283:52 - a technology radar or a radar-like thing
283:55 - and they do also have uh sub-radars uh
283:58 - like technology radars um for like maybe
284:01 - security serverless things like that but
284:02 - this is just the general one there but
284:04 - let's take a look at these three
284:05 - categories and what they should mean to
284:07 - you when you are adopting uh technology
284:10 - so the first is assess so the cncf end
284:12 - user community has tried it out
284:14 - they find it's promising and recommend
284:16 - having a look at these items when you
284:18 - face a specific need for technology in
284:21 - your project
284:22 - okay then there's trial so the end user
284:24 - community has used it with success and
284:26 - we recommend you have a closer look at
284:28 - technology adopt so clearly recommend
284:30 - this technology um that have been used
284:33 - for long periods of time in many teams
284:35 - and has proven to be stable and useful
284:37 - so it's interesting because you have
284:39 - projects and those are like if they're
284:41 - graduated you think that's like a
284:43 - guarantee that you should use them but
284:45 - this is more um less of like what status
284:48 - a project is of like maturity in terms
284:50 - of adoption because that's just a signal
284:52 - to say like enterprises you can use
284:54 - graduated projects you should trust them
284:56 - but this is more practicality saying
284:57 - what works as a combination of
284:59 - technologies um yeah so it's nice to
285:01 - have that kind of balance and have that
285:03 - driven by uh the end users as opposed to
285:05 - just taking the word of the cncf further
285:08 - projects right because like
285:09 - yeah things like that okay
285:11 - [Music]
285:16 - let's take a look here at the cncf
285:17 - charter so the cncf charter is a public
285:19 - document that contains the organization
285:21 - structure of the cncf the mission and
285:24 - values of the cncf the description of
285:26 - membership tiers the definition of cns
285:28 - projects
285:29 - governing policies references to code of
285:31 - conduct general definitions in relation
285:34 - so like what does a organization
285:36 - related to the charter like well how
285:38 - would we describe that general rules so
285:41 - it's basically a big document to help
285:42 - define and guide the cncf and um in this
285:45 - section i used quite a bit of
285:46 - information from it so you didn't have
285:47 - to read the charter and then i used the
285:50 - marketing pages to fill it out so you
285:52 - know hopefully that gives you an idea of
285:54 - the contents of the charter okay
285:56 - [Music]
286:01 - so no organization is complete without
286:03 - some values like things or a list of
286:06 - things that they believe in
286:08 - um and that we're supposed to go along
286:11 - with so um i'm being a bit
286:13 - tongue-in-cheek there because to me it's
286:15 - just
286:16 - all right you know what i mean like
286:18 - uh it's like no different than the it
286:19 - was leadership principles or whatever
286:21 - microsoft or google does but let's read
286:23 - it and see what we have here so the cncf
286:26 - strives to adhere to the following
286:28 - principles fast is better than slow so
286:30 - enable projects to progress at high
286:32 - velocity to support aggressive
286:35 - adoption by users fast is better than
286:37 - slow
286:38 - open open accessible and operates
286:40 - independently of specific partisan
286:42 - intersects that seems fair
286:45 - accepts all contributors based on the
286:46 - merit other contributions i like that
286:48 - that sounds good too technology must be
286:50 - available to all according to the open
286:52 - source values
286:54 - fair uh sorry the technical community
286:56 - and its decisions shall be transparent
286:58 - so fair avoid undue influence bad
287:00 - behavior or pay to play
287:02 - decision making we have strong technical
287:05 - identity so achieve and maintain a high
287:07 - degree of its own technical identity
287:09 - shared across the projects clear
287:12 - boundaries so establish clear goals and
287:14 - what the non-goals to allow projects to
287:16 - effectively coexist help the ecosystem
287:19 - understand where to focus for new
287:20 - innovation
287:21 - scalables support all scales of
287:24 - deployment from startups to service
287:25 - providers and enterprises platform
287:28 - agnostic the specifications developed
287:30 - will not be platform specific such that
287:33 - they can be implemented on a variety of
287:34 - architectures operating system so i mean
287:36 - it's pretty much aligned with um
287:39 - uh you know kubernetes and stuff because
287:41 - it's platforgnostic
287:43 - uh from from small to large but i mean
287:45 - really kubernetes is not easy for small
287:47 - startups but i mean you know it's cloud
287:50 - native so we can't just look at just
287:52 - kubernetes there's a whole scope of
287:54 - projects there but yeah i guess that
287:56 - generally aligns with the cncf
287:58 - [Music]
288:02 - all right so we've been talking about um
288:04 - you know governance stuff and i just
288:05 - kind of want to show you where this
288:06 - stuff is coming from so if you ever want
288:08 - to look it up yourself so i typed in
288:10 - cncf charter and it brought me here to
288:13 - the charter page and so basically a lot
288:15 - of stuff we covered is from here where
288:16 - i've summarized it or just kind of made
288:18 - it a little bit more digestible if
288:20 - you're kind of curious uh what the stuff
288:22 - looks like
288:24 - and if we go up to foundation i wonder
288:25 - if there's more stuff in here
288:28 - so
288:29 - there's all sorts of stuff
288:32 - not a whole lot um that we were looking
288:33 - here this was pretty much uh the main
288:35 - thing there but uh if we go over here
288:38 - and we go to
288:40 - uh here we can see the governing board
288:42 - here we can see uh oversight committee i
288:44 - don't think i checked what staff was but
288:46 - it wouldn't hurt to take a look if we go
288:48 - to who we are that's probably where i
288:49 - got the values from
288:51 - so yeah they linked to the charter on
288:53 - the github here on the about us page
288:56 - they talk about their cloud native
288:57 - definition which again i i'm not a big
288:59 - fan of it we did it in the beginning of
289:00 - the course
289:02 - it's there okay
289:04 - if we go ahead and close that on off
289:06 - we can see the governing board so here
289:08 - you can see all the members you can view
289:10 - their profiles um so nothing super
289:13 - exciting what's interesting is like
289:15 - uh you can read their past minutes
289:17 - because everything's in the open right
289:18 - so you can go here see they meet three
289:20 - to five times a year click and do it and
289:22 - it shows you who showed up
289:24 - uh very formal um and also sometimes
289:27 - what they'll do is show like on github
289:28 - maybe more for
289:30 - um
289:32 - the toc but if we go to the tlc the
289:34 - technical oversight committee
289:36 - right um
289:38 - they show their activity here they have
289:39 - a mailing list so i guess you could
289:41 - start uh talking them there you know
289:43 - this is such an old school thing but hey
289:44 - they still work
289:46 - um if you go to the toc they have their
289:48 - own page here the technical oversight
289:50 - committee explains who and when and why
289:52 - they got there the projects their
289:54 - meeting times where the zoom call is the
289:56 - passcode to get in i don't know if you
289:57 - can just like kind of like show up and
289:59 - uh
290:00 - uh bomb the meeting or something like or
290:02 - people can listen in i guess you can
290:03 - come in they can just mute your kick you
290:05 - uh then there's uh technical advisory
290:07 - groups which we never talked about um
290:09 - the tags
290:11 - and
290:12 - these look like sigs
290:15 - so i'm a little bit confused because
290:17 - sigs and tags um
290:19 - basically have
290:20 - the same thing so maybe they renamed it
290:22 - maybe tags are the same thing i'm not
290:24 - really sure oh look at that
290:27 - yeah
290:27 - look at that same thing so maybe this is
290:30 - cigs or tags i don't know now
290:33 - so that's cool okay so tags and things i
290:36 - guess are the same thing
290:38 - all right
290:39 - um
290:40 - and so you know that's pretty much it i
290:43 - just oh maybe the radar thing we should
290:44 - take a look at the radar so if we go to
290:47 - um
290:48 - and use a radar
290:50 - okay
290:50 - um here this says devsecops that's the
290:52 - one i had in the actual um presentation
290:55 - the slides if you go down below
290:58 - you can see like who end users are they
291:00 - kind of have a presentation it doesn't
291:01 - tell you much but this is what's
291:02 - interesting where you see
291:04 - uh the data so like this is how you
291:06 - understand how it's happening where
291:08 - they're going okay
291:09 - let's vote on
291:11 - terraform as soon as just links to the
291:12 - terraform website oh no it pops up
291:15 - right and so they gather metrics to see
291:18 - adoption so that doesn't necessarily
291:20 - mean that that means that you should use
291:21 - it just understand that's what the data
291:23 - is so we have 21 companies
291:25 - that's not a lot of companies
291:27 - but maybe they're larger companies i'm
291:29 - not sure if it shows us um
291:32 - uh the information there like how do we
291:34 - know what kind of company they are and
291:36 - here i guess we can see the size of them
291:38 - so you know
291:39 - it would be nice if you could like
291:40 - filter based on your company size
291:43 - because that could really help you
291:44 - understand or even industry help you
291:46 - understand that but down below we have
291:48 - different radars so we have
291:50 - multi-cluster management secret
291:51 - management database observability i said
291:53 - serverless i guess there isn't one um
291:56 - but that's totally fine there as well
291:58 - and so here you can read all sorts of
292:00 - stuff these things are again
292:02 - you know take them with a grain of salt
292:04 - they're uh they are what they are uh
292:06 - only other thing i'd like to show you is
292:07 - like end user stuff to show you where i
292:09 - was talking about confusion so we go end
292:11 - user cncf they actually have a page
292:14 - right here and if you scroll on down
292:16 - this is where we start seeing
292:18 - memberships
292:19 - and the language just keeps changing or
292:22 - varies in other places so here they call
292:23 - it a supporter
292:25 - which is 4500 um
292:27 - but you can join the end users for free
292:30 - how you do it i have no idea right i
292:33 - guess you just said join now and you
292:34 - sign up and that's you signing up for
292:36 - free i don't know like i've already
292:38 - signed up before because i when you set
292:39 - the certification you need to sign up to
292:42 - do that so i suppose as soon as you sign
292:44 - up you technically are an end user but
292:46 - here you can see kind of the benefits
292:47 - that you get for doing that but this
292:49 - matches to the memberships we saw
292:51 - earlier so everyone's an end user or
292:53 - stuff like that so you know if you feel
292:55 - confused just know that i'm confused a
292:57 - bit too but um you know it's not really
293:00 - going to show up in the exam but
293:02 - there you go okay
293:04 - [Music]
293:08 - all right let's take a look here at
293:09 - kubecon plus cloud native con so kubecon
293:11 - is a technology conference for
293:12 - kubernetes and cloud nativecon is a
293:15 - technology conference for cloud native
293:18 - uh why is there two and why are they
293:21 - combined is another question because uh
293:24 - you always see presented as kubecon plus
293:26 - cloud native con
293:28 - so um as far as i understand talking to
293:31 - people that have been in the industry
293:33 - longer than me for cloud native stuff
293:35 - i believe it was
293:37 - kubecon existed first then they wanted
293:39 - to do cloud native stuff as well
293:42 - so they tacked that on i don't think
293:44 - cloud native was ever its own conference
293:45 - i think it was just like
293:47 - an adjacent conference with kubecon so
293:49 - it's essentially one conference
293:51 - um and so that's the idea there and it
293:53 - was only north america but then they
293:55 - decided to add a european one
293:58 - uh and so the attendance is actually
294:00 - very significant so if we just take a
294:02 - look here on the right hand side in 2018
294:03 - we had 8 000 in person then 12 000 in
294:06 - person
294:07 - uh 22 816 attendees virtual because of
294:12 - covet uh then we saw kind of a split
294:15 - where i had 17 000 attendees and only 4k
294:17 - in person
294:19 - and so who knows what it'll be for 2022
294:21 - um i'm not sure
294:23 - and even at these conferences you might
294:25 - see adjacent conferences in north
294:27 - america like istiocon
294:29 - con get up get ops con
294:31 - i don't know how you draw the boundaries
294:34 - like i don't know if they have like a
294:34 - separate building or stuff but uh that's
294:36 - a thing but you know i do hear really
294:39 - good things about these conferences i
294:41 - hear they're very inclusive and
294:43 - welcoming
294:44 - uh it's
294:45 - much more refreshing over something like
294:47 - abyss reinvent
294:48 - so hopefully one day i'll get to go in
294:50 - person but uh i just wanted you to
294:52 - understand that this is a thing
294:57 - [Music]
294:58 - all right so i wanted to show you a bit
295:00 - more about kubecon and cloudnativecon
295:02 - just because i felt my slides are a
295:03 - little bit lacking but just to kind of
295:05 - show you
295:06 - how big of a deal it is so i just typed
295:07 - in kubecon plus cloudnativecon made it
295:09 - to the maine's website here it's on
295:11 - linux foundation if you scroll on down
295:13 - you get some really fun screenshots to
295:15 - get a good idea
295:17 - um you know what it's like to be at
295:19 - cubecon so there's probably even more
295:22 - photos if i click here uh it's not
295:24 - loading oh there we go so yeah we can
295:26 - see uh it's it's a big deal it's just
295:29 - like going to
295:30 - um
295:31 - like the aws re invent conference or
295:34 - ignite uh their big or like azure ignite
295:36 - or microsoft ignite it's a big deal
295:38 - right
295:39 - so you know just consider that uh you
295:41 - know you can see the schedule here look
295:43 - how big that stage is right uh you can
295:45 - see all the sponsors so there's a lot of
295:46 - money being put into it if you cannot
295:48 - attend um i don't know if all the videos
295:51 - make it up on here but a good chunk of
295:52 - them do and so you know you can go back
295:55 - and watch some videos that were at
295:57 - previous ones probably go to the
295:58 - playlist to see
296:00 - um what they are so if you just scroll
296:02 - on down here you can see there are some
296:04 - featured playlists
296:06 - right
296:06 - so um you know like that i don't know if
296:09 - all really i don't think all the videos
296:11 - get on there i think it just kind of
296:12 - happened because of covid and they just
296:14 - put some of the videos up because
296:16 - there's a lot a lot of events and i'm
296:18 - not seeing
296:19 - uh the volume of that i would think that
296:21 - if i if i was at kubecon so you know
296:24 - there you go and uh you know hopefully
296:26 - it convinces you that you might want to
296:28 - go okay
296:29 - [Music]
296:33 - all right let's take a look here at cncf
296:35 - projects so projects are technologies
296:38 - and they are managed by the cncf so many
296:41 - cfcf projects are developed by external
296:43 - tech companies and then are handed over
296:46 - to the cncf for long-term support and
296:49 - you can access all these projects at
296:51 - cncf.org slash projects and projects are
296:54 - categorized based on their maturity
296:56 - level and i'm pretty sure you need to
296:58 - know that for the exam so
297:01 - here they have this diagram here that
297:03 - kind of shows
297:05 - some information
297:06 - and this is actually based off a diagram
297:09 - from a book but let's go through the
297:11 - different categories so we have
297:12 - graduated
297:13 - meaning it's production ready for
297:15 - enterprises
297:16 - incubating so the this is where the apis
297:18 - might be rapidly changing
297:20 - and you may have incomplete uh they may
297:22 - be incomplete to be adopted by large
297:25 - enterprises but they are totally fine
297:27 - for
297:28 - smaller companies uh then you have
297:30 - sandbox so experimental prototypes uh
297:33 - and i would not bet that these would
297:35 - pass the security review so
297:37 - um you know there are so many sandbox
297:39 - projects they're just not listed on the
297:42 - website and the maturity level again is
297:44 - based off of this book called crossing
297:46 - the chasm
297:47 - uh which is a diagram in the book from
297:50 - 1991. i don't particularly care for it
297:53 - i'm not really sure why they use um
297:56 - this model
297:58 - like i don't know it's like to try to
297:59 - sell more of those books or somebody in
298:02 - particular liked it and thought yeah
298:03 - that's a good framework to use
298:05 - um but it's fine i mean i would just
298:07 - prefer it being like stable or
298:10 - you know release candidate or something
298:12 - like that but that's how they name them
298:13 - so
298:14 - there's that but let's talk a little bit
298:16 - more about sandboxes um
298:18 - so if let's say you wanted to find
298:20 - sandbox projects because i just said
298:21 - that they're not on the main website but
298:23 - they are in the the landscape so what
298:26 - you can do is go to cncf projects and
298:28 - then check box there and that's the way
298:30 - you can see them now all these projects
298:32 - um go through different kinds of eco or
298:35 - life cycles and so it might be worth to
298:38 - take a look at the different life cycles
298:39 - so here i have project stages and this
298:42 - is from
298:43 - the documentation for cfc projects right
298:45 - from their website so the idea is
298:49 - we have
298:51 - a sandbox so these are experimental
298:53 - neutral collaborations
298:55 - and here they're suggesting like they're
298:56 - low barrier low reward
298:58 - uh and so you know you might not want to
299:01 - adopt them then they have this
299:02 - significant barrier so this is where the
299:04 - majority of development happens i think
299:06 - that's what they're saying there and
299:07 - then from incubation they say the
299:09 - obvious pass so incubation to graduation
299:12 - not a lot of descriptions around the
299:13 - stuff but you kind of get an idea where
299:15 - things are flowing and that some things
299:17 - just completely skip over the sandbox
299:19 - section and go straight to incubation
299:22 - and all these have even more detailed
299:24 - information so when you look at the
299:25 - sandbox process the idea is that there
299:28 - is a project proposal that is in the
299:30 - case of a github issue um the
299:33 - technical
299:34 - committee will triage it and give it a
299:36 - brief request a sig the sigs will make a
299:39 - presentation that is recorded the
299:41 - presentation slides a recording complete
299:43 - recommendation template um and then the
299:46 - toc will review recommendation and
299:47 - presentation and then it will be in
299:50 - sandbox so three toc sponsors to the
299:52 - step forward so that's how we get to
299:54 - that
299:56 - then there's the incubation process
299:58 - so
299:59 - you have a project proposal
300:01 - and
300:02 - it goes to special interest groups again
300:05 - makes a presentation
300:06 - whether it's recommendation they do
300:08 - their due diligence with tech and
300:09 - governance user interviews
300:11 - um and then here we have another review
300:14 - with another presentation the toc vote
300:17 - on it and it makes it into incubation so
300:20 - you can see there's a lot there um i
300:23 - don't think there was one for
300:25 - graduated there probably is a process
300:27 - but i i didn't see one because if i if
300:29 - there was i'd have it here
300:31 - but that's that there so there is at
300:33 - least one graduated cncf project
300:35 - generally for each cloud native category
300:37 - and that's just something that i
300:38 - observed
300:40 - and that kind of makes sense because
300:41 - like how do these categories exist um
300:43 - you know if they don't have it so we're
300:44 - looking at things that are graduated so
300:46 - like container run times k or d core dns
300:50 - envoy
300:51 - at cd
300:52 - uh fluentd harbor helm
300:55 - uh jaeger i think it's pronounced jagger
300:57 - like the j's the y uh kubernetes linker
301:01 - d open policy agent prometheus um the
301:04 - update framework so tough
301:07 - rook
301:08 - and uh tikvi and
301:11 - vitus or vitus
301:13 - lots of names i've never had to say out
301:14 - loud before so hopefully i got them all
301:16 - right but there there are a real a lot
301:18 - of really good uh incubating projects
301:21 - that uh i'd strongly recommend using so
301:23 - i don't think that should be a
301:24 - discouragement but this is really for
301:26 - like
301:27 - you know if you're a large organization
301:29 - like a huge enterprise then you're
301:31 - probably going to gravitate towards
301:33 - these projects okay
301:35 - [Music]
301:40 - hey this is andrew brown from exam pro
301:41 - we're looking at what is serverless so
301:43 - serverless architecture generally
301:45 - describes fully managed cloud services
301:47 - and the classification of cloud services
301:49 - being serverless is not a billion answer
301:51 - as a yes or no but an answer on a scale
301:54 - where a cloud service has a degree of
301:56 - serverless so a serverless service could
301:58 - have all or most of the following
302:01 - characteristics and you basically just
302:03 - have to take an estimated guess to say
302:05 - whether it is serverless there's a lot a
302:08 - lot of debate about serverless but you
302:10 - know i've talked to engineers like at
302:13 - aws and stuff like that where we saw
302:15 - serverless very early on and the
302:17 - definition was really simple there's a
302:19 - degree
302:20 - of operations that you just do not have
302:22 - to perform and you can just focus on
302:25 - providing business value but let's look
302:27 - at the elements that
302:29 - i've included here that i've generally
302:30 - been able to find out about serverless
302:32 - so serverless is generally highly
302:34 - elastic and scalable highly available
302:36 - highly durable secure by default
302:38 - abstracts away the underlying
302:39 - infrastructure and are build based on
302:41 - the execution of business tasks so for
302:44 - business value serverless can scale to
302:46 - zero meaning when not in use the
302:49 - serverless resources cost nothing and so
302:51 - the idea here in these two sections here
302:54 - is we're paying for value you don't pay
302:56 - for idle servers
302:58 - my friend that runs the uh service
303:00 - toronto user group
303:01 - likes to describe it as energy rating so
303:05 - the idea is that um
303:07 - you know consumers uh you know what
303:10 - they're gonna do like think of like if
303:11 - you have like a washer or a dryer and
303:13 - you have this energy rating saying like
303:15 - it's out of three stars out of five of
303:17 - being energy efficient right so the idea
303:20 - is like some things are more serverless
303:22 - than others um you know and that's just
303:24 - the idea there okay
303:26 - [Music]
303:30 - all right let's take a look here at
303:31 - cloud native and kubernetes serverless
303:34 - so
303:35 - the cncf has a landscape for just
303:38 - serverless um
303:41 - services or or cloud native serverless
303:43 - things and so what does that mean well
303:45 - so the cncf classifies as serverless in
303:49 - this landscape to be things like
303:51 - functions as a service so aws lambda
303:54 - azure serverless functions google cloud
303:56 - functions
303:57 - serverless frameworks such as dapper i
304:00 - think that's how it's pronounced it was
304:02 - sam chalice uh installable platforms
304:05 - kubernetes-based event-driven
304:07 - auto-scaling k-e-d-a which we did talk
304:09 - about in this course
304:11 - apache open whisk open foss k-native
304:14 - fission
304:15 - cubeless and tools things like uh
304:19 - lumigo and dashbird so it's interesting
304:23 - that they put um like managed providers
304:27 - because i guess technically you know
304:28 - they're cloud native but they're not
304:30 - they can't be moved to anywhere else so
304:32 - um i think it's kind of like those
304:33 - things where like adabus
304:35 - paid a bunch of money to be like a
304:36 - top-tier uh provider and she's like hey
304:39 - can you throw a little slam down there
304:41 - because to me if it's cloud native it
304:43 - has to be
304:44 - an installable thing it can't be a um a
304:48 - service that is uh managed do you what i
304:50 - mean that can't be moved to any other
304:52 - platform so to me this is where uh you
304:55 - know like maybe these frameworks and
304:57 - this is where
304:58 - um actually i'm going to just
305:00 - zero this out i would just say this is
305:02 - what really feels to me to be um what i
305:05 - call cloud day of service and these
305:07 - things are just kind of like adjacent to
305:08 - them right
305:10 - um so just bear that in mind okay
305:15 - [Music]
305:23 - hey this is andrew brown from exam pro
305:25 - and let's take a look at k native so k
305:27 - native is kubernetes based platform to
305:29 - deploy and manage modern serverless
305:30 - workloads and k native is a project to
305:32 - create a standard set of building blocks
305:35 - that i think that's kind of an important
305:36 - statement right there standard set of
305:37 - building blocks for kubernetes to enable
305:40 - serverless development patterns k native
305:42 - generally is composed of two parts uh
305:45 - and i say generally because there is a
305:46 - third part called building but k native
305:48 - serving so this takes containerized code
305:50 - and deploy it to uh with relative ease
305:53 - it scales to zero costs you have k
305:54 - native eventing triggers serverless
305:57 - functions based on kubernetes api events
305:59 - loop in other managed sources to trigger
306:02 - serverless functions without this part
306:04 - the eventing we might not consider it
306:06 - serverless because if it just had
306:08 - serving to make it easier to
306:10 - [Music]
306:11 - have an opinion on setting up a bunch of
306:13 - infrastructure for you to deploy your
306:15 - apps it would just be like a managed
306:17 - layer um so over here you kind of get an
306:19 - idea of what else is going on here so k
306:22 - native has building inventing and
306:23 - serving it's on top of kubernetes and
306:25 - there can be layers like the app on top
306:27 - like that's just istio for service mesh
306:29 - like discovery to reach those functions
306:32 - some considerations is that it's not a
306:34 - complete serverless framework and it
306:36 - does not offer function as a service
306:38 - offering now that doesn't mean you can't
306:40 - run functions on it but function as a
306:41 - service is more of a fully managed uh
306:44 - thing and so there's just some things
306:45 - that are missing this is not my words
306:47 - this is k native like you watch the
306:49 - proper presentation uh like uh for those
306:52 - uh who like do it like use it and they
306:56 - even say that this is the case so uh
306:58 - that doesn't mean it's not great it's
306:59 - just a degree of service remember back
307:01 - to the energy ratings where something
307:02 - can be more servless than others but
307:04 - it's still pretty darn serverless now
307:07 - k native has its own
307:10 - kubernetes objects that it defines with
307:12 - kubernetes custom resource definitions
307:13 - crds that is something that's out of the
307:16 - scope of this course like talking about
307:17 - crds but just understand that they're
307:19 - used to make your own components and so
307:22 - candidate of components is server
307:23 - service so manage life cycle of a
307:25 - workload route mapping network endpoints
307:28 - configuration maintains desired state
307:30 - revisions so point in time snapshots of
307:32 - code and so basically they're using the
307:34 - word service more like how we would use
307:36 - the word service to run a workload
307:38 - except it doesn't necessarily mean that
307:40 - it's continuously running so you know
307:42 - like when you use something like aws ecs
307:46 - they say service and task service
307:47 - something that that continuously runs
307:49 - uh and doesn't spin down and the task
307:52 - does it runs and it spins down but just
307:54 - understand they call their service and
307:56 - so here's kind of a diagram how they all
307:57 - work together so of course the service
307:59 - would have a configuration a service is
308:01 - basically the function revisions are uh
308:03 - snapshots so like backups of ones that
308:06 - you made and routes that point to this
308:08 - particular one and you're not going to
308:10 - really be doing all the rest you're just
308:12 - going to be working with service and the
308:14 - way you do that with is with the k
308:15 - native cli called kn and use this
308:18 - alongside cube ctl because it's not like
308:21 - you're not going to touch any cube ctl
308:22 - but when you're working with your apps
308:24 - and stuff and deploying your functions
308:26 - which are called services and uh can
308:28 - it's going to be like this kind of
308:30 - different syntax here so think of k
308:32 - native as abstracting awake deployment
308:34 - services autoscaling many more k
308:36 - components and you just create and
308:37 - deploy
308:38 - k n or k native services so there you go
308:46 - [Music]
308:47 - let's take a look here at k native
308:48 - versus open fast and really all i did
308:50 - was grab a excerpt from an article for
308:53 - on the cncf blog from 2020 called
308:56 - serverless open source frameworks open
308:58 - fast k native and more strongly
309:00 - recommend to read it even though we are
309:02 - a few years in the future here uh i
309:04 - still think it rings true based on what
309:06 - i was looking at and just maybe will
309:08 - help to understand the difference
309:09 - between these two a little bit more so
309:11 - unlike openfast k native is not a
309:13 - full-fledged serverless platform but is
309:15 - better positioned as a platform creating
309:16 - deploying and managing serverless
309:18 - workloads however from the point of the
309:20 - view of configuration maintenance open
309:21 - fast is simpler with openfast there is
309:23 - no need to install all components
309:24 - separately as k native and you don't
309:26 - have to clear previous settings and
309:28 - resources for new developments if the
309:30 - required components have already been
309:31 - stalled still as mentioned above a
309:34 - significant drawback of openfast is the
309:35 - container launch time depends on the
309:37 - provider while k-native is not tied to
309:40 - any single cloud solution provider based
309:42 - on the pros and cons of both
309:44 - organizations may also choose to use
309:46 - k-native open fos together to
309:48 - effectively achieve different goals so
309:50 - one thing that was interesting is the
309:52 - container launch time depends on the
309:53 - provider i didn't fully understand why
309:56 - didn't i mean so that's one thing i
309:58 - wasn't sure about that i really tried to
310:01 - research another interesting thing is
310:03 - just when you see the stacks like the
310:05 - tools involved
310:07 - or k-native feels a lot more towards
310:10 - um
310:10 - the cncf's projects like
310:13 - like standard projects and openfast is a
310:15 - little bit different um so like canada
310:17 - feels more again a better migration path
310:20 - back to full kubernetes if you need it
310:21 - in open fastest really feels like
310:23 - serverless like you don't have to do a
310:25 - lot of work there so there you go
310:27 - [Music]
310:31 - hey this is andrew brown from exam pro
310:33 - and we are looking at the pillars of
310:35 - observability so before we talk about
310:37 - observability in kubernetes we should
310:40 - just understand uh this general concept
310:42 - of pillars of observability um and i
310:45 - don't really show them as pillars i show
310:47 - them more like a triforce because i
310:49 - think that that makes it for a better
310:50 - visualization but let's talk about what
310:52 - observability is
310:54 - so it's the ability to measure and
310:55 - understand how internal systems work in
310:58 - order to answer questions regarding
310:59 - performance tolerance securities and
311:01 - faults with a system and application
311:03 - to obtain observability you need to use
311:05 - metrics logs and traces and you have to
311:07 - use them together using them in isolate
311:09 - does not gain you observability so just
311:12 - understand they all work together
311:15 - for metrics we have a number that is
311:17 - measured over a period of time so if we
311:19 - measured the cpu usage in aggregate and
311:21 - aggregate over a period of time we would
311:24 - have our average cpu metrics for logs we
311:28 - have a text file where each line
311:29 - contains event data about what happened
311:31 - at a certain time so it's a log
311:34 - and then there's traces a history of
311:36 - requests that it travels through
311:38 - multiple apps and services so we can
311:39 - pinpoint failures or
311:41 - uh performance or failures and traces go
311:43 - along with spans we'll talk about that
311:46 - and i say it looks like
311:48 - the triforce of observability than the
311:50 - pillars of observability but that's the
311:53 - idea there okay
311:54 - [Music]
311:58 - hey this is andrew brown from exam pro
312:00 - and we are looking at open telemetry uh
312:03 - initializes otel and is a collection of
312:06 - open source tools apis sdks to
312:08 - instrument generate collect and export
312:11 - telemetry data it standardizes the way
312:13 - telemetry data is collected like metrics
312:16 - logs and traces
312:18 - um and it uses the wire protocol which
312:20 - refers to a way of getting data from
312:22 - point to point like soap m q p
312:25 - so
312:26 - the idea here is we have applications
312:29 - that are instrumented with the otel
312:31 - library that go to collector agents so
312:34 - an agent that is on the host and it's
312:36 - going to send it to the oetl collector
312:39 - service uh which essentially are back
312:41 - ends and i mean that's what it is open
312:44 - telemetry is a big deal because
312:47 - it could uh really change the way we
312:49 - collect information and we're starting
312:51 - to see cloud service providers um adopt
312:54 - it so you know you have aws cloud met or
312:56 - sorry cloud watch but like why would you
312:58 - use that when you use open telemetry
313:00 - which gives you a lot more richer data
313:02 - so it kind of competes with um
313:05 - services
313:06 - in some sense but uh definitely is a
313:09 - really great tool to have so let's talk
313:10 - about instrumentation so instrumentation
313:12 - is the act of embedding a monitoring
313:14 - library into your existing application
313:16 - in order to capture monitoring data such
313:18 - as metrics traces or logs so i really
313:20 - like ruby so i grab the ruby example and
313:23 - the idea is that you'd have some kind of
313:24 - library and you'd import that library
313:27 - set some defaults you'd run the
313:29 - configure you'd create a tracer because
313:32 - instrumentations the idea behind it is
313:33 - you're creating traces right
313:36 - uh and traces and spans per se so there
313:38 - uh you have your tracer so you're gonna
313:40 - have one trace that goes along a bunch
313:42 - of projects and then in this application
313:44 - it's going to create a span because the
313:46 - span starts within an application you
313:48 - pass it a variety of attributes like
313:50 - data that you want um and that's all
313:53 - there is to it and the telemetry
313:56 - otel or open telemetry supports a
313:58 - variety of languages so basically all
314:00 - your favorite languages
314:02 - and for certain frameworks uh there are
314:04 - plug and play libraries to quickly
314:05 - instrument your app so if you're using
314:07 - spring asp.net express quarkus uh i
314:11 - assume that there's kind of like built
314:12 - into the background so you're not really
314:14 - doing instrumentation you just say turn
314:16 - it on and it just happens i'd love it
314:19 - for ruby on rails maybe there's a third
314:21 - party for it i don't know
314:22 - um and let's just talk about the
314:24 - collector for a moment so open telemetry
314:26 - collector is an agent installed on the
314:27 - target machine or is a
314:30 - dedicated server and is vendor agnostic
314:32 - way to receive process and export
314:34 - telemetry data it removes the need to
314:36 - run operate maintain multiple agent
314:38 - collectors and this works with improved
314:40 - scalability and support with open source
314:42 - observability data formats like jaeger
314:45 - again i think it's jagger not like
314:46 - jagger but jagger sounds cool too
314:49 - prometheus flew in bit sending to one or
314:51 - more open source or commercial back ends
314:54 - uh the local collector agent is the
314:56 - default location to which intermittent
314:58 - instrumentation libraries export their
315:00 - telemetry data and so here they're just
315:02 - kind of representing what we said so you
315:04 - have oltp uh jagger prometheus
315:08 - and
315:09 - that's going to receivers
315:11 - um and you can see that it's adjusting
315:14 - on both sides here just as an example
315:16 - right to
315:17 - that but this is all what's inside of
315:19 - the ol the hotel collector okay so
315:22 - that's all i want you to know for open
315:24 - telemetry they don't really say much on
315:26 - the exam or if any but it is a really
315:28 - important project to know okay
315:30 - [Music]
315:34 - hey this is andrew brown from exam pro
315:36 - and we are taking a look here at
315:38 - prometheus and open source system
315:40 - monitoring and alerting toolkit
315:41 - originally built at soundcloud yes the
315:44 - company that makes um or allows you to
315:46 - host sound clips prometheus collects and
315:49 - stores its metrics as a time series data
315:52 - and that should give you an indication
315:53 - that it is a time series database and
315:56 - its main features are a
315:57 - multi-dimensional data model with time
315:59 - series data identified by metric name
316:01 - key value pairs prom ql a flexible query
316:05 - language to leverage the
316:07 - the dimensionalities no reliance on
316:09 - distributed storage single server nodes
316:11 - are autonomous time series collection
316:13 - happens via a pull request on http
316:16 - publishing time series is supported via
316:18 - the intermediate uh
316:20 - intermediary gateway
316:22 - targets are discovered via server
316:24 - discovery or static configuration
316:26 - multiple modes of graphing and
316:27 - dashboarding support prometheus values
316:30 - reliability so you can always view what
316:32 - statistics are available about your
316:33 - system even under
316:34 - failure conditions if you need 100
316:37 - accuracy such as per request billing
316:39 - promises prometheus is not a good choice
316:42 - as the collected data will likely not be
316:44 - detailed uh to be or complete enough for
316:47 - that use case in such a uh
316:50 - case you'd be best off using some other
316:52 - system to collect and analyze the data
316:54 - for billing and produces prometheus for
316:56 - the rest of your monitoring so let's
316:58 - take a look here at um the actual system
317:01 - itself that it works
317:03 - and so the idea is that prometheus
317:04 - scrapes metrics from instrumental jobs
317:06 - either directly or via an uh
317:08 - intermediate pushed gateway for short
317:11 - lived jobs
317:13 - uh it stores all scrape samples locally
317:15 - and runs rules over this data set to
317:18 - either aggregate and record new time
317:20 - series from existing data or generate
317:22 - alerts and grafana or other api
317:26 - consumers can be used to uh to visualize
317:30 - the times siri data you can see that it
317:33 - also has alerting and other cool stuff
317:36 - built in there um and there's not really
317:38 - much to show for prometheus every time i
317:40 - see grafana i always think it is
317:42 - prometheus
317:43 - but graphon is only the visualization
317:45 - tool on top of it but it's the next
317:46 - thing that we will talk about okay
317:53 - hey this is andrew brown from exam pro
317:54 - and we are looking at grafana which is
317:56 - an open source analytics and interactive
317:58 - visualization web application grafana is
318:00 - commonly used along with a time series
318:03 - database like influx db prometheus or
318:05 - graphite
318:06 - and so it looks like this
318:08 - and there's really not much else to talk
318:10 - about it for the kcna because you don't
318:12 - need to know that much other than it's a
318:14 - visualization library that works with
318:16 - promised to this
318:17 - but there you go
318:19 - [Music]
318:23 - all right let's take a look here at
318:24 - traces and spans because these are
318:27 - things that we'll come across especially
318:29 - in serverless especially in
318:31 - micro service architecture like using
318:33 - anything with kubernetes because you
318:35 - have to track things between containers
318:37 - or contain between workloads and that
318:39 - can get kind of confusing so
318:42 - here is our graphic let's talk about
318:43 - what a trace is a trace is data or
318:45 - execution path through the system and
318:47 - can be thought of as a directed acrylic
318:50 - graph of spans and so we're talking
318:52 - about a dag this is that thing over here
318:55 - so the idea is that you have
318:57 - a unique id that's going to be tracked
318:59 - through
319:01 - uh all these um spans and then this
319:04 - makes up the trace this is the trace
319:05 - right uh and then the spans are the
319:08 - individual services the individual
319:10 - containers or or whatever that's
319:11 - tracking saying this is what happened uh
319:13 - in my little app this is what happened
319:15 - in my little app and then there's the
319:17 - context in between them like the latency
319:19 - and stuff in between them or did it fail
319:21 - how many times did he try so a span
319:23 - represents a logical unit of work in
319:25 - jager so i actually pulled this from the
319:27 - jaeger documentation this graphic is
319:29 - from jaeger
319:30 - or jagger i'm not sure how to pronounce
319:31 - it because it's used for um
319:34 - tracking the stuff that has an operation
319:36 - name the start time of the operation the
319:38 - duration spans may be nested and ordered
319:40 - to model casual relationships
319:44 - so
319:45 - uh hopefully that gives you an idea what
319:46 - traces and spence are
319:49 - but there you go
319:51 - [Music]
319:55 - all right let's talk about cost
319:56 - management now on the kcna exam i only
319:59 - had one question about cost management
320:01 - it was absurdly hard and obscure
320:04 - um and it had to do with like if you
320:07 - like it was actually scenario based like
320:09 - oh if you had these many things running
320:11 - if you scaled it down would it be better
320:12 - to scale up or scale down or whatever it
320:14 - just didn't make any sense for a casino
320:16 - question so my brain i go that must have
320:18 - been an unscored question or just a
320:20 - bizarre one
320:21 - and there aren't a lot of good resources
320:23 - out there for cost management even
320:25 - though it's part of the exam
320:26 - i had to like scrounge for information
320:29 - and try to make it kind of relevant so
320:31 - let's just go through what i could find
320:33 - and
320:34 - i mean it's just gonna be general
320:35 - knowledge but you know just understand
320:37 - that uh you know it's just the best i
320:39 - can do here okay so first thing is like
320:42 - labeling resources if you label your
320:44 - resources um with like metadata then you
320:47 - can use a visualization tool like
320:49 - prometheus or graphana it will end
320:51 - grafana to then kind of figure out costs
320:54 - all right how you get dollar amounts in
320:56 - that i do not know but i do know that
320:59 - that is a suggestion there you can find
321:01 - idle and unallocated resources because
321:03 - if they're idle or unallocated you're
321:04 - paying for them the idea here would be
321:06 - to visualize idle cpu memory storage and
321:08 - producing graphana and say like hey
321:10 - where do we see zero cpus being used but
321:13 - something's running
321:14 - horizontal sorry workload right sizing
321:17 - would help a lot so
321:19 - with that we can use a vertical pod
321:21 - autoscaler to adjust the cpu memory of
321:23 - pods a horizontal plot autoscaler to add
321:26 - or remove to meet the demand so one is
321:28 - right sizing
321:30 - of the the pods usage itself another one
321:32 - could be right sizing
321:35 - the cluster so to speak
321:37 - but at a pod level then there's cluster
321:40 - downsizing opportunities which is again
321:42 - i guess right sizing
321:44 - where you're using cluster auto scaler
321:46 - there's a double s there there should
321:47 - only be one so i apologize for that uh
321:51 - but it will add or remove nodes to meet
321:53 - the demand um you can leverage uh free
321:56 - trials of kubernetes cost tools like
321:57 - cubecost you know whose recommend that
321:59 - was cubecost so i think they're just
322:02 - trying to use the tool but i mean it's
322:03 - good advice it's not going to be an
322:05 - answer on the exam but it's true uh you
322:07 - can estimate future costs and so here
322:09 - this is where you use like load testing
322:11 - using something like speed scale
322:13 - k6 j meter gatling and so you'd say well
322:17 - what would it cost if i had this kind of
322:18 - traffic or these kind of nodes and stuff
322:20 - like that
322:21 - um so
322:23 - not wasting uh space this is pretty
322:25 - similar to finding idle unallocated
322:27 - stuff
322:28 - but to kind of add to that it's like you
322:30 - could adopt serverless architecture that
322:32 - scales to zero so when no traffic is
322:35 - received for a period of time it just
322:36 - shuts it off okay
322:38 - um and technical debt so maybe you can
322:40 - re-architect to reduce the amount of
322:41 - pods or maybe you should be using more
322:43 - pods and breaking up your app into
322:45 - smaller workloads so you can then
322:46 - isolate what things are cost effect like
322:50 - like costly and what aren't right
322:52 - and also just continually evaluate cloud
322:54 - native technologies and this is the best
322:56 - i can do for cost management but uh yeah
322:58 - for the exam probably just it's going to
322:59 - be around right sizing like vertical pod
323:01 - auto scale or horizontal plot autoscaler
323:04 - and then making the best guess you can
323:05 - okay
323:06 - [Music]
323:11 - hey this is andrew brown from exam pro
323:13 - and we are looking at kubernetes system
323:14 - logs and k logs so system logs
323:18 - um is system component logs that record
323:21 - events happening in a cluster which can
323:23 - be very useful for debugging and you can
323:26 - configure log verbosity to see more or
323:29 - less detail so logs can be as
323:32 - coarse-grained as showing errors with
323:34 - the component or as fine grain as
323:36 - showing step-by-step traces of events
323:38 - such as http access logs pods state
323:41 - changes controller actions scheduled
323:43 - decisions and as easy as they make it
323:46 - sound and detailed information i
323:47 - couldn't find a whole lot here i think i
323:49 - would have to probably jump into follow
323:51 - along and make a practical example to
323:53 - really extract that information out but
323:55 - really they just it was like cost
323:57 - management it's like i could not find
323:59 - good examples readily available to
324:02 - digest in a slide here but there is the
324:04 - cube ctl command logs and so here we're
324:07 - providing the pod name or deployment
324:10 - name whatever it is probably pod name
324:12 - and so that would get you log
324:13 - information
324:15 - there's a library called k log it's the
324:17 - kubernetes logging library it's based
324:20 - off of g log which is golang's logging
324:23 - library and it generates log messages
324:25 - for the kubernetes system components
324:27 - and i think we did talk about cubelet
324:29 - being able to in the cubelet section uh
324:32 - you know
324:33 - taking log data and sending it back uh
324:35 - where wherever
324:37 - uh there so you know hopefully that
324:39 - gives you kind of an idea
324:41 - there about logs okay
324:44 - [Music]
324:49 - all right let's take a look here at
324:50 - chaos testing and testing so what is
324:51 - testing well this is the assertion
324:54 - uh that we have an expectation of inputs
324:56 - and outputs of functions that's the most
324:57 - basic thing in programming so the idea
325:00 - is we have a variable
325:02 - called hello right here and we assign it
325:04 - a string called world and then we assert
325:07 - using our testing framework to say does
325:10 - the variable hello equal world and if it
325:12 - does
325:13 - uh pass if it doesn't fail okay
325:16 - so that's the basic concept now it's not
325:18 - going to be the same for um uh
325:20 - kubernetes but
325:22 - we don't really have to dig that deep
325:23 - because it's not on the exam okay
325:25 - so
325:26 - let's talk about chaos testing so this
325:28 - is building a system to withstand and
325:29 - tolerate any kind of failure by
325:31 - purposely introducing random failures in
325:33 - a production system so it's just like
325:36 - imagine if you uh had a junior developer
325:38 - that was just doing whatever they wanted
325:40 - you know
325:41 - and you're just making sure that your
325:43 - application is resilient to any kind of
325:46 - problems so there's a few different
325:48 - frameworks out there so for chaos
325:50 - testing we have chaos cube for a just a
325:52 - testing framework we have test cube and
325:55 - then there's the generalized chaos
325:56 - monkey which is another kiosk testing
325:58 - framework so i just wanted you to know
326:00 - that there was a chaos cube and test
326:02 - cube
326:03 - frameworks and the exam's not really
326:05 - going to ask you about this stuff but
326:07 - you should know it so that's why i'm
326:08 - showing it to you okay
326:14 - hey this is andrew brown from exam pro
326:16 - and we are taking a look at helm so
326:17 - before we answer that we asked to ask
326:19 - ourselves what is a package manager so a
326:22 - package manager is a collection of
326:24 - software tools that automate the process
326:26 - of installing upgrading configuring and
326:28 - removing computer programs for a
326:30 - computer in a consistent manner so helm
326:34 - is a package manager for kubernetes and
326:37 - helm is broadly composed of three
326:38 - components we have charts so these
326:40 - contain all the resources definitions
326:42 - necessary to run applications tools
326:44 - services inside kubernetes clusters
326:47 - repositories so this is the place where
326:49 - charts can be controlled and shared and
326:51 - releases an instance of a chart running
326:53 - in a kubernetes cluster so i just want
326:56 - to show you the helm chart directory
326:58 - structure so if you were to create a
326:59 - package this is an example i found
327:01 - online where it's a wordpress
327:04 - helm chart and so here you can see
327:06 - there's the chart yaml file license
327:08 - readme
327:09 - things like that one thing is that you
327:11 - always have this chart yaml file but
327:13 - there's also this values yaml which
327:15 - defines
327:17 - the variables and the default values and
327:19 - the values you can pass into this to
327:21 - configure
327:22 - the helm package okay so helen reserves
327:26 - the use of charts direct directory crds
327:29 - so i assume that's custom resource
327:31 - definitions
327:32 - template directories and uh
327:35 - of the listed file names other files
327:37 - will be left as they are
327:39 - okay
327:41 - i'm just pointing out that chart yaml is
327:42 - important and values yamls is important
327:45 - or at least i thought it was because
327:46 - when i opened up the chart um
327:48 - chart.yaml file i was expecting to kind
327:50 - of see something interesting but it's
327:52 - just kind of very boring it's like
327:53 - package.json's like okay these are the
327:55 - dependencies the api versions the
327:58 - description
327:59 - the home page the maintainers nothing
328:02 - super exciting but basically if you want
328:04 - to um package this and put this on their
328:09 - the place where they host them which
328:10 - some are listed in this section here um
328:13 - you know that's something you're going
328:14 - to need so let's talk about packaging
328:15 - installing so to package a chart
328:17 - directory in a version chart archive the
328:19 - helm package command is used so that we
328:21 - do helm package hyphen hyphen sign i
328:23 - guess you have to sign it provide its
328:25 - directory
328:27 - there so version charts archives are
328:28 - used by helm package repositories and i
328:31 - was saying that there's a place where
328:32 - you can find all these and they're on
328:34 - artifact hub so you go to artifacthub.io
328:37 - and there's all sorts of
328:39 - helm packages you can access so i just
328:42 - typed in
328:45 - something like postgrass or something
328:46 - like this and i found this one and often
328:48 - what you're doing is you add the repo so
328:51 - you know where
328:52 - um where to go get
328:54 - this package then you do an update then
328:56 - you do an install and that's pretty much
328:58 - the procedure that you're going to run
328:59 - of course if you have configuration
329:01 - you'll provide values uh via flags and
329:04 - things like that but that's helm in a
329:06 - nutshell but we do cover it in this
329:08 - course so you will at least know how to
329:10 - install something from helm not
329:12 - necessarily make a helm package because
329:14 - it's a lot of work but there you go
329:16 - [Music]
329:20 - let's talk about customize so customize
329:22 - provides more flexibility when writing
329:24 - kubernetes configuration files by
329:26 - allowing you to overlay or override to
329:28 - patch configurations and customize is
329:30 - built in the cube ctl at least a version
329:32 - of it
329:34 - and so customize kind of is put up
329:36 - against helm and being like an easier
329:38 - simpler version of helm
329:40 - we do not do a follow along on customize
329:43 - just because helm i think it's just
329:45 - i mean like if we were to do showing you
329:48 - how to package a helm which we don't we
329:49 - show you an install helm package i'd
329:51 - rather do helm than customize because i
329:52 - think that it's just um
329:54 - has better utility for uh organizations
329:58 - but uh the way customize works is that
330:00 - you define your base architecture in a
330:02 - folder called base so you have
330:04 - deployment service anything you want in
330:05 - here and then you have customization
330:07 - yaml which contains how things should
330:10 - get patched and so then you have down
330:12 - below patches overlays whatever you want
330:14 - to call it because it doesn't matter
330:16 - what the folder name is you can call it
330:17 - whatever you want because you're just
330:18 - going to be using an apply
330:20 - and so it will have a customization yaml
330:22 - and that file will say in that thing
330:24 - it's like a yaml file that says um
330:27 - patch with these other files and these
330:29 - files look very similar to the other
330:30 - ones it just literally replaces
330:32 - components like almost overlaying them
330:34 - um
330:35 - wasn't easy to find anything that would
330:37 - show me how to do this really quickly i
330:39 - probably would have to spend like a
330:40 - couple hours just to get a simple
330:41 - example for you not that it's hard but
330:44 - just hard to find available
330:46 - examples for customize that easily
330:48 - translated over for you but it's not
330:50 - going to really be heavy on the exam i
330:52 - just want you to know that's an
330:53 - alternative to helm and it's uh
330:55 - supposedly easier to use okay
330:57 - [Music]
331:01 - hey this is andrew brown from exam pro
331:03 - and we are taking a look at
331:04 - infrastructures of code and so first we
331:06 - have to kind of outline the problems
331:08 - with manual configuration so there is an
331:11 - advantage to manual configuration
331:13 - it allows your cloud infrastructure your
331:15 - cloud native infrastructure uh to easily
331:18 - start using new service offerings new
331:20 - apis versions to quickly prototype
331:22 - architect architectures however it comes
331:24 - with a lot of downsides so it's easy to
331:27 - misconfigure a service through human
331:29 - error or kubernetes components so this
331:32 - is just a general slide that's why i'm
331:33 - keep on adapting it to kubernetes terms
331:35 - here it's hard to manage the expected
331:37 - state of a configuration for compliance
331:39 - it's hard to transfer configuration
331:41 - knowledge to other team members so
331:43 - infrastructure as a code allows you to
331:45 - write a configuration script to automate
331:47 - creating updating or destroying cloud
331:48 - infrastructure and the idea is an iac is
331:52 - a blueprint for your infrastructure
331:55 - iec allows you to easily share version
331:57 - or inventory or cloud infrastructure and
331:59 - so the idea is that you'd have your
332:02 - script or collections of scripts or
332:04 - whatever tool you use and then by
332:06 - running it once you can do it and so
332:08 - kind of in a sense when you write
332:09 - manifest files in kubernetes you
332:12 - technically are doing infrastructure as
332:14 - a code but you generally get some extra
332:17 - benefits there like um
332:19 - state management so uh things like that
332:22 - so we're doing infrastructures of code
332:24 - but like there's just other benefits
332:25 - around there and so we could just kind
332:26 - of have to understand
332:28 - um the difference there because it's a
332:29 - bit fuzzy with kubernetes okay
332:32 - [Music]
332:37 - all right so what i want to do here is
332:38 - look at popular infrastructures of code
332:40 - tools and also describe declarative
332:42 - versus imperative so declarative we'll
332:44 - start with that so declarative means
332:47 - what you see is what you get it's very
332:49 - explicit it's also more verbose but
332:52 - there's zero chance of misconfiguration
332:54 - so these would use scripting languages
332:56 - like json yaml xml or a kind of hcl and
333:01 - so every single cloud service provider
333:03 - generally has their own tool or they use
333:05 - a generic one
333:07 - like terraform but for
333:09 - azure we've got arm templates and
333:11 - blueprints for aws we have
333:12 - cloudformation for google we have cloud
333:15 - deployment manager for everybody else we
333:17 - have terraform uh does ibm cloud have
333:19 - their own i don't know i think you would
333:21 - have to use terraform for that and
333:23 - oracle cloud you definitely use that um
333:24 - but terraform is this one where uh it's
333:28 - it's designed to be um multi-cloud right
333:31 - on the imperative side we have uh you
333:34 - say what you want and the rest is filled
333:35 - in so it's implicit
333:37 - less verbose you could end up with
333:39 - misconfiguration
333:40 - does more than declarative because
333:41 - you're able to utilize full programming
333:43 - languages that does come with additional
333:45 - complexity but it can be worth it so
333:47 - things like uh the aws cloud development
333:49 - kit cdk or pollumi are two options there
333:53 - um but it's interesting because when
333:54 - we're talking about infrastructure code
333:56 - there is the
333:58 - managed infrastructure
333:59 - or managing infrastructure of the
334:01 - cluster but then there's managing
334:02 - infrastructure in the cluster or app or
334:05 - application infrastructure and that's
334:06 - something we'll talk about here next
334:08 - okay
334:12 - [Music]
334:14 - all right so for kubernetes
334:16 - infrastructures of code can be a bit
334:17 - squishy a bit confusing because the idea
334:20 - is that you have uh infrastructure that
334:22 - kubernetes has to run on like virtual
334:23 - machines
334:25 - like cloud service providers self-hosted
334:27 - data centers but then there's kubernetes
334:29 - components like things inside the
334:31 - cluster and so i'm just going to try to
334:33 - help you understand that it's all
334:35 - infrastructure but we might just have to
334:36 - contextualize it so there's managing
334:39 - infrastructure of the cluster and
334:40 - there's managing infrastructure in the
334:43 - cluster and the tools that we use will
334:45 - be a slightly different because when
334:47 - people think of infrastructure as a code
334:49 - they're going to default to something
334:50 - like cloudformation terraform but um you
334:53 - know it's not going to solve all of our
334:54 - problems and so let's just talk about
334:57 - some of the differences here so if we're
334:58 - managing infrastructure of the cluster
335:00 - this is stuff that the cluster is
335:02 - running on the virtual machines or
335:03 - managed services like eks google cloud
335:06 - engine or or what have you and so those
335:09 - can be set up with a tool like a
335:10 - traditional tool like terraform or cloud
335:13 - formation or
335:15 - azure blueprints or arm templates or a
335:18 - deployment manager use the provision the
335:20 - cluster and manage services so like
335:22 - relational databases or things that you
335:24 - don't want to put on the responsibility
335:26 - of the cluster alongside the cluster
335:29 - itself okay so
335:32 - that's the recommendation now for in the
335:34 - cluster
335:36 - you can use terraform okay you can
335:39 - technically use terraform because they
335:40 - have this manifest module and basically
335:42 - you're just rewriting your manifest
335:44 - files like the yaml files as hcl which
335:47 - is the the base language or the the
335:49 - language of terraform files
335:51 - and so the reason you might want to use
335:53 - terraform is because you benefit from
335:55 - the state management provided by
335:57 - terraform and that way you'll be able to
335:59 - kind of detect configuration drift and
336:01 - things like that kubernetes already
336:03 - manages state within the controller
336:05 - manager and std so it's kind of like
336:08 - well
336:09 - uh terraform manages state but
336:10 - kubernetes already managed the state do
336:12 - we need two things in energy and state
336:14 - and there could be other ways of doing a
336:17 - configuration drift like using the
336:19 - admissions controller so it's debatable
336:21 - whether it's worth the extra complexity
336:24 - to manage things in the cluster using
336:26 - terraform but definitely of the cluster
336:29 - terraform or cloud formation or what
336:30 - have you is totally fine when we're
336:32 - talking about managing in the cluster um
336:35 - i like to put the thing in front of it
336:36 - application of infrastructure so things
336:39 - like pods services ingress anything that
336:41 - you would deploy as components and it's
336:44 - recommended to package these as helm
336:46 - charts and use that in your ci cd now
336:49 - you think well couldn't i just take all
336:51 - these manifest files and put them in a
336:53 - github directory sure but there are some
336:55 - synergies by using helm because it's
336:57 - just easier to like
336:59 - helm deploy than it is to put things in
337:02 - there and so this is kind of where we
337:04 - see a separation of those two could you
337:06 - use ansible
337:07 - i guess i wouldn't recommend it
337:10 - but these are the two that i generally
337:11 - think that would be good and i think
337:13 - terraform would be good for the cluster
337:15 - because if you use it once um it's that
337:17 - won't be too hard if you ever have to
337:19 - move uh to another provider and if
337:21 - you're using kubernetes that's one of
337:23 - the benefits so you know why not use it
337:25 - okay so there you go
337:27 - [Music]
337:31 - hey this is andrew brown from exam pro
337:33 - and we're taking a look at get ops so
337:34 - get ops is when you take infrastructures
337:36 - of code and you use a git repository to
337:39 - introduce a formal process to review and
337:41 - accept changes to infrastructure as a
337:43 - code once the code is accepted it
337:45 - automatically triggers a deploy so
337:48 - here's the general example here where
337:51 - you have some kind of iac tool like
337:53 - terraform
337:55 - and you actually commit
337:56 - the changes to your code and this also
337:58 - could be like helm packages and things
338:00 - like that in the mix to your github
338:02 - repository uh so a pr would be generated
338:06 - and it could be auto auto approved or
338:09 - someone can review it and press a button
338:11 - it gets merged into the main branch and
338:13 - then some kind of
338:15 - cicd tool this is github actions but it
338:17 - could be
338:19 - argo cd
338:21 - it could be
338:22 - uh jenkins x jenkins
338:25 - um flux and then from there it would go
338:28 - to the cluster's providers to affect the
338:30 - managed managed services or it could be
338:32 - going to kubernetes to
338:34 - you know affecting components or things
338:36 - like that or rolling out a hem helm
338:38 - package there to get our changes so uh
338:41 - the most important thing is that it's a
338:42 - formal process review and accept changes
338:44 - of infrastructure code by via a git
338:48 - repository so there you go
338:50 - [Music]
338:54 - all right let's take a look here at ci
338:56 - cd models
338:57 - and before we do i just want to mention
338:58 - a couple terms if you're not familiar
339:00 - with them the difference between
339:01 - production and staging so production
339:03 - commonly abbreviated to prod prod or
339:07 - sometimes even pro
339:09 - is the live server where the real paying
339:11 - users are using the platform and staging
339:13 - is a private server where developers do
339:16 - a final manual test as a customer like
339:18 - doing quality assurance qa before
339:21 - deploying to production and so this is
339:24 - our ci cd pipeline or life cycle
339:27 - whatever you want to call it deployment
339:28 - life cycle we have code build integrate
339:31 - test release deploy
339:32 - okay and so for these it's going to vary
339:35 - because there are some different terms
339:36 - like ci cd and and what have you so
339:39 - let's just take a look at uh what
339:41 - happens here and the first we're looking
339:42 - at is continuous integration and so
339:44 - continuous integration means
339:45 - automatically reviews developers code so
339:48 - it's this part of the pipeline where you
339:50 - you have code it builds it integrates a
339:52 - test but it's not rolling out uh for
339:54 - release okay
339:56 - then you have the concept of continuous
339:57 - delivery so automatically preparing
339:59 - developer's code for release to
340:01 - production that means doesn't mean it
340:02 - gets automatically released but it means
340:04 - that it's ready uh someone's got to
340:06 - press the button to get it out to the
340:08 - server and then you have continuous
340:09 - deployment so this automatically deploys
340:11 - code as soon as a developer pushes code
340:13 - if all tests pass so usually like you'd
340:17 - have a pr and someone would look it over
340:18 - but you could just have really good
340:20 - tests and if your tests say it's okay
340:22 - basically that's like the a-okay to go
340:24 - roll it out so just understand that
340:26 - there's ci cd here and that continuous
340:29 - delivery and continuous deployment share
340:31 - the same initialisms and i think some of
340:33 - them uh might do like a forward slash or
340:36 - not a forward slash indicate the
340:37 - difference between them i don't do that
340:38 - they're both just cd um but just
340:40 - understand that um you know that these
340:42 - share the same one and continuous
340:43 - deployment is the one that does
340:45 - everything whereas delivery is like
340:47 - delivery as in here's the thing but
340:49 - you've got to open it up uh to do
340:51 - something with it okay
340:53 - [Music]
340:57 - all right so let's take a look here at
340:59 - argo versus flex so the cncf have two ci
341:02 - cd projects that serve the same purpose
341:03 - but take a different approach and both
341:06 - of these are in the incubating stage so
341:07 - they're all both safe to use unless
341:09 - you're super enterprise and you have
341:11 - some kind of concern
341:13 - but we have flux and argos let's talk
341:16 - about the difference so flux was
341:18 - originally developed by weaveworks
341:20 - it takes a cli first approach it's
341:22 - experimental web ui is a plug-in so you
341:24 - can get a visual thing it supports
341:26 - role-based access controls it supports
341:29 - multi-tenancy in flux too so if you're
341:31 - using flex one you won't have that it
341:32 - supports helm and customization and
341:34 - that's the logo for weworks uh it has
341:36 - automation of container updates let's
341:38 - take a look at what argo does so it has
341:40 - both a cli and web ui so it's had a
341:43 - little bit more to start with supports
341:45 - role-based access controls supports
341:47 - single sign-on supports multi-tenancy
341:49 - helm customization case on it jsonnit
341:53 - manual commit and sync to update
341:55 - containers and so you might say well it
341:57 - looks like argo basically has almost
341:59 - everything so why not just use it well
342:01 - generally flux is simpler in design and
342:03 - cli focused so if you need to get off
342:06 - the ground real fast flux is very
342:08 - popular
342:09 - if you want a simple solution
342:11 - but you know they do have a lot of
342:13 - overlap and you'll just have to decide
342:14 - for yourself which one it is you want to
342:16 - use
342:20 - [Music]
342:22 - all right let's take a look here at
342:23 - jenkins jack and x and cloud b so
342:25 - jenkins uh what the you
342:28 - piece of garbage
342:31 - oh god
342:36 - all right let's take a look here at
342:37 - jenkins jenkin x and cloud b's so
342:40 - jenkins is an open source popular
342:41 - immature cic-2 tool for any kind of
342:44 - workloads check-ins can be used to
342:46 - deploy applications onto kubernetes
342:49 - because it's for any kind of workloads
342:50 - and jenkins is written in java and have
342:52 - many plugins for any use case now
342:55 - there's jenkins so then why is there's
342:57 - this thing called jenkins x so jenkins x
342:59 - is an open source cs cd tool for modern
343:02 - cloud applications on kubernetes
343:04 - compared to jenkins it's supposed to be
343:06 - much much easier to use and jenkins x
343:09 - may replace or merge with jenkins one
343:11 - day to only have a single ci cd tool for
343:14 - all use cases but you have two options
343:16 - here jenkins and jenkins x
343:19 - and it's good to know like who makes
343:20 - jenkins and it's called cloud b's this
343:22 - is the commercial distribution of
343:23 - jenkins and jenkins x for large and
343:26 - compliance first organizations clouds
343:28 - bees was acquired by infra dna yeah for
343:30 - dna
343:31 - organization created jenkins originally
343:34 - so there you go
343:35 - [Music]
343:40 - all right let's take a look here at
343:40 - circle ci which is a proprietary fully
343:43 - managed ci cd service to make
343:45 - deployments easy and seamless and can
343:47 - support deploying applications to
343:49 - kubernetes so the key part here is that
343:51 - it's proprietary
343:53 - but it is fully managed so it is one of
343:55 - the easiest deployment solutions out
343:57 - there but also uh you know it's just not
343:59 - open source so that's just something
344:00 - you'll have to consider i just want you
344:01 - to know a tiny bit about it okay
344:03 - [Music]
344:08 - hey this is andrew brown from exam pro
344:10 - and we are looking at deployment
344:11 - strategies so a deployment strategy is a
344:13 - way to change or upgrade an application
344:15 - and there's two terms that i think you
344:17 - should know uh regarding deployments and
344:19 - that is rollouts and rollbacks so a
344:22 - rollout is when you replace or update
344:25 - servers with new versions of an
344:26 - application and the word server could be
344:29 - just replaced with pods in this case
344:30 - because the the um
344:32 - nodes is may or may not be something
344:35 - that is getting rolled out it really
344:36 - depends on what happens there we have
344:39 - rollbacks and this is when you replace
344:41 - revert recently updated servers back to
344:43 - the previous version and so there is a
344:46 - um
344:47 - a rolling update but understand that
344:49 - rola is just a generalized term that
344:51 - applies to all of these deployment
344:54 - strategies so there are several
344:55 - different deployment strategies that can
344:56 - be utilized with kubernetes
344:58 - some of these
345:00 - it's a lot easier to do them if you have
345:02 - like argo or
345:04 - flux or jenkins
345:06 - but deployments are built into
345:08 - kubernetes you don't need to have an
345:10 - additional tool to do them but you might
345:11 - be limited in your options and some i'm
345:14 - going to list here are a little bit more
345:15 - advanced and probably won't show up in
345:16 - the exam but you should know them anyway
345:19 - and that's why i'll go through them but
345:20 - i'll point out which ones uh that you
345:22 - definitely need to know versus the ones
345:23 - that are nice to knows so the first is
345:26 - recreate so terminate the current pods
345:28 - and create new pods all at once normally
345:30 - we call this in place deployment but
345:33 - they call it recreate then you have a
345:35 - rolling update so replace one or more
345:37 - multiple pods at a time
345:40 - then you have canary so add new pods and
345:42 - route a subset of your users to the new
345:43 - server if no bugs or errors occur roll
345:46 - out changes to all the pods you have
345:48 - blue greens to deploy an exact copy of
345:50 - your entire infrastructure and when we
345:52 - say infrastructure it might not
345:53 - necessarily be cluster infrastructure
345:56 - but just application infrastructure
345:57 - because kubernetes is a bit different
345:59 - then you swap the traffic and then
346:01 - terminate the old environment or roll
346:02 - back to the old environment
346:05 - in case you know the the new
346:06 - environment's not working out you have a
346:09 - to b testing or red and black
346:11 - deployments red and black they won't
346:13 - come up but a to b might
346:15 - very similar to canary so
346:17 - the idea here is that
346:19 - you aren't necessarily tearing down um
346:23 - that alternate traffic you're leaving it
346:25 - up for a subset of users to test
346:27 - features um and so you know it's just
346:30 - the difference between temporarily or
346:32 - permanently then we have dark launches
346:34 - so this is similar to a to b testing
346:36 - except it's happening um
346:39 - like the a to b is happening
346:41 - at the application
346:43 - layer so
346:44 - um it's not it doesn't require
346:47 - a rollback or anything like that you're
346:49 - just flipping a switch in the code but
346:50 - we will go in detail and show you a
346:52 - diagram of each of these so that you
346:54 - thoroughly understand them but like red
346:55 - and black deployments dark launches
346:57 - that's not going to come up but
346:58 - everything else should and you should
347:00 - know them pretty well okay
347:02 - [Music]
347:06 - all right let's take a look here at a
347:08 - recreate a strategy so the idea here is
347:11 - that it will terminate all running
347:12 - instances and recreate with a new
347:15 - version when i say instances we're
347:16 - talking about pods
347:18 - and this is also known as an in-place
347:21 - deploy that is generally the term used
347:23 - in clusters providers and everywhere
347:25 - else but here they call it a recreate
347:27 - and so the way you'd specify that is in
347:30 - your deployment file
347:31 - in your replica set probably in your
347:33 - deployment file because i can't imagine
347:35 - you can do it other places
347:37 - but in your spec area that's where you
347:38 - define your containers you can add a
347:40 - strategy and just specify the type as
347:43 - recreate so i'm not showing the whole
347:44 - file there for you but it's as simple as
347:47 - that so let's just kind of visualize
347:49 - this so we understand so imagine we have
347:51 - an app running
347:53 - and i put argo cd there but you know
347:56 - it's not like the perfect diagram but
347:58 - the idea is that
347:59 - we're showing argo as the deployment
348:02 - tool but you don't necessarily have to
348:03 - use it um and so the idea is we
348:06 - terminate all servers and there's a
348:08 - period where the traffic is interrupted
348:10 - now recreate would work really really
348:12 - fast so the downtime would be very
348:14 - minimal but it would happen
348:16 - uh new servers are created and uh we
348:19 - route traffic to these new servers so
348:22 - users will experience downtime
348:24 - it can be very fast very simple but
348:27 - rollback
348:28 - is not possible i mean it's possible to
348:32 - roll back to the previous version it's
348:34 - just not possible to roll back to
348:36 - running servers so i think i should just
348:38 - clarify that because with deployments
348:41 - you have a deployment history so there's
348:42 - definitely something we can roll back to
348:44 - but it will mean that we have an
348:45 - interruption again right so it'll be uh
348:49 - you know rule forward
348:51 - interruption roll back
348:52 - interruption and not rolling back to
348:54 - something that's running so this is
348:56 - ideal for non-production workloads or
348:58 - where interruptions can be tolerated
349:01 - [Music]
349:05 - all right let's take a look here at
349:06 - rolling updates so these slowly replace
349:08 - pods one by one or based on as many as
349:11 - you want to specify and this is the
349:13 - default strategy of kubernetes so
349:16 - imagine you have um some instances there
349:18 - or pods running and you terminate uh an
349:22 - amount of pods so in this case we're
349:23 - terminating one and then we spin up a
349:25 - nude pod to take its place so as you can
349:28 - see this is the new pod here
349:30 - uh and then we tear down the old one and
349:32 - then replace that one there and so
349:35 - we are all done and so again you can do
349:37 - that in
349:39 - chunks or sets
349:40 - um
349:41 - and you can you can have it so that it
349:43 - either terminates first or
349:46 - if you want you can have it so that it
349:48 - spins up a new one and then tears down
349:49 - the other one which we'll talk about
349:50 - here in a second so with rolling updates
349:52 - you have reduced availability and i put
349:54 - an asterisk there because it really
349:55 - depends on how you configure it which
349:57 - might happen while each set of pods is
349:58 - taken uh taken terminated as the new
350:01 - ones are created rollbacks can be slow
350:03 - and hard deploys will be slow
350:06 - because it's doing one at a time or
350:08 - a few at a time
350:10 - so
350:11 - let's just talk a little bit more about
350:12 - availability because that's kind of an
350:14 - important thing that might get glossed
350:15 - over here that you need to consider so
350:18 - um available what is availability so the
350:19 - quality of being available to be used or
350:22 - obtained so if there's not enough
350:24 - capacity like memory cpu bandwidth to
350:26 - meet the demand of traffic then users
350:27 - can experience degraded delayed
350:29 - experience or no access to services at
350:32 - all so if you have two servers and you
350:34 - only have one then you know uh that
350:37 - means there's more traffic going to that
350:39 - single machine there may be enough cpu
350:41 - but you know it might make the machine
350:43 - slow or the the app might hang
350:46 - completely so
350:48 - that's where you have to be careful
350:49 - about availability so
350:52 - uh there are some values not sure about
350:54 - the graphics not showing that there we
350:55 - go that you can set the first is max
350:57 - surge and then we have max unavailable
350:59 - so max search says the amount of pods
351:02 - that can be added
351:04 - added at a time and so that means if you
351:06 - want to
351:07 - replace two at a time you can do that
351:09 - and then max unavailable so if you were
351:11 - to set this to be two and two that would
351:13 - ensure there would never be a drop in
351:15 - availability um but the deployment would
351:17 - have to first because the total would
351:18 - have to first create the new pods before
351:20 - tearing down the old ones so i don't
351:23 - know for sure 100 how this works like
351:27 - uh when i say that i just mean that i
351:29 - haven't been deploying a ton of these in
351:31 - practice i mean this is the default
351:33 - behavior but you know we don't observe
351:35 - it to say okay was this server there was
351:37 - this server not there but i do know that
351:38 - if you were set two and two or match it
351:41 - that you wouldn't lose any availability
351:43 - there okay
351:44 - [Music]
351:48 - all right let's take a look here at
351:50 - canary strategy so the idea here is we
351:53 - deploy a new version of the app into a
351:54 - new pod and serve it to a subset of
351:56 - existing users if there is no error or
351:59 - bug that has occurred then the rollback
352:00 - changes to all users by replacing old
352:02 - pods
352:03 - with new pods so imagine you have a
352:06 - bunch of pods let's say we're using argo
352:08 - because it probably make it a lot easier
352:10 - and the idea is you create a bunch of
352:11 - new pods now i show it like as if
352:13 - they're replacing ones
352:15 - but uh you know originally like when i
352:17 - think of canary usually the default
352:18 - behavior in other ones is that it tears
352:21 - down some and replaces them so might do
352:23 - an in-place or add new ones
352:25 - and stuff like that but the way it looks
352:27 - like
352:30 - kubernetes works is it actually spins up
352:32 - new ones alongside them
352:35 - so you know that's just kind of a bit of
352:36 - a difference there but generally the
352:37 - concept's the same so we'll be fine here
352:39 - but the idea is that uh we're gonna send
352:41 - a portion of our traffic um to these new
352:44 - pods and if we are happy
352:47 - uh with the traffic like there's no
352:49 - problems everything's going fine then
352:51 - we'll roll out uh to all the rest
352:53 - meaning like tear down the other ones
352:55 - and replace them with pods with new
352:56 - versions so we got fast roll out because
352:59 - you know when you look at um
353:02 - a roll with a like rolling update it's
353:05 - just like a few at a time where this one
353:07 - will just like completely switch all the
353:09 - ones over very quickly uh it has a slow
353:12 - roll back
353:13 - it should not have a drop in
353:14 - availability because even though it
353:16 - looks like it's
353:17 - replacing these ones here these actually
353:19 - just be additional to these okay
353:22 - if that makes sense
353:23 - um and so canary will use the load
353:26 - balancer weighted rules to only send an
353:28 - amount of traffic to the carry pods in
353:29 - the original pods just so you know how
353:31 - they're doing that balancing there
353:33 - but there you go
353:34 - [Music]
353:38 - all right let's take a look here at blue
353:39 - green deployment so blue green is when
353:41 - you completely create a new environment
353:43 - of all components and you send all
353:45 - traffic to the new new or green
353:47 - environment and if it's okay then you
353:49 - terminate the old blue environment if
353:51 - anything goes wrong you can roll back to
353:53 - blue and tear it down so let's kind of
353:56 - get a visual to understand so imagine
353:58 - you have uh two pods and you define that
354:00 - to being the scope of your environment
354:02 - right
354:03 - and that's the key thing with blue green
354:05 - is that
354:06 - um
354:07 - you know you could consider
354:09 - a set of pods to be an environment you
354:11 - could consider
354:13 - like a node with everything running it
354:15 - on a environment you could consider the
354:17 - whole
354:18 - cluster
354:19 - um a an environment so it really depends
354:22 - on your scope but the way that i was
354:24 - reading about blue green for
354:26 - kubernetes is it we're generally talking
354:28 - about in cluster components defining an
354:30 - application workload but just understand
354:32 - that scope's going to change and the
354:34 - mechanism that you swap on will change
354:37 - but the idea is we have whatever it is
354:39 - that we that we have as our
354:41 - our application and its surrounding
354:42 - components and so we spin up complete
354:45 - identical so we wait till it's ready
354:47 - and then when it's ready we switch over
354:49 - to it and if we like it if everything's
354:51 - okay then we tear down the old one if we
354:53 - don't like it we can just switch back to
354:55 - the old one and so the idea is that you
354:57 - might have to wait a little bit a while
354:58 - for the new environment to spin up but
355:00 - it's going to be faster because it's not
355:02 - doing one at a time
355:03 - and it's a lot safer to move back back
355:06 - and forth so blue green is very popular
355:09 - but again if you need to roll things out
355:10 - really really fast
355:13 - the deployment time can be
355:15 - possibly slower but it really depends
355:16 - like how many pods you have so zero
355:19 - downtime no reduced availability slow to
355:22 - deploy but
355:23 - faster than canary if something goes
355:25 - wrong larger impact to users immediately
355:28 - instantly roll back to previous
355:30 - infrastructure so if there's a problem
355:31 - they're going to be able to resolve it
355:33 - extremely quickly so there you go
355:35 - [Music]
355:39 - all right let's talk about a to b
355:41 - testing or red and black uh deployment
355:44 - uh red black i rarely ever hear but i
355:46 - mean the concepts the same here so the
355:48 - idea is that this is similar to a canary
355:50 - or blue green but the method of
355:52 - deployment uh is the same but it serves
355:55 - the new apps experimental features to a
355:57 - subset of users based on a set of load
356:00 - balancing rules so the idea is that
356:03 - you might
356:04 - you'll have 60 percent of your app on
356:06 - the old app and 40 on the new app but
356:08 - the idea is that you're not tearing this
356:10 - thing down it's not like okay this
356:12 - feature works related to everybody it's
356:14 - let's leave it up for a good period of
356:17 - time and so that's the the context or
356:19 - key difference between a to b
356:21 - versus canary and uh red and black
356:23 - versus blue and green is that it's your
356:26 - intent to test something over a period
356:28 - of time and you're not necessarily
356:29 - rolling back on it
356:31 - at least not immediately okay
356:34 - [Music]
356:39 - all right let's take a look here at dark
356:40 - launches this definitely will not be on
356:42 - the exam but i thought it was
356:43 - interesting and we should include it so
356:45 - similar to a to b testing except a to b
356:47 - happens at the application layer so
356:49 - within the app code so let's say you
356:51 - want to test a feature on a subset of
356:53 - users you code a feature flag in your
356:55 - app to turn on the new feature on and
356:57 - off if the users like it the feature you
356:59 - leave it switched on if they don't you
357:01 - just turn it off and then the next
357:02 - deploy you could remove the code if you
357:04 - wanted to doesn't require you to roll
357:06 - back at the infrastructure level so fast
357:08 - rollbacks
357:09 - so just imagine you have your
357:10 - applications running on pods and you
357:12 - could just flip things on and off when
357:14 - need be so there you go
357:16 - [Music]
357:20 - let's take a look at how deployment
357:21 - history command works so you can check
357:23 - the history of the previous deploys with
357:25 - the following command cube ctl rollout
357:28 - history and then the name of the
357:29 - deployment to deploy hyphen the
357:31 - deployment name uh you don't need to
357:33 - have a forward slash in the middle there
357:35 - uh it's just an alternative syntax i'm
357:37 - just pointing that out because sometimes
357:38 - it trips me up
357:40 - and so here if we did that we could see
357:42 - the previous revision
357:44 - and when i did this repo uh deploy i had
357:46 - to do this
357:48 - flag here even though this is deprecated
357:50 - uh because i uh otherwise it wouldn't
357:52 - show the cause of change so i would
357:54 - imagine that if you have uh automated
357:57 - systems deploying stuff like that then
357:58 - maybe this would be
358:00 - good in terms of description but this is
358:02 - a way to see
358:03 - your history okay
358:05 - [Music]
358:09 - let's take a look at deployment rollout
358:11 - status so you can get the status of your
358:13 - deploy with the rollout status command
358:16 - so very similar similar to history but
358:18 - using the word status and the idea there
358:20 - is you can see it as it's deploying so
358:22 - say waiting for deployment and then what
358:25 - it is successful say that it has
358:27 - successfully deployed
358:28 - [Music]
358:33 - all right let's take a look at
358:34 - deployment rollback so you can roll back
358:36 - to the previous deploy shown in the
358:38 - rollout history with a rollout undo so
358:40 - you type in rollout undo which
358:42 - essentially is rollback uh and then here
358:45 - what we'll see is um
358:48 - no output when we run the command but if
358:50 - we were to run a status you can see that
358:52 - it's uh waiting to do that roll out and
358:55 - finish and so the idea is we'll roll
358:56 - back to that previous version okay
358:59 - [Music]
359:04 - hey this is andrew brown from exam pro
359:06 - and in this follow along i'm going to
359:07 - show you how to set up your own
359:09 - kubernetes cluster for development using
359:11 - a lightweight
359:12 - kubernetes distribution so kubernetes uh
359:16 - generally is very hard to deploy and
359:17 - most people uh like in like for general
359:20 - use case do not set up their own
359:22 - clusters for production what they'll do
359:24 - is they'll use a managed provider like
359:26 - aws's eks which we might do throughout
359:30 - this course i haven't decided yet but if
359:31 - it does show up that might be something
359:33 - we do
359:34 - but that can be really expensive because
359:36 - you have to pay for the control plane
359:38 - almost all providers charge for the
359:39 - control plane the control plane node as
359:41 - we learned throughout this course is a
359:43 - node specifically intended to
359:46 - orchestrate and coordinate all your
359:48 - worker nodes and the pods and everything
359:50 - so it's like the brain of kubernetes and
359:53 - on aws at least it's 10 cents an hour um
359:57 - so there are providers like sivo and so
359:59 - civo is actually very cost effective
360:03 - pricing comparison i wonder if they have
360:05 - it here so if we go here
360:08 - they might actually compare the
360:09 - different prices between the providers
360:11 - so sivo the control plane is free
360:14 - and this is a guess right and this is at
360:16 - scale so if you're using this for
360:18 - learning like if you made a civo account
360:20 - they'll give you 250 dollars i think for
360:22 - uh
360:23 - to start with and for this course you
360:26 - will not end up spending all that so if
360:30 - you are really strapped you could use
360:32 - civo i'm going to be using aws but we
360:34 - aren't going to be launching eks right
360:36 - now what we're going to be doing is
360:38 - launching a virtual machine so that it's
360:40 - only the cost of the virtual machine
360:42 - that we're paying if you really have
360:44 - zero money another thing you can do is
360:47 - use catacota so catacota is a sandbox
360:49 - environment by o'reilly and so they have
360:52 - this section on kubernetes introduction
360:54 - it is not sufficient enough for this
360:56 - course but i'm just pointing it out if
360:58 - you are very very strapped and but you
361:00 - want to get some hands-on this is an
361:02 - option for you i would not recommend
361:04 - doing this as your uh
361:06 - as first because the problem with
361:08 - sandboxes is that you aren't going to
361:10 - experience the hard bits and the hard
361:12 - bits is the experience that you're
361:14 - trying to obtain if you go do these
361:16 - you're going to follow them blindly copy
361:18 - paste them and the problem with that is
361:20 - that you're just not going to absorb any
361:21 - information but i want to make sure that
361:23 - you're aware of these resources this
361:24 - would be good for drilling so after our
361:27 - follow alongs if you wanted to just make
361:29 - make sure that you cement that knowledge
361:30 - you could go back here and try catacota
361:33 - but i think we really should set up our
361:35 - own uh cluster so we have a few options
361:38 - we have mini cube con k3s and micro k8s
361:42 - and so
361:43 - uh there are four different ones and
361:45 - they are all a little bit different so
361:46 - minicube is known for being extremely
361:48 - easy to use but it requires the most
361:50 - resources notice it requires two
361:52 - gigabytes of memory 20 gigabytes of free
361:54 - disk space but they all kind of require
361:56 - at least 10 gigabytes then you have
361:58 - k3s and kind so k3s and kind are
362:02 - essentially the same thing but kind is
362:04 - uh it has a wrap around it so that you
362:06 - can deploy your cluster onto
362:08 - docker and so
362:10 - kubernetes k3s is designed to be
362:13 - directly on bare metal or virtual
362:15 - machines as you see edge iot whatever
362:17 - this is made by rancher so rancher is a
362:20 - company that provides
362:21 - kubernetes managed services
362:23 - and the thing is is that uh k3s is not
362:26 - uh or like the rancher's version of
362:28 - kubernetes is not the same as kubernetes
362:30 - it's not vanilla kubernetes you'll see
362:32 - components in the control plane here
362:33 - like
362:34 - kind and flannel these things don't
362:36 - exist in
362:38 - kubernetes so there's something slightly
362:40 - different here
362:42 - so there's that and then we have kind
362:44 - which is again it's like k3s it's just
362:46 - wrapped in docker so you can see the
362:48 - little boat here to emphasize that and
362:50 - there's micro
362:51 - micro k8s so micro k8 is by canonical if
362:54 - you don't know canonical they're the
362:56 - ones that uh create and manage ubuntu
362:58 - and so it's actually really easy to
363:00 - launch microcase on your ubuntu machine
363:03 - surprisingly because it uses snap but
363:05 - what's nice here is they actually will
363:07 - compare the difference between
363:09 - micro k8s k3s and mini cube and now i
363:11 - said k3
363:13 - k3s is basically kind so just substitute
363:15 - that with kind because we're not going
363:16 - to do k3 3s we're going to do kind in
363:19 - these fall lungs here
363:21 - but let's just look at some of the
363:22 - comparisons so vanilla kubernetes so k3s
363:25 - is not vanilla as i as we saw in that
363:27 - diagram they had things that were
363:29 - slightly different that made up a
363:31 - different kind of control plane uh they
363:33 - mostly support the same things but here
363:35 - you can see the memory requirements
363:36 - micro k8s requires the least amount of
363:38 - memory minicube requires the most amount
363:40 - of memory then we have add-on
363:41 - functionality so micro k8 is very very
363:45 - uh plug-in driven so like it comes with
363:48 - nothing and you have to add everything
363:50 - it's very modular and that's probably
363:52 - why those memory requirements can go
363:53 - lower than those other ones mini cube is
363:55 - kind of like that as well uh k3s you
363:57 - just get what you get or kind then
363:59 - there's different container run times
364:01 - you can run on different ones there's
364:02 - different networking components that
364:04 - work with them storage is a bit
364:05 - different gpu acceleration is if you
364:07 - would want to do like something like
364:09 - machine learning um because you can run
364:11 - machine learning workloads on kubernetes
364:13 - there's a project for that can't
364:14 - remember up top my head
364:16 - so you can see there's kind of a
364:17 - difference there but they all generally
364:19 - kind of work the same um and it's going
364:22 - to be up to you to decide which one you
364:24 - like to use um i end up using my mini
364:27 - cube quite a bit but i generally like
364:29 - micro k8 when i can get it to work
364:32 - so uh just because it starts up so fast
364:35 - but yeah mini cube takes the longest to
364:37 - boot kind is very fast because it's in
364:39 - docker and then micro kx is like instant
364:41 - um which should be no surprise here but
364:44 - uh what we'll do here is um we'll make
364:47 - our way over to aws and before we can
364:49 - even run any of these things we're gonna
364:51 - have to have some kind of uh application
364:54 - to deploy and so what we'll do is we
364:56 - will create ourselves from scratch i'll
364:58 - show you how to do it uh a docker image
365:01 - and we'll host that somewhere in a
365:02 - container repository and we will use
365:05 - that uh as the thing that we will run in
365:07 - all these different uh lightweight
365:09 - containers um and so that's what we're
365:11 - going to do now okay
365:13 - [Music]
365:18 - all right so we are going to go build an
365:20 - application and we're going to use aws
365:22 - so you will have to go create yourself a
365:24 - bus account attach a credit card this
365:26 - isn't going to cost a lot i'm going to
365:27 - be very careful about spend here it will
365:30 - cost something but i really don't want
365:32 - the cost to go over 10 for the entire
365:33 - month while we're doing all these labs
365:35 - collectively like throughout the entire
365:37 - course
365:39 - but the thing i have to tell you is why
365:40 - i chose aws so the reason i chose abs is
365:43 - because it has this a service called
365:45 - cloud9 which is
365:47 - a um a cloud developer environment a
365:49 - cloud ever developer environment is a
365:51 - developer environment running on the
365:53 - cloud a very popular one is git pod and
365:55 - i would have used git pod because i
365:57 - really like them but the problem with
365:59 - git pod is that they uh use docker as
366:03 - the way that they run their environment
366:05 - and so um they're using docker with um c
366:09 - groups version one and in order to run
366:11 - kubernetes on docker you need c groups
366:13 - version two if you don't know what c
366:14 - group says don't worry it's covered in
366:16 - this course we do have to learn it but
366:18 - we could not use git pod so we had to
366:19 - use a virtual machine and we could have
366:22 - just launched any virtual machine up
366:24 - right we could have
366:25 - just went over to ec2 instances and
366:28 - launched one up or or
366:30 - azure virtual machine but the problem is
366:32 - is that
366:33 - there is more work involved launching
366:35 - those clusters like you have to specify
366:37 - the drivers and the base image and just
366:39 - be and you have to install docker and it
366:41 - became too complicated
366:43 - and so
366:45 - cloud9 just makes it really really easy
366:48 - for whatever reason they just have all
366:49 - the stuff to to to make the cluster set
366:52 - up uh super easy um and so that's why
366:54 - we're going to use it okay so what i
366:56 - want you to do is go type in cloud9 at
366:58 - the top here and we will go over to
367:00 - cloud9 we're going to create ourselves a
367:02 - new environment i'm going to call this
367:03 - k-8s env and we'll say this environment
367:07 - will be used
367:08 - to run
367:11 - a
367:13 - mini cube
367:15 - kind
367:16 - and to build
367:19 - our docker application
367:21 - okay
367:23 - and so we'll go ahead and hit next steps
367:26 - and for this we'll create a new ec2
367:28 - instance for direct access that just
367:30 - means that when we launch this and it
367:32 - has a terminal that terminal will be
367:33 - directly attached to the virtual machine
367:36 - and so this will have a virtual machine
367:38 - attached to it so we have to choose the
367:39 - size now remember minicube requires at
367:41 - least two gigabytes of memory and just
367:44 - to be on the safe side i'm going to go
367:45 - to a t3 medium notice that it's four
367:47 - gigabytes of ram uh so we'll do that
367:51 - and we have some options here amazon
367:52 - linux 2 amazon linux ami ubuntu and so
367:55 - ubuntu is fine but sometimes i run it
367:57 - with like pseudo issues and other stuff
367:59 - and so amazon x2 i would like to use it
368:01 - for everything but we can't use it for
368:03 - micro k8 because it we don't have snap
368:05 - installed so we're going to do amazon x2
368:07 - for two of them and then for ubuntu
368:08 - we'll have to set up a separate one this
368:10 - will turn off after 30 minutes of you so
368:13 - if you forget to turn off your
368:15 - environment don't worry it will take
368:16 - care of it for you and so we'll go ahead
368:19 - and hit next step
368:20 - and we'll go and create this environment
368:22 - so if you've never calculated costs in
368:24 - aws we'll just go over ec2 pricing just
368:26 - so you know what you are spending when
368:28 - you are doing this stuff and we'll go
368:30 - over to on demand and we'll look up a t3
368:33 - medium t2 probably costs the same thing
368:35 - but i'm going to look for t3 here so say
368:37 - t3 medium
368:38 - and this is the hourly rate and so the
368:40 - way i calculate anything is i take the
368:42 - adult the the cent amount that's the
368:45 - hourly and we go 7 30 because there's
368:47 - 730 hours generally in a month and so
368:49 - that would cost us 30 if we ran this
368:52 - nonstop which we're not right we're just
368:53 - going to use it when we need it it's
368:54 - going to shut off when we when we i
368:56 - don't need it okay
368:58 - so while that's spinning up we're going
369:00 - to see cloud 9. uh you might have this
369:03 - dark mode or light mode i don't know but
369:04 - we'll give it a moment and then we'll
369:06 - kind of just configure it so it's a bit
369:08 - nicer for us
369:10 - notice that the keyboard mode is vim you
369:12 - might be on default i'm using vim
369:14 - because i like that please say on
369:16 - default vim is very difficult to use if
369:17 - you're not a vim user you can also
369:19 - change
369:21 - the look of it so this is the classic
369:23 - dark theme
369:24 - there's a new flat one
369:26 - that i kind of like
369:27 - and so
369:28 - i want um i want this to be dark i just
369:31 - think it's nicer when it's dark so i'm
369:33 - going to go to
369:35 - preferences maybe and there should be
369:38 - themes here
369:40 - and if i drop down here
369:44 - i can't seem to find it but that's fine
369:46 - so
369:46 - there's just one that's really really
369:48 - nice that i like and it is flat dark but
369:51 - it's not letting me choose that for some
369:52 - reason here today which is totally fine
369:54 - so we'll just go back to
369:56 - um or maybe it's this one here
369:59 - uh
370:00 - this one ah we'll just stay on that okay
370:02 - we're just fiddling too much but we
370:03 - already have a virtual machine so this
370:04 - is an ec2 instance so if we go over
370:08 - to aws again just make sure you're
370:09 - logged in there
370:12 - and we'll sign in here
370:14 - we're going to go over to ec2
370:17 - i just want to show you that there is a
370:18 - virtual machine running
370:21 - okay so there it is there's our virtual
370:23 - machine running
370:25 - and uh the one thing that we didn't get
370:27 - to choose usually when you launch an
370:28 - instance a virtual machine you'll get to
370:30 - choose so we'll say like amazon likes to
370:32 - we'll go to storage now we gotta go next
370:34 - here we just get to choose the size but
370:36 - it defaulted to eight gigabytes right
370:38 - and that's not going to be enough space
370:40 - for our virtual machine and by the way
370:43 - aws has like a new
370:45 - layout here so this is like another way
370:47 - of creating a virtual machine very
370:49 - confusing i don't like that they did
370:50 - that but um
370:52 - the problem is this virtual machine does
370:54 - not have enough storage on it if we try
370:56 - to create our cluster we're gonna run
370:57 - out of space um but we'll worry about
371:00 - that later on so i just wanted to point
371:01 - that out but right now all we care about
371:03 - is creating ourself a new docker image
371:06 - to work with so what i'll do here is
371:08 - i'll go to the left hand side and i'll
371:10 - create ourselves a new folder and this
371:12 - is going to be our app
371:15 - okay and in here what we're going to do
371:17 - is create a sinatra app so i'm going to
371:18 - do sinatra
371:20 - um
371:21 - uh docker okay there should be like a
371:23 - very easy tutorial for us to find here
371:26 - yeah this one's fine i just need the
371:28 - base code i know how sinatra works if
371:29 - you don't know what sinatra is sinatra
371:31 - is a very very
371:33 - um simple web server for ruby that's
371:36 - like this simple
371:37 - um
371:38 - and it's just going to be really easy
371:39 - for us to use okay so what we'll do here
371:42 - is we'll just go and copy this code here
371:44 - so this will be the sinatra app so we
371:46 - will call this
371:48 - server.rb
371:50 - oops that's a folder we'll go ahead and
371:51 - delete that
371:54 - but we will create a new file here this
371:55 - will be server.rb we will need a gemfile
371:58 - that's how we install our plugins
372:00 - gemfile
372:02 - and then we need a
372:04 - config.ru
372:07 - and i think that's
372:09 - everything and so we'll go back over to
372:11 - here and we'll just start copying so
372:13 - we'll go here and we'll grab the actual
372:15 - server code they call there's hello i'm
372:17 - calling mine server just because we
372:19 - should really call it the server you
372:20 - know
372:21 - and it's not copying here we'll try this
372:23 - one more time i'll right click
372:25 - sometimes pasting is kind of a pain here
372:27 - so we'll paste this again
372:29 - there we go and i'm just going to say
372:31 - hello world
372:33 - and that's not hello i'll be able to
372:35 - take that out of there we will need our
372:37 - gem file so
372:39 - if we go back to this little project
372:41 - here this is all we need
372:44 - we just need to specify a source
372:47 - we also need to
372:49 - choose a default web server so we're
372:51 - going to choose web brick for that i
372:53 - know that they left that out of that
372:54 - tutorial that or it's just an old
372:56 - tutorial configure you that is for
372:59 - using rackets away it's like a
373:01 - lightweight interface for
373:04 - servers it's not that important to know
373:06 - you just need to know that you need it
373:07 - so we'll include that as well
373:10 - and that looks pretty fine and then we
373:12 - just need the docker files that's what
373:13 - we're missing here so we'll say new
373:15 - file docker file
373:18 - and then we'll just copy the contents
373:19 - here
373:21 - actually i'll take the simpler one here
373:22 - i don't need all the documentation
373:26 - okay we'll paste that in there
373:29 - this is using ruby 2.7.4
373:32 - so the great thing about cloud9's amazon
373:34 - linux is that it comes installed with a
373:35 - lot of stuff so if i type in ruby hyphen
373:37 - v it comes with a version 2.6.3
373:40 - right now the latest version of ruby is
373:41 - probably like 3.0 or something so i go
373:43 - to ruby here
373:45 - and we go here we can see the latest
373:47 - version is 3.1 so just to be safe i'm
373:49 - going to update the latest one rvm ruby
373:52 - version manager is a way of installing
373:53 - multiple versions of ruby if i do rvm
373:55 - list this is the version installed so
373:57 - i'm going to go rvm
373:59 - install 3.1.0 this might complain
374:02 - and if the reason why is it because it
374:04 - doesn't know that it's up to date so i'm
374:05 - going to type in rbm update which is not
374:07 - the command but i wanted to get the
374:09 - actual command we have to type which is
374:10 - rbm gethead
374:13 - and that's just going to tell it to look
374:15 - at the latest versions of ruby so now if
374:17 - i do rbm install 3.1.0 it'll install
374:20 - that i just realized my text is really
374:22 - small so i'm going to bump that up for
374:24 - you okay
374:25 - so we'll go over here and i will try to
374:27 - find that font while it is installing
374:31 - maybe user settings
374:34 - um terminal okay so terminal we can bump
374:37 - up the font here
374:39 - okay code editor
374:42 - um is the font okay yeah it's fine but i
374:45 - think we can make it a little bit bigger
374:48 - this is terminal code editor
374:51 - here we go
374:54 - okay that's better all right sorry about
374:56 - that
374:57 - i don't think there's much i can do
374:58 - about these there might be something to
374:59 - bump that up but i'm not sure so ruby
375:02 - 3.1.0 takes a little bit of time to
375:04 - install um so we will have to wait a
375:06 - little bit here but let's just take a
375:08 - look at the dockerfile if you've never
375:09 - done docker before
375:11 - you really kind of need to know a bit
375:13 - about docker to work with kubernetes
375:15 - because a lot of times you are packaging
375:17 - um
375:18 - images to be used with kubernetes and
375:19 - docker is the most
375:20 - common one here
375:22 - but here we have the ruby version
375:24 - so this is referencing a
375:27 - base image
375:28 - from docker hub so if i was to go and
375:30 - type in docker hub ruby
375:34 - okay this is what it's referencing it by
375:36 - default it's going to pull from here and
375:38 - it's pulling from this here this 3.1.0
375:41 - okay so if i click into here it'll
375:43 - actually show you the content so this is
375:45 - the uh the way they are setting up ruby
375:47 - for that image and then notice that it
375:49 - extends from bullseye so you can keep
375:51 - going down the rabbit hole but basically
375:52 - this is just a fancy back script for
375:55 - installing uh stuff and then packaging
375:57 - into a container okay we'll go back over
375:59 - to cloud nine it is still installing it
376:02 - what it's going to do is say look at the
376:03 - working directory and take all the code
376:05 - so
376:06 - um and then it's going to copy the code
376:08 - into that folder so create a new folder
376:10 - on the docker image called code and then
376:12 - copy the contents here all of these
376:14 - files into that directory
376:16 - and then do a bundle install so whatever
376:19 - is in the gem file install those uh
376:21 - bundles and expose on port
376:23 - four five six seven we can make this
376:25 - whatever port we want three thousand i'm
376:26 - gonna leave it as four five six seven
376:28 - and then
376:29 - uh when the docker image is is invoked
376:31 - like it's told to execute or run it's
376:33 - gonna run this command first bundle exec
376:36 - rack up so that's runs rack host bind on
376:39 - 0.0.0.0 that means to anywhere in the
376:42 - world you always need to bind to
376:44 - 0.0.0.0 very common for web apps and
376:46 - then it's going to uh listen or it's
376:49 - going to run on port 4567 so we're
376:52 - saying expose 4567 so that that port is
376:54 - open for the docker uh uh instance and
376:57 - then uh being able to access that okay
377:00 - so we will have to wait for this to
377:02 - finish um
377:03 - installing and also get back here in a
377:05 - moment okay
377:07 - all right so after a short little wait
377:08 - there it looks like our ruby version is
377:10 - installed so what i'm going to do is
377:11 - type in rvm list that's going to show us
377:14 - the versions there and notice this is
377:15 - the current version up here
377:18 - oh sorry it is set to this current one
377:19 - but i'm just going to say rvm use 3.1.0
377:22 - just in case and say rvm
377:24 - [Music]
377:26 - default
377:27 - i think it's use 3.1.0
377:30 - default i can't remember what it is
377:32 - that's okay we don't have to default it
377:34 - but now we have the right version of
377:35 - ruby installed so now i'm going to see
377:38 - into that app directory and we're going
377:39 - to do
377:42 - bundle
377:43 - install because we want to make sure
377:44 - that this works before we
377:47 - turn it into a docker image or file
377:49 - right so
377:50 - now that that is ran we can just start
377:53 - it by typing bundle exect
377:56 - ruby
377:57 - server.rb so bundle exec means do this
377:59 - in the context of what's installed in
378:01 - the docker file ruby to execute the ruby
378:03 - file server.rb and we'll hit enter and
378:05 - we'll see what comes out so it looks
378:08 - like it's running i'm just going to
378:09 - close that tab there and if we want to
378:10 - quickly test now we could open up a port
378:13 - to see if it's working but
378:14 - i'm going to open up a new terminal and
378:16 - what i'm going to do is type in curl
378:17 - localhost
378:19 - 4567
378:21 - and it says connection refuse so i'm
378:23 - just going to check to see what port it
378:25 - actually started up it actually started
378:26 - on port 8080
378:28 - okay so if we go back here and do port
378:30 - 8080
378:32 - there it is hello world and that's
378:34 - totally fine
378:35 - um because when it actually launches
378:37 - we've actually told it to start on port
378:39 - 4567 okay but by default it's starting
378:41 - on port 80 but notice when we did a curl
378:44 - we got hello world so it's really
378:45 - copying the contents of what was being
378:47 - served which is html right so it's just
378:49 - a plain text string called hello world
378:51 - so that means this is ready uh to turn
378:54 - into a docker image so docker actually
378:58 - comes pre-installed on amazon linux 2
379:01 - for cloud9 not amazon x2 itself but the
379:04 - version that is being used with cloud9
379:06 - and so i can just type in docker build
379:08 - hyphen t
379:10 - sinatra
379:12 - sample
379:14 - and i think that's how we specify the
379:16 - name i don't do this every day so
379:18 - yeah there we go and that would tag it
379:19 - so sinatra
379:21 - sample and we'll hit enter and that
379:23 - should create ourselves a docker image
379:25 - so it's just downloading
379:27 - stuff and building it
379:30 - okay this usually doesn't take too long
379:32 - because we're really not making so much
379:34 - here but once that is done we will be
379:36 - able to go and do like docker images so
379:39 - i'm just going to type docker images for
379:40 - the time being see what comes up and so
379:42 - notice that we already actually have
379:43 - some pre-installed like python node.js
379:45 - and stuff like that
379:47 - and
379:48 - this finished off so fail to register
379:50 - layer
379:51 - no space left on the device ah so we
379:53 - forgot to resize our drive so if we type
379:55 - in df
379:56 - um h hyphen h stands for human
379:59 - df is like disk something i can't
380:01 - remember what stands for df
380:03 - is for
380:04 - report file from system disk so i don't
380:07 - know the name i don't know what df
380:08 - stands for but it's going to tell us
380:10 - about the disk so if we type in df this
380:12 - shows mounted volume so this is where
380:13 - our storage is
380:15 - and one of these is our um our primary
380:19 - volume and so i can't make sense of this
380:21 - so what i always do
380:22 - is i type in hyphenates which means
380:24 - human show it in human display and so
380:26 - here we see 10 gigabytes and then we
380:28 - have 9.0 gigabytes used and this is all
380:32 - that's available so based on looking at
380:33 - this this is the biggest volume here we
380:35 - know that this came with like an 8
380:37 - gigabyte or 10 gigabyte drive volume and
380:40 - so this must be the one that we are
380:42 - using it's already filled up because
380:43 - docker can fill up
380:44 - drives pretty darn fast so what we'll
380:46 - need to do is make our way over to ec2
380:50 - okay if you're not there we'll just
380:51 - click on databus logo here at the top
380:53 - type in ec2 we'll go over here
380:56 - and we'll just close that and we'll look
380:57 - for instance if you expand the name we
380:59 - should be able to see it kate's cloud9
381:01 - that's the one there we'll checkbox it
381:02 - go over to storage drag up go over to
381:06 - the volume and we can see what size it
381:08 - is uh click into the volume again maybe
381:11 - and this has 10 gigabytes so that sounds
381:13 - right based on what we're looking at so
381:15 - this is where we're going to go ahead
381:16 - and modify this now if we were on the
381:18 - free tier video bus which we'd have to
381:20 - be using t2 micro which we totally can't
381:22 - uh there is a limit of like 30 gigabytes
381:24 - to stay in the free tier but we're
381:25 - already out of the free tiers so and
381:27 - we're not going to keep this around for
381:28 - long so it doesn't matter so just make
381:29 - it 40 gigabytes i know that um uh
381:33 - minicube said 20 gigabytes but four
381:34 - gigabytes because we're going to be
381:35 - running more than just
381:37 - um a mini cube on it okay so we'll go
381:39 - ahead and modify that and we'll click
381:41 - that
381:42 - now aws should automatically expand it
381:45 - sometimes you have to
381:47 - do some weird learning commands to do it
381:48 - or reboot the server but um elastic uh
381:51 - scaling should just happen like elastic
381:53 - uh volumes is something that works with
381:56 - uh supported images
381:58 - and so we're going to go here and just
382:00 - refresh until it's been modified i'm
382:02 - just watching it here this is probably
382:03 - the drive yeah here here's the new one
382:05 - 40 gigabytes
382:07 - and so i'm just waiting for it
382:10 - uh to do something so it's just
382:11 - optimizing i don't know if we have to
382:12 - wait for it to optimize
382:14 - but what i'm going to do is i'm going to
382:16 - go over back back over here i'm going to
382:18 - hit up
382:19 - and notice that it still says 10
382:20 - gigabytes
382:22 - so sometimes i'll do this and it will
382:24 - show up and sometimes it requires a
382:25 - reboot
382:27 - i'm not sure if it's because it has to
382:28 - finish optimizing
382:30 - and i don't know how long it's going to
382:31 - take to optimize so what we're going to
382:33 - do is we're going to go back over to ec2
382:35 - or instances and we're just going to to
382:38 - reboot it you don't want to terminate it
382:40 - that would lose all of our work we can
382:42 - stop this instance and we will not lose
382:44 - our work we can reboot this instance and
382:46 - we'll not lose our work but we'll go
382:47 - ahead and reboot
382:48 - sometimes reboot will take down cloud
382:50 - nine but if see how it's reconnecting
382:52 - but because reboots are so fast it
382:54 - should reconnect without us having to
382:56 - close this and reopen it okay so just
382:58 - give it a moment to do that
383:12 - we'll go back over here
383:14 - now if it still says reconnecting okay
383:16 - it reconnected we're fine okay so um
383:19 - sometimes if it takes too long i'll
383:20 - close it and reopen it i'm gonna close
383:22 - these things here and so now if we hit
383:25 - up
383:26 - we can see we're 40 gigabytes so we
383:27 - should be fine to
383:29 - go and build that docker image so we'll
383:31 - go ahead here and hit that again
383:33 - unable to prepare context unable to
383:35 - evaluate simulation docker file
383:37 - no such file or directory it's because
383:39 - we're not in the right directory when we
383:40 - restarted it put us back to the root
383:43 - folder there so we'll type that in and
383:45 - we'll hit up
383:47 - and we'll let it go again and so these
383:49 - were already downloaded so
383:51 - i guess it downloaded again but
383:52 - sometimes it doesn't have to download
383:54 - twice
383:55 - but we'll just give it a moment here
383:59 - so we'll just go over to here type in
384:00 - docker images
384:03 - notice that ruby's been downloaded says
384:05 - 2.7.4
384:07 - um
384:09 - maybe that was already there because
384:10 - ours is 3.1.0 up here did we save this
384:13 - file
384:14 - i'm not sure if we saved it
384:16 - so if it wasn't saved we'll just have to
384:18 - do this one more time
384:21 - yeah so i think that was the problem
384:23 - there so if i hit up docker images
384:25 - notice like the sizes are showing up
384:27 - here so
384:28 - we might not want to have this image um
384:30 - let's see docker
384:32 - remove uh ruby
384:36 - 2.7.4 i don't use docker on a regular
384:38 - basis but i'm just trying to
384:42 - remember how to do it
384:45 - there we go and so if i hit up here just
384:46 - because these are all taking up space
384:48 - right
384:49 - and so yeah 2.0 2.7.4 is gone and now
384:52 - there's a 3.10 we'll go back here this
384:55 - has been successfully tagged and so this
384:57 - docker image if we go back over here is
385:00 - right here right it's somewhere on the
385:01 - machine
385:02 - um but we need to actually now put this
385:04 - into some kind of repository so we can
385:06 - use it
385:07 - and um there are things like docker hub
385:10 - and other things like that but we're
385:12 - going to use aws's solution because it's
385:13 - very cost effective
385:15 - and we're already using aws so why not
385:17 - so i'm going to go back to aws
385:19 - amazon.com
385:20 - we'll sign in here so i just have
385:22 - another tab i'm already signed in but
385:24 - just how their home page works at the
385:25 - top here i'm going to type in ecr and so
385:27 - ecr stands for elastic container
385:29 - registry that's a place that is like
385:31 - it's like a git repository specifically
385:33 - for docker images we're going to go
385:35 - ahead and hit getting started we want
385:37 - this to be a public repository just to
385:39 - save us a lot of trouble we'll call this
385:41 - sinatra
385:43 - sinatra example
385:45 - and uh notice we can upload this stuff
385:47 - so we'll say this for linux now this
385:49 - will be public facing so people will
385:51 - know where this is
385:52 - generally don't share that out because
385:53 - you don't want to be paying for a
385:56 - traffic going out of aws because that's
385:58 - something eight of us will charge you
385:59 - for but for uh for our purposes no one's
386:02 - gonna know what our url is so it's
386:03 - totally fine
386:05 - and we're gonna go ahead and create
386:06 - ourselves a new repository
386:10 - and it creates it pretty quick almost
386:12 - instant and then we click into the
386:14 - sinatra example and up here we have the
386:16 - view push command so these are the
386:17 - things that we will have to run in order
386:19 - to push it now when we use cloud nine
386:21 - this already has our aws credentials
386:23 - built in if you're doing this on your
386:24 - own machine you'd have to install the
386:26 - aws cli and it's a big pain in the butt
386:29 - but with cloud9 it's already directly
386:30 - integrated with aws credentials so it's
386:33 - going to be super easy so i just copy
386:35 - this line here
386:37 - okay and what that does is it gets our
386:39 - login password and stores some
386:43 - information for ecr okay so go ahead and
386:46 - hit enter so it has stored credentials
386:48 - so notice here it says your password
386:50 - will be stored unencrypted in this
386:52 - config.json so it's storing temporary
386:54 - credentials here
386:56 - for us to use ecr i don't think they're
386:58 - long-lived i guess they're long-lived
386:59 - because they're living on the machine
387:00 - then we do our docker build that's what
387:02 - we already did
387:04 - and then here after the bill complete
387:05 - tag your image so you can push the
387:07 - repository so we copy that we go back
387:09 - here and paste it
387:12 - no such image sinatra example so maybe i
387:15 - did not spell it the same way here so if
387:17 - we go back
387:18 - and type docker images
387:22 - and we'll just scroll up here so is this
387:24 - spelt the same way
387:26 - that's all i can think of that's wrong
387:28 - sinatra
387:30 - example so sinatra sample
387:33 - oh okay
387:35 - so what i'm gonna do
387:36 - because that's a bit silly i'm gonna
387:38 - just go ahead and delete this one we'll
387:39 - say
387:40 - docker remove
387:42 - image
387:44 - sinatra sample
387:46 - or sorry it's image remove i think
387:52 - okay and we go back to docker images and
387:54 - we can see it's been removed and we'll
387:55 - go back over here and this time we'll do
387:58 - example
387:59 - and actually just to do a sanity check
388:01 - will actually just copy what's over here
388:03 - to save us some trouble
388:05 - okay
388:06 - we'll paste that in there
388:08 - and this will be a lot faster because it
388:09 - already has the ruby 3.10 image so built
388:11 - a lot faster we'll go back over here
388:13 - we'll hit up to docker images you can
388:15 - see that it's there with the proper name
388:17 - and we'll just hit up until we get back
388:19 - to this tag so we're going to tag it
388:21 - great and we'll go back over dcr and we
388:23 - will go grab our next line and this will
388:26 - push it
388:29 - all right and so what it's doing is it's
388:30 - actually pushing it over here
388:32 - so if we go back and refresh
388:34 - we're going to wait till it shows up
388:35 - here go back here and watch it as well
388:38 - it shouldn't take too long
388:42 - and it's pushing all i think the layers
388:44 - so like every each one of these lines
388:46 - runs as a layer so
388:48 - that's all the layers that it's pushing
388:49 - and there's obviously layers within
388:50 - layers when we look in the base image
388:52 - there as well but it's almost done you
388:54 - can see it's a little bit bigger than
388:56 - i'd like it to be but that's what it has
388:57 - to be
389:04 - and it's pushed so we go back here we
389:06 - give it a refresh
389:08 - there it is so it's 361 megabytes so
389:10 - it's a little bit big we click into this
389:12 - here nothing super exciting you know it
389:14 - just shows that that it's there but now
389:17 - we have our docker
389:19 - application
389:20 - that we are going to run in kubernetes
389:22 - okay so we can go we'll leave this tab
389:24 - open we'll go back here and uh we'll
389:26 - start
389:27 - installing mini cube
389:28 - [Music]
389:33 - all right so it's time to go set up mini
389:36 - cube so what we'll do is go over to the
389:38 - mini cube website if you just type in
389:39 - minicube and getting started it'll have
389:41 - all the instructions here just note that
389:43 - you choose the right operating system so
389:45 - we'll go over to linux
389:47 - x6x8664 is the type of architecture
389:50 - we're using
389:51 - notice there's binary debian rpm we're
389:53 - using amazon linux
389:55 - which is based off of centos
389:57 - but we don't have that option there so
389:59 - we're gonna have to do a binary download
390:01 - which is not a big deal
390:02 - and we can copy it over here on the left
390:04 - hand side i'm gonna do each line at a
390:06 - time because sometimes when you do
390:07 - multiple lines it just acts kind of
390:09 - funny doesn't matter what tab we'll go
390:11 - to the first tab maybe we'll just cd
390:12 - back here for a second so we're at our
390:14 - top level here and we'll go ahead and
390:16 - paste that on in here and hit enter
390:20 - okay and so that has been downloaded and
390:22 - then the next line is going to now it's
390:24 - now that's down with the binary we can
390:26 - see that it's right here but we need to
390:28 - i guess extract it out and then put it
390:29 - in a executable location so we'll go
390:32 - back over to here and notice this is
390:34 - sudo install and it's going to install
390:36 - it into user local bin which is where we
390:38 - always put things on linux when we're
390:40 - installing binaries and so now i should
390:43 - be able to type in minicube
390:45 - good and so you can see there's a bunch
390:46 - of commands here
390:48 - um you know you can pretty much follow
390:50 - through this but i i we're not going to
390:52 - do exactly this but i know all the
390:54 - commands now since i've done this a few
390:55 - times so let's say mini cube start and
390:57 - what that will do is it will start up a
391:00 - cluster for us it'll do all the work for
391:01 - us
391:02 - notice that it detected that we're
391:03 - running on amazon linux 2 so it's that
391:05 - smart that even knows about amazon linux
391:07 - distribution it's starting up a control
391:09 - plane it's pulling that base image
391:10 - notice we didn't have to specify it's
391:12 - going to probably be using docker as the
391:14 - driver uh normally that's something
391:16 - you'd have to specify is like the driver
391:17 - in the base image but we didn't have to
391:19 - deal with that we didn't have to install
391:20 - docker so we're saving us some trouble
391:22 - but this would have been the base image
391:23 - that we would have specified as like a
391:25 - flag to it
391:27 - it does take a little bit of time to
391:29 - start up but it's not a big deal things
391:31 - that are really nice about mini cube is
391:32 - that you can actually use it to run not
391:34 - just a single cluster but multiple
391:35 - clusters so if you wander around more
391:38 - than uh one
391:39 - kubernetes cluster you just have to
391:41 - specify a different port number okay
391:44 - so i'll give that a moment to start here
391:47 - and this is taking a tiny bit of time
391:49 - it's not going to take forever but we'll
391:50 - give it a little bit of time here
392:01 - great and it's done so here it says cube
392:03 - ctl not found if you need it try mini
392:05 - cube
392:06 - cube ctl so cube ctl is what we use to
392:10 - interact with kubernetes um it's a cli
392:14 - interface and so you can install it
392:16 - independently i've been finding that
392:18 - it's been causing some troubles in some
392:20 - cases so i don't always install it but
392:22 - we can try to install it but i'll just
392:24 - show you here the fact that if you run
392:25 - mini cube ctl it will install it within
392:28 - the context of mini cube so we can type
392:30 - in mini cube cube ctl and do hyphen
392:32 - hyphen get pods
392:35 - okay
392:36 - notice that it's installing cube ctl for
392:38 - us but it'll always only work when we
392:40 - type in municube ctl we have no pods
392:42 - running if we do hyphen a
392:44 - it shows all possible pods so
392:46 - technically there are pods running
392:48 - because we have cube system namespace
392:50 - where we're running things like core dns
392:53 - at
392:54 - etsy or etcd
392:56 - api server control manager the q proxy
392:59 - the scheduler storage provisioner if you
393:01 - don't know them now don't worry
393:02 - throughout this course we're going to
393:03 - learn about all these components so if
393:05 - you come back into this tutorial uh
393:07 - later on it'll it'll totally make sense
393:10 - but anyway um so this is running and we
393:12 - can see all of them there it might be
393:14 - kind of a pain to keep on running mini
393:16 - cube cube ctl so i suppose we can try to
393:18 - install it so we'll type in cube ctl
393:20 - install
393:23 - and we'll see if we can just quickly
393:25 - install if we can't it's totally fine
393:26 - we'll just kind of
393:29 - dial that back there but it says
393:30 - download the latest
393:32 - binary here so we'll go here
393:35 - and it really depends on the version
393:37 - that you're using so this is stable and
393:38 - i'm hoping that it's the same version i
393:40 - don't know how to minicube how to check
393:41 - what version of kubernetes we're using
393:43 - if we scroll up maybe we might see it
393:45 - somewhere here
393:46 - so i have no idea what version is i'm
393:48 - going to assume that it's using the
393:49 - latest and we're just going to luck out
393:50 - and have both here if it doesn't you can
393:52 - always uh fall back to that mini cube
393:54 - qpctl so if i do ls here's cube ctl so
393:57 - it's a binary and so
394:00 - and i'm just going to make sure that we
394:01 - did it for the right environment so
394:03 - yeah linux okay
394:05 - we go back here we need to make it
394:06 - executable so we type in chamod chamod i
394:09 - can't remember what it stands for man
394:11 - chamod here it is change file mode bits
394:15 - okay because just because you download
394:16 - file doesn't mean that you can start
394:17 - using it you have to
394:19 - say that it's allowed to be executable
394:21 - so it's safe to use so use in the
394:23 - context of user a plus x is for it to be
394:26 - executable
394:27 - um as far as how i remembered anyway and
394:30 - we'll hit enter and so now uh it should
394:32 - be executable so if we type in um is it
394:36 - shown i just can't remember now
394:38 - oh yeah sorry it's just lsif and la if
394:40 - we type in ls hyphen la
394:42 - notice here that
394:44 - there's these things here and whether
394:45 - it's sex cable or not will
394:47 - flip i thought it was just yeah it's the
394:49 - x over here because there's three
394:50 - different user groups there's everybody
394:52 - there is um a particular user or
394:54 - something that's broken up into three
394:56 - that if you see that but the x's here
394:58 - mean that it is executable but we don't
395:00 - want to leave it here because then we'd
395:01 - have to always type this like cubectl
395:03 - pods
395:04 - which is kind of annoying like this
395:06 - because we can't just do this
395:08 - right so what we'll do is we'll move it
395:10 - into our use your local bin directory
395:12 - which is the standard place of putting
395:14 - things we'll need sudo because you need
395:16 - you need pseudo permissions in order to
395:17 - move cubes like a binary into that
395:19 - directory
395:21 - so we'll type in uh cube or sorry move
395:24 - sudo move cube ctl
395:26 - user local bin okay and now if we type
395:29 - cube ctl
395:30 - it's everywhere okay so that's going to
395:32 - make things easier for us
395:34 - so now we don't have to do that whole
395:36 - mini cube
395:38 - uh hyphen hyphen thing which is kind of
395:39 - annoying okay um but anyway we'll just
395:42 - clear that out there and we'll type in
395:44 - cube ctl get pods as you can see there
395:47 - are no pods running so that's what we
395:48 - want to do we want to deploy
395:50 - that and so sinatra is kind of like a
395:52 - ruby on rails app so i'm just going to
395:53 - go to google and we're going to type in
395:55 - ruby on rails uh kubernetes
395:58 - tutorial and i think honey badger has an
396:01 - okay one and they make it complicated
396:03 - because they have like all these
396:05 - different kinds of files so they have
396:07 - um
396:09 - like they show you how to start the
396:10 - cluster and they have a config map and a
396:12 - migrate job we just want to deploy it so
396:14 - what i'll do is i'll copy the deployment
396:16 - file they have here and by the way
396:18 - everything i'm doing here will end up in
396:19 - a repository anyway so at some point i
396:21 - will point us to that i'm just doing it
396:23 - on the fly here so bear with me here and
396:26 - so we have that deployment file and i
396:28 - want to just put it somewhere so i'll
396:30 - make a new folder here
396:32 - um i'll call this one
396:35 - k8s
396:37 - i mean you can call it whatever you want
396:38 - doesn't really matter
396:40 - new file and just say deployments
396:44 - the reason i'm getting confused is
396:45 - because normally i would call it app but
396:46 - i made that for the actual app itself
396:48 - and so this is for the kubernetes files
396:51 - but we'll go in here we'll paste that in
396:53 - and there's a bunch of stuff in here so
396:55 - if we go to the top here
396:56 - specifies api version and this is for a
396:58 - deployment now we could call this a pod
397:01 - right but generally in kubernetes you
397:02 - don't deploy pods directly which we will
397:05 - do in this course to show you but you
397:07 - always do deployment so that it can set
397:08 - up pods for you so you have an
397:11 - additional layer of stuff and then you
397:13 - will have a bunch of metadata so it's
397:15 - not you don't have to have this metadata
397:18 - but generally kubernetes recommends like
397:20 - they have recommended labels so if we go
397:21 - recommended labels for kubernetes they
397:25 - have a bunch here and they're actually
397:26 - supposed to have all of these here right
397:28 - like this insane amount here but um
397:31 - for our purposes we'll leave the name in
397:33 - because we will need some kind of label
397:34 - to do selection we'll delete out the
397:36 - process one because we don't need that
397:38 - we're gonna just call this sinatra
397:41 - sinatra
397:44 - sinatra
397:46 - and then we need the name of the actual
397:47 - deployment so the name of the deployment
397:49 - will be sinatra
397:51 - okay so you could do this to make a
397:52 - little bit clearer
397:54 - and um this should be sinatra as well
397:58 - and then we have our docker image which
398:00 - we'll talk about here in a moment so the
398:01 - idea here is that you have
398:03 - a deployment it's called sinatra we're
398:05 - going to provide a label as recommended
398:07 - by kubernetes so that if we need to
398:08 - select things or
398:10 - isolate or group things based on labels
398:12 - we have that then we define our spec so
398:14 - that's
398:15 - spec is specifically for pod spec files
398:17 - so we're specifying the template for our
398:19 - prospect file we have a selector so
398:22 - selectors are required in order for this
398:24 - to work because we have a deployment we
398:26 - need to select
398:28 - the correct um
398:31 - template and so this is a bit redundant
398:32 - but you have to have it i think it's
398:34 - like selecting from here to here
398:36 - we talk about selectors in the course so
398:38 - don't worry about it too much but the
398:39 - idea is we will need that
398:41 - then spec is actually where we define
398:42 - our containers
398:44 - we only have one container defined this
398:45 - one wants to run on port
398:47 - 3000 which is the default port for ruby
398:49 - ruby on rails or changes to 4567 because
398:52 - that's what we decided to make ours
398:54 - uh this is for config map we're not
398:56 - using config map that is for
398:58 - configuration uh environment variables
399:00 - we need our image and so for our image
399:02 - we'll go back to ecr and we're just
399:04 - going to grab the image uri so it takes
399:05 - basically these kind of urls here we can
399:08 - paste that in and we'll take that you
399:09 - can use that for docker hub or all other
399:11 - kinds of ones this one it's public so we
399:13 - don't have to worry about trying to
399:15 - authenticate to a private repository i
399:16 - don't even know how to do this i've done
399:18 - it before but i don't remember off the
399:19 - top of my head but i'm sure it's a pain
399:21 - in the butt so we'll skip that we have
399:22 - this image pull policy so image pull
399:25 - policy means
399:26 - every time this pod is deployed or do
399:29 - you pull the image every single time or
399:31 - only if we never have deployed it before
399:34 - pull it once i'm going to set it to
399:35 - always just because
399:37 - just in case we have to change it it's
399:40 - just going to make it a pain if we have
399:42 - if not present okay then we have our
399:44 - name here we'll call this sinatra
399:46 - okay
399:48 - and then we have our ports so container
399:50 - port is going to be
399:51 - port 4567 because again we said that
399:53 - that's what we're running it on and then
399:55 - we have a readiness probe so we'll learn
399:57 - about readiness probes within the course
399:58 - but readiness probe just says like
400:01 - it determines whether this is running or
400:03 - not so if for whatever reason
400:06 - our
400:06 - our application decides to not run
400:10 - like it's broken or something and the
400:11 - radius probe can't reach it so it's
400:13 - sending out a um an http request to this
400:16 - path and it doesn't return it a status
400:18 - 200 then it will fail okay so we'll do
400:21 - four five six seven we could not have
400:23 - radius pro but i'd like to have them in
400:25 - there so we'll leave them in there just
400:27 - because it was already there for us and
400:29 - so we have our first deployment yaml
400:31 - file okay super exciting again don't
400:34 - worry if you don't remember all the
400:35 - stuff even for this uh course it might
400:37 - be or sorry for the certification course
400:38 - the kcna it might be a bit overkill but
400:41 - you know the more we do the better the
400:43 - better we'll be prepared okay
400:45 - so
400:46 - now that we have our deployment file we
400:47 - are ready to do a deployment so we'll do
400:49 - cube ctl apply hyphen f
400:51 - and it doesn't matter if this is a
400:53 - deployment file a config set file or
400:56 - anything you're always going to do this
400:57 - apply hyphen f thing like apply and
400:59 - specify the file because kubernetes just
401:01 - has one way of of setting up stuff and
401:04 - it's always through this way here so
401:06 - we'll do app deployment
401:09 - oh sorry it's kate's right k8's
401:11 - deployment here
401:13 - we'll hit enter and here it says the
401:14 - deployment sinatra is invalid spec
401:16 - template yaml invalid selector does not
401:19 - match the template labels and this has
401:20 - happened to me before so
401:22 - let's just quickly carefully look at
401:24 - what's going on here
401:26 - um
401:30 - how did i fix this last time so the
401:32 - deployment sinatra is invalid
401:34 - spec template labels
401:37 - spec template metadata labels so spec
401:40 - template
401:42 - metadata
401:45 - labels
401:48 - hmm
401:50 - i don't see the problem here
401:55 - because spec
401:58 - template
402:00 - ah metadata
402:03 - labels invalid value map string
402:06 - kubernetes so it's saying this is
402:07 - invalid
402:10 - okay um what if we just delete it and
402:12 - see what happens okay i don't remember
402:14 - if i needed it or not
402:17 - spec template metadata labels all right
402:19 - so i can't remember what's wrong with it
402:21 - but the great thing is i already have a
402:22 - repository for this because i already
402:24 - done this ahead of time and so i'm going
402:26 - to go pull up our example repository
402:29 - this will be the repository that i will
402:30 - share for the course but it is just one
402:32 - i created temporarily as i was going
402:35 - through this so i'm just typing off on
402:36 - the side here to get to it okay
402:43 - and
402:45 - so it is this one here it's basically
402:47 - the same app
402:48 - um
402:50 - actually no it's not here so one second
402:52 - i got it on my other computer so i'm
402:53 - going to pull up my other computer and
402:55 - i'm going to just quickly take a look at
402:56 - what the difference is
402:59 - because i can't even tell here
403:07 - okay
403:08 - so i'm just going to look here
403:11 - starting at the top here this is fine
403:15 - and then under spec selector it has this
403:17 - so this is fine oh it's a spelling
403:19 - mistake and you're probably staring at
403:20 - this the entire time being like hey
403:22 - andrew you have an obvious spelling
403:24 - mistake i'm dyslexic i'm very sorry i
403:26 - cannot notice those mistakes so we'll go
403:28 - there but it was clear it says saying
403:29 - spect template metadata labels and
403:31 - clearly that was the problem there so
403:32 - we'll go ahead and hit enter and it says
403:35 - that it's created so what we can do now
403:37 - if we want to see this
403:38 - is type in cube ctl get deployments
403:43 - okay
403:44 - once you start using a little bit of ctl
403:46 - it's very very easy to use and we do
403:48 - cover in the course how this the the
403:50 - patterns to ctl but it's like if you
403:51 - want to know pods you type in get pods
403:53 - right it's very straightforward so here
403:55 - we can see we have a deployment says
403:56 - zero out of one is ready we'll go back
403:58 - to pods and we'll say that it is running
404:00 - it says zero to one that it's ready um i
404:02 - don't know if we can do probes we could
404:04 - try probes
404:06 - probe
404:07 - see i i don't know i just i was just
404:09 - trying there um
404:11 - but what we'll do is we'll type in
404:12 - deployment and we're just waiting for
404:14 - the probe to determine that it is
404:15 - working so now it says one out of one so
404:17 - it definitely is working and remember
404:19 - that is running on port
404:21 - um
404:22 - uh four five six seven now i don't know
404:24 - how to look up the ports here but i do
404:25 - know um that we can try to just kind of
404:28 - like ping it there so what we'll do
404:30 - is type in um
404:32 - curl
404:33 - localhost 8080 or sorry 4567 and we'll
404:37 - see if we can reach it okay
404:40 - okay so it says failed to connect to the
404:42 - port
404:43 - all right and that's totally fine
404:44 - because
404:46 - just because we set up a pod doesn't
404:48 - mean that the pod is immediately
404:50 - available in order to access that we
404:52 - need some kind of service okay so that's
404:54 - what we're gonna have to do next um
404:57 - or we might be able to just do port
404:58 - forwarding but we'll figure that out a
404:59 - moment i'll be back in a second okay
405:02 - okay i'm back so
405:04 - all right it was what i thought it was
405:05 - but what we were doing was we were doing
405:07 - port forwarding so when you have a pod
405:09 - running kubernetes you uh by default it
405:12 - is not available like it's uh externally
405:15 - uh the pod has a dynamic ip address and
405:18 - so normally what you'll do is you will
405:19 - attach a service to expose the pod or
405:22 - have a way of getting to the pod right
405:24 - so there's no port and
405:26 - load balancer and
405:28 - things like that but a very easy way
405:30 - without even having to use a service is
405:33 - to just use uh port forwarding so
405:35 - there's a command if you type in cube
405:37 - ctl and we type in hyphen hyphen port
405:40 - forward or sorry not we don't need the
405:41 - hyphen hyphen that was when we're doing
405:42 - minicube so we type in port forward and
405:44 - then we can specify that we want this
405:46 - deployment called sinatra
405:49 - um which is our deployment file yeah
405:51 - it's called that there here
405:52 - and what we can do is say forward port
405:56 - um i'm just trying to think like usually
405:58 - port 8080 is what you have to use cloud9
406:00 - if you want to expose it to the internet
406:01 - so do 8080 and we'll say 4567
406:04 - and we'll do address space
406:07 - 0.0.0.0 you have to bind to 0.0.0.0
406:10 - or we can't see it outside of
406:13 - this cloud9 environment like into the
406:15 - web browser so hit enter and so that is
406:17 - forwarding for forwarding um that port
406:20 - okay i know it looks backwards because
406:22 - you'd think like four five six seven
406:24 - would point to eight zero eight zero but
406:26 - that's just
406:27 - how they showed okay
406:29 - so now what we can do is go back over
406:30 - here and if we do a curl
406:34 - uh we'll just say localhost 8080.
406:37 - now that's saying hello world i think if
406:38 - we do um
406:40 - hyphen l it might show us more
406:42 - information nope okay i was trying to
406:43 - see if we can see like html as well but
406:45 - i guess it really is just text but let's
406:47 - say we want to see this in our web
406:49 - browser so for cloud nine
406:51 - um
406:52 - we need to expose port 8080 so
406:55 - because by default the security group is
406:56 - not open on the ec2 instance so we go
406:58 - back to our ec2 again if you don't know
406:59 - where that is type in ec2 at the top
407:01 - here is that cloud9 environment we're
407:03 - going to go over to security
407:06 - inbound rules and this is all that we
407:07 - have is we can s or sshn which is not
407:10 - very useful so what we'll do is click
407:14 - onto the security group
407:16 - and we're going to go ahead and edit the
407:18 - inbound rules
407:20 - we're going to add a new rule and this
407:22 - is going to open on port 8080. now
407:23 - cloud9 can only run on like in the open
407:26 - on port 8080 and 8081 so we couldn't
407:29 - make this 4567 if we wanted to or 8 000
407:32 - okay
407:33 - so here i'm just going to say my ip so
407:35 - the idea is that only this computer that
407:37 - i'm on right now can access this that's
407:39 - a very secure way of doing that and just
407:41 - say andrew's computer
407:43 - for some reason you can't put hyphens in
407:45 - here and exclamation marks but we'll hit
407:47 - save that rule and so now that port is
407:49 - open
407:50 - so we can do is go back to ec2 however
407:53 - you want to get there click on instances
407:55 - and what we need is the a public ip
407:56 - address of this so we go to the
407:58 - networking tab and there's that public
407:59 - ip address
408:01 - and we'll go to the top here
408:03 - we'll paste it in here and we'll do
408:04 - 8080. and so there it is it's exposed to
408:07 - the internet now this is obviously not
408:08 - what you do in production but this is
408:10 - just a very easy way uh to do that so we
408:14 - didn't cover services which is fine
408:15 - we'll cover that later because right now
408:17 - we're just focused on learning how to
408:19 - use
408:20 - uh you know uh like launching a cluster
408:22 - and stuff like that there's one other
408:23 - thing i want to show you with minicube
408:26 - and um that is the ability to run a
408:28 - dashboard okay so um there's a thing in
408:31 - kubernetes called the kubernetes
408:32 - dashboard
408:34 - kubernetes dashboard okay
408:36 - and it's like a plug-in i'm just trying
408:38 - to find it here
408:40 - okay see this and it's not specific to
408:42 - minicube it's just it can run as a pod
408:45 - and then you can access this and it's
408:47 - just kind of like a nice way a visual
408:48 - way of seeing the stuff that is running
408:50 - in your kubernetes cluster and so uh you
408:54 - know we have figured out how to do that
408:55 - it was quite the pain
408:57 - to figure out how to get this exposed um
409:00 - on um
409:02 - cloud9 but i do
409:03 - know how to do it so the first thing we
409:06 - need to do is we need to stop our
409:08 - cluster
409:09 - okay
409:10 - so i'm going to type in
409:12 - cubectl or sorry minicube
409:15 - stop because we need to start this and
409:18 - make sure that it's listening on 0.0.0.0
409:21 - remember i told you if you're not
409:22 - listening on that things can't reach
409:24 - outside cloud9 it's just it's a very
409:26 - common um thing that you need to do is
409:28 - bind on port zero zero zero even when
409:29 - you're deploying a real world web
409:31 - application you have to do that so what
409:33 - we'll do is type in mini cube start
409:35 - hyphen hyphen listen
409:38 - address
409:39 - and then here we're going to do equals
409:42 - 0.0.0 if you're running like how do i
409:44 - know all these commands i just go and
409:45 - type in mini cube
409:48 - mini cube start commands and then here
409:51 - this is how we figured it out we just
409:52 - went here into the docs
409:55 - nope that's not it
409:57 - maybe it's this one here here it is and
409:59 - it just tells you what all these flags
410:00 - did so we went through this and said
410:02 - there must be some way to bind right and
410:04 - so that's how we found out that you
410:05 - could do the bind that way okay so what
410:08 - we'll do is we'll go ahead and hit enter
410:10 - and so that will make it so that
410:12 - our um that we're binding on there
410:15 - notice that is restarting everything
410:17 - pulling the image i don't i think that
410:18 - since we stopped our cluster our
410:20 - deployment might be gone so we'll have
410:21 - to wait for that to start there
410:24 - but once that starts we'll have to also
410:26 - set up a proxy a kubernetes proxy so
410:30 - and make sure that that address is also
410:34 - on 0.0.0 and then also disable filtering
410:37 - because there's just so many
410:37 - preventative measures and proxima that
410:39 - we have to do so it is running i believe
410:42 - so we'll type in cube
410:44 - cube ctl
410:46 - get pods
410:47 - okay notice that our our app is gone
410:49 - which is totally fine
410:51 - so what i want to do now is i want to
410:53 - start up
410:55 - a proxy so i'll type in cubectl
410:57 - proxy oops
411:01 - address equals
411:03 - 0.0.0.0
411:05 - and then we'll disable the filter
411:09 - we'll say true all right and so that's
411:11 - going to start up a proxy and it's going
411:13 - to allow us to be able to um get things
411:16 - out of the cluster all right because if
411:18 - we don't do that we're not going to be
411:20 - able to do much there
411:21 - and so now what we can do is we should
411:23 - be able to start in another tab um the
411:27 - dashboard so we type in minicube
411:29 - dashboard url and by the way like if you
411:31 - already had a regular kubernetes cluster
411:33 - you'd have to install it but this is
411:35 - just like a shortcut that currently does
411:36 - for you i'm doing i've been having url
411:38 - because if i don't it would try to open
411:40 - it up in the browser right away which it
411:41 - can't do from cloud9 so we just want the
411:43 - url
411:44 - and so here it's going to
411:46 - export expose that address and so we
411:49 - have this address and it's really funny
411:50 - looking which is totally fine
411:52 - um i think actually we can open up port
411:54 - 8001
411:56 - 8 000 i think again in the 8000 range we
411:59 - can open up on cloud9 so what i'm going
412:01 - to do is go back to
412:03 - ec2
412:05 - uh we actually already have a tab open
412:06 - here so i'll use that one here and i
412:08 - want to go back to our security groups
412:12 - and i'm going to edit inbound rules i'm
412:14 - going to add a new one here and it's
412:16 - going to be for 8001 and this is for um
412:21 - technically this is the web app
412:24 - uh
412:25 - sinatra app might make more sense i
412:27 - wrote andrew because sometimes when
412:28 - you're working with multiple people
412:30 - you're running what this ip address is
412:31 - for right
412:32 - and then this one is going to be for k8
412:34 - dashboard
412:39 - we'll save that rule there
412:41 - and so i think
412:42 - what we can do here
412:44 - is copy this
412:47 - go up here change this to eight zero
412:49 - zero one assuming that's what uh we
412:51 - specified everywhere else i think that's
412:52 - what everything defaulted to place that
412:54 - in there fingers crossed and there it is
412:57 - don't explain to me like don't ask me
412:58 - like how these ports and all these
412:59 - things work i'm not very good at
413:01 - networking i know enough uh to get
413:02 - around but
413:04 - i just have the instructions that we
413:05 - figured out that works but here we can
413:07 - see all of our stuff so we go to cron
413:08 - jobs and stuff
413:10 - or pause and see what is working and
413:12 - what is not so what i'm going to do now
413:13 - is go back to this environment here
413:16 - and this tab is taken up and this tab is
413:19 - taken up so we'll go here and make a new
413:20 - terminal tab
413:21 - and here we'll type in cube ctl and
413:24 - we're going to deploy our app again okay
413:27 - so we'll say deployment yaml and we'll
413:30 - go ahead and create that
413:32 - and what we can do is go back to our
413:33 - dashboard here and look we have a pod we
413:35 - have a deployment
413:37 - one out of one it started really fast
413:40 - okay so this is kind of nice as a visual
413:42 - we can click into it
413:43 - we can get some some kind of data with
413:45 - here which is really nice okay
413:48 - and so with that running now um
413:52 - it should oh we don't have port
413:54 - forwarding so if we went back to this
413:56 - here right
413:59 - okay and we tried 80 uh 8080.
414:02 - okay we're not going to see anything so
414:03 - we'd have to go back and forward that
414:05 - port so we'll go ahead and make a new
414:06 - terminal tab
414:08 - cube ctl
414:10 - port
414:11 - forward i'm trying to do based on my
414:12 - memory here
414:13 - um address actually would be we have to
414:16 - specify it so deployments
414:18 - sinatra
414:21 - and
414:22 - it would be
414:24 - addressed
414:26 - uh 0.0.0.0
414:29 - and then it's
414:30 - 80
414:31 - 80 to 4567
414:36 - okay um we'll just hit up till we get
414:38 - the right command
414:40 - so what did i get wrong cubectl port i
414:43 - forgot the r i always forget that and
414:45 - the flag is over here i don't think it
414:47 - really matters what side it's on we'll
414:48 - hit enter we'll go back over here
414:50 - and there we go so that is minicube okay
414:54 - so nothing super complicated there and
414:57 - what i'll do is i'll go back here and we
414:59 - will just stop this
415:01 - and we'll type in cube ctl
415:03 - i don't know if it's still running let's
415:04 - go back here is it still running
415:07 - does that stop the do that stop it
415:09 - cube ctl
415:11 - get pods
415:13 - okay so it still is running so we'll
415:14 - type in mini cube
415:16 - stop
415:18 - and i'll power that down there
415:20 - just stop these other tabs here we'll
415:21 - close them for now close
415:23 - and we'll close and we will close
415:28 - okay
415:30 - and so that's mini cube and so we'll
415:32 - move on to
415:33 - uh doing kind next okay
415:35 - [Music]
415:41 - all right welcome back and so this time
415:43 - we're going to go ahead and use kind so
415:45 - kind seems very similar uh to
415:48 - mini cube so it'll just be up to you
415:50 - what you decide that you want to use for
415:51 - your local development
415:53 - but what i'll do is just to make things
415:54 - a little bit easier i'll just close some
415:56 - of the tabs we have here
415:57 - let's just do a little bit of cleanup
415:59 - here
416:00 - i don't need a mini cube open up here
416:01 - and so we'll take a look at kind then
416:04 - we'll close some of these tabs here
416:06 - so kind as a tool for running local
416:07 - kubernetes clusters using docker
416:09 - container nodes primary design for
416:11 - testing kubernetes itself but may be
416:13 - used for local development and ci a lot
416:15 - of people like it because it's like a
416:16 - lighter version of mini cube and can be
416:18 - very very fast though a mini cube can be
416:21 - very robust and useful in a lot of cases
416:23 - it just depends on what you need and how
416:25 - small you want to go here so
416:28 - to install it we'll go over to the user
416:30 - guide here
416:32 - and i believe the way i installed it was
416:35 - from a binary but we'll go to
416:36 - installation here we'll take a look here
416:38 - so notice we'll see package managers
416:40 - like brew that's for mac os choco
416:43 - which chocolate which is like brew but
416:45 - for windows mac ports which is an
416:46 - alternative and then for linux it's just
416:49 - going to have to be a binary which is
416:50 - not a big deal so we'll be copying these
416:53 - lines here so we'll go back over to
416:54 - cloud nine here uh oops i forgot to copy
416:56 - the lines here but we'll go and copy one
416:58 - at a time so we'll first curl
417:00 - and make sure we're in the environment
417:02 - directory there you might have to cd
417:04 - back there to do that and just type
417:05 - clear again
417:06 - we're having some funny business where
417:08 - it's just showing that top line there we
417:09 - go
417:12 - which is fine i guess
417:14 - uh but we'll paste that in there
417:16 - and we'll go back to the quick start and
417:19 - we'll do chamond notices plus x you
417:21 - could do u u plus x that's just what i'm
417:23 - used to doing but it doesn't really
417:25 - matter and then notice it's going to say
417:27 - some kind of directory but the directory
417:29 - we want that to be in is going to be the
417:31 - user local bin so we'll go here
417:33 - and we'll type in user local bin
417:37 - and this is not going to work unless
417:42 - we do this okay
417:44 - and so i should be able to type kind and
417:46 - there it is okay
417:47 - and so now that it is installed we'll go
417:49 - back to
417:51 - quick start
417:52 - and we need to create our cluster so
417:54 - creating our cluster is very
417:55 - straightforward it should be a concrete
417:57 - cluster we can even name our cluster if
417:59 - we want but we'll just go ahead and do
418:01 - that so we'll say
418:02 - kind create cluster
418:07 - and we'll give it a moment there and it
418:08 - should start up a cluster now remember
418:10 - we have cube ctl already installed so it
418:12 - should be pretty easy but i think if we
418:13 - didn't we could probably do kind cube
418:15 - ctl as well
418:17 - um but anyway this is supposed to be
418:19 - faster than minicube um
418:21 - and we'll give it a moment here it's not
418:23 - feeling much faster but when i was using
418:24 - it before i felt it it felt really
418:26 - blazing fast but i'm not sure what's
418:28 - going on
418:33 - it is taking some time to create that
418:35 - control plane which is totally fine
418:37 - um oh there we go so installing c c and
418:39 - i storage class things like that so set
418:41 - cube ctl context to kind kind
418:44 - um oh it did okay so you can now use the
418:46 - cluster within here so cube cluster info
418:49 - to get some information so we'll do that
418:53 - so it says kubernetes control plane is
418:55 - running here core dns is running here
418:58 - to further debug and diagnose cluster
419:00 - problems use cube ctl cluster info dump
419:03 - so if we type in cube ctl and we were to
419:06 - type in um
419:09 - get pods we can see there's no pods we
419:11 - could do hyphen a notice that it has
419:14 - looks like a different amount of pods so
419:15 - we have core dns and then we have
419:18 - maybe this is a proxy i'm not sure here
419:20 - uh we have a control plane running uh we
419:22 - have kind net we have api server control
419:25 - manager proxy scheduler path provisioner
419:28 - local path provisioner not sure what
419:29 - that is although i guess oh storage path
419:31 - okay and so you know you can just see
419:33 - like it's not one to one with mini cube
419:35 - right so there's going to be a different
419:36 - amount of pods doing uh slightly
419:38 - different things
419:40 - but now that we have it let's just go
419:41 - ahead and deploy our application like we
419:43 - did before so what we'll do
419:46 - is we'll type in um
419:49 - cube ctl
419:51 - and that's in our k directory so we'll
419:53 - say k uh oops apply hyphen f
419:56 - k8
419:58 - deployment right and so that should go
420:00 - ahead and deploy that and
420:03 - now if we want to see that we can type
420:04 - in cube ctl
420:07 - get deployment
420:09 - and if a deployment ever messes up what
420:11 - you can do is you can type in describe
420:14 - you can get more detailed information
420:15 - and you can type in something like
420:16 - sinatra works with pods works with
420:17 - everything and sometimes you get a lot
420:19 - more information so here we'll be saying
420:20 - like scaled up the replica it'll say
420:22 - what it's up to and a lot of additional
420:24 - information so if you ever have a
420:25 - failure always try to describe to help
420:27 - yourself out but we'll say deployment
420:29 - and we're just waiting for it to get
420:30 - ready and it is now ready um so that is
420:33 - started if we do a curl localhost 8080
420:37 - um notice there's a connection refused
420:38 - so there's has to be some way for us to
420:40 - access that
420:42 - um i'm to remember cube ctl is a
420:45 - command that yeah it's not specific to
420:47 - uh to kind or mini cube so we can
420:48 - probably do that as well so we'll type
420:49 - in cube ctl
420:51 - port forward
420:52 - don't forget the r there i always forget
420:54 - it deployment
420:56 - sinatra 8080 4567 because that's what it
421:00 - actually runs on and then we'll have to
421:01 - bind it to
421:02 - uh zero zero zero so zero zero zero zero
421:06 - enter
421:08 - and so now
421:09 - if that's all set up we should be able
421:11 - to open a new tab here
421:13 - terminal
421:14 - and we'll type in curl local host
421:17 - 8080 andrew brown there we go
421:21 - i never tried to set up kind for a
421:24 - dashboard so i'm not even sure how to do
421:25 - it we solved it for mini cube and it was
421:27 - really hard to solve just because we're
421:29 - running it in a virtual machine to
421:30 - expose it
421:32 - um so i'm not sure if we need to do
421:34 - anything beyond that but that's just
421:35 - kind there so it's not super difficult
421:37 - i'm going to take a look here to see if
421:38 - i can figure out the dashboard i'll be
421:39 - back in a second okay
421:41 - all right so i looked it up and it
421:42 - actually is a bit involved so mini cube
421:44 - definitely makes it super easy but like
421:46 - here it's just a medium article where
421:47 - they go through that process and so they
421:49 - say okay we create a kind cluster then
421:53 - we are going to use helm helm is a way
421:54 - of packaging uh applications together so
421:56 - that could make our life a lot easier if
421:58 - we tried to use helm
422:00 - but that's a little bit farther in the
422:01 - course i don't know if i really want to
422:02 - dig into that but the idea is that you
422:04 - would add a repository like this github
422:06 - dashboard so kubernetes github is a
422:09 - repository like the dashboard is if we
422:11 - go like kubernetes dashboard
422:14 - dashboard git hub
422:17 - it should probably have one here so it's
422:19 - pointing to this basically
422:21 - right and in here there probably is a
422:24 - helm package somewhere here
422:27 - and but anyway so the idea is that you
422:29 - do that and you do helm install
422:30 - dashboard kubernetes dashboard
422:32 - kubernetes dashboard
422:33 - so it looks like we it also creates a
422:35 - new name space
422:37 - and then you'd have to set up a proxy
422:38 - and we had a proxy before
422:40 - and then you'd have this
422:41 - link and then you'd have to authenticate
422:43 - because you can't just
422:45 - log in you have to have a token or
422:47 - something and so then to log in the
422:48 - dashboard they're creating um a service
422:51 - account so that's like a type of role
422:53 - like permissions that's rbac
422:56 - and i would imagine that i mean they
422:58 - didn't activate it but they might have
422:59 - to activate rbac so you can see it gets
423:01 - really really involved right so i think
423:03 - that um i mean this would be good to do
423:06 - but maybe not right now because it's
423:08 - very complicated this is more like ckad
423:10 - or cka kind of material but i just
423:14 - wanted to show you uh the effort would
423:16 - be to go get that there so maybe that's
423:18 - one advantage of using mini cube and
423:20 - probably will stick to using mini cube
423:22 - but for kind we pretty much did what we
423:24 - wanted to do with it just to see that we
423:26 - can install and it was easy to use so
423:28 - i'm going to type in kind delete cluster
423:30 - i think that's probably what it is i'm
423:32 - just guessing and it still works that's
423:34 - great and so kind to solve the last one
423:36 - i want to do
423:37 - is micro k8s okay so that's what we'll
423:39 - do next okay
423:41 - [Music]
423:45 - all right so we're going to take a look
423:46 - at how to uh run micro k8s and i found
423:50 - this one
423:51 - like it was very fast i like how it's
423:53 - modular but i found it the hardest one
423:54 - to use to be honest i mean they're all
423:56 - generally pretty easy but the complexity
423:58 - comes because we're running in a virtual
424:01 - machine like a developer cloud developer
424:02 - environment in the cloud so there's
424:04 - additional stuff that you have to
424:05 - consider um and so
424:08 - you know if we want to install micro k8s
424:10 - we'll go to the docs
424:12 - and uh we will go and look for i thought
424:15 - it was like on the homepage they
424:16 - explained even how to install yeah you
424:18 - go to linux and right away they go snap
424:20 - use snap if you don't have snap get snap
424:22 - installed i'm not installing snap uh
424:24 - that's like a package manager i'm not
424:26 - installing it for our amazon linux 2 and
424:27 - since that sounds like a nightmare but
424:29 - what i will do is go to our dashboard
424:33 - and i'll spin up a new instance so um we
424:35 - don't need this one right now i'm going
424:36 - to leave it open and so i'm going to go
424:38 - ahead and create myself a new
424:39 - environment this is going to be
424:40 - micro
424:42 - k8s
424:44 - env
424:46 - this
424:48 - cloud developer environment
424:54 - env just to savor some trouble is
424:56 - specifically
424:58 - for micro
425:00 - k8s and we'll see if we have a little
425:01 - bit less problems ubuntu is great it's
425:04 - just sometimes they render problems with
425:05 - it so it takes the least amount of
425:07 - resources but still i'm going to run it
425:09 - on a t3 medium because i just don't want
425:11 - to have to deal with any kind of like
425:12 - having to delete it recreate it
425:14 - run any issues so here we have ubuntu
425:16 - server
425:18 - 18.04 lts so this one will have snap
425:22 - snap was introduced in like 14 it's like
425:24 - a replacement of
425:25 - uh get install or app install or
425:28 - whatever you want to call it so we'll
425:29 - shut off after 30 minutes that seems
425:31 - fine to me leaving that on the default
425:32 - there and we'll go ahead and create
425:33 - ourselves
425:35 - another cloud9 environment
425:38 - again i would love to do this and get
425:40 - pod but unfortunately can't run
425:41 - kubernetes clusters there right now but
425:44 - we'll take a look here and see what is
425:46 - being suggested so it says pseudo snap
425:48 - install
425:49 - micro k8
425:50 - hyphen hyphen classic so if there's
425:53 - something that's not classic i'd love to
425:54 - know
425:55 - but i don't know much about snap
425:58 - so give it a moment to start up here
426:00 - and then we'll end up copying this
426:02 - command doing that command
426:04 - but notice here like turn on the
426:05 - services that you want notice with the
426:07 - other ones that we didn't have to turn
426:09 - anything on like we didn't turn on the
426:10 - dashboard we just said start the
426:12 - dashboard and maybe it wasn't installed
426:14 - it just pulled it at the time of when we
426:16 - needed it but with micro k8s you can't
426:18 - turn on the dashboard unless you enable
426:20 - it right so everything has to get
426:22 - enabled so when we start this up it
426:24 - doesn't even have anything right and
426:26 - maybe we'll see that when we look at the
426:27 - pods okay
426:29 - so we'll just wait here for cloud nine
426:31 - to start
426:33 - another way we can observe this is we go
426:35 - over to ec2 we go to our instances we
426:37 - can see
426:39 - them here and it gets kind of confusing
426:40 - because um
426:42 - it doesn't show like
426:44 - the uh
426:46 - what it is but like we don't have to go
426:48 - based on the name so i don't think it'll
426:50 - say here like ubuntu anywhere right so
426:51 - if we go to our
426:53 - ami or amazon machine image that's the
426:55 - thing that's running it oh down here it
426:57 - says cloud9 ubuntu so we do have an idea
426:59 - what it is okay but generally sometimes
427:01 - you can't tell what it is if it's not in
427:03 - the name like they didn't write it in
427:04 - the name go back over to cloud9 it is
427:06 - ready everything is nice and big which
427:09 - is nice this pop-up is driving me crazy
427:12 - we'll close that here we'll copy this
427:14 - and we'll go over to our new environment
427:16 - and we'll paste in sudo snap install
427:18 - micro k8 classic
427:21 - now this is an amazon x2 so it's
427:22 - slightly different
427:24 - this is kind of nice i like this
427:25 - experience
427:26 - with snap
427:28 - and it will install good
427:32 - like i think like when you install it it
427:34 - actually starts the cluster up right
427:36 - away
427:38 - because it says check the status of
427:39 - community service so you don't have to
427:40 - say start it just as it's installing and
427:43 - it starts at the same time so i'm
427:44 - surprised i would think they would just
427:45 - like install it and then you'd start it
427:47 - separately but i guess that was their
427:49 - decisions there
427:54 - and while it's waiting we'll just take a
427:56 - look here see if there's anything else
427:57 - interesting i don't think i dug too deep
427:59 - into the docks for microcades i'm mostly
428:02 - familiar with um
428:03 - mini cube and i think that's what we're
428:04 - going to be sticking with throughout
428:07 - this project
428:09 - nothing's super exciting here we'll go
428:11 - back over to michael k8s
428:14 - and it's still taking time so once this
428:16 - is done i will see you back here in a
428:18 - moment okay
428:20 - so after a short little wait it looks
428:21 - like it is installed so we'll go back
428:24 - over to the home page and look at the
428:26 - instructions here so we have micro case
428:28 - status
428:29 - weight ready so wait until it says it's
428:30 - ready
428:32 - and it says
428:33 - insufficient permissions to access it i
428:36 - like how they're like sudo here but sudo
428:38 - not here okay so we got to go ahead up
428:40 - actually has some instructions you can
428:42 - either try again with sudo or add the
428:44 - user ubuntu to the micro kh group
428:47 - i'd rather do this i did this before and
428:49 - i did not have much luck but i'm going
428:51 - to try to follow through with it
428:53 - okay it says after this reload the user
428:55 - group either via a reboot or running new
428:58 - grep
428:58 - new group micro k8s
429:01 - okay so we'll type in clear
429:03 - as i was talking about where i started
429:05 - having issues with sudo
429:07 - it was more than just this but we'll see
429:09 - what happens here
429:10 - so it is running and then it tells us
429:13 - what add-ons are enabled right so this
429:15 - is very add-on based as you can tell
429:17 - so high availability it's it's no so
429:20 - it's obviously it's running on one node
429:21 - so that makes sense
429:23 - what's enabled an h a cluster high
429:25 - availability cluster which is
429:26 - interesting because it's not highly
429:27 - available and then what's disabled right
429:29 - now so we don't have ambassador uh uh i
429:32 - don't know how to pronounce that
429:33 - psyllium ci limb the dashboard's not
429:36 - enabled dns is not enabled we got
429:38 - nothing we don't have link or d we have
429:40 - nothing okay
429:41 - interesting that we can see some stuff
429:43 - so like kubeflow we talked about doing
429:44 - machine learning so it's really nice if
429:46 - you want to install kubeflow you could
429:47 - just enable that if you want k native
429:50 - which is for
429:51 - kind of like it like set does a lot of
429:53 - stuff where you like scale down to zero
429:55 - it's the kind of server stuff you want
429:56 - an open source framework so it really is
429:59 - good as as long as you can deal with
430:01 - ubuntu if i spend more time with it i
430:02 - think we'd be using this as opposed to
430:04 - mini cube but i just want things to be
430:05 - easy okay
430:07 - so anyway what we'll do is we'll go back
430:09 - to here
430:10 - and we'll take a look here so it says
430:11 - turn on the services that you want so
430:14 - right now i'm not going to turn on any
430:15 - services and i want to see if we run
430:18 - into any friction without having to turn
430:19 - anything on because obviously there's
430:21 - nothing but if we type in cube ctl
430:23 - actually that's not even installed on
430:24 - this machine so here it says pseudosnap
430:26 - install cube ctl sure why not
430:31 - so this revision of cube ctl is
430:33 - published using classic and thus may
430:35 - perform arbitrary system outside etc if
430:37 - you understand i want to proceed run
430:38 - classic
430:39 - okay
430:41 - i mean
430:43 - uh
430:43 - micro kh was classic so it must be fine
430:46 - to do this okay so we'll type in cube
430:47 - ctl
430:50 - okay it works great
430:51 - last time in this i hadn't i could not
430:53 - get cube ctl to work but uh we'll type
430:55 - in cube ctl get pods
430:58 - uh the connection of the server
431:00 - localhost 8080 was refused did you
431:02 - specify the right host or port
431:05 - ah interesting it's not working yet i
431:08 - wonder why so i think the reason why is
431:10 - because we don't have anything installed
431:12 - we don't even have a dns installed right
431:15 - so like dns is the way
431:18 - that outside traffic can communicate or
431:20 - just like
431:22 - traffic in general can communicate
431:24 - within a cluster so i bet we have to
431:25 - enable that so we'll go over here and we
431:27 - will only enable
431:29 - we'll only enable dns so i i don't have
431:32 - micro uh k8 down to a t here so i'm
431:35 - copying paste we'll type enable dns okay
431:40 - probably need a dns
431:44 - and we'll give it a moment here notice
431:46 - it's say look what it's creating a
431:47 - service account a config map these are
431:50 - all kubernetes components deployment
431:52 - service you learn about all the stuff in
431:53 - the course um core dns role based access
431:56 - stuff restarting cubelet and dns is
431:59 - enabled so now we'll get getpods
432:02 - and it's still saying this okay i
432:04 - remember this before
432:06 - what if we type in
432:07 - [Music]
432:09 - micro k8ss
432:11 - hold on here
432:13 - okay so i i think this is what i
432:15 - remember i remember i installed cube ctl
432:17 - i got this error i have no idea i was
432:19 - getting that error so then i just by
432:21 - default it to micro k8 cube ctl and then
432:23 - i was having less problems so i'm not
432:26 - sure if we had to have dns to do
432:27 - anything there but it's really hard to
432:29 - do anything without a dns in kubernetes
432:31 - so we probably had to enable it anyway
432:33 - let's do hyphenate let's see what we
432:35 - have look there's only three pods
432:38 - there's nothing here remember how much
432:39 - there was when we did kind
432:41 - and
432:43 - uh the other one like
432:45 - mini cube
432:47 - so there's literally nothing we have
432:49 - calico cube controllers core dns and
432:52 - calico we'll learn about core dns
432:55 - core dns is what kubernetes use it's the
432:58 - dns service here it is covered in the
432:59 - course we'll learn about it calico is
433:02 - a very popular um
433:06 - it's a cat i used to have a calico cat a
433:08 - long time ago but um calico kubernetes
433:10 - is a project by uh tigra tiger i don't
433:13 - know you call it but they are what is
433:15 - used for
433:16 - um
433:18 - uh i don't i remember cni it's in the
433:20 - course
433:22 - it's for it's for um it's for something
433:26 - i can't remember proxy or something i'm
433:28 - just i'm blanking here but anyway
433:30 - there's only three things here so
433:31 - there's not a whole lot so let's see
433:32 - what happens
433:34 - if we go and those some things are
433:35 - pending and some things are running so
433:37 - let's go ahead and deploy our
433:39 - application so we'll go here to the left
433:42 - and we'll go to
433:44 - deployment
433:46 - we'll have to copy this over here
433:50 - and we'll create ourselves a new folder
433:53 - k8s
433:55 - don't need a folder but i'm just making
433:57 - one for fun we'll say deployment.yaml
434:01 - we'll double click this we'll go ahead
434:02 - and paste that in there we will save it
434:05 - scroll on down
434:06 - and so now we should be able to do mini
434:08 - cube or sorry
434:10 - same mini cube micro k8s cube ctl
434:14 - apply hyphen s
434:16 - k s application oops deployment yaml
434:21 - it created it
434:23 - so now we can hit up because this i just
434:26 - can't type micro k so i can't remember
434:27 - how to type it get pods
434:30 - okay
434:32 - remember we do hyphenate shows us all
434:33 - the pods right
434:38 - and i'm just waiting for that to become
434:40 - available
434:41 - we can try deployments as well see if it
434:44 - was successful
434:47 - i'm waiting
434:53 - and we might be waiting on the the probe
434:55 - here so the probe is what's doing the
434:56 - business right it's the one that's
434:58 - saying
434:59 - hey after you checked a few times then
435:01 - we can determine it's ready if we didn't
435:03 - have the probe it'd probably start up a
435:04 - lot faster but i don't know if we're
435:06 - missing another component right
435:11 - still pending
435:12 - so one thing we can do if we're looking
435:14 - at this we could probably put the name
435:15 - in here like this maybe we'll get some
435:16 - additional information
435:19 - uh describe instead
435:22 - describe is your friend
435:25 - okay so we'll scroll up
435:28 - aha so we see something here
435:30 - zero out of one nodes are available has
435:32 - taint
435:33 - node kubernetes disk pressure the pod
435:36 - didn't tolerate if you look this up it
435:37 - might say like hey you're trying to
435:39 - deploy into a node that's not supposed
435:40 - to be there
435:41 - or
435:42 - the other issue is that there's we're
435:44 - running out of storage so let's see
435:45 - where it says disk pressure like the
435:46 - disk is under pressure it means the disk
435:48 - is out of space probably so if we do dh
435:51 - hyphen f oh it's not even installed
435:55 - oh sorry d f hyphen h i spelt it wrong
435:58 - um
435:59 - we can see that we have
436:01 - most of it used up so that's our problem
436:03 - here so it's that problem from before
436:06 - that we had no biggie we'll go over here
436:08 - micro khs that's what we want we'll go
436:10 - to storage we'll go to our volume
436:12 - we'll select our volume
436:14 - and we will
436:16 - modify our volume and we'll bump that up
436:19 - to 40. we probably don't need 40 but i
436:20 - just want it to work
436:23 - and it says it's in use so i think we're
436:27 - in good shape here and if we hit up
436:30 - does it auto expand
436:32 - elastic it's called like elastic
436:34 - something i can't remember the term 99
436:35 - percent use so we're gonna have to
436:36 - reconnect
436:38 - reboot the server here
436:41 - by the way if you do have to like stop
436:43 - and come back to this you can always
436:44 - just stop these by the way you can
436:46 - always just hit stop and as long as you
436:48 - don't terminate you can always start it
436:49 - back up and we can always pick up for
436:51 - where we last left off or just let the
436:53 - um it shut down after a certain amount
436:55 - of time like if you go back to the
436:56 - cloud9 interface
436:59 - you know if you go here
437:02 - if you close these tabs you can always
437:04 - just go back to cloud nine and open them
437:06 - there and they will auto shut down right
437:08 - but anyway um
437:10 - we need to restart this so we'll go here
437:13 - or sorry reboot and we'll reboot that
437:15 - rebooting is super fast so hopefully we
437:17 - don't have to close this
437:19 - but when it does reboot um the cluster
437:21 - might not be started but i guess we'll
437:23 - see
437:27 - so i don't know if we'll have to because
437:28 - like remember we didn't have we didn't
437:30 - start the cluster we just installed it
437:34 - but if it's smart it might always do it
437:36 - you know what i mean
437:47 - so it is reconnecting
437:57 - go back over to ec2 we'll just check the
437:59 - status here
438:02 - no it is running
438:06 - if cloud9 has a hard time reconnecting
438:07 - you just close the tab
438:10 - we'll go back to cloud9 we'll just do it
438:11 - this way
438:13 - it happens sometimes
438:15 - and we'll go over to micro k8s
438:20 - and i'll probably instantly open and
438:21 - have no issues
438:23 - if we're lucky i suppose
438:38 - it's having some real trouble here
438:40 - go back over to ec2
438:49 - i'm just going to check the volume maybe
438:50 - the volume is not ready i think the
438:52 - volume is ready attached
438:54 - doesn't seem like there's any issues
438:55 - here
438:59 - okay so i'm not sure what the problem is
439:01 - but what i'm going to do is i'm just
439:02 - going to take a break i'm just going to
439:03 - close this tab
439:05 - i'm going to take a break and then i'm
439:06 - going to come back to cloud9 i'm going
439:08 - to launch it and it should probably work
439:11 - okay if you ever run into problems like
439:13 - that sometimes it's just worth taking a
439:14 - break there
439:16 - but i'll be back here in a bit okay
439:18 - all right i was gone for like three
439:19 - minutes i went in here press this button
439:21 - it launched instantly so we're back in
439:23 - business here
439:25 - now is the cluster still running i don't
439:27 - know so we'll go back over here we'll
439:29 - say microk status because i don't know
439:31 - if it's just going to start up when we
439:33 - restart the machine
439:35 - and
439:36 - that is k-8s we want this one right
439:38 - micro k8
439:40 - hit enter
439:42 - and we'll see if it's ready
439:44 - it is running okay great so we're fine
439:46 - um i don't think our stuff is still
439:48 - there so if we type in micro k8s
439:51 - uh cube ctl
439:54 - get pods
439:57 - oh it's still running okay cool well
440:00 - that's cool like when we when we uh i
440:02 - don't know if we did it in this but i
440:03 - know that when i restarted um like kind
440:06 - or mini cube this stuff did not persist
440:08 - right they were lost so it's really cool
440:09 - that it just everything went back up i
440:11 - think that's actually one of the
440:12 - benefits of
440:14 - okay so high availability low ops
440:16 - minimal pr
440:17 - there's something about the features
440:18 - they say like that you know yeah
440:21 - autonomic
440:22 - automatic autonomous and self-healing
440:24 - right
440:25 - so basically you know if you restart the
440:28 - machine everything's back in the shape
440:29 - that you wanted to be which is great
440:31 - um like the entire cluster like that's
440:33 - that's awesome um so now that that's
440:35 - running the question is okay can we
440:37 - access that of course if we do curl
440:39 - localhost 8080
440:41 - we're not going to see stuff here so
440:43 - this is where we're going to do our
440:45 - usual
440:46 - um port forward so port
440:48 - forward i'm trying to do this from
440:49 - memory so deployments
440:51 - forward slash sinatra
440:53 - um 8080 4567
440:56 - and then we'll say address
440:59 - address
441:01 - 0.0.0.0 enter
441:05 - and i forgot the r always forgetting the
441:06 - r on that one eh
441:08 - we'll hit enter and so that port is
441:10 - being forward and so now if we open a
441:12 - new terminal
441:16 - and we type in
441:19 - curl
441:21 - localhost
441:23 - 8080. there it is okay so it's the same
441:26 - thing as before it'd be nice to see we
441:29 - get the dashboard working um i'm not
441:31 - sure if that'll be easy but we can give
441:33 - it a go and see see what happens here so
441:36 - what we'll do is go back to the homepage
441:38 - here
441:40 - and
441:41 - yeah i think it's just because they had
441:43 - a couple lines here
441:44 - where is it where'd it go
441:49 - oops
441:50 - that is not what i wanted
441:53 - oh linux we had to click on linux um so
441:56 - we definitely need to have the dashboard
441:58 - installed
441:59 - we don't need to register our our istio
442:01 - so i'm going to go back here
442:04 - oops first second tab here and we don't
442:07 - want to turn off our port forwarding but
442:09 - we're going to type in micro k8s
442:12 - enable
442:13 - dashboard
442:18 - now if the dashboard is just accessible
442:20 - then maybe we'll just stick with micro
442:22 - case i really do like micro creates out
442:23 - of all these
442:25 - um but you know
442:26 - we'll just see what goes here
442:28 - uh lots of stuff about role-based access
442:30 - if rbac has not enabled the dashboard
442:32 - using default token retrieved with
442:34 - this in rebac enabled you need to create
442:37 - a user with restricted permissions shown
442:39 - in etc
442:41 - so
442:42 - we'll see what happens here um
442:47 - so this is going to assign it to
442:49 - something uh what if i just paste that
442:51 - in there
442:55 - okay so we have a token now that i think
442:57 - we used to log in but let's see if we
442:59 - can actually get into the dashboard very
443:00 - easily i'm not sure if this is going to
443:02 - be hard
443:03 - so we'll go and type in the dashboard
443:05 - proxy so that probably launches the
443:08 - dashboard or something here
443:09 - checking if dashboard is running
443:11 - ah and i didn't get to show this earlier
443:13 - but what i wanted to show was the fact
443:16 - that uh the dashboard is just a pod so
443:18 - if we go to micro
443:20 - k8
443:22 - cube ctl
443:24 - get pods
443:26 - and we do hyphen a
443:29 - we should see the dashboard here
443:33 - so the dashboard is probably metric
443:35 - server like when i ran it um for um
443:38 - kubernetes over here
443:41 - maybe we're still running the dashboard
443:42 - i'm not even sure no because we stopped
443:44 - my mini cube so it's not running but um
443:47 - there was two pods one was the dashboard
443:50 - and one was the metrics but i'm pretty
443:52 - sure the metrics one here is the actual
443:54 - dashboard even though it's not showing
443:56 - properly here um but we did
443:59 - start this here i'm just trying to find
444:02 - um
444:04 - dashboard ah so micro case dashboard
444:07 - wait for the dashboard the dashboard
444:08 - will be available here
444:10 - at this port number use the following
444:12 - token to log in
444:14 - okay so even though we have this on port
444:17 - 10443
444:20 - i don't know if we can open that port
444:21 - we'll try it for fun
444:23 - we'll see if we can just open that port
444:24 - up but i don't think it's going to work
444:25 - i think there's going to be a lot more
444:26 - work there and honestly to get the
444:28 - dashboard working i i needed a lot of
444:30 - help i had to pull my co-founder who
444:32 - knows linux networking a lot better for
444:33 - me to figure out so
444:35 - um we will give it a go here but i don't
444:37 - think i'm going to solve it
444:38 - we're just going to try to open up the
444:40 - port
444:41 - so we'll go here into microkates we'll
444:44 - go to networking
444:47 - and we will choose oh it does say
444:50 - networking i meant security we'll click
444:52 - on the security group
444:55 - and we'll edit the inbound rules here
444:58 - we'll add this and we'll go
445:01 - and put in this port number here we'll
445:03 - say uh k8's dashboard
445:06 - and we'll make it my ip so we don't have
445:08 - to worry about anyone else trying to get
445:09 - into this thing and we'll save it and so
445:12 - now
445:13 - we'll go back to ec2
445:15 - and what we need here is the actual ip
445:18 - address so
445:19 - we'll go to details
445:21 - public ip address
445:24 - we will paste it over up on to top of
445:26 - kind and then i need the
445:28 - [Music]
445:29 - port
445:34 - which is here
445:38 - client-side http
445:39 - gpus to an https server okay so it has
445:43 - to be https i i will try to do this
445:47 - we'll advance it's totally fine
445:51 - oh this is so much easier okay great
445:53 - because like with minicube it was so
445:55 - hard to figure out how to get that
445:57 - address to listen on that that port
445:58 - number but here's this token or
446:00 - uh cubeconfig so we can go back over to
446:03 - our michael k8 environment here we'll go
446:05 - ahead and copy this
446:07 - and i'm going to go ahead and paste that
446:08 - in there and we'll hit sign in
446:11 - and there we go so we're in
446:14 - we can go to our pods we can see that
446:16 - our pod is running here the usage and
446:18 - stuff this looks i don't know this looks
446:20 - any different is this the same as the
446:21 - other one it seems like there's a lot
446:22 - more going on here
446:24 - i can't tell because they're not both
446:25 - pulled up side by side but maybe we'll
446:27 - say with micro k8s maybe we'll use mini
446:29 - cube but the idea is that we have both
446:31 - our environments set up
446:32 - and that's all i really want to cover
446:34 - for now so to shut these down what we'll
446:36 - do is go ahead and
446:39 - just close these
446:40 - and i'll go over to ec2
446:43 - and we will go ahead and just turn these
446:45 - off so stop the instance don't terminate
446:47 - them stop them
446:49 - otherwise you're going to be having a
446:51 - lot of extra work here and so we have
446:53 - two developer environments that we can
446:54 - use for the rest of this course so that
446:57 - should be fun hopefully that gives you
446:58 - kind of an introduction into kubernetes
447:01 - uh just obviously a lot going on there
447:03 - but we will unravel it piece by piece
447:05 - throughout this course
447:07 - and there you go okay
447:09 - [Music]
447:14 - hey this is andrew brown from exam pro
447:15 - and what i have here is kind of an
447:17 - amendment to our lab so i did a bunch of
447:19 - labs where um i'm typing constantly
447:22 - micro k8s as cube ctl because i couldn't
447:25 - figure out how to get cube ctl
447:27 - configured properly so when i run this
447:28 - like get pods i would get this error
447:31 - saying localhost 8080 refuse and i'd
447:33 - look it up and it'd say you have to
447:34 - configure your cube config file but i
447:37 - could not find like the examples they
447:39 - were showing did not work and so
447:41 - eventually i did figure it out but i
447:42 - shot a bunch of labs where i'm typing
447:44 - micro k8s cube ctl and just to save you
447:46 - some pain i just want to show you what
447:48 - you can do
447:49 - uh to fix that problem uh and so you
447:51 - just do this later on when you're doing
447:53 - a lab so you don't have to deal with
447:54 - this but i'm going to type in micro k8s
447:57 - micro k8
447:59 - config
448:01 - and then right angle bracket and then uh
448:04 - tilde forward slash
448:06 - um
448:08 - dot cube
448:10 - forward slash config just going to
448:11 - double check to make sure i spelled that
448:12 - right
448:14 - there we go and we'll hit enter and so
448:16 - now if i type in cube
448:19 - ctl get pods
448:21 - we're all in good shape so
448:22 - um i realize that you know depending on
448:25 - when you're watching this video you
448:26 - might not know much about kubernetes but
448:27 - just when you start seeing me type micro
448:29 - case coop ctl if you just want to save
448:31 - yourself the trouble of typing that 100
448:33 - times run this and then you can just
448:34 - write cube ctl and that will be a lot
448:36 - easier okay
448:37 - [Music]
448:41 - hey this is andrew brown from exam pro
448:44 - and in this follow along we're going to
448:45 - take a look at a variety of ways that we
448:47 - can expose our pods via
448:49 - kubernetes service and we're going to
448:52 - continue on using the environments we
448:53 - set up earlier in other follow alongs in
448:56 - our cloud9 environment uh and just
448:58 - looking at the costs here it's we're
449:00 - only at three dollars so we're doing
449:01 - pretty good for this account here but
449:03 - what i'm going to do is make my way over
449:04 - to cloud9 so just type in cloud9 at the
449:07 - top here and if you uh turned off not
449:10 - not terminated but turned off those
449:12 - environments shut them down they should
449:14 - still be here and so we have that k8
449:15 - environment with both kind and mini cube
449:18 - and then micro k8 environment i'm
449:19 - preferring the micro kx environment so
449:21 - i'm going to go ahead and open that one
449:23 - up just because i'm finding that one to
449:24 - be pretty easy to use
449:27 - and we'll just give a moment for this
449:29 - to launch here okay
449:34 - all right so our environment has
449:35 - launched here i'm just waiting for our
449:37 - terminal to appear there we are
449:38 - everything is nice and big
449:40 - uh and so we had deployed something
449:43 - prior so micro k8 is really great
449:44 - because if you had something running
449:46 - prior and you shut it down and start the
449:48 - machine up it should still remain so i'm
449:50 - going to type in micro k8
449:52 - uh k8s okay it's kubernetes or cube ctl
449:56 - and we're gonna say uh get pods
449:59 - and it would be really nice to use cube
450:01 - ctl directly i tried looking up the
450:03 - solution for it it has to do something
450:05 - with the config file but i can figure it
450:06 - out so i'm just going to keep typing
450:07 - micro case cube ctl it's not a big deal
450:09 - for me and so there's that sinatra
450:11 - application and it should end up
450:15 - deploying so there we go so now it's
450:16 - running again so we don't have to worry
450:18 - about deploying uh that sinatra app
450:21 - again i'm going to see what services i
450:23 - don't think we have any but we'll just
450:24 - double check so i'm going to type in
450:26 - cube ctl
450:27 - get services you can also type in svc
450:29 - which is the shortcut but i'm going to
450:31 - stick to typing things
450:33 - full out here but on the exam you might
450:35 - actually see uh initializations which is
450:37 - kind of frustrating because they really
450:38 - should just always use the full names
450:40 - for people learning but here you can see
450:42 - that we do have a service here which is
450:45 - for kubernetes and it's a cluster ip
450:47 - this is the system one that always shows
450:50 - up here so we're not going to touch this
450:51 - one but just showing you that it does
450:53 - exist
450:54 - and before we actually
450:56 - even go ahead and launch a service let's
450:59 - talk about pod communication so if we go
451:02 - back here and type in get pod
451:05 - we should see all the pods that are
451:06 - running and so we only have one which is
451:08 - sinatra uh but this actually has an ip
451:11 - address and so what we can do is type in
451:13 - o
451:14 - which stands for output hyphen o which
451:15 - is a flag type the word wide and we'll
451:18 - get additional information so here we
451:20 - can get the ip address um there's the uh
451:23 - the node that is running on things like
451:25 - that
451:26 - so every time a pod is terminated or or
451:29 - stopped or whatever
451:31 - it will have a new ip address and
451:32 - because
451:34 - dynamic ip addresses make it really hard
451:36 - to make microservices because your ip
451:38 - addresses are changing all the time it's
451:39 - going to be really hard to communicate
451:41 - and so that's the purpose of services is
451:43 - that it can have a static ip that's one
451:45 - reason to have it but let's kind of
451:47 - observe what happens if we were to um
451:51 - terminate this pod okay so what i'll do
451:54 - is i will copy the name of the pod here
451:56 - and we will put in micro
451:58 - k8s cube ctl and i'm going to say delete
452:03 - pod sinatra
452:06 - okay
452:08 - and what we'll do is just go to the top
452:09 - here and i want the wide and notice that
452:13 - even though the pod is destroyed because
452:15 - there's a deployment it's going to
452:16 - always launch a new one because it
452:18 - expects there to be one pod but notice
452:20 - that we have a new ip address so it's
452:22 - not the same one the old one was ten one
452:24 - twenty two nine the new one's ten one
452:26 - twenty two thirteen so that's an example
452:28 - of that dynamicism happening there now
452:32 - if we wanted to communicate with that um
452:35 - like right now the ip address is here
452:38 - but we are not within the node
452:40 - and so if we were to try to type in if
452:41 - we go up here for a second and we were
452:43 - to try to take this ip address and we
452:46 - were to write something like uh curl
452:48 - localhost
452:50 - 8080. okay it says connection refuse
452:53 - because you know these are internal uh
452:56 - internal traffic within the cluster were
452:58 - not inside the cluster
453:00 - so how could we communicate that without
453:02 - a service so one thing that we could do
453:05 - is we could um uh basically uh a remote
453:10 - login into
453:11 - a pod and that's something that you can
453:13 - do in kubernetes and so
453:15 - one thing we can do is uh launch a new
453:17 - pod and so what i'm going to do is just
453:19 - type in service debugging kubernetes
453:21 - because the commands that we want are
453:23 - there
453:25 - and so if i pull up the documentation
453:27 - here they have a couple commands so we
453:29 - have
453:30 - this one where it says
453:32 - if you want to run a pod you can run
453:34 - this one called busybox and if you've
453:35 - never heard of busybox we do cover it in
453:37 - the course and we might have already
453:38 - covered it before this tutorial but busy
453:40 - box is basically a um
453:44 - it's a
453:45 - container and it already contains a
453:47 - bunch of utility libraries that we can
453:49 - use right and so it's just a really easy
453:52 - way to get started so if we go back over
453:54 - here and we look at this what it's doing
453:56 - is saying create a new pod
453:59 - never ever uh restart this so if we if
454:01 - we terminate if we like we exit the
454:03 - command line it will or the shell it
454:06 - will delete and use the image from here
454:08 - so it's on
454:10 - the google's
454:11 - container repository here called busybox
454:13 - and it's going to launch bash so we can
454:15 - interact with it so what i'll do is go
454:17 - ahead and copy this
454:18 - go back here and we'll type in clear and
454:20 - we will launch that and so what it will
454:22 - do is we'll launch up a new pod
454:25 - oh sorry we're going to type in micro k8
454:26 - in the front here
454:28 - but it's going to launch up a new pod
454:31 - and it's going to enter us into bash and
454:33 - so if we go over here we can now type in
454:36 - micro ka test if you don't have a new
454:38 - tab just go here and open a new one here
454:40 - and we'll type in cube ctl get pods and
454:44 - so we can see busy box is running
454:46 - all right and we could have written our
454:49 - own deployment file or pod file in order
454:52 - to provision it it's just a lot easier
454:53 - to just write it at this one line
454:55 - because as soon as we terminate this
454:57 - it's going to oops we'll type exit it
454:59 - will then kill the pod we don't have to
455:00 - worry about it so if i go back to here
455:03 - okay see the pod is gone but what i'll
455:04 - do is go hit up on my keyboard to bring
455:06 - back that command and it's going to
455:08 - enter us back not did not just launch
455:10 - the pod but enter us into the pod so we
455:12 - can execute commands so we are within a
455:15 - pod and so technically pods can talk to
455:17 - other pods because now we're inside the
455:19 - cluster and so if we were to type in
455:22 - let's say the other the other one runs
455:25 - on four five six so if we typed in
455:26 - localhost four five six seven let's see
455:28 - if that works okay so we'll say
455:30 - locals4567 and we will do
455:33 - curl here and so oh curl's not on here
455:35 - so we'd have to type in wget
455:37 - okay so w get and that same thing as
455:40 - curl and so it says connection furiously
455:41 - remember pods
455:42 - communicate sorry containers within a
455:44 - pod all communicate on localhost but uh
455:48 - pods have their own ip address so let's
455:50 - go back here and type in o
455:53 - wide
455:54 - and we can see there's an ip address
455:56 - here so if we were to copy this ip
455:58 - address
455:59 - okay paste it in here put w get in the
456:01 - front
456:02 - and then do
456:03 - 8080
456:07 - oh sorry 4567 right 4567
456:10 - it's able to access that index.html so
456:13 - if i just do ls which lists out all the
456:15 - files there it is and we'll check the
456:17 - contents of it by typing cat index.html
456:20 - and there it is so we were able from one
456:22 - pod uh to communicate with other pod by
456:24 - using its dynamic ip address okay but
456:28 - you know if it
456:29 - if we kill that pod or it gets replaced
456:31 - uh you know that ips is going to change
456:33 - and that's where that pain comes from so
456:35 - that is what i want to show you the pod
456:38 - so next we'll move on to our first
456:40 - service which will be cluster ip okay
456:43 - [Music]
456:48 - all right so what we're going to do is
456:50 - take a look at
456:51 - launching our first service so a service
456:54 - allows you to attach a static ip address
456:56 - and also can do load balancing to
456:58 - multiple pods that it selects and so
457:01 - what i'm going to do here is go to the
457:03 - top and we'll type in service kubernetes
457:06 - because most of the code is here we can
457:08 - just tweak it um and i always like to
457:10 - show you where i'm grabbing the code
457:12 - from so here's to finding a service and
457:14 - so this is an example of one
457:16 - but we want cluster ip if we scroll on
457:19 - down here um
457:21 - i mean that one up there is cluster ip
457:23 - but i'm just trying to see if they
457:24 - actually have a very specific one for
457:26 - cluster ip
457:27 - nope okay so that one up there is
457:29 - cluster ip okay so we'll go back to the
457:31 - top
457:32 - i'm going to go ahead and grab on this
457:34 - one here and we'll go back over here and
457:36 - i'm going to create in our folder here a
457:38 - new file i'm going to call this one
457:40 - service
457:41 - cluster
457:43 - ip.yaml
457:45 - we'll double click into this and we'll
457:47 - go ahead and paste that on in there and
457:49 - so one thing is that we
457:51 - will need metadata so the the metadata
457:54 - name will be the name that shows up when
457:55 - we do
457:56 - uh get services so i'm just going to
457:59 - type in
458:00 - service
458:01 - cluster ip
458:04 - and then we need your selector so
458:06 - uh i'm actually going to
458:09 - leave the selector incorrect so i'm
458:10 - going to go here and do sinatra
458:13 - uh i'm going to go over here and see
458:14 - what this is called so this one is
458:16 - called uh sinatra yeah okay so i'm going
458:19 - to call sinatra and then down below we
458:22 - have the port so tcp is great uh port 80
458:25 - is the port that we want to access
458:28 - within the cluster so we'll say 8080 and
458:30 - the target board is four five six seven
458:32 - so very similar to when we were doing
458:34 - port forwarding right which technically
458:36 - probably was creating service and also
458:38 - proxy at the same time um and then down
458:40 - below here are we still in this
458:41 - environment let me just type exit if we
458:43 - didn't exit busy box there and we'll
458:44 - just type in clear and so
458:46 - a few too many tabs here i'll close the
458:48 - first one um i don't care about that tab
458:51 - but uh so the idea here is that we will
458:53 - um
458:54 - uh provision or deploy the service and
458:56 - so we should be if we're within the
458:58 - cluster access that port 80 uh um the
459:01 - pod via port 8080. so what we'll do here
459:04 - is type in micro k8s and we'll type in
459:08 - cube ctl
459:10 - and then we will type in
459:13 - um
459:15 - apply hyphen f
459:16 - k 8 s service cluster i p address now
459:20 - notice i didn't actually specify a kind
459:22 - and i just kind of want to point that
459:23 - out before we proceed forward because
459:25 - notice these ones have
459:26 - uh there's like a kind option here so
459:28 - normally you're supposed to do
459:30 - well maybe it's not there let's go down
459:31 - to
459:33 - uh node port will be an example that
459:35 - shows us here
459:37 - i'm just trying to find the code example
459:38 - so under type for spec it would be here
459:40 - okay so if we go under here
459:43 - and we set cluster ip
459:45 - okay that's how you know it's cluster ip
459:47 - but if you don't specify it will
459:48 - automatically be cluster ip so even if
459:50 - we don't have this here we dilute it out
459:53 - it's still cluster ip and this should be
459:54 - two tabs two space tabs otherwise we're
459:56 - gonna have a lot of trouble here
459:58 - um and what we'll do is hit enter okay
460:01 - and so created the service and so we can
460:04 - type in micro k8s
460:06 - um
460:07 - yes or sorry cube ctl
460:10 - get uh svc services
460:14 - and so notice here that we have our
460:16 - service cluster ip it's showing us it's
460:18 - cluster ip type and it has a cluster ip
460:20 - address so this service now has a static
460:22 - ip address of 10 132 183 and 8 and any
460:28 - um
460:29 - any pods that are associated with this
460:31 - like that are linked through them
460:32 - is going to be accessed through this
460:34 - static ip address that's never going to
460:36 - change okay we can terminate pods all
460:38 - day and they will be the same
460:40 - and so you can see that it's for port
460:42 - 8080 okay so that's the the port that
460:44 - we're going to need it on the question
460:46 - is did we properly
460:48 - select the pods and so one way we can
460:50 - tell is if we were to go ahead and type
460:53 - in details so if we go micro
460:57 - k8 or sorry describe and then go
461:00 - service
461:01 - and then put the service name here
461:04 - we can get some additional information
461:08 - uh that was described
461:10 - it is described i'm probably spelling
461:11 - around describe
461:14 - maybe services
461:17 - oh you know what i'm forgetting cube ctl
461:18 - here
461:19 - cube ctl
461:21 - okay and so we get some information so
461:23 - it's in the default namespace
461:26 - notes it shows labels none
461:28 - uh annotations none selectors name
461:31 - sinatra cluster ip single stack ipv4
461:35 - that's its ip address
461:36 - but notice down below here
461:39 - it says endpoints none so in the course
461:42 - we'd say that
461:43 - endpoints is the way a service
461:45 - links to pod or pods and if there are no
461:48 - end points then that's an indicator that
461:51 - this service is not selecting the proper
461:53 - pause and so there's probably a mistake
461:55 - with their selector which there is i
461:56 - purposely did that because i wanted to
461:58 - show you uh that end point now what i
462:01 - want to do is i want to now go back to
462:03 - our busy box example that we had earlier
462:05 - so i'm just hitting up to grab that and
462:06 - if you want to find it again just type
462:08 - in service
462:09 - debug
462:10 - kubernetes and get that link and so
462:12 - we'll enter in here whoops
462:14 - did you specify the right host report
462:17 - oh yeah sorry micro k8 in the front
462:19 - again
462:20 - so we'll go ahead and enter here and so
462:22 - theoretically what we should be able to
462:24 - do is use the cluster ip address
462:27 - right and type in wget
462:29 - and do um
462:31 - 8080 and it should be able to download
462:33 - that page but notice it says can't
462:35 - connect to remote host because it's not
462:37 - linking to anything okay so we'll go
462:39 - ahead here and type exit we'll type
462:41 - clear just to clean things up here and
462:43 - what i need to do is i need to update
462:45 - this because this is incorrect so
462:47 - there's a couple ways that we can update
462:49 - this we can just change this and do an
462:50 - apply
462:51 - um or we can use the
462:55 - i'm to remember the name of the command
462:58 - because usually i'll just i'll just
462:59 - update it and apply it but it's
463:02 - oh i can't remember let's go take a look
463:04 - here so we say cube ctl commands
463:08 - it's in the course
463:09 - um
463:12 - we got viewing updating
463:16 - not replace patching so probably with a
463:19 - patch we could probably do it so
463:21 - i rarely ever run patches but let's give
463:23 - it a go and see if that works if not
463:25 - we'll just update the old way
463:27 - or the way that i like to do it but what
463:29 - we'll do here is type in micro
463:32 - k8s
463:34 - cube ctl
463:36 - patch
463:37 - and then probably the service name so
463:40 - we'll say service
463:42 - and then it's called service
463:45 - cluster ip
463:48 - just to make sure i'm going to go here
463:50 - and type in svc so i can see the name
463:53 - yeah it's service cluster ip if i just
463:55 - made a spell mistake i'm just double
463:56 - checking we'll hit enter
463:59 - and it says must specify patcher patch
464:00 - file containing so we'll just say patch
464:06 - okay that didn't work as i thought that
464:09 - shows you how often i do patches here
464:10 - but
464:11 - oh here goes hyphen p okay so basically
464:13 - apache what you can do is kind of change
464:15 - the value here so so do hyphen p and
464:17 - then provide json
464:19 - um
464:20 - right i guess we can do it that way it's
464:22 - not as clean as i'd like but
464:24 - i guess we'll see here
464:26 - so i mean the other way is probably
464:28 - edits
464:29 - but it's not great to edit things
464:32 - on the fly i'll try patch for fun okay
464:38 - so just to make this a bit easier what
464:39 - i'm gonna do is go over here and this is
464:41 - the actual proper selector that we need
464:44 - now you know it's too much work we're
464:46 - just gonna do an apply because i'll do
464:47 - this in another video where i'll show
464:48 - you how to do patch properly
464:50 - just because it's kind of a pain so i'll
464:52 - do hyphen f
464:53 - and we'll do k8's service cluster ip
464:58 - it says that's unchanged oh because we
464:59 - never updated anything okay so what
465:00 - we'll do is copy this because this is
465:02 - actually the way we're going to select
465:04 - it
465:05 - and we'll go back here and then paste
465:08 - this on here oops in here
465:10 - and so now
465:12 - we will then go apply that and if we go
465:14 - back over to here and we do get
465:17 - cvs
465:18 - okay and then we go
465:21 - uh describe
465:24 - cvs
465:26 - service cluster ip
465:28 - we've got a spell right if we want to
465:29 - work
465:31 - we can now see that there is an endpoint
465:34 - all right and so that should suggest
465:36 - that it's now pointing to the correct
465:37 - pod let's go take a look at the pods and
465:39 - see if there's any new information there
465:40 - so get pods
465:42 - um
465:44 - oh hyphen wide
465:47 - and so notice that it says that the ip
465:49 - address is 10 1 22 13. so if we go up
465:52 - here and look at the cluster ip its ip
465:55 - address is
465:57 - 10 132 8 um
466:00 - 183.8 but notice that this is the end
466:02 - point so this one is going to point to
466:05 - this endpoint okay so it doesn't matter
466:06 - that this ip address is not the same as
466:09 - the cluster ip because it will be
466:11 - because it'll just forward this when we
466:12 - access it through the service
466:14 - so what we'll do is go back over to here
466:17 - it will hit up until we hit micro okay
466:19 - it's cube ctl and we start our busy box
466:24 - and so this time what we'll do is go
466:26 - ahead and grab the cluster ip address
466:29 - which is this one here
466:32 - and we'll go ahead and paste this in
466:34 - we'll do
466:35 - 8080. we'll do wget
466:38 - and notice to download the page and so
466:40 - we'll just do cat index.html
466:43 - okay and so you know that's showing that
466:45 - we're we're able to access that
466:48 - um
466:49 - that pod through the
466:51 - service cluster okay
466:53 - so that allows other pods to be able to
466:55 - communicate with a static ip address
466:56 - which is really useful
466:58 - so type in exit
466:59 - i will type in clear and so that's
467:02 - pretty much
467:03 - all there is for the cluster ip now i do
467:05 - want to show you expose because expose
467:07 - is a easier way
467:09 - or just a like one liner of being able
467:12 - to
467:13 - launch a service so i'll type in cube
467:15 - ctl service command and we'll see if we
467:17 - can get some kind of examples here
467:21 - and type in uh expose
467:25 - and so create a service for this is
467:27 - replicated nginx
467:29 - and it should be easier than that
467:32 - um
467:33 - yeah replicate that's for replication so
467:35 - we should be able to do it for deploy so
467:37 - let's see if we can try to do this uh
467:38 - running this one command here because
467:40 - that's what a service is doing is
467:41 - exposing pods by giving a static ip and
467:44 - giving it a point of entry so what we'll
467:46 - do is go back over here i'm going to hit
467:48 - up until we get to rsvcs and all i want
467:51 - to do is go ahead and destroy this or
467:53 - delete this so we'll type in micro k8
467:55 - cube ctl
467:57 - um
467:59 - delete
468:00 - svc
468:02 - uh
468:03 - paste and then we'll go back up here
468:05 - make sure that it's gone
468:07 - it is gone and i want to try this micro
468:10 - k8s
468:12 - um cube ctl expose so it's gonna be
468:15 - exposed
468:16 - and we're gonna what do we wanna expose
468:17 - want to explore a deployment and so
468:20 - we'll need to know what our deployment's
468:22 - called it's actually just called sinatra
468:23 - so i can just type in sinatra
468:27 - sinatra
468:29 - and
468:30 - um looking at our
468:32 - cheat sheet here
468:35 - okay so it's going to be
468:36 - whatever it is so this is a
468:39 - replication controller set or whatever
468:41 - and so then it's the name and so the
468:42 - port and the target port that's what we
468:44 - want to
468:45 - adjust here so we'll paste that in and
468:47 - so our port is the port that we want it
468:49 - to be
468:50 - on the cluster and then it is the port
468:53 - that we're listening to for the
468:54 - container or the pod which is four five
468:57 - six seven so if we hit enter
469:00 - and we go back up here and hit up we
469:02 - will see now that we have
469:04 - um a service called sinatra so it didn't
469:07 - change the name it probably is a flag
469:08 - for name not sure what it would be
469:11 - um but
469:12 - the idea here is that it has a service
469:14 - here with the cluster ip here and so we
469:16 - should be able to access our
469:19 - um our pod the same way so we'll go back
469:20 - up over to this on the left hand side
469:22 - we'll go back and launch our busy box
469:26 - and what we'll do is go ahead and grab
469:27 - this ip address here
469:29 - and actually before we do that let's go
469:31 - and do a describe on this
469:34 - i'm just hitting up to find it from
469:35 - before and we'll type in sinatra
469:38 - and notice that it's pointing the end
469:40 - point to 10 1 22 13.
469:45 - and its ip address is this and so we'll
469:47 - go take a look at our pod again or pause
469:50 - with the hyphen o wide and notice that
469:52 - is the ip address over here so
469:53 - definitely is working properly but just
469:55 - for fun in our
469:57 - busy box we'll just
469:58 - triple check here to make sure so i'm
470:00 - grabbing the ip address of the
470:02 - service and we'll type in wget paste and
470:05 - we'll do 8080. notice that it downloads
470:07 - if we cad it index.html it shows the
470:09 - contents of that file so we'll type in
470:11 - clear we'll exit busybox and so that's
470:14 - just another way and so expose can be
470:16 - done
470:17 - uh you know with any other one so if you
470:19 - want to do node part as well i think you
470:20 - just put the the flag
470:22 - kind hyphen have inclined but i prefer
470:25 - to uh do it always through the yaml
470:27 - files because then we can take that code
470:29 - and commit it to our repository and have
470:31 - infrastructures of code or what have you
470:33 - there which i think is just a lot easier
470:35 - to do
470:36 - but anyway we'll go back to our services
470:38 - here and i just want to go ahead and
470:40 - delete this one here so we will type in
470:43 - a micro k8
470:44 - cube ctl
470:46 - um
470:48 - delete
470:50 - svc
470:51 - sinatra
470:53 - and i've seen some people where they
470:54 - literally just have to type in key uh k
470:57 - and then you know delete svc but you
470:59 - know
471:00 - just for us we're just gonna be typing
471:01 - it over and over again but that's okay
471:03 - because then you will know it uh
471:06 - by heart and you'll pass your exam no
471:07 - problem by being able to remember all
471:09 - these commands
471:10 - but anyway um so that was cluster ip and
471:15 - i guess we'll move on to node port next
471:18 - okay
471:19 - [Music]
471:24 - all right so we are back and this time
471:27 - we are going to have a service but this
471:29 - time it's going to be a node port so
471:31 - what i want you to do is go to the top
471:32 - here we'll leave our cheat sheet open
471:34 - just in case we need it i want to type
471:36 - in service kubernetes i'll go back to
471:38 - the documentation here and i'll scroll
471:40 - on down and i'm looking for
471:43 - uh one for node port so we scroll on
471:45 - down keep going here and we have
471:47 - multiport service which shows that you
471:49 - can have more than one port which is
471:51 - great
471:52 - uh and we'll make our way over to node
471:54 - port so here is our node port example
471:56 - and so i'll go ahead and copy that
471:59 - and we will make a new file here and we
472:00 - will call this service
472:03 - node port yaml
472:05 - okay and we'll double click into it and
472:07 - we'll paste the contents of it and i
472:09 - will just bring this down here for a
472:11 - moment so we can see what we're doing
472:13 - and so this one's going to be called
472:14 - service node port
472:16 - and the type is node port which is fine
472:18 - and then the selector needs to be uh
472:21 - this label here so it actually can match
472:24 - and uh that's the clustering p once
472:26 - we'll close it and so we will paste that
472:29 - on in there
472:30 - and then here for containers it
472:32 - specifies the environment variable port
472:34 - four five six
472:35 - uh seven we don't need to pass any
472:38 - environment variables so i'm pretty sure
472:39 - we can
472:40 - can we safely delete this there's a lot
472:42 - of stuff i always look at this and
472:43 - wonder if the indentation is incorrect
472:45 - oh whoops you know what um
472:48 - we are in the wrong file i was modifying
472:50 - this one by accident here just making
472:51 - sure i didn't mess up our deployment
472:53 - file
472:54 - sorry we actually want to go to this one
472:56 - here okay so
472:57 - um service node port type node port
473:00 - selector app my app and i was going over
473:03 - deployment because i just wanted to copy
473:04 - the contents over here so we'll go here
473:06 - they're all the same so it doesn't
473:07 - matter which we pull from from there go
473:09 - ahead and paste that on in there and
473:11 - notice that we have um three port
473:14 - numbers okay so these are confusing the
473:17 - text here so i'm going to delete these
473:18 - out and we'll write our own descriptions
473:21 - here so the port is the port that you
473:24 - want it to be
473:25 - for
473:26 - in cluster so the in cluster
473:29 - port
473:30 - so or we could say
473:32 - the
473:33 - port
473:34 - number
473:36 - that
473:37 - [Music]
473:40 - resources
473:41 - within the cluster
473:44 - we'll use
473:45 - to communicate
473:49 - okay and then you have the target port
473:51 - so the target port is
473:53 - um the port that we are targeting so
473:56 - that would be so this would be probably
473:58 - 80 80
473:59 - is what we'd want and this would be four
474:01 - five six seven right so
474:03 - uh the port number the container
474:06 - uh is listening on right because we told
474:09 - sinatra to start on 4567 and then the
474:12 - node port is
474:14 - the external
474:18 - uh
474:19 - external port
474:22 - to uh connect
474:25 - to the node all right
474:27 - so i'm just going to make it 3000
474:29 - 30 0001 all right so hopefully that
474:31 - makes sense but it'll make sense here in
474:33 - a moment when we actually put it into
474:34 - action i really wish this would default
474:36 - to two spaces
474:38 - probably is the way here because the
474:39 - thing with the ammo files is they're
474:41 - highly sensitive to indentation and
474:43 - they're supposed to be two-spaced by
474:45 - default so just to make sure we don't
474:46 - have any more problems here i'm going to
474:48 - just double check here and see if i can
474:49 - find
474:50 - um the indentation levels i'm just
474:54 - trying to think about where that would
474:55 - be we'll go to user settings
474:59 - interface maybe
475:04 - indents indentation
475:09 - uh indent
475:11 - uh cloud nine
475:13 - setting
475:16 - that's not useful i just can't remember
475:18 - where it is honestly
475:23 - oh anyway we'll just have to be careful
475:25 - about that it's not a big deal
475:27 - i just don't want to spend all day on
475:29 - screen scrolling here or stop the video
475:30 - just to try to find that option it's
475:32 - really not that big of a deal but anyway
475:34 - so the idea here is we want to be able
475:37 - to without even launching busybox we
475:39 - want to be able to do uh sorry curl wget
475:42 - is very similar but curl is just easier
475:44 - to use and we want to be able to do
475:46 - localhost
475:47 - 8080 or sorry 3001 right 30 0001 and so
475:51 - that's the idea here is that we don't
475:53 - have to we can access
475:55 - the service outside of the cluster right
475:59 - okay
476:00 - so what we're going to do here is go
476:02 - ahead and launch our new node port
476:04 - service so we'll type in micro k8s
476:08 - cube ctl
476:10 - uh apply hyphen f
476:13 - service
476:16 - i love to type it by hand here i was
476:17 - trying to hit tab to auto complete it
476:20 - and we'll hit enter
476:22 - and i forgot to type the folder name
476:24 - here k8s forward slash notice there's a
476:26 - folder we'll hit enter
476:28 - and created the service so we'll type in
476:30 - micro k8s
476:33 - cube ctl
476:35 - get
476:37 - svc
476:39 - for service
476:41 - and
476:43 - there it is notice we have a cluster ip
476:45 - address
476:46 - and so that is assigned right now there
476:49 - is no external ip address
476:52 - so i guess we'll have to take a look at
476:54 - that in a moment here
476:56 - um well i guess
476:58 - we don't yeah because we don't have an
477:00 - external ip address so external ip
477:01 - address would be for if we set up a load
477:03 - bouncer because we need an external ip
477:05 - address for external load bouncer to uh
477:08 - forward it's or like to find the actual
477:12 - service so that makes sense why we don't
477:13 - have an external ip address let's see if
477:15 - we can just get more information on this
477:18 - particular service to see if there's
477:19 - anything new here i'm not expecting
477:21 - anything but let's just take a look here
477:23 - and see if anything is different
477:25 - so whoops
477:26 - head up here and did i type it wrong
477:30 - micro k k disk cube ctl describe svc
477:34 - service oh i typed it wrong yeah
477:36 - all right and so we'll take a look here
477:38 - and see what information we have so
477:40 - default none none that's totally fine
477:42 - it's targeting this so the selector
477:44 - looks correct here it's node port single
477:46 - stack that is its ip address uh the port
477:49 - here and then here it tells us the node
477:51 - port we can see that the endpoint is
477:53 - working so it is going to something
477:56 - all right and so now what we should be
477:57 - able to do
477:59 - is type in curl
478:03 - uh we'll try the localhost here and
478:05 - we'll do
478:07 - the port number here
478:10 - okay and notice uh that we're able to
478:12 - access it outside of the cluster all
478:14 - right so that was what was uh very
478:16 - impressive okay
478:17 - um
478:19 - and so the next thing
478:20 - that we can do here is just check the
478:23 - cluster ip like just as we did before so
478:25 - what i'm going to do is go ahead here
478:26 - and launch
478:27 - up a micro kx cube ctl
478:30 - with the busy box
478:31 - and we will go and just test this
478:33 - cluster so we'll go grab its ip address
478:36 - and we'll type in wget
478:38 - and then we'll do 8080
478:40 - and we can see that we can access that
478:42 - file again
478:44 - okay
478:46 - so that is node port all right and so
478:50 - now that we did no port i guess the next
478:52 - thing to do would be to do um the load
478:55 - balancer one before we do that let's go
478:57 - ahead and just make sure we get rid of
478:59 - that service so we'll say get svc i'm
479:01 - going to copy the name so i i have to
479:03 - figure it out we'll hit up we'll type in
479:05 - delete and we'll paste that on in there
479:08 - and then we'll go back and hit up again
479:10 - and see that it's gone and so now we're
479:11 - ready for load bouncer
479:16 - [Music]
479:18 - all right welcome back uh so we are
479:19 - going to do a service and this time we
479:21 - are going to use the load balancer type
479:24 - so what i want you to do is create a new
479:26 - file here we'll just type service load
479:28 - balancer and i want to tell you that
479:29 - we're not actually going to be able to
479:30 - complete uh this service
479:34 - type here at least we might do it in
479:36 - another follow along if it is easy
479:39 - because we might launch uh eks and if we
479:41 - do then it'll be an opportunity for us
479:43 - to use the load bouncer i'm having a
479:45 - really hard time typing this balancer
479:47 - dot gammel
479:49 - okay
479:50 - and so we'll go over here and again if
479:53 - you don't know how to get there we'll
479:54 - type in kubernetes
479:56 - service to go to the official
479:57 - documentation and see if we can grab
479:59 - some code to work from and so i'm going
480:01 - to just type in load balancer because i
480:03 - just want an example of one maybe click
480:04 - through here and so here is an example
480:06 - we'll go ahead and copy it
480:08 - and we will paste it in
480:10 - to the file here
480:13 - and we'll change the name so service
480:16 - load
480:17 - balancer
480:19 - and we need the selector to match our
480:21 - actual application here so we'll go back
480:22 - here and paste it on in
480:26 - whoops we'll try that one more time
480:28 - that doesn't work it was just right
480:30 - click copy right click paste
480:33 - gives us less trouble here and so
480:35 - there's a few things here we have
480:38 - the ports
480:40 - so again it's like what poor is it
480:42 - running on so this would be port 8080
480:45 - for our service target port would be
480:46 - four five six seven
480:48 - um notice that it's specifying a cluster
480:51 - ip address and then we have a type load
480:54 - balancer and then we have status load
480:55 - balancer ingress
480:57 - ip address 19202 127. so what is going
481:01 - on here well
481:03 - the thing with service load balancer
481:04 - it's used for connecting to an external
481:07 - load bouncer so the idea is that you do
481:09 - something like
481:10 - um an abs would be
481:12 - elastic or elb
481:15 - so
481:16 - if we go here those are the load
481:18 - balancers for aws
481:22 - so if i go here and create a load
481:24 - balancer we're not going to do this
481:25 - right now because it's not going to work
481:27 - if we do it this way but the idea is
481:28 - that aws has load balancers um there's
481:31 - nginx right nginx has their own called
481:33 - nginx plus
481:34 - all right
481:36 - so that is a load balancer that we could
481:38 - use or if you're using azure it has a
481:40 - load balancer if you're using google it
481:42 - has a load bouncer and the idea is that
481:44 - you can
481:45 - have the load balancer from the service
481:47 - provider be used to distribute traffic
481:49 - and make sure your application's highly
481:51 - available which is recommended for
481:52 - production use case and if you were to
481:55 - use one you'd be using the network load
481:56 - bouncer because i don't think you can
481:57 - use the application load bouncer in this
481:59 - way you always have to use a like a t3
482:02 - or sorry
482:03 - level three slash four load bouncer
482:06 - um because application load bouncer is a
482:08 - bit more tricky but the idea is that
482:10 - when you launch
482:11 - uh this here
482:13 - right and if you like if we if we were
482:16 - using eks
482:18 - right so we launched up an eks cluster
482:20 - which is a managed kubernetes service
482:21 - and we were to launch this load bouncer
482:23 - it would automatically provision us a
482:25 - network load bouncer and would connect
482:27 - it okay and so this configuration is
482:29 - going to vary based on your provider so
482:31 - if we go back over to here and look at
482:34 - load bouncers notice down below
482:36 - it tells you that if you go here and
482:38 - like you look at gcp aws
482:40 - there are some very particular
482:41 - configurations or for if you want
482:43 - logging or stuff like that so
482:46 - we're not exactly going to be able to
482:49 - be able to do this here but we could try
482:51 - running this i don't know what we'd have
482:52 - to do for the cluster ip here um
482:56 - i mean i guess it's the cluster's ip so
482:58 - if you go to our cheat sheet maybe we
482:59 - get some information here
483:03 - if there's a cluster commands maybe we
483:05 - can do cube ctl cluster info and see
483:07 - what there is
483:11 - so i'll go here and type in micro k8s
483:16 - okay and so
483:19 - i mean it's running
483:21 - 127.0.0.1 i don't know much about this
483:23 - because i haven't really done this yet
483:26 - but maybe we'll know more when we go
483:27 - through here but i figured we'd just try
483:28 - something here i don't think we always
483:30 - need this value here so i'll go ahead
483:32 - and delete this and we'll just see if we
483:33 - can actually run it if it doesn't work i
483:34 - don't care um but i just wanted to give
483:36 - an attempt here to show you but
483:38 - hopefully you understand the idea behind
483:40 - the service load balancer that it's for
483:41 - connecting to external load balancer
483:43 - service we'll type in cube ctl i'm going
483:45 - to type in apply hyphen f we'll type in
483:48 - k8
483:49 - service load balancer
483:51 - yaml
483:53 - and we'll scroll up here and so we can
483:55 - see here is that it says um the service
483:58 - is invalid cluster ips
484:00 - invalid value failed to allocate this
484:03 - value the provided value is not in the
484:04 - range okay so what if we just go back
484:06 - and put this value in again i'm not a
484:08 - networking expert so i'm not sure what
484:10 - we can put in here i'm going to try it
484:11 - one more time and just see if it even
484:13 - works
484:15 - okay so we can't do that so i'm not sure
484:16 - what to set for this right now but if we
484:18 - do get ek set up
484:20 - we'll give this a go but i just wanted
484:21 - to show you the service load balancer or
484:24 - just make an attempt here and explain
484:26 - why
484:26 - we're not going to be able to do this
484:27 - locally now technically we could
484:29 - probably set up nginx plus because it is
484:32 - open source
484:34 - and you can deploy it so if we did like
484:36 - engine x plus
484:39 - kubernetes
484:41 - uh load balancer
484:43 - service
484:46 - there is a tutorial for it on nginx
484:48 - right so we could do this but it's a lot
484:52 - of work i just want to show you kind of
484:53 - the diagram they here have here so
484:56 - um you can see that you have nginx plus
484:58 - load balancer going to the controller
485:00 - going to the pod and
485:02 - i guess the svc somewhere here that's
485:04 - not a very good diagram
485:06 - but if we go down here it should have
485:07 - all the instructions nope this is not
485:09 - the right one
485:11 - let me use this one here
485:14 - i have the link on my other computer i'm
485:15 - just trying to find it very quickly here
485:18 - just to kind of show you how many
485:19 - instructions there were
485:23 - maybe try this one here
485:28 - they're not making it easy for me so i'm
485:29 - just going to pop on my other computer
485:31 - here just so i can see what the link was
485:32 - that i was looking at
485:36 - um
485:42 - so
485:44 - i'm just gonna double check here
485:46 - engine x plus
485:50 - load balancing kubernetes
485:53 - service
485:55 - and just see if i can find the link here
485:58 - i think it's this one
486:02 - yep this is the one so
486:04 - if you were to follow this i think this
486:06 - is how we could actually uh install a
486:08 - load balancer to test it out but it's a
486:11 - lot of work and it's out of the scope of
486:12 - this course so i just kind of want to
486:14 - show you this article showing what
486:15 - they're doing so here they say okay we
486:17 - have some uh
486:18 - nodes here
486:20 - and actually that's something that we
486:21 - haven't even done is ever ran this
486:22 - command let's go back over here and take
486:24 - a look the nodes we have
486:26 - um oh sorry
486:29 - micro k8s
486:31 - okay so we have one there which is kind
486:33 - of interesting
486:34 - and then down below
486:36 - we've actually never ran api resources
486:38 - might be fun to run
486:42 - again micro k8s we need that in the
486:43 - front
486:45 - this is a command that does show up on
486:47 - the um
486:50 - uh exam and so i probably will make a
486:52 - separate follow along and show this part
486:54 - but this shows us all the i guess api
486:56 - endpoints that are available things like
486:57 - that if we go back over to here
487:00 - uh first we choose the first node and
487:02 - add a label to it so they label it here
487:05 - they're using replication controllers
487:07 - which i think are old i don't think
487:08 - you're supposed to use replication
487:09 - controllers anymore in kubernetes
487:12 - they are replaced with replica sets
487:14 - which is what we cover in the course
487:16 - okay so they basically make a replica
487:18 - set
487:19 - uh and what that is doing is launching
487:21 - nginx plus as a pod
487:24 - in your cluster okay
487:27 - and i guess you label it because maybe
487:28 - you're targeting a very particular node
487:30 - for it to run on
487:31 - and then you what you're doing is you're
487:33 - grabbing the docker image so you're
487:35 - saving it i guess they're loading it
487:38 - um they're configuring nginx because you
487:40 - probably have to configure information
487:42 - so you put the stuff in there
487:44 - you go ahead and
487:46 - create the replication set it's a
487:48 - replication controller i'm going to say
487:50 - replication set you can see that the pod
487:52 - is running so that you have a
487:54 - load balancer then you are getting the
487:58 - node information so you're getting the
487:59 - external ip address of it
488:01 - and then you're able to access it
488:05 - and so i guess here they're creating the
488:07 - service so this one i guess would be the
488:09 - load bouncer one
488:12 - i don't see the type so this is a
488:13 - cluster ip address because we don't see
488:15 - the type there
488:18 - um
488:20 - this is i cluster ip none so that makes
488:22 - it a headless one i'm just looking to
488:24 - see if they do load balance here
488:28 - okay so this is definitely not an
488:29 - external load bouncer because if it was
488:32 - they would use load bouncer but i guess
488:34 - the load balancer can i mean i guess it
488:35 - is but i guess load bouncer can only be
488:38 - used with public cloud service providers
488:40 - like the ones that are defined over here
488:43 - if we go back up to the list
488:46 - right so we don't see the nginx plus in
488:48 - the list here so i think that nginx plus
488:50 - is a load bouncer that you can use
488:52 - but i guess that would technically be an
488:54 - internal load balancer because these are
488:56 - all external ones so
488:58 - just to confirm
488:59 - i guess i was wrong with the nginx plus
489:01 - but it is interesting to see that there
489:03 - but uh yeah so the service is really
489:05 - only intended to be the load bouncer
489:07 - type is only intended to be used with
489:08 - external ones there but that's all we
489:10 - need to do for that one and there's one
489:12 - more type for kubernetes which is
489:13 - external name and i guess we'll give
489:15 - that a go next okay
489:18 - [Music]
489:22 - hey this is andrew brown and we are
489:24 - looking still at service but for the
489:26 - last type which is external name so what
489:28 - i want you to do is create a new file
489:30 - here we'll type in service external name
489:32 - yaml
489:34 - okay and we'll open up that file and
489:36 - make our way over back to our service
489:37 - kubernetes page that i hopefully you
489:40 - still have open and we'll type an
489:41 - external name at the top you can just
489:42 - search it and command f to do that and
489:45 - here is that example there so we'll go
489:47 - ahead and copy that code in and so the
489:49 - idea behind external name is is that you
489:52 - have a service that is able to
489:54 - communicate or talk to you something
489:56 - outside of your cluster so maybe you
489:58 - have a database that you're using like
490:00 - you're using on aws rds which is a
490:03 - relational database and so if you had
490:06 - spun up a relational database it takes
490:07 - forever to spin one up so i'm not going
490:08 - to do it but it would have like a host
490:10 - name like a domain name that you could
490:12 - use because you can't um you can't get
490:16 - an ip address from rds it'll only give
490:19 - you a host name like a domain name and
490:21 - so
490:22 - this allows you to say okay
490:24 - i'll have my database here and so
490:26 - whenever the service is hit always send
490:28 - it over to that database okay
490:31 - so what i'm going to do
490:32 - is maybe we can try it with a virtual
490:34 - machine because that might be a little
490:35 - bit easier it will have a host name i
490:37 - don't know if it'll work but let's try
490:38 - anyway
490:39 - okay and what i'm going to do is go
490:41 - ahead and create myself a new ec2
490:43 - instance and so we'll go ahead and
490:44 - launch an instance
490:46 - and
490:47 - we'll give it a moment here we'll say
490:48 - launch instance here i don't know why it
490:50 - didn't take and so the idea is
490:53 - i want to launch a new machine so let's
490:56 - say amazon x2 and i know so we're doing
490:59 - it with the old experience just in case
491:01 - it's the future and you don't have
491:03 - the old view i'm going to give you the
491:04 - new view even though this might change
491:06 - but the idea is that we need a web
491:07 - server so i'm going to call this apache
491:10 - web server and we want it to be amazon
491:13 - x2 i really do not like this but this is
491:15 - how it is it's going to be amazon's 2
491:17 - instance it's going to be 64-bit
491:19 - architecture x86 uh t2 micro is totally
491:22 - fine we do not need to log into the
491:24 - server so proceed without a key pair
491:27 - and
491:28 - we need to have
491:30 - let's see here allow us to say traffic
491:33 - we do not care about ssh traffic but we
491:35 - do want http so that's totally fine
491:37 - because we want to be open on port
491:40 - 80
491:41 - and then down below the storage is fine
491:43 - and then we've got to go to advanced
491:44 - details and this is where we're going to
491:47 - uh go all the way to the bottom this is
491:49 - all new to me too so i'm a bit confused
491:51 - and this is where we're going to enter
491:52 - our user data so what i want to do is
491:53 - install
491:54 - a apache server i've done this a lot of
491:57 - times but i can't remember so what i'm
491:59 - going to do is just go to a github
492:02 - and go to exam pro code because i
492:03 - probably have an example because i've
492:05 - done it so many times we'll go here and
492:08 - i'm just going to search probably in
492:09 - terraform i've done it
492:13 - like there's an abus apache example so
492:15 - this actually this example probably
492:16 - would have it
492:18 - if we go to the user data yaml
492:21 - those are the two commands we want okay
492:22 - so i'm going to copy these over
492:25 - and technically this is a bash script so
492:27 - we're going to just take this out here
492:31 - whoops
492:34 - um
492:36 - i don't know if i have confidence in
492:37 - that i'm going to go back and maybe
492:39 - we've done it in the solutions architect
492:43 - solution
492:47 - free
492:48 - the free
492:49 - i have a bunch of free repos here they
492:51 - should show up so let's take a look at
492:53 - uh we'll open the developer i know it's
492:55 - somewhere in here maybe it's in the
492:56 - cloud practitioner the competition is i
492:58 - think pretty much updated here
492:59 - um we'll try
493:02 - vbc follow along is it in here no
493:05 - and
493:07 - we have this one that one's
493:09 - i don't see it in here
493:11 - here's the developer
493:15 - i'm just looking for that file i know i
493:17 - have it somewhere here user data.sh
493:21 - yep that looks kind of right to me yeah
493:23 - this one's right so this one what this
493:25 - will do
493:26 - is it will um we don't need the ec2 user
493:29 - here but it's going to install apache
493:31 - which is called httpd i know it's
493:32 - confusing and here it can actually
493:33 - create a custom file and then start it
493:35 - up so this isn't the free intimus
493:37 - developer associate i do have a
493:39 - repository for the project we're working
493:41 - on so it will be in there as well so if
493:43 - we go back over to exam pro here
493:45 - i'm just updating as i make the course
493:47 - here so it's not completely completed
493:49 - here but i have this repository here i
493:51 - don't know why it's blank because i
493:53 - definitely uh committed code to this the
493:56 - other day but that's fine this will get
493:57 - filled out and we'll have examples there
493:59 - okay but for the time being i'm just
494:01 - going to go ahead and grab this on in
494:03 - here and we'll paste this in and i don't
494:05 - need all this content all i want here
494:07 - is
494:09 - to um
494:10 - i need this line so that it knows that
494:11 - it's doing bash
494:14 - okay and so we have sudo yum install
494:16 - apache sudo yum or sorry sudo systemctl
494:19 - so startup apache and if the server
494:21 - needs to be restarted make sure that
494:22 - it's there and so that should be enough
494:24 - to do it and so what i'll do is go ahead
494:26 - and launch this instance
494:29 - and we'll just wait for that to work
494:30 - there okay
494:34 - and so we'll go view all instances
494:38 - and so i'm waiting for this to be
494:40 - running and so the idea is that we have
494:42 - this we have the public ipv4 address but
494:45 - that's not what i want i want the
494:47 - the dns name okay so like this is an
494:49 - idea where it's like kind of like a name
494:50 - domain name or something so what i'm
494:52 - going to do is go ahead and copy this
494:55 - and go back to our micro k8s here i'm
494:57 - going to just paste that on in here
495:00 - and i'm going to call this
495:03 - service apache
495:06 - here they have a namespace
495:08 - i'm going to take that out because i
495:09 - want it to be in the default name space
495:11 - i don't want to go anywhere strange
495:13 - and down below here which is something
495:15 - funny so i'm just going to type in clear
495:16 - and we'll go back over to our ec2
495:18 - instance we're going to refresh here
495:21 - and see that it is running i'm i grab
495:23 - the public ipv4 and just make sure that
495:25 - it works
495:27 - okay so see how it's hanging if it's
495:29 - hanging it's either apache is not
495:30 - running or the port is not open oh no it
495:33 - works okay we just had to wait for it to
495:35 - pass so when you have an ec2 instance it
495:38 - has to be running and then the status
495:40 - checks have to pass if we refresh here
495:42 - well
495:43 - it's working but usually you wait till
495:44 - that you get two out of two but we're
495:46 - impatient here and we're just getting
495:47 - ahead of ourselves so it does work at
495:49 - this address and so the idea is um
495:53 - we are going to we pasted that into here
495:55 - and so i'm hoping that this will have an
495:57 - ip address or something and then we will
495:58 - just curl it or wget it and hopefully
496:00 - we'll get the contents of this page
496:03 - so now that we have this
496:05 - external service we're going to type in
496:07 - micro k8s
496:08 - cube ctl
496:10 - apply hyphen f
496:12 - k8s
496:13 - service external
496:16 - name yaml
496:17 - okay
496:18 - and then we will type in micro
496:20 - k8s cube ctl
496:23 - uh get svc to see what services we have
496:25 - here and notice that this one actually
496:27 - has an external ip address now if we got
496:29 - the load balancer to work in the last
496:30 - one which was uh not ready for that yet
496:34 - it would have had an external ip address
496:36 - where it would have showed that address
496:37 - so that you know
496:39 - for the load bouncer to connect to but
496:40 - here we can see that this external name
496:42 - doesn't have a cluster ip address but it
496:44 - points to external ip
496:47 - so i guess my thought is like okay
496:50 - i guess the other services would just
496:52 - resolve to this one if it knew how
496:55 - so i'm just trying to think here because
496:57 - it is external
497:01 - so what i'm going to do
497:03 - is i want to log into the the
497:07 - our busy box pod here just to see what
497:09 - we can see
497:10 - okay so we'll say wget
497:15 - uh clear
497:16 - and i just want to do like a w get on
497:18 - google here.com yeah that's external so
497:21 - i'm not really sure i mean i understand
497:23 - why we have one but i don't understand
497:25 - the use case so i'll be back here in a
497:26 - moment i just want to try to find the
497:28 - reason why okay
497:30 - um
497:31 - like like what can we test to make sure
497:33 - that this is working as expected because
497:35 - i know if we do a w get here this this
497:37 - is gonna work right we do wget
497:40 - oh this is 403 forbidden
497:42 - um is the port not open
497:46 - oh it actually is forbidden yeah so
497:49 - i wonder why we're getting a 403 on that
497:54 - type an exit here
497:55 - if i do a curl on this no that works
497:58 - here
498:00 - huh
498:01 - so we got a 403 forbidden
498:04 - okay well i'll look into it and i'll be
498:06 - back in a moment okay
498:08 - all right so i did a little bit of
498:09 - reading and says when looking up the
498:11 - host name so whatever it's called the
498:13 - cluster dns service returns a cname
498:16 - record with the value to that so it
498:18 - sounds like that we will have a
498:20 - um an address here and so what we'll do
498:23 - is we will go here and type in micro k8s
498:26 - cube ctl
498:28 - um and we'll say describe svc
498:32 - and this one's called service external
498:34 - name and maybe we'll be able to see that
498:36 - information because that's what i don't
498:37 - know
498:40 - um and so i might be t must be typing
498:42 - this wrong so we'll type in uh get
498:45 - svc for services
498:48 - oh it's called service apache
498:51 - i'll see if we get some more information
498:52 - here and so if we scroll on up here
498:58 - we have
499:00 - this here so what i'm trying to
499:02 - understand
499:04 - is how do we get this so when looking up
499:05 - the host because i don't know if this is
499:07 - always just based on this pattern here
499:10 - okay
499:12 - so we have my service prod so i assume
499:14 - that this is the namespace so we're in
499:16 - the default namespace
499:17 - and our service is called
499:19 - service
499:21 - dot apache or hyphen apache svc because
499:24 - it's a service it's in our cluster it's
499:26 - local and so this is what i want to know
499:29 - so we do curl could not resolve so i
499:32 - mean i understand what it's saying here
499:33 - but i don't know uh what to do with this
499:37 - okay so that's what i'm gonna find out
499:38 - next okay all right so after a little
499:39 - bit of digging on kubernetes we have
499:41 - debugging dns resolution so i think this
499:43 - would be the way that we would figure it
499:45 - out but there are a few things here that
499:47 - it says that might not work well so you
499:48 - have to have a kubernetes cluster cube
499:50 - ctl it's recommended to run this uh with
499:52 - at least two nodes and that you're not
499:53 - acting as the control plane host so if
499:56 - you do not already have a cluster you
499:57 - can create one by using minicube so the
499:59 - thing is is that there is only a single
500:02 - node so i'm not sure if we can just spin
500:05 - up another node
500:06 - um
500:08 - and everything i think is just one node
500:10 - because
500:10 - we're not running multi-nodes it's a
500:12 - single it's a single one there so
500:15 - i guess what we can do is we can try to
500:16 - launch this pod here so this is a dns
500:18 - utility and so what they're doing is
500:20 - they're using this and then they're
500:22 - doing an ns lookup
500:24 - right and so i don't know if i can do
500:25 - that from the c2 instance but um this is
500:28 - what i would give as an attempt even if
500:29 - this doesn't work that's totally fine uh
500:32 - it's we're kind of going way out of the
500:33 - scope uh for the actual kcna but if this
500:37 - if we can't get this to work i figured
500:38 - it doesn't hurt to try right so what
500:40 - we'll do is we'll go back over here
500:44 - and um this is dns utils so i'm going to
500:48 - go back over to this here and we'll make
500:50 - a new file here i'll call dnsutils.yaml
500:54 - and i'm going to go ahead and copy the
500:57 - contents here
501:03 - and we'll go ahead and paste this in
501:04 - so it will launch a pods it's not a
501:07 - deployment it's just a pod ds new tills
501:10 - um
501:11 - and here it's pulling a very specific
501:13 - image so it says e uh end to end test
501:16 - image jesse i don't know who jesse is
501:19 - but thank you jesse dns utils 1.3 and
501:22 - then it has a sleep and 3600 so the
501:24 - first thing it does when it launches it
501:26 - sleeps pull if not presence of pull once
501:28 - restart policy so always restart this
501:30 - pod
501:31 - okay
501:32 - so we'll go back to the debugging here
501:35 - and here we can see that it gets
501:36 - deployed in fact it looks like we don't
501:38 - even need to have this file here we
501:40 - could just
501:41 - hold on here
501:43 - we haven't we haven't done an external
501:44 - file so i'm going to go and delete this
501:47 - here whoops
501:48 - and we'll just actually copy this if
501:50 - because if it does that that's even
501:51 - easier right
501:53 - and i'm typing clear
501:57 - and what we'll do is go over here
502:00 - hit enter next to the server was refused
502:03 - um micro k8
502:05 - we'll be doing that all day here so it's
502:07 - created that dns util
502:10 - and so if we go back over to this
502:13 - here
502:14 - we should be able to do a lookup so i'm
502:17 - going to leave whatever the default is
502:18 - actually we'll look up the pod first to
502:19 - make sure that it does exist and get
502:21 - some descriptions here i'm not sure if
502:23 - we'll find any info interesting
502:25 - information about the pod but let's just
502:26 - do it because they're doing it too
502:30 - right so there's the pod we know that
502:32 - it's working
502:34 - and if we go back over to
502:38 - the debug page here we're going to go
502:40 - ahead and copy this now this is for
502:42 - kubernetes default so
502:44 - this should show us something
502:46 - right that's not for the service that
502:47 - we're looking for but we'll go ahead and
502:49 - paste that on in there
502:51 - again micro k8s in the front there if
502:53 - you're wondering how like i'm jumping to
502:55 - the front there i'm actually hitting
502:56 - control a
502:57 - okay so ctrl e oh well it's not doing
502:59 - what i want but control a would jump to
503:01 - the the back control e would jump to the
503:03 - front but control e is overridden by
503:05 - this file command here so we'll type in
503:08 - micro k8s
503:10 - hit enter and so notice that it is
503:12 - resolving here so we have the server and
503:14 - it's going there all right so now what i
503:16 - want to do
503:17 - is i want to delete this out
503:22 - and
503:23 - we have this so this is what i'm going
503:25 - to try
503:26 - see if this resolves anywhere
503:28 - aha and it does and look what it returns
503:31 - our ec2 52 201 234 550 compute one
503:35 - amazoninbus.com and there's the ip
503:38 - address so that looks like that is our
503:39 - server um so the core dns the dns
503:43 - thing that is
503:45 - part of the control plane is definitely
503:47 - resolving to there so that is absolutely
503:50 - working how that works on the app like
503:52 - how we would use that within the app i
503:53 - don't know but that's great to see that
503:56 - that works so i just wanted to make sure
503:57 - that we had a way to validate there so
503:59 - what we'll do is go back to our ec2
504:01 - instance and shut this down so we'll
504:03 - terminate this one here
504:06 - okay
504:07 - and we do not need um
504:11 - the that service running anymore for
504:13 - debugging so i'm going to go and type in
504:14 - micro k8
504:16 - cube ctl get pods because i can't
504:19 - remember the name
504:20 - and we'll just hit up here we'll say
504:22 - delete pod dns utils
504:26 - and that pod will vanish because there's
504:28 - no deployment so there's nothing that
504:30 - will persist it there and so i think we
504:32 - pretty much covered everything i wanted
504:34 - to cover with
504:35 - um the service types because there's the
504:37 - four types and if we have an opportunity
504:39 - to test the load balancer later we will
504:41 - do that
504:42 - but we're definitely going above and
504:43 - beyond and i'm hoping that this really
504:45 - solidifies your knowledge of kubernetes
504:48 - um and i'll see you in the next follow
504:50 - along okay
504:51 - [Music]
504:56 - hey this is andrew brown from exam pro
504:58 - and this follow along we're going to
504:59 - learn how to
505:00 - set up a kubernetes
505:02 - ingress object so ingress as we covered
505:05 - in the course is for um
505:08 - exposing pods externally and so it's an
505:11 - alternative to use from using a service
505:14 - load balancer and actually generally
505:15 - recommended to use um but you know
505:18 - getting one set up is a little bit
505:20 - tricky uh so hopefully we'll figure that
505:22 - out here so i just launched my micro k8
505:24 - environment because michael k it's going
505:26 - to make it really really easy for us to
505:28 - do whereas if we use something else i
505:30 - can't say for certain if it's that easy
505:32 - so we have our environment
505:35 - here and so what i'm going to do here is
505:39 - i'm just going to take a look at what we
505:41 - have running so we'll say micro k8
505:43 - uh cooper cube ctl get pause we'll see
505:46 - if our sinatra pod is running and it is
505:49 - and then we will look if we have a
505:51 - deployment here and we do
505:53 - so let's take a look at what we can find
505:55 - about kubernetes ingress i'm going to
505:57 - tell you the documentation the main page
505:59 - not very good uh for helping you get set
506:02 - up so they do have this thing here and i
506:04 - guess technically it is correct so
506:06 - that's for the nginx but the thing is is
506:08 - that ingress also requires you to have
506:10 - an ingress controller and so you don't
506:13 - have one by default you have to set one
506:15 - up so if we go to ingress controllers
506:16 - here you can see there are a lot of
506:19 - kinds so we have
506:21 - way to bust gce engine x and then
506:23 - there's a whole bunch down below here
506:27 - all right and so we could probably
506:29 - figure out a way to hook up the aws one
506:32 - but that might be a little bit too hard
506:34 - for our developer environment be a lot
506:36 - easier if we were already using eks it
506:38 - doesn't say that we have to cks with
506:40 - this but i would imagine that it'd
506:42 - probably be a lot easier and so there's
506:44 - nginx
506:46 - which is an open source button you can
506:47 - see there's a lot of different ones that
506:48 - we could use but this is probably what
506:51 - we'll end up using which is the engine
506:52 - x1 here so we'll go over here
506:55 - i'm just trying to find the page that
506:57 - has the documentation uh yeah this looks
506:59 - like it so
507:00 - um if you're doing nginx they have a
507:04 - bunch of different ways that you can do
507:05 - it uh based on your provider so we have
507:07 - micro k8s and so
507:10 - you know i showed you all the
507:11 - lightweight distributions but i didn't
507:12 - tell you that you could actually use
507:14 - docker desktop or
507:16 - rancher desktop in order to run your
507:18 - developer environment without using a
507:19 - cloud developer environment um but i'm
507:21 - going to tell you docker desktop is such
507:23 - a pain like an incredible pain to set up
507:26 - um
507:27 - an ingus controller because you have to
507:29 - use i guess it's not that hard but you
507:31 - have this very complex template here i'm
507:33 - just going to show you this and
507:36 - we don't need all of this here it's
507:37 - going to take that out and so this is
507:39 - what is required as you can see there's
507:41 - a lot of stuff going on here in order to
507:43 - deploy our ingress controller so to kind
507:45 - of sift through that and make sense of
507:46 - it would be very hard but the great
507:48 - thing is since we're using micro k8 if
507:50 - we just go up here for a moment we click
507:52 - on the micro case it's as simple as
507:54 - enabling it and basically that script i
507:56 - just showed you that was for the docker
507:57 - desktop basically does the same thing
507:59 - but does it in one line and we know that
508:02 - it's going to work
508:03 - we could take a look at maybe like what
508:04 - minicube does
508:06 - so minicube also has an add-on so that's
508:08 - nice to see i'm not sure what there is
508:10 - for kind or if they even have kind
508:11 - listed here go to aws that might be
508:14 - interesting to see so then it'll be to
508:16 - expose the nginx controller behind
508:18 - service load balancer type so something
508:20 - more interesting going on there but what
508:22 - we're going to do is stick to our micro
508:24 - k8s because it's super easy so i'll go
508:26 - ahead and copy that command we'll go
508:28 - over here paste it on in and we'll
508:30 - enable ingress and so that will install
508:32 - our ingress controller so you can see
508:35 - it's doing a bunch of stuff and so i bet
508:37 - if we looked at the contents of that
508:38 - desktop
508:39 - docker file where we saw that yaml file
508:41 - i bet it was installing all these things
508:42 - so we have a namespace for ingress it
508:45 - made a service account it made a cluster
508:47 - role rbac
508:49 - role-based access control
508:50 - there so we have a role a role binding
508:53 - role binding config map and a daemon set
508:56 - so a lot of stuff is being created there
508:57 - but you can see we didn't have to uh
509:00 - worry about it i just get like uh
509:02 - worrisome when we have those external
509:03 - scripts and we run them because there's
509:04 - so many moving parts
509:06 - but this way it's all set up pretty easy
509:08 - so now that we have our ingress
509:09 - controller what we need to do is set up
509:11 - our ingress resource so if we go back to
509:17 - the tutorial here actually this looks
509:19 - like the up-to-date version so this is
509:21 - the one we are looking for sometimes you
509:22 - might come across one that is older
509:24 - but this one definitely looks correct to
509:26 - me so i'll go ahead and copy this and
509:28 - we'll go back over to our environment
509:30 - i'm going to just make a new file here
509:32 - and we're going to call this um
509:35 - ingress
509:36 - dot yaml we'll go ahead and uh paste
509:39 - that in here so we'll say paste and
509:41 - we'll just take a look at what we need
509:42 - to change so
509:43 - up above we have the ingress type uh
509:46 - minimal ingress that'll be its name this
509:48 - annotation thing so sometimes
509:50 - annotation is just a type of metadata
509:52 - that is sometimes used by
509:54 - tools or providers so this one is
509:56 - particular to nginx
509:59 - as you can see this nginx ingress
510:00 - kubernetes io so there's something with
510:01 - rewriting so you're specifying the root
510:03 - path there
510:05 - then there's the ingress class name so
510:07 - we'll leave that alone that's totally
510:08 - fine
510:10 - then we have our rules
510:12 - so here what we can do is type in
510:13 - sinatra
510:15 - and the path type is prefix which is
510:17 - totally fine and then we're saying
510:19 - where's the back end so we are
510:20 - specifying something
510:22 - so here it's targeting a service so
510:26 - if that's the case we will need a
510:27 - service i'm just going to double check
510:28 - if we can target a deployment i'm pretty
510:30 - sure it always has to be a service
510:32 - because if we go up to the diagram yeah
510:34 - it always goes to here so we will need a
510:36 - service so i have another tab open here
510:38 - and let's see if we actually already
510:39 - have something running so we'll type in
510:40 - micro k8s
510:42 - um
510:43 - cube ctl
510:45 - and we'll type in get sbc
510:50 - and we do we have uh service apache but
510:53 - that is an external name on which we're
510:54 - not using anymore so i'm going to go
510:55 - ahead and delete that one just to kind
510:56 - of clean up what we have here if you
510:59 - have it you can go ahead and delete it
511:00 - too delete svc
511:02 - but what we'll do is whoops um
511:05 - cube ctl micro
511:08 - case
511:10 - must be spelling it wrong today
511:13 - micro
511:14 - k8s there we go and so what we'll do is
511:18 - use that expose command to just quickly
511:20 - create a
511:22 - a
511:26 - a cluster ip service so we'll have
511:27 - expose
511:29 - deploy
511:30 - and we need the name of it so it's
511:31 - called sinatra
511:33 - and then we need the port so the port
511:35 - will be 8080 and then the target port is
511:38 - going to be 80 or sorry 4567 okay and so
511:43 - it'll say here
511:44 - still typing micro k it's wrong
511:46 - micro
511:48 - okay eights
511:50 - there we go and so now what i'll do is
511:52 - type in micro k8 cube ctl
511:56 - get
511:57 - svc
511:58 - we can see that it's there i'm just
511:59 - going to describe it i just want to see
512:01 - that the endpoints are there so we don't
512:02 - have any problems there is an endpoint
512:04 - so it must be going to the correct pod
512:06 - so we are in
512:07 - aok shape
512:09 - and we'll just go back up there and just
512:10 - type in get again there so it's called
512:12 - sinatra so if we go back to our ingress
512:15 - we're going to target these sinatra
512:18 - and uh the port it operates on is 8080
512:21 - right
512:22 - and so what we'll do now is just save
512:24 - that and we'll go ahead and deploy
512:27 - our ingress so going back over here to
512:29 - the other tab here it doesn't matter
512:30 - what tab we do it on it just that's the
512:32 - tab on so we want micro
512:34 - k8 cube ctl
512:36 - um apply hyphen f and by the way we've
512:39 - been doing apply this entire time we
512:40 - could probably use create so
512:42 - apply is just does create and modify and
512:45 - so create it's just if you only want to
512:47 - create um you know like if you ran it
512:50 - twice it would create two resources
512:51 - where uh modify if it already had the
512:53 - same name it would i wouldn't do it
512:55 - twice
512:56 - but i guess we can try that for fun just
512:58 - because i haven't been using that at all
513:00 - and so here it says that it's created
513:02 - the minimal ingress and so we will now
513:04 - type in micro k8s cube ctl get um
513:10 - ingress
513:11 - and so here we have our ingress here and
513:13 - maybe we can describe it a bit more and
513:14 - see if there's any additional
513:15 - information that might be interesting to
513:17 - look at
513:18 - and so if we just scroll up actually we
513:21 - don't scroll up at all but here it's
513:22 - launched the the default namespace
513:24 - default backend port 80 endpoints
513:27 - default http backend not found
513:30 - um which might not be a problem i don't
513:32 - know if this error actually matters um
513:34 - and then we have four slash sinatra
513:36 - and here you can see it's pointing to
513:38 - the back end sinatra's service name port
513:40 - 8080. so let's take a look and see if it
513:42 - works so
513:43 - this should be all exposed on the local
513:46 - host and so
513:48 - i think we'll be on port 80 or just
513:49 - localhost in general so i think that we
513:51 - can just type in his curl localhost
513:54 - and notice it says not found and so
513:56 - nginx is working it is going to the um
514:00 - ingress controller
514:02 - which is engine x but let's now go and
514:05 - type in forward slash sinatra
514:08 - sinatra
514:10 - okay and that didn't work so we'll type
514:12 - in now 8080 sinatra
514:15 - okay cinatra
514:18 - so it looks right to me i'm just going
514:19 - to go double check what i wrote
514:22 - oh you know what it was i think what we
514:24 - need we might need the protocol in here
514:25 - because it's not going to know what
514:26 - protocol if it's http or https so i'm
514:28 - just going to try this
514:31 - and
514:32 - [Music]
514:34 - it's not giving us what i want it's
514:36 - localhost sin
514:38 - not true i'm gonna double check making
514:39 - sure i'm not spelling anything wrong
514:41 - here
514:41 - sinatra
514:46 - hold on hold on
514:51 - hmm
514:52 - what did i do wrong here
514:55 - because i definitely definitely have had
514:57 - this working uh when i tested before so
515:00 - maybe there's an issue with our cluster
515:01 - let's just double check to make sure our
515:03 - cluster is working so we'll say svc
515:05 - this is a cluster ip here external ip
515:08 - that looks fine
515:09 - um so i know we have our busy box that
515:12 - we were doing before i'm going to see if
515:14 - i can find that here
515:18 - we'll say
515:19 - debug service
515:21 - kubernetes
515:24 - and we'll go ahead and grab our one
515:26 - liner
515:26 - here and we'll go on back here we'll
515:29 - paste that on in
515:32 - and it says connection refuse that's
515:34 - totally fine we'll type in micro kx
515:39 - and we'll do
515:40 - wget oh i don't know what the um
515:45 - oh yeah we do know it's right here okay
515:46 - so what we'll do is just type in wget
515:49 - 8080.
515:51 - okay so it does work cat index html
515:57 - so
515:59 - maybe if we go back up to here
516:04 - maybe this has something to do with it
516:05 - okay default needs to be backend 80
516:08 - endpoints defaults to be back and not
516:09 - found all right so i'll be back here in
516:11 - a moment and see if i can solve it okay
516:12 - all right i'm back and so one thing i
516:14 - notice is that this one sets an ingress
516:16 - class name and when i compared my other
516:18 - code that i found somewhere else it
516:20 - didn't have this field at all and it
516:22 - defaulted to public so i'm thinking that
516:25 - if we change this to public then that
516:26 - will go to the 127.00.1
516:29 - i'll be able to use it that way so
516:31 - that's what i'm going to try here we'll
516:32 - so we'll try to update this
516:34 - so we'll say cubectl apply hyphen f
516:38 - k8
516:40 - ingress and we'll see if that will take
516:42 - um so here it says missing the cube ctl
516:46 - last applied configuration etc etc
516:49 - so it doesn't like it for whatever
516:51 - reason i'm just going to go ahead and
516:52 - delete that line for a second
516:55 - okay it says it's configured but did it
516:57 - change it
516:59 - no it did not so i think in this case
517:00 - what we'll do
517:02 - because i just i'm just curious if we
517:03 - set this to public if it will do what we
517:05 - think we'll do but maybe what we'll do
517:06 - is just delete
517:07 - the um the ingress controller and that
517:10 - might fix our issue here so we'll just
517:11 - say ingress i think it's short for ing
517:14 - if we wanted to do that so we'll say
517:16 - delete ing ingress
517:19 - okay
517:21 - this is all called minimal ingress
517:28 - all right and then we'll just go ahead
517:31 - and reapply this
517:34 - and then we will take a look here
517:37 - so the class is now public but it's not
517:39 - assigning the ip address so what i'll do
517:41 - is just remove this here just because i
517:42 - notice my other one does not have it
517:44 - and we will go ahead and just delete it
517:47 - because maybe it's doing more than just
517:48 - that if you specify the class
517:52 - okay
517:55 - and still no i p address interesting
517:59 - but even though it is a public class
518:00 - let's go ahead and just try it anyway
518:02 - for fun
518:03 - localhost sinatra
518:08 - oh it works there we go okay so i'm not
518:10 - sure why the ip address is not showing
518:12 - up here
518:13 - 1270.0.1 but i think that class has
518:15 - something to do with it there's another
518:17 - thing where you can set the class and
518:18 - the annotation uh so you can see there's
518:20 - some variation there
518:22 - notice like we can do curl we can do
518:26 - you can put http in front of here if
518:27 - you'd like this is running on port 80.
518:29 - so we didn't specify port 80 but that is
518:32 - just if it's public i suppose that's
518:34 - where it would go by default and we have
518:35 - rules for http and so that is port 80 uh
518:39 - which is what we'd be using by default
518:41 - here um so that's ingress for you so
518:44 - hopefully that wasn't too hard but uh we
518:46 - did get through it and we're all good
518:48 - okay
518:49 - [Music]
518:54 - hey this is andrew brown from exam pro
518:56 - and in this follow along what we're
518:58 - going to be taking a look at is jobs and
519:00 - cron jobs so what i want you to do is go
519:03 - the top here and type in kubernetes
519:05 - jobs and this should bring us to
519:08 - hopefully the jobs page here maybe we
519:10 - can take a look at this one as well uh
519:12 - and so we have some example jobs
519:15 - okay this one's a little bit more
519:17 - complicated which is fine but we'll also
519:18 - go to the cube ctl cheat sheet
519:21 - okay because in the um
519:25 - in the course i do use to the samples
519:27 - from here we just type in job
519:29 - and so
519:31 - here we have one where it says create a
519:33 - job which prints the word hello create a
519:35 - cron job that prints
519:36 - hello world every minute okay so what
519:39 - we'll do is we'll go ahead and copy this
519:41 - first one here
519:42 - and you can see it's cube ctl create job
519:45 - hello maybe we'll just type it for fun
519:48 - uh just so that we get better at
519:50 - remembering what is what so we'll type
519:51 - in micro k8s
519:53 - uh cube ctl create job we could do apply
519:56 - i suppose but jobs they run and they
519:59 - they die so i don't think you'd really
520:01 - be updating them maybe you'd be updating
520:03 - this one and using apply so they have a
520:05 - name called hello
520:06 - so we'll just copy the rest there to
520:08 - make our lives a bit easier
520:10 - okay hello hyphen hyphen image equals
520:13 - busy box so that should resolve probably
520:15 - go to docker hub and there's one called
520:17 - a busy box so a lot of times we were
520:19 - using the one that was sourcing google
520:20 - but i think we could just do that as
520:22 - well and so it will run the echo command
520:25 - and it should work so we'll hit enter
520:27 - and it says job.batch hello created
520:30 - notice we don't see where the output is
520:32 - i'm not really sure where we would
520:33 - observe that but let's just take a look
520:34 - here and maybe type in describe
520:41 - okay but you can see here it says job
520:43 - completed completed and it ran the
520:45 - command echo hello world of course we
520:48 - didn't see it but we can see that it did
520:49 - pass that in as the initial command so
520:52 - it definitely did operate that
520:55 - now the next question would be to take a
520:56 - look at um
520:58 - let's just take a look at all of our
520:59 - jobs here for a moment but to run the
521:01 - one on a schedule so here says hello one
521:03 - out of one duration two and age so go
521:06 - back over here very similar um but we
521:09 - have this very interesting looking thing
521:10 - and that's a cron job so cron job cheat
521:14 - sheet i wonder if there's something that
521:15 - we can just show you really quickly here
521:18 - so if you've never seen a cron so cron
521:20 - is part of linux so the idea is that
521:22 - it's a it's a um a thing called cron tab
521:25 - and
521:26 - uh what you're doing is you're saying
521:28 - okay run this on a schedule and there's
521:30 - this thing where you specify the time in
521:33 - minutes hours days month uh
521:36 - monday it's a month month and weekday
521:38 - right so if you have the value zero here
521:41 - which is uh minutes
521:43 - um
521:44 - i guess that's way hold on one two three
521:46 - four five one two three four five
521:49 - so this says every hour
521:52 - uh so zero i guess
521:54 - is one
521:56 - that's interesting you'd think it'd be
521:58 - like if you put a one that'd be every
521:59 - hour but i guess it's zero based on how
522:01 - the numbers are i'm not sure if it shows
522:03 - all the information and oh yeah here we
522:04 - go
522:05 - zero so minutes zero to you really think
522:08 - this would be one because it says hours
522:11 - why is this every hour okay
522:13 - whatever uh so then we have this one
522:15 - here it says uh
522:17 - uh four slash fifteen so every 15
522:20 - minutes
522:21 - uh then you have zero
522:22 - whatever so you kind of get the idea
522:24 - here i don't fully understand the logic
522:26 - here i've done this for years but i
522:28 - always have to look it up
522:30 - but just to show you if you want to read
522:32 - that yourself but we'll go back to the
522:33 - cheat sheet here if we read this
522:36 - they say every minute so
522:39 - i guess that makes sense because if you
522:41 - took an hour and divided it by
522:45 - one did you get that well anyway that's
522:46 - what it says it does but you know this
522:49 - is not so important to know for the exam
522:51 - but just to understand that that's where
522:52 - that logic comes from if you want to
522:55 - learn it on your own you can totally do
522:56 - that so what we'll do is hit enter
522:58 - and oh we have to type in micro k8
523:04 - all right and then we'll hit uh
523:08 - does that look great micro case yeah
523:09 - enter
523:10 - and so what we can do now is to get the
523:12 - jobs
523:14 - oh maybe we have to do crown job for
523:15 - this
523:16 - we do so there it is
523:18 - and so it says last scheduled it is
523:20 - active i assume it's active um but i
523:23 - guess we'll just wait here a little
523:24 - while and see
523:26 - when it does trigger while that is going
523:28 - on
523:29 - let's take a look at what it looks like
523:31 - to create a cron job file
523:33 - so you use batch version one you have a
523:35 - job
523:37 - metadata you specify your container
523:39 - image name command
523:41 - whether it should restart or not
523:43 - and back off limit so
523:45 - you know if it fails then it will retry
523:47 - after a certain amount of time it
523:49 - probably does exponential back off i'm
523:50 - not sure if it's uh every few
523:53 - seconds or whatever so in that sense you
523:55 - can make a job that is reoccurring in in
523:57 - some sense there
523:59 - but yeah that's pretty much all there
524:00 - really is to jobs but we just want to
524:03 - observe this thing works
524:06 - okay and notice that the one minute's
524:07 - going to come up here in a moment ah so
524:09 - it just ran so it says one active last
524:11 - scheduled so let's see if we can get a
524:14 - describe since there's only one it
524:15 - should pull the first one there notice
524:16 - we haven't been specifying the name at
524:18 - all
524:19 - okay
524:20 - because usually you'd write the name
524:21 - whatever it is right and i don't know
524:23 - what the name is it is called hello
524:25 - so we'd say like hello
524:27 - right
524:28 - and let's just take a look at what we
524:29 - have here so namespace is default no
524:32 - labels no annotations that's our
524:34 - schedule
524:35 - currency policy allow
524:38 - uh suspend false
524:41 - nothing super exciting here you can see
524:43 - what the pod is
524:44 - last scheduled time so last time it ran
524:46 - whether there's a job that's active
524:48 - right now
524:49 - and then we have events here so it says
524:50 - create a job saw a completed job i would
524:53 - think that if this runs multiple times
524:55 - we'll see this kind of like a list
524:57 - but um
524:58 - what we'll do is just go back to get
525:02 - so probably trigger very soon
525:05 - uh so when it's actually active it's one
525:08 - and then when it's not active it's zero
525:10 - so this doesn't count up like to say oh
525:12 - it's ran four or five times it's just
525:14 - true or false zero or one right
525:16 - um
525:18 - so we'll do is just hit up here
525:20 - go back to describe because it might
525:21 - have already ran again yeah so here it
525:23 - is you can see that it's starting to
525:25 - um pile on there i'm just curious like
525:28 - uh time to cron uh cron expression
525:33 - just wondering if there is a tool there
525:34 - that we can use okay so let's say we
525:37 - wanted it to be every single
525:40 - um
525:41 - every second
525:45 - is it changing real time okay so it'd be
525:47 - this okay cool
525:50 - let's say you want to do every minute
525:53 - which you want to do every hour
525:56 - okay so i'm not saying i can make sense
525:59 - of this
525:59 - at one point i did know how these uh
526:01 - chronic expressions work but i'm sure if
526:03 - you really wanted to know yeah here they
526:05 - all are uh you could uh look up and try
526:07 - to understand the syntax there but again
526:09 - out of the scope of this and we
526:10 - understand how to run a job in a cron
526:12 - job i think what we'll want to do is
526:14 - just destroy that crown job so it's not
526:16 - constantly running
526:17 - so we'll just say
526:20 - delete quran
526:22 - job hello
526:25 - i'm not worried about the job one
526:26 - because it ran and then it stopped so
526:28 - that's okay there and um i guess that's
526:31 - it for jobs okay
526:33 - [Music]
526:37 - hey this is andrew brown from exam pro
526:39 - and we are back with another follow
526:40 - along and this time we're looking at
526:41 - replica sets so technically we've
526:43 - probably been using replica sets if we
526:45 - go back to our deployment file
526:46 - originally here again we are in the
526:48 - micro k8 environment i don't know if
526:49 - we'll ever be using mini cuber kind now
526:51 - that microcades works so great but um
526:54 - here it's not specifying the
526:57 - replicas account but generally if you
526:59 - were just to add
527:00 - a value i think right here like replicas
527:04 - you could then say okay create a replica
527:07 - set underneath and that's how you would
527:08 - create a replica but let's go take a
527:10 - look at replica sets um kubernetes here
527:15 - and see if we can specify one manually
527:16 - now you never would do this in practice
527:18 - you'd always use a deployment but just
527:20 - to show you that you can do it right so
527:22 - if we go ahead and copy the contents
527:25 - here of this one here and we'll make a
527:27 - new one and we'll call this a new file
527:29 - replica set
527:32 - yaml
527:34 - okay and we go ahead and paste that in
527:36 - there we can kind of read it and see
527:37 - what's going on here so we have some
527:38 - metadata
527:40 - um so we have labels like names like go
527:43 - say name
527:44 - sinatra
527:46 - rc
527:48 - and we'll just say sinatra rc
527:52 - and here we can see how many we want to
527:54 - run
527:55 - and then we i guess we need to have a
527:56 - selector um and so
527:58 - [Music]
528:01 - i'm just trying think here match labels
528:03 - template oh yeah probably they just
528:05 - these probably just have to match the
528:06 - template like this
528:11 - okay
528:13 - and then we can go to our deployment and
528:15 - just grab our container image here
528:25 - and i think that should work
528:27 - so that should launch us three pods in a
528:29 - replica set that are managed
528:31 - okay so we'll type in micro k8s cube ctl
528:36 - um
528:38 - get
528:39 - or sorry apply hyphen f
528:42 - k eights
528:44 - replica set yaml and we'll see if that
528:46 - works it looks like it worked no problem
528:47 - there and so we'll type in micro k8
528:50 - cube ctl
528:53 - get
528:55 - uh rc for replica sets or maybe it's rs
529:00 - there we go and so here's the one that's
529:02 - for the deployment right and then here's
529:04 - the one for rc so even though we never
529:07 - specified replicas originally here it
529:09 - did set up a replica set for one to one
529:12 - and then here you can see the replicas
529:14 - that are is set to i wrote rc i should
529:16 - have wrote rs we have the desired
529:18 - current and ready so generally desired
529:20 - means like go back to that's generally
529:22 - what you want to be running
529:23 - so
529:24 - um again we don't really want to be
529:26 - doing it this way so i just wanted to
529:27 - show you that you could do it that way
529:30 - so we'll just say cube ctl delete
529:33 - rs
529:35 - and delete that replica set and just so
529:37 - this is less confusing if we ever go
529:39 - back to this file we'll type in rs
529:42 - i think the reason i wrote rc because
529:44 - the old one was called replication
529:46 - controller so at the top here um
529:49 - maybe not here but notice here this
529:51 - replication controller this was replaced
529:53 - with replica set and that's probably why
529:54 - i wrote rc
529:56 - but
529:57 - rs is the new way of doing it
530:00 - so now let's take a look at how we would
530:02 - um
530:03 - modify this file here so if we go over
530:05 - here
530:06 - and we already changed the two so i'll
530:07 - just save that file and if we were to
530:09 - type in micro
530:11 - k8s
530:14 - cube ctl
530:16 - update or no sorry apply hyphen f
530:19 - because that will do a modify and update
530:21 - essentially
530:22 - and then we'll do our deployment here
530:24 - and that should update our replica set
530:28 - to now have two so see the desired is
530:30 - two and so if we go check our pods
530:33 - we should now have a second one trying
530:35 - to run and it is
530:38 - okay
530:43 - all right and so that's pretty much all
530:45 - i really want to cover about replicas
530:46 - that's right now of course there's more
530:47 - to it um and we'll see that when we look
530:50 - at scaling okay
530:53 - [Music]
530:58 - hey this is andrew brown from exam pro
531:00 - and we're doing a follow along and this
531:01 - time it's all about scaling and also
531:04 - using hpa the
531:06 - horizontal pod auto scaler so just make
531:10 - sure you launch your micro k8
531:11 - environment that we've been using uh
531:13 - this entire time so i'm going to type
531:15 - clear here and so what we'll do is look
531:18 - up the scale command kubernetes and so i
531:22 - haven't been showing this uh throughout
531:24 - this but there is
531:25 - um like a cube ctl commands
531:29 - a reference
531:30 - let's see if we can find it here
531:32 - and so this is really useful if we ever
531:34 - want to just kind of see examples
531:36 - and so there is a scale command and then
531:38 - there's an auto scale command so if we
531:40 - look at scale
531:42 - down below setting new size for the
531:44 - deployment replica set replication
531:45 - control or stateful set so you know when
531:48 - we did it uh in the last um like the
531:50 - last volume of the replica sets that we
531:52 - ch we changed this to replica set or
531:54 - replicas 2 and then did apply so this
531:56 - basically does the same thing
531:59 - um except it doesn't update this file of
532:01 - course our original file but it will uh
532:04 - update what's in the cluster so if we go
532:06 - here
532:08 - we type in micro k8s cube ctl scale
532:13 - and then we'll go over to our reference
532:15 - here and take a look at how it works
532:17 - um
532:18 - here we can see hyphen hyphen replicas
532:21 - so we can just specify the new amount
532:25 - replicas
532:27 - and maybe we would say four
532:31 - and
532:32 - then i'm just trying to look so i'm
532:33 - assuming it's going to be whatever the
532:35 - resource is forward slash the name
532:38 - so we probably type deploy or deployment
532:40 - and then it's going to be sinatra
532:43 - and so it says that it has scaled
532:45 - all right and so if we go take a look
532:49 - i don't think you can uh yeah hold on
532:50 - here we'll we'll go
532:52 - get deploy
532:53 - and see what it says here so notice it
532:55 - says two out of four already so it is
532:59 - working on deploying the rest of those
533:02 - it says two out of four ready for up to
533:04 - date two available
533:06 - ah there we go just have to take some
533:07 - time and it will say get pods
533:11 - right so we see there are four pods and
533:13 - then we can go get svc
533:16 - and then from there we could um take a
533:19 - look oh sorry i wanted to look at the uh
533:23 - replica set and there's four out of four
533:25 - and if maybe we'll just describe it for
533:27 - fun
533:28 - replicas that
533:34 - okay and
533:35 - you can see
533:38 - some information here that it says
533:40 - replication controller under so i guess
533:41 - it was a replica set controller sorry i
533:43 - almost got confused with replica
533:45 - replication controller there so nothing
533:47 - super interesting here but um you know
533:51 - that's all great
533:54 - so that's scale uh one thing i'd like to
533:56 - show you is what happens when you have
533:59 - an svc that has multiple um pods uh just
534:03 - to show you that we have all our
534:04 - endpoints here okay because when we
534:06 - looked at it before we saw one but if we
534:07 - have four pods one two three four we
534:10 - should see four and we do which is great
534:13 - so we looked at scale and let's take a
534:14 - look at auto scale so if we go up here
534:21 - so auto scale is going to create us um a
534:24 - horizontal pod auto scaler so let's type
534:26 - in hpa kubernetes
534:29 - here and see if we can find an example
534:35 - that's a resource
534:42 - don't see one here one moment
534:45 - let's see if there's one in the
534:46 - walk-through
534:48 - so here they have a deployment and a
534:49 - service
534:52 - so i want to show you the code ah here
534:54 - it is okay so
534:56 - here's an example of a horizontal pod
534:58 - autoscaler
535:00 - so the idea is you're setting the scale
535:01 - target reference
535:03 - you're saying
535:04 - you're targeting the deployment for it
535:06 - you're setting the min replicas the max
535:07 - replicas and then you can say all right
535:10 - you should scale up
535:12 - if the utilization exceeds whatever it
535:14 - is beyond 50 right and so that's an
535:16 - example there i thought i had more like
535:18 - a streamlined example here i'm just
535:19 - going to go double check my other
535:21 - computer
535:22 - to see what i have
535:24 - and i didn't save it but i know it's
535:26 - generally this okay so
535:29 - this is something we can write out but
535:30 - there's an easier way which is using the
535:32 - autoscale it's basically going to just
535:33 - create
535:34 - this file here
535:36 - so what we'll do is do a cube
535:38 - cube ctl autoscale so we'll go back over
535:41 - here
535:42 - and actually we didn't scale down our
535:45 - pod so what we'll do is go back to
535:47 - our scale
535:49 - we did here a moment ago
535:52 - and i want to just put this to one okay
535:55 - and then we'll go and make sure that
535:57 - it's scaled down so it'll say describe
536:00 - deployment
536:04 - describe deployment
536:06 - sinatra
536:11 - or i guess we'll just do get because
536:12 - it's a bit easier to see that
536:16 - okay so we have one and one so now let's
536:18 - say we wanted to set up auto scale so
536:20 - that's going to be micro k8s
536:23 - cube ctl
536:25 - um
536:28 - autoscale
536:30 - and then we'll need to figure out all
536:31 - the other options here so
536:34 - if we scroll up it probably shows us a
536:36 - very simple example
536:38 - oh yeah the name right what do we want
536:40 - to autoscale so we'll say deployment
536:43 - replica
536:45 - or sorry uh sinatra
536:49 - and then here we'll base it off the cpu
536:52 - percent
536:57 - and then
536:59 - we can set our min or max right
537:02 - and what i'm going to do is i'm going to
537:03 - set it to 2 so that it'll automatically
537:05 - scale up to 2 because it'll expect there
537:06 - to be at least 2
537:08 - and we'll hit enter
537:10 - and notice that it created created an
537:12 - auto scaler so um
537:14 - what we can do is type in micro k8s
537:17 - uh cube ctl hpa for horizontal pod
537:21 - autoscaler
537:22 - um
537:24 - or maybe get in front of it first
537:27 - and so here it says unknown targets
537:29 - because it's still trying to figure out
537:30 - the targets i suppose two mins max pods
537:32 - replicas we can see that it is going to
537:34 - the right place
537:38 - okay if we know that this is working we
537:39 - can just go get pods and see how many
537:41 - pods are running
537:43 - so notice there are two pods
537:46 - i'm not sure why the target is unknown i
537:48 - don't know if we have to have something
537:49 - additionally installed for it to know or
537:52 - this just it needs to collect more
537:54 - information over a period of time but we
537:55 - can see that this works so it's as
537:57 - simple as that
537:58 - if we were to try to flood traffic
538:01 - towards those
538:03 - containers or pods i should say then it
538:05 - should spin up another one we're not
538:07 - going to do that because it is a bit
538:08 - complex uh to do that and it's kind of
538:11 - out of scope here
538:12 - and so what we'll do is just get rid of
538:14 - this hpa that we created here
538:19 - actually before we do that i just want
538:20 - to show you the edit command which we
538:21 - haven't really been using much so if we
538:23 - do edit hpa sinatra
538:26 - this will open in a local editor so it's
538:28 - i think using bim is this vim yeah it's
538:30 - vim and it looks very similar to our
538:32 - definition file but this is actually
538:34 - basically the definition file and active
538:36 - data here so you're going to see
538:37 - additional information
538:39 - uh here and so you can actually edit
538:41 - this uh like you i could change the
538:44 - value here maybe change um
538:46 - the minimum
538:47 - to three and i think that it will take
538:50 - effect right so i edited it and if i go
538:52 - hpa notice that the min pods is now
538:55 - three
538:55 - so generally you don't need to edit
538:57 - things on the fly like that but it is
538:59 - possible for you to do that if i go over
539:01 - back to our pods get pods
539:04 - we should see that there is now three
539:06 - running so what we'll do is go ahead and
539:08 - delete
539:09 - hpa
539:12 - sinatra
539:14 - okay and then it should go back to the
539:16 - right amount of pods
539:18 - let's see if it'll actually do that
539:23 - what if we have to scale it down
539:28 - okay
539:28 - and i think the reason why is because if
539:30 - we go to our deployment
539:33 - and we describe it
539:35 - again we only have one so we don't have
539:36 - to specify the name
539:38 - i think it has like a min and a max in
539:40 - here
539:41 - three desired three updated three total
539:45 - three available
539:50 - maybe because we scaled it to three from
539:51 - before i can't remember why so what i'm
539:53 - going to do here is just scale it back
539:55 - down to one so we'll type in scale
539:58 - deploy
539:59 - forward slash sinatra
540:02 - and we'll just say replicas equals one
540:06 - and then we'll go back to our pods
540:09 - and now we only have one pod so you know
540:11 - hopefully that gives you a clear idea
540:13 - how horizontal pod auto scalers work
540:16 - they can get quite complex because there
540:18 - is more logic that can be implemented
540:20 - with
540:21 - auto pod scalers
540:24 - i don't know if we'll do a vertical pod
540:25 - scaler i'm not sure if that's really
540:27 - that necessary uh i haven't decided yet
540:29 - but anyway you can see there's a lot
540:31 - more fancier rules that you can
540:33 - implement for horizontal pod scaling
540:35 - but yeah there you go
540:40 - hey this is andrew brown and in this
540:42 - follow along we're going to be taking a
540:44 - look at how to use config maps so just
540:46 - make sure you're a micro k8 environment
540:48 - and so i am in mine here and i think i'm
540:51 - going to actually need to use the k8
540:52 - environment as well because that's where
540:54 - we created our
540:55 - original uh docker file we might need to
540:57 - do an update there but the idea is
541:00 - config maps allow you to pass data into
541:03 - multiple pods so you have consistent
541:04 - data across your containers so what
541:07 - we're going to do here is just type in
541:08 - config map kubernetes
541:11 - and we'll go here
541:12 - and we'll take a look here and so here's
541:14 - an example of a config map so we'll just
541:16 - copy the contents here
541:19 - we'll go over here and we'll say
541:21 - new file
541:22 - configmap.yaml
541:25 - and we will go ahead whoops uh
541:27 - reload and we'll just paste this content
541:29 - in here so this looks a bit confusing
541:31 - but the idea is that you have your data
541:33 - and then you can have a key and a value
541:36 - but then you have some values that are a
541:37 - little bit more complex and the reason
541:39 - why is that um these will turn into like
541:41 - json or yaml file formats not super
541:44 - important for the scope of what we're
541:46 - doing so i'm just going to simplify this
541:48 - so it's not as complicated and what i'm
541:50 - going to do here well we might leave
541:51 - actually it in because i don't think
541:52 - it's going to hurt anything if we do
541:54 - leave it in hold on here and i'm just
541:56 - going to go ahead and just
541:58 - leave it in maybe we can view it as yaml
542:00 - but i want to
542:02 - set a message here and we'll just say
542:04 - um
542:05 - uh
542:06 - i remember like how do you say
542:08 - how do you say hello in bar soon
542:13 - okay
542:15 - so hello
542:21 - okay so if you don't know bar soon
542:22 - barsoon is the uh mars books i think
542:25 - it's bar soon that's how you pronounce
542:27 - it
542:27 - and so we'll say
542:29 - bar soon and that's basically saying
542:31 - like hello mars okay
542:33 - and so the idea is that we will update
542:35 - our original file to consume that
542:37 - environment variable so if um
542:40 - we'll say like hello message maybe
542:42 - is a better name here and actually just
542:45 - to make things a bit easier for me so i
542:47 - don't have to kind of guess what it is
542:48 - i'm just going to type it in all caps
542:50 - hello message
542:52 - and so what we'll do is go back to our
542:53 - original k environment and this is where
542:57 - yeah we created our app and so in our
542:59 - ruby app what we can do is
543:01 - do something slightly different i'm
543:03 - going to do env
543:05 - [Music]
543:07 - oops
543:08 - single quotations here it's being a
543:10 - little bit silly and so if there is an
543:12 - environment variable it will use that
543:14 - otherwise
543:15 - use hello world i'm gonna just put an
543:17 - extra exclamation mark here so that we
543:19 - know that it's working and so that
543:20 - shouldn't cause any issues so we'll
543:22 - double check make sure this works we'll
543:23 - cd into that directory here we'll do a
543:26 - bundle
543:27 - install shouldn't shouldn't need to but
543:28 - we'll just do it for fun
543:30 - um
543:35 - okay
543:36 - let's see here um
543:39 - could not find bundler
543:42 - oh okay oh sorry rvm list so rvm used uh
543:47 - 3.1.0 remember i couldn't default it
543:49 - before i just didn't want to look it up
543:51 - because i figured we weren't going to be
543:52 - going back here too often and now we'll
543:54 - do a bundle install make sure
543:55 - everything's fine
543:56 - and then i'll do bundle exect
543:58 - ruby sinatra just to make sure that it
544:01 - or sorry a server just to make sure that
544:02 - it's working correctly
544:04 - and then on a new tab here i'm just
544:06 - gonna make a new file tab here i think
544:07 - this is running on port 8080
544:10 - yes so we'll just do a curl oops
544:13 - that's a file i want a terminal
544:16 - we'll do a curl localhost 8080 and it
544:20 - says hello world the double exclamation
544:21 - mark okay
544:23 - now if we were to pass an environment
544:25 - variable we'll just double check to make
544:26 - sure that works so what we can do is go
544:28 - to the front of it and type in hello
544:31 - message
544:32 - equals
544:34 - new message
544:36 - okay
544:37 - maybe double quotations here i'm not
544:39 - sure if it'll take double or singles
544:41 - and we'll go back over here and we will
544:43 - hit up make sure that our app works it's
544:45 - not taking it one second here uh maybe
544:47 - we don't need the semicolon maybe we'll
544:49 - just take that out like that
544:54 - there we go all right so
544:56 - it is accepting um environment variables
544:59 - so now what i want to do is i want to
545:02 - repackage that docker file so i think we
545:04 - might have wrote it in here no we did
545:05 - not just came with it and so i'm going
545:07 - to write
545:08 - um bundle
545:11 - docker
545:12 - or sorry docker build hyphen t or sorry
545:16 - period hyphen t
545:18 - um
545:19 - we called it sinatra yeah i don't
545:21 - exactly remember so what i'm going to do
545:23 - is just go over to the console here open
545:25 - a new tab we'll go over and go grab it
545:27 - from ecr just because if i make a typo
545:29 - here it's always a big pane to fix so
545:31 - we'll go to our container registry here
545:35 - and we will go into our app here we'll
545:38 - view the push commands we'll take a look
545:40 - here and this is the one i want
545:42 - so that way i'm not making any mistake
545:44 - okay
545:48 - and i'll make sure i'm in the k8
545:50 - environment here and we'll go ahead and
545:51 - just erase that out there hit enter and
545:54 - that's going to build that new one and
545:56 - then what we can do is then copy these
545:58 - next lines here and have a really easy
546:01 - time so go ahead and paste that in
546:03 - and we'll go ahead and paste this in
546:06 - okay and so now we have our
546:08 - your authorization tire is
546:10 - expired that is totally fine if that
546:11 - happens we just go back to the top here
546:13 - and we paste that on in okay hit up up
546:17 - to go to the last one there and now it's
546:18 - just pushing the updated version there
546:21 - so now that that's all updated what i
546:23 - want to do here is i want to double
546:25 - check my deployment file and see if it's
546:27 - set to always yeah always pull the
546:29 - public image
546:30 - and so what we can do
546:32 - here again we're back in the micro k8s
546:34 - we're going to go ahead and just delete
546:36 - our deployment so we'll say micro kx
546:39 - um cube ctl delete deploy sinatra
546:44 - and then what we'll do is say cube ctl
546:47 - apply hyphen f
546:49 - k 8
546:51 - deployment
546:52 - and so that should pull the latest image
546:55 - it didn't seem like it did though
546:57 - usually it would say like downloading or
546:58 - something maybe it is pulling it
547:01 - but what we'll do here is just
547:04 - get
547:06 - our pods
547:11 - and wait for it to run so maybe it is
547:13 - pulling because it is taking some time
547:15 - so let's say describe deployment see
547:17 - what's happening
547:24 - i don't know if we can see the the
547:26 - images here docker images
547:28 - no it doesn't show them
547:31 - okay um also maybe this has changed so
547:34 - that's something that we should just
547:35 - double check
547:39 - okay so if i go into here
547:43 - oh yeah that's way different okay
547:46 - so what we'll have to do is just paste
547:48 - that on in there
547:50 - does that say latest it doesn't say
547:51 - latest
548:00 - maybe we just click in the latest there
548:02 - yeah okay so it should take it i just
548:04 - want to double check to make sure i
548:05 - think because like that was a very
548:06 - particular version and i would i didn't
548:07 - click into that we pasted that in there
548:09 - yeah this is the same thing
548:11 - so
548:12 - um i mean we should be in good shape so
548:14 - let's just double check here and say get
548:16 - pods i just can't believe it pulled that
548:18 - fast right like i figured we'd see like
548:20 - a message like pulling the image or
548:21 - something
548:22 - so then what we're going to know is if
548:24 - we kind of expose this and take a look
548:25 - here do we still have our ingress
548:26 - controller running
548:28 - ingress
548:29 - oh we do nice okay so if that's the case
548:32 - then what i'm going to do here is just
548:33 - do um
548:36 - curl local host forward slash sinatra
548:40 - ah we have our double exclamation mark
548:42 - so it is definitely
548:43 - uh using the latest image so now we are
548:45 - set up and so the idea with our config
548:47 - map is we're going to create this and
548:49 - then we want to get this message to show
548:51 - up here
548:52 - um this will just be like config map
548:54 - data here
548:55 - name that there and so what we'll do
548:57 - is type in um
549:00 - micro k8s
549:02 - cube ctl apply
549:04 - hyphen f
549:05 - k eights
549:07 - config map
549:08 - i'm gonna say okay so that created that
549:10 - config map there
549:14 - and um i'm just looking off screen here
549:17 - because i want to see if there's a way
549:18 - we can visualize it as a yaml file
549:22 - um i'm just looking here
549:28 - yeah there's like a way like output so
549:30 - what we can do is type in cube ctl get
549:33 - config map to look at it for a moment
549:35 - here
549:36 - oh maybe we should say oh micro k8 it's
549:38 - in front here
549:41 - okay so we have this one which is the
549:43 - certification root thing and then we
549:45 - have config maps so we'll say get
549:46 - configmap configmap
549:48 - maybe not a great name for it should
549:49 - probably called it sinatra but whatever
549:51 - and so um that doesn't tell us much but
549:54 - we go hyphen o yaml
549:56 - now it shows us in the format of a yaml
549:58 - file so
549:59 - we can kind of look at that data
550:03 - and see what it looks like so we have
550:04 - hello world equals that game properties
550:07 - equals this
550:08 - kind of see what the structure is i
550:10 - suppose
550:12 - i'm not sure if there's like a nicer way
550:13 - to look at it i'm just double checking
550:15 - here
550:17 - no that's pretty much it okay so now
550:20 - that we have that we need to now
550:22 - associate that to our pod or a
550:24 - deployment so if you deployed a pod you
550:25 - could specify it there but we're doing
550:27 - it through our deployment and so we can
550:29 - either mount it as a volume or we can
550:31 - pass it along as environment variables
550:34 - and so i think what we want to do is do
550:36 - nvar here so we'll go over back to our
550:40 - reference file here and we'll just say
550:41 - nvar
550:44 - and
550:45 - i'm just off screen here with like this
550:47 - one because i know i've seen it
550:48 - somewhere here
550:50 - environment variables
550:53 - maybe it's in
550:55 - this ultimate guide here to config maps
551:00 - because there's one where you can mount
551:01 - yeah this is what i'm looking for and
551:02 - and and env from okay
551:06 - so you think they'd have that in the
551:08 - main
551:09 - it's always a lot of work to figure
551:11 - stuff out here so what we'll do is go
551:12 - back to our deployment and so this one
551:14 - is showing with a pod but i'm going to
551:15 - assume that i can do that with a
551:17 - deployment because why not
551:19 - and so
551:20 - i think it would probably go
551:22 - in line here oh we have env up here
551:26 - so we could say env from
551:28 - see i don't think we need to set this
551:30 - yeah so like here we could probably
551:31 - override it first let's just do this as
551:32 - a test before we bring in our config map
551:35 - and so we'll just say um goodbye goodbye
551:40 - goodbye moon okay
551:43 - and then what we'll do is do an apply
551:46 - before we do our configmap we'll just
551:48 - see if this works
551:50 - deployment
551:52 - k8 deployments
551:55 - great and then we will just want to do
551:57 - our curl here
552:00 - to see if it would take it
552:03 - uh and it didn't take it hello message
552:06 - i'm just wondering here
552:10 - i'm just looking at our server file here
552:12 - yeah it's called hello message
552:15 - so it should load that instead
552:20 - all right well that's totally fine what
552:22 - i'm going to do here is i'm still going
552:23 - to specify um an and and n bar or n from
552:28 - i think the reason why i see this is
552:30 - confusing is because
552:32 - it's indented here but it's actually on
552:33 - the same line here so
552:34 - this didn't work but we will just delete
552:36 - this out
552:37 - or actually we'll just change this to n
552:39 - from
552:41 - and then we need to figure out how to
552:43 - map it so we'll say config
552:45 - map ref
552:46 - colon space space name example or sorry
552:50 - whatever the config map is called so
552:51 - it's called config map and so i think
552:53 - that's how we should be able to map it
552:55 - again i'm just trying this i haven't
552:57 - done it before so i'm just hoping that
552:58 - it works first time
553:00 - and what we'll do here
553:02 - let's go ahead and do a deploy here and
553:04 - we'll see if we get an error so
553:06 - um and from
553:08 - unknown field called name
553:11 - all right so that didn't work as
553:12 - expected
553:14 - so we'll have to go here and look up
553:16 - some stuff so
553:18 - config map for
553:21 - deployment
553:22 - kubernetes
553:28 - so this again this one's for pod
553:33 - that is frustrating
553:36 - it should it should be able to go in
553:37 - here it just says name though oh did
553:39 - maybe i put a hyphen in front of it so i
553:40 - made an array and that messed it up
553:43 - which by the way um no actually the
553:46 - other the other resource was fine no i
553:48 - did it correctly
553:49 - just make sure that we've
553:51 - done this right
553:54 - i'm just copying off screen the contents
553:56 - here making sure i typed it right
553:58 - looks right to me
554:00 - just double check here we'll paste it in
554:04 - paste
554:08 - um
554:15 - making sure i'm getting the indentation
554:17 - correct here
554:21 - yeah that's indented and we'll try one
554:22 - more time
554:28 - maybe maybe it's too far indented there
554:30 - there we go and so we'll try this again
554:34 - okay so it says
554:35 - unknown field name v1 env
554:38 - emv from source if you choose to ignore
554:41 - these errors
554:43 - hmm
554:46 - unknown field
554:51 - okay so i'll be back here in a second
554:52 - and figure out what's wrong okay
554:54 - all right so uh staring at it for a
554:56 - little while here i think that the issue
554:58 - is that this needs to be indented so
554:59 - we'll try that first because i just
555:01 - found a stack overflow that just said
555:03 - hey your indentation is wrong and they
555:05 - have an example here where this shows
555:07 - more indented from this one and this one
555:08 - is more indented from that one
555:10 - so uh we'll just do both of that so this
555:13 - one
555:14 - from from the e that's where we have to
555:15 - look maybe we'll just do that as a
555:17 - sanity
555:18 - check
555:19 - ah there we go so it looks like it has
555:22 - now been configured so
555:24 - oh but it's the wrong name
555:26 - so we'll have to type in configmap
555:28 - because that's not gonna work if we do
555:30 - that
555:31 - okay we'll try this again
555:33 - and so it says now it's now configured
555:35 - so we'll go back to our deployment here
555:37 - and just see if there's anything
555:39 - observable that's interesting here so
555:42 - you say describe deployment since
555:43 - there's only one it's going to select
555:44 - the first one i know i said 100 times
555:46 - but just so you know
555:47 - and here it says environment variables
555:50 - from configmap configure map optional
555:52 - false i'm not sure what the optional
555:53 - false is but it looks like it must be
555:55 - associated
555:57 - and so i'm just hoping that if we do
555:59 - a localhost that's going to work now i
556:02 - don't know if we have to restart the
556:04 - pods or if it would restart the pods so
556:06 - i'm just looking here
556:07 - so 12 seconds go scale down scale up so
556:09 - i think it did turn off and turn back on
556:11 - the pods
556:13 - so
556:14 - if we go here and do our um curl local
556:19 - host sinatra i'm hoping that it will
556:20 - show
556:21 - bar soon oh it does there we go so for
556:23 - whatever reason when we set an
556:24 - environment variable it didn't work
556:26 - maybe it was indentation or something
556:28 - but here it's definitely accepting the
556:30 - environment variable for a configuration
556:32 - set there so that is really nice now
556:34 - there's another way to uh use or to to
556:38 - pass them along and that's by mounting
556:40 - it as a volume which is kind of
556:42 - interesting let's see if we can do that
556:44 - really quickly here so volume
556:49 - okay and so what you can do is specify a
556:50 - volume mount
556:52 - and this is on a pod
556:54 - and assume it works the same way you
556:55 - just have it with the containers
556:57 - and then we specify a volume so i think
557:00 - what we would need is a
557:02 - volume mount here i don't know if that
557:03 - would be enough for it to work
557:06 - so go back to our micro k8s here and
557:08 - we'll just scroll on down here hit enter
557:11 - paste that on in
557:12 - and
557:14 - making sure that is right we didn't grab
557:16 - it all did it
557:18 - oh it's right here okay and so i think
557:20 - that would need to be the same level
557:22 - indentation here and so we'll indent
557:24 - here and we'll
557:26 - uh
557:27 - now that indentation's fine
557:29 - and so we have
557:31 - name config which seems fine
557:35 - uh we'll just have a config map
557:38 - we'll go to config
557:40 - actually i think we would have to
557:41 - associate so we have a volume mount and
557:43 - then we'd have to actually have the
557:44 - volume to associate with so we'll have
557:45 - to go back to here and then the this is
557:48 - the volume so we'll go and
557:51 - go here and then paste that on in
557:56 - and here it looks like it's just doing
557:57 - it in line
558:00 - so
558:01 - set the volumes at the pod level then
558:03 - mount into the containers inside the pod
558:05 - provide the name of the config map you
558:07 - want to route an array of keys to uh to
558:09 - convey to create as files okay cool so
558:12 - now going back to this it kind of makes
558:14 - sense that when you have this this would
558:15 - be isolate files and we have all those
558:17 - in there for example so we can give that
558:19 - a go
558:20 - in terms of indentation level we need to
558:22 - figure that out so this one is
558:24 - at the same level as containers
558:28 - so we will go
558:29 - up here
558:31 - and hit back
558:33 - and follow the line
558:35 - so it has to be here
558:41 - there okay
558:42 - and we'll go down
558:45 - and i think that's okay sometimes like
558:48 - when it's like this you have to have it
558:49 - the same line indication is kind of
558:50 - weird and so it says here so this one's
558:53 - called config map
558:55 - an array of items array of keys from the
558:58 - configmap to create as
559:00 - files
559:03 - okay so what i'm going to do is i'm just
559:04 - going to comment out
559:06 - our old one here so
559:08 - i kind of want to leave it in just in
559:09 - case we want to pull it back up i'm just
559:11 - going to put image right i'll put a name
559:13 - at the top here
559:14 - okay
559:16 - and then i'll just comment this
559:18 - out and then i'm going to go over to our
559:20 - config map well we'd have to update our
559:22 - config map for this to work so what i'm
559:24 - going to do here is go exclamation mark
559:26 - exclamation mark
559:28 - and
559:29 - then
559:30 - what i want to do here
559:32 - is um
559:35 - yeah this all looks fine so i don't know
559:36 - if this is going to work because we
559:38 - don't have we didn't specify this as a
559:41 - file since it says an array of keys from
559:43 - the configmap to create as files
559:45 - so i'm going to assume that it's going
559:46 - to default back to hello world okay
559:49 - so now that we have this and assuming we
559:51 - have got this all right
559:52 - um we'll go ahead and deploy let's see
559:54 - what happens so we'll type in micro k8
559:56 - cube ctl
559:59 - apply hyphen f k8 and
560:03 - deployment.yaml and so that's going to
560:04 - update it
560:06 - and then we will do our curl
560:09 - it still it still says
560:11 - um
560:12 - caror bar soon because of course we did
560:14 - not push this so that's why that's not
560:16 - updated and i don't know if it would
560:17 - actually restart the pods for that if it
560:19 - mounted the volumes or maybe it's still
560:20 - doing it so let's go and
560:22 - look at what it's doing so we'll
560:24 - describe it
560:25 - and here it says
560:28 - nothing fancy
560:32 - i'm just taking a look here
560:35 - ah so it does mount to config
560:37 - which is great
560:39 - and we have config map here
560:45 - okay
560:48 - and so i don't think it's um the other
560:50 - original config map i don't believe is
560:52 - there anymore so it shouldn't be saying
560:54 - that so i'm guessing that it didn't
560:55 - restart the pods let's just try again oh
560:58 - there we go so it probably was just
560:59 - shutting down the pods right so
561:01 - restarted so it definitely is uh loading
561:05 - the other one and it doesn't have that
561:06 - environment variable so now what i'd
561:08 - like to do is see if we can get into
561:10 - this
561:11 - machine
561:12 - and be able to
561:16 - view that mounted directory so we'll
561:18 - look it up like
561:19 - kubernetes pod ssh
561:24 - all right and it's not ssh it's more
561:26 - like
561:28 - it's like execute here so this is the
561:29 - line that we want execute
561:32 - if we look over here you can see what it
561:34 - does so execute execute a command in a
561:36 - container and so the command that we're
561:38 - executing is saying uh get us into
561:42 - the actual instance here and i'm
561:43 - assuming shell demo needs to be a
561:46 - particular container just double check
561:48 - here
561:49 - so verify the container is running so
561:52 - get pod shell demo get a shell to the
561:55 - running container so probably one of the
561:57 - running containers which will be sinatra
561:59 - here so go ahead and paste that in and
562:01 - we'll just swap this out for sinatra
562:06 - and it was refused because we didn't
562:08 - have micro k8s in the front as per usual
562:11 - and i didn't type it right probably so
562:13 - we will
562:14 - oh and i'm in the wrong environment
562:15 - that's why
562:16 - so
562:17 - just be careful about this one and i
562:19 - don't need this anymore because we've
562:20 - already updated uh that
562:22 - and so we'll paste that on in here
562:23 - whoops
562:25 - we'll type in micro k8s
562:30 - and says sinatra pod not found maybe we
562:35 - called it sinatra example or something
562:36 - so we'll say
562:37 - micro k8s
562:39 - cube ctl get pods
562:43 - okay yep they're very uh they're very
562:45 - unique okay so then we'll have to
562:47 - actually give it the pod name here
562:51 - right and so now that we're here we'll
562:53 - do ls and we'll go to cd to the root and
562:56 - we have a config directory we'll go
562:58 - inside of there and notice we have
562:59 - game.properties user
563:00 - interface.properties so if we really did
563:02 - want hello world to be propagated over
563:04 - there we would have to write in
563:06 - that file you know hello world and then
563:09 - its path okay and if we go into game
563:11 - properties is that oh that's a file so
563:13 - we can go cat game properties and see
563:14 - its content and so there we can see the
563:17 - files so yeah that's pretty much config
563:19 - map
563:20 - two different ways to access it very
563:23 - cool
563:24 - and yeah that's it
563:27 - [Music]
563:31 - hey this is andrew brown from exam pro
563:32 - and we are taking a look at secrets so
563:35 - we did config map which uh are uh
563:38 - completely
563:39 - not encrypted in any way whatsoever and
563:41 - so secrets is a great way for us to pass
563:43 - our sensitive information into our pods
563:46 - or containers uh so what we'll do is
563:48 - pull up the kubernetes secrets
563:50 - now by default by default uh they're
563:53 - stored in unencrypted api
563:55 - api so in order to do that we'd have to
563:57 - enable encryption at rest for secrets
564:00 - rbac rules all these other things
564:03 - i'm not sure what we'd have to do for
564:04 - that i mean like for the ksna it's a bit
564:06 - out of scope but let's just take a look
564:08 - at micro kds and type in status and see
564:11 - if
564:12 - um if there is any kind of like
564:15 - extension just to turn that stuff on to
564:17 - configure it
564:18 - micro k8s status
564:21 - micro k8s
564:24 - am i crazy today am i not typing it
564:26 - right
564:27 - oh you know what it's because i didn't
564:28 - type exit i was still in um
564:32 - in our pod from before so micro ks
564:35 - status
564:36 - i'm just curious what we can see here in
564:38 - terms of options so
564:40 - we don't have rbac turned on so i'm not
564:42 - sure if i'll have to turn it on to use
564:44 - it but there's rbac
564:47 - and i don't see anything in particular
564:48 - for secret so you know there might be
564:50 - some things we need to configure but uh
564:52 - i don't particularly care if they're
564:54 - secured i just want to go through the
564:56 - motions with you to see how it would be
564:58 - done so there are different types of
564:59 - secrets that you can set so pay is what
565:02 - generally is for user defined stuff and
565:03 - then we have a variety of other ones
565:04 - here i would imagine that maybe
565:07 - the encryption is different or something
565:09 - i'm not really sure um but you know
565:11 - we'll go through the motions of setting
565:13 - up our own secret so it's very similar
565:16 - to doing the config map so
565:18 - here's an example of some data
565:20 - so we'll go ahead and grab this secret
565:22 - here and make our way back here and
565:24 - we'll create a new file
565:26 - called secret.yaml you can also ingest
565:29 - them from a file so even though we are
565:31 - placing uh the data right in here you
565:34 - can include additional key value pairs
565:36 - opaque so you can pass the data in just
565:39 - like that
565:40 - um say like username password
565:44 - andrew brown testing one two three
565:48 - and notice here it says service account
565:50 - token so if we go back here and we look
565:52 - at the types we can change it so maybe
565:54 - basic auth would usually have a username
565:55 - and password
565:57 - okay so go ahead and paste that on in
565:59 - here
566:02 - and then there's annotations for the
566:04 - service account name that's with role
566:06 - based access controls i don't know if we
566:08 - need this right now uh i have a feeling
566:11 - that we probably do but i'm going to go
566:12 - ahead and delete it out and see what
566:13 - happens so we'll just say
566:14 - basic auth
566:17 - say sinatra basic auth
566:20 - as the metadata name
566:23 - and so we'll see if we can actually
566:25 - create this here
566:27 - so type in micro k8s cube ctl apply
566:31 - hyphen f
566:32 - k8s secret
566:34 - okay
566:36 - so it says error when creating secret in
566:39 - version one uh cannot be handled as a
566:42 - secret illegal base64 data as the input
566:47 - okay
566:48 - so i guess it expects us to do something
566:51 - with it so we'll take a look here
566:56 - um
566:57 - oh they actually have an example right
566:58 - here oh string data okay so we'll change
567:00 - this over here so i guess it's going to
567:02 - vary based on what you're doing so this
567:04 - says data this one says string data
567:06 - because that's technically what it is
567:08 - i guess it was b64 we'd have to just
567:10 - encode it but we'll go switch that over
567:12 - like that
567:13 - hit enter and it created it so now we
567:15 - can type in micro k8
567:17 - s
567:19 - cube ctl
567:20 - get secret
567:23 - secrets
567:25 - micro
567:26 - there we go uh maybe we get some detail
567:29 - so say uh describe
567:33 - secrets
567:34 - sinatra basic off
567:39 - all right and so notice that we cannot
567:41 - see the contents of it says 10 bytes and
567:43 - 11 bytes um still we didn't go through
567:46 - all those motions of setting up these
567:47 - other things so i'm just hoping micro k8
567:49 - did it for us because i don't know if
567:50 - like we didn't set up secrets as it said
567:53 - uh above here with all these options if
567:55 - it would show plain or show just in
567:57 - bytes but at least it looks like it's
567:59 - obscuring from us so that's really great
568:01 - if we want to go fetch that secret
568:03 - that's a good question so we'll go back
568:05 - here and see if it allows us or shows us
568:08 - how to fetch that data
568:12 - it is not
568:14 - you can edit it using secrets i just
568:15 - want to see how we can see it
568:19 - okay so i know
568:23 - uh let's see this is secrets and this is
568:26 - on kubernetes as well this is managing
568:28 - secrets using a configuration file i'm
568:30 - just looking for the cube ctl command so
568:32 - we can view it
568:33 - so we scroll on down here
568:36 - so verify decode ah so maybe that's what
568:39 - we want so cube ctl get secret
568:42 - um
568:44 - yeah this one shows bytes
568:46 - oh did they do something similar to us
568:47 - like basic auth
568:50 - well let's give a go and see what
568:51 - happens if we run this but this we're
568:53 - not following this tutorial so i can't
568:54 - expect this to work the same way
568:56 - but we will try for fun
569:01 - and we will say here
569:03 - the proper name which is this
569:05 - paste that
569:06 - in and we'll type in micro k8s
569:13 - micro k8s
569:15 - oh it does okay great so that did work
569:18 - so we have this output json path so i
569:20 - guess what we're saying is get the
569:21 - secret
569:22 - and then we specify get us the data even
569:24 - though it says string data i think it's
569:25 - just saying like the data is being
569:27 - inputted as a string but we want to grab
569:29 - the data and so that is one way for us
569:31 - to access our data using cube ctl but
569:33 - how do you get it within a pod that's
569:35 - the question so it's no different than
569:37 - what we were doing we can i think we can
569:39 - mount it as a volume i think we can do
569:41 - that so we go over here um back over to
569:43 - this and we say volume
569:46 - i know we can do it with a volume
569:48 - whoops
569:50 - volume
569:53 - as a file volume mounted so it's going
569:55 - to be the same process
569:57 - as we did with config map
569:59 - as you can see here so
570:01 - nothing's super exciting we're not going
570:02 - to go through all that but we will look
570:04 - at how to do it for um
570:07 - just not like we did the environment
570:08 - variable so we can go secret
570:11 - um
570:13 - what's the one we set that we commented
570:15 - out up here config map ref it would be
570:17 - like secret ref
570:21 - secret ref
570:24 - yes so if we wanted to do it uh like
570:27 - pass it this way here we could do secret
570:28 - ref here
570:31 - and if we wanted to update this maybe we
570:32 - could try like hello hello message
570:37 - say like secret message
570:39 - i don't know if this will work but we'll
570:40 - try for fun
570:43 - and i'm going to go here and type in
570:45 - clear and then we will go ahead and
570:47 - apply this if we can find it here
570:50 - and so now we'll make sure that we
570:52 - actually have that data
570:54 - yeah it is here so notice that it is
570:56 - encrypted and so i'm hoping that we can
570:59 - just pull that information out so this
571:01 - is called
571:03 - secret base basic auth even though basic
571:04 - authors don't be using a password that's
571:06 - totally fine i don't care
571:08 - um just copying that
571:10 - paste that in there
571:12 - that looks okay and so
571:15 - what we'll do
571:16 - is we will update
571:19 - apply f will update our deployment
571:23 - and see if that takes
571:25 - and i got type cube ctl in there
571:31 - okay
571:32 - and then we need to
571:35 - wait for our containers to or pods to
571:38 - spin down and spin back up
571:42 - and by the way as we've been doing all
571:43 - this we actually haven't been using the
571:45 - um dashboard which
571:47 - surprised we haven't been uh it might be
571:49 - fun to go take a look at that
571:52 - just because uh we've been adding all
571:53 - these things and we haven't used it at
571:55 - all
571:56 - so
571:57 - i think the easiest way is to go to the
571:59 - home page here go to linux scroll on
572:01 - down go to micro8
572:04 - proxy dashboard proxy
572:06 - and i'm going to make a new terminal
572:08 - here tab hit enter
572:13 - and this is the token we want so
572:16 - i want to
572:16 - [Music]
572:18 - go and find the ec2 instance and get its
572:20 - ip address because i don't know what it
572:22 - is
572:25 - and here it is
572:28 - so we'll go ahead and grab that
572:30 - we will override this one and i need the
572:32 - ip address here so go grab the
572:36 - port number there and it says
572:40 - cannot find the request http colon
572:49 - 10443
572:52 - client sent hp request to an http server
572:55 - yeah okay it should be colon oh sorry
572:58 - we'll just put the s in and then we'll
572:59 - advance because we don't have a
573:01 - certificate attached
573:03 - and then we need the token so we'll go
573:04 - back here hopefully we've grabbed it in
573:06 - time i don't know if it's going to
573:07 - expire or something and we'll sign in
573:09 - and now it's just fun to kind of look at
573:11 - this so we had a config map here below
573:14 - you can see it was created over here
573:17 - can we edit these in place oh that's
573:19 - cool
573:21 - so yeah if we wanted to just edit this
573:23 - that'd be really cool to do
573:25 - um
573:26 - we don't have any persistent volume
573:28 - claims do we have or we have our ingress
573:29 - service just poking around for fun here
573:31 - we'll look at our
573:32 - deployments so what i'm curious about is
573:35 - like did our pods change so available
573:38 - progressing new replica set available so
573:40 - nothing super new here
573:42 - this happened a minute ago so i think it
573:44 - did happen one minute ago it did replace
573:46 - our
573:50 - our pods there so that means that we
573:51 - should be
573:52 - okay to do a curl local host
573:55 - and do sinatra
573:58 - ah there we go so it worked um so yeah
574:01 - that's secrets
574:03 - okay so there you go
574:05 - [Music]
574:10 - hey this is andrew brown from exam pro
574:12 - and we are doing another follow along
574:13 - and this time we're dealing with volumes
574:15 - and and specifically with uh persistent
574:17 - volume so we have our two environments
574:19 - and we're going to use our micro cage
574:21 - environment here and so what i want you
574:23 - to do is make your way back over to here
574:26 - and within
574:27 - micro creates we need to enable storage
574:30 - so we type in micro k8 status
574:32 - there is an option to
574:34 - uh
574:35 - have a storage here and so all this
574:38 - storage thing does
574:40 - is um i'm just trying to find it here
574:43 - here it is so it will create us a
574:45 - storage class uh and
574:47 - the reason why we're doing this is
574:49 - because when you usually have a storage
574:51 - class you generally are
574:53 - linking to something external so it
574:55 - could be like um aws ebs or
574:58 - azure disk or something like that and
575:00 - just to make this easy for development
575:03 - uh micro case has this storage class
575:05 - that is locally on the machine uh so
575:08 - we're not gonna learn how to create a
575:09 - storage class because it's gonna create
575:10 - one for us but we are going to use it
575:12 - and it's just going to make learning
575:14 - persistent volumes and persistent volume
575:16 - claims a lot easier so we'll type in
575:17 - micro k8s
575:21 - and we'll type in enable and then
575:23 - storage and that will enable our storage
575:25 - so it's just going to go ahead and
575:26 - create us a storage class there
575:30 - okay and so here it says it created an
575:32 - rbc authorization so a cluster role
575:34 - cluster role binding service account
575:36 - storage class stuff like that it says
575:38 - it'll be available soon so now what
575:40 - we'll do is type in uh cubectl
575:43 - and uh we'll say get
575:47 - maybe sc for storage classes yep there
575:49 - it is and so this is the name it's
575:50 - called micro k8 host path and so the
575:53 - idea is that on this node uh we will
575:55 - have um our volume or our or something
575:58 - mounted to our directory here okay
576:00 - and so now that we have that out of the
576:03 - way i'm just pulling up the instructions
576:05 - i wrote earlier and so what we'll need
576:07 - to do is create a persistent persistent
576:09 - volume so a persistent volume
576:12 - is
576:13 - basically
576:14 - uh it's saying okay this is the volume
576:17 - and it uses this type of storage class
576:19 - all right and so that's what we're going
576:21 - to be doing there and ignore my stream
576:23 - deck i really hate how it always pops up
576:25 - but i'm just going to uh say remind me
576:27 - later okay i usually don't get pop-ups
576:29 - in my in my videos but there's one there
576:31 - so what we'll do is go and type in
576:32 - persistent volume and see if we can just
576:34 - pull some code from the kubernetes
576:37 - website to start with okay so we'll just
576:40 - load that up here and i'll just scroll
576:41 - on down and i'm just looking for
576:43 - persistent volume
576:46 - an example of persistent volume so we
576:48 - have uh here's one okay so what we'll do
576:50 - is just basically kind of grab this one
576:52 - this is clearly not enough
576:53 - but i do have my code off screen here
576:56 - that we will bring in here to make it a
576:57 - bit easier and so i'm going to make a
576:59 - new file here and we're going to call
577:00 - this pv.yaml
577:03 - all right and then we'll go ahead and
577:04 - paste that on in there and so we'll just
577:07 - take a look at what we have so
577:10 - the first thing is we'll need metadata
577:11 - i'm going to call this mypv i really
577:14 - don't like when people type foo and
577:15 - we're going to apply labels type local i
577:18 - don't know if we need to have the label
577:20 - there but that's the example that they
577:22 - are using
577:23 - for micro k8 so if we typed in micro k8
577:28 - storage they might show an example there
577:31 - let's see if there's an example here
577:36 - no
577:37 - we might type in like tutorial
577:45 - and it's the same page here
577:50 - and it could be this one
577:53 - no but that's okay like i just have it
577:55 - off screen i just like to show you where
577:56 - i'm grabbing the code from so you get
577:59 - very good at googling too because really
578:01 - with kubernetes you have to spend a lot
578:03 - of time looking for stuff because the
578:04 - main docs is always kind of uh not that
578:08 - great so the storage class name is going
578:09 - to be the storage class that we want it
578:11 - to be so this is going to be micro k8
578:13 - i'm going to copy and paste it so i
578:14 - don't
578:15 - type it wrong here and so we have cube
578:17 - ctl sc and we'll go grab its name from
578:20 - down below
578:22 - and paste it in the storage class here
578:25 - and then we need to specify the capacity
578:28 - so how much we're going to reserve of
578:29 - space for this and so i'm going to do
578:31 - capacity
578:33 - storage
578:34 - and we'll say one gigabyte okay
578:37 - making sure i split capacity right and
578:39 - then we might want to specify our axis
578:41 - mode
578:42 - so the axis mode is like can you read
578:44 - and or write okay
578:46 - and make sure you set those to two
578:47 - spaces over there
578:50 - and so we'll say access modes
578:53 - and i think this is an array so we'll do
578:55 - hyphen there we'll say read
578:57 - write once
578:59 - um
579:00 - claim reference we don't need that um
579:03 - but what we do need is to set the host
579:06 - path and so we're going to actually say
579:08 - for this
579:10 - storage volume where is it going to be
579:12 - accessible on our node or our local
579:14 - machine here and so i'm going to say
579:16 - mount data and so that means
579:18 - uh not within uh the pod but here in our
579:21 - developer environment our virtual
579:22 - machine on the forward slash mount data
579:24 - that is what will be will be shared to
579:27 - our uh pods okay
579:30 - so this looks okay to me
579:32 - but i did type a lot by hand so
579:33 - hopefully it is all correct and so what
579:35 - we'll do is go ahead and deploy this
579:39 - okay and so we'll type in k8
579:42 - pv yaml
579:44 - and it's created our volume there and so
579:46 - what i'll do is go ahead
579:48 - and we will go view the contents of it
579:51 - so say cube ctl
579:53 - pv or sorry
579:55 - get pv
579:58 - i gotta spell it right
580:00 - okay so
580:01 - what we see is the name the capacity the
580:04 - access mode whether to retain it is it
580:07 - available but notice there is no claim
580:09 - so technically it's not linked to
580:11 - anything right now and so that will be
580:13 - what we'll do next with the pvc the
580:16 - persistent volume claim let's get a bit
580:18 - more of a description here to see if
580:19 - there's anything interesting
580:22 - and so we'll just expand that up
580:24 - and it's pretty much you know same
580:26 - information nothing super exciting so
580:29 - now what we need is a persistent volume
580:32 - claim
580:33 - okay and so what we'll do is just go
580:36 - back over here and see if we have an
580:37 - example and there is one
580:40 - so we'll do is go
580:41 - back over here and say new file we'll
580:44 - say pvc.yaml
580:47 - and we'll go ahead and paste that
580:49 - and we need our metadata i'm going to
580:51 - call this mypvc
580:53 - uh we don't care about namespace we'll
580:55 - put in the defaults here
580:56 - and we do need to specify a storage
580:59 - class so that one will be the same as
581:01 - the other one
581:03 - so i'll just go over here
581:08 - okay
581:11 - and
581:13 - we'll paste that on in there
581:18 - and we'll delete that
581:20 - and then we need to specify the
581:21 - resources
581:24 - i don't care about the volume name we
581:25 - don't have to write that in there it
581:27 - will just set it to my pvc i think and
581:29 - so we'll say resources and we'll tab in
581:31 - we'll say requests
581:34 - and then we'll say storage so we're
581:36 - saying how much we want to request so
581:37 - i'm going to set it the same value and
581:39 - this is not going to work because if
581:40 - this is one gigabytes and this is one
581:42 - gigabytes it's just taking up too much
581:43 - of the space and you have to be less
581:45 - than that but i just want to show you
581:47 - what happens if we match it one to one
581:49 - okay so what we'll do is type in clear
581:52 - and i'm going to do cube ctl
581:54 - apply hyphen
581:56 - f and then we'll specify k8 uh pvc
582:01 - gamble
582:02 - and notice that my pvc is in valid
582:04 - access mode required at least one axis
582:06 - mode so maybe my indentation is the
582:09 - wrong levels or i deleted it out
582:11 - oh no i didn't even specify it so we'll
582:13 - go here
582:14 - these darn spaces um
582:18 - two
582:19 - maybe this little cog will let me set it
582:21 - nope
582:22 - nope i just don't feel like looking it
582:24 - up
582:25 - okay
582:26 - so we'll go here and type in storage
582:28 - class name colon and then oops no no no
582:32 - no no we already have that what we want
582:33 - is our access modes it's going to be the
582:35 - same thing because what it's trying to
582:36 - do is say
582:38 - a pvc is saying like tell me what you
582:40 - want like this is what we want and then
582:42 - the pv uh the person's volumes this is
582:44 - what we have and if it matches up then
582:46 - they will uh match up via a claim okay
582:50 - so we'll go here and paste that in and
582:53 - i'll go back and hit up and so it
582:54 - created the pvc and so now what we'll do
582:57 - is type in
582:58 - cube ctl
583:00 - get pvc
583:05 - um
583:06 - type that right
583:08 - there we go and so it says status is
583:11 - bound
583:12 - and we'll type in pv
583:14 - and
583:15 - it's bound and it's claimed okay so it
583:16 - did match up so i don't know when i was
583:18 - doing this and i had it the the wrong
583:20 - side or one one to one it didn't work
583:22 - but i guess like if we were to set this
583:24 - to be like two then i would expect this
583:26 - not to work so let's just go and change
583:27 - that to do
583:29 - because clearly that's too large right
583:32 - and here it says forbidden only
583:33 - dynamically provisioned pvcs can be
583:35 - resized
583:36 - okay well we don't really want to resize
583:38 - it so what we'll do is delete it first
583:40 - so we'll say cube ctl
583:42 - delete
583:43 - pvc mypvc
583:46 - okay we'll type in clear we'll go take a
583:48 - look at the pvc make sure there's
583:50 - nothing claimed
583:55 - not sure how it's claimed when it's not
583:56 - there anymore
584:00 - okay
584:03 - well
584:04 - uh what i'm going to do is i'm going to
584:06 - go ahead and just delete
584:09 - the pv here
584:11 - and we'll just run them again okay
584:16 - okay so we'll type clear and i'm just
584:18 - going to hit up
584:19 - because i want to
584:22 - run uh pv
584:25 - and then i want to see that it is
584:28 - not claimed and then what we'll do is do
584:30 - pvc
584:33 - okay and then we'll go back to get pv
584:41 - i'm just going to stretch this a bit
584:42 - larger here
584:49 - and uh notice here i don't know why it's
584:51 - so hard to read i don't remember seeing
584:53 - this many columns here but
584:55 - we have the name i'm just going to try
584:56 - to expand this a bit more and run this
584:58 - again
585:00 - maybe i'll just bump down the font here
585:01 - to make it a little bit easier because i
585:03 - can't see what's going on here with this
585:05 - font this big
585:06 - so go back to our terminal here
585:10 - terminal terminal terminal where are you
585:11 - there we go and we'll just bump this
585:13 - down a little bit so there we go that's
585:15 - a lot more manageable
585:17 - so here we can see my pv and this one is
585:20 - not claimed and um it's i guess it's
585:23 - showing up the pvc that we have here but
585:26 - notice that it's not matching up because
585:27 - it's it's too large right so
585:30 - what i'll do here is i'll change this
585:31 - back to one i'm going to see if i can
585:33 - actually change it i know it said like
585:34 - before we can't resize it but maybe we
585:36 - can if
585:37 - it's not claimed yet
585:39 - so we'll run that
585:42 - field cannot be less than the previous
585:43 - value so notice here
585:46 - okay so i guess you can expand it but
585:47 - not shrink it so that's fine
585:49 - so what we'll do is just go ahead and
585:51 - cube ctl
585:52 - um
585:53 - delete pvc
585:56 - we'll say my pvc
585:59 - and we'll type clear
586:04 - okay and so now what we'll do is we'll
586:07 - go and then run it again
586:09 - and actually before we do that i just
586:10 - want to shrink it so it's smaller i'll
586:11 - say 200 megabytes
586:13 - there we go
586:16 - and then we'll go back there just trying
586:17 - to figure out the bounds of this stuff
586:19 - so it's claimed it's bound um so now the
586:22 - only thing that we need to do is we need
586:23 - to actually have a deployment that has a
586:27 - volume attached so what we'll do is go
586:29 - back to the kubernetes page here and see
586:31 - if it actually shows an example with the
586:33 - deploy i think it shows like with a pod
586:35 - maybe here
586:39 - keep scrolling down here
586:42 - yeah and so this is pretty much
586:44 - yeah so it says pod but we can do this
586:46 - with a deploy and so what we're going to
586:47 - do is go back over here to our deploy up
586:50 - here and there's a lot of stuff going on
586:52 - here so i'm just going to go copy the
586:54 - contents here make a new file and call
586:56 - this deployment
586:58 - with
587:00 - pv
587:01 - or storage
587:06 - and we'll paste that
587:08 - and we do have some old stuff here that
587:09 - i do not want so first we will delete
587:13 - uh and make sure you put the
587:16 - yaml part on the end of it or it's not
587:18 - gonna work properly
587:20 - it's not for coloring so
587:22 - obviously we've done a volume mount with
587:24 - a config map but
587:27 - here we have sinatra so i'm going to say
587:29 - sinatra with volume
587:32 - or storage
587:35 - okay
587:36 - and we're just going to keep
587:38 - up with that maybe
587:40 - just say pv
587:45 - like with
587:46 - pv just trying not to type a hundred
587:49 - things here
587:55 - oh we have our container name sure we'll
587:57 - just update that as well
587:59 - and this all looks fine we don't need
588:02 - environment variables
588:04 - ports are fine the readiness probe is
588:06 - fine so that's what we would have if we
588:08 - had our minimal one for before
588:11 - and so what we need to do is make it so
588:14 - that we attach a volume to it so we'll
588:16 - go back over to here
588:18 - and notice that we need to do a volume
588:20 - mount so we'll go ahead and copy paste
588:21 - that in that needs to be aligned with
588:23 - the name image within the containers the
588:25 - indentation is a little bit tricky but
588:27 - we'll figure it out so i'll go ahead and
588:29 - paste that on in there
588:32 - and we'll just fix our indentation
588:36 - i'm noticing this is all four spaces
588:45 - okay and so this
588:47 - should be
588:49 - i would say like that that looks okay to
588:51 - me
588:52 - and then what we need is the volumes
588:54 - part so we'll copy that that's going to
588:56 - be aligned with containers
589:01 - and we probably can just paste it even
589:03 - above to make our lives a bit easier
589:17 - okay and so we have the
589:21 - we gotta see what we need to match this
589:22 - up with so
589:25 - for the volumes part
589:27 - we'll give it a name like mypvc
589:29 - and then what we're putting here is
589:30 - mypvc so we're matching what volume
589:33 - claim we want to be attached or like
589:35 - associated with this actual
589:37 - pod
589:38 - okay and then under the containers
589:40 - itself this is what we want to define as
589:43 - the mounting directory so i'm going to
589:45 - just call this mount
589:47 - local
589:48 - data here
589:50 - and then
589:51 - underneath here we just want the names
589:53 - i'm going to say my pvc
589:56 - all right and so
589:57 - this should be the mount directory on
589:59 - the actual container okay and so now
590:01 - what we'll do is go ahead and deploy
590:03 - that so i'll type in cube ctl
590:06 - um apply f
590:10 - deployment
590:12 - or k8
590:14 - deployment
590:15 - with storage
590:18 - and i gotta spell cube ctl correctly
590:20 - and so that's deployed
590:24 - and so what we'll do is just type in
590:25 - clear
590:26 - and then i'll just say um cube ctl
590:29 - get pods
590:32 - so we can see all of our pods and then i
590:34 - want to
590:35 - describe the one with storage notice
590:36 - that we have two of them maybe we had
590:38 - replicas on two here
590:40 - yeah we do
590:42 - and so i only want a one so i'm going to
590:44 - scale that down so i don't have to deal
590:46 - with two or actually we can just
590:47 - probably apply it
590:49 - to set up there update the value there
590:54 - get pods
590:55 - there we go
590:57 - and we'll just wait for that to connect
591:04 - while it's waiting we can just go ahead
591:06 - and describe it
591:09 - um
591:11 - so this will be for the deploy
591:14 - or we can describe the pod as well um
591:16 - we'll describe the deploy first no no
591:18 - we'll do pod
591:19 - we'll do pod and then we'll just copy
591:21 - the name here and just see like what
591:23 - kind of volume information we can see if
591:25 - any
591:26 - um so it says persistent volume claim my
591:28 - pvc not found so that's an error and
591:31 - that's why it's not proceeding forward
591:33 - so we must have spelled something
591:35 - incorrectly
591:37 - so we'll go back over here to my or our
591:39 - pvc here it says my pvc
591:42 - so that seems like that should be the
591:44 - name
591:45 - we'll type in cube ctl
591:48 - get pvc
591:50 - and there it is my
591:52 - pvc
591:54 - persistent volume claim
591:56 - not found
591:57 - [Music]
591:59 - let me just take a look at my
592:00 - instructions
592:04 - well it looks like it's totally fine
592:09 - let's just hit up and see if anything's
592:10 - changed
592:13 - no it still can't find that volume
592:17 - so let's take a look at the
592:18 - pvc volume itself
592:21 - and describe it and see if there's any
592:22 - issues
592:28 - so it has a volume it is bound
592:32 - and we'll go pv
592:35 - and that looks okay as well
592:40 - so i can think of is there's something
592:42 - wrong with my script here so i'll be
592:43 - back here in a moment and just compare
592:45 - my uh my old script with this one okay
592:47 - all right i'm back and so i just
592:49 - carefully stared and i can see what the
592:50 - problem is this is mv it should be m y
592:53 - so that's probably what our problem was
592:55 - and so what we'll do is just type clear
592:57 - and redeploy that hopefully it takes
592:59 - effect good
593:01 - and then we'll hit up until we can get
593:02 - to our pod the pod is going to have a
593:04 - different name so we'll have to go get
593:06 - pvc or sorry get pod
593:09 - and then from there we still have two
593:12 - one is running one is probably going to
593:14 - stop
593:17 - and if there's two deployments i'm just
593:19 - going to double check here
593:20 - nope we only have one
593:24 - we go
593:24 - and so i'm just going to grab that pod
593:26 - name and we'll just say cube ctl
593:29 - get pod here
593:31 - and we'll just describe it make sure
593:33 - there are no issues
593:37 - well
593:38 - gotta type it in the right place you
593:40 - can't do get described that makes no
593:41 - sense
593:42 - okay and so here we can see
593:45 - um there are no issues i'm just trying
593:47 - to see if there is the claim here it is
593:50 - read only false persistent volume
593:53 - so it's all in good shape so that's good
593:55 - to see let's go take a look at what it
593:58 - looks like for the actual
594:00 - um deploy so we'll say deploy and it's
594:02 - called
594:06 - sinatra with storage
594:10 - and there we can see the volume claim
594:12 - information again
594:14 - okay
594:15 - so now the next question is
594:17 - can we see if our volume is actually
594:20 - working
594:21 - so what we'll do
594:24 - is we'll go to that directory so i told
594:26 - you it was local here mount data
594:28 - remember this if we go back to our pv
594:30 - here
594:31 - we specified it's here so we actually
594:33 - have a mount a data directory there and
594:35 - i can just make a new file so i'll say
594:37 - touch
594:38 - and we'll just say hello.txt
594:43 - now we'll do a pseudo on that because it
594:44 - just doesn't like if we don't do sudo so
594:46 - now that we created the file what we
594:47 - should do is ssh or i guess um i say ssh
594:51 - but we're actually just remotely
594:52 - connecting to the shell so we'll type in
594:54 - cube
594:56 - execute hyphen i t
594:58 - and then we need the name of a container
595:00 - and then we'll have to have bin bash
595:02 - notice before we did like sh we probably
595:04 - do sh as well it's basically the same
595:06 - thing
595:07 - um in a new tab i'm just going to go
595:08 - ahead and grab
595:11 - the pod name so we'll say cube ctl get
595:13 - pods
595:14 - and that is the name of our pod
595:20 - double checking there
595:22 - yep
595:23 - and then we'll go ahead and paste that
595:25 - in here
595:30 - oh sorry cube ctl
595:33 - and so we're within our actual container
595:36 - now
595:37 - and so we mounted this at mount
595:41 - it's being kind of silly here we mounted
595:42 - this at mount m8
595:44 - mnt
595:46 - local data
595:47 - so i'm just going to do ls on here i
595:49 - don't i don't know why this uh this is
595:51 - kind of being a bit glitchy here
595:53 - if you notice i'm typing it's kind of
595:54 - going weird soft to type it out by hand
595:55 - no problem
595:57 - and notice we have hello txt and that's
595:59 - within our container so that's pretty
596:00 - much
596:02 - all we need to know for our persistent
596:03 - volumes
596:05 - i'm not going to clean this stuff up i
596:06 - think it's totally fine it's not going
596:07 - to heat up a lot of our resources here
596:09 - but yeah that's it for storage so just
596:11 - note that you always have to have a
596:13 - persistent volume claim
596:15 - um in order to attach a volume there
596:17 - there might be an edge case where you
596:18 - can attach a persistent volume to like
596:20 - static resources with a persistent
596:22 - volume claim but you always have to have
596:24 - a pvc with a pv with a storage class
596:27 - okay
596:27 - [Music]
596:32 - hey this is andrew brown from exam pro
596:34 - and this fall on we're going to be
596:35 - taking a look at net policy so again i
596:37 - want you to launch your micro case
596:38 - environment that we set up earlier in
596:39 - the course and what we're going to do
596:41 - here is just type in clear and
596:45 - get started here so in order for us to
596:47 - use net policies we're going to have to
596:48 - have some kind of cni so
596:51 - um
596:52 - cni plug-in right and so there's a
596:54 - variety of different kinds but for cube
596:56 - ctl they don't have a whole lot of
596:58 - options we just have
597:00 - psyllium so i'm not sure if that's the
597:01 - proper way to pronounce it but that's
597:03 - how i'm going to pronounce it here i'm
597:04 - going to type in cube ctl status or
597:06 - sorry micro k8 status
597:14 - and give it a moment here to load and so
597:15 - there might be other options here but
597:17 - the only one that i recognize here is
597:18 - called selem or cilium and so that's
597:21 - going to allow us to have uh full
597:23 - network policies all right so we'll go
597:25 - down below here and we're just going to
597:26 - type in micro case enable
597:29 - and then put in psyllium
597:33 - and then once that's in there what we're
597:34 - going to need
597:36 - this is taking a second here uh what
597:38 - we're going to need is to have some
597:40 - namespaces so with network policies we
597:42 - can isolate based on or like control
597:46 - traffic based at the pod level or at the
597:48 - name space level
597:49 - i'm going to do it at the namespace
597:51 - level for this example because we don't
597:53 - need to go
597:54 - too super deep into net policies we just
597:56 - need to get something working
597:58 - and i'll just pull up while that's going
598:00 - we'll type in net policies kubernetes
598:02 - and see what the documentation gives us
598:07 - all right and so here we are if we just
598:09 - scroll on down so here is a general
598:11 - network policy ours is going to be a lot
598:12 - simpler than this this says ingress and
598:14 - egress and
598:15 - it's quite quite fancy
598:17 - so what we'll do is go back here and see
598:19 - if it's ready it's not yet but i already
598:21 - kind of know what we need to do so
598:23 - what we'll do is we will create three
598:25 - different name spaces and we'll launch
598:27 - a server or a
598:29 - deployment into each of them and the
598:31 - idea is that we'll have
598:32 - uh one namespace that we'll try to talk
598:35 - to and one will
598:38 - be blocked and one will not be okay so
598:40 - what we'll do is create our name spaces
598:42 - we'll type in cubectl
598:44 - ns for short for namespace you can type
598:46 - namespace if you want but ns and we'll
598:47 - have one called fire
598:51 - and um
598:53 - oh sorry create
598:56 - and then we'll have fire ice
598:58 - and wind and so those will be our three
599:01 - name spaces that we'll be using
599:04 - then we'll have to launch some pods i
599:06 - don't feel like launching our sinatra
599:08 - app so i'm just going to deploy
599:11 - nginx
599:13 - all right and so we'll just put the
599:14 - image in here and say engine x and we'll
599:16 - make sure the namespace is uh for fire
599:19 - and so we'll hit up here and then what
599:21 - we'll do one is for ice
599:27 - and then we'll do one for wind
599:33 - okay and so now we should have all our
599:35 - pods so we'll just type in cube ctl get
599:37 - pods and ice
599:40 - wide
599:42 - hit up again
599:46 - um
599:46 - [Music]
599:48 - no resources found in the ice namespace
599:51 - what if i just type in
599:52 - pods here
599:54 - huh
599:57 - i guess the deploys are still happening
600:01 - let's just get deploys
600:07 - maybe just without the there okay and so
600:11 - we see that they're ready but they're
600:12 - not doing anything here so i wonder if
600:15 - we've like used up all of our resources
600:17 - on the machine
600:18 - so what we'll do is get deployed we'll
600:19 - say describe
600:21 - deploy hyphen end ice
600:24 - and we'll say ice engine x and we'll see
600:26 - what it's complaining about
600:31 - there's no errors so maybe it's just
600:32 - taking time
600:34 - i mean we are doing all this stuff over
600:35 - here so i'm not sure if that was
600:37 - conflicting with it we are seeing a
600:39 - connection refused issue so it looks
600:41 - like this probably didn't install
600:43 - properly
600:45 - okay
600:48 - and we'll go back here and do a get
600:52 - okay yeah so it just took some time here
600:54 - now this didn't work out
600:57 - i've never seen that happen before i'm
600:59 - just checking here created
601:04 - because when i when i did this it never
601:05 - failed a
601:08 - so we'll try one more time and see if we
601:10 - need to do that
601:12 - so it's already enabled so i'm not sure
601:14 - about all these errors i don't know this
601:15 - is going to run us into an issue but if
601:17 - we create our network policy and doesn't
601:18 - work we'll know that we don't have it
601:21 - properly installed but maybe we have
601:22 - enough installed
601:24 - and we'll be lucky okay so looks like
601:25 - all of our pods are running and stuff
601:27 - like that so
601:28 - what we're going to need to do is
601:30 - basically ping a pod from one other pod
601:32 - and so what we'll
601:34 - do i'm just going to
601:36 - write out a command here so we'll have
601:37 - to do cube ctl hyphen n
601:41 - choose um
601:42 - a name say so i'm going to do fire then
601:44 - we're going to have our pod name and
601:46 - then we're going to curl a ip address
601:49 - to somewhere and maybe i guess the idea
601:51 - is like
601:52 - this ip address is going to be like what
601:55 - we want to access so we say okay from
601:58 - from uh from an ice
602:01 - from an ice um
602:04 - pod
602:05 - hit this fire ip address okay
602:08 - that's what we're gonna do so what i'll
602:10 - do is just type in clear and the first
602:12 - thing we need is that pod name so
602:15 - we'll go and type in cube ctl
602:20 - get pods n
602:21 - ice
602:23 - we'll go ahead and grab that name on
602:24 - there
602:26 - i'm going to just move back there
602:30 - and then
602:31 - what we'll do is get fire hyphen o wide
602:34 - because we're going to need its ip
602:35 - address so there is its ip address
602:38 - okay and then we'll go to the right here
602:41 - and paste that on in
602:44 - and just complaining about this because
602:47 - maybe we forgot a word like exec
602:49 - there we go
602:51 - great and so the idea is nginx is
602:53 - running an nginx page if you hit this
602:54 - and so
602:55 - we can access the fire server from the
602:59 - ice server okay
603:01 - and just to show for
603:04 - the wind one so we'll do wind here
603:06 - and then we'll go ahead and grab
603:09 - wind
603:14 - okay
603:16 - we'll go ahead and delete this out
603:20 - great so
603:22 - right now we don't have network policy
603:23 - in place so it makes sense that they're
603:24 - able to communicate so now what we'll do
603:26 - is create ourselves a network policy
603:29 - i'm going to call netpal
603:31 - fire yaml
603:34 - and what we'll need to do is grab us
603:36 - some code
603:38 - so go to the network policy page we have
603:40 - up here this is a way too much we don't
603:42 - need this much code but we'll go here
603:44 - and i don't feel like dealing with
603:45 - egress so egress means
603:47 - leaving the pod ingress would be
603:50 - incoming from the potter container so
603:51 - we'll delete out the egress here and i'm
603:54 - just going to take a look off screen
603:56 - here to the policy that i created
604:00 - okay
604:02 - and we're going to rename this so it
604:04 - says net paul fire to ice so that's what
604:07 - it's going to be so we're going to allow
604:08 - communication from fire to ice or i
604:11 - should say ice to fire ice can
604:13 - communicate with fire okay but wind
604:15 - won't be able to communicate fire but
604:16 - it's all about fire so we'll just call
604:18 - it the pull fire here
604:20 - and then what we'll need is a pod
604:21 - selector so what we're saying is this is
604:23 - going to apply for our fire engine x
604:28 - right so select all those pods
604:30 - and then we need a policy type so we
604:32 - only want ingress so we'll just take
604:33 - that out for now
604:35 - and then from here they have like a from
604:36 - and they're doing ip block uh notice
604:38 - there's a namespace selector pod
604:40 - selector they're just showing a lot more
604:41 - information that we need this is going
604:42 - to be on port 80
604:44 - because that's going to be how we're
604:45 - doing the curls just on a
604:47 - port http there
604:49 - and so
604:51 - we're not going to do pod selector we're
604:52 - just going to do namespace selectors so
604:54 - anything from that name space will be
604:55 - able to communicate
604:56 - and so what we'll do here is just change
604:58 - this
604:59 - we'll need to figure out what the label
605:01 - is we're not going to do ip so we don't
605:02 - care about that but what we'll do is
605:05 - figure out
605:06 - what kind of label we can apply here
605:08 - because that's what we're going to need
605:09 - so
605:10 - what we'll do is type in
605:12 - cubectl
605:14 - getnamespace
605:16 - wind actually won't describe probably
605:19 - here
605:20 - and see what kind of ener labels we have
605:22 - so this is a label so we'll do is just
605:25 - grab this part here
605:27 - and paste that on in
605:29 - and then this part is going to be
605:30 - wind all right and so that should
605:34 - work
605:35 - uh we have to specify this is the fire
605:36 - namespace because it's definitely not in
605:38 - the default namespace
605:40 - and double checking
605:41 - looks okay to me
605:43 - all right so let's go ahead and give it
605:45 - a deploy so we'll type in apply f
605:48 - k8s
605:49 - netpole
605:50 - fire.yaml
605:52 - it's created the file so hopefully it
605:54 - works
605:56 - we'll type in cubectl
606:00 - get netpol
606:04 - oh hyphen end fire
606:06 - and we'll describe its contents just to
606:08 - see
606:10 - what there is here and so it's saying
606:12 - um pod selector is for fire allowing
606:16 - ingress traffic to port 80 so traffic
606:19 - into port 80 to fire but only from wind
606:22 - okay so ice should not work and wind
606:23 - should work so now if we just hit up we
606:25 - already set this up before and we'll
606:27 - just hit up until we find the commands
606:28 - we want so we'll try wind first
606:31 - and wind was able to download the page
606:33 - no problem
606:35 - and then we will go over to
606:39 - ice
606:41 - it's working so if they're both working
606:44 - and the policies in place that means
606:45 - that psyllium is definitely not
606:47 - installed properly so what i'm going to
606:49 - do here is type in micro ks disable
606:52 - psyllium
606:55 - see now when i ran this it was smooth as
606:58 - butter i just enabled it had no problems
607:01 - so i'm not sure why we're having
607:02 - problems here but we'll disable it and
607:03 - then maybe we'll re-enable it and
607:04 - hopefully it works but if the network
607:06 - policy is not in place then that's why
607:08 - it would not be working okay
607:17 - all right and so now we'll enable it
607:18 - again and we'll hopefully it'll just
607:20 - work because maybe when we were
607:22 - installing it there was just like
607:23 - network connectivity issues not relating
607:25 - to our environment but just
607:27 - what we were downloading it from
607:37 - and so i'll see you back here in a
607:39 - moment when this is done downloading
607:40 - okay and hopefully it installs properly
607:44 - all right so it looks like we're still
607:45 - having this here now again i did this uh
607:48 - same environment just a different
607:49 - account and had no problems with it so i
607:52 - just don't trust this environment i feel
607:53 - like there's something wrong with it so
607:54 - what i'm going to do is just type in i'm
607:56 - going to make a new volume so this will
607:57 - be micro k8
607:59 - of
608:00 - netpol
608:02 - env
608:03 - and so this will be our environment
608:05 - specifically dedicated for testing this
608:07 - example here so i'm going to go back
608:08 - here again you might not have this
608:09 - problem it might work perfectly for you
608:12 - and you'll just proceed forward with no
608:13 - problems but what i'm going to do is go
608:15 - ahead and set up a new
608:18 - pod here so we'll go ahead or sorry uh
608:20 - environment so i'm going to spin up this
608:22 - new environment i'm going to make my way
608:23 - over to the aws console
608:26 - right and from there i want to go to ec2
608:32 - and i'm gonna just see if there's any
608:34 - new machines here
608:52 - i'm not sure why it's not spinning up
608:54 - another machine
608:54 - [Music]
608:59 - not having much luck here today
609:12 - we'll go back to ec2
609:14 - normally ec2 instances show up pretty
609:16 - fast so i'm kind of just surprised there
609:18 - it is okay and so we'll go to our next
609:20 - uh network policy environment just for
609:22 - this case we'll go ahead and go over to
609:25 - our volumes
609:28 - and
609:28 - i'm going to click into the storage i'm
609:30 - going to modify it we're going to set it
609:32 - to 40 gigabytes so we don't have any
609:34 - problems here
609:37 - and then i'm just going to wait for this
609:38 - environment to start up uh here then we
609:41 - want to install micro kh so we'll go
609:44 - micro
609:46 - i mean it's just snap so
609:48 - well we'll go to the website micro
609:50 - creates
609:52 - and just quickly reinstall micro k8 on
609:53 - this environment because it was so easy
609:55 - since last time we did it so we'll paste
609:57 - that on in there
610:24 - and looks like our volume has resized it
610:26 - shouldn't be a problem here
610:30 - probably shouldn't be running commands
610:31 - unless we know it's been resized but you
610:33 - know i just want to get it done
610:35 - and so michael kate's there we'll have
610:37 - cube ctl
610:42 - and then we learned from our fix that we
610:43 - can do micro k8s
610:46 - config
610:47 - and then do a
610:49 - cube config
611:01 - maybe about to touch that file first
611:05 - just make an empty file
611:12 - well maybe we type in cube ctl and maybe
611:15 - it'll generate out that directory for us
611:22 - all right remember we have to type these
611:24 - things in
611:26 - so we'll go and paste that on in
611:28 - then we'll paste that on in
611:30 - then we'll paste that on in
611:33 - then we'll type in micro
611:35 - case cube ctl
611:38 - get pods and then it'll download
611:41 - oh no it didn't have to download it
611:42 - great and so maybe we'll hit up now to
611:44 - um that line we have here
611:46 - there we go and so now it did that so
611:48 - now i can do cube ctl cap pods
611:51 - good and now i'm going to just make sure
611:52 - i have enough space on this drive here
611:58 - and i'm just looking for
612:00 - the drive usually it's 10 but we set it
612:02 - to 40 gigabytes
612:04 - so looking for it here
612:07 - it's still at basically 10. so we'll go
612:10 - over to our ec2 instance back to it
612:15 - and i'm just going to go ahead and
612:17 - reboot it
612:22 - and we'll give that a moment to
612:23 - reconnect
612:34 - and so if this works that'll be great if
612:36 - it doesn't that would suck but i hope it
612:37 - does
612:42 - worst case scenario i could always just
612:43 - open my other environment and show it
612:45 - there but it's just kind of frustrating
612:46 - if i can't replicate it here
612:52 - and if this hangs too long you can just
612:53 - hit refresh sometimes that helps here
612:56 - too when it's doing a reconnect here
613:00 - or if it does that another thing i do is
613:02 - just go
613:03 - back to the cloud 9
613:08 - interface here
613:12 - and then i would open up netpol
613:26 - and if it is rebooting we can go back
613:28 - here and just double check
613:30 - so it's two out of two
613:42 - i guess whenever it decides to connect
613:43 - i'll be back here in a moment okay
613:45 - all right so i did a few refreshing and
613:47 - then finally let me back in here so it's
613:49 - not always perfect when reconnecting so
613:51 - we'll type in micro case status to see
613:53 - what we have installed because this is
613:54 - now completely fresh here
613:58 - micro k8 micro k8 status
614:08 - there we go we had to wait for it to get
614:09 - running there again i'm going to scroll
614:11 - up here and so all we have is the h a
614:13 - cluster so we'll want dns for sure
614:16 - so we'll go here and say enable dns and
614:19 - then um we want
614:22 - the psyllium right so we'll go here and
614:24 - grab psyllium
614:31 - and so i expect the nest install without
614:33 - issue but i'm hoping psyllium just works
614:35 - with a fresh
614:37 - fresh fresh fresh environment
614:54 - so this will take a little bit of time
614:55 - but i will wait until it's done here and
614:57 - i'll see you back in a moment okay
614:59 - all right so look it actually worked no
615:01 - problem this time so for whatever reason
615:04 - the old environments just kind of bust
615:05 - at least for that particular use case so
615:08 - we will have to uh back pedal here and
615:12 - redo a lot of the stuff we just did
615:14 - which is not a big deal it's not going
615:15 - to take too long to do so i guess we'll
615:17 - just go ahead and do it again and
615:19 - practice makes perfect right so we need
615:21 - our
615:23 - name spaces so we'll say create an s
615:25 - fire
615:26 - create ice
615:29 - create wind
615:31 - and then we need to create
615:34 - deployments so deploy
615:36 - fire engine x
615:38 - image engine x
615:41 - hyphen n
615:43 - fire
615:45 - and then we got ice
615:49 - okay and then we got wind
615:57 - great and so then from here what we'll
615:58 - do is we'll create ourself a new um
616:03 - file which will be our net paul fire
616:09 - yaml
616:11 - and we'll go back to our original
616:12 - environment here that we're running
616:14 - and i'm going to go ahead and just grab
616:16 - this file here
616:21 - we'll go ahead and paste that on in
616:26 - okay and that looks
616:27 - what we were using before so it's
616:29 - totally fine and so we'll type in cube
616:30 - ctl apply hyphen f actually before we do
616:34 - um let's go make sure we can communicate
616:35 - between our nodes
616:37 - so
616:38 - um uh let's remember what that command
616:40 - is so it's cube ctl whoops
616:43 - cube
616:44 - ctl hyphen n fire exec
616:47 - and then we need
616:50 - our pods here so we'll say new terminal
616:54 - so say cube ctl
616:56 - get pause and fire or sorry ice
617:02 - and then we'll say
617:04 - wind
617:05 - and then for fire we need hyphen o wide
617:09 - and so we'll go ahead and grab our ip
617:10 - address here
617:12 - paste that on in
617:14 - we'll go ahead and grab this one here
617:18 - and this is actually going to be for
617:21 - it was wind here a moment ago i already
617:23 - kind of forgot
617:25 - and i believe it goes here
617:30 - well the first one is ice
617:33 - wind oh sorry that says ice here so
617:36 - change that to ice
617:38 - and i believe it was uh hyphen hyphen
617:41 - curl
617:42 - and then localhost or i guess uh
617:44 - whatever the ip address is yeah there we
617:47 - go okay great so this one's set up and
617:49 - then i'm just gonna quickly do the wind
617:58 - so we'll do
618:00 - wind
618:06 - and then that one wind okay great so
618:09 - that works no problem now let's go ahead
618:11 - and deploy our network policy so we'll
618:13 - do cube ctl
618:15 - apply
618:16 - hyphen f
618:18 - net pull fire yaml
618:22 - and so it created it and so now what we
618:24 - can do is go hit up try out wind it
618:26 - works fine
618:28 - try out ice
618:30 - it works fine
618:31 - okay so
618:33 - one of those should have hung like it
618:35 - should have not worked
618:37 - but it didn't um
618:42 - so maybe there's something wrong with
618:44 - our selectors it does say roll up here
618:46 - which doesn't seem right to me
618:48 - so let me go back over here now
618:51 - like psyllium definitely did not install
618:52 - properly so i don't think our network
618:54 - policy was our problem i do believe that
618:57 - uh it wasn't installed correctly but
618:59 - let's just take a look at the actual
619:01 - selector name so we'll say
619:03 - describe
619:05 - pods
619:08 - and fire
619:11 - because i think it's just app by default
619:13 - yeah so it is so change this to app
619:17 - okay
619:19 - and then we'll have to redeploy our
619:23 - fire policy
619:25 - we'll type clear
619:33 - i'm just trying to find our commands
619:34 - that we type below maybe it's in this
619:36 - screen here there we go so does ice work
619:39 - notice that ice is hanging look it can't
619:41 - connect
619:42 - right because we said that wind is
619:43 - allowed to have access and not
619:46 - um not ice and so we go to wind
619:49 - and there we go so that's all there was
619:52 - to it unfortunately we had to take a
619:53 - bunch of detours there um but you know
619:56 - that's the learning experience and
619:57 - that's the hard parts that you're
619:59 - looking to watch so
620:01 - that's pretty much it
620:03 - and you can delete this environment
620:05 - because we're done with it so what we'll
620:08 - do
620:09 - is close the network policy environment
620:12 - and we'll go back over to
620:14 - our environments here i'm going to go
620:16 - ahead and just delete this one because
620:18 - we are done with it
620:22 - okay
620:24 - there you go
620:25 - and i'll see you in the next one
620:30 - [Music]
620:31 - hey this is andrew brown from exam pro
620:33 - in this following we're going to be
620:34 - looking at k native which is a
620:35 - serverless or serverless-like
620:39 - platformer tool
620:40 - for kubernetes and so because this is
620:43 - such a heavy duty tool on top of
620:45 - kubernetes i don't want to pollute our
620:47 - existing micro k8 environment so i'm
620:49 - going to create a new environment here
620:50 - we're going to call this k or micro k8
620:55 - okay native so it is a bit work to set
620:57 - up but in this case it makes sense to do
620:59 - it okay so we'll do env i'll do it next
621:02 - we're going to choose a t3 medium just
621:04 - so that we have sufficient space
621:07 - and or memory and here we'll choose
621:10 - ubuntu and we'll go next steps
621:13 - we'll go ahead and create that i really
621:15 - really wish aws would let us choose the
621:17 - storage size i'm just going to check if
621:18 - there's any additional options
621:20 - no they really should let you do that
621:21 - because it's such a pain that you have
621:22 - to go resize stuff we'll go ahead and
621:24 - create this environment
621:26 - and while that is creating i'm going to
621:28 - go over to a new tab we'll type in
621:32 - console.8bus.amazon.com we'll make our
621:33 - way over to ec2
621:35 - and we are looking for this new
621:37 - environment because we need to increase
621:39 - that volume size as per usual
621:41 - so we'll give it a refresh here
621:43 - and
621:44 - [Music]
621:45 - is it here yeah it's right there so
621:47 - we'll go into here we'll go over to
621:49 - storage
621:50 - we will choose the volume
621:53 - and i will go to actions
621:55 - and is the volume ready yet oh we have
621:57 - to choose it
621:59 - modify the volume and we'll change this
622:01 - to 40 gigabytes we'll hit modify we'll
622:03 - hit modify we'll go back to ec2
622:06 - and even though it is running we are
622:09 - going to restart it reboot it
622:12 - just to save us some trouble here
622:14 - and so now we just have to wait till
622:16 - this connects
622:18 - and then from there
622:20 - oh did it really reconnect that fast
622:24 - nope it's reconnecting okay great
622:26 - and so we just need to wait for that
622:28 - reconnection to happen as that's going
622:29 - let's go take a look at k native so k
622:32 - native here is enterprise grade
622:35 - serverless on your own terms so it says
622:37 - kubernetes-based platform to deploy and
622:39 - manage modern service serverless
622:41 - workloads if you're wondering what k
622:42 - native is compared to open foss or other
622:45 - serverless frameworks strongly recommend
622:47 - reading this article like versus open
622:49 - fos it is an article
622:51 - on the cnsf blog and it's very very good
622:53 - at explaining the stuff i like to the
622:55 - point that i actually grabbed this quote
622:56 - here and put in the course so we could
622:58 - understand the difference between the
622:59 - two but if you get an opportunity to
623:00 - read this whole thing and it doesn't
623:02 - just talk about those twos it talks
623:03 - about all the types of
623:05 - open source frameworks
623:07 - serverless frameworks for
623:09 - kubernetes but coming back over here the
623:12 - idea is kubernetes and just going
623:14 - actually to this article because it does
623:16 - outline it pretty well
623:19 - but k native already uses um components
623:22 - that we're familiar with like istio
623:25 - and it uses
623:26 - kubernetes underneath of course but
623:28 - there's three components to building
623:29 - eventing and serving and so venting
623:32 - serving is where we're spending most of
623:33 - our time but the idea is serving is the
623:35 - ability to quickly serve stuff that will
623:38 - automatically scale from scratch have
623:40 - routing and networking so the idea is
623:41 - that
623:42 - um when we are utilizing kubernetes we
623:44 - have to uh provision all these things
623:47 - like services and pods and deployments
623:50 - and so the idea with k native is that
623:52 - you just have one line and it does all
623:54 - the stuff for you you only have to set
623:56 - up you don't have to set up horizontal
623:57 - pod auto scale or anything it just all
624:00 - works for you does snapshots it
624:03 - has revisions for your code and then on
624:06 - top of that it has eventing so the idea
624:08 - is that not only does it make it easy to
624:09 - just
624:10 - provision
624:12 - things
624:13 - and have all those nice services around
624:15 - it but eventing allows you to
624:17 - trigger
624:18 - when these
624:20 - functions should run based on a bunch of
624:23 - stuff and so there's a whole ecosystem
624:25 - with that not sure why the redirecting
624:26 - is kind of messing up here so yeah down
624:28 - below
624:29 - they had on the website before i'm not
624:31 - sure why i can't seem to find it right
624:33 - now
624:33 - but
624:34 - on the k native page here they had a
624:37 - good description out here serving and so
624:39 - they talked about
624:40 - the integrations they had i can't seem
624:42 - to find it right now but the idea is
624:44 - that you can trigger stuff for that to
624:46 - happen so
624:48 - oh we're under serving i wanted a
624:49 - venting that makes sense now
624:52 - so the idea is that you have triggers
624:53 - channels descriptions there's all sorts
624:55 - of ways to uh trigger your k native
624:57 - events but now this environment's ready
624:59 - what we'll do is get micro k8 installed
625:01 - so we'll do the classic here
625:04 - okay
625:05 - and while that is going i'm going to
625:07 - install cube ctl just to save myself
625:09 - some time
625:11 - we'll just do cube ctl
625:21 - uh
625:23 - i think i might have just accidentally
625:24 - canceled that out there
625:27 - okay so cube ctl is installed micro case
625:29 - is almost installed here
625:32 - and then we'll have to wait for the
625:33 - server to spin up as that is going we'll
625:35 - go back over here and look at the
625:36 - tutorial to get getting started here
625:39 - look at the quick start here
625:41 - uh we'll have to also install um kn so
625:44 - kn is the um
625:46 - k native
625:48 - utility library so we'll have to go grab
625:50 - the binary as well
625:52 - um so the easiest way to do this is to
625:54 - go to the release page here
625:57 - and then what we need to do is download
626:00 - um the one that we need so
626:02 - amd 64 is x64 architecture x86 sorry and
626:07 - so that is the file that we need
626:09 - and i'll need to show that in finder
626:14 - and it's just downloading there as well
626:17 - while this oh now that we have michael k
626:19 - it's installed
626:20 - type in microcase dns
626:23 - and also k native
626:26 - uh enable
626:27 - assuming the uh micro kx is ready oh
626:30 - right we need to run these two lines
626:31 - here so we'll run this one
626:34 - and we will run this one
626:35 - [Music]
626:37 - and then we'll run this line here
626:40 - and then we'll go back up and we will
626:42 - enable dns and k native and those both
626:44 - will install assuming that
626:46 - the cluster is ready
626:48 - and i'm still waiting for this to
626:49 - download okay this is now done
626:52 - and so the idea here
626:55 - is trying to hide some things
626:56 - in my screen here but here is the file
626:59 - so i have it downloaded here and i'm
627:00 - just going to quickly rename this to kn
627:03 - because it is a binary right
627:05 - and then the next thing we need to do is
627:06 - upload it to
627:08 - cloud9 so if we go to file upload local
627:11 - files i'm just dragging that kn file
627:14 - it's just that file here right that we
627:16 - just renamed
627:17 - and it's going to be there so we'll go
627:19 - ahead and close that it uploaded pretty
627:21 - darn fast oh it's still uploading right
627:23 - here you can see the percentage
627:25 - so we're just going to wait for that to
627:27 - finish as that is going i'm going to go
627:28 - here and
627:30 - um make it so that we can use cube ctl
627:32 - so we'll type in micro k8 config
627:36 - tilde
627:37 - q a period cube config
627:41 - um
627:44 - maybe we'll close this tab here and
627:45 - reopen a new tab close
627:48 - and open a new terminal
627:51 - and hit up again
627:53 - we already did this so i'm not sure why
627:55 - i have to do this twice
627:59 - maybe i made a mistake
628:02 - maybe i forgot the s on there
628:04 - okay and then we'll go back there
628:08 - oh you know i forgot to put the
628:10 - um right angle bracket
628:12 - and so now we should be able to do cube
628:14 - ctl get pods
628:17 - clear
628:18 - we'll go over here and it looks like
628:21 - installation is still going
628:25 - and while that's going we should move kn
628:27 - into the correct directory so we'll go
628:28 - back over to k native and we'll have to
628:31 - chamod it
628:33 - so go over here and we'll check mod and
628:36 - then we want to move that into a
628:38 - location like user local bin
628:40 - so we'll say sudo move
628:43 - kn to user local bin
628:46 - great so kn is now
628:49 - ready to go there and if we go back here
628:51 - we're just waiting for k native to
628:52 - finish
628:53 - i'm just going to double check to make
628:54 - sure that it's anything else there we
628:56 - might check the version afterwards which
628:57 - might be okay to do so we'll go over
629:00 - here
629:01 - check our version
629:03 - cannot execute binary file exec format
629:06 - error
629:10 - i wonder if it's actually a binary let
629:12 - me just double check
629:18 - oh did i download the amd
629:21 - did i download the wrong one
629:24 - that's probably what it is
629:28 - all right well we'll go back over here
629:32 - and uh no amd is right yeah that's the
629:36 - one that we want oh but i downloaded
629:38 - darwin i needed linux for xxx darwin is
629:41 - for mac os i'm sorry so we'll download
629:44 - that one and i guess we'll have to go
629:45 - ahead and delete this other one here so
629:47 - we'll say remove
629:50 - sudo remove
629:51 - user local bin
629:53 - kn
629:56 - and now that's done downloading i'm
629:58 - going to go ahead and go grab that one
630:00 - so i'm just going to delete the other
630:01 - one here
630:04 - and we will open up our file upload here
630:07 - so
630:09 - file upload local files
630:12 - drag that on over
630:13 - we'll rename this to kn
630:17 - we'll drag that back on in there we'll
630:19 - have to wait for that to upload which
630:20 - shouldn't take too long we'll go over
630:22 - here and the k native should be
630:24 - installed uh we'll do cube ctl get pause
630:27 - and we'll just take a look at what was
630:29 - installed
630:30 - because everything's pods right so here
630:32 - you can see we have istio so istio was
630:35 - installed for it
630:37 - um we have cave native serving cave at
630:40 - native eventing just to kind of show you
630:42 - what's going on here and we're just
630:44 - waiting for this to download and then we
630:46 - can proceed generally forward
630:49 - but maybe i'll just take a look and see
630:51 - what kind of code i have here
630:54 - yeah we need to wait for kn
630:57 - so once we have kn installed we will
631:00 - then go towards serving our first
631:02 - service so here they have a hello world
631:05 - go example and notice we just do kn
631:07 - service create
631:08 - and it will do a bunch of stuff for us
631:11 - okay
631:13 - so that is now uploaded so now we'll
631:16 - just hit up and do the same thing we did
631:17 - before so we'll chamod our kn
631:20 - i'm just gonna close this so it's out of
631:22 - the way
631:23 - and then we will move our stuff into the
631:25 - correct directory
631:27 - okay
631:28 - kn version
631:30 - great
631:31 - so
631:32 - i think we're a-okay
631:34 - um
631:35 - so go back over to here
631:38 - we'll go ahead and grab this now they do
631:39 - have yaml notes that's using k native
631:41 - dev so the specification is different
631:44 - but looks pretty similar to what we
631:45 - normally see so we're going to go ahead
631:47 - and create this
631:51 - hit enter
631:53 - it's going to go ahead and create the
631:55 - sample
631:56 - now
631:57 - i think that
631:59 - when i created this i remembered that
632:01 - this hung for a long time even though it
632:03 - did create the service
632:05 - so if this takes too long i might just
632:07 - cancel or kill it out okay so i'm gonna
632:10 - type clear here
632:11 - and as this is going i'm just gonna go
632:14 - back up here and type in pods and just
632:16 - see if that spins up so yeah it is
632:18 - creating the container
632:20 - and maybe we can just kind of inspect
632:21 - what that pods doing so we'll say um
632:25 - i was going to type um
632:27 - cube ctl get
632:30 - pods paste that in there
632:32 - and then maybe describe it
632:38 - let me just kind of read what it was
632:40 - doing so down below
632:42 - it's successfully creating the image
632:43 - it's pulling the image
632:45 - it's creating a proxy things like
632:48 - that and i'll just hit up here again
632:53 - okay so that pod
632:55 - is
632:57 - there
632:58 - so go back here
633:00 - and the idea is that when we run this
633:01 - we're expecting this output to happen
633:03 - which
633:04 - seems like it's never going to occur
633:06 - anytime soon
633:09 - but we did just describe the service
633:12 - well hold on here so
633:15 - okay i know that's never going to finish
633:17 - but i know that it's ran so what we'll
633:19 - do is we'll just proceed forward so i
633:21 - know we didn't have this and so i had to
633:22 - go look up kind of see what the command
633:24 - is so if we type in kn
633:26 - service list we can see all the services
633:27 - we deployed so there is hello don't
633:30 - worry that it says it's not ready
633:31 - because it totally did it did definitely
633:33 - work we'll type describe hello
633:35 - and as you can see here it says hello
633:37 - default one revisions okay type age
633:40 - reason so definitely is working but i
633:43 - don't know why it hangs like this all
633:46 - right so but we did install k native we
633:48 - did run through the basis of the
633:49 - tutorial so technically you know we we
633:52 - did use k native uh in terms of the kcna
633:55 - it's not like you really need to know
633:56 - how to do this i'm just kind of showing
633:58 - you so you get more domain knowledge on
634:00 - this kind of stuff and kind of show the
634:02 - experience of where you might hit
634:03 - friction there but i'm just going to
634:05 - stop there and that's all i really
634:06 - wanted to show you 4k native so we are
634:08 - done and what i'm going to do
634:11 - is go back to our um
634:14 - uh
634:16 - like our cloud9 stuff
634:18 - just because we have so many darn
634:19 - environments i just want to go ahead and
634:20 - delete this one so you are not
634:23 - having spend
634:24 - we'll type in delete
634:26 - and that's it for k native okay
634:28 - [Music]
634:32 - hey this is andrew brown from exam pro
634:34 - and i showed uk native now let's go take
634:35 - a look at open foss and let's go set
634:38 - that up and we will have to set up a new
634:39 - environment i know this is a pain but
634:41 - it's better to set these up in islip
634:43 - just because um it is quite the large
634:45 - install so what we'll do is create
634:47 - ourselves a new environment we're going
634:48 - to type open foss
634:51 - faas
634:53 - env maybe just put micro k8 so we
634:55 - remember that it's micro k8
634:57 - and we'll go ahead and hit next step we
634:59 - will choose t3 medium
635:02 - then we'll choose ubuntu we'll scroll
635:04 - down and we'll hit next step we'll
635:06 - create that environment
635:07 - and we'll give that a little bit of time
635:09 - to create as that's going we'll type in
635:10 - console aws amazon.com
635:13 - make our way over to ec2
635:16 - and i'm just waiting for that new one to
635:18 - spin up as that's going
635:21 - we have this nice article
635:23 - which is open fast k native and more
635:26 - just to kind of show the architecture so
635:29 - with openvos it uses docker and it could
635:31 - either use docker swarm or kubernetes it
635:33 - has prometheus function watchdog api
635:36 - gateway it has a lot of stuff compared
635:38 - to k native
635:40 - and this article explains like that open
635:43 - foss is easier to use than k-native but
635:46 - you might have some issues moving from
635:49 - one provider to another
635:51 - so that is one concern there but you'd
635:53 - have to read the whole thing to fully
635:55 - understand it
635:56 - but what we're going to do is go to the
635:58 - open fos website
636:03 - and i think they kind of have a tutorial
636:05 - here that we might be able to kind of
636:06 - follow
636:10 - maybe getting started here deployment
636:15 - kubernetes
636:17 - ah here we are micro k8s
636:19 - nope that's no help i do have the link
636:21 - here off screen that i was using
636:25 - let me just go take a look
636:31 - um
636:35 - i think it's like first python function
636:37 - that's what we want so we'll type in
636:38 - open fos
636:42 - first python function
636:46 - that was definitely what i want to use
636:48 - here
636:52 - okay and we will have to install the
636:54 - fast cli well actually we don't because
636:56 - it's part of
636:57 - micro k8 so this environment is starting
637:00 - to run and so what we'll do is hit
637:02 - refresh here and we need to resize our
637:04 - drive as per usual so we'll go here to
637:07 - storage
637:08 - volumes
637:10 - and we'll go ahead and modify
637:14 - our volume and we'll change this to 40
637:17 - gigabytes and hit modify
637:22 - and while that's going we'll install
637:24 - micro k8 so we'll just go to micro k8
637:27 - website
637:28 - i think by now i have this memorized but
637:30 - i do not
637:31 - we'll go sudo snap install micro k8 it's
637:33 - classic we'll make a new terminal here
637:36 - and then we will do the same thing for
637:38 - cube ctl
637:43 - okay
637:50 - and we'll wait for that to install
637:52 - we'll check on our volume our volume is
637:54 - probably resized but we'll have to wait
637:56 - for microcase to finish installing
637:58 - before we do our reboot here
638:10 - there we go and then we will type in
638:13 - micro k8
638:15 - cube ctl
638:16 - and then it'll spit out the stuff here
638:17 - that it wants us to do so we will paste
638:19 - that on in there
638:22 - we'll do new groups micro k8s
638:25 - okay and then we'll do micro k8 cube c
638:27 - or uh config
638:30 - port slash cube
638:32 - config and see if that works
638:34 - i forgot the um
638:38 - arrow
638:41 - micro k8
638:43 - cube ctl get pods
638:47 - up again notice that it works now no
638:49 - problem okay and so we'll go back to our
638:51 - ec2 instance
638:53 - and we'll just reboot it
638:55 - so we'll say reboot reboot
638:58 - and that will have to reconnect
639:01 - and so yeah i mean it's not super tricky
639:05 - we don't have to install uh fast cli
639:07 - like we did uh kn because microcase has
639:09 - it already and it's kind of a pain to
639:12 - install so i'd rather not
639:14 - do it this way
639:17 - um
639:20 - yeah i think we could do microkids i
639:22 - can't remember actually now no you know
639:24 - what i think uh i think we actually do
639:25 - have to install it okay so we will
639:28 - install i'm just trying to remember
639:29 - right so
639:31 - i guess we can try when this is
639:32 - reconnected we'll type in microcades um
639:35 - and we'll see if it actually works but i
639:37 - think actually for this that i it is
639:39 - there but i ended up installing open
639:41 - fast cli because if we didn't i ran into
639:43 - an issue later on in this follow along
639:45 - and that's the reason for it
639:48 - but we have to wait for this to
639:49 - reconnect okay
639:50 - so i'll see you back here when this is
639:52 - reconnected all right so after waiting a
639:54 - short little while here it is ready
639:56 - again so uh we are in good shape so i'm
639:58 - gonna type in micro k8 dns and then
640:00 - we're gonna do open foss
640:04 - and i have to probably write the word
640:05 - enable in front of it so that it
640:07 - actually works and so that's going to go
640:08 - ahead and start to install open fast for
640:11 - us
640:12 - we also need to install
640:14 - the
640:16 - cli here so copy this line from where we
640:20 - ever found it here on the first python
640:22 - page
640:24 - and so
640:25 - it's saying running with sufficient
640:26 - privilege permissions attempt to move
640:28 - fast cli
640:30 - so we are okay okay for shape if i type
640:33 - it fast cli it does show up that is good
640:37 - and open fast is installing so it'll
640:39 - take a bit of time after it's installed
640:41 - we do need to verify it i'm going to
640:43 - close the micro cades page so it stops
640:45 - popping up and driving me crazy
640:48 - i'm just going to double check what we
640:49 - need to do for
640:51 - the next steps because we do need to
640:53 - verify the installation
640:57 - and i'm just double checking here to see
640:59 - if it's here i think um
641:01 - micro case is going to prompt us to tell
641:03 - us hey
641:04 - run this so you know that it's running
641:05 - yes it does and so what we'll do is grab
641:08 - this line to see if it works
641:10 - and the next thing is we need this
641:11 - password to actually use it so we'll hit
641:13 - enter and we'll get this nice little
641:14 - password so i'm just going to drop it in
641:16 - here i'm going to clear this out
641:19 - and then i'm just going to grab this
641:20 - password for the time being and save it
641:22 - here
641:23 - because we'll need it for authenticating
641:25 - to open bus
641:28 - and now what we need to do is actually
641:30 - go ahead
641:31 - and build our function so
641:34 - we'll go back over here and
641:38 - they have one here so they make a
641:40 - directory called functions and they put
641:41 - all these these files in here and stuff
641:44 - so let's scaffold a new python function
641:47 - using the cli
641:48 - sure why not so we'll go ahead and do
641:51 - this
641:52 - and paste that in
641:56 - and here it's provisioned us a new
641:58 - folder and hello python wow that's a lot
642:00 - easier than typing it all in by hand so
642:02 - if we open it up we can see the content
642:03 - so it says open fos it's saying where it
642:06 - is
642:07 - here is the function it's going to the
642:09 - handle is going to point to this
642:10 - directory which is going to open this
642:11 - handler.pi file if you have ever
642:14 - deployed an as lambda function or
642:16 - anything serverless this is looking very
642:17 - familiar right like a handler file and
642:19 - so here is our fancy handler file you
642:22 - have your requirements.txt for anything
642:24 - you want to install so what i'm going to
642:26 - do is go back here and take a look at
642:28 - the next step here and so it's just
642:29 - telling us to update the file with this
642:31 - print hello so we'll get back over here
642:34 - and replace the contents of this file as
642:36 - such
642:40 - and we will save that
642:42 - go back over here
642:44 - and i think that this stuff is showing
642:46 - up because it thinks that this is
642:48 - a lambda function which it is not it's
642:50 - an open fos function and then it's just
642:53 - saying look at the contents of that file
642:54 - it looks like it's correct because it
642:57 - set it up all for us which is great
643:00 - and then down below we can just build
643:02 - it as such so we'll go here
643:05 - and we'll type in fos cli build hyphen f
643:10 - it's going to prepare our function
643:18 - okay
643:22 - and i think that the image is being
643:24 - stored locally so it's not going out to
643:26 - uh
643:27 - because we didn't we don't have a
643:29 - remote repo i guess it's i guess it's
643:31 - building it here on the machine never
643:32 - mind
643:33 - so
643:34 - the image is built
643:36 - and by the way while we're at it we
643:39 - should do get pods hyphenate just look
643:41 - at all the pods that open fast added so
643:43 - we have prometheus basic auth alert
643:45 - manager gnats um
643:48 - q worker gateway and stuff like that and
643:50 - the gateway is something that we're
643:51 - going to have to use next because we
643:53 - have to have a way to connect to that
643:55 - pod
643:56 - so i'm just scrolling on down here and
643:58 - seeing how we can see
644:01 - the pod
644:03 - next
644:06 - because we want to deploy it right so we
644:08 - built it and then we want to actually
644:10 - deploy it so i'm looking for deploy
644:17 - ah here it is okay
644:19 - so now that we've built it the built the
644:20 - image let's go deploy it so we actually
644:22 - run the function and notice that we get
644:24 - an error it says connection refused
644:26 - failed to deploy with status 500
644:29 - and so
644:30 - for this i know
644:32 - that we will have to do port forwarding
644:35 - because i looked up another tutorial on
644:37 - getting started with open fast and what
644:39 - they had to do here
644:41 - was to port forward
644:44 - open fast
644:46 - and specifically for the the service
644:49 - called gateway
644:52 - we do 8080 colon
644:54 - 8080
644:57 - and so now that we have port forwarding
644:58 - i have to go over to our other tab here
645:01 - and then what we can do is try to deploy
645:03 - again
645:06 - and we don't have it in the context of
645:07 - this batch file so we'll just go ahead
645:09 - and copy this line here
645:11 - paste it on in
645:13 - it says unauthorized access so we have
645:14 - to log in first so we'll go ahead and do
645:16 - fast cli login and so now it wants the
645:19 - password so we'll have to do hyphen
645:20 - hyphen password
645:22 - and then we'll have to provide the
645:23 - password that we have it here
645:28 - okay and now we can go ahead and deploy
645:31 - and it says hello python so there you go
645:34 - that's how you deploy
645:36 - a serverless function with openfast
645:39 - so we're all done here and what we can
645:40 - do
645:41 - is go back to cloud nine and shut down
645:43 - this environment
645:49 - we'll go over here to open fast micro
645:51 - case environment we'll delete
645:54 - will delete
645:56 - and there you go again it's not
645:59 - needed to know the stuff for the exam um
646:02 - well there are serverless questions but
646:04 - just to kind of like really cement uh
646:06 - what these things are just by going
646:07 - through the motions of it okay
646:08 - [Music]
646:12 - hey everybody this is andrew brown and
646:14 - welcome back to another follow along and
646:16 - this time we're going to learn about
646:17 - helm so what i'm going to do is go to
646:18 - google and type in helm and here we go
646:21 - to the helm website so helm is a way of
646:25 - packaging your various scripts like your
646:28 - manifest files into
646:30 - a single package that people can use to
646:32 - quickly uh set up projects here and so
646:35 - i'm just waiting for the helm page to
646:36 - load i'm not sure why it's so slow here
646:38 - today but we'll click it again
646:41 - maybe they knew i was up to something
646:42 - and that's why it's slow but here it is
646:44 - the package manager for kubernetes
646:47 - so yeah just think of anything like ruby
646:49 - or python or node.js like npm install so
646:51 - you're installing basically a program
646:53 - but it's installing like those files
646:56 - into
646:56 - your cluster so above here we have
646:59 - charts and i'm not going to show you how
647:00 - to package um
647:02 - a helm project because that gets pretty
647:04 - complicated but we will install a
647:06 - project and take a look at the contents
647:09 - of one so helm has this artifact hub
647:11 - where you can uh view or browse a bunch
647:14 - of different kubernetes projects but i'm
647:16 - going to go up here and just type in
647:17 - postgres
647:19 - and um i just want to see one that
647:21 - actually has a bunch of code so we can
647:22 - just kind of look at uh what would be in
647:25 - a helm directory there's one for azure
647:28 - that is pretty good so i'll type that
647:30 - one in here and it's bitnami for azure
647:34 - okay so uh we'll go here and here is a
647:37 - project
647:39 - and if we go to the github repository
647:41 - they're almost always hosted on github
647:43 - but i'm just looking for the templates
647:44 - if we click into templates here it shows
647:46 - us all the files that are
647:49 - involved and notice that we have these
647:51 - like handlebar stuff here so you can see
647:53 - that you know you might have a template
647:55 - like a config map but then you have this
647:57 - pragmatic stuff where you can pass in
647:58 - values to helm and it will change that
648:01 - stuff but let's go find the repository
648:04 - if we can here that's what i'm looking
648:05 - for
648:06 - um
648:07 - where are you i know it's here somewhere
648:11 - so
648:13 - i mean there's the that's the azure uh
648:15 - uh
648:16 - uh container repository so i'm not sure
648:18 - if it'll show us that let's go ahead and
648:20 - grab that actually never go to the azure
648:21 - container repository there we go so we
648:23 - can't see it there so maybe this one is
648:25 - not a great example which is totally
648:27 - fine but here says this is the repo okay
648:29 - it is on github there we go so here it
648:31 - says postgres h a so high availability i
648:34 - assume and the idea here is you have
648:37 - templates
648:38 - and in your templates you can start to
648:39 - see we have a variety of different files
648:41 - you have postgres
648:43 - pg pool again i'm not going to get super
648:45 - deep into how this actually works but
648:47 - just to show you that the files are
648:48 - there then there's this values.yaml
648:50 - thing this defines the type of
648:52 - parameters that we passed into the
648:53 - template so there's a lot there i would
648:55 - imagine that when you use helm you you'd
648:57 - have a command flag like hyphen hyphen
649:00 - values and you pass the values you want
649:01 - or you could specify a file most likely
649:04 - but anyway that's the contents of a file
649:06 - but let's take a look at how we go ahead
649:08 - and install one so i'm just going to
649:10 - open up my off screen here my my helm
649:13 - instructions when i was trying to find
649:14 - something out i'm just trying to find an
649:16 - example of something that was um that
649:19 - worked very well and actually you know
649:21 - what i used juice box from oh wasp and
649:23 - that was actually really easy to use so
649:25 - what i'm going to do here is going to
649:26 - browse all packages
649:28 - and i think what i did is i went to like
649:30 - security or maybe i went to web
649:31 - applications that's probably what i did
649:34 - and if we go here we'll probably see the
649:36 - juicebox app so it is here or juice shop
649:39 - sorry and so if we scroll on down you
649:42 - have some instructions here but the real
649:43 - instructions you can see there's all the
649:45 - values um configured here but if you go
649:47 - to install it gives you the two steps so
649:49 - here it is but we'll need helm first
649:51 - installed on our micro case environment
649:53 - so launch your micro k8 environment and
649:56 - then once you're in there we're going to
649:57 - do ls
649:58 - we're going to need to install helm so
650:00 - if you do micro k8 status what you'll
650:03 - see here is that they do have a helm
650:07 - uh
650:08 - plug-in add-on whatever you want to call
650:10 - it module
650:12 - right here oh it is enabled on this
650:14 - cluster great so
650:16 - um but anyway the thing is is like we
650:18 - want to use helm 3. there is helm 2 in
650:21 - here so if you were to do micro creates
650:24 - enable helm that would give us two and
650:26 - the problem with that is that it uses a
650:27 - tiller server it's like this additional
650:29 - thing that's really complicated and so
650:31 - we'd want to activate helm3 now it looks
650:32 - like it got activated for another reason
650:35 - we could have been using something else
650:36 - and it had to be activated so i think we
650:38 - typed in like micro k8
650:41 - micro k8 helm 3 that's how we would
650:44 - probably access it yeah but i'm going to
650:46 - actually go and directly install
650:48 - the
650:49 - helm
650:51 - cli without having to do through michael
650:53 - k8 and we can just do that on ubuntu by
650:55 - doing sudo snap install helm i'm not
650:58 - sure if it'll ask us to do classic yeah
651:00 - it asks us to do classic i don't really
651:01 - understand this whole classic thing but
651:03 - we'll go ahead and hit enter and it's
651:05 - going to go ahead and install helm so
651:07 - now we just type in helm
651:09 - okay and so if we go back to our juice
651:11 - shop we're going to copy the first line
651:13 - here because we need to add the repo to
651:15 - know where this is stored all right so
651:18 - that could be on github it could be on
651:20 - elastic container repository azure's
651:22 - container repository
651:24 - docker hub maybe
651:26 - i guess not docker hub because that
651:27 - wouldn't make any sense but some kind of
651:29 - repository right
651:31 - and so
651:32 - um
651:33 - i'm losing where i am here we are so
651:34 - we'll go ahead and paste that in there
651:37 - yeah i guess the ecr
651:38 - might not make sense because that's for
651:39 - docker containers but um anyway so if
651:42 - you add the repository we'll go back
651:43 - here and we'll go grab our install chart
651:46 - and if we go back and paste that in it
651:49 - will uh go basically set up that
651:51 - application so if we read it here it
651:53 - says um
651:56 - default namespace deploy get the
651:57 - application url by running these
651:59 - commands and so this is the command we
652:01 - can run so all it's doing is doing a
652:03 - port forward because it's already
652:05 - running so if we do cube ctl
652:07 - um get pods a bit we can probably see it
652:10 - running there so there is the my juice
652:11 - shop i'm not sure what else that
652:13 - installed but uh i guess if we wanted to
652:15 - know we would just probably go to the
652:16 - repo and take a look here so where is
652:19 - that repo
652:21 - where are you source code here on github
652:25 - and so this is the i think the the one
652:27 - that uh we're using here and if we go
652:29 - into templates so it deployed a config
652:32 - map a deployment ingress a service so it
652:34 - deployed a bunch of stuff
652:37 - and um what we'll do is go back here i
652:40 - really wish i had deployed that in a
652:41 - namespace so we could easily delete it
652:42 - but that's totally fine i don't think
652:44 - we're going to run into a lack of space
652:46 - here but what we'll do is paste this
652:48 - line in here that's the one they
652:50 - suggested but one addition i'm going to
652:51 - do address
652:52 - 0.0.0.0 so we can access this outside of
652:55 - our cluster
652:57 - and i'm going to
652:58 - change the port here from 3000 to like
653:00 - 8081 something like that maybe but
653:03 - clearly the app is running on port
653:06 - whoops
653:07 - uh is running on port 3000 so almost
653:10 - like a ruby on rails app it's probably
653:11 - php though
653:13 - when you talk about vulnerable apps php
653:15 - is usually the one to go with so anyway
653:17 - this is now running and i don't know if
653:19 - the ports are open on that so what we'll
653:21 - do is go over to ec2
653:23 - and
653:24 - maybe just open all the tcp ports for
653:26 - our ip address so we don't have to
653:28 - worry about opening individual ports
653:30 - because this is just for development so
653:31 - we'll go to security we'll go to
653:33 - security groups
653:35 - and yeah so we only opened up that port
653:38 - but i'm just going to go ahead and say
653:40 - all por all tcp ports
653:43 - okay and that'll just save us a lot of
653:44 - trouble there so save that rule and then
653:47 - what we'll do is get the ip address of
653:49 - the cc2 instance that's running our
653:52 - environment here
653:54 - so if we go up here to details we're
653:57 - going to grab that public ip address we
653:59 - said it's on 8081. i'm just hoping that
654:01 - it works 8081 fingers crossed there it
654:04 - is and here's the awas juice shop if
654:06 - you've never heard of owasp it's um
654:09 - it's for security so it stands for open
654:11 - web application security project but
654:14 - really it's a organization that has um i
654:18 - think it's nonprofit yeah nonprofit
654:19 - organization that has not just one
654:21 - project but a lot of different projects
654:23 - and resources and stuff
654:25 - um to help you secure applications and
654:28 - they have like chapters like user groups
654:30 - meetups all around the world um and so i
654:33 - mean this is one of their apps or
654:34 - projects that helps you learn how to
654:36 - better secure apps so it's purposely
654:38 - insecure but that is the owasp app okay
654:42 - so maybe we'll just kill the olaf's app
654:45 - maybe by killing the deploy there just
654:47 - so it's not uh or run it in here but
654:49 - we'll do cube ctl get pods
654:52 - and i'm just gonna kill it
654:54 - so say cube ctl
654:56 - delete
654:58 - um
655:00 - delete
655:01 - pods this one
655:04 - okay and those other resources are still
655:05 - there but because it is an app that's
655:07 - designed to be vulnerable i know it's
655:09 - only access by rip address i figure we
655:11 - should just kill just in case but yeah
655:13 - that's all i wanted to show you with
655:15 - helm it wasn't that hard there you go
655:17 - [Music]
655:21 - hey this is andrew brown from exam pro
655:22 - and this follow along we are going to
655:24 - set up a service match using linker d
655:26 - now i did do this
655:28 - lab ahead of time but i'm going to tell
655:30 - you that i just couldn't get it 100
655:33 - working at least in cloud 9 because when
655:35 - you wanted to
655:36 - see the viz dashboard you have to have
655:39 - an ingress controller and that has to
655:41 - run on port 80 and if we are running in
655:44 - a cloud 9 environment we can't run on
655:46 - port 80 we're just not allowed to open
655:48 - up on that port so
655:50 - um i mean we can do it in cloud 9 and
655:53 - kind of get an incomplete tutorial but i
655:55 - figured let's try to do it in ec2
655:58 - and
655:58 - hopefully there we will be able to see
656:01 - the dashboard now if that doesn't work
656:03 - it's totally fine because we can see
656:04 - everything in the
656:06 - buoyant dashboard but
656:08 - we'll give it a go and do our best here
656:11 - uh for the kcna you're not expected to
656:12 - know how to set up a service mesh but i
656:14 - just want to go through the motions with
656:16 - it with you so you can kind of see and
656:18 - be able to really understand the purpose
656:20 - of a service mesh so i'm going to go
656:22 - over to ec2 and instances we're going to
656:24 - launch a new instance and it's going to
656:26 - go to the old wizard we're going to go
656:27 - to the new wizard even though i don't
656:28 - like it and we're going to type in here
656:31 - k8
656:33 - or a micro k8
656:35 - linker d
656:36 - okay
656:39 - linker d
656:40 - and we need to choose ubuntu
656:43 - and it's going to be on 20 which is
656:44 - totally fine 64-bit architecture here we
656:47 - want to have a t3 medium or we can have
656:51 - t2 but we'll just do t3 because we've
656:53 - been doing that this entire time
656:55 - t3 medium
656:57 - we'll scroll on down here and we will
657:00 - allow ssh traffic that's totally fine
657:02 - we're going to allow http traffic from
657:05 - the internet
657:06 - that's going to be totally fine
657:08 - and we're going to want to have 40
657:11 - gigabytes here
657:13 - and we'll go to advanced details
657:16 - and i'm just going to look through here
657:17 - to see if there's anything else we want
657:18 - i want to set a roll
657:20 - but where the heck do they put this is a
657:22 - totally new interface i don't know
657:23 - because i don't want to have a key pair
657:25 - i'm going to say no key pair here
657:27 - and what i want to have is attach a roll
657:30 - where the heck did they put it
657:34 - i'm looking for i am roll
657:39 - roll
657:40 - where are you
657:42 - is always changing the stuff on me like
657:44 - crazy
657:46 - shut down stop terminate detailed
657:48 - elastic credits
657:50 - capacity
657:54 - is it just gone
657:57 - hostname oh it's right here we're all
657:59 - for frick six and so we're gonna need to
658:01 - create a new i impulse uh profile get a
658:03 - new interface i'm not used to where
658:04 - things are and i probably already have
658:06 - one for ssm role but we'll just make a
658:08 - new one so we'll go here create a new
658:10 - role
658:11 - because we want to use sessions manager
658:12 - to connect to stuff and this is new too
658:14 - they just won't stop changing things on
658:16 - me so um
658:18 - they used to have like nice little icons
658:20 - so you could see what you're looking at
658:23 - so we are creating a database service
658:24 - account it is for ec2
658:27 - oh my goodness what is going on here
658:30 - introducing the new experience what do
658:32 - you what do you think it's terrible
658:35 - like
658:36 - no it's like the the drop out the the
658:40 - drop down
658:41 - is
658:43 - it used to be very clear
658:48 - what to click okay
658:50 - whoever is doing their designs i don't
658:52 - know they gotta send back the uh
658:55 - the intern okay because it's you can't
658:57 - even revert to the old experience and
658:59 - it's weird because it's still like using
659:00 - old elements but anyway so what we would
659:03 - need to do is choose um the use case for
659:06 - the service so we are doing the ec2 i
659:07 - guess this is clear i just i'm getting
659:09 - confused we'll go ahead and hit next and
659:11 - so i want ssm roll so hit ssm
659:14 - and we are looking for
659:17 - uh the proper one i'm just checking here
659:19 - because this one says this is deprecated
659:20 - use this one so that's the real one i
659:22 - want to look for and that's going to
659:23 - allow us to use sessions manager so we
659:25 - don't have to ssh and do anything super
659:28 - complicated so i'll just check box those
659:29 - there
659:31 - where is it
659:34 - okay we'll type in ssm again
659:37 - it is being super glitchy today
659:40 - and
659:42 - i want
659:46 - is it this one
659:49 - i'm gonna double check here
659:51 - amazon ssm manage instance core
659:54 - i'll type core instead
659:59 - there it is okay so we'll go ahead and
660:01 - hit next
660:03 - and we'll just say
660:04 - micro k8
660:06 - linker d
660:09 - roll ssm just so we know what it is
660:12 - click create roll
660:16 - and there it is okay so we'll go back
660:18 - here and now we'll type in
660:20 - linker d
660:23 - there it is and so now we can use
660:24 - sessions manager
660:26 - we'll go ahead and launch this instance
660:28 - a lot of work
660:30 - tons and tons of work to get this going
660:31 - here
660:33 - and now that that instance is launched
660:35 - we can go view it
660:38 - and the experience is not going to be as
660:39 - nice i'm going to tell you right now
660:41 - it's not going to be as nice as using
660:42 - cloud9
660:45 - but we are going to get through it and
660:46 - you will learn how to use a virtual
660:49 - machine without a nice environment
660:52 - so we'll refresh here
660:56 - because i'm waiting for these two status
660:58 - checks to pass we don't necessarily need
660:59 - to wait for it i'm going to hit connect
661:00 - and if it works that's fine so we see we
661:02 - have four options here is to do instance
661:04 - connect sessions manager ssh client ec2
661:07 - serial console they just won't stop
661:09 - creating new connection types we're
661:11 - gonna go with sessions manager here
661:12 - which is gonna be totally fine
661:14 - we'll give it a moment here to launch
661:17 - and hopefully we don't have to spend
661:18 - drivers or anything else with micro case
661:20 - but i guess we'll find out here in a
661:21 - moment um so
661:23 - it's connecting
661:24 - [Music]
661:25 - actually i'm just thinking this is an
661:27 - ubuntu instance so i i don't even know
661:28 - who i am so type who am
661:30 - i
661:32 - ssm user
661:34 - um good question i usually do those
661:36 - amazon links too so
661:38 - we'll type in sessions manager
661:41 - ubuntu
661:44 - user cause i don't know what the user's
661:46 - called
661:51 - like who's the default user
662:01 - okay so
662:02 - aws ubuntu
662:05 - default user
662:09 - it says okay so for amazon linux 2 it's
662:11 - ec2 user and it's ubuntu because we need
662:14 - to be the right user when we do this it
662:15 - always logs us as the ssm1 which is
662:17 - silly we'll type in sudo su hyphen and
662:20 - then we'll type ubuntu and we become the
662:22 - user that we want to be there we go
662:24 - we'll type in clear notice that this is
662:26 - a lot more limited and you'll just have
662:29 - to live with it it's not a big deal and
662:30 - so what we'll want to do is go install
662:32 - micro k8s
662:37 - and hopefully we don't run into any
662:39 - serious problems but we'll go here
662:43 - and hit
662:44 - paste
662:47 - we'll try again copy
662:52 - and then paste there we go hit
662:54 - enter and that will install it
662:58 - close that off there
663:00 - and we'll wait a little bit of time here
663:02 - shouldn't take too long to install
663:05 - actually while it's going let's go take
663:07 - a look at link rd
663:09 - so
663:10 - i mean there's istio there's linker d um
663:12 - we're doing liquor d just because that's
663:14 - what i do the lab with uh we could have
663:15 - done istio but
663:17 - it's just what it is so linker d is a
663:19 - service mesh it gives you all this cool
663:22 - functionality on top of it and it makes
663:23 - it really clear once you start to see
663:24 - the dashboard so if we type in like
663:26 - linker d
663:28 - linker d uh viz here
663:34 - i'm just trying to show you what it
663:35 - looks like here if i can find a
663:36 - screenshot
663:39 - maybe type dashboard
663:43 - the idea is once we get it running we're
663:45 - going to get all this kind of rich
663:47 - information
663:48 - about our network and stuff like that
663:50 - and that's really useful when you have a
663:53 - lot of pods and you're just trying to
663:54 - figure out what's going on like where
663:55 - are requests coming from what's the
663:56 - latency
663:58 - all sorts of information that's within
663:59 - prometheus
664:00 - okay and then there's buoyant which we
664:02 - might use here so let's go back here and
664:05 - see if it's installed it is installed so
664:07 - now we'll install cube ctl
664:15 - and now we will see if our
664:18 - micro ks is running so we'll say get
664:20 - pods see if it works
664:22 - that's okay we'll type in micro k8 in
664:23 - the front of it
664:25 - and we'll run these lines as per usual
664:26 - as it likes
664:29 - so it's a bit tricky here so you might
664:31 - have to right click
664:33 - go paste
664:39 - and then we'll grab this here
664:43 - if the font is too small i'll try to
664:44 - bump it up here
664:46 - there we go
664:48 - and we'll go back here and now we'll
664:50 - type micro k8
664:52 - um config or actually we'll type in cube
664:54 - ctl first
664:56 - get pods we don't expect to find
664:58 - anything good
664:59 - and then from here we'll type in config
665:02 - lesson arrow
665:03 - tilde
665:04 - and then
665:06 - cube config
665:09 - we'll put pseudo in front of that
665:12 - oh it's really not liking today
665:18 - permission denied okay well what if we
665:21 - get the contents of that file
665:22 - because that's all we need really um
665:32 - cube ctl get pods
665:35 - no
665:37 - because all that's doing is it's
665:38 - probably piping this information into
665:41 - here
665:42 - so maybe we can just copy the contents
665:45 - like this
665:47 - and i'm going to type in vi
665:50 - tilde cube
665:52 - config
665:54 - it's in vi so by every key matter so hit
665:57 - i to go to insert mode
665:59 - right click
666:00 - paste
666:02 - okay and just make sure it's not cut off
666:03 - at the top i hit escape to go back to
666:06 - visual mode notice when i hit i it goes
666:08 - to insert mode i hit escape i'm out of
666:10 - here so now what i want to do is type in
666:12 - colon wq
666:15 - exit type clear then we'll type cube ctl
666:19 - um get pods
666:21 - okay so now cube ctl is working as
666:23 - expected so now we'll go and type in
666:25 - micro k8
666:27 - dns
666:28 - and then linker d
666:30 - linker d
666:33 - and we'll have to type enable in the
666:34 - front there
666:36 - so that's going to go install a bunch of
666:37 - stuff it's going to create its own name
666:39 - spaces and stuff so you can see it's
666:40 - creating service count config maps
666:42 - deployments all sorts of fun stuff while
666:44 - it's going let's go look up
666:46 - linker d
666:48 - tutorial here
666:50 - getting started
666:56 - i'm just going to see if this is the
666:57 - thing that i use to go through it yeah
666:59 - generally i think so we'll have to do
667:01 - link or do check here
667:08 - okay
667:10 - we'll go back over here
667:14 - the only uh unfortunate part is that we
667:16 - don't have multiple tabs right so
667:19 - uh when we're running things here it's
667:20 - going to be a little bit hard hopefully
667:22 - we don't need to have more than one tab
667:25 - for this to work
667:33 - i'll see you back here when this stops i
667:35 - don't know this is just going to happen
667:36 - for a very long time or if it will
667:38 - finish after a while but i'll see you
667:39 - back here if and when this is done okay
667:42 - all right welcome back so it did it did
667:44 - finish installing it installed a lot of
667:46 - stuff like tons and tons of stuff let's
667:48 - just take a look at what we have um so
667:50 - we'll type in cube ctl get pods hyphen a
667:55 - and you can see that we have a linker d
667:57 - name space
667:59 - a linker d vis namespace
668:02 - identity destination proxy injector
668:04 - grafana prometheus web all this sorts of
668:07 - stuff um just to understand the
668:09 - architecture better we'll type in linker
668:10 - d
668:12 - architecture i don't know if it's going
668:13 - to help much but we'll take a look at it
668:14 - anyway because they have this
668:16 - architectural diagram so the idea is
668:17 - that it created a control plane and a
668:19 - data plane right so and these are
668:22 - um well i guess this is your usual stuff
668:24 - right this is your stuff but it created
668:25 - its own control plane uh in the linker d
668:28 - name space and here it has an identity a
668:30 - destination proxy stuff like that but
668:32 - what we'll need to do is we will need to
668:34 - run a program and then inject
668:37 - um
668:38 - the sidecar into the pod so that
668:41 - link rd can monitor it and we could be
668:43 - using our deployment yaml file with our
668:46 - sinatra app but because we're in this
668:48 - very constrained environment we'll just
668:50 - use the one that they have okay so they
668:52 - have one here for uh emoji voto and so
668:56 - we'll go ahead and copy this one and so
668:58 - it looks like
668:59 - they have their own yaml file so we'll
669:01 - go ahead here
669:02 - back to sessions manager and we will go
669:04 - and paste this in below
669:07 - and hit enter
669:10 - and it looks like we have an app
669:12 - deployed
669:13 - so then we will go back over to here
669:16 - and then it says oh we have port forward
669:18 - so we can do some port forwarding here
669:23 - to
669:26 - this
669:29 - unable to board for it because it's not
669:31 - running so i guess we're waiting for the
669:33 - pods to
669:35 - run so we'll go back here to pods
669:39 - maybe to deploy maybe it's still
669:41 - deploying
669:44 - did this deploy in a particular
669:45 - namespace i'm just going to double check
669:46 - yeah it does have its own namespace
669:49 - so we'll go here and then say
669:51 - n
669:53 - emoji
669:54 - photo
669:57 - and they're ready now so we'll go back
669:58 - here and we'll do some port forwarding
670:01 - okay so that's on port 8080 um
670:05 - oh sorry so
670:07 - um
670:08 - yeah i think it's forwarding to 8080
670:10 - which is totally fine i don't know if we
670:12 - need to yeah it's going from 127 0 to 0
670:15 - 0.0 like anywhere do we need port
670:17 - forwarding i guess we do
670:18 - double check here what did it create
670:21 - because we don't have an ingress
670:22 - controller so it must be internal
670:24 - it's probably not exposed anyway so
670:26 - we'll go back to our instances and from
670:28 - here we need to find our ip address
670:30 - everything's kind of big because i
670:32 - expanded it for
670:34 - this page here it's just going to keep
670:35 - bumping down like that
670:37 - we'll go in here we'll grab our public
670:39 - ip address
670:40 - and we'll paste this in here and it
670:41 - shouldn't work because we need to open
670:43 - up that security group so we'll go here
670:45 - to our security groups
670:46 - and we'll go to security groups again
670:49 - and we'll edit the inbound rules and we
670:51 - will open up port 8080 so we'll say all
670:53 - tcp
670:55 - custom actually not all tcp yeah we'll
670:57 - do it for us because i don't care i
670:59 - don't want to have to open all the
671:00 - individual ports let's say andrew's
671:02 - computer
671:03 - that's our ip address so no one else can
671:05 - see it
671:06 - and now when we go here to port 8080
671:09 - we should see there app
671:13 - give it a moment here i think it's just
671:14 - loading i think it is working
671:17 - if it's not we'll do http colon slash
671:21 - sometimes the protocol matters
671:29 - says it should work
671:33 - my thought is that it's not binding to
671:35 - uh the address a it's on localhost
671:39 - and i'm gonna bump this up here
671:44 - so we have port forwarding
671:48 - here
671:50 - but it's not creating a proxy per se
671:55 - um i'm going to look at how we did this
671:56 - earlier because we obviously did it
671:58 - earlier in our like mini cube and cube
672:00 - ctl stuff i just don't remember
672:06 - how we did it so just give me a moment
672:08 - here
672:10 - you know what yeah we need to bind on
672:12 - the address
672:13 - so it's address and then we'll say
672:15 - 0.0.0.0
672:18 - okay and then we'll go back here hit
672:20 - enter
672:22 - cool we can vote for emojis um
672:26 - i always use upside down
672:27 - and it isn't an option so i guess that's
672:30 - how it is
672:31 - we'll do the leaderboard cool that's a
672:33 - nice little app they have there
672:35 - all right
672:37 - so our app is running
672:39 - and we will go back over to linker d
672:43 - and uh if you click around you might
672:45 - notice that it's a bit broken for
672:47 - example if you try to vote for donut
672:48 - you'll get a 404.
672:50 - sure let's give it a go
672:53 - where's the donut let's try taco
672:56 - that's fine
672:58 - vote on your favorite donut ah 404 okay
673:03 - so we got a 404 there
673:06 - these errors are intentional so we can
673:08 - identify the problem so with emoji
673:10 - installed running we need to add a mesh
673:13 - to it
673:14 - so we are basically injecting it so it
673:16 - says cube ctl get emoji deploy
673:19 - it's going to then do link or d inject
673:23 - and so liquid d inject is going to
673:25 - inject that data into there so this is
673:28 - what's going to install it
673:30 - like the sidecar so that we can track it
673:32 - okay so we'll go back here i'm going to
673:34 - kill this
673:35 - we'll paste that oops we'll paste that
673:37 - in there hit enter
673:41 - uh command not found linker d
673:45 - i think it's because we all have to do
673:47 - micro k it's like this micro k8s
673:52 - hit enter
673:55 - there we go so now it's been injected so
673:57 - technically linker d should be tracking
673:59 - it
674:01 - um it explains it that's totally fine
674:04 - and so then congratulations you now add
674:05 - link or d just as the control plane is
674:08 - possible to verify everything is working
674:09 - the way it should check your data plane
674:11 - with linker d
674:13 - proxy check so we'll copy that line
674:15 - we'll go back here paste it on in hit
674:18 - enter
674:19 - we'll have to do micro k8 in front of it
674:23 - we're getting a bunch of check boxes so
674:24 - i'm assuming yeah we're waiting for the
674:26 - data plan to be good it says everything
674:28 - is a-okay so
674:30 - it looks like it's been installed
674:31 - properly
674:33 - i'm kind of curious if we take a look at
674:37 - we say um the pod so we say cube ctl get
674:41 - pods and
674:43 - what's the thing called emoji vote
674:48 - we'll do cube ctl
674:52 - get
674:54 - uh ns
674:57 - it's actually emoji
674:59 - photo
675:04 - and then i just want to take a look at
675:08 - the app because all these have been
675:09 - injected right so i'm just curious if
675:10 - we'd see anything in the describe i
675:12 - don't think we will but
675:13 - just for
675:17 - sanity i'm just going to check okay
675:18 - describe pod
675:20 - paste the pod name in here
675:25 - pods
675:31 - well the pod is right there so i'm not
675:33 - sure what it's talking about
675:36 - did i make a mistake emoji no it looks
675:38 - right
675:44 - all right well whatever oh you know what
675:47 - it's because we need the namespace
675:49 - emojivodo
675:51 - there we go
675:53 - um i'm just trying to see if like we can
675:54 - see anything because the idea with like
675:56 - link or d is
675:58 - that it's it shouldn't touch the code or
676:01 - anything here but we are seeing stuff in
676:03 - here so we can see things like linker d
676:05 - proxy
676:06 - so there's some volumes that are mounted
676:08 - to our thing
676:10 - and then there's a bunch of this stuff
676:12 - so look at the proxy so yeah i guess you
676:14 - can see stuff so i just wanted to see if
676:16 - that was the case
676:18 - we'll go back over to here
676:20 - and we'll explore linker d so we want to
676:23 - install a viz and so visit is an
676:25 - extension that allows us to see metrics
676:28 - so we'll go here and install that
676:32 - all linker d install is doing if you do
676:34 - vis install what it will do is output
676:36 - i'll just run it without the other one
676:38 - just so you can see what it does
676:39 - so we'll paste that in there paste
676:42 - micro k8 and all it's going to do is
676:44 - print out
676:45 - code so this is actually what it's going
676:46 - to run so when you see it piping here
676:48 - it's actually going to do an apply
676:50 - by taking that content so go back here
676:53 - paste the full line in here and run it
676:55 - we have to put micro case s in the front
676:58 - here every single time
677:01 - and so now it is installed vis metrics
677:05 - and then down below here it says to
677:07 - install buoyant and so we don't have to
677:09 - install buoyant right away because that
677:11 - is a third-party cloud services this is
677:13 - them being tricky to try to get you to
677:14 - sign up for um services so buoyant is a
677:18 - cloud provider that
677:20 - um tracks a bunch of stuff and it's
677:22 - optional and i might uh do it in this
677:26 - tutorial here but i just
677:27 - like the fact that they did that without
677:29 - telling us what was going on here but
677:31 - now that we have that running we want to
677:32 - be able to see
677:34 - the dashboard so i'm just looking up how
677:37 - do we do that
677:40 - to actually visualize
677:42 - that dashboard here i'm just looking at
677:44 - my instructions when i was going through
677:46 - it
677:48 - [Music]
677:50 - um we type in
677:56 - micro k8s
677:57 - linker d
678:00 - viz dashboard
678:06 - okay and so now we have the dashboard
678:08 - running on port 50750
678:13 - it's not bound to address
678:15 - 0.0.0.0 so i don't know how that's going
678:17 - to work but we'll give it a go anyway
678:22 - and that's where i ran into an issue
678:24 - where i needed an ingress controller so
678:25 - that we could actually see it
678:27 - um i'm just trying to find where we are
678:29 - so if we do this
678:32 - notice that it's not resolving right so
678:34 - the problem is is that we are running
678:36 - the dashboard
678:38 - but
678:40 - the dashboard needs to be um exposed
678:43 - somehow
678:44 - and so i think the way i did it
678:48 - um
678:50 - was setting up an ingress so we'll type
678:51 - in expose
678:53 - this dashboard linker d
678:56 - this is the part that i'm saying that i
678:58 - wasn't sure if i'd be able to show you
679:00 - because i literally didn't test this in
679:02 - the ec2 i just said hey let's do this
679:03 - tutorial okay and so here they're saying
679:05 - like instead of using link or dvis
679:07 - dashboard every time you'd like to see
679:08 - the dashboard make an ingress controller
679:10 - but we need one because we need to run
679:12 - it on port 80 for it to work because i
679:14 - googled as well like other stuff and it
679:16 - says like if you expose it on an ingress
679:18 - controller it's not port 80 it will mess
679:20 - up
679:21 - i couldn't you can't send an ingress
679:23 - controller anything besides http https
679:25 - which is 18443 and that's where we ran
679:27 - into issue
679:28 - so down below here it says engine x
679:31 - that's what we were using before so we
679:33 - probably should just use it
679:35 - and um
679:37 - i guess what we'll do
679:40 - is we'll do what we did before which is
679:43 - uh enable
679:45 - um the index controller from our ingress
679:46 - tutorial so we're going to leverage that
679:48 - knowledge i'm just trying to find where
679:49 - we are here so i'm going to type in
679:51 - micro k8 status
679:55 - and we are going to need ingress so
679:58 - we'll go up here and type in
680:01 - uh micro qris
680:04 - ingress
680:08 - notice that like traffic ingress
680:09 - controller i don't know how to use that
680:11 - one and i only know how to use the
680:14 - nginx one so i don't want to learn
680:16 - something new right now so we'll go back
680:17 - up here and type in
680:19 - enable
680:22 - and while that's going on i'm going to
680:23 - go take a look
680:25 - at our ingress tutorial to try to get a
680:27 - refresher here on how do we set this
680:29 - stuff up
680:31 - so
680:33 - yeah we install ingress
680:35 - oh it already does nginx so it is
680:36 - installing nginx and so i guess all we
680:38 - need to do is now create an ingress
680:40 - yaml file
680:44 - so
680:45 - what we'll do here is
680:49 - it's kind of a pain
680:51 - to
680:52 - write it out so what i'm going to do is
680:54 - go over here back to our cloud9
680:55 - environment because we should still have
680:57 - that file in our micro ks environment
681:00 - i'm just going to go
681:02 - ctrl 0 to go back to normal size here
681:04 - and we'll launch this here and we'll go
681:05 - grab that and then tweak it just so that
681:08 - it's a bit easier
681:12 - and so
681:13 - [Music]
681:14 - i mean we probably could use the one
681:16 - that they have here but i just don't
681:17 - know about it
681:23 - i guess we could try it also needs a
681:24 - password so that authenticates it passes
681:26 - it to basic off
681:28 - um it's also using secret i don't think
681:30 - we need to enable that
681:32 - i don't think we need our rbac
681:34 - this says it's on port 8084
681:39 - dashboard i think this is fine so what
681:41 - we'll do is we'll go ahead and copy the
681:43 - contents here i know we're launching
681:44 - this but if
681:45 - we'll try to yeah give this a go first
681:48 - so
681:51 - um i'm just double checking here the
681:52 - host does the hostname matter this
681:54 - exposes the dashboard dashboard
681:56 - example.com
681:58 - and protects it with basic auth
682:02 - hmm
682:04 - i don't know if we need to have a host
682:06 - name so we'll just say
682:08 - cubectl or sorry um
682:11 - linkerd
682:15 - expose
682:16 - dashboard stack overflow because i feel
682:20 - like we might see an example that's not
682:21 - using that
682:24 - because this person probably wanted to
682:25 - do a particular port and see they're
682:27 - using the same code here notice that
682:28 - they took out hostname because we don't
682:30 - want to have that hostname
682:32 - and it says it's never going to be a
682:34 - path like that it needs to serve on the
682:35 - root of the url so change the route here
682:37 - and so that's what i remember i was
682:39 - reading here
682:40 - this is correct i've only added using
682:42 - the rewrite target there
682:44 - so
682:45 - looking at this one here i'm going to go
682:47 - copy this content we're going to go over
682:49 - to our micro case environment i'm just
682:50 - going to make a new one here new file
682:52 - called
682:52 - linker d
682:54 - um
682:55 - ingress
682:56 - yaml
683:00 - this doesn't work it's totally fine but
683:01 - i just want to try if we can
683:05 - and so i'm just going to see what they
683:06 - did we can put anything we want in here
683:07 - i think that's what it'll take
683:09 - and so i don't see the annotation on
683:13 - this oh i guess this is the secret so
683:15 - it'd be down below here oh yeah so
683:16 - engine x
683:18 - we've got a bunch of headers here this
683:19 - is this looks fine i guess
683:22 - 8084 that's totally fine so i think what
683:25 - it's saying is you can't do this you
683:27 - can't have link or d on that so i'm
683:29 - going to delete that out of there
683:32 - and then i'm going to go ahead and copy
683:34 - all this here
683:36 - i'm going to right click copy
683:39 - go back to our environment here i'm
683:40 - going to bump up the font i'm just doing
683:42 - control plus to do that
683:45 - and
683:46 - i'm going to touch a new file called
683:48 - ingress.yaml
683:50 - and i'm going to do vi ingress.yaml
683:53 - and this is vim so remember every key
683:55 - matters so hit i
683:57 - and then right click paste
684:00 - and then just uh hit escape
684:03 - and then what i'm doing is i'm hitting
684:05 - um
684:06 - k on my keyboard k goes up so hit k all
684:09 - the way up i'm making sure nothing's cut
684:10 - off and then hit j all the way down jj
684:12 - jjj
684:13 - and that looks fine so i'll do colon
684:15 - wq write and quit
684:18 - and so i have this ingress file and so
684:19 - i'm going to try and deploy this so
684:21 - we'll say cube ctl
684:23 - apply
684:25 - hyphen f ingress yemel
684:28 - and it says
684:30 - no matches for kind ingress in version
684:32 - beta 1. so i'm going to hit up again
684:34 - we'll hit vi ingress yaml and then we'll
684:37 - hit k to go all the way up
684:40 - down we're hit j to go down okay
684:44 - i'm trying to get this beta so if i hit
684:45 - h and l h moves me left l moves me right
684:49 - i'm sorry for all the vim stuff
684:51 - and so what i want you to do is move
684:53 - over to the v using the l button and
684:55 - then hit c for change
684:57 - and then w for word
685:00 - and now it's in insert mode okay so now
685:02 - the keyboard acts like a normal keyboard
685:04 - and we're going to type v1
685:07 - okay because that code is just old and
685:08 - hit escape
685:10 - and then colon wq
685:13 - all right and then we'll hit up again
685:14 - and then we'll try to apply the ingest
685:16 - controller
685:18 - so it says no match ingress type so i'll
685:20 - go over
685:22 - oh you know it's even more wrong than i
685:23 - think it is we go head up here again
685:26 - sorry for revise so we'll hit h
685:28 - to go to the left all the way to
685:30 - extensions and hit cw when you're on the
685:33 - e c for change w for the word
685:35 - notice that it's an insert mode so now
685:37 - we're typing normally and it's actually
685:40 - networking
685:43 - dot k8s
685:45 - dot io
685:47 - and then hit escape
685:50 - and then colon wq
685:52 - hit up we'll try to apply it again
685:55 - oh it just doesn't want to work okay so
685:57 - error validating ingress yaml
686:01 - um
686:02 - validation unknown field service port in
686:06 - io k-8s
686:08 - api networking if you choose to ignore
686:10 - these errors
686:12 - turn validation off
686:16 - i think the reason why is the syntax
686:17 - change as well so hit up again i'm so
686:20 - sorry for this
686:22 - and then hit j to go down
686:24 - down down down and this syntax has
686:27 - changed so instead of it being service
686:29 - name back end like this it's actually if
686:31 - you go over here to the colon or sorry
686:33 - go to this line here and hit
686:35 - or actually go to the sign here to sorry
686:37 - the back end here colon and hit o
686:40 - okay it inserts mode goes the next line
686:42 - and then hit escape
686:45 - and then hit i
686:46 - and then hit tab to indent and then tab
686:48 - again
686:49 - it's not indenting right so i'll hit i
686:52 - and i'll just backspace till we're in
686:53 - the right space
686:55 - and we'll type in service
686:57 - colon
686:59 - escape
687:00 - we'll hit j to go down
687:01 - d d
687:03 - d d okay and then hit enter
687:06 - or sorry o sorry uh i okay
687:10 - indent
687:11 - i know this is a big old mess name you
687:14 - know what i'm going to make it easy for
687:15 - you i'm just going to hit colon wq quit
687:17 - here i'm going to remove this ingress
687:18 - file we're going to just make a new one
687:21 - we'll just do it over here because i
687:23 - don't mean to give you all this vim
687:24 - nonsense
687:26 - and i'm just trying to get back to
687:27 - normal size i gotta go back to this tab
687:29 - here ctrl o you can't do it over here
687:31 - and so the problem here is this is just
687:34 - all old so this should be
687:38 - we'll open up our other one as a
687:39 - comparison here
687:42 - you can tell how tired i am because this
687:44 - is so darn complicated we'll go copy
687:47 - again if you just want to watch you can
687:49 - just watch me do this
687:51 - all it's important is that you see how
687:53 - it works so the back end here should be
687:55 - service
687:57 - and this should be port
688:00 - okay and so we'll copy the contents
688:01 - there
688:03 - go back over to our virtual machine i'm
688:05 - going to bump up the font because it's
688:07 - too darn small
688:08 - it's not letting me bump it up here we
688:10 - go oh hit plus that's why
688:13 - and i went too large now okay there we
688:15 - go
688:16 - and so we'll take touch ingress
688:19 - yaml vi ingress yaml i to go insert mode
688:23 - right click paste so we don't have any
688:24 - mistakes hit escape pro colon wq right
688:28 - to quit and then we will hit up to try
688:30 - to run this again and hopefully we have
688:32 - all the right syntax we still have a
688:34 - darn error okay so
688:36 - um unknown field port for ingress back
688:40 - end oh i made a mistake
688:43 - remove ingress yaml
688:46 - we'll go back over here we'll
688:48 - return to normal size i got to go off to
688:50 - another screen because i can't do
688:52 - control zero there go to the bottom here
688:54 - and what i forgot to do was
688:56 - do number
688:58 - this is on space is four we need this on
689:00 - spaces two
689:03 - this should be number like this indent
689:07 - and that is the right syntax so we'll go
689:09 - ahead copy this again
689:12 - touch ingress yaml
689:15 - we have to spell that correctly i'll
689:17 - bump up the font so you can see what i'm
689:19 - doing
689:20 - and we will do vi ingress again we'll
689:23 - hit i to go insert mode right click
689:25 - paste
689:26 - hit escape
689:28 - colon wq right quit
689:30 - hit up
689:34 - okay it looks a bit better so error
689:36 - validating ingress validation data
689:39 - unknown field port for in-gas back-end
689:41 - what are they talking about it
689:42 - definitely is a thing
689:43 - so go back over here
689:46 - and we'll just take a look at this
689:52 - back end service port port definitely
689:55 - exists
689:56 - for sure i know that it definitely
689:57 - exists
689:58 - is there something else that i'm doing
690:00 - that's wrong here i'm just going to keep
690:01 - looking
690:06 - it looks right to me
690:16 - i'm just reading it here
690:19 - invalid type got string expected map oh
690:23 - i know what it is
690:25 - if it's a map
690:26 - it's expecting
690:29 - well it's kind of confusing i mean i
690:31 - guess you could do this
690:33 - because that would be a map right
690:37 - hmm
690:40 - let's just see what we do ingress
690:43 - kubernetes
690:45 - just see if we can see an example there
690:51 - uh no we are doing it correctly
690:54 - everything looks fine
690:59 - i'll be back in a moment here and i'll
691:01 - come back with the answer okay
691:02 - all right so it looks like we've hit a
691:04 - dead end so i tried launching linker d
691:06 - in the background and doing port
691:07 - forwarding so by that i mean like i did
691:09 - an ampersand on the end here and so now
691:11 - it's running in the background i don't
691:13 - know how to shut it off and i could run
691:14 - on another port and i tried also an
691:16 - address so i ran on an address and you
691:18 - can do that but then it said hey you
691:20 - have to do dns binding
691:23 - and it's just like almost impossible so
691:25 - i think for the scope of this
691:27 - we don't really need to do more i could
691:28 - show you buoyant but i just don't care
691:30 - about buoyant cloud i'm not here to try
691:32 - to sell a third-party provider but let's
691:34 - just take a look at linker d linker d um
691:38 - viz
691:39 - dashboard and just so we can kind of
691:40 - maybe see what it's supposed to do
691:43 - but holy smokes it is super hard to get
691:45 - that set up and it's just because
691:48 - you know we don't have in the community
691:50 - that content that's just like available
691:51 - to copy paste in there i'd have to spend
691:53 - hours to figure that out or stuff like
691:55 - that but anyway for the kcna totally out
691:57 - of scope but i just wanted to show you
691:58 - that like the idea is if we if we were
692:00 - there we would see our grafana dashboard
692:03 - that's powered by prometheus and we get
692:05 - all these fun cool graphs okay so you
692:08 - know hopefully we'll have an opportunity
692:10 - to look at prometheus if i figure it out
692:11 - um
692:12 - if we attempt the managed service it
692:14 - might be a bit easier but uh yeah that
692:16 - is linker d at least service mesh how
692:19 - you set up with micro k8s
692:21 - with the exception of not being able to
692:22 - solve that last part there but again not
692:24 - super important for the kcna just going
692:26 - through the motions to see the
692:27 - components okay also i guess we should
692:29 - shut down that environment so you're not
692:30 - spending money so go over to ec2 and
692:33 - this one's a bit easier we're just going
692:34 - to terminate that one so we'll go over
692:36 - there
692:37 - and we'll look for our micro 8k8 linker
692:40 - d and we will um terminate that okay
692:45 - so there we go
692:46 - [Music]
692:51 - hey this is andrew brown from exam pro
692:53 - and in this follow along i'm going to
692:54 - show you how to set up uh kubernetes on
692:57 - a managed service like google cloud
692:58 - platform we're actually going to look at
692:59 - a bunch of them gcp
693:01 - aws azure sivo digitalocean
693:05 - just so you get an idea of what it's
693:07 - like actually setting these up for
693:08 - production um you know they're not going
693:11 - to exactly be on the exam because the
693:13 - exam is more focused on kubernetes cloud
693:15 - data itself so you should know about
693:17 - managed services but i'm going through
693:19 - this with you because in practicality
693:21 - this is where you'd actually deploy
693:23 - kubernetes and if you get to see what
693:25 - it's like on all the different providers
693:27 - even if you can't do what i'm doing and
693:29 - just watch through it you can understand
693:31 - the differences between the offerings
693:33 - how easy it is to do it but
693:36 - measuring my frustration level as i work
693:37 - through it
693:38 - and just kind of get a bit of a
693:40 - difference so we're starting with gcp
693:42 - because it's the easiest um and you know
693:45 - i just want to start off with something
693:46 - really nice and light so what we'll do
693:48 - here is make sure you have a google
693:49 - cloud account i'm not going to show you
693:51 - how to do that but uh once you do have
693:52 - your account and your your full access
693:54 - account there i'm going to go ahead and
693:56 - create a new project you can see i was
693:57 - doing one earlier here and it did not
693:58 - delete but we'll say new project and
694:01 - i'll say gke example 2
694:04 - and i'm going to go ahead and go and hit
694:06 - create so that's going to create our
694:08 - project
694:10 - and then
694:11 - they usually create pretty darn quick
694:12 - notice it's still going there so we
694:14 - might have to wait a little bit
694:16 - there it is it's ready we'll click over
694:17 - to our gke example too
694:21 - and from here at the top we'll type in
694:23 - gke now if we don't want to do that we
694:25 - could also go on the left-hand side here
694:26 - if you click that button and go down
694:27 - below and go to kubernetes engine but
694:29 - i'm going to type in gke and google
694:31 - makes it super super super super easy to
694:34 - run kubernetes which is no surprise
694:36 - because they originally created
694:37 - kubernetes and then gave it to the cncf
694:40 - right so if they didn't have the easiest
694:41 - platform i would be uh surprised i'll go
694:44 - ahead and enable that and while it's
694:45 - going let's look up gke prices
694:48 - because it's actually pretty in line
694:50 - with aws now i used to say that gke had
694:52 - a free control plane but looks like they
694:54 - don't anymore the control plane
694:56 - is 10 per hour regardless of its
694:58 - autopilot mode or standard mode so
695:01 - you're always paying for that control
695:03 - plane all right
695:05 - difference between autopilot mode and
695:06 - standard mode well standard mode is just
695:08 - like how aws runs with ec2 instances
695:10 - it's just running on virtual machines um
695:12 - and then autopilot mode is running on uh
695:16 - uh cloud run so cloud run is like a bus
695:19 - fargate it's just a way of running
695:20 - serverless containers so this one you
695:22 - pay for what you use this one you pay
695:24 - for the underlying uh virtual machines
695:26 - that you spin up same thing
695:29 - um there are some nice things about
695:31 - google cloud where they have a service
695:33 - called antho so anthos is a way of
695:36 - google cloud anthos
695:38 - is a way of
695:40 - having a gke cluster but you can
695:42 - actually have um
695:45 - nodes
695:46 - running on different environments like
695:48 - aws
695:49 - on your environment stuff like that and
695:50 - manage it from essentially location so
695:52 - there's an additional cost for that i
695:54 - don't really know the use case for this
695:56 - because i just
695:57 - can't really think about it but um one
695:59 - nice thing about anthos is that it has
696:01 - anthous migrate so you go migrate um
696:04 - to gke for some reason like if you want
696:07 - to do it's always under that and what it
696:08 - can do is it can actually import a
696:10 - virtual machine from anywhere like aws
696:12 - and it will turn it into a container and
696:14 - then run it on gke so it's like this
696:15 - really easy way to get your
696:18 - containers or your applications into
696:20 - containers
696:23 - like it will generate out a docker file
696:25 - so i'm just drinking water here but
696:27 - the advantage there is that if you had a
696:29 - vm and you use that tool then you get
696:31 - the docker file you wouldn't have to
696:32 - write it yourself so that's kind of one
696:33 - advantage that i like about that
696:35 - but anyway we're over here we typed in
696:37 - gke we're on our cluster and so we have
696:40 - an option with quick start which is not
696:41 - bad but i'm going to just do it the
696:43 - old-fashioned way create we have two
696:46 - options standard autopilot standard is
696:48 - where you manage the nodes so
696:50 - virtual machines underneath this is
696:51 - using google or run cloud underneath
696:54 - right serverless containers so we'll
696:56 - choose gke standard
697:01 - and we'll need to name our cluster so
697:02 - i'll say gke example
697:05 - and it has to be lowercase of course
697:08 - zonal or regional we just don't want to
697:10 - render a zone we'll let it choose
697:12 - whatever zone it wants uh for the
697:14 - control plane we'll have it release
697:16 - channel
697:17 - we don't care about stack version we'll
697:18 - let it stay up to date
697:20 - and we'll go next and hit
697:22 - create
697:29 - now there was a bunch of other options
697:30 - but i didn't click them
697:32 - and maybe i'll go back there i don't
697:33 - even know if i ever looked at them when
697:35 - i went there oh standard mode
697:38 - configure here
697:41 - default pool
697:43 - yeah so i never even looked at this so
697:44 - it's going to launch up three nodes we
697:46 - really don't need three nodes we could
697:47 - have made it two
697:49 - which is too late now if you're watching
697:51 - this maybe before you launch this maybe
697:52 - you might want to make it two because
697:53 - it's more like think about every node
697:55 - that you run is going to cost money
697:56 - right so we don't want these running too
697:58 - long here it's using e2 e2 medium notice
698:01 - like when i launched up my um uh
698:04 - cloud9 environment i chose
698:07 - four gigabytes of memory because that's
698:09 - what i find it at like they say you can
698:11 - run it on to run it on a less but i
698:13 - would never run it on less than four
698:14 - gigabytes the the nodes
698:16 - 100 gigabytes so you know i run it at 40
698:19 - but like this is kind of more for a
698:20 - production use case i'm going to go here
698:22 - to security that looks fine metadata
698:23 - that looks fine
698:25 - automation options networking options
698:29 - i'm just seeing if there's anything
698:30 - interesting here
698:33 - yeah the only thing i would have done is
698:34 - i probably would have made it two nodes
698:36 - okay or even one like i only need one
698:39 - additional node there but we're running
698:40 - three nodes which is fine
698:42 - uh for you i i'd probably reduce it just
698:45 - to save money but for me it's fine
698:46 - because we're not going to keep this up
698:47 - for long and so we are just waiting for
698:50 - this to provision and so it says it
698:53 - takes about five minutes it is like the
698:55 - fastest set provisioning i know that
698:56 - like
698:58 - digitalocean says there's four minutes
698:59 - but honestly gke
699:01 - or uh like provisions clusters so darn
699:05 - fast it's really awesome but i'll see
699:07 - you back here in a moment when it's done
699:08 - it's at 67
699:10 - i'll see you then okay
699:11 - hey this is andrew brown from exam pro
699:13 - and we are back with gke and so uh again
699:17 - i'm telling you this this one's the
699:18 - easiest one to use all we got to do is
699:20 - click connect at the top and what it's
699:23 - going to do is show the command line
699:24 - that we use with gcloud in order to
699:26 - authenticate to the cluster
699:28 - uh and then cube ctl will work but it's
699:30 - even easier that we just hit run in
699:31 - cloud shell it's going to launch cloud
699:34 - shell it's going to establish that
699:36 - connection and then we can do cube ctl
699:38 - right away
699:39 - and as this is working i'm just going to
699:41 - maximize this window so we can see what
699:43 - we're doing
699:45 - and notice that it has a line here so
699:46 - now we just have to hit enter
699:49 - and then we'll say authorize
699:53 - you're gonna be so disappointed when we
699:55 - see uh the azure's uh cloud shell
699:57 - because it's so painful and so if we
699:59 - type in cue whoops
700:01 - if we type in i was just typing there i
700:03 - don't i don't know why i did that but if
700:04 - we type in cube ctl get pods
700:09 - give it a moment here to think so there
700:11 - it is connecting if we do hyphen a we
700:13 - can kind of see all the interesting
700:14 - things that it has here so fluent bit
700:16 - gke metrics connectivity agent dns
700:20 - all this fun kind of stuff metric server
700:22 - and so now what i want to do is just
700:23 - deploy something so let's say cube ctl
700:26 - um create deploy engine x image
700:31 - equals nginx because i just want to
700:33 - expose something so that we can see
700:35 - something
700:36 - um and i think we need a double hyphen
700:38 - notice like when you're doing this when
700:40 - i'm typing it's a bit delayed it might
700:41 - be delayed for you because it is a
700:42 - remote shell okay so it's created that
700:45 - now now what's interesting here is if we
700:47 - go
700:48 - to i don't know why it's on our gka
700:50 - thing but we'll go back to our engine
700:52 - maybe because i expanded it
700:54 - we can actually see
700:55 - our cluster if we go to workloads
700:57 - we can see it in here
700:59 - okay we can click into here
701:01 - we can see
701:03 - stats and stuff it's all hooked up and
701:06 - given us rich information go back to
701:08 - workloads even notice like we can hit
701:10 - deploy here
701:11 - and specify information so i i didn't
701:14 - have to do through here i could just
701:15 - went here and said new container image
701:18 - and just specify the repository and
701:19 - stuff like that
701:21 - so it does really add
701:23 - a very nice additional layer if like
701:25 - you're really not great at the scripting
701:27 - here this makes things so much easier
701:30 - and uh not not for everything though
701:33 - like
701:34 - and by the way we can go here we can
701:35 - edit these live too so we want to edit
701:37 - this server or like this sorry this
701:38 - resource it'll pull up the ammo we can
701:41 - edit it in line here which is really
701:42 - nice but if we go over to the service or
701:44 - service ingress
701:47 - we can't create a service we can create
701:49 - ingress if we already have a service
701:51 - created so not everything is great in
701:55 - google cloud world but it's still
701:56 - extremely good
701:58 - and one of the best okay so i'm going to
701:59 - do
702:00 - cube ctl expose
702:02 - because we want to have a service so
702:05 - that we can connect to ingress so that
702:06 - we can
702:09 - see what we built here so we're doing
702:11 - engine x port equals port 80
702:14 - okay hyphen hyphen
702:16 - target port equals 80.
702:20 - and then we want to type
702:22 - equals node port because it has to be
702:24 - either load balancer or node port
702:26 - forward to work you can't use cluster ip
702:28 - in order to hook up the ingress to get a
702:31 - load balancer with kubernetes we'll go
702:32 - ahead and hit enter that is now exposed
702:35 - we can go up to our
702:37 - services here
702:38 - and then we can see the services there
702:40 - and now if we want to add ingress
702:42 - we can just checkbox it here and say
702:44 - create ingress
702:47 - and what it's going to do is set up an
702:49 - external load bouncer at a google cloud
702:51 - load balancer so that is fine
702:54 - we'll go down here and choose nginx we
702:55 - can't change either of these right there
702:57 - that's fine http protocol is fine we can
702:59 - preview
703:02 - the ingress here so this is what it's
703:03 - going to do very simple
703:05 - right so nothing complicated we'll go
703:07 - ahead and create i remember how painful
703:08 - it was when we were doing ingress like
703:11 - what we were doing with uh service mesh
703:13 - right so it's so nice that this is super
703:15 - easy to do because that is the honestly
703:17 - the the biggest pain
703:19 - for this stuff is um let me do k8
703:21 - ingress i don't know if that's gonna be
703:23 - the name of the ingress
703:25 - oh it is okay
703:26 - um because that is usually the largest
703:27 - pain is just doing a deal with ingress
703:29 - and so
703:30 - google knows that and so they make it
703:32 - super easy
703:33 - so now what it's going to do
703:35 - is it's going to spin up
703:38 - a um
703:41 - a load balancer
703:42 - right so it's creating ingress and it
703:45 - says external hp lb
703:48 - and this does take quite a bit of time
703:51 - so i'll see you back here in a bit okay
703:53 - all right so we are back it wasn't a
703:55 - long wait but just know that you should
703:57 - hit the refresh button because i was
703:58 - sitting here it just looked like it
703:59 - wasn't done but it was done for a long
704:01 - time but i was fine because i was doing
704:02 - another follow along but if you're
704:04 - sitting here don't sit here for 100
704:05 - years hit the refresh button make sure
704:07 - that it is done or not done so it is
704:10 - done and
704:12 - what it's done is it's actually set up a
704:14 - load balancer for us in this case so no
704:17 - if you scroll on down below it says load
704:19 - balancing resources we can click through
704:21 - those and you can see it actually set up
704:23 - a load balancer
704:25 - right here it is we have an ip address
704:27 - we have um probably a like a dns record
704:30 - something somewhere here but we have
704:31 - load balancer we click back here we can
704:33 - see it made a load bouncer for us
704:36 - all right so now
704:38 - if we want to access this i'm just
704:40 - trying to remember how or i'll just look
704:42 - up my instructions that i wrote
704:44 - um
704:46 - i didn't write write it down but you
704:48 - know what we'll just type in cube ctl
704:51 - um
704:53 - because it's an ingress controller so we
704:54 - type in get ingress
704:58 - and there's its ip address it probably
705:00 - is the same
705:01 - yeah it's the same one as here
705:03 - and so if i copy this
705:06 - whoops
705:07 - if i copy this
705:11 - and we go new tab here and we paste it
705:12 - in
705:13 - ta-da our nginx page works okay one
705:16 - other thing i want to show you is that
705:17 - it has a code editor if you hit open
705:19 - editor we didn't have a need for it but
705:21 - if we did need to use one
705:23 - just to give it a second to launch
705:26 - the reason i'm showing it to you here is
705:27 - because
705:29 - it is really really awesome it's
705:31 - basically
705:32 - all visual studio code we could have
705:34 - technically done
705:36 - instead of using aws cloud9 we could
705:38 - have technically used this uh but the
705:40 - only thing is that it only has a single
705:42 - context at least i don't know how to
705:43 - change the context uh and so the reason
705:46 - i went with cloud9 is because you can
705:47 - spin up multiple virtual machines and
705:50 - stuff like that and cloud shell is more
705:52 - like tied to a single uh virtual machine
705:54 - i don't know how to flip between them
705:56 - okay
705:56 - um but it is it's fine it runs really
705:59 - fast and google cloud is very easy to
706:01 - use but i was more comfortable with
706:02 - cloud9 that's why i used it but i just
706:04 - wanted to show it to you because when we
706:05 - go to use
706:07 - azure i just want to compare it to how
706:10 - awful
706:11 - their shell is like as their code editor
706:13 - and it makes no sense because they make
706:15 - visual studio code and it's terrible but
706:18 - anyway we've accomplished our goal here
706:20 - and so in order to get rid of all this
706:22 - stuff uh what we're going to do is go
706:24 - ahead and delete our cluster so i'll go
706:27 - ahead here and i'm going to go and
706:29 - delete our cluster
706:33 - and now it did create a load bouncer so
706:35 - i'm really hoping that it tears down the
706:37 - load balancer with it
706:38 - um
706:41 - right so we go to load balancers
706:44 - i don't want to kind of delete it and
706:46 - cause an issue here oh it did vanish
706:47 - right away so i guess it does tear it
706:49 - down right away uh and if you really
706:51 - really want to make sure that everything
706:52 - is gone
706:54 - we can go ahead and delete the project
706:56 - or like the yeah the project that we
706:58 - create so we go to manage resources and
707:00 - then you'll see gk2 example we'll go
707:02 - here hit delete and we'll put the name
707:05 - in
707:06 - and it will shut down so no we're not
707:08 - getting billed for anything in that
707:09 - project anymore uh it will be scheduled
707:12 - for delete for march 18th but we don't
707:13 - have to worry about it anymore okay
707:15 - so we are done google cloud we'll move
707:17 - over to azure then we'll do the really
707:20 - hard one at us and then we'll do some
707:21 - bonus ones okay
707:22 - [Music]
707:27 - hey this is andrew brown from exam pro
707:29 - in this follow along i'm going to show
707:30 - you how to provision um
707:32 - a kubernetes cluster on microsoft azure
707:35 - or azure i like to say azure it's more
707:37 - fun to say
707:38 - and so
707:39 - their service is called aks or
707:42 - kubernetes service azure kubernetes
707:44 - service and you might have to enable
707:46 - this somewhere in there that's not what
707:48 - i'm going to show you it looks like they
707:48 - got some free training which is kind of
707:50 - cool um but i just know the way that i
707:52 - know how to do it so what we'll do is
707:54 - type in kubernetes at the top we're
707:55 - going to go to kubernetes service notice
707:56 - that they have something called azure
707:58 - arc remember how we talked about anthos
708:00 - well
708:00 - azure arc is like azure's um multi-cloud
708:04 - service where you can manage uh nodes on
708:06 - other providers and on-premise in one
708:09 - place so kind of a competing service but
708:11 - works a bit different and so we'll do is
708:13 - create a new cluster
708:16 - and from here we will have our
708:18 - subscription and we'll create a new
708:20 - resource group because it'll make it
708:21 - really easy to clean this up afterwards
708:22 - so we'll just say
708:24 - um
708:25 - example so we know what to do there
708:27 - everything's gonna be put in there and
708:28 - the nice thing is they have some options
708:30 - so we are doing this for devtest so we
708:32 - want this to be nice and cheap i'm gonna
708:34 - say aks
708:35 - example here hopefully it lets me name
708:37 - it that way yes it's fine the region's
708:39 - fine i don't care about availability
708:41 - zones the version is fine the one thing
708:43 - about like different
708:46 - providers is that they might have
708:47 - different versions available and some
708:49 - might be more progressive than others i
708:50 - would imagine i would imagine that
708:52 - google is the best at keeping that up to
708:54 - date and the only difference between
708:56 - like some of these tiers
708:58 - is like the availability so we we want
709:01 - less availability
709:03 - because we just don't care
709:05 - for it because for dev and test
709:07 - down below notice it's giving us uh
709:09 - standard b4s 16 gigabytes that's quite a
709:12 - bit
709:14 - that is insane but that's what they're
709:16 - recommending i'm not going to leave that
709:17 - up for long i guess we could change it
709:23 - i'm going to leave it alone i just don't
709:24 - want it to break okay
709:26 - so because i i ran it on this um but to
709:28 - be honest it's kind of expensive i'm
709:30 - going to go with one node because i
709:32 - don't want a bunch of them because i
709:34 - don't know how expensive this thing is
709:35 - and at 16 gigabytes of memory that could
709:37 - be kind of expensive maybe look up the
709:38 - cost of this
709:40 - standard
709:41 - price
709:42 - usually they show you in the menu eh
709:45 - so
709:46 - if we go here to pricing
709:50 - oh i don't know i'm not going to worry
709:51 - about it but you know
709:53 - it's
709:54 - yeah sometimes it'll tell you right here
709:56 - if you open this up they'll tell you the
709:57 - cost 150 55 a month
710:00 - again we're not running this for long so
710:03 - you know
710:05 - uh i guess we could try i just don't
710:07 - want to break we'll go with b2s okay
710:10 - i just don't know if that's what's going
710:11 - to be on for the cluster right but i
710:13 - would imagine that's all the nodes for
710:15 - production workloads at least three
710:16 - nodes are recommended but we only want
710:18 - one so we'll say next
710:22 - and it's going to run the system on a b2
710:23 - yeah that should be fine everything will
710:25 - be fine
710:26 - i just don't know if it's using like
710:27 - windows servers underneath because if
710:29 - it's using windows servers
710:30 - those always need a lot of memory
710:34 - okay so enable virtual nodes um
710:37 - nope we don't need that enable skill
710:39 - sets sure we can
710:41 - have that left on we have authentication
710:43 - it's going to have system assigned
710:44 - managed identity that's just how it
710:46 - integrates with
710:48 - azure
710:49 - role-based access controls we'll have it
710:50 - enabled
710:52 - could we do azure active directory sure
710:54 - but i'm not going to turn that on we
710:55 - have the option between cubenet and
710:57 - azure cni if you choose that you have a
710:59 - lot more options but we're going to
711:00 - stick with cube cube cni and we can't
711:02 - use azure option unless we're using
711:04 - azure cni uh notice we can use uh calico
711:07 - but we're not doing any network policies
711:08 - so it does not matter here today
711:11 - um
711:12 - we probably want routing but we're not
711:14 - going to do it that way
711:17 - uh we don't care about container
711:18 - registry right now we don't care about
711:20 - azure policies uh we don't need to worry
711:23 - about encrypting the secret service kind
711:24 - of similar to kms so azure key vault
711:27 - would be the way to
711:28 - secure your secrets in a more secure way
711:30 - and we'll go ahead and review and create
711:32 - and so this will take a bit of time it
711:34 - takes
711:35 - longer than google cloud but way faster
711:38 - than aws okay so we'll go ahead and
711:41 - create this
711:43 - and we'll wait a while and i'll see you
711:45 - back here in a bit i'm just waiting for
711:46 - the next screen to make sure that it is
711:48 - working correctly
711:49 - there we go and so we'll wait till this
711:51 - is done okay so see you then
711:53 - all right so we are back uh didn't have
711:55 - to wait super long i don't know if it
711:57 - tells us the time here but um
711:59 - again not super long to wait maybe
712:02 - 10 minutes
712:04 - i'm not sure but down below it says
712:06 - connect to cluster and that's the first
712:07 - thing we want to do so let's click that
712:09 - and we get a bunch of instructions so
712:10 - that's kind of nice and so here it says
712:12 - open cloud shell and run these two
712:14 - commands so if we press this here it
712:16 - actually runs the first two for us which
712:18 - is nice
712:19 - and from the google cloud one you
712:21 - remember we had a shell so azure has a
712:23 - shell it's not as nice okay
712:26 - um it does have a code editor but like i
712:28 - don't know if we showed the google cloud
712:30 - run code editor i'll probably show it
712:31 - now because i'm actually jumping between
712:33 - all of them right now even though for
712:35 - you it doesn't seem that way
712:37 - but it has a code editor and it is a
712:39 - terrible code editor
712:41 - just awful and it's weird because like
712:43 - microsoft makes visual studio code and
712:45 - you think that they would do a much
712:47 - better job here for it but notice that
712:49 - it ran
712:50 - these two commands here so it ran them
712:52 - for us so we're in there and so now all
712:54 - we have to do is kind of run the stuff
712:56 - kind of here uh but looking through here
712:58 - this stuff isn't very particularly
713:00 - useful
713:02 - um so i'm just trying to think here what
713:04 - did i do i'm gonna go look at my
713:05 - instructions
713:08 - because i think they had a sample app
713:09 - and that's what i ended up using is
713:11 - there uh the app that they provide there
713:17 - yeah so i looked up i think what i did
713:18 - is i looked up ingress because it was
713:20 - getting pretty confusing how to do it
713:22 - because when i went over to
713:24 - uh micro microsoft here and by the way
713:26 - let's just test cube ctl to see if it's
713:28 - working sorry for the small font i don't
713:30 - know if there's much i can do about that
713:33 - not really
713:35 - font size
713:36 - large
713:38 - little
713:39 - cube get pods so we'll say get pods
713:46 - here right and we'll do hyphen a
713:50 - and we'll just expand this so we can at
713:52 - least see what's going on here
713:55 - okay and so a lot less is running here
713:57 - than what we see for a google cloud but
714:00 - you see core dns
714:02 - csi as your disk so it's that's how the
714:05 - disk is being persisted with percent
714:07 - volumes mesh your server tunnel front
714:09 - okay so what we'll do
714:12 - is minimize this for a second
714:16 - uh is it still here is this it
714:19 - uh
714:21 - what'd you do asher
714:23 - azure's interface is so janky uh but oh
714:26 - yeah we just can click it again we can
714:27 - reopen it i just wanted to make sure we
714:28 - could find it so here
714:30 - uh is
714:32 - our kubernetes cluster so like they're
714:34 - very good about showing us the latest
714:35 - stuff so we go there you can see it
714:37 - click into it
714:38 - and um
714:40 - it's similar to google cloud so we can
714:42 - see namespaces we can add namespaces we
714:45 - actually see a little bit more
714:46 - information so we see workloads these
714:48 - are all the system ones i don't remember
714:50 - in google cloud is them really showing
714:52 - us those at least they filter them out
714:54 - so we have deployments pods replica sets
714:57 - staple sets daemons uh json cron jobs
715:01 - and you can add stuff but it's not
715:04 - as nice so you go add with yaml
715:07 - right it's not like a nice big old
715:09 - interface so there is like with quick
715:11 - start applications but these are
715:13 - like applications so you would choose
715:17 - deploy an application voters sample
715:19 - applications yeah so that's the sample
715:20 - app that you can deploy so like we could
715:22 - deploy that but i'd rather just kind of
715:24 - go through the steps ourselves so we
715:25 - actually learn something and not just
715:27 - press a bunch of buttons and have it do
715:29 - it for us but notice like service
715:30 - ingress it's not gonna be as nice as a
715:32 - google cloud just period
715:34 - uh then we've got our node pools and
715:35 - stuff down below here but you can
715:36 - integrate like git ops into it so i
715:39 - whatever like github actions or whatever
715:42 - azure uses but um what i want to do here
715:44 - is bring back up our terminal here and
715:47 - we are going to look up ingress
715:50 - kubernetes
715:52 - azure or azure um or aks
715:56 - now the one thing about microsoft is
715:59 - sometimes their services are clunky like
716:01 - like they're either really good or
716:03 - they're just
716:04 - like there's nothing there but they're
716:06 - always really good about being able to
716:07 - copy paste and get things done via the
716:09 - terminal so i know the first thing we
716:11 - need to do is do a basic configuration
716:12 - so we need to have
716:14 - um
716:15 - an ingus controller and so this one's
716:17 - going to be the engine and nginx ingress
716:19 - controller that we're going to use so
716:20 - we're going to copy the contents of this
716:23 - and we're going to go back over to here
716:25 - we're going to go ahead and just paste
716:27 - that on in
716:28 - and it's going to use helm it's going to
716:30 - install
716:31 - the ingress controller like adabus has
716:33 - their own but for whatever reason
716:34 - kubernetes i'm using
716:36 - nginx but you can configure whatever you
716:38 - want so they have a more customized
716:40 - complicated one which we're not going to
716:42 - do
716:43 - but once our ingress controller is
716:45 - created
716:49 - we are going to
716:50 - then uh
716:51 - build up these demos so
716:54 - go back over here and it is running okay
716:57 - great so now the next thing is we need
716:59 - to get these two files because this is
717:00 - the app they have they have
717:02 - i guess we don't need both
717:05 - um because when i ran it i just did both
717:07 - because they said to do both
717:10 - we'll do both because they might have
717:11 - roots for both and i don't feel like
717:13 - copying paste them out so what we'll do
717:14 - is we'll need to create two files we'll
717:16 - have to do touch app
717:18 - uh app one yaml and we'll say touch
717:21 - app to yaml and then here we'll type in
717:24 - code app one yama to open up in the uh
717:26 - the editor here uh and i have the code
717:29 - here from prior so i'll what i'll do
717:31 - here i'm just going to remove my old
717:32 - ones
717:34 - so that you can go through the pain that
717:36 - i went through
717:38 - getting these going here
717:40 - okay and so just type clear here
717:43 - we refresh that they're gone good this
717:45 - this file's not actually here just
717:47 - pretend that it's not here
717:48 - uh so i'll do touch
717:50 - app
717:51 - one yemel
717:53 - and we'll say code app one yaml here
717:56 - okay it's empty right so then we'll go
717:58 - over here we will copy the contents
718:01 - paste it on in
718:04 - did i get it yeah okay right click paste
718:07 - or space control v
718:09 - i can't right click paste but i can go
718:10 - control v
718:12 - whatever and uh we'll go the top right
718:15 - corner save
718:18 - code
718:19 - app to yaml
718:22 - okay
718:23 - down here copy
718:27 - control v
718:28 - this is what i'm talking about their
718:29 - editor is terrible makes no sense and
718:32 - then we'll say uh code routes.yaml
718:34 - because we need to set up um
718:38 - is it ingress yeah it's ingress
718:40 - and they have a pretty complex routing
718:42 - for us so we'll copy that
718:44 - and we will control v
718:47 - and save it
718:48 - and uh so now we have our three now i
718:50 - won't get this code editor out of the
718:52 - way if it'll let me
718:54 - this is the best i can do and we'll need
718:56 - to run these now here's the thing
718:59 - they say
719:00 - to run these like this but i'll show you
719:02 - what happens
719:03 - makes no sense what happens here so i'm
719:06 - just going to paste that on in
719:08 - notice i have to right click paste there
719:10 - and i can't control v there it just
719:11 - makes no sense
719:12 - uh so if i do app one it does
719:15 - it goes cannot find the file and i i
719:18 - don't know why because if you go ls
719:20 - it's right there so what i did is for
719:22 - when we were doing our service mesh we
719:24 - learned that there was a way to pipe the
719:26 - contents of a file uh there and so i
719:29 - tried that and that works so instead of
719:31 - doing that we do cat
719:33 - app one yellow i'm just gonna show you
719:34 - that dumpster dumps the content there
719:36 - but we can make a pipe and then say cube
719:39 - ctl apply hyphen f
719:42 - uh and so the contents will be this
719:44 - hyphen here
719:46 - don't ask me how it works i just know
719:47 - how it works ingress basic because this
719:49 - is the name space that this this stuff
719:51 - is all being provisioned too if you
719:52 - noticed
719:53 - i didn't point that out but
719:56 - uh well we the uh the controller is in
719:59 - there anyway so we hit uh enter here
720:02 - that'll be one
720:03 - i hit up i hit ctrl a and i move over to
720:06 - two and that's two and then we do our
720:08 - routes
720:10 - can't always trust written tutorials you
720:12 - have to learn
720:14 - okay and so now we have
720:16 - all that stuff set up
720:18 - so now what i want to do is just see
720:21 - our ingress here so cube ctl
720:24 - get
720:25 - actually we can do all for fun
720:27 - uh get all
720:29 - uh hyphen all we learned that in our
720:31 - namespaces tutorial and do hyphen
720:34 - ingress basic and just see what we have
720:36 - here
720:39 - [Music]
720:47 - no oh maybe we don't need the hyphen
720:49 - knife at all that's probably for
720:50 - deleting yeah there we go okay so
720:54 - here we can see a bunch of stuff we have
720:55 - our pods our services our deployments
720:58 - our replica sets but it's not showing us
721:00 - ingress and that's actually what we want
721:01 - to see so we'll go ing
721:05 - and i think it's working usually what
721:07 - i'm looking for is if it has an address
721:08 - because if it has an address then
721:10 - ingress is working right if there is no
721:11 - address there then we have a problem and
721:14 - i know because i spent so much time
721:16 - doing this the wrong way and being like
721:17 - where's the darn address so if you got
721:19 - this wrong just shut everything down
721:21 - start over because it's super hard to
721:22 - debug
721:24 - but if we copy this we should be able to
721:26 - go up here just like paste it on in and
721:27 - there it is okay another way we could
721:30 - see this is if we um we're here
721:33 - and we go to our workloads
721:35 - and
721:37 - nope sorry ingress
721:39 - and you go over here and we can see the
721:40 - ip address there
721:42 - so normally when you set up something
721:44 - it's going to have a load balancer but
721:47 - for whatever reason
721:49 - it doesn't with this one doesn't set up
721:50 - a load bouncer so
721:52 - i don't know why so
721:54 - but that's fine like there is a load
721:55 - bouncer but i just mean like a managed
721:57 - load bouncer like we used
721:59 - whatever there's a called application
722:00 - gateway um the load bouncers in
722:02 - kubernetes or sorry uh azure are a
722:03 - little bit funny names like there's one
722:05 - called like they call them gateways a
722:07 - lot
722:07 - like application gateway and stuff like
722:09 - that don't call them load bouncers but
722:11 - it doesn't set up one but we're all done
722:13 - here we accomplished our goal so in
722:15 - order to shut this down what i'm going
722:17 - to do is go
722:20 - look up resources because it's all a
722:21 - resource group so it should be easy for
722:22 - us to shut down we go to resource groups
722:24 - and i called this one
722:28 - okay it's example so we click into that
722:31 - and there's our cluster and we're going
722:33 - to go ahead and delete the resource
722:34 - group and then we say k it's example
722:38 - go ahead we hit delete and that's it and
722:40 - just make sure that it deletes azure is
722:42 - a bit buggy okay you really don't want
722:44 - this running
722:45 - uh and causing you money but i'm
722:46 - shutting my down just make sure to
722:48 - refresh double check um azure is
722:51 - notorious for like being delayed in
722:53 - terms of updating so just come back
722:55 - after 30 minutes an hour just make sure
722:56 - that resource group is gone hit the
722:58 - refresh triple check just be sure okay
723:01 - but that's it we finished um our
723:03 - kubernetes cluster for azure hurrah
723:07 - [Music]
723:11 - hey this is andrew brown from exam pro
723:13 - in this follow along we're going to
723:14 - learn how to set up eks so that's
723:17 - awesome elastic kubernetes service to
723:20 - run a cluster and the goal is we just
723:22 - want to run anything on and expose it so
723:24 - we can see the app running in our
723:26 - browser i'm going to tell you right now
723:28 - eks is the hardest and takes the longest
723:31 - to set up
723:32 - it's not important for the exam for you
723:34 - to pass but it really does cement
723:35 - knowledge and give you a practical way
723:37 - of using kubernetes in production use
723:39 - cases and so um you know if you do get
723:42 - stuck don't worry just watch and just
723:44 - see what the process is to understand uh
723:46 - the caveats to actually getting a
723:48 - managed service up and it for me i can
723:51 - do it because i really know aws inside
723:54 - and out but like if somebody was new to
723:55 - it it's super super painful what we'll
723:58 - do is we'll go to the top here and type
723:59 - in eks of course you'll need an aws
724:01 - account and so we'll go over here and
724:04 - the first thing we are going to do
724:06 - when it goes here is we're going to add
724:08 - a cluster we'll go and create ourselves
724:10 - a cluster i'm going to call mine eks
724:12 - example
724:13 - all right and it lets us choose the
724:15 - kubernetes version we're going to need a
724:17 - cluster service role
724:19 - um
724:20 - i'm not sure select whatever let's just
724:22 - let us make one i i remember my other
724:24 - account i already had one so i must have
724:26 - created one uh prior but i guess what
724:28 - we'll need is we'll need that cluster
724:30 - rolled so there's a couple ways we can
724:31 - do it so
724:32 - here it gives you the instructions to do
724:34 - it or what we can do is use this cloth
724:36 - formation template so i am going to use
724:40 - this cloudformation template you think
724:41 - they'd have a link just to launch it
724:42 - prior to 2020 etc etc whatever okay so
724:46 - what i'll do is i'll copy the contents
724:48 - here
724:50 - tell you aws does not make it easy uh
724:52 - and we'll go to cloudformation
724:54 - it's almost like they want you to use
724:55 - their managed
724:57 - container services
724:58 - but we'll go over to cloudformation this
725:00 - is an infrastructure as a service tool
725:02 - for setting stuff up uh notice like our
725:04 - cloud9 environments are over here so
725:06 - that all got set up here we'll create a
725:07 - new stack
725:09 - and um
725:11 - we want to provide the template so
725:15 - template is ready i just
725:18 - want to
725:19 - i guess i'll have to save it so
725:20 - what we'll need to do is open up any
725:23 - kind of editor so i have a vs code on my
725:25 - local computer
725:26 - so i'm just going to go grab that
725:29 - if it will open here there we go
725:33 - it's opening off screen here i'll show
725:35 - it to you in a moment
725:41 - okay so i have i'm just saving the file
725:43 - over here you can see i have a bunch of
725:45 - other cool scripts there we're gonna go
725:47 - save that to our desktop
725:49 - okay i'm gonna go to my desktop here
725:53 - i'm just not sure what's on my desktop
725:54 - so that's why i'm just not
725:56 - sharing it very clearly and i'm just
725:58 - going to call this
725:59 - application.yaml
726:02 - okay just notice over here it says
726:03 - application.yaml right
726:06 - and i'm going to go ahead and save that
726:08 - and so now what i'll do is go back to
726:10 - cloudformation and i guess we'll just
726:12 - upload the template
726:14 - here on our desktop
726:16 - there it is we'll say open
726:20 - and we'll say next
726:25 - cluster or eks cluster i am rule it's so
726:29 - silly that it's like this i wish it was
726:31 - a managed rule it looked like they're
726:32 - saying that it was at one point just
726:35 - create it
726:36 - just make it for me here ada best please
726:39 - acknowledge yeah yeah yeah yeah
726:42 - all these warnings for a roll um
726:44 - prior to 2020
726:46 - had an entry with the service link role
726:49 - the policy is no longer required
726:52 - okay well anyway uh we'll let that
726:54 - create there for a moment it should not
726:56 - take much time at all because it's a
726:57 - role those should be super super fast
727:01 - and we'll just keep hitting refresh
727:02 - still works and there it's created so if
727:04 - we go to stack info we can see that it's
727:06 - completed as well we'll go back over
727:08 - here and we'll refresh
727:10 - and there is our role so we'll scroll on
727:12 - down notice we can encrypt
727:15 - our um
727:16 - we can use uh encrypt our secrets using
727:18 - kms so that is adabus's key management
727:20 - service so that's a great way to encrypt
727:22 - your secrets then we have all these
727:24 - subnets and um i already know that's
727:26 - going to tell us to like pair this down
727:28 - it's not going to like them all but
727:30 - what we'll do is we'll scroll on past
727:32 - there we can see we can choose ipv4 ipv6
727:35 - i'm going to leave it ipv4 public public
727:37 - private private we'll leave it public
727:39 - there's some advanced settings we're not
727:40 - going to touch that
727:42 - notice that it's using vpn cni so amazon
727:44 - has its own i guess plugin and it's
727:47 - going to automatically install that for
727:48 - us the uh for that then we can choose a
727:52 - particular version uh for this so it'll
727:54 - be whatever version there we'll have
727:56 - core dns which is a version there we can
727:58 - choose our cube proxy version we'll go
728:01 - next this is nice we can actually get
728:03 - all logging into cloudwatch logs but i
728:05 - don't care about any of this so i'm just
728:06 - going to say next
728:08 - and then here we have our tags our
728:10 - networking stuff like that i'm expecting
728:12 - it will complain
728:13 - okay we'll hit create because usually it
728:15 - doesn't work because it will say
728:19 - cannot create the cluster because
728:21 - there's not a sufficient capacity to
728:23 - support the cluster
728:24 - so
728:25 - it could be based on
728:27 - a does not have enough resources or
728:29 - that's probably what it is so what i do
728:31 - is i just like take off the last three
728:33 - and then i hope that it works
728:36 - just double checking there and we'll go
728:37 - next next
728:39 - create
728:41 - and there we go now here's the part
728:44 - that's crazy this is going to take
728:46 - at least 30 minutes to spin up all right
728:48 - it takes the longest i have no idea why
728:51 - but um i literally am doing this uh
728:55 - and and i'm going to be doing other
728:56 - follow alongs while i'm waiting for this
728:58 - to spin up and so i'm gonna stop the
729:00 - video here i'll be back in a moment but
729:01 - just go take a break watch your favorite
729:03 - episode of the show and also if you are
729:06 - spitting this up we probably should talk
729:07 - about cost so if we go uh aws eks
729:10 - pricing
729:14 - right because if you don't have a lot of
729:15 - money you might not want to be doing
729:16 - this but if you go to i already told you
729:19 - this but it's going to be 10 cents per
729:20 - hour just for the
729:23 - control plane node so that's going to be
729:25 - the one that controls all of our nodes
729:27 - and then we spin up other ones there and
729:29 - eks can actually run either on ec2 so
729:31 - you can run ec2 instances so you just
729:33 - spin up those nodes and they're always
729:34 - running or it can use a fargate so
729:37 - fargate is serverless containers meaning
729:38 - that
729:39 - you only pay for what you use so you
729:42 - don't pay for servers running all the
729:43 - time but that means that there will be
729:44 - cold starts you can even deploy this on
729:46 - outpost so outpost is like a a server
729:49 - rack that can be put in
729:51 - a data center and runs away specific
729:53 - stuff so if you want to deploy there as
729:54 - well you can do that but um that's all
729:57 - we're talking about for that for now and
729:59 - i'll see you back here in a bit all
730:00 - right so after a really really really
730:02 - really really really long wait the
730:04 - longest wait you'll ever have to wait
730:05 - for a cluster eks is ready uh just
730:08 - beware hit that uh refresh because
730:10 - sometimes it's ready it'll just not
730:12 - update and you have to hit that button
730:14 - once in a while okay
730:15 - so
730:16 - if you go here we have compute
730:19 - we'll have to create some node groups we
730:20 - have networking we have add-ons
730:23 - authentication logging
730:25 - it's a little bit more bare bones
730:26 - they're not really giving you a whole
730:28 - lot here we can see our workloads here
730:29 - if we click into them but you don't get
730:31 - the same kind of controls we saw in
730:34 - azure kubernetes service and um google
730:37 - cloud kubernetes service like
730:39 - where we could launch things and stuff
730:41 - like that
730:42 - so really it is cli driven
730:46 - again eks is the hardest to set up but
730:48 - it is pretty powerful but not from like
730:51 - an easy to use kind of uh perspective
730:53 - but we are gonna need some uh nodes okay
730:56 - so i'm gonna pull up my instructions uh
730:58 - off screen here because it is super hard
731:01 - super hard uh to set this stuff up okay
731:05 - and so um the first thing i think we'll
731:08 - need is we'll need to open up cloud
731:09 - shell so i'm going to open up cloud
731:11 - shell here at the top there
731:13 - oh it goes a whole new page you think
731:15 - like the other ones that they load in
731:17 - place but nope not aws it launches in a
731:19 - new one they were the they were the
731:21 - third provider in the first tier
731:22 - providers to get a cloud shell so no
731:24 - surprise there i guess theirs is a bit
731:26 - clunky that's fine
731:28 - uh and it doesn't have like a code
731:29 - editor built in but like you don't need
731:31 - it because you got cloud9 so it's not a
731:33 - big deal
731:34 - so we'll pull up the elastic kubernetes
731:36 - service again here just so we have it
731:38 - on this tab over here and um we're gonna
731:41 - have to really rely on a tutorial for
731:43 - this so
731:44 - um we'll just say cloud shell
731:48 - eks because aws does not have good
731:50 - instructions here
731:51 - this person here
731:53 - great instructions okay so i'm going to
731:55 - go here and what i'll do is i'll just
731:57 - first make a bin directory
732:00 - waiting for that cloud shell environment
732:01 - it's also the slowest to start
732:04 - okay
732:05 - and the font is like super small so
732:07 - we'll go here and we'll just go a little
732:09 - extra large
732:11 - okay and we're in better shape so i'll
732:13 - go ahead and paste those commands in
732:16 - good so it's going to create a bin
732:18 - directory for us
732:20 - we're going to install cube ctl
732:24 - okay
732:26 - we're going to um
732:30 - update config this this allows cubectl
732:32 - to talk to our cluster
732:34 - all right hit enter on this one
732:36 - sometimes when you paste it in the last
732:37 - command doesn't get executed you have to
732:38 - hit enter so just be careful there the
732:40 - name here i believe we call it eks
732:42 - example
732:46 - i'm just going to double check yeah it
732:47 - is okay
732:48 - and then we want to install
732:52 - eks ctl so eksctl is the um
732:59 - this databus is cli for eks and it's a
733:02 - way of making a lot easier to uh way of
733:05 - working with eks we could even
733:07 - provisioned
733:08 - our cluster this way but that's not how
733:09 - i did it
733:10 - okay
733:11 - so what we'll do is copy this contents
733:13 - here
733:14 - paste it on in hit paste
733:18 - enter
733:20 - and we'll go back over here to our
733:21 - instructions and helm because we will
733:23 - need helm because that is what we will
733:25 - need to install the um
733:30 - the ingress controller so remember when
733:32 - we were doing or
733:34 - whatever it's called the controller yeah
733:36 - when we were doing the uh azure one we
733:38 - used helm to install i i went through
733:40 - very quickly but we used helm to install
733:42 - it and so it's gonna be the same for aws
733:44 - so now that we have it we need to um
733:47 - actually create a node and or nodes and
733:50 - those are managed with node groups so
733:51 - back in our cluster we'll go to
733:52 - workloads or configuration i guess and
733:55 - we'll go to compute
733:56 - and we'll add a node group
733:58 - and we'll say my
734:00 - node group
734:02 - and then what we'll need is an iron rule
734:05 - so
734:07 - it's a little bit silly because we have
734:08 - to go to i'm console make our own now
734:10 - and we also have to look up how to make
734:13 - one
734:14 - so we have the i am cluster node we
734:16 - looked at up earlier but if you still
734:17 - have that link open you go under there
734:19 - there's the node item rule
734:20 - and they don't give you a cloud
734:22 - formation template for whatever reason
734:25 - but we can just create it in the cli
734:29 - but um
734:32 - i'm just looking here
734:36 - i did it this way i went through the
734:38 - management console because it was easier
734:40 - so here we'll click on uh or we already
734:41 - have it open up here and i'm going to
734:43 - create a new role i'm going to follow
734:44 - these instructions the thing is aws has
734:46 - great documentation but it's very easy
734:48 - to like glance over the most important
734:50 - information because it's so text heavy
734:52 - not broken up in a way that's easy but
734:54 - what we'll do is we will create one for
734:57 - i think it's for ec2 yeah so we'll
734:59 - choose ec2 the reason it changes this
735:01 - interface i do not like it why is it so
735:02 - light and gray it looks like it's uh
735:05 - doesn't work and then this interface is
735:07 - still doesn't make any sense but we need
735:09 - this one this one and
735:11 - this one so we will copy that name and
735:14 - we need that policy we'll hit enter
735:17 - we'll grab that then clear the filters
735:19 - it's still selected see that that means
735:21 - that there's a policy selected even
735:22 - though we don't see it we'll hit enter
735:24 - on that one we'll select that one so now
735:27 - we have two
735:29 - and we'll go back up here and then it
735:31 - says you probably want this one i go
735:33 - okay great
735:35 - and then we select that so we have our
735:36 - three we'll go next make sure you have
735:38 - the three that are there
735:40 - and we'll go back and then it has a nice
735:43 - name for us doesn't matter what we name
735:44 - it
735:46 - but i'm going to stick with the name
735:47 - that they have here
735:49 - paste it on in go to the bottom create
735:52 - the role
735:54 - and
735:55 - our role is created so we can close that
735:57 - tab go back over here refresh
736:01 - if you didn't know aws and you weren't
736:03 - like used to doing this like for some
736:05 - services this would be super painful for
736:07 - me it wasn't too hard but i can imagine
736:10 - hard we don't need a launch template
736:11 - that's totally fine labels taints tags
736:13 - don't care
736:15 - absolutes too notice it's using the t3
736:18 - medium just like what we're using on
736:20 - cloud nine so that four gigabytes is a
736:22 - good option 20 uh this size
736:25 - i like to do higher like 30 well
736:29 - we'll leave it at 20. we'll leave it to
736:30 - 20 because when we're running it on
736:32 - cloud9 it's sharing both the control
736:33 - plane and the worker note like all the
736:37 - the data planes so the idea is that 20
736:39 - is probably enough for our nodes i'm
736:41 - gonna put one minimum two maximum
736:43 - desired is one
736:45 - and one so that we are saving money here
736:48 - not like when we were doing it with uh
736:50 - google cloud
736:51 - or azure in particular um so there are
736:54 - three subnets those are fine we'll hit
736:56 - next
736:57 - this all looks fine we'll hit create
737:01 - and now we have to wait for those nodes
737:03 - to spin up
737:05 - while that is
737:06 - going let's go find our instructions
737:10 - for
737:12 - ingress
737:14 - so what i'm going to do is type in
737:15 - ingress
737:18 - eks
737:22 - the first one here
737:23 - and this is the right one and so when i
737:25 - first did this i did not want to read
737:27 - all this and so i kind of skipped
737:28 - through it and then i found out i had to
737:29 - do all these steps
737:30 - so these are some things that we're
737:32 - going to have to do
737:33 - so there's a bunch of prerequisites so
737:35 - the idea is that we are going to be
737:37 - using application load bouncer so that's
737:38 - aws's load bouncer and then we're going
737:40 - to use ingress in order to
737:43 - get to our app and they even have a fun
737:45 - example app that we're going to be using
737:47 - but before we can do that we're going to
737:49 - have to do a bunch of stuff the first
737:50 - thing is to install
737:52 - the application load balancer controller
737:55 - okay and so here we will right click
737:59 - and we have to do a bunch of stuff so
738:00 - the first thing is we'll need to create
738:02 - an impulse so we'll go ahead and the
738:04 - nice thing is they just have raw data
738:06 - here so we just hit copy we don't have
738:08 - to
738:09 - do a crazy amount of work we'll go back
738:10 - to our cloud shell paste this on in here
738:13 - we'll go back to our instructions
738:15 - so we've
738:16 - downloaded we just downloaded the file
738:18 - and so now we'll end up creating it so
738:20 - this is the same thing as if we went
738:21 - through the the im policy and did it all
738:23 - manually
738:24 - so we'll hit paste hit enter
738:27 - and now we have the policy created
738:28 - that's one step
738:31 - and we installed eks uh ctl because we
738:34 - need to
738:35 - um
738:37 - install the item service and actually
738:38 - when i ran this i forgot to replace the
738:40 - my cluster part here so i'm gonna make
738:42 - sure i don't forget to do that
738:44 - and i'm gonna copy this here
738:47 - and i'm going to paste
738:49 - and
738:50 - if you right click place it usually
738:52 - always pops up like that so we'll say
738:53 - eks cluster
738:54 - make sure you don't spell that wrong
738:56 - it's a pain to fix
738:58 - okay or sorry eks example see i'm
739:01 - already go i'm already doing it wrong so
739:03 - 100 make sure that's right because it's
739:05 - such a pain to fix um and then we need
739:07 - our ip our um
739:09 - account id so on another tab here if you
739:12 - drop down there's the account id as well
739:15 - so i'm going to paste that on in there
739:17 - okay and so that should be all good
739:20 - notice the namespace is going to be cube
739:21 - cube system so it's launching in the uh
739:24 - the systems
739:25 - namespace usually don't do that but for
739:26 - this case you do and we'll hit paste
739:30 - and that will create a service account
739:32 - it says unable to create imcount without
739:35 - an imoc id provider so it says eks ctl
739:39 - utils run this first so it's just that
739:41 - eks we haven't randy
739:43 - um
739:44 - ctl and so we just have to basically
739:45 - kind of authenticate and it goes here
739:47 - and says hey
739:48 - if you want to run this you have to hit
739:50 - you have to run
739:52 - approve okay because that was just a dry
739:54 - run so we do this
739:58 - okay and that worked
740:00 - and then what we need to do is go back
740:02 - and run this i'm hitting up making sure
740:04 - that name is correct making sure that
740:05 - account id number is right again it's
740:07 - big pain to fix run that
740:11 - it's going to go ahead and create us a
740:13 - service account
740:22 - waiting for cloud formation stack so
740:24 - it's actually spinning up a cloud
740:25 - formation stack
740:27 - so i think when we delete our cluster
740:29 - then we can just like tear all this
740:30 - stuff down which makes it a lot easier
740:31 - right
740:33 - so we are going to wait on that there
740:35 - for a bit we'll go back to eks and also
740:36 - see if our nodes are ready
740:39 - so i don't see our nodes yet we refresh
740:41 - here oh we just had to refresh there it
740:43 - is and these i probably show up on ec2
740:45 - so if we go over to ec2
740:53 - we should see there it is
740:56 - okay
740:57 - um so that is our
741:01 - ec2 instance running we do not see the
741:03 - control plane aws is managing it we
741:05 - can't touch it okay
741:07 - so go back over here this one has
741:08 - finished our node is ready so we can
741:10 - deploy stuff to it but we're still
741:12 - installing this thing here
741:14 - so go back over here
741:16 - and so now we're going to use a helm
741:18 - chart to actually install the
741:19 - application database load balancer now
741:21 - we have our permissions so we grab this
741:22 - first line here
741:24 - we paste it on in we hit enter
741:26 - oh it says it doesn't know what helm is
741:30 - what are you talking about
741:31 - because we definitely installed it so
741:34 - let's go back to this instructions here
741:36 - did i not copy and paste this maybe we
741:37 - didn't run the last line so we'll hit
741:39 - enter here
741:40 - paste
741:42 - enter
741:45 - helm
741:46 - okay there we go
741:50 - we'll hit enter okay so eks has been
741:52 - added so now uh we'll make sure that
741:54 - it's up to date the repo or whatever
741:56 - whatever it wants there repo update
741:59 - and then the next thing is to actually
742:01 - install it so we'll scroll past this
742:03 - stuff it's saying
742:04 - different use cases so we'll grab this
742:06 - one where it's actually installing it
742:09 - we'll right click paste
742:11 - paste it in hit enter
742:14 - enter
742:16 - oh
742:17 - stop stop stop
742:19 - this is where i mess up i i put the
742:21 - wrong name in here okay so i want to
742:23 - paste this in again like this
742:25 - and this is where i ran this issue where
742:26 - i didn't have the right name so i'm
742:28 - going to type in eks
742:30 - example
742:32 - so sorry about that and i'm going to
742:33 - make sure this is spelled the same way
742:34 - capital e is case sensitive
742:36 - i really should just made it all
742:38 - lowercase for us this looks fine we'll
742:40 - hit paste
742:45 - cannot reuse a name that is still in use
742:50 - oh
742:51 - no
742:54 - no no no no no this is a pain um
742:59 - now i don't know because we messed it up
743:01 - so
743:02 - maybe we can uninstall it i don't know
743:04 - like helm uninstall
743:12 - palm uninstall
743:17 - uninstall release so it is possible to
743:18 - do that so i'm really hoping that we can
743:20 - uninstall whatever mess i made there
743:25 - i should have just let it ran and then
743:26 - corrected it
743:29 - i don't know if we need um
743:32 - the second part here but i'll just do
743:33 - this
743:37 - not found
743:43 - oh
743:44 - i know it's going in the cube system ctl
743:46 - so we'll do
743:50 - dang it
743:52 - it's not gonna let me do it again is it
744:00 - let's try this again hit enter
744:05 - cannot reuse the name that is still in
744:07 - use
744:12 - okay so we'll do cube ctl
744:15 - get pods
744:18 - uh we'll say cube system
744:23 - you're never supposed to really touch
744:24 - cube system that's that's the idea here
744:30 - uh yeah cube system you gotta put an n
744:32 - on this
744:38 - so i don't see anything there that's
744:39 - important
744:44 - i guess we'll have to look at the helm
744:45 - chart and see what it's actually
744:46 - installing so we'll type in um
744:49 - this is where this is where the pain was
744:50 - and this is actually where i messed it
744:52 - up and it became really hard and uh i
744:53 - mean like i made it even worse than
744:55 - before
744:56 - so what we'll do
744:57 - it's not all lost it's just that we have
744:59 - to have a little bit of a detour now
745:01 - hopefully you don't have to do this and
745:02 - uh you don't make that mistake and you
745:04 - just carefully watch the video
745:06 - but there is this thing here that's on
745:08 - helm so if i type this in
745:13 - we go a helm chart
745:17 - it should be an artifact here and so the
745:19 - idea is that if we open this we'll see
745:20 - the contents of it right which we
745:22 - learned in our helm
745:24 - tutorial so
745:33 - just going through here
745:36 - i'm looking for the actual contents of
745:38 - the repo
745:42 - what does it install templates
745:46 - installs a deployment ingress class
745:53 - a bunch of things
745:57 - okay
745:58 - but what are they called though
746:06 - because maybe you'll have like the
746:07 - default name in here in the values
746:14 - anyway i'm going to be back i'm going to
746:16 - try to figure this out but i really wish
746:17 - i didn't do that
746:20 - all right so one other thing i might try
746:22 - here is by doing an uh i think i say an
746:24 - upgrade was it
746:27 - i'm just on stack overflow on the
746:28 - right-hand side so use an upgrade and
746:31 - then do
746:32 - a hyphen i flag and install the release
746:35 - if it doesn't exist so what we'll do is
746:37 - we're going to copy this
746:40 - and i'm just going to see if this works
746:42 - as a fix right if you installed and you
746:45 - didn't make the mistake then you are
746:46 - fine but for me whoops we don't want to
746:48 - change the system uh the
746:50 - that there but this is just kind of
746:52 - painful so what we'll do is say eks
746:55 - example here
746:56 - make sure that is right
746:59 - and then we'll go ahead and hit paste
747:02 - hit enter
747:05 - well it's only going to work if i type
747:07 - it right you know so up grade
747:13 - eks
747:15 - example
747:17 - paste
747:21 - oh
747:22 - nice okay so we are super super lucky
747:25 - that we're back in business here um so
747:27 - we'll go back over to our tutorial
747:30 - and here we can verify whether it's
747:32 - working so we'll go over here paste it
747:34 - in
747:36 - okay that looks fine and then we'll go
747:39 - back over here and that's all there is
747:41 - to that part next part is we need to do
747:44 - this tagging for our subnets because if
747:45 - we don't do it it doesn't know where
747:48 - to use the load balancer so
747:50 - what we need to do is go back to eks if
747:53 - we go to details it should show us the
747:55 - um
747:56 - subnets here so i'm going to open one
747:59 - two and three
748:01 - and then we're going to have to add tags
748:04 - so we'll give it a moment there and so
748:06 - there this one is we'll check box it go
748:08 - to tags
748:10 - i told you a bus is a lot of work
748:12 - um and so we need
748:16 - i'm just going to open all three so i'm
748:17 - gonna have to like
748:18 - figure this stuff out here manage tags
748:22 - manage tags
748:25 - and
748:26 - okay so the first one is this
748:28 - so we grab this
748:31 - paste it in and this is going to be eks
748:34 - example
748:37 - shared
748:38 - okay
748:39 - i'm just going to copy that so i don't
748:40 - have to keep typing it
748:45 - shared
748:48 - shared and we don't just need one tag we
748:51 - need two tags
748:52 - so go here and
748:54 - then they say you need this one as well
748:57 - so we'll go here and then the value here
748:59 - is one
749:01 - and then here and then the value here is
749:03 - one
749:04 - and then we go here and the value here
749:06 - is one and then we'll go save
749:10 - save
749:11 - and save
749:16 - okay
749:18 - oh you know what this is for private
749:20 - it's supposed to be this one bro for
749:22 - frick's sakes
749:24 - no biggie we'll just go and add those
749:28 - you can just tell like eks just crushes
749:31 - my spirit okay we'll just
749:33 - go back over here
749:35 - copy that
749:38 - why won't it paste
749:40 - oh i can't actually remove it
749:42 - okay
749:44 - so stupid that interfaces
749:46 - um we'll go over to here
749:49 - remove
749:50 - and then one and hit save and then go
749:53 - back to here
749:55 - and then we'll
749:57 - add this here and then remove that one
749:59 - and hit save great so those are all
750:01 - updated so now we meet all of our
750:03 - requirements so the next thing that we
750:05 - want to do is run the fun app that comes
750:08 - along here so they have a sample app
750:10 - and they are using fargate but we are
750:12 - not using fargate so we'll skip that and
750:14 - we'll just go ahead and grab this it's
750:16 - going to launch right into our node and
750:18 - so we'll paste this in and we'll hit
750:20 - enter
750:21 - and it says that it's created the app
750:25 - um and if we want to see the contents of
750:26 - that file like we can just paste the
750:28 - link up here and if we just take this
750:30 - out we can actually see
750:31 - what's here so we have a service
750:34 - ingress a deployment and a namespace
750:37 - okay the game is 2048 you might have
750:40 - heard of this game before
750:41 - and i think that's it but i'll double
750:43 - check the instructions see if there's
750:45 - anything additional here
750:47 - uh no but it will say i guess we
750:49 - download the file we actually have to
750:50 - run it
750:52 - okay so we will oh no no i think we did
750:54 - yeah we ran it okay the instructions are
750:56 - really weird how they just kind of weird
750:58 - iterations there the same thing
751:00 - but uh if we go down below here and we
751:02 - do the get ingress right if we check our
751:04 - ingress
751:08 - right and if it has an address that's
751:10 - how you always know if this stuff is
751:11 - working so if we copy this
751:14 - and go anywhere up here
751:18 - it says cannot be reached
751:21 - okay
751:22 - uh but it has a port
751:26 - so maybe what we'll do is we'll just
751:28 - double check to make sure everything's
751:29 - working correctly i'm going to go over
751:30 - to
751:31 - ec2 here
751:33 - because that's where our load bouncers
751:35 - are because it created an alb right
751:38 - and if i go to the load bouncer here
751:41 - i was just hoping that it worked
751:43 - and so there is our load balancer
751:46 - and i'm just going to make sure that it
751:48 - can be reached it's also possible that
751:50 - the node is still starting and there's
751:51 - nothing wrong
751:53 - with it
751:54 - and so this would normally have a target
751:57 - this is an alb right so this should oh
751:59 - we actually have to go to target groups
752:00 - to see
752:02 - if we go to target groups here and
752:03 - select
752:06 - uh says healthy targets
752:10 - it has targets
752:11 - it says initial target registration is
752:13 - in progress
752:14 - so it's still
752:16 - making like uh determining whether to
752:18 - help you okay so now it's healthy if we
752:20 - go back here and try it does it work
752:22 - there we go cool and so we have a game
752:25 - so join the two numbers to get started
752:27 - uh
752:29 - uh okay use your arrow keys oh okay
752:35 - somebody in the bus had too much time on
752:37 - their hands they're like okay
752:39 - what excuse can i have to make a game
752:42 - they probably worked in like the
752:43 - kubernetes department or eks but anyway
752:46 - that's a fun game and it's cool that we
752:47 - get to deploy that so now
752:49 - we are all done that was the hardest one
752:51 - that was super hard and so
752:54 - what we'll do is go over to eks
752:57 - and we'll go ahead and delete it
753:00 - to confirm
753:02 - type in
753:03 - my node group sorry so just notice we
753:05 - are not deleting the cluster first go to
753:07 - eks carefully you don't click on ecs
753:09 - otherwise you go somewhere weird but we
753:10 - have to destroy the node group first i
753:12 - know this because it will complain if we
753:14 - don't so we call this my node group
753:16 - that's what it's telling us to type in
753:18 - and then
753:20 - once that is gone then we can go ahead
753:21 - and delete the cluster i can try this
753:23 - right now but i don't know if it'll take
753:24 - it until the node group's gone
753:27 - it hasn't finished attaching yet so
753:33 - i'll be back here in a little bit it
753:34 - takes a little bit time to delete
753:36 - all right so now that our node group has
753:38 - been deleted we can go ahead and delete
753:40 - our cluster so we'll go to the top here
753:42 - delete our cluster
753:44 - and type in eks example now aws
753:47 - does not like
753:49 - azure and gcp where they have
753:52 - resource groups or projects so you got
753:53 - to be really careful about what is
753:55 - lingering here so just make sure double
753:57 - check to make sure these things are
753:58 - deleted after it's deleted
754:00 - uh we did create a load balancer um but
754:03 - it was created through kubernetes so i'm
754:05 - hoping that it just deletes itself
754:07 - but if it doesn't you should double
754:09 - check because a load balance is going to
754:10 - cost you 15 bucks a month if you forget
754:12 - to delete it
754:13 - if you go to the left-hand side
754:15 - to ec2 and go to load bouncers
754:18 - you know it should be deleting or
754:20 - something like that and uh you know
754:22 - cloudformation some of these things were
754:23 - spun up there so
754:25 - sometimes that's a good indicator if
754:27 - they're all getting torn down so i'm
754:28 - going to go over here and just double
754:29 - check
754:32 - and so
754:34 - we have the cluster roll
754:36 - ah the load bouncer is here
754:41 - okay
754:44 - and so if i go to resources
754:47 - it's just a roll so there's no load
754:49 - balancer here
754:51 - so i'm really hoping that it tears it
754:53 - down
754:55 - so what i'll do is i will i guess i'll
754:57 - just have to make sure i'll just uh i'll
754:59 - have a i'll check back in here with you
755:02 - and just make sure that it's gone well
755:03 - here this one's gone so let's go check
755:05 - the ec2 instance
755:07 - i didn't think it would delete the
755:08 - cluster that fast because it takes so
755:09 - long to create clusters if we go to our
755:11 - load balancer
755:15 - it's still here so
755:17 - tricky tricky aws so we'll go ahead and
755:19 - delete it
755:20 - and that should be that i'm going to
755:22 - just double check is there any auto
755:24 - scaling groups
755:25 - there shouldn't be
755:27 - nope we're fine so that was the only
755:28 - thing i was really worried about was
755:30 - that autos or that application load
755:32 - balancer because that costs you 15 bucks
755:33 - a month if you forget about it but now
755:35 - you're a-okay and we did the hardest one
755:38 - so uh feel proud uh that you've tackled
755:42 - uh some of the hardest managed providers
755:44 - and there you go
755:48 - [Music]
755:50 - hey this is andrew brown from exam pro
755:52 - in this follow along we're going to look
755:53 - at how to utilize uh ibm's uh offering
755:57 - for kubernetes so here i have an ibm
755:59 - account you'll have to go create one i'm
756:00 - going to go ahead and log in to my
756:02 - account now they do have a very sleek ui
756:05 - i have to say for um
756:07 - a cloud provider and so give a moment to
756:10 - log in here now i did already launch a
756:12 - cluster and the reason why it takes so
756:14 - long to launch them and i really don't
756:16 - want to have to launch one and wait so
756:17 - what i'll do is i'll kind of piecemeal
756:19 - this in the sense that i will uh show
756:22 - you kind of the creation process but i
756:23 - won't hit the create button and then
756:24 - we'll go to the active cluster and we'll
756:26 - see if we can kind of do stuff there so
756:28 - what i want to do is just make sure
756:30 - my running cluster is already there so
756:32 - i'm just kind of trying to remember i
756:33 - don't use ibm cloud too much so i'm not
756:35 - sure the interface too much but if i go
756:36 - to kubernetes here i should have a
756:39 - cluster already running
756:41 - because it did take a long time for it
756:43 - to spin up like longer than aws so i
756:46 - think uh kubernetes or ibm wins the
756:49 - longest time to revision control plane
756:51 - award uh if there is ever a reward not a
756:53 - good award to to win but the idea here
756:56 - is you'll go to ibm cloud left-hand side
756:58 - and you're going to go to kubernetes and
757:00 - then from there you're going to create a
757:01 - new cluster so i'll hit i guess i can't
757:03 - right-click that but we click it and
757:05 - they have two plans and don't get
757:07 - shocked here i know this is 2 500
757:10 - and that is a bit crazy okay but they do
757:13 - have a free plan and that could be the
757:14 - reason why it takes so long to provision
757:16 - maybe it's slower so you you have a free
757:18 - plan that lasts for a cluster that will
757:21 - last for their days and it'll
757:22 - automatically delete it's for uh just
757:24 - tinkering around and doing things with
757:26 - so notice that it is free but there
757:27 - could be some additional charges but
757:29 - let's take a look at the standard to
757:30 - understand the cost of kubernetes on ibm
757:33 - cloud so down below we have i
757:35 - classic and vpc and then you can choose
757:38 - your resource group um
757:40 - for whatever and then it just shows you
757:42 - geography availability metro symmetra is
757:44 - just i guess the town or whatever uh and
757:47 - then notice down below this is basically
757:49 - the cost here that's driving up is the
757:50 - amount of nodes but if we scroll past it
757:52 - for a second there's these integrations
757:54 - that they have which is nice activity
757:56 - tracking logging monitoring and so these
757:59 - technically add a cost so if you check
758:00 - box them off it actually doesn't really
758:02 - lower the cost there so it's not a true
758:05 - cost but if we go up here maybe the
758:07 - problem is our instance is too large so
758:08 - it's at 16 gigabytes we know that the
758:11 - minimum should probably be something
758:12 - like four so if we switch over to uh
758:16 - four here i'm just looking which one's
758:17 - cheaper this one's the cheaper one and
758:19 - so we will choose that one so save per
758:22 - tool and now it's down to 982 still
758:26 - really really expensive so let's go down
758:28 - to one node and look it's 340 dollars so
758:32 - for whatever reason i don't know
758:34 - the logic behind it
758:36 - but it's extremely extremely expensive
758:39 - but hold on here let's take a look here
758:40 - so this is 15 cents here
758:43 - it still says three workers
758:45 - three zones ah okay so that's the reason
758:48 - why it's so darn expensive so if we were
758:49 - to reduce the amount of zones
758:52 - there we go
758:54 - okay so that looks a lot more reasonable
758:56 - so this says a hundred dollars and
759:00 - i guess that actually is
759:02 - pretty cost effective so like if we had
759:04 - a two v uh c uh
759:07 - uh v cpus and four memory let's go take
759:09 - a look here so if we go as a comparison
759:11 - we'll use ewbs for pricing here
759:22 - uh and so we're using a t3 medium so if
759:24 - we go to ht3 medium and we look at the
759:26 - cost it says zero three three six and
759:28 - theirs is
759:29 - zero fifteen cents for something
759:31 - comparable at least that's what i it
759:32 - looks comparable to me we go 730 so it'd
759:35 - be 24
759:36 - but like with the control plane it
759:38 - pretty much is the same cost but overall
759:40 - the worker nodes are more expensive if
759:41 - you had to scale up for whatever reason
759:43 - ibm cloud is super super super expensive
759:47 - uh all i can think of is that maybe
759:49 - there's something i don't understand
759:50 - about
759:51 - this vm
759:53 - so i'm just trying to look if there's
759:54 - something maybe more cost effective
759:57 - so like if we went virtual shared
760:01 - i'm just trying to find the lowest cost
760:03 - here
760:05 - no so i guess they're just generally
760:06 - expensive
760:08 - uh okay so but anyway the idea is you'd
760:10 - go free and then you'd uh
760:12 - create the cluster i can't make more
760:14 - than one free cluster but you create it
760:16 - and then what it will do is it will
760:18 - start to
760:19 - uh provision like it will get it ready
760:21 - to go
760:22 - and i'm gonna tell you it takes
760:24 - forever so it'll start the control plane
760:26 - and then it has to start the nodes so
760:29 - you will see it um if we go over here to
760:31 - the ibm cloud
760:34 - yeah you'll see like here it'll be like
760:36 - progress progress progress progress and
760:38 - then when that finish will say available
760:39 - and you go to the worker nodes and this
760:40 - will be like progress progress progress
760:42 - progress but they do have a really nice
760:44 - interface so it's not showing up here
760:46 - but it was showing the instructions
760:48 - before if i click help yeah there it is
760:50 - and so it popped up and it was like
760:51 - here's your instructions and i really
760:53 - liked that and another thing is it has
760:55 - the kubernetes dashboard so you press it
760:57 - and i mean i haven't seen it work yet
761:00 - but i'll click it and
761:02 - we should be able to get our dashboard
761:03 - so that's really nice i don't see any of
761:05 - the providers doing that and i don't
761:07 - know why they don't do that because it's
761:08 - super super nice
761:10 - um yeah i like that
761:13 - but uh let's see if we can connect never
761:15 - done it before so ibm has their own
761:17 - cloud shell so we'll click on that and
761:19 - add that there
761:21 - we'll see if we can get like an ingress
761:22 - controller connection we might not be
761:24 - able to do it on the free tier but let's
761:25 - see what we can accomplish
761:31 - and while that's going i'm just pulling
761:32 - up some instructions here to see if i
761:34 - have some
761:35 - reusable ones here
761:45 - there we go so this one's up i'm not
761:47 - sure if there's a way for me to increase
761:48 - the font here
761:49 - um
761:51 - i don't see an option i can try control
761:53 - plus which is kind of
761:54 - a weird way of doing it but it will work
761:57 - and so we'll go back over here this will
761:58 - be all over uh too large and we'll copy
762:00 - this line here that's to connect to the
762:02 - cluster so paste that on in we'll hit
762:04 - enter
762:10 - and we'll type in cube ctl get pods
762:13 - hyphen a just to kind of look at what
762:15 - there is
762:16 - now they got calico core dns
762:18 - dashboard metrics hopefully every time i
762:20 - do this with the providers you kind of
762:21 - see that everything's a little bit
762:23 - different and we'll carry that
762:24 - information forward
762:26 - uh there's olm operator i don't know
762:27 - what that is but yeah we have some nodes
762:29 - so i guess we can go ahead and start
762:30 - launching stuff so we'll do what we
762:32 - normally do so we'll do
762:34 - cube ctl
762:37 - create
762:38 - deploy
762:39 - engine x
762:41 - image equals nginx
762:44 - um
762:46 - and i think that is it yeah okay and
762:48 - we'll hit enter
762:50 - so we have our deployment
762:53 - look here deploy your app so set up an
762:54 - image repository deploy your app we
762:56 - already did that
762:57 - expose your app test access your apps
762:59 - create a node port to test your app
763:02 - if we click this where does it go
763:05 - i'm just curious if they like have
763:07 - anything built in i was thinking maybe
763:08 - we'd go like to the worker nodes or
763:10 - something and
763:11 - and uh you know like how we saw gcp
763:14 - no it's just instructions okay so
763:16 - if we go into worker note over here
763:19 - can we click into this or configure it
763:23 - no if we go to the worker pools
763:28 - um nothing super exciting they have this
763:30 - devops which is i guess like get ops
763:33 - it's probably like do continuous
763:34 - delivery so i guess that's kind of nice
763:36 - but i'm not really seeing any kind of
763:38 - like easy to use interface so i think
763:40 - like
763:41 - basically it's just
763:42 - a cluster with no additional
763:45 - fluff now what's interesting is they do
763:47 - have a bunch of these add-ons here so
763:48 - you can press it and it will
763:50 - automatically install so that's kind of
763:51 - nice
763:52 - um
763:53 - i'm just trying to look around here
763:55 - because i really haven't poked around
763:56 - it's all add-ons okay so that's pretty
763:58 - much it so what we'll do is we'll try to
764:01 - uh we'll make a service i guess so we'll
764:02 - need a node port service
764:04 - let's see what they say here so
764:08 - i guess they're suggesting to make a
764:09 - node port
764:13 - get a public ip address worker node in
764:15 - the cluster if you want to ask that
764:16 - we're going to from private get the
764:18 - private ip what i'm wondering about is
764:20 - like ingress
764:22 - um
764:24 - yeah i don't know
764:26 - i'm not sure let's say uh
764:29 - ibm cloud ingress
764:31 - kubernetes
764:45 - so here we have a service that's being
764:47 - exposed
764:49 - up then there's ibm provider domain
764:56 - so yeah i'm not sure i guess i could
764:58 - spend more time with it it looks like
764:59 - this is kind of the ingress here
765:02 - i wonder if we could just use this
765:05 - show more
765:06 - oh it does say engine x
765:09 - um
765:12 - i'm thinking about it
765:14 - yeah let's let's try it okay so we'll
765:16 - say uh cube ctl
765:18 - um expose sorry i'll bump this font up
765:20 - here
765:27 - i think i went to baker
765:32 - deploy
765:36 - um engine x
765:40 - port 80. i'm just trying to remember off
765:43 - the top my head
765:44 - target port 80 that's the way i learn i
765:47 - have to try to like recall from memory
765:48 - and get it right and then we have the
765:50 - type right
765:53 - and we'll say node port
765:57 - cool
765:59 - um and so then we need ingress so we'll
766:01 - go over here to this and i mean we've
766:03 - done lots of different
766:07 - ingress here
766:18 - and so um i don't think there's like an
766:20 - editor per se no but uh what i'll do i'm
766:24 - just gonna do ls i'm gonna say bye
766:26 - i'm gonna say ingress yaml
766:28 - and this is vi so everything's hard so
766:30 - i'm gonna hit i for insert and then i'm
766:32 - going to right click and paste
766:37 - it didn't like that so i'm going to hit
766:38 - colon control q
766:41 - it's all the way over here
766:45 - uh
766:46 - q
766:47 - q quit
766:49 - so i'm gonna try this again
766:51 - ctrl v maybe oops sorry i control v
766:56 - huh so i don't i can't seem to really
766:57 - paste this in here so i think we're
766:59 - pretty much bust here because
767:01 - otherwise we in order to get this file
767:03 - in here we need to connect cube ctl on
767:05 - my local computer or something else so
767:08 - i would say we're pretty much bust here
767:10 - and i'm not really that worried about
767:11 - trying to get ibm cloud to work but just
767:13 - more show to show you the interface
767:14 - we've seen a lot of times how this stuff
767:16 - works
767:17 - um but there is a little bit of trouble
767:19 - here so i think that's all i can really
767:20 - do here
767:22 - for ibm cloud but hopefully that gives
767:23 - you kind of an idea
767:25 - of what it looks like for ibm cloud
767:30 - but i was hoping what would happen is if
767:31 - we deployed that ingress that maybe it
767:33 - would just work but then down below
767:36 - uh exposing the lb to your kubernetes
767:38 - ingress cluster so there might be like
767:40 - some alb stuff so i would think that
767:42 - either maybe you'd have to like enable
767:43 - alb but like since we're doing this in
767:45 - the free tier i don't even know if they
767:46 - give us that so that's why i i don't
767:48 - have confidence that we can expose it
767:51 - but we would need ingress a
767:53 - so i think we're pretty much done here
767:54 - i'm just going to go ahead and click in
767:56 - here
767:56 - and we're going to delete this cluster
767:59 - and we'll i guess we'll type it again
768:01 - here
768:03 - and there we go
768:06 - and just make sure it is deleting i'm
768:07 - just going to refresh here
768:14 - there we go and i'll see you later okay
768:16 - [Music]
768:20 - hey this is andrew brown from exam pro
768:22 - and this follow along we are going to
768:23 - learn how to launch a kubernetes cluster
768:26 - on digitalocean so
768:28 - if you've never used digitalocean
768:29 - they're kind of like a cloud service
768:31 - provider i call them a third tier cloud
768:32 - cloud service provider because they were
768:34 - traditionally a vps a virtual private
768:37 - server basically just virtual machines
768:38 - and they've expanded to have a bunch of
768:40 - other stuff such as kubernetes so i
768:42 - actually already launched a cluster on
768:44 - here
768:45 - um but i am going to show you how to
768:47 - create one so uh digitalocean is known
768:49 - for being really really really easy to
768:51 - use so if we go here and create a
768:53 - cluster
768:54 - and we'll give a moment here the idea
768:55 - here is we'll select our kubernetes
768:57 - version so they have recommended version
768:59 - and then your your location so maybe i
769:01 - want to toronto we have our vpc network
769:04 - we'll have our node pool name and then
769:06 - here it's going to say how many nodes
769:08 - you want we're going to go down to one
769:09 - because we want to save money and notice
769:12 - that it's making the recommendation of
769:14 - about um
769:15 - four gigabytes it says 2.5 of
769:18 - ram usable so i guess that's fine
769:21 - um you know like i aim for like two to
769:23 - four uh gigabytes for for uh worker
769:26 - notes like if it's a single node like
769:29 - we're doing with
769:31 - micro k8 it's on cloud nine then it
769:33 - makes sense to have four gigabytes but
769:35 - here two
769:36 - two will do fine okay
769:39 - so anyway twenty dollars a month very
769:41 - very very cost effective
769:44 - i don't even know if the control plane
769:46 - cost anything digital ocean
770:01 - that well so i can't say for certain so
770:03 - i shouldn't say that
770:04 - absolutely but i can't seem to find the
770:07 - pricing but i think the the control
770:09 - plane tier is free i think
770:11 - um
770:13 - unless one of the nodes is actually the
770:15 - whatever node so anyway um
770:19 - friend downtime that makes sense so
770:20 - we'll have our name here whatever you
770:22 - want to call it then we go ahead and
770:23 - create the cluster
770:24 - and so we'll wait here a moment
770:28 - and so here it will start to spin up and
770:30 - it says it'll take about four minutes to
770:32 - create usually it has a message there
770:35 - yeah and this is what i like about
770:36 - digitalocean is that they give you all
770:38 - the information you need right in place
770:40 - so thank you for using oh thank you
770:42 - thank you for using manage kubernetes
770:44 - your kubernetes cluster is being
770:45 - provisioned provisioning usually is
770:47 - complete within four minutes you can
770:48 - configure the cluster as you wait and
770:51 - then go through these steps and it tells
770:52 - you like how do you connect and all that
770:53 - kind of stuff so that's really really
770:56 - nice of them and they have one-click
770:57 - installs just like how we saw with ibm
770:59 - cloud
771:01 - um i don't think we saw this for their
771:02 - providers but like um i mean like google
771:05 - cloud had that marketplace so i guess
771:07 - they do
771:08 - um and i guess azure i don't know i
771:11 - don't know if we saw a marketplace for
771:12 - azure but it's nice if you want to just
771:14 - install a controller and if we want to
771:16 - do anything we probably would need an
771:17 - ingress controller if we could figure
771:18 - out how to use it
771:19 - um and so it's pretty clear okay
771:23 - so i already have one running to save us
771:26 - time because i don't want to wait a
771:27 - hundred years for it to spin up or stop
771:29 - the video and come back here
771:31 - uh so i'm going to go into here
771:35 - and notice i already spent a dollar
771:36 - after a day so it's not too bad
771:38 - but if we go to resources here we can
771:40 - see
771:41 - our node pool and we can see the two
771:44 - nodes i guess underneath
771:47 - and then there's a load balancer
771:48 - attached so low bouncers and volume
771:50 - should be managed etc
771:52 - we have uh any insights here
771:55 - just waiting for the load so we get some
771:56 - metrics so that's nice of them
771:58 - and there are some settings uh but and
772:00 - they also have a button for kubernetes
772:02 - dashboard so that's cool i didn't notice
772:03 - that before only other provider i saw
772:05 - that did that was ibm cloud so i like
772:07 - that so i like having that button there
772:09 - but anyway if we scroll on down
772:12 - um we might want to go install the
772:14 - ingress controller so because we if we
772:16 - want to reach the internet right so just
772:18 - press that button and it does take some
772:19 - time and again that's why i did this
772:21 - ahead of time just so i don't have to be
772:22 - clicking a thousand things here but when
772:24 - we want to connect um
772:27 - the idea here is
772:29 - we need to install the doctel kubernetes
772:32 - cluster config thing this thing here so
772:34 - in order to do this we're going to need
772:36 - an environment so i'm going to go back
772:37 - to my italy's account we're going to do
772:39 - it via cloud9 okay
772:42 - we probably could even do it um
772:47 - oh sorry wrong account uh this is
772:49 - developers
772:52 - uh
772:53 - andrew brown
772:54 - i should already be logged in here but
772:56 - i'm not
772:57 - just give me a moment here
773:07 - and i think this is the right password
773:09 - so we'll just paste that on in there is
773:10 - that the right account nope
773:12 - nope nope nope i have more than one
773:14 - account here
773:17 - and
773:18 - oh it's this one
773:20 - i have a lot of aws accounts
773:23 - so we'll get in here and what we'll do
773:25 - is we'll go back to cloud9
773:29 - we could probably do this in the shell
773:30 - but just in case we need an editor could
773:32 - have went over to gcp but we haven't
773:35 - done much in gcp so i don't want to
773:37 - force you to be over there okay
773:40 - so we'll launch our micro k its
773:41 - environment and then what we'll need to
773:43 - do is install
773:44 - the uh the docker
773:47 - ctl right so they have a guide on that
773:50 - and digitalocean is known for having
773:52 - really really really really really good
773:54 - guides they're just known for it and so
773:56 - they have a snap install so that's
773:57 - pretty nice
773:58 - so once it spins up the idea is we're
774:01 - going to
774:02 - run this line and then using docker tl
774:04 - integration cube ctl requires cube
774:07 - config
774:08 - so
774:10 - i guess that would mess with our
774:11 - configuration with micro k8s
774:15 - um
774:16 - i'm just trying to decide here because
774:18 - you know what i actually want a fresh
774:20 - environment i don't want to mess with a
774:21 - micro case so we'll just say
774:22 - docker
774:23 - env environment
774:26 - unless docker has its own
774:29 - cloud shell
774:30 - i don't think it does it really should
774:32 - get one that would be really smart
774:33 - that's a record docker if you're
774:34 - watching or sorry not docker
774:36 - digitalocean if you're watching go get
774:38 - your own like
774:40 - um
774:41 - like get pods you know
774:43 - you can also do this in git pods but
774:45 - i don't want to switch right now
774:47 - so
774:48 - this we don't really need anything large
774:50 - because we're not actually um
774:54 - we're not actually running kubernetes on
774:55 - it so i'm just going to create this
774:56 - environment
774:58 - and then we'll spin that up and as
775:00 - that's way we're going to just take a
775:01 - look at what our next episode so it says
775:03 - sudo snap install
775:05 - that and i believe i choose ubuntu
775:07 - hopefully
775:08 - and then using this integrations but we
775:11 - could probably go over here just run the
775:12 - next line
775:15 - but we probably have to install cube ctl
775:16 - as well right
775:18 - snap runs in complete isolation you need
775:20 - to be grant permissions in your equity
775:21 - systems some doc requires this requires
775:24 - cube consumed
775:26 - okay well we'll figure it out i'm sure
775:28 - it's not that hard but we'll wait for
775:29 - this to spin up
775:32 - while we're waiting we might as well
775:33 - just poke around
775:36 - here so
775:37 - i guess we already kind of looked at all
775:39 - this there's nothing really new to look
775:40 - at
775:44 - come on cloud9
775:47 - so we're going to have to download this
775:48 - config file for sure so i'm just going
775:49 - to go ahead and download that now
775:58 - and oh is it almost there it's
775:59 - connecting
776:24 - okay so now that we're in uh we'll have
776:26 - to do sudo snap install cube ctl
776:30 - uh and classic so i'm starting to
776:32 - remember the the pseudosnap commands
776:36 - and then for this one it'll probably
776:37 - just be
776:39 - doctl
776:42 - okay
776:45 - i guess this digitalocean ctl is what it
776:48 - stands for there
776:55 - and i guess we could probably do this
776:57 - even though i'm not really
776:58 - 100 sure on it
777:06 - because i know when i tested it i didn't
777:08 - i didn't do that i just i had cube ctl
777:10 - and ctl i ran the one line
777:19 - actually i'm going to run this one
777:20 - because it says i all have to do this
777:28 - access token is required okay
777:31 - doc ctl auth init
777:35 - and so i need an access token so from
777:37 - here what we do is we go to the api
777:42 - and from here you can see i have a bunch
777:45 - so i'm just going to delete these
777:56 - and from here we're going to say cube
777:59 - and we'll create it
778:01 - and this key is going to be temporary so
778:02 - i'm going to copy it and i'm going to
778:03 - end up deleting this so it's not going
778:05 - to be a big deal so i'm going to paste
778:06 - that in there hit enter
778:08 - and it says permission denied so i'm
778:09 - going to do sudo in front of there and
778:11 - then paste it again
778:13 - and that's fine so now if i do soup tpl
778:15 - get pods
778:16 - let's see if i get environment
778:18 - connection was free refused did you
778:20 - specify the host or path
778:22 - um
778:24 - oh you know what it's because we didn't
778:25 - run that other line so let's run this
778:26 - because i think this is just an
778:27 - alternate way so i think the
778:29 - documentation
778:30 - didn't we just
778:32 - do that what if we do sudo on this
778:35 - nope
778:36 - what if we try this again the auth
778:41 - token is valid
778:47 - grant
778:48 - oh so doc tl config
778:51 - maybe we do have to run that other line
778:53 - this one here
778:55 - okay
778:56 - paste
778:58 - and then we'll hit up
779:02 - maybe we'll
779:03 - take out the pseudo maybe it's getting
779:04 - confused because there's pseudo there
779:11 - now i did this on my local host and it
779:13 - was like super easy
779:26 - yeah i'm not i'm oh you know what um are
779:29 - we in the right cluster hold on let me
779:31 - just double check here
779:33 - go back to our kubernetes cluster i want
779:34 - to make sure it's the um
779:37 - the one that already is running uh which
779:39 - is
779:41 - i wanna do the one that's one day old
779:42 - here
779:44 - okay
779:45 - and we will copy that again
779:48 - and i will paste that in again
779:52 - okay and i will run doc ctl
779:55 - off in it again
779:57 - and i will go grab
780:00 - oh
780:02 - this is so frustrating
780:05 - it's probably you know my fault there
780:07 - we'll just generate a new token
780:10 - oh look there's tokens here
780:14 - maybe it created these tokens tokens you
780:16 - have generated with the api
780:19 - i'm confused
780:21 - okay what if we do docs ctl oops let's
780:23 - do doc ctl um
780:26 - cube ctl is that something we could do
780:30 - i don't know i'll be back here in a
780:31 - moment okay all right so every time we
780:34 - try to run doc ctl auth in it we get uh
780:37 - even though i have an api key here right
780:40 - i copy and we paste it here
780:45 - we get the silly error so maybe we just
780:47 - do mk dir home ubuntu
780:50 - is there a config directory
780:52 - there isn't so i'm just going to make
780:54 - one
780:59 - is that the one it wanted
781:04 - okay and now what if we round it again
781:07 - maybe that's the problem
781:15 - okay so
781:16 - doc uh ctl often it worked that time i'm
781:19 - not seeing any weird additional keys
781:21 - there we're gonna try this again
781:27 - using doc steel till snap grant it via
781:29 - the doc ctl cube config plug to use this
781:32 - command so sudo snap this so we'll try
781:34 - this now
781:37 - okay and i wonder if this no i'm just
781:40 - gonna refresh here because there was
781:41 - things popping up here i don't know how
781:42 - they should up in the api yeah so
781:44 - there's this now here i think this just
781:46 - was created when we ran that connect
781:50 - okay
781:51 - and uh so we'll hit enter again
781:55 - and for this this is permission to
781:57 - deny so i'm just going to make it
781:58 - manually
782:04 - i'm trying to copy it one second maybe
782:05 - just copy that
782:10 - i'll try this again
782:12 - there we go
782:15 - cube ctl
782:16 - get pods
782:19 - there we go okay great so now um let's
782:22 - launch ourself a
782:25 - deploy
782:26 - so what we'll do here is type in cube
782:28 - ctl deploy or
782:30 - create deploy
782:31 - engine x image equals nginx
782:35 - and then
782:37 - oh it already exists
782:39 - so maybe i made it prior
782:41 - keep see a tail get pods
782:44 - all right
782:45 - we'll do cube ctl
782:49 - get svc because i've already i might
782:51 - have already
782:52 - created a nginx cluster ip so i'm just
782:55 - going to delete those because i was
782:56 - doing that
782:58 - previously i didn't
783:00 - get rid of them so delete
783:01 - svc
783:04 - engine x
783:12 - um
783:12 - [Music]
783:13 - cube ctl get ingress i'm just wondering
783:16 - if i have anything there
783:18 - so i did make one before i'm just going
783:19 - to go ahead and delete it okay
783:28 - okay so the first thing we want to do
783:30 - now so we have our
783:32 - pod right
783:33 - so we'll do cube ctl get or
783:38 - create
783:39 - or sorry it's expose expose
783:43 - deploy
783:45 - nginx
783:48 - um
783:48 - port 80
783:50 - target port 80.
783:53 - so no sometimes i do equals and
783:54 - sometimes i don't you don't you can do
783:56 - it either way it doesn't matter and then
783:58 - the port or the type
784:00 - or kind where's the type i think it's
784:03 - type is node port
784:06 - and then we'll just do cube ctl
784:08 - um get svc because i want to make sure
784:11 - that is a node port
784:13 - there we go i don't know if it has to be
784:14 - a node port but that's the one i made
784:18 - and so the next thing you do is install
784:20 - the nginx ingress controller
784:23 - okay and so then we need an ingress
784:28 - so
784:29 - i'm just wondering if we can look this
784:30 - up on the docks here so
784:32 - kubernetes uh
784:35 - um i keep on saying docker but it's
784:36 - digital lotion digitalocean
784:40 - ingress
784:47 - okay so here they have a service
784:50 - and this one's just cluster ips not even
784:51 - node port
784:52 - and then they have a deployment here
784:56 - which is fine
784:59 - and then they do a second one for some
785:00 - reason
785:03 - okay
785:05 - they install the nginx controller so
785:07 - that's something that we did so the
785:09 - nginx controller consists of a pod and a
785:11 - service
785:13 - the services the type load balancer etc
785:15 - so i don't think we need to do this
785:17 - because we press the button and that's
785:19 - basically the same thing
785:22 - okay
785:23 - and so then we need an ingress
785:25 - controller and the reason i'm looking it
785:27 - up here is because maybe there is a
785:28 - specific configuration
785:30 - to um digitalocean but it looks like
785:33 - just a standard one here
785:35 - so
785:37 - what i'll do here and i don't know if
785:38 - there's anything about this domain name
785:39 - stuff that we need to figure out i think
785:41 - that's where i kind of ran into some
785:42 - issues where i wasn't sure what to do
785:45 - um let me scroll up here is there
785:46 - anything about the domain name
785:51 - a fully registered domain name is
785:52 - available i don't really want one i just
785:54 - want to deploy one without one so what
785:56 - we'll do is we'll just copy the contents
785:58 - here
785:59 - and we're gonna go over here it's no
786:01 - different than any ingress controller
786:03 - for nginx i think
786:05 - okay and we'll paste that on in there
786:07 - and we're just going to take a look here
786:08 - so one thing i don't want is i don't
786:10 - want
786:11 - the host
786:13 - so what we'll do is take this out here
786:16 - and then here for the service i'm going
786:18 - to type nginx
786:20 - the path is fine there this all looks
786:21 - fine
786:23 - and so what we'll do is type in cube ctl
786:26 - um
786:28 - apply hyphen f
786:31 - ingress
786:35 - okay and if this works
786:38 - what we're expecting to see is an
786:40 - address here
786:42 - but i don't see one
786:44 - and this is the problem i was running
786:45 - into where i wasn't resolving
786:48 - okay
786:51 - so it says endpoints default they should
786:54 - be back and not found i don't think that
786:55 - matters
786:58 - and it is pointing to the nginx instance
787:00 - i just don't know why we don't have
787:05 - so like ingress address
787:09 - empty digitalocean
787:15 - so notice that they're not using host so
787:17 - they're saying it's empty as well
787:20 - if you are using nginx controller you
787:22 - don't need to see the ingress address
787:25 - okay
787:26 - when you install ingress controller to
787:28 - the cluster it creates a load balancer
787:29 - to handle all your incoming requests
787:30 - make sure the below
787:32 - part is completed
787:35 - so let's copy this because we could have
787:37 - installed it via helm or hit that button
787:39 - and so this will just confirm that it's
787:40 - installed i'm pretty sure it is
787:41 - installed trying to make our way back to
787:43 - the lotion so we hit this
787:45 - and so it is there we can see the load
787:47 - balancer
787:49 - i'm actually curious because i think
787:51 - that uh load balancers are in digital
787:53 - ocean i don't use this lotion on a
787:54 - regular basis so i'm not sure if we go
787:56 - to load bouncers did it create one so it
787:58 - did create a load bouncer for us
788:00 - i'm just curious doesn't have an ip
788:02 - address or a dns hostname
788:05 - um so i maybe made one for each one and
788:08 - there are ip addresses which is great
788:11 - and so down below here it says you
788:13 - should see an external ip address
788:15 - corresponding to the ip address of
788:16 - digitalocean load balancer
788:19 - okay
788:23 - and so there's one there one there but
788:25 - we're going to look at what there is
788:26 - here so this one has 10 24 oh sorry
788:28 - external 157 230 70 53 is that the one
788:32 - we're looking for
788:34 - neither of those match the load balancer
788:36 - they're all 68.
788:39 - okay
788:40 - well even if it is
788:43 - let's just go grab this one
788:45 - and see if that works
788:48 - because
788:49 - it says ingress engine x i'm just going
788:50 - to double check that
788:52 - this is ingress nginx controller
788:56 - it's not the same thing
788:59 - svc hmm
789:03 - okay well it's there so it does work
789:06 - and it is routing tangent x so it does
789:07 - work even though we don't have the
789:08 - address it's just a lack of confidence
789:10 - because i just kind of expected the
789:11 - address to be there but the digital
789:13 - ocean wasn't too bad
789:15 - so we'll go here
789:16 - and we'll go ahead
789:18 - and delete
789:21 - this
789:25 - and hit destroy
789:29 - and we'll put the name in here
789:33 - oh we want the load bouncer
789:36 - i didn't checkbox the bouncer but when
789:38 - we go destroy here
789:42 - let destroy
789:46 - that other one didn't have any resources
789:48 - because that was the one that i just
789:49 - spun up to show you
789:51 - and so because i didn't checkbox that
789:53 - thing i'm going to go to networking here
789:55 - and just make sure i remove those
789:57 - because this probably costs something i
789:58 - would think so we'll hit destroy
790:01 - we'll copy the name there and hit
790:02 - destroy
790:05 - i don't there's like any volumes
790:06 - lingering around so i'm just gonna
790:08 - double check
790:10 - nope
790:11 - there's no droplets or anything so uh
790:13 - yeah that's all there is to it um and
790:17 - there you go
790:18 - that's it
790:20 - [Music]
790:24 - hey everybody this is andrew brown from
790:25 - exam pro in this follow along i'm going
790:27 - to show you how to launch a kubernetes
790:28 - cluster on sibo so over here you can see
790:31 - i have a credit balance of 250 dollars
790:33 - when you first sign up you get 250 for
790:36 - free uh for a month and so you can see
790:39 - that i have a 0.3 spend because i
790:42 - launched one cluster uh sivo actually
790:44 - has a lot of great educational content
790:46 - for kubernetes um so they cover a lot of
790:50 - stuff here
790:51 - uh and so you know it's just if you need
790:53 - more stuff this is it mine is more
790:56 - certification focused where there's this
790:58 - general knowledge so maybe there's some
790:59 - places where you can fill the gaps in
791:01 - here by using their academy
791:03 - they also have docs here i haven't
791:04 - really gone through their docs so i'm
791:05 - not sure
791:08 - the quality of them but i do know their
791:09 - academy is is a-okay
791:12 - and you'll notice that they have
791:12 - kubernetes but looks like they have
791:14 - virtual machines load bouncers volumes
791:16 - and some networking things so what we'll
791:18 - do is go to kubernetes at the top here
791:20 - i'm going to create myself a cluster and
791:23 - here i'm just going to call this cluster
791:24 - uh sivo cluster for fun
791:27 - we can choose how many instances i just
791:29 - want one we choose the default network
791:32 - we can choose an existing firewall and
791:34 - go default default whatever they have
791:36 - there whatever that means i'm not sure
791:38 - what firewalls are on sivo
791:40 - and then there's a different sizes so
791:42 - notice that i mean like if it was me i
791:44 - would go straight to medium and so if
791:46 - you go to extra then it goes hey you
791:48 - should probably choose the medium so i'm
791:50 - like okay cool i know i know what size
791:52 - of carbonate clusters i should be using
791:53 - so we go back here and it's 20 20 a
791:56 - month now i do know that the control
791:58 - plane for sibo is free so that is
792:01 - something that's really great i'm not
792:02 - sure again i'm not sure if they'll be
792:04 - able to do that forever but that is one
792:06 - of their positions when you go to sibo
792:07 - pricing
792:09 - sievo pricing here
792:12 - that is um their advantage where they go
792:15 - look
792:16 - uh you are playing for the control plane
792:17 - and all these other providers and for us
792:20 - uh the control plane is a hundred
792:21 - percent free okay so
792:23 - uh obviously these costs are are quite
792:26 - large but um
792:28 - but yeah so that is an advantage with
792:30 - sibo now what we'll do is go ahead and
792:33 - launch a new cluster
792:35 - oh sorry i was already launching one
792:36 - wasn't i
792:38 - uh so we'll go back to this tab here we
792:40 - have our medium you can see monthly or
792:42 - hourly you're not gonna get charged like
792:44 - immediately twenty dollars it's gonna be
792:45 - whatever it is percent
792:47 - and then we have some stuff in the
792:49 - marketplace so just like everything
792:51 - there are marketplaces might just wanna
792:53 - poke around here to see what they have
792:55 - so pretty pretty standard stuff i like
792:57 - how like the ci cds are here i didn't
792:59 - notice them on the other ones but maybe
793:01 - i just never noticed but anyway we'll go
793:03 - ahead and create this cluster
793:08 - and so we'll have to wait for it to
793:09 - create and has this countdown here
793:11 - saying how long it's going to take
793:13 - um and it's relatively pretty quick i
793:15 - think we'd say like a few minutes
793:18 - and so um i'll see you back here when
793:20 - it's done okay
793:22 - all right so after waiting a little
793:24 - while our cluster is running so we'll
793:26 - have to take a look at how to uh get
793:28 - working with this and the way it works
793:29 - is you'll need to have a cube config and
793:32 - just download that and use that so what
793:34 - i'm going to do is make my way back over
793:35 - to aws because we're going to use our
793:37 - cloud9 environment and um i have one
793:40 - provision from
793:42 - um
793:44 - before
793:45 - the digitalocean one i'm actually just
793:47 - going to go delete that and make a new
793:48 - one right now
793:51 - okay
793:52 - and then what i'll do here is create a
793:54 - new environment and we'll just say civo
793:57 - env just so we have a way of interacting
793:59 - with it i'm going to stay with the
794:00 - ubuntu just because
794:02 - i usually go with amazon linux but it
794:03 - says it's so easy to do that pseudo snap
794:06 - install for that cube ctl i figured
794:08 - we'll stick with it we'll do a t2 micro
794:10 - because we don't need anything else than
794:11 - that we'll go ahead and spin that up
794:14 - so while we're waiting there i guess the
794:16 - question is is like how do we do ingress
794:18 - because i didn't really do much
794:20 - uh with sibo
794:23 - so
794:23 - maybe what we can do is go take a look
794:25 - at their docs and see if they have
794:27 - instructions for that so i'm going to go
794:28 - here
794:29 - i just want to see um how we can do
794:32 - ingress so because that's always the
794:34 - questions like how do you do ingress how
794:36 - do you do load bouncing right
794:38 - so ingress controller with your own tls
794:40 - certificate
794:43 - um i want to know
794:48 - let's look at load balancing here
794:51 - so creating a load balancer relies on
794:53 - the sivo control uh
794:55 - cloud control manager sending the
794:57 - appropriate request to the cvo api to do
794:59 - load balancing and so then down below
795:02 - the low bouncy algorithm is provided in
795:04 - the round robin here's the annotation i
795:06 - imagine this is the annotation that we
795:07 - expect to see in our ingress controller
795:10 - or something like that
795:12 - external traffic policy session affinity
795:14 - firewall like yeah yeah what i really
795:17 - just want is i just want to know how to
795:19 - do it
795:21 - like what are the step-by-step
795:22 - instructions
795:24 - um for us to
795:25 - deploy so i'm not 100 sure
795:29 - okay
795:32 - and this kind of just says like how easy
795:34 - it is to uh utilize this stuff and
795:36 - that's always the question that i have
795:37 - here so here they have ingress and
795:40 - it looks like this but it's using tls i
795:43 - don't really care about tls
795:46 - all right so we'll go back here and this
795:47 - environment's ready and we will do our
795:50 - sudo snap install cube ctl classic
795:54 - to get that going there and then for
795:56 - civo we definitely have to download the
795:59 - config cubeconfig so we'll download the
796:01 - cubeconfig
796:03 - and
796:04 - i have to spell cubectl correctly it's
796:06 - not going to work
796:08 - and then what we need to do is we need
796:10 - to upload this file so i'm just showing
796:12 - this in my uh
796:15 - folders off screen here we're going to
796:16 - go to file
796:19 - um upload local files
796:21 - and then here i'm just dragging on in
796:23 - that file here
796:25 - and then we're going to hit close
796:29 - and did it upload
796:32 - yep so that's the contents of the file
796:34 - and so what i'll do is i'll say move
796:36 - to cube
796:38 - config
796:40 - we need to put the name of what we're
796:41 - actually moving so sivo
796:44 - this
796:46 - uh sure we'll say touch or make
796:48 - directory
796:50 - cube
796:53 - and then we'll move that into the right
796:54 - place and then we'll see if we can do
796:55 - this cube ctl get pods
797:00 - great
797:01 - and then i'll just do cube ctl
797:04 - create deploy um
797:07 - engine x hyphen hyphen image nginx and
797:10 - we'll hit enter and so that creates that
797:12 - there we'll go back to sivo and see if
797:14 - there's any way we can kind of like view
797:16 - our load like what kind of interface or
797:18 - stuff does it give us or is it really
797:19 - bare bones that's fine if it's bare
797:20 - bones
797:22 - but let's just see what we can see
797:27 - so we're going here and we'll go into
797:29 - our cluster
797:33 - okay
797:36 - and
797:37 - um we'll go to install applications
797:42 - marketplace uh i guess this one doesn't
797:44 - really show you anything and that's
797:46 - totally fine um
797:49 - but uh i guess the question is is like
797:51 - how are we going to network this so i'll
797:53 - be back here in a moment and i'll figure
797:54 - it out and i'll see you here
797:56 - soon okay all right so i'm not sure if
797:57 - this is going to work but because this
797:58 - one is specifically with your own tls
798:00 - certificate but i'm going to just try to
798:02 - maybe follow through with instructions
798:04 - here so we already created our nginx
798:06 - thing and then the next thing we need to
798:08 - do is expose it so what i'm going to do
798:10 - is go back over to cloud9 we'll type in
798:12 - cube ctl and by the way civo has their
798:15 - own um
798:17 - uh
798:18 - like tool like to create stuff so i mean
798:21 - that could be useful but i didn't
798:22 - install it so i guess we'll just
798:24 - do what we can here we'll type in expose
798:26 - deploy nginx and sometimes you'll see
798:28 - people do this and this is totally valid
798:30 - as well but i just like to have with no
798:32 - space or like no hyphen or forward slash
798:36 - there we'll do 80 and then we'll do
798:38 - target port
798:39 - equals 80 and then we'll say
798:42 - um kind or no it's type
798:45 - and we'll say node port because that's
798:47 - just what i've been used to doing
798:50 - and so now we have a service and the
798:51 - next thing we'll need is an ingress
798:53 - controller so i'll type in ingress
798:55 - yaml and then we'll go ahead
798:59 - uh
799:00 - yeah that's fine close tab because we
799:02 - deleted that one there
799:04 - and we'll go here and we'll copy the
799:06 - contents here
799:07 - and we'll modify it a bit so
799:10 - replace with your cluster dns name so we
799:12 - probably need that
799:15 - i don't care about tls
799:18 - this is going to go to engine x
799:21 - we're going to leave the path normal
799:22 - we're going to go to port 80
799:25 - and
799:26 - it's fine if the path prefix it just
799:28 - looks slightly different because usually
799:29 - when we do ingress they look a little
799:31 - bit different here and we'll just type
799:33 - in ingress here and so what we'll do is
799:34 - grab our cluster dns name
799:38 - which is here
799:42 - okay and then we'll go ahead and post
799:44 - that we usually don't do a host but um
799:48 - for this since they're doing it let's
799:49 - give it a try
799:51 - and we'll do
799:53 - cube ctl apply hyphen f ingress yaml
799:57 - great and so now we can use cube ctl
800:01 - get ingress
800:04 - and it has an address
800:05 - so go grab that
800:08 - whoops
800:10 - did not work as expected
800:14 - 404 not found
800:16 - but at least um it's doing something you
800:18 - know what i mean so we'll go back here
800:20 - http colon slash
800:23 - okay what if we try with the uh the host
800:29 - and we'll advance
800:31 - oops
800:34 - um
800:40 - can i advance
800:43 - you cannot visit right now because the
800:45 - website uses hsts network errors in
800:48 - attack usually temporary with this page
800:49 - will probably
800:51 - work later so usually like if we have
800:53 - that we just advance right it's not a
800:55 - big deal what if i just try http can i
800:57 - do that
800:59 - or does it always forward
801:02 - no it does okay um so that's not going
801:06 - to work
801:08 - hmm
801:10 - so maybe we do need a tls but it does
801:12 - say like
801:13 - bring your own tls certificates so maybe
801:15 - we can just gener generate one in place
801:18 - um so
801:20 - save the cluster in the desired
801:22 - configuration so
801:25 - three node cluster greenstone create
801:26 - certificates so here they have a line to
801:29 - create a certificate
801:34 - okay
801:43 - and we'll go to the next place here
801:47 - and
801:47 - [Music]
801:49 - it
801:50 - says waiting okay so generated it out
801:53 - and then it says create a secret
801:59 - okay
802:02 - because maybe the requirements for civos
802:04 - you have to have tls or
802:06 - some kind of secure thing to connect i'm
802:08 - not sure but that is kind of my guess
802:10 - there
802:11 - maybe we should just follow through
802:12 - their tutorial here because
802:14 - they might have other things configured
802:15 - that i'm not aware of
802:17 - so let's just
802:18 - go all the way down the list and follow
802:20 - their instructions
802:22 - so we'll do this
802:26 - and then we'll go down and we'll copy
802:28 - the contents here
802:31 - um
802:32 - i'm just going to rename this
802:34 - to
802:37 - and then we'll just gut the content here
802:39 - well i don't have to
802:40 - get that cluster ip or dns again so i'm
802:43 - just going to paste that there
802:44 - and we'll scroll up and we'll just grab
802:47 - this value here cut
802:50 - and then we will
802:52 - paste this here
802:53 - and we will paste this here
802:57 - and then we'll delete the old one if we
802:59 - can find where it starts which is here i
803:01 - believe
803:03 - good
803:04 - and so then we'll do
803:06 - cube ctl apply hyphen f
803:08 - ingress two
803:15 - and then we'll do ingress and we'll have
803:17 - two there which is totally fine
803:19 - we're going to delete the old one i
803:20 - guess
803:21 - that's the one i made so cube ctl delete
803:25 - ingress or
803:27 - ing ingress
803:29 - clear
803:32 - and then check if everything works so
803:34 - there they are
803:36 - doing a curl there but it looks like you
803:37 - can also just go to the demo so maybe
803:39 - what we'll do is just copy this line
803:41 - here
803:42 - go to our browser type forward slash
803:44 - demo
803:45 - cannot be reached
803:53 - so
803:54 - i mean we can also try the curl
803:56 - right but i don't think that's going to
803:57 - make a difference because you know it's
803:59 - either right or it's wrong you know
804:10 - oh yeah so it's working it says it's
804:11 - here
804:13 - so if that's the case maybe it's just
804:16 - not resolving yet because it's like new
804:17 - or
804:18 - something so i'm going to grab the ip
804:20 - address instead
804:23 - okay and then i'm just going to try this
804:24 - instead
804:27 - 404 not found
804:28 - so it is 100 working it could be
804:33 - a firewall thing so they do have a
804:35 - firewall
804:37 - as we saw as the default so let's take a
804:39 - look at what's there
804:41 - um i'll just go back to command zero
804:43 - here to resize our stuff because that
804:45 - manage firewalls
804:48 - and i don't know anything about civo so
804:50 - i'm just hoping that's like open a port
804:52 - so we will go in and
804:56 - the default firewall has all ports open
804:58 - so if you install anything out of the
805:00 - box we advise to create custom firewalls
805:02 - so everything is open
805:06 - but technically according to uh to their
805:08 - tutorial it is working correctly now why
805:11 - i can't access it here
805:13 - i don't know
805:15 - okay but we do know that when we ran
805:17 - this command
805:20 - for ours and we could also probably even
805:22 - try with the ip address maybe i don't
805:23 - know if that would make it uh like if we
805:24 - still get the same thing
805:30 - so here it says 404 which is fine and
805:31 - we'll try this one again
805:34 - and here we get a 200 hello world so it
805:36 - is working um i don't know if i know
805:38 - enough about sibo to get beyond this
805:39 - point but it's totally fine uh and i
805:42 - think we are a-okay here so i'll go back
805:44 - to cloud9
805:46 - and we will go and clean this up
805:49 - but just do that can i get back to
805:50 - cloud9 easily yes i can
805:52 - and we will delete our sivo environment
805:58 - and we'll go back to our cluster here
806:00 - kubernetes and we will go ahead and
806:02 - delete
806:04 - our
806:05 - cluster
806:08 - and we are all done there you go
806:12 - [Music]
806:16 - hey this is andrew brown from exam pro
806:18 - and we're going to take a closer look at
806:19 - namespaces so we have been using
806:21 - namespaces throughout our labs but i
806:23 - figured i'd give it a little extra
806:25 - attention here just to talk about a few
806:27 - extra commands i think that we should
806:29 - know uh so you know if we want to and
806:31 - again i'm in our micro case environment
806:33 - so just make sure you have that spun up
806:35 - there in cloud nine so you can follow
806:37 - along here but
806:39 - what we'll do here is type in cube ctl
806:41 - get namespaces and so we can get a list
806:44 - of our namespaces
806:46 - the server doesn't have a typename
806:47 - system maybe because we got to type it
806:48 - right
806:50 - all right and instead of typing
806:51 - namespaces we can also type ns you can
806:54 - see we created those ones prior fire ice
806:56 - and wind depending on when we did the
806:57 - labs if i want to make a new one it's
806:59 - just cube ctl create ns
807:02 - um
807:03 - borg it would be our new namespace there
807:06 - okay
807:07 - and some interesting things is uh like
807:10 - if you let's say we launched a pod so
807:13 - let's make let's launch a
807:14 - or a deployment into this name space so
807:17 - we type in cube ctl
807:19 - um
807:21 - create deploy
807:23 - uh hyphen hyphen image
807:26 - nginx
807:27 - um
807:29 - n
807:30 - borg okay and so what that will do
807:33 - i really gotta learn how to spell keep
807:34 - ctl right what that will do is launch it
807:36 - in that name space so if we do
807:38 - uh cube ctl get pods
807:42 - that always shows for the default
807:44 - namespace right it's not gonna show us
807:46 - all of our apps it's gonna show what's
807:48 - in the default namespace
807:51 - all right so if we want something from
807:53 - another namespace other than default we
807:54 - have to put the n and then the name so
807:56 - we do borg
807:59 - and i think it's just not there yet
808:00 - because it's still spinning up so if we
808:01 - were to do
808:03 - deploy here then we could see it
808:05 - oh did that not work
808:07 - exactly one name is required okay so i'm
808:09 - not paying attention here
808:12 - i'm just checked out here so we will put
808:14 - the word engine x here
808:16 - great and so now if we go back here we
808:18 - can see that we have a pod but notice
808:20 - that if we uh do not have that it should
808:22 - not show up so all right so you need to
808:24 - have that hyphen end or
808:26 - if you want to be more verbose you can
808:28 - do hyphen hyphen
808:30 - name space it's important to list like
808:32 - the variants because when i was taking
808:34 - the exam like when i didn't know there
808:36 - was a difference between deployment
808:36 - deploy i couldn't tell if one was just
808:38 - like purposely wrong or there was an
808:40 - abbreviation or a shortcut for stuff so
808:43 - just understand there's a lot of
808:44 - shortcuts
808:45 - and i don't think the exam would ever
808:47 - try to trick you by having like fake
808:50 - fake abbreviations like that okay
808:53 - um so if you think it is kind of
808:54 - generally says deployment or deploy then
808:56 - it's probably the same thing on the exam
808:59 - so one interesting thing that we could
809:00 - do would be to um
809:04 - list multiple resources so uh and this
809:06 - is not namespace specific but what we
809:07 - can do is we can say get
809:10 - all
809:11 - and that will actually list out a bunch
809:12 - of resources so here we got our positive
809:14 - deployments or replica sets and some
809:16 - things won't ever show up there like um
809:18 - maybe like
809:20 - config maps
809:22 - secrets
809:23 - ingress okay and so that allows us to
809:25 - bring in a lot more stuff so not all of
809:27 - these things have stuff but notice we
809:29 - are getting things listed out actually
809:30 - they do we did get a lot of stuff here
809:32 - so just realize that that's another way
809:34 - with answers but now can you get
809:36 - multiple name spaces so if i say get uh
809:39 - you know pod and then i say hyphen or
809:42 - hyphen name
809:43 - um
809:44 - default and
809:47 - board just understand that you can only
809:48 - pass it one which is kind of frustrating
809:50 - i kind of wish there was a way to do
809:51 - multiples if there is i sure don't know
809:53 - how to do it but one interesting thing
809:55 - is if you want to delete everything in a
809:56 - namespace you can do delete all and so
809:59 - remember what all returned right so
810:00 - anything that all returned is what it
810:02 - would delete so i think if we wanted to
810:04 - get all of them we probably have to do
810:05 - like cm secrets ingress like that
810:08 - right but i'm just going to do all
810:12 - and then we would do hyphen n and then
810:14 - we would just say borg
810:18 - it says uh
810:20 - no name was specified
810:23 - oh sorry so it'd be all
810:26 - hyphen hyphen or sorry uh dash dash or
810:29 - hyphen hyphen all and so that way you
810:31 - don't specify name you can just say all
810:33 - the names right and so it's deleted
810:35 - those resources there i don't know if
810:37 - the namespace still exists cubectl get
810:40 - namespaces and that's still there as
810:42 - well so we'd have to delete that
810:43 - namespace cubectl delete nsborg
810:47 - and there you go so that's all i really
810:48 - wanted to show you is just some of those
810:50 - extra commands because it's nice to have
810:52 - that delete all ability uh when you put
810:54 - everything in the namespace and you just
810:55 - delete it okay there you go
810:57 - [Music]
811:01 - hey this is andrew brown from exam pro
811:03 - in this follow along we're gonna be
811:04 - looking at role-based access controls
811:06 - also known as rbac i'm going to tell you
811:08 - right now they're a pain to set up
811:10 - they're such a pain
811:12 - and there's two types we have cluster
811:14 - roles like cluster stuff and then
811:16 - there's uh just roles and those are name
811:18 - space which we do cover in the course
811:20 - we're not going to do both because we
811:21 - just be here all day and we really don't
811:23 - need that for the kcna but i do want to
811:25 - set up one a role uh for a particular
811:28 - user and then restrict some resources
811:31 - okay so i'm just going to type in clear
811:33 - here make sure you launch that micro
811:34 - creates environment
811:36 - and this is a little bit tedious and
811:37 - painful but we will get through it um
811:39 - and we might have to kind of like piece
811:40 - it together because it was a lot of work
811:42 - for me to
811:43 - get a working solution here so if you
811:46 - can't get through it don't worry just
811:47 - watch along if you do get stuck and just
811:50 - understand all the components that go
811:51 - involved
811:52 - but i'll get through it here on video
811:54 - here so do not worry but what we'll do
811:56 - is type in micro k8
811:59 - kate's status and we have the ability to
812:02 - enable it and i just want to note if we
812:04 - do rbac kubernetes here normally what
812:07 - you would do but we're using micro case
812:09 - but normally what you would do is you
812:11 - would have to specify
812:12 - when you start your
812:14 - cluster the api server
812:16 - you'd have to tell it to run an
812:18 - authorization mode of rbac
812:20 - now we don't have to do that we just
812:22 - have to enable it here so just
812:24 - understand that that's abstracted away
812:26 - for us
812:27 - but if you do see on the exam that flag
812:29 - just remember you know what it does okay
812:32 - and so what i want to do is just enable
812:34 - rbac it's right here there it is and
812:37 - we'll go ahead and hit enter and we'll
812:40 - give it a moment to enable it shouldn't
812:41 - take too long so it's reconfiguring the
812:43 - api server so it's likely adding that
812:45 - authorization mode flag so that it is
812:47 - enabled and there it is
812:49 - okay so
812:50 - um i'm looking for my super complex
812:53 - instructions for
812:55 - uh just the role so the first thing
812:57 - we're going to need is we're going to
812:58 - need um
813:00 - a way of identifying our users and
813:02 - there's a few different ways to do that
813:03 - if we go to authentication
813:05 - kerneubernetti's kubernetes
813:07 - don't worry if you can't say it i can't
813:08 - say it half the time or spell it but
813:11 - we have a few different ways that we can
813:13 - authenticate
813:14 - and
813:15 - it
813:16 - says it should say here the list
813:19 - so
813:20 - certifications bearer tokens there's
813:23 - three ways
813:25 - and it's not showing it here
813:29 - let me double check let's go to the top
813:30 - here i remember being the two of the top
813:32 - um
813:35 - maybe it's not this page
813:40 - maybe it's controls here
813:44 - well i'm gonna tell you i'm not sure
813:45 - where the page is but i can tell you
813:47 - that there are three ways uh at least at
813:50 - least three ways of doing it so one's
813:52 - using a certificate another one is
813:53 - having a bearer access token and there's
813:55 - another way
813:57 - they're not going to ask you on the exam
813:58 - so it's not a big deal
814:00 - maybe like the security exam that would
814:02 - be where that would matter but what
814:03 - we're going to do is we're going to
814:04 - generate out a certification because
814:06 - that was the one that i found the
814:08 - easiest to understand even though
814:09 - there's a lot of steps involved so what
814:11 - we'll have to do is generate out
814:13 - ourselves a certificate and so we're
814:15 - going to use openssl to do that so we'll
814:18 - type in openssl we're going to type gen
814:20 - rsa because rsa is the type of um
814:24 - cryptographic thing that we want to do
814:26 - there we'll type out to output um
814:29 - the uh the thing that we're generating
814:31 - here of the key and then we'll put the
814:33 - name so i'm going to call everything
814:34 - developer just to make things easier you
814:36 - could put the name like andrew or
814:38 - something here but just stick with me
814:39 - here and do developer because it becomes
814:40 - super hard
814:42 - to swap this all out so uh 2048 i
814:44 - believe is the length of the key that we
814:46 - want we hit enter and it generates out
814:48 - our rsa private key so now that we have
814:51 - our rsa private key um we need to uh
814:54 - create or generate a client site uh sign
814:57 - request a csr don't ask me what that is
814:59 - i do not remember but i just know that
815:01 - we need to do it so we'll type in
815:02 - openssl req new hyphen key
815:07 - developer.key
815:09 - hyphen out
815:10 - developer.csr that's what we want to
815:12 - generate a csr
815:14 - s-e-b-j and then we which stands for
815:17 - subject and then we have this very
815:18 - special syntax so cn is going to be the
815:20 - user's name which is developer we don't
815:22 - want to make a mistake and then oh
815:24 - capital o equals is going to be the
815:26 - group because remember rbacs can have
815:28 - users and groups we're going to call it
815:30 - developer as well we could call it
815:31 - developers but again for simplicity
815:33 - we're just going to call it developer
815:34 - okay i'm going to double check to make
815:36 - sure that's okay
815:38 - and if you're wondering like where did i
815:40 - get all these instructions
815:41 - oh also notice we've got this error so
815:44 - it's possible
815:46 - that this line didn't work i remember
815:48 - getting this error so let me look here
815:50 - because i did have a fix for it
815:54 - can't load root orange okay so i think
815:56 - it's like r d
815:58 - here let's just look it up and see if we
815:59 - can find it very quickly
816:02 - so they say try removing your commenting
816:04 - out rand line in this thing yeah that
816:05 - was the problem here so this is maybe a
816:08 - weird problem with ubuntu
816:10 - um and so i almost didn't catch that
816:12 - error there i'm gonna do ls did it
816:13 - generate out that csr it shouldn't
816:15 - because it wouldn't have worked so i'm
816:16 - going to go ahead and delete that
816:18 - and then what we're going to do
816:20 - i grabbed that line over here this one
816:22 - here and we're going to have to open
816:23 - this up
816:25 - so normally we could do like
816:27 - c9 and file name but unfortunately like
816:29 - last time i did npm install i could try
816:32 - it right now and see if it works npm
816:33 - install uh
816:34 - this this would install the c9 client
816:37 - i should be able to do c9 and then do
816:39 - this
816:40 - but it's not opening up so i think it's
816:42 - because we're on ubuntu and on amazon x2
816:43 - so i'm just going to clear that out and
816:45 - so if since we can't use cloud9 to
816:47 - easily open it we'll have to open up
816:49 - invi
816:50 - and vi is a big pain because every key
816:52 - matters okay so i'm going to hit enter
816:55 - and
816:56 - before you touch your keyboard
816:57 - understand that every single key doesn't
816:59 - act like a normal key so if i hit
817:02 - j it goes down if i hit k it goes up if
817:05 - i go l it goes right
817:07 - okay if i go h it goes left all right
817:10 - every key is bound to something so
817:11 - you've got to be very careful so what
817:12 - we're going to do is hit j until we get
817:14 - down to this rand line and then we're
817:17 - going to hit i to go to insert mode look
817:19 - down below it says insert mode here and
817:21 - now your keyboard acts like a normal
817:23 - keyboard and your cursor even though it
817:25 - selects the r it's actually in front of
817:26 - it and we're going to make a pound okay
817:28 - that's going to comment it out now to
817:29 - get out of insert mode we'll hit escape
817:31 - on our keyboard
817:33 - okay left and now do colon to execute
817:36 - commands but then this right for w q for
817:39 - quit
817:40 - um and the problem is we're in read-only
817:42 - mode so i had to do sudo there so what
817:44 - i'll have to do is do colon cue
817:46 - exclamation mark and then hit up
817:49 - ctrl a to go to the front sudo enter
817:52 - and it brought me back to the same spot
817:54 - so we'll go i
817:56 - insert mode
817:57 - pound
817:59 - escape
818:01 - notice insert mode is out so now we're
818:02 - in normal mode
818:03 - colon wq
818:05 - i use vim as my primary um
818:08 - layout or keyboard layout so for me it's
818:10 - normal but you know a lot of people
818:12 - aren't and you know just got to be very
818:14 - careful there so we've updated the open
818:16 - ssl cnf and so what we'll do
818:19 - if it generated a key i don't trust it
818:21 - so i'm going to delete it
818:22 - because i don't want to see that message
818:23 - there and we'll hit up until we get back
818:26 - to
818:28 - this one
818:29 - okay notice no errors we'll hit up
818:35 - can we get this one no errors good now
818:38 - the question is where am i getting these
818:39 - crazy commands well the only way is to
818:41 - look up tutorials because if you go on
818:44 - the kubernetes docs they do not help
818:45 - whatsoever um so at least like the
818:49 - kubernetes docs is good in some places
818:51 - bad in other places um but i'm just
818:53 - trying to find the article ahead so it'd
818:54 - be like rbac
818:56 - rbac with kubernetes yeah and i think it
818:59 - was like a mini cube that i used so i
819:01 - had to adopt this
819:06 - rbac probably spell it right so we can
819:08 - find it easily
819:11 - because one of the key skills of
819:14 - learning kubernetes is being able to
819:15 - find solutions and so this is the fellow
819:17 - that made one i don't know if he has a
819:18 - video but
819:20 - generally like a lot of these commands
819:21 - are here um yeah i think he has a video
819:23 - i didn't watch it i just kind of like
819:25 - went through and kind of adapted it to
819:26 - to my needs
819:28 - um but you know a lot of that stuff you
819:30 - just got to look for it or understand
819:31 - how this stuff works
819:33 - so we generated our csr we fixed the rng
819:36 - problem
819:37 - and so now the next thing we need to do
819:40 - um
819:43 - is we need to generate out a crt okay
819:47 - and so that's just another thing we need
819:48 - to generate out but before we do we need
819:50 - the crt these are cert certificates um
819:54 - for kubernetes so if i type in
819:56 - kubernetes certifications
820:00 - or maybe certificates because it's not
820:02 - certifications per se
820:05 - um and we go maybe here
820:08 - nope that's not it maybe here
820:14 - that's not it
820:15 - i'm just looking at i got the links here
820:17 - i'm just trying to google it so we can
820:19 - find it
820:21 - best practice certifications okay so
820:23 - kubernetes
820:25 - best practices you can only imagine how
820:26 - much time i spent looking this stuff up
820:29 - and we go here and so what we're looking
820:31 - for is where these um
820:34 - certificates are so when you install
820:36 - your kubernetes cluster it generates at
820:39 - all these different kinds of
820:40 - certificates so these certificates are
820:42 - used to validate uh authenticity of
820:44 - things right so you say okay this is
820:46 - your certificate we'll
820:48 - bind them together somehow and double
820:50 - check and things like that so we need to
820:52 - have the crt and the ca key and so we
820:56 - need to know where these are now if
820:57 - you're using minicube they install in a
820:59 - particular place if you're using micro
821:01 - k8s
821:03 - they install a particular place but this
821:04 - is where they are by default so micro
821:06 - k8s
821:07 - is somewhere else
821:10 - and so if we want to know where it is
821:13 - i think we'd have to look up like micro
821:15 - k8s um off
821:17 - okay
821:20 - so if we go to the docs here
821:24 - i think it might be under service and
821:25 - ports
821:28 - and if we scroll on down here
821:34 - it shows you here var snap microwaves
821:36 - current certs so this is where they are
821:38 - so what we'll do is copy this directory
821:41 - and we're going to do ls and then paste
821:43 - it in to see where they are and we can
821:45 - see we have a csr conf cube etc etc ah
821:49 - there they are c a c a dot key and then
821:52 - cr dot cert so this is where they are
821:54 - and so now that we have that we now need
821:56 - to type this big old ugly
821:59 - command here so open ssl
822:01 - x509 which is a type of certificate or
822:04 - something i've seen 509 i don't really
822:06 - know what it is you're going to see it
822:08 - for years we'll say developer.csr
822:10 - because we're going to need that
822:12 - and then we do hyphen ca and then we
822:15 - have hyphen ca key and then we have
822:17 - hyphen ca
822:19 - create serial and then out
822:22 - um developer we didn't type everything
822:24 - and i'm just kind of just like filling
822:25 - out the
822:26 - the obvious stuff
822:28 - and then what we'll do is fill in
822:30 - these ones here so we got to fill in a
822:32 - value here
822:33 - okay we got to fill a value in there
822:35 - so what we need is
822:38 - and we'll open up our readme to make
822:39 - this a little bit easier i'm just going
822:40 - to go ahead delete the contents here but
822:42 - i need this address
822:45 - actually just to make this easier i'm
822:46 - going to copy this here because this is
822:47 - such a pain to type
822:49 - and we'll paste it in here
822:51 - and i'm going to grab the contents here
822:54 - just in case we make a mistake and we
822:55 - have to type this like 100 times
822:57 - or like execute it 100 times and so here
823:00 - we want
823:01 - uh ca cert
823:07 - and here we want um
823:11 - this is
823:12 - ca key yeah
823:14 - okay
823:15 - and so this is the big old line that we
823:17 - need so what we'll do
823:19 - whoops
823:21 - did i mess that up
823:22 - okay so we'll copy that line
823:24 - just clear this one out oops
823:27 - again i'll copy this line again yank
823:29 - paste
823:31 - looks okay hit enter
823:33 - and can't open
823:35 - for reading no such file or directory
823:37 - okay so i'll double check one more time
823:40 - i clearly made a mistake
823:45 - oops sorry ls
823:48 - oh crt
823:50 - sorry i wrote cert
823:54 - uh here
823:56 - okay so i'm gonna yank that line
824:00 - oops didn't get it
824:02 - try one more time
824:04 - it's a bit hard to copy
824:06 - i don't want to wrap the text there's a
824:07 - way of wrapping it but it's just like
824:09 - don't have to unwrap it so
824:10 - hit enter
824:12 - okay and generate out our crt
824:16 - are you lost
824:17 - okay so let's create a user now so the
824:20 - way we do that is we're gonna type in
824:22 - cube
824:23 - ctl config
824:26 - set
824:27 - credentials
824:29 - developer hyphen hyphen client
824:32 - certificate
824:37 - equals developer dot crt
824:40 - hyphen hyphen client
824:43 - hyphen key
824:45 - developer dot key
824:50 - if you hear rumbling i don't know if you
824:51 - can hear it but my my stomach's been
824:52 - like rumbling through a lot of the labs
824:54 - so if you hear like a rumbling sound
824:56 - it's probably my stomach um cube ctl
824:58 - config set credentials developer that's
825:00 - the developer that we want uh the client
825:02 - credentials developer crt client hyphen
825:04 - key developer dot key we'll hit enter
825:07 - uh and i typed it wrong so that would be
825:09 - a problem
825:11 - oh boy it's acting funny so what i'll do
825:13 - is i'll just copy the contents here
825:23 - and if we do want to make this easier i
825:25 - can just do this
825:27 - so my life is not so painful
825:30 - this uh backlash allows you to do multi
825:32 - lines okay so
825:34 - client
825:36 - probably should be spelled right
825:39 - paste that in there it didn't take it
825:40 - one second we'll try this again
825:43 - clear
825:44 - paste it in again
825:46 - it's not taking it
825:50 - okay we'll make it one line all right i
825:51 - don't know why it's being silly but
825:54 - whatever
825:56 - so we'll copy this again
826:00 - that or there actually is an error okay
826:02 - i just can't tell if it's a multi-line
826:03 - error here
826:04 - it's missing the y here
826:07 - there we go okay so the developer has
826:09 - been set
826:10 - so now we have created our user
826:14 - and if you want to see the users there's
826:16 - a command it's called cube ctl config
826:19 - view hyphen o because like if you do
826:21 - view you get
826:23 - a bunch of this stuff right and so
826:25 - this config file
826:27 - shows us things so we can see admin and
826:29 - developer there if you want to be really
826:31 - clever you can do um parsing so if you
826:33 - do hyphen o you could pass it like
826:35 - jsonpath
826:37 - uh which is a i think it's like jq
826:39 - syntax there's a name for that syntax i
826:40 - can't remember what it's called i
826:42 - covered in one of my other courses
826:45 - asterisk
826:47 - and then we say dot name here
826:49 - okay
826:51 - and um
826:53 - did i type that right
826:55 - i forgot the equals here
826:58 - so we get the names really all it's
826:59 - doing is it's just parsing it through
827:01 - and grabbing out the admin and developer
827:02 - so we can see that we have um uh two
827:06 - users whoops
827:08 - i just wonder if this is actually the
827:09 - same contents as let me just type clear
827:11 - again so type in uh view again here one
827:13 - second so this is that file but i wonder
827:15 - if this is the same file as our cube ctl
827:17 - so if we type in cat which just means
827:19 - concatenate like to print out and we go
827:22 - cube config i wonder if it's just the
827:23 - same darn file
827:25 - uh it's similar so notice like there's
827:27 - some additional stuff here so we have
827:28 - certificate authority which is this big
827:30 - old string here
827:31 - server micro k8 we have context
827:34 - uh uh kind config user preferences but
827:37 - notice that when we do config view
827:40 - it's just a shortened version so ah here
827:42 - it is so look it says data omitted so it
827:44 - is the same file it's just that it's
827:46 - obscuring that just in case for security
827:48 - because i would assume you do not want
827:50 - to share your certificate authority data
827:52 - um
827:53 - i'm not worried about it because this is
827:55 - locked in on a vm and this will be
827:56 - deleted by the time you get to see it so
827:58 - i'm not too worried about it but yeah so
828:01 - all it did was really add it here and
828:03 - then provide those links there that was
828:04 - that big fancy link that we did with the
828:06 - set credentials there so now the next
828:08 - thing we need is a context so a context
828:10 - is to say what user are we right now so
828:12 - these are the users possible users and
828:14 - the the things that we need to uh
828:16 - authenticate them with notice this one
828:18 - uses a token to authenticate but here
828:20 - are the contexts so right now we are the
828:22 - micro creates cluster and uh like that's
828:25 - or sorry that's the context for this
828:27 - cluster because you could have multiple
828:28 - clusters uh that you want to connect to
828:30 - and then this is the user that we are
828:32 - we're the admin user okay and this is
828:34 - for uh micro k8s so what we'll do
828:38 - is um
828:39 - we will actually we can see our current
828:42 - uh
828:43 - contacts by typing current config
828:45 - current
828:48 - context it'll just show us who we are
828:51 - current
828:52 - contact so i don't see here oh it's
828:54 - right here right
828:56 - okay so if we hit that we are micro case
828:58 - right now that's who we are
829:00 - um and so
829:04 - yeah because the name is michael gates
829:06 - the context is called micro caves okay
829:08 - and so now what we can do is we can uh
829:11 - switch
829:13 - our context
829:15 - so or actually we need to make a new
829:17 - context sorry because we don't have a
829:18 - context for our developer yet so we'll
829:20 - type in cube ctl config set context
829:23 - developer hyphen hyphen cluster equals
829:26 - micro k8
829:28 - cluster
829:29 - and then hyphen hyphen user equals
829:31 - developer okay
829:33 - and so now if we go back and we view
829:36 - you can now see that we have a context
829:39 - here
829:40 - and just make sure the cluster is
829:41 - correct if that's wrong we'll end up
829:42 - with an error
829:44 - so um
829:47 - we haven't switched context yet we are
829:49 - still this context here
829:52 - but um one thing we'll want to do is we
829:54 - will want to uh set some permissions
829:56 - here but before we do i just want to
829:58 - show you a command to say what do we
829:59 - have access to so there's a thing called
830:00 - cubectl auth and auth we have this thing
830:03 - this is can i and we can say list pods
830:06 - and so if i say this it'll tell me
830:08 - whether i'm allowed to list pause this
830:09 - is a way of checking
830:11 - role-based access controls before we
830:12 - even set them okay and if we're a
830:14 - developer i can say as
830:16 - uh equals developer can i right now
830:20 - oops
830:22 - say uh hyphen hyphen as
830:24 - developer am i allowed to look at it it
830:27 - says no so i created this new user and
830:29 - it's not the admin user and so it
830:31 - doesn't have any access when we first
830:33 - created it so if we were to switch over
830:35 - to it like if we typed in cube ctl
830:38 - um
830:38 - to remember how we switch here
830:41 - oh it's config use context
830:44 - developer
830:48 - really got to learn how to type properly
830:51 - and so if we type in cube ctl get pods
830:55 - we have no access this is forbidden
830:57 - right you don't have any privileges uh
830:59 - you're not allowed to do this okay so
831:00 - what we need to do is create some role
831:02 - based access controls to allow them to
831:04 - have access to those pods so what we'll
831:06 - do is go back and switch to our back to
831:08 - our micro k8s
831:11 - let's type clear here and that's where
831:13 - we need to uh create ourselves a roll
831:15 - and a rule binding so what i'll do i'm
831:18 - just pulling up my example here and then
831:19 - what uh we'll do is type in roll rbac
831:22 - there's a role kubernetes
831:24 - and get some example code so we'll go to
831:27 - using rbac authorization we'll scroll on
831:30 - down and here is basically the same
831:31 - example that we want so i'll make a new
831:34 - one in our case folder here new file um
831:37 - role dot
831:39 - yaml
831:43 - we'll paste that on in there
831:44 - uh this one's called pod reader sure
831:46 - we'll leave it as is that's totally fine
831:48 - and then we need a
831:50 - um
831:52 - a role binding i don't know why they go
831:54 - like role in the role cluster this
831:55 - really should show you end to end but
831:57 - this is how they do it and so if we go
831:59 - down i'm just looking for one that looks
832:01 - like the one that we need
832:04 - these ones are all
832:06 - very silly
832:12 - roll
832:15 - binding i guess we'll use this one even
832:16 - though i really don't like it we'll have
832:18 - to adjust it where this is this one here
832:20 - as well this is the one i think we
832:21 - wanted role binding examples
832:23 - okay so we'll go back here we'll make a
832:24 - new file
832:27 - roll binding
832:28 - yaml
832:32 - okay and um i'm just going to double
832:34 - check because i might have modified this
832:35 - a bit yeah mine's a lot more easier to
832:38 - read so we'll just take out these
832:39 - comments here so that we can just see
832:41 - what we're doing i just don't want any
832:43 - of the stuff in so i can see what's
832:44 - going on just to make sure that it's
832:46 - right so the idea here is that uh we
832:48 - have a role binding kind and then we
832:50 - have our metadata
832:52 - uh read positive is fine the name space
832:54 - is fine so the subject the kind is going
832:56 - to be user the name is going to be
832:58 - developer because we called our
833:00 - developer
833:01 - user
833:03 - and so that's the subject now we need to
833:05 - um
833:07 - have the role reference and so i think
833:09 - it's called pod readers if we go back to
833:10 - the one
833:12 - looks good to me
833:14 - and then if we go back uh we'll just yep
833:16 - that's fine we'll save it make sure that
833:17 - little dot is cleared and so that should
833:19 - be good so we are good to
833:22 - set these up so we'll say cube ctl
833:25 - apply hyphen f roll.yaml i wonder if we
833:28 - can do multiple files like this i don't
833:29 - ever try
833:31 - does that work
833:33 - nope
833:35 - that i typed it wrong so i'll just hit
833:36 - enter
833:38 - oh you know what
833:39 - we probably can do it let me just try
833:41 - this
833:43 - let me just try this and see if this
833:44 - works
833:49 - all right well if there is a way of
833:50 - doing multiple ones i have no idea how
833:52 - to do it
833:53 - and then we'll just say rolebinding.yaml
833:57 - there we go
833:58 - and let's go take a look at what those
833:59 - look like so we say get
834:01 - cube ctl get roll
834:04 - and we'll say describe the role
834:08 - okay so get watch list pods all good
834:10 - there and then we'll say
834:12 - get roll binding
834:16 - okay read pods
834:17 - pod reader and we'll say describe it
834:21 - oops
834:24 - describe
834:25 - user developer that's who's allowed to
834:27 - use this role
834:28 - um
834:29 - so
834:30 - now let's go back up remember that uh
834:33 - auth command we had
834:35 - here it is as developer can they use it
834:37 - yes okay so now what we'll do is we'll
834:40 - switch context so we'll say cube ctl
834:43 - um
834:44 - i already forgot what the command is it
834:46 - is
834:51 - config
834:53 - use context
834:55 - developer
834:58 - i have to type
835:00 - use
835:01 - and we'll say cube ctl
835:03 - get pods
835:06 - cube ctl get pods you got a spell right
835:08 - for it to work
835:09 - and then we'll try svc
835:13 - oh
835:14 - our juice app is running again huh we
835:16 - had destroyed the deploy
835:18 - prior so it shouldn't be running but i
835:19 - guess it's still running whatever
835:21 - anyway um so notice that we get a denied
835:23 - access for services but we can get it
835:25 - for pods so it is working as expected
835:27 - i'm going to just switch back to micro
835:29 - case so we're not confused and that's
835:32 - all i wanted you to learn there are uh
835:34 - role based clusters and they're really a
835:36 - pain to set up and it's just really time
835:38 - consuming but if we go if you really
835:40 - want to know how i know
835:43 - there's a few tutorials if we say rbac
835:46 - cluster roll 100 days of kubernetes i
835:49 - know that um
835:53 - there is a good example there i'm just
835:55 - going to pull it up here if you're if
835:56 - you want to look at it yourself if you
835:58 - are on the example platform all these
836:00 - links are there for you just so you know
836:02 - but let me take a look here
836:05 - i'm trying to find the example
836:10 - um can't really find it but let's say
836:13 - rbac um
836:15 - micro k8s
836:18 - tutorial
836:26 - roll
836:33 - ah yes
836:35 - so
836:37 - anis i know i don't know how to
836:39 - pronounce her name i know her she's
836:40 - super nice she's on twitter uh and so
836:42 - she goes here and
836:44 - i think she's just created a role in
836:45 - cluster roles she does a cluster role
836:47 - one and so if we go through here
836:50 - um that's a role so they create a role
836:53 - i guess i guess he does both
836:55 - but let's just take a look at cluster
836:56 - rule here so for cluster role you have
836:58 - to create a service count um you'll have
837:00 - to set up verbs right
837:03 - so what resources
837:06 - uh oh yeah this is where the sticky part
837:08 - was so in order to um
837:10 - i guess it's not hard but she was using
837:13 - this third-party library and i just did
837:15 - not want to use it because then you have
837:16 - to install crew and do that and so
837:19 - probably there's a way i could figure it
837:20 - out but you know honestly we don't
837:21 - really need to learn cluster roles it's
837:23 - not that big of a deal
837:24 - they're very similar to roles they're
837:26 - just not names based right so you won't
837:28 - see a namespace in them and they're for
837:30 - workloads and not necessarily or sorry
837:33 - like they're scoped at the cluster
837:34 - cluster rules what was interesting was
837:36 - service account because service account
837:37 - isn't a user it is a
837:40 - like for workloads and stuff like that
837:42 - but i figured just doing a role and
837:44 - stuff that is fine for kcna and just
837:46 - conceptually understanding other ones is
837:47 - good enough
837:48 - so we'll do
837:50 - is close off these other tabs close this
837:52 - off here
837:54 - this one and this one and that's all i
837:55 - wanted to show you for rbac okay
837:58 - [Music]
838:02 - hey this is andrew brown from exam pro
838:04 - and this follow along we're just going
838:05 - to be looking at a bunch of
838:08 - random
838:09 - cube ctl commands that we just didn't
838:11 - cover through any of the other follow
838:13 - alongs but could appear on the exam or
838:15 - just help you contextualize a few things
838:17 - so i'm going to launch my micro k8
838:19 - environment and as that is spinning up
838:21 - what i'm going to do is make my way over
838:23 - to google on a new tab we're gonna type
838:25 - in cube ctl commands and you know this
838:28 - is the one i usually point you to but i
838:30 - just also noticed if you click even if
838:32 - it's the cheat sheet right here left
838:33 - hand side you go to cube ctl commands
838:36 - and uh that's another way to get to it
838:37 - so there's just some things like api
838:39 - resource cluster management we might
838:42 - want to just take a quick peek at um i
838:45 - don't even look at top what's that the
838:46 - top commands lets you see resource
838:48 - consumption for nodes and or
838:50 - pods cool so maybe we'll just play
838:51 - around with a few of these just to see
838:53 - what we can see
838:54 - so i'm going to type in cube ctl
838:58 - get pods to see what we have here
839:01 - just to see if anything is running yet
839:03 - um
839:04 - and we can always just type in micro k8s
839:07 - as well
839:09 - i'm not sure if we have a permissions ah
839:11 - there we go so we are fine there um i
839:13 - thought we might have a permissions
839:14 - issue there but i'm actually surprised
839:16 - on the server that i don't have um
839:19 - the cube ctl installed because we are on
839:21 - ubuntu so
839:24 - um i can't remember what we did for that
839:25 - i think was something with the config
839:27 - file but
839:28 - um i think it was like cube ctl
839:31 - um config and then we would just do this
839:34 - dot cube
839:36 - uh config
839:38 - oh sorry micro cr8s
839:41 - right
839:42 - did not mean to open up that tab
839:48 - okay it's all just having clear and if i
839:49 - type in cube ctl get pods it's gonna
839:51 - save me some trouble oh cue get pods can
839:53 - i do that no so i see a lot of people
839:55 - alias the k command i'm not sure how
839:57 - that gets done but um
839:59 - let's go back over to here and just look
840:01 - at some of them here so we have cube
840:03 - ctl top
840:04 - and that might be fun to try so let's go
840:06 - give that a go and see what that does
840:10 - um qctl top
840:14 - so this top command allows you to use to
840:16 - see resources consumption on nodes so we
840:19 - need to specify something maybe like
840:20 - node
840:23 - um is unavailable to handle requests
840:25 - let's try pod
840:28 - okay so that didn't work but uh maybe
840:31 - just as a test we can do micro k8s
840:34 - there
840:35 - okay but we are we have pods right
840:38 - all right so i'm not sure as the reason
840:40 - why that's not working
840:41 - but i'm not too worried about it because
840:43 - it's not on the exam but i just saw it
840:45 - there so i just wanted to give it a go
840:47 - api versions is definitely something we
840:48 - might want to try out so we'll just type
840:50 - in clear cube ctl api versions
840:55 - versions
840:57 - and so here it's telling us all the api
841:00 - versions so if we go back over here
841:01 - we'll just give it a read print the
841:03 - support api versions on the server in
841:05 - the form of groups and versions so i
841:08 - guess the idea is that
841:09 - all of these things are apis so
841:12 - what i mean by that is like if we go
841:14 - create a file any kind of file like a
841:16 - persistent volume if you go to the top
841:18 - uh maybe that's not the best example but
841:20 - the idea is you have a group and then
841:22 - you have a version and so if any of the
841:24 - syntax changes because the functionality
841:26 - changes that might be version two that
841:27 - might be version three or down below
841:30 - like c auto scaling we have one two
841:33 - v two beta one v two beta two and so by
841:36 - copying this and putting this up here
841:38 - into the api version will change the
841:41 - nature of these files
841:43 - all right and i don't know if like
841:46 - it's you get what you get i would
841:47 - imagine that you install a version of
841:49 - kubernetes and then that's going to
841:51 - support different ones so as new
841:53 - versions of kubernetes come out i
841:55 - imagine they might drop older versions
841:57 - or things like that or maybe the betas
841:59 - vanish i really don't know um but i mean
842:01 - generally that's the idea behind the api
842:03 - versions let's go back over to cube ctl
842:06 - reference here
842:07 - cluster info might be one that we might
842:09 - want to run here so go ahead and just
842:11 - type in clear at the bottom and then
842:13 - we'll paste that on in there and hit
842:14 - enter
842:15 - so it says the control plane is running
842:18 - uh nothing super exciting
842:20 - now this is micro cave so i'm not sure
842:22 - if we would get
842:24 - more detailed information
842:26 - if we're doing a managed provider if we
842:27 - self-deployed versus a lightweight
842:29 - distribution like microkates but
842:31 - we get some information there which is
842:32 - nice
842:33 - cordon drain those are really for
842:36 - managing nodes or spinning them
842:38 - spinning them down uncord on as well
842:40 - taint uh as well so these are we're not
842:43 - going to be touching at all
842:45 - this would be something you would do in
842:46 - the cka the administrator
842:48 - then we have other ones down below here
842:50 - i don't even know what alpha is these
842:51 - commands correspond to alpha features oh
842:54 - that sounds like fun let's see what
842:56 - alpha features we have so events is
842:58 - experimental so i imagine that maybe
843:01 - that can be turned on
843:02 - um so yeah down below here so cube cube
843:05 - ctl alpha events might turn it on i
843:08 - suppose or something like that or maybe
843:10 - you just have to put alpha in order to
843:12 - access the events that's probably what
843:13 - it is right
843:15 - um then there's api resources so print
843:17 - the supported api resources on the
843:19 - server so we'll go ahead and copy this
843:21 - we'll type in clear
843:23 - and we'll hit enter
843:25 - and so if we just scroll up here
843:28 - and just expand it a bit not too
843:30 - different from the
843:31 - api versions per se but like
843:34 - here it's saying what is the name of the
843:36 - api resource so like bindings events
843:38 - pods things like that what is its short
843:40 - name what version is this one currently
843:42 - on is it namespaced
843:45 - and what kind is it right so actually uh
843:49 - saying kind in terms of a component or
843:51 - stuff and i guess this would be useful
843:52 - if you wanted to know
843:54 - what kubernetes components are namespace
843:56 - and not right because we said that there
843:58 - are certain components in our namespace
844:00 - section that you can put in any states
844:02 - that you can't put in a namespace and
844:03 - this may also affect whether you use a
844:05 - cluster role or a role for particular
844:07 - things
844:08 - because i would think that if you have a
844:10 - role and then you have a component that
844:12 - isn't that is not allowed to be
844:13 - namespace you probably need to have to
844:15 - use a cluster role uh we don't really
844:17 - get that deep into that kind of stuff
844:20 - with our back or roll based access
844:21 - controls and that kind of level detail
844:23 - because again the kcna level
844:25 - we're not too worried about that
844:27 - information maybe that's the csk or
844:29 - ckad or the cka
844:33 - um config we definitely used and there's
844:35 - a lot of options under there explained
844:38 - uh we have not used so
844:39 - ctl explained uh the command describes
844:42 - the fields associated with each
844:44 - supported resource so that might be fun
844:46 - let's try pods over here
844:51 - enter
844:53 - and we typed in that here so a pod is a
844:56 - collection of containers that run on a
844:57 - host this resource is created by clients
845:00 - and schedules api version kind metadata
845:03 - oh so it actually explains all the
845:05 - fields within
845:06 - um within pods so that's kind of useful
845:09 - and maybe documentation that might not
845:10 - show up actually on the page but it's
845:12 - here in the commands
845:15 - so that's nice but really all i really
845:17 - wanted to do was show you api resources
845:19 - and api versions because i definitely
845:22 - definitely know that those will appear
845:24 - on the exam and you need to know uh what
845:27 - they're there for okay so api resources
845:29 - show you all the possible supported
845:30 - resources uh and then api versions is
845:33 - all the supported api versions okay