00:00 - in many software job interviews you will
00:02 - be asked to solve coding challenges
00:04 - based on algorithms and data structures
00:07 - one type of algorithm that can be used
00:09 - to solve these challenges is the greedy
00:12 - algorithm greedy algorithms are used to
00:15 - solve optimization problems and they
00:17 - select the best result at each iteration
00:20 - in this course tanishq uses animations
00:22 - and diagrams to help you understand how
00:25 - to solve coding challenges using greedy
00:27 - algorithms let's say that you find
00:29 - yourself
00:30 - on a square on a green square in a 2d
00:33 - plane
00:34 - there's a voice that comes from above
00:37 - your objective is to maximize the goal
00:40 - because the goal you can get is the gold
00:43 - you keep
00:45 - all right all of this is pretty weird uh
00:47 - why are you on a 2d green square and
00:49 - what is this voice but now the voice
00:51 - continues and says that hey there are
00:54 - three rules that you need to keep in
00:55 - mind and if you follow these rules i'll
00:57 - let you keep the gold
01:00 - alright first rule you can move in any
01:02 - direction up down left or right
01:06 - second
01:06 - once a path is taken there is no going
01:09 - back
01:10 - third the game ends when no more steps
01:13 - can be taken
01:15 - all right so now you're pretty excited
01:16 - you have the rules in hand and you have
01:18 - the objective of maximizing the amount
01:21 - of gold coins you can get
01:23 - of course you're in a 2d plane you
01:24 - should get as many gold points as
01:26 - possible
01:27 - so
01:28 - what you do is you go ahead and follow
01:29 - the first rule i say that now i want to
01:32 - look in all the four directions so we'll
01:34 - go ahead and look in all the four
01:35 - directions and we see this
01:37 - we see that on the bottom square if we
01:40 - reach and if we go to the bottom square
01:42 - we'll get two gold coins on the left we
01:44 - have one and on the right we have three
01:47 - the top sell is a much more interesting
01:49 - cell saying that you will get one gold
01:51 - coin at this point of time you will get
01:53 - one gold coin when you reach this square
01:55 - and this square happens to be a dead end
01:58 - marked by the bold lines
02:01 - all right so now you'll ask the question
02:02 - hey well since there is only
02:05 - one way i can go you know once a path is
02:07 - taken there is no going back
02:09 - let me just go ahead and select three
02:10 - you know i want to maximize the amount
02:12 - of gold i can get and it looks like well
02:14 - perhaps three might lead me to the
02:16 - answer
02:17 - so what you'll do is you'll go ahead and
02:19 - select three and continue on and on your
02:22 - journey and at the end you get three
02:24 - plus one plus seven plus two plus five
02:26 - total gold coins hey looks like a
02:28 - successful run
02:30 - but is it actually the most optimal well
02:32 - the voice is kind of disappointed right
02:34 - now so that makes sense that maybe you
02:36 - have the optimal answer and you see the
02:38 - rest of the grid and hey
02:40 - we indeed found the optimal answer we
02:42 - were able to maximize the good for this
02:44 - particular grid
02:46 - now obviously the voice is kind of
02:47 - disappointed and
02:49 - it does not like this so what it does is
02:51 - takes you and throws you in another grid
02:54 - now we'll do the same computation again
02:57 - we'll go ahead and look in all the four
02:58 - directions and we see it's a similar
03:00 - kind of setup
03:02 - mostly because the voice was lazy to
03:03 - change these four squares
03:05 - but now you'll again realize that hey
03:08 - last time i selected greedily
03:11 - i selected the biggest square that i got
03:13 - i selected the biggest gold coin value
03:15 - giving cell and i just followed the path
03:18 - so let me just go ahead and do that
03:19 - again let me just greedy pick the
03:22 - highest value and hey maybe i get
03:24 - optimal answer once again
03:25 - and so you go on and on and on but hey
03:28 - this time the voice was smarter
03:30 - it only gave you zeros on this path
03:33 - and now it pulls you back again and says
03:35 - hey you know what you missed
03:37 - if you went to the square at 2 if you
03:40 - went bottom
03:42 - then you would have gotten 2 plus 9
03:44 - which is much greater than three
03:46 - this is an example of the case where
03:49 - thinking in a greedy approach will not
03:51 - work
03:52 - and so you might ask the question hey it
03:53 - worked for the first one but if it is
03:56 - not going to work optimally for all the
03:59 - possible cases
04:00 - why do we even need to think about
04:01 - greedy solutions why do we need to worry
04:04 - about greedy solutions at all
04:06 - well there are two big reasons we should
04:07 - worry about it first it is asked in
04:10 - interviews and second is it general
04:12 - algorithm that you should know because
04:15 - here's the thing
04:16 - life gets complicated
04:18 - and perhaps when you explore every
04:20 - single permutation combination you
04:23 - realize that hey
04:24 - this was too much effort and there might
04:27 - be some problems where you can't even
04:28 - explore every single permutation in
04:30 - combination
04:32 - and greedy in that case comes as a
04:34 - savior
04:35 - because using a gradia algorithm
04:37 - guarantees that you will get a solution
04:39 - it might be the optimal one it might not
04:42 - be the optimal one but at least you'll
04:44 - have a solution
04:46 - all right so what we are going to do is
04:48 - over the next 10 videos that i've made
04:51 - we are going to look at 10 different
04:53 - interview problems all from interview
04:55 - bit and we're going to slowly build up
04:57 - our intuitions on how to proceed with
04:59 - greedy algorithm problems hello
05:02 - everybody and welcome let's talk about
05:05 - the problem bulbs on interview bit
05:08 - we're given n bulbs in total which are
05:10 - either on or off represented by 1 and 0
05:13 - respectively
05:15 - the condition mentioned in the question
05:17 - says that turning on the ith bulb causes
05:19 - all of the remaining bulbs on the right
05:21 - hand side of it to flip
05:23 - which means that all of the bulbs on the
05:25 - right hand side which were one will
05:26 - become zeros and vice versa
05:30 - the goal of this problem is to find the
05:32 - minimum number of switches to turn all
05:34 - of the bulbs on
05:35 - the constraints mention that the n the
05:37 - number of bulbs can be between 1 and 10
05:40 - to the power 5
05:41 - and a of i can be 0 or 1 representing
05:44 - that the bulb or the bit we are looking
05:47 - at currently can either be 0 or 1.
05:50 - all right let's take a test case and try
05:52 - to work out a solution
05:54 - in the case of one zero one this is the
05:56 - test case we're gonna start off with we
05:58 - will also set the initial cost to zero
06:01 - we'll say that uh this cost is going to
06:03 - keep a track of the number of flips or
06:05 - the number of switches that we require
06:07 - to convert everything to once
06:10 - on the bottom right hand side is the
06:11 - logic we are going to use which is
06:13 - already mentioned in the question
06:15 - the question says that if the bulb is on
06:17 - well that's great we'll just continue on
06:20 - but if the bulb is zero that is if the
06:22 - current bit we are looking at is zero
06:25 - then well we have to increase the cost
06:27 - by one and flip everything on the right
06:29 - hand side of it
06:30 - all right so let's try to simulate and
06:33 - see what happens
06:34 - so this is the first element that we get
06:36 - the first bit is one so we'll continue
06:39 - on
06:40 - now in this case we get the bit as zero
06:42 - what does this mean
06:44 - this means that we have to increase the
06:45 - cost by one and we have to flip all of
06:48 - the bits on the right hand side of it
06:51 - including the current one so the zero
06:53 - becomes one and the one on the right
06:55 - hand side of it becomes a zero
06:57 - pretty simple right
06:58 - so now this is the area that we are
07:00 - currently working with
07:02 - what about this third element now
07:04 - well since this is a zero we have to go
07:06 - to the else condition
07:08 - the else condition says that the cost
07:10 - should be increased by one
07:11 - for converting this zero to a one
07:14 - and then we'll flip all of the bits on
07:16 - the right hand side of it since there
07:18 - are none we don't have to worry about it
07:19 - anymore
07:20 - and we have the final array as one one
07:23 - one
07:23 - at this point we note the cost which is
07:25 - equal to two and we'll return this as
07:28 - the final answer
07:30 - now let's try to analyze the time and
07:33 - space complexity of the solution
07:35 - the space complexity is order of 1 since
07:38 - we only ever store this cost variable on
07:40 - the top right
07:42 - however the time complexity is a bigger
07:44 - issue
07:45 - it's order of n square
07:47 - see because for every single bit as
07:49 - we're iterating over the array we'll
07:50 - take order of n time
07:52 - and for every single bit we might have
07:55 - to do another special operation of
07:57 - converting everything on the right hand
07:58 - side of it to
08:00 - be 0 or 1 basically flipping that around
08:03 - so that's order of n time to iterate
08:05 - over the bits and order of end time
08:07 - again if the bit is a 0.
08:10 - so that's order of n square time worst
08:12 - case
08:13 - now this was the naive solution and we
08:16 - were able to
08:17 - write down the knife solution just by
08:19 - using what was given in the question
08:21 - however can we optimize this
08:24 - the optimization of the solution depends
08:27 - on one single logic there's just one
08:29 - thing that you need to know to optimize
08:31 - this relation
08:33 - all right let's take a bigger case and
08:35 - try to work out and simulate what is
08:37 - going to happen
08:38 - in this case we have 0 1 0 1 1 0 1 1.
08:43 - we see that the first bit is 0 so what
08:45 - do we do
08:46 - remember we went in the else case
08:49 - we encounter a certain cost in this case
08:51 - represented by the arrow
08:52 - and because of this cost we were able to
08:54 - convert this zero to a one and we have
08:56 - to flip everything on the right hand
08:58 - side of it so the one becomes zero and
09:00 - the zeros become one so we have one zero
09:03 - one double zero one double zero
09:06 - now in this case we encounter a 0 again
09:09 - well that's kind of a painful thing to
09:10 - do as we already noted the time
09:12 - complexity is out of n squared
09:14 - so since we have the 0 let's go ahead
09:17 - and convert this 0 to a 1 encounter a
09:19 - cost of 1
09:20 - and convert everything on the right hand
09:22 - side of it
09:23 - to be flipped so the ones become zeros
09:26 - and the zeros become once again
09:29 - now there's something going on there's
09:31 - something very interesting in this slide
09:33 - i want you to pause and ponder what's
09:35 - going on there's one small little detail
09:37 - that you have to figure out
09:40 - all right
09:41 - if you place both of these side by side
09:43 - you'll realize that both of these 0 1 0
09:47 - 1 1 0 1 1 and 1 1 0 1 1 0 1 1
09:52 - have this yellow part of the string
09:54 - repeated
09:55 - both of them have this yellow part of
09:57 - the array repeated
09:59 - now what does that mean
10:02 - well this means that if you do two flips
10:05 - represented by these two blue arrows
10:06 - that we show
10:08 - if you do two flips everything on the
10:10 - right hand side of it becomes flipped by
10:12 - once and then gets flipped again
10:14 - in essence
10:16 - they get reverted back to their original
10:18 - states
10:20 - think about this this makes sense
10:22 - mathematically as well
10:24 - say that we are looking at an array and
10:26 - we are looking at a random bit in the
10:28 - array somewhere in the middle
10:29 - at this point let's say that the cost is
10:31 - some cost variable that we have stored
10:33 - over here represented in bread
10:36 - now we'll ask the question hey is the
10:38 - cost even or odd
10:41 - is the number of flips we have done even
10:43 - or odd
10:44 - because if we have done even number of
10:46 - flips the bit remains as is the bits get
10:50 - reverted back to its original states so
10:52 - the b becomes b it remains as is
10:56 - however if the cost is ordered we have
10:58 - to flip the bid that's because it has
11:00 - been flipped an odd number of times so 1
11:03 - becomes 0 and then becomes 1 and then
11:05 - perhaps becomes 0 again
11:08 - so if the cost is odd
11:10 - we have to flip the bit
11:13 - now then what well
11:15 - if we can figure out this part well
11:17 - we can just write down what we did
11:19 - before if the current bit we are looking
11:21 - at is one now we'll just continue else
11:24 - will increase the cost by one
11:27 - all right let's try to code this up
11:30 - so here's the code written
11:32 - and we're of course going to start off
11:34 - with the cost equals to zero and we'll
11:36 - return the cost at the end
11:38 - now we'll see for every single bit in
11:40 - the array we'll iterate over all the
11:41 - bits in the rf we'll see if the cost
11:44 - modulo 2 is equal to 0 that is if this
11:47 - current bit has been flipped an even
11:49 - number of times well b equals to b
11:52 - b remains as is
11:54 - else b equals to not b that is if the
11:58 - bit was 1 it becomes 0 and if it was 0
12:00 - it becomes 1.
12:03 - and now we can
12:04 - again ask the question as before we can
12:06 - say that if this current flipped bit
12:09 - is equal to one
12:10 - then what
12:12 - well just continue as is
12:15 - and in the else condition we'll increase
12:17 - the cost by one
12:19 - and once we're done with this iteration
12:22 - we finally will have the cost
12:24 - so you can realize that this takes order
12:26 - of n time complexity where n is the
12:27 - number of bulbs
12:29 - and it still takes order of one space
12:31 - since we are not storing anything other
12:32 - than the cost variable
12:35 - all right so this is it for the solution
12:37 - to the problem bulbs on interval
12:40 - hello everybody and welcome by let's
12:43 - talk about the problem highest product
12:45 - on interview build
12:47 - we are given an array of n integers and
12:50 - the goal of this problem is to find the
12:52 - highest product we can get by
12:54 - multiplying three elements we can pick
12:56 - any three elements from the array
12:59 - the constraints mentioned that n the
13:01 - number of elements in the array can be
13:02 - between 3 and 5 times 10 to the power 5
13:06 - let's take a couple of examples to
13:08 - understand this better
13:10 - when the input given to us is 1 comma 2
13:13 - comma 3 comma 4 that is we have 4
13:15 - elements in the array the output we get
13:17 - is 24
13:18 - and that's because we can multiply 2
13:20 - times 3 times 4 and this is the highest
13:23 - possible product we can get which is 24.
13:27 - now when the input is 0 comma minus 1
13:29 - comma 10 comma 7 comma 5
13:31 - we multiply 5 7 and 10 together to get
13:34 - 350 which is the highest possible value
13:37 - we can get and so we return 350 as the
13:39 - answer
13:41 - now what is one thing that is
13:43 - immediately very clear from these
13:45 - examples
13:47 - the first thing we realize is that we
13:49 - can sort the array and we can pick the
13:51 - top three elements
13:54 - in fact we can write this down and we'll
13:56 - say that you know what one of the
13:58 - observations in solving this question is
14:00 - that we have to take the highest three
14:02 - elements multiply them together and
14:03 - return them at the end
14:06 - now whenever you have these kind of
14:08 - hypotheses whenever you have these ideas
14:10 - it is always a good idea to test them
14:13 - out
14:14 - you have something in mind you have a
14:16 - possible solution in mind try your best
14:19 - to find a test case where this might not
14:21 - work
14:22 - all right we'll take a couple of more
14:24 - test cases and see how this is playing
14:26 - out
14:26 - first we'll actually test this if this
14:29 - actually works so let's say that the
14:31 - case is minus five minus two one zero
14:34 - zero three four five
14:36 - in this case the logic works perfectly
14:38 - because we take the highest three
14:40 - elements three four five multiply them
14:42 - together and get 60 as the answer
14:45 - right so this makes sense our logic is
14:48 - sort of making sense for all of these
14:49 - three test cases
14:51 - so we'll mark this as green and we'll
14:53 - take another test cases as i mentioned
14:55 - it is always a good idea to find test
14:57 - cases for which for which this logic
15:00 - might not work
15:02 - and in this case is the test case minus
15:05 - 5 minus 2 minus 1 0 0 1 1 5.
15:09 - again the array is sorted just for the
15:11 - sake of convenience which is something
15:13 - we'll also do in the chord part but if
15:16 - we multiply one one and five together
15:18 - which are the highest three elements we
15:20 - get the answer as five
15:22 - but this is incorrect
15:25 - and this is because there's something
15:26 - else going on
15:28 - okay
15:30 - now we now that we have this array what
15:32 - is actually the answer
15:34 - well the answer
15:36 - is minus 5 times -2 times 5 giving us
15:40 - 50.
15:42 - and this is the second observation that
15:44 - we need to make
15:46 - recall how when you multiply two
15:48 - negative numbers it becomes a positive
15:50 - number again
15:52 - which means that we have two possible
15:55 - cases that we have to consider
15:57 - push we have to take the highest three
15:59 - elements that's for sure that something
16:01 - we have established is correct for some
16:03 - test cases and for the remaining test
16:05 - cases we have to consider the case where
16:08 - there are two negative values and one
16:09 - positive value as shown in the second
16:12 - test case over here
16:13 - now this second test case gets 50 as the
16:16 - output which is indeed the correct
16:18 - answer
16:19 - all right uh instead of saying two
16:21 - negative and one positive since we are
16:23 - already sorting the array we can say
16:25 - that you know what
16:26 - consider the lowest two and the highest
16:28 - one
16:29 - so either we take the first uh the
16:31 - highest three elements on the right hand
16:33 - side or we take the lowest two on the
16:35 - left and the highest one on the right
16:37 - all right now let's actually talk about
16:39 - the code for the solution
16:41 - here is the code and
16:43 - as i mentioned the first step is to sort
16:45 - the array so a equals to sorted of a
16:48 - which will return me a sorted array
16:50 - and this will be sorted in ascending
16:52 - order
16:53 - so on the line seven i have height three
16:55 - equals to a of minus one times minus two
16:57 - times minus three basically saying that
16:59 - we're going to pick the highest three
17:01 - elements
17:02 - and then this is the second case that i
17:04 - mentioned we will pick the
17:05 - two lowest elements which is a of 0 and
17:08 - a of 1
17:09 - and we multiply it with the high one so
17:12 - which will multiply it with the highest
17:13 - element on the right hand side of the
17:15 - array
17:16 - now the answer can be any of those cases
17:19 - and so we'll simply return the max of
17:21 - high three
17:22 - and load to high one
17:24 - and that is really it for the code of
17:26 - the solution we can go ahead and submit
17:28 - this
17:29 - and this gets accepted
17:31 - all right so this is it for the solution
17:34 - to the problem highest product hello
17:37 - everybody and welcome back let's talk
17:40 - about the problem disjoint intervals
17:43 - we're given a list of intervals each
17:45 - represented by the start and the end
17:47 - times
17:48 - and the goal of this problem is to find
17:49 - the length of the maximal set of
17:52 - mutually disjointed intervals
17:54 - what does this mean
17:56 - let's take an example to understand this
17:57 - better let's say that the input given to
18:00 - us is 1 comma 2 2 comma 10 and 4 comma
18:03 - 6. so there are three intervals given to
18:05 - us and we have to find a particular
18:07 - permutation and combination of all of
18:09 - them such that we can select
18:11 - the mutually disjoint intervals and we
18:13 - can create the maximal possible set of
18:15 - them
18:16 - the answer in this case comes out too
18:18 - because we're going to select the
18:19 - intervals 1 comma 2 and 4 comma 6
18:22 - leaving out 2 comma 10.
18:24 - this is the best possible case that we
18:26 - can have
18:28 - now this might look a bit bit cryptic so
18:31 - let's go ahead and visualize this so
18:33 - this is the visualization i've created
18:35 - and uh by the way these do take a lot of
18:37 - time to create so if you like this video
18:39 - be sure to give it a thumbs up if you
18:41 - like the effort i'm putting it
18:43 - let me know in the comment section down
18:44 - below anyways let's go ahead and plot
18:47 - out the uh
18:48 - intervals which is 1 comma 2 2 comma 10
18:51 - and 4 comma 6
18:53 - and now we're going to start off with
18:55 - some simulation we're gonna say okay you
18:57 - know what let's go ahead and select the
18:58 - interval one comma two so this is what
19:00 - happens when we select the interval one
19:02 - comma two
19:03 - and now we ask the question hey can we
19:05 - select the interval two comma ten as
19:06 - well
19:08 - and the answer is no in this case
19:10 - because in 1 comma 2 and 2 comma 10 we
19:12 - can see that 2 is being repeated
19:14 - so the point number 2 is going to create
19:17 - an intersection between these two
19:18 - intervals which we do not want
19:21 - right so what we'll say instead is that
19:23 - you know what
19:25 - let's go ahead and skip over 2 comma 10
19:26 - and let's see what will happen if we
19:28 - include 4 gamma 6 and straight
19:30 - so if you look at both of them these are
19:32 - indeed mutually disjoint intervals and
19:35 - we can get the final answer as 2 for
19:37 - this particular test case
19:39 - now we did leave out 2 comma 10 so let's
19:41 - go ahead and see what will happen in a
19:43 - case when we try to include 2 comma 10.
19:46 - in the case we include 2 comma 10 we
19:48 - have 1 comma 2 and 4 comma 6 both left
19:51 - out
19:52 - and that's because in 2 comma 10 1 comma
19:54 - 2 intersects in the two position and 4
19:57 - comma 6 is basically embedded into 2
19:59 - comma 10 so
20:00 - when we select 2 comma 10 we cannot
20:03 - select anything else
20:05 - right so the final answers for both of
20:06 - them are two and one
20:09 - so in this particular test case we
20:11 - explored two different possibilities and
20:12 - we got the best possible answer as two
20:16 - now
20:17 - this what we have done here is twofold
20:19 - the first thing we've done by default is
20:22 - sort these index we've sorted these
20:25 - intervals
20:28 - now this sorting is something that we
20:29 - commonly do in these kind of interval
20:31 - questions so that's one thing that you
20:32 - can keep in mind for later on as well
20:34 - now the sorting thing is also very
20:36 - important for this question and we'll
20:38 - come back to it later
20:40 - but now the second point is that we have
20:42 - in a way made some sort of decision
20:45 - right this question can be boiled down
20:47 - to a dynamic programming problem in a
20:49 - way because we are going to make
20:51 - decisions
20:52 - of whether we want to include 1 comma 2
20:54 - or not whether we want to include 2
20:56 - comma 10 or not or whether we want to
20:58 - include 4 comma 6.
21:00 - any time we are making these sort of
21:01 - decisions and we want to look into the
21:04 - future we want to look into the past and
21:05 - we want to figure out okay what's going
21:07 - on this current point of time
21:08 - whenever we want to make decisions
21:11 - we're always going to go for dynamic
21:13 - programming so dynamic programming is
21:15 - going to give you one correct solution
21:17 - is one particular approach that is going
21:19 - to give you a correct solution
21:21 - but that might be a bit too complicated
21:23 - and maybe there's something else going
21:25 - on
21:26 - and before jumping into any one approach
21:28 - it's always a good idea to look at more
21:30 - test cases and see if there is another
21:32 - sneaky observation somewhere hidden
21:34 - and so let's go ahead and try to find
21:36 - out what's going on
21:39 - so i've written another test case which
21:41 - is one of the test cases mentioned in
21:43 - the question itself on interview bit and
21:45 - the test case is 1 comma 4 2 3 4 comma 6
21:48 - and 8 comma 9 and i've plotted these out
21:51 - again because there are two
21:52 - possibilities that will consider
21:54 - and just a quick aside there can be test
21:56 - cases where there are multiple such
21:58 - possibilities but i've only mentioned
22:00 - two of them
22:01 - for this test case just for the sake of
22:03 - convenience
22:05 - all right so let's go ahead and say that
22:07 - i want to select the interval one comma
22:09 - four i make a decision to include the
22:11 - interval 1 comma 4 so the answer on the
22:14 - right hand side will become 1 in this
22:15 - case
22:16 - now can i select 2 comma 3
22:18 - i cannot because it intersects can i
22:20 - select 4 comma 6 again no because 1
22:23 - comma 4 and 4 comma 6 intersect at 4.
22:26 - can i select 8 comma 9
22:28 - yes i can so let's go ahead and include
22:30 - that and increase the answer count by 1.
22:34 - pretty good right
22:35 - so as soon as we selected 1 comma 4 we
22:38 - sort of created a chain of events that
22:40 - led us to the answer to
22:42 - so 1 comma 4 in a bit drove the solution
22:44 - and we got the answer as 2.
22:47 - now what if i don't select 1 comma 4 and
22:49 - what if i select 2 comma 3 instead so in
22:52 - the second possibility we are going to
22:54 - first select 2 comma 3. now can i
22:55 - include 1 comma 4 no because it will
22:58 - intersect can i include 4 comma 6
23:01 - yes i can because 2 comma 3 and 4 comma
23:03 - 6 do not have anything in common they do
23:06 - not have any intersections
23:08 - now can i go ahead and select 8 comma 9
23:11 - as well
23:12 - yes i can
23:13 - and so in this way by selecting 2 comma
23:16 - 3 we were able to get a better answer of
23:19 - 3.
23:20 - now if you also notice as i mentioned 1
23:23 - comma 4 as soon as we select the
23:25 - interval 1 comma 4 in the first
23:27 - possibility it sort of drives the rest
23:29 - of the decision making and the second
23:31 - case in the second possibility as soon
23:34 - as we select 2 comma 3 it drives the
23:36 - rest of the decision making
23:39 - now what is the difference between 1
23:41 - comma 4 and 2 comma 3
23:43 - maybe there's something inside of these
23:45 - both intervals that can lead us to the
23:47 - solution
23:48 - so maybe this interval is uh
23:51 - maybe 2 comma 3 gave us a better answer
23:53 - because it starts later you know uh 2 is
23:57 - greater than 1 so
23:58 - this interval is smaller this interval
24:01 - from 2 to 3 starts from 2 instead of 1
24:03 - so maybe starting later is a good idea
24:06 - maybe it's a good heuristic to get to a
24:08 - solution
24:09 - or maybe it's not
24:11 - maybe it's the ending times that really
24:12 - matter and because 2 comma 3 ends early
24:15 - we can say that you know what all the
24:18 - intervals that are going to end early
24:20 - are going to give us a better answer
24:22 - now at this point we can't really be
24:24 - sure i mean we just got the hypotheses
24:27 - now let's go ahead and test this out
24:28 - we'll take the first example that we saw
24:30 - the first very first example that we saw
24:32 - which is 1 comma 2 2 comma 10 and 4
24:34 - comma 6.
24:36 - now which of them is going to hold in
24:38 - this case
24:39 - feel free to pause and see
24:41 - whether starting earlier sorry whether
24:44 - starting later or ending earlier is a
24:47 - better heuristic to get to an answer
24:50 - if you notice 1 comma 2 starts earlier
24:54 - and 2 comma 10 starts later but
24:58 - we do not select 2 comma 10
25:01 - we do not select the interval which is
25:03 - starting later we select the interval 1
25:05 - comma 2 which is starting earlier which
25:08 - means the point 1 is wrong
25:09 - but what about ending early
25:11 - we can see that both the intervals 1
25:13 - comma 2 and 4 comma 6 are going to end
25:15 - earlier than the larger interval of 2
25:18 - comma 10. so it looks like the first
25:20 - point starting later
25:22 - is wrong and the second point ending
25:24 - earlier is correct
25:26 - and feel free to pause here and ponder
25:29 - of like what this heuristic means
25:32 - this makes a lot of sense because ending
25:34 - early
25:36 - gives us possibilities in the future to
25:38 - work well
25:39 - if an interval ends early right now
25:42 - we can say that it leaves a lot more
25:44 - space a lot more time for other
25:46 - intervals to join in the party
25:49 - but if an interval ends later on if it
25:51 - and if an interval drags on for a long
25:53 - time
25:54 - well then it might block other intervals
25:58 - to join the party which means that
26:00 - ending early is a very good heuristic
26:02 - for this question
26:03 - in fact it is the optimal heuristic now
26:06 - i've already explained the intuitions
26:08 - but there's a formal proof behind
26:11 - why ending early is going to give you
26:12 - the optimal solution now if you're
26:14 - interested in the formal proof is
26:16 - mentioned on my website links down below
26:18 - if you want to check it out
26:19 - but anyways we'll keep this ending early
26:22 - point in mind and we are going to go
26:24 - ahead and implement this logic
26:26 - so here's what i've done so the first
26:28 - thing we'll do is sort the intervals as
26:30 - i've already mentioned in the starting
26:32 - sorting the intervals is always a good
26:34 - idea and so we'll sort the intervals and
26:36 - the key in this case is the lambda
26:38 - function where we input x which is one
26:41 - particular interval and we're going to
26:42 - return x of 1 basically saying that sort
26:46 - these intervals by their ending
26:48 - positions because we want the intervals
26:50 - that end early to come forward first and
26:53 - we want the intervals which end later to
26:55 - go towards the end
26:57 - pretty simple so now what we're going to
26:59 - do is we're going to go ahead and start
27:01 - with the interval a of 0 we're going to
27:03 - interval which started
27:05 - and ended the earliest
27:08 - so a of 0 is the interval we're going to
27:09 - start off with we'll increase the count
27:11 - and we'll set the count to 1 because
27:12 - we're already going to select a of 0
27:15 - and we'll also set the previous of s and
27:17 - the previous of e in mind which is the
27:19 - previous of start and the previous of n
27:22 - this would make sense in a second
27:24 - now what we'll do is we'll iterate over
27:26 - the elements inside of the array we'll
27:28 - iterate over the intervals giving us the
27:30 - start and the end times of each interval
27:32 - and now i'm going to ask one very
27:34 - important question
27:35 - i'm going to ask the question hey is
27:37 - the start of this current interval i'm
27:39 - looking at is before
27:42 - the ending of the previous interval
27:45 - let me say it again
27:47 - does the current interval start
27:51 - before the previous interval ends
27:54 - that is is there a overlapping is there
27:57 - an intersection between these two
27:59 - intervals
28:00 - because if there is an intersection if
28:02 - this condition is true then go ahead and
28:03 - pass do nothing in this case we don't
28:06 - want to mess with the cases where there
28:07 - are intersections we want to avoid them
28:09 - instead
28:10 - and in the else condition we're going to
28:12 - go ahead and write you know what go
28:14 - ahead and increase account because
28:15 - clearly this current interval that we're
28:17 - looking at is not intersecting with the
28:19 - previous one so which means that we can
28:21 - include this current one right so we're
28:23 - going to go ahead and increase the count
28:25 - by one
28:26 - and we'll also say you know what
28:28 - go ahead and set the previous of f
28:30 - previous of s and the previous of e to
28:32 - be s comma a
28:34 - basically the previous intervals now
28:36 - become the current intervals times
28:38 - all right so this is it for the code of
28:40 - the solution now i know this is one of
28:43 - those questions where the greedy
28:44 - solution ends up giving you the optimal
28:46 - solution
28:47 - and the proof for that is mentioned in
28:49 - the written article on my website links
28:51 - down below
28:52 - in any case as i mentioned before these
28:56 - visualizations do take a lot of time to
28:58 - create so if you enjoy this video give
29:00 - it a thumbs up it lets me know that
29:02 - you find these visualizations helpful
29:04 - and meaningful and if you want more of
29:06 - this kind of content well go ahead and
29:08 - hit the subscribe button i'll see you
29:11 - very very soon
29:12 - hello everybody and welcome back
29:15 - let's talk about the problem largest
29:17 - permutation
29:19 - we're given an array of a random
29:21 - permutation of numbers from 1 to n
29:24 - that is we are given n total numbers
29:26 - ranging from 1 to n both inclusive
29:30 - and we are also given b which is the
29:32 - number of swaps in a that we can make so
29:34 - we can pick any two integers inside of
29:37 - the array a and we can make a swap
29:39 - between them
29:40 - and we can do this kind of swap b number
29:42 - of times
29:44 - the goal of this problem is to find the
29:46 - largest permutation possible
29:49 - let's take an example to understand this
29:50 - better
29:51 - let's say that the input is a equals to
29:54 - 1 3 2 and b equals to 1.
29:57 - now of 1 3 2 we can already see that you
30:00 - know n equals to 3 which is there are
30:02 - three total elements ranging from 1 to 3
30:04 - both inclusive and b equals to 1 which
30:06 - means that we can make one swap
30:09 - instead of this adding we can pick any
30:11 - two integers once and make a swap
30:13 - between them
30:15 - the biggest and the largest permutation
30:17 - possible in this case is 3 1 2
30:20 - and that is because we can swap one and
30:22 - three giving us three one two
30:24 - now you can imagine one three two as one
30:27 - thirty two and three one two as three
30:29 - hundred and twelve
30:30 - and so the output is the largest
30:33 - possible permutation we can get out
30:36 - feel free to write down more examples
30:38 - and try this out yourself
30:39 - you won't be able to find any better
30:41 - permutation than 3 1 2 when b equals to
30:44 - 1.
30:45 - all right
30:46 - now let's take a couple of more examples
30:48 - and try to build our intuitions and
30:50 - understanding from it
30:52 - let's say that the input argument to us
30:54 - is one two three four pretty simple
30:56 - permutation right
30:57 - and b is given as one which means that
30:59 - we can make one swap in total
31:03 - now let's actually write this array down
31:04 - once again and now i'm going to ask you
31:07 - the question
31:08 - what is the number that has the biggest
31:10 - bang for its spark
31:12 - what is the number that can change the
31:14 - most
31:14 - is the number four right what is the
31:17 - biggest number possible and so
31:19 - if we can bring four to the front
31:21 - that'll be better than bringing three to
31:23 - the front or two to the front right
31:25 - so what we'll do is we'll swap four and
31:28 - one
31:30 - and that's it and that's the answer for
31:32 - this test case pretty simple right
31:34 - we're basically trying to find the
31:36 - numbers which have the biggest bang for
31:37 - the buck
31:39 - all right let's take another example and
31:41 - we'll try to work out a solution again
31:44 - let's say that the input is three two
31:46 - four one five and b equals to three
31:49 - which means that in this case we can
31:50 - make total of three swaps
31:52 - now how do we proceed to a solution
31:55 - well what is the first thing that we
31:57 - should do we wanna maximize the number
31:59 - we want to make the number as big as
32:01 - possible
32:02 - so what we can do is
32:04 - uh we look at three two four one five
32:05 - and we realize that five is the biggest
32:07 - number five has the biggest demand for
32:09 - its buck right so we can take one b
32:12 - we can take one step
32:14 - and we can bring five to the front
32:16 - that does mean three goes at the end but
32:19 - you know what
32:20 - a number starting from five is going to
32:22 - be much greater than a number spreading
32:23 - from three
32:25 - so we'll make that swap happen
32:27 - okay what's the next step then
32:29 - well since we have three b's we can go
32:32 - for another row and try to look at this
32:34 - again now which number has the most bang
32:36 - for its bug
32:38 - since we already made a swap with five
32:40 - five is already in the best position
32:42 - possible
32:43 - how about 4
32:45 - now we can go to 4 and we can say that
32:47 - you know what go ahead and swap 4 with
32:49 - the element in its position so after 5
32:52 - we want to put 4
32:54 - and so this is exactly what we'll do
32:55 - we'll swap out five sorry we will swap
32:58 - out four bit two
33:00 - all right so
33:02 - now we'll do this
33:04 - and how about this we have five four two
33:07 - one three and now was the next element
33:09 - that we can swap this is the last swap
33:10 - that we can make
33:12 - which element do you think will give the
33:13 - most bang for its buck
33:15 - five and four are already in place
33:18 - and now we only have the largest element
33:20 - three that is remaining which is not in
33:22 - its place right
33:24 - so we'll go ahead and swap two and three
33:29 - and this is the solution for this test
33:32 - case
33:34 - now what is one thing that we observed
33:36 - right away what is the one thing that we
33:37 - realized and we were solving these
33:40 - problems
33:42 - what we realized was that we can
33:43 - greedily replace
33:45 - the higher elements so we can say that
33:47 - you know what if 5 is not in its place
33:50 - if 5 is not in the first position let's
33:52 - go ahead and make that happen let's go
33:54 - ahead and put 5 in the first place
33:57 - and then we'll ask the question we'll
33:58 - ask the same question for 4
34:01 - we'll say hey is 4 in the right place is
34:03 - 4 in the second place in this test case
34:06 - if 4 is not well go ahead and make that
34:08 - happen go ahead and make that swap
34:10 - and similarly for 3 and then 2 and then
34:12 - 1. now in case b equals 200 well we will
34:16 - have reached a point where we have 54321
34:18 - so that won't be very useful to us which
34:21 - means that you know the scary constraint
34:23 - given to us that b can be 10 to the
34:25 - power 9 is not really meaningful since
34:27 - the ra is only 10 to the power 6
34:29 - elements
34:30 - in any case this is the entire logic
34:32 - that we need to solve the problem
34:35 - we can greedily replace the higher
34:37 - elements
34:38 - so we'll make sure
34:40 - the highest element n is at the first
34:42 - position
34:43 - then the second highest element n minus
34:45 - 1 is at the second position and so on
34:47 - and so forth till we get to one
34:49 - all right let's talk about the code
34:52 - the first thing we'll do is set up a
34:54 - couple of variables that we'll need for
34:55 - related
34:56 - now we set i equals to zero since i is a
34:59 - pointer going from the start of the
35:00 - array to the end of the array
35:02 - we need i because
35:04 - in the case of three two four one five
35:07 - i wanted to look at the right hand side
35:09 - column
35:10 - note how five four and three are
35:12 - underlined these are the elements that
35:14 - have been swapped with the other
35:15 - elements on the right hand side which
35:16 - are 3 2 and 2 respectively
35:20 - now
35:21 - these elements are underlined because
35:22 - you can imagine that i is going from the
35:24 - start to the end
35:26 - and i is trying to fix every single
35:28 - number
35:29 - so first we're going to fix 5 and then
35:31 - we're going to fix 4 and then 3 and then
35:33 - 2 and so on and so forth
35:35 - so
35:36 - this max is going to keep a track of
35:40 - of the current n right so this max
35:43 - starts from n and then goes to n minus 1
35:45 - and then n minus 2 and so on and so
35:47 - forth as you can see here
35:51 - now we also have this d which basically
35:53 - tells us the positions of every single
35:55 - element
35:56 - so dictionary is a dictionary from the
35:59 - value say from five to its current index
36:03 - so in the case of three two four one
36:05 - five
36:06 - the value of the key five is four
36:10 - that's because it's sitting at the
36:11 - fourth index
36:13 - similarly for the value 4 the index is 3
36:17 - sorry the index is 2 and so on
36:21 - now we're going to say while these two
36:23 - conditions would while b exist while we
36:25 - have any number of swaps left to be done
36:28 - and we still haven't iterated through
36:30 - the entire array so while we're still
36:32 - iterating through the array and while we
36:34 - have swaps remaining to be made
36:36 - we'll do some computation
36:38 - we'll say that first of all get me j
36:41 - now what is j
36:43 - j is the d of max basically j is the
36:46 - location where the highest element is
36:48 - sitting so in the case of 3 2
36:52 - 4 1 5
36:54 - as i showed in the presentation
36:57 - the in the first iteration j is going to
36:59 - be what
37:00 - j is the location of the maximum
37:02 - possible value now the maximum is 5 in
37:05 - our case so we're going to go ahead and
37:07 - ask the question hey where is 5
37:10 - and the answer we get is 4 5 is sitting
37:13 - at the index fort
37:15 - now we'll ask the question hey is the
37:17 - current index i the same as the return
37:19 - index j
37:21 - that is
37:22 - is 5 in its right position or not
37:25 - now if it's in right's position well we
37:28 - don't really need to do anything it's
37:30 - already in its right position and we can
37:32 - just continue on as is
37:34 - however if it's not in its right
37:36 - position we'll have to do
37:38 - a swap
37:39 - and so every time we do a swap we'll
37:41 - have to reduce the b by one
37:43 - and what is the swap going to be
37:44 - swap is simply going to swap the i and
37:47 - the j elements
37:48 - right as we saw
37:50 - uh when we realized that you know what 5
37:52 - and 3 had to be swapped because 5 was
37:55 - towards the end and 5 should be in the
37:57 - start well we wanted to replace 5 with 3
38:00 - and so 3 will move to the position of
38:03 - pipe
38:04 - now we'll say that a of i comma a of j
38:07 - equals to a of j comma e of i basically
38:09 - 5 and 3 gets swapped
38:12 - this is one more thing that we need to
38:13 - do which is absolutely essential
38:16 - which is to update their dictionary
38:18 - values as well since both of these
38:20 - numbers now are at different indices
38:22 - than they were at before
38:24 - we'll update the dictionary values
38:27 - also towards the end of this while loop
38:29 - will also say i plus equals to 1
38:31 - basically now we'll increase the i
38:32 - pointer by 1 and we'll reduce the max by
38:35 - 1 and that's because we started off with
38:38 - the maximum value as n then we'll move
38:40 - on to n minus 1 and then so on and so
38:42 - forth
38:43 - at the end after we have made all of
38:45 - these swaps we would have a a that is
38:48 - remaining and this a is something we'll
38:50 - return at the end
38:51 - all right so this is it for the code
38:54 - and that is it for the solution to the
38:56 - problem largest permutation
38:59 - hello everybody and welcome back
39:02 - let's talk about the problem meeting
39:04 - rooms
39:05 - we're given a list of intervals defined
39:07 - by their starting and their ending times
39:10 - and each of these intervals basically
39:11 - represents a single meeting and now we
39:14 - are given a list of meetings
39:16 - the goal of this problem is to find the
39:18 - least number of meeting rooms required
39:20 - so that we can conduct all of the
39:21 - required meetings
39:23 - the constraints mention that n the
39:25 - number of meetings can be between 1 and
39:28 - 10 to the power 5.
39:29 - the constraints also mention that every
39:31 - single time
39:33 - can be between 1 and 10 to the power 9.
39:36 - so let's take an example to understand
39:38 - this better
39:39 - let's say the input we get is 5 comma 10
39:42 - 15 comma 20 and 0 comma 30.
39:45 - what it means is we have three different
39:46 - meetings where the first meeting starts
39:48 - from 5
39:50 - and ends at 10. so basically you can
39:51 - assume it starts at
39:53 - time some t equals to 5 units and ends
39:56 - at t equals to 10 units then there's
39:58 - another meeting starting from 15 ending
40:00 - at 20 and a third meeting starting from
40:03 - zero ending at 30.
40:05 - now the output of this problem is two
40:07 - saying that there are at least two
40:08 - number of rooms required to conduct all
40:10 - of these meetings
40:12 - and that is because we have to realize
40:14 - that 0 and 30
40:16 - 0 comma 30 and 5 comma 10 are two
40:18 - meetings which intersect right they take
40:21 - place simultaneously which means that
40:22 - we'll need to create two different rooms
40:24 - so that both of them can happen around
40:26 - the same time
40:28 - similar is the case for 0 comma 30 and
40:30 - 15 comma 20. both of them again
40:32 - intersect so we'll need at least two
40:33 - rooms so that the meetings can actually
40:35 - take place
40:37 - all right let's go ahead and expand upon
40:39 - this example and try to work out how we
40:42 - actually got to a solution
40:43 - and simulate what is going to happen
40:46 - so now what i'm going to do is i'm going
40:48 - to create these meetings so we have one
40:50 - meeting from 5 to 10
40:52 - we have another meeting from 15 to 20
40:54 - and a third meeting from 0 to 30.
40:58 - now what we can do is we can go ahead
40:59 - and start scanning from the left to the
41:02 - right
41:02 - and so i'm going to create a pointer and
41:04 - this is the yellow pointer that we are
41:06 - going to see and this pointer is going
41:08 - from the start to the end scanning the
41:10 - meetings basically it is going to ask
41:12 - the question hey how many meetings are
41:14 - there currently going on
41:16 - and so the current variable c u r r
41:19 - will start from zero basically saying
41:20 - that there are no meetings at time of
41:22 - zero and as we iterate as we scan
41:24 - through these times we'll go ahead and
41:26 - increase the current which represents
41:29 - the number of meetings going on
41:30 - currently
41:31 - and max is the second variable we need
41:33 - to keep a track of which will tell us
41:35 - how many meetings rooms do we require
41:37 - and the max is going to be the answer at
41:39 - the end
41:40 - so the first thing we'll do is uh we
41:42 - realize as soon as we hit time 0 we see
41:45 - that there is one meeting that is
41:46 - starting at this point of time
41:48 - so we'll need to increase the current by
41:50 - one
41:50 - right so now we can go ahead and say
41:52 - that current equals to one what is the
41:54 - maximum number of rooms are required
41:56 - maximum is just the maximum possible
41:58 - value of current so we'll put one in
42:01 - this place as well
42:03 - now what do we do next
42:05 - well the next thing we realize is that
42:07 - from time zero including time one two
42:09 - three four
42:10 - we will only require one total meeting
42:13 - room and so the current remains one but
42:16 - as soon as we hit time equals to five
42:18 - we'll need two meeting rooms
42:20 - because at this point of time another
42:21 - meeting starts right the meeting from
42:24 - five to ten starts at this point of time
42:26 - so the current increases to two which
42:27 - means that there are two meetings going
42:29 - on simultaneously
42:31 - now what is the max going to be max is
42:33 - going to reflect the changes in the
42:34 - current and become two visible
42:36 - all right so now from the point of time
42:38 - five six seven eight nine we will have
42:41 - two meetings running simultaneously
42:43 - right so the current remains two and the
42:45 - maximum remains two
42:47 - but as soon as we hit time equals to ten
42:49 - the current decreases back to one
42:52 - and that's because one particular
42:53 - meeting the meeting from five to ten has
42:55 - ended right now which means that the
42:57 - current number of meetings going on is
43:00 - one that's the meeting from 0 to 30
43:02 - which is still going on so we'll still
43:04 - need one room to take care of now what
43:06 - happens from time 10 to 11 12 13 14
43:10 - will only ever require one total meeting
43:12 - room but as soon as time hits 15
43:15 - we'll need another meeting room to
43:16 - accommodate both of these meetings
43:18 - simultaneously the maximum stays the
43:20 - same and the current becomes two
43:23 - so then what happens when we move to the
43:25 - time 20 well if current again decreases
43:27 - to 1 since we only have one meeting
43:29 - going on right now
43:31 - and then at time equals to 30 the
43:33 - current decreases to zero basically
43:35 - saying that the meeting that was going
43:36 - on earlier from 0 to 30 has ended
43:39 - so the only thing that is remaining is
43:41 - the maximum which is equal to 2 which
43:44 - becomes the answer
43:46 - now one thing that we have done across
43:48 - this solution is that we're going over
43:50 - every single time stamp so we're going
43:52 - at time goes to zero we're going at time
43:54 - goes to one and two then three then four
43:56 - and five
43:57 - right and we're going to look at every
43:59 - single time stamp we're going to look at
44:00 - every single time and scan across all of
44:02 - these meetings to know which of them is
44:04 - going on
44:05 - as you can imagine that will take quite
44:07 - a lot of time
44:08 - in fact if we have cases like these
44:11 - where we have one meeting from 0 to 10
44:13 - to the power 9 which is by the way a
44:14 - valid constraint
44:16 - whenever we have these kind of meetings
44:18 - well
44:19 - as you realize 10 to the power 9 is not
44:21 - a feasible way to deal with this right
44:24 - if we iterate from 0 all the way up till
44:26 - 10 to the power 9 will already get a
44:28 - time limit exceeded and that's even just
44:30 - looking at one single meeting what if we
44:32 - have multiple of these kind of meetings
44:35 - that just means that this is not a good
44:37 - way to look at it there's an
44:39 - optimization that's hidden somewhere
44:42 - all right so how do we think about the
44:43 - problem now
44:44 - well let's go back to the nicer example
44:46 - and notice what you have done previously
44:49 - the thing we realized previously was
44:51 - that we only care about the places where
44:54 - the change happens so what it means is
44:57 - we are only going to focus on 0 5 10 15
45:00 - 20 and 30. we don't care about what
45:02 - happens at time equals to 3 or time
45:04 - equals to 7 or time goes to 16 or 24 or
45:07 - 31 or 32.
45:09 - we only care about the times where
45:11 - changes happen
45:12 - we only care about time zero where our
45:14 - meeting starts we only care about the
45:16 - time five when another meeting starts at
45:18 - a time 10 a meeting ends so we care only
45:22 - about the points of times where the
45:23 - number of meetings is going to change so
45:26 - that's central observation in solving
45:28 - this problem
45:29 - in fact what we're going to do is we're
45:30 - going to write down these formally so
45:33 - we're going to say at times 5 15 and 0
45:36 - we are going to require plus 1 meeting
45:38 - rooms
45:40 - what it means is as soon as we hit time
45:42 - equals to 5 we'll need one more meeting
45:44 - room
45:45 - and if you look at the visualization
45:46 - that makes a lot of sense right so what
45:48 - you've done is we've figured out we have
45:50 - picked out all of the starting indices
45:53 - which are 5 15 and 0
45:55 - as you can see from the array on the top
45:56 - and we have all assigned them plus one
45:58 - value similarly we have assigned minus
46:02 - one value to 10 20 and 30 because if you
46:04 - look at the array above again 10 20 and
46:06 - 30 are all the ending times basically
46:08 - saying that at time equals to 10 i
46:11 - require one less meeting room because at
46:13 - time it goes to 10 one meeting has ended
46:16 - right so now what we can do is we can go
46:18 - ahead and write them in a better format
46:20 - and we're going to create a tuple of
46:22 - the time comma the change in the meeting
46:24 - rooms required
46:26 - now the next step we're going to do is
46:28 - pretty simple once you understand what's
46:29 - going on the only thing we're going to
46:31 - do is we're going to sort all of these
46:33 - numbers by their times
46:35 - so 0 comes first then 5 10 15 20 and 30.
46:38 - remember this is the way we discussed uh
46:41 - in the initial example as well this is
46:43 - how we are going to look at the problem
46:45 - so what it means is
46:47 - at time equals to zero i'm going to
46:49 - require plus one meeting room so we're
46:51 - gonna have this current in the max
46:53 - variable as before and at time equals to
46:55 - zero i need plus one meeting rooms so
46:57 - the current now increases by one saying
47:00 - that i need one more meeting room than
47:01 - what i had previously i had zero so now
47:04 - zero plus one becomes one
47:06 - what is the max going to be
47:08 - max is going to be the maximum value of
47:09 - current we have seen so the maximum will
47:11 - become one as well
47:13 - this is what happens at time equals to
47:15 - zero
47:16 - now what happens when you move to time
47:17 - equals to five
47:19 - at time equals to five another meeting
47:21 - starts so we increase the current by 1
47:24 - and the maximum reflects the change
47:27 - now what happens at time equals to 10
47:30 - a meeting has ended now we don't know
47:32 - which meeting has ended but one of the
47:34 - meetings has ended that means the
47:36 - requirement for the number of rooms has
47:38 - decreased by one the current decreases
47:41 - from two
47:42 - as we saw here the current decreases
47:44 - from two here to one here
47:46 - all right make sense
47:48 - and similarly so on and so forth we can
47:50 - keep on going we can keep a track of the
47:52 - current as how the meeting rooms
47:55 - increase or decrease and change
47:57 - at the end of this iteration you'll
47:59 - notice that the current becomes zero
48:00 - again because all of the meetings that
48:02 - started
48:03 - all of them have ended right now and
48:06 - maximum is again the answer to this
48:08 - problem
48:10 - all right so pretty simple what's going
48:11 - on right let's go ahead and implement
48:13 - this
48:14 - so this is the implementation with this
48:15 - question the first thing we are going to
48:17 - do is create this data array this data
48:19 - list which is going to store
48:22 - plus one so for every single starting
48:24 - and ending element inside of this array
48:26 - for every single meeting i'm going to
48:28 - say you know what data dot append add
48:30 - the value s comma 1 to the
48:33 - data array
48:34 - basically saying that at this start
48:36 - point of time i require plus one meeting
48:39 - rooms
48:40 - the number of meeting rooms the
48:42 - requirement of these meeting rooms
48:43 - increases by one
48:45 - at the same time i'm going to say
48:46 - whenever this particular meeting ends go
48:48 - ahead and decrease the requirement of
48:50 - the meeting rooms
48:52 - and so as i described earlier the next
48:54 - step is going to be sorting all of these
48:56 - values so we can iterate over them in a
48:58 - meaningful way so the time is going to
49:00 - increase one by one
49:02 - and we're going to increase the time and
49:04 - keep a track of the current as well as
49:06 - the answer
49:07 - so i'm going to say for underscore comma
49:09 - b in data basically saying uh i don't
49:11 - care about the time anymore i only care
49:13 - about the change in the current so i'm
49:15 - going to say for every single of these
49:17 - values the current increases by the i so
49:19 - if v is plus one the current increases
49:21 - by one if b is minus one the current
49:23 - decreases by one pretty simple
49:26 - and the next step is then again the
49:28 - writing answer equals to the max of
49:30 - answer and the current
49:31 - basically saying that keep on storing
49:33 - the maximum possible value of current
49:35 - that you can get
49:37 - and at the end we can return this answer
49:39 - so let's go ahead and go ahead and test
49:41 - this out
49:44 - we are going to go ahead and submit this
49:45 - as well
49:51 - all right cool so this gets accepted
49:53 - hello everybody and welcome back let's
49:56 - talk about the problem distribute candy
49:59 - there are n kids standing in line each
50:02 - of them having an integer rating
50:03 - associated with them
50:06 - we have to distribute the candies
50:07 - following two rules
50:09 - first each kid gets at least one candy
50:12 - and second kids with the higher ratings
50:14 - than their neighbors get more candies
50:18 - the goal of this problem is to find the
50:19 - minimum number of candies required to
50:21 - satisfy both of these rules
50:24 - the constraints mentioned that n the
50:25 - number of children can be between 1 and
50:28 - 10 to the power 5.
50:30 - let's take an example to understand this
50:31 - better
50:32 - when the input given to us is 1371 the
50:36 - output is 7
50:37 - and that's because the candies we can
50:39 - give them are one two three and one
50:41 - respectively
50:43 - let's go ahead and take a look at a
50:44 - visualization to help us understand
50:46 - what's going on better so here what i've
50:48 - done is i've plotted out all the values
50:50 - so
50:51 - the kid of the rating one is present at
50:53 - the first index then the kid of the
50:55 - rating three then seven and then one
50:57 - back again
50:58 - all right so since the goal of this
51:00 - problem is to find the minimum number of
51:02 - candies possible and we have to assign
51:04 - at least one candy to each kid
51:06 - let's go ahead and assign the kid with
51:08 - the value of one
51:10 - one single candy right so this is where
51:12 - we are going to start
51:14 - and now what happens to the kid with the
51:15 - rating three
51:17 - well since the kid with the rating three
51:19 - has a higher rating than kid of the
51:20 - rating one we have to give it more
51:23 - candies now how many more well we can
51:25 - give it three candies or five or ten or
51:27 - hundred or thousand the goal of this
51:29 - problem is to minimize the number of
51:31 - candies we can give so what we'll do
51:33 - instead is we'll just ensure that you
51:35 - know what this kid is going to get two
51:37 - candies which is greater than one
51:39 - all right so this still satisfies the
51:41 - condition mentioned in the question
51:43 - all right so now we move on to the kid
51:45 - with the rating of seven
51:47 - the kid with the rating of seven looks
51:49 - at the kid with a rating of 3 on the
51:50 - left hand side and on 1 on the right
51:53 - hand side
51:54 - and realizes that wait a second i'm
51:56 - greater than both of them
51:57 - now it looks at the kid with the rating
51:59 - 3 and says that you know what since i'm
52:01 - greater since i have a higher rating
52:02 - than my neighbor i should get one more
52:04 - candy than the neighbor so we'll assign
52:06 - at the value three and now what about
52:08 - the kid with the rating one at the
52:09 - present at the very last
52:12 - well we don't have to assign it any more
52:14 - candies than the previous one because
52:16 - this current kids rating is lesser than
52:18 - its neighbors
52:20 - which means that we can go ahead and
52:21 - simply assign it the default value
52:22 - saying that you know what since you are
52:24 - at a lower value we're just going to
52:26 - give you one candy
52:28 - to formalize the logic we have seen up
52:30 - till now we'll write it this way so
52:32 - we'll say that if the rating of the
52:34 - current kid is greater than that of the
52:37 - previous kid then we are going to
52:38 - increase the score by one and we are
52:40 - going to save that score corresponding
52:42 - to that kid
52:44 - otherwise we'll set the score to 1 by
52:46 - default all right so let's go ahead and
52:47 - test this idea out on other test cases
52:50 - to see if it actually holds up or not or
52:52 - maybe it's just a product of this
52:54 - particular test case
52:56 - all right so let's take another example
52:57 - this is the example we have
52:59 - the kids are operating 1 7 4 3 and 1.
53:04 - now as with previous case we're going to
53:06 - assign this first kid the candy of 1
53:09 - because that is the minimum number of
53:10 - candies we can give
53:12 - what about the kid with the rating of
53:13 - seven
53:14 - well it looks to the left of it and it
53:16 - realized that hey
53:18 - this kid has a candy of one and since i
53:21 - am
53:21 - since my rating is greater than that of
53:23 - the previous one i'm gonna increase the
53:25 - score by one so the previous score was 1
53:28 - the current score becomes 2 and we're
53:30 - going to save that
53:32 - now when we move on to the kid with a
53:33 - rating of 4 we'll ask the same question
53:35 - hey
53:36 - is this kid having a higher rating or a
53:38 - lower rating than the previous one
53:40 - so now we'll say that you know what
53:42 - since 4 is lesser than 7 this kid's
53:44 - rating is lower than the previous ones
53:47 - we'll assign it the default value of 1
53:49 - and we follow the similar logic for the
53:51 - values for the kid of the rating 3 and
53:54 - 1.
53:55 - all right so this is the answer we have
53:57 - up till now following the logic we made
53:59 - however this is incorrect
54:01 - and that's because if you realize the
54:03 - right most kid with the rating one
54:05 - gets one candy and that's where it has
54:08 - the lowest rating so we'll have to give
54:10 - it one candy
54:11 - but the kid who is at the second last
54:13 - position with who has the rating three
54:16 - should get actually two candies
54:18 - and that's because in the question it's
54:20 - mentioned that we're looking at the
54:21 - neighbors which means that we're looking
54:23 - at both the right and the left neighbors
54:25 - together
54:26 - now in this case the kid with the rating
54:28 - 3 has a higher rating than that of the
54:30 - kid of the rating one on the right hand
54:32 - side
54:33 - right which means that it should get a
54:34 - greater amount of candy
54:36 - and so the answer changes
54:38 - which means that we cannot simply
54:41 - iterate from the left to the right
54:43 - anymore and we cannot get the answer
54:45 - this way because here's what the real
54:47 - answer is going to look like kid with
54:48 - the rating three is going to get two
54:50 - candies because of the kid of the dating
54:52 - one on the right hand side
54:53 - similarly the kid with the rating four
54:55 - is not actually going to get one candy
54:57 - but is going to look at the kid on the
54:58 - right hand side and say that you know
55:00 - what hey this kid of rating three is
55:02 - getting two candies so i should get more
55:04 - right
55:05 - so this kid will actually end up getting
55:07 - the answer three
55:08 - and similarly we'll look at the kid of
55:10 - the rating salmon and now it goes ahead
55:12 - and looks at both its right and left
55:14 - neighbors the left neighbor says one and
55:16 - the right neighbor says three and it
55:18 - realizes hey wait a second i'm greater
55:20 - than both of them
55:21 - so what i'm going to do is i'm going to
55:23 - pick the maximum of them i'm going to
55:25 - say that you know what this right kid is
55:27 - at a rating of 4 and it's already
55:29 - getting three candies
55:30 - which means that because i'm at rating 7
55:32 - i'm i'm higher than the kid of the
55:33 - rating four i should get more candies
55:36 - so i'll go ahead and
55:37 - get
55:38 - four candies in total
55:41 - now all of this was to demonstrate the
55:43 - fact that we cannot simply iterate from
55:45 - the left to the right
55:47 - and as we saw in this case the change is
55:49 - sort of
55:50 - propagated from this one kid
55:53 - on the right hand side and the change is
55:55 - propagated from the right to the left
55:59 - make sense this means that we cannot
56:01 - simply iterate from the left to the
56:02 - right and we can't do the same for the
56:04 - right to the left case either
56:06 - because if we just iterate from the
56:08 - right to the left we will just have
56:10 - inverted the problem
56:12 - which means that iterating in either of
56:14 - these directions is not going to be
56:16 - helpful for us
56:17 - we need a way out of the situation we
56:19 - need a better way to assign candies to
56:21 - kids
56:23 - how about this
56:24 - about to start from the lowest rating
56:26 - kids
56:27 - so in this case is the kids of the
56:29 - dating one there are no other kids who
56:31 - have a rating lower than one which means
56:33 - that we can go ahead and assign values
56:35 - of one to both of these kids
56:38 - that's because there is
56:40 - constraint mentioned in the question
56:41 - that we have to assign at least one
56:43 - candies to even the lowest possible
56:45 - writing kids
56:47 - so we'll go ahead and start with this
56:48 - default case right this is the default
56:50 - case keep this in mind as soon as we
56:52 - find the default case we're going to
56:53 - assign it one value
56:55 - all right so now we'll go ahead and ask
56:57 - the question for three now right we're
56:59 - starting from the lowest rating kills
57:01 - and we're trying to move up the ladder
57:03 - so now we are going to look at the kid
57:04 - with the rating three and we are going
57:06 - to ask the same question
57:08 - look at the right and look at the right
57:10 - right
57:11 - and we'll see if the kid if the current
57:13 - kid's rating is greater than the left
57:15 - kids rating then you have to give it one
57:17 - more candy
57:18 - and if the current kids rating is
57:21 - greater than the right kids grating well
57:23 - you have to give it
57:24 - you have to give it one more candy than
57:25 - the right kid
57:27 - now in the case of the kid of the rating
57:28 - three what do we do we look at the left
57:31 - there is nothing we look at the right
57:32 - there is one candy
57:34 - now this current value is going to be
57:37 - one plus one
57:38 - so we'll say that the kid of the rating
57:40 - three is going to get a value of two
57:43 - you will understand this better as we
57:45 - walk through this more so let's go ahead
57:47 - and answer the question what happens to
57:48 - the kid of the rating food
57:50 - right
57:51 - the kid of the rating four looks at the
57:53 - kid on the left hand side
57:55 - which is seven it's greater so we won't
57:57 - touch that but on the right hand side is
57:58 - a kid with a lower rating which means
58:00 - that four can demand one more candy from
58:03 - the kid of the rating three
58:05 - right so it's gonna look at two and be
58:07 - like okay give me two plus one candies
58:09 - now please
58:10 - so this is going to get three candies
58:13 - and now we finally move on to the kid
58:14 - with the highest rating rate we started
58:16 - from the lowest hitting kids and we
58:18 - slowly moved up the ladder and now we
58:20 - are going to look at the kid with the
58:21 - value of seven
58:23 - and what is this kid going to do
58:25 - this kid will look at the left kid gives
58:27 - one candy
58:28 - is going to look at the right kid has
58:30 - three candies and now this kid will
58:32 - realize hey you know what
58:34 - i'm greater than both of these guys so
58:36 - let me go ahead and get myself four
58:38 - candies because that is going to satisfy
58:40 - both the conditions all right so now
58:42 - this should make a lot more sense
58:44 - in fact let's go ahead and take one more
58:46 - example which is a slight bit more
58:47 - complicated example
58:49 - but solving through this should get you
58:51 - to the solution and if you're able to
58:52 - solve this yourself then you've pretty
58:54 - much done
58:56 - the solution for this question all right
58:58 - feel free to pause the video at this
58:59 - point of time
59:00 - and try this out yourself
59:03 - all right cool i assume you paused and
59:04 - solved now let's go ahead and start
59:06 - walking through this test case so the
59:08 - first thing we'll do is start from the
59:10 - lowest generating kids in this case it's
59:12 - two kids on either side
59:13 - who have the rating one
59:15 - so we'll go ahead and assign them one
59:16 - value each right we're going to go and
59:19 - give them one one candy because that is
59:21 - the minimum possible candy we can give
59:22 - like these are bad kids so we'll just
59:24 - give them one candy and tell them to be
59:26 - happy with it
59:28 - now we'll move up the ladder we'll say
59:29 - okay what about the kid of the rating
59:31 - too we look at the left we look at the
59:33 - right now the left kid has a candy of
59:35 - one this guy is higher than that so it
59:37 - needs more candies
59:39 - so we'll go ahead and give it the candy
59:40 - too
59:41 - now we'll go ahead and look at the kids
59:43 - of the rating three what do we do again
59:46 - well look at the right most three value
59:49 - kid right
59:50 - this guy this guy is going to look at
59:52 - the right kid which is lower and the
59:54 - left kid which is at equal value
59:57 - now since it found a kid with the rating
59:59 - lower than i that is the current kids
60:01 - value is greater than the right kids
60:03 - value
60:04 - we are going to the second if condition
60:06 - and we'll say that the number of candies
60:07 - we are going to have to give through
60:09 - this kid is one plus the right kids
60:11 - value
60:12 - all right so now we'll go ahead and give
60:14 - this the value of two
60:17 - what about the second third kid which is
60:19 - uh
60:20 - present towards the middle
60:22 - well we'll ask the same question hey
60:24 - is this kid having a higher rating than
60:26 - the kid on his left hand side no is this
60:29 - kid having a higher rating and the kid
60:31 - on the right hand side
60:32 - well no again it is equal but it's not
60:34 - greater
60:35 - which means that we can go ahead and
60:37 - assign it the default value of
60:39 - 1. we basically undercut the skill okay
60:42 - that's the wrong explanation
60:45 - now okay what about the kid of the
60:46 - rating four
60:47 - okay look on its right look on its left
60:49 - left there is nothing but right you can
60:51 - see that there is kid of rating one
60:53 - so we are going to give it the value of
60:55 - 2
60:56 - and then for the value of 7 we're going
60:59 - to look at the left and look at the
61:01 - right and what do we see there's 2
61:03 - either k so just do 2 plus 1 giving us
61:05 - 3.
61:07 - all right so this is it for the logic
61:08 - it's pretty simple what we're going to
61:10 - do is we're going to start from the
61:11 - lowest ratings and we're going to
61:13 - gradually move up the food chain we're
61:15 - going to gradually move up the ladder
61:17 - and look at from the worst kids to the
61:19 - best kids and each time we'll go and
61:21 - look at the left and the right and
61:23 - assign it one more candy if needed
61:26 - all right so let's go ahead and start
61:28 - with the code
61:29 - so n is the length of the array the
61:31 - number of kids we have and data is what
61:33 - is going to be the very helpful part for
61:35 - us so data is just a sorted array of x
61:38 - comma
61:39 - basically saying that okay for this
61:41 - particular kid rating this is its index
61:44 - right that is all i've done so what we
61:46 - are going to do is we are going to sort
61:47 - all of these kids by the ratings
61:50 - but since we are sorting we are going to
61:51 - mess with the array structure right
61:53 - we're going to mess with the indices so
61:55 - we need a way to store the indices and
61:56 - that is why we have this x comma i
61:58 - instead of just x
62:00 - all right cool so now we're going to go
62:02 - ahead and assign one by default to every
62:05 - single kit
62:06 - that's the initial uh assumption in the
62:08 - question we have to assign every single
62:10 - kid at least one values
62:12 - all right so we'll go ahead and assign
62:14 - everyone at least one candidate and now
62:16 - we're going to iterate over the data
62:18 - we'll say that for every single x comma
62:20 - i that is now x is not really important
62:22 - for us but we'll say that for every
62:24 - single i for every single index that you
62:26 - get
62:27 - we'll go ahead and ask two questions hey
62:29 - if i greater than zero basically saying
62:32 - that if there is a kid on the left hand
62:34 - side of this particular kid and
62:37 - this current kid's value is greater than
62:39 - the left kids value well if that is the
62:42 - case then go ahead and do
62:44 - candies of i minus one plus one
62:46 - right if there is a kid to the left of
62:48 - you who is a valid kid then go ahead and
62:50 - take its value and increase it by one
62:52 - only if
62:54 - the current reads current kids rating is
62:56 - greater than the left ones
62:58 - and we'll do the similar thing for the
63:00 - kid on the right hand side and this is
63:02 - just a simple sanity check just to
63:03 - ensure that you know the element i plus
63:06 - 1 actually exists in the area or not
63:08 - pretty simple
63:09 - and towards the end what we can do is we
63:12 - can simply return the sum of all the
63:14 - candies
63:15 - right as you saw the yellow elements are
63:18 - all the candies for every single person
63:20 - for every single kid and so we'll just
63:21 - sum them all up together to get the
63:24 - final value
63:25 - all right let's go ahead and test this
63:27 - out just to see if everything is working
63:29 - correctly
63:30 - and we'll go ahead and submit this
63:36 - all right cool so this is it for the
63:38 - video solution to
63:40 - distribute candies on interview build
63:42 - hello everybody and welcome back
63:45 - let's talk about the problem seeds
63:48 - there's a row of empty seeds and filled
63:51 - seeds represented by a dot and an x
63:53 - respectively
63:54 - the goal of this problem is to find the
63:56 - minimum number of moves required to make
63:59 - the people sit together
64:01 - the constraints mentioned that in the
64:02 - total number of seats including both
64:04 - empty and filled
64:05 - are between 1 and 10 to the power 6.
64:08 - so if we look on the right hand side the
64:10 - input looks like dot dot x dot dot x dot
64:14 - and the output of this question is two
64:16 - now let's go ahead and take a look at a
64:18 - visual explanation to understand this
64:20 - better
64:21 - so we have people two people sitting on
64:23 - the indices two and five and the rest of
64:25 - the seats are empty
64:27 - now what can we do to get to a solution
64:30 - well the question asks us to
64:32 - group these people together
64:35 - so what we can do is we can ask the
64:36 - person sitting at the index 5 to move to
64:38 - the index 3
64:40 - that we will have grouped together all
64:42 - of the people and we'll get a total cost
64:44 - of 2.
64:45 - why is that
64:46 - that is because the person was sitting
64:48 - at the index 5. so 5 minus 3 gives us 2.
64:51 - basically we're looking at the absolute
64:53 - difference between these two seats
64:55 - alright so two is one possible answer
64:57 - and this is one possible configuration
65:00 - if you go back to the original now we
65:01 - can ask the question hey is there any
65:03 - other better thing that we can do
65:05 - what if we ask the person sitting at the
65:07 - index 2 to move at the index 4
65:10 - well we'll get the same answer as 2
65:11 - because 2 minus 4 in the absolute
65:13 - difference of 2 and 4 is still 2.
65:16 - and of course this condition is still
65:18 - satisfied that these people are grouped
65:19 - together at the end
65:21 - so this is a pretty simple test case and
65:24 - there's not a lot of things going on
65:26 - so what we'll do is to get a better
65:28 - insight into the problem to get a better
65:30 - observation and analysis of the problem
65:33 - let's go and take a look at a bigger
65:34 - test case and i know this might look
65:36 - scary but as we work through it this
65:38 - will make a lot of sense all right so
65:41 - the goal of this problem is to group all
65:43 - of these people together
65:45 - so how about this how about i go ahead
65:47 - and assume that all of these people are
65:50 - going to be grouped together starting
65:52 - from the index zero so here's what we'll
65:54 - do we'll ask the person sitting at the
65:56 - index one to move to the index zero
65:59 - this will get a cost of one
66:01 - then we'll ask the person sitting at the
66:03 - index foot to move to the index one so
66:05 - that we can group them together
66:07 - then we'll ask the person at seven to
66:09 - move at two
66:10 - and eight to move at three
66:13 - in this we have grouped together all of
66:15 - the people and we've gotten the answer
66:17 - as 14.
66:18 - however there is no guarantee that this
66:20 - is in fact the optimal solution
66:22 - so what can we do to find an optimal
66:24 - solution
66:26 - if you notice the goal of this problem
66:28 - was to group together the people
66:30 - in other words we're looking at a
66:31 - contiguous segment of people that
66:34 - start from a particular index in this
66:37 - case these group of contiguous people
66:39 - started from the index 0.
66:41 - maybe that is not where we have to start
66:44 - maybe
66:45 - the best most optimal solution starts
66:47 - from the index one instead
66:49 - and so this is what can happen
66:51 - basically we are going to recalculate
66:54 - the cost of moving every single person
66:57 - to their appropriate seats
66:59 - right so one moves to index one four to
67:01 - two seven to three and eight to four
67:05 - make sense and we'll calculate the total
67:07 - cost and now the minimum has decreased
67:09 - the minimum has become ten
67:11 - pretty cool right and now we still don't
67:14 - know whether this is the optimal
67:15 - solution or not so what we can do is we
67:17 - can go ahead and we can go ahead and
67:19 - test out the index two as well
67:21 - right we are now going to start the
67:23 - contiguous segment from 2
67:25 - and so on and so forth we can keep on
67:28 - doing we can keep on increasing the
67:31 - starting position of the segment
67:33 - and for every single starting position
67:36 - of the segment we are going to calculate
67:38 - the time taken the number of moves taken
67:41 - for every single person we can sum them
67:43 - all up together and we'll be able to get
67:45 - to a solution
67:47 - at the end of this iteration as we have
67:49 - tested out every single index
67:51 - whatever is the minimum we'll return it
67:53 - as the answer
67:55 - all right so let's go ahead and
67:57 - implement this
67:58 - i have implemented this in python 3 and
68:01 - by the way just by the way one of the
68:02 - things that you have to do for this
68:04 - question is switch to python 2.7 because
68:06 - there are some issues in python 3. uh i
68:10 - am not sure what the exact issue is but
68:12 - it looks to be an issue on the interview
68:14 - bit side so we'll skip over that anyways
68:16 - switch to python 2.7 if you're using
68:18 - python all right so first thing we'll do
68:20 - is set up a mod which is one of the
68:21 - requirements of the question
68:24 - and now what we'll do is we'll figure
68:26 - out the indices for every single cross
68:28 - so we'll iterate over all of those uh
68:32 - all of those characters in a basically
68:34 - iterating over all the dots in the x's
68:36 - and we'll ask the question hey is the
68:38 - current character you're looking at
68:40 - is the current character an x
68:43 - because if that is well go ahead and
68:45 - save its index
68:47 - so by the end of this iteration this
68:49 - crosses will have
68:51 - all the indices
68:54 - of x's
68:56 - and that's fine all right so this is the
68:58 - first step now what's the next step
69:00 - remember that when we were looking at
69:02 - the array when we were looking at the
69:04 - case like this we started off from index
69:06 - 0.
69:07 - so let's go ahead and force everyone to
69:09 - go to index 0.
69:11 - what we'll do is we'll go from i
69:14 - will go for i come across and enumerate
69:16 - of crosses
69:18 - we'll do cross minus i this is going to
69:21 - save the number of moves required
69:24 - assuming
69:26 - starting position
69:28 - starting position of the segment is zero
69:31 - right so feel free to pause here and
69:33 - understand what's going on we're looking
69:35 - at the index of one cross and we're
69:36 - going to move it to another index i
69:40 - which is going to be the appropriate
69:41 - index assuming that the starting
69:43 - position of the segment is zero
69:45 - and now we are going to go ahead and
69:47 - find the number of process and we'll say
69:48 - simply say this is one edge case we can
69:51 - simply say that you know what
69:53 - if n equals to zero if the number of
69:55 - cross is zero well there are no people
69:58 - and the entire row is empty just return
70:00 - early and return zero
70:01 - saying that we don't require any amount
70:03 - of cost moving a person here from here
70:06 - to there because there are no person at
70:07 - all
70:08 - all right cool this is a simple test
70:10 - case now we'll go ahead and initialize
70:12 - the answer starting from infinity
70:14 - remember this is the minimum possible
70:15 - answer that we want to get so i'm going
70:17 - to initialize with the maximum possible
70:19 - value
70:20 - and now i'm going to start from all of
70:23 - the segment stars in range of length of
70:25 - a
70:26 - basically whenever i have this kind of
70:29 - so in this case we have an array of
70:30 - limit tenth
70:32 - i am going to assume that a starting
70:34 - segment can be from anywhere between 0
70:36 - and 10.
70:37 - so this is what i've done i'm going to
70:39 - iterate over every single possible start
70:41 - of the segment
70:43 - for each of these segment starts i'm
70:44 - going to keep a track of the total cost
70:46 - for each segment which is going to start
70:48 - from 0. and now i'm going to say for
70:50 - cross and crosses basically for every
70:52 - single moves
70:54 - required so this is the number of moves
70:56 - now crosses stores the number of moves
70:59 - for every single one of these crosses
71:02 - figure out the difference between this
71:03 - and the start of the segment so this
71:05 - will give you the answer for the current
71:08 - configuration
71:10 - and now we'll do total plus sequence to
71:11 - this value and total mod equals two so
71:14 - basically uh this is like one of the
71:16 - extra constraints the questions is the
71:18 - value can be very large we have to
71:20 - return minimum value mod
71:22 - what is this i think a standard power
71:24 - eight plus 3
71:26 - all right anyways so this is like an
71:28 - implementation level detail that's why i
71:29 - did not mention in the
71:31 - problem setup that i had anyways once we
71:33 - have this total what we can do is simply
71:35 - assign answer as the minimum value of
71:38 - the answer and the total mod with the
71:40 - mod
71:42 - all right so as we go ahead and iterate
71:44 - through the segment starting points and
71:46 - as we go ahead and iterate through every
71:48 - single one of these crosses
71:50 - we will be able to get an answer so
71:52 - let's go ahead and quickly test this out
71:55 - all right looks to be correct and we can
71:57 - go ahead and submit this so you can see
71:59 - that this says test case easy success
72:01 - but this will fail for hard test cases
72:04 - and that's because of this loops over
72:05 - here you see this loop takes order of n
72:08 - time to run
72:09 - and that's because we are iterating for
72:11 - every single possible segments chart
72:14 - now this takes order of n where n is the
72:16 - number and is the length of the array
72:18 - which is the number of seeds in the row
72:21 - for every single one of those i also
72:23 - have another order of an operation
72:25 - inside of it
72:26 - where i'm saying for every single cross
72:28 - in cross is do something
72:30 - and now the number of crosses in a row
72:32 - can be order of n at maximum right if
72:34 - you have 10 people in the row you can
72:37 - also have a worst case where all of
72:39 - these seeds are fit
72:40 - so this will just be a lot of pain to do
72:43 - and this is order of n nested inside of
72:45 - another order of n
72:47 - giving the total time complexity as
72:49 - order of n square and you can see that
72:51 - the test is hard failed because the time
72:53 - limit exceeded
72:55 - all right so how do we start to think
72:56 - about optimizing this problem i mean
72:58 - this is already a pretty complicated
73:00 - problem but now we're asked to optimize
73:03 - this
73:04 - all right let's go ahead and take a
73:06 - fresh start let's say that this is the
73:08 - configuration we have this is the test
73:10 - case we have
73:12 - now if you look at it
73:13 - can we not say that okay assume
73:16 - 1 4 seven and eight are people standing
73:18 - on these indices right so these are all
73:21 - of these people standing now let's say
73:23 - that the person one is uh standing alone
73:25 - four is standing alone but seven and
73:27 - eight are having an interesting
73:28 - conversation or maybe they're in a party
73:30 - and now
73:32 - they'll go ahead and invite person one
73:34 - and four to join the party
73:36 - now where do you think both of these
73:39 - should land up like they want to all
73:40 - meet up together right that's the goal
73:42 - of the problem we have to group together
73:44 - these people so since 7 and 8 are
73:46 - already at their locations
73:48 - they're going to go ahead and call 4 and
73:49 - 1 to come to their side
73:52 - right so this is one way we can think
73:53 - about it the answer is hidden in
73:55 - clusters of people
73:57 - right so maybe if there is a very large
73:59 - cluster somewhere in the middle then
74:01 - that might
74:02 - attract all of these people and that
74:04 - might minimize the number of moves we
74:06 - take so this is just a heuristic
74:09 - and whenever we have heuristics like
74:10 - these whenever you have ideas of how the
74:12 - solution might proceed
74:14 - go ahead and do your best to disprove it
74:17 - instead of proving it try to disprove it
74:19 - and if you can find a test case where
74:20 - you can disprove it well you can go
74:22 - ahead and build your intuitions and
74:23 - observations more
74:25 - so let's go ahead and take a look at
74:26 - another test case this is a little bit
74:28 - more complicated but it'll do the job
74:31 - so now
74:32 - if you look at it there are like three
74:34 - different total clusters of people there
74:36 - are two clusters in the very beginning
74:38 - two two words middle and three towards
74:40 - the end right
74:41 - so
74:43 - what now well since we said that maybe
74:45 - the biggest cluster is going to attract
74:47 - the most people so let's assume that's
74:49 - the case let's assume 10 and 12 do not
74:52 - move but they're going to invite
74:53 - everyone else
74:55 - so 4 and 5 are going to move to 8 and 9.
74:58 - this is going to take a cost of 4 and 4
75:00 - respectively
75:02 - similarly we are going to call 0 and 1
75:04 - to 6 and 7 right
75:06 - so this will take a cost of 6 and 6
75:08 - giving us a total cost of 20.
75:12 - now in this this case you can see that
75:14 - all of them are grouped together neatly
75:15 - towards the end of the adding and maybe
75:18 - maybe that is the answer we are looking
75:20 - for
75:21 - right maybe 20 is the answer we're
75:23 - looking for
75:24 - but now if we use the brute force
75:26 - solution to verify it we'll find that
75:28 - the test case not actually satisfies the
75:30 - condition is this one
75:32 - the configuration which satisfies this
75:34 - condition is this one
75:36 - we have the starting segment index has
75:39 - two
75:40 - and you can see that the score we get as
75:42 - two plus two for the first two guys zero
75:45 - plus zero for the middle two guys the
75:46 - middle two guys don't move and the last
75:48 - three guys move and come towards this
75:50 - place
75:52 - now what does this hint you at it looks
75:55 - like everyone has come towards the
75:56 - middle of the area
75:58 - right it looks like everyone has come
76:00 - together with four and five although the
76:02 - biggest cluster was ten eleven twelve
76:04 - these four and five guys somehow
76:06 - attracted everyone else
76:08 - so maybe it's the point of middle which
76:10 - is the more interesting observation we
76:12 - can get
76:13 - you know maybe we have to think about it
76:14 - from a middle point of view
76:17 - but now the question is how do you
76:19 - exactly define a middle
76:21 - at this point i want you to pause and
76:23 - figure out what a measure of the middle
76:24 - could be
76:25 - i know all of this has been pretty weird
76:27 - up till now is pretty new stuff
76:30 - but feel free to pause at this point and
76:32 - try to figure out a solution because if
76:34 - you can do it trust me this is one of
76:36 - those kind of questions for which the
76:38 - solution you will never forget you will
76:40 - never forget if you can figure this out
76:42 - on your own
76:43 - all right pause right now if you want to
76:45 - try this out
76:47 - all right so if you go back to school
76:49 - level mathematics one of our chapters
76:51 - we're taught is statistics
76:54 - and when it comes to statistics there
76:55 - are three different very common basic
76:58 - ways of getting to know our data set
77:01 - are three different measures that we use
77:02 - very commonly
77:04 - mean
77:04 - median and mold
77:06 - now mode as we already proved is not
77:08 - going to give us the solution we're not
77:10 - looking at the biggest cluster because
77:12 - 10 level 12 obviously moved towards the
77:14 - middle so mode is out of the picture
77:16 - what about mean and median
77:19 - well let's go ahead and assume that mean
77:21 - is going to give us the answer so what
77:23 - we'll do is we'll take all of these
77:25 - indices of the
77:26 - people
77:27 - sum them all up together and divide it
77:29 - correctly so we'll have
77:31 - a total of 43 divided by the seven
77:33 - people that have there that are there
77:36 - we have 43 as a total divided by seven
77:39 - people that are there and so the mean
77:40 - comes out to six
77:42 - now what this means is the mean means
77:45 - that
77:46 - six is the middle point of the array
77:48 - which means that since there are seven
77:50 - total people
77:51 - there should be three people on the
77:53 - right of six and three people to the
77:55 - left of six
77:57 - however it looks like 6 is not the right
77:59 - answer 5 is
78:01 - 5 is more middle than 6 somehow
78:04 - so clearly mean is not the correct way
78:06 - to look at it
78:08 - what about median instead
78:10 - if we look at median we get 0 1 4 5 10
78:13 - 11 12 and again the middle element in
78:16 - this case is what
78:17 - the middle element is 5
78:20 - and 5 exactly matches with the perfect
78:23 - the optimal solution it perfectly
78:24 - matches with the optimal solution
78:26 - and so it looks like we are looking at
78:28 - median as the perfect position for these
78:32 - segments
78:33 - so median is going to define us the
78:35 - answer so let's go ahead and write down
78:37 - that instead of going for that large
78:40 - order of n segment start loop what we
78:42 - are going to do is we are going to do
78:44 - something very very simple we are going
78:46 - to say that the segment start
78:49 - is nothing but the median the array now
78:52 - what what area we are looking at we are
78:53 - looking at the crosses array
78:55 - and we'll figure out the n by two
78:58 - element we're looking at the middle
78:59 - element we're looking at the median
79:01 - all right so that is all i've done that
79:03 - is all the change i've made let's go
79:04 - ahead and test this out once
79:06 - and we'll go ahead and submit this
79:10 - all right so this works out
79:12 - anyways i know this was a little bit
79:14 - complicated to figure out the median and
79:16 - the mean thing
79:17 - but
79:18 - now that you know about the median thing
79:20 - keep it in mind for future reference
79:22 - because there are many other questions
79:24 - especially the tricky ones like these
79:26 - which require both knowledge of mean and
79:28 - medium so
79:30 - keep mean and median in mind test them
79:32 - both out in given a test case and see
79:34 - which one works out which one does not
79:36 - and that'll give you a better way to
79:39 - approach the problem and optimize the
79:41 - solution hello everybody and welcome
79:43 - back
79:44 - let's talk about the problem sine minus
79:46 - two holes
79:48 - we're given n minus and n holes defined
79:51 - by these two arrays
79:52 - which contain position of each of the
79:54 - mice and each of the holes respectively
79:57 - and a mice takes one minute to travel
79:59 - one unit left or right
80:02 - the goal of this problem is to find the
80:04 - minimum time after which all mice are in
80:06 - holes
80:07 - so basically the problem is we have to
80:09 - select a mice and assign it a hole so
80:11 - that it can travel from its position to
80:13 - the hose position
80:14 - taking the amount of time which is the
80:16 - difference between them right
80:18 - so i know this can sound a bit confusing
80:20 - so let's go ahead and take an example to
80:22 - understand this better so the first row
80:24 - tells us the positions of the mice and
80:26 - the second row tells us the positions of
80:28 - the holes
80:29 - so what we're going to do is we're going
80:31 - to go ahead and plot this out just for
80:32 - the sake of clarity so there's a mice
80:35 - that exists at position three another
80:37 - mice at position two and one more mice
80:39 - at position position minus four
80:42 - then we have three holes
80:44 - one hole at zero one at minus two and
80:46 - one at four
80:48 - pretty simple right the problem setup is
80:49 - pretty simple
80:50 - now what's the greedy solution over here
80:52 - what is something that you can do
80:54 - greedily
80:55 - well what you can do is assign
80:58 - every single mice the corresponding hole
81:01 - and what i mean by that is if you look
81:03 - at the mice number minus 4 it can simply
81:05 - go to the whole number minus 2
81:08 - and that's because both of them occur at
81:10 - the first position
81:11 - right when we sort these arrays when we
81:14 - sort the mice array when we sort the
81:15 - whole array we can simply iterate over
81:17 - them one by one so we can say that for
81:20 - the first mice we're going to assign it
81:21 - to the first hole
81:23 - so it'll look something like this
81:26 - and we'll take total of two time because
81:27 - it went from minus four to minus two
81:30 - similarly now we are going to look at
81:31 - the second mice and assign it to the
81:33 - corresponding second hole
81:35 - mice moves from two to zero taking again
81:38 - a time of two
81:40 - and then we look at the third mice and
81:41 - assign it to the third hole and so this
81:43 - mice will go from three to four
81:48 - now if you realize what you've done we
81:49 - have assigned the mice to their
81:51 - corresponding holes
81:53 - why is that correct
81:55 - why will that work can we prove that
81:57 - this will always work
81:59 - and so to prove that this will always
82:01 - work what we can do is we can prove that
82:03 - the mice will never cross each other
82:06 - right because if they never cross each
82:08 - other they will always go to their
82:09 - corresponding holes
82:11 - now
82:12 - can we prove that the mice will never
82:14 - cross each other because if we are able
82:16 - to prove that then we'll be able to
82:18 - prove that our greedy solution is in
82:20 - fact the optimal solution
82:22 - so let's go ahead and take a simpler
82:23 - case where we just have two mice and two
82:25 - holes correspondingly
82:27 - now let's say that the
82:29 - what we want to make these mice do is
82:31 - cross each other right instead of
82:33 - going from
82:34 - left mice to the left hole and the right
82:36 - mice goes to the right hole we are going
82:39 - to say the right mice is going to the
82:40 - left hole and the left mice is going to
82:42 - go to the right one
82:44 - but here's the catch
82:46 - here is the most important thing which
82:48 - makes the solution happen
82:50 - both of these mice are identical
82:53 - i know these mice don't have any
82:54 - identity of their own
82:56 - which means that we can look at their
82:58 - paths and we can make a split in the
83:00 - middle
83:01 - what i mean is this
83:03 - i can say that the left mice takes just
83:05 - a slight bit longer out and ends up at
83:07 - the left hole and the right mice ends up
83:08 - taking a longer route to go to the right
83:10 - hole and now what have we done we are
83:12 - saying that if the mice cross each other
83:15 - that is if they have if they are in this
83:17 - kind of configuration
83:19 - then we can always say that we can split
83:21 - them out this way
83:22 - and these mice will end up taking longer
83:25 - times to get to their corresponding
83:26 - holes
83:28 - which is approved by contradiction
83:29 - because we will never take these longer
83:31 - routes we will always take the shorter
83:33 - most optimal corresponding route
83:36 - which means that the sorting approach
83:38 - will indeed work and the greedy solution
83:40 - is in fact the optimal solution
83:43 - so let's go ahead and code this up the
83:45 - code is pretty simple the first thing we
83:46 - are going to do is sort both of these
83:48 - arrays so we'll sort all of the mices by
83:50 - their positions and sort all of the
83:52 - holes
83:52 - by their positions
83:55 - we're also going to have an answer which
83:56 - we start from 0 and now we're going to
83:58 - iterate for every single mice and every
84:02 - single hole in both of these arrays so
84:04 - all this does is is going to give us an
84:06 - iterable of the first mice and the first
84:08 - show then the second mice in the second
84:10 - hole third mice and the third hole and
84:12 - so on and so forth so we'll be able to
84:13 - iterate over these mice and the holes
84:15 - effectively
84:16 - and now i can simply say that the answer
84:18 - is the maximum of answer
84:20 - and the absolute difference between a
84:22 - and b so which is the time
84:25 - my stakes which is sitting at position a
84:27 - to go to the hole at position b
84:30 - and that is it at the end we can return
84:32 - the answer so
84:34 - that is really it we can go ahead and
84:35 - test this out
84:37 - and submit this as well
84:42 - all right cool this works out so
84:44 - yeah this is it for the solution to the
84:46 - problem assign mice to holes hello
84:49 - everybody and welcome back
84:51 - let's talk about the problem majority
84:53 - element
84:54 - now most of the videos on youtube will
84:56 - try to explain to you the boyer moore
84:58 - algorithm which is from a class of
85:00 - voting algorithms
85:01 - however it is one of those
85:03 - which you need to know beforehand to
85:05 - truly understand it plus if you're given
85:07 - this question in an interview there is
85:09 - no way you can come up with that on your
85:11 - own
85:12 - however
85:13 - i'm going to present another solution
85:15 - i'm going to present a solution which is
85:17 - super sneaky something that you can come
85:19 - up with during an interview and it's not
85:22 - even hard it's pretty simple and it's
85:24 - right in front of our eyes all right
85:26 - without talking too much let's go ahead
85:27 - and get started
85:29 - all right so the problem setup says that
85:31 - we're given an array of integers of
85:33 - length n and the majority element is
85:35 - defined as the element which occurs with
85:37 - greater than n by two frequency
85:39 - the goal of this problem is to find the
85:41 - majority element so if we look on the
85:43 - right hand side we see that the input is
85:45 - 3 2 4 2 2.
85:47 - clearly the majority element is 2
85:49 - because it occurs with a frequency of 4.
85:52 - and this frequency of 4 is greater than
85:54 - the required frequency of n by 2 which
85:56 - is 3.
85:57 - all right so
85:59 - how can we get started with the solution
86:01 - to this problem well let's talk about
86:03 - the 9 solution what is something that we
86:05 - can do right away
86:07 - what we can do is create a frequency
86:09 - table so we can say the 3 occurs with
86:11 - the frequency of 1 2 occurs with the
86:14 - frequency of 4 and 4 occurs with the
86:16 - frequency of 1.
86:18 - nothing special right we've just created
86:19 - frequencies corresponding to each
86:21 - element
86:22 - and now what we can do is after this
86:24 - step 1 we can take the step 2 as going
86:27 - over all of the keys in the dictionary
86:28 - and finding out their values and if the
86:31 - value is greater than the required
86:32 - frequency of n by 2 well we can return
86:35 - that as the answer so in this case as we
86:38 - iterate over the keys we look at 3 then
86:39 - we look at 2 and we realize that 2 has a
86:41 - frequency of 4 which is greater than the
86:43 - required frequency of n by 2 3.
86:46 - so since 2 has a greater frequency we're
86:48 - going to return 2 as the answer
86:50 - pretty simple right nothing too special
86:53 - all right so was the space time
86:54 - complexity analysis
86:56 - well order of n space is required for
86:58 - the solution because we're going to
87:00 - store a hash map or a dictionary which
87:02 - can take order of end time to generate
87:04 - as well
87:06 - all right so we can go ahead and
87:07 - actually look at the code for this which
87:09 - is pretty damn simple in python so from
87:11 - collections we are going to import
87:12 - counter and counted enough is nothing
87:15 - but is going to create us
87:17 - a hash map or a frequency table
87:20 - and we're going to say counter of a
87:21 - first of all go ahead and create that
87:22 - counter
87:23 - and then
87:24 - use the most common function to get the
87:26 - most common
87:28 - one element so basically get the highest
87:31 - frequency element
87:32 - and the rest is just uh syntax related
87:35 - stuff and this one-liner solution will
87:37 - get you the correct answer that is in
87:39 - fact how i was able to solve this in
87:41 - less than one minute but
87:44 - the solution is not the most optimal
87:46 - because we are going to take order of n
87:47 - space
87:48 - and the follow-up question an
87:49 - interviewer can ask you is that how can
87:51 - you reduce the space
87:53 - is there a way to make the space order
87:55 - of one
87:56 - can you make the space constant
87:59 - which brings me to the sneaky solution
88:01 - at this point other people will go ahead
88:03 - and present to you the boyer moore
88:04 - algorithm however there's a better
88:06 - solution that exists right in front of
88:08 - our eyes
88:10 - all right so let's go and take a look at
88:11 - the array again this is the same area as
88:13 - we've seen before
88:14 - and the constraint is now written in
88:16 - front of us that we have to do it in
88:17 - order of one space
88:20 - if you think about it we have to
88:21 - compress the entire hash map we have to
88:24 - create compress sort of the entire
88:26 - dictionary that we created which took
88:28 - order of n space earlier we have to
88:30 - compress all of that into somehow this
88:32 - order of one space
88:34 - sounds pretty weird right
88:36 - impossible in fact
88:38 - here's the thing whenever you're stuck
88:40 - in a dead end like this i've explained
88:42 - this by the way in other solutions on my
88:44 - channel as well whenever you're stuck in
88:46 - these weird kind of situations where
88:48 - there seems to be no other way and the
88:50 - space constraint is order of one
88:52 - you have to think in terms of bits go in
88:56 - the binary representations okay you
88:58 - don't look at the numbers now as numbers
89:00 - anymore but they're binary
89:02 - representations
89:03 - here's what i mean
89:05 - instead of looking at 3 i'm going to
89:06 - look at 3 as 0 1 1 which is nothing but
89:09 - the binary representation of 3. again
89:11 - i'm not going to change anything i'm not
89:13 - going to write extra lines of code to
89:14 - convert this this is just how it is
89:16 - stored in memory
89:18 - so we're going to write 3 as 0 1 1 2 as
89:20 - 0 1 0 and 4 as 1 0
89:23 - and i've written this for all of the
89:24 - numbers
89:25 - now what i'm going to do is something
89:27 - very interesting all right something
89:29 - super super sneaky i'm going to write
89:32 - answer over here and we're going to
89:33 - start iterating now if you realize one
89:36 - thing
89:37 - the majority element is the number which
89:40 - exists with more than n by two frequency
89:43 - right
89:44 - what it also means is that its binary
89:46 - representation will exist more than n by
89:48 - two times
89:49 - right is binary representation itself
89:52 - will have a frequency of greater than n
89:53 - by 2.
89:55 - what i can also say is
89:56 - every single one of it bits will also
89:59 - have a frequency greater than n by 2
90:03 - which means that if we narrow down and
90:05 - if we just look at say this particular
90:07 - column
90:08 - we see a lot of zeros
90:09 - what does this mean
90:11 - this means that majority element has
90:13 - zeros in this place
90:15 - and that's because this column is
90:17 - overwhelmingly filled with zeros there
90:20 - is a majority of zero over here and
90:22 - remember we're looking for the majority
90:23 - element all of its bits are in majority
90:26 - so what we're going to do is we're going
90:28 - to iterate over all of these columns one
90:30 - by one and we'll build our answer
90:33 - here's what i mean so we'll look at this
90:35 - column and we'll find out the majority
90:36 - element which is either one or zero
90:39 - right we're not worrying about any
90:41 - frequency tables or hash map right now
90:43 - i've just flipped the problem on its own
90:45 - head and now i'm asking get me the
90:47 - frequency of one and get me the
90:48 - frequency of zero that's it just two
90:50 - variables nothing else
90:52 - so we can see that the frequency of zero
90:54 - is overwhelmingly more than the
90:55 - frequency of ones
90:57 - in fact it is greater than n by two
90:59 - this means that the answer the majority
91:02 - element has a 0 in this particular
91:04 - column's position
91:06 - all right what about this particular
91:08 - column
91:09 - that's right we see that this column is
91:11 - overwhelmingly filled with once which
91:14 - means that the majority element has 1 in
91:16 - this place so we're going to write
91:19 - 1 in this answer location
91:22 - and then we'll iterate over to this
91:23 - column again and what do we see there
91:26 - are lots of zeros not many ones the
91:28 - number of zeros is greater than n by two
91:30 - so we'll just keep zero over here
91:32 - and that is it
91:34 - so at the end of the iteration we see
91:36 - that the answer is zero one zero
91:38 - what is the integer representation of
91:40 - this binary number
91:42 - that's right it's 2. we've found the
91:44 - majority element
91:46 - and look at what we did right
91:48 - we just iterated over all of these
91:50 - columns once and say if the number is
91:52 - represented in 30 bits we'll just go
91:54 - over this 30 times so it's like 30 times
91:57 - and just the time complexity right now
91:59 - all right this will make sense a bit
92:01 - more uh once we look at the code but
92:04 - mostly this is the logic
92:05 - what we are going to do is we are going
92:07 - to iterate over these columns one by one
92:09 - and then for every single column we're
92:11 - going to iterate over the numbers and
92:13 - find whether the bit is one or zero and
92:16 - we'll count the number of ones we'll
92:17 - count the number of zeros and we'll be
92:20 - able to guess whether the answer will
92:21 - have one or zero in this place
92:24 - all right let's go ahead and look at the
92:25 - code
92:26 - so we're going to start off with a
92:28 - couple of variables n is the length of
92:30 - the a which is something we're going to
92:31 - require very soon then we have the
92:33 - answer which is set as 0 and this is the
92:36 - answer which we are going to return at
92:38 - the end
92:39 - right so as you remember we start the
92:40 - answer from 0
92:42 - all right so now what we're going to do
92:44 - is we're going to iterate over the
92:45 - columns one by one so we'll say for b in
92:47 - range of 32 that is
92:49 - for every single bit from 0 1 2 3 all
92:52 - the way up to 32 go ahead and iterate
92:54 - over these columns
92:56 - for each of these columns i want you to
92:58 - keep a track of the number of ones in a
92:59 - column because the number of zeros is
93:01 - simply n minus the number of ones right
93:04 - so we can just keep a track of the
93:05 - number of months to get to a solution
93:08 - and now we'll say you know what go ahead
93:10 - and iterate over all the numbers in a
93:12 - this is an order of n time operation
93:15 - we'll go ahead and write order of n over
93:17 - here
93:18 - now we'll say that you know what if
93:22 - 2 to the power of b this is nothing but
93:25 - 2 to the power of b if 2 to the power of
93:27 - b and num is true
93:29 - that is this entire line means what this
93:32 - lines mean that the current bit b is set
93:35 - in nums if the current bit b is set in
93:38 - num then we can increase the number of
93:40 - ones by one
93:41 - and we'll say that you know what at the
93:43 - end of this iteration if you find that
93:45 - the number of ones is greater than n by
93:48 - two that is there are overwhelmingly a
93:50 - number of ones inside of this column
93:52 - we'll go ahead and make this column of 1
93:55 - as well so go ahead and set this bit
93:58 - 1 inside of the answer we can also write
94:00 - this as
94:01 - this or operation and we can write it as
94:04 - plus it's the same either way
94:06 - anyways once we're done with all of
94:08 - those columns we would have built our
94:09 - answer one by one and we'll have the
94:12 - answer returned at the end
94:14 - so we'll go ahead and test this
94:15 - hang some of this
94:21 - meanwhile let's talk about the
94:22 - complexity analysis the space taken is
94:24 - order of one since we only ever store a
94:26 - couple of variables and the time
94:27 - complexity is order of n times log w now
94:31 - i know this log w seems a bit off since
94:33 - we're just doing uh
94:35 - you know 32 total uh
94:38 - iterations over for the columns but we
94:41 - have to put this log of w because
94:44 - this 32 is not guaranteed right they can
94:46 - be numbers which are huge which are not
94:48 - stored in 30 or 32 bits they may take 50
94:51 - bits or 100 bits or 1 000 bits whatever
94:53 - that is so we'll just say log of w
94:56 - as the log of the word size
94:58 - so in this case integers had a size of
95:01 - like 10 to the power 9 which is
95:02 - approximately 2 to the power 30 so we
95:04 - took 30 times n iterations
95:07 - right so it's order of n times log w
95:10 - again i know this is not the most
95:12 - optimal the time complexity can be order
95:14 - of n and space complexity can be order
95:16 - of one with the boy or more algorithm
95:18 - however this is an algorithm that you
95:20 - can come up with even during an
95:21 - interview and the thing we realized and
95:24 - the central observation that helped us
95:25 - solve this problem was that whenever the
95:28 - space constraint is so high whenever the
95:30 - space constraint is very very hard
95:32 - and we are working with these integers
95:34 - and there seems to be no other way out
95:37 - we have to think in terms of bits
95:40 - that is the central us is the central
95:43 - observation in getting a solution for
95:45 - this problem this will not only help you
95:47 - for this problem but other problems as
95:49 - well so keep this idea in mind for later
95:52 - all right anyways this is it for
95:54 - solution to the problem majority element
95:57 - hello everybody and welcome back let's
96:00 - talk about the problem gas station
96:03 - all right here's the problem setup we're
96:05 - given n gas stations in total which lie
96:07 - along a circular route each of them has
96:10 - a of i amount of gas present
96:13 - and to travel from station i to station
96:15 - i plus 1 there is some cost associated
96:18 - with it which is given by the b of i
96:20 - so one quick thing to note is that a of
96:22 - i and b of five are two elements from
96:25 - the arrays a and b both of the size n
96:27 - all right the goal of this problem is to
96:29 - find the earliest station in terms of
96:31 - the indices from where we can travel
96:34 - around the entire circuit so basically
96:36 - you start from a particular index i
96:38 - which is the lowest possible index and
96:41 - that index is such that you can start
96:42 - from i and you can make a journey
96:44 - and go back to i
96:46 - right and we have to return minus 1 if
96:48 - it's not possible
96:50 - let's go ahead and take a look at an
96:51 - example assume this is an example given
96:53 - in the question itself and the answer to
96:55 - this example is the index four all right
96:58 - so index four is an index from where you
97:01 - can go ahead and do an entire circular
97:03 - route and come back at index four let's
97:06 - try to verify this and we'll work around
97:08 - with the problem setup so that we
97:09 - understand what's going on better
97:11 - all right so when we're in the station
97:13 - for when we started the station 4 we
97:15 - have gas 7 and cost 1. what does that
97:18 - mean
97:19 - that means that at station 4 we start
97:20 - from an empty tank and we go ahead and
97:22 - fill in seven units of gas
97:24 - right
97:25 - and now cost 1 says that to travel from
97:28 - station 4 to station 0 remember this is
97:30 - a circular route to travel from station
97:33 - 4 to station 0 is going to take one unit
97:36 - of cost
97:37 - right so it's going to take one amount
97:39 - of gas from it which means that the
97:41 - current amount of gas we have still
97:43 - remaining is going to be 6.
97:46 - so we have we are starting from the
97:48 - station port and once we reach the
97:50 - station zero we still have six units of
97:52 - gas remaining so when we reach the
97:54 - station zero what we'll do is we'll fill
97:56 - up the tank with three units of gas
97:57 - again so that brings up to nine units
98:00 - and then we have to spend four more
98:02 - units of gas again to travel to the next
98:04 - station
98:05 - so we had six plus three minus four
98:07 - total amount of gas now
98:09 - which gives us five
98:11 - right so at station zero we have five
98:13 - units of gas in our tank all right what
98:16 - happens when we go to station one
98:18 - we'll do five plus five minus two five
98:20 - is the current amount of tank we have
98:22 - five is the amount of gas we get on the
98:24 - next station and we have to subtract two
98:26 - as the cost so five plus five minus 2
98:29 - gives us 8.
98:30 - similarly what happens when we go to the
98:32 - station number 2
98:34 - we do 8 plus 2 minus 1 giving us 9.
98:37 - and then what about station 3 we do 9
98:40 - plus 1 minus 9 giving us 1.
98:43 - what next
98:45 - well now we can go back to the station
98:47 - four this is the station we started off
98:49 - from and we went ahead and we did a
98:52 - complete circular loop and we reached
98:54 - back at the same station station four is
98:56 - the lowest possible station that we
98:58 - could have started from that resulted in
99:00 - a circular route
99:02 - so four is the final answer for this
99:04 - test case now how do we think about the
99:06 - solution well the brute force solution
99:08 - says that for every single index you
99:10 - know iterate over the array go for every
99:12 - single index and for every single index
99:15 - run a simulation
99:17 - right so that simulation is going to
99:18 - take order of end time as we just saw
99:20 - and we have to do this for every single
99:21 - index that means that we are looking at
99:23 - a total of order of n square amount of
99:25 - time
99:26 - and perhaps order of one space because
99:28 - we don't really store anything than a
99:29 - current variable right so we need to
99:31 - think about an optimization
99:33 - now before we jump into the optimization
99:35 - which by the way is going to be super
99:36 - simple i have to mention one trick which
99:39 - i learned before
99:40 - this trick has helped me out a lot in
99:42 - questions where there is like a circular
99:44 - route or whenever we have to go in a
99:46 - circular direction
99:48 - and that trick is to simply take this
99:50 - array and copy paste it
99:53 - all right so what i've done is i've
99:55 - copied the array the first part of the
99:57 - area first half of the array right now
99:59 - is the initial thing and the second half
100:01 - is just a copy paste of it all right and
100:03 - i've also mentioned the original indices
100:05 - on the top of them so the index 5 is
100:08 - actually the index 0.
100:10 - now how does this help us
100:12 - well think about it this way because we
100:14 - are going on on a circular route if we
100:16 - start from the index 0 we want to end at
100:18 - the index 0 again
100:20 - but because circular things are a bit
100:22 - more complicated to take care of what we
100:24 - have simply done is we have expanded
100:26 - that out and so now we are going to say
100:29 - when you start from index 0 go ahead and
100:31 - figure out if you can end at index 5
100:33 - instead
100:34 - if you start from index 1 see if you can
100:36 - end at index 6 because index 6 is
100:38 - nothing but an index 1.
100:40 - similarly if you go to index 4 we just
100:43 - want to ensure that you end at index 9
100:45 - because 9 acts as 4.
100:47 - so all i've done is simply taken the
100:49 - initial array doubled it so in a way we
100:52 - have avoided the circular thingy problem
100:55 - this makes the solution a lot simpler
100:57 - because the only thing we have left to
100:58 - do now is to iterate over that and that
101:01 - is it
101:02 - all right let me walk you through the
101:03 - solution it'll make a lot more sense
101:05 - so let's go ahead and say that uh 0 is
101:08 - the starting index
101:10 - 0 is the station i'm going to assume
101:12 - which is going to lead me to the station
101:13 - number 5. all right i'm going to assume
101:15 - that so let's go ahead and mark this
101:17 - this is our starting index
101:19 - now this is our starting index we start
101:22 - off with the empty gas tank what do we
101:24 - do we fill in three units of gas and the
101:26 - cost is well the cost is four
101:29 - which means that the current is uh minus
101:30 - one well that is not so good we have
101:34 - three units of gas with us and to go to
101:36 - the next station we require four
101:38 - which means that we don't have enough
101:40 - gas to go to the next station
101:43 - here's a if condition for you we'll ask
101:45 - the question hey is the current lesser
101:47 - than 0
101:48 - because as soon as the current becomes
101:50 - lesser than 0 let's go ahead and make a
101:52 - full reset let's go ahead and say that
101:54 - you know what this station will not work
101:56 - out for us this question this station is
101:58 - uh is going to give us a negative value
102:00 - we don't want that
102:01 - so we are going to say that if the
102:03 - station is going to give you a negative
102:04 - value just set the current to zero let's
102:07 - just go ahead and restart everything
102:08 - from scratch and so in this case i'm
102:10 - going to go ahead and initialize and i'm
102:12 - going to reset the start to
102:14 - i plus one
102:16 - so we simply move on to the index one as
102:18 - the starting position as you can see by
102:19 - the yellow circle moving
102:21 - now at the index one now at the station
102:24 - one we again ask the same questions we
102:26 - start off with an empty gas tank the
102:27 - current is zero as you can see from the
102:29 - if condition previously
102:31 - we start off with an empty gas tank now
102:32 - we fill five units of gas
102:35 - go to the next station we require two so
102:36 - the remaining is three
102:38 - pretty simple
102:39 - so now we have three units of gas
102:41 - remaining that is we have three extra
102:43 - units of gas and now we can go to the
102:44 - next station with three more units of
102:46 - gas than we had previously
102:49 - so three plus two now becomes five which
102:51 - means that once i reach the next station
102:53 - i'm going to fill in two units of gas
102:55 - which brings me up to five units then
102:57 - i'm going to spend one unit of gas so it
102:59 - brings me down to a total of four units
103:01 - of gas
103:02 - all right pretty simple still greater
103:04 - than zero which means that i can i still
103:06 - have four units of gas surplus i have
103:09 - these extra four units of gas just lying
103:11 - around just in case
103:12 - so now i'm going to go ahead and go to
103:14 - the index
103:15 - three
103:16 - so as soon as i go to index three i see
103:18 - that i have four units of gas i fill in
103:20 - with one bringing me to a total of five
103:24 - now i have five units of gas and the
103:25 - cost to go to the next station is nine
103:28 - which means that the current comes out
103:30 - to minus four because five minus nine is
103:32 - minus four
103:33 - which means that this will not work out
103:36 - either
103:38 - we assume that the starting index of one
103:40 - will work out for us but it did not work
103:42 - out for us
103:43 - so what we need to do is we need to go
103:45 - ahead and reset the start to i plus one
103:48 - right we're gonna reset everything we're
103:50 - gonna say you know what screw the index
103:52 - one screw the index zero both of them
103:54 - that did not work out let's just go
103:56 - ahead and restart all of our
103:58 - computations from the index four so
104:00 - we'll restart the current to zero and
104:03 - set the start to i plus one so we start
104:05 - off from 4
104:07 - now at this point i want you to pause
104:09 - the video and figure out something
104:11 - missing figure out something that is
104:12 - going wrong all of my explanation up
104:14 - till now has been correct but there is
104:15 - one assumption
104:17 - that is wrong well at least that should
104:19 - look wrong to you
104:21 - that's the assumption over here look at
104:23 - this
104:23 - earlier we considered the index 0 then
104:26 - we considered the index 1 as the
104:27 - starting position and we jumped to index
104:30 - 4 directly we never even considered
104:33 - 2 and 3.
104:34 - so now the question is well why don't we
104:36 - want to consider the indexes 2 and 3
104:39 - what's wrong with them why not consider
104:41 - both of them
104:42 - right and so this is where the
104:44 - optimization comes into play this is the
104:46 - most important part right we we don't
104:49 - want to go back otherwise it'll just
104:50 - become like we're going to start from
104:52 - every single index and that'll become n
104:53 - square that's pain
104:55 - but because we have this logic of
104:57 - starting from start equals to i plus 1
105:00 - we were able to jump a couple of indices
105:03 - now again this begs the question hey why
105:05 - not consider two and three
105:08 - here's the thing here's the very very
105:10 - important things is my new detail which
105:12 - matters a lot
105:13 - look at the if condition on the left
105:15 - hand side the condition says that if
105:17 - current is less than 0 then go ahead and
105:19 - make a restart
105:21 - in other words i can say that car only
105:23 - passes a station when the current is
105:25 - greater than equals to 0.
105:28 - what this also means is that
105:30 - as it passes through more and more
105:32 - stations it keeps on collecting more and
105:34 - more fuel that is
105:36 - in a one particular station it is going
105:38 - to collect at least zero amounts of fuel
105:41 - if not more so it might be some positive
105:43 - amount of fuel it's going to accumulate
105:45 - every single station it passes through
105:47 - and if it does not pass through well it
105:49 - goes to the if condition and gets reset
105:50 - it
105:52 - so now we know that car only passes when
105:55 - current greater than equals to 0 and
105:56 - it's going to accumulate more and more
105:58 - field
105:59 - which means that starting from one did
106:01 - not give me an answer right starting
106:03 - from one gave us a negative value of
106:05 - four
106:06 - but if you start from two you'll get
106:08 - even a much more worse value in fact go
106:10 - ahead and try this out yourself if you
106:12 - start off from two you'll get gas two
106:14 - cost one giving a current of one which
106:16 - is already lesser than the current of
106:17 - four and now you have one
106:20 - of current you add it with a gas of one
106:22 - and remove cost nine basically now
106:25 - giving you minus seven
106:26 - so if you start off from two you are
106:28 - going to end up much worse
106:30 - you're going to end up with the current
106:32 - value of negative seven although it does
106:33 - not mean anything different but it's
106:35 - just extra computation
106:38 - starting from one was the best possible
106:39 - option because it was the earliest we
106:41 - could have started
106:43 - and we could have collected a lot more
106:45 - fuel if we started off from one instead
106:47 - of two
106:47 - but hey even one did not work out so how
106:50 - in the world will do work out
106:52 - all right i think that's enough
106:54 - explanation for why we do start equals
106:56 - to i plus one
106:57 - and uh so let's go ahead and do the
106:58 - computation we start from the index four
107:01 - we start from the station four now and
107:03 - we have gas seven cost one
107:05 - what does that mean we do plus 7 minus 1
107:08 - giving us 6.
107:09 - now we'll go on to the next index with
107:11 - the
107:12 - uh
107:13 - capacity of well of course the tank
107:15 - capacity is infinite but now we have the
107:16 - current s6 and we're going to add it to
107:18 - the gas and remove the cost from it so
107:21 - we'll do six plus three
107:22 - minus four
107:24 - notice one more thing that we're doing
107:26 - remember that we copy pasted the array
107:29 - once right if you can see the nicest
107:31 - five six seven eight are nothing but a
107:33 - copy of one zero one two three 4
107:36 - and of course you can compare the gas
107:37 - and the cost values as well
107:39 - now all the reason why we did that was
107:41 - so that we could simply iterate over it
107:43 - and get our life get our job done make
107:45 - life easy and it is going to make our
107:47 - life easy because now it's simply going
107:49 - to continue with the same logic we're
107:51 - still going to keep that f condition in
107:52 - mind and we're going to continue forward
107:55 - all right so now we are at the index 5
107:57 - where the station 5 which is nothing but
107:59 - the station 0
108:00 - and currently we have 5 units of gas
108:03 - what happens when you go to the next one
108:05 - we do 5 plus 5 minus 2 giving us
108:08 - 8 then we do 8 plus 2 minus 1 giving us
108:12 - 9
108:13 - then we do 9 plus 1 minus 9
108:16 - giving us one
108:18 - and finally we'll do one plus seven oh
108:20 - wait
108:21 - as soon as we go to the next station i
108:24 - want you to realize something
108:26 - look at that we have reached the station
108:28 - number four
108:29 - and look at the station that was marked
108:31 - earlier the number station 4 was marked
108:34 - earlier which means that we have gone
108:35 - through an entire loop
108:37 - again the station number looks like it's
108:39 - 9 but it's actually 4 behind the scenes
108:42 - right so now we are again at the index 4
108:45 - we are again at the station 4. what does
108:48 - that mean
108:49 - what does that mean what the initial
108:51 - question was
108:52 - the question was find the initial index
108:54 - which will find the earliest index such
108:57 - that you can go and loop around once
108:59 - and so we have found that index and so
109:01 - what we can do is we can say if i equals
109:04 - to equals to start plus n n is the
109:07 - length of the array which is 5 in this
109:08 - case so if 9 equals to equals to 4 plus
109:12 - 5
109:13 - go ahead and return 4
109:15 - perfect right as you can recall the
109:17 - earlier answer was 4 as well and the
109:19 - current answer we're going to return is
109:20 - also 4
109:22 - pretty amazing right we did nothing
109:24 - special just two if statements i promise
109:26 - you that is literally it just these two
109:29 - conditions and looping over all these
109:30 - values that is it nothing complicated no
109:33 - special proofs or mathematic or
109:35 - arithmetic you need to worry about
109:36 - all right let's go ahead and code this
109:38 - up now so what we'll do is figure out n
109:40 - which is the length of a basically
109:42 - saying that these are the number of gas
109:44 - stations with us
109:46 - we're going to start the current and the
109:47 - starting both from zero as i mentioned
109:50 - we're going to assume the start as zero
109:52 - this is our starting position assuming
109:54 - that this start will give us the answer
109:56 - at the end
109:57 - we also have current which is going to
109:59 - keep a track of the current value of the
110:01 - gas tank
110:02 - now we are going to iterate for i and g
110:04 - comma c in
110:06 - a star 2 b star 2 okay just a quick
110:09 - aside what this means is simply that i'm
110:11 - going to take this array a and i'm going
110:12 - to copy paste it once again
110:14 - so a is nothing but twice of a it's just
110:16 - a plus a right is the same as a plus a
110:20 - all right sorry
110:22 - and then we do uh b plus b or b times
110:24 - two same thing we'll zip both of them a
110:27 - is nothing but the gas and b is nothing
110:29 - but the cost and now we're going to
110:31 - enumerate over that
110:33 - so as i mentioned the first if condition
110:35 - is saying that you know what if the
110:36 - current index i
110:38 - is equal to equals to star plus n
110:40 - basically you have seen this station
110:42 - before the station is a loop of the
110:44 - previous start that you've seen if that
110:46 - is the case look at the condition over
110:48 - here if that is the case i've just copy
110:50 - pasted it return start
110:53 - again simple very very simple okay
110:54 - nothing special we're doing it's just
110:56 - simple stuff
110:58 - all right and then we'll go to this
110:59 - statement with says current plus equals
111:01 - to g minus e so what it says is whatever
111:04 - the previous current was now you add it
111:06 - to the certain amount of value of gas
111:09 - right i'm going to say uh
111:11 - this is current plus g
111:13 - minus e all right very simple i'm going
111:16 - to take the previous value in my gas
111:18 - in my gas tank add some additional gas g
111:21 - and remove some cost of
111:23 - moving to the next station
111:26 - and then we'll move on to this if
111:27 - condition over here as i already
111:28 - mentioned again simple copy paste if
111:31 - current is less than zero that is if we
111:34 - have
111:34 - not enough gas to move to the next
111:36 - station well that means that we have to
111:38 - reset
111:39 - the current so the current becomes zero
111:41 - and we have to set the start as i plus
111:44 - one
111:45 - basically we'll say everything including
111:47 - i
111:48 - and everything before i and including i
111:51 - is all useless for us let's just reset
111:54 - the start to i plus one
111:56 - all right so if you notice we are
111:57 - returning the start over here now if you
111:59 - can find an answer you'll be able to
112:01 - return it over here but in case you do
112:03 - not find any such answer in case there
112:05 - is no such possible case
112:08 - where you can take an index and loop
112:10 - around the circuit once and reach by the
112:11 - same index
112:12 - well then you unfortunately have to
112:14 - return -1 saying that you know what i
112:17 - reach the end of this for loop which
112:18 - means that there is no way
112:20 - there's any such possible index
112:23 - all right and i'm speaking let me go
112:24 - ahead and actually show you and test
112:25 - this out
112:27 - all right cool this works out and we'll
112:28 - go ahead and submit this
112:35 - and there we go our answer is correct
112:38 - all right so this is it for the solution
112:40 - to the problem gas station
112:42 - these visualizations take me a lot of
112:44 - time to make and if you appreciate them
112:46 - if you appreciate the high quality of my
112:49 - visuals explanations and the solution
112:51 - let me know in the comment section down
112:52 - below and give this video a thumbs up
112:54 - anyways
112:56 - this is it for this video solution and
112:58 - as always thank you so much for watching