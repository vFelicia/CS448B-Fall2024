00:00 - Hi, welcome to my free Java video course.
Lesson One. My name is Marcos B. I'm a software
00:16 - Craftsman with 14 years of experience in Java.
My goal is to teach you Java in the easiest
00:23 - possible way. Okay, we will start with a briefing,
which is basically a lot of theory in the
00:29 - beginning. Second, we will do a practice session,
where we will actually write our first Java
00:36 - program. Finally, we will do a short key briefing,
where we will recap what we learned so far,
00:43 - and add some more theory were needed. In this
first lesson, I'm going to introduce you to
00:52 - the following 15 Java key words or concepts,
which you will need to understand your first
00:58 - coding session later on. Please note, especially
if you already know some programming, I really
01:04 - focus on not using any term before I officially
introduced it, getting a keyword explained
01:11 - using concepts I don't know, something that
always ticks me off in classes, so I aim to
01:17 - do better in this aspect. Therefore, intentionally,
I might explain a few things, not 100% academically
01:25 - correct in the beginning. When necessary,
I will add the academically correct later
01:31 - on. As stated earlier, my goal is to teach
you Java in the easiest possible way. If I
01:40 - can achieve this by looking just a bit stupid,
that's fine with me. Last but not least, this
01:47 - is really only a first introduction. It's
okay if you don't directly grasp everything.
01:53 - We will go in more detail and recap the important
parts later on.
02:00 - A package or better package structure is like
the file structure on your computer. It helps
02:10 - to organize the different files of your program.
The top root folder of a package structure
02:17 - is usually the organization's domain name
in a reverse order. In my case, that would
02:25 - become Marco spiele. For example, if you don't
have a domain for the program you're writing,
02:32 - it's okay to invent your own domain name,
but make sure it's a unique name. The reason
02:39 - for this is that the name of a program file
is actually a combination of its own name,
02:44 - plus the full package structure of the package.
It recites and there are millions of other
02:51 - programs out there, and chances are high that
someone else has already used exactly the
02:56 - same program file name before you. As Java
code is heavily shared worldwide, a strategy
03:04 - was needed to come up with a unique name to
prevent name clashes. Each domain names can
03:11 - technically exist only once. Therefore, using
a domain name as the prefix for your package
03:19 - name as the default. Think of the package
name, like an absolute file name of your program
03:25 - file. Using your package name is optional,
but I highly recommend you to do so even for
03:35 - the simplest program. When used, the package
must be declared on the first line of your
03:40 - Java program. The package name is starting
with a domain name in reverse order. As stated
03:50 - before. The reason for this is that the package
name from left to right gets more and more
03:56 - specific. Using lowercase and singular for
package names is the recommended default.
04:03 - Last but not least, the package name also
serves as a high level description of all
04:10 - the Program Files related to a certain topic.
code written for less than one of this Java
04:16 - course would end up in a package called con
Marco spiele. java course lesson one for example.
04:24 - Please choose package names for fully. It's
not just a stupid name. The package names
04:31 - reflect the internal structure of your entire
program. Last but not least, I recommend you
04:37 - to choose package names related to your specific
business topic. Rather than just using technical
04:44 - terms. Good names are key. To simplify programming.
Every program file will reuse existing code.
04:56 - To do so you have to import the code into
your program file. In our program file, the
05:03 - import statement or import statements will
follow directly after the package declaration.
05:09 - Here you can also see how the package name
must be included in the import statement,
05:15 - as it is actually part of the programs falling.
You may import specific files, or all files
05:24 - of a certain package using the star symbol.
Besides regular import statements, they are
05:33 - also static imports, which we will cover in
detail at a later time. A simple program can
05:41 - easily consist of 1000s if not 10s of 1000s
of code lines, it's very easy to get lost
05:47 - in such a big pile of information. Therefore,
it's really important to impose a structure
05:53 - on the program code besides using packages,
as explained before, in Java, the program
06:00 - code is classified into different units of
code. Such a unit we call a class.
06:09 - The programmer is the one who may decide how
to name and structure packages, as well as
06:17 - classes. One aspect of Java is to improve
cooperation between business clients and programmers.
06:23 - The client is able or should be able to tell
what he wants, the program is able or should
06:30 - be able to know how this can be expressed
in code. The closer this code is related to
06:36 - the business easier, the cooperation between
programmers and business people will be forming
06:43 - a common language related to the business
and use throughout the code is therefore of
06:48 - utmost importance. By convention, the name
of a class in Java should be a noun, starting
06:56 - with a capital letter. opening curly brace
defines the beginning of the definition of
07:02 - the class, where we will later write all our
code related to a car. The closing curly brace
07:11 - defines the end of the definition of the class,
a class should be focused on only one topic.
07:18 - As a recommendation, keep your classes as
small as possible to improve reusability as
07:24 - well as readability. A class usually consists
of one or more methods. As the name implies,
07:36 - it defines a method of how to achieve a certain
thing, like a method double could be defined
07:44 - to calculate the double amount of an input
given methods are sometimes also called functions.
07:50 - For now, one at 100%. Academically correct,
it's okay to use the terms interchangeably.
07:57 - By convention, the name of a method should
be a verb that best describes the purpose
08:03 - of the method. Methods define the actions
you can execute on classes, so they further
08:10 - refine the structure of our program code.
methods can do pretty much everything for
08:16 - us. methods can operate not only in numbers,
but also on text, colors, sounds, you name
08:23 - it. A book would have chapters, every chapter
would have paragraphs and every paragraph
08:31 - would have sentences structuring your Java
code in a similar way. Packaging name would
08:38 - be like a chapter, a class would be like a
paragraph, and a method would be like a sentence.
08:45 - For example, methods internally can call other
methods, which will then form a hierarchy
08:51 - of methods calling each other. As a programmer.
It's up to you of how you want to structure
08:59 - your code, how long you want a method to be,
which method will use which sub methods. I
09:06 - would recommend however, to always think of
the current level of abstraction, just as
09:11 - if you would write a book. For example, a
method prepared dinner could internally call
09:17 - a method prepare appetizer, followed by a
method called prepare main course, followed
09:25 - again by a method called prepper. Desert.
The prepare main course method for instance,
09:31 - could internally call a method called boil
water. Mixing the levels of abstraction work
09:39 - for example mean to have a method prepare
dinner, internally calling a method prepare
09:44 - appetizer 30 followed by a method called warm
water without having a proper main course
09:52 - method surrounding it. Coming up with clean
structure is key in programming. Make your
10:00 - Code speak to you. Today with problems of
millions of lines of code. The most important
10:06 - part of programming is structure and readability
for humans. As soon as you start to lose focus
10:13 - and have difficulties in understanding what
a program does, chances are high you will
10:18 - misunderstand some concept of the code. And
so you might introduce an error. Keep your
10:25 - methods as short as possible. As a rule of
thumb, I would recommend 123 lines with 20
10:32 - lines as a maximum.
10:38 - The definition of a method follows a similar
concept of that of a class. First, we define
10:44 - the name of the method. As stated before,
he was a word and start with a lowercase letter.
10:51 - The name of a method is followed by an opening
and closing bracket. This is the place where
10:57 - we mainly find the names of zero to an unlimited
amount of input fields. When using the method
11:03 - later on, you will need to choose a value
for those values. These values are called
11:09 - method parameters. In order to further improve
the structure and readability of your code,
11:15 - I recommend you to use as few as possible
method parameters, with three to five parameters
11:22 - as a maximum, everything more than that will
not be readable. The opening curly brace defines
11:30 - the beginning of the method definition. closing
curly brace defines the end of the method
11:37 - definition. Later, we will define the actual
code of the method that will go into the space
11:44 - between the curly braces. As the name implies,
a variable is a variable value, a placeholder
11:56 - for a value that you can set. The value of
a variable may change while the program is
12:02 - running. For example, when the third value
is calculated over the lifetime of your program.
12:10 - variables can be used as input or output values
of methods. For example, variables can be
12:16 - of different data types, like numbers or text.
data types we will cover in detail at a later
12:23 - time. Just for example, possible variable
names for a car could be my old car, my pushy,
12:33 - or mom's car. There are different types of
variables, like instance variables, static
12:42 - variables, local variables, parameters or
arguments, we will cover the differences in
12:48 - a later session.
12:54 - Public is an access modifier that defines
that any class from any package may use the
13:00 - class or method with public access modifier.
Besides public, there are also other access
13:06 - modifiers like private default or protected.
Here we are only skimming a topic. In a later
13:12 - session we are going to cover access modifiers
in detail. Here you can see the access modifier
13:22 - public in action. The class as well as the
method now posts have public access defined.
13:32 - For every method, you actually have to define
our return value. Ironically, even when you
13:38 - don't want to return any value at all. In
this case, you will send void as return value
13:44 - of the method to explicitly define that the
method will not return a value. Besides void,
13:51 - a method can actually return any kind of data
type. Here you can see the void return type
13:58 - in action or drive method suppose to make
the car drive which is expected to execute
14:05 - an action but not to return any value to us.
As a rule of thumb, it's good design to differentiate
14:12 - between query methods, which will return a
value but do not alter the state and command
14:19 - methods which offer the state but do not return
a value. In respect to this best practice
14:25 - rule. Drive is a command method and therefore
does not return any value. The Add symbol
14:37 - indicates an annotation. We will cover annotations
in detail in a later session. Just for now,
14:44 - I want you to know that with ADD test, we
indicate that a given method will be used
14:50 - as a test. When a class a variable or method
name consists of more than one word In Java,
15:00 - you use an uppercase letter to indicate the
beginning of a new word. This is called camel
15:07 - case, as the ups and downs of upper and lowercase
letters look like camel humps. In other programming
15:18 - languages, and underscore is used to separate
two words from each other inside a variable
15:24 - name. In Java, however, camel case is used
instead. To indicate the end of a sentence,
15:33 - we use a thought in English sentences. In
Java, however, the DOT has a completely different
15:39 - meaning. The dot between the variable car
and the method drive indicates that we want
15:47 - to execute or we will alter. Alternatively,
say call the method drive on car. As the.is
15:56 - already used to indicate a method being called
a colon is used to indicate the end of a statement
16:02 - in Java. Here we can see an example of a test
method that is expected to test that our car
16:10 - drives. The method drive is executed on car
with the value of 100. Colin says I want this
16:19 - to be executed period. I talked about classes
already. I said that a class is a way of structuring
16:30 - code in Java, a unit of code. This is perfectly
true. However, it's only part of the magic.
16:37 - A class is like a template, like a definition
of what you want the class to do for you later
16:43 - on when the program is running. The class
car for example, defines the behavior of a
16:49 - car. However, when your program is running,
we say at runtime, there will usually be a
16:56 - number of cars, each car may have its own
unique set of values, one car might leak oil,
17:04 - so the value of oil could drop to zero while
the program is running. So our classes like
17:10 - the human DNA, a definition of how something
should be created when the program is running.
17:20 - When a Java program is running, it would usually
create a certain number of objects that will
17:25 - exist as a set of values in the computer's
memory. And those values might change while
17:31 - the program is running.
17:38 - Each program language for certain concept,
Java is an object oriented language. Everything
17:44 - is focused around objects in Java. In Java
writing classes is a way of defining a model,
17:51 - which focuses on necessary aspects to solve
a specific problem. It needs the brain powers
17:57 - of a clever Java programmer to fully understand
the problem and to extract a theoretical model
18:03 - from it and transfer this model into classes.
The skills of the programmer will have high
18:10 - impact on how precisely a problem is transferred
into a class model. Simply speaking, the more
18:18 - accurate this is done, the less code has to
be written and maintained. The fossils or
18:23 - program will run, the less errors it will
have. The power of Java is to be able to define
18:30 - an execute table model, like a virtual machine
on your computer. With concepts and names
18:37 - taken from the real world, which heavily improves
the communication of the programmer, and the
18:43 - business client, programmer and business client
can both talk of a car. While the one is talking
18:49 - of a real car, and the other of the representation
of this car on the computer, they will understand
18:56 - each other. Here we see a simplified definition
of a class car. Now imagine a game where each
19:07 - player creates a car when the game starts.
The program in this example, might create
19:13 - three different cars at runtime. Now I talked
about classes and objects that will be created
19:23 - from those classes. But how will these objects
be actually created? We will need a method
19:30 - that will create the objects for us. This
is a very special method. It is called on
19:36 - a class and we'll create an object each time
we call this method. But as soon as the object
19:44 - exists, we cannot call this method anymore.
The special method is called a constructor,
19:50 - as it is used to construct objects from class
files 
19:58 - to create a new object of time car, you write
new car. For example, the constructor in this
20:05 - case, just like a method is given two different
numbers, one for the age of the car and one
20:12 - for the maximum speed. In our example, when
the program is running and executes this line,
20:19 - a new object will be created in your computer's
memory. We will, we talked about variables
20:27 - already. However, before we can use a variable,
we need to define it beforehand. Call my Porsche
20:37 - Colin is an example of a variable declaration,
we declare the variable which we called my
20:44 - portion of the type car. Now that we have
a variable declared, we have to allocate the
20:53 - object we created a variable declaration,
object creation, and allocation can all be
21:01 - done in one single line. So this line reads
as when the program is running, and when this
21:07 - line of code is executed, create an object
of type car with first of all you won, and
21:13 - a second volume of 320. Then create a variable
of type car and give it a name my portion.
21:21 - Last but not least, assign the car object
to the variable named my portion. After this
21:27 - line, whenever we use my portion, we actually
referenced the object created in memory. Also,
21:35 - you might notice when looking at this line
of code, we put two values into the constructor
21:40 - of car. But without looking into the code
of the class car, we wouldn't even know what
21:46 - their meaning actually is. This is one reason
why you should try to limit the number of
21:52 - variables used in a method as well as in a
constructor, the less the better.
21:58 - In session, to have this free Java video course,
we're going to write our first Java program.
22:06 - When we write code, we actually start by writing
a program, which is actually testing the program
22:12 - or class we are going to write. We do this
for two reasons. First, the test forces us
22:19 - to properly think our idea through which will
improve our code a lot. Second, the main effort
22:27 - in the lifecycle of a program is actually
not the first time effort of writing the program
22:32 - code, but to maintain the program, like extending
or improving the functionality or fixing arrows
22:39 - called bugs in your code. Whenever you write
code, there is a high risk you will introduce
22:46 - defects in your code. When your program is
written once with the help of a test, this
22:52 - test will ensure that whatever happens, your
program will continue to function as designed
23:00 - initially. To recap, in Lesson One of this
free Java video course, I explained the necessary
23:07 - theory to code our first Java program, which
we are going to do in a minute, we are going
23:14 - to use these 15 Java keywords and concepts
described in detail in the prior session.
23:20 - If you haven't done yet, I would recommend
you to start with session one before watching
23:26 - this practice session. Okay, so now I'm in
my development environment. I've created a
23:39 - folder structure of calm Marcos build Java
course, lesson two in a folder called test
23:49 - and also here source main. Java. com Marcos
build Java course lesson two. This is where
23:59 - we will write our tests have already created
the fall person test of Java. This here is
24:07 - where later we will have our actual program.
But okay, so let's start person test. As described
24:18 - in Lesson One, we have to start with a package
declaration. So I write and you see here,
24:25 - I actually get support by my environment,
about the development environment. I'll tell
24:33 - you later. For now just see that it actually
assists you. Actually, when you start learning
24:39 - to program, I would recommend you to start
with a regular text editor because you need
24:47 - to learn all these keywords. And so I guess
it's easier in the beginning. I mean not easier,
24:54 - but it helps you to learn the stuff from scratch.
If you really have To focus and concentrate,
25:01 - and you don't get assistance. But as soon
as you manage all these keywords, as soon
25:08 - as you know all them section environment is
really helpful. Okay, so I use package, and
25:16 - then I have to define it. COMM macros, we'll
see how it assists me again, it already knows
25:26 - the package, because I have here the folder
structure, and the folder structure, and the
25:33 - package declaration in my file actually have
to be the same. Otherwise, this would be an
25:39 - error. So actually, I don't even have to write
it anymore. I can just follow. Okay, so this
25:48 - is my package. And you see, before we have
an underline or red underline, which means
25:55 - something is wrong. Now, oh, editor seems
to be fine with what I wrote so far. Okay,
26:02 - here we are. Later, we'll have imports, as
described in lesson one. But we will add them
26:10 - later. Normally, you start defining your class
first. See, again, I wrote public and see
26:17 - how it's underlined red, so something is missing.
So I say class, and now I have to define the
26:26 - class name is a person test. So I call my
test person test, it's a test for our first
26:37 - program, which is the class person. Okay,
now I have to add the brackets. When I add
26:46 - the first one, my editor already adds the
second one. Because for every opening bracket,
26:53 - you always need a closing bracket.
26:56 - Okay, so this is the beginning. And this the
end of my person test.
27:03 - Okay,
27:05 - no at the annotation test. So that I define,
I want to write a test. And see, magically,
27:16 - the input appeared. Because my environment
already knows, I want to write a test. The
27:24 - test also, I mean, it's actually a class.
And it even has package. And this is all three
27:32 - unit test. We'll talk much more about j unit
in later lessons. But for now, we just know
27:41 - this is a test magically somehow. Okay, and
we need to test the method. test method will
27:46 - be public. It won't return any value, so it
will be void. And I will give it a name what
27:55 - I want it to do should return hello world.
Hello World is actually like a running gag
28:04 - of programmers. Someone I don't know who once
started. That first program you write in a
28:14 - language should return hello world. So we
do that to write a test. For my first HelloWorld
28:26 - program, I expect my person to return hello
world to me. And I'm going to test this. We
28:34 - haven't written any actual code for person.
But we're starting reverse. So we're starting
28:43 - with the test, as explained before. So now
I can just assume I was done. You see, it's
28:50 - red, which means we don't have a class person
yet. But this doesn't matter. Now for this
28:55 - person, I need a variable name. And as my
name is markers, just for fun, I call it person
29:01 - I call the person Marcus. Okay, now I have
to create person markers. Remember, this was
29:11 - calling the constructor creating the object.
And so this is creating the object of person
29:19 - from the type from the class person. And the
equal sign assigns that object which is created
29:28 - in the memory of RPC to the variable, the
reference variable person because this is
29:36 - a reference that we can later on use referencing
the person.
29:44 - Okay.
29:46 - Now this is read, but we'll take care of this
later. We just continue. Okay, so assuming
29:54 - we were done, what do we want? We want to
test something And testing, we say we want
30:03 - to assert something, we want to assert that
a method we're going to write is returning
30:11 - the hello world for us. So, we want to compare
if our expectation is equal to what the method
30:21 - is going to return. So we say assert equals,
this also is starting as red, because we will
30:29 - have to import more stuff. But for now, we
just take it, I use this was again metric
30:38 - I add one quotation mark, and my environment
already adds a closing quotation marks. This
30:47 - is what we call a string. And I say hello
world, because I want my person to return
30:55 - HelloWorld for me, so, the first part here
is the expected return Well, you know, I add
31:03 - a comma. And now I have to add what is going
to be tested Marcus dot for calling a method
31:16 - Hello, world. So on the object, Marcos of
class person, I want to call a method, hello
31:30 - world, with no parameters given and what is
returned here, I want to assert that it equals
31:44 - to hello world. Now, this is not going to
work. Because we still have some red stuff.
31:53 - For example, here, we don't have actually
written the class. But here we will let our
32:01 - environment help us, you see. Now I just have
to say create a class person. Sorry, again,
32:13 - create class person. And here, it already
asked us destination package, create class
32:22 - person. COMM walkersville. java course lesson
two. Okay, sounds good. Because our test,
32:30 - and the actual class of the test will be in
the same package. This actually helps us a
32:37 - lot. But more about this later on. I say,
okay, and magic magically, or first class
32:46 - got created. You see the package, and the
class. This is actually kind of the smallest
32:54 - class possible, just with opening and closing
bracket. But it doesn't do anything yet. Okay,
33:02 - but you see, it's not red anymore. So let's
go to from next, assert equals, oh, it wants
33:11 - to import something statically. I said before,
I will later on tell you what means static
33:19 - import. But for now. Just believe me, we have
to import this. This is another import from
33:31 - org j unit. But this time, it's an assert.
And so this is like a method. We import the
33:42 - method assert equals. But, um, don't focus
too much on this. We'll go in more detail
33:49 - later. For now, what is important, we want
to write our first test. So we still need
33:57 - to define a method. And it also tells us cannot
resolve method HelloWorld. Okay, help us please
34:05 - create method HelloWorld. We had enough it
moved the method to the wrong place, but I'll
34:12 - fix that. Of course, we need to have it here.
Okay, no, nothing read anymore. And we can
34:25 - start calling our first test. I say run. And
this actually executed our first test, which
34:37 - again executed our first class that was automatically
written. And here we see we have an error.
34:45 - It tells us a missing return statement. So
I said we want to return a string you see
34:55 - string. But as you see the method is empty.
We don't return anything. So let's fix that
35:01 - fix that return. This is how we say it, we
have to say return. And I just have to type
35:10 - Hello, world. exactly as I was expecting it,
I get the column to say yes to it return hello
35:17 - world. Okay, now we switch over to the test.
And I'll execute the test again. And that's
35:30 - green, all tests passed. This is our first
test. And it worked on in our first class,
35:40 - Tara. Okay. Thank you. That said, lesson three
debriefing. For debriefing, we will go back
35:53 - to our development environment, and have a
look what we learned so far. Okay, now we're
36:02 - back in our development environment. And now
let's repeat what we learned so far. The first
36:09 - line of our program is the package declaration.
It must be unique. And it usually consists
36:21 - of your domain name in reverse order. So in
my case, calm, Marcos, bu Java course, lesson
36:28 - two, and we ended with a color. Actually,
it's not mandatory, it's optional. But please,
36:38 - I really recommend you to use a package name.
Later on, you will probably see why you just
36:45 - need to have some practice. But for now, just
believe me treat this as if it was mandatory.
36:52 - And always define a package name. After the
package declaration, we can have one or more
36:59 - import statements. This just for our lesson,
now I made up I created a new class called
37:07 - name. And this is an A sub package called
lesson three. Actually, all classes that are
37:16 - in the same package. So person has an a package
called macro spiel Java course lesson two,
37:23 - for all classes that are in the exactly same
package, lesson two at the end, we don't need
37:30 - to import them, Java will find them automatically.
But here I made this lesson three. So if we
37:39 - want to use the name class that I just wrote,
we have to import it. Okay. Next thing is
37:49 - class definition public class person. And
with these brackets, that says the class begins,
37:57 - this says the class ends. Public means all
other classes, for example, my new class name,
38:07 - in any package can see the class person. What
this can see means is still a bit work. For
38:16 - now, just take it as it is, I don't expect
you to fully understand it yet. This will
38:22 - need some practice. And here for now, some
new stuff, I added the class that I defined
38:33 - name, and I made it private, which is also
best practice to have we call this a reference
38:40 - variable, because it is a reference to later
on an object of type name. And I made it private,
38:48 - which means other objects that get created
will not be able to see. See again, I say
38:56 - See, or access this field here directly. If
they want to use it, they have to go using
39:07 - this method I also just created this one is
public and it returns personally. So when
39:15 - they call person dot name, the method you
can give it any name I just call it salt,
39:23 - but you could also call it I don't know.
39:30 - Return the name. So this can be anything um,
and it will return the person's name. So here
39:43 - again we see return, which means I want this
to be returned to whoever calls that method
39:50 - and the colon which means do it execute it.
Okay. What else did we learn? We learned that
40:01 - this stream, and that having a class, returning
HelloWorld is like a running gag in programming
40:11 - for the first program that you do. So this
is why I made class person return hello world.
40:18 - I mean, actually, it might not make sense.
But yeah, just was all made up. Then also,
40:24 - going to the test, we learned, we actually
start with writing a test. When we wrote the
40:32 - test, we hadn't defined the class person yet.
We hadn't defined the method HelloWorld yet.
40:42 - We did all this on the fly. In our development
environment assisted us with some auto completion,
40:50 - it was able to create the class as well as
the method. So this is really a handy way
40:54 - of programming. First of all, you define the
test. So this gives you an opportunity to
41:02 - think about the property sign. And then you
define what you need, and you don't have to
41:10 - actually even write it yourself. And when
you did everything correctly, you can simply
41:16 - execute the test. And when it returns, okay,
and it screen, you will see that you did a
41:26 - proper job. Okay, see, here, you'll see a
green bar, which means the test executed successfully.
41:38 - So when testing we often speak of green or
red bar, because the green bar is such a good
41:49 - signal that you understand your test passed
successfully, that people got used to just
41:56 - speak of green and red bars. Okay, so we learned
some more stuff, for example, that this is
42:04 - an annotation. And I told you, you don't need
to know more details about it yet. We will
42:09 - go into details later. Besides on top of input
static, and also, I just want you for now
42:20 - to know that something static exists, but
we will go into details later. Okay. I think
42:30 - that's it. It's okay, if you don't understand
everything perfectly yet, I don't expect you
42:38 - to. Um, so we'll go in more details later.
And we will repeat all this stuff. So it's
42:48 - fine. I mean, the start is really tough. I
know that I don't expect you to be an expert
42:54 - in Java yet. Um, this is just an introduction,
and you will grasp it soon. lesson four. Okay,
43:04 - we're back in my ID E. Id is actually the
short form for integrated development environment.
43:12 - And as this is much shorter, usually you just
say ID e. m, let's recap what we learned so
43:20 - far. And the first one, you have the package.
And the second line, you might have import
43:30 - statements, you don't necessarily need something
I didn't tell you so far is here we use name.
43:38 - And we use the classes short name, because
actually, the classes real full name includes
43:47 - always the package name, so that the name
is of the class is unique. So we could also
43:55 - use its full name, including the package name,
and then we would not need to import the class.
44:02 - But I mean, as you see, this is much more
readable, much shorter, so also much more
44:07 - handy. So this is what you normally do. There's
only one exception, which is a bit more advanced.
44:13 - So I will just shortly mention it. Sometimes
it rarely happens that you would have two
44:21 - classes of the exact same short name
44:26 - but have different packages. And so to define
which one you mean, then you would have to
44:33 - use one with the full package name. Okay.
So next, we define the class. The class starts
44:44 - with a curly opening brace and ends for the
curly closing brace. Um, we have here, we
44:52 - say it's an instance variable actually. And
this is an instance method instance variable.
45:00 - And instance methods could be, of course,
much more. But those together we call the
45:05 - members of the class, because they belong
to the class. An instance is just like an
45:15 - object. So of one class, you can create various
instances, like, one person could be Marcos,
45:23 - another person could be, could have the name
of Peter. And you could have hundreds of hundreds
45:29 - of class of objects, sorry. And each one of
these objects is an instance. And for the
45:37 - instance variables, this means that each instance
has their own version of this variable, which
45:47 - each might have a different value does not
need to. But it's like a duplicate version.
45:55 - There's also another thing, which is called
a class variable. And a class method, which
46:02 - we do when we add static to it, we can add
static here, as well as to the here. In this
46:10 - case, now when we create different instances,
and we change the person name of one instance,
46:18 - this means that all other instances will also
have the name change to the new value. This
46:25 - is a bit more advanced and static. We should
talk about this in detail later. So I just
46:32 - shortly, just to be complete, wanted to mention
it. For now, it's totally enough, if you know,
46:40 - this is an instance variable, and this is
an instance method, okay. Besides that, I
46:51 - would want to add a constructor, I think I
talked about constructors already.
46:56 - Okay.
46:58 - Opening and closing curly brace. This is what
we call a default constructor. It does not
47:09 - have any parameter here, not any variable.
And so this is the default constructor. When
47:15 - we want to create an object of type person
of class person, this constructor will be
47:22 - called and everything that we would do in
here would also be executed. So this constructor
47:30 - is actually used to initialize an object.
Because for example, let's do something else.
47:38 - Now let's add a parameter, prison name. So
this now gets a bit more dynamic, more interesting,
47:48 - because we could try to set the inner person
name to the given person name. Now, you see
47:59 - something is wrong. Variable person name is
assigned to itself. Well, of course, how should
48:06 - our ID or Java know? What do you mean? Here,
we need something to differentiate to tell
48:13 - Java, what we want is we want to set this
instance variable to the value of the parameter
48:22 - person name. One thing we can do to fix that,
we could just rename the variable to see it
48:29 - works. Now we can automatically automatically
resolve the problem. But usually you don't
48:35 - want that I mean, person name is better name,
of course. And now what we have to do, we
48:43 - have to add this to one of them. And as we
want to set the value of person name to the
48:51 - instance variable person name, we add this
dot person name. And so Java knows that we
48:59 - mean this one here. And now, when someone
calls the constructor to create an object
49:06 - of type person, it'll also have to add the
person's name. And then the person named darts
49:15 - directly gets set at the time the object is
created. Okay, one more thing that you should
49:23 - know is now that we have created our own constructor
that has the parameter person name, this means
49:33 - this class does not does not have a default
constructor, an empty constructor like I showed
49:38 - you before this one has gone. Java will automatically
created when there is no constructor defined
49:45 - by us. But as soon as we have defined one,
General will not do that. Now if you remember
49:53 - our test from the last version, we use the
constructor without any parameter. So this
50:00 - will later on fail, but I want to show you
so I will let it as it is. Okay, so, um, remember
50:09 - we had that method here HelloWorld, I told
you that in the first program in every programming
50:17 - language has like a running gag, you return
hello world. Hello World is actually a string.
50:24 - And here we say the method should return a
string. Now, I want to do some more advanced
50:31 - on, I would like to have a method, I can give
a parameter of string. And then I want to
50:39 - say hello, the person's name. Um, okay. And
as you also might remember, usually we start
50:48 - with a test. So let's write a test for what
I'm planning. Okay, so how do we write the
50:56 - test? So we have to first of all at the end
here, and then say test. This is what we call
51:05 - it a notation. Much more. We don't know yet.
And you don't need to know for the moment.
51:11 - I mean, this is all confusing. So relax. I'll
repeat everything various times, you will
51:18 - understand that very soon. For now, let's
just write the test. So I say should we turn
51:28 - Marcos.
51:30 - Okay, because this is what I want the method
to do. Okay, now I have the opening and closing
51:39 - brackets for the method. Okay, so we need
to create an object of type person. Last time
51:47 - I called it, Marcos. This time, I want to
show you how we can use any name we want.
51:52 - So it's called person, new person. So with
that new person, and the regular brackets,
52:01 - I call the constructor. And this is like a
method that is being initially executed at
52:09 - the time when the object is created in our
memory, and see something is read here. Because
52:18 - I told you the default constructor is gone.
So if we want to do that, we have to go back
52:23 - to our class. And we have to add the default
constructor again. We can add it at any place,
52:33 - put it here. Okay, and now this is empty,
and it'll work. But having an empty method
52:45 - or an empty constructor might be confusing
for a colleague. So usually what we do in
52:51 - this case, we leave a comment. To mention
we haven't forgotten anything. We have done
52:56 - this on purpose. So let's see how do we do
a comment actually.
53:07 - So I say empty. On purpose, default constructor.
So what I have here is a multi line comment.
53:21 - There's also also a single line comment, which
you do just like this single line, comment.
53:33 - But I really recommend you should prefer the
multi line comment for various reasons. I
53:40 - will go in detail about comments in a later
session. So for now, this is all I want to
53:46 - show you. Okay, so we have fixed the test.
Yes, the red thing is gone. Great. We have
53:56 - created an object of type person, let me copy
this to show you one thing. You can actually
54:05 - create various objects one after the other.
But now, we already have one object that we
54:14 - called person. So this will not work. So we
would have to give this for example, person
54:20 - two. And so like this, we could continue.
We could create any number of objects, just
54:27 - so that you see. We have one class of type
person. And we have two objects created calling
54:35 - the default constructor. And so we have two
objects when this is executed later on. I
54:43 - will delete this again. I mean, this was just
a short demonstration. Because we should remember
54:48 - what we want to achieve actually is we want
the method to return Marcos. Well, actually
54:53 - I was wrong. I want to say hello, Marcos.
Okay, so now let's assert again. assert equals,
55:01 - I want Hello, Marcos. And I want to say person
dot Hello. And I want to give it here, when
55:15 - we use a variable here, we call it an argument.
This is just to make it more confusing, and
55:22 - people use this interchangeably. But to be
correct here, it's called an argument. But
55:28 - it's all about variables. So we add a string.
And I add markers. Okay, and see something
55:35 - is missing our ID, he tells us something right
here, we need to call him to finish this.
55:42 - So I want on the object of person we created
in the line before, I want to call a method
55:49 - Hello. And you see it's red. And it also our
Id even already tells us cannot resolve method
55:55 - Hello. It doesn't exist. But we are programming
in a test driven style. And so we will have
56:05 - to create a method right now. Okay, I'm actually,
with some magic, I can automatically make
56:16 - my array he created for us. Well, there are
different IDs, and I will speak about it specifically
56:23 - later on. So for now, I just did this to speed
up it up. Just believe me. I mean, you. I'm
56:31 - sure you could create that by yourself. Now
and he did something it said return now about
56:38 - now this is something special. I don't want
to talk now. I'll tell you later. Okay. Sorry,
56:44 - I don't want to confuse you. But I also don't
want to tell you too much. So one after the
56:51 - other. And now, I would add well Marcus's
a bit. Let's say name. Name, because it could
57:03 - be any name, not necessarily has to be Marcos,
we could add any name we want. And what I
57:09 - want is I want to add name to Hello. What
we say here we want to concatenate hello and
57:17 - name. And something is missing. Oh, it doesn't
like it. What is missing is a plus. This is
57:25 - how you concatenate two strings together.
So a new bigger string is created. And you
57:32 - can do this any number of time. But for now,
I mean, all we wanted to say is Hello, and
57:40 - the given name. So this should be fine. Actually,
there's a little back hidden, which you will
57:45 - see very soon. Which I did on purpose, because
I want our test to fail.
57:53 - Let's execute it. Ah, so you see expected
Hello, Marcos. But actual Hello, Marcus. So
58:05 - there's a space missing. So see, this is one
reason why tests are really handy to help
58:11 - you to think about the stuff you code. But
also when you do introduce a back an arrow,
58:20 - then you will directly spot it and you're
able to fix it before it goes on production
58:26 - and destroy something. And yeah, this can
be really expensive. So let's fix this. Let's
58:35 - go down to our method. And here was a space
missing. Let's add it. We go back to the test.
58:44 - executed again. And now the bar is green.
It's works. Oh, that's great. Okay. Um, yeah,
58:58 - I think that's it for now. Lesson five. So
now, I would like to talk about modifiers
59:07 - first of all about visibility modifiers. Actually,
we already talked about them a bit. One visibility
59:15 - modifier is private. Another one is public.
So public, I think I already said this class
59:23 - is visible or usable. From all other classes
in all other packages. This class now resides
59:32 - on the package comm Mako speelde. java course
lesson two. So here, for example, name is
59:39 - in lesson three. So if we would go in the
code of the name class, it could easily use
59:45 - person as long as it's public. A private class,
we can try that. No, it says modifier private
59:57 - not allowed here. And of course how That makes
sense. I mean, a class that's not usable anywhere.
60:05 - But just in this class. This doesn't make
sense. But actually, there is one more option,
60:12 - we can leave the modifier away. And this will
give us the default modifier. This is also
60:19 - why it's called default modifier, also package
level modifier, because now, person can only
60:27 - be used from other classes within this package.
And we can do the same for the variables,
60:37 - the constructors, we can even have a private
constructor, we could have that public, we
60:46 - could have that method private. And this one
default. And we can even call, let's use this
60:56 - one. Let's call HelloWorld. From this method
here, all this is working. And this actually
61:05 - even makes sense. Because especially when
your methods are growing, I personally would
61:11 - say not more than three or 10 lines. Then
to break things up, you can split a long method
61:17 - into smaller private methods, and then calling
the private method. Like, I mean, here, we
61:27 - have only two methods. So to make things up,
you can call one method three times. But of
61:35 - course, I could define further methods. We
don't have this now. And then you can call
61:41 - any number of methods later on. Okay, so to
recap, visibility modifiers, we learned so
61:56 - far is public, private, and default or package
level. Besides there are other visibility
62:04 - modifiers, one, for example, is protected.
But we don't need this at the moment. So you
62:12 - should be perfectly coming alone, along with
just public, private and default. So for now,
62:22 - let's just concentrate on these few. Let me
fix the class shortly. Because very soon,
62:30 - we are going to need it in our test. And I
don't want to adjust the test, I want to have
62:38 - the code as it was before. Okay, because now
I want to show you a new concept. I have this
62:50 - idea. I have prepared the test should return
number of persons. Let me create a few objects
62:59 - of type person, one person, person to
63:08 - person,
63:13 - we could also use the other constructor, but
then I would have to create an object of name,
63:18 - as this at the moment is just too much work
for me, I'm not doing it. And I can also give
63:24 - it a different name, like my person, just
to show you, we can have any name for the
63:31 - variables. So what this means is when the
test will be created here, after this line
63:39 - is executed, which is just after the column,
we will have one object and memory two objects
63:45 - in memory. And after this line three objects
in memory. So what I want now I want to test
63:57 - on a number of objects. Now I should have
three objects created. And I want to create
64:04 - a method that tells me exactly that. Just
dynamically, my person thought number of persons.
64:14 - Okay, still read, remember, we'll create it.
And today Ah, int appeared. Because I mean
64:26 - three is a number. And a number in Java is
an integer, or he In short, an int an int
64:34 - this actually a primitive. And the default
of this is zero. So this is why my ID he put
64:41 - zero here. So it's not red anymore. We can
have a first run. But this will not work of
64:49 - course, because it statically returns zero
we expect three. So this is not what we want.
64:56 - Well of course we could say three statically.
So, now this should work. It's a bit cheating,
65:09 - of course, greenbar Tada. But, I mean, I want
this to dynamically work. So why not only
65:18 - have two persons, I want this to be two. And
well, of course, I have to rename a variable.
65:26 - Let's copy it. And now when I execute it,
of course, this is not going to work expected
65:34 - to, but it's still three. So my first approach
the static one, always returning three. Nice
65:42 - gag, but yeah, not what we need. So what we
need is, at the specific time, when each object
65:50 - is created, we need to count each object that
is created. So what would be the place where
65:58 - the object is created, there is one thing,
similar to a method that is called and this
66:07 - is, you might guess it, the constructor, we
used the default constructor for creation.
66:15 - So we would have to do something in here.
Now, I want to invent a variable, an instance
66:22 - variable, I also call it or let's call it
person counter, person counter equals two.
66:35 - And now I say person counter, because I want
the value it had before. And then I want to
66:42 - add one to the last value of person counter
to have the new value dynamic. So on the left
66:51 - side, is the new value. On the right side
is still the value from the prior calculation.
67:00 - And I add one to it. Now, this is a lot of
code again. And this incrementation by one
67:09 - is used so often, that they invented short
form for that, which is plus plus. So with
67:17 - plus plus, we say take the current value of
person counter incremented by one and save
67:24 - it again into the value of person counter,
it's still red, because we still have to create
67:29 - it. Let's do that. Make it private, of course,
it's an int. I call the person counter and
67:38 - column. Because I don't have to say zero,
I could also say equals to zero. But the default
67:47 - for end is zero anyway, so what we usually
do is, we just put it here as is. So the idea
67:54 - would be it starts with zero. The first time
this constructor is called, it's incremented
68:01 - by one, and so on. So that my method now should
not statically returns three, but person counter
68:10 - instead. Okay, let's try that. Execute the
method. Still not working it returned one.
68:24 - It didn't return zero. It didn't return three
it returned one. How is that? We didn't say
68:31 - one anywhere. Maybe you guessed it already.
So we started with zero, we incremented by
68:38 - one. Now I told you something in the prior
session, which is this constructor is part
68:47 - of the instance. So each object has their
own constructor has their own method. So this
68:56 - is called for each of the objects. So in the
end, both objects would have the counters
69:02 - set to one. So what we need is more like a
global counter. That is not on the instance
69:11 - level. But we say on the class level, because
for all the objects of type person, there's
69:17 - only one class person and this we achieve
with a modifier called static. Okay. However,
69:31 - as a recommendation because this will help
you in the future, I won't go on details Why
69:39 - just believe me. As we have the variable of
types of static, you should also have the
69:45 - method of type static, it would work also
without that, it just better believe me. Okay,
69:54 - so now let's execute it. And this work Great.
Let's try another thing. Let's add this time
70:09 - for
70:10 - free
70:14 - for for an exit executed and it works, I said
actually person to why not saying person one.
70:32 - And it works? Well as you see this might be
confusing I mean which variable to decide
70:37 - on. And also there is a recommendation. Actually
what Java does is Java sees that number of
70:50 - persons as a static method, it sees that you
have an instance variable off type person.
70:58 - And as this is a static method, it doesn't
call the method on the object. Because as
71:06 - this method is static, it's not part of the
object anymore. This is like moving it out
71:11 - of the object. This method now is part of
the class. So Java does some magic here, is
71:19 - trying to be smart and is smart, and calls
the right method of the class. So what we're
71:29 - doing here is working because Java knows how
to do it properly, but it's not so nice. What
71:36 - is better is darkly saying person, so that
everyone knows you're not going to any specific
71:43 - instance, we're just calling a static static
method. On the person class, let's execute
71:51 - that again. And it's working. Thank you. So
in lesson six of this Java course, I'm going
72:02 - to talk about the tools which I'm using. So
first of all, let's start with this computer.
72:07 - It's an apple MacBook Pro. This ID that I'm
using here is IntelliJ IDEA, which actually
72:17 - at the moment is my favorite ID. Before I
was using many, many years, Eclipse clips
72:24 - is open source is also very popular at the
moment, especially with companies because
72:31 - it's open source and free. However, I think
intelligence here is really getting better
72:38 - and better every year. So I really like it
and recommended. And they're not paying me
72:43 - for saying that. But I mean, this is your
personal preference, and every person is different.
72:50 - So I would say just try it out yourself. There's
also NetBeans. NetBeans is also very popular,
72:58 - and it's also for free. I'll just in a second,
I'll show you where to get them. But let's
73:07 - have a closer look at my tests before. So
in the tests, might have seen it already.
73:13 - I'm using j unit, which is a testing framework.
framework means it's like a tool set. It's
73:21 - a set of tools to set of classes. And it's
open source. So it's free to use. And I mean,
73:29 - writing such a framework, it's not really
hard work. But why doing it if it's already
73:35 - done. So this makes it really easy to start
with testing. J unit also is only one of a
73:42 - few testing frameworks. The second one I would
tell you about is test and G, I think they're
73:48 - pretty much the same. And really depends on
the company that you work in some use j unit,
73:55 - some use testing G or any other framework,
I think between j unit and test ng g there
74:02 - knows not so much big differences. So it doesn't
really matter. I just decided to use j unit
74:08 - in here. IntelliJ IDEA actually supports both
of them out of the box. So you can easily
74:14 - try them. Um, I'm not going in much more details,
by the way. I mean, this is a Java tutorial.
74:22 - So I focus really on Java. Just to be complete,
I wanted to mention what I'm using here. But
74:29 - I do this in less than six because at the
beginning, I think learning a new language
74:34 - is already quite difficult. So I wanted to
focus on Java, but not that you puzzled. What
74:42 - the heck is that here? What are you doing?
I wanted to mention this is J unit. And there
74:47 - is lots of documentation on the internet.
Yeah, so you can read a lot about it. Okay,
74:55 - so maybe we just go to the browser now. and
have a look. So first of all, I told you about
75:04 - intelli j idea for you pops up.
75:10 - So you can download, I would first of all,
go with the free edition, and then see if
75:18 - you like it or not. Besides, of course, there's
Eclipse. This one is open source anyway. And
75:28 - then you can choose your operating system,
and 32 or 64 bit, whatever you need. Last
75:39 - but not least NetBeans. Just press the download
button, choose your language, and operating
75:55 - system. And then also j unit, let's have a
look on that. In most It is these days, you
76:08 - won't have to install it, because it would
come pre installed anyway. But just for the
76:13 - record, I mean, this also has lots of documentation.
So yeah, he you can download the most current
76:21 - version. Let's check documentation. Here.
It also talks about Maven, which, by the way,
76:28 - also using so this way, you can define in
Maven that you want to use the current version
76:35 - for 12 of j unit, which I actually did, because
I'm also using Maven, which we're going to
76:41 - in a second. But after j unit, let's also
have a look on tests and G
76:55 - test ng g on this page just provides the false
for Eclipse. But as I told you in IntelliJ
77:02 - IDEA, it's included anyway. And I checked
for NetBeans. I mean, I'm not so familiar
77:08 - with NetBeans, I have to admit that beans,
but I saw there is a plugin, which you can
77:19 - download and install. So probably works just
as well. Now let's talk a bit about Maven.
77:27 - Maven, there's what's called a build management
tool. So as the name implies, it manages your
77:37 - build. Now, what's a build? Well, when you
program your programming consists of hundreds
77:44 - of classes, and then you would want to release
them on production or send them to a client.
77:50 - And then of course, you would not want to
send each file separately. So the so you would
77:55 - usually do a package a single file out of
all the tasks together. And in former times,
78:02 - and say in prehistoric times, this was done
manually. And this is really not a funny job.
78:08 - So people very soon started to program, some
little scripts to make this task easier. The
78:17 - first tool that I know of is probably make
it's a Unix tool. And often make they came
78:25 - up with and and Maven again is the successor
of Maven of m sorry. And Maven currently exists
78:35 - in version three. Besides Maven, there's also
Gradle and other build tools, I'm using Maven,
78:45 - here you see it find that I'm using j unit
412. And also the find that my source encoding
78:53 - is UTF eight, because what this bill two also
can do for you. I mean, it can do so many
78:58 - things is environment specific settings. So
that I tell that my source encoding is UTF
79:07 - eight, I can do it here. And so much more.
So also about Maven, you can visit the website,
79:17 - Maven. There, you can download it. They also
have a free book, which is really a great
79:26 - book. You can download all the files, even
the sources that you would need. And also
79:35 - check Maven book. I really recommend that.
As far as I remember. It's available as HTML.
79:44 - And also there should be a PDF somewhere.
All this is just too long. Anyway, I know
79:53 - there is also a PDF available which you can
download. And so you can read all about Maven
80:02 - Last but not least, let's also talk about
bit about text editors. Because I think in
80:07 - at least one of the lessons I did so far,
I told you, you should start not with an ID.
80:15 - But you should start with a text editor instead,
well, there are two that I would recommend,
80:21 - first of all testbed for Windows, I really
like it using Windows. for Mac, it's unfortunately
80:30 - not available. In this, you can write your
code, then you would save it. And then assuming
80:40 - you have already downloaded the Java JDK,
which I have also not talked about, because
80:45 - I assume I should be easy, but maybe we could
first, shortly go there. So for the JDK, so
80:55 - that you can download your code, you can just
go here, say download, by the way that was
80:59 - NetBeans, if it was soiled, and you can choose
your operating system and download it. I assume
81:07 - you have already done that. And so when you
have installed a text editor, or like text
81:13 - pad, or sublime, you're on. Mac, I'm using
sublime, which is also a great editor. Download
81:23 - button. It's also available for Windows and
Linux. So using this text editor, here, I've
81:33 - loaded the class person that we saw before.
I mean, it helps you a bit like see, I click
81:40 - on person's name, it highlights the variable
person name and all forms, but it would not
81:45 - so heavily assist you, like you might have
seen when I was in my ID, which for the beginning
81:51 - is actually good, I think. Because when your
ID is too smart, then you don't have to use
81:59 - your brain cells too much. I mean, after some
time, when you have coded too much, this is
82:07 - really welcome. But for the beginning, I really
recommend to use your brain cells and so that
82:12 - you get used and familiar with all these keywords,
public class, private static, should really
82:19 - get familiar with that. And so for the beginning,
just use a text editor, then you can also
82:25 - go on the console and called Java arc and
compile the class. Also, this is one show
82:32 - you because in this course really I only focus
on the theory of Java. So yes, I think that's
82:41 - it really short introduction of the tools
that I'm using.
82:45 - If you have any questions, send me an email
as always, um, yeah. Lesson seven. So now
82:55 - let's start with the topic of this video,
which is conditional statements, and of course,
83:01 - conditional statements, and Boolean. So a
Boolean is a new data type. This one is actually
83:10 - a primitive and it can have two values, Boolean,
true or false. And this is all there is to
83:19 - it. So conditional statements, I mean, there
is a condition and it can hold true or not.
83:30 - And that is something is executed or not.
I think, already from the wording, it makes
83:35 - sense, and you might easily understand it.
But what exactly is a Boolean? Why is it called
83:41 - Boolean? I mean, this is a bit weird, I think,
well, at least this is what I found. So I
83:47 - just looked it up on the internet. Here on
Wikipedia, we have Boolean algebra, and I'm
83:58 - really not a big fan of mathematics. So let's
go over this really fast. The only thing that
84:04 - matters to me is Boolean algebra was introduced
by George Boole in his first book, blah, blah,
84:11 - blah whatsoever. So it turns out that the
Boolean is called all the end because of this
84:17 - guy here. Um, I leave this as your homework,
read everything about George Boole and Boolean
84:25 - algebra, of course, this is again a big topic
by itself. We have folk focusing again on
84:33 - Java, I just wanted to help you that you get
a feeling why Boolean is called a Boolean.
84:42 - So this thing here is really helpful when
we want to say if something happens or something
84:49 - exists, some condition, then only execute
a specific area of code. And then you can
84:57 - also say else if this condition does not hold
true execute something else. So this is really
85:04 - the if statement is probably the most important
statement, not only in Java probably in all
85:11 - programming languages, at least the ones I
know of, because it allows us to, like really
85:18 - have a different execution flow each time.
For example, we could say, I mean, B is a
85:24 - bit boring. Let's call this Monday. And let's
add all the raining. I was raining. Let's
85:36 - also have Monday. Okay, so in this little
example, it's Monday, and it's raining. And
85:45 - nobody could say if it's Monday, and percent
twice,
85:54 - raining.
85:55 - So what these two M percent mean is, and so
this tells Java to check on this boolean value,
86:04 - check if it's true, and only if the first
boolean value. Or he could also be a function,
86:13 - like, is it Monday, which would have to return
a Boolean. And if it does, only then Java
86:24 - would execute, go here. And check if this
is also true. Which also could of course,
86:30 - be a function if Is it raining or whatever,
right. And if both here are true, then this
86:46 - block here, starting with the curly braces,
is going to be executed. Now. I mean, I don't
86:52 - want to implement the functions. So let's
make this Monday again. And simply raining.
87:01 - Just to keep it simple, and then drink beer.
Because rain. I mean, what else can you do?
87:10 - Um, but now let's make this more easy to drink
beer. I'm from Munich, so I'm really a beer
87:19 - lover. So on Mac, I mean, as depends which
platform you use. On Mac, you press just out
87:29 - and seven, twice. This is called the pipe
symbol. And the pipe symbol symbolizes or,
87:38 - um, yeah, I know this is a bit weird. This,
you just have to know by heart that this means
87:45 - or, again, as before with the two ampersands.
When you repeat it twice, it's called the
87:54 - short circuit operator, which means if the
first condition is already not true, for the
88:05 - end, at least, then it's not going to execute
the rest. So whenever In a statement, it sees
88:13 - that a condition will cannot hold true anymore.
It will stop at the beginning and they will
88:19 - not execute the rest, which is very handy.
Because I mean, if before we had a method
88:25 - here, is it raining. Now imagine this method
takes like two hours to execute, we could
88:35 - really save that time if we already see. This
is only true if both are true. So this is
88:43 - why you use the ampersand twice. And the pipe
symbol wise, this is I would say the default.
88:53 - So I want to even spend time to talk about
the other alternative. But now this is so
88:58 - much nicer. If I have an orange here, if it's
Monday, or if it's raining, I drink a beer.
89:08 - So this really increases my chance my chance
to get a beer. So I personally liked the statement
89:15 - so much more. I'm just kidding. Um, so this
is the difference. Or, and, and, and of course
89:26 - you can further combine that led so I don't
know what to do. Let's say raining and let's
89:38 - say Tuesday and sunny. So we have to introduce
these Boolean variables first. So Tuesday.
89:52 - Well, if it's Monday, it can't be Tuesday.
So we will say false here. And Boolean, if
90:03 - it's raining, it can't be sunny. So sunny
will be false. But of course, let's change
90:11 - this. Now it's not Monday. It's Tuesday. So
this will be true. And I misspelled that sunny.
90:21 - Okay, now they're not red anymore. So now
what do we have here? Monday is false. So
90:28 - if Monday is raining, but it's not Monday
at the moment. So this is the whole thing
90:33 - here is not true. But here we have an or true
Tuesday, this is true, Sunny is still false.
90:42 - So this is also false, which means the whole
if statement is false. And we cannot drink
90:49 - a beer. But let's make this true. And now
it's Tuesday. And it's sunny, and we can drink
90:57 - a beer Ray. Of course, I mean, when it gets
more complicated, I'd recommend you to introduce
91:03 - more brackets to really tell Java first execute
this. And the result when you have it, then
91:13 - only execute the next statement. I mean, if
you go more in more detail on the algebraic
91:20 - logic, you will see there are preferences.
And they're really rules on that. But if you
91:26 - don't know them, and if you always just add
the brackets, you're on the safe side to show
91:31 - what you want. Okay, now, let's make this
not so complicated. Because let's introduce
91:42 - something, something else. And this else is
the else statement. Because if it's not money,
91:52 - we can do something else. And this is the
new keyword that I'm introducing the else.
92:00 - statement. So here, we can say drink, milk.
might also be nice. Okay, so, only on Monday,
92:12 - we drink beer. And on all other days, we drink
milk. So that means we have to drink a lot
92:18 - of milk. So if you I mean, milk is really
healthy. So I recommend you to drink milk
92:24 - like this. It's much better. But of course,
let's introduce some more variation. If no
92:33 - sorry, else if, um, as you introduce a new
day, let's say Friday. So we have to introduce
92:46 - Friday. At the moment, it's Tuesday, Tuesday.
So we'll change that in a moment. Make this
92:57 - false. So else a Friday.
93:05 - Sorry.
93:07 - Drink water. Okay, so what do we have now?
And I mean, you can format this in any way,
93:18 - but usually, you formatted like this, too,
so that you can see this all this whole construct
93:25 - belongs together? Because it starts with if
money. And if this is not true. Java has to
93:34 - check else is it Friday? If so, then call
this function. And in all other cases, we
93:43 - still drink milk. So, okay, and you can have
any number of L's if statements here.
93:58 - Else if I don't know some other condition,
we could just say sunny. Um, if it's sunny,
94:09 - um, what should we do? go swimming, go swimming.
Yeah, we can do anything here. Okay, so you
94:23 - can have any number of L's if statements.
And you can have just one l statement, of
94:29 - course, but you don't have to, I mean, this
is not obligatory. You can also leave it away.
94:36 - You just you cannot have AIDS if by itself
because else what I mean, there has to be
94:44 - the whole statement has to start with some
Eve. I'm okay. I think this pretty much is
94:54 - enough for if else if and else. Now let's
do some more cool stuff. Let me Remove all
95:00 - that. Because normally, you evaluate some
condition. And then when the condition is
95:11 - evaluated, this returns a Boolean. Under the,
under the covers, I would say, for example,
95:17 - you could say in E equals to four. And then
we could say end. j equals to three, omit
95:31 - that. Okay, so we have two primitive data
types of the end, which are introduced in
95:39 - a form of video. And then I can compare those
values. I can say, I mean, of course, as well
95:47 - as with the Boolean is it's obvious. But I
mean, in a big program, it's not so easy.
95:53 - Normally, one function calls the other, and
he would like have the user typing in nature.
95:59 - And then you don't know if the user typed
in four, three, some in this is a really stupid
96:05 - example. I think we know that four is bigger
than three. But let's assume that we don't
96:10 - know. And then I could say, if i greater than
j, then do something. Else. Do something else.
96:29 - I mean, here, it's again, you can say ELLs,
if you could say if j greater than I, what
96:47 - else can we say, oh, if i equal to j, which
at the moment, of course does not hold true.
96:59 - This, by the way, you see there are two equal
signs. The reason is this equal sign we use
97:08 - here when we assign the value of four to i,
or j, so we can't use that again. Instead,
97:16 - in Java, here use two equal symbols to express
I want to have a Boolean check. And what you
97:28 - also can do so so you see the result of this
will be a boolean value, you can assign that
97:34 - boolean value are equal to a boolean variable.
And this is actually quite often very smart.
97:45 - I mean, here, it's very easy to understand.
But sometimes you have way more complex terms.
97:53 - And then if you give it a name, your code
will be much more easy to read, because now
97:59 - you can say are equal. Okay. And then there
is also greater or equal, smaller or equal.
98:12 - And then also unequal, which I will usually
I'm typing like this, but it's actually the
98:24 - same. So not equal, you can say with the exclamation
mark equal, or with greater, smaller, like
98:33 - this, it's both the same thing.
98:37 - I really prefer that one. I think it's more
readable. Because this is like, exclamation
98:43 - mark, really easy to read. And with this,
you can also whatever condition you have,
98:52 - if this no holds true, when you put the exclamation
mark in front of it, that is false. If this
99:00 - before was holes. Now it's true. Thank you
can even Yes, you can, you can add any number,
99:10 - exclamation marks, and every time the value
is inverted. So from to false than true again,
99:16 - and false again, and so on. I mean, this is
not really readable. So I wouldn't do it.
99:23 - Just to be complete. I wanted to mention this
as possible. Okay, on. I think this pretty
99:33 - much wraps it up. We talked about Boolean.
This is a condition. If it's true, we execute
99:41 - code that is in here. You see it can also
be empty. I mean, it doesn't really make sense.
99:47 - I mean, I would really recommend you to write
something, execute some method. You can also
99:57 - of course, you don't have to have an method
in here, while again, I would recommend it
100:02 - because it might be much more readable. But
in here, you can also do crazy stuff like
100:09 - i equals to eight, for example. J equals 299.
So you see, now we have actually some code
100:25 - or plus class, the increment operator that
I talked about, I think it was in less than
100:32 - five. So if j with three before, when this
is executed will be four, or minus minus,
100:44 - it was three before it will be two. Okay,
so you can have 30 Booleans. And here, what
100:55 - you cannot do is compare a Boolean to another
data type like int, amin, this wouldn't really
101:02 - make sense what you can do, but, and this
really, a lot of beginners do like to compare
101:12 - a boolean value let's make this Monday again.
Monday. True. And now you could say, if Monday
101:24 - equals to true, what does this mean? I mean,
this means if true, equals to true. Of course,
101:33 - this works. And if this was false, if false
equals to true, false does not equal to true.
101:41 - So the whole thing is false. But I mean, this
is one comparison too much. To say, if Monday,
101:49 - this is enough. Yeah. But really, comparisons
like this false or true. I really see very
101:58 - often in code. So if you see that, you're
free to refactor the code, and just shorten
102:06 - it. If it's true, then just say, if Monday,
if it was, if Monday false use just say, if
102:12 - not Monday. So, see, this is not. Okay. Lesson
eight, I would like to introduce you to loops.
102:25 - This is really exciting, because it's a very
cool feature. It allows you to execute a repetitive
102:33 - task much faster than any human could do.
So this really makes our programming very
102:40 - powerful. So it's very important to know how
to program loops. So there are certain different
102:47 - types of loops. The first one is a for loop
for because it says like, for a number of
102:58 - times, execute something. So this is why for
and then sorry, this writing here will be
103:06 - a bit cryptic. I'm sorry. The reason is because
this loop is really also a very old loop.
103:14 - That was also introduced before Java, actually,
I think it's, for example, is part of C and
103:21 - c++, which are much older than Java, actually.
So and when they invented Java, they just
103:29 - took over the same style. So this is why it's
a bit cryptic. So
103:36 - we have three sections here. Let me first
of all, type it and then explain. So this
103:48 - the three sections that this first loop usually
has, which means First of all, introduce an
103:57 - int, and assign it a value of zero. calling
this variable II, I sorry, is like the default,
104:09 - because I just for integer because the guys
that invented programming, are sometimes also
104:18 - mathematics, mathematicians. So yeah, they
really like short variables like AI. And it's
104:26 - so it's so common. I also used AI, but you
could also call it like culture. It just that
104:34 - people would expect you to call it AI. In
this type of loop. It's mostly always called
104:41 - AI or just why are some some variables short,
just one letter. Okay, anyway. So this is
104:48 - our counter variable that defines how many
times we want to execute a certain statement.
104:57 - Our statement that we want to execute is actually
that Create a person object. And we want to
105:02 - do this four times. In programming languages,
again, mathematicians, they're to blame. They
105:12 - don't start with one, but they start with
zero. So if we want to execute it four times,
105:19 - we have to make sure that we stay that I stay
smaller than four, because from zero to three,
105:28 - this is four times. And each time when we
are finished at the end of the loop, I is
105:35 - incremented by one, see, this is the plus
plus. So afterwards, it's incremented by one,
105:43 - and then the next round, it will be one, one
is smaller than four. next one will be two,
105:50 - two is smaller than four, three is smaller
than four, and four is not smaller than four.
105:57 - So for the fifth time, the loop will be exited.
And so afterwards, the court will be here,
106:09 - the cursor kind of, and we will not execute
it a fifth time. So I copied this into the
106:16 - for loop.
106:23 - And then this should make sure that four persons
on the fly are created. Actually, because
106:32 - this variable is defined within the block,
we cannot access the person object anymore
106:42 - in here, I think I showed you this, see it's
red. This is about the visibility, what we
106:52 - could do is we could put the definition of
the variable up here. This way, we can still
107:05 - access person one, but actually only the last
one because the variable person will always
107:12 - be overwritten by the next one. I mean, for
this little test here, this is okay. Because
107:18 - all we want is we want to calculate the number
of times the constructor was called. So this
107:27 - works, as well as we could also define person
in here doesn't make a difference. In our
107:35 - case, because this is a static method. We
talked about this in the earlier lesson. So
107:41 - now, let's try that code. And it's green.
Now let's try it to put the time here. This
107:59 - darkness does not work. Because see we expected
for but actually, there was 10 times the person
108:07 - constructor was called because this is 10
a year. So this is how the first loop The
108:15 - for loop. The regular for loop usually looks
to define an end, you give it a one letter
108:22 - name like I, you assign it zero, and then
you compare it to some max value. In this
108:34 - case, 10. Before we head for so that the test
is green again, you always have to separate
108:43 - these blocks with a colon. And then you increment
i by one. You can also do any other statement
108:53 - in here. Like you could say, I equals i plus
two. Which will then let's see. So I'll assume
109:08 - something. See now we only created two persons,
because each time it was incremented by two,
109:18 - which means the number of times that we were
going through the loop was only half the number
109:26 - of course. And if we add four or even I don't
know 10 we will probably only executed once.
109:34 - Let's try that. Yeah, see actual one. Okay,
so usually you could put any statement here,
109:47 - but the default is to just increment a counter
variable by one. So, release. Try to stay
109:58 - with the default and do it like This, I could
even further tell you crazy stuff. Like you
110:05 - don't even have to do all this can have this
empty. This now would be an infinitive loop,
110:18 - you can try this at home, because this will,
like probably crash your PC because it will
110:24 - create lots of objects.
110:28 - Um,
110:31 - but it is valid. Okay. But this is how it
should usually look. So anyway, let's go to
110:42 - the second loop, which is the while loop,
while some condition holds true, execute.
110:52 - And each of these loops have their specific
reason to be used. I mean, actually, in theory,
111:07 - you could use always just the one loop like
this loop or that loop, it just that when
111:13 - you want to count something, I mean, this
really is helpful. Because it does all everything
111:19 - at once, if you want to do exactly the same
code, we have to do it like this int i equals
111:26 - to zero. Well, I smaller than four. And then
you have to say, at the end, I plus plus.
111:39 - So this is exactly the same. And you see,
it's not so nice and short anymore. So this
111:46 - while loop, you would usually do one, for
example, you have some condition that gets
111:52 - dynamically calculated, like we had the function
here should drink beer. So if you had some
112:06 - function here, like should drink beer. This
is when you would use a while loop. I mean,
112:14 - I have not defined those variables here. But
I hope you get the idea. If you have some
112:20 - function that is always calculated, you will
use the while loop. And then in here. You
112:27 - could also create person, and you don't have
to do this now. Because we assume that this
112:39 - method sometimes would return false. And when
returns false, this loop would be exited.
112:47 - Okay, but let's go back because actually want
to run it once. And there is a bracket missing.
113:02 - Because I promise you we can do exactly the
same thing. So let's try that. Okay, well,
113:16 - this probably will not hold true anymore,
because then we have done it eight times.
113:26 - So let me remove that code. Okay. Let's check.
Seems Okay. Let's see what j unit says. Okay,
113:43 - seems like this is okay. So it's the same
one. And then last but not least, there's
113:51 - also another loop, which is called This is
the newest loop because it was introduced
113:57 - as far as I remember, with Java five, this
is the most simple and the coolest loop. However
114:04 - I'm sorry I cannot show you this one. Because
for this I need to introduce you to arrays
114:10 - and collection which I will do in one of the
next lessons. So for now just know there is
114:23 - another loop the coolest one actually. But
yeah, so this was a very short introduction
114:29 - to two different loops. Well actually yeah,
I could also show you the while loop you can
114:35 - also do it kind of let's say backwards. So
you can say do while some condition um the
114:50 - regular while and the for loop I showed you
that very common bows, but this one you will
114:57 - hardly ever see because Again, it's a bit
more difficult to understand. What it does
115:05 - is it executes this statement the first time,
sorry, without even checking a condition.
115:12 - So the condition is checked only afterwards.
Of course, we also need to increment.
115:21 - Okay.
115:26 - So what we do here is we assert that number
of persons equals to four, well, no, this
115:37 - is, this won't work, we have to sort it afterwards,
sorry. So now we create the first person without
115:52 - even knowing how many times we have created,
then we increment i. And at the end, we check
115:58 - that I is smaller than four. Let's try this
and remove that.
116:08 - See, this also works. Um, this depends on
the logic that you need. Sometimes you may
116:22 - use that. But actually, all the three different
loops I showed you, they are like equivalent,
116:29 - you can do everything with each of those loops.
So it's just the different style. And this
116:39 - depends on what you want to express what's
easier for you to use. This you will get used
116:45 - when you're like, did a few months of programming,
and you use each of them, you will get the
116:52 - hang of it. What's like usable in which situation.
Lesson nine, I would like to introduce you
117:00 - to arrays. Arrays are also a very cool feature
of many programming languages. And they also
117:09 - appear in Java. I kind of unofficially introduced
them already in the last video, where I mainly
117:19 - talked about loops. And we stopped when I
said there is one more loop the for each loop
117:28 - that is specifically designed for arrays and
collections. So today I'm going to introduce
117:35 - you to areas at least. And so we can also
see the for each loop. And so an array is
117:42 - really like container, a box, or let's say
a list. So an array isn't is also an object
117:51 - is a data construct that can hold a number
of primitive data types or objects. And as
118:01 - I already said, box, so far person, the way
we define it is with these were brackets,
118:14 - which symbolizes something like a box, I think,
which is easy to remember, because we will
118:21 - put our persons kind of in in here we could
think and because this container will hold
118:29 - a number of persons, I will call this variable
persons. Okay, now I say new person. But now
118:41 - there comes something new again. I don't use
the regular brackets, or again use the square
118:48 - brackets. This does not call the person constructor.
This would be done like this, and should not
118:56 - be working yet there's already a thread on
the line. So I'm not calling any constructor
119:03 - here. This is a specific syntax that says
Create me an array of type person that can
119:15 - hold a number of persons. And we have to now
give the number which is four. That was still
119:22 - a red underline now it's gone. So now Java
knows we want an array of type person that
119:29 - can hold four persons same thing we can do
with it. And by the way, on a Mac, you have
119:40 - to press out five and six for the square brackets.
So in that same way is equals to new end,
119:54 - which is also you know in this primitive but
now I say new ends because I'm not creating
120:01 - again, I'm not creating an end, I'm creating
an object, an end airy object. Okay. And you
120:12 - can also see that it's an object, because
when I put it here, and I'll put down the
120:19 - button, I see a number of methods that I can
call. And we are this is actually not a method,
120:26 - this is an attribute, which I can directly
access. So if you remember, I think you I
120:33 - said you should have your attributes private,
this is accessible, it's not private. So this
120:39 - actually violates that rule. And yeah, so
this is also a very old construct, and shows
120:47 - us one place where Java itself violates the
rules of good object oriented design, but
120:56 - we just have to live with it anyway. So what
this does, and we will use it very soon as
121:02 - it gives us the number of
121:08 - like the the length of the array than the
like, in this case for, okay, if this is three
121:17 - year, why intz dot length should return three.
And in a minute, you will see what we use
121:28 - it for, let's remove the end. Because I want
to continue with a person's I want to feel
121:37 - this error. And the way this is done, again,
we need to break it we need a lot of times
121:44 - is I say zero here, oh, I said person, of
course this is wrong, we don't have a person,
121:51 - we have only this one object, persons. And
the type is person airy. So it's not a person,
122:02 - it's a person airy object. Okay, and here
we can say new capslock. person. What this
122:12 - does is it creates a new person object in
memory, and puts a reference to this person,
122:26 - which is like a remote control a way to access
the person into the array at position zero,
122:36 - which is the first position. Let's copy and
paste that four times. Three, four. So position
122:48 - one, position two, position three. Okay. If
I would say position four, what you don't
123:00 - have, I would again, get an error, which we'll
talk about in detail when I introduce exceptions,
123:07 - which is again, a new big topic. Oh, okay.
So, and when you have done that, what you
123:16 - can also do is, you can do crazy stuff like
at position three, put the object that is
123:33 - in the person's array, at position, whatever,
zero or one or whatever. Right, because whenever
123:47 - you write on every ad position, as it contains
a person, it's exactly the same as if you
123:57 - would say, person, my person equals to a new
person. So now I created a person. And this
124:15 - object was assigned to this variable to this
reference variable. And can also do it like
124:24 - this. So now, this variable can access that
object, as well as all there's title. Persons
124:36 - at position three, can also access the same
object. So we have like two references to
124:43 - like remote controls to this one object. Yeah,
and you can do also the opposite. You can
124:53 - say, my person equals to I don't know something
Let's take two persons at position two, which
125:06 - means the object that is at this position,
the reference to it will be assigned to the
125:15 - reference variable, my person. So this, my
person object now
125:23 - should still be here, if I'm not wrong, I
mean, this really gets confusing. So, I mean,
125:29 - I'm just explaining this so that you get the
hang of it. But in reality, don't make it
125:34 - too complex, because you see, the more complex
the more box packs you could introduce. Okay,
125:41 - so I hope you get the hang of it. Um, one
more thing I might mention. Of course, no
125:49 - one forces you to, to really define to set
an object at each position. Now, when I left
125:57 - out position one, this position is empty.
So what does that mean? What we say is at
126:06 - position one, there is now because knowledge
the word like for nothing. So there is nothing,
126:14 - there is no reference. If we access it, we
get an exception, because Java will not know
126:21 - what to do. Okay. So that much about now,
which we could also specifically do, by the
126:30 - way, we could also now it, it's called, the
wrong button. Sorry. Yeah, so now you can
126:50 - also write, so this is like, put nothing here.
Or, here, that would mean that the beginning,
126:59 - you have the new person object at position
two, later on, you kind of throw the reference
127:07 - away. And if no reference exists to an object
anymore. In Java, there is something called
127:16 - a garbage collector, I will talk specifically
about the garbage collector very soon, in
127:21 - a specific lesson only about the garbage collector.
So this one is smart, and we'll throw away
127:27 - that object, we'll clean up the memory. For
us, this is really a cool feature of Java.
127:32 - In other languages like c++, this doesn't
exist. And so you have to take care of cleaning
127:38 - up the memory by yourself, which is really
not fun. So this is really one of the coolest
127:45 - features of Java. But anyway, I guess I'm
going too far, let's make this more simple
127:50 - again. Because what I actually want to do
is now I want to take the for loop, and combine
128:00 - that with the arrays and introduce the for
each loop. But let's start easy, let's first
128:07 - of all, go to the regular for loop, take that
put it here. And now we have let's remove
128:24 - all that all we have is an object of person
array called persons. And we have this for
128:38 - loop that may create for whatever in this
case persons. And so we will use that dynamically,
128:52 - so because I will change while we go through
loop, we'll start with zero will be 123. So,
129:03 - we can say persons at position I this is really
a cool thing now, because this means this
129:13 - one line Let me clean this up. So we create
each time an object of type person and we
129:26 - put it into the array dynamically add position
I. So this will on the fly fill the whole
129:34 - array with persons. And what we can also do
is in a different loop but also just in the
129:45 - same loop. We can access this object by saying
persons at position I and call some method
129:54 - on it like hello world that we created in
an earlier lesson.
130:03 - Um, okay, I think I have not introduced you
how to print something on the console. But
130:11 - maybe I should not do this now, because I
guess I feel it gets confusing with all this
130:17 - stuff with Aries, but would be handy now to
show you that this can print all the name
130:23 - of something for each person. But maybe I
will do this in a later lesson. Okay, so just
130:31 - believe me, if we would print that, we could
like print, hello, and then a person name
130:39 - for each person. Okay, this is already nice,
but it gets nicer with a new loop for each
130:47 - loop. And this is not so much different from
the regular for loop. It was introduced only
130:56 - in Java five. And this works like that. person,
person, and then colon and then persons. So
131:15 - what this does is it automatically under the
hood, it does everything that this for int
131:28 - it does. And now we can also access person
dot HelloWorld. Of course, this requires because
131:38 - now we are using it. So this requires that
this has already run? Um, let me think. Yeah,
131:49 - so this is only for like reading it. I'm fulfilling
it. Now fulfilling it, I wouldn't use it.
132:00 - Because you have to specifically say what
you want to do. Because if this is empty,
132:07 - this would also be empty. Okay, so but we
can call person HelloWorld on it, and see
132:14 - how much nicer This is really condensed. So
this is the for each loop. And the for each
132:21 - loop is like besides areas, there's also other
constructs, other container types, which I'll
132:30 - also soon introduce, like collections really
a cool topic, because they're even more powerful
132:39 - than just arrays. And so this for each loop
also works with these collections, whatever
132:48 - that is. And it does whatever is required.
And it also does it in a very smart way. So
132:57 - it's really smart to use that for each loop,
not only because it's more condensed, but
133:03 - also because it's a performance and proper
way of doing it. Because Java will assist
133:09 - you in doing it. Okay, so I think this pretty
much wraps it Oh, no, there is I have I have
133:20 - a not sorry. I didn't know Have I told you.
I think I promised and then I didn't do it.
133:28 - Person start length. This attribute which
is not private, I think is public. Yes, should
133:36 - be public. This gives us dynamically the four.
So I mean, here, we know that it's four. But
133:43 - just imagine what can also be yours, you have
a method, which just gets a parameter. And
133:51 - you don't know its size. So you couldn't say
four. And so this just dynamically takes the
134:00 - lengths that you need. And as you see in this
loop, we don't even need it because this is
134:07 - dynamically calculated by Java for you. Which
of course also that's the person that links
134:15 - in the background. At least this is what I
assume. Okay, lesson 10. I would like to introduce
134:23 - you to enums. enums and Java represent an
enum eration. So they enumerate something
134:34 - they were introduced in Java five. Now, I
want to further extend my explanation about
134:43 - arrays because there is one more cool thing
and it also makes it easier for us.
134:49 - We can actually even on the fly out five,
aisle six, well this is autocompleted id he
134:58 - already PR Since two equals two, and now I
do something new, I say curly brace, this
135:12 - is alt eight and nine on my Mac, by the way,
and see, there is no red marking anymore.
135:21 - This actually also works. So what does that
mean? This actually is a shortened form. And
135:29 - this says there should be an array. And we
don't have to say, a specific size, because
135:38 - the size is automatically calculated, because
the brackets are empty. This means empty size,
135:46 - that would be the same as saying zero, which,
of course, doesn't make much sense. But just
135:55 - technically, it's possible. So and we cannot
feel this array. So and we don't have to set
136:05 - the size, this gets calculated automatically.
So I'm just copying. I can also put your mouth
136:15 - if I want to, I can also create a new object.
My let's call it my personal Sorry, I can
136:39 - also just to show you what's possible define
a variable of type person and then assign
136:49 - now to it or talked about now, which is like
nothing and put it here. So this actually
136:56 - is the same like that. And I mean, I want
you to also see this, what this does is it
137:04 - does not or what is not is, it does not like
combine this array and that array. Instead,
137:12 - it says what you have at position zero of
this array, which in our case, is this person
137:20 - object. Take the reference to add and the
reference, copy it here, which means this
137:32 - position as well as later on, persons, zero.
So later on, after we have defined the array,
137:43 - if we say, person to zero, that will be exactly
the same as persons zero. Because they both
137:54 - point to this object in memory. All this is
a bit complicated, I'm sorry, I hope you can
138:01 - follow me. And I will do a specific tutorial
only on memory management and show you how
138:07 - things look in the memory. For now, I just
hope you can follow if not, it's not so important.
138:16 - I mean, we're talking here about areas and
what I want you to understand is like this
138:22 - is an array and this is a way of defining
the array and the specifics about the memory
138:29 - Don't worry, we can go in more detail later.
And you will you will understand this very
138:36 - soon I'm sure let's do the same trick again
just with a different position. You can actually
138:43 - even do it twice or any number of times can
take another one or it doesn't matter let's
138:50 - put this or we can also remove them now put
it here. So yeah, you can do what and you
138:57 - can also do it on the fly you can say new
person. Now there is no a little difference
139:03 - which is this object that defined here.
139:09 - It sits somewhere in the memory and might
error a person's to has a reference to it
139:18 - outside of my array there is no one who has
a reference to it, which we can change after
139:27 - we have defined it. We could also say I have
not to count 0123456 I hope I have counted
139:39 - correctly if not imagined I had counted correctly.
Okay, so I said six. So at position six. We
139:50 - cannot copy this reference and I can say my
let's call it secret person. Let's call it
140:00 - just VIP. So my VIP, now I have a reference
to it outside of the airy. So I created it
140:15 - dirty on the fly in this line together with
the definition of this array. And later on,
140:24 - just for the sake of it, I assigned it a variable,
which we then also can use and work on it
140:32 - like hello world, which you can also do is,
say, person two at position six dot HelloWorld.
140:42 - So you can really work with the areas at specific
positions, just as if you had a variable,
140:50 - it's exactly the same thing, even though it
looks a bit awkward. But yeah, you get used
140:56 - to it. Okay, anyway, I think this is a very
handy short definition. Because see how much
141:02 - shorter This is here we find just for persons
and area for persons. And this was actually
141:10 - five lines. Now in just one line, we have
defined an area of six positions, and we have
141:17 - filled it, and this is all in one line. And
I think it's still readable. I mean, readability
141:23 - is the most important thing. So it's not about
making something short. It's okay to make
141:30 - it short, if it keeps being readable, or if
it's even more readable. That is okay. Okay.
141:38 - And I might also already introducing new stuff,
I might also introduce you to final final
141:46 - is another variable modifier. We already talked
about public and private and static, not final,
141:57 - something new final says are like locked in
this variable, I don't want to anyone to poke
142:05 - around with that variable. So if I later after
saying final, say this, Java will say Oh,
142:17 - no cannot assign a value to a final variable
person to. So this is like a protection. As
142:25 - you see, I have to say final. So this is one
more keyword. And this is one key more keyword
142:33 - to read. This is one more keyword to write.
And so I would only do it if it makes sense
142:39 - for a reason. And if you have code that is
just like here, two lines. I mean, while doing
142:45 - that, I would assume you know what you do,
and you wouldn't like put this to now if you
142:51 - don't want to just one line later. Where this
does make sense is if you have something like
143:00 - some constant values, some status values,
for example, you could have a process a program
143:07 - that operates on some values. And then you
want to remember the state that your processes
143:13 - in Okay, let me give you an example. So for
this, we will again define an array, but we
143:24 - would do it in the class on the class level,
and we would not do it for the objects, but
143:31 - for all objects of the class. I mean, and
this, of course, is static. So static, we
143:43 - talked about this already means we have just
one of this type for all the objects and no
143:51 - final. So static and final, they're really
close friends, they are used together very
143:57 - often. And all that say string
144:01 - because I want to have a string. But actually
I want to have a string array. And I said
144:07 - we said the braces right after it so that
we see it's not a string. It's a string array
144:17 - and I call it my state values equals and then
the curly braces again. And now I can say
144:34 - like pending, processing and processed. I
could of course sorry, brackets missing. Add
144:53 - many more. Just for now. I have a short example.
So this is what we could do. Something is
145:02 - wrong here. Yes, comma. Okay. And this means
now, and I've also, oh, I did something and
145:10 - didn't explain you why I did that. So far,
all the variables that we defined, we had
145:16 - in lowercase letters here, use the uppercase
letters, and the underscore. This is also,
145:24 - again, a best practice, because like, we would
use this static final, somewhere down here
145:35 - in the code. And you see, now the definition
is gone, we don't see it anymore. And so that
145:42 - a programmer working in here and knows what
you're working on here is static final. So
145:49 - I don't want you to touch it, I just want
you to read it. There, therefore, we use the
145:56 - capital letters, and we separate them with
the underscores so we don't use the camel
146:02 - case. And then we could, again, of course,
iterate through these values.
146:11 - For
146:13 - so let's do the for each loop, say, stream,
nice date, or just stayed. And then the curly
146:28 - braces again, we could say, if we're talking
about if state has a certain volume, will
146:48 - actually we can't on a stream, say equals,
this is not going to work properly. Because
146:59 - the equals is working on on on primitive values
like int, and it's comparing the value that
147:07 - is directly in the variable. Oh, no, sorry,
I'm going really complicated. Um, I don't
147:15 - know if I, if I'm making it too complicated.
But now that I already started, I might as
147:21 - well continue what we have to say for if we
want to compare two strings is equals. And
147:30 - so we can compare that to some other value.
So we can do it, state equals and then a string,
147:40 - some other value. So this is some that equals
is a method that is directly given to us from
147:47 - the string class that we haven't written,
but we're using it from Java. And the says,
147:53 - compare this string to some other something,
blah, blah, blah. Okay, if they're both the
148:04 - same, we could do something. And then we could
do this a number of times for each value.
148:16 - So we had, as far as I remember, something
like pending.
148:21 - And
148:22 - processing. And, of course, uppercase and
lowercase make a difference here. And I think
148:38 - it was processed, but I mean, this is just
an example. So it doesn't really matter that
148:41 - much. So, and then we could do some some something,
colo method. And here we would call a second
148:57 - method and the third method and so on. Okay,
but actually, this is a lot of code. So there
149:12 - is a faster way of doing that. And this is
the switch statement that are also promised
149:18 - to talk about. And second. This string here
is also not so nice, because you could change
149:28 - it any time. You could say in here, state
equals to love. And, of course with just a
149:41 - few lines. I'm sure no one would ever do that
or hope. But he mentioned we only have always
149:50 - see a very short examples. We could have like
a very complicated code, hundreds, if not
149:56 - 1000s of lines and we could like call other
methods For what is two other classes, and
150:02 - then if someone in some other class, like
changes your value, you might not notice.
150:09 - And you don't want that. You want actually
to have the value final. But this with final
150:17 - doesn't work, because final only protects
the variable. It does not protect the value
150:23 - in here, which you can change any time. And
for this, we have the email. The enum allows
150:31 - us to define an enumeration. Oh, okay, oh,
let me just remove that. Or we can keep it
150:39 - for the time being. But let's jump over I
have prepared here class will actually it
150:46 - will be our enum and it will not be a class.
Okay, so far have just said package. For less
150:54 - than 10, I have set less than 10. And now,
like you know it with the class, the class
151:02 - we would say public class, logging level,
151:09 - and
151:10 - races. But this time we're not doing a class,
we're doing something a bit smaller. And this
151:17 - is the enum. And now this is obligatory, you
have to start with the status definition.
151:27 - And it's not a string. So we don't need the
double codes that we would have for the string.
151:35 - Now this is really a value and enumeration
value, which we define as our email. So we
151:46 - like we like program our own type. And we
already program the allowed values pending,
151:55 - had processing. I think we had processed.
Yeah, and then we end
152:07 - here.
152:08 - And now we have defined an email. And we can
use that. Let's go back to our test. Let's
152:20 - say logging level logging level, or let's
call it
152:33 - my
152:36 - state equals to logging level pending. So
this is a lot looking like static. And this
152:49 - is already how it came. Because now we can
use these static values, we can also iterate
152:58 - over them. But we cannot change this. I mean,
we cannot. Of course we can change it. But
153:07 - we can only change it to the allowed level
allowed statuses that we have defined beforehand.
153:14 - We can set pending, processed and processing,
the order is different but still the same.
153:22 - It can only have one of the three values.
We could not say here. something crazy, because
153:31 - it's not a string, we can only use the values
that we have defined here. And this is really
153:37 - helpful and makes also our code more readable.
Now we can again, iterate through this enum.
153:51 - In this case, it's a bit more complicated
actually, because we have to call a method,
153:58 - which is called values. This method will give
us something like an array of all the allowed
154:06 - values in here, pending processing processed.
And then, of course, there's not a string
154:13 - anymore. We say let me also remove that. And
then we can do the same. Now, it's okay to
154:29 - say equals, see this works. Of course, it
does not make sense. I mean, a string will
154:36 - never be equal to an enum, but it's perfectly
fine. You may compare any object to another
154:44 - object. Of course it makes more sense to say
equals dot for example, pending and then here,
154:59 - processing and prose So 
let's put processing.
155:14 - Here.
155:17 - Let's put processed. Okay? Um, but this is
not so readable. And we don't need equals
155:24 - here. This is so cool. Actually, for an enum,
we can do the comparison, just with the double
155:34 - equals, again, this does work. Because yada
yada, yada. Java DOES MAGIC under the hood.
155:45 - So for now, just believe me it's working.
Because this is not an object, this is a static
155:56 - value. Okay. Let's just remove this. Okay.
Now, you see, I think it already got so much
156:10 - more readable and shorter. That However, there's
still a shorter form, which is the switch
156:17 - statement. However, we will not do this today.
We'll do this in the next tutorial, the switch
156:26 - statement, because I think otherwise, it's
just too much for one tutorial. Now we talked
156:31 - about arrays repeated the for each loop. Yeah,
and I introduced the enum, which has here
156:42 - this values method. Actually, there's much
more an enum can do. Maybe I should show you
156:50 - this one. We can also add these brackets here.
Let me do this for a moment. And now we can
156:59 - put values in here. So what is this going
to be? I'm adding a constructor, which must
157:10 - be private. Let me check if it may be default,
but I think not. Well, let's just try it seems
157:23 - to be working so far, but I'm sure it may
not be public, yet. This is not working. So
157:29 - default, visibility seems to be okay. Even
though I think it's a bit awkward. And now
157:36 - see this. It says the end cannot be applied
to this constructor. Because so far the constructor
157:46 - is empty. Because what happens is, this is
calling the constructor. So let's put in here,
158:03 - and now it's working. So having the constructor
here, you might also see I was kind of lying
158:12 - to you, of course this is an object. But it's
just that for specific reasons, I don't want
158:18 - to go in detail, we can still do the comparison
with the double equals here. Okay, anyway,
158:25 - so we have a constructor. And let's now assign
the eye to some other variable. Of course,
158:34 - you see, this doesn't make sense, assigning
eye to eye and we have already had that. This
158:40 - thought I know, of course, I have to define
it. And make let's make this private. So now
158:49 - it's working. I don't like it, I want this
private, this is just what he would do. Okay.
158:56 - And then I mean, this, this depends what this
means could be some code of some form. So
159:05 - let's have a method that returns public code.
And this was returned. I. So this enormous,
159:18 - really powerful, is allows us in dismissing
to have methods to return something. But it
159:30 - has these static values that we can iterate
over and that we can only choose from. You
159:37 - could also think of a traffic like light with
like red, yellow, and green. You can also
159:44 - of course have more values here any number.
159:48 - I'm actually you don't have to have the enum
in its own file. You could directly on the
159:55 - fly define it in line in a class, I would
just not recommend you to do saw, I mean,
160:01 - forever, you're all there is an exception
and find out these exceptions for yourself.
160:06 - But in 99% of the cases, you would be better
off having it in your own class. So yeah,
160:17 - there's much, much more actually that you
can do with an enum. But I think we already
160:24 - this tutorials already a bit long. And I think
I want you to digest this for now. We can
160:31 - further extend this anytime, of course. So
that's the name. With its constructor and
160:40 - a public method returning the I, you can also
have more parameters in here like a string.
160:49 - But if you're if one of them has it, and all
of them have to have it, and every parameter
160:56 - appearing here has to appear in the constructor
string, some string or let's just say s. You
161:04 - may use it but you don't have to use it. But
usually, of course, you would use it as equals
161:10 - s. And then something.
161:13 - Yeah. Okay.
161:15 - So I think that's enough for now. And the
next tutorial, I'm pretty sure I'm going to
161:25 - show you the switch statement. Because this
is really cool for using for iterating over
161:32 - these enum values, then the code gets much
shorter. I am going to talk about the switch
161:41 - statement, which is another conditional statement.
Very similar to the if statement. However,
161:50 - first of all, let's recap what I showed you
in the last episode. Actually, in the last
161:56 - one, I covered a lot of ground, I think, I
hope this wasn't too fast for you. So let's
162:03 - shortly recap. First of all, I showed you
this new way of defining an array. So like
162:12 - the traditional, let's call it, the traditional
one was this one, where you just said, person,
162:18 - square brackets, persons equals to new person
have four chairs with the size of four. So
162:26 - this can hold four elements starting at zero.
Well, this needs a lot of lines. And this
162:35 - actually is the short form just with the curly
braces opening and closing. And with a comma
162:43 - separated list, you can define an array. And
my recommendation is end with a comma at the
162:50 - end, so that you can easily extend the array
at a later time. Also, I introduced a new
163:02 - modifier for variables, a final modifier,
the final modifier kind of protects a variable
163:09 - for us. So what it does is when in a later
line, I try to assign something new. Like
163:23 - let's use this area on top here, this is not
going to work cannot assign a value to final
163:29 - variable persons to also we can try to assign
now, which is like emptying the variable will
163:38 - also not work. This is nice ish. However,
I personally prefer to not use it locally
163:48 - in a method. But instead to use it for static
final variables that are used read only and
163:57 - are defined at the top of the class usually
like this here. I hadn't said any modifier.
164:08 - So this at the moment is default visibility.
Usually I would prefer, like having it private.
164:16 - And if you need other classes accessing it,
I mean, this is supposed to be read only.
164:22 - So it would be okayish have this public. However,
even better. If you really want to focus on
164:31 - clean code like I do. You could provide a
public method returning the string array.
164:40 - I don't know some name. Let's call it states.
And in here, first of all, let me finish this
164:58 - we could copy this out Because with a copy
if someone else, because the final, what it
165:05 - does protect is as I set the variable, what
it does not protect as the content. So it's
165:12 - safer if return a copy of the array. And there's
actually a helping Claus, which provides of
165:21 - Java, Java util, which provides some static
methods and really have a look, see, we are
165:30 - going to use the copy. But there's also many,
many more methods like here for doing a binary
165:36 - search and so on. This is really a big toolbox
of methods that you can use, play around with
165:43 - them. And I might show some of them at a later
time. For now let's use the copy off. And
165:52 - then we take the array. And we have to state
the size, which again, we take dynamically,
166:01 - array dot length, yeah, we also talked about
this. But this is dynamically returning the
166:07 - length of the array, which in this case is
three, because the array has three elements.
166:15 - So this is really a nice way of
166:17 - generating clean code and returning this array.
Also, I told you, it's all in capital letters
166:26 - and using the underscore and not written in
camel case, because this symbolizes that is
166:35 - a static final. So in short, you just talk
of a static final, because this is how you
166:41 - write it. Okay. Let's go back to the bottom.
I'm sorry, so not much about the array. I
166:54 - also very shortly talked about equals, because
I had to, because for two strings, like ABC.
167:03 - And you if you want to compare them, you cannot
do so with the double equals. This is not
167:13 - going to work, even if it's the same. Because
the problem is that this comparison does not
167:21 - compare objects. And this is an object, instead,
it compares the reference variable. So equals
167:31 - does work for int three, and then you can
say three equals I, because the three is actually
167:43 - in here. But if you have a string, let's make
it null for now. In here is not the object
168:03 - or now in here is the reference, which is
something you can think of something like
168:11 - a number also will be saved in here. And when
you compare with the equals the two equal
168:20 - signs, then you compare this variable, which
means you kind of compare if it's exactly
168:29 - the same. So what will be true is if you would
say my string equal equal my string, but this
168:41 - usually is not what you want to say. And so
when you compare two strings, you have to
168:48 - say equals talking about equals usually in
one sentence, you should always also talk
168:55 - about the hashCode method. This is already
a very advanced topic. So let me keep this
169:02 - very short for now. It just that if you create
a new class, like I created the class person,
169:11 - it's often a good idea all depends, but you
might want to implement the equals method
169:19 - in your person object so that you can compare
two persons. But if you do, so, you also have
169:26 - to implement the hashCode method. What the
hashCode method is and all the details I will
169:34 - explain at a later time. Okay, so that much
about the string comparison. Oh, one more
169:42 - thing. I made this now because I also wanted
to make a point. What I see very often is
169:49 - people that would write equals like this,
my string dot equals and then a static value.
169:57 - This is not so nice, because as you see this
Might be now. And then this throws an error.
170:03 - And of course, we don't like arrows. So instead,
always put a value in the front, which will
170:11 - never be now, like this string here. I mean,
this is ACB, as a roll down, it will never
170:19 - be now. So ACB equals now, we'll just return
false. But now equals ACB will always throw
170:33 - an error. Okay. So let's stop here. Then,
actually, the biggest part of the last lesson,
170:47 - we talked about enums, which I introduced,
I created this enum here logging level, let's
170:54 - go to the class. So public enum logging level,
I do find, actually, the name is a bit awkward.
171:04 - Because it's not a logging level, I was thinking
of something like info, warning, and error.
171:16 - But then I decided we haven't talked about
logging either. So I
171:23 - instead took pending processing process. So
this would more be more like a status. But
171:28 - I don't know, let's leave the name for now
is just a stupid example. So this is the IEM
171:34 - that are introduced, which is a bit similar
to a class, but has some limitations, but
171:40 - also has some features a class does not have.
So it allows us to define these static on,
171:49 - let's call them labels that we can act upon
in our code. So we can say if something is
171:56 - pending, to this or that, so it's not only
more readable, it's also more safe. enon was
172:05 - introduced was Java five. And before that,
people would have taken numeric values, like
172:13 - if something is equal to not to zero, or one.
But then already people started to calculate
172:23 - these values, this really gets nasty and problematic.
And I'm not showing you this because I want
172:29 - you to do it in the proper way. And that is
using an enum. So this is really a cool feature.
172:37 - You can you don't have to also introduce a
constructor, if you want to have extra values
172:44 - for each enum value. And you can provide methods
that would return these values, or do whatever
172:54 - you want, which are also like to make the
code more readable, is I often provide I mean,
173:02 - not always. Whenever your code and you design
your code, always think decisions through
173:11 - don't make a decision just because this is
never smart. So if for whatever reason, then
173:18 - the code you work on, for example, the pending
value, and you need to ask is it pending,
173:25 - that it might be nice to add this method is
pending.
173:35 - And then you can say return this, which is
the minimum and not only the minimum, but
173:42 - the current value of the enum equals equals
pending. So if in the code, you have an enum
173:56 - let's do this modern level, still I call it
stage or status equals logging level, not
174:13 - take processing. And then I could say if stayed
Dodd is pending, which now would be false.
174:21 - Some code would have to be executed. But what
I want you to know is only add such a method
174:32 - if you really need it. So it would not be
wise to always by default, provide a method
174:39 - for each of these values.
174:44 - People usually get lazy and when they see
something is working, they tend to just overuse
174:53 - stuff and they just like I might be I might
need this. So let's just ask Method just because
175:01 - no, never do that. Never add a method just
because always think think it through, I mean,
175:10 - code lives. And you can always change your
code later. And you always can add a method
175:15 - later. So only edit when you need it. Let's
say no, we don't need it. So we will also
175:20 - remove it. Okay, I think this pretty much
rounds it up. For enums. Actually, they allow
175:29 - much more crazy stuff, like each value could
have their own method implementations. I hardly
175:36 - ever use it. So let's not show this for now.
I think this is pretty much what you need,
175:45 - usually. And now, let's finally actually go
to the topic of this lesson, which is the
175:52 - switch statement. So I think I already a bit
introduced it. In the last lesson, I said,
175:58 - we want to shorten this here. So the switch
statement is also a conditional statement.
176:05 - And that's pretty much exactly the same, like
these ifs here, just in a shortened form.
176:12 - Okay, I mean, don't think about the exact
meaning here. This is just pseudocode. To
176:20 - explain you something. Okay, this time, I
will not use a for loop, I will directly operate
176:27 - on this state here. And then we can instead
of saying if we can say switch, so we are
176:36 - operating on that value here. And then, instead
of if we're saying case, so if it's the case
176:50 - that the state has this or that volume, case
pending. So this is the same as saying, If
177:02 - equals pending. If you just have one, then
if it's of course shorter. But the switch
177:09 - statement is usually used when you iterate
through all or most of them, because you have
177:18 - this extra of saying switch, but then the
more states you have, the easier or shorter
177:25 - it will get processing case process. Now I
mentioned we will have 100 different ones.
177:36 - Let's format this. Now what happens is, I
haven't put any method here, and I have not
177:44 - put a break statement here. So actually, what
would happen here, now let's put the same
177:53 - method call, I mean, I have not implemented
the method, just the method. Imagine this
177:57 - was a method. So for all these three different
states, while there is a common reason, we
178:04 - would call this method. If imagine we use
a switch statement within a private method,
178:12 - you could also like return a value. So this
depends, the difference with a return is when
178:21 - you return something from a method, of course,
you also leave the method, while I'm pointing
178:26 - this out is because normally usually, what
you want is you want to do something and it
178:38 - might not even return something like printing
something on the console. And you would call
178:45 - one method. And in here, you would call a
second method or do a second something calculation
178:55 - or so. And here a third one. Now it gets problematic
if you forget the break, because what then
179:04 - happens is a fall through this will be cold,
as well as that will be cold. So this is really
179:11 - a big source of bugs. Very, very dangerous.
So in this case, never forget the break. And
179:19 - if sometimes you'll want to have them together
because you want all the three of them for
179:26 - example or to to call a certain method it's
recommended to leave a comment false through
179:36 - so that you tell the next program I know what
happens and I did this on purpose.
179:45 - Okay.
179:50 - So that much about follow through. And you
don't have to set all possible values. You
179:59 - can also leave One out, if nothing is found,
in this case, we will just leave the switch
180:04 - statement, and we'll just not do anything.
What you can also do is you always have the
180:13 - possibility to adding a default, which will
be called if none of the other case statements
180:20 - apply. And then people sometimes say, I don't
know, call default method. Well, he, I really
180:35 - want to warn you. And of course, again, we
had fall through would have to say, break.
180:41 - This is not so wise. The problem is, I mean,
code lives. And who stops the next colleague
180:49 - from extending your enum adding, for example,
an error state here for some text, your colleague
181:03 - would just do this would not know there is
this switch statement. And now, you implemented
181:10 - the switch statement, you didn't think of
the error case. And the error case might need
181:17 - a specific behavior. But now you would also
call this method for this new error flag.
181:26 - So usually, we don't want that. So what I
recommend you for the default statement, either
181:33 - you don't use it, or even better use it. But
here, you would throw an error. He say, I'm
181:44 - not doing this now, because I haven't talked
about exceptions yet. We will do at a later
181:51 - time. But this is the place where you would
have like an exceptional case. And the good
181:59 - thing about this is when someone extends your
income, and someone forgets to extend also,
182:09 - one or more switch statements, you will see
this, I mean, you might say Oh, but then my
182:14 - program crashes. And this is so nasty. Well,
of course it is. But there is a rule in good
182:21 - design. And this is called fail early, it's
always better to have a high severe back on
182:28 - production even. And to have to fix this within
let's say, seconds or hours than to have a
182:36 - high severe bug. And no one notices it. Because
if it would not throw an error, it might calculate
182:45 - something in a wrong way. But a client might
notice this, let's say three months later,
182:51 - and then the problem will be so so much bigger.
So when programming, sometimes you just have
182:58 - to be brave. I also see people that try to
prevent arrows and like return something,
183:05 - for example, return now. So this is actually
just, instead of accepting I have done something
183:13 - wrong. And let's fix it. This is just like
putting the problem to the future and making
183:19 - it bigger. So I want you to be brave and throw
exceptions and handle them then this is always
183:27 - better. I mean, I'm not saying you should
program buggy code. Of course, we should try
183:32 - and concentrate. But sometimes bad things
happen. And then it's always better to fail
183:37 - early. And so you you notice the problem and
you can fix it. This is always better than
183:45 - hidden bucks. Okay. I hope you got my point.
183:53 - Okay,
183:54 - so also here. Well, if you have an exception,
you don't need to break because an exception
184:01 - always leaves the block. But what is important
to always have a break, or, like here, we
184:11 - don't have to break, leave a comment for through
to tell the next programmer, I know what I'm
184:18 - doing, I want this and Tommy about warnings.
One more thing. don't overuse switch. as well.
184:28 - don't overuse the if statements, these conditional
statements, you'll see how much the code grows
184:33 - also in combination with for loops and see
how many levels This adds to the code. You
184:42 - have to understand this switch. And then there
is different case statements or default. And
184:48 - then inside of the case statement, there might
be a method called and so on. So this really
184:55 - complicates the code. Same as with the if
statement. You have to See what is the condition
185:01 - for me to enter this blog, ha, then this method
is called, you might click to the method,
185:08 - you might want to check here. So this all
makes it more complicated. And actually, this
185:14 - is also like a, let's call it a relic from
the past. This is what we call procedural
185:20 - code. Because it's like a procedure, it's
like really, this makes you thinking like
185:29 - a machine, like a machine would switch a state.
What's a case this dude that case this do
185:36 - that. But humans usually don't, they don't
think like this. And the cool thing about
185:42 - object oriented programming is that the object
oriented programming is very close to how
185:47 - humans think. And this allows you to like
talk to business guys. And this really makes
185:54 - your code nice. And switch is not object oriented.
There are some cases, corner cases where you,
185:56 - it might just be easy and fast to use it,
but don't over use it. Really, I mean, there
185:57 - are people that would have maybe hundreds
of lines in here, this is just crazy, really
185:58 - hard to read. This is also why I had here
method, this is not yet perfect, but still
185:59 - better than just having huge switch statements.
There are techniques, for example, just shortly,
186:00 - you could have an object representing the
pending state, and an object representing
186:01 - the process state and so on. So they are at
once techniques of how to prevent a switch
186:02 - statement. And it always depends, like, what's
better? for very small switch statements?
186:03 - It might be okay. Just remember, they are
a bit like evil and should not be overused.
186:04 - Okay, I hope I have added enough warnings
of switch. And if statements. This is also
186:05 - one reason why I'm only introducing it now.
Because I really want you to become a object
186:06 - oriented programmer. I will further continue
talking about the switch statement. So I told
186:07 - you that it's used to iterate over the different
values of enums enums, which are also told
186:08 - you were introduced with Java five, um, before
that, the switch statement also existed, but
186:09 - you had to emulate enums. And the way this
was done was by using int values. Um, this
186:10 - is not so optimal. And this is also why enums
were introduced, because they're more typesafe.
186:11 - And I would also not recommend you to show
to us ins in the switch statement. I think
186:12 - I already said that in the last episode. I
even didn't want to show you but now I realized
186:13 - I think I should still show you. Because you
will see it sooner or later. And so that you
186:14 - can understand code of others, I will show
you, but just try to avoid it. Um, okay, anyway,
186:15 - with that warning, I'll show you. And now
let's give it some name. Um, I call it my
186:16 - state.
186:17 - And now I give it some number 42. I mean,
this is just an example. And could mean whatever.
186:18 - And this is already your problem. 42. What
does it mean? Does it mean pending? Does it
186:19 - mean processed? How do we know? Well, to make
it a bit better, they then introduce static
186:20 - final values, which I'll do right now also.
So let's go to the top and on the class level.
186:21 - Let's introduce now this is a method. Let's
do it here. Private static, final, let's call
186:22 - it processed, processed. Forgot to give it
the type of the primitive type int and this
186:23 - is the 42. And we could also have pending
so this is like a trick. But you see this
186:24 - is also where a normal use case From. So this
is also why in enums, we usually use the capital
186:25 - letters. Okay, because it's a constant value
that will not be changed. So now I will give
186:26 - this the name of pending cross cutting, let's
call this processing and processed. Now, of
186:27 - course, we need different values, that could
be a 40, then this could be a 41. And this
186:28 - would be a 42. And now I can copy that, go
back down. And then I can say, my state oops,
186:29 - equals pending. And pending now, I think it
was 41. And then I can now switch on the end.
186:30 - And now this is funny before depending was
of the logging level. But Java is smart enough
186:31 - to realize, now we're not iterating on the
enum anymore, but on the int and s, we also
186:32 - have processed there, as we have named it,
it still works. Of course, I mean, just to
186:33 - show you, this is just because we named the
variable the variable. So if we processing
186:34 - is not used, called is something then of course,
we will have to use this something below here,
186:35 - because now you see pending as red, because
cannot resolve symbol pending. Because we're
186:36 - not on the interim anymore. We only int something,
the problem is that my status an end. So no
186:37 - one guarantees us that only these three values
that we want to use are used. anyone at any
186:38 - time could say my state equals to 300. And
then it will not be something it will not
186:39 - be processed, it will end up in the default.
See. And this is also a reason why here you
186:40 - should not have regular code, but throw an
exception instead. Which we'll talk about
186:41 - very soon, I hope. Okay, so anyway, this is
what you can do with an int. And since since
186:42 - Java seven, I mean, at the time I'm doing
this video we are, we have Java eight. So
186:43 - when they introduce Java seven, you now can
also use strings on my string, give it a name,
186:44 - called also my string. Okay, not used yet.
and copy it. And now we can also switch on
186:45 - strings. Of course, something doesn't work
because it's not a string, it's an int. So
186:46 - now, I can of course start to use. Well, for
example, the empty string or a blank string.
186:47 - I can use, again, something in lowercase letters.
And of course, here also I can do a column
186:48 - labels, which then of course, are private,
static, final string. And now I call it I
186:49 - don't know. I haven't used pending because
here of change it to something.
186:50 - And I will call this pending. But it could
also be any anything any string 42 Yeah, whatever.
186:51 - So of course, using that label, I'm only using
one now I think you got the point on too far.
186:52 - Okay, so now, that label I can also use pending
in here. Um, you might remember from the last
186:53 - session I talked about the fall through, which
is you don't have a brief statement here.
186:54 - So if it's this case statement will be the
same one as that statement, which will both
186:55 - then call this method and then break is called,
which will leave the switch statement. So
186:56 - the court will continue online 122. The default
is at the end. It could also by the way, be
186:57 - anywhere else. For example at the top which
would not be also a full Through. So if it's
186:58 - not pending or something, or pending is, I
don't even know anymore what we put there,
186:59 - I think it was 42. So, in this case, all the
threes different cases would call a method,
187:00 - which he or we could have some other method.
As always, I'm not going to implement the
187:01 - method. And then we could say break so that
for the default, just this method would be
187:02 - called. And then we would end up here, leaving
the statement and ending in Wait, where's,
187:03 - see, if I put my cursor at the beginning of
the switch statement of the curly brace, I
187:04 - don't really see it ends up here. Because
if you have a method, and this is also a reason
187:05 - why you should keep your methods very short.
You see, the method seems to go until line
187:06 - 141. And this method now got so big, that
it's really hard to see where it starts and
187:07 - where it ends. So yeah, I can't say it often
enough, keep your methods short, I would really
187:08 - keep them at one to 10 lines at most. I'm,
I'm really happy. If I'm able to keep them
187:09 - at one to three lines. Some say I'm really
on my might be too strict on that. But you
187:10 - will very soon see the fruits of your methods
are, the easier it is to understand them.
187:11 - And also, the easier it will be to reuse them.
Yeah. Okay. But now back to the topic of the
187:12 - switch statement. So you can use it with strings.
As of Java seven, you can use it with enums,
187:13 - like I showed you in the last episode, you
can use it with ins and any other number types.
187:14 - So far, I've only showed you int. I'm actually
there are others. I'm not sure if I should
187:15 - really talk about the others, because they're
hardly ever used. They've just the range of
187:16 - the number ranges just a bit smaller. In 99%
of the cases you would use it because I mean,
187:17 - it doesn't really matter these days. how large
the ranges. So it is always fine. I mean,
187:18 - not but maybe I still show you. For example,
this could be a bite. But now this is already
187:19 - not working anymore. Why is it because I have
changed it on the string. Let's fix that.
187:20 - So the bite here. This is just smaller than
the end. For example, if you put 3000 here,
187:21 - it says this is incompatible, because it's
an int because it's too small. Um, yeah, but
187:22 - the three works. But I really don't want to
go further in details. If you're interested,
187:23 - you can also read this on the internet. Because
all you really need encode in 99% of the cases
187:24 - is the end. So okay, I think this pretty much
rounds up the switch statement.
187:25 - So you can use it with a string and an int
Oh, there's one data type, which I might show
187:26 - you. That's also interesting. And this is
a car. A car is a string of a length of one,
187:27 - while it's not a string, but it's very similar.
So it uses these single quotes instead of
187:28 - the double quotes. So if I'm using the double
quotes, it's automatically a string. And this
187:29 - doesn't work anymore. Here it says incompatible
types required car found string with a single
187:30 - quotes, it's a car. So it's a character of
length one one single character. Of course,
187:31 - it could also be a or b. But it cannot be
longer than one character. Because then it's
187:32 - not a character anymore. Too many characters
in character literal. Okay, so we can also
187:33 - iterate over characters. This sometimes might
be interesting. if you for example, parsing
187:34 - a string or what is parsing it's have a string
five string equals something. And now you
187:35 - can take each single character, because a
string is actually a combination of several
187:36 - characters. And then you can iterate over
each character. And then you can switch over
187:37 - this. Um, yeah. This you might need at a later
time. So I've also introduced car now and
187:38 - told you there are other number types. I would
like to introduce you to logging. Well, actually,
187:39 - what is logging?
187:40 - Hmm.
187:41 - Well, first of all, let's tell you what my
idea is. I have prepared this little test
187:42 - here. I have prepared a little class car service.
I wanted to process this string, BMW, or Beamer.
187:43 - And in the class, this class so far is empty.
My idea is I want to be notified in some way,
187:44 - like a print out on the console into a file,
that database or maybe even an email or something.
187:45 - So I want to be notified in some way I want
to monitor if someone calls this method, so
187:46 - that I, like later on, can go through all
the course and can see if something happened.
187:47 - For example, if my system was hacked, I could
go through a file and see what time what happened.
187:48 - And then yeah, analyze it. So that's the idea.
And the way this is done, is by logging. So
187:49 - actually, logging for me this word was a bit
weird. So I looked it up. Wikipedia is your
187:50 - friend. So let's do this. So logging is called
logging for a ship's logbook. A logbook? Is
187:51 - this thing here, you know, of ancient times
when the captain in his cabin was making plans,
187:52 - and was writing down at what time he was at
which place and what speed the ship was going
187:53 - in that direction. So this is a logbook. So
this is already like monitoring the state
187:54 - of the ship. And but still I was asking, why
is the logbook called logbook. While this
187:55 - article here have a read just very fast going
through it says it. The term originally referred
187:56 - to a book for recording readings from the
ship lock. So what is a chip lock, let's click
187:57 - and ship block, also called common lock shaped
lock or just lock is a navigation tool for
187:58 - marinas used to estimate the speed of a vessel
through water. Interesting, so there's also
187:59 - an image. So this thing here is the shape
lock from the end of the ship. And here's
188:00 - even a picture they were throwing out the
ship luck and in equal distances they were
188:01 - not in this line in this long line and the
faster the boat goes the faster Of course,
188:02 - this chip block is taken away. And by measuring
the time they could measure the speed and
188:03 - this was done given by knots. So this is still
why speed of a ship is given in knots even
188:04 - today. So here it says ship log and associated
kit, the real of lock line is clearly seen.
188:05 - So it seems I don't know this, but I just
guess it that it's called lock, because this
188:06 - really looks like a lock, like, like a three
strong because it's this huge block. So I
188:07 - would guess that this is why it's called lock.
So, this is why the ship lock is called ship
188:08 - lock. And this is why the act of doing like
writing something into the lock is called
188:09 - logging. And as a programmer, you can think
of yourself of like the captain of the code.
188:10 - And as such when you want to write on events
that happen while your program is running,
188:11 - you are logging and this is what we are going
to do today. So how is logging done in 2015
188:12 - and 15 Well, currently you would use SL for
J. This is a framework for logging. I mean,
188:13 - of course, you could write your own logging.
But this is a lot of work to make it
188:14 - work properly. And this has been done already
for you. You can just use this framework.
188:15 - Well, actually, this is only for Sade, well,
FSH is a design pattern that we haven't talked
188:16 - about. So two, we could say it like, allows
you to use here is how it's used. you import
188:17 - the code, Ork SL for j logger and logger factory.
And then, within your code, you say logger,
188:18 - logger, logger, factory, get logger. give
it the name of the class. And you can use
188:19 - it with different implementation of logging.
Because for many, many years, the most prominent
188:20 - logging framework was log for J. Well, this
has changed. At the moment, you should probably
188:21 - better use lockback because it's a more powerful,
and it's author is I don't can't pronounce
188:22 - it properly. But I try shakey Goku, and this
is the same guy that actually implemented
188:23 - love for J. So he continued with lockback,
because he wanted to make logging even better.
188:24 - So today, therefore, we use SL for j in combination
with lockback. Because using this sl for j
188:25 - visade. will allow us at a later time, if
there is a new logging framework introduced
188:26 - that is even better than lockback, we can
easily each switch to the new framework without
188:27 - having to change the code. Because the code
doesn't use the code of lock bag. It uses
188:28 - SL for J. So how is this done? Let's jump
into the code. Okay, so first of all, I told
188:29 - you, I'm using Maven for the configuration
of the dependencies. So here I've configured
188:30 - to use the dependency org. So for j, and lockback,
classic. This is actually the implementation
188:31 - of SL for J. And this is the core code of
lockback. So you need these three dependencies
188:32 - to get logging in your code. Okay. And then
you should also have in source main resources,
188:33 - our file called lockback, dot XML. Here, you
can define different things. Well, first of
188:34 - all, you can say, how should you lock where
should you lock, in my case, I say, with giving
188:35 - this class console appender, that will result
that my code is locked to the console directly.
188:36 - There are also other appenders, or other implementations
for logging. So we can also look to the file
188:37 - to the database, to email. And if there's
something you want to have locked to that
188:38 - doesn't exist. You can also implement your
own implementation, like I don't know, maybe
188:39 - like logging into Twitter in some way, if
that makes sense to you. Okay, and this is
188:40 - the pattern, how, when a message is written,
in this case, to the console, it should look
188:41 - like so the patterns has, I mean, you have
to read the documentation for details, but
188:42 - it's like, give me the time when this event
occurred, the threat the logging level, because
188:43 - the logging level is like a mechanism. It's
like a grouping mechanism. You can have different
188:44 - levels of logging. This is like a signal of
the severity of the problem. Because debug
188:45 - is probably for debugging purposes, use that
sparsely.
188:46 - Then there is a logging level info and error.
So error you would use if there is an error
188:47 - in your code, info for general information,
and debug, just for you know, some debug information.
188:48 - But this really should be used partly because
for debugging. You can also use a debugger,
188:49 - like in your ID, or we haven't talked about
debuggers either. But yeah, just for now.
188:50 - Now there are different levels. So, in your
code, you can then say, I want to lock this
188:51 - on level debug. And here I have defined the
package name. And I say here, this, when I'm
188:52 - when there's some logging of a class that
is of this package, then I want to log it,
188:53 - if it's debug, I could to also put your error,
that would mean only if it's an error, log
188:54 - it. Or I could put here info, that would mean
only login, if it's info. info, of course,
188:55 - also, it would include arrows, because this
is like more. So debug includes all includes
188:56 - debug, info and error, but error would only
log messages that are locked on level error.
188:57 - So you see, this is really makes it more flexible.
And you can even have here different loggers
188:58 - for different packages. So we could also copy
this and, like have here a different package
188:59 - like Java course two, and so on. And we could
then have this on the one on debug and the
189:00 - other one on error. So this is really flexible
and can be changed. And here, this is the
189:01 - root level. So like, generally lock on info
level just for this package. Log on debug
189:02 - level, this is what it means. Okay, this was
only very short. There's much more information,
189:03 - of course, on the internet. But first of all,
maybe a week go to our test. And we add the
189:04 - login details here into car service, I put
it. So first of all, I need to import a few.
189:05 - Like we saw just before in the documentation
here you see my ID, he already helps me SL
189:06 - for j because I said we want to import only
SL for j and SL for j by itselves. knows that
189:07 - it should be used, I should use lockback because
it will find the dependency of log back classic.
189:08 - This one here. So SL for j is really smart.
So we don't have to tell it. Okay, so we say
189:09 - SL for j lager and we say import org SL for
j.no. Just one dot logger factory. Okay, a
189:10 - factory, by the way, is another design pattern.
At a later time, I will also do probably a
189:11 - course, only on design patterns. design patterns
are like best practices on how you should
189:12 - program code. And when you know what a factory
is, you will directly know what this thing
189:13 - he does. Okay, more about design patterns
at a later time. Anyway, this is what we have
189:14 - to do. And now in our class, we would probably
say private final lager. Let's call it log,
189:15 - because it's all log. And then we say logger
factory. Get logger. So what this factory
189:16 - does like a factory. This is why it's called
a factory. It gives us a logger. And we don't
189:17 - know how is it created on the fly is a longer
reused, this is a smart thing and does all
189:18 - the necessary work for us. Now, we should
still give it the name of this class. Because
189:19 - this will be used car service class. That
sorry, in our log back XML XML file which
189:20 - is in source main resources. As I showed you,
I mean, here we have a package, but we can
189:21 - even extend that and lock only for specific
classes.
189:22 - So this is the test and this is the service.
Okay, so this is how you generally find a
189:23 - logger. Now, in here, you can now use it log.
Well actually, it's not static. I might just
189:24 - as well have this in lowercase log dot and
in former times, like With log for j, some
189:25 - of you might know it, you would usually say
like this is debug enabled. If it's debug
189:26 - enabled, only then log something, log dot
debug. And now I could say, processing, car
189:27 - plus input. So the input given in our case,
BMW, this will create a string, and then this
189:28 - will be concatenated. together. And all this
will be locked, if the debug level isn't able,
189:29 - at the time when the code runs, which at the
moment, as far as I remember, it is. So we
189:30 - can activate and deactivate this. The reason
why we need this line, I mean, we could also
189:31 - do it without just like this. But this is
not so good. I mean, in case of a string,
189:32 - it's not so bad. I mean, all that would happen
is this string, and that string would be put
189:33 - together. But you mentioned the string could
be really of in almost infinitive lengths.
189:34 - So Java in the background for you, this concatenation
might take a lot of time, especially if we
189:35 - have some very big object here, that might
internally consists of other objects, and
189:36 - so on. So this creation of a string, as stupid
as this might sound can take a lot of time.
189:37 - And, of course, I mean, here, we just have
a very stupid small program with just one
189:38 - debug line. But of course, you would log maybe
not on debug, but on info or something, or
189:39 - error, maybe a lot of stuff in your application.
And like, you could think of 1000s users concurrently
189:40 - calling this method. And then if this only
takes, like, I don't know, 200 milliseconds,
189:41 - 200 milliseconds might not seem a lot of time.
But if this is done 1000s of times, then this
189:42 - can really consume a lot of performance of
your server or PC. And so we would only like
189:43 - to concatenate the string, prepare the string
for logging, if this will actually be logged,
189:44 - because if we say log info, but then the logging
framework finds out, well, this does not have
189:45 - to be locked, it would have to throw away
all the strings that were concatenated. So
189:46 - we had done this without any need. And so
this we would want to prevent. And this is
189:47 - why in lock for j, you would do it like is
debug enable debug. Or you can also say is
189:48 - info enabled is error enabled, and so on,
is info enabled. Now it's locked for j and
189:49 - SL for j However, there's actually even a
smarter way. Because you see, this was three
189:50 - lines of code. And this is you can put here,
these curly braces. And then you don't have
189:51 - to say plus, but you say comma. So within
the framework, the framework decides, well,
189:52 - the user in this case, this would be us wants
to log on debug, first of all check is debug
189:53 - enabled for this class. And if so, only then
take this input converted to a string if it's
189:54 - not a string already, and only then concatenate
this string with this string. So this is really
189:55 - a smart thing now. Okay, so another enough
of talking. Let's try this out. Okay, let's
189:56 - check. We have the input given from the process
method. And we want to say processing car,
189:57 - and then in our test,
189:58 - we put here BMW or Beemer. Okay, so let's
also recheck our configuration file, log back
189:59 - XML. We said comarca spiele. java course,
level is debug and the root level is info.
190:00 - So if we no log on debug, within this package,
and comarca spiele Java course this is the
190:01 - package. This means we should log it. Okay,
let's run the test.
190:02 - Okay, so something happened. Process finished
with exit code zero. And here you see
190:03 - at this time, which is now on level debug
from this class from this package car service,
190:04 - we wrote processing car column BMW. So this
was logged. Okay. Now, let's try to deactivate
190:05 - it. Let's say we only want to log on error
level for this package. Let's execute it again.
190:06 - Run. Process finished. On top, this is all
information from lockback. When it gets configured?
190:07 - Well, you see there is no BMW locked. Okay,
let's change that. We could say the root level
190:08 - is debug. And we could say or, let's have
this on, let's have this on debug. And now
190:09 - let's change the package. For example, Java
course two. Well, we're not in Java course
190:10 - too. But we are in the package called Marco
spiele Java course, which means we should
190:11 - log on the root level, which is debug. So
I would expect the test to log again. Let's
190:12 - try it run. And there you see it already.
debug, call marks will Java course card service,
190:13 - processing car BMW. So this seems to be working.
Okay. And here, again, you see the pattern.
190:14 - This is what's compared. Here, we have the
minus that we have set here, minus and then
190:15 - the message, and then this n, I think this
is for new line, so that when there's the
190:16 - next lowing a new line will be attached. Okay.
And this is the console appender. So this
190:17 - is the console that we can see here, in our
ID, if you would run this from the console
190:18 - with like, for example, a terminal here, you
would only see it within the terminal. Okay.
190:19 - So let's maybe go back to the documentation,
and check this a bit more. Okay, so here,
190:20 - you see, and you should really use read it.
Now, I'm just really fast going through it,
190:21 - you can read it typical usage pattern for
this is pretty much what we did. And here
190:22 - with the curly braces, we locked on debug.
Well, we could also change maybe, after reading
190:23 - the documentation, let's also log on Arrow
and info that you see this also works. And
190:24 - here, it's also explained what I showed you
binding with a logging framework at deployment
190:25 - time. So it says here lockback Classic, you
need this. If you want lockback as the logging
190:26 - framework, which we used. Yeah, so really
have a look here and read this. And here you
190:27 - see the dependencies, this is what we did.
You can also here you see you can use it with
190:28 - lock for J. But lockback, as I showed you
is like the successor for for j and there
190:29 - is also documentation of lockback which should
also have a look, by the way again. So the
190:30 - author is chechi Goku, and others. Yeah, so
see they they worked on these frameworks for
190:31 - 12 years. I mean, you wouldn't want to work
for 12 years and there are at least these
190:32 - three guys. So this is a lot of work and brain
power that has gone in that logging framework,
190:33 - which you can use just by configuring it in
your code. Okay. Yeah, and you see we have
190:34 - also done it import org. So for j logger,
and logger factory, here they made it static
190:35 - which is also fine.
190:36 - And here they log on info level. Okay. And
here's the configuration file. This I have
190:37 - also showed you Okay, and there are also other
appenders I think I have put them here. Let's
190:38 - see, oh, there's also the explanation you
can do it with logger is debug enabled, like
190:39 - I showed you, or you see better alternative
with the curly braces. Because this is I mean,
190:40 - basically, it's the same thing. But this is
three lines. And this like clutters your code
190:41 - easily. And this is only one line. So it's
nicer. Because logging, I mean, it's important
190:42 - that you want to focus on the domain, on the
business that you work in. And logging should
190:43 - just not be in the way of your business. The
business is important thing. And logging is
190:44 - important. Yes. But it's like not as important
as the business. So really have a look and
190:45 - go through all the documentation. It really
explains this really nicely. Okay. So now,
190:46 - I promised you, and then we should finish
already. We can also log on different levels,
190:47 - like you can see error. Well, as, as far as
I remember, we're still on debug level. And
190:48 - error is included within debug, because debug
is the finest logging level. So this should
190:49 - also look just here, I would expect to see
not debug but error. So that we know, well,
190:50 - we would use this in case an error occurred.
So that we can differentiate how important
190:51 - some logging event is. Now you see an error.
So we would write, oh, some error occurred?
190:52 - Well, in our case, this is not an error. So
we should also not log in on error. What else
190:53 - can we use? Let's see, we should also able
to log this on worn for a warning. So you
190:54 - would use a warning for something very close
to an error. But where no one has to manually
190:55 - interfere, then you could use one logging
level. And info you would use for example,
190:56 - when your server starts when your program
starts up, just so that the user of the program
190:57 - knows everything is fine. And like here, this
is an info level. So we are informed lockback
190:58 - is just starting up. Okay. And here you see
now we have one level processing car BMW.
190:59 - So now that we're using one level, let's put
the root level to error. And now the package
191:00 - that we're not using as well as the root level
are both on error. And it's printed to standard
191:01 - out, which is this appender the console appender
which is this console here. Okay, and now,
191:02 - I would not expect to see any logging. And
you see, just the info from doc back at the
191:03 - logging is gone. Which again, we can change.
If we say here worn or let's change this back.
191:04 - Here also we can say worn. So now we should
see the one locked again. Yeah, there it is.
191:05 - Okay, well, as I Oh, I think I promised you
to show you the appenders and I have not.
191:06 - So let's finally go back to Firefox. And see
I had it somewhere here found? employee No,
191:07 - this is not yet. But it's somewhere appenders.
There, this is easy. Chapter four appenders
191:08 - is really a good read. So I'm really fast
going over it. So outputstream appender, console.
191:09 - appender. This one we used. File append Not
this one is of course very important to write
191:10 - into a file and go through it read it. So
there you can set the encoding and all these
191:11 - parameters. And there are some really cool
appenders like rolling file appender Well,
191:12 - that means that new files are created when
like the file is has a certain size or like
191:13 - for every day we could have a new file. This
is important for servers because otherwise
191:14 - if we're always writing into the same file,
this very soon can reach
191:15 - tons of gigabytes. Yeah. And therefore on
production for a server you very often use
191:16 - a rolling file appender so that thing is really
important. Somewhere there should also be
191:17 - ODP appender that is supposed to To log into
a database directly, really cool thing. And
191:18 - this is really very easy to be configured.
Where is it, it was down somewhere. Somewhere,
191:19 - somewhere somewhere, maybe I've already missed
it, there is an SMTP appender, I would assume
191:20 - from the name that is used for logging, sending
an email when there is a lock event. And somewhere,
191:21 - that was also the DB appender. I know it is
SMTP appender, blah, blah, blah, blah, ebf.
191:22 - There it is. So this allows you to directly
write into a database, and you see all these
191:23 - databases are supported. So this is really
great stuff, and so on, I mean, this page
191:24 - still goes on. So there are really a lot of
appenders out of the box that you can use.
191:25 - And as I said, you can always extend it and
write your own appender, which allows you
191:26 - to lock to any other source. So that pretty
much rounds up logging. I would like to show
191:27 - you the main method of Java. The main method,
as the name implies, is the method that is
191:28 - used to start a program initially. However,
as this course, is done in test driven style,
191:29 - or TDD In short, so far, we actually never
used it. Because we start programming by writing
191:30 - a test. And so far, we use the test to execute
our code. Well, actually, as you might have
191:31 - guessed, at some time, when you're done with
development, you would want to run the program.
191:32 - And for this, you will need a class that has
a main method. So how does this main method
191:33 - look? Well, it's not so different from any
other method. It is a public method, so that
191:34 - it can be started from outside of the class.
It is a static method. Because we want to
191:35 - run the method without having an instance
without having an object of car selector.
191:36 - Because the class car selector in this case
here is only the like executer the, like the
191:37 - frame that we use to start our program. And
therefore, I mean, we also only need, we don't
191:38 - need further instances of this class. And
this is why the method is static has to be
191:39 - static by definition. The method is void because
it doesn't return anything. And the name must
191:40 - be made. So that it can be found by Java.
By the way, I might notice shortly, I always
191:41 - say noticed by Java. Well, actually, what
I mean is noticed by the compiler, because
191:42 - the compiler will compile the program to bring
it into an executable form. Well, compiler
191:43 - is a big topic, there are huge books, if not
even libraries about compilers that you can
191:44 - so you could even study compilers. So I tried
to prevent to keep you away from that topic.
191:45 - But maybe, if I keep talking about Java, executing
something, I maybe should now say compiler,
191:46 - and at a later time, I might do a dedicated
session on my bit of compiler details. So
191:47 - that you will know more about compilers. So
anyway.
191:48 - Okay, so back to the public static void Main
method. Now we add the brackets, but actually,
191:49 - they have to contain something, because when
we start our main method, we want to be able
191:50 - to give it arguments that the program might
need to run and this is obligatory. So these
191:51 - are arguments that come as input as strings,
but as there can be a number of strings. This
191:52 - is an area here. So square brackets, and all
the name of the string array. You can use
191:53 - any name, people usually would set here arcs.
This is what you would see in documentation
191:54 - I usually prefer arguments, because this is
more readable. Okay. And then of course, as
191:55 - always, for our method, you would have the
curly braces, the opening and the closing
191:56 - curly brace. Um, yeah. And that's already
it for the main method. Now, let's leave it
191:57 - empty for a moment. And now when you compile
this class here, on the console using a terminal,
191:58 - you can execute this Java class. And it will
then call this main method automatically.
191:59 - So this is the place where you like set up
your whole program. In the last episode, I
192:00 - created a car service. So we can use this
in here, car service car service. But I mean,
192:01 - technically, it also works to run just the
empty main method, it will just not do anything.
192:02 - So let me directly say new car service, no
title car service.
192:03 - Okay.
192:04 - And then you can call the method, car service
dot process. Yeah, remember, and this requires
192:05 - an input. By the way, just to show you what
is possible in Java. You can also do all this
192:06 - on the fly, you can say new car service thought
process, the only difference is that, you
192:07 - will then just call the method, and you will
not have any variable to access the core service.
192:08 - If you don't need it, that might be fine.
Well, the only thing missing now is a string.
192:09 - And I mean, we could use any string here,
like PVC. But I mean, to make it a bit more
192:10 - interesting, we could no, take the string
array. And as as this as this is an array.
192:11 - Of course, we need a for each loop, which
are also introduced already. So let's say
192:12 - string argument for one, colon arguments.
So this is iterating through our array, that
192:13 - will be given to us. When the program runs
at runtime, opening curly brace again, closing
192:14 - curly brace.
192:15 - Okay.
192:16 - That was formatting it. Okay, and now I can
take that argument. And so dynamically call
192:17 - the process method, dynamically creating an
object. While this is always creating a new
192:18 - object. So I mean, I wanted to show you that
this is possible. But of course, it would
192:19 - probably be smarter to just create one object
and then put a reference on this object. So
192:20 - this would be from the performance perspective,
probably faster. But it's really hard to talk
192:21 - about performance. Because the compiler these
days is really smart. It might, it often recognizes
192:22 - stuff. And when before a while it compiles
it can optimize your code. So talking about
192:23 - performance is a topic by itself. And you
would usually test for performance just by
192:24 - saying this will be fast or slow. You can
hardly do but again, performance. Yeah, I
192:25 - could also do a course only on performance
really a big topic. Um, yeah. So now I created
192:26 - an instance of car service. And in the main
method, I have this for each loop. And then
192:27 - for each argument that is given to our main
method when the program is run, we call the
192:28 - car service. Now let's execute this. Because
now we can run this without actually a test.
192:29 - Well, I mean, in this episode, I want to show
you the main method. But I mean, what I said
192:30 - still holds true, you should always start
programming with writing a test. But anyway,
192:31 - see, now I have a run car, see, like the domain.
And I can execute the main method directly.
192:32 - Here. This shows me the console directly in
my ID. Well, it seems like there's nothing
192:33 - printed. This could either be because in the
class, remember, we had the logging, the logging
192:34 - could be deactivated, but so far, I remember
it's still active. It should log on worn at
192:35 - the moment. Well, the reason this doesn't
work. Anything is a different reason. And
192:36 - the reason is, well, we didn't give our program
any arguments. So I mean, this is running,
192:37 - this is not throwing any exceptions. By the
way, we will talk about exceptions very soon.
192:38 - But it's empty. So the for loop will actually
not be executed at all.
192:39 - When the program is run, so we will directly
jump to line nine or 10, just after it so
192:40 - the program will directly exit. But we can
change this easily using our ID, I can click
192:41 - on Run, and I say Edit configurations. And
here, I can configure how my main class see
192:42 - this also contains always the full package
name. So how this is run, I can give it some
192:43 - program arguments. So on the console, that
would be car selector, and then whitespace,
192:44 - and then the program arguments. So let me
put here a few car names. BMW, or shi. C,
192:45 - Mercedes. Yeah. And then Okay. And then let
me run the main method again. And now you
192:46 - see, we have three warning loggings processing
car BMW processing card pushy, and processing
192:47 - commerce. seeders. Yeah. So that's the main
method.
192:48 - Um,
192:49 - one more thing just really slightly mentioned.
What is also possible and not many people
192:50 - know is you can do this. Now what does that
mean? And see, all the code is still working.
192:51 - This thing with the three dots here is called
a foul arcs. Like a variable argument parameter,
192:52 - which means when this is defined like this,
the code, the method that would call our main
192:53 - method, while in this case, it's directly
started by the virtual machine itself. This
192:54 - would have the ability to directly put in
strings that will be converted automatically
192:55 - by the compiler to an array. So this is very
close to an array, but it's like just more
192:56 - convenient for whoever calls that method.
192:57 - Just so that you have seen this would also
be possible. The question is, does it make
192:58 - sense because, well, Normally, you would not
call the main method directly.
192:59 - So if you don't call the main method directly,
it doesn't make a difference. But of course,
193:00 - you can write a test and you can call the
method directly. And in this case, it would
193:01 - make a difference because you could directly
call the method which just one string? Yeah,
193:02 - but let me talk about Fox arguments at a later
time. Okay, so let's re add. Let's make this
193:03 - an array again.
193:04 - Okay.
193:05 - So now, string array arguments. Okay. So that
much about the main method, now, maybe a bit
193:06 - of background knowledge for you. So I don't
know if my Java course is actually the first
193:07 - Java course you ever listened to? I guess
in most cases, you would probably already
193:08 - have heard another course or read the book
about Java. And in this case, you might not
193:09 - directly understand why didn't talk about
the main methods so far. I mean, this is Episode
193:10 - 14 already. So let me give you the reason
for this. Because I really decided to do so
193:11 - specifically. Because this is really a main
a main decision for me. Okay, so the reason
193:12 - is, first of all, I think, in the very first
lesson, when you have never heard about Java,
193:13 - and its keywords, it's hard to directly be
confronted with public static, void. This
193:14 - is just the name of the method would be okay,
but public static void, and then even an array.
193:15 - All all this stuff for a very first lesson
in Java is a bit much I think. Now in our
193:16 - episode 14, you should by now know what public
means What static means what what means. And
193:17 - we have also talked about arrays. So I hope
that by now, you can easily follow my explanations,
193:18 - and you understand what all this means. Okay?
And then second, also, this is a static method.
193:19 - And I told you, I think various times, Java
is an object oriented language, where you
193:20 - usually focus on creating objects, but static,
this method is not object oriented. There's
193:21 - just one version of this method. I mean, of
course, it might make sense. But, yeah, as
193:22 - you should try to avoid static, wherever possible,
I think showing you a static method in the
193:23 - very first Java lesson might lead you to the
wrong conclusions. Yeah. And then also, next
193:24 - reason is, um, even though, I mean, the main
method is, on the one hand, very important,
193:25 - because you use it to actually execute your
program to actually get your program running.
193:26 - For any program at hand, you would have only
one main method. And usually programs would
193:27 - consists of hundreds, if not 1000s, of classes.
And just one main method. And last but not
193:28 - least, I mean, this counts for Java, se. But
if you like program a server application,
193:29 - what you usually do is you don't re implement
all the server code. But you would like use,
193:30 - for example, an open source server implemented
in Java, for example, Tomcat, and such a server,
193:31 - I mean, has already been implemented for you.
And so you use that as like an infrastructure,
193:32 - even though it's software. And so the Java
code you write will run within that Java software
193:33 - infrastructure. And therefore, when you program
code for server, you usually don't write even
193:34 - a main method at all. So, for example, in
my case, I mean, I have programmed in Java
193:35 - for pretty much 14 years now. But I have maybe,
I don't know, 10 times 20 times, well, definitely
193:36 - less than 100 times I have programmed a main
method, while I have programmed really 1000s
193:37 - of classes, I'm sure. So the main method is
not so important. And, yeah, so we started
193:38 - with writing a test anyway. So you are also
able to run your code, at least for testing
193:39 - without the main method. Of course, I mean,
the tests. For example, let's look at this
193:40 - one. This one is based on the framework j
unit. And j unit by itself is a Java program.
193:41 - So j unit does have a main method. Of course
it does. But you don't see it. All you see
193:42 - is the test methods that we write. And his
test method, they like plug into the whole
193:43 - j unit mechanism, bet so we don't have to
write the main method. I mean, this is why
193:44 - just using a framework, like j unit is so
handy, because it saves us from writing our
193:45 - own main method. Yeah, and I promise you,
you can actually even execute even the main
193:46 - method as if it was a regular method. Now
here you see I have prepared that he is an
193:47 - array of string arguments, BMW and Porsche.
So this static method is called with the given
193:48 - arguments as execute the test. And yeah, you
see, this works just as well processing car
193:49 - BMW processing car pushy.
193:50 - And,
193:51 - as one last thing, maybe you'll see I could
change the signature of the method. Like I
193:52 - could say the method returns some end. In
this case, just as an example 42 I could even
193:53 - not make it static anymore. I can change it
in any way. This is okay as it's a Java method,
193:54 - it just will not be recognized as a regular
main method. So this will will not allow us
193:55 - to execute it as a Java program, but our test
can still execute it as it was before. I mean,
193:56 - now this is returning something. So we don't
use the return value, but we could in return
193:57 - use equals to Yeah. So you see, it's really,
we're calling the main method returning something.
193:58 - And we can still call it from the test. But
if we want this to be really a main method
193:59 - that will allow us to start a program, then
the signature must look like this. Okay, so
194:00 - I think that's pretty much all I can tell
you about the main method, I'm really happy
194:01 - that we were finally able to have a look at
the main methods. So now, with the 14 episodes
194:02 - that I've done so far, I think this course
now really has gone quite far, by now you
194:03 - should really know quite a lot about Java,
and should be able to write your own programs
194:04 - by now, I will, of course, add a few more
things. But By now, you should really be able
194:05 - to write your own small programs. I would
like to talk about Exception Handling in Java.
194:06 - So first of all, let's have a look at some
theory, and some background information about
194:07 - exception handling. And then later on, we
will as always, directly jump into my ID.
194:08 - And I'll show you how to do Exception Handling
in practice. Okay, so as you see, this is
194:09 - the Wikipedia article about exception handling.
So first of all, let's have a short look at
194:10 - the definition. So here this article says
exception handling is the process of responding
194:11 - to the occurrence during computation of exceptions,
and animals or exceptional conditions requiring
194:12 - special processing. Okay, let's stop here.
Let's digest that. So, um, I think what is
194:13 - very important is two things. First of all,
it is about exceptional conditions. Because
194:14 - in my opinion, this is something that many
programmers get wrong. I mean, an exception
194:15 - is called an exception, because it should
handle exceptional conditions. So the question
194:16 - really is what is an exceptional condition.
While in my opinion, an exceptional condition
194:17 - is something that really, as the name implies,
only happens exceptionally which means only
194:18 - really rarely, only in very specific situations.
And those situations are an animal's soul.
194:19 - So for example, programming errors, you when
your program, you introduce the buck, you
194:20 - forgot to like you have an array, and you
have one field that is empty. And I talked
194:21 - about that means it has a field that is set
to now. And then when you try to access this
194:22 - field, that, for example, can throw a so called
null pointer exception. Well, that would be
194:23 - really an exceptional case, which you wouldn't
have guessed it would happen. And yeah, that
194:24 - would be one reason for an exception. So exception
handling is really the, as it says here process
194:25 - of responding to the occurrence of exceptions.
So something exceptional happens. And then
194:26 - we need
194:27 - a way to react on that to handle that. Some
special processing, which is not the normal
194:28 - program flow. But the cool thing about Yeah,
this also sent here, often changing the normal
194:29 - flow of program execution. because ideally,
we want like a central place that handles
194:30 - the exceptions. And so we want to leave the
normal program flow and we want to just specifically
194:31 - take care of this exceptional case. Okay.
And here continues, it is provided by specialized
194:32 - programming languages, which gives us a hint,
it is not provided by all programming languages.
194:33 - Well, let's have a look at the history which
will tell us. Yeah, software Exception Handling
194:34 - developed in Lisp in the 1960s and 1970s.
Well, I think the first programming language
194:35 - was invented by Conrad Sousa in, like 1943,
or something. So you see, it took a while
194:36 - until they finally came up with the idea of
exception handling, that something like this
194:37 - is really necessary. And, well, maybe a bit
more about the history and Java, because again,
194:38 - with Java, there was some something new introduced,
and that is checked exceptions. Before all
194:39 - exceptions were unchecked, which means any
line of code can throw any kind of exception.
194:40 - And there is no mechanism that forces you
to handle it, if you don't handle it. That,
194:41 - for example, causes the program to stop. And
well, therefore, as soon as exceptions were
194:42 - like introduced, many times nasty things happened.
And so when they invented Java in like 1995,
194:43 - or something, they thought, well, maybe we
should do this a bit better. And well, first
194:44 - of all, let's have a look. Check the exceptions
here. The designers of Java device checked
194:45 - exceptions, which are a special set of exceptions
194:46 - here.
194:47 - Okay, and to make it short, so what's the
difference about checked exceptions, he is
194:48 - also already an example and i o exception,
which happens when there is a problem with
194:49 - an IO operation input output operation. The
difference with checked exceptions in Java
194:50 - is they must be declared explicitly in the
method signature, or be handled. If you don't
194:51 - do that, you will directly get a compile time
error, which means you're not able to even
194:52 - compile your program. I looked at actually
up I think it's here it's quite interesting.
194:53 - Like how it came with the checked exceptions.
The Java programming language introduces the
194:54 - concept of checked exceptions, checked exceptions
must be handled in a method, or the method
194:55 - must declare the exception in our throws clause.
Now it continues, I think here it's even more
194:56 - interesting. According to Anvil wrath, who
was there at the beginning, the credit for
194:57 - the Java exception scheme should mostly go
to Jim Waldo. And then they go on. And here
194:58 - after some consideration, Java was retooled
to have checked exceptions, only those exceptions
194:59 - for which there was no recovery, or reflect
application errors would be unchecked, and
195:00 - the world was safe again. Well, so they thought.
Now, in the meantime, it's 2015, which just
195:01 - like 20 years later, and it turns out, that
was not so smart. Because the problem is,
195:02 - and this is also why stated at the beginning,
maybe we should go back to the very top. Exception
195:03 - handling is the process of blah, blah, blah,
blah, blah, blah, blah, exceptional conditions.
195:04 - And this is the important part. Because they
had the idea to have still unchecked exceptions
195:05 - for something like programmer arrows for something
that is, as the name implies, exceptional,
195:06 - and to have the checked exceptions for everything
else. But now I ask, why have checked exceptions
195:07 - for these cases that can be handled? Why not?
If you if you can handle a specific situation,
195:08 - why not that instead validating that situation?
And not at all throwing an exception? And
195:09 - also, and now maybe we should already jump
into the ad because I guess it goes too far.
195:10 - on too much theory. Let's directly jump into
the code. So yeah, so here you see An email
195:11 - that I've written car stayed with a different
states driving, waiting and parking. I've
195:12 - written this public static from method that
converts a string to a car state using a switch
195:13 - statement. I told you, in a previous episode,
that since Java seven, it's possible to use
195:14 - a switch inside air to use a string inside
a switch. And I want you not to do it. This
195:15 - still applies. But in this case, I assume
that we are getting input from the console.
195:16 - And input from the user coming from the console
cannot be an enum must be a string. So this
195:17 - is all I mean, for every rule, there is an
exception. So this is an exception to the
195:18 - rule, which is here, we do have a switch,
switching on a string. But now here, we have
195:19 - the default case. And I also told you, I wouldn't,
I will only throw exceptions and the default
195:20 - case, so that it cannot happen, that someone
adds a new state. And this new state would
195:21 - then be handled by the default case without
anyone noticing, to have the fail early principle.
195:22 - And so I told you to throw an exception, but
I didn't show you yet. While we can do this
195:23 - now, and this is quite easy. You can just
say throw new exception, because an exception
195:24 - in Java is just an A class. Like almost any
other class, while it has some specific
195:25 - methods and stuff, but at least it's an it's
a class and we create, we can create objects
195:26 - from it. Now, you know, you already see a
checked exception and action. And you see
195:27 - how the compiler already wants me unhandled
exception. java. lang exception. So this is
195:28 - also the package java. lang exception. And,
yeah, this is the number one checked exception.
195:29 - Don't ask me why it's called exception. If
it's actually a checked exception, something
195:30 - like a checked exception. I mean, the name
was not used within Java Lang. So you just
195:31 - have to know that this exception is a checked
exception. And on top, the default, unchecked
195:32 - exception is an is a runtime exception. This
sorry, also not my fault. This also you have
195:33 - to know I mean, runtime makes sense, because
something that goes wrong at runtime. And
195:34 - so you would normally use a runtime exception
for things where you don't know how to handle
195:35 - them directly. And the idea was, as I said
before, to have checked exceptions, for cases
195:36 - where you know how to deal with them. But
as I said, if you know how to deal with them,
195:37 - why not dealing with them without throwing
an exception beforehand, using validation?
195:38 - But anyway, let's continue. So how can we
fix that compile time error? One reason is,
195:39 - at exception to method signature, let's use
our ID to help us and here it adds throws
195:40 - exception. Now you see the compile time error
is gone. Nothing is read anymore, it seems
195:41 - like we fixed the problem. So we told the
Java compiler, we know there is a checked
195:42 - exception. We just don't care. The color should
take care of it. And now I have this car service
195:43 - class here. And I made it to use the static
from method that I implemented. And you see
195:44 - now this class has the problem. Okay, again,
let's do the same thing. Add exception to
195:45 - method signature. Okay. And I guess you know,
where this leads to. Now we are the main method.
195:46 - And again, we have the same problem. Well,
we can notate This is all the wrong stuff.
195:47 - Seems like we're on the wrong line. But yeah,
I can no here appears add exception to method
195:48 - signature. Okay. Well, sorry, I'm just lazy.
I could of course have written that myself.
195:49 - But whenever you write something, you have
the chance of introducing a typo like this.
195:50 - So whenever possible, I prefer to have my
ID he helped me and to have code written automatically
195:51 - by the ID that can save From introducing bugs
with typos for example. Okay, so now this
195:52 - will be, like fixed. But now the question
is, what did it help us, we have here throws
195:53 - exception, we have here throws exception,
and we have here throws exception. So three
195:54 - times we had to add this throws exception.
And only because Java tells us this is a checked
195:55 - exception. But besides, we didn't handle it,
which means what will happen when I execute
195:56 - the code, and the default case is chosen,
the exception will be thrown, it will be Bob,
195:57 - it will bubble up to the top to the main method.
And as the main method doesn't handle it,
195:58 - the program will stop. And we will see the
exception stack trace. Yeah, same thing we
195:59 - could do, for example, with a runtime exception,
throw new runtime exception. Also in in both
196:00 - cases, you can and you should add some meaningful
message that tells us why the exception happened.
196:01 - So let's say on state, and concatenate that
with a given state. Oh, okay. So now, I can
196:02 - still keep it. But I don't have to. It's not
obligatory anymore, because this is not a
196:03 - checked exception anymore.
196:04 - Same here, I can remove all these. And this.
So now I have exactly the same code. The only
196:05 - differences I mean, I'm not handling the exception,
that my method signature doesn't get any longer.
196:06 - Because he mentioned again, I'm always bringing
this example, you have a huge program of hundreds
196:07 - of classes. And as soon as one method has
that throws exception, this is really contagious,
196:08 - which means another method, sooner or later,
we'll use the method that says throws exception,
196:09 - will then also have to say throws exception,
this method again will be used. And sooner
196:10 - or later, you will have that throws exception
in each and every method. And then it doesn't
196:11 - help us at all. It just makes the code more
wordy, let's say. And yeah, it's not really
196:12 - meaningful. So anyway, let's first of all
provoke that exception that we see how such
196:13 - as exception stacktrace looks like for this
to happen. I have to call the main method.
196:14 - And I have to give it some some argument that
we don't know yet. Okay, let's go here run.
196:15 - I think I have prepared something already.
Edit configuration. And yeah, flying parking,
196:16 - driving, driving ABCD E, F, G, because also,
I wanted to show you, I mean, I've introduced
196:17 - the main method only in the prior episode.
So here we have some valid states, as well
196:18 - as some invalid states. Also in lowercase
letters, it will should be invalid. And as
196:19 - we're iterating through the arguments and
a for each loop, we should see. Well, let's
196:20 - just let's just do it. actually still have
to run it. And let's have a look what happens.
196:21 - Okay, so you see, the exception happened.
I'm on state flying. So I would assume the
196:22 - reason is that this happened for the very
first time the first argument was already
196:23 - flying. So this is our program stopped. This
is the reason because it's not handled. Now,
196:24 - we could also handle it to show you what's
the difference. Now the question is where
196:25 - to handle such an exception? Well, always
as early as possible, like at the class that
196:26 - can do something about the exception. In our
case, um, I just defined that. In the case
196:27 - that I get a wrong argument from from when
the program is called as an argument. I want
196:28 - this to be printed to the console, so that
the user knows which means I mean, I wanted
196:29 - to be printed here, which means the first
place where I can handle this exception is
196:30 - only here on the very top. And so there is
this new construct, I say, Troy, which is
196:31 - like telling the compiler, I know something
evil can happen. And I just want to try it.
196:32 - But now I can say catch. And I can catch this
runtime exception. Usually, I mean, I don't
196:33 - like really short variable names, because
they're not readable. But in the case of an
196:34 - exception, because an exception log is always
very, very short. The default is to call the
196:35 - exception for with E, for exception. And I
think here, this exception is okay. Because
196:36 - we don't want too much with the exception,
and the block will be so small that everyone
196:37 - knows the E is for the exception. Okay, so
curly braces. And now we can do various things.
196:38 - First of all, we could say e dot print stack
trace.
196:39 - Well, this is actually exactly what we have
here. This is the stack trace, the stack,
196:40 - you can think of as a list of all the methods
that were called in reverse order. So here
196:41 - you see main process from can also jump there.
I mean, this is not, this doesn't hold true
196:42 - anymore, because I've no edits code. But at
the time, we executed this code, and the exception
196:43 - was thrown. This told us exactly in each class,
where the exception happened while he is still
196:44 - true. And he also, but in my car selector,
I have adjusted the code, by the way about
196:45 - this. The fact that I've adjusted the code,
also, when you sometimes have a stack trace,
196:46 - and you need to analyze where it came from,
this is really often happening, that the code
196:47 - that is running on production is older than
the code that you develop on, because of course
196:48 - development continues. And then you can only
find out the exact place where the exception
196:49 - happened, if you keep the exact same code
that you have running on production. Yeah,
196:50 - but this only really, I don't want to go into
more details. Um, this would be a topic on
196:51 - its own, again, about revision control. And
this is really a huge topic. But yeah, just
196:52 - that, you know, the stack trace is really
helpful if and only if you have exactly the
196:53 - same code that was implemented at the time
this code was running. I mean, that they're
196:54 - both in sync. Okay, so print sectors here
wouldn't make sense, because in this case,
196:55 - it's just the default anyway. But this can
be used. And it's often used to lock for example,
196:56 - in I don't know, was it Episode 13? I think
I talked about logging. And so when you want
196:57 - to log an exception, you can do it like this.
This is usually how you do it. Well, I haven't
196:58 - got the log class here. And I don't want to
do log error or log one you will say and this
196:59 - depends error only when there is something
that has to be done. For example, a database
197:00 - that has to be restarted. In other cases,
probably one is also okay. Okay, message is
197:01 - the string that I added into the constructor
of the exception
197:02 - here.
197:03 - And I have removed the stack trace, because
this is actually done inside of the log object,
197:04 - which I want to add. Now. If you want to know
more about logging, have a look at my episode
197:05 - 13 where I explain logging in detail. Okay,
so logging is one thing we can do. But in
197:06 - this case, I say I don't want to log it, I
want to directly printed on the console. I
197:07 - think also in the episode about logging, I
want you not to do it always to prefer logging.
197:08 - But in this case, let's assume we have just
a very small program only be used to run something
197:09 - from the console. And in this case, it can
be okay to just say system error dot Clinton.
197:10 - Which I also wanted to show you once print
ln For new line, and here, then I can say
197:11 - dot get message. Or I can also say e dot print
stack trace, which doesn't make sense, because
197:12 - we already have that. So to alter the behavior,
let's do this. Okay, let's run it again. Now,
197:13 - you see something else. You see the program
hasn't stopped. But instead we see unknown
197:14 - state flying Unknown, Unknown state driving
an unknown state abcdefg. Yeah, so all the
197:15 - invalid states were printed out. Without we
don't even see the exception anymore. And
197:16 - it's red, because I use system error Clinton,
I could also use out print on because this
197:17 - is a special channel, only for errors. And
this is printing in general. See, now it's
197:18 - white. But really, I still warn you don't
overuse system out or system error print on.
197:19 - Because Yeah, you can't configure it like
you can configure logging. So in 99% of the
197:20 - cases, using a logger is better. Anyway. So
let's have a look at the code now and think
197:21 - is this really nice. Now, we have a for loop,
we have a try, we have a catch. Um, you see
197:22 - a lot of different hierarchies and a lot of
different levels that we have to understand.
197:23 - And this is something I really don't like,
this makes the code quite complicated. Okay,
197:24 - so this is something you should try to prevent.
And, anyway, I can also, alternatively show
197:25 - you, we could do exactly the same.
197:26 - If this was throwing an exception. The only
difference is that if we're not handling it,
197:27 - we have to add the signature
197:28 - throws throws. So yeah. Maybe also, I should
now show you the alternative. If If we don't
197:29 - want to add the method signature, the exception
signature, we can directly in here, say catch
197:30 - and then handle it. And then I mean, handling
an exception does not necessarily always mean
197:31 - you have to print it, I mean, printing, it
doesn't really solve the exception, it might
197:32 - be even better to really have a method that
does something about the exception, and which
197:33 - I call no handle the exception. The only problem
with that is, and I'm not implementing the
197:34 - method now. And this is what I said before,
I'm the case that you're really able to do
197:35 - something about the exception, which in this
case, I mean, what could we do, if the user
197:36 - typed in something wrong? There's not much
we can do? Well, there is one thing, we could
197:37 - for example, ask the user to type in to fix
the state he typed in. But this we couldn't
197:38 - handle here. So again, if we want to, like
ask the user to do something about it, I would
197:39 - instead validate
197:40 - the state. So let's remove all that. Let's
for the time being I add the runtime exception,
197:41 - but I will change it very soon, because now
instead, I want a validation at it. And this
197:42 - can be done in the following way. I remove
all that trycatch instead, I say Valley date
197:43 - argument and now I can implement that method.
Create method validate my ad he helps me again.
197:44 - I'm
197:45 - now well actually I want to say is valid with
a Boolean returned. Okay. Now, you see this
197:46 - is also interesting, by the way about the
main method because this method is static.
197:47 - Also, this Method automatically esthetic.
So because when this method is static, a static
197:48 - method cannot call a method that is not static,
because an instance method can only be called
197:49 - when there is an instance. But for the main
method, we won't create any instance, of course
197:50 - selector. So for this reason this is static,
and it's private, because we don't need to
197:51 - call it from outside, only the main method
will call it. Now how can we validate it?
197:52 - Well, for example, we could use a method directly
provided to us from the enum class, and that
197:53 - is value of this is not implemented by us.
But it's implemented, like automatically,
197:54 - when they implemented when they invented the
enum and Java, this is one method that you
197:55 - get for free. So this will directly try to
convert your string to an enum. So here I
197:56 - can say car stayed. Cars date. So this actually
does exactly the same thing. Like our switch
197:57 - did. So actually, we won't need it anymore.
Very soon. The difference to the method that
197:58 - I implemented is or bill, I did it actually
also like this, when the conversion doesn't
197:59 - work, this will throw a runtime exception,
I think, an in because they have different
198:00 - types of runtime exceptions. And I think it
will be an illegal argument exception to tell
198:01 - us the argument that you are giving that you
are giving to me, sorry, is invalid. But still,
198:02 - it's a runtime exception. So and because this
will throw an exception, we have to add the
198:03 - try catch block here, because we want to handle
this. Try catch. And then I say runtime exception
198:04 - he or I hope I'm right. I can directly say
in valid on
198:05 - invalid
198:06 - human exemption, there it is. I think that
should be the one if not, we will see it because
198:07 - the exception will not be caught. Okay, and
then here, we can just return false without
198:08 - logging anything.
198:09 - Now,
198:10 - let's see, this is the wrong one, because
we can't catch an exception that is never
198:11 - thrown. So invalid. Let's see what the lead
catch. Now this is not what I want. Maybe
198:12 - it's an invalid state exception. Yeah, this
works. So see, this is also how you see this
198:13 - value off may throw an invalid state exception
if the argument given is unknown, in case
198:14 - of, for example, flying driving ABC. Okay.
198:15 - And
198:16 - to be honest,
198:17 - um,
198:18 - I think this is also not optimal, that we
only have this value off method, I think it
198:19 - would be much, much nicer if the IEM base
class will directly provide is valid method
198:20 - just returning true and false. But again,
seems like the inventors of Java doesn't didn't
198:21 - listen to my opinion, crap, just making a
stupid joke.
198:22 - So for this reason, we do have the exception,
but we are able to convert it. So because
198:23 - we converting it directly. The exception doesn't
be doesn't pollute our whole system, let's
198:24 - say like this. And we can now say here, return
true. Which we could also put at the end of
198:25 - the method. This is exactly the same. Yeah.
So wherever you have it. So and this is also
198:26 - the jump. I mean, imagine you could have lots
of other code like system out print owns and
198:27 - just print something. So you could have many,
many more lines. That would do lots of stuff.
198:28 - Let's just copy and paste that to show you
many more lines. We could even reassign car
198:29 - state to something else. Let's just say now.
So what happens if This line of code doesn't
198:30 - work out, because the argument is unknown,
for example, flying. When the code is executed,
198:31 - the execution will jump from here, directly
into the catch. So this is leaving the normal
198:32 - program flow, the normal program flow would
go from line 2122 2324 25, and so on. But
198:33 - here we're jumping from line 21. To line 28.
Yeah, and this is helpful, because, for example,
198:34 - imagine we have done this several times, for
examples here. And there, even maybe in sub
198:35 - methods, then we have just one catch, that
would handle all these different places where
198:36 - an invalid state exception could happen. That's
the idea of exception handling. Okay, just
198:37 - to give you some more details, actually, I
don't even need that. So I would remove it.
198:38 - We're only like, abusing that volume of method
to have the information. Is that valid or
198:39 - not? Okay, and now I can react on that. I
can say if not valid, or I can say only, like,
198:40 - only process it if it's valid. Yeah, maybe
let's do this. Because you saw already hold
198:41 - the invalid states are printed. Now let's
do something else. Let's only process valid
198:42 - arguments. The question, of course, is, does
that make sense? Now we wouldn't even realize
198:43 - we have a problem in our code. So maybe we
should also say else. Print that we have problem.
198:44 - system error dot print. ln M. invalid. argument
given? Or let's say ignoring, ignoring invalid
198:45 - argument. So this, by the way, whenever you
log, I think I'm not repeating myself, because
198:46 - I already talked about logging, but I can't
say it often enough. Always add as many arguments
198:47 - as possible, so that whoever is responsible
for a problem knows why this happens. Otherwise,
198:48 - yeah, it's really hard to understand why something
doesn't work out. Oh, no, we still have an
198:49 - illegal argument exception. How is that? I
don't know. And this is interesting, because
198:50 - we can now check. Like, this is what I told
you. It's in car state. There's, ah, we still
198:51 - have the from it seems like we call it somewhere.
But no, I'm wrong. Because the session line
198:52 - five, so this is not yet. Car state. Illegal
Aha, this is why See, I was wrong. This is
198:53 - the invalid state exception. And what is actually
thrown by Java is the illegal argument exception.
198:54 - So see, this is actually what happens most
that we see it. No, no constant flying. So
198:55 - this is what Java gives us. It throws an exception.
And this now we will catch. Okay, let's retry.
198:56 - See, this is how everyone introduces sparks.
And this is why we need tests. Today, I'm
198:57 - not doing a test because I just want to show
you exceptions. But
198:58 - yeah. We do need tests. Tests are very important.
Okay, now it works. See, ignoring invalid
198:59 - argument flying ignoring new argument driving,
ignoring invalid argument abcdefg. And the
199:00 - valid argument was processed. It just didn't
lock just didn't do anything. Which of course
199:01 - we can change. Here we could say system out
print. ln, again, this thing here is evil.
199:02 - Only use it in very rare situations. Yeah.
I can say bellet. Stayed. Car stayed. executed
199:03 - again. Yeah, so you see three invalid states
and two valid states. Okay. So of course,
199:04 - I mean, this was just an issue. Sample Normally,
you would have some method doing something
199:05 - about the state
199:06 - further,
199:07 - do something with the car state. I mean, I'm
just making this up, because all I want to
199:08 - explain you is exception handling, but I hope
you get the idea. So anyway, there's one more
199:09 - thing. And then actually, I would like to,
like, shortly recap the important points of
199:10 - exception handling. And the missing thing
now is, oh, by the way, let's remove the from,
199:11 - because I showed you, we don't actually even
need this anymore. Okay. Because what you
199:12 - can also do is finally, finally, this is very
important, not in our case, now, I'm just
199:13 - making some something up. Finally, as the
name implies, this is done. Finally, at the
199:14 - end, no matter even exception happened or
not, this block will always be called. And
199:15 - this is important. When you have resources,
when you have input output operations, or
199:16 - in short I O, which you have, if you communicate
with a database, if you read something from
199:17 - a file from your hard disk, Yeah, something
like this. Because when you like read something,
199:18 - especially from external systems, who can
tell you that the external system is actually
199:19 - available, or like the hard disk could fail.
And so with i o operations, there's always
199:20 - nasty stuff that can happen. But there's one
important thing, which is, for AI operations,
199:21 - you need resources. And so you have to close
them. In any case, otherwise, you really could
199:22 - have a problem with more and more resources
lost. So yeah, this is a big topic, I can't
199:23 - explain it in like a second. But all I want
to tell you for now, this finally is very
199:24 - important when you deal with IO operations
that might fail. And in this case, you can
199:25 - close these resources and close resource for
now I'm just giving you my resource, this
199:26 - stupid method. You can implement that yourself.
But also they are very cool. Helping utility
199:27 - classes found on the internet, open source.
Like for example, I Oh, utils. Oh, it already
199:28 - find something. But this is not the one I
mean, the one I know of is for example, I
199:29 - think from Apache, and they will have something
like close thing silently or so close resource.
199:30 - And then this will do all the nasty stuff
for you. Okay, I'm stopping here, what is
199:31 - important is, and this I want to show you
just by printing something system out, print,
199:32 - ln.
199:33 - And I will throw the exception again. Which
means what you can also do is you don't even
199:34 - have to catch it. This also works try and
darkly finally. Okay, formatted the code.
199:35 - So, now with the invalid argument, our program
will be stopped, execution will be stopped.
199:36 - But in any case, let's say I am still running.
And I can also show you this line will not
199:37 - be printed after exception. Well, it might
be that this runs once if the first argument
199:38 - is a valid one. Because with the string airy,
we never know for sure the order is not guaranteed.
199:39 - But so that you see, I would whatever happens
for this vote for every time we call is valid.
199:40 - This will always be printed. So let's see
what happens. Okay, oh, something's still
199:41 - wrong. Not Found. Yeah, because we have removed
the from Yeah, sure. Um,
199:42 - so let's for now remove that. We at the moment,
don't need it. And see, this is again, the
199:43 - reason why we need tests.
199:44 - I'm really doing some nasty hacking at the
moment. Okay, and you see, I'm still running
199:45 - And then the exception comes. So this is what
happens when the exception happens. We didn't
199:46 - catch it. So we see the stack trace instead.
But I'm still running is printed before that.
199:47 - And this is the place where we can do some
cleanup operations, like closing resources.
199:48 - But you could do anything in here, basically.
Same thing, if we catch it, catch is a runtime
199:49 - exception, runtime exception, because it's
also a runtime exception. We should talk about
199:50 - inheritance very soon. So that I can go in
more details why that is. So now what is wrong?
199:51 - Yeah, we need the closing curly brace, and
one less of this. So now we can say, oh, maybe
199:52 - I just have I will also show you print stack
trace. So this should actually do the same.
199:53 - And now I will say, system out. print on.
199:54 - Hello, again.
199:55 - So you get an idea. In finally block.
199:56 - Oh, okay.
199:57 - Oh, no, something weird happened. And this
is for all the invalid states flying driving.
199:58 - The stack trace was printed. And it's red.
Because, yeah, it's the print stack trace.
199:59 - So it's printed on system error. Okay. And
you see, this is the illegal argument exception,
200:00 - the first one, the second one, and so on.
And you see at the end, hello again. Which
200:01 - comes after the whole stack trace. Yeah. And
you'll also see this line will not be printed
200:02 - off to exception. Because it seems like I
mean, we had different arguments in here.
200:03 - So for the valid ones, this line was printed.
And you see also, I mean, now I'm really having
200:04 - a hard time knowing why this happened. So
again, I violated my own rule. I didn't add
200:05 - the argument. So here I can say, our arguement.
I say valid argument. Yeah, because if it's
200:06 - after the value of if this is printed, it
means the exception did not happen. Now, let's
200:07 - call this again. And let me also remove the
stack trace for now to make it a bit more
200:08 - readable for us. And let's run the main method
again. Okay, see now it's more readable. So
200:09 - what do we have here? Hello again. So the
runtime exception happened. And, again, I
200:10 - did not add the argument. In this case, I
can also say get message, which gets us the
200:11 - message of the exception. I'm not sure if
our illegal argument exception has a message.
200:12 - But we'll try this.
200:13 - Yeah, see, this is the message Hello again.
And the message is no II non constant car
200:14 - marktspiegel car stayed flying. So now you
see he can understand the problem so much
200:15 - better. And after this we under finally block
then comes the valid argument parking. In
200:16 - this case, we're also ending in the finally
block. Then comes a second valid argument.
200:17 - Also in the finally block. Here again comes
in invalid state
200:18 - thriving,
200:19 - but we're also in the finally block. And the
last invalid state also in the final block.
200:20 - So the finally block is always executed all
K. I think this pretty much rounds up everything
200:21 - I wanted to tell you about Exception Handling
today. Now because this was quite a lot. Let's
200:22 - go Shortly through the most important gotchas,
okay, so, in Java, there are runtime exceptions,
200:23 - which are unchecked exceptions, unchecked
means they are not enforced by the compiler
200:24 - to be handled, you can just throw them, and
also Java will throw them for you. For example,
200:25 - a very famous or infamous exception is the
null pointer exception, you should never throw
200:26 - that yourself, Java will throw that for you,
if you try to access something that is at
200:27 - the moment now, just now for the exception
is probably the most famous exception, because
200:28 - when it happens, you will not be very happy.
Okay? So unchecked exceptions, or runtime
200:29 - exceptions. And they can happen at any line,
because any line can also be null. And they
200:30 - don't have to be handled in code. If they're
not, then in the worst case, the program will
200:31 - stop, like we saw before, because the exception
will bubble up all to the top. And if it's
200:32 - not handled in here, the program will stop.
And it will by default, print the stack trace.
200:33 - Then Java was the first and actually also
the last programming language that introduced
200:34 - checked exceptions. Checked exceptions are
exceptions, that are enforced by the compiler,
200:35 - that you do something about them, or you add
a throws with the exception name. In your
200:36 - method signature. There are various checked
exceptions. One of the most famous ones is
200:37 - probably the i o exception. That will be C,
it's in Java i o package. This one will be
200:38 - thrown if you have any problems with i o operations,
which is again a topic on its own. Okay, um,
200:39 - and I said Java was also the last programming
language that introduced checked exceptions.
200:40 - So this really shows us indicates us that
checked exceptions were not so smart. Because
200:41 - you see, all they help us in the end, is they
add noise to the method signature. And the
200:42 - case that to use them for cases that you can
handle them. Well, I say, if you can handle
200:43 - them, why not taking care of the problem beforehand,
for example, by using validation, validating
200:44 - the case, the given argument, and then handling
that without actually even throwing an exception.
200:45 - And then maybe last but not least, for every
rule, there's always an exception, we saw
200:46 - that. I've removed it, unfortunately, yeah,
let me go back. We saw that with the switch
200:47 - on the string were set in a prior episode.
Don't do that, while I did it here. And, um,
200:48 - we also saw saw that
200:49 - here,
200:50 - where I use the value of method of enum, which
throws an exception, and I said, Well, we're
200:51 - trying to validate it. So if we are validating
as we don't need the exception, it just that
200:52 - we can't do anything about it how the method
was written by the inventors of Java, so we
200:53 - just have to live with that sometimes an exception
is thrown where we will just validate it.
200:54 - But what we can do is we can catch the exception
and then return true or false, for example,
200:55 - so we can convert the exception into a valid
return value. Also, there is a hack. If you
200:56 - have a library, like an old library that will
still throw a checked exception, like an IO
200:57 - exception. What you can always do is you can
wrap we say wrap a checked exception into
200:58 - our runtime exception. And this is like this.
Let's create more ioexception Let's create
200:59 - an ioexception shortly. So see, you can also
just create them like any other object. And
201:00 - now on that exception while it cannot be called
IE because we already have that I can now
201:01 - say throw new runtime exception and okay.
Give it the IO exception. And this is why
201:02 - we wrap it. Because we put this exception
into the constructor of runtime exception,
201:03 - which means this is the wrapper, it wraps
around the other exception. And now our compiler
201:04 - will be fine. Because we're not throwing an
IO exception anymore. We're throwing a runtime
201:05 - exception. Well, this is a nasty hack. But
I think it's still better than having checked
201:06 - exceptions all over your code. And yeah, I'm
going to talk about interfaces in Java. Well,
201:07 - interfaces are probably the most powerful
feature of object oriented languages. Well,
201:08 - before I continue, first of all, some organizational
stuff. So this is divided into three parts.
201:09 - Part One, I will first of all, talk about
the definition, what does actually the word
201:10 - interface mean? And tell you a bit about the
history. Like how were interfaces introduced
201:11 - into Java. I'll make this part as short as
I can not to put you to sleep. And then second,
201:12 - we'll jump into my ID, he will do a short
coding session, and I'll show you how to practically
201:13 - use interfaces in Java. And then last but
not least, I'll do a short discussion about
201:14 - the pros and cons of interfaces from a clean
coder perspective. Okay, so let's start to
201:15 - jump into the topic interface. So what does
interface actually mean? So I've opened up
201:16 - the dictionary page. And the definition is
an interface is the point of interconnection
201:17 - between entities. And interfaces do not only
exist in programming, but also in all other
201:18 - kinds of areas, for example, in chemistry
and physics, and there is defined as a thin
201:19 - layer or boundary between different substances.
And I think this perfectly also applies to
201:20 - interfaces in object oriented languages and
Java. Because it's really a very thin layer,
201:21 - you will see, there is not much code needed
to define an interface. And it also forms
201:22 - a boundary. When I say boundary, I think of
something like the Chinese wall, which was
201:23 - a big protection from the hordes that were
invading from the north.
201:24 - And this is also what an interface is, it
can protect a class from other classes, but
201:25 - more of this later, okay. And then maybe we
should also look at the object oriented point
201:26 - of view. So in object oriented programming,
it's a piece of code, defining a set of operations
201:27 - that other code must implement.
201:28 - So yes,
201:29 - all this holds true for interfaces in Java.
But now, enough of the definition. Let's have
201:30 - a look at the history. For this, I actually
had to do some research on the internet. Finally,
201:31 - I found this page here from Oracle, where
Oracle says the concept of an interface in
201:32 - the Java language was borrowed from the Objective
C concept of a protocol. Well, pretty much
201:33 - everyone says are things that Java was actually
the first language introducing interfaces.
201:34 - Well, actually, Oracle itself says that this
is not true. It was birthed from Objective
201:35 - C. I find this quite interesting. Objective
C. I thought we should also have a look on
201:36 - Objective C, then. So I found this page here
saying, Brad Cox and Tom love created the
201:37 - Objective C programming language in the early
1980s. So actually much older than Java. Java,
201:38 - was released as far as I know, in 1995. So
15 years later, in an effort to get people
201:39 - to write cleaner, more modular and clearly
Separated code. Yeah, that sounds actually
201:40 - quite good. Now, what is interesting is here,
this paragraph also says, into interfaces
201:41 - were introduced to Java to enhance Java's
single inheritance model. So whatever single
201:42 - inheritance model means
201:43 - they didn't say
201:44 - they had introduced the interfaces to get
more cleaner, more modular, and clearly separated
201:45 - code. There is a different reason. Well, I
haven't told you what inheritance means yet.
201:46 - And this for a reason. Because, um, well,
Java was released in 1995, said before, and
201:47 - now we have 2015 20 years later, actually,
in the meantime, the especially the clean
201:48 - code community does not believe so much in
inheritance anymore. Because, of course, inheritance
201:49 - has a lot of advantages. But also many disadvantages
about this, I'll tell you, and one of the
201:50 - next episodes when I'm going to talk about
inheritance in Java. But anyway, so when Java
201:51 - was introduced, Java is the successor of c++
we could say. And c++ still had a model using
201:52 - multiple inheritance. So multiple inheritance
is even more complicated than single inheritance.
201:53 - And here they write. multiple inheritance
created too many problems for programmers,
201:54 - as well as compiler writers, because it's
actually not so easy to implement multiple
201:55 - inheritance in into a compiler. So it seems,
because they did not support multiple inheritance,
201:56 - they added interfaces to Java s, like replacement
for multiple inheritance, to like, fix that
201:57 - Java did not support multiple inheritance.
And this is quite funny. And let me say it
201:58 - in different words, I would say, it seems
like the really powerful feature of interfaces
201:59 - was introduced into Java by kind of accident,
because they said before, they didn't think
202:00 - about cleaner, more modular, clearly separated
code, but mostly just to have a way of having
202:01 - something similar to multiple inheritance.
Okay, let's stop here, and jump directly into
202:02 - my ID. Cuz I felt you were already feet been
falling asleep. Um, so here, this is my car.
202:03 - So it was test that I've used in earlier episodes.
Also, I've added this should demonstrate interfaces
202:04 - method, as the name implies, just for demonstration
purposes, I'm still using the car service
202:05 - that I've implemented, also in one of the
earlier episodes, and I've added a drive method
202:06 - to it. So the idea is to have a service class.
And when I call the drive method, that this
202:07 - should, like start the engines of several
cars, and make them drive. So for this, in
202:08 - my car service, I have now a method drive.
It creates First of all, three different cars.
202:09 - I mean, this is just an example you mentioned,
were hundreds of cars. And now I call the
202:10 - drive method on each of these cars.
202:11 - Okay, actually,
202:12 - all these classes are in the same package.
This is why I don't have to import any class.
202:13 - But imagine each class would be in a different
package. We would have to import each class
202:14 - separately like BMW and Porsche GE and mercy
is and so on. So what we say here is actually
202:15 - this car service at the moment is really Deeply
coupled to these car classes, this is something
202:16 - that we don't want more about this later.
And also, you see, we need a lot of code to
202:17 - make all the cars drive. And this is something
that we want to improve with using interfaces.
202:18 - Now what, again, what is an interface? Well,
an interface is also like an abstract type
202:19 - definition, what this type should be able
to do. In our case, we have an I mean, I'm
202:20 - already saying it three different cars. And
all these cars can drive and you see it already,
202:21 - I have three different drive methods. I mean,
the way they hold how they are driving might
202:22 - be different because of course, a BMW has
a different engine than a pushy, and again,
202:23 - a different engine than ms cedars. But they
have some certain specifics, like, for example,
202:24 - they would all have four wheels, and they
can all drive which we can make something
202:25 - like a contract off. So in this way, let us
introduce an interface and I've prepared something
202:26 - here, car dot java. So far, we only have the
package declaration, we have to extend that.
202:27 - So let's start. Let's start as if we would
write a class. So let's say public class car.
202:28 - And then opening and closing curly brace,
and now public void drive.
202:29 - Okay.
202:30 - And then in here, we could do something. Well,
the problem is if we do it like this, this
202:31 - is not going to work, because then all the
different types will have to drive the same
202:32 - way. But this is not what we want. For example,
He in pushy, I have implemented already the
202:33 - drive method. I mean, this is just a stupid
example. I still want you hardly ever to use
202:34 - system out print line. But here for our example,
I just wanted to show you that each method
202:35 - is implemented in a different way. Here it
says masseter striving there it says Porsche
202:36 - driving, the BMW actually even has three different
methods. These ones we will actually use at
202:37 - a later time. And it also has the drive method,
which says BMW driving. Okay.
202:38 - So now,
202:39 - maybe before,
202:40 - I'm going to
202:41 - continue with doing the interface, we could
also try to execute the code as it is. Let's
202:42 - do this. Now, just so that you see the code
should be running by now already. So it says
202:43 - BMW driving Porsche driving Mercedes driving.
So what I want to achieve is exactly the same
202:44 - just using interfaces with less and more readable
code. By the way, exit code zero means everything
202:45 - is fine. If there is a problem, an exception
thrown, it would be exit code one. Okay. So
202:46 - back to what at the moment is still a class.
Now there is a very easy way to make this
202:47 - an interface. And this is I say interface.
But now it seems there is still a problem.
202:48 - It says interface methods cannot have a body,
or what is the body, the body is this part
202:49 - here in blue. So the body is actually the
method implementation. method also has a method
202:50 - signature. This on top here is called the
method signature, public void, and the name
202:51 - of the method is drive. Okay. Sorry. So it
seems like it cannot have a body. How is that?
202:52 - Well, I guess even makes sense. Because we
said we just want to have a definition, like
202:53 - a contract. But we don't want to actually
implement it. The implementation will be done
202:54 - by the specific implementations by BMW by
Porsche and by my seniors. And we have already
202:55 - done the implementations. So let me remove
the body. Now there's still something wrong
202:56 - and you see it. Here it even says it It wants
now, the semi column because the semicolon
202:57 - now says, I'm finished. I'm done. This is
all I want to say. So now we have an abstract
202:58 - definition of a method that other classes
may implement. And when they implement the
202:59 - interface car, we can also say they play the
role of a car. Because actually a class can
203:00 - implement more than one interface. A class
can implement any number of interfaces. And
203:01 - remember, before I spoke about multiple inheritance,
well, multiple is, this is why it's similar,
203:02 - because it also allows to have,
203:03 - like,
203:04 - multiple implementations in a way, but more
of this later. So a class can also implement
203:05 - multiple interfaces. Okay. And when I click
here, you also see modifier public is redundant.
203:06 - Why is it redundant? because by definition,
all methods that we define in an interface
203:07 - must be public, they are always public. So
even if I remove it, well, if you still remember,
203:08 - the episode I did on the visibility modifiers,
you might now think, Well, now that there
203:09 - is no modifier defined, it must be of default,
or package level visibility, no, it is still
203:10 - a public visibility, because it always a method
is always have public visibility. Another
203:11 - modifier that is implicitly here is abstract,
can put it abstract just means what we have
203:12 - here, that the method is not implemented,
and that it just consists of the method signature,
203:13 - and that the body is left away, and that we
have to semicolon here. So also, this is redundant,
203:14 - we can and we should remove it. Always define
your methods without public and without abstract,
203:15 - you should just know that implicitly, they're
there. Okay. And then there's one more thing
203:16 - you can do in an interface. Um, but I warn
you not to do it. This is actually an anti
203:17 - pattern. But still just to be complete. I
let me show you. And this is you can add public
203:18 - static, final. So you can add constants, for
example, Max, Max speed. I don't know 320.
203:19 - And however, you shouldn't do so. And when
you think about it, I guess you will easily
203:20 - find out why. Because for example, the BMW
might only do a max speed of 240. Porsche
203:21 - Yeah, maybe a Porsche can maybe do 320, but
maybe also even more than Mercedes, I don't
203:22 - know. So this is actually not part of this
should not be part of the interface, because
203:23 - this is an implementation detail. And such
an implementation detail should be hidden
203:24 - within the class, or even better. In an email
about this, let me also shortly show you a
203:25 - little page I found on the web. And this is
here it is on the page of sonar. Well, actually,
203:26 - it's called sonar cube sonar cube is really
a very cool tool. It's actually one of my
203:27 - favorite tools for static code quality analysis.
I'm pretty sure very soon, I'll do an episode
203:28 - on sonar cube alone. For now, let me keep
this as short as possible, because we still
203:29 - want to talk about interfaces. But in this
sonar cube, it's actually a rule that checks
203:30 - that you don't use constants in an interface.
Here it says console should not be defined
203:31 - in an interface. And there was also or there
is also very smart, cool guy, Joshua blah,
203:32 - the author of Effective Java, which is, by
the way, also a must read, I have a link to
203:33 - that book on my blog, on Marcus minus bo.com,
where you can directly buy it from MSN. So
203:34 - if you have the time, you can also read all
this, but I think I already explained the
203:35 - important parts. Here, we can also look at
it. So noncomplying code is to define the
203:36 - variables directly in the interface. And you
see here they even didn't say public static
203:37 - final because this is again, every variable
you define, is implicitly a constant. So you
203:38 - don't even have to say public Static final.
But this is not good. Anyway, the much better
203:39 - solution is to use an enum we have talked
about enums already. So I won't go in more
203:40 - detail here. Another possibility, which I
would not recommend, you can also have something
203:41 - called constant classes, which you make final.
203:42 - And then in the class, you have the public
static final constants. This is possible,
203:43 - but it's always better to have small enums.
Because usually what happens is in these constant
203:44 - classes, they would grow. And they would grow
and have contain all kinds of different constants.
203:45 - While this only contains the constants of
this status here. And also, I mean, talked
203:46 - about this when I talked about enums is type
safe. Well, here, you could change any number.
203:47 - Okay, so anyway, so now back to our code.
So, here, you already see it's redundant.
203:48 - All this is redundant, and should be removed.
But this should also be removed. As I said
203:49 - before, because it's an implementation detail,
this is not part of our contract. Because
203:50 - the car should just define what needs to get
done, what behavior class implementing that
203:51 - behavior has, like it should drive, but the
way how it's how it drives, if it drives fast
203:52 - or slow. This is part of the class and not
part of the interface. This is really important
203:53 - when you want to do clean coding. Okay. So
now let us implement, use the interface. So
203:54 - now, when I say implements car, when you you
can now use BMW as a car. And when you do
203:55 - so, BMW plays the role of being a car. And
as I said before, you can also implement several
203:56 - interfaces, which we're going to do very soon.
But first of all, let me finish this quarshie
203:57 - implements car. And Marie cetus implements
car. Well, the compiler was directly happy,
203:58 - I hadn't got to do anything, or implements
car. Because the work I've done beforehand,
203:59 - implementing the method will normally let
me know that this just to be faster in my
204:00 - here, code example. You won't do it like this,
you define a class, you say it implements
204:01 - an interface. And then you see I already have
a problem with the compiler, which tells me
204:02 - I have to implement the abstract method, Dr.
Okay, and then you do this. And the compiler
204:03 - is happy. It has to be exactly like defined
in the interface. You cannot, for example,
204:04 - say int as a return value, because this is
not how it was defined in the interface. Okay,
204:05 - now, let me also show you, oh, there's still
a problem with car. It seems there's the curly
204:06 - brace missing, somehow. Okay, it seems like
I probably deleted too much. Okay, see how
204:07 - small is is well, actually, by the way, I'm
an interface should have at least one method.
204:08 - While this is also not true, there are even
something called market interfaces that don't
204:09 - even contain a single method. This is a specialty,
which I'm not going to go in detail now. But
204:10 - usually they would have at most, at least
one method, and maybe even many more methods.
204:11 - But again, I want to warn you, I see often
interfaces with 10s of hundreds of methods.
204:12 - And sometimes it's just too much. It's better
to have many, many interfaces and to have
204:13 - your classes implement several interfaces
at once, so that you can decide what role
204:14 - your class is going to play. And lo let's
implement more interfaces in here. I've already
204:15 - prepared again, adding these methods, because
I have also what interfaces one interface
204:16 - is the lockable interface, which I defined.
The idea for such an interface is
204:17 - for example, you want to do logging, you want
to do you want to lock several different objects,
204:18 - could have cars, persons whatsoever, everything
can be lockable. And I defined that in order
204:19 - to be likable. Such a class must implement
a method called message, which I then later
204:20 - in my learning framework can call. Because
I know that whenever I have a class that implements
204:21 - luggable, it will then have a message method
that I can call and it returns me a string
204:22 - that should be used for logging purposes.
Then also, well took me a while to come up
204:23 - with examples, because what other roles could
a car play, I said, it could also be a property.
204:24 - And such a property would have an owner, for
example, the owner of the BMW I made myself
204:25 - I mean, I want to have a BMW, how cool is
that. And one more interface, I said, I just
204:26 - came up with the idea, we could also have
a role of being an asset, an asset would have
204:27 - a value. And so my BMW also has a value. So
I cannot easily say, implements luggable.
204:28 - Think this one I have not implemented yet.
And I still have to do No, not twice implement
204:29 - car, comma luggable, comma, asset, comma property,
the order doesn't matter. But now you see,
204:30 - I've implemented already the value method
and the owner method, the message method,
204:31 - I still have to implement. And as I said before,
the order is not controlled, so I can put
204:32 - it in any order message.
204:33 - And, yeah,
204:34 - here, we just return something
204:35 - on the car.
204:36 - Okay, now, I have a class implementing 1234
different interfaces. OK, now let's use my
204:37 - classes implementing the interfaces. For this,
we go back into my car service, what I can
204:38 - already do is now my variable my reference
variable is at the moment of type BMW, the
204:39 - class so my BMW can do everything that a BMW
can do, which at the moment is drive message
204:40 - owner value, these are methods that we inherit,
see, there is inheritance already, from the
204:41 - object class more of this very soon, but these
were the classes that we have directly implemented
204:42 - in the BMW class, so I can use all of them.
Or let me show you a message, we can use them.
204:43 - Now, what I can also do is, now that I've
implemented the car interface, I can say my
204:44 - I create an object of type in W, but I put
a reference on it of type car. And now, this
204:45 - will change the behavior. Now, I can just
call drive on it, because now my BMW just
204:46 - plays the role of a car I can also say luggable
and then I will not be able to drive the car
204:47 - because in the context of logging, I don't
care about driving all I care is about login
204:48 - and for logging, I would need such a message
okay.
204:49 - So,
204:50 - now, let me make all these cars and this is
also something you should do I mean, the object
204:51 - is the object, but the variable when you have
an interface, always try to like reference
204:52 - with the with an interface to the object.
Because this way, you can more easily exchanged
204:53 - your code like imagine the BMW would come
as an argument to the method. Now, at the
204:54 - moment we have these three cars, imagine at
a later time someone in when so very cool
204:55 - Marquess car, then when the when the method
is operating on the car interface type, this
204:56 - method will work even with new classes introduced
without even knowing them at the time, we
204:57 - wrote our car service. So whenever possible,
use the interface type. Okay. So now, I want
204:58 - to have a for each loop. And for this, let
me put All these cars into a car array. We've
204:59 - also already talked about array called as
cars equals two. And now the short definition
205:00 - I can even do it on the fly. Make it even
more shorter. You W, you're pushy.
205:01 - You're more serious.
205:02 - Okay.
205:03 - Hello, on this array, I can now easily iterate.
And I can now say car dot drive. And, or as
205:04 - said before, each car will drive differently.
But this will be handled by the object. Now
205:05 - our car service does not know any specific
implementation anymore. This is the coupling,
205:06 - decoupling the code is not coupled so much
to the specific implementations, my car service,
205:07 - all that it uses, all that it knows is now
the car interface. Okay, and with these few
205:08 - lines, I iterate over all the cars and I drive
them. Let's execute this code to and have
205:09 - a look if it works. Yeah, see, this is exactly
the same as before, my BMW is driving or a
205:10 - Porsche he is driving and marmet cetus is
driving. Now let's also have a look at the
205:11 - car reference. As you see, we can only execute
drive on it. That is defined by the car interface.
205:12 - And we do have a BMW as the first element
in our area. But this headline 10, we don't
205:13 - know. All we know is we have an area of cars.
Okay, so we cannot call any BMW specific method.
205:14 - In here. I can also not say BMW, because this
is not competitive compatible. We need a car.
205:15 - And we don't need to be in w because this
array is of type car. Okay, so let me fix
205:16 - that.
205:17 - Okay.
205:18 - So
205:19 - I think this pretty much wraps up my explanation
of interfaces in Java. A really cool feature.
205:20 - And now let's have a discussion about the
pros and cons about the advantages and disadvantages
205:21 - of interfaces in Java. Well, first of all,
let's start with the disadvantages. And actually,
205:22 - I can tell you, there are not so many. Well,
you see, for every interface that are introduced,
205:23 - I have to type down this code. And, of course,
this is here, not much, it could be of course,
205:24 - much more. So, and each class that wants to
use an interface has to implement this interface.
205:25 - So there is some added complexity. Also in
my car service, I'm using now the car interface.
205:26 - And whenever you introduce complexity, this
complexity must be justified. So if it makes
205:27 - sense, if it helps us with something, for
example, here, I'm not able to easily iterate
205:28 - over all the cars. And you mentioned there
could be many, many, many, many more. But
205:29 - my for loop would just be the same. So this
would be for example, a justification. But
205:30 - my car service at the moment does not implement
an interface. Well actually, this is kind
205:31 - of an exception to the rule. Most services
should implement an interface. Very often
205:32 - this makes sense, because it's specifically
for testing so that you can exchange the concrete
205:33 - implementation just here. In my example, it
does not make sense because I just want to
205:34 - explain you interfaces and I want to have
it really short and neat and not too complicated.
205:35 - And I know I will only have this one class
here for demonstration purposes. So why Would
205:36 - I implement an interface here? So at the moment,
I don't see a reason to make my car service
205:37 - implemented interface. Sometimes, of course,
there are corner cases, we're not sure. My
205:38 - personal point of view there is, if I know
that for the next months, I'm not going to
205:39 - need the interface. My probably leave it away.
Because code, I mean, it lives you are allowed,
205:40 - you can change it, you can refactor your code.
So if at a later time you, it turns out you
205:41 - need to interface then edit at a later time.
Just don't do arbitrary decisions. There are
205:42 - people that like they love interfaces. And
for this reason, they do something I would
205:43 - call interface readers, like an illness, blindly
adding an interface implementing an interface
205:44 - always just because, and I think this is not
too smart. And then really, interfaces can
205:45 - be a disadvantage, because they just make
everything more complex. But now, this is
205:46 - already pretty much it. To the advantages,
so the advantages, I think a few ones are
205:47 - already mentioned, while explaining the interface.
Probably one of the most important ones is
205:48 - that it decouples your code, as I explained
before, like now, the car service only uses
205:49 - the cotton Well, no, I was actually like,
sorry, of course, as it is implemented at
205:50 - the moment, we still say new BMW new Porsche
new messages. So of course, at the moment,
205:51 - it would still be coupled. But normally, of
course, he would also not do it like this,
205:52 - what he would usually do is you forward an
array that is already filled, only then. Now,
205:53 - our core service is not coupled to the specific
implementations. So it really allows to decouple
205:54 - your code much better than without interfaces.
And this decoupling also helps with other
205:55 - things, for example, team cooperation. Imagine
you have a big team of 10 2030 developers,
205:56 - and you have a big project that you have to
work on for weeks or months.
205:57 - And then you would probably form smaller sub
teams. And then each sub team would work on
205:58 - a specific area. For example, one team in
our example here, could work on the car service,
205:59 - while there would be another team implementing
different car types. Now the problem is, the
206:00 - car service is then or might be dependent
on specific car implementations to test it.
206:01 - And on the other hand, the team that implements
the different car types might need a car service
206:02 - for testing, and for integrating their code
with the other code. So it's like, each team
206:03 - is dependent on the other team. And so each
team blocks the other team. So nothing can
206:04 - be finished. And interfaces can be a solution
to the problem. Because when you introduce
206:05 - an interface here, for example, in this case
for the car service, then the team implementing
206:06 - the different cars would just do a very stupid
dummy implementation, something similar like
206:07 - I did here, where you don't have real code,
or just something where you see it's working.
206:08 - And then the other team can independently
also work on their code. And also add dummy
206:09 - implementations where needed. And only when
both are finished, they can be brought together.
206:10 - So interfaces really help in team cooperation.
And then next advantage is interfaces really
206:11 - include increase your flexibility, because
as you see, as I have changed it now we have
206:12 - the cars array as a parameter to our drive
method. So actually at runtime, in this case,
206:13 - in our test method, we have this drive method.
So now at runtime, I could have something
206:14 - some condition if it's sunny, just making
this up. Then I want to drive in my Porsche.
206:15 - And so I create a pushy here, so I would say
car car And then I would say if sunny car
206:16 - equals to new Porsche else if it's not Sunny,
well, I hope I had so many cars, then I would
206:17 - say I take the BMW instead. Because it's better
for rainy weather. Knew, of course, and now
206:18 - I don't want to make an error, let me change
the method. And I don't implement sunny nose.
206:19 - So I just say true here, just to have it simple.
So in this case, Now, of course, you wouldn't
206:20 - be cold. And in my drive method to make this
work, make this a car to have it simple. And
206:21 - I would call drive. So now at runtime, we
will decide what kind of car this is. So this
206:22 - really adds a lot of power to our code.
206:23 - So
206:24 - it might be a pushy, and it might be a BMW
that is given to the Dr. method. Really cool
206:25 - feature.
206:26 - Okay,
206:27 - I guess there are many, many more advantages
of interfaces. Let me know if you have more
206:28 - to add. But I think this is enough for the
moment so that you get an idea of what interfaces
206:29 - are. And all the advantages interfaces have.
Just also, again, the warning don't fall into
206:30 - our interface, serious illness. This will
also be not wise. But I think this pretty
206:31 - much wraps it up. I'm going to talk about
inheritance in Java. inheritance is actually
206:32 - a very powerful feature of object oriented
languages. Similar to interfaces, inheritance
206:33 - allows to handle a group of similar objects
in a uniform way. On top of that, however,
206:34 - it also allows to prevent code duplication,
by inheriting the members of a class from
206:35 - a parent class to its child classes. I'm the
members of a class in case you don't remember,
206:36 - are the instance variables, and the instance
methods. So everything that is not static.
206:37 - Okay, well, I guess that sounds very promising.
The problem is, I think inheritance is just
206:38 - a bit too powerful actually. Well, if used
incorrectly, inheritance, can severely damage
206:39 - your code. So really take here and use inheritance
sparsely. I mean, there are definitely justified
206:40 - cases to use inheritance. But whenever in
doubt, I would not use it. Okay. And also,
206:41 - it actually requires some experience to know
when to use inheritance, and when to avoid
206:42 - it. To give you a real world example, I'm
at the moment I'm working on a project of
206:43 - about maybe 15,000 lines of code. And there.
I used inheritance, maybe once. Yeah. So there
206:44 - are alternatives to using inheritance. I'm
about this. We will talk at the later time.
206:45 - Yeah. Well,
206:46 - let's stop here for a moment. Because now
the introduction is almost over. You see me
206:47 - in the button right corner talking to you
all very soon disappear, because I'll jump
206:48 - into the code. And I'll show you how to implement
and use inheritance. Before that one personal
206:49 - request. I'm doing this videos for you. So
that you can learn Java, I hope they useful
206:50 - to you. If so, I would be very happy if you
could give me your thumbs up in the bottom
206:51 - right corner of this video. And remember,
you can also subscribe to my YouTube channel.
206:52 - Okay, well enough of advertisement Now, let's
really do a coding session and jump into the
206:53 - code. Okay, so here you see I have prepared
this CEU test class for you. We are actually
206:54 - not really testing something now. This is
just for demonstration purposes, any arbitrary
206:55 - example. Um, this example is actually taken
from the book, headfirst Java, from Kathy
206:56 - Sierra, she is really my favorite author of
any Java related book, highly recommended
206:57 - to read
206:58 - this and any other offer books. In case you
want to know, you can find a link
206:59 - to her books on my blog on market minus b.com.
I have a must read section there, you can
207:00 - find her books. Okay. Now back to the code.
So I have here the SU class. So the idea is,
207:01 - we have here an area of animals, similar to
the area of cars I had in the last episode,
207:02 - where I introduced you to interfaces, and
I had a car every with BMW and Mercedes and
207:03 - a pushy, now we have an animal array with
a dog, a gorilla,
207:04 - and a line and a tiger. So you should already
see interfaces and inheritance in Java. When
207:05 - you use them, here, it looks quite similar.
And this, by the way, is called polymorphism.
207:06 - You might have heard that.
207:07 - And the idea of polymorphism is that on the
left side, you have a variable a reference
207:08 - variable of this super type a parent class
207:09 - animal. But Polly Morphe. I mean, this also
works with interfaces. So the idea is just
207:10 - that you have an interface or a super or parent
class.
207:11 - And on the right side, an animal can be a
dog, a gorilla, a line, a tiger, anything,
207:12 - so different things can be assigned to the
left variable. Because the polymorphism means
207:13 - like, many sides solve can have different
implementations on the right side. And they
207:14 - will all be handled uniformly here, I have
prepared this feed animals method. Let's maybe
207:15 - jump here. Okay, so you see I've prepared
this for each loop, everything that is read,
207:16 - we still have to implement, I have only prepared
it. So we're iterating through my array, we
207:17 - still have to implement the eat method. And
we still have to implement the H method. Now,
207:18 - again, totally stupid, arbitrary example.
But just to have something to show you. And
207:19 - to have variation. My idea was, I mean, totally
arbitrary. Really, this depends on the design
207:20 - of your code that like because code is always
like a model of the real world. And so it
207:21 - totally depends on the example that you're
working on. Well, in my example, I just defined
207:22 - that I said, Well, every animal, a dog, a
gorilla, a line, Tiger, they all eat in a
207:23 - different way. Because for example, a gorilla
would probably eat, I don't know what it eats
207:24 - grass, or leaves or something will align.
I don't know. It's some kind of meat. So therefore,
207:25 - my idea was to have an implementation, a concrete
implementation of the eat method in each different
207:26 - animal subtype. And further, my idea was to
have this H method. Well, every animal can
207:27 - be of a different age. But the calculation
Well, normally, you wouldn't probably calculate
207:28 - the age. But I mean, this is just my stupid
example, I made it a method. So the calculation
207:29 - would be the same for every animal. So my
idea is to have this as a concrete method,
207:30 - an animal and have this as an abstract method,
because this is something here, where interfaces
207:31 - are different. Sorry, yeah, but interfaces
are different to inheritance. In interfaces,
207:32 - you only have abstract methods. And because
you have only abstract methods, the abstract
207:33 - keyword is not needed. But here we can enhance
inheritance, we can mix it, maybe I should
207:34 - already jump now to the animal class. So an
animal class this is still just a stupid simple
207:35 - class totally empty. So you can use inheritance
with just a simple class. And now let's implement
207:36 - two methods concrete
207:37 - methods, public void, eat Later on, I'll make
this abstract. But for now, I wanted concrete.
207:38 - public void. Ah, oh, okay. So now maybe we
should also do something in the method. And
207:39 - again, avoid system or print boom, just, if
you're like me doing an example, showing something.
207:40 - This is the exception polluter rules and it's
okayish to use system or printable, but avoided
207:41 - in real code. Okay, so I say, animal is eating.
Well, this is not what we want. So it's just
207:42 - step one, I said every animal is eating in
its own way. And here is say, h is cold. collated.
207:43 - Okay, it's here the dots to just for fun.
So now, see, this class looks totally like
207:44 - a regular class, you have seen so many times
before. Now, I go to the dog class, and I
207:45 - want the dog to be an animal. Well, if this
would be an interface, I would say implements
207:46 - you remember, but it's not it's a class and
we extend the class and therefore the keyword
207:47 - is extends really, totally easy. Okay, so
we say extends animal. And all this is already
207:48 - using inheritance. Now it's looks like as
if the dog class was empty. But in fact, we
207:49 - can already use these two methods in dog Okay,
let's continue doing this for all the other
207:50 - subtypes
207:51 - gorilla
207:52 - extends animal line extends animal. These
by the way are two interfaces, I also want
207:53 - to show you and I might just as well do it
now, we can mix using interfaces and using
207:54 - extending classes using inheritance we can
mix them the question is should we first say
207:55 - extends or first implements, well, there is
a rule it must be that we say extends first
207:56 - and then implements because in Java, we have
single inheritance. So, we can only extend
207:57 - a single class, but we can implement any number
of interfaces, and therefore, this is a comma
207:58 - separated list. And therefore, to make it
a bit easier, it's at the end. So, we say
207:59 - implements and I can say this interface lockable
and comma printable. So, an interface plays
208:00 - a role. So Aline can play the role of being
a lovable, when like, he mentioned, the code
208:01 - is running on production at a certain time
where we want to lock the line or we want
208:02 - to print it and therefore we can implement
this interface. Again, this is pulley Morphe
208:03 - that align can be a luggable Okay, so, you
see there is something red, because now we
208:04 - have a lot of methods that we have to implement.
First of all, from the animal, I mean, the
208:05 - order is arbitrary. We can also start with
a printable. So there was a public void. Um,
208:06 - was it print I hope method. And then there
was a public void I think message for luggable.
208:07 - This might have Yeah, you see, so the rule
is, when we implement an interface method
208:08 - as well as when we, when we implement an abstract
method from animal, the signature, the method
208:09 - signature must be exactly the same. We can't
say what year because the interface said it
208:10 - must be a string, return something just for
our little example. Okay, and in here, I say
208:11 - system dot out.
208:12 - Print.
208:13 - ln
208:14 - printing,
208:15 - okay, get the idea.
208:16 - So, now, there is still the eat method missing.
No, actually, it's not because we made it
208:17 - concrete. So we don't have to implement the
method I'm already a bit too fast.
208:18 - So see the red is gone. Everything so far
seems okay. But there's still a problem and
208:19 - Sue test. Let's check this are the tiger,
we still have to do the tiger extends because
208:20 - the tiger was not an animal yet. Maybe we
should look at this again. I mean, this is
208:21 - interesting. So see, all those classes are
all already extending the
208:22 - animal. And so these are already animals,
but the tiger is not yet required, we need
208:23 - an animal with found is a tiger. Okay, so
let's make this also an animal. Now it's an
208:24 - animal, and now it's working, the red is gone.
208:25 - Okay, but we still haven't done what we want
it. Because I said I want this method abstract.
208:26 - Now, you probably remember from when I explained
interfaces, an abstract method does not have
208:27 - this method body, the implementation, but
just the method signature, this here on the
208:28 - top,
208:29 - the method signature. So let's remove the
body. And we have to say abstract in the interface
208:30 - we didn't have to, because in interface, all
the methods are,
208:31 - by definition abstract. But here I mean, how
would Java Nope, there's a concrete method.
208:32 - And this one is supposed to be abstract. So
therefore, in inheritance, we have to explicitly
208:33 - set abstract. But now there is a difference.
Because if one method is abstract, the whole
208:34 - class has to be abstract.
208:35 - Now,
208:36 - what does this mean? Because actually, this
changes a bit of the behavior. And this, again,
208:37 - depends on your personal design of the program
that you're writing. An abstract class cannot
208:38 - be instantiated. Now, we cannot say the compiler
will not allow us We can't say new animal.
208:39 - An abstract class is like just the contract,
just the protocol. Pretty much the same as
208:40 - an interface is just the raw definition. But
we cannot create instances from an abstract
208:41 - class, we can only do so from concrete classes.
But concrete classes cannot have abstract
208:42 - methods. So this is something that you have
to clearly think of. And also amin, I said,
208:43 - another warning, I said that this can be used
to prevent code publication. Now you might
208:44 - think, well, cool, I just create some tool
class. And this has any method that I'm like
208:45 - needed anytime for example, age. And then
I can say animal extends tool. Because even
208:46 - the inheritance can have several layers. So
even though talk says extends animal animal,
208:47 - again, could extend some class. So now we
could say, extend some to class haven't implemented
208:48 - that. But I hope you get the idea. Well, even
though you can do so you should not do so.
208:49 - Because the rule is you have to apply and
is a test. Also, this is from
208:50 - the book of Kathy Sierra had first Java. They
you say an animal is a tool? No, it's not.
208:51 - So because it's not a tool, we don't say tool.
Because otherwise, this can really get nasty.
208:52 - And so you shouldn't do that as a recommendation.
But really a strong recommendation. Okay.
208:53 - So yeah, it still has to be made abstract
because of this abstract method here and we
208:54 - have to remove new animal as I said, doesn't
work. Okay, not everything read has gone.
208:55 - Now,
208:56 - let's go into our classes again. See, now
there is a problem. Now that this method is
208:57 - abstract, we also forced to implement it.
So we have to say, public void, eat. And we
208:58 - have to implement this method. And again,
stupid examples system called print ln dog
208:59 - is eating dot dot dot Okay, So gorilla is
eating in a different way. It's, I don't know,
209:00 - grass or something reuleaux is eating leaves.
Um, next one line, the line is eating something
209:01 - again, and the tiger is eating something.
So in this case, they all implement the eat
209:02 - method in their own unique way. So in reality,
you wouldn't, of course have your system out
209:03 - print on but some specific, Tiger related
logic that only fits for tiger. And this is
209:04 - why we have it here. And all the logic that
fits for all animals you put here. And this
209:05 - by the way, I mean, on the one hand, this
is handy. But to me, this is really a double
209:06 - double sided sword. I mean, this is handy
and can help. But on the other hand, it also
209:07 - is really complex. Because when you're in
a class like Sue, how do you know which animal
209:08 - implements eat, and which animal just inherits
the eat method, same for the H method,
209:09 - because we could of course, again mix that.
And we can also override a method. So for
209:10 - example, ah, this one is implemented. But
we could say, gorilla is implementing the
209:11 - age by itself are not something. So this is
like, how you could define an exception to
209:12 - the rule. You could say, well, my gorilla
does not use the H method. But instead, the
209:13 - H method is replaced by exactly this method.
209:14 - And the way this is done is, the signature
must be this method signature here must be
209:15 - pretty much looking the same. You can't like
change the return value or the parameter
209:16 - values.
209:17 - Well, you see, you can, but it's just not
using inheritance. Now, this is also why it's
209:18 - not yellow, but gray. Um, this is called overloading
a method. overloading a method means you implement
209:19 - a method that has the same name as another
method. But it's just something completely
209:20 - different. So this has nothing to do with
inheritance. If you want to inherit the method
209:21 - and override me override it, it has to have
the same signature. Okay, there is one exception.
209:22 - And for this, I have to introduce a new visibility
modifier. I think shortly, I talked about
209:23 - it in an earlier episode, but I didn't really
explain you what it means. And this is protected.
209:24 - Now what means protected? protected, means
it's visible, on the one hand, similar to
209:25 - default, or package level visibility, and
the whole package. So now we can use the H
209:26 - method. In Su. See, this is not read. It also
means it's visible in any class that extends
209:27 - animal. In our case, now, we have all the
classes in the same package. But he mentioned
209:28 - we had a car sitting, extend animal, I mean,
of course, we should not this would be stupid.
209:29 - But just technically not from a design perspective.
We could then use the H method, because it's
209:30 - protected. So the visibility is to any class
that inherits from animal on top, any class
209:31 - that is in the same package. And this again,
makes it complex. Do you see how much I have
209:32 - to explain? so that you understand, and this
is why I would avoid using it. So I just want
209:33 - you to passively know when someone else uses
it. But I would really avoid it. But so protected
209:34 - visibility is less visible than public. And
what I am allowed to do is I can increase
209:35 - the visibility in a child class. So where
was I? Here? So I'm allowed you see it works.
209:36 - I can say public void. Now this is still not
inherited. Nowadays, it's yellow again. So
209:37 - I can say public And now I can also say protected,
which at the moment is the same visibility
209:38 - as in parent class animal. But I'm not allowed
to say private, this will give me a compiler
209:39 - error, attempting to assign weaker access
privileges. It was protected. So you're allowed
209:40 - to make it public, but not less than protected.
The idea behind that is, I mean, an abstract
209:41 - method defines a contract a protocol. Exactly.
Like with interfaces, by saying extends animal,
209:42 - you promise any other class in the Java universe?
I am an animal, and you have a method that
209:43 - is public. And you can call it. And me. You
mentioned the crazy stuff that would happen.
209:44 - If there is one class that just does not fulfill
this contract. So this is why it's not working,
209:45 - it has to have the same visibility. Oh, okay.
Then also, I mean, I said, we inherit the
209:46 - members of a class. And I said, the members
of the class are the instance methods. These
209:47 - are the instance methods, and the instance
variables. So you can also have here a protected,
209:48 - I'm in H. And this will also be inherited.
We can now say, directly access is in here.
209:49 - I mean, this is the H method. Maybe I should
now here have a public void. h method instead
209:50 - of the eat method.
209:51 - Okay.
209:52 - And now I can say this dot age, or just age?
Or a statement? Yeah, of course not. It's
209:53 - not finished
209:54 - 45. So this would now we'll set the age to
45. Or just age because here, we don't need
209:55 - this. Because we know what we mean.
209:56 - Um,
209:57 - even though this is possible, we inherit the
age field, I would not make use of it. Well,
209:58 - first of all, because I don't like protected
as I said, and second, because I think this
209:59 - kind of violates the capsulation because the
animals should be the only one working on
210:00 - its internal variables. Okay. So avoid protected
and avoid like, making the variables the members
210:01 - the the instance members visible. If we have
a static method, public static, something.
210:02 - Well, I have to implement it. Of course, this
can be used static void. For example, by saying
210:03 - animal dot something can also be used now.
From Zoo or wherever. So we could say, animal
210:04 - dot something. Yeah, you see, it's also formed
formatted differently. So we don't really
210:05 - see this as a static method.
210:06 - But this will not be inherited. So you cannot,
like override this or so. And the gorilla
210:07 - class again, you can say animal dot something
210:08 - will actually you can even say and this is
a bit weird. Gorilla dot something. But this
210:09 - is not inheritance. It's just Java is a bit
smart. Here. The compiler is a bit smart.
210:10 - It knows gorilla is an animal. So it realizes
this is an animal and then it takes the static
210:11 - method.
210:12 - But this is still not inheritance. Oh, K.
Let me remove that. I hope I haven't confused
210:13 - you too much with that static.
210:14 - Just remember, we only inheriting the members
of the clause. The instance methods and the
210:15 - instance variables. All Okay. Well, I think
this is pretty much it. Maybe I should execute
210:16 - it again. And now we see dog is eating. He
is calculated. Gorilla is eating gorilla is
210:17 - implementing the H by itself. This was I was
overwriting the H method in gorilla, and only
210:18 - in gorilla lion is eating, he has calculated
Tigers eating ages calculated. So inheritance
210:19 - really is a complex beast. And in conclusion,
use it sparsely. Only use it when you can
210:20 - say, when you can apply the is a test. A dog
is an animal, a gorilla is an animal, a lion
210:21 - is an animal, a tiger is an animal, a tool
is not an animal. So you will not say tool
210:22 - extends animal never. Um, if you're just looking
for something to like, not copy and paste,
210:23 - to not duplicate code, you can do something
else, put your code into its own object, a
210:24 - tool object. And then always you can use composition.
You could say, for example, a tiger has, I
210:25 - don't know, um, has a leg. If that makes sense
or not, I don't know. So leg, leg.
210:26 - And then you if you have a method, for example,
walk, you can say leg dot walk. And if you
210:27 - have another animal that also needs up it
called eat still. So this would be walk. So
210:28 - now if you have another animal that should
also use the lecture also use this method,
210:29 - you can also make it to have
210:30 - this member. And this by the way can and also
should be an interface. So that really makes
210:31 - it much more flexible actually, even than
inheritance. Because using an interface, you
210:32 - can exchange the behavior at runtime. This
is something I showed you in the last episode
210:33 - talking about interfaces, where I said you
could have some condition, if I don't know,
210:34 - Sunday.
210:35 - He was
210:36 - this implementation and otherwise the other
implementation. I mean, this is just not real
210:37 - code. Just very fast. Else. I just hope you
get the idea. I could say if Sunday, like
210:38 - equals to my fast leg, legs, you know.
210:39 - And
210:40 - the other days, I'm not so fast. I say used
to slow lag. And then after the instantiation
210:41 - I would say like dot walk.
210:42 - Okay,
210:43 - so of course I mean this if else again introduces
some complexity. So whenever you design something,
210:44 - there's always pros and cons, you have to
think, what do I really need? But so you can
210:45 - use this, just to give you one example to
not use inheritance and still not duplicate
210:46 - your code. Oh, okay. Let me remove that. Don't
want it to be read. Wanted to be working.
210:47 - Okay, now, let's maybe recap before I finished
this video. So we talked about inheritance.
210:48 - We talked about polymorphism. I showed you
you can use composition. And there's also
210:49 - actually design principle it's called favor
composition over inheritance. As I showed
210:50 - you you can mix using inheritance with was
that one of these classes? Yeah. With interfaces,
210:51 - I showed you can implement several interfaces,
you can only extend one class. So I cannot
210:52 - say it already. When I do the calmer Something
is wrong. So I cannot say this animal to this
210:53 - doesn't work. Just believe me for now. Or
I mean, yeah, this is also a class, which
210:54 - is implemented. Yeah. So you see class cannot
extend multiple classes. This works in C plus
210:55 - class. And it's even more nasty than Single
inheritance. This causes something called
210:56 - the deadly diamond of death. But I will not
continue. This is too, too much for now you
210:57 - can google this deadly diamond of death. Because
Java doesn't support multiple inheritance.
210:58 - I'm going to talk about the method finalize
of the class object. The class object is the
210:59 - root of the class hierarchy. Every class in
the whole Java universe inherits the methods
211:00 - of this class. So this is what makes those
methods here, very important. Which is probably
211:01 - also the reason why those methods are very
often used in Java developer job interview
211:02 - questions. So one way or the other, I hope
I have now raised your attention. Also, you
211:03 - should now that this episode, as well as the
following ones talking about all those methods
211:04 - are based on the really great book, Effective
Java second edition from Joshua block. I think
211:05 - I mentioned it already earlier. Now I have
to say it again, buy this book read it. Even
211:06 - better would be if you read it twice. It's
full of condensed information. Advanced Java
211:07 - developer must know my episode is supposed
to give you an introduction to the topic.
211:08 - But for more detailed information, it's necessary
that you read this book. Okay. So let's already
211:09 - start talking about the finalize method. The
finalize method is actually a hook method.
211:10 - What is a hook method? a hook method is a
method that, um, there is an empty implementation
211:11 - provided in the class object. And the idea
is that when you want this method to be used,
211:12 - he would provide an implementation in your
own class, by inheriting by overwriting sorry,
211:13 - by overwriting this method. And then this
method will be called by the JVM. But before
211:14 - I go in more details, the one the most important
takeaway from this episode is, this method
211:15 - is flawed. So the best you can probably do,
generally speaking, is not overriding this
211:16 - method. So not using it because it has its
flaws, will, in this episode, see? Why. I
211:17 - mean, there are some few valid users, at least
according to Joshua blog.
211:18 - I can tell you, I'm developing in Java since
2001. So quite a few years already, I have
211:19 - never ever overwritten this method. So today
is probably the first time to demonstrate
211:20 - you what it is what it does. Okay. So maybe
we should already jump into the into the code,
211:21 - because it might be easier to understand for
you, or maybe before we read here, this description.
211:22 - So the finalize method is called by the garbage
collector of an object, when garbage collection
211:23 - terminate determines that there are no more
references to the object. So again, next question
211:24 - was probably what is the garbage collector?
Well, the garbage collector is really a very
211:25 - cool thing of the Java language. Other languages
such as c++, don't have it. As the name implies,
211:26 - it collects the garbage what's the garbage
the garbage is or objects that you created,
211:27 - worked on them. And after some time, the process
will be finished, at least on certain objects,
211:28 - he will not need them anymore. And so it helps
to free up those memory resources. So that
211:29 - you hopefully never run into out of memory
exception. And this is all done behind the
211:30 - cover as synchronously by the garbage collector
for you. But here is already the problem of
211:31 - the finalize method. Because I said it's,
it's called just before the garbage collector
211:32 - runs. The problem is the garbage collector
is running as synchronously so you can't influence
211:33 - when or if the garbage collector is running.
It is like its own smart beast. And you have
211:34 - no influence to tell it that it should run.
You can only give it recommendations. But
211:35 - you have no guarantee that the garbage collector
will ever run. And so you also have no guarantee
211:36 - that the finalized method will ever run. Yeah,
and what would you usually do in the finalize
211:37 - method, the idea was, you will also clean
up stuff, they're just not memory related
211:38 - resources, but not memory real related resources.
For example, if you have a connection to some
211:39 - i o resource, like a database or a file, those
are also system resources. And all resources
211:40 - are limited. So if you don't want to get in
trouble, and if you don't want that your system
211:41 - totally, totally freezes. You have to, again,
free up resources when you don't need them
211:42 - anymore. So the idea was to do that in a finalized
method. Now the flaw is, you don't have a
211:43 - guarantee that runs. And this already says
it's not working as intended. Okay. Besides,
211:44 - Joshua Bloch also gives other reasons. For
example, He somehow measured that creating
211:45 - an object and destroying it, again, is 430
times slower when you have an finalizer method
211:46 - implemented. So again, don't use it. And now
let's jump into the ID and look at it in more
211:47 - detail from a practical point of view. Okay.
Also, just before, in the API documentation,
211:48 - you might have seen, this method is actually
protected. Here. Again, we can see it protected
211:49 - void finalize, I mean, this Java API is just
written into the source code. Here, you can
211:50 - see the source code of object dot java. So
you see, it's also just a regular Java class.
211:51 - And you'll also see this method is empty.
This is what I said, it's a hook method. The
211:52 - idea is that you override the method and that
you provide code that is executed for cleaning
211:53 - up non memory resources.
211:54 - And Java, try to prevent that you directly
call the finalize method, because as I said,
211:55 - the idea is that you don't call it but that
the JVM calls it for you. So this is why this
211:56 - method is actually protected. Protected is
quite hard to understand. One way you can
211:57 - use a method that is protected is if you are
in the same package. So let's check this class
211:58 - isn't a package Java Lang. So I thought being
nasty, I can just as well create a class in
211:59 - this package. And this is what I did here,
test Java. In package Java Lang. You see,
212:00 - everything seems fine. I don't have any exception
from the compiler. So now, let's try to call
212:01 - this method. And you see, this dot finalize,
seems to be working. I mean, this is not working,
212:02 - because this is a static method. So we would
actually need a non static method. Or I could
212:03 - also say, new object. Well, there is an exception,
because it can throw a throwable as we see
212:04 - here at the bottom. I'm not going to handle
this now, because I only wanted to show you
212:05 - from a theoretical point of view, this is
possible. There's just one problem. Let me
212:06 - now surrounded with a try catch to get the
compiler happy. So see, this would be now
212:07 - directly calling finalize, from a class that
is in package Java Lang. So I'm within my
212:08 - public static void Main method. So I execute
it. Bam, I get an exception, security exception.
212:09 - It's prohibited. I cannot use Java Lang as
a package name. So this is not working. Okay,
212:10 - I just thought I should show you. I think
this is quite interesting. Now, let's close
212:11 - this again. And let's complete remove this
method. Okay, so what you should also know
212:12 - I mean, I said object is the root class, but
it's also a concrete class, you can create
212:13 - objects of the class object. What I don't
like here is that the word object is used
212:14 - twice, because the class is called object.
That's a bit confusing. So anyway, you see,
212:15 - you can call all those methods. But here within
the class car selector, we cannot call the
212:16 - finalize method. Okay. So for this, I have
here, this portion class, that's also close
212:17 - the object class. And now let's override the
finalize method, public void finalize, without
212:18 - any parameter. So to override a method, it
is very important that you do it exactly.
212:19 - Like in the superclass, the only difference
is, and this is allowed, I don't make it protected
212:20 - anymore, I can make it public. Because public
is more visible than protected. This is fine.
212:21 - Okay. And now, the idea would be that in here,
I do clean up my resources. Let's imagine
212:22 - I had some i, o reader, i, o reader, reader,
Peter, I'm not going to implement this, just
212:23 - so that you get the idea. So the idea was
that within here, he would like for example,
212:24 - close those resources for this, usually I
already use provide a closed method. Now there
212:25 - are several problems for one, I said, you
don't have a guarantee that this method is
212:26 - ever called. This is totally in control by
the JVM, and you can not influence that it's
212:27 - running out of your control, it's running
as synchronously. And therefore, it doesn't
212:28 - really serve our purpose. Second flaw is,
if within here, we have an exception that
212:29 - is not caught,
212:30 - the
212:31 - process here will be stopped. And our objects
will remain in some weird, let's say zombie
212:32 - state. Yeah. Okay, so the question is, what's
the alternative than to using the finalize
212:33 - method, the alternative would be, if you have
a class that you will use that uses resources
212:34 - that you want to be closed before it's cleaned
up, you could provide, like I told you here,
212:35 - the reader would do. You could and you should
provide some closed method. And then in here,
212:36 - you do clean up i o resources. I'm going to
implement this now. And then make this compilable
212:37 - in car selector. Let's imagine this was a
client of using Porsche. When we have Porsche,
212:38 - Porsche, a new Porsche you use a try Finally,
we talked about Exception Handling array.
212:39 - And I think, there in this episode, I told
you also, you can say try catch and finally,
212:40 - but you can also use the finally without a
catch. Now, if we need a catch or not, this
212:41 - is a different discussion. What is important
is that at the end, you have finally because
212:42 - the finally the cool thing about the Finally,
even when there is an exception happening,
212:43 - it will always be executed. Because this was
our problem, we need to make sure that the
212:44 - non memory resources get cleaned up. Okay,
so try finally. And then in here, we could
212:45 - say Porsche e dot close to clean up the resources.
This is how you probably do it in Java. Okay.
212:46 - Also, shortly, let me show you what I think
is interesting. Let's go back what I had before
212:47 - and the finalize method. What I also want
you to know is I mean, I said we overriding
212:48 - the method from the class object which is
empty. And there's actually an annotation
212:49 - that is quite helpful here. And this is the
annotation, the override annotation. See,
212:50 - when I put the ad, there is override. So about
annotations. We have haven't talked a lot
212:51 - yet. So let me explain that. In short, this
is actually some meta information for your
212:52 - compiler, that you say, Well, my intent here
is I want to override some method. If this
212:53 - has a different name, some other name. Here,
you see, you get an exception method does
212:54 - not override any method from its superclass.
Now, you might not understand what this helps
212:55 - us. So let's, again, call it finalize. Now
the thing is, you only override a method if
212:56 - the signature is the same as in the superclass.
Now, if I add the parameter here, this is
212:57 - not overriding anymore, but overloading the
method, because it's just a method that has
212:58 - the same name. But as it has a different parameter,
it has a parameter string, and not no parameter.
212:59 - This is not overriding anymore. And now we
get a compile error. So you will directly
213:00 - notice. So this helps us to have the problem
directly at compile time while we're still
213:01 - in our ID. And we will not because otherwise
it could happen, you think you have implemented
213:02 - a method while you have not. And then you're
still using the superclass method. And this
213:03 - you will only see when your code runs on production.
This is why whenever you override something
213:04 - at this override, annotation. Okay. So I think
this is pretty much it, talking about the
213:05 - finalize method. In short, again, generally
speaking, don't use it. Instead, to free up
213:06 - non memory resources use a try Finally, I'm
going to talk about a method clone of the
213:07 - class object,
213:08 - a class object I said before, is the superclass
of all the objects in the Java universe. And
213:09 - this is why you can use the method clone in
all your objects. Now, the question is, should
213:10 - you Really? And the short answer is, you should
not at least generally speaking, and this
213:11 - is similar to the finalize method that we
talked about in the last episode, which is,
213:12 - again, the reason why I'm talking about clone
today, because in this aspect, they're both
213:13 - quite similar. Okay, but before going in more
details, maybe first of all should clarify
213:14 - what actually does the clone method do. And
clone as the name implies, it creates an identical
213:15 - copy of the object that you call clone on.
So what it does not do is, if you have an
213:16 - object, you can always assign it a second
or third, how many references ever you want.
213:17 - The problem is with references, that when
you work on this reference, all other references
213:18 - will have will be influenced by your changes.
And sometimes this is not what you need, you
213:19 - want an independent copy. And for this reason,
you could use the clone method. However, there
213:20 - are actually better alternatives, which I'll
tell you later. But now enough of talking
213:21 - Anyway, let's jump into my ad and look at
the code. Okay, so, here you see my Porsche
213:22 - test, you might remember the pushy and the
other cars from my earlier episodes. Before
213:23 - I show you the nasty stuff, I wanted to show
you one case, where actually I think using
213:24 - clone is actually good. And this is here I
have prepared an array of strings 123 and
213:25 - here, I mean array is also an object. So it
also has the clone method and for the string
213:26 - for the array, it was already implemented
the way it should be. So you can and you should
213:27 - clone your array. So I can say string copied
array equals to array dot clone. And then
213:28 - I can assert not same, which means this check
checks. Now, if we just have a reference.
213:29 - In this case, it would be the same
213:30 - airy
213:31 - and copied airy. Which, to show you that their
friends I can also call, assert same and use
213:32 - twice the same reference. So this should be
true. They should with not also be true. So
213:33 - there are two different instances.
213:34 - You see, it finished with a green bar, this
is what we want to see. So it seems error
213:35 - and error compared to itself, it's both the
same reference, they're both referring to
213:36 - the same object. But the copy is not the same
reference, it's not the same object, it is
213:37 - a new object. And now, I mean, I want to make
this short. But I want to show you at least
213:38 - system out, print ln. And then, you know,
this is not I just want to show you the first
213:39 - element and then I just hope you believe me,
or you can do it at home can print out the
213:40 - whole elements in in an in a loop. Now I'm
just showing you the first element of my copy,
213:41 - and you see it's one. So the other ones are
also or unlike just as well. Otherwise, you're
213:42 - telling me copied error. This way, you also
learn how you can print out the whole array.
213:43 - And this is now I can print odd STR and this
will then in the loop and a for each loop,
213:44 - print out all the strings
213:45 - for us.
213:46 - So I hope this is working now. 123 C, out.
Okay. So for now this should be enough. This
213:47 - was just a very short demonstration of a good
case of clone. Actually, I found on the internet
213:48 - and very interesting article Actually, it's
a newsletter article from Dr. Heinz Cabot's,
213:49 - he's really a very cool guy. I love his newsletters.
And he actually made a test and found out
213:50 - that clone for very small areas might be a
bit shorter, f slower. However, for large
213:51 - arrays, it's actually faster than any other
method. Well, I can't go in more detail, we
213:52 - don't have the time. And this is also very,
very advanced already. And we're still on
213:53 - beginner level, approaching more advanced.
So anyway, let's continue with our portion.
213:54 - And this is now really test driven style programming.
Because I start with an empty test. The code
213:55 - is not finished, we start with writing a test
to test Well, first of all we read, and then
213:56 - we are working our way to get the test screen.
Okay. So I say Porsche Porsche equals to new
213:57 - Porsche, actually, this is something you can't
know. Before doing this episode, I have extended
213:58 - adjusted my class a bit. I mean, you might
remember the Porsche from my last episodes,
213:59 - because it was empty. Initially, there was
no attributes, no instance members. So this
214:00 - I had to change because I want to show you
something that we copy. So I added a string.
214:01 - And I said, it's the owner, the name of the
owner. And well, which name should I choose?
214:02 - Because I always wanted to own a Porsche.
I thought I might just as well make me the
214:03 - owner of the Porsche. And because you probably
also want to own a Porsche. I thought I should
214:04 - make you the owner of our copy of our clone.
Because I will not give you my pushy, but
214:05 - I might just as well copy mine and then give
you this copy. Well, in real world, this is
214:06 - pretty much impossible. However, here in Java,
See how easy that is? Only problem we have
214:07 - is I don't know your name. So for this example,
I just assume your name is Peter. So I say
214:08 - Peters for xi equals to new pushy. But this
is not what we wanted to do. Right? We wanted
214:09 - to clone. Yeah, because this is no easy. I
can just say Peter, and then you have your
214:10 - pushy but this is not the original idea. So
let's remove that. And now let's say Porsche
214:11 - dot clone. And interesting enough, really,
I mean, we can see what happens behind the
214:12 - covers, because this is done really, by the
JVM. And we don't care too much, as long as
214:13 - it works. But there is never a constructor
actually cold. So this is really internally
214:14 - copied from the memory. It's just see, we
still have this read something is still wrong.
214:15 - I mean, I said, we start with a not working
test. So it says clone has Protected Access
214:16 - and Java Lang object. And this is something
we have to fix. So the method that says the
214:17 - method is already there. The problem is, it's
not visible to us, because it is protected.
214:18 - Protected would be visible in the same package.
The class object is in the package, Java,
214:19 - Lang, as I showed you last time. But here
we are in a different package. Also, my Porsche
214:20 - test does not inherit anything from Porsche.
Because this is from Porsche, so I can't use
214:21 - clone in here. Okay, but what I can and what
I will do, I can override the original clone
214:22 - method. But still, I want the code the implementation
of the class object. But let's already jump
214:23 - into the Porsche class. So I will override
it, public, Porsche, because I wanted to return
214:24 - a Porsche to me,
214:25 - clone.
214:26 - And then you might still remember from my
last episode, we can and we should put the
214:27 - override here to have a check from the compiler
side, that we actually did everything correctly.
214:28 - Now, let me format that. Okay. And you see,
there's nothing red. So it seems like so far,
214:29 - everything is fine. We'll actually went into
one interesting thing is the original implementation
214:30 - says object, because in object, what could
you return, you don't know. The object that
214:31 - the method always is exactly copying whatever
object there is. And in our case, we have
214:32 - a Porsche. So the so it is also fine to directly
make this return pushy. But now we have an
214:33 - empty implementation. And we have to return
a Porsche. Or we could say return new Porsche.
214:34 - But again, this would not be a clone. So this
would, our test would fail in this case. So
214:35 - this is not what we can do. So we have to
say super, super means. I want to call a method
214:36 - from superclass in this case object. And you
will see already here I see clone is actually
214:37 - the first method, because my ID is already
smart, it knows the name of this method is
214:38 - clone. So it assumes I want to call super
clone. Okay, so and then I want to return
214:39 - it. So all we did so far is we override the
method. And then again, we said, well, actually,
214:40 - I don't really want to override it. All I
want is I want to use the method of class
214:41 - object. So all we did so far is we made the
visibility public so that we're able to use
214:42 - it this is all we did so far. But now, you
see there is still a problem unhandled exception
214:43 - Java Lang clone, not supported exception.
And this is already in my opinion, a flaw
214:44 - because, like, why does this Now throw a clone
not supported exception, if we do support
214:45 - clone. So, anyway, this is how it is. And
now we have to fix that the way we fixed that
214:46 - is we say try, because there is an exception
that could happen. And we will catch the exception.
214:47 - Catch. And there my ID Egan helps me clear
not supported exception.
214:48 - I usually give it the name here. Okay, now,
what should we do here? Some people say return
214:49 - now. Because we have to return something.
This is just the signature forces us
214:50 - to return something. But this is not so nice.
I mean, actually, we assume this is hopefully
214:51 - never happening. But if it for whatever reason
is happening, we really want to see that it
214:52 - is a problem. So in this case, and I kind
of copied that from Josh block. Because again,
214:53 - my episode here about clone is based on his
book, Effective Java second edition. And it
214:54 - was exactly the same with a finalized episode.
So I can only give you a short introduction
214:55 - to the topic. Um, Josh block in his book,
he has like, I think eight pages only on the
214:56 - clone method. You should really buy the book
and read it. So for this, you can go to macros
214:57 - minus bu.com, click on mastery, it's, and
there you will find the book and you can buy
214:58 - it directly. Yeah, also all the books in the
must read section. I mean, I have picked the
214:59 - name for a reason. Those are really books.
I want you to read them all. They're really
215:00 - classics, the best of the best best Java books
you could find, in my opinion, at least. So
215:01 - if you trust me by that book and read it,
okay, anyway, so what he did and what I will
215:02 - do the same, as he said, throw new assertion
error. Because if this happens, this is not
215:03 - even an exception. Is this really an error?
We really have a big problem here. If we get
215:04 - this clone, not supported exception. Okay,
so this year now seems fine. But there's still
215:05 - something wrong. And this is it says I'm calling
super dot clone. And as I told you, this is
215:06 - the method from object, an object returns
an object, at least from the signature of
215:07 - the method. But we are smarter we know actually,
it's safe to say pushy, because this object,
215:08 - I mean, the super type is object. But the
subtype is a Porsche. So we do an explicit
215:09 - cast, and we cast it to Porsche. This is safe
here. Yeah, if it was not safe, it would throw
215:10 - a class not support F. Class cast exception.
Sorry. But in this case, believe me, we'll
215:11 - see. It'll it should work. Okay, well, are
we done? It looks like we were. Well, actually,
215:12 - as I said, this method is flawed. So we are
not done, we still have to do some more thing.
215:13 - But this I want to see. I mean, my idea was
to implement the method I did that. So now
215:14 - let's go back to our test, you see, everything
is? Well, I can't say green, but the red stuff
215:15 - has gone. So I can execute the test. But I
haven't asserted anything yet. So the first
215:16 - assert that I want to do is I want to assert
not same. This is just a shorter, Handy form
215:17 - of saying not equal. So it won't be the same
if we say pushy, not equal to Porsche Peters
215:18 - pushy, because the idea is that when my clone
word that I have a new object. And because
215:19 - it's good to have a method that already from
the method name tells us what it does, I use
215:20 - this one. And I compare not pushy to Peters
pushy. So my first test is just asserting
215:21 - that this reference here is not referencing
this Porsche here now. But something else,
215:22 - this isn't our first test all I want to achieve.
Okay, so I execute the test.
215:23 - And bomb.
215:24 - You see the assertion error? I said, Well,
everything will be saved law when it's not.
215:25 - And this is why tests are so great. Yes. And
now we can see what happened. And think about
215:26 - why did this happen? Okay, so by jumping here,
see, line 28. I see this happened. Problem
215:27 - is here in this case, without further knowledge,
it would really be hard to know why this happened.
215:28 - So here, sorry, I have to help a bit. Thing
is, I mean, I told you this method is flawed.
215:29 - It's not enough to use the power of inheritance
here. On top you have to use, you have to
215:30 - implement an interface here. So we are already
implementing car. But for interfaces, I told
215:31 - you in the episode about interfaces, we can
implement several interfaces. So here I have
215:32 - now to implement the cloneable interface from
Java Lang also. Now, funnily enough implementing
215:33 - the interface, normally, I would expect that
I would have to implement some method. Well,
215:34 - in this case, it's different. We don't have
to implement anything. And this is a specific
215:35 - case, this interface we call a market interface.
So this interface is actually empty. There's
215:36 - nothing in there. It just tells the JVM. I'm
implementing cloneable. So you can call cloneable
215:37 - here, it's a clone here it works. And this
is a bit awkward, because normally when you
215:38 - implement an interface, you would on the Reference
Now, like I can now say that I implement cloneable,
215:39 - I can also make this a cloneable. So that
my pietras portion now plays the role of being
215:40 - a cloneable. The problem is, this doesn't
help me anything. I don't have the method
215:41 - cloneable. Here, all I have is the other methods
of the class object, which we're not using
215:42 - now. So because I can also say car, I mean,
I'm implementing, also the car interface.
215:43 - And then I can call the methods of car, which
is drive, plus all the methods of class object.
215:44 - Okay, well about macros interface. That's
also another topic. This is a design pattern.
215:45 - haven't talked much about design patterns
yet. Marker interface really has good users.
215:46 - So a marker interface, generally speaking
is not bad. It just here in this case, it's
215:47 - a bit weird that you have to implement a market
interface and then on top, you have to override
215:48 - the method. Okay, so I make this portion again.
But now, and now the same as already, again,
215:49 - working because otherwise you could not compare
different things. Let's try it again. And
215:50 - see, now we have the green bar process finished
with exit code. So my first assumption is
215:51 - correct. Peters pushy is not the same instance,
as pushy. Okay. So now I want to see who is
215:52 - the owner at the moment of Peters, Porsche,
Peters, Porsche, Dodd, s string. And this
215:53 - is why before I prepared this method, because
it returns Porsche II off plus the owner's
215:54 - name, because at the moment, we don't have
another way of seeing the content of owner's
215:55 - name. So I wrote this method to see who is
owning it at the moment. Okay. And my expectation
215:56 - when we're finished is that the name would
be Peter. So I would say it should return
215:57 - partially off, Peter. So let's write a test
for this. assert, equals, first, the expectation,
215:58 - you also see it expected. So I'm expecting
it to say pushy off Peter. Okay. And then
215:59 - comma. And I put here pushy, Dodd as string,
which is calling the method. So I expect the
216:00 - method to return portion of pizza later on.
I mean, there's also again, a method called
216:01 - equals. In an later episode, I'll talk about
this and we will have a better way of comparing
216:02 - that for now. I'm using the S ring method,
because we haven't talked about the equals
216:03 - method yet. So there's still something missing.
216:04 - Okay. I can remove that. So let me also execute
this test now. And it should be read. Yeah,
216:05 - oh, there's an error. I have missed a semicolon.
Again, sorry. Yeah, comparison failure. Expected
216:06 - portion of Peter bar is still mine. Now this
is even cooler for me. Now I have actually
216:07 - two portions. But okay, I said you get one.
So let's change that. And for this, I will
216:08 - now change the owner. So I will sell on my
second car. Okay, and I will sell it to Peter.
216:09 - Which means I mean, I just made this method
up before I assign the owner's name the new
216:10 - owner. Okay. Also, by the way, I mean, here
I'm using string to have this as simple as
216:11 - possible for our example. Usually, I would
prefer to have this proper object also, like,
216:12 - name, for example, and I also already have
that here. But in this fast example, I use
216:13 - string. But more object oriented would be
if you have name as an object there. Okay,
216:14 - so I sell it to Peter. And now I expect the
test to be green. Let's try it again. Okay,
216:15 - it's green,
216:16 - it worked.
216:17 - But now I have a fear. What if now my pushy
would not be mine anymore. So on top, I want
216:18 - to assert that the The original pushy is still
mine portion of macros to the original portion.
216:19 - K, which also worked. And this tells us now
starting from my pushy macros, I called the
216:20 - clone method, it created a new object in memory.
And this new object was assigned to the reference
216:21 - Peters Porsche he inserted that they're not
the same object to different objects. And
216:22 - then I changed the second object. And I gave
it the owner of Peter. So and I asserted that
216:23 - now, the owner's name is Peter, by comparing
the string. And second, I asserted that what
216:24 - I was working on the second object, the copy
was not influencing my policy. So this is
216:25 - like proving that our clone operation did
work. But now let's look at the code. What
216:26 - we needed to do for this, I had to say implement
cloneable, I had to override the clone method,
216:27 - I had to call the super clone method, I had
to catch the clone, not supported exception.
216:28 - This is a lot of lines for only this. And
actually, there's more to it. Because actually,
216:29 - what this does is it creates only a shallow
copy, and not a deep copy. Now, again, this
216:30 - is a more advanced topic. So I try to keep
this as short as possible. What's the difference
216:31 - between a shallow copy and a deep copy? Okay,
well, a deep copy for this, I have prepared
216:32 - here a more complex object BMW. And here I'm
using actually the object name. And I'm even
216:33 - using a second object color. And let's make
this a bit bigger. So you see more, a deep
216:34 - copy would mean that not only BMW is copied,
but also all the objects inside of BMW are
216:35 - copied. So that they are also independent,
that they're not referencing the same object.
216:36 - But a shallow copy will here, only copy the
reference. And the object for name, as well
216:37 - as the object for color will still be the
same objects for shallow copy. Sometimes this
216:38 - is okay. And sometimes it's not, it really
depends on your implementation. However, in
216:39 - short, if you're using clone want to make
a deep copy, you will also have to call clone
216:40 - on the internal objects, and this here, I
have prepared. So here, I'm calling clone
216:41 - actually, three times. Now, one more problem
of the clone method is what I'm actually doing
216:42 - here is, first of all, I cloned BMW, and then
on this attribute, and this one, which is
216:43 - already fully functional, I assign a new value,
which only works if this is not final. So
216:44 - it turns out not to in order to make a deep
copy, it only works if your internals are
216:45 - not final, and sometimes you want them to
be final. So this is really a limitation of
216:46 - the clone method. And also, I mean, how complicated
it is, is not so nice. Okay. Um, and for this,
216:47 - there are alternatives I told you. I've written
here a lot of code. I have written this code
216:48 - so I could show you what to think. Yeah, I
would want to make this episode not as long,
216:49 - because I noticed many of you are only watching
like the first minutes. So 95% will already
216:50 - be asleep anyway. So let's keep this short.
So in short, let me show you alternatives
216:51 - to using the clone method. There are two alternatives.
The first alternative is using so called copy
216:52 - constructor, and this is this thing here.
The copy constructor has one parameter, and
216:53 - this is the same object. And then you see
here, I say new name, on owner's name, new
216:54 - color on BMW dot color. So I'm taking the
internals and I'm creating new objects on
216:55 - it.
216:56 - And so in the end, I will have a new object
that has the same values as the original object.
216:57 - This is One alternative. The other alternative
would be, and this is actually my preferred
216:58 - one to use a so called static factory method.
216:59 - And this is this here, it's a static method.
So you can directly say BMW as the class name
217:00 - dot new instance, you can give it the BMW
object you want to copy. So in this case,
217:01 - probably Marquess BMW. And then you You see,
I again, call the constructor, new BMW. But
217:02 - here, this is a more complex object. So I
have to recursively we call this recursively.
217:03 - Because again, I say new instance. And he
also new instance. And I have to again, call
217:04 - those methods to also cop copy the owner's
name, because now I'm actually doing a deep
217:05 - copy, I could have also just assigned the
values, this would be a shallow copy, but
217:06 - it's safer to have deep copies. Okay, so And
for this, we can also have a short look into
217:07 - name and color. Because there again, I do
the same thing. Here I have my new instance
217:08 - method. So this is taking a parameter of name,
and then says new name, first name, dot last
217:09 - name. Now, first name and last name are both
strings. And strings are also objects. So
217:10 - why do I not need to copy down? Okay, now
it gets more and more complicated, I'm sorry,
217:11 - um, thing is a string as an object, but it's
actually an immutable object. And immutable
217:12 - means whenever you change the object, like
you assign, instead, first name, Marcos, you
217:13 - say, Peter, you will not influence the other
reference. But instead, whoever said make
217:14 - this, Peter will get a new object. So this
was really helpful. And for string, this is
217:15 - done for you. Actually, you can do this for
your own objects too. And in order to achieve
217:16 - this, you just have the limitation that you
don't offer any method to the client that
217:17 - allows the client to change the values in
here. But instead, you will always for any
217:18 - change, return a new instance. And then you
have an immutable. For this, I have also here
217:19 - an immutable test. Because there's another
class that actually does it, which is big
217:20 - integer. Big integer is similar to an int,
that we already looked on it just a bit better.
217:21 - First of all, because it can work on ends
of, well, at least theoretically, any length
217:22 - until your memory is full. And there you have
operations to add and subtract, for example.
217:23 - Now, when you say one, add one, this is returning
a new object to but the original object will
217:24 - not be influenced by this operation, you can
also subtract, but everything that you call,
217:25 - every method that you call will never influence
will never change how the object looks. So
217:26 - it's created once with the constructor, this
will like assign one to it. But after this,
217:27 - you can never ever changed it again, which
is very helpful. In many cases, it's really
217:28 - a good design principle to use immutables
whenever possible. Um, yeah, and it's also
217:29 - very good to use multiples when you do code
multi, multi threading. We haven't talked
217:30 - about multi threading yet, we will at a later
time. But there immutables are also very helpful,
217:31 - they will make everything more easy. So, maybe
you take one more thing with you from this
217:32 - episode. And this is favor immutables try
to design your objects your classes in a way
217:33 - that they are not mutable, that they cannot
be changed after they were created. Or came
217:34 - here at the same thing with string. Maybe
I can show you so I call so assigned twice
217:35 - Hello, which in memory is actually the same
object. But when later on here, I Say hi.
217:36 - This will influence the string one, and not
influence a string to let's execute this shortly.
217:37 - So you see, like the speaker so we can see
Bo's bigger even. Okay. So now I see the first
217:38 - string here printed Hi, the second string
printed Hello. And so they're not equal, the
217:39 - first one has high, and the second one has
Hello. And if I remove this, this is why I
217:40 - had commented it out. Let's execute it again.
Of course, now they both have Hello. So that's
217:41 - the difference. And this is one example of
an immutable strings are, by definition immutable.
217:42 - Maybe we could also call this here. So I print
out any n 01. And two. And also, I assert
217:43 - to do a few things. So the input value of
one is one, the input value of two is two,
217:44 - and the end value of zero is zero. Well, I'm
operating on these objects, they will always
217:45 - return a new object, return a new object,
they will not influence the original object,
217:46 - this is an immutable, this is something that
you should try always to achieve our K, let's
217:47 - go back to Chrome. Let's recap. So in order
to properly use clown, you have to first of
217:48 - all, override the clone method so that it
is public. Second, you don't have to, but
217:49 - it's recommended. Use not object here, but
use the type of the class that you're in,
217:50 - then you will have to do an explicit cast
to the class here. Catch the claw not supported
217:51 - exception, thrown your assertion error, which
will show you in case you forgot to implement
217:52 - cloneable, which you will also have to do.
However, what this is going to achieve, it
217:53 - will create a shallow clone for you. Which
means if there are objects that are not immutables,
217:54 - and you then operate on those objects, this
can break another object, because still you're
217:55 - not totally independent, you're only potentially
independent, you're only on the first level
217:56 - independent. But if here you have name, this
will only copy the reference and the object
217:57 - here would still be the same. If you also
want to achieve this, you have to implement
217:58 - a more complex clone method, you have to also
call clone on the internal objects and then
217:59 - assign the new clone values to your internal
attributes, which will only work if they are
218:00 - not final. So this already limits the way
you can implement your code. See if this is
218:01 - not working now. So and this is one of the
one of the many, sorry, one of the many reasons
218:02 - why you should not use clone, other than to
clone an array. And I showed you two alternatives.
218:03 - One is use a static factory method. I call
the new instance. Same like Josh block in
218:04 - Effective Java that you should buy. And here,
I call the constructor. And again, recursively.
218:05 - I call again, a factory method on name. And
again, a factory method on color, which even
218:06 - creates a deep copy. Or I can do the same
thing with a constructor. But you see this
218:07 - is actually shorter. So this is why I would
prefer to use the factory method. But it both
218:08 - works. Okay, so here, I call twice a new constructor,
I create a new name object, and I create a
218:09 - new color object. Okay, and then in name,
we can also look. You see, I do the same thing.
218:10 - And this now is strings and I said strings.
Now we don't have to call clone because a
218:11 - string is immutable. So you have to do this
recursively until you reach either an immutable
218:12 - object or a primitive. If this were again,
like first name object, we would have to continue
218:13 - with cloning, or copying, like calling the
constructor until you reach either a string,
218:14 - or a primitive value or another immutable
object. See here also implemented clone.
218:15 - And then we can also look at color one last
time. For all of them, I have done the three
218:16 - different implementations here with a static
new instance method, here with a clone method.
218:17 - And last but not least, here with a copy constructor,
it receives a color object, and then it retrieves
218:18 - the string from the original object, which
is a string, which we don't have to clone
218:19 - any further. I'm actually going to talk a
bit about various smaller topics. We're still
218:20 - on track, talking about the class object,
and all its methods. The last two methods
218:21 - I need to tell you about are hashCode. And
equals. Actually, they're one of the most
218:22 - important methods in Java, I think. However,
hashCode and equals are a bit more complicated
218:23 - to explain. So before I can tackle them, I
decided to push an episode in between to straighten
218:24 - things up. And to talk a bit about the missing
pieces in this episode. Okay, so let's start.
218:25 - As you see, I have prepared this demo test
class for you. Actually, we're not really
218:26 - testing something today. This is really only
to use to demonstrate those few small missing
218:27 - things. So let's do one by one. And the first
thing is, I want to talk about static imports.
218:28 - You might remember, I think I talked about
static imports, in the first three episodes,
218:29 - and I kind of promised you to later on give
you more details about it. The problem at
218:30 - this time was we hadn't talked about static.
Well, in the meantime, we have, I just didn't
218:31 - have any better opportunity to talk about
it. And I felt a bit guilty. So I think now,
218:32 - I should really finally tell you what exactly
is a static import, how you can use it, and
218:33 - what it helps you. So actually, we used it
all the time. And you might have seen it.
218:34 - Here on top, I have this import static org
j unit assert dot star, it's just grayed out
218:35 - because at the moment, I'm not using it. This
is also set here unused import statement.
218:36 - Now you can see it. And you can also see here,
the regular import or j unit test sub question
218:37 - is, what's the difference between the two
of them? So this one imports the code of the
218:38 - whole test class? Well, this one here, a static
import just focuses on all the static methods.
218:39 - Because in j unit, you know, when we want
to test, we always use these assert methods.
218:40 - assert equals assert true.
218:41 - Let's do that now. Like assert. True, you
see, it already helps me true. I mean, when
218:42 - true is always true. There's a stupid, but
I just want you to see the method. And the
218:43 - thing is, this is only not working because
I have this here assert and seeing, it's not
218:44 - great anymore, it turns white, because now
it's in use. So let's actually have a look
218:45 - at this class, I can jump there, you see even
it says it extends object will no wonder all
218:46 - the classes extend object anyway. So here
you see, I see the decompiled code. This is
218:47 - what my ID he can also do to show me the code.
This is very helpful, so you understand better
218:48 - what happens behind the cover. So you Here
you see a lot of static methods. So this class
218:49 - actually like groups them and makes them usable
to me. And as you might know, from static
218:50 - when I talked about static, the way you would
use a static method would be normally you
218:51 - say class name, dot assert true. Now you can
either use the full fledged class name, which
218:52 - is org dot j unit dot assert, and then assert
true or if you don't want to use the package,
218:53 - you would import the class and then you can
just say assert dot assert true. Of course,
218:54 - there are also other methods, you can have
a look on those, by yourself. actually quite
218:55 - complicated ones like you can even compare
areas, and so on and so forth, not equals
218:56 - equals, with message without is equals, and
so on. Well, we have used some of them. So
218:57 - this means I can also say, assert dot assert
true. But now you see this is not working,
218:58 - because I have not normally imported the assert
class. So if I would want to do this, I would
218:59 - have to say org, J unit dot assert, and then
import it like this. Now you see it's not
219:00 - used anymore, because now I'm not statically
importing it, but regularly, and I'm using
219:01 - the class name to use the method. But I mean,
when they introduced it, I think this was
219:02 - with Java five. The reason to introduce this
where it was to just make these statements
219:03 - shorter, because you don't always want to
write assert dot all the time.
219:04 - Okay,
219:05 - and you could also do it as said before, without
any import, this would even be more longer
219:06 - than you could go without the import. Now,
they are not see, but there it is working.
219:07 - That's the difference, because now I don't
do any import. Let's put it back. And then
219:08 - we can go with or without. And if you wanted
like this and the shortest form, you need
219:09 - the static import and not the regular import.
So that is a static import. And the dot star
219:10 - means just input all the static members or
members, static is not members, all the static
219:11 - functions and also the static variables of
the class. So if you have variables you want
219:12 - to import that are static. This also works
with the star operator here. But you can also
219:13 - say you import only specific functions or
attributes. So this is up to you. Okay, so
219:14 - that's all I can tell you about static imports,
I think sometimes they're helpful. More often,
219:15 - it actually happens, then you would think
that you would import several methods or attributes
219:16 - that are the same in different classes. If
you have that it's exactly the same, like
219:17 - I told you about the imports, you can only
import one method name once by using a static
219:18 - import. If you're not have a second class
that has the same method, you will then have
219:19 - to use the full fledged, or at least a class
name so that the JVM, the compiler knows,
219:20 - in this case, I want the assert true method
from this class. And in the other case, I
219:21 - want the assert true from another class. Okay,
so you can't I mean, there must be a way that
219:22 - the compiler understands what you're trying
to do. If I only import this statically once,
219:23 - I mean, then it's just obvious the assert
true is part of the assault class here. Oh,
219:24 - okay. So that much about static imports. The
next small thing I want to talk about, let's
219:25 - open this up is default values for different
data types. I think this is quite important.
219:26 - And also interesting. Because I see many people
that would have here, member variables defined.
219:27 - And then they would say something like, here,
or for cards, different weight. Like for the
219:28 - Boolean, they would say false. Or for the
object, they would say novel. And you don't
219:29 - have to do that. Because now for object, as
well as false for a Boolean is the default.
219:30 - So this is in my eyes, this is just clutter,
you write code that you don't have to. I mean,
219:31 - for every rule, there's always an exception.
For example, if this is very important that
219:32 - this is set to false. And this is really a
specific case and you want to give a message
219:33 - with it. It might make sense to sometimes
right here explicitly false. But then it also
219:34 - maybe you should name your variable a bit
different so that it says why this is important.
219:35 - And because my Boolean now I mean, this might
be the problem. It doesn't say why this is
219:36 - always false. Okay, so And now let's have
a look at all the different defaults. But
219:37 - when I say default, this really only applies
for these member variables up here. If you
219:38 - for example, have a local variable Like Boolean,
B, you can't do that, if I'm not trying to
219:39 - use it, this is not going to work. If b, this
will give me a problem variable b might not
219:40 - have been initialized, but it does work with
the Boolean up here. This is going to work,
219:41 - see, and now it will count as false. So the
if would not be executed the branch. Okay,
219:42 - but now enough of talking, blah, blah, blah.
You might already be asleep, so wake up. Okay,
219:43 - so let's make this a bit bigger, so we can
see it properly. Okay. Now, so you see, by
219:44 - default value, short default value, those
are all zero.
219:45 - Actually, there are many number types that
we haven't talked about. And this is also
219:46 - what I'm just going to introduce right now.
Because we totally focused on end, because
219:47 - this is actually the one that is most times
used. But as you see here, there are also
219:48 - others. I think I shortly once showed you
bite, and I also showed you one's car. Um,
219:49 - but there are also others. In my opinion,
this is just the smaller data types, we will
219:50 - see the ranges very soon are only here because
I think like this or similar, they existed
219:51 - in other programming languages before Java,
like maybe c c++. In my opinion, this is a
219:52 - The reason is probably because like something
like 30 years ago, the memory was so expensive.
219:53 - And that was really the memory space was so
limited, like you would have a memory of,
219:54 - I don't know, a few kilobytes. Now with gigabytes
of RAM, this is totally a different issue.
219:55 - So the space end users actually a bit more
bytes. But the space is really not relevant
219:56 - these days, in 99, and probably 99.9% of the
cases are always use int. So wide and short,
219:57 - in my personal opinion on something like deprecated.
I mean, this is not true, actually, because
219:58 - I'm sure someone can tell me there is a specific
case where you would need them. It just that
219:59 - on average, generally speaking, you should
be fine with an int. And we will look at actually
220:00 - the sizes of these types in a second. So yeah,
that long is actually bigger, can save longer
220:01 - numbers than end. This sometimes might be
needed, but also not so often really, I think,
220:02 - now float and double, as the name implies,
at least for float, they're both floating
220:03 - numbers. And double, I think the name comes
because it's like double the space or something,
220:04 - then that of a float. Actually, also these
I hardly use, because first of all, I personally
220:05 - did not worry too much with these kinds of
floating point calculations. And second, in
220:06 - case I did, for example, calculating on money
that you would need that. But they are they
220:07 - are quite problematic, actually, because they
don't calculate properly on the scent, it
220:08 - can happen that when you have something like
two euro 20 multiplied by, I don't know, divided
220:09 - by a number of people that in the end, you
lose or you gain a cent. And like in India,
220:10 - in the financial industry, this is just not
okay. So therefore float and double can't
220:11 - use be used there. The reason I can't perfectly
tell you but I think it has to do with internally
220:12 - these numbers of course stored in a binary
format, you know, a computer only knows zero
220:13 - and one. And then when, from this format,
it's transferred to our decimal format. For
220:14 - those floating point numbers, then there are
rounding issues. And therefore, when you really
220:15 - need to have a correct floating point result,
there are various other solutions. One is
220:16 - to store the number without the floating point,
for example, as a long or end or alternatively
220:17 - even as a string. And then you do your calculation,
and when it's finished. You insert the floating
220:18 - point visually at the place in the UI where
it's needed. Which is also dependent on like
220:19 - local settings, like numbers are formatted
differently in different languages. So therefore,
220:20 - this is usually the way you would go, at least
definitely in the credit card or in any financial
220:21 - industry. Okay, so anyway, float and double
are both floating point numbers. What is interesting,
220:22 - by the way, is like, when you have a constant
value,
220:23 - like 34 43.31, this here, I mean, this is
a value of constant value. And if I just write
220:24 - this down like it is at the moment, this is
now by definition automatically a double.
220:25 - If I want to have this as a float, I have
to say, the capital a lowercase F, at the
220:26 - end, which makes it up float. So, if I have
like float my float node equals to this, or
220:27 - he really have to say f at the end, because
if you leave it, I would get a problem, because
220:28 - it says it found a double, but float is required.
And the same applies actually for int, short
220:29 - bite, there is just the other way around,
because there is the default. And when you
220:30 - want to use a short short as equals to 43.
This just works implicitly because Java sees
220:31 - the space is fitting. And then it will just
implicitly convert the end because this is
220:32 - really an end to a short. Ever. Let's try
the same thing with a long, long for d3. This
220:33 - also works because now you try to store the
smaller thing, the end into a long, which
220:34 - should always fit. Okay. So what else, so
we have object, the default value is now as
220:35 - I said before, Boolean, the default value
is false. Car. Now this is interesting, it
220:36 - depends on if you safe if you display this
as a car as it is. And then this is I think
220:37 - it's called the null character. And I think
this is just nothing or maybe space here you
220:38 - see there is something it just can't be displayed
by my UI. I mean, here, if I try there's nothing
220:39 - blue. But here when I go over it, it's displayed
as blue because there is actually something
220:40 - it just not visible. And I can convert this
character, the default character to an end.
220:41 - And then it's a zero. Okay? Now, so these
were the default values of the different number
220:42 - data types as primitives. Okay, and now, as
the next topic, I also want to tell you never
220:43 - told you so far, all these number types, they
in parallel also exist as objects. Let's have
220:44 - a look, and then see and discuss why that
is. Okay, so you would have bide my, this
220:45 - is used already on top. So let's call, let's
just call it b
220:46 - equals to bite dot value of now, this is a
static method method, which can and should
220:47 - be used to convert convert, sorry,
220:48 - a byte primitive to a byte object. You can
also say new byte. But this is just not recommended
220:49 - because this might use more space. So, I don't
want to go in details because then I could
220:50 - talk forever for performance optimization.
But this is just creating always a new object,
220:51 - while the other one might reuse an existing
object of the same value. So, this usually
220:52 - is good enough. Okay, there's also other methods,
static methods like pars. The difference is,
220:53 - this works not on a string as far as I know,
let's try to Yes. And let's go into the function
220:54 - See, I can Also see it here. And this converts
it not to the object, but again to the primitive.
220:55 - This is the value of it converts it to abide.
He even you can give the radix, like the radix
220:56 - of 10, or eight or 16, or whatever. This usually,
well, I never really needed. But there are
220:57 - a lot of lot of functions. What is also interesting
is that these objects, they all extend the
220:58 - abstract type number, abstract class, we talked
about inheritance already. So you're here
220:59 - you can see all these different functions
that each of those number types have to implement.
221:00 - So each of them, you can convert to an int,
long float, double as the primitive value.
221:01 - The green stuff is, by the way, the Java API
documentation that you can also read online,
221:02 - short. So this, all these types automatically
will have. Okay, so back. Now, besides offering
221:03 - these cool methods, that might be helpful.
There is also another reason why these exists
221:04 - as objects. The reason is, I think, mainly
because there is something called collections
221:05 - that we will talk about very soon. I think
I even mentioned it shortly, it's something
221:06 - similar to an array, it's like an array on
steroids. It's just a container that you can
221:07 - throw in objects. And that's really it, you
can only throw in objects. And so you could
221:08 - not throw in any primitive. And therefore,
this is also called a wrapper type, because
221:09 - this object then will wrap around this primitive
type, and can be wrapped and unwrapped. Which
221:10 - by the way, in the past, when working with
primitives and collections was needed. So
221:11 - before putting it into the collection, you
would have converted your primitive data type,
221:12 - like the CMI byte, input, the object would
then have, let's just say collection, let's
221:13 - just say add, I mean, in reality, it looks
a bit different. But just so that you get
221:14 - an abstract idea, you would have added this
thing here. And later on, when you wanted
221:15 - to retrieve it again, you could then say,
wide dot, get the byte value. And then again,
221:16 - there were people saying all this is just
too much work. And so I think also, with Java
221:17 - five, there was an auto conversion introduced,
that now Java can work with a primitive and
221:18 - an object, and will automatically behind the
covers convert a primitive to an object and
221:19 - an object to a primitive, whatever is needed
by a certain function. Now, this is heavily
221:20 - in used by almost every developer, I really
don't like it, and I really activate in my
221:21 - ID, that I get displayed these conversions.
Because for one, this could even be an issue
221:22 - with performance, because I see functions
that would like convert from a primitive to
221:23 - an object, and to a primitive and so on back
and forth several times, which is just stupid.
221:24 - Second, for a primitive, you have the default
value of a zero, that is safe, that will never
221:25 - throw a null pointer exception. Ever for an
object. When it's not initialized, like here,
221:26 - the value will be now and then when you on
an object call, b dot byte value, this will
221:27 - actually throw a null pointer exception. The
problem is you don't see it, because it'll
221:28 - be automatically be inserted by the compiler
for you. You only see it at runtime and then
221:29 - you get a nullpointerexception. So really
be careful with these automatic conversions.
221:30 - I personally hardly ever use them.
221:31 - Okay, but so, so that you know of each of
these primitive number types There is also
221:32 - the same type as an object. The names are
pretty much always the same, like there's
221:33 - a short object. For int, it is integer. So
there's an integer. For long it's long. For
221:34 - float is float and double, it's double. And
also Boolean exists as an object. Which by
221:35 - the way, also has static Boolean object values.
So you can even say Boolean be laughter Remove
221:36 - the bite. Because this is also B, Boolean
b equals to true, or equals to false. But
221:37 - now this is an object. I can also show, you
know, the automatic conversion works. Even
221:38 - though this is an object, the aesthetic value
here, can even jump there you see public static,
221:39 - final Boolean false equals to new Boolean
false. So the cool thing when you use this
221:40 - is there's only one object that is always
reused, and you don't always say new Boolean,
221:41 - to save some space. Okay. And now you see,
I can assign this object to the primitive
221:42 - type, because internally, the compiler will
do this for you, you just don't see it. Okay,
221:43 - so that's, I think, all I can tell you about
the different number types and their object
221:44 - variants. Now let's have a look at their ranges.
I said for example, byte In short, they have
221:45 - smaller ranges. But enough of talking, I think
the best is I just show you. So execute the
221:46 - test. And we see, let me scroll this down.
I think this makes it easier. Because then
221:47 - we can see the test and the code in parallel.
Okay, so here, I used the system print long.
221:48 - Remember, don't use it avoided. Just try test,
it doesn't really matter. I just shortly wanted
221:49 - to show you the results. Otherwise, in productive
code prefer logging, because it's more flexible
221:50 - and would probably lead generally speaking
to more performance, okay, but enough. So
221:51 - here you see. So there are signed types and
unsigned types. Signed means you see, there
221:52 - is a minus, so it goes from minus 128 to plus
127. Interesting is, this is not 128. But
221:53 - 127. While he is 128. This actually is for
all the sign types. The reason is, the JVM
221:54 - in your memory of your computer will actually
need this one number to store the information
221:55 - if it's a minus or a plus. And this is why
they had to take one number away. And they
221:56 - just decided that minus has one, one more
number than Plus, I mean, they could have
221:57 - also done it the other way. But this is how
it's done in Java. Okay, so you see, this
221:58 - is only for very small numbers. 120 minus
128, two plus one and 27 short is already
221:59 - much bigger. It can store 32,000 something
plus and minus again, one less here on the
222:00 - right side in again is much bigger. I think
this is like 2 billion or so long, again is
222:01 - much bigger. I don't even know how long this
number is. Um, yeah, usually you should be
222:02 - fine with int can in some rare cases you need
a long Yeah, actually, sometimes I needed
222:03 - a long Okay. And then there's his float floating
point number with the exponent minus and plus
222:04 - and the double see here even is much bigger
324 to 308 minus plus and the car this one
222:05 - is unsigned. So, this is why there is no minus
which is also why the size here is 65,000
222:06 - something is the double size down to the short
because the short has the same space, but
222:07 - it needs to have it in a signed form with
a minus and a plus. So this is why here we
222:08 - can store zero to 665,000
222:09 - Okay, and car as you have seen before, usually
is used not to store numbers, but characters.
222:10 - But if you convert it to an end, you can also
use it to store numbers unsigned from zero
222:11 - to 65,000 something okay. I think this is
actually interesting to see all these ranges.
222:12 - Okay, so these were the ranges let's go to
the next. And so, in order to be able by the
222:13 - way to show you see here I converted this
two intz and also our This is also interesting
222:14 - you see here I used actually the object, the
objects and the These are static values, which
222:15 - gives me the min and max value. This is really
handy. When you need those ranges, you can
222:16 - just use them out of the box and say min value
max value, because I wouldn't know them. Yeah,
222:17 - directly, I can just look them up. And Java
will tell me then, okay, let's close this
222:18 - now. And go to our next test. Because now,
what I want to show you is actually, you can
222:19 - also save your numbers, not only on the base
10, but also on the base to base eight, and
222:20 - base 16. So now it depends. I don't know,
if you had this already in school or university,
222:21 - I'm assuming you had, they should be really
easy for you to understand that, for example,
222:22 - with the base two, you would store you would
display a number would be displayed differently,
222:23 - then with the base 10. If you never heard
of this, then don't don't mind this really
222:24 - is not so important. I think I never needed
to display the number in one of these formats,
222:25 - decimal was always fine to me. I mean, this
is also the way the value will be stored here
222:26 - on the left side is always the same, no matter
which bass you use. So this might just be
222:27 - used, because you are in a certain domain
and a certain business area where you need,
222:28 - for example, the hex. And so you would, for
example, have documentation that speaks of
222:29 - a hex value. And so you could have the same
value as you have them in the documentation
222:30 - here in your code, which would make it easier
possibly to look at the code. However, this
222:31 - has nothing to do with how they're stored.
I mean, they're still stored on your computer
222:32 - in your memory. And your computer can always
only store them as zeros and ones. So internally,
222:33 - no matter what format, you use them internally,
they're saved always in the same format. And
222:34 - by default, they're also when I print them
out, which I'll show you in a sec, they will
222:35 - also always be printed out on the base of
10 just like a regular number like you know
222:36 - them. So this is only a displaying issue in
the code. If you want to display them in the
222:37 - binary format, you need specific formatting
options. This will be an episode on its own.
222:38 - So I will not go in detail on this. Now. Also,
I think this is not needed in many cases.
222:39 - What is also interesting, by the way, I mean,
the space two was introduced with Java seven
222:40 - only. So this only recently got added. Speaking
as of 2015, before, you had only the option
222:41 - to store, base 10, base eight and base 16.
Now the Edit base two besides to make this
222:42 - stuff more readable. I mean, especially with
base two, you will get these long strings
222:43 - here of zeros and ones. So that you could
easily read this. And also for something like
222:44 - credit card numbers, you can add these underscores
actually as many as ever you want.
222:45 - You're just not allowed to do it at the beginning
of the string and at the end of the string.
222:46 - But I mean, I don't see how this would make
any sense, because this wouldn't help to read
222:47 - it. So this is why you put them here in between,
you can also add more like here. Now the question
222:48 - is, is that more readable? In this case? Of
course not. But I think it can be quite helpful,
222:49 - especially for something like credit card
numbers for long numbers that you can read
222:50 - them more easily, like on the phone talking
to a colleague, and you want to read out the
222:51 - number nine you can talk about the blogs makes
it easier. But these underscores again, this
222:52 - is just the displaying issue in the code.
The way they are stored is exactly the same
222:53 - like before. So now let's execute the test.
So I mean, so that this gets printed out,
222:54 - and we can have a look at it. Okay, so here
you see the first one ob this just indicates
222:55 - I'm storing the number in binary. The number
is given in a binary format. So this is just
222:56 - the zero. You can use the capital and a lowercase
it's supposed to same. So this one is an apple
222:57 - On this long thing here, so ob four is binary
format, and undo redo Do you do all this,
222:58 - you can use your calculator and calculate
it. And in the end, you will see this is this
222:59 - number in decimal format.
223:00 - Or K.
223:01 - By the way, of course, just shortly, binary
format means you can't, for example, use a
223:02 - three, this will give you an error, integer
number two large, because now we are in binary
223:03 - format, indicated by the B and zero here with
the base eight, and scroll down. It, it started
223:04 - with a zero only. So zero and seven means
this is a seven now, but 010 is actually the
223:05 - eight in the on the base of eight. As I said,
if you know it from like school or university,
223:06 - you will understand what I'm talking about.
If not, doesn't matter. Not important. Yeah,
223:07 - you will hardly ever need it. Let's have a
look at it. So as I said, this is the seven,
223:08 - this is the eight. And this is some large
number. So these underscores are not displayed
223:09 - in here. This is just to help so that it's
more readable in the code. And the base 16
223:10 - hex code is started with zero and x. And then
the zero is 01. The F, you know in Latin,
223:11 - no, I think our numbers are not Latin, their
Arabic numbers. And these Arabic numbers,
223:12 - they are based on the base 10. So nine is
the last number. And when you want to say
223:13 - 10 you need one zero, while on the hex, you
don't have any more Arabic numbers. So therefore
223:14 - they used ABCDE, F for 10 to 16. So the F
is actually the 16. Let's execute this. Well,
223:15 - I was lying to you. It's the 15 in this case,
because we start with the zero. No, yeah,
223:16 - it's the 15. Because the 16 again, would be
one zero. Okay, yeah. can get really easy,
223:17 - confusing. Sorry. So anyway,
223:18 - I mean,
223:19 - I think it's not so important. It's just interesting
to show off. I mean, like in a job interview,
223:20 - I think you really should know, Java inside
out. And so I think you should know that this
223:21 - is possible. The question if you personally
will use it, because you personally in your
223:22 - project will need it. I don't know, depends,
maybe you need it. But if you need it, it's
223:23 - here to be used. Okay. So now, I think really
did an in depth view on all these small topics.
223:24 - And I think this is really now a good base
to talk about hashCode and equals. Going to
223:25 - talk about the two methods equals, and hashCode.
This tutorial actually concludes my presentation
223:26 - of all the methods of the Java Lang object
class, equals and hashCode both follow a contract
223:27 - that ties them closely together, which is
also why I'm talking about both methods in
223:28 - just one episode. Knowing all the details
about these two methods, will make you a better
223:29 - programmer today. So get yourself some popcorn,
and listen carefully. So let's start with
223:30 - the equals method. What does it do? What's
it actually useful for? the equals method
223:31 - is used to compare two objects for equality,
similar to the equals operator, which is used
223:32 - for primitive values. But before I'm going
into much more detail, let's first jump into
223:33 - my ID and see this in action. Now in my ID,
let's first of all, see, what do we need the
223:34 - equals method for anyway, because so far,
we happily used the equal equal operator,
223:35 - and this was working. Let's see this again,
with two primitive values, I equals four,
223:36 - and J equals four. So now I assert, with the
equals operator that they're both equal. And
223:37 - we get the green bar. Old tests passed, everything
is fine. So i equals to J. Now let's do the
223:38 - same thing with strings. Here we have a constant
value of Hello, and another constant value
223:39 - Hello. And each has assigned to its own string,
reference variable. Now, we all Want to compare
223:40 - these two strings with the equal operator?
Let's try this. And Ted Ah, this is also working.
223:41 - And I told you a string is an object. So as
this is working, it seems we don't need the
223:42 - equals method at all. Well, with a string,
it's a bit tricky, actually. Because with
223:43 - a string, there is some optimization going
on in the background for constant values,
223:44 - because for this constant value, there's actually
only one and both variables, they both point
223:45 - to the same object in memory. The variable
is stored in a memory area called stack, the
223:46 - object is stored in a memory area called heap.
And there's only one, but things get quite
223:47 - differently. As soon as I add a new string
variable, and always say, string hello, three
223:48 - is only age. And then I say at runtime, hello,
three equals two, hello, three, plus, concatenate
223:49 - ello to it, which will be Hello, at runtime.
And just to be sure, let's also print this
223:50 - that we can see there is really Hello. In
the variable, hello, three. And then let's
223:51 - assert, hello, one, equal operator Hello,
three. And this is not working, we get the
223:52 - red bar, nasty, nasty. So now they're not
equal. But here you can see it printed out
223:53 - Hello. So from our expectation it should have
been equal. So this is something really tricky
223:54 - with string.
223:55 - And ensured you should not use equal operator
on objects, also not on strings. Instead,
223:56 - for strings, there is the equals method. Let's
try this. Hello, one equals Hello, three.
223:57 - This works, it seems like using that method,
they're both equal. Now, let's have a look
223:58 - actually at the method. Here we are clustering.
And there is a method equals operating on
223:59 - an object. It says things like if this equals
to the object given return true. So if it's
224:00 - the same reference, if it's the same object,
this is actually a performance optimization.
224:01 - Now it checks that the object is actually
a string. This is achieved by the instance
224:02 - of operator so that we can safely cast the
object to a string. And so that we can compare
224:03 - both strings. Interesting thing about instance,
of By the way, which not many people, many
224:04 - developers know, or at least not all, yet.
This also includes a check for now, if an
224:05 - object is now this will never be a string
will never be true and will return false.
224:06 - So anyway, without going into further details,
there's this while loop. And this compares
224:07 - character by character of both strings. And
only if they're completely equal, it will
224:08 - return true. So this is how equals was implemented
in the class string. But actually, I told
224:09 - you, the equals method is a method from the
class object. And yes, it is. Well, it turns
224:10 - out string is also a subclass of object and
the string class overrode the equals method
224:11 - here. So then it works on strings as expected.
Okay. So it seems like for strings we can
224:12 - happily use equals, so that we know that a
string like hello one and hello three is equal.
224:13 - Now, how are things with classes that we implement
ourselves? Like here I have created a class
224:14 - car with owner Marcos. It is a Porsche and
it is it has the color silver So it seems
224:15 - like it has both instances have exactly the
same attributes. So I would expect them to
224:16 - be the same car. Now let's first of all, try
it with the equal operator, like before. And
224:17 - this is false. It's not working test failed.
Well, of course, because we have two different
224:18 - instances here. Let's try the positive case.
portion one, equal operator, my Porsche one
224:19 - again, comparing it to itself. So yes, this
is working, of course. But it seems like for
224:20 - to be able to compare Porsche one and Porsche
to we again need to use the equals method.
224:21 - Let's do this now. For sheet one. Oh, let's
first of all, I want to push it to here. But
224:22 - let's also do this, my portion one equals
my portion one,
224:23 - I would expect that to be true. And yes, it
is true. My Porsche one, so it is equal to
224:24 - itself. Now, let's compare my Porsche one
to my Porsche e two. And let's see if this
224:25 - works. Huh,
224:26 - it's not working. We have the nasty red bar.
This was so nicely working with a string,
224:27 - why is it not working with our car? Let's
jump to this method again. And you see, we're
224:28 - in the class object. Because in our car class,
we have not overwritten the equals method.
224:29 - So what happens is, the original method of
the class object is used. And as you can see
224:30 - here, internally, what happens is, we compare
this which is the object itself, in this case,
224:31 - my pushy one, we compare it using the equal
operator to the object that is coming into
224:32 - the method, which was pushy to. And this compares
only the reference variables and not the objects.
224:33 - So this is false, because we have two different
reference variables.
224:34 - What by the way, is also possible. To make
this true again, we could assign my portion
224:35 - to the reference variable of my portion one,
which would mean this object is somewhere
224:36 - in memory, no variable is assigned to it.
And there is this one object
224:37 - here in this line, and both variables, point
to it. Let's try this. And see if this works.
224:38 - Because now actually, we only compare the
same object with each other. Like here. This
224:39 - compares the reference variables, which now
have the same value. So this would be working.
224:40 - But this is not what we want. So let's remove
that we really want to compare both objects.
224:41 - We want to compare this one with that one.
Okay, so let's have a look at the class car.
224:42 - This is a small class I wrote. And it just
has a constructor and these attributes for
224:43 - now. And there is no equals method overwritten.
So this is what we have to do. Public Boolean
224:44 - equals now, I want to compare a car car. No,
this you cannot do in the class object. There
224:45 - is object. So we have to say object here.
And then later on, we have to cast it to a
224:46 - car, like we saw on the class string.
224:47 - And then it's always good to add the override
annotation so that we make sure we have properly
224:48 - overwritten the method. Now, I mean, this
is not a true implementation. I always return
224:49 - false, just to see that when I'm in my car
test, not jump there. See, it jumps to me.
224:50 - I overridden method. Now, of course, when
this always returns false, this will also
224:51 - not work. So we will have to implement it.
But actually implementing such an equals method
224:52 - is not so easy. And we need some more theory
for this before we can continue. So let's
224:53 - first of all, jump back to my slides. Before
we are able to implement the equals method,
224:54 - we need to come up with a proper design first.
Actually, many developers just skip the design
224:55 - phase, and simply click on autogenerate. But
this may lead to severe bugs, or at least
224:56 - two sub optimal performance. Let me show you
how you can properly do it. First of all,
224:57 - you have to define what it is in your specific
program that makes two car instances equal
224:58 - or unequal. In your program, are two cars
equal when they have the same manufacturer,
224:59 - maybe when they have the same manufacturer
in color, or the same engine, the same number
225:00 - of wheels, the same top speed, the same vehicle
identification number, or when In short, based
225:01 - on a knowledge of the business you are working
in, you have to decide which fields are identifying,
225:02 - and which fields are redundant, and not helpful
for the equal comparison. Besides for improved
225:03 - performance, you need to define in which order
you want to compare the attributes. Are there
225:04 - any fields that have a high chance to be unequal?
Are there fields that may be compared faster
225:05 - than others? To implement a meaningful equals
method, you must first analyze all these aspects
225:06 - in great detail. Let's go through this process.
With my example. I would assume that the car's
225:07 - top speed relates to the type of engine and
some form. So that seems to be a redundant
225:08 - field, that will not be helpful for the equals
implementation. So let's just remove it. Let's
225:09 - just say the number of wheels is always for
in our specific example. So number of wheels
225:10 - would also not help us to differentiate the
car. What about the VIN?
225:11 - Well,
225:12 - this again depends on the type of program
you want to create. For a public authority
225:13 - like the police, this one is probably the
only proper way of identification. But what
225:14 - about a program used by the manufacturer itself.
While the car is still being built, and not
225:15 - sold yet, I would assume the witness of less
importance. But I personally wouldn't know
225:16 - that in detail. This is what you will have
to clarify with the business people of your
225:17 - company or your department. Based on their
knowledge, you have to select which attributes
225:18 - to compare in which order. In my artificial
example here, I'm the developer as well as
225:19 - the business analyst. So for my example, I
just arbitrarily define that two cars with
225:20 - different wind numbers can be seen as equal.
Therefore, I will not include this field in
225:21 - my equals comparison later on. Now, before
you think that's it, I'm sorry, there's actually
225:22 - some more theory to cover. In the introduction,
I already told you that there is a contract
225:23 - of equals and hashCode we have to fulfill.
First of all, there are five conditions, our
225:24 - equals implementation has to comply with,
believe me, it looks much more scary than
225:25 - it actually is. Let's go through each of them
slowly. reflexivity. An object must be equal
225:26 - to itself, so that when I call my old car
equals my old car, it returns true. I think
225:27 - this makes sense and should be easy to understand.
symmetry to objects must agree whether or
225:28 - not they are equal. If my old car equals some
other car, then some other car equals my old
225:29 - car must also return true This sounds obvious
and very simple, when in fact, it is not such
225:30 - a simple condition when it comes to inheritance.
If you have a car class and a BMW class, which
225:31 - is extending the car class, it could happen
that your BMW is equal to a car. But the same
225:32 - car is not equal to the BMW is every BMW is
a car. But not every car is a BMW. So you
225:33 - see, the symmetry rule can actually lead to
some nasty problems. There are quite a few
225:34 - interesting articles online discussing potential
symmetry issues of the equals method. cover
225:35 - each contract condition with a dedicated unit
test to make sure your class is fully compliant
225:36 - with a contract. Our next condition is transitivity.
If one object is equal to our second, and
225:37 - a second is equal to a third, then the first
must be equal to the third again. This rule
225:38 - sounds much more complicated than it actually
is. If object A is equal to object B, and
225:39 - object b is equal to object C, they should
all be equal to each other so that C is also
225:40 - equal to a consistency. If two objects are
equal, they must remain equal for all time,
225:41 - unless one of them is changed. So when you
repeatedly compare the same two objects with
225:42 - a equals method, it should always return the
same result. In other words, calling the equals
225:43 - method should not alter the object in any
way. The last rule model returns false is
225:44 - what Josh Bloch calls nonlocality. When knowledge
is given as a parameter to any equals method,
225:45 - they should always return false and never
throw a null pointer exception. So now, you
225:46 - know quite a bit about the equals method.
But what is the hashCode method actually useful
225:47 - for? For processing similar objects are usually
put into a collection. Such a collection in
225:48 - Java is like a more powerful array, or an
array on steroids, as I often call it.
225:49 - Besides other things, it allows you to look
up objects not only based on their index position,
225:50 - but also based on their specific values. This
is where the equals method comes into play.
225:51 - To speed up this lookup process, the Java
creators added specific hash based containers
225:52 - that will use the hash value as a grouping
mechanism to reduce the number of equal comparisons
225:53 - needed. In the optimal case, each object that
is considered unequal by the equal method
225:54 - will also return a different hash code. This
hash code is used to group the objects in
225:55 - so called buckets. Now, in this optimal case,
you will be able to find each object simply
225:56 - by a lookup based on its hash value. However,
there may also be something called hash collisions,
225:57 - where two unequal objects will share the same
hash code, in which case they end up in the
225:58 - same bucket. Now, if I'm looking for that
scar, I have to look up the correct bucket
225:59 - based on the hash code minus 391. That car
will return. However, as there is a hash collision,
226:00 - I will on top have to do an equals comparison
on a list of two cars in this case, illegal
226:01 - but inadmissible bad performing hash code
implementation could statically returned 42
226:02 - for all objects. In this case, however, the
whole hashCode logic would not help at all.
226:03 - In the end, you would have to do an equals
comparison on the entire list of cars just
226:04 - as if the hashing logic had never existed.
Okay. Now that I have talked about the general
226:05 - idea of the hashCode method, I have to further
tell you about the contract that the hashCode
226:06 - method has to fulfill. The first condition
that has to be fulfilled by the hashCode method
226:07 - is for any two objects return same hash codes
when equals returns true. To achieve this,
226:08 - use the same idea Define attributes for both
methods in the same order. Don't worry too
226:09 - much. Now, if you don't fully understand what
I mean. As soon as I'm finished introducing
226:10 - you to the hashCode contract, I will jump
back in my ID and show you a practical example.
226:11 - When hashCode is invoked more than once on
the same object, it must consistently return
226:12 - the same int value as long as the object is
not changed. This role is similar to the equals
226:13 - consistency rule, I introduced to before both
equals and hashCode methods must return consistent
226:14 - results. To fulfill this contract, you should
override hashCode whenever you override equals,
226:15 - and vice versa. Also, when you add or remove
attributes from your class, you will most
226:16 - probably also have to adjust your equals and
hashCode methods. Last but not least, aim
226:17 - to return different hash codes when equals
returns false. This is not a hard and fast
226:18 - rule, but it will improve the performance
of your program by minimizing the number of
226:19 - hash collisions. to the extreme, the hash
code contract would allow to statically return
226:20 - 42 for all objects, as Josh block states in
his book Effective Java, however, this could
226:21 - result in quadratic rather than linear execution
time, and therefore, could be the difference
226:22 - between working and not working. Actually,
the hashCode method is a rather complicated
226:23 - beast, I couldn't practically fit in all the
details without risking that you would fall
226:24 - asleep. Therefore, I have done a follow up
tutorial, that will give you an in depth view
226:25 - on the hashCode method, which you will need
to understand to become an expert in Java
226:26 - programming. Below this video, there's a link,
you can click to watch my follow up tutorial
226:27 - for the hashCode method. For now, that's all
the theory, you need to be able to implement
226:28 - your own hashCode and equals methods. to round
up this topic, let's jump back into my ID
226:29 - to show you some practical examples of hashCode
and equals methods. So back to my ID II, you
226:30 - can see I've implemented both equals, and
hashCode based on the fields manufacturer,
226:31 - engine, and color, also here and hashCode,
manufacturer, engine, and color. So I've implemented
226:32 - them based on the decisions I made during
the simulated design phase that I did during
226:33 - the theory session. So the car clause has
fields like Vehicle Identification Number,
226:34 - Manufacturer, engine, color, and number of
wheels. But in the design phase, I decided
226:35 - that number of wheels and Vehicle Identification
Number are not helpful for the way I want
226:36 - to compare a car. Of course, this is totally
arbitrary. So this is not how you would do
226:37 - it. I really can't stress that enough. In
your case, in reality, you have to talk to
226:38 - the business people and find out what is important
and what is not. Also totally arbitrary is
226:39 - the order that I've chosen. I just thought
about it. And I thought that while there are
226:40 - millions, or however many colors that for
usually for cars, there are not so many colors.
226:41 - I think most cars are either black or white,
silver, blue, red. A few might even be green,
226:42 - or yellow. But that's probably it. So I thought
they there are probably more different manufacturers,
226:43 - and also more different engines. And I want
the equals method. If I compare two objects
226:44 - which are not equal, I want to leave the method
as early as possible, because the earlier
226:45 - I leave the method, the faster the entire
code will run. If two instances are equal,
226:46 - then usually it has to go till the very end.
So in this case, it doesn't make a difference.
226:47 - But it does make a difference if it's not
equal. If we can leave the method here. So
226:48 - for perform performance optimization I have
chosen this order
226:49 - on.
226:50 - So this is what I would also ask you to do,
think about a good order to improve the performance.
226:51 - And if the performance is important, then
you should test it, because you never know
226:52 - for sure until you test for the performance.
What is important that the order is the same
226:53 - hashCode and equals. And now, we should also
talk about all this stuff here on top. This
226:54 - mostly is also a performance optimization,
at least here, this equals object. So, if
226:55 - I compare the object to itself, I want to
directly return true, because then the reference
226:56 - variable references the same object in memory.
And so I directly know it's the same object,
226:57 - I don't have to compare all these things.
So, this is why I have this here. If you have
226:58 - a specific case, where you know that you will
never ever compare an object to itself, you
226:59 - might even leave this if a way. Yeah, this
is the this depends. Generally, this is done,
227:00 - because such a check doesn't also cost a lot,
then this object equals null return false
227:01 - is actually very important here. This is the
last rule that we have to fulfill that when
227:02 - an object that we compare is now that we always
return false, which is also important because
227:03 - otherwise object dot get class would throw
a null pointer exception that this cannot
227:04 - happen, because now we are already, we have
already left the equals method with false.
227:05 - Okay. And then the third, if check compares
both classes. So that we make sure that the
227:06 - object that is coming in to all equals method
is also a car. So that we're not comparing
227:07 - bikes and cars, for example, or cars and apples
or whatever, right? Because otherwise, also,
227:08 - this explicit cast to car would also throw
a class cast exception. But now that we have
227:09 - made sure that they both have the car class,
we can safely caused the object to a car.
227:10 - And now I think this is quite interesting.
Because now I can easily say manufacturer
227:11 - equals other dot manufacturer. This field
here is private. But because we are here in
227:12 - car, even though that this is another instance,
but it's also an instance of car, I can directly
227:13 - access this private field. So I don't have
to use any method, I can directly access the
227:14 - field. This works and makes the code I think,
much more readable and shorter. So if it's
227:15 - not equal, then I can directly leave the method
and say return false. I do this with all the
227:16 - fields. And if I'm here, that I'm sure that
all the three fields are equal. So I do not
227:17 - compare number of wheels as well as we equal
identification number, because as I said,
227:18 - about them, I don't care because number of
wheels, in my specific example would always
227:19 - be four. So would be the same anyway. And
we equal identification number, that might
227:20 - be two different cars. But just like, if I'm
only interested in the price of a car, for
227:21 - example, or the look, then I wouldn't care
that actually, they are physically two different
227:22 - cars. I would just say well, this is a BMW
with I don't know, that kind of engine and
227:23 - Lou. So for me, this is the same car. Period.
Yeah. Okay, so that much for the equals method.
227:24 - Now the hashCode method. This is actually
very complicated, I'm sorry, and it's so complicated
227:25 - that I've decided to do a follow up tutorial,
as said before, which I really recommend you
227:26 - to watch. There is a link below this video,
you can click to watch the follow up. So he
227:27 - only in short about the hashCode method. The
31 year is a prime number and a prime number
227:28 - he is multiplied with always the result. So
this continues to take the hash code of a
227:29 - field, which will return some in number
227:30 - will edit, starting with one, and then multiply
it with 31. And this for each attribute. The
227:31 - reason is this is an optimization to have
less collisions, because I told you about
227:32 - the collisions, that this can decrease the
performance. As you see, I'm actually not
227:33 - really doing something here, I'm just calling
recursively hashCode for each class. And this
227:34 - is why now we should jump in the other classes,
at least, I can show you all the classes,
227:35 - but I've chosen engine here in this case,
to see how it's actually hashCode implemented
227:36 - in one example. So let's jump to engine. Okay,
so the equals method is pretty much the same,
227:37 - or at least similar. Then in car, the only
difference is here, I added something that
227:38 - I called optional field, because I defined
that this optional field could also be now.
227:39 - So therefore, my check here for equals has
to be a bit more complicated. Because I have
227:40 - to save it's now then I check if the other
field is also now, if it's not now, then this
227:41 - field is now the other is not so it's not
equal. And if it's not now, then I can compare
227:42 - both fields. So I'm doing all this again to
prevent another pointer exception. In the
227:43 - other case, when I don't check for now, my
assumption is that, well, this is a primitive
227:44 - field, so it can't be null anyway, but for
car, my assumption was that a car always needs
227:45 - a manufacturer, engine and a color. So my
assumption is, those fields will never be
227:46 - now, if someone would introduce a bug. And
would forget to set these fields then, of
227:47 - course, this could produce a nullpointerexception.
But checking for something that is exceptional.
227:48 - This is what I call rocket code. Because it's
like extra safe code, this is just cluttering
227:49 - your code, you have to have certain assumptions,
like saying mighty sign for bits that these
227:50 - fields, these fields can never be now. And
so I trust on that. Otherwise, well, the program
227:51 - will crash, okay, we have to fix it. But then
the problem is already fixed. And the code
227:52 - stays clean. And this is important, because
your code should be really readable and maintainable.
227:53 - Okay, so only four fields where you know,
they can be null at these extra null checks.
227:54 - Okay. So that much for the equals method,
everything else here should be the same as
227:55 - in car. Now for the hashCode method. Here,
you see there is some more stuff going on.
227:56 - Because here, I cannot forward to a hash code
method. But instead, I have here a primitive
227:57 - long. And for that, because the primitive
fields there, you actually have to calculate
227:58 - some hash code. And this is a long, and so
we want to like convert a long to an int.
227:59 - A long has that has like 64 bits, while an
int has only 32 bits. So you want to like
228:00 - make the long to half its size, and you want
to make it in a way that will result in the
228:01 - least possible number of collisions. And therefore,
this weird line here. This here does it. This
228:02 - is actually based on again, Josh blocks book
Effective Java there, he explains it. One,
228:03 - actually, he doesn't explain it too much.
If you want an in depth explanation again,
228:04 - watch my follow up tutorial about hash code
there, I can explain you. Now here only insured.
228:05 - This is a shift by 32 bits. And then this
is an X or Y you again, come like let's say
228:06 - combine this field. And last but not least,
you do an exquisite cast from long to end
228:07 - where you throw away Half of the long, but
this whole thing can't explain you in like
228:08 - one minute, you have to watch really the extended
tutorial. But this is really a very performant
228:09 - good way to create an end hash code from alarm.
This is the standard default way of how this
228:10 - is done today.
228:11 - And the second field here is a string as it
can be now, I need this extra knowledge check.
228:12 - And I'm not sure if I have shown you this
before. This is like in if it's just shorter,
228:13 - because otherwise the code would even be longer.
So you have to read it as is optional field
228:14 - now. If true, then return zero, else return
optional field dot hashCode. So this again
228:15 - calls the hashCode method of string. This
I showed you in the beginning of this episode,
228:16 - where the code was like in a while loop, going
over each character of the string, and then
228:17 - calculating an int value for the string. So
as this is already done for us, we can simply
228:18 - call the hashCode method. Okay. So, again,
you also see, I have, in this case, two fields.
228:19 - And in this case, I decided to use both to
differentiate if an engine is equal or not.
228:20 - And so as I use type an optional field and
equals, again, I use type an optional field
228:21 - and hashCode in the same order and same fields.
Okay, last but not least, some class now this
228:22 - is this doesn't mean anything, this is really
totally abstract, I just wanted to it very
228:23 - short, show you all the different primitive
types they are plus the string object. So
228:24 - that you see like how the different cases
of equals and hashCode could be calculated.
228:25 - So let's first of all look at hash code. So
this with long we have already seen, same
228:26 - one here, float, well float has the same size
32 bits like an end. And then there is a native
228:27 - function, which will convert the float to
an int to be used for the hashCode. Double
228:28 - A has the same length as a long. So this is
done in two steps. First of all, it's converted,
228:29 - again, with a native function too long. A
native function is a function that is not
228:30 - implemented in Java, but in machine dependent
code. So I can't show you. But again, for
228:31 - details, watch my follow up tutorial. But
anyway, so long we take and again, we do this
228:32 - weird line here to convert it to an end. Next
one Boolean. Here again, this weird stuff
228:33 - here. If it's true, question mark, then 1231.
And if it's not true, then take this number.
228:34 - All this stuff is really technical might be
a bit hard for you to understand. This is
228:35 - just really important for performance optimization
to have the least number of collisions. Um,
228:36 - car is just taken as it is because it can
be handled like a number. For string again,
228:37 - we call this hashCode method. And for the
other fields, everything that is as big as
228:38 - an end or smaller than an end, that's relatively
easy because you can just take the value as
228:39 - it is because a byte will always fit into
an end short will always fit into an end.
228:40 - And an end of course, should also fit into
an end our K so I know this was really rough
228:41 - really short. I'm just not enough time to
go in more details. But exactly For this reason,
228:42 - I have done the follow up tutorial you can
watch. I hope then it will be more easy to
228:43 - understand. Now last but not least, let's
have a look also at equals. So I think for
228:44 - the primitive values here, it's pretty easy
because you don't have to use equals If you
228:45 - can just use the not equal operator.
228:46 - So if it's if the bytes are not equal, just
looking at the variables without any objects
228:47 - involved, false is returned. And also see
this is the order I've chosen, I start with
228:48 - the smallest possible values, because here
checking them is probably faster than doing
228:49 - all this crazy stuff down here. And this is
why I've chosen the order. All K, with a short
228:50 - end, long, this is all easy. With float, it's
a bit more difficult, we have to convert it
228:51 - first to an end, that will has to be converted
to a long, um, Boolean is, again, easy. Well,
228:52 - actually, if this was a real whoops, if this
was a real implementation, I would have done
228:53 - it differently, I would have put it to the
top. So this order is also based to explain
228:54 - you the different types. So in reality, I
would ask you to really think about the order
228:55 - based on what the business tells you what
is easy to differentiate. And like, then also
228:56 - you have to think, like, from the performance,
what takes longer to calculate. Um, of course,
228:57 - it depends if you really need the performance.
And if you do, then always test performance,
228:58 - because you might think something is fast.
But when you tested, it turns out, it's not
228:59 - as fast as he would have thought, okay, because
what I'm telling you here is just a rule of
229:00 - thumb, but I might be totally wrong in a specific
case. So this is also what I'm doing, if I
229:01 - need a certain performance, I test for it.
In all other cases, I just do how I feel like
229:02 - it. Or I just use my gut feeling to sort the
values, as I think could be fitting out. Okay,
229:03 - so I hope you liked this episode about hashCode.
And equals I'm sorry that this is all so complicated
229:04 - and so long. I just wanted to put in everything
possible, because this is really such an important
229:05 - topic that he should really understand in
detail. Of course, there is way more actually.
229:06 - So I would also ask you go to my blog, www
dot Marquess minor spiel.com. I will put up
229:07 - some links to some extended articles on the
topic on and also you might consider buying
229:08 - Effective Java from Drush blog, he also talks
about it quite extensively. So
229:09 - here
229:10 - I will give you a high level introduction
to the Java collections framework. Unfortunately,
229:11 - there are several overloaded uses of the word
collection. Let me clarify the various meanings
229:12 - up front. The different use cases are a collection
without any it relevance as a compilation
229:13 - or group of things. Second, the Java collections
framework, a library of different interfaces
229:14 - and classes. Third, a collection as a data
structure. Think of a box or container that
229:15 - can hold a group of objects, like an array,
for example. For us, the Java collections
229:16 - interface, one of the two main interfaces
of the Java collections framework, and fifths,
229:17 - Java util collections, or utility class that
will help you to modify or operate on Java
229:18 - collections. This episode is based on chapter
11 of the OCA OCP study guide. The book is
229:19 - packed with knowledge. As a great fan of the
author is Kathy Sierra and Bert Bates. I recommend
229:20 - you to read this book, even when you don't
plan to get a certified programmer. So what
229:21 - is the Java collections framework? from a
high level perspective? First of all, it's
229:22 - more like a library a toolbox of generic interfaces
and classes. This toolbox contains Various
229:23 - collection interfaces and classes that serve
as a more powerful object oriented alternative
229:24 - to arrays, collection related utility interfaces
and classes that assist you in using the collections.
229:25 - I'm going to describe both parts in detail
now. On the next slides, you will see the
229:26 - interface and class hierarchy for collections.
Unlike arrays, all collections can dynamically
229:27 - grow or shrink in size. Except before a collection
can hold a group of objects, a map can store
229:28 - pairs of objects that have some kind of relation,
which ties them together, named key and value.
229:29 - A value
229:30 - does not have a specific position in this
map, but can be retrieved with the key it
229:31 - is related to relax if you don't get it now.
We will look at it in more detail later on.
229:32 - So here you see the hierarchy of classes and
interfaces, extending or implementing the
229:33 - collections interface. Just try to remember
some of the names listed here. This is just
229:34 - an overview so far. As you can see, the collection
interface sits on top of a number of sub interfaces
229:35 - and implementing classes. A collection can
hold a group of objects, the collection interface
229:36 - is extended by the interface of set list and
queue. A set is defined as a group of unique
229:37 - objects. What is considered as unique is defined
by the equals method of the object type the
229:38 - set holds. So in other words, a set cannot
hold to equal objects. A list is defined as
229:39 - a sequence of objects. So unlike a set, a
list can contain duplicate entries. Besides
229:40 - a list keeps its elements in the order, they
were inserted into the list. A queue has two
229:41 - sides, entries are added to the end and removed
from the top of the queue. This is often described
229:42 - as first in first out, which is pretty much
like a waiting line in real life works. The
229:43 - first person queueing up will also be the
first person leaving the queue. Now let's
229:44 - have a closer look at the interfaces and classes
that extend or implement the set interface.
229:45 - Hash set linked hash set and three set are
all implementing the set interface. Hash set
229:46 - is the default implementation that is used
in the majority of cases. Linked hash set
229:47 - is like a mix of a hash set and the list as
it does not allow duplicate entries like a
229:48 - set. But it returns its elements in the order
in which they were inserted. Like your list
229:49 - would do. Chrisette will constantly keep all
its elements in sorted order. But keep in
229:50 - mind, there is no free lunch. So every edit
feature comes at a certain Cost Of course.
229:51 - After looking at the classes implementing
the set interface, let's also have a look
229:52 - at the two extending interfaces we haven't
talked about yet. As the name implies, sorted
229:53 - set is a set that is constantly sorted. The
navigate will set interface was added which
229:54 - Java six, it allows to navigate through the
sorted list. For example, it provides methods
229:55 - to retrieve the next element greater or smaller
than a given element of the set. Next, let's
229:56 - have a closer look at the classes that implement
the list interface. Every list is the default
229:57 - implementation of the list interface. Like
any list implementation, it does allow duplicate
229:58 - elements and it does allow to iterate the
list in the order of insertion. As it is based
229:59 - on arrays, it is very fast to iterate and
read from an every list. But adding or removing
230:00 - an element at a random position is very slow,
as this will require to rebuild the underlying
230:01 - array structure. vector is a class that exists
since JDK one which is even before the collection
230:02 - framework, which was added with Java two.
In short, its performance is sub optimal.
230:03 - So So please never use it. Use ArrayList or
linked list instead. So let's directly remove
230:04 - it and forget about it. The next list implementation
is linked list. As the name implies, its implementation
230:05 - is based on a linked list, which makes it
easy to add or remove elements at any position
230:06 - in the list. Last but not least, let's have
a look at the classes implementing the queue
230:07 - interface. We already talked about link list,
as it also implements the list interface.
230:08 - However, the fact that it's based on a double
linked list makes it quite easy to
230:09 - also implement the queue interface. linked
list is the default queue implementation.
230:10 - priority queue is a queue implementation that
keeps its elements automatically ordered.
230:11 - It has similar functionality like a tree set,
but it does allow duplicate entries. Now let's
230:12 - look at the map interface. This interface
has no relation to the collection interface.
230:13 - A collection operates on one entity, while
a map operates on two entities. A unique key,
230:14 - for example, a vehicle identification number,
and an object that is related to this key
230:15 - for example, a car object with the help of
the key you can retrieve the object it relates
230:16 - to. The interface map is the root of a lot
of interfaces and classes, which we'll look
230:17 - at now. The class hash table was the first
collection in Java JDK one that was based
230:18 - on a data structure hash table. So the Java
creators called a hash table. Unfortunately,
230:19 - this makes it a bit hard to differentiate
between the two. Like vector the class is
230:20 - deprecated, because of its sub optimal performance,
so let's also remove it and forget about it.
230:21 - Instead, use one of the other classes that
implement the map interface. hashmap is the
230:22 - default implementation that you should use
in the majority of cases. A map usually does
230:23 - not make any guarantees on how it internally
stores its elements. An exception to this
230:24 - rule is linked hash map, which allows to iterate
the map in the order of insertion. Last but
230:25 - not least, tree map is a constantly sorted
map. Now let's look at the interfaces that
230:26 - extend the map interface. As the name implies,
the interface sorted map extends the map interface
230:27 - and defines the contract of a constantly sorted
map. navigable map again extends the sorted
230:28 - map interface, and adds methods to navigate
through the map. This allows you to retrieve
230:29 - all entries smaller or bigger than a given
entry, for example. Actually, there are many
230:30 - similarities between the map and the set hierarchy.
The reason is that the set implementations
230:31 - are actually internally backed by a map implementation.
Last but not least, you might have noticed
230:32 - the Java collection classes often contain
the data structure there are based on in their
230:33 - name. To choose the best collection for a
given situation, you have to compare the specific
230:34 - characteristics of data structures like array,
linked list, hash table or tree first. In
230:35 - short, there is no single best option. Each
one has its very own advantages and disadvantages.
230:36 - I promise to talk about this very exciting
topic in a later episode. So stay tuned. This
230:37 - overview of the collection and map classes
that only show you a part of the whole story.
230:38 - In a later episode, I will introduce you to
the concurrent containers of the Java collections
230:39 - framework. generics is a topic at least as
big as the Java collections framework. In
230:40 - the context of this episode, I will therefore
only explain you the bare minimum you need
230:41 - to understand the collections framework. It's
okay if you have a lot of open questions after
230:42 - my brief overview. Give both of us some time.
I promise to explain everything one after
230:43 - the other I would recommend you to subscribe
to my YouTube channel to be informed as soon
230:44 - as I upload the next episodes of the Java
collections framework. Now fasten your seat
230:45 - belts. Here, it's going to be a bumpy ride,
I promise. You see this weird stuff in angular
230:46 - brackets. Just relax. Actually, it's much
easier than you might think. And the first
230:47 - line, you see I have defined a list variable
my list. And with a string parameter in ANGEL
230:48 - brackets, I tell the compiler that my main
list reference variable is supposed to be
230:49 - used only with strings.
230:50 - Then I create an object of type ArrayList.
And again, I tell the compiler that this object
230:51 - is only supposed to be used with strings,
and the compiler will ensure that no one ever
230:52 - tries to put anything else than a string into
my list. In other words, this is what makes
230:53 - the container type safe. Also, note that I
use the interface list for the variable and
230:54 - not ArrayList. This makes your code more flexible.
Only at one place you create the object, but
230:55 - at various places in your code, he will use
it. When you use list instead of error list
230:56 - for the reference variable. You could later
replace the error list by a linked list, for
230:57 - example. And all
230:58 - you had to adjust was this one line of code.
In case you don't really need to specific
230:59 - methods of a list,
231:00 - you could also use the collection interface
instead. Always use the least specific interface
231:01 - for the reference variable. Oh, by the way,
I'm sure you notice the integer 100 that I
231:02 - use as a constructor argument. This I have
added for performance optimization. As said
231:03 - before, the collection classes can dynamically
grow and shrink in size. However, aerialist
231:04 - and all hash table based collections are internally
operating on arrays. When an array based collection
231:05 - grows in size, it will internally on the fly,
create a larger array and transfer all contents
231:06 - from the old to the new array. This of course
takes some extra time. What on hardware is
231:07 - so fast, that is usually should not be a problem.
But on the other side, if you already know
231:08 - the exact, or at least the approximate size
of your error based collection, this is usually
231:09 - better than trusting on the collections default
size. In the next episodes, I will look at
231:10 - the data structures that the Java collections
are based on, which will help you to better
231:11 - understand performance considerations like
this one. However, to me, taking care of such
231:12 - small little details, makes the difference
between a developer and a software craftsman.
231:13 - So I wanted to let you know as early as possible.
Okay, enough, blah, blah, blah.
231:14 - Let's get back to the topic of generics. Now
in the second line, you see how a hashmap
231:15 - is instantiated accordingly. As said before,
a map is basically a relation of one identifying
231:16 - key to one value element. Both these elements
can be of different types. Like you in my
231:17 - example, I use Vin, the vehicle identification
number as the key and the car object as the
231:18 - value. This has to be added as a comma separated
list in ANGEL brackets. And the compiler again
231:19 - will check that this holds true. If you create
the instance reference variable and the object,
231:20 - both in one line, you can also leave the second
pair of angel brackets empty, as it can be
231:21 - inferred from the generic type of the reference
variable. This was introduced with Java seven
231:22 - and is called the diamond operator. Because
the empty Angel brackets in a way, look like
231:23 - a diamond. Actually, I'm sorry. That's not
the whole story. There are two parts. And
231:24 - what I just showed you. This was actually
part two, the usage or invocation of a generic
231:25 - class when you lock in the contract parameter
to be used. But this is only possible if the
231:26 - method, the interface or the class was defined
to be used in a generic way beforehand. Here
231:27 - you see a generically defined interface. In
the first line, the interface is defined as
231:28 - an interface operating on two separate generic
types that have to be specified at a later
231:29 - time. However, when these types are locked
in, this will automatically also specify the
231:30 - type, the types, interface methods we'll use.
So, if you see some weird one letter types
231:31 - in one of the next slides, just remember it
means this is a method that can be used in
231:32 - a generic way. Okay, now we are ready to look
at some additional utility interfaces of the
231:33 - Java collections framework. They are implemented
by classes of the collections framework or
231:34 - the JDK in general, but they can also be implemented
by your own classes, making use of the power
231:35 - of the collections framework. Well, strictly
speaking, the interface Java Lang iterable
231:36 - is not part of the framework. But more precisely,
it sits on top of it. It is the super interface
231:37 - of Java util collection. So every class that
implements Java util collection, will also
231:38 - implement the Java Lang iterable interface.
Okay, anyway, let's now look at each interface
231:39 - in detail. an iterator is an object that acts
like a remote control to iterate through a
231:40 - collection. Let's look at its methods. Boolean
has next returns true if the collection has
231:41 - more elements. ie next returns the next element
in the iteration. And void remove removes
231:42 - the last element returned by this iterator
from the underlying Collection. This interface
231:43 - provides only one method, which will return
an iterator every collection that implements
231:44 - this interface can be used on the for each
loop, which greatly simplifies the usage of
231:45 - your homemade collection. In order to plug
in your collection into the for each loop,
231:46 - you will have to execute two simple steps.
First create an iterator that is able to iterate
231:47 - over your collection with methods like hasnext.
And next, as we saw on the last slide. Second,
231:48 - you need to implement the iterable interface
by adding an iterator method that will return
231:49 - an instance of this iterator implementing
the interface Java Lang comparable defines
231:50 - a sort order for your entities. The interface
contains only one method you need to implement
231:51 - which is int compared to if you want to define
a natural sort order for an entity class,
231:52 - make it implement this interface. return a
negative integer if the object is less than
231:53 - a given method argument, zero if the object
is equal to the given method argument, and
231:54 - a positive integer if the object is greater
than the given method argument. What means
231:55 - smaller or greater is for you to define. For
numbers, that would probably mean that one
231:56 - is smaller than five, for example. But for
colors, This all depends on how you want to
231:57 - sort your entities. When you put objects of
an entity that implements the comparable interface,
231:58 - into a tree set or tree map, it will use your
compare to method to automatically sort all
231:59 - elements you put into the collection. As you
can see, the Java collections framework has
232:00 - been greatly designed for extension. It offers
a lot of possibilities to plug in your own
232:01 - classes. This interface is very similar to
the comparable interface. It allows you to
232:02 - define additional sorting orders like a reverse
ordering. So the sorting logic is not directly
232:03 - implemented in your entity, but in an external
sorting strategy class that can optionally
232:04 - be added to a collection or sorting method
to the Find an alternative sorting order for
232:05 - your collection of entities. The rules of
the interface contract are pretty much the
232:06 - same as for comparable. return a negative
integer if the first argument is less than
232:07 - the second argument, zero if both arguments
are equal, and a positive integer if the first
232:08 - argument is greater than the second. Last
but not least, let's look at the two utility
232:09 - classes, collections and arrays, like a Swiss
Army knife. They provide static helper methods
232:10 - that greatly enhance the general usefulness
of the collection classes. Java util collections
232:11 - offers methods like sword shuffle, reverse
search, min or max. And Java util arrays operates
232:12 - on areas and not on collections actually,
similar to the collections class, it allows
232:13 - us to swap areas or to search through areas
for example, I'm going to take an in depth
232:14 - look at ArrayList. And the second half, I'll
do a practical coding session. Okay, let's
232:15 - get started. Error list is the default implementation
of the list interface. As with any implementation
232:16 - of list, you can have duplicate elements in
your array list. And you can go from element
232:17 - to element in the same order as the elements
were inserted. As it is based on Aries, aerialist
232:18 - provides fast access, but inserting or removing
an element at a random position requires more
232:19 - time, as this will require to reorganize the
list. fast access however, is crucial for
232:20 - most applications, which is why ArrayList
is the most commonly used collection. to store
232:21 - data that changes frequently. However, consider
using an alternative container, for example
232:22 - linked list. I will talk about this as well
as other containers in the upcoming episodes
232:23 - of my free Java video course. Okay, before
I continue, let me introduce you to two different
232:24 - terms, which are important to understand in
context with error list, size and capacity.
232:25 - Size is the number of elements the ArrayList
currently holds. For every element you add
232:26 - to the list, the size will grow by one capacity
or ever, it's the number of elements the currently
232:27 - underlying array can hold. The capacity of
the array list grows in intervals. The error
232:28 - list starts with an initial capacity. Every
time you exceed the capacity of the array,
232:29 - the ArrayList copies the data over to a new
array that is about 50% larger than the previous
232:30 - one. Let's say you want to add 100 elements
to an aerialist have an initial capacity of
232:31 - 10. As the list grows, the system will create
six more areas
232:32 - to take the place of the first. First one
area that can hold 15 elements, then one for
232:33 - a maximum of 22 elements. Then areas with
a capacity of 3349 73 and finally 109 elements
232:34 - to hold the growing list. These restructuring
arrangements can negatively impact performance,
232:35 - you can instantly create an array of the correct
size to minimize these merging activities
232:36 - by defining the correct capacity at creation
time. In case you don't know the final size
232:37 - of the ArrayList at creation time, estimated
as close as possible. Choosing a too large
232:38 - capacity however, can also negatively impact
performance. So choose this value carefully.
232:39 - I advise you to always explicitly set the
capacity at creation time as a documents your
232:40 - intentions. For most projects, you won't have
to worry about optimizing performance to too
232:41 - powerful hardware. But this is no excuse for
sloppy design and poor implementation. Here
232:42 - you can see a simplified extract of the class
aerialist. Keep in mind, the real class looks
232:43 - a bit more complicated. This is just meant
to give you a more concrete idea of what the
232:44 - class ArrayList looks like. As you can see,
error list is just a class anyone could have
232:45 - written. Given enough time and knowledge,
there is no black magic, you can find the
232:46 - actual source code online. However, don't
rely too much on internals that you spot them
232:47 - the source code as they may change any time
if they're not defined in the Java language
232:48 - specification. Default capacity is the initial
size of the array, when you don't specify
232:49 - it as I recommended before element data is
the array used to store the elements of the
232:50 - ArrayList in size is the number of elements
the ArrayList currently holds get add and
232:51 - remove are some of the many functions ArrayList
provides, we will look at those methods now.
232:52 - So, let me give you a short overview of the
methods of the ArrayList class. To make things
232:53 - easy for you, I have broken up the overview
into methods belonging to the Java util collection
232:54 - interface, and methods belonging to the Java
util list interface. When I talk about other
232:55 - containers in later episodes, implementing
the list or the collection interface, I will
232:56 - refer back to this episode. Instead of repeating
myself over and over again. Make sure you
232:57 - are subscribed to my YouTube channel. So you
will be informed when I release episodes about
232:58 - these classes also. Okay, so let's start with
the methods belonging to the Java util collection
232:59 - interface. The contract of the collection
interface does not guarantee any particular
233:00 - order, and therefore does not provide any
index or order related methods. So here you
233:01 - can see the first set of methods that implement
the collection interface. So what I say about
233:02 - these methods does not only apply to ArrayList,
but also to all classes that implement the
233:03 - collection interface. The method Boolean ad
appends the element to the end of the collection
233:04 - to the next empty cell of the underlying array.
Boolean at all appends all given elements
233:05 - to the end of the collection. The stuff in
ANGEL brackets is related to generics. In
233:06 - short, it ensures that no one can call such
a method with the wrong arguments. From now
233:07 - relax. I will tell you more in my upcoming
episode about generics. Boolean remove removes
233:08 - the first occurrence of the element you specify
from the collection. Boolean remove all removes
233:09 - the given elements from the collection. The
iterator method returns an object usually
233:10 - use an a loop to move from one element to
the next element of the collection. Step by
233:11 - step you say I iterate over the collection.
Hence the name iterator. incise returns the
233:12 - number of elements of the collection. Boolean
contains returns true if the collection contains
233:13 - at least one instance of the element you specify.
233:14 - Wide clear removes all elements from the collection.
Boolean is empty. This returns true if the
233:15 - collection contains no elements. And to array
returns an array containing all of the elements
233:16 - of the collection.
233:17 - Alright, let's move on to the methods of the
Java util list interface. The methods are
233:18 - similar in part to the methods we just looked
at, but they differ in that they require an
233:19 - order on the elements of the list. So here
again, you should know that everything I say
233:20 - about these methods does not only apply to
every list, but to all classes that implement
233:21 - the list interface. This add method with an
index parameter. It's actually more like an
233:22 - insert method. It allows you to insert an
element at any index position of the list.
233:23 - Instead of just adding the element to the
end of the list. And the process the elements
233:24 - of the underlying array will be shifted to
the right and migrated to a larger array if
233:25 - necessary. The remove index method allows
to remove an element from any index position
233:26 - of the Similar to the Add method we just looked
at, this might require to shift the remaining
233:27 - elements of the underlying array to the left.
The get by index method returns an element
233:28 - from any given position of the list. The index
off method takes an object and returns the
233:29 - index of the first occurrence of the element
in the list, or minus one if the element is
233:30 - not found. In last index of returns the index
of the last occurrence of the element in the
233:31 - list, and SP four minus one if the element
is not found. List sub list returns a view
233:32 - of the list starting with the position you
specify as from index and ending one possession
233:33 - before the one you specify as to index. Last
but not least, the sword method sorts the
233:34 - list following the order of the given comparator.
Alright, so let's end the lecture session,
233:35 - time to move on to some practical coding.
So now I'm in my early and you can see I have
233:36 - prepared a little test method. So we can do
some practical coding with ArrayList. I have
233:37 - already created an instance of ArrayList.
And I've assigned it to a reference variable
233:38 - of type collection. Now, this might be a bit
counterintuitive at first, because why is
233:39 - that not ArrayList? Or at least list. While
there is a reason to it. And let me cite Robert
233:40 - C. Martin, he says, a good architecture is
one that maximizes the number of decisions
233:41 - not made, or the number of decisions D fared.
And this is such a situation, because by making
233:42 - this collection,
233:43 - I mean, you would create this instance for
a reason, of course, and you probably would
233:44 - forward it to either other methods and or
other objects. So now, if you make this an
233:45 - ArrayList, this will really limit all your
other objects, because they all only have
233:46 - to work on an ArrayList. But now, the requirements
of your business, I mean, requirements, usually
233:47 - they change very fast as you know. And if
they change, like for example, an ArrayList
233:48 - can hold duplicate elements. But now there
might be a new requirement that tells you,
233:49 - you cannot have duplicate elements, you have
to prevent that you have duplicate elements.
233:50 - So you might want to use hash set here. Now,
if you use list or every list everywhere in
233:51 - the code, it will be very tough to change
your mind, you will have to touch a lot of
233:52 - code, which is very dangerous. But if this
is a collection, a collection can be so so
233:53 - many things. And so it will be much easier
to change your mind. Because all you will
233:54 - have to do is change the instantiation of
the object that is actually being used. So
233:55 - if you can, like of course, this limits the
number of functions that you can use, because
233:56 - the collection interface is less powerful
than the list or the error list interface.
233:57 - But if you can, like if you only need the
methods of the collection interface, well
233:58 - then do it like this. later on. We will switch
here to a list interface because I will also
233:59 - show you methods that only appear in the list
interface. But we'll start with a reference
234:00 - variable of type collection. And then you'll
also see the difference. Okay, what else can
234:01 - you see in the single line? Besides you might
spot that have used generics in the angel
234:02 - brackets, so we have created a collection
of type string. And here, you might spot the
234:03 - so called diamond operator that was introduced
with Java seven. Well, because we do both
234:04 - in one line, we do the object instantiation.
And we create the reference variable in one
234:05 - line. The compiler directly sees this must
be a string. And this is why here we can use
234:06 - the diamond operator. But we could also do
it the old way by typing here string. This
234:07 - is just a bit shorter. Okay, and last but
not least, you should notice here I wrote
234:08 - initial capacity, which is a constant, which
I have defined here as private final int,
234:09 - initial capacity five. Now you might say well,
you could have also said just five I mean,
234:10 - this is faster. Well, at first, it might seem
so but this is a so called magic number. And
234:11 - this is evil, because it makes it so much
harder for the next developer to know what
234:12 - this five actually means. Like not everyone
knows that an aerialist has an initial capacity.
234:13 - But if you use the constant value here, you
document in the code your intentions. So this
234:14 - is actually quite good. And I recommend you
to do it also. Okay, but now let's already
234:15 - start using some methods. I mean, we're not
doing I'm not going to properly program something,
234:16 - but we're just playing around with the methods,
so you get a better feeling of like what aerialist
234:17 - is all about. And as this is now, a collection
reference very Oh, of course, you'll only
234:18 - see all the methods of the collection interface.
And we'll start simple with ADD. Of course,
234:19 - like one limitation that we have now is we
don't see any index based methods, which was
234:20 - also the reason why before in my slides, I
divided the methods into methods that are
234:21 - related to the collection interface, and methods
that are related to the list interface. Because
234:22 - now I can also go back to the slides and compare,
because now we're doing the methods of the
234:23 - collection interface. So this is a collection
of type string, so I can add a string. So
234:24 - let's add B, capital B. Let's add some more.
234:25 - A
234:26 - later on, I'm also planning to sort the error
list, which aerialists allows. But right now,
234:27 - with the collection reference variable, we
will not be able to sort it. But stay tuned.
234:28 - I'll do it soon. Oh, okay. And I mean, even
though we have a reference variable of type
234:29 - collection, still, the fact that we have an
ArrayList influences that we can have duplicate
234:30 - elements. So let's do that. Maybe I should
also add one eight here. Okay, and now let's
234:31 - count how many numbers elements I added 123456,
the initial capacity or ever is five. So that
234:32 - means when you add the sixth element, internally,
within the execution of this method, the error
234:33 - list will realize, well, the capacity is insufficient,
will then create a new array of a larger size,
234:34 - and will then migrate all the existing data
to the new array. Before the next element,
234:35 - the second he is added, which costs some extra
time. But really don't worry, I mean, in the
234:36 - regular situation like this five, six elements,
the performance difference is altra altra.
234:37 - Low. So never, I'm never worry, in such situations,
this should really be only, like only think
234:38 - about this when it gets a problem. And usually,
this could get a problem if you have like
234:39 - 1000s or 10s of 1000s, if not a million of
elements. So it always depends on the amount
234:40 - of elements, you have the amount of iterations
that you do. Okay. So and then we can also
234:41 - print the error list as it is now, there are
two different ways ArrayList has also a two
234:42 - string method. So I could directly say system,
out print ln elements. But I'm doing it a
234:43 - bit more complicated, because I want to show
you how we actually iterate over the ArrayList.
234:44 - And this is because every list, and every
collection implements the iterable interface,
234:45 - which is used in this new for each loop. And
so we can iterate over the array list by saying
234:46 - string string, and then column and then elements.
And what is required to iterate over this
234:47 - list will be done here inside and you don't
see it. This is all done by the compiler for
234:48 - us internally. In short, I can tell you, there
is an iterator method that I showed you showed
234:49 - Before, which will then be used. You might
also check my last episode where I introduced
234:50 - you to the iterable. And the iterator interface,
both will be used here. For now. I mean, it's
234:51 - enough, if you see, you can use the ArrayList
and the for each loop. And now we can print
234:52 - out each element separately, which of course
gives us a bit more flexibility. Like I could
234:53 - print something else here also. Okay. So this
is called iteration going over the collection,
234:54 - element by element. And I also want to show
you, let's comment this, oops, let's comment
234:55 - this out. I also want to show you that which
is a feature of list, this order, how we added
234:56 - the elements, AB AC E, will be also exactly
the same order as the elements are printed
234:57 - out, which would be different if we had a
set. Okay, but enough of talking, let's already
234:58 - execute it and see it in action.
234:59 - Okay, so here you see a B, A, C, E, exactly
like we added that, which is a feature of
235:00 - list. Okay, now that we added elements, we
could also remove some elements, which is
235:01 - also just as easy we move. And now on the
collection interface, I can't remove by index.
235:02 - But I can remove by stating the object that
I want to be removed, which by the way, internally
235:03 - uses the equals method. If you don't know
about the equals method, I also have a video
235:04 - about the equals method. So it goes over each
element and checks by using equals, which
235:05 - is implemented in the string class. If there's
a is equal to one of those elements here,
235:06 - and will then remove it. You might also notice
I have two A's. So now it's interesting to
235:07 - know, like will the first a be removed will
the second AB removed of or both be removed?
235:08 - And there is another tip I have for you. Like
if you have such questions, you can look for
235:09 - a book for video tutorial, you can look in
the API and so on and so forth. But you will
235:10 - never be as Sure. And probably also never
be as fast if you just write a simple test
235:11 - like this. And you just try it out for yourself.
I mean, how pragmatic How cool is that? Because
235:12 - the code doesn't lie. If you see it, he will
be sure that it behaves like you can see it.
235:13 - So let's do this and check which element is
removed. And here you see B, A, C E. So the
235:14 - first a is missing? So the answer is the first
element is removed, not all A's are removed.
235:15 - Okay, so what else can we do? Let's check.
We can also ask for the size. Let's make this
235:16 - a bit simpler now. To have it as short as
possible. So now we have 1234 elements. I'll
235:17 - copy that copying some code that you will
reuse is just safer not to introduce any typo,
235:18 - or K. And as long as you're just copying the
code and not duplicating the code, it's also
235:19 - fine. So this supposed to give us the number
of elements. Let me document this out. So
235:20 - we just see the number of elements. Let's
also do it directly after instantiation of
235:21 - the object. So I expect here to see a zero,
no elements included. Or I mean this would
235:22 - be another alternative possibility that this
would throw an exception if the list is empty.
235:23 - So let's check that execute the test was actually
not really a test. I'm just experimenting
235:24 - but here. So you see it return zero and the
first line and then four. So this is the size
235:25 - method. You can even ask, Are you empty? Which
should probably here say Yes, true. And here
235:26 - probably false. And there is true and false.
Okay. So let's now switch Over to the list
235:27 - interface. And let's also play a bit around
with that. You see, I have not a reference
235:28 - variable of type list. And I can use all the
methods exactly like I used them before, because
235:29 - the list interface
235:30 - extends the collection interface. So it includes
all the methods that the collection interface
235:31 - has. But on top of that, we now have more
methods
235:32 - than just the methods of the collection interface.
For example, I can insert an element by giving
235:33 - an index position. So I could for example,
say, at index position zero, at me, I don't
235:34 - know T and S at index position two. And then
let's use the simple fast print odd method.
235:35 - Let's remove this because it'll format the
list in a one liner. But let me just show
235:36 - you what I mean. Okay, we still have the true
we can also remove this. Okay, but for now
235:37 - it's fine. So we have T, because we added
that at index position zero, which means this
235:38 - will be inserted where a was before. Before
I added that at index zero, this was the index
235:39 - zero. So this, put it to where a was before
and then shifted everything else to the right.
235:40 - And this is why now this is nice to see it
like this in one line. Because you see, this
235:41 - is all shifted to the right, which when I
remove an element, the opposite happens. Like
235:42 - if I remove the s, everything will be shifted
to the left. But let's see this later. Okay,
235:43 - and we added the S at index two. So now this
is index 01 and two, which again shifted the
235:44 - rest to the right. Okay, so let's also remove
something, let's do this here. Let's say I
235:45 - remove index. And now let's see, I remove
index one, which is which should be the B.
235:46 - Okay. And there, it seems I am wrong because
the a is still there. And the B is still there.
235:47 - Let us see. Well, of course, because it's
a bit confusing. As I added the T at index
235:48 - position zero, a is now index position one,
and this one was removed. So removing by index
235:49 - is always not so easy. Really, I have to tell
you these index based methods, I hardly ever
235:50 - use them. Normally, you're fine, actually
with most of the methods of the collection
235:51 - interface, which again tells you like, often
it's a good idea to use collection here. Okay,
235:52 - so this actually inserts an element. Okay.
By the way, let's increment this a bit, just
235:53 - for demonstration purposes. I mean, this is
not so flexible. I mean, really, as I said
235:54 - in my slides, you should really think carefully
the number of elements that you need. Just
235:55 - here, it's different because we're playing
around, because I want to show you the difference
235:56 - again in the example between the capacity
and the size, because the size of the list
235:57 - is the number of elements. Let's do this here,
and not the capacity, because my area with
235:58 - a capacity of 100 the area will be 100 elements
big even though they're empty, but the size
235:59 - however, will be much smaller. And here you
see the size is four and not 100. So there
236:00 - is a difference. Okay. Now we can also ask
for the index of a certain element. Let's
236:01 - do this here. Index off and there is also
last index off and also is empty. Yeah, this
236:02 - we should also use. So index off. Let's use
the aim. Yeah. Which is maybe we should remove
236:03 - that. to not make it too confusing to keep
the A where it is. So now index off gets you
236:04 - the first index of an element. So I would
expect that to be zero now, let's see this.
236:05 - And they receive zero. And we can also say
last index of, which should be the second
236:06 - a.
236:07 - Check that. And you might ask, Well, what
do I need the index for? All you can use that
236:08 - to more flexible, like combine the methods
now that you have the index, you could also
236:09 - say like, like, remove this index or so on,
I don't know, might be helpful. Okay, so now
236:10 - I can also show you the clear method. And
the is empty method. I think the is empty
236:11 - method we already saw. But now let's use rim
236:12 - clear. This method is void, so I cannot cannot
print it. But I can put it here, clear, will
236:13 - empty the list. And then we'll ask
236:14 - is it empty now. And we can also print out
the list. An empty list, which is also interesting,
236:15 - because this would be another question. Can
I print out an empty list? Or will this again
236:16 - throw an exception maybe? Let's test it. And
you see yes, it is empty. And you can print
236:17 - it. It's just the square brackets and there's
nothing in there. So this was an empty list.
236:18 - Okay. So I think that's already it. A really
short introduction, some practical coding,
236:19 - I really recommend you to do the same fire
up your ID or your text editor and play around
236:20 - with the methods of earliest. I know there
are many, many more methods of course, it
236:21 - just that in this video i don't have all the
time. So this is just meant to give you some
236:22 - motivation to play around with it by yourself.
Okay, that's it for this episode. If you have
236:23 - any questions, leave them as a comment below
this video. And please remember to give me
236:24 - a thumbs up before you go. Thanks for watching,
and see you next time.