00:00 - thank you
00:03 - [Music]
00:04 - [Applause]
00:05 - [Music]
00:09 - what's going on guys welcome to amigos
00:11 - code my name is nelson and in this
00:13 - course i'm going to teach you everything
00:15 - you need to know about functional
00:17 - programming with java
00:19 - so when i first saw functional
00:21 - programming i was like you know what is
00:24 - this i saw functions by function
00:26 - predicates being used all over the place
00:29 - and to be honest
00:31 - i only realized the power of it when i
00:33 - learned about the clarity of programming
00:35 - so you see most of us write imperative
00:38 - programming which means that you define
00:40 - every single implementation detail of
00:43 - your code whereas declarative you simply
00:45 - tell it what you want instead of
00:47 - defining you know the details for
00:49 - example you might have a variable or
00:52 - actually you might have a loop
00:54 - right so you define you know the initial
00:56 - value how to increment it and how to
00:59 - stop it right so with declarative
01:02 - programming you have none of that you
01:04 - simply tell it what you want and that's
01:06 - what i'm going to teach you in this
01:07 - course
01:08 - so in this course i'm going to teach you
01:10 - exactly you know what the differences
01:12 - what the differences are between
01:14 - imperative and declarative programming
01:17 - and why you want to move away from
01:19 - imperative programming then i'm going to
01:21 - teach you about the functional
01:22 - interfaces that java has to provide so
01:25 - functions buy functions predicates
01:28 - consumers suppliers
01:30 - and all that good stuff right so once
01:32 - you learn that you can then start to use
01:35 - streams and optionals to write code in a
01:38 - declarative way and then towards the end
01:40 - i'm going to teach you one of my
01:41 - favorite design patterns when it comes
01:44 - to functional programming and that is
01:46 - the combinator design pattern which is
01:48 - really really awesome it's really good
01:51 - for validation where you simply define
01:53 - all of your validations in an interface
01:56 - and then you define exactly step by step
01:59 - what you want your validation to be it's
02:01 - really really awesome and finally i'm
02:03 - also going to teach you exactly about
02:06 - lambdas callbacks and
02:08 - the properties of functional programming
02:10 - so that you fully grasp exactly the
02:14 - whole concept
02:16 - so if you haven't subscribed to my
02:17 - youtube channel go ahead and subscribe
02:19 - because that way i can you know provide
02:22 - more awesome content like this without
02:24 - further ado let's go ahead and learn
02:26 - everything you need to know about
02:28 - functional programming with java
02:37 - all right so before you start this
02:39 - course i want to make sure that you
02:41 - really
02:43 - learn from this course because i want to
02:44 - add value so what i want from you is to
02:47 - go ahead and practice as i teach because
02:50 - that's the best way for you to learn any
02:52 - new technology
02:54 - also go ahead and join the private
02:56 - facebook group so if you have any
02:57 - questions you can go ahead and engage
02:59 - with other students and the group is
03:01 - full of cool people just like you
03:05 - so this is all i wanted to say for now
03:07 - and enough of me talking let's go ahead
03:10 - and learn about functional programming
03:18 - all right let's go ahead and bootstrap
03:21 - our application where i'm going to show
03:22 - you all the examples throughout this
03:26 - course so i've got intellij right here
03:29 - and if you've never used intellij then i
03:32 - highly suggest you to enroll to my free
03:35 - course where i teach you pretty much how
03:37 - to use
03:38 - this awesome ide and to be honest as a
03:42 - software engineer this is probably the
03:45 - ide of your choice when it comes to
03:48 - java back-end development
03:50 - so let me go back to intellij
03:53 - and
03:54 - the first thing i want to do is to
03:55 - create project
03:57 - and right here i'm going to pick maven
04:00 - now the project sdk it doesn't really
04:02 - matter whether you use java 11 12 or any
04:06 - other version as long as is above
04:10 - 1.7
04:11 - so i'm going to stick with 11 right here
04:14 - and as i said the version does not
04:17 - matter
04:18 - next let me go ahead and click next
04:20 - and then right here for the group id i'm
04:22 - going to say com dot and then amigos
04:26 - and then code so right here this could
04:28 - be your own organization
04:30 - and right here let me simply name this
04:33 - as java and then functional
04:39 - and then i'm going to press
04:40 - next and then i'm going to save this
04:43 - under code and then java functional
04:46 - and then simply press finish
04:51 - there we go let me actually collapse
04:53 - this maven tab right here and also let
04:57 - me collapse this
04:58 - and right here go ahead and simply
05:00 - enable auto import to import
05:02 - dependencies
05:04 - and this is the actual palm file right
05:07 - so if i open the functional oh actually
05:09 - java functional folder inside you see
05:12 - that we have only the pump file
05:14 - and this contains the group id artifact
05:18 - id and then the actual version so let me
05:20 - just
05:21 - remove that line
05:22 - and also remove this pop-up
05:25 - and finally i'm going to put this full
05:27 - screen
05:29 - and this
05:30 - is all and actually let me just close
05:32 - this because we're not going to need
05:34 - this palm file and this is pretty much
05:37 - everything you need in order to
05:38 - bootstrap the application to follow
05:41 - along so obviously i'm going to give you
05:43 - the source code at the end of this
05:46 - course but i highly suggest you to
05:49 - practice as i teach because that's the
05:51 - best way
05:52 - of you learning any new topic this is
05:56 - all for now
05:57 - if you have any questions about intellij
05:59 - as i said go ahead and roll to my course
06:01 - right here where i teach you everything
06:04 - you should be aware of this awesome ide
06:13 - let me go ahead and give you an example
06:15 - of imperative programming
06:17 - so imperative programming involves you
06:21 - as a developer defining every single
06:25 - detail about your implementation
06:28 - so right here inside of the source
06:31 - folder
06:32 - inside of main and then java
06:35 - let's go ahead and create a new package
06:37 - so you can right click on this folder or
06:40 - i'm going to use keyboard shortcuts and
06:42 - also you can see
06:44 - down here so right here you can see all
06:47 - the keyboard shortcuts that i'm going to
06:48 - use throughout this course
06:51 - so right here i'm going to use
06:53 - the error so i'm going to select package
06:56 - and then right here i'm going to name
06:58 - this as imperative and then okay
07:01 - now inside go ahead and create class
07:05 - and this will be called as main
07:09 - now let me collapse this
07:11 - and inside i'm going to type p
07:14 - s
07:15 - and then vm for public static main
07:19 - there we go
07:20 - and now we have a main method that we
07:23 - can run
07:24 - so let's go ahead and define a list
07:28 - and the type of this list will be of
07:31 - type and then person
07:34 - so right here let me go ahead and simply
07:36 - name this as people
07:38 - equals
07:39 - to and then list
07:41 - and then dot and then off so right here
07:44 - what we're going to do is simply create
07:46 - few people or actually
07:48 - a few people of time person so right
07:51 - here let's go ahead and simply create a
07:53 - class so
07:55 - uh let's go ahead and say static and
07:57 - then class
07:59 - and then person
08:01 - and this person will have a name so
08:04 - private
08:05 - and then final
08:08 - string and a name
08:10 - and we also will define a gender
08:13 - so
08:15 - enum
08:16 - and this will be gender
08:19 - and the gender will be male or female
08:24 - and then right here what we're gonna do
08:27 - or actually underneath is simply say
08:30 - private
08:32 - final and then gender
08:35 - and that will be the gender
08:37 - and let me add this to constructor
08:41 - and there we go
08:43 - so now we have
08:44 - this class right here called person
08:48 - and let me also define a two string
08:49 - method right here so two and then string
08:53 - and there we go
08:54 - so now right here we can simply say list
08:58 - of
08:59 - and then new
09:01 - and then person
09:02 - and right here let's give it a name so
09:05 - john
09:06 - and john is a male
09:09 - and let me have a static import for this
09:13 - and let's go ahead and duplicate
09:15 - this so i'm going to press command d a
09:17 - couple of times
09:19 - and there we go so let's have maria
09:22 - and she's a female
09:25 - let's have
09:26 - aisha
09:28 - she's also a female
09:31 - just like that
09:32 - let's have
09:34 - alex
09:35 - it's a mel and let's finally have alice
09:39 - just like that and alice she's of course
09:42 - a female
09:45 - so
09:46 - now that we have this
09:48 - list right here
09:50 - let's go ahead and find out how many
09:53 - females that we have
09:55 - so
09:56 - the way that we will do it with
09:59 - the imperative approach is let me add a
10:01 - comment right here so in
10:03 - an imperative
10:05 - approach is simply by doing the
10:07 - following so first we need an empty list
10:11 - and then of type and then person
10:14 - and then let me simply say females right
10:17 - here equals to a list
10:20 - of
10:21 - and then or actually not even a list of
10:23 - let's go ahead and use a new
10:25 - and then array list so this is an empty
10:27 - list
10:28 - now what we need to do is to loop
10:30 - through people
10:32 - so let's go ahead and simply say four
10:35 - and then person
10:37 - and then person
10:39 - inside of people
10:42 - and right here we're going to say
10:45 - if and then person
10:47 - or actually let me go anything to say
10:49 - female
10:51 - and then dot
10:52 - equals to person
10:55 - dot and then gender just like that
10:58 - so if this is the case i'm going to say
11:01 - females dot and then add
11:04 - and then person just like that
11:07 - and that would semicolon and then right
11:09 - here at the very end what i'm going to
11:11 - do is simply print each people so again
11:14 - let me simply copy this
11:17 - just like that
11:19 - and then right here
11:22 - this instead of
11:24 - people
11:25 - this will be
11:26 - females
11:28 - and this will also be
11:30 - female
11:31 - and then
11:32 - south
11:33 - just like that so system.out.printline
11:36 - oops
11:38 - just like that and then
11:40 - female
11:42 - now if i go ahead and pretty much run
11:45 - this class right here so let's go ahead
11:48 - and run this class
11:51 - can
11:53 - and there we go
11:55 - so right here you can see that
11:58 - we have only females in our output
12:02 - and basically this is pretty much what
12:05 - imperative programming is so basically
12:08 - we are defining every single
12:11 - detail so right here you can see that
12:13 - first we have an empty list
12:16 - and then we loop through that
12:19 - and then we have an if statement
12:21 - and finally we have a final for loop
12:24 - looping through
12:26 - females and you can see that there is a
12:28 - lot of logic not you know you know a
12:31 - substantial amount of logic but you can
12:33 - see that for example this if statement
12:35 - is some logic and also you can see that
12:38 - this is a lot of code for something very
12:41 - simple and this is what i wanted to show
12:44 - you about the imperative approach next
12:47 - let's go ahead and implement this
12:49 - using the declarative approach and you
12:52 - will see that it's much neater
12:56 - and we pretty much just tell it what we
12:59 - want to do instead of defining every
13:02 - single implementation detail right here
13:10 - so to use declarative approach with java
13:14 - ia functional style programming we
13:17 - simply have to do the following let me
13:19 - let me collapse this
13:21 - so right here so what we're going to do
13:23 - here is
13:25 - instead of us creating a list
13:28 - and then having two for loops what i'm
13:30 - going to do is the following
13:32 - first let me go ahead and pretty much
13:34 - have a comment and right here this will
13:37 - be declare
13:39 - relative and then approach
13:42 - now
13:43 - the way that we use declarative approach
13:46 - is by using streams with
13:49 - collections
13:50 - so
13:51 - don't worry about um
13:53 - so much about what a stream uh is
13:56 - because i'm gonna show you exactly later
13:58 - on
13:59 - but for now just follow along so go
14:01 - ahead and simply say people so people is
14:04 - the original list right here so this
14:08 - list of people
14:10 - and then
14:11 - dot and then stream
14:13 - right here so now we have a stream and a
14:17 - stream allows us to go into an abstract
14:20 - mode where we simply tell it what we
14:23 - want
14:24 - so right here let's go ahead and simply
14:26 - say dot and then filter
14:29 - and what we want to filter
14:32 - is
14:32 - basically
14:34 - this so right here we have a person so
14:36 - this takes a person and then i'm going
14:38 - to say the exact same thing right here
14:41 - so i'm going to take this
14:43 - if statement
14:44 - oops
14:45 - let me press command w a couple of times
14:48 - command c
14:49 - and then put it here there we go
14:52 - so you see that i'm filtering and then
14:55 - this takes a person
14:56 - and i'm using this
14:59 - same if statement so basically
15:01 - female.equals and then person.gender
15:05 - right
15:06 - and then finally i'm going to say dot
15:09 - and then collect
15:10 - and then collectors
15:12 - and then to list
15:14 - end up with semicolon
15:16 - and
15:18 - right here what i'm going to do is
15:20 - put this on a new line
15:22 - and the same with collect just like that
15:27 - and right here
15:29 - we can simply now go ahead and simply
15:31 - say dot and then for each
15:34 - and then we can use system
15:40 - dot and then out
15:42 - and then column column and then print
15:45 - line
15:47 - so now let me actually add um
15:51 - right here so let me simply add this as
15:53 - a south so i'm going to print this
15:58 - just like that
15:59 - there we go
16:01 - and let me do the same here so i'm going
16:03 - to copy that
16:05 - and then paste that take this comment
16:10 - put it here so you can see exactly in
16:12 - the console what i'm doing
16:14 - so now
16:16 - you can see that
16:18 - this
16:19 - is much concise and right here you can
16:22 - see that i'm not creating a list and
16:25 - then adding to that list
16:27 - and then
16:28 - doing the if statement so on and so
16:30 - forth so you can see that
16:32 - is very straightforward and i'm just
16:34 - telling what i want so from the people
16:38 - array list or a list basically this is a
16:41 - list
16:42 - i'm going to stream so i'm going to go
16:43 - into this abstract mode
16:46 - then i'm going to filter all the females
16:49 - and then i'm going to collect to a list
16:51 - and finally i'm going to
16:53 - print everything so technically i don't
16:56 - even need this collector list because
16:59 - i'm simply printing out things
17:02 - so let me simply run this for now so you
17:06 - can see exactly what's happening
17:08 - there we go so basically you can see
17:10 - that we have the exact same
17:12 - output right so if i put this whole
17:15 - screen you can see that we have the
17:16 - exact same output but the declarative
17:19 - approach is much neater
17:22 - so obviously if you were to have this
17:27 - into a list right here so this is where
17:29 - collect comes into play
17:32 - and then i can remove
17:34 - this line
17:35 - and this with semicolon
17:37 - and then extract this to a variable
17:40 - and then say females
17:44 - and then two right
17:46 - and you can see that now i've got a list
17:49 - right here and i could again simply say
17:52 - females
17:53 - to
17:54 - dot and then for rich
17:56 - system dot out column column print
18:00 - line
18:02 - so if i run again
18:05 - you can see that this is the exact same
18:07 - output
18:09 - so there we go now you should have a
18:12 - full understanding of the differences
18:15 - between declarative and imperative
18:18 - approach
18:20 - so
18:21 - obviously i've just shown you uh you
18:23 - know the difference between both but
18:25 - there are a few things that we need to
18:27 - understand in order to
18:29 - write code
18:31 - like this
18:32 - right so i'm going to teach you about
18:34 - functions by functions predicates by
18:37 - predicates consumers
18:39 - and you know all the good stuff that
18:41 - java has to offer when it comes to
18:44 - functional programming if you have any
18:46 - questions go ahead and drop me a message
18:49 - otherwise let's move on
18:56 - all right let's go ahead in this section
18:58 - learn about the java.util.function
19:02 - package
19:03 - so basically this package contains
19:05 - functional interfaces that provides
19:07 - target times for lambda expressions and
19:09 - method references
19:11 - so each functional interface has a
19:15 - single abstract method
19:17 - basically you can have one interface
19:20 - with
19:21 - multiple
19:23 - methods but you must have only one
19:27 - single abstract method to be considered
19:30 - as a functional interface
19:33 - so basically you can see some examples
19:35 - right here so the assignment the
19:37 - assignment context so this is how you
19:40 - for example
19:41 - define a predicate
19:43 - and this is how for example you use it
19:46 - within the actual
19:48 - uh you know stream so right here you've
19:50 - seen that we can get stream from a list
19:52 - right so streaming and filter
19:55 - and
19:56 - there's another example where you can do
19:57 - some casting
19:59 - so
20:00 - this package right here contains a bunch
20:03 - of
20:04 - functional interfaces right here you can
20:06 - see by consumer by function
20:09 - binary operator by by predicate boolean
20:12 - supplier consumer
20:14 - and the list goes on
20:16 - so they are pretty much
20:18 - identical apart from the type so the
20:21 - ones that you will most likely be using
20:24 - are functions by functions predicates by
20:28 - predicates
20:29 - and consumers and also there is a by
20:31 - consumer but i'm like but i'm going to
20:34 - explain exactly how everything fits
20:36 - together
20:37 - because once you learn
20:39 - those main ones then the rest will be
20:42 - very simple
20:44 - so right here i want to show you that so
20:46 - we have a predicate so where is the
20:48 - predicate
20:50 - so let me find predicate
20:52 - so right here so a predicate let me
20:54 - quickly show you a predicate
20:56 - and
20:57 - show you that we actually have used
21:00 - you know a predicate before so a
21:02 - predicate represents
21:04 - a predicate
21:06 - basically this particular represents a
21:08 - predicate
21:09 - a boolean value function of one argument
21:15 - so let me go back to intellij
21:17 - and right here remember where we had
21:20 - this declarative approach
21:23 - so right here so this filter
21:25 - so basically if i pretty much extract
21:28 - this into a variable
21:31 - you can see that this is a predicate
21:36 - and look at this
21:37 - this predicate
21:39 - looks like this
21:40 - so the predicate accepts a person
21:44 - and then returns true or false
21:48 - based
21:49 - of that person i.e whether the person
21:53 - is of type
21:55 - female
21:56 - right but what we've done right here we
21:59 - simply inlined
22:01 - like that that's why you don't see the
22:04 - predicate keyword but indeed
22:07 - this is a predicate and a predicate
22:10 - looks like this
22:13 - so
22:14 - don't worry about
22:16 - this if it doesn't make sense but i'm
22:18 - going to try my best to explain you
22:20 - exactly
22:21 - how you go from
22:23 - uh you know normal java functions to the
22:27 - functional interface world
22:31 - join me in the next one
22:37 - all right so i've gone ahead and created
22:40 - a new package right here called
22:42 - functional interface
22:44 - and inside of this package i'm going to
22:47 - go ahead and create a class
22:49 - and first i want to name this class as
22:52 - underscore and then function
22:56 - and i'm going to explain why i'm saying
22:58 - underscore right here but for now go
23:00 - ahead and simply say underscore and fun
23:02 - underscore function or you can name this
23:05 - anything other than function without
23:09 - underscore right
23:11 - so right here what i'm going to do is
23:12 - simply say public static void main to
23:16 - have a main method
23:18 - and
23:19 - right here what i'm going to do is
23:21 - simply do the following
23:23 - so let's go ahead and create a function
23:25 - so static
23:27 - and then function so this function will
23:30 - take a number
23:31 - right so take a number and then
23:33 - increment that number by one
23:37 - so let's go ahead and simply say
23:39 - int
23:40 - and then
23:41 - increment
23:45 - and then this will take an integer
23:48 - number
23:50 - and then it will return
23:53 - number
23:54 - and then plus one
23:56 - so now if i go ahead and simply say
23:59 - increment
24:01 - and then zero
24:05 - and then end up with semicolon
24:08 - and
24:09 - if i pretty much extract this to a
24:11 - variable and for now let's go ahead and
24:13 - simply sound this
24:15 - increment
24:17 - and let me put this full screen let me
24:20 - run this now
24:23 - oops i'm running the wrong one so i need
24:26 - to run this function
24:28 - there we go so you can see that the
24:29 - result is one very simple so if i put
24:33 - one right here
24:35 - this will be
24:37 - two
24:38 - so what i want to show you is how we go
24:41 - from
24:43 - this so
24:44 - this is what you are used to
24:46 - to
24:47 - this right here so let's go ahead and
24:49 - learn about the function
24:51 - um
24:53 - interface so where is the function
24:59 - so
25:00 - this one right here
25:02 - so
25:03 - this
25:04 - says that represents a function that
25:06 - take that accepts one argument and then
25:09 - produces a result
25:11 - so this is pretty much what we have here
25:14 - right so this function that we have so
25:16 - this is a normal function in java so
25:20 - this is what you are used to
25:22 - so this
25:24 - takes
25:25 - an input
25:27 - and then returns
25:29 - one single output right here and this
25:32 - is pretty much the equivalent right here
25:36 - so represents a function that accepts
25:38 - one argument and produces a result so
25:42 - the way that we convert this into a
25:45 - function right here is the following
25:49 - so let's go ahead and simply
25:53 - say
25:54 - function
25:57 - and if i actually delete this so i want
25:59 - to show you something so function
26:01 - you can see that this function takes a t
26:05 - right so t and then r so basically these
26:08 - are the data types of the input and the
26:12 - output so let's go ahead right here and
26:15 - simply say that this
26:16 - will be of type integer so the input is
26:20 - integer
26:21 - and the output is also an integer
26:25 - right here
26:26 - so now let me go ahead and simply say
26:28 - increment
26:29 - and then function
26:31 - or actually increment by
26:34 - and then one
26:36 - function right here
26:38 - and then this
26:39 - will be
26:41 - equal to
26:42 - right now this is where things become a
26:45 - bit tricky so here
26:47 - equals two and then this will be the
26:49 - actual
26:50 - number
26:52 - and then right here we pass a lambda
26:55 - and then i'm going to say number
26:57 - and then plus plus
26:59 - there we go
27:00 - and i would semi column
27:04 - so
27:05 - you can see that
27:08 - this
27:09 - and this are the exact same thing
27:13 - so basically
27:14 - this integer right here corresponds to
27:17 - the actual input so
27:19 - this one right here right this data type
27:23 - this integer corresponds to the return
27:26 - type
27:27 - and then this number corresponds to the
27:32 - parameter to this function right here
27:35 - and then i'm saying
27:36 - number plus plus well actually let me
27:38 - simply make them the same so number plus
27:41 - one
27:42 - and let me also rename this function to
27:46 - increment by and then one
27:49 - so
27:50 - you can see that
27:52 - this is pretty much the same but now we
27:55 - are talking in
27:57 - functional
27:58 - style world
28:00 - so now the way that we use this is as
28:04 - follows
28:05 - so go ahead and simply say increment by
28:09 - one and the reason why we're not seeing
28:11 - this this function is because we can
28:14 - actually put it inside of this method
28:16 - so inside of this main method we can
28:20 - paste that function there
28:23 - or
28:25 - if you want this can also be static
28:28 - like that right
28:30 - so let me actually um
28:33 - put this on a new line so you see
28:35 - exactly
28:36 - how it is
28:38 - so right here i can say increment by one
28:41 - function
28:43 - and what i'm going to do is simply say
28:45 - dot and then apply
28:48 - so the apply pretty much takes the
28:50 - actual argument so let me go ahead and
28:52 - simply say 1
28:54 - and then right here
28:57 - i'm going to say
28:58 - increment and then 2
29:02 - and i can change this data type to
29:04 - integer
29:06 - and then simply say south
29:08 - and then increment 2
29:11 - then
29:12 - let me simply run this again
29:16 - you can see that we have the exact same
29:19 - output
29:20 - so this is how you use
29:23 - a function
29:25 - so basically
29:27 - it's the exact same thing as this
29:30 - function right here but in a functional
29:33 - style way
29:35 - so if you have any questions about this
29:37 - go ahead and drop me a message
29:39 - but i'm gonna show you exactly how
29:42 - all of this fits together right because
29:44 - now you might be asking you know why
29:47 - should i use
29:49 - uh you know this function right here
29:52 - instead of a normal regular function
29:55 - right
29:56 - and don't worry by the end of this
29:58 - course
29:58 - everything will be clarified
30:01 - so there are a few methods that i want
30:03 - to teach you so right here
30:06 - if i pretty much say increment function
30:10 - uh or actually increment by one function
30:12 - dot you can see that we have
30:14 - um apply and then this method right here
30:18 - and then so i want to teach you
30:21 - what this method is because you might
30:24 - use it later on
30:26 - so let me simply
30:27 - remove that
30:29 - and this is all for now join me in the
30:31 - next video see ya
30:38 - all right let's say that you want to
30:41 - combine multiple functions together to
30:44 - achieve
30:45 - a desired state or a desired output
30:49 - so let's say that you have this
30:52 - function right here so increment by one
30:54 - function
30:55 - but let's also create another function
30:58 - oh actually let me not copy base but
31:00 - simply say
31:02 - static and then function
31:05 - and this function will take an integer
31:09 - and
31:10 - this function will also return an
31:12 - integer
31:13 - and then i'm going to say multiply
31:16 - by
31:18 - and then 10
31:20 - right here
31:21 - so this will take the number
31:25 - oops number
31:27 - and then this will be lambda just like
31:29 - that
31:30 - and then number
31:32 - times and then 10 just like that
31:36 - so
31:38 - we have this function right here
31:41 - and what we want to do is after
31:43 - incrementing so after incrementing
31:47 - uh by one right here we want to apply
31:51 - that or the function immediately
31:54 - so you could do something like this so
31:56 - you could say
31:58 - int
31:59 - increment
32:01 - or actually multiply
32:03 - and then equals two
32:05 - and then multiply by ten
32:08 - uh let me actually rename this to a
32:10 - function
32:13 - just like that
32:15 - and then right here you could say
32:17 - equals to
32:21 - multiply by 10 function dot
32:24 - apply
32:25 - and then increment
32:28 - nn2 right
32:32 - so
32:33 - uh this is
32:35 - not quite right
32:37 - because
32:39 - this is a name so right there
32:42 - and then remove that
32:44 - and this should be multiply
32:46 - by 10
32:48 - let me grab that name there
32:50 - paste it there and there we go so now if
32:52 - i do a south
32:53 - and then multiply by 10 function
32:58 - well actually
32:59 - i'm getting all confused right here so
33:01 - this should be multiply
33:07 - there we go so this is the actual output
33:09 - so now if i run this
33:13 - you can see that
33:15 - we take 2
33:17 - multiplied by 10 is 20.
33:20 - so obviously
33:22 - this is you know quite normal for us to
33:25 - do but we can do something better so
33:27 - what we can do is
33:29 - simply combine the two functions
33:32 - together
33:33 - so right here what i'm going to do is
33:36 - simply say increment by one function
33:40 - dot
33:41 - and then and then
33:44 - multiply by 10 function
33:47 - and right here
33:49 - what i'm going to do is simply extract
33:52 - this to a variable so this will give us
33:55 - yet another function
33:57 - and let me simply say
33:59 - add by
34:01 - 1
34:03 - and
34:04 - then multiply
34:09 - by
34:10 - 10 there we go
34:13 - so if i put this on a new line and you
34:15 - can see exactly what it's doing so now
34:17 - let's go ahead and simply say add
34:20 - by 1 and multiply by 10
34:24 - and then simply say apply
34:26 - and you can see that you can keep on you
34:29 - know chaining these functions as you go
34:31 - along but for now let's simply chain two
34:34 - functions so now i'm going to say apply
34:36 - and
34:37 - the number that i want is
34:40 - one right
34:42 - so
34:44 - this should give us the exact same
34:46 - result so 1 plus 1 2
34:49 - 2 plus
34:50 - 10 you guessed it right that would be
34:52 - 20.
34:54 - so
34:55 - obviously i need to
34:58 - put this around
35:00 - system.out.printline
35:02 - just like that
35:05 - run this again
35:07 - you can see that we have 20 right here
35:10 - so if i change this
35:12 - to let's change this number right here
35:15 - so instead of one let's go ahead and
35:17 - change it to four
35:19 - four plus one five
35:22 - times ten
35:24 - fifty right here
35:26 - and this is pretty much how you chain
35:29 - functions together
35:31 - so if you have any questions go ahead
35:34 - and drop me a message
35:35 - next let me go ahead and teach you about
35:39 - by functions
35:46 - all right so what a by function is
35:50 - is
35:51 - the same as
35:52 - a function
35:54 - but instead of taking one
35:58 - input it takes two inputs and produces
36:02 - one output
36:04 - and by function for
36:06 - two things right
36:08 - so
36:09 - right here
36:11 - we have this function right here so this
36:14 - one add by one and multiply by 10.
36:17 - so let's say that the first number that
36:20 - we give it
36:21 - is the one that it should increment and
36:23 - then the second one is the one that it
36:26 - should multiply
36:28 - by
36:28 - so right here let me go ahead and define
36:30 - this as a normal function so you can see
36:33 - exactly
36:34 - um
36:37 - the equivalent so increment and we'll
36:40 - actually increment by one
36:43 - and
36:44 - multiply
36:46 - just like that so now right here
36:48 - we have a second argument so
36:52 - int num to multiply
36:57 - by
36:59 - just like that
37:01 - and now i'm going to wrap everything
37:04 - within
37:05 - parenthesis
37:07 - and then say times and then num to
37:10 - multiply by
37:11 - now the way that we define the exact
37:14 - same thing
37:16 - but using
37:18 - a by function is as follow
37:20 - so let's go ahead and simply say buy
37:23 - and then function
37:26 - so the first argument is the
37:29 - first input which is the actual number
37:32 - that we want to
37:34 - add one by so let me go ahead and simply
37:37 - say this is an integer
37:40 - the second one is also an integer
37:44 - the third one is also an integer
37:47 - so bear in mind that you can have
37:49 - different data types depending of your
37:52 - circumstances
37:54 - so right here let me simply say
37:57 - that this will have the same name but by
38:00 - function
38:01 - so usually you wouldn't include the pi
38:04 - function
38:05 - for the name but i'm just doing it so
38:07 - that you understand exactly
38:09 - and reason about these things so right
38:13 - here this now will take
38:16 - two things so because it takes two
38:19 - arguments we need to wrap this within
38:22 - parenthesis
38:23 - so this will be
38:25 - number
38:26 - to
38:28 - increment
38:30 - by
38:31 - one
38:33 - and then number
38:34 - two
38:37 - mul
38:38 - t
38:39 - ply and then buy
38:42 - and this will be now a lambda and what
38:45 - we do is simply say number two
38:49 - increment by one plus and then one
38:53 - right so this is the exact same thing
38:55 - that we did here
38:56 - and then this will be within parenthesis
39:01 - and then finally
39:04 - times and then number to multiply by
39:07 - and that would semicolon
39:09 - and let me just put this on a new line
39:13 - yet again
39:15 - so you see exactly everything so i've
39:17 - got bigger font because i want you to
39:19 - see exactly properly
39:21 - but you know you shouldn't indent things
39:23 - like this but basically
39:26 - this right here is the exact same thing
39:30 - as this
39:32 - so now let's go ahead and use it so
39:35 - right here remember
39:37 - we had this function so add by 1 and
39:40 - then multiply by 10. so let's go ahead
39:43 - and say this now is a by
39:45 - function
39:48 - and this was the function example
39:55 - so let me actually add a comment so
39:58 - takes one
40:01 - argument
40:03 - and
40:04 - produces
40:05 - one result
40:08 - so now
40:09 - the by function
40:11 - is almost the same but it takes two
40:14 - arguments right here
40:17 - so let's go ahead and use our function
40:20 - so right here so increment by one
40:23 - and then multiply
40:25 - let's go ahead and give it four
40:28 - and then let's multiply four
40:31 - by one hundred
40:33 - so basically this will be
40:34 - four plus one five
40:37 - five times 100
40:39 - 500
40:40 - so let's go ahead and simply
40:42 - uh i'm not going to even
40:45 - put this into a variable i'm simply
40:47 - going to say south
40:49 - and then just like that so let me
40:53 - put like that
40:55 - and there we go
40:57 - so now if i run this
41:01 - you can see that we have 500 right here
41:06 - now let me go ahead and use
41:09 - the by function so if i escape out of
41:12 - this
41:13 - and let's actually have the same system
41:16 - right here so
41:17 - system.line
41:19 - and right here
41:20 - let me simply use the actual
41:22 - function
41:23 - i think we have to have it as static so
41:26 - this guy right here
41:28 - so this has to be static
41:33 - there we go now it should appear
41:35 - by function
41:37 - and this should be dot and then apply
41:41 - and apply takes 4 and 100
41:45 - now if i run this
41:49 - you can see that we have the exact same
41:52 - result
41:53 - so
41:54 - this one right here is using
41:57 - normal java function
41:59 - and this one right here is using the buy
42:02 - function
42:03 - let me go ahead and show you the actual
42:06 - docks you'll see that we have lots of
42:09 - buy so let me say let me search for buy
42:12 - so you could see that we have
42:14 - you know a double
42:16 - by function to int by function to long
42:20 - by function
42:21 - and all of these by functions are the
42:24 - exact same thing as the function but
42:27 - they take two arguments as you can see
42:30 - here right
42:32 - so the same with predicate so it takes
42:34 - two arguments and returns true or false
42:37 - so this is the difference between a
42:40 - function and a by function if you have
42:42 - any questions go ahead and join me
42:44 - message
42:45 - otherwise let's move on
42:52 - all right next let's go ahead and learn
42:54 - about consumer
42:56 - so a consumer so let me search for
42:59 - consumer
43:01 - right here so consumer
43:03 - so a consumer represents an operation
43:05 - that accepts a single input argument and
43:08 - returns no result
43:10 - so let me show you exactly first the
43:13 - non-functional way and then the
43:15 - functional way so let's say that right
43:19 - here again let's have public static
43:22 - void main
43:23 - and right here let's go ahead and define
43:27 - a static class
43:29 - and then customer
43:32 - and then let's go ahead and simply say
43:34 - private
43:35 - final and let me put this full screen so
43:38 - private final
43:39 - and then string
43:41 - and then
43:42 - customer
43:43 - name
43:45 - private
43:46 - final
43:47 - string
43:49 - customer
43:50 - phone
43:51 - number just like that
43:54 - so next let me add that to constructor
43:57 - and
44:00 - now what i'm going to do is have a
44:02 - function right here
44:04 - so let me go and simply say static
44:07 - and then right here let's go ahead and
44:09 - say greet
44:10 - and then customer
44:12 - so this will take a customer
44:17 - and right here let's go ahead and simply
44:20 - say south and then hello
44:24 - and then customer
44:26 - and then dot customer name
44:29 - and then right here plus
44:32 - and comma
44:33 - thanks for registering
44:37 - and then phone
44:39 - number
44:40 - and then plus
44:42 - customer
44:44 - dot and then customer phone number
44:47 - so let me actually put this on a new
44:49 - line so you can see everything
44:52 - so now let's go ahead and simply create
44:53 - a new customer so new
44:55 - customer
44:57 - this will be
44:58 - let's say that maria
45:00 - and then my real phone number will be
45:02 - 99999
45:05 - right
45:06 - so
45:08 - let me go ahead and cut this
45:10 - and then simply say great customer pass
45:14 - new customer just like that and end up
45:16 - with semicolon
45:21 - just like that
45:22 - so
45:23 - now if i
45:25 - run this class
45:29 - you can see that we have hello maria
45:31 - thanks for registering phone number 9999
45:35 - so the way that we achieve the same but
45:38 - using the functional interface
45:42 - so the consumer functional interface
45:45 - is by doing the following
45:47 - so let me go ahead and simply say static
45:51 - and then
45:52 - consumer
45:54 - so consumer takes one argument so this
45:57 - will be of type
45:58 - customer and then right here let me go
46:01 - ahead and simply say greet
46:05 - customer consumer
46:08 - equals
46:09 - to
46:10 - and then we'll take the customer
46:14 - what we're going to do is pretty much
46:15 - the exact same thing right here so let
46:18 - me grab all of this
46:20 - and then paste it there
46:22 - and basically
46:24 - now i can go ahead and simply say
46:26 - greet customer consumer
46:30 - dot and then right here
46:32 - instead of apply we simply accept
46:35 - now let me go ahead and extract this
46:38 - customer
46:39 - so maria
46:40 - and then also pass maria right here
46:44 - so there we go so this is using
46:48 - functional
46:49 - interface
46:51 - so this is actually
46:53 - consumer
46:57 - and then normal
47:00 - java function
47:02 - right
47:03 - so
47:05 - if i run this
47:09 - you can see that we have the exact same
47:11 - thing right
47:13 - so basically a consumer takes one
47:15 - argument
47:16 - and pretty much returns
47:18 - nothing it's like a void function right
47:22 - so this customer right here is the data
47:25 - type of the input so is this one
47:30 - this customer
47:31 - is the actual name of the
47:34 - uh input so this customer right here
47:37 - and void you could technically say that
47:40 - void is a consumer
47:43 - so if you have any questions on this go
47:45 - ahead and drop me a message
47:47 - otherwise let's learn about by consumers
47:56 - all right so let's go ahead and learn
47:57 - about the buy consumer so the same way
48:00 - that we've done
48:02 - with functions
48:03 - and by functions we have the same for
48:07 - consumer so pretty much
48:09 - every one of these uh functional
48:12 - interfaces they have the
48:14 - buy
48:15 - version so in front of it they have the
48:17 - buy version
48:19 - so the by simply means that instead of
48:23 - taking one argument it takes two
48:27 - arguments
48:28 - now let's go ahead and change this
48:31 - function so let me simply
48:33 - grab that
48:35 - and
48:36 - let's go ahead and simply say v2 for
48:38 - example so this will be the version 2.
48:41 - so what we're going to have is a by
48:43 - consumer right here
48:47 - and let me import this
48:50 - so first we will take the customer
48:53 - and then we will have the boolean so
48:56 - right here so this boolean
48:58 - so this boolean
48:59 - will represent whether we should hide
49:02 - the customer's phone number
49:05 - show
49:06 - and then
49:08 - phone and then number
49:10 - so now we have an error because we have
49:12 - two arguments and because we have two
49:15 - arguments we need to enclose these
49:17 - within parenthesis just like that
49:21 - now right here what i'm going to do is
49:23 - instead of printing the actual phone
49:25 - number like that
49:27 - i'm going to say the following so i'm
49:30 - going to put this within parentheses
49:32 - just like that
49:34 - and
49:37 - right here i'm going to say show phone
49:39 - number so if show phone number
49:41 - then we can pretty much print that
49:44 - otherwise i'm simply going to have some
49:47 - stars just like that
49:49 - so now let's go ahead and test this out
49:53 - so let's go ahead and simply say great
49:55 - customer v2 and let's pass maria
50:00 - and then right here let's simply say
50:02 - true for now
50:05 - so this is actually complaining because
50:07 - we need to say dot accept
50:11 - and if i run this
50:14 - you can see that
50:17 - this is the version two of our
50:20 - function now let's go ahead and simply
50:22 - say false
50:25 - run that
50:27 - and you can see that now we are hiding
50:29 - the number right here so basically if
50:32 - you were to
50:33 - convert this into a normal regular java
50:37 - function
50:38 - this would be as follow so let me just
50:41 - duplicate all of this
50:43 - just like that
50:45 - call this v2
50:48 - and then right here
50:50 - we simply take the exact same variable
50:53 - so show phone number
50:57 - but right here
50:59 - boolean
51:00 - show phone number
51:02 - and let me grab everything from here
51:06 - and then put it here
51:09 - there we go
51:10 - and i would semicolon
51:13 - and
51:15 - i can simply now go ahead and say get oh
51:19 - actually great customer
51:22 - v2
51:25 - pass maria
51:27 - and then true
51:30 - run
51:31 - there we go
51:32 - and you can see that we have the exact
51:34 - same information so there we go this is
51:37 - how you use a
51:39 - by consumer
51:41 - if you have any questions go ahead and
51:42 - drop me a message otherwise let's move
51:45 - on
51:51 - all right let's go ahead and learn about
51:53 - predicates so i've gone ahead inside of
51:55 - the functional interface package created
51:58 - this underscore predicate
52:01 - class
52:02 - and inside let's go ahead and simply
52:05 - type public static void main
52:08 - and let's go ahead and learn about
52:10 - predicates
52:11 - so
52:12 - let's say that you want to
52:15 - do the following so let's say that you
52:17 - have a function so a normal travel
52:20 - function so static
52:22 - and then this will return a boolean
52:25 - and right here let's simply go ahead and
52:28 - say
52:28 - is
52:30 - phone
52:30 - number valid
52:33 - so let's go ahead and simply take a
52:35 - phone number so string and then phone
52:39 - number
52:41 - and for now let's go ahead and keep it
52:43 - very simple but this validation is not
52:46 - real
52:47 - but it's just to illustrate the actual
52:49 - example and purpose of predicates
52:53 - so right here let's simply say that this
52:55 - note this phone number in order to be
52:57 - valid it has to meet the following
52:59 - criterias so let's return phone number
53:03 - dot
53:04 - and then starts
53:07 - with
53:08 - and
53:09 - let's say that the phone number has to
53:11 - start with
53:13 - zero seven
53:15 - and let's also say that the phone number
53:17 - and
53:18 - phone number
53:20 - dot
53:21 - and then length
53:23 - is equal to
53:25 - eleven
53:27 - so this is a simple phone validation uh
53:31 - method but this is not real it's just to
53:34 - illustrate the purpose
53:36 - now let's go ahead and simply do a south
53:39 - here
53:40 - and let's go ahead and have this phone
53:42 - number so zero seven
53:45 - and then zero zero zero zero zero zero
53:47 - zero zero zero
53:49 - and let's have another one
53:52 - zero and then
53:54 - nine and then we can add um you know
53:58 - a couple digits like so
54:01 - right
54:02 - so the validation is not real but this
54:05 - will illustrate the purpose so now if i
54:07 - run this so let me run this main method
54:15 - you can see that i'm printing the number
54:17 - but what i meant to do was to actually
54:20 - let me cut this
54:22 - so what i meant to print was is phone
54:25 - number valid and then pass the actual
54:27 - phone number so same with that one
54:29 - cut it
54:31 - is phone number valid and then paste it
54:34 - run it again
54:37 - you can see that the first phone number
54:39 - is valid so it meets the actual
54:41 - criterias let's also have another one so
54:44 - the same but this will be 10 characters
54:47 - long
54:49 - and if i run this again
54:52 - you can see that the first one is valid
54:54 - the second one the second one the second
54:56 - one isn't and the third one isn't as
54:59 - well
55:00 - so right here we're simply doing a
55:02 - simple phone validation uh check
55:05 - now in order for us to use the
55:08 - functional style we can use the
55:11 - predicate so predicate right here so you
55:14 - can see represents
55:16 - a boolean valid function of one argument
55:19 - right
55:20 - so
55:21 - right here the way that we use a
55:23 - predicate is as follows so this exact
55:26 - same function as predicate will be
55:29 - something like this
55:30 - static
55:31 - and then right here predicate
55:35 - and then this will take a string so this
55:39 - will be the phone number
55:41 - and then let's copy this exact same name
55:45 - and then let's simply say predicate
55:49 - and right here
55:50 - this will be equal to and then
55:53 - phone number
55:56 - so let's actually grab this
56:00 - and then this lambda
56:04 - and
56:04 - on a new line i'm simply going to grab
56:08 - this
56:11 - and then paste it
56:13 - and then end with semicolon
56:15 - now let's go ahead and use it so to use
56:19 - it
56:19 - is phone number valid predicate
56:23 - dot
56:24 - and then test so this is the actual
56:26 - method that we need to use
56:28 - so now we're going to test
56:30 - the following let's test the first
56:32 - number
56:33 - so we know that the first number is
56:34 - valid so basically this will be the
56:37 - exact same thing so we need to simply
56:39 - south this
56:42 - just like that
56:45 - there we go
56:46 - and let me duplicate this
56:48 - and basically we should have the exact
56:50 - same output
56:52 - there we go
56:54 - and then paste that in
56:56 - let me do south
56:59 - without
57:01 - predicate
57:02 - and then right here
57:04 - weight
57:05 - predicate
57:11 - and if i run this
57:15 - you can see that we have the exact same
57:18 - result so true false false
57:21 - and without predicate true false false
57:24 - so basically this is the equivalent so
57:27 - the predicate is the equivalent
57:30 - as
57:31 - this normal java function
57:35 - and the cool thing about predicates is
57:36 - that you can have a bunch of predicates
57:39 - and then combine them together so the
57:42 - same way that we've done with function
57:43 - using and then we can we can also use it
57:47 - with predicates so let's say that we
57:49 - have another predicate so let's have
57:52 - another project so static and then
57:54 - predicate
57:56 - and this predicate will take a string
58:00 - and then let's say contains
58:06 - and then number and then let's simply
58:08 - say number three so if the phone number
58:10 - contains number three
58:12 - so phone number
58:14 - and right here i'm simply gonna say
58:16 - phone number
58:17 - dot and then contains
58:20 - and then three
58:22 - just like that
58:24 - now the way that you
58:27 - change predicates is as follow
58:30 - so right here let's simply go ahead and
58:31 - say is phone number valid so we're gonna
58:34 - pass this phone number so this one right
58:37 - here there we go
58:39 - and then we can say dot and then
58:42 - is phone number valid predicate
58:45 - dot
58:46 - and then and another predicate so the
58:49 - other predicate is contains number three
58:53 - dot
58:54 - and then test
58:56 - let's actually pass
58:57 - this number right here so the last one
59:01 - there we
59:02 - go and let's wrap everything without a
59:06 - system.print line
59:08 - let me put this on a new line
59:11 - and
59:14 - just like this there we go
59:17 - so if i say right here
59:20 - is
59:21 - phone
59:22 - number valid and
59:24 - contains
59:26 - number
59:27 - three
59:31 - equals and then plus
59:33 - the actual result
59:35 - let's do the same for a different number
59:38 - so let's actually
59:39 - let's actually do for this one very
59:42 - first one
59:43 - so right
59:44 - here and let's actually put a three
59:48 - right here
59:49 - so
59:50 - this should be false because the phone
59:53 - number
59:53 - isn't valid but it contains number three
59:57 - right here but this one the phone number
59:59 - is valid so it starts with zero seven
60:01 - eleven characters long
60:03 - and contains number three at the end
60:06 - so let's go ahead and
60:09 - run this method
60:11 - and there we go so you can see that the
60:14 - second one is true as i explained why
60:16 - and the first one is false
60:19 - now you can use ands but you can also
60:23 - use or
60:25 - so or means either one of them is true
60:29 - so if i was to say right here so
60:32 - instead of and i can use or
60:35 - right and then if i remove
60:38 - three here and put a zero
60:41 - run this
60:44 - this will still be true if true because
60:47 - we only need one condition to be true if
60:50 - you use an and so if you chain multiple
60:53 - predicates together using an and all of
60:56 - them have to be true
60:58 - so the same way that we have
61:00 - predicates we have by predicates by and
61:04 - then predicates right here and basically
61:06 - they are the same thing
61:08 - but instead of taking one argument they
61:10 - take two arguments
61:13 - so i'm not going to give you a full
61:15 - example on by predicates because you
61:17 - should be familiar now with by
61:19 - predicates by functions by consumers so
61:22 - on and so forth so if you have any
61:24 - questions on predicates go ahead and
61:27 - drop me a message otherwise let's go
61:29 - ahead and learn about the final
61:31 - functional interface i want to show you
61:33 - and then we can start putting all the
61:35 - puzzle together so that all of this
61:38 - starts to make sense and how you
61:41 - actually end up using it
61:44 - join me in the next one see ya
61:51 - all right go ahead and inside of the
61:53 - functional interface package create a
61:56 - class called underscore supplier with a
61:59 - public static void main
62:01 - method
62:02 - so
62:03 - let's go ahead and learn about what a
62:05 - supplier is so if i go to the docs
62:09 - right here you can see that they say
62:11 - supplier t
62:13 - represents a supplier of results
62:16 - so basically
62:18 - sometimes you might have a method right
62:20 - here that simply
62:22 - uh let's say that
62:24 - we have a method
62:26 - like that so like
62:27 - a method like this so static and then
62:30 - get or actually string
62:34 - get
62:35 - connection
62:37 - url
62:38 - watch let's simply say get db
62:44 - connection url right
62:46 - so
62:47 - this
62:48 - will
62:49 - take no arguments
62:51 - and let's simply return
62:54 - and then for example j dbc
62:58 - column for slash forward slash localhost
63:02 - and then
63:03 - 5432
63:05 - forward slash
63:06 - let's say
63:08 - users
63:09 - right so this is not real but you get
63:11 - the idea
63:12 - so
63:13 - the way that we can
63:16 - use this function now is if i simply say
63:18 - south
63:20 - and then get
63:21 - db connection url
63:24 - and then if i run this
63:26 - you can see that we get the actual
63:28 - connection url for some kind of database
63:31 - so the purpose of this function right
63:34 - here is simply to return
63:36 - a value right here so this is the value
63:39 - that it returns
63:41 - so we can do
63:43 - so we can use a supplier to represent
63:46 - the exact same thing so i'm going to
63:48 - copy this url
63:50 - and to
63:51 - have this java function as
63:54 - functional
63:55 - we simply have to say supplier or
63:58 - actually static
64:00 - and then supplier
64:02 - and then this will supply a string
64:06 - and then get
64:07 - let's
64:08 - grab this
64:10 - and then supplier
64:13 - and right here equals two and then what
64:17 - we need to do is simply have
64:19 - parenthesis
64:22 - and then we simply pass or actually
64:24 - return this
64:26 - just like that
64:28 - so if i put this on a new line so you
64:30 - can see exactly what i'm doing
64:32 - and you can see that now this is the
64:34 - exact same thing but if i go ahead and
64:37 - simply say system.out.life
64:40 - so south
64:41 - and then right here to use this i can
64:43 - say get
64:45 - db connection url supplier
64:48 - dot and then get
64:50 - so now if i run this
64:54 - i do get the exact same result
64:58 - so this is pretty much how you use a
65:01 - supplier so a supplier simply
65:04 - returns
65:05 - any kind of value that you want right so
65:08 - this data type doesn't have to be a
65:10 - string it could be you know your custom
65:13 - classes your custom objects
65:15 - um
65:16 - you know an array
65:18 - pretty much anything that you want so
65:20 - for example if you wanted to return a
65:22 - list right here you could simply say
65:24 - list
65:25 - and then of type and then string right
65:27 - here
65:28 - and then here i would say list dot of
65:33 - and then just like that and that would
65:36 - semicolon right so now if i run this
65:45 - you can see that this now is a list so
65:48 - if i was to return
65:50 - something else so
65:52 - right here
65:53 - let me simply add comma new line
65:57 - and then this
65:59 - like so so it's much neater
66:02 - just like that
66:04 - oops just like that
66:06 - and right here let's simply say uh
66:09 - customer for example right
66:11 - so get a connection urls
66:14 - and then supplier and then here urls run
66:18 - this
66:20 - and there you go so now we are returning
66:22 - a list with two urls
66:25 - so if you have any questions on
66:27 - suppliers go ahead and drop me a message
66:30 - otherwise let's move on
66:37 - all right so by now you should see
66:39 - exactly the differences between
66:42 - writing a normal java function and
66:45 - functional interfaces
66:47 - so
66:47 - the benefit of you know knowing the
66:50 - functional interfaces is when you start
66:52 - to use optionals and streams but more
66:55 - specific streams right so once you start
66:58 - using streams with all of these
67:00 - functional interfaces you will start to
67:02 - write clean code and that's what i'm
67:05 - going to teach you next
67:12 - okie dokie now that you've learned about
67:15 - consumers functions by functions
67:18 - predicates by predicates and suppliers
67:22 - and also i think by consumers
67:24 - now let's go ahead and actually learn
67:26 - how this is useful to us when writing
67:29 - code
67:30 - so
67:32 - go ahead and create a new package under
67:35 - java so package
67:37 - and call this as streams
67:41 - now go ahead and create a new class and
67:44 - simply call it underscore and then
67:47 - stream
67:48 - just like that
67:50 - enter public
67:52 - static void main
67:55 - enter
67:56 - now remember inside of the imperative
67:59 - uh package go ahead and open that up
68:02 - and let's actually steal some code so
68:05 - right here let's steal
68:07 - all of this so the enum gender as well
68:10 - as the
68:11 - person class
68:12 - so let me close this
68:15 - and then right here let me paste that in
68:18 - and i'm gonna cancel because i don't
68:19 - want to import from imperative.main so
68:23 - cancel
68:25 - and
68:27 - let me go back again
68:29 - and let's actually steal some code again
68:32 - so let's take this list right here so
68:35 - we're going to take this list and then
68:38 - we can close this once more
68:40 - and then right here inside
68:43 - let's go ahead and paste it
68:46 - and you see right here it's trying to
68:47 - import from imperative.main
68:50 - cancel out of it
68:52 - and let's simply import the actual list
68:55 - ourselves so i'll just press option
68:57 - enter and right here let's import mail
69:00 - and gender
69:02 - just like that and finally let's go
69:04 - ahead and add a static import for those
69:07 - so i'm just pressing
69:09 - option and then enter add static import
69:13 - now let me go ahead and close this
69:16 - and
69:17 - let's actually use what we've learned in
69:19 - the previous section
69:21 - with streams so this is pretty much
69:24 - where everything starts to make sense
69:27 - so
69:28 - let's go ahead and use a couple of those
69:31 - functional interfaces that we've learned
69:33 - so if i collapse this or actually open
69:35 - this so consumer function predicate and
69:38 - suppliers
69:40 - so
69:40 - go ahead and simply say people
69:43 - dot
69:44 - and then stream
69:47 - right so
69:49 - stream pretty much takes us to
69:51 - an abstraction mode and if you want to
69:54 - learn about all of this i've got this
69:58 - course right here where i teach
70:01 - everything about the java streams api
70:04 - because once you've
70:05 - because once you learn this
70:08 - the way that you write your java code
70:10 - will change quite significantly so stuff
70:13 - that you use to take 20 lines of code
70:16 - you can simply collapse into perhaps
70:19 - five lines of code and to be honest
70:21 - knowing how to use the java streams api
70:24 - will make you a much better developer
70:27 - so i also have a free video on youtube
70:31 - where i teach about filter soar group by
70:34 - all match basically this is a an
70:36 - introduction of this awesome api but for
70:39 - now let's go ahead and learn some of
70:41 - these methods
70:42 - so go ahead and say people.stream
70:46 - and now go ahead and simply say dot
70:50 - so what i want you to do is to actually
70:52 - look
70:53 - carefully so right here so look at the
70:55 - methods that we have we have map collect
70:58 - filter find first for reach all match
71:02 - but what i want you to see is exactly
71:04 - look the map function takes a function
71:08 - right takes a function
71:10 - of some type that extends person and
71:14 - then you can see the other one so the
71:16 - other argument so question mark extends
71:19 - our
71:20 - mapper so this is exactly what we've
71:22 - learned right so a function takes an
71:25 - input and
71:26 - produces an output
71:28 - so the same with collect so collect
71:31 - is a supplier
71:33 - and you can see you buy consumer so this
71:36 - is awesome right this is everything that
71:37 - we've learned so the same with filter
71:40 - takes a predicate
71:41 - find first so this returns simply an
71:43 - optional
71:45 - for which takes a consumer right
71:49 - let's look another one so for example
71:51 - drop wow this takes a predicate find any
71:56 - flat map so this is a very useful
71:58 - function
71:59 - takes a function inside
72:01 - and right here flat map to wind
72:04 - map to double so this takes a two double
72:07 - function right
72:10 - and you can see right here
72:12 - non match a verify you of a very useful
72:15 - function as well
72:17 - reduce
72:18 - binary operator
72:20 - and then right here you have another
72:22 - reduce
72:24 - and then look at this
72:26 - sorted takes a comparator it's not
72:28 - relevant to us
72:29 - take wow you can see that this takes a
72:32 - predicate
72:33 - and to array into function basically
72:36 - this is pretty much everything that we
72:39 - have learned right so functions by
72:42 - function consumers predicates
72:44 - and the other good stuff so basically
72:46 - this is now where everything comes into
72:50 - action so let me go ahead and show you
72:53 - for example how to use this map function
72:56 - so go ahead and simply select the map
72:59 - function and the map and the map and and
73:01 - the map function simply does
73:04 - transformations
73:05 - so right here this takes a person
73:09 - right and from here what we want to
73:11 - return so i want to return person
73:14 - dot and then the actual gender
73:17 - now let's go ahead and simply say dot
73:19 - and then collect
73:20 - and then collect us to set
73:23 - right
73:24 - so
73:24 - and also um
73:26 - let me extract this to a variable
73:30 - genders
73:33 - and then south
73:36 - and then genders
73:39 - or actually not even south so let me let
73:41 - me simply remove that
73:43 - because i want you to see exactly what
73:45 - we're doing so right here so instead of
73:47 - collect let's go ahead and simply say
73:49 - dot
73:50 - and then look at this
73:52 - for each takes a consumer and we've
73:54 - learned about consumers right a consumer
73:58 - simply takes an argument and produces
74:01 - nothing so void right so right here we
74:03 - will take a gender
74:07 - and what we want to do with this gender
74:09 - so we want to simply do a
74:12 - system dot out
74:15 - dot print line and then gender
74:18 - and now we can use method reference with
74:21 - this
74:21 - like so and beautiful code
74:24 - now let me go ahead and run this method
74:28 - so you can see what we are doing
74:33 - tada there we go male and female right
74:37 - so you can see that we mapped everything
74:40 - so
74:41 - right here
74:42 - we
74:43 - stream the people list
74:46 - so
74:48 - oops
74:49 - so right here
74:50 - we stream the people list right contains
74:53 - a bunch of people right here so john
74:56 - maria
74:57 - aisha alex and alice
74:59 - so
75:00 - we map so we perform a transformation on
75:03 - that list so we convert
75:05 - every single one of them into a gender
75:08 - so now we simply have a list full of
75:11 - genders
75:12 - and then we collect to a set removing
75:16 - duplicates and then we simply print
75:19 - that's why you see that we have only
75:21 - male and female
75:23 - right here
75:24 - so if i was to have another gender right
75:27 - here
75:28 - cannot
75:30 - actually
75:31 - prefer
75:36 - not to
75:39 - say but basically this is not gender i'm
75:41 - just giving you an example so right here
75:44 - let's add another one another person
75:46 - right here
75:48 - there we go
75:52 - then prefer not to say
75:54 - this will be bob
75:57 - and you could tell that this is a gender
75:59 - but
76:00 - so if i run this
76:03 - you can see that now we have prefer not
76:05 - to say as well right here
76:07 - so if i was to now
76:09 - map this into
76:12 - the actual name right so let's say name
76:16 - and then run this
76:19 - we simply now get the actual names
76:21 - instead of genders
76:23 - so this is really really really awesome
76:27 - so let me actually let me also show you
76:29 - that we can simply get the length of
76:31 - each name so let's also perform another
76:34 - map operation
76:35 - right or in
76:37 - or in this scenario let's say map
76:40 - to int
76:41 - this takes the actual
76:43 - uh
76:44 - name so this time it's name
76:46 - and then simply say name dot and then
76:49 - length
76:50 - and
76:52 - right here we're not going to collect
76:54 - set
76:55 - so let me delete that
76:57 - and then we can even change this to
76:59 - method reference
77:00 - just like that if i run this
77:05 - you can see now the length of each name
77:08 - so this is the power of streams
77:12 - so you might be asking you know what is
77:14 - this
77:15 - right or what is this
77:18 - or what is this
77:19 - so let me just show you right now so
77:22 - what i'm going to do here is simply
77:24 - extract this to a variable
77:28 - and also this to a variable
77:31 - and also this
77:34 - to a variable
77:36 - and now check this out so this is what
77:39 - you've been learning in the past videos
77:42 - so look at this function
77:44 - that takes a person returns a string
77:47 - and then the same here two in function
77:49 - we haven't learned to int function but
77:51 - basically this is the same thing so this
77:54 - takes a string and returns an integer
77:57 - that's all it does and you can see right
78:00 - here in consumer so an end consumer
78:03 - simply takes
78:05 - an integer and it prints out the result
78:08 - so right here so let me actually replace
78:10 - this with a lambda so you can see
78:12 - exactly what is this you see that
78:14 - this is what we've been
78:16 - learning throughout this course but
78:18 - when you use it with streams you don't
78:20 - have to
78:21 - have all of this syntax basically you
78:24 - can ditch the left hand side and just
78:26 - keep these right so if i now inline
78:30 - everything so
78:31 - command shift n
78:33 - command shift and there
78:35 - command shift and there
78:37 - and look at this
78:40 - right
78:41 - and here even method reference
78:43 - and there we go so if you want to learn
78:45 - more about streams
78:47 - go ahead and check my course on java
78:50 - streams api where you learn
78:53 - everything about writing code in a
78:56 - declarative way
78:58 - this is all for now join me in the next
79:00 - one
79:05 - all right let me show you some other
79:07 - methods right here so still right here
79:10 - so let's go ahead and
79:12 - uh for now i'm gonna pretty much just
79:15 - comment everything right here so i'm
79:17 - gonna comment this
79:19 - and right here let's go ahead and simply
79:21 - say people dot and then stream
79:24 - and then right here let's go ahead and
79:26 - simply say all
79:28 - and then match basically we want to know
79:31 - that in our list we only have females so
79:35 - right here so this takes a predicate and
79:37 - remember a predicate looks like this
79:40 - so this will take a person
79:43 - and then in this list we want to make
79:45 - sure that we
79:47 - only have
79:49 - females so female
79:52 - dot and then equals
79:54 - person
79:56 - dot and then
79:58 - why should not people person
80:01 - dot and then gender there we go
80:05 - and now and i'll end this with semicolon
80:09 - and if i extract this to a variable you
80:11 - can see that this
80:13 - is a boolean now let me go ahead and
80:15 - simply say contains only females there
80:19 - we go
80:20 - and if i do a south on this south
80:23 - and then contains only females
80:27 - and let me actually go ahead and
80:29 - destructure all of this so i'm going to
80:31 - extract this to a variable
80:33 - and check this out so right here so
80:36 - we've learned about predicates right so
80:38 - this is what we've learned previously
80:40 - so now let me go ahead and run this
80:44 - again
80:46 - and you can see that it's false right
80:48 - because in our list
80:50 - so right here in our list
80:52 - we contain both male and females
80:55 - so
80:56 - if you want for example to say um
81:00 - or is
81:02 - say the opposite you could say for
81:05 - example i think match let's look at for
81:07 - let's look at match so any match right
81:10 - here right so any match
81:12 - so any match
81:14 - means
81:15 - any match taking our predicate so
81:18 - if we have at least one female then this
81:21 - will return to
81:23 - run this
81:25 - there we go true right so if i for
81:28 - example remove all the females here
81:32 - just like that
81:33 - run it again
81:36 - and it's false now right
81:39 - so let me undo all of that
81:42 - and finally we have uh i think it's
81:45 - non-match
81:47 - right so let's say that now we change
81:50 - this to
81:51 - prefer
81:52 - not say
81:54 - and let's remove bob from here
81:57 - so basically
81:59 - i want to make sure that in our list we
82:02 - do not have someone with prefer not say
82:06 - gender
82:07 - if i run
82:08 - this you can see it's true
82:11 - if i add bob back
82:14 - this will be false
82:17 - there we go
82:18 - so you can see the power of streams
82:21 - right so
82:23 - obviously we have
82:24 - other methods really really useful
82:26 - methods so if i do a person or actually
82:29 - people dot and then stream
82:32 - dot and
82:34 - look at those methods right
82:36 - so
82:39 - mean peak reduce sorted
82:42 - take wow
82:44 - um
82:46 - so
82:47 - right here drop while
82:49 - not much you've seen
82:51 - find first
82:53 - map and map to int so basically
82:56 - once you learn
82:57 - all of this the way you write java code
83:00 - will change and you will become a much
83:04 - better java developer
83:06 - so this is all for
83:10 - this video next let me also show you
83:12 - that you can use um you know all of the
83:15 - goodness of java functional interfaces
83:18 - with optionals because you know again
83:20 - optionals changes the way that you deal
83:23 - with null pointer exceptions in java
83:27 - join me in the next one see ya
83:34 - all right let me go ahead and show you
83:36 - how to use java optionals with
83:39 - functional interfaces so if you've never
83:42 - heard about java optionals or if you've
83:44 - never used java optionals go ahead and
83:47 - check my youtube channel where i've got
83:49 - this
83:50 - crash course on java optionals
83:54 - and i highly suggest you to learn how to
83:56 - use optionals because
83:58 - they will help you a lot in terms of
84:01 - dealing with null pointer exceptions
84:05 - so let me go back to intellij
84:07 - and let me create a new package
84:09 - so right here
84:12 - optionals
84:14 - and inside let's go ahead and create
84:16 - main class
84:18 - and right here
84:20 - public static void main
84:22 - and there we go
84:24 - so now let's go ahead and simply say
84:26 - optional
84:28 - dot
84:28 - and then off
84:31 - nullable
84:32 - so right here let's simply say no
84:35 - right
84:36 - and
84:37 - if i now press
84:38 - dot
84:39 - check this out you can see that right
84:41 - here you have a bunch of methods but if
84:45 - you look closely again so these methods
84:48 - they do take for example the first one
84:50 - or else to throw
84:52 - takes a supplier right so this supplies
84:56 - an
84:56 - exception you can see or else
84:59 - or so right here
85:01 - this takes a supplier
85:04 - map again function
85:06 - if present consumer
85:09 - filter
85:12 - flat map
85:14 - so right here if present or else right
85:18 - is present or else get so this is a
85:21 - supplier so let me actually use this one
85:24 - or else get
85:26 - and then remember suppliers so right
85:29 - here
85:31 - oops
85:32 - there we go
85:33 - so let me simply say
85:35 - default
85:36 - value
85:37 - just like that
85:39 - extract this to a variable
85:41 - and let me simply name this as value
85:44 - now if i go ahead and simply say south
85:46 - on value
85:48 - there we go
85:50 - if i run this
85:51 - you can see that we get default value
85:54 - but now check this out if i simply add a
85:57 - value here
85:58 - so
86:00 - hello
86:02 - run this again
86:04 - you can see that we get a low right
86:07 - so let's
86:09 - try something else so instead of or else
86:11 - get
86:12 - let's go ahead and simply say dot
86:15 - or
86:18 - so right here so or else
86:22 - throw so this again we have to
86:25 - supply an exception
86:27 - oops just like that
86:30 - new
86:31 - illegal set exception
86:34 - and you can have for example a message
86:36 - right there
86:37 - and
86:39 - exception
86:40 - for example right
86:42 - so
86:44 - you can see that if i extract this to a
86:46 - variable
86:48 - this is a supplier and we've learned
86:50 - about suppliers remember so right here
86:54 - so this is a supplier
86:57 - right
86:58 - it takes no arguments but it supplies a
87:01 - value so there we go
87:04 - now let me again show you something else
87:07 - so if i delete this
87:09 - so instead of saying or else throw let's
87:11 - go ahead and use for example
87:14 - so let's use something that has a
87:17 - consumer so if present
87:19 - there we go if present we receive the
87:21 - actual value here
87:24 - and then we do something with the value
87:27 - so right here let me simply remove that
87:31 - and let me move this above
87:34 - and then this
87:36 - there we go
87:37 - now because i only have one single value
87:41 - but basically you could do like some
87:42 - logic right here right if you had like
87:45 - you know something that you wanted to do
87:48 - like a business logic right
87:50 - so now
87:52 - because i only have one value i can
87:54 - delete all of this
87:56 - i can delete that
87:58 - and i can even go one step further
88:01 - use lambda method reference
88:04 - just like that and look at this looks
88:05 - beautiful so now let me go ahead and
88:07 - simply say john
88:11 - gmail.com
88:14 - in fact let's go ahead and pretty much
88:17 - um
88:18 - have a custom message so right here so
88:22 - email
88:23 - and what we're gonna do is simply say
88:24 - south
88:28 - and then sending
88:31 - email to
88:34 - and then
88:35 - email
88:37 - there we go
88:38 - now if i run
88:40 - this you can see that right here
88:44 - we do get sending email to john
88:47 - but now
88:48 - as soon as i pass a null here
88:53 - right
88:55 - if i run this
88:56 - we get nothing but now i can go ahead
88:59 - and pretty much change this with
89:02 - so there is another method right here so
89:06 - if present or else takes the consumer
89:09 - and then the other empty action is a
89:11 - runnable so that
89:13 - is our consumer so let me actually grab
89:16 - this so you can see what am i doing so
89:19 - this is the first one so this email
89:23 - and then right here we have to pass
89:26 - comma
89:27 - right comma
89:28 - and then a runnable so a runnable goes
89:32 - like that
89:34 - and there we go
89:35 - so let me
89:37 - pretty much just put this on a new line
89:40 - and this on a new line just like that
89:44 - and then if i close that
89:46 - indent things
89:47 - there we go and then here what i'm going
89:49 - to do is simply say south
89:53 - cannot send email
89:57 - there we go now if i run this
90:01 - you see that we have cannot send email
90:04 - as a default value so
90:07 - again i can remove that and have method
90:09 - reference
90:10 - and look at how this now starts to flow
90:13 - guys
90:14 - so this is the power of functional
90:17 - programming streams optionals
90:20 - and you know once you start writing code
90:23 - like this you can achieve a lot more
90:26 - instead of using imperative approach so
90:29 - as i said go ahead and roll to this
90:32 - course right here where i teach
90:34 - everything you need to know about java
90:37 - streams api
90:38 - also if you want to learn about
90:40 - optionals go ahead and check this video
90:42 - where i show you how to use optionals
90:45 - and how to be safe with no values
90:49 - this is all for this section if you have
90:52 - any questions go ahead and drop me a
90:53 - message
90:54 - otherwise let's move on
91:02 - let's go ahead and learn about this
91:04 - awesome design pattern called
91:07 - combinator
91:08 - so
91:10 - let me go ahead and first create a new
91:12 - package
91:14 - and right here i'm going to simply name
91:15 - this as combinator
91:18 - and then pattern
91:21 - so
91:21 - right here what i want to do is to
91:24 - create a class so i want to create class
91:28 - and let's say that we will start with
91:30 - the user so the user actually a customer
91:33 - so we have a customer
91:35 - and this customer has few properties so
91:39 - let me collapse this so private final
91:42 - string name
91:44 - let's also give it an email
91:48 - phone number
91:52 - and let's also give it a local date for
91:56 - date of birth
91:58 - now let me go ahead and pretty much just
92:01 - add those to a constructor
92:03 - and let me generate some getters right
92:05 - here so get it
92:07 - just like that
92:09 - so
92:11 - now let's say that you
92:13 - have a system right where customers do
92:16 - register to your system and you and you
92:19 - need to perform some kind of validation
92:22 - right so what you would do for example
92:24 - would be something like this so inside
92:27 - of your package you would create a class
92:30 - and then customer
92:32 - validator
92:35 - and then service
92:37 - right
92:38 - and in this class right here you would
92:41 - have few methods to validate few
92:44 - properties of a customer right
92:47 - so you could have a method so right here
92:49 - you could say public
92:51 - and then boolean
92:53 - is
92:55 - email valid
92:56 - right and this takes a customer
92:59 - or better takes a string
93:01 - email
93:03 - right
93:05 - and right here you'd simply say return
93:07 - and then email
93:08 - dot contains you know this is a rubbish
93:11 - validation but this is just for
93:13 - illustration purposes
93:15 - right so contains that
93:19 - or actually contains the add symbol for
93:21 - now let's keep it simple
93:22 - then you might want to have order
93:24 - validation for the actual
93:26 - um
93:29 - phone number so right here so is and
93:32 - then
93:34 - phone
93:36 - number valid so this will be phone
93:38 - number
93:41 - and then right here phone number
93:44 - right here contains
93:45 - so instead of contains let's go ahead
93:47 - and simply have a simple validation so
93:49 - it starts with
93:51 - and then
93:52 - plus and then zero right
93:55 - and then what did we have so if i go
93:57 - back so we have uh date of birth
94:00 - so let's go ahead and simply say that
94:02 - the date of birth so right here
94:05 - is adult so is adult
94:08 - so right here we take a local date
94:13 - and then
94:14 - dob
94:17 - and then what we're going to do here
94:19 - is simply say
94:21 - period
94:22 - dot and then between
94:24 - so we're going to
94:26 - calculate the number of years between
94:29 - two dates so the start date will be uh
94:32 - inclusive so this will be the dob so
94:35 - customers and date of birth and then
94:38 - local date dot and then now
94:41 - and then right here
94:43 - dot and then get years and let's say
94:46 - that for someone to be an adult they
94:47 - have to be
94:49 - over 16
94:51 - just like that
94:52 - right so if i put this whole screen so
94:53 - you can see
94:54 - so
94:55 - this is then your customer validator
94:58 - service right so now the way that you
95:00 - would use it is
95:02 - let's go ahead and create a new class so
95:05 - main
95:07 - and then public static void main like
95:10 - that
95:11 - customer
95:13 - and then customer equals to new and then
95:15 - customer
95:17 - and then right here let's go ahead and
95:18 - simply say that this is alice
95:21 - and then she has an email of alice at
95:24 - gmail.com
95:27 - and then the actual phone number is plus
95:31 - and then zero so oops plus and then zero
95:36 - and then any random number
95:39 - and finally let's go ahead and simply
95:41 - say that she
95:43 - was born
95:44 - so local date of
95:46 - and then 2 000
95:48 - just like that
95:51 - and then one and then one and there we
95:54 - go so if i collapse this
95:56 - and you can see that now
95:58 - we have a customer that we can perform
96:01 - some validation now obviously
96:04 - um
96:05 - you know this um validator service right
96:08 - so this could even be private
96:11 - so private
96:13 - and then private
96:15 - and then right here so let's go ahead
96:17 - and combine the both
96:19 - let's go ahead and combine everything so
96:21 - is
96:23 - oh actually let's go ahead and simply
96:24 - say public so this is the actual
96:26 - uh interface that we provide to clients
96:29 - so public
96:30 - and then boolean
96:32 - and then
96:34 - is
96:35 - valid
96:38 - just like that
96:39 - and this now will take a customer
96:44 - and now what we're going to do is simply
96:45 - say return
96:47 - and then is
96:49 - email valid
96:51 - customer dot get email
96:54 - and then and
96:56 - and then
96:57 - is phone number valid customer dot get
97:00 - phone number
97:02 - and finally and is in then adult
97:06 - customer dot and then get
97:09 - and then dob
97:10 - just like that
97:11 - so this is actually you know normal code
97:15 - uh
97:16 - but
97:17 - so
97:18 - what i want to teach you really is how
97:19 - are you going to be able to use a
97:21 - functions to
97:23 - change this in a much better way and a
97:26 - neater way right so here if you have
97:30 - extra validation you have to have
97:31 - another method
97:34 - like that and then simply append here
97:36 - and then basically right here you don't
97:38 - have
97:39 - visibility
97:40 - whether um you know whether the
97:44 - phone number was invalid or it wasn't an
97:47 - adult or or anything right because this
97:49 - simply returns a boolean right is valid
97:52 - so if i go ahead and show you what i
97:54 - mean so right here
97:55 - let's go ahead and simply say customer
97:57 - validator service
97:59 - service equals to actually let me rename
98:02 - this to
98:03 - uh validation validate the service
98:06 - new and then customer validated service
98:10 - now let's go ahead and say validator
98:12 - service
98:14 - dot
98:15 - is valid and then pass customer
98:19 - there we go so what i'm going to do
98:21 - actually is in line this oops not that
98:24 - so basically i want to inline
98:27 - um
98:28 - this guy right here so like that
98:31 - and then i'm gonna do a south
98:33 - just like that and then end that like
98:36 - that so now if i go ahead and run this
98:46 - there we go so you can see that this
98:47 - customer is valid and from now on
98:51 - let's say that
98:53 - we
98:54 - can
98:56 - store customer
99:01 - store customer in
99:04 - and then db right
99:06 - so
99:08 - now
99:09 - um
99:10 - actually let me say if and then valid
99:14 - right
99:15 - so now if i go ahead and pretty much
99:18 - just for example remove the add sign
99:21 - run this
99:23 - you can see that now it's false so it's
99:25 - not valid
99:26 - and also let me go ahead and remove the
99:28 - plus sign right here
99:32 - there we go
99:33 - still not valid but now you don't know
99:36 - exactly you know what is wrong with our
99:39 - validation so the combinator pattern
99:42 - it's an awesome design pattern that
99:45 - allows you
99:46 - to chain functions together so basically
99:50 - a combinator is a function that might
99:52 - take other function as arguments and
99:55 - returns new functions
99:58 - so this is an awesome pattern that i'm
100:00 - pretty sure that you will love and
100:03 - that's what i'm going to teach you next
100:10 - all right let's go ahead and use the
100:12 - combinator pattern to improve
100:15 - this validation service right here that
100:18 - we have so validated service actually
100:20 - so this validation sub so so this class
100:24 - right here
100:25 - is
100:26 - okay but we can do
100:28 - way better than this right because right
100:30 - here for example if you want to have
100:33 - um you know a different method that
100:36 - validates for example
100:38 - just email and their phone number then
100:40 - you would duplicate this
100:42 - so right here
100:44 - and then you would say is valid
100:46 - phone number and email
100:48 - and basically just remove for example is
100:51 - adult from here
100:52 - and we don't want to do this right so we
100:55 - want to have a very
100:57 - beautiful interface that we can simply
100:59 - chain all of these validations together
101:03 - so let's go ahead first and expand the
101:06 - project tab
101:07 - and right here let's go ahead and simply
101:09 - create
101:10 - a
101:11 - class
101:12 - and this will be called customer and
101:16 - then
101:17 - let's actually name this as registration
101:22 - validator
101:25 - there we go and instead of a class let's
101:27 - change it to an interface
101:30 - now what i'm going to do here is the
101:32 - following so
101:33 - right here i'm going to say that this
101:35 - will extend
101:37 - a function so remember we've used
101:40 - functions right here and the first
101:42 - argument that we want for this interface
101:45 - is a customer
101:47 - so the type of is a customer
101:49 - and then right here let's go ahead and
101:51 - simply say validation
101:55 - and then result
101:58 - so let me end that
102:01 - just like that
102:02 - and let me put this on a new line so you
102:04 - can see exactly what we're doing
102:06 - now this validation result this will be
102:08 - an enum so enum
102:11 - and then validation or let me actually
102:14 - just copy and paste this so validation
102:16 - result just like that
102:18 - and now i can import this oops
102:22 - actually i did the right thing and let
102:24 - me actually do a static import right
102:25 - here there we go
102:27 - now here what i'm going to do is have a
102:30 - you know few results that i want my
102:33 - validated service or actually my my
102:36 - customer registration validator to have
102:39 - so one i want this to be success right
102:42 - so this is where all the validation is
102:44 - successful
102:46 - then we have few
102:48 - errors so right here we have
102:50 - phone
102:53 - number
102:54 - not and then valid
102:58 - we also have email
103:00 - not and then valid
103:02 - and we also have
103:04 - is
103:05 - not
103:06 - an
103:07 - adult
103:08 - just like that so the way that we're
103:11 - going to
103:12 - use this with this interface is as
103:15 - follows so this is where combinator
103:17 - pattern
103:18 - uh kicks off so right here we're simply
103:20 - going to have the validations that we
103:22 - want right so here you can have as many
103:24 - validations
103:26 - as you want and then you chain them
103:28 - together at the end so right here let's
103:31 - go ahead and simply say static
103:34 - and then right here what we're going to
103:35 - return is
103:37 - this guy right here so the same
103:39 - uh interface so right here we will
103:41 - return this function right here right
103:43 - that takes a customer and returns a
103:46 - validation result so right here i'm
103:48 - gonna say is and then email valid and
103:51 - then i'm not taking anything there
103:53 - but right here what i want to say is
103:56 - return
103:57 - and then
103:58 - customer
103:59 - and right here i'm going to say customer
104:02 - so basically the exact same
104:05 - validation that we had before so
104:06 - customer
104:07 - dot and then contains
104:11 - and then at
104:14 - so if this is the case
104:17 - what i'm going to do is simply return
104:20 - you guessed it success
104:23 - otherwise phone number
104:26 - oh actually no phone number uh email is
104:29 - not valid and let me have a static
104:31 - import for this
104:32 - and the same for success
104:34 - there we go
104:35 - now let's go ahead and do the same for
104:38 - phone number
104:40 - right here let me actually steal some
104:42 - code so from here
104:44 - what did we have we had this so i'm
104:48 - gonna copy that go back
104:51 - and then is
104:54 - phone number valid
104:56 - and then i'm going to
104:58 - change that with this
105:00 - and then customer
105:02 - dot
105:03 - get phone number
105:05 - starts with that
105:08 - so if that is the case then it's valid
105:11 - otherwise so right here phone number is
105:14 - not valid let's go ahead and do the same
105:17 - for
105:18 - is adult so right here
105:20 - static
105:22 - and then customer registration
105:24 - validator
105:26 - is
105:26 - an adult
105:29 - there we go let me steal some code from
105:31 - here so
105:32 - this is what i want
105:36 - just like that go back
105:38 - and then customer
105:42 - will actually return customer
105:45 - and then i'm going to paste
105:47 - that
105:48 - and then right here
105:51 - customer dot
105:53 - and then get dob
105:55 - so if this is the case
105:58 - right so if the customer
106:00 - age is bigger than 16
106:02 - what i'm gonna do so let me put this on
106:04 - a new line
106:06 - so if it's bigger than 16 what i'm gonna
106:08 - do
106:09 - is simply return success otherwise
106:13 - is not an adult
106:16 - there we go indent this properly
106:18 - and there we go
106:20 - so
106:21 - one final thing that now we have to do
106:24 - is right here we have all of these
106:26 - functions of these three functions
106:29 - and the combinator pattern allows us to
106:32 - chain all of these functions together so
106:34 - the same way that you saw with a
106:36 - function where we can use and then and
106:39 - the same with predicates by using
106:41 - i think it was and
106:43 - right or or we can have the same logic
106:46 - with the combinator pattern so right
106:49 - here what i'm going to do here
106:52 - is the following so i'm going to have a
106:53 - default
106:55 - method and right here i'm going to
106:57 - return a customer valid data so the same
107:01 - thing that we did here and then i'm
107:02 - going to say and
107:04 - right so right here we're going to take
107:06 - a customer data
107:08 - and then i'm going to call other
107:11 - so basically this is where the magic
107:13 - happens right
107:14 - so i'm going to say other
107:16 - and
107:19 - inside i'm going to return
107:21 - and then customer
107:23 - and then inside what i'm going to do is
107:25 - simply say this dot and then apply
107:29 - so we are going to apply
107:32 - this customer
107:34 - and i'm going to shrink this to a
107:35 - variable so i'm going to say result
107:38 - and now check this out i'm going to say
107:40 - return
107:41 - and then result
107:43 - dot
107:44 - equals
107:46 - and then
107:47 - success
107:49 - so if it is equal to success
107:51 - i'm going to apply the other
107:54 - validator
107:55 - dot and then apply and then customer
107:59 - otherwise i'm going to simply pass the
108:01 - actual result not super result
108:05 - there we go
108:06 - so if we get to this point we know that
108:09 - we have an error
108:11 - so now this is complaining because i
108:12 - need to
108:13 - pass semicolon right here
108:16 - so let's go ahead now and use this
108:19 - awesome interface
108:20 - so let's go back to the main method
108:23 - right here
108:25 - and
108:26 - now let me simply comment this out and
108:29 - let me simply add an add sign right here
108:32 - or actually let me simply
108:34 - leave it as it is and then i'm going to
108:36 - show you exactly all the errors so now
108:39 - let's go ahead and simply say
108:41 - customer or actually not here um
108:46 - so
108:48 - using
108:50 - combinator
108:52 - pattern
108:53 - so right here let's go ahead and use a
108:54 - customer
108:56 - registration validator
108:58 - and then
108:59 - dot
109:00 - and check this out so we have all of
109:03 - these methods right is an adult is email
109:06 - valid and is phone number valid
109:09 - so let me go ahead and simply start with
109:11 - is
109:12 - a email valid right
109:15 - but now what i want to do is the
109:17 - following
109:18 - so right here i'm going to say
109:21 - dot
109:22 - and then check this out we have this
109:25 - method so and right here so this is the
109:27 - one that we defined so i'm going to say
109:30 - and
109:31 - and then let's use the rest so if i do
109:34 - if i press
109:35 - ctrl shift you can see that we have the
109:37 - other methods so is phone number valid
109:42 - dot and then and
109:44 - and then is an adult
109:46 - there we go
109:47 - so
109:48 - if i
109:50 - now
109:51 - add a static import
109:52 - you can see that now this becomes much
109:54 - much cleaner so now
109:59 - we have these three methods that we have
110:01 - chained together the way that we use it
110:04 - is simply by saying dot and then apply
110:07 - and then pass customer
110:09 - there we go
110:10 - now if i extract this to a variable
110:12 - so result
110:14 - and let's go ahead and simply say south
110:17 - and then result
110:19 - so now
110:22 - what i'm going to do here is say if
110:25 - and then result
110:28 - not
110:28 - equals to success so success
110:33 - we're going to throw
110:35 - so let's throw
110:37 - so throw
110:39 - new illegal state exception
110:41 - you could have your own exception but
110:43 - for now let's go ahead and throw an
110:44 - illegal state exception and then the
110:47 - actual result
110:50 - dot
110:50 - and then name
110:53 - there we go
110:54 - and basically this will actually print
110:57 - out the same thing right here but i want
110:58 - you to see the actual result so
111:01 - let's go ahead and scroll up and let's
111:03 - start with a valid customer so at gmail
111:07 - and then the phone number has to start
111:08 - with plus and then zero
111:10 - so if i go ahead and run this
111:15 - there we go we have success right here
111:19 - and
111:20 - if i scroll up let's now check all the
111:23 - validation that we have so let me remove
111:26 - the add sign
111:28 - and then
111:29 - run
111:31 - there we go you see that email is now
111:33 - valid and we've thrown an exception
111:35 - right so email or valid
111:38 - so if i add that back
111:41 - and if i remove it plus here
111:44 - run this
111:46 - there we go phone number not valid
111:49 - and if i had a plus there
111:51 - and let's make sure that this guy was
111:54 - born
111:55 - uh you know 2015
111:58 - or this guy
112:00 - alice was born 2015 so which means that
112:03 - you know she's not an adult so if i run
112:06 - this
112:08 - you can see that is not an adult right
112:12 - and you can even customize your
112:14 - exception that we throw by including the
112:16 - name or you know an id or anything like
112:19 - that but basically now you can see the
112:21 - power of the combinator pattern so
112:25 - if you have more stuff that you need to
112:27 - change to this validation so let's say
112:29 - that the requirements change you can
112:32 - simply duplicate this
112:34 - and then have your custom implementation
112:36 - inside of the
112:38 - um interface that we've defined defined
112:40 - so this one right here so customer
112:42 - registration validator
112:45 - and then just chain all the validation
112:47 - logic and scenarios that you have and
112:50 - this is the power of the combinator
112:52 - pattern so one last thing that i want to
112:54 - show you is that
112:56 - so if i
112:57 - uh command
112:59 - z a couple of times there so basically
113:01 - so right here you see that we call dot
113:04 - apply so if i comment this
113:08 - and then right here let me simply
113:10 - remove the apply there
113:13 - so the cool thing about um you know
113:15 - these functions so let me change the
113:17 - variable right here
113:18 - to a validator so the cool thing about
113:22 - this right is that this is
113:25 - lazy right
113:27 - none of this stuff is run until we
113:30 - invoke the dot apply so if i say result
113:34 - right here you can see that we have all
113:36 - of these methods right we can compose
113:39 - applies on and so forth but
113:41 - if i run this
113:45 - you can see that nothing gets printed
113:47 - out and even if i for example right here
113:50 - so
113:51 - where we um
113:54 - return here so the email
113:58 - value
113:59 - so right here so is email valid so let
114:02 - me grab that
114:03 - and then let me simply south
114:05 - and then
114:06 - running email validation
114:11 - and then right here simply return that
114:15 - and end up with semicolon there so even
114:17 - if i run this
114:20 - you can see that we still get nothing
114:23 - but as soon as i
114:25 - uh revert all of this
114:29 - just like that
114:31 - and then call apply
114:33 - now check this out if i run
114:36 - you can see that we have the running
114:38 - email validation and i think i need to
114:41 - undo all of this
114:43 - and then run it again
114:46 - and there we go so running email
114:48 - validation right and then we have is not
114:50 - an adult and the actual exception
114:53 - so i hope that you see the power of the
114:56 - combinator pattern
114:58 - i
114:58 - use it whenever i can to perform
115:01 - validation like this and you should also
115:04 - do it if you have any questions go ahead
115:07 - and drop me a message
115:09 - otherwise let's move on
115:16 - all right so in this final section let
115:18 - me go ahead and explain you few things
115:20 - that
115:21 - will help you to fully understand
115:23 - the functional interfaces and functional
115:26 - programming with java so so go ahead and
115:29 - create a new package
115:31 - and
115:32 - in this package we're going to call it
115:34 - as final
115:36 - and then section right here
115:39 - so inside create a main method
115:42 - and then so let me
115:45 - put this full screen like this
115:48 - and then ps
115:50 - and then vm for public study void main
115:54 - and
115:55 - right here what i'm going to do is i'm
115:56 - going to write some javascript and there
115:58 - we go so what i want to touch on this
116:01 - video is call backs so
116:05 - maybe you've done some javascript and
116:07 - javascript they have this notion of
116:09 - callbacks so a function in javascript
116:13 - looks like this so this won't work in
116:15 - java but it looks like this so you have
116:17 - a function
116:19 - and then you give it a name so
116:22 - hello
116:25 - and then right here you might have for
116:27 - example a variable so let's say and then
116:30 - first
116:32 - name
116:33 - last name
116:35 - and then call back
116:37 - something like that right
116:39 - so
116:40 - right here what we're going to do is
116:42 - let's say for example the last name is
116:45 - not provided then we simply have like
116:47 - console.log so let's simply say
116:50 - console.log
116:52 - and then right here
116:54 - first
116:56 - and then name
116:58 - and then i can say if
117:01 - if we have last name
117:04 - then we're going to console.log
117:08 - and then last name
117:13 - otherwise we will have this callback so
117:16 - we're going to invoke the callback right
117:18 - so you might have seen code like this in
117:20 - javascript basically this is an extra
117:22 - function so if i take this command c
117:27 - and then go to chrome and then inspect
117:31 - and then right here go to console
117:33 - paste my function there
117:35 - and then enter
117:37 - you can see that we have undefined now
117:38 - if i say hello
117:41 - and then say
117:42 - first name
117:43 - john
117:44 - and then pass
117:46 - now there
117:47 - and then right here i can pass a
117:49 - function so this is a callback right
117:53 - so
117:54 - console
117:56 - dot and then log
117:58 - and then no
118:00 - last
118:02 - name provided and then end this with a
118:06 - parenthesis here
118:08 - if i now run this
118:10 - oops we have a error there and they
118:13 - should shouldn't have the column there
118:15 - so enter
118:17 - and you can see that now we have john
118:19 - and then no last name provided
118:21 - so basically you can see that this
118:24 - callback right here is a function and
118:25 - you can have like you know a lot of
118:28 - logic in it right
118:30 - but you know this is very simple so
118:31 - we're just logging but if you want to
118:33 - have for example
118:34 - an extra logic that goes to the database
118:37 - and there's you know some other stuff
118:39 - you could definitely do it i'm just
118:41 - showing you the callbacks in javascript
118:43 - so right here if i now pause so right
118:46 - here if i now say alex and then montana
118:51 - and then
118:52 - run this
118:53 - you can see that now we're not printing
118:55 - the actual callback right so now we have
118:57 - john and then montana the last name so
119:00 - we can achieve the same in
119:02 - java using functional programming and
119:05 - the functional interfaces so the way
119:07 - we're going to do it is as follow so let
119:10 - me simply
119:11 - comment this right here so you have it
119:13 - for reference
119:15 - so now what i'm going to do is actually
119:16 - have a static
119:18 - and then void and right here what i'm
119:21 - going to do is actually combine both
119:23 - worlds so we can have a
119:26 - regular method so normal java method
119:29 - and also
119:30 - inside as a parameter we can have a
119:32 - function right so this is you know
119:35 - programming because now we are free to
119:37 - do whatever we want so right here you
119:39 - see static void and then let's go ahead
119:42 - and simply say hello
119:44 - and then right here string
119:47 - and then
119:48 - first and then name
119:51 - string
119:52 - last and then name
119:54 - and then right here
119:56 - what do you think we need right so
119:58 - remember we've learned about functions
120:01 - by function consumers suppliers
120:04 - predicates so
120:06 - we kind of just want to have a function
120:11 - that might take for example last name if
120:13 - it's there print it otherwise have for
120:16 - example a default message so right here
120:19 - what we're going to do is simply say
120:21 - consumer
120:23 - and then of type and then string
120:27 - and then let's simply name this as call
120:29 - pack just like that
120:32 - there we go and then right here let me
120:34 - simply say south
120:36 - and then first name
120:38 - and then i'm going to say if
120:40 - and then
120:41 - um
120:43 - last name
120:45 - equals to no
120:46 - right we could even say is blank right
120:50 - but equals to null so if it's equal to
120:52 - null or actually let's revert this so
120:54 - it's the same as the
120:56 - function that we have right here as
120:58 - javascript so if it's not equal to no
121:00 - let's go ahead and say south and then a
121:03 - last name
121:04 - otherwise else
121:07 - we're going to say call back
121:10 - dot and then accept and then the string
121:13 - that we want is
121:14 - first name for example right so let's
121:16 - take this first name right here and then
121:18 - do something with it
121:20 - so now the way we use it is as follow so
121:23 - let's go ahead and say hello
121:26 - and then john
121:30 - right here
121:32 - and then montana
121:35 - and right here let's have our callback
121:37 - so let's go ahead and simply pass now
121:38 - for now right
121:40 - so if i run this
121:48 - there we go you see that we have john
121:49 - montana but now let's go ahead and
121:52 - define this callback so right here we'll
121:54 - have um
121:56 - a callback that takes a value and the
121:59 - value will be the actual first name it
122:02 - doesn't matter and then we will do
122:04 - something with it so right here
122:06 - south
122:08 - and then what did we have so
122:10 - right here we said
122:13 - last name not provided so let's do the
122:15 - same here
122:19 - and then four
122:21 - and then plus and then john and then
122:24 - value right
122:26 - so you could even you could even change
122:28 - this to first name if you want but i'm
122:31 - just going to leave it as value now if i
122:33 - run this
122:36 - you see that we have john montana but
122:38 - now watch this if i pass no right here
122:43 - and then run
122:47 - there we go
122:48 - no last name provided for john so
122:51 - basically i just want to show you that
122:52 - you can combine
122:54 - you know a normal function
122:56 - with
122:57 - these functional interfaces and do stuff
122:59 - like this
123:00 - and achieve
123:01 - a similar concept
123:03 - as javascript that they call callbacks
123:06 - so there are other languages that have
123:07 - the similar
123:09 - concept but javascript you see a lot of
123:11 - these callbacks been thrown and you can
123:14 - pretty much do the same with functions
123:16 - another way that you might see callback
123:19 - is
123:20 - so right here so because right here you
123:22 - might not want to pass a default value
123:24 - right so you might have something like
123:26 - this so right here
123:28 - let me just duplicate this
123:30 - and then call it two
123:32 - and then right here so i'm gonna simply
123:35 - remove this
123:36 - and then runnable
123:38 - and this will be the callback
123:40 - and then right here
123:42 - call back dot and then run
123:44 - right so this is a bit different now
123:47 - so right here the way we use it is
123:49 - simply say hello
123:51 - like here and then two
123:54 - and then right here you simply pass this
123:58 - runnable right here and you have no
124:01 - value there
124:02 - basically this now is the exact same
124:04 - thing
124:05 - as
124:06 - this concept right here right because
124:09 - we're not taking any value and because
124:12 - um i only have one line there i can
124:14 - simply do this
124:16 - and then check this out just like that
124:19 - and beautiful code so now if i run this
124:25 - you see that it's the exact same thing
124:27 - but right here we're not taking any
124:29 - arguments
124:30 - so there we go so
124:32 - this is how you combine both worlds
124:35 - where you can mix and match these
124:37 - functional interfaces with normal
124:38 - functions and have callbacks if you have
124:42 - any questions go ahead and drop me a
124:43 - message otherwise let's move on
124:50 - let me go ahead and teach you about
124:52 - lambdas
124:53 - so we've been using lambdas throughout
124:56 - this course with you know all these
124:58 - functions but basically let me show you
125:00 - exactly how they're used and for example
125:03 - if you only have one return statement if
125:05 - you have two arguments what you should
125:07 - do
125:08 - uh when using lambdas so
125:11 - let's go ahead and
125:13 - expand this so commander n1 and right
125:16 - here for this main method let me go
125:18 - ahead and simply name this as callbacks
125:22 - just like that
125:24 - now let's go ahead and create a new
125:25 - class and then simply call it as lambdas
125:29 - there we go
125:30 - oops not lambers but lambda
125:35 - and then this
125:36 - just like that
125:38 - now let me collapse that
125:40 - and then public static void main
125:43 - now inside let's go ahead and have a
125:46 - function
125:49 - there we go that takes a string
125:51 - and returns a string
125:54 - there we go so let's simply say
125:57 - uh print
125:59 - and then name
126:00 - equals two so this guy will take name
126:04 - and then right here
126:05 - so this part right here it's a lambda
126:08 - right so this is a lambda where
126:12 - this is the actual argument right so
126:14 - this name right here
126:16 - is what comes from this data type so
126:19 - right here then you have to pretty much
126:22 - just
126:22 - uh do the following so if you have only
126:26 - one line so if you simply return
126:28 - immediately you can simply do this so
126:32 - south
126:33 - and then
126:35 - actually not even south my bad
126:37 - so you can simply um and this is not a
126:40 - good example so not print name
126:43 - but let's simply say
126:46 - upper and then case
126:50 - name for example something like this
126:51 - right
126:52 - so now right here if you simply return
126:55 - immediately you can simply do this so
126:59 - name and then dot and then uppercase
127:02 - right
127:03 - so you can immediately do this so this
127:06 - is only when you have
127:08 - one
127:09 - return statement
127:11 - right after
127:12 - this um
127:15 - error right here
127:16 - so because you only have one return
127:19 - statement and you can even see that
127:22 - intellij is telling you that you can use
127:23 - a method reference so this is because
127:26 - right here this is the same as doing
127:29 - this
127:30 - right it's the exact same thing so
127:33 - this is more understandable
127:35 - but you know once you get too
127:37 - comfortable with this you'll start to
127:39 - use code like this
127:41 - now
127:42 - another thing is
127:43 - right here so
127:45 - if you have to do some extra logic and
127:49 - not return immediately you need to have
127:51 - these curly braces right here so now you
127:54 - can have a logic right so you can for
127:57 - example say if
127:58 - and then name
128:00 - dot um or actually is blank right here
128:04 - so if it's blank
128:05 - then you can
128:06 - throw
128:08 - new illegal
128:10 - and an argument exception something like
128:13 - this right
128:14 - and then right here
128:16 - otherwise now
128:18 - because
128:19 - i need to return i need to say return
128:24 - and then name to uppercase but also i
128:26 - need to
128:27 - add
128:29 - semicolon right here
128:31 - right so you can see that now
128:32 - this is the actual method body for this
128:35 - lambda right so this lambda so this is
128:37 - the entire thing right here
128:41 - so another thing that you could do with
128:43 - lambdas is you see right here
128:45 - where you have name
128:47 - so if this is a by function so by
128:50 - function
128:51 - uh just like that
128:53 - and then right here let's simply have
128:55 - um
128:57 - let's have an integer right here integer
129:00 - and this will be h
129:02 - right so now you see that
129:04 - i need to put age right here because
129:06 - this data type is for this one and this
129:10 - data type is for the second one
129:12 - right and string is what this by
129:15 - function returns now because i have two
129:18 - arguments i need to do this
129:22 - i need to enclose them within these
129:25 - parentheses so let me actually go back
129:27 - for a second so right here so where we
129:29 - have a function
129:30 - so you see this is a function
129:32 - i can even you know enclose them with
129:35 - parentheses but because i only have
129:38 - one
129:39 - argument
129:41 - right into this function right here i
129:42 - can simply ditch
129:44 - this right but if you have a by function
129:52 - and right here let's simply say integer
129:54 - again
129:56 - and then
129:57 - age now you need to enclose like that
130:01 - right
130:02 - and you could you know
130:04 - do something like another logic right
130:06 - here so south for example
130:09 - and then h something like that right
130:12 - and you know the way you'd use it is as
130:15 - follows so uppercase
130:17 - name dot
130:18 - apply
130:20 - and then
130:21 - alex let's have alex here and alex is 20
130:25 - right
130:26 - there we go and this returns a string
130:29 - right here
130:31 - upper
130:35 - cased
130:36 - name
130:39 - and then south
130:41 - and then uppercase name
130:44 - i can even in line this like so
130:47 - if i run this
130:55 - there we go so 20 and then alex
130:58 - so basically this is uh this logic
131:00 - doesn't really make sense but i just
131:02 - want to show you exactly different ways
131:04 - that you can use these lambdas right
131:07 - here
131:08 - so
131:09 - if you have any questions on lambdas go
131:11 - ahead and drop me a message otherwise
131:13 - let's move on
131:19 - all right so just to let you know that i
131:22 - think i didn't mention this at the
131:23 - beginning of this course
131:25 - but when you use these functional
131:28 - interfaces
131:29 - you see right here where you define the
131:31 - actual
131:32 - inputs and outputs of functions right so
131:35 - string and an integer and then string
131:39 - so these right here they have to be the
131:42 - object type and not the primitive so for
131:45 - example integer right so you could have
131:48 - an integer like this
131:50 - so integer and then number
131:53 - equals to no right
131:56 - and then you can also have integer and
131:58 - then let's say counter
132:01 - and right here
132:02 - i can't say
132:04 - this
132:05 - so this is invalid right because this is
132:08 - the primitive
132:09 - um
132:11 - version of
132:12 - this object type right here right so
132:15 - right here you either have to say a
132:17 - number so it could be negative number or
132:20 - positive number so if i do a zero right
132:22 - here you could see that this goes away
132:25 - so
132:26 - for that reason
132:27 - you are not allowed to have
132:30 - primitives in here right because if you
132:34 - have to pass nose then then you can so
132:38 - with primitives you cannot
132:41 - so right here you see that we have this
132:43 - integer right here so i can go ahead and
132:45 - simply say no right here
132:47 - and you see that works but if i was to
132:49 - have this integer so the primitive type
132:53 - that does not work
132:56 - and also
132:57 - one thing that i've been doing a lot
132:59 - throughout this course
133:00 - is having static right here so static
133:05 - so the reason why i've been doing static
133:07 - is because i'm outside so right here i'm
133:10 - outside
133:11 - of the main function and the main
133:14 - function is static right and you can
133:16 - only use
133:17 - static methods inside of this main
133:20 - function so right here you can see that
133:22 - this still works but if i remove the
133:24 - static keyword you can see that
133:27 - it does not work right so this is
133:30 - something that to bear in mind uh your
133:33 - functions and buy functions they don't
133:35 - have to be static right in fact having
133:38 - static throughout your code base is not
133:41 - practical so ideally what you would do
133:44 - is
133:45 - simply have for example so let's say
133:47 - that you have a class let me actually um
133:50 - put this inside
133:52 - so just like that
133:54 - so let's say that you have a class
133:57 - and then call this a service for example
133:59 - right
134:00 - what you should really be doing is like
134:03 - having you know publix
134:06 - and then your function for example or
134:11 - predicate or consumers right so consumer
134:16 - of string
134:19 - and then blur
134:20 - [Music]
134:21 - equals two
134:24 - and an s right
134:26 - just like that
134:28 - and then basically this is your public
134:31 - interface
134:32 - you can also change this to private
134:35 - or
134:36 - no
134:37 - access modifier at all so this is
134:39 - package protected right
134:41 - so just to bear in mind that
134:44 - you know they don't have to be static
134:45 - and you should avoid static but the
134:47 - reason why i've been using static is
134:49 - because i've been doing everything
134:51 - inside of this public static void main
134:55 - method
134:56 - so there we go if you have any questions
134:59 - on primitives and
135:01 - the use of solid keywords go ahead and
135:03 - drop me a message otherwise catch me on
135:06 - the next one
135:12 - all right let me go ahead and quickly
135:13 - show you the rules that come with
135:16 - functional programming and everything
135:18 - that we've learned throughout this
135:20 - course so the first thing i should know
135:22 - is that
135:23 - um
135:24 - there should be no state around
135:28 - your functions right so the functions
135:31 - they have to be pure functions so they
135:33 - shouldn't depend on any other state so
135:38 - for example if you have a global state
135:40 - like
135:41 - or a global variable your function
135:43 - should not depend on that global state
135:47 - right so that's the difference between
135:49 - pure and in pure functions so pure
135:52 - functions
135:53 - don't depend on global state impure
135:56 - functions do depend on global state
135:59 - and that comes with the side effects
136:02 - right so your functions should have no
136:05 - side effects
136:07 - other than
136:08 - everything inside of the body of your
136:11 - function right it shouldn't have a side
136:14 - effect
136:15 - outside of the function and also higher
136:19 - order functions so
136:21 - a function is considered to be higher
136:23 - order function
136:25 - if one of these two conditions are met
136:27 - the function takes one or more functions
136:30 - as parameters so we saw how to so we saw
136:34 - how to pass
136:35 - functions inside a normal functions
136:38 - right
136:39 - or if the function returns another
136:42 - function as result so with the
136:44 - combinator pattern that's exactly what
136:46 - we've done so let me actually show you
136:48 - so right here so with callbacks so right
136:52 - here
136:56 - so right here
136:57 - so you can see that right here we are
136:59 - passing
137:00 - a function right here so this is a
137:03 - function right and also within our a
137:07 - combinator pattern so remember so
137:10 - customer and then registration validator
137:15 - check this out so right here
137:17 - we are
137:18 - returning
137:19 - a function so this interface extends
137:23 - customer
137:25 - or actually extends function that takes
137:27 - a customer and sends a validation result
137:30 - but if you check the return type of
137:32 - all of these methods right here so if i
137:35 - do a
137:36 - command shift
137:37 - and then minus you can see that
137:40 - they all return
137:42 - the function right here so this means
137:45 - that
137:46 - we are satisfying with this property
137:50 - higher order functions
137:52 - so
137:54 - make sure that for example let me
137:57 - actually show you uh you know the no
137:59 - state and pure functions inside effect
138:01 - so if i go back to
138:02 - let's say lambdas right here
138:05 - so you see this function right here so
138:07 - ins by function right here so
138:11 - i should never depend
138:13 - on for example counter right so let's
138:16 - say that i do for example south
138:19 - and then counter or if i change the
138:22 - state of counter right i should never do
138:26 - this because it will break
138:29 - all of this right so you see that there
138:31 - might be some side effects on the
138:34 - outside of
138:35 - this function right here right so
138:39 - outside of this function there might be
138:41 - there's some side effects
138:42 - also you see that
138:45 - you are now mutating state
138:48 - and it's no longer a pure function it's
138:51 - an impure function because it depends on
138:55 - um
138:56 - global state so you never want to do
138:59 - this or for example increment the number
139:02 - so number
139:03 - and then you know increment um you know
139:06 - plus plus something like that you should
139:08 - never do it right so your functions
139:11 - right here they should be
139:13 - self-contained right
139:16 - so they should only depend on the state
139:18 - that you define inside so right here i
139:21 - could say in inc and then counter
139:24 - equals to zero so this is absolutely
139:27 - fine right because this counter
139:31 - so this counter right here it's only
139:33 - visible inside of this function and not
139:36 - the outside world
139:39 - so if you have any questions on these
139:41 - properties
139:42 - go ahead and drop me a message and i can
139:43 - give you more examples but this
139:46 - is pretty much everything you need to
139:49 - know about functional interfaces and
139:51 - functional programming
139:53 - with java
139:55 - if you have
139:56 - any questions go ahead and drop me a
139:58 - message
139:59 - next let's go ahead and wrap up this
140:02 - course
140:08 - okey dokey amigo
140:10 - i want to congratulate you for
140:12 - completing this course and practicing
140:14 - throughout so as you saw for you to
140:17 - write functional programming you just
140:19 - have to shift the way that you think you
140:22 - no longer think about regular java
140:25 - functions but you start to use functions
140:28 - by functions
140:29 - predicates consumers suppliers so on and
140:32 - so forth
140:33 - now the next step for you is to enroll
140:35 - to my course on java streams api because
140:39 - once you combine everything that you've
140:41 - learned in this course with java streams
140:44 - you will start to write code that really
140:47 - really shines
140:49 - instead of you writing code that takes
140:50 - for example 20 lines of code you simply
140:53 - take
140:54 - five lines of code with streams and
140:56 - functional interfaces
140:59 - so this is all for now go ahead and
141:01 - subscribe to my channel to get more
141:03 - videos like this and it really means a
141:05 - lot to me to see a lot of you you know
141:08 - sending me messages suggesting for new
141:10 - courses
141:12 - and i'm trying my best to give you
141:15 - awesome content
141:16 - that will allow you to become a software
141:19 - engineer also if you haven't joined the
141:21 - private facebook group go ahead and join
141:24 - because that way you can see what's up
141:26 - you can connect with all the students
141:28 - and if you have any questions just drop
141:30 - them and i'm pretty sure one of us will
141:33 - be able to help you this is all for now
141:35 - and i'll catch you on the next one see
141:37 - ya
141:41 - [Music]