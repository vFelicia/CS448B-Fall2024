00:00 - hey guys uh welcome to a new series that
00:02 - i'm super excited to get started it's
00:04 - the introduction to game development in
00:06 - this series we're going to cover a lot
00:07 - of basic topics like collision detection
00:09 - the game loop handling different frames
00:11 - per second um all kinds of cool issues
00:14 - that we're going to get into it's all
00:16 - going to be in this vanilla javascript
00:18 - no third-party libraries or framework
00:19 - all we're going to use is the html5
00:22 - canvas and we're going to be drawing it
00:24 - directly on the browser so if you know
00:26 - just a little bit of javascript you
00:27 - should be able to follow it just fine
00:29 - have fun and enjoy the series
00:35 - so we're going to be using code
00:36 - sandbox.io for this project this would
00:38 - be a good way to use multiple javascript
00:41 - files in in one project let's go ahead
00:43 - and get started here
00:45 - we'll say create sandbox
00:47 - i'm just going to do a vanilla app here
00:51 - all right let's get rid of this div here
00:55 - let me
00:56 - update my preferences here let's go to
01:00 - editor
01:01 - let's make line height larger
01:04 - let's make the font size larger
01:08 - all right that should be good
01:10 - so we have a empty app here we have our
01:13 - index.js file let me go ahead and delete
01:15 - everything in there
01:18 - and we have our project setup
01:20 - first thing we want to do is create our
01:22 - html5 canvas
01:25 - let's give it an id
01:27 - i want to call it game screen
01:30 - the canvas is going to be what we draw
01:32 - our game in
01:34 - let's uh let's create some styling here
01:37 - i'm just going to
01:39 - throw it up here real quick
01:41 - because all we need is we need to say
01:44 - game screen
01:46 - let's give it a border of one pick solid
01:49 - black
01:51 - and let's give the canvas itself a width
01:53 - and a height
01:54 - so let's do width of 800 pixels and a
01:57 - height
01:58 - of 600 pixels
02:01 - there you go now you can see we have our
02:03 - game screen here and this is what we
02:05 - will draw our game in
02:11 - so we now have our canvas here
02:13 - um let's get rid of this guy
02:16 - um let's learn how to draw something on
02:19 - the canvas
02:20 - so let's go into our index.js file
02:24 - let's uh let's first grab the canvas so
02:27 - let's do
02:28 - let canvas equals
02:30 - document.getelementbyid
02:33 - and we're looking for the game screen
02:38 - and we need the context of the canvas
02:43 - so next we'll say let
02:45 - context
02:47 - equal canvas dot get context and we're
02:50 - going to be using two dimensional
02:53 - context here
02:55 - the context gives us a rendering context
02:57 - for actually drawing to the canvas
03:00 - i'm going to rename this to ctx just
03:03 - because we're going to be using it a lot
03:04 - in this project and context is kind of a
03:06 - long word just keep typing over and over
03:08 - again
03:10 - now let's simply just draw a square onto
03:12 - our canvas so let's say ctx.fillrect
03:16 - so we're going to fill a rectangle
03:19 - we're going to start it at uh
03:21 - coordinates of 20 20. so 20 on the
03:24 - x-axis 20 on the y
03:26 - and how big do we want it we want to say
03:28 - the width will be 100 and the height
03:30 - will be 100.
03:32 - there we go simple square if we want to
03:34 - change the color we can tell the context
03:37 - let's
03:37 - fill the style
03:39 - equal to this value
03:41 - let's make it red so f00
03:45 - now we have a red square
03:46 - now do note that once you set the fill
03:49 - style every time you make a new drawing
03:52 - it's going to use that same fill style
03:54 - so if we do ctx dot fill rect let's do
03:57 - another one at
04:00 - 200 200
04:01 - and make it a little bit smaller 50 by
04:03 - 50.
04:04 - that square is also going to be red if
04:06 - you want it to be blue
04:08 - we have to update the fill style
04:11 - to
04:12 - zero zero f
04:15 - and now that one is going to be blue so
04:17 - the fill style sets the fill style and
04:19 - then you're gonna fill a rectangle with
04:21 - that style that you've recently
04:23 - specified
04:28 - next let's talk about clearing the
04:29 - screen
04:31 - if you notice here we're drawing these
04:32 - two squares on here
04:34 - if i update this uh let's let's move it
04:37 - to
04:38 - 220
04:42 - you see that it turned into like a
04:43 - rectangle it kind of stretched
04:45 - 3240
04:47 - same thing now it's not actually
04:49 - stretching what's happening is
04:52 - every time you redraw onto the canvas
04:54 - what was previously on the canvas is
04:56 - still there
04:59 - so when you're working with a game where
05:01 - objects are moving around on the screen
05:03 - you want to make sure you clear what was
05:04 - previously there before
05:06 - so all we want to do is we're just going
05:07 - to say t ctx dot clear wrecked so it's
05:11 - going to clear everything on the screen
05:13 - but you have to give it an area that you
05:14 - want to clear so we're going to start at
05:16 - 0 0
05:17 - and we're going to do the whole screen
05:19 - which was 800 wide by 600 tall
05:24 - now if something gets updated 350
05:27 - 360
05:29 - this is actually going to move on
05:32 - on the screen
05:33 - you're not going to have what was
05:34 - previously there
05:39 - so this is going to be a very important
05:41 - part of our game to make sure we clear
05:42 - between every frame
05:48 - now we know how to draw to the screen
05:49 - let's first start working on our paddle
05:52 - the paddle will be at the bottom and
05:53 - you'll be able to move it left and right
05:54 - in order to catch the ball and bounce it
05:57 - back up towards the bricks
05:59 - so let's go ahead and get rid of these
06:01 - squares we're drawing here
06:03 - and let's create a class to handle all
06:06 - the aspects of a paddle
06:08 - let's go into source create new file i'm
06:11 - just going to call it paddle.js
06:15 - and we'll have a class of
06:18 - paddle we might need a constructor
06:23 - and we're going to need a method for
06:25 - drawing the paddle
06:27 - now the draw method is going to need the
06:29 - context so we'll pass that in
06:33 - and we're going to need some attributes
06:34 - for this paddle so let's set some things
06:37 - up here
06:38 - um when this paddle is created let's set
06:40 - a width
06:42 - um i'm just going to guess here we can
06:44 - always update this later i'm going to
06:46 - say 150
06:48 - let's set the height
06:50 - equal to
06:52 - i don't know maybe 30 pixels
06:56 - and we need a position so
06:58 - they should probably know how big the
07:00 - game screen is so that way if we update
07:02 - the game screen later we can just set it
07:05 - in one place
07:06 - so in our index
07:08 - let's have a constant here of
07:11 - game width
07:13 - 800
07:15 - and a constant of game height
07:18 - of 600
07:19 - and we will pass this in
07:23 - game
07:25 - height there we go
07:26 - we'll pass this into our paddle class
07:28 - when we want to create it so our paddle
07:30 - is going to take a game width
07:34 - and a game height
07:40 - so the position of the paddle needs to
07:42 - be in the center of the screen
07:44 - so let's see here let's say this top
07:47 - position
07:48 - equals
07:49 - and i like to make the position an
07:50 - object
07:52 - that way we can say position x is you
07:55 - know this position position y is this
07:58 - position and then we can just update
08:00 - this by saying something like
08:02 - this dot
08:03 - position dot x
08:05 - and you can update it
08:08 - so let's go with this right now um y
08:10 - we're going to be at the very bottom of
08:12 - the screen but a little bit above it so
08:16 - we want to say
08:18 - game height
08:19 - minus this dot height
08:23 - minus how much do we want off the bottom
08:25 - let's just say 10 pixels
08:28 - i'll explain this in a little more
08:29 - detail once we finish it
08:31 - we want to start in the middle of screen
08:33 - so we'll say gain width
08:35 - over 2
08:37 - minus this.width over 2.
08:42 - now let's just draw this up and then i
08:43 - can
08:44 - better explain how this is working
08:47 - so we'll say ctx dot fill rect
08:50 - we want to say it's going to be in
08:52 - this.position.x
08:56 - this.position.y
08:58 - and the size of it is this dot width
09:00 - and this dot height
09:04 - so now we have our draw function let's
09:06 - go back into index.js
09:08 - we're going to say we're going to have a
09:10 - paddle here it's going to be a new
09:11 - paddle
09:13 - and it takes in the game width and game
09:14 - height so game
09:17 - width
09:18 - game height
09:21 - and we just need to say paddle.draw
09:24 - that's giving us an error because it
09:26 - doesn't know what paddle is
09:28 - so on our paddle class
09:30 - we need to export this export default
09:34 - class paddle
09:36 - so now we're exporting this so in our
09:38 - index.js file
09:41 - we can import paddle
09:45 - from
09:47 - source paddle
09:50 - all right so now that this class knows
09:52 - what or this file knows what paddle is
09:54 - we're instantiating it and then we're
09:56 - going to say draw the draw needs to have
09:59 - the context of our game
10:02 - there we go so we have our paddle drawn
10:04 - now let me go back and explain
10:06 - how we calculated this
10:10 - so we want this to be in the middle of
10:11 - the screen
10:12 - let's think about the the y position
10:14 - first
10:15 - the square is drawn from the top left
10:17 - corner so if we want this to be at the
10:19 - bottom of the screen but off the page by
10:22 - about 10 pixels what we need to do is we
10:24 - take the game height so 800 which will
10:26 - be right down here at the bottom
10:28 - move it up the height of the square
10:31 - which is 30
10:33 - and then subtract 10 to give it just
10:35 - that little bit of buffer
10:37 - so game height minus this height minus
10:39 - 10 puts it right here off the bottom of
10:42 - the page
10:44 - for the x position we want to
10:47 - center it between zero and six hundred
10:50 - so in order to do that we take the game
10:53 - width and divide it by two that puts us
10:55 - at 300 which would be right in the
10:57 - center
10:58 - but since
10:59 - the square is built from the top left
11:02 - corner we need to move it to the left by
11:04 - half of the width
11:06 - and that gives us our center position
11:08 - here working with classes like this
11:09 - allow us to know that this file is the
11:12 - paddle we can adjust the height maybe do
11:14 - it by 20. that looks a little better
11:18 - and we also want to set the the style
11:20 - remember the the context was set by that
11:22 - last time we did
11:23 - the fill style so let's do ctx dot fill
11:26 - style
11:28 - equals
11:29 - um
11:31 - i don't know let's just do let's just do
11:34 - a green
11:38 - how about a light blue
11:40 - all right that works
11:45 - now your next step is probably going to
11:47 - want to be moving the paddle or moving
11:49 - things on the screen but in order to do
11:50 - that we need to establish a game loop a
11:52 - game loop is something that runs every
11:54 - frame updates all the objects redraws
11:56 - them in their new position and uh and
11:59 - then moves on to the next frame
12:01 - so let's see what that would look like
12:03 - now you would think you could just do a
12:05 - you know a simple while loop and
12:07 - and iterate over everything
12:09 - redraw the paddle
12:12 - but in reality that's not going to work
12:14 - well because you have to think about all
12:16 - the computers running at different
12:17 - speeds a very powerful computer is going
12:20 - to run this while loop a lot faster than
12:22 - a much slower computer so
12:24 - what we're going to do is we're going to
12:26 - create a new function
12:30 - i'll call it game loop
12:35 - and inside of here we're going to want
12:37 - to
12:38 - clear our canvas
12:40 - we're going to want to update our paddle
12:44 - which let's just uh put that in here
12:47 - real quick
12:48 - so update
12:50 - the update function um let's just for
12:52 - for now let's just say this dot position
12:55 - dot x plus equal five
12:58 - now we want to change it five pixels per
13:00 - per second
13:02 - so the update function needs to bring in
13:04 - a delta time
13:08 - or you might see it as dt in a lot of
13:10 - other games we'll just call it delta
13:12 - time that means the change in time how
13:14 - much time has changed since the last
13:16 - time
13:17 - this has been updated
13:19 - so we're going to update this
13:21 - we're going to say 5 divided by the
13:24 - delta time
13:27 - that means it's going to go 5 pixels
13:29 - divided by how much time has been passed
13:32 - so let's go get that delta time
13:36 - inside our index.js function
13:39 - we need to know what the last time was
13:43 - so we're going to start at 0. now this
13:45 - loop needs to bring in a timestamp
13:51 - and we need to do paddle.draw
13:54 - pass in the ctx
13:56 - and we need to calculate how much time
13:58 - has passed
14:00 - so we will do here
14:05 - let delta time
14:07 - delta time
14:09 - equal timestamp minus last time so how
14:12 - much time has passed and now we need to
14:14 - set the last time equal to the current
14:17 - timestamp
14:18 - so where does the timestamp come come
14:20 - from we're going to request
14:22 - an animation frame from the browser
14:26 - and give it the game loop
14:31 - so every time this runs it'll say hey
14:33 - when the next frame is ready call this
14:36 - game loop again and pass the time stamp
14:38 - and we'll calculate the delta time pass
14:40 - it into our paddle.update function
14:46 - and continue
14:48 - so just to get this thing to start let's
14:50 - just call game loop once
14:53 - now the reason this isn't working is
14:54 - because on our very first frame uh we're
14:57 - not passing a time stamp at all
15:00 - which is fine because we're starting at
15:01 - zero
15:02 - but the paddle is expecting to divide by
15:04 - the delta time here which is going to be
15:06 - zero
15:07 - so we can just put in here if not delta
15:10 - time
15:12 - return
15:15 - so if no delta time is passed in we'll
15:17 - just return and now you can see that our
15:19 - paddle is moving across the screen
15:23 - all right so let's just remove this and
15:24 - we'll handle actually moving the paddle
15:26 - with inputs and another episode in the
15:28 - future
15:29 - so just as a quick recap we have our
15:32 - game loop that runs every frame it
15:34 - calculates how much time is passed
15:36 - it clears the screen it updates the
15:39 - paddle and then it redraws the paddle
15:41 - and then again it calls the game loop
15:43 - again with the next frame's timestamp
15:50 - now let's create a simple input handler
15:51 - to listen to a couple key events for
15:53 - moving the arrows left and right these
15:56 - will be used to move the paddle left and
15:57 - right on the screen
15:59 - let's create a new file
16:02 - call it input.js
16:04 - and then here we'll have a new class of
16:06 - input handler
16:10 - and let's give it a constructor
16:19 - and let's export this
16:22 - so now in our index.js file we can
16:24 - simply import it
16:31 - there we go
16:33 - all right so what should this thing do
16:34 - let's just add an event listener for
16:36 - listening to a key down event on the
16:37 - arrow keys
16:39 - document.add event listener
16:42 - we're going to listen to key down
16:45 - and we're going to give it a
16:47 - function that passes the event
16:51 - and let's just alert the event.keycode
16:57 - in our index.js file all we need to do
16:59 - is instantiate it before the game loop
17:01 - so new input handler
17:06 - if i push the left arrow key we get 37.
17:10 - if i push the right arrow key i get 39.
17:14 - that's great so now we just need to make
17:17 - a little switch here
17:19 - event.keycode
17:23 - so we're going to do different things
17:24 - based on the keycode so if we have
17:27 - 37 this is going to
17:30 - move left
17:34 - and if we have 39
17:39 - we're going to move right
17:42 - we can get rid of this alert
17:45 - all right let's check it out so left
17:47 - arrow key move left
17:49 - right arrow key move right
17:51 - next we need to tell the paddle how to
17:53 - handle these movements
17:59 - next let's actually move the paddle with
18:01 - a
18:02 - key down here so let's uh remove this
18:05 - alert and we're going to say we want to
18:07 - we want to call the paddle and we want
18:09 - to say move left
18:11 - we don't know what the paddle is so
18:12 - let's let's put it in our constructor
18:16 - and in our index.js file
18:18 - let's pass the paddle to our input
18:20 - handler
18:22 - all right now we need to create the move
18:24 - left function on our panel
18:26 - so let's say here move left
18:30 - and what's going to happen here
18:32 - let's say we have the paddle has a max
18:34 - speed
18:36 - let's set it to 10
18:38 - and the current speed that it is moving
18:40 - is zero
18:43 - all right so when we move left we want
18:45 - this speed to be equal to
18:48 - negative max speed so it'll be moving at
18:51 - negative 10 pixels per second
18:54 - in our update function
18:56 - we now want to say this dot position dot
18:59 - x
19:00 - plus this dot speed
19:02 - so when we tell it to move left the
19:04 - speed becomes negative 10
19:07 - and then when we update the x position
19:10 - gets
19:11 - moved a minus 10 amount
19:13 - let's try it out
19:17 - there we go so the paddle's moving i
19:19 - want to slow it down a little bit here
19:21 - maybe move it to 7
19:23 - and the other issue is
19:25 - once it gets to the edge of the screen
19:28 - it keeps going we want to make sure
19:30 - that it cannot leave the bounds of our
19:32 - game
19:34 - so what we'll say here is we'll say if
19:37 - dot position
19:38 - dot x is less than zero
19:43 - this.position.x
19:44 - will be set to zero
19:49 - there we go now it stops when it hits
19:50 - the edge of the screen
19:52 - now all we have to do is do our move
19:54 - right and we'll be done
19:56 - so right here we'll say paddle dot move
19:59 - right
20:00 - go into our paddle class make a move
20:03 - right function
20:05 - this dot speed
20:07 - equals this dot
20:09 - max speed
20:10 - so it sets it to the positive seven we
20:13 - have here
20:18 - whoops let's refresh that
20:21 - so there we go we can move it left we
20:23 - can move it right
20:24 - but again just like with the left bounds
20:27 - we need to make sure that it can't go
20:29 - off the right side of the screen
20:32 - so if this.position.x
20:36 - plus this dot width is greater than
20:40 - the game width which do we have here
20:45 - we do not have so let's let's save this
20:47 - here this that game width
20:50 - was game width
20:53 - and this that game well we don't need
20:55 - the height here so let's just stick with
20:56 - the game with
20:58 - if the position plus if the x position
21:01 - plus the width of the paddle is greater
21:03 - than the game width
21:06 - then this stop position dot x is equal
21:09 - to this dot game width
21:12 - minus this dot width
21:15 - now does that make sense
21:19 - let's move it to the right
21:22 - so if the x position plus the width of
21:24 - the paddle is
21:26 - past the edge of the game screen
21:28 - we set the x position right here where
21:30 - the x position plus the width will line
21:33 - up perfectly with our game screen
21:39 - all right now let's work on stopping the
21:41 - paddle when the player releases a key so
21:44 - let's just copy this real quick
21:49 - but instead of key down we're going to
21:51 - do key up
21:54 - and let's just change this to stop so if
21:58 - we release one of these keys we're going
22:00 - to stop the paddle
22:01 - so let's just create a quick function in
22:03 - here
22:04 - stop
22:06 - this dot speed equals zero
22:09 - let's try it out
22:16 - all right that works great but here's a
22:18 - problem if i'm pushing left and then i
22:20 - push right and i'll release the left key
22:25 - it kind of stops for a second
22:31 - so what we need to do is we need to make
22:33 - sure that it's moving in the same
22:34 - direction that we're releasing
22:38 - so if we release the left key
22:40 - we need to say if paddle dot speed is
22:44 - less than zero so if it is traveling
22:46 - left we will stop
22:48 - if we release the right key we need to
22:50 - check if the paddle dot speed
22:54 - is greater than zero
22:56 - so if it is traveling right and we
22:57 - release the right key it'll then stop
23:00 - let's try it
23:04 - there we go no stuttering
23:07 - now it works as intended
23:13 - all right next let's learn how we can
23:14 - draw an image onto our canvas
23:17 - first we need an image so let's go and
23:19 - create a new directory called assets
23:22 - and maybe in there we'll create a new
23:25 - folder called images
23:27 - and in here let's go ahead and
23:31 - upload a file
23:35 - see i have a ball.png file here
23:38 - i am a terrible pixel art so please
23:40 - forgive me
23:42 - all right so we have our ball
23:44 - now we need to load the image into html
23:47 - so let's go in here and let's just say
23:49 - image source equals
23:51 - assets images ball.png
23:57 - alright so we have our ball showing up
23:58 - on our page but we want it in our canvas
24:01 - so let's give it an id of image ball
24:05 - and let's also just hide it from the web
24:08 - page so all images
24:10 - will be display
24:12 - none
24:15 - all right so now that we have it here
24:16 - even though you can't see it we can grab
24:18 - it using this id
24:21 - so let's go into our
24:23 - index.js file
24:26 - let's see here let's just put a spot
24:28 - here images
24:30 - we'll say let ball
24:32 - let's say image ball equals
24:35 - document.getelement by id and we'll pass
24:38 - it the
24:40 - id we gave it
24:44 - here so we have the image now whenever
24:48 - we want to draw it we can just say
24:50 - ctx dot draw image
24:53 - image ball
24:54 - and the position
24:59 - and there you go
25:01 - now maybe this size doesn't work for us
25:03 - maybe we want to bump it up to maybe 16
25:05 - by 16.
25:07 - so let's specify that here
25:11 - so we have the image the position x
25:13 - position y
25:14 - and the width and height of our ball now
25:17 - let's just simply refactor this into its
25:19 - own class so let's create a new file
25:21 - here
25:23 - ball.js
25:25 - and here we will export a default class
25:28 - of
25:30 - ball
25:31 - we're going to need a
25:34 - constructor
25:37 - and we're also going to need a draw
25:38 - function
25:40 - and later we'll also do an update
25:42 - function
25:45 - that is to do later
25:48 - all right so the constructor we need to
25:50 - get the image
25:52 - so we'll say this dot image equals and
25:54 - then we can grab this document get
25:57 - element by id
26:00 - pop that in there
26:02 - we can get rid of this
26:05 - and we can also grab
26:07 - this draw image
26:09 - and move it into our draw function
26:12 - we need to pass it the context
26:16 - and this will be this dot image
26:20 - so when we create the ball class it'll
26:21 - grab the image from the page and every
26:24 - time we want to draw it we'll draw it
26:25 - here
26:28 - so inside index we will import ball from
26:32 - source ball
26:36 - and let's say let ball equal new ball
26:43 - then in our game loop we need to draw
26:46 - the ball
26:50 - and there it is and now we have a new
26:53 - clean class that we can use to
26:55 - change the position of the ball as it
26:56 - moves around in our game world
27:02 - before we start moving the ball around
27:03 - on the screen let's just clean up a
27:05 - couple issues real quick in our index.js
27:07 - file we have a couple hard-coded values
27:10 - down here this should be the game width
27:13 - and this should be the game height
27:17 - also instead of just calling the game
27:18 - loop like this we can use the request
27:21 - animation frame
27:23 - and that will give us a valid timestamp
27:24 - which means we can go to our
27:27 - padljs file
27:29 - and in our update function
27:32 - we can get rid of this check here
27:36 - let's make sure everything still works
27:39 - all right
27:40 - let's move on to moving the ball
27:43 - let's go to our ball class
27:45 - our update function is going to take a
27:47 - delta time
27:49 - so we can know how far to move
27:51 - let's set the speed
27:54 - and let's just hard code it for now and
27:56 - we'll adjust it based on which direction
27:57 - it's moving later
27:59 - let's give it an x speed
28:01 - and a y speed
28:11 - all right now on our update function we
28:12 - can just say
28:14 - let's see here we also need a position
28:17 - so let's do
28:19 - this.position
28:22 - let's give it an x of 10 and a y of 10.
28:30 - now in our update function we can say
28:32 - this dot position
28:34 - dot x
28:35 - plus equals this dot speed dot x and
28:39 - this dot position dot y plus equals this
28:42 - dot speed dot y
28:46 - and in our draw function we need to
28:48 - update it so that it is drawn at
28:51 - this.position.x
28:54 - and this.position.y
28:58 - let's go back to index let's make sure
29:00 - we're oh we're not updating it so let's
29:03 - say ball dot update pass in the delta
29:06 - time
29:09 - and there we go we have our ball moving
29:12 - all right now let's clean up these extra
29:15 - hard-coded values right here
29:18 - so let's give the ball a
29:21 - size
29:22 - set to 16
29:24 - and we'll set both of these
29:26 - to this dot size oops
29:37 - there we go
29:39 - so we're going to draw the image with
29:40 - its position and its size
29:42 - now if there's any power ups that might
29:44 - change the size of the ball we can
29:45 - simply just change the value and it'll
29:46 - draw it at a different size
29:50 - now we need to worry about bouncing off
29:52 - the walls
29:54 - just like the paddle we'll need to take
29:55 - in the game width and the game height so
29:58 - we know where the walls are at so back
30:01 - in our index.js file
30:04 - when we instantiate the ball we're going
30:06 - to give it game width
30:08 - and game height
30:19 - alright so now the ball knows how big
30:21 - the game world is let's talk about the
30:24 - collisions here
30:27 - in our update function
30:29 - we'll need to say
30:30 - if
30:31 - this dot position.x so it's already been
30:34 - moved if it's greater than
30:37 - this that game width
30:40 - or if
30:42 - this.position.x is less than zero
30:46 - we need to reverse the speed on the
30:48 - x-axis
30:55 - all right now we need to do the same
30:57 - thing for
30:58 - y
31:00 - if the position y is greater than the
31:03 - game height
31:04 - which later will change this to either
31:06 - be the game over or you lose your try
31:09 - and if the position y is less than zero
31:14 - the speed y gets reversed
31:17 - let me change this to speed x
31:22 - all right let's see if it bounces off
31:24 - the bottom wall here
31:27 - there we go
31:29 - i can't quite see the edge of the canvas
31:38 - all right we need to adjust this just a
31:40 - little bit
31:41 - on the y
31:42 - we need to say if this position y
31:44 - plus this dot size
31:47 - is greater than the height
31:53 - there we go
31:54 - same thing on the right
31:56 - if the position x plus this dot size
32:02 - let's uh let's bump up the speed a bit
32:09 - all right looking good
32:14 - let's do a little bit of refactoring
32:16 - right now we're passing two parameters
32:18 - to both the ball and the paddle we're
32:20 - passing the game width and the game
32:22 - height
32:23 - if we're going to pass more parameters
32:24 - like the ball might need to know where
32:26 - the paddle is we're starting to just
32:29 - chain on more and more parameters to
32:30 - these constructors
32:32 - that is a sign that things need to be
32:34 - refactored and cleaned up a bit so let's
32:36 - take care of that
32:38 - let's go ahead and create a new file
32:41 - we'll call it game.js
32:45 - export default class game
32:49 - all right so this guy
32:50 - is going to be in charge of managing all
32:53 - this for us
32:54 - so let's go to index.js
32:57 - let's uh
32:59 - get rid of the ball paddle and input
33:02 - handler and let's move it out to this
33:04 - new class
33:06 - so let's give it a constructor
33:09 - we're going to need to pass it the game
33:11 - width
33:12 - and the game height
33:17 - so right here we'll say this dot game
33:19 - width equals game width
33:21 - and this dog game height equals game
33:24 - height
33:26 - alright
33:28 - now instead of passing the ball and the
33:30 - paddle the game width and game height
33:33 - we'll just pass it an instance of this
33:40 - let's move this out into a new function
33:45 - call it the start function
33:48 - so when we're ready for our game to
33:49 - start we will instantiate these objects
33:52 - we'll have our ball we'll have our
33:53 - paddle and we'll have our input handler
33:58 - now let's go ahead and import these guys
34:04 - so our paddle input handler and ball
34:07 - now let's refactor our paddle and ball
34:09 - class
34:11 - instead of taking game width and game
34:13 - height we're just going to take the game
34:15 - object
34:16 - our game width will be our game dot game
34:19 - width the game height will be game dot
34:21 - game height
34:24 - same thing for our paddle
34:26 - we'll just take in a game object
34:30 - game dot game width game dot game height
34:34 - and this needs to know the game that
34:36 - game width as well
34:41 - all right
34:43 - now let's create our game object
34:46 - a game equal new game
34:50 - pass of the game with
34:51 - pass the game height
34:54 - game dot start
34:57 - that'll instantiate it
35:00 - and we need to import it
35:10 - all right next we have this game loop
35:12 - trying to update and draw our objects so
35:16 - let's uh let's take this out
35:19 - and what if we just said game.update
35:23 - and game.draw
35:25 - those functions don't exist yet so let's
35:27 - uh let's take care of that
35:30 - so we'll do an update
35:33 - and a draw function
35:37 - now what we had before is we had paddle
35:39 - update paddle draw so let's just move
35:41 - these around
35:43 - to update we're going to update
35:45 - this paddle
35:48 - and then we're going to draw the paddle
35:49 - in this function
35:53 - same thing with our ball
35:55 - let's update the ball
35:59 - and let's draw the ball
36:08 - next we need to know the delta time so
36:09 - let's just pass it in
36:13 - and let's pass in our context
36:18 - let's go back to index.js and we'll pass
36:20 - in the delta time
36:24 - and the context
36:28 - now let's take a look at our errors here
36:31 - ah the paddle and ball don't exist on
36:32 - the object so let's just change this to
36:34 - this
36:43 - there we go right back to where we
36:45 - started
36:48 - now as we make more and more objects
36:50 - such as all the bricks we don't want to
36:51 - have to say this.brick.update
36:57 - we're just writing the same thing over
36:58 - and over again so let's uh let's clean
37:00 - this up a little bit let's do
37:02 - this.gameobjects
37:05 - this is going to be an array
37:10 - we could just say here
37:13 - this.ball
37:14 - this dot paddle
37:19 - and then here instead of doing each of
37:22 - these we can just say
37:23 - this.gameobjects
37:25 - for each
37:27 - object
37:30 - object.update
37:32 - deltatime
37:38 - oh because we need to remove these guys
37:42 - same thing with draw
37:44 - this game objects
37:47 - for
37:48 - each object
37:52 - object.draw ctx
37:56 - so now any object we make all needs to
37:58 - do is have an update and a draw method
38:01 - and we can just add it here so if we add
38:04 - 40 bricks we just add the 40 bricks to
38:06 - this array
38:07 - and the rest of this game class takes
38:09 - care of it automatically for us
38:11 - so a quick review
38:14 - our index j s file just starts a new
38:17 - game by instantiating a game object
38:20 - telling it to start
38:22 - and then in our game loop
38:24 - we clear our screen and we tell the game
38:27 - to update and draw
38:29 - and our game class
38:32 - it now passes its own instance to the
38:35 - object so that they can get any
38:38 - information they need so the ball can
38:40 - get information as to where the paddle
38:42 - is located on the screen
38:44 - then we just put all the game objects
38:46 - into an array and we have an update and
38:48 - a draw function that handle
38:50 - updating and drawing all of our game
38:51 - objects in our world
38:57 - now that we have our refactoring out of
38:58 - the way and we have everything wrapped
39:00 - up into a game class let's handle the
39:02 - collision between the ball and the
39:03 - paddle
39:04 - inside of our ball class we're given the
39:06 - game let's just make sure we have it
39:08 - here available for the ball to use
39:14 - now we can use the game within any of
39:16 - our other functions
39:19 - just to prove a point inside of our
39:21 - update function let's do a console log
39:27 - dot this.game.padle.position
39:28 - dot x
39:30 - so now every update we're gonna log
39:32 - where the paddle is even though we're
39:34 - currently looking at the ball object
39:41 - as i move the paddle left and right you
39:43 - can see
39:44 - the position is being printed out at the
39:47 - current value
39:49 - our update function currently updates
39:50 - the position of the ball and checks to
39:52 - see if it is hitting
39:54 - a wall
39:57 - on the left or right
39:59 - of the screen
40:01 - and we also check to see if it hits a
40:02 - wall on the top or bottom
40:07 - so now let's check with the paddle
40:15 - now the ball is always going to collide
40:16 - with the paddle with the bottom of the
40:18 - ball hitting the top of the paddle
40:20 - so let's say bottom of ball equals this
40:24 - dot position dot
40:26 - y
40:30 - plus this dot
40:34 - believe its size
40:36 - yes this dot size
40:41 - and let's do the top of paddle equals
40:43 - this dot game dot paddle dot position
40:46 - dot y
40:50 - now that we have this information we can
40:52 - start with our collision check
40:54 - if the bottom of the ball
40:56 - is greater than or equal to the top of
40:58 - the paddle
40:59 - so we're hitting the paddle we want to
41:01 - reverse the speed
41:07 - and we also want to set the ball so it's
41:09 - just
41:10 - touching the paddle
41:12 - so the position y is equal to this game
41:16 - paddle
41:17 - position y
41:19 - minus
41:22 - the size
41:24 - so now we take a look when the ball
41:26 - comes down and it hits the paddle
41:29 - it'll bounce right off of it
41:33 - all right now here's an issue all we're
41:35 - doing right now is checking where it's
41:37 - at on the y-axis so if it's left of the
41:39 - paddle it still bounces off
41:41 - so we need to know
41:44 - if the ball is actually hitting within
41:45 - the bounds of the paddle
41:50 - let's do left side of paddle is this
41:54 - game.paddle.position.x
41:58 - and let's do
42:00 - right side of paddle equals this game
42:04 - paddle
42:05 - position x plus
42:07 - this game paddle
42:09 - width
42:11 - so now we know where the left and right
42:13 - sides of the paddles are
42:15 - let's extend our if statement here
42:18 - so if the bottom of the ball is greater
42:20 - than the top of the paddle
42:21 - and
42:23 - this stop position dot x is greater than
42:26 - or equal to the left side of the paddle
42:29 - and if this dot position
42:32 - dot x plus the size
42:34 - is less than or equal to the right side
42:36 - of the pedal
42:40 - get rid of that
42:44 - let's try it out
42:46 - let's see if we can still bounce the
42:47 - ball off the paddle we can
42:52 - now let's see if it goes to the left
42:54 - side of the paddle
42:58 - all right it does pass through and hit
42:59 - the the ground which will end the game
43:01 - now let's check the right side of the
43:02 - paddle just to make sure that is working
43:04 - as well
43:08 - all right so we now have a basic
43:11 - collision between the ball and the
43:12 - paddle working and we can bounce the
43:14 - ball back towards the bricks that we
43:16 - will build soon
43:21 - all right let's introduce some bricks to
43:23 - the game as you can see i've already
43:24 - loaded a brick png file here into our
43:27 - images folder
43:29 - let's load that into our index.html
43:41 - now let's create a new class
43:51 - class 18 constructor
43:54 - it will need an update function
43:58 - and a draw function
44:03 - all right let's just copy some code from
44:05 - our ball class here
44:13 - pass in the game
44:14 - [Music]
44:15 - i'm going to get image brick
44:20 - i don't need this
44:22 - we will set the position in the
44:25 - constructor
44:32 - will not have a speed because it's not
44:34 - moving
44:36 - and instead of size we'll have a width
44:40 - let's just say
44:41 - 52
44:42 - and a height of 24.
44:46 - in our draw function we'll need to take
44:47 - the context
44:50 - we'll draw the image the position
44:53 - and the width
44:55 - and the height
45:02 - all right now let's start uh adding
45:04 - these bricks to the game
45:07 - in our game class
45:09 - all right let's first import the brick
45:16 - now let's create a new brick for an
45:17 - example
45:21 - give it a position
45:26 - and let's add it to our game objects
45:30 - all right so we now have a brick loaded
45:32 - into our game
45:33 - let's just see how easy it is to make
45:35 - lots of bricks
45:38 - our brick width was 52
45:41 - so let's do this
45:43 - that bricks equal a new array
45:49 - let's do a loop of
45:51 - 10 times
45:54 - and for each one we will push
45:57 - a new brick object
46:01 - position of x will be i times 52
46:04 - and the y position will be let's say 30.
46:09 - now to add an array to an existing array
46:12 - we can just use a spread operator
46:19 - alright so that's all that's needed to
46:20 - have a bunch of bricks displayed into
46:22 - our game world
46:27 - now this is not a whole lot of fun
46:29 - building a loop and manually pushing
46:30 - these bricks we want to have different
46:32 - levels with different arrangement of
46:34 - bricks so let's go ahead and take care
46:35 - of that now
46:38 - let's create a new file
46:43 - and let's define what a level looks like
46:47 - so level one is going to be an array of
46:50 - arrays
46:51 - so
46:52 - let's just uh write it out and then i'll
46:54 - explain what we're doing here
47:03 - so decided i want to do 10 bricks per
47:05 - row
47:11 - so as you can see here we have four
47:13 - arrays within the level array each one
47:15 - corresponding to a row
47:17 - with ones and zeros
47:19 - so what i'm going to do here is anytime
47:21 - there's a one that'll become a brick a
47:24 - zero is just going to be an empty space
47:26 - so for this first level we'll have
47:29 - you know three rows of full bricks and
47:31 - then the top row uh we'll just have some
47:33 - bricks here and there
47:35 - now we need a function to actually turn
47:37 - these levels into the bricks
47:41 - so we'll need to know about a brick
47:47 - and we'll also need a function that will
47:49 - build it
47:55 - now this function needs to know what
47:57 - level you're using
47:58 - so you'll pass it the level
48:00 - and it will create a bunch of bricks
48:06 - all right so let's start working on this
48:15 - so let's loop through our level to get
48:17 - each row
48:19 - and then for each row
48:22 - we'll get a brick
48:30 - and now we will create our brick so
48:32 - let's take a look at our brick
48:33 - constructor
48:34 - brick takes the game and the position
48:39 - so we'll need to also pass in the game
48:41 - here
48:47 - all right so if the brick equals one
48:51 - so if it is set to be
48:53 - added to the game
48:55 - we will say bricks dot push new brick
48:58 - pass of the game and the position
49:02 - we need to create the position
49:08 - let's leave that as a placeholder for
49:10 - now
49:12 - so our x and y what are we going to do
49:14 - here so our full game width is 800
49:18 - we're doing eight bricks per row
49:23 - so let's change our brick size to 80. so
49:26 - 80 times 10 is 800
49:29 - we have the height of 24
49:32 - so if we go back to our levels
49:35 - x
49:36 - will be
49:38 - 80 times the brick index
49:42 - the
49:42 - y
49:44 - let's start it at 20 from the top
49:47 - plus
49:48 - 24 times the row index
49:53 - all right let's check it out and see if
49:54 - it works
49:55 - let's go into our game let's get rid of
49:58 - this
50:00 - let's import our
50:02 - level
50:04 - so we have build level and level one
50:07 - that we're going to import from
50:11 - levels
50:14 - now our bricks we're going to say
50:17 - build level
50:19 - we're going to pass it the game
50:21 - and level 1.
50:27 - and we need to remember that we should
50:29 - return the bricks back to the game
50:35 - there our first level has been built
50:37 - and now we have a simple place that we
50:39 - can go in here and we can modify our
50:42 - level
50:44 - so we could change it a little bit
50:52 - just change this top row some
50:56 - and now we have a completely different
50:57 - look
50:58 - let's move the bricks a little further
51:00 - away from the top of the game
51:02 - so let's go into our
51:04 - create levels
51:05 - let's bump this up to 50.
51:09 - maybe 75.
51:12 - there you go now we have room once you
51:14 - break through to have it bounce up
51:15 - against the ceiling there
51:18 - and we have our level creator complete
51:25 - so we now need to detect the collision
51:27 - between the ball and each brick of the
51:29 - game
51:30 - now right now our ball class has some
51:33 - collision detection between the ball
51:35 - itself and a paddle which is a rectangle
51:38 - just like a brick so i'd like to reuse
51:39 - this code
51:41 - but it's best not to copy and paste it
51:43 - let's put it someplace reusable
51:45 - let's copy this
51:47 - let's create a new file i'll call it
51:50 - collision detection
51:56 - now let's just export a function
52:02 - and we'll need the ball and a game
52:05 - object
52:07 - let's go ahead and paste our code in
52:09 - here
52:11 - so we have the bottom of the ball we're
52:13 - also going to need the top of the ball
52:20 - we have the top of the game object
52:27 - we have the left side of the game object
52:34 - and we have the right side of the object
52:40 - we also need the bottom of the object
52:56 - all right now instead of this we need to
52:59 - refer to the ball
53:04 - and instead of the the game paddle
53:08 - we need to refer to the
53:11 - game object itself
53:22 - all right now let's update our if
53:24 - statement
53:25 - if the bottom of the ball is greater
53:27 - than or equal to the top of object and
53:30 - the top of the ball is less than or
53:33 - equal to the bottom of object
53:39 - and the ball position x is greater than
53:42 - or equal to the left side of object and
53:44 - the ball position x plus the ball size
53:48 - is less than or equal to the right side
53:49 - of the object
53:50 - then we're going to do whatever we need
53:52 - to do
53:53 - so instead of this we're just going to
53:55 - return true
53:58 - otherwise we'll turn false
54:01 - this function is only telling us if
54:03 - there's a collision and not what to do
54:04 - with it
54:09 - now let's go back into our ball file
54:13 - let's import this function at the top
54:21 - called the function detect collision
54:29 - now down here
54:32 - at our where we're doing our collision
54:34 - detection
54:35 - we'll remove all of
54:36 - this and instead say if detect collision
54:41 - i'm going to pass it the ball which is
54:43 - this
54:44 - and the paddle game.paddle
54:53 - let's make sure that still works
54:58 - it does
55:00 - so that's a successful refactor
55:02 - now it'll be easy for us to detect
55:04 - collision with the bricks
55:07 - let's go into the brick clasp go into
55:10 - our update function here
55:13 - first we need to import our function
55:24 - then we will just say if
55:26 - detect collision
55:28 - between the ball
55:30 - and the object which is the brick itself
55:35 - let's tell the ball to reverse the y
55:38 - speed
55:46 - let's check that out
55:49 - as you can see it's bouncing off the
55:51 - bricks here at the top of our screen
55:55 - now we need to just remove the brick
55:56 - from the game once it's been hit
55:58 - so i'm going to
56:00 - add a property here
56:06 - called marked for deletion
56:09 - once it's been hit we will mark it true
56:15 - now our game is going to be responsible
56:16 - for removing these bricks from the game
56:20 - so in our games update function we're
56:23 - going to update all the objects
56:25 - then
56:28 - we're going to filter it down to the
56:29 - ones that are not marked to for deletion
56:47 - and there we go we have successfully
56:49 - made it so that the ball can bounce off
56:51 - the bricks and destroy them
56:56 - we're going to work with pausing the
56:58 - game first let's update the ball so it
57:01 - doesn't start above the bricks but down
57:03 - here so that it's not trapped
57:05 - let's go into our ball file
57:09 - let's set the y position to 400
57:13 - and let's set the
57:15 - speed to a negative two
57:17 - there we go
57:19 - all right now let's go into our input
57:21 - handler
57:22 - we're going to need a new input here
57:26 - uh key code 27 is the escape key that's
57:28 - what we're going to use to pause the
57:30 - game
57:31 - so we'll do here is we'll say game
57:33 - dot pause
57:34 - or let's say toggle pause because they
57:36 - could unpause the game as well
57:39 - so this class doesn't know what the game
57:41 - is so let's pass it into the constructor
57:46 - all right now let's go into our game
57:47 - class
57:49 - this is where we'll do the remaining of
57:51 - the work
57:52 - all right so our input handler we need
57:54 - to pass in the game which is this
57:58 - and we need a new function called toggle
58:00 - pause
58:04 - so we're going to introduce here is game
58:06 - states a game state is going to tell the
58:08 - game where it's at is it paused is it
58:11 - running is it at the title screen the
58:13 - game over screen
58:14 - we're going to be working with this for
58:16 - a few episodes
58:17 - let's go ahead and create here a
58:20 - constant
58:23 - and we're going to define all of our
58:25 - states
58:26 - so we'll have paused
58:29 - give that a value of zero
58:32 - running for when the game is running
58:36 - the menu
58:37 - and also game over
58:42 - all right so we're only going to work
58:43 - with pause and running for today
58:46 - when we start a game we want to set the
58:49 - game state equal to game state
58:51 - running
58:53 - later we'll start the game at the menu
58:55 - but for now we're going to keep it the
58:56 - way it's running right now
59:03 - next we need to toggle pause so if this
59:06 - game state
59:08 - is
59:09 - paused
59:13 - we're going to set the game state
59:18 - to running
59:20 - so it's paused and they click the pause
59:22 - button it'll unpause the game
59:26 - otherwise
59:30 - we're going to pause the game
59:33 - now right now it's not doing anything
59:35 - because we're not telling the game to
59:36 - stop running when we hit the pause
59:38 - button
59:40 - so inside of update function let's just
59:42 - say
59:44 - if this game state
59:48 - is
59:49 - paused
59:52 - we're not going to update anything
59:55 - so right there i just hit the escape key
59:56 - and the game is frozen hit it again and
59:59 - it starts running again
60:05 - all right now let's do a little display
60:08 - to show that the game is actually paused
60:09 - and not frozen
60:12 - so inside of our draw function we still
60:14 - want to draw everything even though the
60:15 - game's paused
60:18 - let's first shade the whole screen so
60:20 - it's a little darker so let's see here
60:22 - we have our context
60:25 - let's create a rectangle
60:27 - that covers the whole screen
60:34 - let's fill it
60:38 - let's do an rgba so we can do black but
60:41 - with
60:42 - 50 opacity so you can see through it
60:47 - and let's fill it
60:49 - so there we go but we only want this to
60:50 - show when we're paused so let's just do
60:54 - if this game state
60:58 - is
60:59 - paused
61:07 - and now if i pause the game it shades it
61:10 - gray unpause it and goes back to white
61:14 - let's add a little bit of text as well
61:18 - let's create a font of 30 pixels aerial
61:23 - let's fill it
61:29 - let's fill it white
61:33 - let's align it center
61:36 - and let's let's
61:38 - let's fill it and position it
61:41 - so we say fill text
61:44 - paused
61:46 - and we're going to put it
61:47 - 50
61:48 - on the x-axis and y-axis so
61:51 - the x will be our game width over 2
61:54 - and the y will be our game height
61:57 - over 2.
61:59 - let's pause the game
62:01 - and unpause it
62:05 - all right now we can pause and pause the
62:07 - game
62:11 - so the next thing we need to do is add a
62:13 - menu screen here so that the game will
62:16 - not just start right away but the user
62:17 - will be able to hit the space bar and
62:20 - start the game
62:21 - so we already have our game state menu
62:23 - set up here
62:25 - so let's start the game
62:28 - when we start the game we'll start it at
62:29 - menu
62:31 - next we need to go down to our update
62:34 - we don't want to update anything if it
62:36 - is paused or if this game state
62:43 - is at the menu
62:48 - let's change these to triple equals
62:53 - there we go
62:57 - next in our draw function
63:00 - we have our pause state drawing here
63:03 - let's make a new one for the menu
63:10 - let's update these comparators
63:14 - let's make it a solid black
63:18 - and in our text
63:20 - instead of pause we will say
63:23 - press spacebar
63:27 - to start
63:30 - there we go
63:33 - now we need the input handler to trigger
63:36 - the start of the game
63:38 - let's go into our files let's go into
63:40 - input
63:44 - case 32 i believe is a spacebar
63:47 - game.start
63:50 - now we're going to need to modify our
63:52 - game a little bit
63:57 - so when we start this is when the game
63:59 - is actually going to start when the
64:02 - game is created we need to set up some
64:04 - things so we'll move this stuff up to
64:06 - our constructor
64:10 - the bricks will be built when the first
64:12 - level is loaded the game objects will be
64:14 - loaded when the game is started
64:16 - input handler needs to be moved up here
64:24 - let's clean this up a little bit
64:28 - all right so that should be everything
64:30 - we need to start the game
64:34 - let's go ahead and try it
64:36 - hmm nothing happens
64:38 - oh yes the last thing we need to do here
64:40 - is when we start the game is we need to
64:42 - change the game state
64:44 - to
64:46 - running
64:49 - let's refresh
64:56 - all right now what is also calling this
64:58 - start here let's go look at our
65:01 - index.js file ah yes we're immediately
65:04 - calling the game start when we load the
65:06 - the page
65:07 - let's remove that
65:10 - now we have an error on our draw
65:12 - function
65:14 - the issue is that the game objects has
65:16 - not been initialized yet
65:19 - so let's do that here
65:22 - set it equal to an empty array
65:27 - all right we now have our menu screen if
65:29 - i hit space the game will start and
65:31 - everything works
65:32 - the way we expect it
65:34 - if i hit space again though you'll
65:36 - notice that it actually rebuilds the
65:38 - level
65:40 - so let's fix that real quick
65:48 - if
65:50 - this.gamestate
65:52 - is not equal to
65:54 - the menu
65:56 - then we will return
65:58 - so only the menu can trigger the start
66:00 - of the game
66:03 - let's try this again
66:05 - there we go it doesn't rebuild the level
66:07 - automatically
66:12 - let's now handle the game over state
66:16 - all right so the game should have a
66:18 - number of lives or balls or or tries i'm
66:22 - going to call it lives
66:24 - i'm going to set it to one for now so we
66:26 - can test this
66:29 - now let's go down to our update function
66:34 - if
66:35 - this dot lives
66:37 - equals zero
66:39 - this dot game state
66:41 - will be equal to
66:43 - game over
66:45 - so we run out of lives we end the game
66:49 - and we don't want to update anything
66:51 - else if it is game over
66:58 - so there we go
66:59 - once we hit game over
67:00 - the update will stop running
67:02 - now we just need to draw our game over
67:05 - screen
67:07 - let's just
67:08 - copy this here
67:10 - from our menu
67:12 - and we will say game
67:15 - over
67:19 - just need to add an extra brace there
67:22 - there we go so we have our game over
67:24 - screen built
67:25 - uh let's just test it real quick to see
67:27 - what it looks like
67:38 - there we go just need to fix some
67:39 - brackets
67:46 - let's format the document
67:49 - so this is what it'll look like
67:51 - now we need to actually get the game to
67:53 - go to the game over state once the game
67:55 - is lost
67:57 - so let's change this back to menu
68:02 - now inside of our ball class
68:05 - we're checking collisions with both the
68:07 - top and the bottom
68:10 - we just want to check
68:11 - a wall on top
68:13 - so if the position of the ball is plus
68:16 - the size is greater than the game height
68:18 - that's the bottom of the game
68:21 - so let's cut this out
68:29 - if
68:30 - we hit the bottom of the game
68:33 - do we have access to the game here
68:36 - we do
68:39 - this.game.lives minus minus
68:43 - all right let's try it out
68:46 - i'm going to start the game
68:48 - i'm going to purposely let it hit the
68:50 - bottom here
68:53 - game over
68:55 - perfect
68:59 - now what's going to happen when the ball
69:01 - gets below
69:02 - the game
69:03 - now we're going to lose a life but it's
69:05 - immediately going to game over even
69:06 - though we have three lives set here
69:09 - that's because the ball is never being
69:10 - reset
69:18 - let's grab this here i'm going to pull
69:21 - this
69:22 - out
69:23 - and i'm going to create a function
69:25 - called reset
69:34 - so that will reset our position and
69:36 - speed
69:37 - so down here oops
69:40 - when we lose a life
69:43 - we will call reset
69:50 - let's try it out
69:53 - so it should go below the screen
69:57 - it'll reset
69:59 - so now we're down to two lives
70:04 - and i reset we have one life remaining
70:10 - game over
70:16 - now the last thing we're going to do in
70:17 - this series is allowing the player to
70:19 - complete a level and move on to the next
70:21 - level so let's see how we can do that
70:24 - right now we have a bunch of bricks
70:25 - loaded into our level
70:27 - and i've updated my level here so we
70:29 - only have one brick that's easy to clear
70:31 - and we can move on to the next level and
70:33 - make sure everything works
70:36 - the problem is since the bricks are
70:37 - loaded into these game objects we don't
70:40 - know
70:40 - when all the bricks have been destroyed
70:43 - so let's create a new array for the
70:44 - bricks
70:48 - and let's just load them in here
70:52 - so this dot bricks is build level
70:55 - we'll pull the bricks out of our game
70:56 - objects
70:59 - now in our update function
71:02 - we still want to loop over all of our
71:04 - game objects and update them and the
71:06 - same for our draw we want to go over all
71:07 - of our objects and update them or draw
71:10 - them
71:11 - so what we can do
71:14 - is we can have an array here called
71:18 - dot dot this dot game objects
71:22 - and dot dot dot this dot bricks
71:25 - so that's going to spread the game
71:27 - objects and the bricks together into one
71:28 - array
71:30 - and then we can do the same thing here
71:32 - we did before let's make sure that works
71:36 - it does for the update but let's make
71:38 - sure we can draw as well
71:41 - so instead of this game objects we're
71:43 - going to spread the game objects
71:46 - as well as the bricks
71:50 - let's take it up
71:54 - all right so we're able to bounce off
71:56 - the brick just fine however it's not
71:58 - clearing the brick
72:00 - it's not clearing the brick because our
72:03 - check here to remove any objects that
72:06 - are marked for deletion is only checking
72:08 - the game objects
72:10 - we really just needed to check the
72:11 - bricks
72:16 - rename this to brick
72:19 - see if that works
72:22 - there we go we cleared our brick
72:25 - now let's check to see if all the bricks
72:27 - are gone
72:30 - so inside of our update
72:33 - we can say if
72:34 - this.bricks.length
72:38 - equals zero
72:41 - new level will need to be loaded in here
72:46 - let's take a look
72:49 - once the brick is destroyed our console
72:51 - is logging so that is working
72:54 - now how do we actually load the new
72:56 - level
72:57 - well let's create a new level real quick
73:01 - i'm just going to make it a duplicate of
73:03 - level one
73:09 - uncomment these
73:12 - so we have our level two
73:14 - inside of our game let's
73:16 - import this guy
73:22 - and let's create an array of our
73:25 - levels
73:28 - so this dot levels is going to be level
73:30 - one and level two
73:33 - and this current level is going to be
73:36 - the index so remember arrays start at
73:39 - zero so the current level at zero will
73:41 - be level one
73:42 - once the level reaches level
73:44 - current level of one
73:46 - the array at
73:48 - index one is level two that will be
73:50 - loaded
73:52 - we will say this
73:54 - dot current level
73:56 - plus plus so we'll increment the current
73:58 - level
74:03 - and then we will need to run the start
74:05 - function again
74:11 - now start function needs to know what
74:13 - current level we are on
74:16 - so we'll say this dot levels
74:18 - at this dot current level
74:22 - see if that works
74:27 - all right so our level did not increment
74:30 - now last check here is we're checking to
74:32 - see if the game is at the menu
74:35 - if not it returns so that is why
74:37 - the new level is not being loaded
74:42 - so what we can do is we can make a new
74:43 - game state here
74:46 - let's just say new level
74:52 - so in our start we will return if it's
74:55 - not equal to the menu or if the game's
74:58 - state is not equal to
75:01 - new level
75:03 - there we go
75:05 - we also want the ball to be reset
75:13 - let's make sure we have that in here we
75:14 - do have a reset function that we built
75:16 - last episode
75:18 - so reset the ball set the game objects
75:21 - get the bricks
75:22 - the last thing we need to do is before
75:24 - we call start we will say this.gamestate
75:28 - equals gamestate.newlevel
75:32 - let's check it out
75:43 - and change this to and
75:48 - we have a new level
75:50 - and that's all it takes to load in a
75:52 - second level after completing the first
75:54 - i hope you've enjoyed this game dev
75:56 - series and i hope it's taught you a lot
75:58 - on how to build a game i know this is
76:00 - the very basics there's
76:02 - some bugs there's a lot of things that
76:03 - we can do with this game but i wanted to
76:05 - keep it simple so that we could go over
76:07 - the basic understanding of game
76:09 - development if you enjoyed the series
76:11 - make sure you hit the thumbs up and
76:12 - subscribe for more videos