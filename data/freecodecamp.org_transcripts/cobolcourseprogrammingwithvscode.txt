00:00 - [Music]
00:03 - hello there and welcome to your
00:05 - introduction to cobol no matter what
00:07 - brought you here we're glad to see you
00:09 - and hope that you enjoy all that went
00:11 - into creating these videos
00:13 - first things first what is cobalt well
00:16 - whenever there's an acronym i like to
00:18 - start there and cobalt is an acronym for
00:21 - common business oriented language
00:24 - that's a big tell right there right in
00:26 - the name this is a business language
00:29 - compared with other more general purpose
00:31 - languages cobol was designed around data
00:33 - processing specifically data processing
00:36 - with incredibly high accuracy extreme
00:39 - efficiency and ease of reading and
00:41 - writing
00:42 - cobol has indeed been around for over 60
00:45 - years as of this recording and surprise
00:48 - surprise the fundamentals of business
00:50 - being able to process very large amounts
00:52 - of data accurately and efficiently
00:54 - continue to be important so all of the
00:58 - transactions that happen when you're
00:59 - using a credit card visiting a store or
01:02 - doing pretty much anything with a bank
01:04 - there's a good chance some cobalt code
01:06 - got executed somewhere in there
01:08 - in fact every day about three trillion
01:12 - dollars in finance gets handled by
01:14 - cobalt so let's just make sure we're
01:17 - clear here cobalt pretty much runs the
01:19 - world it has been kept up to date to
01:21 - support new requirements throughout the
01:23 - years and 1.5 billion lines of new code
01:26 - are written every year
01:28 - suffice to say learning this language
01:31 - will give you a very valuable set of
01:33 - skills
01:35 - in this course you're going to be
01:36 - working with enterprise cobol which is
01:38 - an implementation written specifically
01:39 - to run on ibm z mainframes
01:42 - the banks insurance agencies energy
01:45 - companies retail chains that depend on
01:47 - cobalt to run their extremely important
01:48 - transactions
01:50 - guess what a whole lot of them also
01:52 - depend on ibm z mainframes to ensure
01:55 - their applications can keep up with the
01:57 - demand 24x7
01:59 - learning enterprise cobol says i want to
02:02 - work on the most important code running
02:04 - on the most important systems running
02:06 - the types of things that no exaggeration
02:09 - at all the world depends on
02:11 - that's a pretty bold statement and i
02:13 - have no problem at all saying it because
02:16 - it's the truth
02:18 - [Music]
02:26 - you might be thinking cobalt on the
02:28 - mainframe am i going to need punch cards
02:31 - and a tie to get through this well first
02:33 - of all
02:34 - no you'll be happy to know that we're
02:35 - going to be teaching all this with
02:37 - visual studio code which as of right now
02:40 - is the most popular editor used
02:42 - worldwide
02:43 - visual studio code or vs code for short
02:46 - supports something called language
02:48 - server protocol which simply put makes
02:50 - it able to support a very large number
02:53 - of languages and environments so the
02:55 - things you'd expect to be there like
02:57 - code completion workspace symbols hover
02:59 - text references and diagnostics can all
03:02 - be supported without it having to be
03:04 - specifically written into vs code itself
03:06 - it gains functionality through
03:08 - extensions which use the language server
03:11 - protocol or lsp
03:13 - we're going to use extensions for vs
03:15 - code that give us all the goodness for
03:17 - cobalt as well as allowing us to connect
03:19 - to a real live mainframe system so after
03:22 - you download and install vs code hop
03:25 - into the extensions marketplace and
03:27 - search for ibm z open editor and hit the
03:30 - install button while that's installing
03:33 - do the same for zoe explorer z-o-w-e
03:36 - that's the simple version of things for
03:38 - more detailed instructions on installing
03:40 - the extensions visit the book version
03:42 - for the full details and screenshots
03:44 - couple of basics once you're in you'll
03:47 - also notice these vertical lines very
03:49 - important for cobalt these are the
03:51 - margins those margins segment each line
03:54 - of cobalt code into its various parts
03:56 - which we'll get into later on just know
03:59 - that it's easier to see whether your
04:01 - text is starting right next to a line
04:03 - than it is to count empty spaces so
04:06 - lines good also if you hover your mouse
04:09 - over some fields a little pop-up box
04:11 - will appear showing you additional
04:13 - information just know that this will
04:15 - come in really handy when you really
04:16 - start hacking away at cobalt code later
04:18 - on and you may also notice that some
04:21 - words get displayed differently than
04:22 - others that's all part of syntax
04:25 - highlighting it just makes things a
04:27 - little bit easier to understand at a
04:28 - glance
04:29 - and this bar across the top that's the
04:32 - breadcrumb view it shows information
04:34 - about what line you're currently at
04:36 - click on any element in that breadcrumb
04:38 - trail and it will highlight the block of
04:40 - text for that element it'll also show
04:43 - you a little outline view of the code
04:45 - over here
04:46 - lastly down at the bottom of your screen
04:49 - there should be a panel with a problem
04:51 - section and if it's not there go up to
04:53 - view and select problems from the editor
04:56 - menu you can click on the problems it is
04:58 - found and it will jump right to those in
05:00 - the code it will find basic logical
05:02 - errors without you having to run or test
05:04 - your code it just knows about those
05:06 - problems ahead of time so you'll
05:08 - definitely want to fix those as they
05:09 - come up
05:11 - got all that i'd say you're ready to
05:12 - dive into some actual cobalt so let's go
05:16 - [Music]
05:24 - cobalt is an english-like computer
05:26 - language it's that way by design meaning
05:29 - it's fairly easy to read understand and
05:32 - maintain compared with other programming
05:34 - languages you'll find that each line of
05:36 - code is pretty transparent about what
05:38 - it's trying to do that's often the first
05:40 - thing people notice about cobol that
05:42 - what it's trying to do is very easy to
05:45 - figure out and you don't have to spend a
05:47 - whole lot of time tracing through code
05:49 - to make sense of it all
05:50 - that's thanks in part to cobalt being
05:52 - standardized so the way that a cobalt
05:55 - implementation should be approached is
05:57 - all described in great detail in that
06:00 - standardization
06:01 - now cobol has gone through several
06:03 - revisions over the years so you do need
06:06 - to keep in mind which particular
06:07 - standard you're working with
06:09 - particularly when you're working with
06:11 - code outside of this course but it
06:13 - mostly comes down to the addition of a
06:15 - few new features better support and
06:18 - small tweaks to fix problems cobalt
06:20 - written specifically for the ibm z
06:22 - mainframe operating system zos is said
06:25 - to be enterprise cobol the code you'll
06:28 - see here in this course is all
06:30 - enterprise cobol and it all gets
06:32 - compiled and executed differently than
06:34 - cobalt you might be writing for other
06:36 - platforms but it is also able to take
06:38 - advantage of hardware and operating
06:41 - system features unavailable anywhere
06:43 - else so it still follows the current
06:46 - cobalt standardization but it's written
06:48 - with enterprise systems in mind
06:51 - let's take a look at some of the basic
06:53 - cobol syntax at a high level so you can
06:55 - get a better feel for the cobol standard
06:58 - right up front one of the key aspects of
07:00 - cobalt some languages use spaces some
07:03 - use tabs cobalt is column dependent
07:06 - meaning it looks at a line of code and
07:08 - expects certain things to be at certain
07:10 - positions in that line
07:12 - specifically it's looking in five key
07:15 - areas of a 72 character line and those
07:19 - look like this
07:20 - the first section columns one through
07:23 - six are the sequence number area
07:25 - sometimes these are blank other times we
07:28 - use them to provide context to a series
07:30 - of statements
07:31 - the next section is the indicator area
07:34 - and it's a multi-purpose area if we're
07:36 - going to leave a comment an asterisk a
07:39 - star goes in here or if we're continuing
07:41 - a previous line it'll be a dash or a
07:44 - hyphen it can also be a d for a
07:47 - debugging line or a slash for source
07:50 - code listing formatting don't worry
07:52 - about all that just yet we'll show you
07:55 - how and why you'll use those later on
07:57 - just remember it's column seven and it's
07:59 - one character
08:01 - next we've got the a area which goes
08:03 - from columns eight to eleven in here
08:06 - you'll find divisions sections
08:08 - paragraphs level indicators and other
08:10 - elements that give cobalt programs their
08:12 - structure
08:14 - right next to it in columns 12 through
08:15 - 72 is the b area this is where you put
08:19 - the actual statements sentences and
08:22 - clauses the things that make a cobol
08:24 - program perform calculations and do
08:27 - stuff
08:28 - then last but not least the
08:29 - identification area running from column
08:31 - 73 to 80. well the compiler might
08:35 - consider at least because it actually
08:36 - ignores it so it doesn't consider it at
08:39 - all it's actually an area the programmer
08:41 - can use for any purpose so it's often
08:44 - just left blank
08:45 - now when you're writing in a programming
08:47 - language there are certain words we have
08:49 - to be careful of
08:51 - words like data end file if ready set
08:55 - until
08:57 - those are cobalt reserve words and when
08:59 - the cobalt compiler sees those words it
09:02 - thinks we're telling it to do something
09:04 - very specific so we shouldn't say ready
09:07 - unless we mean what the compiler thinks
09:10 - it means
09:11 - a full list of reserve words is
09:13 - available at the link in your guide
09:15 - in the next video we're going to talk
09:17 - about how all this fits together in the
09:19 - program structure
09:21 - [Music]
09:29 - let's talk structure koval has a
09:31 - hierarchy structure meaning that it's
09:33 - got things within other things that's
09:36 - part of what gives it its structure the
09:38 - biggest things in a cobalt program are
09:40 - divisions and within those divisions
09:43 - there are sections and within those
09:45 - sections you'll find paragraphs those
09:48 - paragraphs contain sentences and
09:50 - sentences have statements
09:53 - let's start at the statement and work
09:55 - our way back out a statement is a single
09:58 - directive usually starting with one of
10:00 - those reserved words we just talked
10:01 - about so something like add divide move
10:05 - compute
10:06 - those statements go into sentences
10:09 - just like a spoken sentence can reveal
10:11 - many pieces of information a cobalt
10:13 - sentence can contain one or more
10:15 - statements it's just a nice way of
10:17 - placing a bunch of statements together
10:19 - into a logical container
10:21 - so here is a sentence made up of
10:24 - statements and you can see that the end
10:26 - there is a period that period is an
10:28 - implicit scope terminator it says all
10:31 - the previous statements that have not
10:33 - yet ended are declared as finished you
10:37 - can also terminate a scope of a
10:38 - statement using what's known as an
10:40 - explicit scope terminator like if you
10:42 - started with an if statement and you end
10:45 - with an end if
10:47 - then you don't need to specify that
10:49 - you're done with a period
10:50 - either way works and you'll see both
10:52 - used throughout this course
10:54 - so that's sentences and what do
10:56 - sentences go into well generally
10:59 - paragraphs paragraphs are user defined
11:02 - written by you to give your program
11:04 - structure
11:05 - generally a paragraph represents a
11:08 - specific action made up of smaller steps
11:11 - so if it's something that might get
11:13 - called several times throughout your
11:15 - program like applying interest or
11:17 - prompting the user for a series of input
11:19 - that would go into a paragraph
11:22 - that way you can call that paragraph by
11:24 - its name from elsewhere in the program
11:27 - paragraphs go into sections and there
11:29 - are all sorts of sections they can have
11:32 - user defined or predefined names so they
11:34 - can be used to give your program
11:36 - structure or to make sure certain
11:37 - information is where it needs to be for
11:39 - things to run correctly
11:41 - and then there's divisions and there are
11:43 - four cobalt divisions and we can cover
11:46 - all those right now first is the
11:48 - identification division which is where
11:50 - you'd put the name of your program who
11:52 - wrote it when it was written how it
11:54 - should be used all that helpful
11:56 - information then there's the environment
11:58 - division there are two major sections
12:01 - here one lets you set the type of
12:03 - computer environment required to run
12:05 - your program and the other sets of the
12:07 - mapping between the files in your
12:08 - program and the files on the actual data
12:11 - sets so it's the link between your
12:13 - program and the system it's running on
12:16 - the data division sets up all the data
12:18 - that will be used within your program
12:20 - that includes files data from other
12:22 - programs what type of storage or memory
12:25 - you'll use while the program is running
12:27 - and what it will give up when the
12:28 - program ends then there's the procedure
12:31 - division this is where all those
12:33 - sections and paragraphs go so the
12:35 - instructions for how to take data in how
12:38 - to set up the variables performing math
12:40 - on them interacting with the user and
12:42 - all that kind of fun stuff that happens
12:44 - in the procedure division
12:46 - are you ready to see all those
12:47 - statements divisions sentences and
12:49 - paragraphs and actions i sure hope so
12:52 - because it's time for a lab basic cobol
12:54 - syntax in this lab you'll connect to an
12:57 - ibm z system check out a simple cobol
13:00 - hello world program and then submit the
13:02 - jcl to compile the program and view the
13:05 - output good luck and have fun
13:08 - [Music]
13:15 - in this section we're going to talk all
13:17 - about cobol variables i'm pretty sure
13:20 - every programming language in existence
13:23 - has variables of some sort and even
13:25 - basic algebra has the concept of having
13:28 - a letter represent a value like x equals
13:30 - 5.
13:31 - cobalt is really no different though it
13:33 - does put its own spin on some of the
13:35 - details which we'll cover here
13:38 - simply put a variable is a name chosen
13:41 - by the programmer to represent a value
13:44 - that name is referred to as a data name
13:47 - that data name can be anything as long
13:49 - as it's 30 characters or less doesn't
13:52 - contain any spaces is made up of only
13:54 - letters digits and or hashes and isn't a
13:57 - reserved word
13:59 - so some examples of good data names
14:01 - might be balance
14:04 - inventory one two three four five and
14:06 - north american sales in 2020-final
14:10 - that's exactly 30 characters
14:12 - there will be no problem with any of
14:14 - those however if we wanted a data name
14:16 - of top five percent with a percent sign
14:19 - or phone numbers with a space in the
14:22 - middle those would not be good
14:25 - we also have to think about what type of
14:27 - variable we want because when we declare
14:29 - or create a variable we have to tell
14:32 - cobalt what it's going to be numeric
14:35 - just numbers alphabetic just letters or
14:38 - both
14:39 - alphanumeric we also have to tell just
14:42 - how many of those letters and or numbers
14:45 - we think we're going to be using and we
14:47 - do all this because cobalt is an
14:49 - extremely efficient programming language
14:52 - and part of what lets it be so efficient
14:54 - is knowing exactly what's going on with
14:56 - all of its data right from the beginning
14:59 - we set this up in the picture clause
15:02 - picture or pick for short sets the
15:05 - length and the data type of a programmer
15:08 - selected variable name
15:09 - so pic9 is a single numeric value where
15:13 - the length is 1. the 9 means numeric it
15:17 - doesn't mean it's a value of 9 or a
15:18 - length of 9 it just means here's a
15:21 - variable of numeric type and since we
15:23 - didn't specify a length we only get one
15:26 - it defaults to one so i don't know maybe
15:29 - we're programming an elevator in a
15:31 - building with nine floors we could use
15:33 - that to store what floor we're currently
15:35 - on could be handy for that
15:37 - and if we need more than one digit we
15:39 - can specify that within the parentheses
15:41 - like here pick nine parentheses four
15:44 - that says it's a numeric variable and
15:47 - there's four of them that might be a
15:49 - good place to store perhaps the year
15:52 - because obviously you would need four
15:54 - digits to represent a year like 2020 or
15:58 - 2021 or 55 45 or 1999
16:03 - four digits for the year always
16:07 - pick a means we have a single alphabetic
16:09 - character and because we didn't specify
16:12 - length we only get one so i could use
16:13 - that to store my favorite letter
16:16 - z
16:18 - pick x eight gives us eight alphanumeric
16:21 - characters
16:22 - x means alphanumeric and with that many
16:25 - i could store a us license plate made up
16:27 - of up to eight letters and numbers now
16:30 - not all pick clauses are created equal
16:33 - so you need to know that the maximum
16:35 - length of a numeric picture clause is 18
16:38 - while an alphabetic pick clause can be
16:40 - up to 255
16:42 - and know that there are lots of other
16:44 - types of pick clauses we will dive into
16:46 - those as we need them for now just focus
16:49 - on those three numeric alphabetic and
16:52 - alphanumeric
16:54 - you can use picture clauses to represent
16:56 - symbols that appear in the value so for
16:58 - example
16:59 - pick nine parentheses four v nine
17:03 - what the heck does that mean well nine
17:06 - parentheses four means there's four
17:08 - digits then we've got a v which
17:11 - represents the decimal position the dot
17:14 - then two more nines so two more digits
17:17 - we can use this pick clause to represent
17:20 - 1425.82
17:23 - that could be a radio frequency or a
17:25 - measurement of some sort we can also do
17:28 - something like this pick dollar sign 9
17:31 - comma nine nine nine v nine nine
17:35 - that can be used to represent one
17:37 - thousand two hundred and thirty four
17:38 - dollars and fifty six cents the dollar
17:41 - sign and comma carry through and the v
17:43 - indicates the decimal area when we think
17:46 - of a variable we often think about
17:48 - something variable meaning it can change
17:52 - cobalt also has things called literals
17:54 - which contain data that will not change
17:56 - during the course of the program so i
17:59 - might use a literal to store something
18:01 - that i'm going to use several times in a
18:03 - program but only want to have to set it
18:05 - once for all those other places
18:07 - so maybe the name of a company a string
18:10 - of characters that i use to separate
18:12 - lines and output or copyright
18:14 - information
18:15 - anything that's going to get used more
18:17 - than once and isn't going to change
18:18 - while a program is running cobol has a
18:21 - few figurative literals built in to make
18:24 - things easier you can use them without
18:26 - setting them up yourself and a few
18:28 - you'll find most handy are zero and
18:30 - zeros space and spaces low value high
18:34 - value null nulls and you'll notice that
18:36 - for some of these there's a singular as
18:39 - well as a plural version very handy so
18:41 - if you're starting a new variable and
18:43 - you want it to be all spaces the
18:45 - efficient way to set that up is using
18:47 - the spaces literal rather than sitting
18:50 - there and going space basically
18:53 - using literals is what efficient
18:55 - programmers do and i want you to be an
18:57 - efficient programmer up next our good
19:00 - friend the data division
19:02 - [Music]
19:10 - all of the data you're going to use in
19:12 - your program gets set up in the data
19:14 - division to add structure to this we use
19:17 - what's called a data relationship we can
19:20 - see that by looking at this segment of
19:21 - code right here in this data division
19:24 - we've got level indicators each with
19:26 - their own descriptive entry
19:28 - print rec has a level indicator of 01
19:31 - meaning it's the highest and then the
19:33 - data definitions are below it at 0 5
19:37 - and the file account rec has its own set
19:40 - of variables with their own level
19:42 - indicators down here don't you just love
19:44 - that structure it's basically saying the
19:46 - data this file needs are the account
19:49 - fields and then below it it spells out
19:51 - exactly what those account fields are
19:54 - so we've declared the data let's do
19:56 - something with it
19:57 - move and compute are reserved words that
19:59 - we use to alter the value of variables
20:02 - move does well you probably figured it
20:05 - out it moves the data from one place
20:08 - into a variable and compute is used to
20:10 - perform math so in this example we've
20:13 - got a bunch of 77 level variables up top
20:16 - which are who where why rate hours and
20:19 - gross pay you'll notice the first three
20:22 - are alphanumeric and the last three are
20:24 - numeric then down in the procedure
20:26 - division we're using move to set up some
20:29 - of those variables the who where and why
20:32 - are captain cobalt san jose california
20:35 - and learn to be a cobol expert
20:38 - and that's spelled out pretty clearly on
20:40 - those lines we're also setting the hours
20:42 - and rate to 19 and 23.
20:45 - we are not going to set the gross pay
20:48 - with a move instead we're going to use
20:50 - compute and set that to the answer of
20:53 - our times rate
20:55 - and then lastly we'll output the values
20:58 - of our variables with some text before
21:00 - them so the person using the program
21:02 - knows what value they're looking at
21:04 - pretty simple right good because it's um
21:08 - oh yeah it's time for a lab
21:11 - take a look at the payroll zero zero
21:13 - cobalt source code in the id.cbl dataset
21:17 - and when you're ready to give it a try
21:19 - make sure you're submitting the jcl for
21:21 - it and not the cobol itself you submit
21:23 - the jcl to run the cobol got that i know
21:27 - you do have fun
21:29 - [Music]
21:36 - up until now we've mostly been moving
21:38 - data between variables taking them from
21:41 - user input or outputting them to a
21:42 - display now we're going to take things
21:44 - to the next level and start working with
21:46 - files
21:48 - to do this we're going to use select and
21:50 - assign clauses in the environment
21:52 - division
21:53 - fd statements in the data division and
21:56 - from the procedure division open close
21:59 - read into and write from statements
22:02 - the environment and data division is
22:04 - where we describe our inputs and outputs
22:06 - which will get used in the procedure
22:08 - division because as we all know
22:11 - that's where the action happens
22:13 - let's take a look at that action in
22:15 - action here you can see the file control
22:18 - paragraph in the input output section of
22:21 - the environment division
22:23 - what we're doing here is associating
22:25 - each cobalt internal file name with an
22:28 - external data set name in this case
22:30 - print line is the name of the internal
22:33 - file name and
22:35 - p-r-t-l-i-n-e
22:36 - is the external data set or file so
22:40 - that's the select and assign clauses in
22:42 - the environment division
22:44 - further down in the data division this
22:46 - is where we define the level numbers
22:48 - variable names data types and lengths
22:51 - the fd reserve word is used to give the
22:54 - cobalt compiler more information about
22:56 - those internal file names
22:58 - so print line which is linked with the
23:01 - data set file prt lina has these fields
23:06 - types and lengths and account rec which
23:09 - is linked to a cct rec has these fields
23:13 - types and lengths
23:15 - when your cobalt code is running on an
23:16 - ibm z mainframe it'll have access to
23:19 - both traditional z os data sets as well
23:21 - as unix files for right now we're going
23:23 - to focus on the z os sequential data
23:26 - storage method because it's extremely
23:28 - common and a good place to start when
23:30 - working with files in cobol
23:32 - a data set in z os is made up of records
23:36 - and you can think of each record as a
23:38 - line within a data set with a defined
23:41 - length so like anything written out row
23:43 - by row you'll find the exact value
23:46 - you're looking for by scanning down to
23:48 - the right record and then across for the
23:50 - field you want
23:52 - if you take all these fields and add up
23:54 - their length that makes up the entirety
23:56 - of the length of that record you got it
23:58 - it's kind of simple the way data input
24:01 - output or io is handled is a program
24:03 - says hey i'd like to read this piece of
24:06 - data out here and then the operating
24:08 - system or data io subsystem goes and
24:11 - gets it and places it into memory where
24:13 - the program can go and read it if a
24:15 - program is requesting lots and lots of
24:17 - reads one right after the other that's a
24:19 - lot of i o operations which is somewhat
24:22 - inefficient and can lead to slow
24:23 - performance it would be like going into
24:25 - a restaurant and ordering a soda and
24:27 - then waiting until that's brought out
24:28 - and saying you know what i'd also like a
24:30 - hamburger then they bring that out you
24:32 - say fries too
24:34 - and they bring that out and you say
24:36 - ketchup and then they throw you out of
24:38 - the restaurant because that's extremely
24:39 - inefficient and annoying and we don't
24:41 - want to be inefficient or annoying in
24:43 - cobalt programming we have this concept
24:45 - of something called blocks because we
24:47 - know so much about the records we can
24:50 - load data as a block where a block is a
24:53 - group of records as long as the program
24:55 - is going to read one record followed by
24:57 - the next followed by the next and so on
25:00 - we can get the records we want in order
25:02 - into what's called a buffer take a look
25:05 - at this we can see a block of records
25:08 - loaded into a buffer where the overall
25:10 - record length is the size of each field
25:12 - combined we set that overall block size
25:16 - in the buffer with the block contains
25:19 - clause
25:20 - earlier we used the assign clause to
25:22 - describe a data set source file we said
25:25 - select account rack with a dash in it
25:28 - assigned to account rec if we're running
25:30 - this in z os using jcl we need to have a
25:33 - jcl dd statement to link account rec to
25:36 - that actual data set
25:38 - the jcl required for the cobalt compiler
25:41 - to make the connection back to the
25:42 - actual data set looks something like
25:44 - this slash slash account rec
25:47 - d d d s n equals my.data comma disp
25:51 - equals shr
25:54 - if you're unfamiliar with jcl this is a
25:56 - data declaration statement that's what
25:58 - the dd stands for it says that for
26:01 - account rec look here at my.data the
26:05 - disk equals shr just means it expects
26:08 - that the data set exists before we try
26:10 - to use it and that other people can use
26:12 - it at the same time we don't require
26:14 - exclusive access
26:15 - now i don't know about you but i kind of
26:17 - want to see this all spelled out from
26:19 - end to end so we'll start out with
26:21 - account rec that's what we reference
26:24 - within our procedure division in the
26:25 - actual code
26:27 - account rec is what's defined in the
26:29 - environment division's input output
26:31 - section
26:32 - slash slash account rec a cct rec seven
26:36 - characters then gets connected via a dd
26:39 - statement to my.data the actual data set
26:42 - on the disk now don't sweat the jcl
26:45 - stuff too much right now i know you came
26:46 - here to learn cobol not jcl and chances
26:49 - are if you're given some code to write
26:51 - or modify somebody will prepare that jcl
26:54 - for you or at least tell you what data
26:56 - sets and names to use so you won't have
26:57 - to guess
26:59 - there's a link to an online resource for
27:01 - basic jcl concepts in the course notes
27:03 - if you're curious though
27:05 - one other important note the cobalt
27:07 - compiler assumes that what you tell it
27:09 - for the file names is true and correct
27:12 - and it will work when it goes to run
27:14 - because it doesn't have any way of
27:16 - checking what's actually in your jcl or
27:18 - actually on the file system
27:20 - and if any part of that chain is broken
27:22 - or not correctly linked you're going to
27:24 - get an error at run time
27:26 - that's why it's important to have a good
27:28 - naming scheme because chasing those
27:30 - types of errors is no fun at all
27:32 - up next we'll talk about putting all
27:34 - that to use in the procedure division
27:37 - [Music]
27:45 - now we're in the procedure division
27:47 - where we actually open those files that
27:49 - happens in the open file section and we
27:51 - can open files for input and output like
27:54 - this
27:54 - here we've got account rec open for
27:56 - input and print line open for output and
28:00 - just as we open the file we should
28:02 - really make sure to close them when
28:03 - we're done this can be done at the
28:05 - program completion or if it's going to
28:07 - be a long running program when we're
28:08 - done using that file resource we do that
28:11 - with the close dash stop
28:14 - so we just say close
28:16 - account dash rec and then close print
28:19 - dash line and then stop run stops the
28:22 - processing
28:23 - because cobalt is often used to handle
28:26 - lots and lots of data it's a safe
28:28 - assumption that we'll need a way to
28:29 - process records one after the other
28:32 - until we're done you may have seen in
28:34 - other programming languages the concept
28:36 - of a for or a do statement cobalt uses
28:39 - perform and in practice it looks like
28:41 - this
28:42 - i encourage you to hit the pause button
28:44 - on this screen and study it for a little
28:46 - bit because while it's extremely
28:47 - straightforward there are a few bits in
28:49 - here that might raise an eyebrow and
28:51 - we'll go through all of that so i'm
28:54 - stalling here to give you time to find
28:56 - the pause button
28:58 - and we're back so starting at the top
29:01 - we've got the read next record paragraph
29:05 - the first thing we're going to do here
29:06 - is perform a read record that's the
29:09 - first line there are no conditions about
29:11 - it we're going to do a read record at
29:13 - least once
29:15 - that read dash record is defined down
29:17 - here that is going to read the next
29:20 - record from the file and if we're at the
29:23 - end put a y presumably for yes into
29:27 - lastrack
29:28 - then when we're done reading we have
29:30 - this end read and even though that
29:33 - terminates logically and explicitly with
29:35 - the end read it also terminates
29:38 - implicitly with that period there so
29:40 - we're just being complete covering all
29:41 - of our bases
29:42 - now going back up into the read next
29:45 - record we're indenting and our first
29:48 - line here is a perform until
29:51 - it says perform until last rec equals y
29:54 - and why would last rec equals y
29:57 - it would be y if read record detected it
30:00 - hit the bottom and it processed its last
30:02 - record
30:03 - and if that file was empty it would hit
30:06 - this first perform put a y into last rec
30:10 - and then the logic of this until
30:12 - statement would say we're done
30:13 - performing we're bumped out of the logic
30:16 - because there's nothing left to do here
30:18 - and we've also hit this implicit
30:20 - terminator so we're done with this
30:22 - paragraph if the file is empty
30:25 - if the file has a couple of records in
30:27 - it like we would expect then we continue
30:29 - and we're going to do a write record
30:31 - with the data we just got that's defined
30:34 - down at the bottom of the example code
30:36 - then we'll do another read record before
30:38 - going back up to the top of this perform
30:40 - loop where we'll check to see if we got
30:42 - a y
30:43 - if it does we'll end if it's values then
30:46 - we're going to use write record to write
30:48 - them out continuing that process until
30:50 - we've hit the bottom of the file setting
30:52 - last rec to y and finishing
30:55 - reading a file from top to bottom is
30:57 - like the c major scale of cobalt
30:59 - programming you're going to have to do a
31:01 - lot of it so you should know how to do
31:02 - it forwards and backwards and this code
31:04 - right here is a great example of this
31:07 - type of logic done right
31:09 - keep all that good stuff in mind as we
31:11 - go into lab number three you'll use
31:14 - everything we touched on in this lesson
31:16 - to fix some code remember that the all
31:18 - important chain of links between the
31:20 - procedure variables environment
31:22 - variables and the jcl data sets needs to
31:26 - be correct and if it helps write them
31:28 - out so you can double check things as
31:30 - you write it go get to it lab number
31:32 - three
31:37 - [Music]
31:41 - you'll often hear cobalt referred to as
31:43 - a structured programming language in
31:46 - this definition structured means that it
31:48 - relies on the concept of passing control
31:50 - and adhering to a flow structure as a
31:53 - program executes in other words the way
31:56 - that you write your code is used to
31:58 - spell out how it should be executed
32:00 - people writing code in c pli python and
32:04 - of course cobalt use the structure of
32:07 - their languages to ensure code flows
32:09 - exactly the way it ought to
32:11 - another style of programming known as
32:13 - object oriented programming divides code
32:15 - up into smaller segments called classes
32:18 - each having its own specific purpose
32:20 - and each class has its own set of
32:22 - variables and methods then once the
32:24 - classes are defined you write the code
32:26 - that describes the interaction between
32:28 - them all and if you're writing a program
32:30 - where you're going to benefit from this
32:32 - type of class object relationship it
32:34 - allows for you to write very capable
32:36 - code without needing to define each and
32:39 - every instance of each and every class
32:41 - from scratch every single time
32:44 - however i can tell you from a little bit
32:45 - of experience that it's also very easy
32:48 - to write something that looks very
32:49 - simple but behaves completely different
32:52 - from what you intended you're
32:54 - essentially building the structure of
32:55 - code on the fly and that has its
32:57 - advantages but a lot of the code people
33:00 - write on cobalt needs to be transparent
33:03 - and readable and easily diagnosed which
33:05 - is a lot easier to do in a structured
33:08 - language
33:09 - you get the ability to jump around a
33:11 - little bit in cobalt but you should be
33:13 - sure to use those sparingly and not rely
33:15 - on them to provide the backbone of your
33:18 - program
33:19 - as we saw before cobalt passes control
33:21 - primarily using the perform keyword and
33:24 - using paragraphs so how can we best make
33:27 - use of this structure i'm so glad you
33:29 - asked let's take a look at basic program
33:32 - control and flow through a snippet of
33:34 - code
33:35 - we're setting up the output of print
33:37 - line we're setting the message headers
33:39 - of print rec to the number is
33:43 - and then we're adding one to the counter
33:45 - variable moving that value to message to
33:48 - right and then writing print rec which
33:51 - will print something like the number is
33:53 - one
33:54 - then we do the same thing again with the
33:56 - exact same code adding one moving it to
34:00 - message to right and printing it for as
34:02 - many times as we feel like repeating in
34:04 - this section here the only indication i
34:07 - have that i might be done is that the
34:09 - name of the program is 2 10 1 so i can
34:13 - assume we'll do this 10 times
34:15 - a simple looking program but dreadfully
34:18 - repetitive and not a very good use of
34:20 - anybody's time remember we want to be
34:22 - efficient and that doesn't look
34:24 - efficient
34:25 - those three lines of code keep getting
34:27 - written again and again and again so
34:30 - rather than typing them out let's
34:32 - address that issue right here we'll move
34:34 - those three lines of code into a new
34:36 - paragraph called write new record and
34:39 - then we'll just call that paragraph 10
34:41 - times using the perform keyword so the
34:44 - program will get here then run this
34:46 - then go here then run this and i'll do
34:49 - that 10 times this is called an out of
34:52 - line perform statement because it
34:53 - requires jumping down here and then back
34:56 - up and it's definitely less code but it
34:59 - still seems kind of repetitive right
35:01 - that's where we need to look into using
35:03 - a loop using an inline perform statement
35:06 - and once i pop that up on the screen
35:08 - you'll see exactly what i mean
35:10 - in the previous versions the part of the
35:12 - code we were repeating was add one to
35:14 - the counter move that counter value to
35:17 - message to right and then writing it out
35:20 - here we see the move counter statement
35:22 - that looks the same and here's that
35:24 - print wreck we wrap those two lines in
35:27 - this perform and end perform which forms
35:30 - our loop
35:31 - so what about incrementing the content
35:33 - of counter
35:34 - that happens as a condition of the loop
35:37 - itself perform that sets up the loop
35:40 - varying counter from 0 1 by 1 until
35:44 - counter equals 11. that
35:47 - i mean we really don't have to spell out
35:48 - what it does right it basically looks
35:50 - like english perform a loop where each
35:52 - iteration of the loop increases the
35:54 - counter by one starting from one until
35:57 - we get to 11. why did we say 11 we had
36:00 - to say 11 because if we said 10 we would
36:03 - hit 10 after incrementing it match this
36:06 - until clause and bump out before
36:09 - executing the move and print part you'll
36:11 - see a logic like this in other languages
36:13 - like this java example obviously the
36:16 - cobalt version involves a lot more
36:17 - typing but it's easier to read and
36:19 - you'll also get autocomplete so your
36:21 - editor will write a lot of that for you
36:23 - another way you can get around this is
36:25 - by using a go to now
36:28 - here's the thing about go to
36:30 - don't use go to unless you absolutely
36:33 - have to do it and you absolutely know
36:35 - exactly what it's going to do
36:38 - go to does exactly what it sounds like
36:41 - it jumps the program to where you're
36:42 - directing it and it just kind of picks
36:45 - up and runs from there the difference
36:46 - between go to and perform is that
36:49 - instead of it being a special assignment
36:51 - that will do and then return from it's
36:53 - just gonna go there and start executing
36:55 - from there it's like when you're reading
36:57 - something online you see a word or a
36:59 - phrase you don't understand so you
37:01 - search for it and you find a video about
37:03 - it and you watch that video ideally you
37:05 - go okay cool now i understand that and
37:08 - you jump back to where you were or if
37:10 - you're like me you go hey that was kind
37:12 - of cool what was i looking at again and
37:15 - there goes the whole afternoon
37:17 - if you were to go back to that program
37:18 - we showed earlier and replaced the
37:20 - second perform right new record call
37:22 - with a go to right new record like this
37:26 - the program would jump ahead to the
37:27 - right new record paragraph execute it
37:29 - and then just keep on going because it
37:31 - didn't know that was on a special
37:33 - assignment it just thought okay well
37:35 - this is where i am now just understand
37:37 - the difference and be careful when using
37:39 - go-to statements because you might be
37:41 - losing some of that structure that your
37:43 - program needs to be successful
37:46 - if that didn't make sense you might want
37:48 - to re-watch this video and check your
37:50 - notes because right now we're going to
37:52 - go to the next video
37:55 - [Music]
38:03 - when you start planning a program start
38:04 - thinking in paragraphs if you were to
38:07 - start whiteboarding the overall flow of
38:09 - a program drawing words and boxes and
38:11 - connecting those boxes with arrows a lot
38:14 - of those boxes will get implemented as
38:16 - paragraphs and that's good that's kind
38:18 - of the point a paragraph gets defined in
38:21 - the procedure division starts at column
38:24 - eight and can have any name you like
38:26 - apart from a reserved cobalt keyword the
38:28 - declaration of a paragraph is terminated
38:31 - with a period the paragraph itself can
38:33 - contain one to many cobalt sentences and
38:37 - is terminated by either the start of
38:38 - another paragraph or the end of the
38:41 - entire program
38:42 - from an application architecture
38:44 - perspective you really want to spend
38:46 - some time up front charting out the flow
38:49 - of your program and deciding what part
38:51 - will get handled in what paragraph if
38:54 - you start this way instead of kind of
38:56 - figuring it out as you go along not only
38:58 - will your code be less error prone
39:00 - you'll have a nice reference to use
39:02 - later on
39:03 - now there are two big situations where a
39:06 - light should go on over your head and
39:07 - you'll say to yourself ah
39:09 - that's a good use for a paragraph
39:11 - the first is if you find yourself typing
39:13 - the same couple of lines over and over
39:15 - and over again like adding a bunch of
39:17 - numbers together and finding the average
39:20 - if you find yourself doing that think
39:21 - about packaging those up into a
39:24 - paragraph and giving it a name and by
39:26 - the way put at least a few seconds of
39:28 - thought into your paragraph names nobody
39:31 - wants to open up a bunch of source code
39:33 - to find paragraphs called do file stuff
39:36 - or test123
39:39 - aim for something like open input files
39:41 - or check for duplicates that way you
39:44 - know exactly what's going on in there
39:46 - also if you've got a couple of lines
39:48 - that need to happen a bunch of times
39:50 - extracting those lines into a paragraph
39:53 - and using a perform keyword to execute
39:55 - them a certain number of times or until
39:58 - a certain condition is met is good
40:00 - practice for writing comprehensive code
40:03 - a paragraph can come before or after the
40:06 - code calling it but you should try to
40:08 - order your paragraphs close to the order
40:10 - that they'll be executed in at run time
40:13 - just to make it easier to find them what
40:15 - i'm saying is don't just throw new
40:17 - paragraphs at the bottom of the program
40:19 - you may see people start their
40:21 - paragraphs with numbers and each
40:22 - paragraph will look like one thousand
40:24 - dash open files two thousand dash read
40:27 - next record and so on then as you extend
40:30 - your program you can add them into the
40:32 - appropriate significant digit that way
40:34 - you can say you know what that paragraph
40:36 - should be in the three thousands and so
40:38 - on we kind of don't have to rely on this
40:40 - anymore with modern editors that can
40:42 - quickly jump between the paragraphs of a
40:44 - program but this explains why you might
40:47 - see this done in code that you're
40:48 - looking at and you may or may not choose
40:50 - to do the same when you write yours
40:53 - you may also see empty paragraphs at the
40:55 - end of other paragraphs like this
40:57 - the open files end paragraph has no code
41:01 - and does nothing but for someone reading
41:03 - through code it makes a nice visual
41:05 - indicator that the code for this
41:07 - paragraph ends here it also comes into
41:10 - play if you're using the perform through
41:12 - keyword which we'll learn about in just
41:14 - a little bit
41:15 - one of the simplest ways of setting up a
41:17 - loop is with times for example here we
41:20 - say perform 10 times and then some code
41:23 - finishing with end perform
41:26 - and we can set that up with a number
41:28 - just like that or with a numeric
41:30 - variable like this perform my new
41:32 - paragraph counter times whatever counter
41:36 - is it'll perform that paragraph that
41:38 - many times we can also perform through
41:41 - and this can be spelled out through or
41:44 - just th r u
41:45 - check out this example
41:47 - we have our first paragraph 1000
41:49 - paragraph a that says perform
41:52 - 2000 paragraph b through 3000 paragraph
41:56 - c
41:56 - this is another reason to consider the
41:58 - order that you state your paragraphs now
42:01 - we'll hit this perform through jump down
42:03 - and execute paragraph b and c and then
42:06 - finish this paragraph we'll never hit d
42:09 - because we were only performing through
42:11 - paragraph c
42:13 - we can also perform until which will
42:15 - evaluate the check and if that condition
42:18 - is not met it'll take some action this
42:20 - is usually done until a number hits a
42:23 - certain level or two variables are the
42:25 - same like increment this value until
42:28 - it's equal to that value
42:30 - in this example the order is that we do
42:32 - the check and then do the code and if
42:34 - the condition is met we're done we've
42:37 - done it until
42:38 - if that doesn't match your logic we can
42:40 - also do perform until with test after
42:44 - like here this will run the loop and
42:46 - then do the test
42:48 - there's also perform varying where we
42:51 - say something like
42:52 - perform varying counter from 0 1 by 1
42:57 - until counter equals 11. we just looked
42:59 - at that earlier
43:00 - and if you really want to get fancy you
43:02 - can nest those performs like this where
43:04 - we've got two counters going on counter
43:07 - and counter two and every time we
43:09 - increment counter by one we're going to
43:11 - step counter two from one to five in
43:15 - increments of one so we would get one
43:18 - one two three four five two one two
43:20 - three four five three one two three four
43:22 - five and so on
43:24 - now i don't know about you but i'm
43:26 - starting to get a little loopy myself in
43:28 - the next video we'll cover linking in
43:31 - other cobol programs
43:33 - [Music]
43:41 - a cobalt program can call other cobalt
43:44 - programs and you do that with the call
43:46 - keyword followed by the name of the
43:48 - program
43:49 - that can be call prog a1 with the
43:52 - literal program name being in single
43:54 - quotes or like this where we move the
43:57 - program name to a variable and then call
43:59 - that variable
44:01 - the way a calling program calls a called
44:03 - program is through something called
44:05 - linkage and i'm going to show you a very
44:07 - basic example of it the program being
44:09 - called has this section called the
44:11 - linkage section and in here it defines
44:14 - three variables month day and year
44:17 - they're all numeric two digits for month
44:20 - and day and four for year of course
44:22 - there's four for year and they've all
44:24 - got an ls at the end so you know they're
44:26 - in the linkage section as opposed to the
44:28 - variables up here in the working storage
44:31 - section which have a ws at the end
44:34 - so this program over here that we're
44:36 - calling it knows that it's going to be
44:38 - called and it prepares itself by setting
44:41 - up the linkage section it also sets up
44:43 - the procedure division using the using
44:46 - keyword so it's going to use those three
44:48 - variables from the linkage section in
44:50 - addition to the three variables from the
44:53 - data division working storage section
44:56 - now the calling program sets up those
44:58 - three variables in preparation for this
45:00 - which in this case matched the variables
45:03 - in the linkage section we want to set
45:05 - those up just like any other variable
45:08 - then we do this call date sub using
45:12 - month out day out year out there's those
45:15 - three variables we're calling that other
45:17 - program and giving it those three
45:19 - variables to store the output that it
45:21 - generates
45:23 - linking programs can get quite
45:25 - complicated but for now we're just going
45:27 - to leave it at that just know that there
45:29 - are ways of passing actual data as
45:32 - opposed to references to data mechanisms
45:34 - for getting a return value from a called
45:37 - program and all other sorts of goodies
45:39 - once a program reaches a certain size
45:41 - you're almost guaranteed to see
45:43 - everything we've talked about in these
45:45 - last few videos put to use so if this
45:47 - all makes sense you're in good shape
45:49 - let's keep this party going
45:51 - [Music]
45:59 - a big part of cobalt is generating
46:02 - reports you've got tons and tons and
46:05 - tons of data and you need a way to
46:07 - produce a report of that data so someone
46:09 - else can look at it and go
46:12 - hmm yes yes
46:15 - that's very good yes
46:18 - for that reason we've spelled out an
46:19 - example of generating report data here
46:22 - which can be very easily scaled out to
46:24 - handle multiple records and called any
46:26 - number of different ways at the end
46:28 - you'll be asked to complete a lab that
46:30 - puts all of this to use
46:32 - previously we looked at the select and
46:35 - respective assign programmer chosen
46:37 - names we had something like this in the
46:39 - environment division we used print line
46:42 - as the internal cobalt file name for the
46:44 - output
46:45 - now in the file descriptor marked by fd
46:49 - within the file control paragraph we
46:51 - start to connect it all together the fd
46:54 - entry defines the layout of the record
46:57 - within that print line internal file
47:01 - and you can see you were saying fd is a
47:04 - file the highest level descriptor is
47:07 - print wreck and then within that print
47:09 - wreck we have the individual fields
47:12 - defined
47:13 - first account number o presumably for
47:16 - output that's a value of eight
47:18 - alphanumeric characters then look at
47:20 - this filler that's an odd name for a
47:23 - field and it's actually not a field but
47:25 - a cobalt reserved word remember those we
47:28 - use filler to allocate memory space
47:31 - typically between words or variables and
47:34 - filler can be empty it can be dashes or
47:37 - any literal in this example it's eight
47:40 - characters of account number then two
47:43 - spaces and you can see that we spelled
47:46 - out spaces there with s-p-a-c-e-s that's
47:49 - a handy shortcut so you don't actually
47:51 - have to type out the spaces
47:53 - each one of those filler lines in here
47:56 - is just inserting two empty spaces and
47:58 - in this case it might seem somewhat
48:00 - basic but without filler your reports
48:03 - would just be a bunch of values slammed
48:05 - up against one another consider this
48:07 - partial program
48:09 - this is the working storage section
48:11 - we've got four headers defined there's
48:14 - no logic in here this is just something
48:16 - that defines what our data looks like
48:18 - notice we've got some areas up here that
48:20 - are just filler and we're filling them
48:22 - up with this text financial report for
48:26 - then in header two it's a mixture of
48:28 - literal labels and printed out variables
48:31 - so we'll have the word year notice it's
48:33 - year with a space at the end of it and
48:35 - that's why it's five characters
48:37 - then the value of hdr year header year
48:42 - same with month and day
48:44 - header three is all filler it's just
48:46 - account two spaces last name two spaces
48:50 - limit two spaces and balance and then
48:52 - forty spaces
48:54 - if you need forty spaces for your
48:56 - account balance i wanna be your friend
48:58 - send me an email once you're done
49:00 - learning cobalt
49:02 - then in header four this is more filler
49:04 - it's eight dashes two spaces ten dashes
49:08 - two spaces and so on so what i see up
49:11 - here so far is a header that goes up top
49:13 - and that says what the report is and
49:16 - then there's some sort of header info
49:18 - that spells out the time period the
49:19 - report is for which is kind of important
49:22 - and then we've got two headers for the
49:23 - values which i'm assuming will be listed
49:26 - out below
49:27 - makes sense so far
49:28 - so that header too that's date info the
49:31 - data name layout for the date info is
49:34 - defined here and it's kind of neat how
49:36 - this works the high level variable name
49:40 - is ws current date data that's ws for
49:45 - working storage and then within that
49:47 - we've got two sections ws current date
49:50 - and ws current time
49:53 - the date is divided up into the year
49:56 - month and day and the time is divided up
49:59 - into hours minutes seconds and
50:01 - milliseconds now we know exactly what
50:04 - that current date data looks like
50:08 - which is good because that's one of the
50:09 - first things we're going to do in the
50:11 - procedure division aka the division
50:14 - where all the action happens
50:20 - check out this procedure division we
50:22 - start out with a paragraph called write
50:24 - headers and then we've got these four
50:26 - move sentences the first one takes the
50:29 - current date from what's known as an
50:31 - intrinsic function
50:33 - more on that later but what it does is
50:35 - it takes the current date of when that
50:38 - code is actually executed and it copies
50:40 - it into ws current date data
50:44 - then because we defined how the fields
50:46 - of year month and day line up within
50:49 - that data name layout we can just tell
50:52 - it to move the year month and day
50:54 - portions of that data into those three
50:57 - variables then in lines five and six we
51:00 - write out our report header that's the
51:02 - financial report four part and the date
51:04 - info that follows it from header two
51:07 - we're writing those out to print rec and
51:09 - we're writing them out there from header
51:12 - one and header two
51:14 - then we move spaces to print rec and
51:17 - line seven if we didn't do this we might
51:19 - leave straight characters behind we want
51:22 - to start out with the next series of
51:23 - moves and writes assuming that we have a
51:25 - blank record and then we write it out so
51:28 - if you're following along at home which
51:30 - i hope you are we've got the financial
51:33 - report for then the date header and info
51:36 - then a blank space because in line eight
51:39 - we wrote out that line of spaces and put
51:41 - it into the print rec in line seven
51:44 - lines nine and ten write out the column
51:46 - headers of account last name limit
51:49 - balance and those nifty dashes that went
51:51 - under them now all we have to do is
51:53 - print out the data that goes underneath
51:55 - those headers and
51:57 - you know what that's where the lab comes
51:59 - in
52:00 - that will show you how you can take data
52:02 - from a file and use it to generate a
52:04 - report with all the nice formatting and
52:06 - spacing that makes it nice and easy to
52:08 - read after that why don't you report
52:10 - back here for the next lesson
52:13 - [Music]
52:21 - the path that a program takes is
52:22 - sometimes referred to as its logic does
52:25 - the user want to enter more data if yes
52:28 - then we'll jump to the part of our code
52:30 - where we'll let them put in more data if
52:33 - they're done then we'll jump to the part
52:34 - of our code where we're going to process
52:36 - that data it's kind of like hitting a
52:38 - fork in the road and we use what we know
52:41 - to inform that decision
52:43 - maybe you want to look at a bunch of
52:45 - accounts and find the ones that haven't
52:46 - been updated in the last 60 days in that
52:50 - case we're taking the difference between
52:51 - the most recent update and today's date
52:54 - and comparing that difference to 60.
52:57 - presumably if the difference is greater
52:59 - than 60 then we're gonna do something
53:01 - special with that account
53:03 - that's all logic and unless we insert
53:06 - our own logic a program is going to run
53:09 - from the top to the bottom until it's
53:11 - done so we need to learn how to express
53:14 - what we want to happen in a program's
53:16 - logic
53:17 - three of the most common types of cobol
53:19 - conditional expressions are
53:21 - general relation conditions class
53:23 - conditions and sign conditions and a lot
53:26 - of these are fairly simple it's taking
53:28 - two operands comparing them to one
53:30 - another and saying is this greater than
53:32 - that or is this equal to that or saying
53:35 - is this numeric is this lowercase
53:38 - sometimes because of the way our logic
53:40 - is structured we'll want to say is this
53:42 - not numeric because maybe we asked the
53:45 - user for a number and we got that
53:47 - something like xx and we need a way of
53:49 - saying if this is not numeric go and
53:52 - prompt that user again and remind them
53:54 - we're looking for a numeric answer so
53:57 - whenever you're writing a conditional
53:59 - expression they typically start out with
54:01 - is
54:02 - and then there's a test or a comparison
54:04 - afterwards and you can between the test
54:07 - and the comparison throw in a knot to
54:09 - flip that logic around
54:11 - there's another important and powerful
54:13 - tool you have in writing program logic
54:15 - known as conditional names these are
54:18 - used primarily to say the input we're
54:21 - taking needs to pass this test
54:23 - a conditional name is declared in the
54:25 - working storage section with an 88 level
54:28 - number in this case it has to be an 88
54:32 - level number we use a conditional name
54:34 - to say the variable that i'm under needs
54:37 - to match this and it can be a literal a
54:40 - series of literals or a pattern or
54:42 - anything like that and it's a good way
54:44 - of verifying user input and again it
54:46 - always has to be an 88
54:49 - take a look at this example
54:51 - we move az into usa-state
54:55 - then we enter this if statement if state
54:59 - the only way this will pass as true is
55:02 - if state evaluates as true which in this
55:06 - case will only pass if it's equal to tx
55:09 - so we're going to say the state is not
55:12 - texas
55:14 - then here we're moving tx to usa-state
55:18 - that will pass because it matches that
55:20 - 88 conditional statement it equals tx
55:24 - why would we do something like this well
55:26 - imagine instead of just putting in one
55:28 - state we put in all 50. that makes sure
55:30 - somebody didn't put in something like z
55:33 - z or one two as their state or something
55:35 - like that that didn't make any sense so
55:37 - we can use conditional names as a way of
55:40 - validating or limiting data before we
55:42 - try and do something with it
55:44 - there are other ways of implementing
55:46 - this type of logic but being able to
55:48 - have one place to define the scope of
55:50 - the data for a test is quite handy
55:53 - if we're comparing values like if this
55:56 - is greater than that we use conditional
55:59 - operators and those include is greater
56:02 - than which can be written out as is
56:04 - greater than sign remember those
56:06 - alligator mounts
56:07 - or is equal to which can be written out
56:10 - with the equal sign we can also say is
56:13 - greater than or equal to with is greater
56:15 - than equal to
56:18 - we can take that concept and put it to
56:20 - use in conditional expressions that's
56:22 - where we put those if then else
56:24 - statements to use and you're probably
56:26 - already familiar with those concepts
56:28 - either from another programming language
56:29 - or just from everyday talking logic if
56:32 - it's nice out then i'm gonna go for a
56:34 - hike else i'm just gonna stay inside and
56:36 - play video games again we've defined two
56:39 - possible outcomes and what will inform
56:41 - that decision the weather
56:43 - in code we might write something like
56:45 - this
56:46 - if facial expression is happy then say
56:49 - hey i'm glad you're happy otherwise say
56:52 - what can i do to make you happy
56:54 - obviously we would want this program to
56:55 - actually do stuff if you're happy or not
56:58 - happy maybe clap your hands
57:01 - but this shows a basic if then else
57:04 - statement
57:05 - we have another way of doing this that's
57:07 - more useful if there's more than two
57:09 - paths and that's an evaluate statement
57:11 - we set that up like this
57:13 - first we evaluate facial expression when
57:16 - it's happy we do this when it's sad we
57:18 - do this when it's perplexed we do this
57:20 - and we can keep on going until we run
57:22 - out of possibilities and then we hit the
57:24 - end where we just say end evaluate this
57:27 - comes in handy for menu type items like
57:29 - press one to show account balance press
57:31 - two to make withdrawal press three to
57:33 - transfer money etc each one of those
57:35 - could be a when in this big evaluate
57:38 - statement another thing that happens
57:40 - quite often in programming is performing
57:42 - some sort of function or set of steps
57:44 - until something happens maybe it's
57:46 - processing files until we've reached the
57:48 - end or adding stops to this truck
57:50 - driver's route until the truck is full
57:53 - if we're iterating over data
57:54 - specifically tables trying to find a
57:57 - specific entry we can use search
57:59 - statement that syntax looks like this
58:03 - search the facial expression table until
58:05 - you've found the index marked happy then
58:07 - presumably we do something with that
58:09 - record although in this example we issue
58:12 - a stop run so i guess they found
58:14 - happiness and there's nothing left to do
58:16 - let's get back to those conditions you
58:19 - know we can say if this number is equal
58:21 - to that number that's a test of the
58:23 - relationship between two operands which
58:26 - can be numeric or text
58:28 - we can also use conditions to test the
58:30 - content of a data item like is numeric
58:33 - or is not alphabetic lower or even is
58:36 - kanji and for numbers we can say is
58:39 - positive is negative and is zero and
58:43 - just so you know we're really only
58:44 - skimming the surface here to read more
58:46 - about all these conditions visit the ibm
58:49 - knowledge center for enterprise cobol
58:51 - there's links for that in your material
58:53 - we're coming up on that time time to put
58:56 - what you've learned to use in a lab and
58:58 - we're still working on those reports
59:00 - this time we're going to add in a
59:02 - special case if we happen to be in the
59:03 - state of virginia which will result in a
59:06 - special entry in the last line of your
59:08 - report good luck and i'll see you back
59:10 - here when you're done
59:15 - [Music]
59:19 - cobalt is often used to process lots and
59:22 - lots and lots and lots of data and a lot
59:24 - of data is made up of lots and lots and
59:27 - lots and lots of numbers
59:29 - so in order to deal with all those
59:31 - numbers we need to take a look at cobalt
59:34 - arithmetic expressions
59:36 - that's that's it that's that's the intro
59:40 - nope
59:41 - more
59:42 - all right let's put this graphics budget
59:44 - to use it's math time
59:51 - nice
59:52 - good job guys
59:53 - so what is arithmetic expression well an
59:57 - arithmetic expression can be built up
59:59 - with numbers variables that represent
60:01 - numbers the figurative constant of zero
60:04 - and any combination of those enclosed
60:07 - within parentheses including any
60:09 - combination of all that that i just
60:11 - mentioned having mathematical operations
60:14 - performed on them
60:16 - i think that about covers it
60:18 - for example number of people minus
60:21 - number of staff times three divided by
60:24 - eight would be how many pizzas you need
60:26 - in order to feed a crowd of this many
60:29 - people assuming we're not feeding the
60:30 - staff each person will want three slices
60:33 - and there are eight slices per pizza
60:35 - that's a pretty good mix of variables
60:37 - and literals and parentheses and we can
60:40 - spell expressions out with plus minus
60:43 - times divided by and you can also use
60:45 - two asterisks or stars to show
60:48 - exponentiation so 2 star star 8 is 2 to
60:52 - the 8th power meaning we keep doubling
60:55 - two eight times that's 2 4 8 16 32 64
60:59 - 128 256 2 to the eighth equals 256.
61:04 - sometimes it makes sense to spell out
61:06 - our arithmetic expressions using the
61:08 - compute command this can help make your
61:10 - code more readable or just focus a
61:12 - series of arithmetic operations in one
61:15 - place so we can say compute z
61:18 - equals a plus b divided by c exponent d
61:22 - minus e we can also say compute x y z
61:26 - equals all of that and it will assign
61:28 - the answer of whatever that might be to
61:31 - all three variables x y and z
61:34 - now you've probably heard of the order
61:36 - of operations before and if a part of
61:38 - your brain lit up that you haven't heard
61:40 - from in a while the word pemdas probably
61:43 - does the same that is the order in which
61:45 - we tackle an expression starting with
61:48 - parentheses then exponents
61:50 - multiplication division addition and
61:52 - subtraction pemdas
61:55 - by default cobalt will evaluate
61:57 - expressions this way if you want to
61:59 - either circumvent that order or you want
62:02 - to make it more clear for yourself or
62:04 - others who are reading your code you can
62:06 - also enclose sections of your
62:07 - expressions in parentheses cobalt will
62:10 - start with the most nested part of the
62:12 - expression the part enclosed in the most
62:14 - parentheses and then keep working its
62:16 - way out after that it'll look at the
62:18 - unary operators positive negative then
62:21 - exponents then multiplication and
62:24 - division from left to right and then
62:26 - addition and subtraction from left to
62:28 - right
62:29 - that means that an arithmetic expression
62:31 - must begin with either a left
62:33 - parenthesis
62:34 - a unary operator or an operand in the
62:37 - form of a literal number or a variable
62:39 - representing a number there are
62:41 - limitations to how far you can push
62:44 - arithmetic expressions in cobol the
62:46 - first is that exponents in fixed point
62:48 - expressions cannot be more than nine
62:50 - digits if the compiler sees this it'll
62:53 - truncate it and you will get a
62:54 - diagnostic message
62:56 - also while the data descriptions of
62:58 - operands in expressions don't need to be
63:00 - the same meaning you can multiply a
63:02 - two-digit number by a four-digit number
63:05 - the maximum size of each operand is
63:07 - either 18 or 19 decimal digits depending
63:11 - on the compiler option used if you're
63:13 - working with data that requires either
63:15 - very big numbers or a very high degree
63:18 - of precision make sure you know if
63:20 - you're using compatibility or extended
63:23 - mode for arithmetic there are also
63:25 - considerations to
63:27 - consider when dealing with the rounding
63:29 - of data and there's more to get into
63:31 - that we can't cover in its entirety here
63:33 - but that's all spelled out in the
63:35 - procedure division statements cobalt
63:38 - language reference
63:40 - as you've probably guessed we're going
63:41 - to get to use some of these new skills
63:43 - in the upcoming lab check out this
63:45 - change to the working storage section
63:48 - here we've got t limit and t balance
63:51 - there's some big numbers in there and
63:53 - we'll learn more about data types in the
63:54 - upcoming data type section but i can
63:57 - tell you right now those are big numbers
63:59 - or at least able to represent big
64:01 - numbers they're a comp three data type
64:04 - and they start out with a value of zero
64:07 - and look at this we've got what looks
64:09 - like more header type content except
64:11 - we're calling it trailer and i'm not a
64:13 - betting man but i think that's going to
64:14 - come at the end it looks like it's
64:17 - showing us some sort of totals so that
64:19 - makes sense too
64:20 - and then in the read next record
64:23 - paragraph we now have a perform limit
64:26 - balance total line which is calling this
64:29 - which is two compute statements which
64:31 - look like they're keeping a running
64:32 - total of the balance in total from every
64:35 - line it's processing
64:37 - hmm
64:39 - of course we're gonna write it out so
64:41 - we've got this right t limit t balance
64:44 - paragraph which moves the running totals
64:46 - into the dash o variable so that when we
64:49 - write the trailer lines out the actual
64:51 - values are gonna show up in there those
64:54 - are the parts you'll need to finish this
64:56 - sections lab and
64:58 - by my calculations it's time to get to
65:00 - work
65:05 - [Music]
65:10 - computers don't have fingers
65:13 - i mean do they
65:15 - i mean i guess
65:17 - no no they no they don't except what
65:20 - about
65:21 - no no no computers computers do not have
65:23 - fingers let's let's just stick with that
65:26 - so so when a computer is thinking of a
65:29 - number like the number eight it's not
65:31 - going like this it's lighting up little
65:34 - bits of memory that represent that
65:36 - number eight it's got its own methods of
65:38 - taking numbers letters and other
65:40 - concepts and representing them
65:42 - electronically one of the ways you can
65:44 - make sure your programs are running as
65:46 - quickly and efficiently as possible is
65:48 - by choosing the best way for cobalt to
65:50 - represent that data in its memory
65:54 - let's start out with numerical
65:55 - representation there are five different
65:58 - computational value representations
66:00 - let's start with comp one
66:03 - comp 1 is also known as a single
66:05 - precision floating point number
66:07 - representation this is useful for
66:10 - numbers that are very small and close to
66:12 - 0 or very large up to 10 to the power of
66:15 - 38 however comp one has somewhat limited
66:18 - precision it only has about seven
66:21 - significant decimal digits anything
66:23 - beyond that gets rounded so a value like
66:26 - 1 234
66:29 - 567.89
66:32 - that rate there is nine digits and it's
66:34 - going to get rounded which if you're
66:36 - dealing with dollars and cents you might
66:38 - not want to happen but for simple
66:40 - numbers a comp one might work
66:43 - then there's comp 2. this is a double
66:47 - precision floating point numeric
66:48 - representation and this can handle
66:51 - bigger numbers about 10 to the power of
66:53 - 307
66:55 - it has more significant digits up to
66:57 - about 15 so it goes further than comp 1
67:00 - in all regards but it is still somewhat
67:03 - limited and then there's
67:05 - can you guess we did comp 1 comp 2
67:09 - yes you in the back
67:11 - no it's actually comp 3 comp 3 and this
67:15 - is where it gets interesting this is
67:17 - what's known as a bcd or binary coded
67:20 - decimal this is by far the most utilized
67:23 - numeric value representation in cobol it
67:27 - is also somewhat unique and native to
67:29 - the mainframe computer and z
67:31 - architecture and with good reason it has
67:34 - to do with decimal fractions when you do
67:36 - lots and lots of operations with decimal
67:38 - fractions and the data is stored in
67:40 - binary that's when you start to get
67:42 - rounding issues representing that data
67:45 - in binary coded decimal avoids these
67:47 - issues it exactly represents values with
67:50 - decimal places and can go up to 31
67:53 - decimal digits ask someone in a banking
67:56 - credit card or payment processing
67:58 - industry why they depend on cobalt and
68:00 - they're probably going to mention bcd
68:02 - binary code of decimal and decimal
68:04 - fractions
68:06 - and then there's comp 4. comp 4 is only
68:09 - capable of representing integers so if
68:12 - you're dealing with something like a
68:13 - counter or you're only working in
68:15 - integers using comp 4 has you covered
68:17 - there
68:18 - and then there's comp 5 which is the
68:21 - same as com4 but with it you can specify
68:24 - the position of a decimal point it's got
68:26 - space efficiency of comp 4 with the
68:28 - exactness of com3 the drawback there is
68:31 - that cannot exceed 18 decimal digits
68:35 - so there's your numerical value
68:37 - representations
68:38 - numbers are good but sometimes you want
68:41 - to use letters and you'll be happy to
68:42 - know that cobalt's got you covered there
68:44 - as well there's ebcdec which stands for
68:47 - extended binary coded decimal
68:50 - interchange code and ascii which stands
68:53 - for american standard code for
68:55 - information interchange
68:57 - and it's not like one supports bigger
68:59 - words than the other it really just
69:00 - comes down to how the characters are
69:02 - represented in the computer's memory
69:04 - ebcdec has eight bits per character
69:06 - ascii uses seven and the characters are
69:09 - distributed across the possible
69:11 - combinations of those bits differently
69:13 - today the only place you're likely to
69:15 - see ebsydeck code is if you're on an ibm
69:17 - mainframe most everywhere else uses
69:20 - ascii or unicode however just keep this
69:22 - in mind if you're working on programs
69:24 - written a long time ago because every
69:26 - once in a while you'll go to load some
69:28 - data and it'll show up looking all weird
69:31 - your first instinct should be to say is
69:33 - it possible that this data is ebsedec
69:36 - and i'm trying to load it in ascii or
69:38 - vice versa because that happens quite
69:40 - often and now you'll know and you'll be
69:41 - prepared
69:42 - in this slab you'll deal with an issue
69:44 - just like that where spoiler alert
69:47 - there's a mismatch between external data
69:50 - and the cobalt representation of that
69:52 - data there's a hint and an explanation
69:54 - in there to help you along because this
69:56 - is a tricky one
70:01 - [Music]
70:05 - if you're like me one of the things you
70:07 - like about cobalt is how straightforward
70:10 - each line of code within a program is it
70:12 - does what it says it's going to do and
70:15 - there's really no mystery about what do
70:18 - this until this happens means
70:21 - however sometimes you need to do
70:23 - something beyond just add two numbers
70:25 - together or print out a line of text and
70:27 - it would be a shame if every time you
70:29 - needed to for example turn a string of
70:32 - characters from lowercase to uppercase
70:34 - you had to go and build that paragraph
70:36 - of logic all by yourself first off
70:39 - you're just repeating work and more
70:41 - importantly that's important code logic
70:43 - that needs to work right every single
70:45 - time being added onto whatever the
70:48 - primary role of the program that you're
70:50 - writing is
70:51 - there's got to be a better way
70:59 - well fortunately cobalt has a number of
71:02 - what are called intrinsic functions
71:04 - built in that you can use and if you're
71:07 - working with business data chances are
71:09 - there's something in there for you don't
71:12 - worry it's not like there's 500 new
71:14 - functions you have to keep track of the
71:16 - most recent release of enterprise cobalt
71:18 - for z os includes 70 intrinsic functions
71:22 - and they fall into the categories of
71:24 - math statistics
71:27 - date time
71:29 - financial
71:30 - character handling and
71:32 - general
71:34 - let's take a look at some of those
71:35 - intrinsic functions they all follow the
71:38 - format of function then the name of the
71:42 - function and then any arguments passed
71:44 - to that function in parentheses for
71:46 - example look at this we've got two
71:49 - variables item one and item two item one
71:52 - has hello world in it with a capital h
71:55 - and a capital w the rest lower case and
71:58 - then there's item two which is empty and
72:01 - we're going to display item one which
72:03 - should look exactly like it does up here
72:05 - with that capital h and capital w then
72:08 - we're using the uppercase and lowercase
72:11 - intrinsic functions to show item 1 in
72:14 - both uppercase and lowercase form note
72:17 - that this is just being called in the
72:19 - display function so it's not altering
72:21 - the stored data that's just how it's
72:23 - going to show up when the display goes
72:25 - to show it then in this line we're
72:28 - moving the upper cased version of item 1
72:30 - into item 2 and then displaying it so in
72:34 - this last line if we display item two
72:36 - it'll show hello world in all caps
72:40 - that's going to come in handy and making
72:41 - sure we don't have any duplicate values
72:44 - otherwise first street with lowercase st
72:47 - would be a different entry than first
72:49 - street with an uppercase st which
72:52 - happens quite often if we just uppercase
72:54 - everything we can be sure that all the
72:56 - data coming in is case insensitive
72:59 - there's also math intrinsic functions
73:02 - got a bunch of values that you want
73:03 - summed up you could line them all up and
73:06 - make an equation out of it or you could
73:08 - say compute x equals function sum
73:13 - a b c divided by d that'll sign x the
73:16 - value of a plus b
73:18 - plus c divided by d and just like before
73:21 - anything within a pair of parentheses as
73:24 - seen as one operand and it needs to get
73:26 - figured out before totaling the sum
73:29 - but wait there's more
73:45 - form that one's signed with nine spaces
73:49 - we can use the function of current date
73:51 - with the argument of one colon eight and
73:55 - move that into the first variable what's
73:57 - going on there well we're specifying the
74:00 - output in this case we want the output
74:02 - from character one that's the one
74:05 - through eight that's the eight which
74:07 - just happens to be where the year month
74:10 - and day live within that output then we
74:13 - want another function integer of date to
74:16 - turn that date into a number that number
74:19 - is the number of days that have passed
74:21 - since january 1st 1601 so it's going to
74:25 - be a big number but it's also not likely
74:27 - you'll need to go back much further than
74:29 - 1601 so pretty safe bet anyway what we
74:33 - have now is essentially a count of days
74:36 - with that we can add 90 to it and now
74:39 - we're talking about a date that's 90
74:41 - days from now you see what we're doing
74:43 - now we're going to use another function
74:45 - to transform that integer form back into
74:49 - year month and day form using the date
74:52 - of integer function see what we're doing
74:54 - there we flipped it
74:56 - and now we wind up with what is a nicely
74:58 - formatted date in the form of year month
75:02 - day and that's 90 days into the future
75:05 - because we added 90 to it and that takes
75:08 - into account going through all the
75:09 - months of different lengths leap years
75:11 - and all that stuff intrinsic functions
75:15 - and there's more lots more like 60
75:18 - something more keep that in mind as
75:20 - you're writing code and you think to
75:21 - yourself gee i can't believe i have to
75:23 - write this out by hand because there
75:25 - just might be an intrinsic function that
75:27 - you can use right there
75:29 - intrinsic functions sound like something
75:31 - you might want to try oh well guess what
75:34 - act now and you can do just that with
75:36 - this intrinsic functions lab get yours
75:39 - today
75:41 - [Music]
75:48 - we are at the last section of this
75:50 - cobalt series first off i am extremely
75:53 - glad you made it here and i hope you
75:55 - feel a lot more confident in your own
75:58 - abilities as a cobalt programmer
76:00 - of course the world goes on from here
76:02 - there are lots more functions methods
76:05 - and ways of dealing with files and input
76:07 - to explore but if you made it this far
76:09 - you can tackle anything else you come
76:11 - across you'll be able to understand the
76:14 - syntax plug it into your code make
76:16 - requested changes port a program from
76:18 - one system to another you've got all
76:21 - that just like with any other
76:22 - programming language the internet is
76:24 - full of code samples mini exercises and
76:27 - forms with people looking to help go to
76:30 - the open mainframe project and go into
76:32 - the cobol section on there for a good
76:34 - head start on those resources whether
76:37 - cobol is your first programming language
76:39 - or your 15th or your 50th i hope you've
76:42 - learned what this specialized language
76:44 - is all about and you'll see why it's
76:46 - used so widely in highly transactional
76:49 - systems all around the world from our
76:51 - team to you thank you for watching thank
76:54 - you for participating and we wish you
76:55 - the best in all that you do
76:58 - stop run
77:00 - [Music]
77:03 - you