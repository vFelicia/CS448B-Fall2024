00:00 - welcome to this comprehensive go
00:02 - programming course for beginners
00:04 - throughout this course you'll learn key
00:07 - Concepts and techniques to write
00:09 - performant idiomatic go code you will be
00:13 - guided by the expertise of Lane Wagner
00:15 - and Alan lyers who combined have over 18
00:18 - years of coding experience alongside
00:20 - mastering topics such as variables
00:22 - function loops and more you'll also have
00:25 - the opportunity to apply your newfound
00:27 - skills in seven real world projects
00:30 - ranging from building an RSS aggregator
00:32 - to implementing authentication with API
00:35 - keys so get ready to unlock the
00:38 - incredible potential of go go has been
00:41 - exploding in popularity recently it
00:43 - feels like all the most modern tech
00:45 - companies are using go to build scalable
00:47 - back-end infrastructure it actually
00:49 - makes a lot of sense goes fast
00:51 - lightweight has an amazing developer
00:54 - experience and is actually super easy to
00:56 - learn stick around and in just a few
00:58 - minutes I'll explain the rest of the
00:59 - reason why go could be a game changer
01:02 - for your coding career at this point
01:04 - I'll just introduce myself really
01:05 - quickly I'm Lane the founder of boot.dev
01:08 - and I've been writing go for a little
01:10 - over seven years and I've been building
01:12 - software for about 10. I've actually
01:14 - spent over two years designing this go
01:17 - course and I've taught thousands of
01:19 - students with this material the feedback
01:21 - from all of my students over the last
01:23 - couple years has actually been
01:24 - Incorporated in the course so everything
01:26 - is very battle tested and up to date I
01:29 - was actually just making some updates
01:30 - yesterday so how does this course
01:32 - actually work well we're going to start
01:34 - by doing over 100 Hands-On coding
01:38 - lessons and exercises now when we're
01:41 - done with all of that you'll actually
01:42 - have a really strong grasp on the
01:44 - fundamentals so at that point we'll go
01:46 - build a production ready back-end server
01:48 - in go from scratch now I'm begging you
01:52 - please do not binge watch this video
01:54 - tutorial hell is a very real place and
01:57 - it's a place that you will go if you
02:00 - don't write your own code get your hands
02:03 - on the keyboard and write some code with
02:05 - me in fact you should actually be coding
02:07 - ahead of me and only using my Solutions
02:10 - when you get stuck so head over to
02:12 - boot.dev and create a free account
02:14 - that's where all of the code samples for
02:16 - this course are hosted now alternatively
02:19 - I have linked a GitHub repo in the
02:21 - description below all of the raw code
02:23 - for the samples in this course are
02:25 - hosted there it won't be quite a
02:27 - streamlined of an option but it is an
02:28 - option now you should also know that
02:30 - this course is just one part of the full
02:33 - backend developer career path over on
02:36 - boot.dev so if you're interested in
02:37 - going from zero to hired as a back-end
02:40 - developer you should definitely check
02:41 - that out too now as long as we're
02:43 - talking about external resources know
02:45 - that if you get stuck during this course
02:47 - you have some options for help first
02:49 - you've got the boot.dev Discord second
02:51 - you've got the free code Camp Discord
02:53 - and third you've got the free code Camp
02:55 - Forum I will link all of those down in
02:57 - the description below okay one last
02:59 - thing before we jump into the course if
03:01 - you want to connect with me personally
03:02 - or you want access to my other go and
03:04 - back-end content then you can follow me
03:06 - on Twitter at wagslane or you can
03:09 - subscribe to my YouTube channel at
03:11 - boot.dev I'll link both of those down in
03:13 - the description below with all of that
03:14 - out of the way let's talk about go
03:16 - everyone always wants to talk about how
03:18 - fast the go programming languages let's
03:21 - talk about it and let's compare go to
03:23 - some of the other more popular
03:24 - programming languages
03:26 - so in terms of execution speed
03:30 - execution
03:33 - speed
03:35 - go is much faster than JavaScript python
03:38 - Ruby and PHP pretty much any interpreted
03:42 - language a language that's not compiled
03:44 - is going to be slower than go because go
03:46 - is a compiled language now don't worry
03:48 - too much if you're not familiar with the
03:49 - terms compiled and interpreted we'll
03:51 - talk about those in just a minute for
03:53 - now just understand that go is much
03:55 - faster than these languages when it
03:58 - comes to executing programs if we're
03:59 - doing computationally heavy work go is
04:02 - going to be much more performant than
04:04 - some of these other languages now here
04:07 - on the other side I've listed some
04:08 - compiled languages so when it comes to
04:12 - compilation speed
04:15 - compilation speed
04:17 - go is actually much faster than these
04:20 - compiled languages when it comes to
04:21 - compiling the code now again we'll talk
04:24 - about compiling in a minute but for now
04:26 - just understand that you have to compile
04:28 - your code before you can run it when
04:30 - you're working with a compiled language
04:31 - and so by having a fast compilation
04:34 - speed like go has it actually increases
04:37 - developer productivity quite a bit we
04:39 - can iterate more quickly on our code we
04:41 - can deploy it more quickly it's not as
04:43 - expensive to run tests to compile the
04:46 - program and deploy it to production so
04:48 - this is actually a huge benefit that go
04:50 - has now I do want to point out that go
04:52 - does not necessarily run faster it does
04:54 - not necessarily have a faster execution
04:56 - speed than all of these languages but it
04:59 - does beat them handily when it comes to
05:01 - compiling not to beat a dead horse but I
05:04 - want to talk a little bit more about
05:05 - execution speed so we talked about how
05:07 - go is generally faster than the
05:10 - interpreted languages right python
05:11 - JavaScript Ruby PHP and so on it gets a
05:14 - little interesting when we compare go to
05:17 - kind of the name natively compiled
05:18 - languages or the languages that compile
05:21 - directly to a kind of machine code that
05:24 - runs on your CPU versus the compiled
05:27 - languages that run on top of a virtual
05:28 - machine right so the the two big ones
05:30 - that run on a virtual machine are Java
05:32 - and c-sharp while some of the compiled
05:34 - or natively compiled languages that
05:36 - you'll be familiar with might be rust C
05:38 - C plus plus even though go is a natively
05:42 - compiled language a language that
05:44 - compiles directly to machine code like
05:46 - rust C and C plus its execution speed is
05:49 - actually more similar to Java and C
05:52 - sharp when it comes to its run time
05:55 - speed how many computations it can do
05:57 - kind of per second and we'll talk more
05:59 - about this later but the primary reason
06:01 - for that is the go run time
06:05 - there's basically a chunk of code that's
06:07 - included in every go program that
06:10 - manages memory and that tends to slow
06:13 - down the execution speed a little bit
06:15 - that said it is worth pointing out that
06:18 - a go program tends to use much less
06:21 - memory than Java and c-sharp because
06:24 - there isn't a need for an entire virtual
06:26 - machine
06:27 - here we are at the first coding
06:28 - challenge let me break down what we are
06:31 - supposed to do and then I'll kind of
06:32 - explain what this code over on the right
06:33 - actually does so
06:36 - um our assignment is to log the string
06:39 - starting textio server to the console
06:42 - instead of hello world so throughout
06:45 - this course we'll be building out little
06:47 - pieces of the textio product which if
06:50 - you're familiar with twilio it'll kind
06:52 - of be like a twilio clone it's a kind of
06:54 - back-end server that sends SMS and email
06:57 - messages and works a lot with kind of
06:59 - textual data every file of go code has a
07:03 - package declaration at the top here we
07:05 - have a package main simply because this
07:08 - program builds into an executable go
07:11 - program right so we can run this code
07:13 - kind of Stand Alone the next line is
07:15 - importing the fmt package from the
07:18 - standard Library we are importing it
07:20 - because we're using it down here within
07:22 - the main function now the main function
07:24 - is the entry point to the program so
07:27 - every go program starts execution at the
07:30 - top of the main function which is just a
07:32 - function named main that takes no inputs
07:34 - and doesn't return anything on line six
07:37 - and seven we have some single line
07:38 - comments these don't execute they are
07:41 - not part of the program they're just
07:42 - there for documentation and single line
07:44 - comments just start with that double
07:46 - slack finally on line eight we have the
07:48 - one thing that this program actually
07:50 - does which is print the string hello
07:52 - world to the console so let me go ahead
07:54 - and run that
07:56 - see down here printed to the console
07:58 - it's using the standard libraries fmt
08:00 - package
08:02 - um and the print line function that is
08:04 - exposed from that package uh to do so
08:07 - the assignment here is pretty simple
08:09 - we're just supposed to swap out that
08:11 - hello world message for starting text i
08:14 - o server I'm going to run that and make
08:16 - sure it looks like what I would expect
08:19 - we're good to go next let's fix a quick
08:22 - bug I love quick wins
08:25 - um we're not going to talk about all of
08:26 - this syntax in this program what we're
08:29 - interested in is just fixing the math
08:31 - bug on line 17. so the assignment
08:34 - description says textile users are
08:36 - reporting that we are billing them for
08:37 - wildly inaccurate amounts they're
08:39 - supposed to be billed for .02 dollars
08:42 - for each text message they send
08:45 - something else is happening so the total
08:48 - cost here is being set to the cost per
08:51 - message plus the number of messages
08:55 - now that doesn't make a lot of sense to
08:56 - me go ahead and pause the video see if
08:58 - you can figure this one out on your own
09:01 - um to me it looks like the cost per
09:03 - message should be multiplied by the
09:05 - number of messages right
09:07 - and let me let me run it like this
09:10 - so we can see
09:12 - Doris spent 4.02 on text messages today
09:17 - or messages
09:19 - that doesn't make sense right for four
09:21 - messages she should not be billed four
09:23 - dollars and two cents if each message
09:25 - only cost two cents so I'm gonna go
09:28 - ahead and change that to a multiply I
09:30 - would expect eight cents
09:32 - yep Dora spent eight cents on text
09:35 - messages today cool I'm gonna go ahead
09:37 - and submit that
09:38 - this is one of my favorite XKCD Comics
09:41 - uh you can pause and read it uh really
09:43 - quick if you'd like slow and resource
09:46 - expensive compilation times are a really
09:49 - terrible thing to work with I've worked
09:50 - on systems in Java and C plus plus that
09:53 - took over an hour to compile the code
09:55 - that means that if we find a bug and we
09:58 - want to deploy it to production even if
09:59 - we get the bug fixed within five minutes
10:01 - it's still going to take an hour just to
10:04 - build the new production version so that
10:06 - we can deploy it on our servers I've
10:08 - personally never worked on a go program
10:10 - that's taken more than just a couple of
10:12 - seconds to build and compile so the
10:14 - first question is go code generally runs
10:16 - blank then interpreted languages and
10:19 - compiles blank then other compiled
10:21 - languages like cnrust so the answer is
10:24 - going to be faster and faster right it
10:26 - runs faster than most interpreted
10:28 - languages and it compiles faster than
10:30 - most compiled languages
10:32 - so the question on this one is does go
10:34 - generally execute faster than rust the
10:37 - answer is going to be no
10:38 - so I've thrown around this word
10:39 - compilation or compiled a few times but
10:43 - we haven't really talked about what it
10:44 - means
10:45 - when we write code
10:47 - we write it in a human readable format
10:50 - right typically in a file in the case of
10:53 - go a DOT go file right maybe main.go
10:57 - and this file is going to contain human
11:00 - readable text right go code that we as
11:03 - developers work on the thing is your
11:05 - computer's Hardware doesn't know what
11:08 - any of that human readable text means
11:11 - your computer's CPU only understands
11:14 - binary
11:16 - right which is ones and zeros
11:19 - right which at the end of the day is
11:21 - just numbers right but it's just numbers
11:23 - and simple operations things like add
11:26 - and subtract
11:28 - so we need some process that we can use
11:31 - to convert human readable code to
11:33 - machine code that can be executed by the
11:36 - computer's hardware and that's all that
11:39 - compilation is compilation is just the
11:41 - process of taking some human readable
11:43 - code right go code in our instance and
11:47 - converting it to Binary or machine code
11:49 - that our computer can actually
11:51 - understand so what does this process
11:52 - actually look like Well normally
11:56 - you'd start by writing your go program
11:58 - so say main dot go
12:03 - and you'd run it through the go compiler
12:05 - on your command line you type go build
12:11 - and that would produce a new file which
12:14 - is the executable program let's say we
12:16 - were doing a hello word a hello world
12:18 - program it might be hello
12:21 - world
12:23 - dot e x e
12:26 - right an executable program on your
12:28 - computer and then you could run that
12:30 - executable directly on your operating
12:32 - system without ever having to use the go
12:34 - tool chain again so the great thing is
12:37 - you can take this hello world.exe
12:39 - program and give it to someone else and
12:42 - they can run it on their computer
12:43 - without ever having to install the go
12:46 - tool chain or even know that you used go
12:48 - to build the program in the first place
12:50 - this is different than languages like
12:52 - python where if you want to run
12:54 - someone's python code you have to use
12:56 - the python interpreter every single time
12:59 - and you run the source code you run the
13:02 - source code directly on your machine
13:04 - it's also worth pointing out that part
13:06 - of the reason that compiling is so much
13:09 - faster at runtime is that we do all of
13:12 - this compiling work up front so when we
13:14 - go to run the executable we don't have
13:16 - to do any conversions from Human
13:18 - readable text to Binary machine code
13:21 - that's different than how interpreted
13:23 - languages work with an interpreted
13:25 - language add as we run the program The
13:28 - Interpreter is reading the human code
13:30 - and kind of at runtime converting it to
13:33 - machine code that the CPU can operate on
13:35 - so you might be wondering where is the
13:38 - compiling Happening Here on boot Dev
13:40 - well we actually do the compiling and
13:43 - the running at the same time for you so
13:45 - when you click the Run button we're
13:47 - actually taking your code shipping it
13:48 - off to our servers compiling it running
13:51 - it and giving you the result don't worry
13:54 - when we get down the road to the actual
13:56 - project you'll be building and running
13:58 - your own go code on your own machine but
14:01 - we can see the difference between a
14:03 - compiler error and a runtime error even
14:06 - here on boot Dev so for example here in
14:08 - this code the assignment says to pass
14:11 - this exercise fix the compiler error in
14:13 - the code so I'm just going to run it as
14:15 - is and you'll see we get this nasty
14:17 - error here and it says main.go right
14:20 - line six syntax error this is actually a
14:23 - compile time error so we weren't even
14:25 - able to compile file this code it didn't
14:27 - fail at runtime it failed at compile
14:29 - time right which again that distinction
14:31 - will become more clear a little bit
14:33 - later so anyways um we can fix it by
14:35 - adding that close parenthesis that was
14:37 - missing
14:39 - and now it compiles and runs just fine
14:44 - so to review
14:46 - go code like this little go program here
14:49 - that prints hello world
14:51 - that's not understood directly by the
14:54 - hardware on your computer your
14:56 - computer's processor or your computer's
14:58 - CPU understands machine code so we need
15:02 - to take our human readable go code run
15:06 - it through the go compiler to produce
15:08 - the machine code that we can run
15:09 - directly on our CPU right the CPU is
15:13 - designed by the manufacturer to run a
15:15 - specific format of binary
15:18 - cool so the question for this exercise
15:20 - is do computer processors understand
15:23 - English instructions like open the
15:25 - browser
15:27 - no processes are not chatgpt they need
15:31 - machine code
15:32 - now we touched on this very briefly
15:34 - before but I want to talk about how you
15:36 - distribute a compiled program versus how
15:39 - you would distribute an interpreted
15:40 - program so let's say that you'd written
15:43 - a script in Python so you've got this
15:45 - script
15:46 - main.py right this is raw python code
15:50 - and you want to give it to your friends
15:52 - so that they can run your script well
15:54 - all you would do with an interpreted
15:56 - language is give your friend
15:59 - the main.py file and then on their
16:02 - computer they would run the command
16:04 - python
16:07 - main dot p y
16:10 - and they'd be able to run your code now
16:12 - there are a couple of downsides to this
16:14 - approach the first problem is that your
16:16 - friend needs to have python installed on
16:19 - their computer so your your friend being
16:22 - able to use your program is dependent on
16:25 - them already having python installed
16:27 - it's even dependent on them knowing how
16:29 - to use it or knowing how to use a
16:31 - command line right so Distributing the
16:33 - programs of interpreted languages can be
16:35 - tricky because it's really only useful
16:37 - if you're Distributing to other
16:39 - developers who know how to use these
16:40 - tools already the other problem is the
16:43 - code itself let's say you spent you know
16:46 - many weeks writing this python script
16:48 - and it's super useful and you're trying
16:50 - to sell it to customers if you just give
16:53 - them your python code I mean they
16:55 - effectively own it they can change it
16:57 - even if you didn't intend for it to be
16:59 - open source congratulations it's now
17:01 - open source the problem is you can't
17:04 - really allow someone to use your program
17:06 - without giving them all of the special
17:10 - sauce that makes it work let's review
17:12 - how this works in a language like go
17:15 - so in go we'd start the same way right
17:18 - we'd write some human readable go code
17:20 - in a file called main.co but instead of
17:22 - giving that file to our friend we're
17:24 - going to compile it first
17:27 - I'm going to compile it
17:29 - we'd use the go tool chain so we'd write
17:31 - something like go build in our command
17:33 - line and that would produce a new
17:36 - executable file right so this is this is
17:39 - machine code here
17:41 - um let's just say that the name of our
17:43 - program is Hello World why not
17:48 - so for on Windows it might be
17:49 - helloworld.exe
17:52 - right so when you go online and you
17:54 - download a program to you say it's a
17:56 - video game it is probably a bundle of
18:00 - machine code it is a built binary right
18:02 - in order to run your favorite video game
18:05 - let's say Starcraft 2 or World of
18:07 - Warcraft you don't need to install the C
18:09 - plus compiler right you're just given
18:12 - the built kind of final product the
18:15 - final executable program and that's what
18:18 - we're doing in the go programming
18:21 - language as well so now we can give our
18:23 - friend this executable
18:25 - they don't need to install go and they
18:27 - do not need access to the original
18:29 - source code so generally speaking
18:31 - Distributing programs that are natively
18:34 - compiled is much much easier than
18:36 - Distributing programs that kind of have
18:38 - a runtime dependency like an interpreter
18:41 - so to answer the question for this
18:43 - exercise do users of compiled programs
18:46 - need access to the source code no they
18:49 - don't and a related question which
18:52 - language is interpreted we've got go C
18:54 - plus plus Python and rust and the answer
18:57 - is python
19:01 - the rest are all compiled so now the
19:03 - question is why is it generally more
19:05 - simple to deploy a compiled server-side
19:08 - program or back-end application and the
19:10 - answers are compiled code is more memory
19:12 - efficient because Docker exists there
19:15 - are no runtime language dependencies or
19:17 - because compiled code is faster
19:20 - well it's just the same as what we
19:22 - talked about earlier when we deploy to a
19:25 - server say on the cloud we have to have
19:28 - all of the dependencies that our
19:31 - back-end application needs in order to
19:33 - run installed on that server and if
19:36 - there are no runtime dependencies if all
19:39 - we need is a compiled binary then that's
19:42 - arguably the simplest way to do it right
19:44 - so the answer is it's more simple to
19:47 - deploy a com to deploy a compiled
19:49 - program to a back-end server if there
19:52 - are no runtime language dependencies
19:54 - things like the python interpreter or
19:56 - The node.js Interpreter for example go
19:59 - is strongly typed and statically typed
20:03 - and that's a really good thing if you've
20:06 - been paying any attention at all to the
20:08 - JavaScript World you'll notice that a
20:10 - lot of JavaScript developers are making
20:11 - the switch to typescript and that's
20:14 - primarily to get access to static typing
20:18 - a lot goes into typing and type systems
20:21 - but one of the biggest benefits of a
20:24 - static type system light goes is that
20:26 - when we declare a string right like say
20:29 - this username string that I've set equal
20:32 - to wagslane We Can't later accidentally
20:35 - change it to an integer a number right
20:37 - like a float64. it's going to stay a
20:41 - string the nice thing about a static
20:43 - type system like we have with go or that
20:45 - you have with typescript is that we get
20:47 - feedback on our errors uh much more
20:49 - quickly right rather than finding out
20:51 - about a bug when our code is running in
20:53 - production we find out about the bug say
20:55 - when we compile our code let's move on
20:57 - to the assignment the assignment says
20:59 - we'll be using basic authentication for
21:01 - the text I O API so basic authentication
21:03 - is is just this format here where you've
21:05 - got a username and a password in an HTTP
21:09 - header it tells the server on each
21:12 - individual request to the server who you
21:14 - are right it's kind of like logging in
21:17 - um
21:18 - or rather it's kind of like being logged
21:20 - in
21:20 - okay uh so the code on the right has a
21:25 - type error change the type of password
21:26 - to a string Okay cool so I'm just going
21:28 - to run it to see the type error first so
21:30 - invalid operation username plus colon
21:32 - plus password has mismatch types of
21:35 - string in it now this is a
21:36 - physical time error we weren't even able
21:38 - to compile this code right let alone run
21:40 - it in production
21:42 - um so we've been instructed in the
21:44 - assignment change the type of password
21:45 - to a string but use the same numeric
21:48 - value so that it can be concatenated
21:50 - with the username variable Okay cool so
21:52 - I'm just going to change this to a
21:53 - string by surrounding it in double
21:55 - quotes that's how you do strings and go
21:59 - pretty similar to other languages and
22:00 - then I'm just going to change that type
22:02 - to a string type and run it again
22:06 - authorization basic Wags Lane colon
22:09 - number that looks good to me
22:13 - when we're talking about the performance
22:15 - of a programming language or an
22:17 - application we really care about how it
22:19 - performs across two different axes one
22:21 - is speed how fast it can do computations
22:24 - right which is kind of measured in CPU
22:27 - cycles and then we also have memory
22:30 - consumption which is just how bloaty the
22:32 - program is how much data it has to store
22:34 - in memory to be able to do those
22:37 - computations every program you write no
22:39 - matter the language is going to be using
22:42 - memory every time you create a new
22:44 - variable it allocates space in memory
22:46 - where it can store that variable's data
22:49 - now in languages like rust or C memory
22:53 - management is effectively manual now
22:56 - that said Russ does have some nice
22:58 - tooling that kind of takes care of it
23:00 - for you at compile time so it's not
23:01 - quite as error prone as as it would be
23:04 - in C or C plus plus but at the end of
23:06 - the day your program is allocating
23:08 - memory right it's saying this chunk of
23:11 - memory I'm going to use I'm going to
23:13 - store some very variable data here in
23:15 - this bit of RAM and then later your
23:17 - program says I'm not using it anymore so
23:20 - we can free it up for use by other
23:22 - programs now let's jump over to Java so
23:25 - with Java it's a little bit different
23:26 - Java is a garbage collected language
23:29 - garbage collection which essentially
23:31 - means that memory management is
23:33 - automated
23:35 - and in Java it's done by the Java
23:38 - virtual machine so every time you run a
23:41 - Java program you're actually creating an
23:43 - entire
23:45 - mini virtual machine
23:48 - that your Java byte code runs within so
23:52 - this is the jvm
23:55 - and then you kind of insert your code
23:59 - into the jvm
24:02 - and you run your code in there and the
24:06 - jvm is what takes care of allocating and
24:09 - freeing all of the memory that you use
24:11 - and this creates overhead basically at
24:14 - the end of the day Java programs use
24:17 - quite a bit more memory than rust or C
24:20 - programs go is in an interesting sort of
24:23 - in-between world where go is a garbage
24:26 - collected language like Java so it has
24:28 - automated
24:30 - automated memory management but it does
24:33 - not have a jvm when you compile go code
24:36 - rather than having to run it within a
24:39 - jvm just like with rust and C you get
24:42 - one binary or one executable program the
24:46 - difference is that go includes a runtime
24:52 - a run time
24:54 - within every single binary that's built
24:58 - using legal programming language
25:00 - so we could think of it as something
25:02 - like this it's kind of like a little
25:03 - Sidecar
25:05 - that is compiled alongside
25:08 - your code
25:09 - so your go program basically has this
25:13 - this little bit of extra code that's
25:15 - added to it and that bit of code is what
25:18 - handles garbage collection and automated
25:21 - memory management so it's a little more
25:23 - bloaty than what you'd get with rust and
25:25 - C right it is garbage collected
25:28 - um but it's not nearly as
25:31 - um expensive in terms of memory overhead
25:33 - as a language like Java or c-sharp let's
25:36 - take a look at what some actual numbers
25:38 - look like I pulled this chart from
25:40 - Dexter darwick's blog and if you're
25:42 - following Along on boot Dev you can
25:44 - click the link to go check out the full
25:45 - the full blog in the description of this
25:47 - experiment but basically he built a
25:50 - restful web server in three different
25:52 - programming languages right in Java go
25:54 - in Rust and then measured the memory
25:56 - consumption and when the servers were
25:59 - just at rest effectively doing nothing
26:01 - and waiting for requests to come in
26:03 - rust used less than half of the memory
26:07 - that go was using and go used 100 times
26:11 - less memory right measured in megabytes
26:14 - then the jvm was using to run the rest
26:18 - service so to order the three languages
26:20 - in terms of memory efficiency I would
26:22 - say Java is the least efficient go is in
26:25 - the middle and rust would be the most
26:27 - memory efficient and it's also worth
26:29 - pointing out just really quickly that as
26:32 - the load on the server increases I would
26:34 - expect go to have more similar
26:38 - performance to Java in other words we
26:40 - wouldn't see as quite a large
26:42 - discrepancy here right go would likely
26:45 - still be more memory efficient than Java
26:48 - almost certainly in fact but it probably
26:50 - wouldn't be a 100x discrepancy we're
26:53 - seeing this huge discrepancy
26:56 - um mostly because this is an idle a test
26:59 - of an idle program so generally speaking
27:02 - which language uses more memory that's
27:04 - going to be Java
27:06 - another question on the same topic is
27:08 - what's one of the purposes of the go run
27:11 - time so to style go code and make it
27:14 - easier to read that doesn't make sense
27:15 - that would be like compile time tooling
27:17 - right not run time tooling
27:19 - to clean up unused memory to cook fried
27:22 - chicken or to compile go code so it's
27:24 - definitely going to be to clean up
27:26 - unused memory and if you remember the
27:28 - runtime is just that little bit of extra
27:30 - code that's included in every compiled
27:33 - go program that among other things
27:35 - handles memory management
27:38 - so we've already talked about how go has
27:40 - strong and static types but we haven't
27:43 - yet talked about what those types are
27:45 - you're probably already familiar with
27:47 - Boolean values and string values which
27:50 - are valid go types and also exist in
27:52 - pretty much every other programming
27:53 - language numbers are where it first
27:55 - starts to get a little bit different if
27:58 - go is your first compiled programming
28:00 - language generally speaking numbers fall
28:02 - into four different buckets we have
28:05 - integers unsighted integers or uints
28:08 - floats and complex numbers integers are
28:12 - just whole numbers they can be positive
28:14 - or negative right one two three four you
28:17 - get the idea unsigned integers are the
28:20 - same as integers but they're not signed
28:22 - which basically just means they don't
28:23 - have a negative component you can only
28:25 - represent positive numbers in an
28:28 - unsigned integer you're probably already
28:30 - familiar with the idea of floats it's
28:31 - just fractional numbers right numbers
28:33 - that have a fractional component things
28:36 - like 1.21 or 3.14 complex numbers are a
28:40 - little funny they're used to represent
28:42 - the concept of imaginary numbers if
28:45 - you've gotten to imaginary numbers in
28:47 - your math studies I've never actually
28:49 - used complex numbers
28:51 - um in production I'm sure there are
28:53 - plenty of use cases for them but we're
28:55 - not going to go into detail on how they
28:56 - work here you can certainly go read up
28:58 - on it if you'd like the only other thing
29:00 - worth mentioning is that size matters
29:02 - when it comes to types A uint 8 and a u
29:06 - inch 16 are two different types they
29:08 - both represent unsigned integers but a
29:11 - unit 16 has twice as much room for data
29:15 - within it it has 16 bits of data whereas
29:18 - a unit 8 only has eight bits
29:21 - for example the largest number that you
29:23 - can store in a uint 8 is 255 because
29:27 - that's the largest number you can
29:28 - represent with eight ones and zeros in
29:30 - binary but with a uint 16 the largest
29:33 - number you can store is about 65 000.
29:36 - again because that's the biggest number
29:38 - that can be represented by 16 binary
29:41 - digits just like bigger number better
29:43 - person a bigger number in your types
29:45 - means you can represent more possible
29:48 - values within that type so bullet64 can
29:52 - represent more values than a float 32.
29:54 - the only reason you wouldn't use a
29:57 - larger type is if if you're trying to
29:59 - save on memory if you're trying to write
30:01 - a program that is hyper performant
30:03 - you'll want to use a smaller size right
30:05 - if you know that an integer is only ever
30:08 - going to store three different values
30:09 - say one two or three then you might
30:11 - consider using a uint8 the byte type is
30:14 - an interesting one and it's one that
30:15 - you'll use a lot especially when you're
30:17 - say marshaling a Json object to be sent
30:20 - across a network connection or maybe
30:22 - you're reading to and from a file on
30:24 - disk but under the hood a byte is just
30:27 - an alias for the uint 8 type which makes
30:30 - sense right a byte is just eight binary
30:33 - digits eight bits and that's all a uint
30:35 - 8 is a rune is a Unicode code point
30:39 - which generally speaking you can think
30:41 - of as one character in a string and
30:44 - that's usually how it's used under the
30:46 - hood it's just an alias for the int32
30:49 - type moving on to the assignment it says
30:52 - initialize the given variables to end
30:53 - float64 Bool and string respectively
30:56 - with their zero values and and as we can
30:59 - see here if we just use VAR the name of
31:01 - the variable and the type that should do
31:04 - it so we'll initialize the variables
31:06 - here so VAR
31:08 - SMS sending limit is an INT
31:12 - bar cost per SMS is a float
31:16 - 64.
31:19 - has
31:21 - permission
31:23 - is a Bool
31:25 - and
31:27 - username
31:28 - is a string okay cool and all so all of
31:32 - these variables are now instantiated and
31:34 - should contain their zero value so for
31:36 - example 0
31:37 - 0.0 false and empty string let's go
31:41 - ahead and run that
31:43 - and that looks correct to me I'm going
31:45 - to go ahead and submit it
31:47 - we've been declaring variables the hard
31:49 - way now we're going to do it the easy
31:51 - way there is an operator and go colon
31:54 - equals that is the short assignment
31:56 - operator and it allows us to declare
31:58 - variables and have go infer their type
32:01 - so instead of typing VAR empty string we
32:05 - can just say empty colon equals the
32:07 - empty string and go knows that this has
32:12 - to be a string so it is a string now
32:14 - when we use this short assignment
32:17 - operator we're not saying this is a
32:19 - loose type that can change in the future
32:20 - it's still a static type empty is a
32:23 - string just like it would be if we
32:25 - declared it this way in reality in go
32:27 - you will very rarely see variables
32:30 - declared like this you will almost
32:31 - always see them declared using the
32:34 - shorts the short assignment operator for
32:37 - example
32:38 - num cars colon equals 10 creates a new
32:41 - variable called num cars and sets it
32:42 - equals to 10 and its type will be
32:44 - inferred to be an INT and the int type
32:47 - Alias is either into 32 or in 64
32:50 - depending on your computer's
32:51 - architecture if you want to specify a
32:54 - particular size of integer then you
32:57 - would declare it using this kind of long
32:58 - hand syntax so in this assignment we're
33:01 - just meant to declare a variable named
33:03 - congrats with the value happy birthday
33:05 - using a short variable declaration so
33:08 - as simple as congrats colon equals the
33:12 - string happy birthday
33:15 - let me run that
33:18 - perfect
33:20 - this next assignment says our current
33:22 - price to send a text message in textdio
33:25 - is two cents however it's likely in the
33:27 - future that the price will have to be a
33:29 - fraction of a penny or have a fractional
33:31 - part to the cost so we should use a
33:33 - float 64 to store this value edit the
33:36 - pennies per text declaration so that
33:39 - it's inferred by the compiler to be a
33:40 - float64. Okay cool so here
33:44 - we're just setting it equal to two
33:46 - I run that
33:48 - and I get the type of pennies per text
33:50 - is int and this percent T in go
33:55 - um is is a formatting verb that tells
33:58 - the go programming language or or at
34:00 - least the printf function I should say
34:02 - the formatting package from the standard
34:03 - Library
34:04 - um that I want to print to the type of
34:06 - this variable rather than its value so
34:08 - that's why we're saying in there instead
34:10 - of 2.
34:12 - um to get a float all we need to do is
34:14 - change it from 2 to 2.0 I believe
34:17 - 64. cool
34:20 - another handy syntactic Quirk of the go
34:23 - programming language is that we can
34:24 - declare multiple values on the same line
34:26 - so in this assignment it says declare a
34:28 - float called average open rate and a
34:30 - string called display message on the
34:32 - same line okay so average open rate
34:36 - display message
34:39 - same line the average open rate must be
34:42 - 0.23
34:46 - and the display message should be the
34:49 - string
34:50 - is the average open rate of your message
34:52 - and then it looks like
34:58 - this is just going to print them
34:59 - together so it's going to say 0.23 is
35:02 - the average open rate okay cool let's go
35:03 - ahead and run that
35:06 - 0.023 is the average open rate of your
35:08 - messages that looks correct to me
35:11 - so we've already briefly talked about
35:13 - the different type sizes in go right so
35:15 - we have the int type int 8 in 16 into 32
35:19 - and in 64. and it's important to
35:21 - understand that the int type just
35:23 - aliases into 32 or in 64.
35:27 - um same with the uint type just
35:29 - depending on your cpu's architecture so
35:31 - you might be on a 32 or a 64-bit machine
35:33 - most modern machines are going to be 64
35:36 - bits my recommendation is that unless
35:39 - you have an explicit reason to care
35:41 - about the size right so unless you're
35:44 - trying to kind of hyper optimize for
35:46 - performance then you should really just
35:48 - stick to these four types int uint
35:50 - float64 and again if you're working with
35:53 - imaginary numbers then complex 128 but
35:55 - that's honestly unlikely so these three
35:59 - types are going to do the vast majority
36:01 - of the heavy lifting when it comes to
36:03 - working with numbers in go we can also
36:06 - convert
36:07 - between you know different number types
36:09 - for example we could take a an integer
36:12 - 88 and convert it to a float like this
36:14 - so become
36:15 - 88.0 right converting the other way is a
36:19 - little trickier though because say we
36:20 - had 88.6 if we were to convert it to an
36:22 - INT we would lose the 0.6 we would
36:24 - truncate it down to just 88. now this
36:28 - assignment says our text Au customers
36:30 - want to know how long they've had
36:31 - accounts with us follow the instructions
36:33 - in the comment provided you will create
36:34 - a new variable called account age int
36:36 - that will be the truncated integer
36:38 - version of account age Okay cool so
36:41 - create a new account age end here
36:44 - should be the result of casting a count
36:45 - age to an integer so we'll just do int
36:48 - account age and I would expect that to
36:50 - be 2 after casting it because it should
36:53 - truncate the 0.6 so let's go ahead and
36:56 - run that
36:57 - your account has existed for two years
36:59 - yeah that looks good to me
37:02 - we already briefly touched on this but
37:04 - it's worth mentioning again I recommend
37:06 - that you stick to the I call them the
37:08 - default types so for example we know
37:11 - there's um you know five or six I can't
37:13 - think of it off the top of my head now
37:14 - different types of ins right int int 8
37:18 - and 16 and 32 and 64. I'd recommend
37:21 - sticking to int unless you have a very
37:23 - good reason to specify a smaller size
37:26 - like int 8 or in 32 and that's simply so
37:29 - you avoid cluttering your code with tons
37:32 - of type conversions that can sometimes
37:34 - even lead to bugs so unless you need a
37:38 - smaller type for performance reasons
37:39 - just use these default types
37:43 - okay so the question for this assignment
37:45 - is when should you elect to not use a
37:48 - default type
37:49 - when either a default or a specific size
37:52 - will work when my system has lots of
37:54 - extra Hardware that I want to utilize or
37:56 - when performance and memory are the
37:57 - primary concern
37:59 - so it's going to be performance if you
38:01 - have performance concerns that's the
38:03 - time I would maybe
38:05 - stray away from the default types
38:09 - the next question is what does the size
38:12 - of a type indicate so a float64 what
38:15 - does 64 mean is it bits bytes or nibbles
38:19 - the answer is going to be bits now it is
38:25 - worth pointing out nibbles is a real
38:26 - thing so a byte is eight bits a nibble
38:29 - is actually Four bits if you didn't know
38:32 - that fun interesting trivia
38:35 - aside from variables go also supports
38:38 - constants which are immutable values and
38:42 - in go just like in JavaScript or
38:43 - typescript we use the const keyword and
38:46 - constants do not support the short
38:48 - declaration syntax so we have to kind of
38:51 - write it all out
38:53 - okay so getting to the assignment says
38:55 - use two separate constants something
38:56 - weird is happening in this code what
38:58 - should be happening is that we create
38:59 - two separate constants Premium plan name
39:02 - and basic plan name right now looks like
39:04 - we're trying to overwrite one of them
39:05 - okay cool so on line six we've got
39:07 - Premium plan name
39:09 - and we're setting it to Premium plan and
39:11 - then we have Premium plan name again
39:13 - attempting to override the value
39:16 - and set it to a new string if we try to
39:18 - run this we actually get a compile time
39:20 - error so we're not allowed to mutate
39:23 - constants in go
39:25 - so what we should be doing is creating a
39:28 - separate constant and it should be named
39:31 - basic plan name
39:33 - let's go ahead and run that
39:35 - plan Premium plan plan basic plan looks
39:39 - good to me
39:40 - Constance in go are not the same as
39:43 - constants in JavaScript and in
39:45 - typescript in JavaScript and typescript
39:47 - the const keyword really just means you
39:49 - can't reassign to this variable but you
39:51 - can compute the variable or the
39:53 - variable's value at runtime in go every
39:57 - value that's stored in a constant must
40:00 - be known or computed at compile time
40:03 - before the program runs so if we create
40:06 - this new constant called my int and set
40:09 - it equal to 15 within the compiled go
40:12 - binary effectively this symbol my int
40:14 - just refers to the static number 15.
40:18 - the cool thing is that we can actually
40:21 - compute constants like we can make
40:23 - constants that depend on other constants
40:25 - but that computation will run when we
40:28 - compile our code not when we run our
40:31 - code
40:31 - so for example I can create this
40:34 - constant first name Lane last name
40:36 - Wagner and then I can create a new
40:37 - constant called full name it's first
40:39 - name plus a space plus and a last name
40:41 - and that's really convenient in case I
40:43 - ever want to change first name now I
40:45 - don't have to change it in two places
40:46 - right full name will automatically
40:48 - update but this is only valid because
40:50 - all of the inputs to this full name
40:53 - constant first name and last name are
40:55 - known at compile time so the compiler
40:58 - can still do the thing it wants to do
41:00 - which is replace full name with a static
41:03 - string right lane space Wagner
41:06 - so on to the assignment
41:08 - says keeping track of time in a message
41:10 - sending application like textile is
41:12 - critical imagine getting at a point
41:14 - reminder an hour after your doctor's
41:17 - visit not very helpful right
41:19 - complete the code using a computer
41:20 - constant to print the number of seconds
41:22 - in an hour
41:23 - Okay so we've got the number of seconds
41:25 - in a minute is 60. the number of minutes
41:28 - in an hour is also 60 so how many
41:31 - seconds are in an hour
41:32 - cool well we could hard code this as
41:35 - like 60 times 60.
41:38 - but the cool thing is we can actually
41:40 - compute it because we can say well we
41:41 - know the minutes the number of minutes
41:43 - in an hour and we know the number of
41:45 - seconds in a minute
41:48 - and if we multiply those two together we
41:50 - should get the number of seconds in an
41:52 - hour right
41:56 - that looks correct to me
42:00 - so I'm obviously a huge go fan but
42:03 - formatting strings and go is honestly
42:05 - one of my least favorite features of the
42:07 - language I think it's one of its
42:09 - weaknesses at the moment who knows maybe
42:10 - it'll improve in the future the way it's
42:12 - done well we essentially have two
42:14 - different functions provided to us by
42:16 - the standard Library we have printf and
42:18 - S printf printf prints a formatted
42:22 - string directly to standard out and S
42:25 - printf just Returns the formatted string
42:27 - as a value basically all string
42:30 - formatting in go currently works the
42:32 - same way we have these formatting verbs
42:34 - things like percent V percent s percent
42:37 - d
42:39 - and they're replaced in the string
42:42 - template with actual values so for
42:44 - example I am percent V years old the
42:48 - percent V in this case is replaced by 10
42:50 - the first parameter that comes after the
42:54 - template in the printf function
42:57 - here we could also replace with a string
43:00 - instead of an issue right I am percent V
43:02 - years old way too many Prince I am way
43:05 - too many years old percent V is sort of
43:07 - the default formatter it's usually what
43:11 - you want a us don't want to print in
43:13 - kind of the default standard way using
43:15 - percent V then there are a few others
43:18 - percent S interpolates A String percent
43:20 - D interpolates an integer in decimal
43:23 - form so for example 10 becomes the
43:26 - number 10 instead of say in binary form
43:28 - uh percent s is for floats so you can
43:31 - specify the number of kind of places
43:34 - after the decimal point that you want
43:37 - printed out to the console or print it
43:39 - out to the returned string in the case
43:41 - of s printf
43:43 - um
43:43 - so actually do end up using percent F
43:46 - fairly regularly when I'm working with
43:48 - floats so on to the assignment it says
43:51 - create a new variable called MSG on line
43:53 - 9. MSG stands for message of course it's
43:57 - a string that contains the following hi
43:58 - name your open rate is open rate percent
44:00 - where a name is the given name and open
44:02 - rate is the open rate rounded to the
44:04 - nearest tenths place okay so the tenths
44:07 - place is the number right after the
44:09 - decimal so let's get started here
44:12 - message colon equals fmt dot s printf so
44:16 - we're going to use S print f
44:18 - instead of print F because we don't want
44:21 - this value going to standard out we want
44:23 - it returned from the function so we can
44:25 - save it in the MSG variable
44:28 - let's just grab this template
44:32 - so we'll use percent s we could use
44:35 - percent s or percent V here because
44:37 - we're just uh interpolating a string and
44:39 - we'll do percent
44:42 - point one F because we want
44:46 - to just print the first
44:50 - number after that the decimal point
44:52 - right the tenths place
44:54 - okay and then we just pass
44:57 - the two values as the following
44:59 - parameters or as the last two parameters
45:01 - so name and open rate
45:05 - all right so the first value name we'll
45:07 - go into the first verb the second value
45:09 - will go into the second verb let's run
45:11 - that see what we get
45:13 - I saw Goodman your open rate is 30.5
45:15 - percent that looks good to me
45:18 - let's talk about conditionals in go so a
45:20 - conditional is just where we are
45:22 - checking if a condition is true if it is
45:24 - we do one thing if it's not we may do
45:26 - another so for example uh here's an if
45:29 - statement in go and if this expression
45:32 - evaluates to true then we'll run the
45:36 - stuff within the curly braces the body
45:38 - of the if statement if you're familiar
45:40 - with other programming languages like
45:41 - JavaScript this is a very very similar
45:44 - syntax the only difference is we're not
45:45 - surrounding the height is greater than
45:47 - four section with parentheses so again
45:51 - to be clear this bit between the if
45:54 - keyword and the curly brace will be
45:57 - evaluated and if it evaluates to true
46:00 - then the stuff inside the curly braces
46:03 - will be executed
46:05 - um so in this case we have the variable
46:07 - height and we're using the greater than
46:10 - operator to compare it to the number
46:12 - four so if height is greater than four
46:14 - then we'll print you are tall enough
46:17 - sort of listed some of the different
46:19 - comparison operators down here at the
46:21 - bottom they're basically identical to
46:23 - pretty much every other programming
46:25 - language you will probably have used uh
46:27 - up to this point
46:29 - additionally we can do different things
46:32 - if the if statement does not evaluate to
46:35 - true so this is a perfectly valid if
46:37 - statement you do not need an else if or
46:40 - an else block they are they're optional
46:43 - effectively
46:44 - um but the way it works is when we get
46:47 - to this code basically we'll we'll
46:49 - compare height to six right and if that
46:51 - expression evaluates to true then we'll
46:53 - just print you are super tall and we'll
46:56 - be done
46:57 - okay otherwise if that expression of
47:00 - values to false then we'll drop down
47:02 - into this next if else or sorry else if
47:05 - statement and we'll compare height to
47:08 - four if height is greater than four then
47:10 - we'll print you are tall enough and
47:13 - again we'll be done at that point so if
47:15 - this evaluates to true we execute this
47:18 - kind of section of code between the
47:20 - curly braces and at that point we'll be
47:22 - done
47:23 - otherwise if that's also false so if
47:26 - height is not greater than 6 and height
47:28 - is not greater than 4 then the else
47:30 - statement executes notice the else
47:33 - statement does not have its own
47:34 - expression it just kind of always
47:36 - executes if all of the if and else if
47:39 - statements um turned out to be false
47:42 - so let's jump into the assignment it
47:44 - says fix the bug on line 12. the if
47:46 - statement should print message sent if
47:49 - the message length
47:50 - is less than or equal to the max message
47:53 - length or message not sent otherwise
47:56 - okay cool so up here we've defined two
47:59 - variables message length is 10 Max
48:01 - messes length is 20.
48:03 - um and then here we're going to do some
48:04 - comparing let me just run the code in
48:06 - its current state
48:08 - it says trying to send a message of
48:10 - length 10 and a max length of 20.
48:13 - message not sent okay so that seems
48:16 - problematic right because with a message
48:18 - length of 10 and a Max message length of
48:20 - 20 I should be able to send that message
48:23 - so the Bug Online 12 I think we just
48:26 - need to flip this operator to be less
48:28 - than or equal to so that now this
48:31 - expression right message length less
48:33 - than or equal to Max message length
48:35 - should evaluate to true because it is
48:40 - message length is in fact smaller okay
48:42 - let's run that
48:47 - message sent that seems to work
48:49 - it's worth pointing out that in go we
48:51 - also have kind of an alternate way to
48:53 - write if statements
48:55 - if the variable that we are comparing in
48:59 - an if statement is only used in that if
49:02 - statement then this syntax can be
49:04 - helpful okay so here's kind of the
49:07 - traditional way of doing something we
49:08 - would create a variable called length
49:10 - let's just assume it's an integer you
49:11 - can kind of forget this function Syntax
49:14 - for now we'll talk about it in a future
49:17 - chapter but basically the idea here is
49:19 - we have a length variable it's an
49:20 - integer right and we're initializing it
49:22 - here we're creating the variable here
49:26 - um and then we're comparing it against
49:27 - one right we're checking if it's less
49:28 - than one and if it is we're doing
49:29 - something in this case we're printing
49:31 - that the email is invalid well instead
49:33 - of this syntax then by the way this
49:35 - works perfectly fine there's nothing
49:36 - wrong with doing it this way but we can
49:39 - alternately do it this way which is
49:40 - basically to initialize that length
49:43 - variable in the if block within that
49:46 - first kind of initial statement so
49:49 - notice there's two statements here
49:50 - separated by a semicolon
49:53 - and in the first one we're creating that
49:55 - length variable and then we're moving
49:58 - the comparison itself kind of after the
50:01 - semicolon
50:02 - and then if that condition obviously
50:04 - evaluates to true then we'll execute the
50:06 - block this does kind of two things for
50:08 - us first it saves us a line of code
50:12 - um which I would argue probably isn't
50:13 - the biggest benefit in the world
50:15 - um but more importantly uh it makes it
50:17 - so that this length variable is only
50:20 - accessible within uh kind of the scope
50:23 - of this if block so kind of down
50:26 - underneath this code we wouldn't be able
50:28 - to use the length uh variable anymore
50:30 - which is kind of nice if you never
50:32 - intended to use it in the first place
50:34 - you can kind of think of this as a clean
50:37 - code hack or like a
50:39 - um kind of safety hack to ensure that
50:43 - the length variable is never reused Down
50:46 - Below in other code when you never
50:47 - intended it to be reused okay so uh the
50:52 - question for this assignment is why
50:53 - would you use the initial section of an
50:56 - if statement and the answers are to
50:58 - confuse other programmers to keep the
51:00 - code concise and the scope limited or to
51:02 - speed up your code
51:04 - um the answer is going to be to keep the
51:05 - code more concise and to again limit the
51:07 - scope that that variable exists Within
51:12 - like other programming languages go
51:15 - supports functions functions are
51:16 - basically just a way to break up your
51:18 - code into individual units that are
51:21 - easier to reason about right a function
51:23 - takes in a specified number of inputs
51:25 - and it returns a specified number of
51:28 - outputs for example this subtract
51:30 - function here named sub takes two inputs
51:33 - X an integer and Y an integer and it
51:36 - returns a single integer in this case it
51:39 - just performs the simple calculation x
51:41 - minus y and then Returns the result to
51:44 - the caller now this little bit right
51:46 - here right Funk sub X integer y integer
51:50 - returns integer is what's known as the
51:53 - function signature if you've never heard
51:55 - that term before it's basically just a
51:58 - description of what the function does in
52:01 - terms of its types in terms of its
52:03 - inputs and its outputs and what types
52:05 - they are right this basically says this
52:08 - is a function called sub it takes an
52:10 - integer X and an integer Y and returns
52:12 - another integer function signatures are
52:15 - great because they tell us how we can
52:17 - use the functions really at the end of
52:19 - the day if we're the person calling the
52:20 - function or the person using the
52:22 - function really all we care about is
52:24 - what we need to give the function as
52:26 - inputs and what we get out of the
52:28 - function in terms of its outputs so we
52:30 - function signature basically tells us
52:32 - all we need to know about a function to
52:34 - be able to use it it omits all of the
52:36 - implementation details the stuff with
52:38 - within the curly brackets or within the
52:40 - body of the function so let's get on to
52:43 - the assignment Simon says we often need
52:45 - to manipulate strings in our messaging
52:47 - app that makes sense right we're working
52:48 - with SMS and email messages within
52:51 - textio so we're doing a lot of textual
52:53 - data manipulation
52:55 - the concat function should take two
52:57 - strings as inputs and smash them
53:00 - together right so returning a new string
53:02 - that is a concatenation of the inputs
53:04 - for example hello Plus World equals
53:07 - hello world so we'd expect to return
53:10 - this concatenated string from our concat
53:14 - function over here fix the function the
53:17 - function signature of concat to reflect
53:19 - its Behavior Okay cool so let me try
53:20 - running this and just see what happens
53:23 - looks like undefined S1
53:26 - undefined S2 undefined this one okay so
53:28 - these are undefined and
53:31 - so S1 and S2 that kind of stands for
53:33 - string one string two that makes sense
53:35 - the problem here is that we're not
53:38 - we're not telling go
53:41 - what the types of the inputs should be
53:45 - and this plus operator when operating on
53:47 - strings just concatenates so that should
53:49 - work let's go ahead and run that
53:54 - yeah this looks good to me I want to
53:57 - just make one more point about function
53:59 - signatures in go you'll notice that the
54:01 - type comes after
54:04 - the name of the variable so S1 is a
54:07 - string S2 is a string and that's just to
54:09 - make it a little easier to read the
54:11 - authors of the go programming language
54:12 - kind of built on uh a lot of the ideas
54:15 - from C and in C it was the reverse it
54:17 - was string S1 string S2 and that just
54:21 - kind of reads a little clunky if you're
54:23 - used to kind of speaking in plain
54:25 - English makes more sense for the type to
54:27 - kind of come after what it describes go
54:30 - provides another bit of interesting
54:32 - syntactic sugar when it comes to
54:33 - function signatures when multiple
54:35 - arguments are of the same type in this
54:37 - case X and Y the inputs to the add
54:39 - function are both integers the type only
54:42 - needs to be declared on the last one
54:45 - assuming that they're in order right so
54:47 - in this case this is valid go code and X
54:50 - and Y are both integers because they
54:52 - follow one another we can put the
54:54 - integer just after the Y if we were
54:57 - going to add say a string as a third
54:59 - parameter to this function then we would
55:01 - just add a comma here after int and put
55:04 - you know name String or whatever this is
55:07 - just a bit of syntactic sugar it makes
55:09 - our code a little less verbose you don't
55:11 - need to do this you can explicitly put
55:13 - the type on every input and output but
55:15 - you will often see code like this it's a
55:17 - convenient shorthand so we've got these
55:19 - two example Snippets of code Funk create
55:24 - user first name String last name String
55:26 - age ins and Funk create user first name
55:28 - last name String agent so which of the
55:31 - following is the most succinct way to
55:33 - write a function signature succinct is
55:34 - just another word for kind of it's I
55:37 - guess it's the opposite of verbose right
55:38 - fewer fewer words
55:42 - um it's going to be the one that uses
55:43 - the syntactic sugar which is this one
55:46 - because we're omitting the string
55:48 - keyword after first name so we already
55:50 - talked about this briefly the idea that
55:52 - in go we specify the type of a variable
55:57 - after the variable name and this is you
56:00 - know different from kind of the C style
56:01 - way of doing things which if you were to
56:03 - declare a variable Y in C you would say
56:05 - int Y and really the authors of the go
56:08 - programming language just felt that that
56:10 - didn't flow naturally from English it's
56:12 - not the way we talk right we say x is an
56:15 - integer not integer is X if you want to
56:19 - read up on that decision and why they
56:21 - ended up choosing that style then you
56:23 - can follow this link here assuming
56:24 - you're following Along on boot Dev
56:26 - so the question is what are we talking
56:28 - about when we discuss this declaration
56:30 - syntax right this the swapping of the
56:33 - name and the type
56:35 - um and here are options the decision
56:37 - about camel case versus snake case
56:40 - um the style of a language used to
56:41 - create new variables types and functions
56:43 - guard Clauses versus if else no the ever
56:46 - important question of tabs versus spaces
56:48 - now it's going to be the style of
56:50 - language used to create new variables
56:51 - types and functions related question is
56:54 - Which languages declaration syntax reads
56:56 - like English from right to left see or
56:58 - go the answer is going to be go go
57:01 - supports functions as data or basically
57:04 - the idea that you can pass functions
57:06 - around your program to be called in
57:08 - different places callbacks right if
57:10 - you're familiar with JavaScript then
57:12 - you're probably familiar with the idea
57:14 - of a callback it's a function that you
57:15 - could pass to another function to be
57:17 - called later this question deals with
57:20 - that idea whenever we pass a callback in
57:23 - go the type of the function changes
57:26 - based on what its inputs and outputs are
57:28 - so for example here
57:31 - Funk int is a function that takes two
57:35 - integers as an input and returns an
57:37 - integer and that's going to be a
57:39 - different type
57:41 - than a function that say took three
57:43 - integers as input and returned an
57:45 - integer and if you think about it it
57:47 - makes sense right if I'm going to pass
57:49 - ion to another function so that it can
57:51 - call it later it kind of needs to know
57:53 - how many inputs how many parameters it
57:56 - can pass into that function if it's a
57:58 - function that takes two inputs versus
58:00 - three inputs then the caller is going to
58:02 - have to write the code differently so we
58:05 - have to treat every function signature
58:07 - as its own unique type so this question
58:10 - is a bit of a doozy I encourage you to
58:12 - pause the video and try to work this one
58:14 - out on your own but basically it says
58:16 - what is this hairy beast here right F
58:20 - Funk Funk int
58:24 - all right
58:25 - potential answers are a function named F
58:28 - that takes as int takes an INT as the
58:31 - argument and returns an INT
58:33 - no it is not nearly that simple right
58:37 - a function named F that takes a function
58:39 - and an INT as arguments and returns a
58:43 - function let's see
58:45 - uh that right there is a full function
58:48 - and an INT
58:50 - as arguments and returns a function no
58:52 - this returns an INT
58:54 - okay a function named F that takes a
58:56 - function and an INT as wrote arguments
58:58 - and returns in it that's what I believe
59:00 - it will be
59:01 - function named F that takes a function
59:02 - as the argument and returns an INT yep
59:05 - that's not it so to be clear
59:08 - f is a function
59:10 - it takes two parameters
59:13 - a function
59:15 - right a function of a specific type a
59:17 - function that takes two ins and returns
59:19 - an INT
59:20 - and as its second parameter an INT
59:23 - and then F returns an INT
59:26 - hopefully that makes sense again feel
59:28 - free to pause the video and and stare at
59:30 - that for a second
59:31 - let's talk a little bit about memory and
59:34 - how data that we create in our program
59:37 - using variables is stored in memory so
59:40 - over here
59:42 - I'll keep track of the memory of our
59:44 - program and over here I'll write some
59:45 - code
59:48 - so let's say
59:50 - in our code we write X colon equals five
59:54 - right so we're creating a new variable
59:56 - called X and we're giving it the value
59:59 - the integer value of five and then we're
60:01 - placing the value five
60:04 - in that memory right stored as binary
60:08 - data within Ram now in our program X the
60:12 - symbol is essentially just a pointer
60:16 - it points to this location in memory so
60:20 - let's say on the next line of code we
60:22 - update X and we say x equals 2. so now
60:26 - we're reassigning the value of x to 2.
60:29 - now let's try something different what
60:31 - if we create a new variable called y
60:35 - and we initialize it to the current
60:37 - value of x which in this case happens to
60:40 - be 2.
60:41 - well in this case
60:44 - we're actually going to allocate a new
60:46 - section of memory to store the value of
60:49 - y
60:50 - and we'll initialize it to the current
60:52 - value of x which is 2.
60:56 - and the symbol y
60:59 - now has its own location in memory so we
61:04 - basically created a copy of X now this
61:08 - idea is really important to understand
61:10 - because sometimes in programming we'll
61:13 - have multiple variables that actually
61:16 - point to the same location in memory
61:18 - they can overwrite each other
61:20 - and sometimes we don't sometimes we have
61:22 - copies
61:23 - of data right so now for example if I
61:26 - were to update y let's say I made y
61:29 - equal 1
61:31 - at this point x would be unaffected X
61:34 - would remain 2
61:35 - but y now
61:37 - becomes one right because we have a copy
61:40 - these two variables X and Y reference
61:43 - different locations in memory so why
61:45 - does all of this matter well in go
61:47 - variables are passed by value not by
61:50 - reference so let's take a look at this
61:52 - code snippet here
61:54 - top of main we declare a new variable
61:56 - called X we set it equal to five and
61:58 - then we pass X into a function called
62:00 - increment
62:01 - the increment function just adds one to
62:04 - X right making it six
62:06 - after that we print X and the weird
62:09 - thing is
62:10 - that when we print X here we still get
62:13 - five and the reason for that is the
62:17 - increment function was operating on a
62:19 - copy of X when we pass X in here to
62:22 - increment increment gets a new copy of X
62:25 - still equal to 5. it increments that X
62:28 - to 6 and then because we are not
62:30 - returning it it essentially just gets
62:33 - thrown away and then back in main we
62:34 - still have this same X that's still
62:37 - equal to 5. the correct thing to do here
62:39 - would be to have the increment function
62:41 - return X after making its modification
62:44 - and up in main we would write x equals
62:48 - increment X so that we could capture the
62:51 - return value from the increment function
62:53 - so moving on to the assignment it says
62:55 - it's critical in textio that we keep
62:57 - track of how many SMS messages we have
62:59 - sent on behalf of our clients fix the
63:01 - bug to accurately track the number of
63:03 - SMS messages sent okay let me just try
63:06 - running this in its current state
63:09 - and we're missing a return
63:11 - okay I'm going to remove this
63:14 - this uh type return there and see what
63:18 - happens
63:19 - set 430 messages
63:22 - and it looks like here we have sends so
63:24 - far sends to add increment sends is
63:27 - doing nothing because sense so far is
63:30 - still printing
63:32 - is 430.
63:34 - okay I think I'm understanding so let me
63:37 - put that back in
63:38 - the assignment says alter increment
63:40 - sends so that it Returns the result
63:42 - after incrementing sends so far
63:45 - alter the main function to capture the
63:47 - return value from increment sends and
63:49 - overwrite the previous sends so far
63:51 - value Okay cool so this is pretty
63:53 - similar to the code snippet here
63:55 - basically we need to return an INT so
63:58 - we're going to return
64:00 - send so far
64:02 - and then here
64:04 - we need to reassign since so far
64:07 - into the result of increment sense
64:10 - cool
64:12 - so
64:13 - again here we'll still be operating on
64:16 - copies but because we're going to return
64:18 - the copy and save it back into the
64:20 - original variable we should be good to
64:22 - go let me run that
64:24 - yep you sent 455 messages that looks
64:28 - correct functions in go can have
64:30 - multiple return values and when they do
64:32 - have multiple return values the Syntax
64:35 - for specifying that is just to wrap the
64:37 - return values in parentheses as well so
64:40 - when there's just a single return value
64:42 - we do not wrap that return value in
64:44 - parentheses but when there are multiples
64:46 - we do wrap them in parentheses one thing
64:49 - I really like about go is that it does
64:52 - not allow you to have unused variables
64:55 - and because it doesn't allow you to have
64:57 - unused variables and because it allows
64:59 - you to have multiple return values from
65:01 - a function we kind of need a way to
65:03 - ignore some of the return values because
65:05 - there are definitely instances where a
65:07 - function returns two things but maybe we
65:09 - only care about one of those things for
65:11 - example a point on a graph can be
65:13 - described by its X Y coordinates but
65:16 - maybe all we care about is the x
65:18 - coordinate so here we can call the get
65:20 - Point function and ignore the Y value by
65:24 - using an underscore and it's important
65:25 - to understand that the underscore is not
65:27 - just like a conventional name that we're
65:30 - going to ignore it's actually ignored
65:32 - the compiler
65:33 - completely removes it from our code so
65:36 - moving on to the assignment here in
65:38 - textio we have obviously first names and
65:40 - last names for all of the users that
65:42 - we're able to send messages to well when
65:45 - we welcome someone to textio we don't
65:47 - need their last name so let me go ahead
65:50 - and try to run this code
65:51 - and you'll see we'll actually get a
65:53 - compiler error that says last name
65:54 - declared and not used like I said go
65:57 - does not allow us to have unused
65:59 - variables which I think is a kind of an
66:02 - awesome uh little bit of the tooling it
66:04 - helps keep our code very clean and
66:06 - concise easy to understand
66:08 - um so we need to explicitly ignore that
66:12 - last name with an underscore if we're
66:13 - not going to use it let me try running
66:15 - that again
66:16 - and that looks good to me
66:19 - in go we can name our return values and
66:22 - if we do it actually Alters the behavior
66:24 - of the function just a little bit let's
66:27 - take a look at this function get chords
66:29 - or get coordinates it returns two
66:31 - integers and we've named the integers X
66:35 - and Y and by naming them we've actually
66:38 - initialized at the top of the function
66:40 - the the variables X and Y and they're
66:43 - initialized with their zero values so in
66:45 - the case of an integer literally just
66:47 - the number zero for both of them the
66:50 - other interesting thing about naming our
66:52 - return values is that if we use a naked
66:55 - return statement
66:57 - a return statement that doesn't
66:58 - explicitly say for example return 0
67:02 - comma five then the values of X and Y
67:06 - are automatically returned from the
67:09 - function so
67:11 - this version of get coordinates is
67:14 - actually the exact same as this kind of
67:17 - more verbose version of get coordinates
67:19 - right here we have not given the return
67:22 - values the names X and Y and instead
67:24 - we've initialized X and Y to their zero
67:27 - values and then returned them explicitly
67:29 - now a couple of recommendations I would
67:32 - recommend using named returns when you
67:36 - want to document kind of what the
67:38 - intended purpose of each return value is
67:42 - so for example if you have a function
67:44 - that just returns three integers that
67:46 - function signature could be pretty
67:47 - confusing but if you have a function
67:49 - signature that says it returns three
67:51 - integers and they're named width height
67:53 - and length that's a lot more interesting
67:56 - to the caller of the function they
67:58 - understand the purpose of each
68:00 - individual return value much better so I
68:02 - like to think of named return values as
68:05 - basically a built-in way of documenting
68:07 - what the purpose of all of your return
68:09 - values are and you should generally just
68:11 - use the them on the other hand this
68:13 - implicit or automatic return that you
68:16 - get along with named return values I
68:19 - would typically advise against you'd
68:21 - only want to use this in like very short
68:23 - very simple functions because it harms
68:27 - readability right and I'm pulling this
68:28 - directly from the tour of go they also
68:30 - agree with me
68:32 - um implicit returns or naked return
68:34 - statements
68:36 - um generally a little bit harder to
68:37 - understand so the way I would write this
68:39 - function personally would be get chords
68:41 - x y and and then I would explicitly
68:43 - return X and Y so let's jump down into
68:47 - the assignment it says one of our
68:49 - clients likes us to send text messages
68:50 - reminding users of Life events coming up
68:53 - fix the bug by using named return values
68:55 - in the function signature so the code
68:57 - will compile and run as intended Okay
68:59 - cool so this is the function we are
69:02 - interested in fixing years until events
69:04 - looks like it takes a user's age as
69:07 - input and then returns or should return
69:10 - kind of the number of years until
69:12 - they're an adult which is 18 the number
69:14 - of years until they can drink at least
69:16 - in the US which is 21 and the number of
69:19 - years until they can rent a car which
69:20 - apparently is 25.
69:22 - um
69:22 - and it looks like we never want a
69:26 - negative number so if if any of these
69:29 - are less than zero we just set them
69:31 - equal to zero that makes sense once
69:34 - you're over 18 your years until you're
69:37 - an adult are just zero right you're
69:38 - already an adult
69:39 - okay let me try running this see what we
69:41 - get okay undefined years until adult all
69:44 - right this makes sense right because
69:47 - there's no colon here so we're not
69:49 - defining a new variable and the
69:50 - assignment said to use named return
69:52 - values so let's go ahead and do that
69:54 - two years until adults years until
69:57 - drinking I'm gonna
70:00 - format this a little better
70:04 - and we'll do years until car rental
70:08 - so again this will declare all of these
70:10 - values with their zero value at the top
70:11 - and then this naked return statement
70:14 - should return them in order
70:17 - and just to make sure adult drinking car
70:20 - rental
70:21 - adult drinking car rental okay we're in
70:23 - the right order let me run that
70:29 - first test so four years old they'll be
70:31 - an adult in 18 years can drink in 17
70:33 - coming to current 21 that all looks good
70:36 - 10 it's going down 22 Yep this looks
70:41 - good to me so as I mentioned before
70:43 - explicit returns are probably better
70:45 - than implicit returns in most scenarios
70:48 - it just makes a lot more sense right so
70:51 - here in this function get chords x y and
70:54 - so we're using named returns but we're
70:56 - still explicitly returning X and Y this
70:59 - is how I would recommend writing most of
71:02 - your go code
71:03 - um
71:05 - this this function here is doing the
71:07 - same thing it's explicitly returning
71:10 - hard-coded values though instead of the
71:12 - variables X and Y and it's just
71:15 - important to understand that this
71:16 - effectively overrides the implicit
71:18 - return of X and Y so in this case 5 and
71:21 - 6 will be returned again that's why I
71:23 - recommend doing it explicitly because
71:25 - when you see a return statement that has
71:27 - explicit values being returned those are
71:30 - the ones that are returned you don't
71:31 - have to do any guesswork you don't have
71:32 - to scroll back to the top of the
71:33 - function to see which values are being
71:35 - returned so now we're going to break
71:37 - that advice just for practice's sake
71:40 - um the assignment says fix the function
71:41 - to return the named values implicitly
71:44 - okay so here we have a problem in our
71:46 - code where we are basically explicitly
71:48 - returning zeros which as we talked about
71:51 - overrides the implicit return so my
71:54 - guess is if we look at all of these yep
71:56 - every test is returning zeros
71:59 - if we just remove that implicit return
72:02 - and run that
72:04 - and it should work as intended
72:06 - yep
72:08 - and then just to show you what I mean
72:09 - like what I would recommend doing is
72:11 - this
72:17 - bigger
72:19 - like that that's how I'm going to
72:21 - recommend doing it and in fact because
72:22 - Boot Dev just checks the output this
72:26 - should work just fine with our test so
72:28 - I'm going to submit it like this
72:32 - moving on to some questions about named
72:34 - returns so it says when should naked
72:37 - returns be used and the answers are for
72:40 - large functions for small functions or
72:42 - for complex functions and I would argue
72:45 - if you're going to use naked returns at
72:46 - all which honestly I'd kind of just
72:48 - recommend against then you should only
72:49 - use them for small functions the more
72:52 - complex and large your functions get the
72:54 - more important it is to be explicit and
72:56 - readable and document your returns with
72:58 - named returns and things like that the
73:00 - next question is when should named
73:02 - returns be used so when there are many
73:05 - values being returned when the function
73:07 - is simple or when there are few
73:09 - parameters being returned I would argue
73:11 - it's never really a problem to name your
73:14 - return values but it's really important
73:17 - when there are many values being
73:19 - returned especially if there are many
73:20 - values of the same type being returned
73:23 - because then you can you know
73:24 - essentially tell the caller of your
73:26 - function through your function signature
73:28 - what they should expect each value to
73:30 - represent let's talk about one of my
73:31 - favorite programming patterns or
73:34 - programming styles that is early returns
73:36 - or what they're also sometimes called as
73:38 - guard Clauses so in early return or a
73:42 - guard Clause is exactly what it sounds
73:43 - like it's just when we return early from
73:46 - a function so this function divide if
73:49 - it's past a divisor of zero then it
73:52 - returns early with an error otherwise it
73:55 - goes ahead and does a kind of the
73:57 - division and Returns the results and a
74:00 - nil error now we're going to talk about
74:02 - errors soon you don't have to worry too
74:04 - much about how they work for now just
74:07 - understand that a nil error effectively
74:09 - means no error so when we're looking at
74:12 - this divide function we can understand
74:13 - that if the divisor is zero we're going
74:16 - to return early and basically say we
74:18 - can't do this division because we can't
74:20 - divide by zero otherwise we'll take the
74:23 - happy path towards the end of the
74:25 - function
74:26 - practices when it comes to software
74:29 - engineering and how we write code change
74:31 - all the time right there's millions of
74:33 - developers all around the world writing
74:35 - code and we all have different opinions
74:36 - and kind of the the common opinion about
74:40 - a certain style tends to change over
74:42 - time
74:43 - um the interesting thing is I think that
74:44 - these days
74:46 - um guard Clauses and early returns are
74:48 - kind of looked at as a good thing this
74:50 - is clean code right this is a good way
74:51 - to write code certainly most go
74:53 - programmers think this way but it wasn't
74:56 - always that way there used to kind of be
74:58 - a heuristic that developers used which
75:01 - was you shouldn't ever return from a
75:04 - function in more than one place so back
75:07 - when that was kind of the more popular
75:08 - way of doing things you'd get kind of
75:10 - nasty if else nested statements like
75:13 - this if you look at this function get
75:15 - insurance amount
75:17 - basically takes a status as input it
75:20 - returns an integer and it only has one
75:23 - return statement so it only returns from
75:25 - one place but I would argue that doesn't
75:27 - necessarily make this function all that
75:29 - much easier to understand right we're
75:31 - initializing a variable up at the top
75:33 - amount and then just in this big nasty
75:36 - nested if else chain we're kind of
75:38 - reassigning the value of amount based on
75:42 - some conditional logic now compare that
75:44 - with guard Clauses right so with guard
75:47 - Clauses instead of overwriting the
75:49 - variable amount and then returning it at
75:51 - the end of the function we're just
75:53 - returning early with the proper amount
75:55 - at each step of the way now both of
75:57 - these functions do the exact same thing
75:59 - they have the same behavior but I would
76:02 - argue that the one with the guard
76:03 - Clauses is much easier to understand
76:07 - so the question for this exercise is
76:09 - which is true guard Clauses are
76:11 - unreadable guard Clauses are generally
76:14 - worse than nested if else statements or
76:16 - guard Clauses provide a linear approach
76:18 - to logic trees okay so it's definitely
76:21 - not
76:22 - um these two right so I'm gonna go with
76:24 - provide a linear approach to logic trees
76:26 - and really all that means is rather than
76:28 - having to follow kind of a tree
76:30 - structure to look at conditional logic
76:32 - we can just follow a straight line right
76:34 - is it this no we move on is it this no
76:37 - we can move on right it allows us to
76:40 - break up kind of the cognitive load when
76:42 - we're when we're reading code so
76:43 - definitely a linear approach there the
76:46 - next question is what is a guard Clause
76:48 - so a bit wise or operation and and
76:50 - operation in Boolean logic or an early
76:52 - return from a function when a given
76:54 - condition is met and it is an early
76:56 - return
76:57 - let's talk about structs so structs are
77:00 - the first collection type that we're
77:01 - going to talk about in this course a
77:03 - collection type is just a type that
77:04 - contains other types in the case of a
77:07 - struct a struct is just a collection of
77:09 - key value pairs if you're familiar with
77:11 - python dictionaries or JavaScript object
77:14 - literals this is basically the same idea
77:16 - so for example we can define a car
77:19 - struct and we can say a car has a make a
77:22 - model a height and a width and each of
77:24 - those fields has its own Associated type
77:27 - so let's move on to the assignment I
77:29 - think looking at the code is going to be
77:30 - the easiest way to understand structs
77:33 - okay complete the message to send struct
77:36 - definition it needs two Fields phone
77:37 - number and integer and message a string
77:39 - and
77:41 - um on these exercises I always recommend
77:42 - kind of going and looking at the test
77:44 - Suite this is all the code the way boot
77:46 - Dev works like all the code is here and
77:49 - we're really just testing standard
77:50 - output to see if you got the right
77:51 - answer so you can see literally
77:53 - everything that's going on
77:55 - um
77:56 - so here you can see where a message to
77:57 - send is going to be instantiated with
77:59 - phone numbers and messages and here you
78:01 - can see where it's the uh if fields are
78:04 - going to be accessed with the dot
78:06 - operator so let me go ahead and run it
78:08 - in its current state we should get yep a
78:10 - compile time error where it's saying
78:12 - message is undefined phone number is
78:13 - undefined right so we need to add those
78:15 - to the definition
78:18 - all right phone number
78:20 - integer
78:23 - message
78:26 - string
78:27 - let's go ahead and run that
78:29 - and sending message love to have you
78:31 - aboard to that big number okay that
78:34 - looks good to me
78:35 - struct keys can hold any type not just
78:39 - primitive types like integers strings
78:41 - and booleans here you can see we've
78:43 - actually nested the wheel struct within
78:47 - the car struct right so we have the car
78:49 - Struck from the last example and we've
78:50 - added a front wheel and a back wheel and
78:53 - they are each of type wheel right and a
78:56 - wheel has a radius and a material so we
78:59 - can actually Nest structs within other
79:01 - structs and then we also saw this just a
79:03 - little bit in the last assignment but
79:06 - this is how we can instantiate a new
79:08 - instance of a struct right so
79:11 - this is the struck definition we're
79:13 - saying this is what a car looks like and
79:16 - then here we've created a new empty car
79:18 - called my car and when you create it
79:21 - kind of with those empty uh those empty
79:25 - brackets all of the fields inside of the
79:28 - struct will just be initialized to their
79:29 - default values there's zero values right
79:32 - so strings will be empty strings ins
79:34 - will be zero
79:36 - and then here we're using the dot
79:38 - operator to access Fields right so my
79:41 - car dot front wheel right so we're
79:43 - accessing the front wheel key and then
79:45 - dot radius to access access the radius
79:48 - within the front wheel and we're setting
79:50 - it equal to five again with this syntax
79:52 - stuff it's just best to get Hands-On
79:54 - keyboard and jump right into it so let's
79:56 - get to the assignment says textio has a
79:58 - bug we've been sending texts with
80:00 - information missing before we send text
80:02 - messages in textio we should check to
80:04 - make sure the required Fields have
80:06 - non-zero values notice that both the
80:08 - user structs that's this here is a
80:11 - nested struct or notice that the user
80:13 - struct is a nested struck within message
80:14 - to send okay so message to send has a
80:17 - message which is a string and then a
80:19 - sender and a recipient and both of those
80:21 - are of type user okay that makes sense a
80:25 - user is the sender a user is the
80:26 - recipient and then there is a message
80:27 - cool complete the send the can send
80:31 - message function
80:32 - okay
80:34 - it should only return true if the sender
80:37 - and recipient Fields each contain a name
80:39 - and a number if any of the default zero
80:42 - values are present return false instead
80:45 - Okay cool so can send message this is
80:48 - essentially a function that's going to
80:49 - validate a message to send to see if it
80:51 - actually has data inside of it so
80:55 - if I run the code right now
80:58 - it's always returning true right so you
81:02 - have an appointment tomorrow you have an
81:03 - event tomorrow
81:06 - I'm Susie Saul ah see there's a phone
81:08 - number missing there that's a problem
81:10 - looks like there's a phone number
81:12 - missing there that's a problem okay
81:15 - let's see so
81:17 - sender and recipients contain a name and
81:19 - a number so if m
81:22 - to send
81:24 - Dot
81:28 - sender enter
81:30 - name whatever dot name is
81:35 - empty
81:37 - and false
81:40 - right
81:42 - and then if Ms dot is going to be
81:45 - recipient
81:47 - is empty also return false so we're just
81:49 - going to do some guard Clauses here
81:51 - and then sender and recipient and now
81:53 - we're interested in the number
81:55 - number is an integer so if it's zero
81:59 - cool so we're just basically doing a
82:02 - very simple validation to make sure
82:04 - um that names aren't blank and numbers
82:06 - are not blank so let me run that
82:11 - okay so this one has all the information
82:13 - there and it's sent now this one has a
82:16 - number missing can't send message that
82:18 - looks correct
82:19 - okay this is looking good to me
82:23 - all right next up we have Anonymous
82:25 - structs so Anonymous trucks are just
82:28 - struct instances that don't have a name
82:31 - so whenever you create a new Anonymous
82:35 - struct and go you're you're immediately
82:37 - instantiating a struct of a given type
82:40 - right the type of the struct doesn't
82:43 - have a name so for example here we have
82:45 - a struct
82:47 - with a make and a model now in the
82:49 - exercise previously remember we actually
82:51 - had this same exact struct but we'd
82:54 - given it a name the name was car right
82:56 - here we haven't created a new struct
82:58 - definition we haven't created a new
83:00 - struck definition called car instead
83:02 - we're immediately instantiating a new
83:04 - instance of a struct called my car this
83:07 - could be named anything right and it
83:10 - just has a make and a model field on it
83:13 - so the only reason you would use an
83:15 - anonymous struct is if you have no
83:18 - reason to create more than one instance
83:21 - of the struct so to be clear about
83:24 - what's happening here we're creating a
83:26 - new variable called my car
83:27 - and it has two Fields it's a struct with
83:30 - two Fields make and model and we're
83:32 - immediately giving it a value of make
83:36 - Tesla Model 3.
83:38 - and this type this specific struct type
83:41 - doesn't exist anywhere else within our
83:43 - program this is kind of a type that's
83:44 - just unique to this one instance called
83:47 - my car it's not very common that you'll
83:50 - see kind of top level Anonymous structs
83:53 - like this more often you'll see nested
83:55 - Anonymous structs right so rather than
83:58 - creating wheel as a separate struct type
84:01 - we've just said well Wheels kind of
84:03 - always exist within cars I know that's
84:05 - not really true but maybe within our
84:07 - program it's true so we just create a
84:10 - little Anonymous struct within the
84:12 - greater car struct now as far as best
84:15 - practices in writing clean code my
84:18 - opinion is that you should generally
84:19 - favor named structs you avoid Anonymous
84:23 - trucks unless you have a really good
84:25 - reason to use them you'll really never
84:27 - go wrong with naming your structs okay
84:30 - so the question on this assignment is
84:33 - what is a good reason to use an
84:34 - anonymous struct you're worried about
84:36 - security you need your code to be faster
84:37 - you're worried about user privacy or it
84:40 - is only being used once
84:42 - well the only thing even remotely
84:44 - related to how Anonymous trucks work
84:46 - um is that it's only being used once so
84:48 - if you're certain that you only want
84:50 - this type to be used one time maybe you
84:52 - don't want someone accidentally reusing
84:53 - a type
84:54 - then you might want to use an anonymous
84:57 - struct
84:58 - next question is what's one advantage of
85:00 - using an anonymous struct anonymous
85:02 - trucks make your code run faster
85:04 - Anonymous drugs prevent you from reusing
85:05 - a struck definition you never intended
85:07 - to reuse or Anonymous trucks can be
85:09 - compiled more quickly it's this reuse
85:12 - one one place that I have used Anonymous
85:16 - kind of top level structs from time to
85:17 - time is in HTTP handlers so if I know
85:20 - that a given HTTP endpoint will always
85:23 - return a specific Json payload then I'll
85:27 - use an anonymous struct to define the
85:29 - shape of that Json payload we haven't
85:31 - really talked about Json in go yet but
85:34 - kind of spoiler alert structs are how we
85:36 - structure Json data typically
85:39 - next we have embedded structs and
85:42 - embedded structs are not the same thing
85:44 - as nested structs an embedded struct is
85:47 - basically where we take all the fields
85:49 - from one struct and kind of shove them
85:52 - into another one let me show you what I
85:54 - mean so here's our car struct that we've
85:58 - been using for our examples um it's got
86:00 - to make in a model great here's our
86:02 - truck struct now you'll notice we've
86:06 - embedded the car type here but the car
86:10 - is missing kind of a name a key in the
86:13 - truck struct the bed size is the key ENT
86:16 - is the type here we just have the type
86:18 - which is car
86:20 - so what does this do and how does it
86:22 - differ from a nested struct well in the
86:24 - embedded struct if we want to access the
86:27 - field model from a an instance of a
86:31 - truck rather than doing truck dot car
86:34 - dot model we would just do truck dot
86:37 - model because these fields of the car
86:40 - type are becoming kind of top level
86:42 - fields of the truck type we're
86:45 - inheriting all of those fields from the
86:48 - car type now I have to be careful with
86:50 - the word inherit even though it is kind
86:52 - of a pretty good descriptive term for
86:54 - what's happening go is not an
86:56 - object-oriented language because it
86:59 - doesn't support classes or inheritance
87:01 - in the class-based sense so if you're
87:03 - familiar with the idea of object
87:05 - oriented programming just know that
87:06 - classes and inheritance aren't really
87:09 - what's going on here this is you can
87:11 - almost just think of this as a shorthand
87:13 - for kind of retyping this make and model
87:16 - into the truck struct it's it's almost
87:18 - just a syntactic sugar so that we don't
87:21 - have to retype all of these fields so
87:25 - let's take a look at some code and how
87:28 - we would use this truck struct so I've
87:30 - created this new instance of a truck
87:33 - called it Lanes truck has a bed size
87:35 - which is an integer right and it has a
87:38 - car
87:39 - here now you might look at that and say
87:41 - that looks an awful lot like a nested
87:42 - struct and the Syntax for creating a new
87:46 - instance of an embedded struct is very
87:49 - similar to the Syntax for a nested
87:52 - struct essentially the key is just the
87:55 - same name as the type this is kind of a
87:58 - quirky thing about
88:00 - um composite literals the embedded stuff
88:03 - looks like the nested stuff however when
88:05 - we're accessing the individual fields on
88:10 - um Lane's truck using the dot operator
88:12 - you'll see they're all accessed at the
88:14 - top level it's not Lane's truck dot
88:18 - car.make it's lanestruck. make right
88:21 - it's not
88:22 - lanestruck.car.model it's just Lane's
88:24 - truck dot model so those fields are
88:26 - being brought up
88:27 - into the top level it's just when we
88:30 - kind of instantiate the truck the first
88:32 - time that we need to do this sort of
88:33 - nested syntax so let's hop into the
88:36 - assignment it says at textio a user
88:39 - which is a struct represents an account
88:41 - holder an Ascender is just a user with
88:44 - some additional sender specific data a
88:46 - sender is a user that has a rate limit
88:48 - field that tells us how many messages
88:49 - they are allowed to send fix the system
88:51 - by using an embedded struct as expected
88:53 - by the test code okay so let's go ahead
88:55 - and take a look at the test code
88:58 - so it looks like the test code is
89:00 - creating some senders
89:02 - and it's expecting that a sender
89:05 - has a rate limit and that it has a user
89:08 - right and this is looking like an
89:10 - embedded struct
89:12 - and up here you can see s is a sender
89:15 - and we're directly accessing name number
89:17 - and rate limit all the top level
89:20 - so I think all I need to do here is
89:22 - embed the user struct in fact let's run
89:24 - this without without that see what
89:26 - happens yep we're getting some undefined
89:29 - fields
89:30 - we'll embed the user type in there
89:35 - and that's looking pretty good to me
89:38 - I will mention just to give you an idea
89:41 - of like when you use this in the real
89:42 - world one place that I use it actively
89:44 - on boot Dev is users have kind of public
89:47 - fields on boot Dev and private Fields so
89:50 - public fields are stuff that we show on
89:53 - the leaderboard things that kind of
89:54 - anyone can see about your profile maybe
89:56 - your bio or your profile picture but
89:59 - users also have private Fields things
90:01 - like your hashed password right the
90:04 - password we store in the database and
90:05 - I've actually embedded
90:07 - the private Fields within the public
90:10 - user so that I can easily nullify them
90:13 - when I don't want to send private data
90:16 - to a given web page
90:19 - all right let's go ahead and run this
90:22 - code
90:24 - let's talk about methods on structs or
90:27 - just methods in general in go
90:30 - um I know I told you go is not objects
90:31 - oriented and it's not but if you squint
90:34 - really hard structs in go kind of look
90:37 - like classes in a language like Java
90:40 - JavaScript or python so methods in go
90:43 - are just Behavior or functions that we
90:46 - can Define on a type and more often than
90:48 - not we end up defining methods on
90:50 - structs although we could Define methods
90:52 - on any type so let's take a look at the
90:55 - Syntax for this so here we have a simple
90:57 - rectangle struct it has a width and a
90:59 - height right and here we've defined an
91:03 - area method on the rectangle struct so
91:07 - this is just a function right we're
91:09 - familiar with functions already the only
91:11 - difference is that we've added this
91:12 - special parameter before the name of the
91:14 - function
91:15 - which is again just a parameter that
91:18 - comes into the function just it's just a
91:20 - special parameter in in this case it is
91:23 - of type rect which is just a struct and
91:25 - we've named it r
91:27 - and then this function just returns r
91:30 - dot width times r dot height right so it
91:32 - Returns the area of the rectangle so why
91:35 - would we use a method on a struct well
91:38 - there are reasons that we'll get to
91:39 - later when we talk about interfaces
91:42 - um but for now it's mostly a syntactic
91:44 - thing a syntactic sugar thing if we have
91:47 - behavior that we want to Define on a
91:49 - given type then structs can be a really
91:52 - good choice they give us this nice
91:53 - syntactic sugar right we create this new
91:55 - rectangle called R and now we can just
91:57 - call r dot area to get the area of the
92:00 - rectangle it a nice way to do computed
92:04 - properties on a type right so we could
92:07 - have stored area as a separate number
92:09 - within the rect struct
92:12 - the problem with that is now we lose
92:14 - kind of a single source of Truth when it
92:17 - comes to the area right if we store the
92:19 - area as say 50 and the width and height
92:22 - is 5 and 10 but then we update the
92:24 - height and forget to update the area
92:26 - right now we have a bug in our code so
92:29 - this is a great way to kind of have a
92:32 - one-line accessor to get the area of a
92:35 - rectangle but we don't have to actually
92:37 - store that area in our struct as kind of
92:40 - duplicate data so let's get down to the
92:42 - assignment it says let's clean up
92:43 - textio's authentication logic we store
92:46 - our users authentication data inside an
92:48 - authentication info struct okay so
92:51 - that's here it's got a username and a
92:52 - password we need a method that can take
92:54 - that data and return a basic
92:55 - authorization string the format of the
92:57 - string should be authorization basic
92:59 - username colon password right so this is
93:01 - the kind of standard basic authorization
93:03 - that's used in HTTP requests
93:06 - the assignment says create a method on
93:07 - authentication info called get basic
93:10 - auth that Returns the formatted string
93:12 - okay cool
93:14 - so let's create a new
93:19 - a new method and we can kind of
93:21 - reference this syntax over here so it's
93:23 - func and we want the receiver to be an
93:26 - authentication info struct so I'll just
93:27 - call it AI who that's that's actually
93:29 - confusing let's do auth auth I
93:33 - authentication info
93:36 - and we wanted the name of the method to
93:40 - be called get basic auth
93:42 - and it returns a string
93:45 - okay and then we want to return this
93:49 - format here
93:52 - so if you remember we can use the format
93:54 - package to do that so we'll return
93:56 - fmt.sprintf
94:00 - remember s print F Returns the string
94:02 - rather than printing it to standard out
94:04 - over to the console and we'll use
94:10 - that template
94:12 - username and password are both just
94:15 - strings so we'll use percent s for our
94:17 - formatting verbs and then we can do auth
94:20 - I Dot
94:22 - username first
94:24 - and auth I dot password
94:28 - next okay cool that looks correct to me
94:31 - let's run it
94:35 - perfect
94:37 - let's talk about interfaces so an
94:39 - interface in go is just a collection of
94:42 - method signatures for example take a
94:44 - look at this shape interface so we have
94:46 - an interface it's named shape and it
94:49 - specifies two different method
94:50 - signatures so area is a method that
94:53 - takes no parameters and returns a
94:56 - float64. perimeter is another method
94:58 - that takes no parameters and returns a
95:00 - float64. now any type that implements
95:03 - both of these methods and and matches
95:06 - their method signatures will implement
95:08 - the shape interface which really just
95:10 - means that we can think of it and treat
95:12 - it as a shape so for example let's take
95:15 - a look at this rectangle struct so erect
95:18 - has a width and a height both of which
95:21 - are float 64s and again this is just a
95:24 - this is just a kind of standard struct
95:27 - and it has two methods on it uh one is
95:30 - the area method it takes no parameters
95:32 - returns a float64 one is the perimeter
95:35 - that takes no parameters and returns a
95:37 - flow 64. and because a rectangle
95:39 - implements both of these methods we can
95:41 - think of a rectangle as a shape a shape
95:45 - is just anything where we can kind of
95:48 - calculate its area and calculate its
95:50 - perimeter and multiple types can
95:52 - implement the same interface so for
95:54 - example this circle struct it has a
95:57 - different underlying data right rather
95:59 - than a width and a height we can
96:01 - represent a circle with just a radius
96:03 - but to calculate its area and its
96:05 - perimeter the calculation is a little
96:07 - bit different right we're using pi for
96:09 - example but the method signature is
96:12 - identical right we don't pass anything
96:13 - in because we have all the data we need
96:15 - on the circle struct and we just return
96:17 - a float64. so both circles and
96:20 - rectangles because they implement the
96:23 - required methods can be thought of as
96:25 - shapes or we could say they implement
96:27 - the shape interface let's get into the
96:30 - assignment I think it'll all start to
96:31 - make a little more sense so the
96:33 - assignment says the birthday message and
96:34 - sending report structs have already
96:36 - implemented the get message method
96:39 - so let's take a look at that so birthday
96:42 - message is destruct here sending report
96:44 - is destruct here they both have this get
96:46 - message method that returns a string
96:49 - and they're just it looks like the
96:51 - strings that they return are just a
96:52 - little bit different right the birthday
96:53 - messages get message uh function returns
96:56 - this like hi blank it is your birthday
96:59 - on blank and ascending report says your
97:02 - blank report is ready right so they're
97:04 - just they just formatted a little a
97:06 - little differently
97:07 - okay so Simon Says first add the get
97:10 - message method as a requirement on the
97:12 - method interface okay so we need to
97:14 - finish the message interface
97:17 - and add a get message method
97:21 - that returns a string
97:24 - Okay cool so now this message interface
97:27 - because birthday message and sending
97:30 - report both implement this method we can
97:33 - think of both of those as messages next
97:37 - it says complete the send message
97:39 - function it should print a messages
97:41 - message which it obtains through the
97:43 - interface method Okay cool so the a
97:46 - message is an interface so inside of the
97:49 - send message function we don't actually
97:51 - know if we're dealing with say a
97:53 - birthday message or sending report we
97:55 - just know that we have access to a
97:57 - message so really the only thing we can
97:58 - do with it is call get message
98:02 - which we know will return a string and
98:04 - it says it should print a message so
98:06 - we'll do fmt.printline
98:09 - just print out the message
98:11 - cool
98:13 - okay now this is powerful right let's go
98:15 - take a look at how this code is actually
98:18 - called so we have this test function
98:20 - that also just takes a method a message
98:22 - and it sends that message right it's
98:25 - just calling our send message function
98:27 - here
98:28 - but down here and this is where it's
98:30 - most interesting the test function is
98:33 - not past like
98:36 - interface literals that's not even like
98:38 - a real thing right an interface is like
98:40 - abstract type that represents other
98:42 - types instead because the test function
98:45 - takes an interface we can pass into it
98:48 - any struct that implements that
98:50 - interface so for example here on line 42
98:53 - we're passing an ascending report and
98:55 - then on line 46 we're passing in a
98:57 - birthday message those are two different
98:59 - types in a strongly typed language being
99:01 - passed in as the first parameter to a
99:03 - single function but the reason it works
99:05 - is because we're using interfaces
99:09 - okay let's go ahead and run this see
99:11 - what happens
99:14 - your first report report is ready you've
99:16 - sent 10 messages hi John Doe it is your
99:18 - birthday
99:20 - this looks great this looks great to me
99:24 - in go interfaces are implemented
99:27 - implicitly and what that means is when
99:30 - we have a type like in our last example
99:32 - we had the rectangle type that
99:34 - implemented the shape interface we never
99:36 - had to explicitly write anywhere on the
99:40 - rectangle struct that it was intended to
99:44 - implement the shape interface because it
99:47 - satisfied all the requirements of the
99:49 - shape interface it just kind of
99:50 - automatically implemented it and that's
99:53 - fairly unique to go in a language like
99:55 - Java we might have to write something
99:56 - like this
99:57 - um we can take a look at this little
99:58 - example here we've got this employee
100:01 - interface and a contractor struct if we
100:03 - wanted the contractor to implement the
100:05 - employee we would need it to still
100:08 - fulfill the interface right by
100:09 - implementing all the methods but we
100:10 - might need to also explicitly type
100:12 - something like implements
100:14 - employee
100:16 - right we'd explicitly say that we intend
100:18 - to implement that interface in go it's
100:21 - done automatically let's hop into the
100:23 - assignment it says at textio we have
100:25 - full-time employees and contract
100:26 - employees we've been tasked with making
100:28 - a more General employee interface so
100:31 - that dealing with different employee
100:32 - types is a little simpler add the
100:35 - missing get salary method to the
100:37 - contractor type so that it fulfills the
100:40 - employee interface Okay cool so we have
100:42 - the employee interface we have the
100:44 - contractor struct
100:46 - and if we look at the full-time struct
100:48 - it looks like it already implements
100:50 - the employee interface so we just need
100:53 - to add the Missing Method because right
100:56 - now a contractor has a get name but does
100:59 - not have a get salary okay cool
101:02 - let's go ahead and do that we'll do
101:03 - employee
101:05 - get salary it returns an INT
101:08 - and a contractor's salary is their
101:11 - hourly pay multiplied by how many hours
101:13 - they work per year
101:15 - okay so be something like
101:19 - C Dot
101:21 - hourly pay multiplied by C DOT hours
101:28 - here
101:30 - okay and just because I'm curious I want
101:32 - to go look at how a full-time salary uh
101:35 - employee works yeah so you can see the
101:38 - the way that a full-time employee their
101:41 - salary is calculated is is totally
101:42 - different like their their salary is
101:44 - actually just stored probably because
101:45 - the way we think of full-time employees
101:47 - is like you know you make sixty thousand
101:48 - dollars a year you make seventy thousand
101:49 - dollars a year whereas contractors often
101:51 - get paid by the hour so it makes sense
101:53 - that they have a different calculation
101:55 - and then down here in the test Suite
101:58 - um this looks very similar to the last
102:00 - assignment where the test function is
102:02 - able to take as inputs any type of
102:04 - employee right so we can pass in both
102:07 - full-time and contractors here let's go
102:09 - ahead and run that
102:14 - Jack Bob and Jill we can see all of
102:17 - their salaries even though
102:22 - Jack is full-time and Bob and Jill are
102:24 - both contractors so that looks good to
102:26 - me
102:27 - in go types Implement interfaces
102:30 - implicitly because it kind of decouples
102:32 - the definition of the interface from the
102:34 - definition of the type the type doesn't
102:37 - even really need to know that it
102:38 - implements a certain interface and
102:41 - that's really really cool because it
102:43 - means it's easy for a type to interfa to
102:45 - implement lots of different interfaces
102:48 - so the quiz question here is how is an
102:50 - interface fulfilled
102:52 - answers are a type has all the required
102:54 - interfaces methods defined on it or a
102:57 - struct embeds the interface in its
102:59 - definition and the answer is going to be
103:01 - it has all the methods defined the next
103:04 - question is can a Type fulfill multiple
103:07 - interfaces or Implement multiple
103:09 - interfaces and yes why not another quiz
103:12 - question go uses the blank keyword to
103:15 - show that a type implements an interface
103:17 - and the answers are fulfills implements
103:19 - inherits and there is no keyword in go
103:21 - and the answer is that there is no
103:23 - keyword in go interfaces are implemented
103:26 - implicitly
103:32 - in the next question it says in the
103:34 - example given the blank type implements
103:36 - the blank interface let's take a look
103:40 - so example here we've got the shape
103:42 - interface Circle struct
103:46 - Ural has an area method so it looks like
103:48 - the circle type implements the shape
103:51 - interface like we talked about before a
103:53 - type can Implement multiple interfaces
103:55 - it just needs to have all the methods
103:57 - for all the different interfaces for
103:59 - example the empty interface so that's
104:01 - this this definition right here this is
104:03 - an interface with no methods required
104:07 - is actually always implemented by every
104:10 - single type in the go programming
104:12 - language now it's often not a very
104:14 - useful interface because you can't
104:16 - really do anything with an empty
104:17 - interface you have no methods to call
104:19 - let's jump down into the assignment it
104:21 - says add the required method so that the
104:23 - email type implements both the expense
104:25 - and printer interfaces Okay cool so
104:27 - we've got these expense and printer
104:29 - interfaces
104:31 - two different methods we need to
104:32 - implement
104:33 - and we have this email type with an is
104:35 - subscribe Boolean and body string cool
104:39 - all right cost method
104:41 - if the email is not subscribed so if not
104:44 - e dot is subscribed I believe is what
104:47 - the field was
104:49 - then the cost is 0.05 times
104:53 - uh the length
104:56 - for each character in the body so the
104:58 - length e dot body now remember go is
105:02 - strongly typed and we can't multiply an
105:05 - INT by a float directly so we need to
105:07 - cast this integer sorry I think I
105:09 - highlighted those backwards
105:12 - the length of the body is an integer
105:14 - this is a float so we need to cast
105:17 - the length of the body to a float so we
105:18 - can we can multiply a float by float
105:22 - um otherwise we'll return
105:24 - uh it's a 0.01
105:29 - times that same thing the length of the
105:31 - body
105:32 - cool uh the print function should just
105:35 - print to standard out the email's body
105:36 - text easy enough
105:38 - print line e dot body
105:43 - okay
105:45 - so now our email struct implements both
105:48 - of these interfaces and if we come down
105:50 - here to look at the test function
105:55 - this is interesting the test function
105:57 - takes an expense and a printer
106:00 - right so we can use both of those
106:01 - methods there
106:04 - and actually the email struct so we're
106:07 - creating instances of emails here we're
106:10 - actually passing it into test as both
106:12 - the expense and the printer right
106:15 - because it makes sense it implements
106:17 - both cool let me run that
106:20 - oh what did I screw up 0.05 times float
106:22 - 64 length value of type 64 is not used
106:27 - to
106:28 - let's see
106:32 - 0.05 times 64 length of e dot body what
106:37 - did I screw up value of type float64 is
106:40 - not used
106:43 - I forgot my return
106:45 - cool let's try that again
106:49 - Okay so
106:52 - switching with cost 11 cents hello there
106:54 - printing with cost one dollar I want my
106:56 - money back yeah that looks that looks
106:59 - pretty good
106:59 - let's submit it
107:02 - up until this point we haven't really
107:04 - been naming the arguments of our
107:06 - interfaces method signatures
107:09 - um but we totally could so if we take a
107:10 - look at this this is The copier
107:12 - interface it's a copy method that it
107:15 - requires which takes two strings and
107:17 - returns an INT the interesting thing is
107:19 - when you look at this method signature
107:22 - it's kind of hard to tell what the
107:23 - intention behind the interface is it's
107:26 - like great it takes two strings but what
107:28 - are those strings supposed to represent
107:30 - right so here we can take a look at what
107:33 - I would consider a better interface
107:36 - definition where The copier interface
107:38 - actually has a copy method that
107:40 - specifies the source file is kind of the
107:42 - name of the first parameter and the
107:45 - destination file is the name of the
107:47 - second parameter and it bytes copied is
107:50 - the integer that's returned so you know
107:53 - the functionality here is identical but
107:56 - now we have much better I I mean I would
107:59 - consider it documentation of what the
108:01 - intention behind this interface is
108:04 - so the question is are you required to
108:06 - name the arguments of an interface in
108:08 - order for your code to compile properly
108:09 - uh no no it'll work fine either way next
108:14 - question is why would you name your
108:16 - interface's methods parameters right
108:17 - like we don't need to why would we do it
108:19 - execution speed memory savings or
108:22 - readability and Clarity uh it's going to
108:24 - be for readability and Clarity type
108:26 - assertions so type assertions are
108:29 - something you'll see every once in a
108:31 - while I would argue they're probably not
108:32 - super common but you will come across
108:34 - them and the whole purpose of a type
108:36 - assertion is so that you can take an
108:38 - interface and kind of cast it back into
108:41 - its underlying type so in this code
108:43 - sample here we can kind of assume that s
108:46 - is an instance of a shape interface and
108:49 - at this point in the code because it's
108:51 - just an interface we don't know
108:52 - necessarily if it's a circle or maybe a
108:54 - square or maybe some other type so what
108:57 - we do is we do a type assertion to cast
109:00 - it to the circle struct and basically
109:03 - what what happens here is on the left
109:05 - hand side of the um this short
109:10 - declaration operator here we get back
109:12 - the instance of the circle so this is
109:14 - going to be an instance of the circle
109:17 - struct again the underlying struct
109:19 - behind the shape interface
109:21 - if it was a circle right because we
109:25 - can't be sure if we had a shape we're
109:26 - not sure if it was a circle or maybe
109:27 - something else but this okay variable
109:31 - this is going to be a Boolean and if
109:33 - it's true then it was a circle and we
109:37 - should have a valid kind of filled out
109:38 - Circle struct if okay is false then we
109:42 - kind of have to discard the circle
109:45 - um because we weren't able to parse out
109:47 - um the shape as a circle because it
109:49 - wasn't a circle
109:51 - so let's move on to the assignment it's
109:53 - an email then it should return the
109:54 - emails to address and the cost of the
109:56 - email if the expense is an SMS then it
109:58 - should return the sms's phone number and
110:00 - cost if the expense is any other
110:02 - underlying type just return an empty
110:03 - string and a 0.0 for the cost Okay cool
110:06 - so we've got this get expense report it
110:08 - takes an expense as input and my guess
110:12 - is yep expense is this interface so our
110:15 - job is to kind of try to cast it into
110:18 - the potential underlying types email and
110:21 - SMS
110:22 - so
110:24 - first we do
110:25 - email okay
110:29 - expense Dot and we'll cast it to an
110:33 - email type
110:34 - if okay
110:37 - so if it's an email return the emails to
110:39 - address so it's going to return email
110:43 - dot to address
110:48 - as that string there
110:50 - and
110:52 - also it's cost so email dot looks like
110:55 - cost is a method
110:57 - email.cost okay
111:01 - next we can do s okay
111:06 - e dot cast on SMS so if it's an SMS we
111:12 - can return
111:14 - sms's to phone number to phone number
111:20 - and the
111:22 - sms.cost I believe that's also just yep
111:25 - just a method
111:27 - okay it says otherwise if it has a
111:31 - different underlying type return empty
111:34 - string
111:35 - and 0.0 for the cost
111:38 - okay cool that feels
111:43 - at least like we followed the
111:44 - instructions let's see what we get
111:47 - not enough arguments in call to SMS dot
111:50 - cost let's take a look at sms.cast
111:54 - hmm
111:57 - have want
111:59 - what did I screw up here
112:04 - ah it should be s dot cost I named I
112:07 - named The Struck the struct S all right
112:09 - let's try that again
112:13 - report the email going to John Doe will
112:15 - cost
112:16 - 11 email the sms okay cool and invalid
112:20 - expense perfect
112:22 - I mean that feels right I can come down
112:24 - here and check the test Suite yeah
112:26 - invalid okay cool let's submit that
112:29 - when we want to do a lot of successive
112:31 - type assertions in a row there's
112:33 - actually a better way and that's with
112:34 - type switches so here's a Syntax for a
112:37 - type switch basically we have an
112:40 - interface and we cast it
112:42 - at the very top of the switch and then
112:44 - we can actually check and kind of
112:46 - pattern match against different possible
112:48 - types
112:50 - if none of the types that we've
112:52 - specified are the matching underlying
112:54 - type then it will kind of fall down to
112:56 - the default case so let's write some
112:59 - code and see how it works um down in the
113:01 - assignment it says after submitting our
113:02 - last snippet of code for review a more
113:04 - experienced gopher or term for a go
113:07 - developer told us to use a type switch
113:09 - instead of successive assertions let's
113:12 - make that Improvement implement the get
113:14 - expense report function using a type
113:16 - switch
113:17 - Okay cool so kind of the same thing
113:20 - though if it's an email we'll return a
113:22 - to address and a cost if it's an SMS
113:24 - then we should return a phone number to
113:25 - cost blah blah blah right the difference
113:27 - is we're going to use a different syntax
113:29 - this time okay so we're going to be
113:31 - using this switch syntax
113:33 - so switch
113:37 - value colon equals e DOT type
113:42 - okay Open brackets case we are
113:46 - interested in if the expense is an email
113:50 - so case email now the interesting thing
113:52 - is with now within this case block V is
113:56 - an email so I can treat it like an email
113:58 - so I can do return V Dot
114:02 - oh what was it two address I think yeah
114:05 - new address
114:08 - B dot cost
114:12 - Ace SMS
114:15 - return V Dot to phone number I think it
114:19 - was two phone number
114:22 - B dot cost
114:25 - and default
114:27 - return
114:29 - uh I think it was empty string just zero
114:32 - values right empty string and 0.0
114:35 - okay cool let's see what happens
114:39 - with that oh am I forgetting nope I've
114:41 - got
114:42 - oh I'm indenting a little weird
114:45 - there we go let's run that
114:49 - cool BMS SMS is going to be is going to
114:52 - this number with this cost
114:55 - got some emails and costs okay that's
114:57 - looking good to me now that we've
114:59 - learned what interfaces are and how we
115:01 - use them let's talk about how we can use
115:03 - them more effective and in a sort of
115:05 - idiomatic and clean way if you forget
115:08 - all of the other advice that we're going
115:10 - to go over when it comes to writing
115:12 - cleaning interfaces don't forget this
115:15 - one and that is to keep interfaces as
115:17 - small as you can the best the cleanest
115:20 - and the most useful interfaces typically
115:22 - just have one or two methods defined on
115:25 - them imagine a simple Stringer interface
115:28 - it has one method defined on it called
115:30 - string that simply returns a string you
115:33 - can take that interface and implement it
115:36 - on basically any type and now you have a
115:38 - super useful interface for logging out
115:41 - string representations of different
115:42 - types there isn't a hard and fast rule
115:45 - about exactly how many methods you
115:47 - should be defining on your interfaces
115:49 - but what you really should be doing is
115:51 - looking for kind of the minimal Behavior
115:54 - necessary to accurately represent an
115:56 - idea or concept right so for example
115:59 - here's a slightly larger interface from
116:02 - the standard Library again normally
116:04 - we'll see interfaces in the standard
116:05 - library with maybe just one or two or
116:07 - three methods this one has five but this
116:11 - is kind of still the minimum amount or
116:15 - or the the minimal necessary behavior
116:18 - that we need to describe a file like a
116:20 - file in your file system right we need a
116:22 - way to close the file we need a way to
116:24 - read it we need a way to seek to
116:26 - individual uh kind of sections of the
116:29 - file
116:30 - so this is an example of a slightly
116:33 - larger interface right I would say five
116:35 - methods is definitely a on the larger
116:37 - end but it's still a good interface
116:40 - because it's using as as little Behavior
116:44 - as it possibly can to describe an
116:46 - operating system file so the question
116:48 - that goes along with this is interfaces
116:51 - should have as blank methods as possible
116:53 - and the answers are complex few and many
116:56 - and the answer is going to be few the
116:59 - next mistake that I've seen new go
117:01 - developers make is when they write an
117:03 - interface that sort of knows about the
117:07 - types that they've intended to satisfy
117:10 - it so for example if you have a car
117:12 - interface and you've defined an is fire
117:16 - truck method on the car interface that
117:18 - returns a pool you know whether or not
117:20 - it's a fire truck that's probably a
117:22 - mistake you would actually just want to
117:24 - use a type assertion or a type switch if
117:26 - you really needed to figure out the
117:28 - underlying type you should not make your
117:31 - interfaces aware of the underlying types
117:33 - this also breaks rule number one right
117:35 - because rule number one we don't need to
117:37 - know if a car is a fire truck for like
117:39 - the minimal behavior of a car I mean you
117:43 - can see how this sort of design pattern
117:45 - would get out of hand very quickly
117:46 - because we might need to also Define
117:48 - other booleans like is pickup is sedan
117:51 - is tank right if you start catering to
117:54 - all of the underlying types of a given
117:56 - interface your interface is going to be
117:58 - really bloated and become very very
118:00 - large so the question here is actually
118:02 - the reverse it says it's okay for types
118:05 - to be aware of the interfaces that they
118:07 - satisfy if it were flipped around the
118:10 - answer would definitely be false but
118:11 - because we're talking about the types
118:13 - being aware of the interfaces they
118:14 - satisfy I don't think that's necessarily
118:16 - a problem they don't need to be aware of
118:19 - them right because again in go
118:21 - interfaces are satisfied implicitly but
118:24 - I would argue to some extent they are
118:26 - aware of them because the developer had
118:28 - to go in some cases out of their way to
118:31 - satisfy the implementation of an
118:33 - interface so I'm going to go with true
118:34 - on this one so now this is the reverse
118:37 - question it says it's okay for
118:39 - interfaces to be aware of the types that
118:40 - satisfy them no they should not be aware
118:43 - finally I just want to talk about how
118:45 - interfaces are not classes sometimes
118:47 - this can get mixed up especially if
118:49 - you're coming from an object-oriented
118:50 - background interfaces are just a very
118:53 - different idea interfaces are not
118:55 - classes they are much Slimmer classes
118:57 - have a lot of functionality going on
118:59 - inheritance is a fairly complex topic
119:01 - interfaces are honestly just a simpler
119:05 - idea interfaces don't have Constructors
119:08 - or deconstructors that require the data
119:10 - is created or destroyed right so that's
119:12 - another way that they differ from
119:13 - classes that have kind of this inherent
119:16 - setup and tear down situation
119:19 - interfaces are not hierarchical right
119:22 - there's there's no hierarchical
119:24 - inheritance tree when it comes to
119:26 - interfaces and the most interesting one
119:29 - is that interfaces defined function
119:31 - signatures but not underlying Behavior
119:34 - right so this is actually a big
119:36 - difference between interfaces and
119:39 - classes in a class A Child class can
119:42 - inherit behavior from a parent class
119:44 - which can kind of dry up your code right
119:46 - don't repeat yourself in go that's not
119:49 - the case at all an interface doesn't dry
119:50 - up your code you still have to go
119:52 - Implement all of the methods on all of
119:54 - the different types individually
119:56 - interfaces just allow us to use all of
119:58 - those types kind of in the same places
120:01 - later in this course we'll get to talk
120:04 - about generics which is a way to kind of
120:07 - dry up your code and funny enough kind
120:10 - of uses interfaces under the hood or
120:13 - kind of as a part of the generics system
120:16 - to make that happen
120:18 - so finally the question is interfaces
120:20 - allow you to define a method's behavior
120:22 - once and use it for many different types
120:25 - that's false go has a very unique way of
120:30 - handling errors really quickly let's
120:32 - review how JavaScript handles errors and
120:35 - the way JavaScript handles errors is
120:36 - very similar to python or Java it uses a
120:39 - try catch Paradigm and let's contrast
120:41 - that with how go handles errors in its
120:43 - sort of unique way let's pretend that we
120:45 - have a function called get user and
120:48 - we'll start with JavaScript so we have a
120:50 - function called get user whoa
120:53 - and it returns a user so we'll do const
120:56 - user equals get user and we have to wrap
121:00 - the get user function the call to the
121:02 - get user function in a try block because
121:04 - we know that the get user function can
121:06 - throw because let's just say for example
121:07 - maybe the user doesn't exist Okay cool
121:11 - so if something goes wrong we add a
121:14 - catch block and if this function throws
121:17 - execution will stop we'll enter the
121:19 - catch block and do whatever's in here
121:20 - for now we can just console.log
121:24 - the error now let's take a look at what
121:26 - this function looks like in go
121:28 - we'd do something like this we do user
121:32 - error colon equals get user
121:38 - if error does not equal nil
121:43 - then we could print out the error and
121:46 - return so that we don't continue and
121:48 - then down here we could you know deal
121:51 - with the user object so use user here
121:55 - and for consistency sake we could say
121:57 - use user here after the user object is
122:00 - created in JavaScript okay so what's the
122:03 - difference well let's talk about the
122:04 - first reason why I prefer goes error
122:07 - handling to JavaScript error handling
122:09 - let's pretend we need to go get some
122:12 - data for the user after we've already
122:14 - kind of retrieved the user successfully
122:17 - so let's say we need to go get the
122:18 - user's profile picture well in go all we
122:21 - would do
122:22 - is call the next dangerous function
122:24 - let's say get user Pro profile and maybe
122:28 - it takes a user dot ID as input right so
122:32 - we need to successfully wait for the
122:34 - user to come back and then we can go
122:36 - fetch its profile
122:39 - all right so this looks very similar
122:41 - we're
122:42 - doing another dangerous function get
122:44 - user profile and it returns a profile
122:46 - and an error if an error with the
122:49 - profile occurs again we'll just kind of
122:51 - print out the error in return otherwise
122:53 - now we have a profile object okay what
122:56 - would we do in JavaScript well in
122:58 - JavaScript we can't just take this try
123:01 - catch and paste it down here and update
123:04 - some stuff this will not work if we do
123:06 - get user profile user dot ID
123:11 - profile
123:14 - the problem with this code is that user
123:18 - is only available within this try Block
123:21 - it's scoped to the try block right so
123:24 - this user object here will be undefined
123:27 - so the normal thing to do in JavaScript
123:29 - would just be to take this line here
123:32 - and inject it within
123:35 - the try block
123:37 - the original try block right so now I'm
123:39 - doing my second dangerous function after
123:41 - I do my first dangerous function the
123:44 - reason I don't like this is that the
123:46 - logic for handling the errors is now all
123:49 - in one place if I want to handle the
123:53 - error for the get user profile function
123:55 - differently or separately that I want to
123:59 - handle the error from the get user
124:00 - function I have to actually Nest the
124:02 - whole try catch
124:04 - like this
124:07 - right so now user.id is accessible
124:09 - because I'm in the same try block but I
124:12 - get a second catch block so we kind of
124:14 - get this nasty nesting if we want to
124:17 - treat each individual error separately
124:19 - and this kind of brings us to the second
124:21 - reason why I prefer goes error handling
124:24 - and it's that it forces us to think
124:26 - about each individual error that's
124:29 - passed back from a dangerous function so
124:32 - again in JavaScript kind of the normal
124:34 - thing to do unless you really needed
124:36 - separate error handling would be to just
124:38 - kind of do all of your dangerous stuff
124:39 - in one large try block the problem with
124:42 - this in my opinion is that it kind of it
124:46 - doesn't encourage me to remember which
124:49 - of these functions is dangerous in the
124:51 - first place for example maybe this is a
124:53 - safe function and this is a dangerous
124:54 - function that can potentially throw in
124:56 - error but looking at this code from kind
124:58 - of a calling perspective I don't really
125:01 - know that that's the case whereas in go
125:03 - because a function returns kind of the
125:06 - valid data and the error with every
125:09 - function call I know for a fact that the
125:12 - get user profile function can throw an
125:16 - error because it returns an error value
125:19 - this will probably make more sense if I
125:21 - actually write out some of these
125:22 - functions so in JavaScript the get user
125:24 - function might look just like this
125:25 - function get user
125:29 - uh we could say uh do some get user
125:33 - logic here
125:36 - and then maybe it returns you know a
125:38 - user
125:40 - looking at the function signature
125:43 - all I can tell in JavaScript is that
125:46 - this function takes no arguments and the
125:48 - only way for me to know what it returns
125:49 - is to go find that return statement see
125:51 - oh okay it returns a user however in go
125:54 - I actually get two super helpful things
125:57 - in the function signature and remember
125:59 - the function signature is just kind of
126:01 - that first line of a function definition
126:03 - so in go if I were to write the function
126:05 - definition for the get user function
126:07 - would be something like this funk
126:09 - get user
126:10 - doesn't take any inputs but it returns a
126:14 - let's say a user struct
126:16 - and an error
126:18 - right and then we have some kind of
126:21 - do get user logic here
126:24 - right so now just by looking at this
126:27 - function signature I can tell that it
126:29 - returns a user and that it could
126:31 - possibly return an error as well that I
126:33 - need to go handle whereas again in
126:35 - JavaScript not only do I not get to see
126:38 - in the function signature what is
126:40 - potentially returned but I also don't
126:42 - know that this function can throw I have
126:44 - to kind of go digging deeper into the
126:46 - function definition to see if there's
126:49 - potentially something uh dangerous going
126:52 - on in the meat of the function so again
126:54 - to reiterate because this is actually a
126:56 - super important point when you're
126:58 - learning about how errors are handled in
127:00 - go the primary reason I like error
127:03 - handling in go is that it forces me as I
127:06 - write my code to be kind of hyper aware
127:09 - of every potential error and make sure
127:12 - that I write code that handles it so now
127:15 - that we understand what error handling
127:18 - in go kind of looks like from a high
127:19 - level let's dive into the details errors
127:22 - in go are just values and specifically
127:25 - they're just interfaces so the built-in
127:28 - error interface is an interface with a
127:31 - single method the error method and that
127:33 - method returns a string describing what
127:36 - went wrong so how do we actually go
127:38 - about handling errors in code well let's
127:40 - take a look at this function right here
127:42 - so this is a function in the standard
127:43 - Library it's called ASCII to integer it
127:46 - takes a string and attempts to convert
127:48 - it into an integer value and potentially
127:50 - that can be problematic right because
127:52 - you can write strings that aren't
127:54 - numbers under the hood Okay cool so what
127:57 - do we do we get back an integer and an
127:59 - error and in essence it's it's really
128:02 - simple the error
128:04 - is either nil or it's not nil if it is
128:08 - nil that means everything went fine and
128:10 - nothing went wrong so if the error is
128:13 - nil it means there is no kind of string
128:16 - representing what went wrong because
128:18 - nothing went wrong however if the error
128:21 - is not nil that means something did go
128:24 - wrong right so if the error is not nil
128:27 - in this case then we'll print an error
128:29 - message and return from the function
128:31 - right so we're basically writing guard
128:34 - Clauses that say something went wrong
128:37 - let's handle this error and get out of
128:39 - here right enough talk let's write some
128:41 - code so you can see what I mean
128:43 - let me expand this so it's a little
128:45 - easier to see the code okay the
128:47 - assignment says we offer a product that
128:49 - allows businesses that use textio to
128:51 - send pairs of messages to couples it's
128:53 - mostly used by flower shops and movie
128:55 - theaters okay great complete the send
128:57 - SMS to couple function so that's this
128:59 - function here it should send two
129:00 - messages first to the customer and then
129:02 - to the customer's spouse so use send SMS
129:06 - to send the message to customer if an
129:08 - error is encountered returns 0.0 and the
129:11 - error uh do the same for message to
129:13 - spouse if both messages are sent
129:15 - successfully return the total cost of
129:16 - the messages added together okay I think
129:19 - I understand what's going on so we're
129:21 - basically going to send both of these
129:23 - messages one after the other
129:24 - um if any errors happen we kind of abort
129:27 - early and return the error
129:30 - okay so uh send SMS takes a message's
129:35 - input so first we'll say uh send
129:40 - SMS and we'll send the message to the
129:43 - customer
129:45 - and send SMS returns a float64 on air so
129:49 - we'll say I think it's the cost
129:53 - return the total cost okay yeah so cost
129:55 - error
129:56 - send SMS all right if error does not
129:59 - equal nil so if there was a problem
130:01 - sending the SMS
130:03 - uh returns 0.0 in the error so return
130:06 - 0.0
130:13 - right because this function send SMS to
130:15 - couple Returns the total cost and an
130:18 - error so we're saying if we failed to
130:20 - send the SMS then it costs nothing and
130:23 - we'll return the error that describes
130:25 - what went wrong
130:27 - otherwise we'll do it for the message to
130:29 - spouse so we kind of are just going to
130:30 - do this exact same thing so I'm going to
130:32 - say cost for for let's say customer
130:39 - cost for spouse
130:42 - and we'll be sending the message to the
130:43 - spouse
130:45 - cool
130:46 - all right now if we get to the bottom of
130:49 - the function that means nothing went
130:50 - wrong so we can return
130:53 - cost for customer
130:55 - Plus
130:56 - for spouse
130:59 - and nil
131:01 - right because we get down here nothing
131:03 - went wrong so we don't have an error to
131:05 - return okay let's go ahead and run this
131:07 - code and see what we get
131:10 - and I want to just scroll down and take
131:12 - a look at some of these test cases
131:14 - okay message for customer thanks for
131:16 - coming into our flower shop message for
131:18 - spouse we hope you enjoyed your gift
131:19 - error can't send texts over 25
131:21 - characters Okay cool so I mean if we
131:24 - look at the send SMS function it
131:26 - actually throws an error or I shouldn't
131:28 - say throws because we don't throw in go
131:30 - right but returns an error value that
131:33 - says can't send text over blank
131:35 - characters
131:36 - so that looks correct to me
131:39 - um here we've got message to customer
131:41 - message to spouse total cost
131:44 - okay this is looking pretty good to me
131:46 - I'm going to go ahead and submit that we
131:47 - talked about how error handling in go is
131:49 - all built around the error interface in
131:51 - fact let's just review that really
131:53 - quickly this error interface is really
131:55 - just an interface that wraps a method
131:57 - returning a string because if you think
131:59 - about it at the end of the day an error
132:01 - is just a kind of nullable string either
132:04 - it's a string representing what went
132:06 - wrong or saying what went wrong or it's
132:09 - nothing because nothing went wrong so
132:11 - being good at handling errors in go has
132:15 - a lot to do with being good at
132:16 - formatting strings or formatting useful
132:19 - error messages so let's review how we
132:21 - format strings and go most formatting go
132:24 - is built around kind of these formatting
132:26 - verbs that are defined in the format
132:28 - package the fmt package of the standard
132:31 - Library so for example the S printf
132:33 - function returns a string where it
132:36 - interpolates the values passed into the
132:38 - function after the formatting string
132:40 - into the formatting stream string where
132:44 - where where the verbs exist so for
132:45 - example this first percent V is replaced
132:48 - with name the second percent V is
132:50 - replaced with age
132:52 - percent V is the verb we use for sort of
132:54 - the default format right if you format
132:57 - an integer using percent V then it kind
133:00 - of just prints the integer in string
133:02 - form but there are other ways that we
133:04 - can format stuff for example the percent
133:06 - F verb is used to format floats and you
133:10 - can actually specify how many decimal
133:12 - places you want to show up in your
133:14 - output string by kind of prefixing the F
133:17 - portion with a 0.2 for two decimal
133:21 - places or say a point one for a single
133:23 - decimal place so let's jump right into
133:25 - the coding assignment
133:27 - assignment says we need better error
133:29 - logs for our backend developers to help
133:31 - them debug their code complete the get
133:33 - SMS error string functions that's this
133:35 - one right here it should return a string
133:37 - with this format
133:38 - Okay cool so I'm just going to jump
133:39 - right ahead
133:40 - so it should return
133:46 - fmt.s printf right because we're trying
133:49 - to format a string
133:50 - this format let me expand that a little
133:53 - bit
133:57 - okay so turn a string with that format
133:58 - cost is the cost of the SMS so I'm going
134:01 - to replace cost here with the cost
134:04 - formatted to two decimal places so
134:06 - percent point two F right for two
134:08 - decimal places and replace recipient
134:12 - with the stringified representation of
134:14 - the recipient's phone number which is
134:15 - the string here
134:17 - so percent V it's important to point out
134:20 - I could also use S here to format a
134:22 - string but V and S do the same thing
134:24 - effectively when you're working with
134:26 - strings
134:29 - and
134:31 - then we need to pass in as parameters
134:34 - the values that we want to format or
134:36 - that we want to interpolate into the
134:37 - string so it's going to be cost and
134:40 - recipient
134:42 - I'm going to dedent that because that is
134:44 - some crazy formatting
134:49 - okay that looks better
134:51 - all right SMS that costs percent 0.2 F
134:54 - to be sent to percent V this looks good
134:56 - to me all right I'm gonna go ahead and
134:57 - run that and see what we get
134:59 - ah right can't forget to
135:02 - import the formatting package
135:04 - let's run that
135:07 - okay SMS the costs 0.4 1.40 to be sent
135:11 - to the string cannot be sent
135:14 - awesome this looks correct to me I'm
135:17 - going to go ahead and submit that
135:19 - let's talk about building our own custom
135:21 - error types so remember the error
135:24 - interface is an interface in fact let me
135:26 - jump back and show you what it looks
135:28 - like again so it's just this interface
135:31 - here and because it's an interface that
135:33 - means we can build our own types like
135:36 - this user error struct here that
135:38 - Implement that interface which means
135:40 - they can be used as errors and remember
135:43 - that the error interface just has one
135:46 - single method that we need to Define
135:47 - right the error method that returns a
135:50 - string and as long as we have that then
135:53 - our type can be used as an error so for
135:56 - example we could create this user error
135:58 - type that stores a name
136:01 - and then we can use it as an error to
136:03 - format an error message that contains
136:06 - the name of the user's account who had
136:08 - an error so for example in this snippet
136:12 - here we have a send SMS function and if
136:15 - we're not able to send a message to a
136:16 - user we can actually just return that
136:18 - user error struct with the user's name
136:21 - and again that is an error we can return
136:25 - that struct as an error type because it
136:28 - implements the error interface the
136:30 - caller of this function would then just
136:31 - treat it like any other error the reason
136:34 - this is useful is that we can store
136:36 - structured data within our errors so if
136:39 - we want to format them a specific way we
136:42 - have access to sort of dynamic data like
136:44 - a name let's write some code that uses
136:47 - this concept so the assignment says our
136:49 - users are frequently trying to run
136:50 - custom analytics queries on their
136:52 - message deliverability metrics right so
136:55 - we're sending lots of messages we want
136:56 - to know are these messages getting
136:57 - delivered
136:59 - they end up writing a bad query that
137:01 - tries to divide a number by zero it's
137:02 - become such a problem that we think it
137:04 - would best to make a specific type of
137:05 - error for dividing by zero update the
137:08 - code so that the Divide error type so
137:11 - that's this error type here or rather
137:13 - this struct here
137:15 - implements the error interface its error
137:18 - method should return a string formatted
137:19 - and falling way cannot divide dividend
137:22 - by zero okay let's write that method so
137:26 - it's going to be
137:28 - a function on the Divide error type so
137:31 - I'm going to name it d e which is a
137:35 - a divide error
137:37 - and the name of the function must be
137:38 - error takes no arguments and returns a
137:41 - string right so that's that's the
137:43 - function signature we need to use to
137:46 - implement the error interface and then
137:48 - we're going to return a string
137:51 - and we're going to need to format the
137:52 - string so we'll use S printf
137:54 - the format package is already imported
137:58 - and this is our template
138:02 - and dividend in this case is a float 64.
138:07 - and
138:08 - you it says here dividend is the actual
138:11 - dividend use the percent V verb so
138:12 - percent V okay so we're just going to
138:15 - kind of do the default formatting for a
138:16 - float64.
138:18 - and
138:21 - let me indent all this so that it's kind
138:24 - of readable
138:26 - or dividend is the actual dividend of
138:28 - the Divide error okay so we'll do d e
138:30 - Dot
138:31 - dividend
138:33 - that will interpolate there
138:36 - okay that looks correct to me I think
138:38 - we've implemented the error interface
138:40 - properly let's go ahead and run that
138:42 - oh I forgot my comma
138:46 - um this is kind of an interesting Quirk
138:48 - of the go programming language
138:50 - um if you add a new line after the last
138:53 - parameter to a function you have to put
138:55 - a comma so this would work
138:59 - all right and
139:01 - this would work
139:05 - but this does not work right that's what
139:07 - I did the first time so just kind of
139:09 - something to watch out for
139:12 - okay so let's take a look at this um
139:13 - dividing ten by zero cannot divide 10 by
139:16 - 0 dividing ten by two quotient 5
139:18 - dividing 15 by 30. five okay this is
139:22 - looking like it formatted properly let's
139:24 - submit that so we've got a quiz question
139:26 - it says what is the underlying type of
139:28 - an error is it an interface is it a
139:30 - struct is it a string
139:32 - well it could technically be a structure
139:36 - a string right like we saw in the last
139:38 - uh the last assignment but the most
139:41 - correct thing would be to say an
139:43 - interface because it must always be an
139:46 - interface right it must always implement
139:48 - the error interface it could also be a
139:50 - structure a string but it will always be
139:53 - an interface next question is can a Type
139:55 - be an error and also fulfill another
139:57 - interface
139:59 - well errors are just interfaces and we
140:01 - know that types can fulfill any number
140:02 - of interfaces as long as they have all
140:04 - of the required methods so yeah there's
140:06 - no problem with this let's talk about
140:09 - the errors package so the standard
140:12 - library and go has an errors package
140:14 - that exposes a few useful
140:16 - functionalities but the one we're most
140:18 - interested in right now is the
140:19 - errors.new function so the useful thing
140:22 - about the errors.new function is allows
140:24 - us to create a new error from just a
140:27 - string so we don't need to kind of you
140:29 - know Define a new struct or a new type
140:30 - and then have it explicitly implement
140:32 - the error interface that can be a lot of
140:35 - code if all we want to do is kind of
140:38 - return an error with a very specific
140:40 - string let's go ahead and use it the
140:42 - assign is twilio 's software Architects
140:44 - may have over complicated the
140:45 - requirements from the last coding
140:46 - assignment yeah all we needed was a new
140:49 - generic error message that Returns the
140:50 - string no dividing by zero when a user
140:53 - attempts to get us to perform the taboo
140:54 - right the taboo of dividing something by
140:57 - zero complete the divide function use
140:59 - the errors.new function to create an
141:01 - error when y equals zero that reads no
141:03 - divided by zero okay so this is pretty
141:05 - straightforward basically if Y is 0
141:08 - which means that the the number that we
141:11 - divide by would be zero which is
141:13 - obviously a huge problem in mathematics
141:14 - you're not allowed to do that in go or
141:16 - most programming languages that I'm
141:18 - aware of so we need to return an error
141:20 - here so that this operation never
141:22 - happens so we'll return errors.new
141:26 - looks like the errors package is already
141:28 - imported for us and we just need to
141:31 - return an error
141:33 - that says no dividing by zero
141:38 - okay let's go ahead and run that and see
141:40 - what we get
141:41 - oh I screwed up
141:43 - this function returns a float64 and an
141:46 - error so we should return a zero value
141:49 - for that first value when we're
141:51 - returning a non-nil error let's go ahead
141:53 - and run that
141:55 - cool dividing 10 by 0 no dividing by
141:58 - zero
142:01 - all of this looks good to me let's talk
142:03 - about loops in go so if you are familiar
142:06 - with Loops in other languages loops and
142:08 - ghosts and tactically are very similar
142:09 - to say Loops in JavaScript the main
142:11 - difference is just that we don't use the
142:14 - parentheses around uh kind of the the
142:17 - signature of the for Loop
142:19 - um which again is very similar to how if
142:21 - statements in go work we're basically
142:22 - just dropping those uh parentheses
142:24 - syntactically
142:26 - um the initial portion runs at the
142:28 - beginning so for example in this snippet
142:30 - of code where We're looping over the
142:32 - integers 0 through 9. in the initial
142:35 - section we're just initializing a
142:37 - variable I and setting it equal to zero
142:39 - in the condition section we're checking
142:42 - and making sure that I is less than 10.
142:44 - so at the end of every uh kind of
142:47 - iteration of the body which in this case
142:48 - we're just printing I in the body we're
142:51 - going to check and make sure that I is
142:53 - less than 10. if it is we'll continue on
142:55 - to the next iteration of the loop
142:56 - otherwise we'll be done and then at the
142:59 - end of every iteration we'll also be
143:01 - running this after section so we'll be
143:04 - incrementing I and that happens before
143:06 - the condition is run so for example if
143:10 - we increment I to 10 and then I is no
143:13 - longer less than 10 we will not continue
143:15 - on to the next iteration of loop which
143:17 - is why this prints 0 through 9 and not 0
143:20 - through 10. let's jump right into the
143:21 - assignment it says at textio we have a
143:23 - dynamic formula for determining how much
143:25 - a batch of bulk messages cost to send so
143:28 - we need to complete the bulk send
143:29 - function it takes a number of messages
143:31 - as input and returns a float64 which it
143:34 - looks like will be the total cost of the
143:37 - batch of messages okay each message
143:40 - costs 1.0 plus an additional fee the fee
143:43 - structure is so it's going to be first
143:45 - message is 1.0 plus 0 so 0 is the fee
143:48 - second message is 1.0 plus 0.01 third
143:52 - message is 1.0 plus 0.02 okay cool and
143:55 - then our job is to use a loop to
143:57 - calculate the total cost of all of these
143:59 - messages for you know the number number
144:01 - of messages that we've been given
144:03 - okay let's let's just start writing some
144:05 - code so total cost I'm going to just
144:07 - start it out at 0.0 and then we'll use a
144:10 - loop where I colon equals zero to do
144:13 - like num messages iterations so you know
144:16 - a number of iterations equal to num
144:18 - messages so start I at zero and then
144:22 - we'll do I is less than
144:24 - now messages
144:27 - and I plus plus
144:30 - okay so this kind of body of the for
144:32 - Loop should execute num messages times
144:36 - and we're going to want to add to the
144:37 - total cost so plus equals and we're
144:40 - going to use this formula so it's going
144:41 - to be 1.0 Plus
144:44 - this fee and how do we calculate that
144:46 - fee well it looks to me like it is 0.01
144:50 - times the basically the message number
144:54 - right so for the first message at index
144:57 - 0 I equals 0 it's going to be a fee of
145:00 - zero so if we just use I this should
145:03 - work because if I is 0 and we multiply
145:05 - that by .01 anything multiplied by zero
145:07 - is zero right so we'd get 1.0 plus zero
145:10 - for the second message I should be one
145:13 - so we'll get 1 plus 0.01 because
145:15 - anything multiplied by 1 is itself and
145:18 - so on and so forth that's looking
145:20 - correct to me
145:21 - at the end of the function we'll just
145:22 - return a total cost
145:25 - cool let's run that
145:27 - oh
145:29 - untyped float constant truncated to int
145:31 - okay so I is an INT and we cannot
145:34 - multiply an INT by a float 64. so I'm
145:36 - going to cast
145:38 - um I to a float 64. let's try that again
145:42 - and take a look at some of these numbers
145:44 - Okay cool so the cost for 10 messages is
145:48 - 10.45 and that sounds about right
145:52 - because each message costs one
145:55 - plus this like fractional part that
145:57 - grows over time so like the 10th message
145:59 - would have cost like
146:02 - 0.10 and it would decrease over time
146:06 - so that looks about right to me
146:12 - 50 messages
146:15 - yep okay I'm going to go ahead and
146:17 - submit that one interesting thing about
146:19 - for Loops in go is that each section of
146:21 - the for Loop the initial the condition
146:23 - and the after are actually optional and
146:25 - we can omit any of them so for example
146:27 - if we omit the condition then the for
146:30 - Loop will just run forever so let's see
146:32 - why this might be useful um let's jump
146:34 - into the assignment the assignment says
146:36 - complete the max messages function given
146:38 - a cost threshold it should calculate the
146:39 - maximum number of messages that can be
146:41 - sent and then it looks like the fees for
146:43 - each message are going to be identical
146:45 - to the last assignment so let's go ahead
146:47 - and just get started so max messages we
146:49 - have a threshold a cost threshold right
146:51 - we want to see how many messages we can
146:54 - send while keeping the total cost under
146:56 - the threshold so I'm going to create a
146:58 - total cost variable
146:59 - and set it equal to 0.0
147:02 - and then this is going to look really
147:03 - similar to the last assignment but
147:06 - basically we'll set I equal to 0 to
147:08 - start
147:10 - I'll skip the condition for now because
147:13 - we don't know to what number we're kind
147:16 - of looping up to right we're trying to
147:18 - calculate that so I don't know where to
147:20 - stop yet
147:21 - um
147:22 - but I do want to increment I with every
147:25 - iteration of the loop
147:27 - and then I basically want to update the
147:29 - total cost by adding to it and use this
147:33 - formula over here right so it's going to
147:34 - be 1.0
147:37 - Plus
147:39 - 0.01 times
147:42 - I which I need to cast to a flow 64.
147:47 - okay so that formula is looking again
147:49 - identical last time now if I want to
147:51 - return
147:53 - the the maximum message that I can send
147:56 - while keeping the cost under the
147:58 - threshold and basically I need to check
148:00 - and say if the total cost is greater
148:04 - than the threshold
148:07 - then I should return
148:09 - I
148:10 - does that sound right so for example
148:13 - let's say that right off the bat
148:15 - the threshold were I don't know say
148:17 - negative one
148:18 - right so I'm not allowed to send
148:20 - anything I would want to in that case
148:21 - return zero right because I can't send
148:23 - any messages so what would happen we'd
148:25 - enter the loop I'd calculate the total
148:27 - cost for the first message which would
148:29 - be 1.0 and then because the total cost
148:32 - is already higher than threshold I would
148:34 - return I which would be zero so that
148:36 - works right
148:38 - however if the threshold were a little
148:39 - higher let's say the threshold were 1.5
148:41 - then what would happen is we'd do that
148:44 - comparison the total cost would be
148:47 - less than the threshold so we'd continue
148:51 - to the next Loop iteration of the loop
148:53 - where I would be incremented to one
148:55 - and then on that next iteration we'd go
148:57 - over okay so this is looking good to me
148:58 - let me go ahead and run this code
149:04 - okay so with a threshold of 10
149:08 - I can send nine messages without going
149:10 - over the threshold
149:12 - that sounds right
149:14 - right
149:16 - because I have like nine in some
149:17 - fractional part
149:19 - let's go ahead and submit it and see
149:20 - most programming languages have support
149:23 - for a while loop and really a while loop
149:26 - is very similar to a for Loop except it
149:29 - doesn't have that kind of initial and
149:31 - after statement it it just runs until
149:34 - some condition is no longer true now
149:38 - because of this similarity the authors
149:40 - of the go programming language decided
149:42 - to not include an explicit while loop
149:45 - with a while keyword instead the for
149:48 - Loop is a while loop where just
149:50 - basically both those side kind of
149:53 - sections are omitted and we just have a
149:57 - condition that follows the four keyword
149:58 - so in other words if we have a four
150:01 - keyword and then a single expression
150:03 - then it is a condition
150:05 - that while true will continue to kind of
150:08 - run the body of the loop over and over
150:10 - and over again until the condition stops
150:13 - being true let's take a look at an
150:15 - example here we have a variable called
150:18 - plant right we start it equal to one and
150:21 - we've done this outside of the for Loop
150:23 - right and then within the for Loop we
150:25 - just have one section where we're
150:27 - comparing the variable plant height to
150:29 - the number five
150:30 - right and while it is less than five
150:32 - we'll print this message and then at the
150:34 - end of the loop we'll increment plant
150:36 - height now you might notice this looks
150:38 - just like a for Loop where we've
150:39 - essentially taken the initial statement
150:40 - and moved it up outside of the for Loop
150:42 - body and we've taken the after statement
150:44 - and moved it within the for Loop body
150:45 - and that is what we've done right but
150:48 - it's to demonstrate that this is valid
150:51 - syntax let's jump right into the
150:53 - assignment okay so the assignment says
150:56 - we have an interesting new cost
150:57 - structure for our SMS vendor so at
150:59 - textio we have a vendor that we have to
151:01 - pay to send text messages through right
151:04 - so we're a software service that makes
151:05 - sending text messages easy but we do
151:08 - have to pay some kind of maybe Hardware
151:10 - service that actually does the sending
151:12 - of uh the text messages kind of over the
151:15 - wireless network
151:16 - okay
151:17 - um they charge exponentially more money
151:19 - for each consecutive test text we send
151:21 - let's write a function that can
151:22 - calculate how many messages we can send
151:23 - in a given batch uh given a cost
151:25 - multiplier and a Max cost in pennies
151:27 - okay so given a cost multiplier and a
151:30 - maximum cost our function will return
151:32 - basically the number of messages that
151:34 - we're allowed to send
151:36 - um that's under that that Max cost so it
151:39 - says in a nutshell the first message
151:41 - costs one penny Okay actual cost and
151:43 - penny starts at one and each message
151:45 - after that first message uh costs the
151:47 - same as the previous message multiplied
151:50 - by the cost multiplier okay so that's
151:53 - happening here
151:54 - um it gets expensive uh there is an
151:56 - infinite Loop in the code okay so on
151:58 - line 10 here we have this four with no
152:01 - body and then an open curly bracket
152:04 - um let me show you what happens when we
152:05 - run that
152:06 - our code's going to sit and run and
152:09 - execute the body of that for Loop over
152:11 - and over and over and over with no exit
152:12 - condition uh this is obviously a problem
152:14 - we don't want uh an infinite for Loop
152:17 - there so our job is to exit before
152:20 - incrementing Max messages to send if the
152:23 - cost of the next message would go over
152:24 - the Max cost so all we need to do is
152:27 - check
152:28 - and only execute this Loop while the
152:31 - actual cost is less than
152:34 - or equal to the Max cost in pennies
152:37 - and we're going to have to cast looks
152:39 - like so this is a float this is an end
152:41 - so we're going to cast this to
152:43 - 64.
152:47 - now this should work because Max message
152:49 - to send starts at zero
152:52 - so
152:54 - assuming the actual cost is less than
152:57 - the Max cost then we go ahead and
152:59 - increment say we can send one more
153:01 - message and then we take a look at the
153:03 - next cost and if the next cost is still
153:07 - less
153:09 - then we'll essentially get to add
153:10 - another message so we'll keep kind of
153:12 - looking ahead and calculating the next
153:14 - cost right and as soon as the next cost
153:17 - goes too high we stop
153:19 - okay so I'm gonna go ahead and run that
153:24 - cool so with a multiplier of 1.1
153:29 - and a Max cost of five we can send 17
153:32 - messages that sounds about right
153:35 - right the actual cost starts at one
153:40 - the Max cost is five multiplier of 1.1
153:42 - yeah that sounds right
153:44 - um so the multiplier goes up
153:46 - Max cost goes up now we can send nine
153:48 - messages that all looks good to me let's
153:51 - talk about the modulo operator how it
153:54 - works and go and kind of how it works uh
153:56 - generally so the modulo operator is a
154:00 - percent sign so it looks like this
154:03 - right and the modulo operator
154:05 - essentially calculates remainders
154:08 - remainders so what do I mean by that
154:10 - well let's jump into an example let me
154:13 - switch colors so
154:15 - four
154:17 - four divided by 3
154:19 - in sort of a normal floating Point
154:22 - division uh equals like
154:26 - 1.333333 forever right we have this
154:29 - fractional part however that's how math
154:31 - Works normally and that's how math Works
154:33 - in floating Point division in a language
154:35 - like go if we're doing integer division
154:37 - then we can't have a floating Point
154:39 - result so the result of 4 divided by 3
154:43 - in integer division is actually just one
154:45 - it's essentially the number of times
154:47 - that 3 can be divided evenly into four
154:51 - and then we chop off the remainder
154:53 - the interesting thing about the modulo
154:57 - operator
154:58 - is that for modulo 3 doesn't return the
155:03 - number of times that 3 can be divided
155:04 - evenly into four it Returns the
155:07 - remainder
155:09 - after that division so actually in the
155:11 - case of Four modulo 3 the remainder is
155:13 - also one so it's the same but for
155:16 - example five modulo 3
155:21 - is 2.
155:23 - and 6 modulo three
155:28 - is zero again because 3 divides evenly
155:31 - into six right
155:33 - six integer division
155:36 - by three
155:38 - is two right because 3 goes evenly into
155:41 - six twice but the remainder is zero
155:43 - that's why six mod three is zero let's
155:46 - say let's do a couple more examples feel
155:48 - free to pause the video in between when
155:51 - I give the question and provide the
155:53 - solution
155:54 - um so maybe you can practice a little
155:55 - bit
155:56 - okay so let's do 12.
155:59 - mod 4.
156:02 - we'll do in fact maybe I'll just write
156:04 - out all the problems first let's do 16
156:08 - Mod Five
156:10 - let's do
156:12 - 22
156:15 - mod 8.
156:18 - and let's do
156:21 - 27
156:23 - mod
156:25 - six
156:26 - I think those will be
156:28 - also we get okay 12 mod 4. so does four
156:31 - divide even Lanes twelve uh yes four
156:34 - times three is twelve right so the
156:35 - remainder is zero
156:37 - all right how many times does five
156:39 - divide evenly into 16 the answer is 3
156:42 - right 5 10 15.
156:44 - and the remainder would then be one
156:46 - how many times does eight go into 22 8
156:50 - 16 24 so 24 doesn't work so it's going
156:52 - to be 16 and then 22 subtract 16 is 6 is
156:57 - the remainder
156:58 - right and then 27 mod 6 goes into 27 4
157:02 - times 6 times 4 is 24 so a remainder of
157:06 - 3. so an important thing to note here is
157:09 - if you're trying to figure out if a
157:10 - number divides evenly into another
157:12 - number then you can just check if say a
157:17 - mod b
157:20 - equals zero right if a mod b equals zero
157:25 - then that means B divides into a an even
157:29 - number of times so a is a multiple of
157:32 - so in go the module operator is just
157:35 - that percent sign right so 7 mod 3 this
157:39 - expression is going to evaluate to one
157:41 - we'll also need to know about the
157:43 - logical and operator and the logical or
157:45 - operator which are double Ampersand and
157:47 - double bar respectively The Logical and
157:50 - operator operates on two Boolean values
157:53 - and only returns true if both sides are
157:57 - true right this and that
157:59 - the or Operator just needs at least one
158:03 - side to be true right in order for the
158:06 - entire expression to evaluate to True
158:08 - let's jump into the assignment it says
158:10 - we're hiring engineers at textio so it's
158:12 - time to brush up on the classic fizzbuzz
158:13 - game coding exercise has been
158:15 - dramatically overused in coding
158:16 - interviews around the world
158:18 - it's a function that prints the numbers
158:19 - 1 to 100 inclusive each on their own
158:21 - line but substitutes multiples of three
158:23 - for the text Fizz multiples of five for
158:25 - Buzz and multiples of three and five for
158:28 - fizzbuzz Okay so maybe a for Loop
158:33 - or I colon equals zero I is less than
158:36 - 100 actually less than or equal to
158:38 - because it's set inclusive right I plus
158:41 - plus
158:44 - okay
158:45 - um we need to think about the order in
158:47 - which
158:48 - kind of these things can happen so we're
158:50 - checking for multiples of three
158:51 - multiples of five and multiples of three
158:53 - and five so we actually should check for
158:55 - multiples of three and five first
158:57 - because something could be that and one
159:01 - of the other two conditions right it
159:02 - could be a multiple of three and five
159:04 - and just a multiple of three
159:06 - that makes sense maybe it'll make sense
159:08 - when I type it out so if I mod
159:15 - three zero
159:17 - and I mod
159:20 - three
159:23 - zero oops not three and three
159:27 - and five
159:28 - then we'll print
159:31 - Biz Buzz
159:33 - right
159:34 - else if
159:36 - I mod
159:38 - three zero
159:41 - then we'll just print
159:44 - is
159:47 - else if I Mod Five is zero we'll just
159:52 - print Buzz
159:54 - otherwise
159:56 - we'll print
160:00 - I
160:02 - right
160:04 - if they're both multiples fizzbuzz if
160:06 - it's just three Fizz if it's just five
160:09 - Buzz okay let's try that
160:13 - Oh cannot forget to import the
160:15 - formatting package
160:20 - okay
160:23 - let's see
160:25 - fizzbuzz one two Fizz four Buzz five is
160:29 - seven eight is Buzz one oh ha ha
160:34 - one through one hundred that would have
160:35 - been close I almost didn't follow
160:36 - instructions I was like why do we have a
160:38 - Fizz Buzz up front that doesn't uh that
160:40 - doesn't make sense okay cool
160:43 - the one tooth is four Buzz right five is
160:46 - a multiple of five ten is a multiple of
160:49 - five fifteen is a multiple of five and
160:51 - three so this is looking correct to me
160:55 - I'm gonna go ahead and submit that so in
160:57 - the last assignment we kind of uh did a
160:59 - if else chain within our for Loop but
161:01 - there's another way that we can write
161:03 - guard Clauses within Loops
161:06 - um so that we don't have to necessarily
161:07 - do that if else chaining
161:09 - um if we don't want to the continue
161:11 - keyword stops the current duration of a
161:13 - loop and continues to the next iteration
161:15 - so continue is a powerful way to use
161:16 - guard classes right so we write our for
161:18 - Loop and then if some condition happens
161:21 - we can kind of bail out of the body of
161:24 - the for Loop early and just continue on
161:26 - to the next iteration the break keyword
161:29 - is similar in that it stops the current
161:31 - iteration but instead of continuing on
161:33 - to the next iteration it just ends the
161:36 - loop entirely moving on to the
161:37 - assignment it says as an Easter egg we
161:39 - decide to reward our users with a free
161:41 - text message if they send a prime number
161:44 - of text messages this year because
161:46 - textio is is run by a bunch of nerds
161:48 - complete the price the print primes
161:51 - function it should print all of the
161:52 - prime numbers up to and including Max
161:55 - X it Should Skip any numbers that are
161:57 - not prime okay so here's the pseudocode
161:59 - print primes Max so let's convert this
162:02 - pseudo code into real go code so for n
162:07 - in range 2 to Max plus one so we're
162:09 - going to do four and colon equals two
162:14 - n is less than
162:16 - Max Plus One
162:20 - n plus plus
162:24 - okay if n is 2 if n is 2
162:30 - n is prime printed fmt dot print line n
162:36 - and we need to continue right
162:39 - continue to the next iteration you're
162:42 - basically saying okay this n is prime
162:43 - we'll print it and then we can move on
162:47 - all right if n is even so if
162:51 - n mod 2 is 0 right that's an easy way to
162:55 - check if something is even
162:57 - and not make your way onto our
162:59 - programmer humor
163:01 - if n mod 2 is 0
163:05 - n is not prime skip to the next end so
163:08 - we do not print and we just skip
163:11 - okay
163:13 - next we do a nested for Loop here for I
163:16 - in range so for I clone equals
163:20 - three to the square root of n plus one
163:24 - okay this is actually interesting I
163:26 - could use the math dot square root
163:28 - function here that would be a valid way
163:30 - but if I want to stay in integer land
163:32 - which I think I do
163:34 - I can do
163:37 - um
163:38 - I can instead Square I so I times I
163:43 - times I
163:45 - and see if it's less than n
163:48 - plus one
163:49 - right
163:51 - does that make sense so instead of doing
163:53 - I is less than the square root of n
163:56 - I can do I squared is less than n
164:01 - right
164:03 - that that makes sense to me
164:05 - cool
164:07 - um because basically we're just saying
164:08 - we only need to check up to the square
164:10 - root of n we know that if we go higher
164:12 - than that
164:13 - um we don't care about numbers higher
164:16 - than the square root
164:17 - um
164:18 - cool
164:19 - next one is I plus plus
164:26 - if I could be multiplied into n so if n
164:31 - mod I oops
164:34 - if if I goes into n evenly so if that
164:38 - results in a zero
164:40 - n is not prime skip to the next n
164:44 - okay so I can't continue here because if
164:48 - I continue here I'll just skip to the
164:49 - next I and I want to skip to the next n
164:53 - so I think what I do here
164:55 - is I do something like is prime
165:00 - true
165:02 - here I set is prime is false
165:06 - and break
165:08 - and then at the end of the for loop I
165:09 - can say if not is prime
165:15 - continue
165:17 - okay
165:21 - if n is not prime skipped next n yeah so
165:25 - we'll break out of this Loop
165:28 - it will break out of this Loop
165:31 - and then we'll continue
165:34 - cool
165:36 - now I just want to be clear there are
165:38 - other ways to write this function I'm
165:40 - kind of on purpose using lots of
165:42 - continues and breaks so that we can get
165:45 - some practice with it
165:46 - cool um n is prime printed so if we get
165:49 - all the way to here without any of these
165:51 - kind of guard Clauses being triggered
165:53 - then n is just Prime so fmt.printline
165:57 - and
165:58 - let's run that and just sanity check our
166:02 - code
166:03 - primes up to 10. two three five seven
166:08 - yep right that's two is a prime number
166:11 - it's kind of like the only even prime
166:13 - number and nine is an odd number before
166:17 - 10 but it's not prime because it's
166:20 - evenly divided into by three right maybe
166:22 - I should have even explained what prime
166:24 - numbers are in the first place in case
166:26 - you're not familiar there is uh there is
166:29 - a link here if you want to go read more
166:30 - about them but basically a prime number
166:32 - is any number where the numbers that
166:36 - multiply evenly into it are anything
166:39 - except one in itself so if it has any
166:42 - multiples or if it has anything that
166:45 - multiplies into it that isn't just one
166:49 - and itself it's Prime right so seven you
166:52 - can't you can't multiply two into seven
166:55 - you can't multiply three into seven you
166:57 - can't multiply four into seven right um
167:00 - so it's Prime
167:02 - um let's just uh look at a couple more
167:04 - of these examples so up to 20 we've got
167:06 - two three five seven eleven thirteen
167:08 - Seventeen nineteen right again we're
167:10 - skipping 15 because it has the multiples
167:12 - three and five
167:14 - 's up to 30
167:16 - um again skipping 25 and also skipping
167:20 - 27 because 9 divides evenly into 27 as
167:24 - as just three cool so hopefully that
167:26 - makes a bit of sense
167:28 - and then just kind of as a as an
167:31 - explanation of why this pseudo code
167:33 - Works we're skipping even numbers
167:34 - because they can't be prime right if 2
167:37 - divides into something it's not prime
167:39 - um we only check up to the square root
167:40 - because anything higher than the square
167:42 - root has no chance of multiplying evenly
167:45 - into n
167:46 - right so like for example take the
167:49 - number 16. its square root is 4 nothing
167:51 - over 4 could possibly evenly divide into
167:56 - 16.
167:58 - that the square root couldn't right so
168:00 - like for example 8 divides evenly into
168:02 - 16 but that's only because 4 and 2
168:05 - already do
168:07 - okay we start checking it two because
168:09 - one is not Prime
168:11 - one's kind of a special case number
168:14 - okay so this is looking correct to me
168:16 - I'm going to go ahead and submit it
168:20 - let's talk a little bit about how arrays
168:22 - work under the hood so if you're
168:24 - familiar with the idea of arrays from
168:26 - JavaScript or lists from python a race
168:29 - and go are similar
168:32 - you can think of an array as just an
168:34 - ordered list of items so we usually
168:37 - denote arrays with square brackets
168:39 - and an array of say three integers might
168:43 - be something like two
168:45 - two three
168:46 - one right so we've got three integers
168:49 - stored in our array the first thing is
168:52 - the integer two it's stored at index
168:54 - zero the next one is a three it's stored
168:57 - at index one and finally we have a one
169:00 - stored at index two now here's the big
169:04 - difference between arrays and go and
169:06 - arrays in JavaScript or lists in Python
169:08 - in go arrays have a fixed size so the
169:12 - type of this array would be
169:16 - three
169:19 - int
169:21 - so inside of the square brackets we kind
169:24 - of indicate the size of the array and
169:26 - then after we indicate the type of thing
169:29 - in the array so this arrays type is an
169:33 - array of three integers in languages
169:36 - like JavaScript or again like lists in
169:39 - Python arrays are kind of dynamically
169:42 - resized they don't have a fixed size you
169:44 - can add things onto the end you can push
169:46 - stuff on to the beginning but in go
169:49 - arrays are always fixed so to show you
169:52 - what this looks like in code basically
169:55 - we can create a new array of 10 integers
169:58 - like this
169:59 - it will initialize all of the indices in
170:02 - the array to the zero value so this
170:04 - would be an array of ten zeros basically
170:07 - if we know what we want to store at each
170:10 - index in the array then we can use an
170:13 - initialize literal here so we're saying
170:14 - we have an array of six integers and in
170:17 - the first index I wanted two and then a
170:19 - three and then a 5 and so on so let's
170:22 - jump into an assignment and see how this
170:24 - works
170:25 - the assignment says when a message is
170:26 - not responded to we allow our clients to
170:28 - have up to two additional messages that
170:30 - are sent as nudging reminders get
170:32 - message with retries returns an array of
170:35 - three strings where index 0 is the first
170:37 - message if the first message is not
170:39 - answered by the recipient we send second
170:41 - and then we'd send the Third
170:43 - update get message with three ties to
170:45 - return the three following strings in an
170:46 - array
170:47 - click here to sign up pretty please
170:49 - click here we beg you to sign up Okay
170:51 - cool so this is pretty straightforward
170:53 - here we're just going to return
170:55 - an array and you can see the return type
170:57 - up here it's a string array of size
171:00 - three so we just need to create an array
171:04 - literal and return it
171:06 - and in this case we want an array of
171:09 - strings of size three so Ray string size
171:12 - 3 and we can use these curly brackets
171:17 - um
171:18 - to be kind of where we put this string
171:20 - literal so the first string is going to
171:22 - be click here to sign up right this is
171:24 - the first message of the sent
171:27 - pretty please click here
171:31 - and we beg you we beg you to sign up
171:34 - and then just remember that in go you do
171:36 - have to put that last comma if you're
171:39 - going to use a new line
171:41 - okay
171:43 - um pretty straightforward right
171:45 - let's see how that works
171:48 - sending
171:51 - sending to Bob click here to sign up
171:53 - they responded sending to Alice click
171:55 - here to sign up pretty please click here
171:57 - they responded okay this is looking
172:00 - this is looking good to me
172:04 - I'm gonna kind of get a peek at the uh
172:10 - at the test Suite
172:12 - cool let's submit it and see how we did
172:14 - so we've talked about how arrays are
172:17 - fixed in size and you might be wondering
172:19 - well that's not very useful why would I
172:21 - care about an ordered list of things if
172:24 - I can't even add to or remove from the
172:26 - list well that's where slices come into
172:29 - play so let's draw out a simple array
172:34 - I'll do it in yellow let's just say it's
172:36 - storing some numbers we might have some
172:38 - numbers like six
172:39 - three
172:40 - two six
172:43 - five
172:45 - and I'll draw the indices let's do that
172:47 - in pink so the index of the first item
172:50 - is zero and then one two three four
172:54 - right and the size of the array is five
172:56 - which in go we would write like like
172:58 - this we would say we have
173:02 - an array of five items and they are
173:05 - integers Okay cool so we understand what
173:08 - an array is but what's slice well slice
173:11 - is in go are written with this syntax
173:14 - open close bracket
173:16 - int
173:17 - and you'll notice that the size is
173:19 - missing okay so a slice is a dynamically
173:24 - sized flexible view into an array so
173:28 - slices are built on top of arrays so
173:30 - that means for example that I could
173:32 - create a slice
173:34 - that just looks at this kind of middle
173:38 - portion
173:39 - of this array if I were to write this in
173:42 - code I would basically say if this array
173:44 - is named a so a is this yellow array
173:47 - here if I want to create a slice on top
173:50 - of that array then I could write B
173:54 - colon equals a
173:58 - from we're using square brackets here
174:01 - index one
174:04 - up to but not including index four
174:08 - okay so the first the first number is
174:09 - inclusive the second number is exclusive
174:12 - and now B is this slice of kind of just
174:16 - that middle view of the array and here's
174:19 - the important thing to understand in go
174:21 - we actually almost never deal with
174:24 - arrays directly 99 times out of 100
174:27 - you'll just be working with slices
174:30 - because slices provide a much better
174:32 - developer experience they're built on
174:35 - top of arrays for kind of memory
174:37 - management reasons which we'll talk
174:38 - about in just a second but you really
174:40 - want to be working
174:42 - um for the most part with slices because
174:44 - you don't have to worry about that fixed
174:46 - size problem so just to review slices
174:49 - sort of in code we can create an array
174:53 - literal like this right this is an array
174:55 - because we have we have the size of the
174:58 - array there six integers
175:01 - and then we can create a slice on top of
175:03 - the array like this
175:05 - cool
175:06 - um let's jump into the assignment so you
175:07 - can kind of get a feel for how this all
175:09 - works
175:10 - okay the assignment says retries are a
175:12 - premium feature Now text use free users
175:14 - only get one retry message while Pro
175:16 - members get an unlimited amount complete
175:19 - the get message with retries for plan
175:21 - function it takes up plan variable's
175:23 - input that's a string matches up to one
175:25 - of these if the plan is a Pro Plan
175:27 - return all of the strings from get
175:30 - message with retries Okay cool so get
175:32 - message with retries it looks like
175:33 - returns
175:35 - an array of three strings
175:37 - okay let's just jump right into it if
175:39 - plan is
175:42 - plan Pro
175:44 - then we'll return all messages
175:46 - right return all the strings yep and a
175:49 - nil error
175:51 - otherwise if the plan
175:53 - is plan free
175:57 - return the first two strings right the
175:59 - original string and kind of the what the
176:01 - first retry message so return all
176:04 - messages and we're going to slice it
176:06 - from index 0 up to not including index
176:09 - two subtly indexes zero and one right
176:11 - two two strings
176:14 - and then we'll also return nil
176:16 - and finally if it's neither of those
176:19 - return an error that says unsupported
176:21 - plan
176:22 - so return
176:24 - nil errors dot new unsupported plan and
176:30 - nil
176:31 - um is just kind of the zero value of
176:33 - slice
176:34 - cool um this is looking good we need to
176:37 - make sure we import the errors package
176:40 - let's go ahead and run this and see what
176:42 - happens
176:44 - we got an error cannot use all messages
176:46 - variable of type
176:49 - array size 3 string as slice of string
176:52 - okay cool
176:54 - so we have an array
176:57 - all messages is an array not a slice
176:59 - right so we actually need to slice this
177:03 - to change its type but we want all of
177:07 - the values inside of the array so we're
177:08 - just going to use this colon syntax
177:11 - to get access to everything in the
177:14 - underlying array let's run that again
177:20 - cool sending to Oscar
177:22 - click here to sign up pretty please
177:24 - click here so that's two two messages
177:26 - with no response
177:28 - um and I'm guessing because yep Oscar's
177:30 - on a free plan just Jeff is on a Pro
177:33 - Plan so he gets all three messages this
177:35 - is looking correct to me these next few
177:37 - questions will reference kind of
177:39 - excerpts from the effective go book
177:42 - which is definitely a book I recommend
177:43 - reading although it is a bit out of date
177:45 - it was written a while ago
177:48 - um and the authors have basically made
177:49 - the decision not to update
177:51 - um the book over time kind of keeping it
177:53 - as a snapshot so it has a lot of great
177:55 - stuff in there and go has very strong
177:57 - backwards compatibility so it's still a
177:59 - great read I'm just going to be aware
178:00 - that it hasn't been updated
178:02 - um in a while
178:04 - cool
178:05 - um that said everything we explained
178:07 - here I'll obviously provide uh context
178:10 - um four so the thing that's important to
178:14 - understand in this section is that
178:16 - slices are references to kind of what
178:20 - goes on underneath the hood with arrays
178:23 - so what that really means to you as a
178:27 - developer is when you use slices and
178:29 - more specifically when you pass them
178:31 - around say into a function you're
178:33 - actually passing a reference which means
178:36 - if you change the values in that slice
178:40 - within a function
178:41 - the caller the person who called your
178:44 - function or I should say the bit of code
178:45 - that called your function will actually
178:47 - have access to those changes it will see
178:49 - those changes even if you don't
178:51 - explicitly return the slice again now
178:54 - this is different
178:56 - um from sort of normal primitive values
178:58 - which are passed by value you might
179:00 - remember us talking about pass by value
179:02 - earlier in the course
179:04 - typically if you pass in say a string or
179:06 - an integer into a function and then
179:08 - within that function you change it the
179:10 - caller won't see those changes you have
179:12 - your own copy of that data that's that
179:15 - does not hold true with slices so just
179:18 - understand that when you pass a slice
179:19 - into a function it might get modified
179:22 - okay cool
179:24 - um so which references the other is the
179:27 - question do arrays reference slices or
179:29 - do slices reference arrays and the
179:31 - answer is that slices reference arrays
179:33 - the next question is can multiple slices
179:36 - point to the same array right is that
179:39 - true or false multiple slices point to
179:40 - the same array
179:42 - um that is true remember slices are just
179:45 - kind of a view into an array so it makes
179:48 - sense that you can have multiple views
179:49 - into the same underlying array so
179:52 - multiple slices can point to the same
179:54 - array now here's that question
179:57 - um that we talked about earlier a
179:59 - function that only has access to a slice
180:01 - can modifying the underlying array
180:05 - the answer to this is that is true even
180:08 - if the function doesn't return that
180:10 - slice it can modify the values in the
180:13 - underlying array let's talk about how
180:15 - slices work um kind of specifically how
180:18 - they work in relation to your computer's
180:19 - Hardware or your computer's Ram
180:23 - now Ram just stands for Random Access
180:25 - Memory it's where variables are stored
180:28 - the best way to think about Ram is just
180:30 - a mapping of addresses
180:33 - so address
180:36 - to data
180:38 - right it gives us a place to store stuff
180:41 - so for example at address 0
180:45 - we might have some data that represents
180:48 - I don't know the number four
180:50 - right
180:51 - and then at address one
180:53 - we might have some data representing the
180:55 - number five I don't know I'm just making
180:57 - stuff up
180:58 - but you get the idea we have addresses
181:00 - and we have data associated with that
181:04 - address slices and the arrays that they
181:07 - are built on top of are stored in
181:09 - contiguous memory basically what that
181:12 - means is a slice or an array is an
181:16 - address in memory where the slice or
181:18 - array starts so for example at address 0
181:22 - we might say this is the start of a
181:24 - slice
181:26 - and the slice actually continues for the
181:30 - next you know several uh kind of bytes
181:33 - of data let's say that it's a slice of
181:35 - length three so it actually would reach
181:37 - across all three of these addresses so
181:40 - if you have an array or a slice
181:43 - um and its address is zero and its
181:46 - length is three then you know kind of
181:48 - how many uh stores of data in memory
181:52 - um your slice or array will use now this
181:56 - is primarily important for performance
181:58 - because all of the data is stored next
182:01 - to next to each other in memory it's
182:03 - going to be going to be stir to kind of
182:05 - iterate over all of the values in our
182:07 - slice if we stored each index in kind of
182:10 - random places in memory it would take a
182:12 - lot longer to go collect all of that
182:14 - data just you know from a hardware
182:15 - perspective however there is a downside
182:18 - to having to store all of our memory
182:22 - um kind of next to each other let's
182:24 - pretend that we have this slice or this
182:27 - array that starts at address 0 and has a
182:29 - length of three so it's using kind of
182:31 - these three addresses in memory or these
182:34 - three bytes of memory and let's say here
182:36 - at address 3 we're storing a different
182:39 - value
182:40 - maybe we're just storing I don't know
182:42 - the number six
182:44 - um but this is a different variable
182:48 - this is some other variable the problem
182:50 - is if we want to expand our slice say
182:54 - add another value to it we're going to
182:56 - run into the next thing in physical
182:58 - memory that's a huge problem we don't
183:00 - want to overwrite some other variable
183:02 - just because we're growing our slice so
183:05 - this is why arrays are fixed in size if
183:08 - we just can't grow them then we'll never
183:10 - have this overwriting problem so the the
183:13 - question of course is how do slices do
183:15 - it right so well slices are built on top
183:17 - of arrays and basically what happens is
183:20 - I can draw this out for us
183:22 - when we want to grow a slice
183:25 - whose underlying array has run out of
183:28 - room right so we have our slice
183:31 - um built on top of this length three
183:33 - array and we want to grow it into a
183:35 - length of four what happens under the
183:38 - hood and this all kind of happens
183:39 - without you seeing it as a developer
183:41 - you'll you'll see later when we get to
183:42 - the syntax it's actually really simple
183:45 - um what happens is this data is copied
183:47 - into a new location of memory so we just
183:48 - take this four we put it over here 5
183:52 - over here uh actually I'm going to use
183:54 - the same colors that would probably be
183:56 - easier to understand so 4 comes over
183:58 - here 5 comes over here 3 comes over here
184:02 - and then let's say that we
184:04 - um we know we want to grow our slice
184:06 - significantly so the new underlying
184:08 - array
184:10 - let's say we'll have a length of 6 now
184:13 - so it had three here
184:15 - now the new array has allocated
184:18 - pre-allocated right we've essentially
184:20 - reserved memory for us up to six spaces
184:24 - let me draw all of that out
184:28 - cool
184:29 - and these addresses over here are going
184:31 - to be totally different right maybe it's
184:33 - address 15 address 16 17 18 19 and 20.
184:41 - cool so all the data from the old array
184:42 - gets copied over and now we're able to
184:45 - expand our slice
184:48 - our slice to our length of four
184:51 - right so here our slice was length three
184:54 - and the underlying array was length
184:56 - three now we've copied over the data
184:59 - we've created a much larger underlying
185:02 - array
185:03 - and now we have a slice of length four
185:05 - maybe we wanted to append say
185:07 - the number two to the end of the slice
185:09 - so again as the developer you're not
185:11 - going to have to do all of this array
185:13 - management manually but it's important
185:16 - to understand that this is what's going
185:18 - on under the hood because it has
185:19 - performance implications copying data
185:22 - isn't super efficient if you're copying
185:25 - data from one section in memory to
185:27 - another over and over and over again it
185:30 - can slow down your programs so now that
185:32 - we've covered all of that memory stuff
185:35 - and how it works under the hood what
185:37 - does that mean in code right well this
185:39 - is how we can create a slice without
185:42 - explicitly creating an array under the
185:44 - hood right so this will automatically
185:46 - create an array under the hood for us if
185:49 - we use this syntax so this is basically
185:51 - saying I want a new slice of integers I
185:54 - want its initial length to be five so
185:56 - the length of the slice right the length
185:58 - of the view into the array will be five
186:01 - and the capacity will be 10. so the
186:06 - capacity is kind of the total space that
186:09 - we have to grow the slice until we need
186:11 - to allocate a new array under the hood
186:13 - so you could almost think of this
186:15 - capacity as just the length of the
186:17 - underlying array now I told you that you
186:19 - don't need to think about the size of
186:20 - the under the lying array and that is
186:22 - true
186:23 - typically you'll actually use this
186:24 - syntax where you don't even specify a
186:26 - capacity
186:28 - so if you do not specify a capacity it
186:31 - defaults to the length so the kind of
186:34 - length of the underlying array for a
186:36 - slice of integers with length five will
186:38 - just be five and if you grow it past
186:40 - that the memory copying will happen and
186:43 - you'll create a new underlying array now
186:46 - you might be thinking oh that's terrible
186:47 - for performance in reality it's not that
186:50 - bad the only reason you would start to
186:52 - kind of fuss with specific capacities
186:55 - and optimizing your memory copying is if
186:57 - you're having performance problems
187:00 - generally speaking the convenience of
187:03 - keeping your code simple and easy to
187:04 - understand is going to outweigh kind of
187:07 - the performance cost that it'll have
187:09 - it's it's a very small one generally
187:11 - speaking and then it's also just worth
187:13 - pointing out that we can also create
187:14 - slice literals right so this just
187:16 - creates a new slice of length three and
187:20 - initializes these three values into that
187:23 - slice rather than what would happen up
187:25 - here which is that we create kind of all
187:28 - of the zero values to fill out the slice
187:31 - kind of of the given length so this
187:32 - would be a slice of five zeros right and
187:35 - then to just point out two more things
187:36 - regarding syntax there is a built-in
187:38 - length function that Returns the length
187:41 - of a slice and a built-in cap function
187:43 - that Returns the capacity so now that we
187:47 - are experts on slices let's jump into
187:49 - the assignment
187:50 - says we send a lot of text messages to
187:52 - text you and our API is getting slow and
187:53 - unresponsive so I just mentioned how you
187:56 - probably shouldn't worry about
187:57 - performance well here's a case where you
188:00 - should worry about performance right you
188:01 - shouldn't worry about performance until
188:02 - well it starts to become a problem so
188:05 - we're starting to have a problem with
188:06 - this memory copying being slow
188:09 - so we've been asked to pre-allocate our
188:12 - slices
188:14 - it says
188:15 - um if we know the Rough Side of this
188:17 - life before we fill it up we can make
188:18 - our program Faster by creating the slice
188:20 - with sis ahead of time alright so
188:22 - complete the message get message costs
188:24 - function
188:24 - it takes a slice of messages and returns
188:26 - a slice of message costs float64s right
188:30 - reallocate a slice for the message cost
188:32 - of the same length as the message slice
188:33 - let's go ahead and start off with that
188:36 - so costs
188:38 - we'll make a new slice and it's going to
188:40 - be a slice of float
188:42 - 64. and a length of
188:46 - length messages same same length
188:50 - cool
188:51 - um now we want to fill the co fill the
188:53 - cost slice with cost for each message so
188:55 - let's go ahead and iterate over each
188:57 - message so for I colon equals zero
189:01 - I is less than length of messages
189:05 - I plus plus
189:10 - let's get the message at that index
189:12 - messages zero
189:16 - oh not a zero excuse me
189:18 - at High
189:20 - okay the cost in the cost size should
189:22 - correspond to the message in the message
189:23 - slice the same index the cost of a
189:25 - message is the length the message
189:26 - multiplied by .01 so cost
189:29 - equals the length of the message
189:31 - multiplied by
189:33 - 0.01 that's going to need to be cast to
189:37 - a float 64.
189:40 - perfect
189:41 - cool and then we just need to save that
189:43 - into the costs slice so costs at I
189:47 - equals cost
189:49 - right
189:50 - correspond with the same index and we
189:53 - know that that
189:55 - um that index already exists because we
189:57 - pre-allocated it to the correct size
190:00 - cool so now we can just return costs
190:03 - let's go ahead and run that
190:08 - and see if these make sense
190:13 - okay these costs line up with the length
190:16 - of the messages so this is looking good
190:17 - to me let's review the difference
190:19 - between the length and the capacity of a
190:21 - slice sometimes this can be a little bit
190:22 - confusing the length is the thing that
190:25 - you're going to care about most often
190:27 - the length just tells you how many
190:28 - things are in that slice right if I have
190:30 - five items then the length of the slice
190:32 - is going to be five
190:34 - the capacity the capacity of a slice
190:38 - reports the maximum length the slice can
190:40 - assume right before it gets kind of
190:43 - reassigned into a new array so capacity
190:46 - is really again only something you're
190:48 - going to care about if you're worried
190:49 - about performance but the length you'll
190:51 - be concerned about just for kind of
190:53 - normal business logic reasons right just
190:55 - because you want to know how many things
190:56 - are stored in your slice so to answer
190:59 - this question it says what does the cap
191:00 - function return answers are at the last
191:03 - element of a slice or the maximum length
191:05 - the slice of the slice before
191:07 - reallocation of the underlying array is
191:09 - necessary the answer is going to be the
191:12 - maximum length the next question is what
191:14 - does the length function return length
191:17 - of the slice or the maximum length of
191:19 - slice before the reallocation is
191:20 - necessary and the answer is going to be
191:22 - the current length of the slice and we
191:24 - haven't really talked about this yet but
191:26 - I'll just kind of inform you as we
191:28 - answer this question it says what do
191:30 - length and cap the two functions do when
191:33 - a slice is is nil do they Panic or
191:37 - return zero and the answer is that they
191:39 - return zero they are safe functions to
191:41 - call
191:42 - um they won't make your code panic and
191:44 - error and crash right
191:45 - um I don't know how much we've talked
191:47 - about panicking up to this point in the
191:49 - course but panicking just means run time
191:51 - error that's unrecoverable unrecoverable
191:55 - um generally speaking you don't want
191:57 - your code panicking and you want to
191:58 - write your code in such a way that it
192:00 - can't Panic so again length and cap here
192:03 - are safe they will never Panic if a
192:07 - slice happens to be the zero value which
192:09 - is nil time for some very attic
192:12 - functions this sounds like a really
192:15 - complex thing but we've actually been
192:17 - using variatic functions up to this
192:19 - point in the course because the S printf
192:22 - print F print line all those functions
192:25 - are actually very Attic So a variatic
192:28 - function receives the variatic arguments
192:30 - as a slice let's take a look at the
192:32 - syntax so here we have a sum function
192:35 - and its function signature is just maybe
192:37 - a little bit different than you're used
192:38 - to basically we have this nums parameter
192:42 - which is of type dot dot dot int
192:45 - now here's the thing dot dot dot int
192:49 - as far as the function definition is
192:52 - concerned is just a slice we treat this
192:55 - just like we would if it said you know
192:57 - square brackets int it's just a slice of
193:02 - integers so you're probably sitting
193:04 - there thinking well why can't I just use
193:05 - a slice of integers why can't we just
193:07 - keep it simple why do we have to do
193:08 - everything differently ah okay well uh
193:11 - don't don't worry too much
193:13 - um the difference is on the caller's
193:15 - side so the function definition is the
193:18 - same whether you use dot dot dot int or
193:20 - square brackets int but if you use a
193:23 - variatic function
193:25 - then the calling code so the code that
193:28 - uses the sum function can actually pass
193:31 - in kind of any number of arguments and
193:34 - they'll come into the function as a
193:36 - slice of integers so here we could call
193:38 - for example sum one two three and the
193:42 - sum function gets a slice of integers
193:45 - with you know the values 1 2 and 3 in
193:49 - the first three indexes of the slice
193:51 - um this means that the caller could also
193:54 - call sum 1 comma two right and we'd have
193:57 - a slice of length too so it kind of just
193:59 - gives the caller of the function a
194:02 - different syntax and specifically kind
194:04 - of a more flexible syntax uh for how
194:07 - they're able to pass in sort of a
194:09 - dynamic number of arguments into the
194:11 - function now again we've already been
194:13 - using variatic functions you probably
194:16 - remember the print line function right
194:18 - this is how we print text to the console
194:23 - um it's a very attic function dot dot
194:26 - dot interface right so it can take any
194:30 - number of arbitrary inputs and it sort
194:32 - of prints them all out with new lines in
194:36 - between each element now along with
194:38 - variatic function definitions we also
194:41 - have another operator called the spread
194:43 - operator and the spread operator is kind
194:46 - of like the inverse of a variatic
194:48 - function by using the spread operator
194:51 - we're able to take a slice of values and
194:56 - pass them into a variatic function
195:00 - so this isn't the intended use case 100
195:03 - of the time otherwise you just Define
195:05 - your your function to take a slice of
195:07 - strings and you'd pass in a slice of
195:09 - strings but if you do have a function
195:11 - that is already variatic and you want to
195:13 - pass in a slice as the variable part
195:16 - then you can use this spread operator
195:18 - this trailing dot dot dot to sort of
195:21 - spread out
195:24 - in this case this name slice into the
195:27 - variatic function let's get our hands
195:29 - dirty with this so it says we need to
195:31 - sum up the costs of all individual
195:33 - messages so that we can send an end of
195:34 - month Bill to our customers complete the
195:37 - sum function so that it Returns the sum
195:39 - of all of its inputs
195:41 - cool so this is going to be very similar
195:44 - to this sum function right the
195:46 - difference here is that we're using
195:47 - float64s and we're going to write it
195:50 - from scratch so that we get our own our
195:52 - own crack at it
195:54 - Okay so
195:55 - first things first let's create kind of
195:58 - the default sum which is going to be
196:02 - 0.0.0 so
196:04 - let's say total
196:08 - now remember we can treat nums as just
196:11 - another slice of 64s so
196:14 - 4i colon equals zero
196:17 - I is less than length of nums
196:20 - I plus plus
196:23 - total plus equals
196:26 - nums at I
196:29 - right
196:31 - return total
196:34 - cool pretty straightforward
196:37 - um let's go ahead and run that
196:42 - so summing three costs bill for the
196:45 - month six dollars five costs 15 10 costs
196:49 - 55 do these match up
196:52 - looks like yep that should be six
196:56 - plus four plus five that's six plus nine
196:58 - that's fifteen Yep this is looking good
197:00 - I'm gonna go ahead and submit that
197:02 - now I told you that resizing slices is
197:04 - possible we just haven't really done it
197:06 - yet that's what the append function is
197:08 - for so the built-in append function is
197:11 - actually a very attic function but it
197:13 - allows us to just add new things to the
197:15 - end of a slice and it automatically
197:17 - takes care of adjusting the length and
197:19 - the capacity of the slice accordingly
197:21 - right allocating new underlying arrays
197:24 - as necessary now here are your syntax
197:27 - options for using the append function if
197:30 - you just want to append one thing then
197:31 - you'll use this top option let's say we
197:33 - have a slice called slice we want to
197:35 - append a variable called one thing to it
197:37 - basically we call the append function we
197:40 - pass in the slice we want to append to
197:43 - as the first item we pass the variable
197:46 - that we want to append onto the end as
197:48 - the next thing and then we reassign back
197:51 - into that same slice now because append
197:55 - is a very attic function we can append
197:57 - multiple things right so if we want to
198:00 - append the first thing and then the
198:01 - second thing thing after that we could
198:03 - do it like this and obviously we could
198:05 - also use the spread operator if we want
198:07 - to to be 100 honest though 99 of the
198:11 - time you'll be using this first one
198:12 - because you'll just be appending items
198:13 - one at a time let's hop into the
198:15 - assignment it says we've been asked to
198:17 - bucket costs for an entire month into
198:20 - the cost that occurred on each day of
198:23 - the month so complete the get cost by
198:26 - day function it's return a slice of
198:28 - float64s where each element is the total
198:30 - cost for that day okay so we have like
198:32 - this giant list of costs and we need to
198:34 - kind of uh condense all the costs that
198:37 - happened on a specific day into one
198:40 - index for that day makes sense to me the
198:44 - length of the slice should be equal to
198:46 - the number of days represented in the
198:47 - costs slice
198:51 - including any days that have no costs up
198:54 - to the last day represented in the slice
198:56 - Okay cool so if we have costs just for
198:58 - say the first month or the first day of
199:01 - the month and the fifth day of the month
199:02 - then we should have
199:04 - um kind of five indexes in our resulting
199:07 - array with kind of a non-zero value in
199:09 - the first and the fifth indexes zeros in
199:12 - the middle and nothing after that
199:14 - okay here we've got an example
199:17 - um
199:19 - given this input so day cost so we have
199:23 - costs on days on days zero one and five
199:27 - this would be the resulting array right
199:31 - four dollars on the first day 5.2 on the
199:34 - second day because we sum those right
199:37 - and then on that last day we'd have 2.5
199:39 - cool let's write the function
199:44 - so first things first we're going to
199:46 - need
199:47 - um we're going to need a slice to append
199:50 - into so costs by day
199:54 - we'll make a new uh a new slice of float
199:58 - 64. and here I'm just using the slice
200:01 - literal syntax instead of the make
200:03 - function there
200:05 - pretty dang similar
200:08 - now we're probably going to want to
200:10 - iterate over all the costs so for I
200:13 - colon equals zero I is less than length
200:16 - of costs
200:18 - I plus plus
200:25 - I
200:28 - okay so a cost is this structure here
200:31 - and we can take a look at the day there
200:36 - um
200:36 - we're going to need to figure out
200:38 - basically when we're appending to this
200:42 - cost spy day slice and when we're just
200:45 - adding to an existing index so I think
200:48 - the easiest thing to do would basically
200:50 - be to say
200:52 - um if
200:56 - day is greater than the length of costs
200:59 - by day
201:04 - actually it's going to be a four so like
201:07 - while the day is greater than the length
201:10 - of cost by day we're going to a pen cost
201:12 - by day equals append cost by day
201:16 - 0.0
201:19 - right so in effect this for Loop here
201:21 - just says if I've encountered a day
201:25 - that I don't yet have room for I'm going
201:28 - to grow the slice by just appending
201:31 - zeros until I have enough room
201:34 - so once we're done with that Loop
201:36 - we should be able to assign directly
201:39 - into the costs by day
201:42 - by basically saying cost by day plus
201:44 - equals
201:49 - cost.value
201:51 - right
201:53 - because it starts at zero so then we can
201:54 - just add
201:57 - let me just add the cost
201:58 - and again if if the day is less than
202:01 - cost by day then we just don't do this
202:03 - step we just skip over this for Loop
202:06 - so that's looking correct to me I'm
202:08 - going to go ahead and return costs by
202:10 - day
202:13 - and let's run that code
202:15 - see what we get undefined day what did I
202:19 - screw up here
202:23 - yeah needs to be cost dot day right
202:27 - access that field
202:29 - invalid operation cost byte a plus
202:31 - equals cost of value
202:33 - so cost value is a float 64
202:36 - costs by day
202:39 - is a slice of flow 64s
202:43 - right because this is a slice so costs
202:46 - by day
202:47 - at
202:52 - cost dot day
202:55 - right
202:58 - right because our the slice that we're
203:00 - returning
203:02 - um the indexes in each or the indexes of
203:06 - the slice represent each day in the
203:07 - month so we need to index back into the
203:09 - day
203:11 - okay
203:12 - try that
203:15 - whoa what do we got
203:17 - Panic runtime error index out of range
203:20 - zero with length zero
203:22 - okay
203:24 - what did we screw up
203:27 - so
203:31 - somewhere we are indexing into a slice
203:36 - where the value doesn't like the the
203:39 - index that we're indexing with is
203:41 - outside the range of the slide so
203:43 - um we haven't really talked about this
203:44 - this is probably great that we ran into
203:46 - this bug
203:47 - um
203:48 - if you try to index which is this
203:51 - operation here so like this is indexing
203:53 - into index five right but here we're
203:56 - indexing into cost.day which holds an
203:58 - integer
204:00 - um if you try to index into an index
204:02 - that is outside the length of the slice
204:04 - so you have a slice of length say three
204:06 - and you try to access index six then
204:10 - you'll encounter this error that's what
204:12 - we're seeing here
204:13 - so it looks like that's what we're doing
204:17 - so for cost.day is greater than the
204:21 - length now let's think about that
204:24 - if the day is 5
204:26 - and the length is five
204:30 - we're not going to do our growth so I'm
204:33 - actually I think I have an off by one
204:35 - error here right I actually what I
204:38 - actually want to do is say if the cost
204:41 - if the if the cost ID is greater than or
204:44 - equal to the length right because an
204:49 - array or a slice of length four
204:51 - actually only has three
204:54 - kind of indexes I mean it has four
204:57 - indexes but they start at zero so like
204:59 - length four the indexes are zero one two
205:01 - and three right let's go ahead and run
205:04 - that again
205:06 - cool
205:07 - no more panic
205:11 - day one one dollar or day zero one
205:14 - dollar day one five ten day two 250
205:17 - let's see if that
205:18 - lines up with the test Suite
205:24 - so here it looks like Day Zero should
205:26 - have one day one should have yep 5.1 if
205:30 - we add those together and day three
205:32 - should have five point was it six point
205:35 - three yep six by three okay this is
205:38 - looking correct to me
205:41 - slices can hold other slices right this
205:44 - kind of creates a 2d Matrix
205:47 - of values right so for example here a 10
205:52 - by 10 matrix of integers would look
205:54 - something like this where the First
205:56 - Slice is just a slice of slices
206:00 - hopefully that makes some amount of
206:02 - sense if not don't worry we'll get into
206:04 - the assignment here in just a second
206:06 - so it says we support various graphs and
206:08 - dashboards on textile the display
206:10 - message analytics for our users the UI
206:13 - for our graphs and charts is built on
206:14 - top of a grid system let's build that
206:16 - grid logic so this is super common in
206:18 - graphics development right we're kind of
206:20 - building on 2D screens so we need sort
206:22 - of an X and A Y cell within a matrix
206:26 - which is again often represented as a
206:29 - slice of slices the assignment says
206:31 - complete the create Matrix function it
206:33 - takes a number of rows and columns and
206:36 - returns a 2d slice of integers where the
206:37 - value of each cell is I times J where I
206:40 - and J are the indexes of the row and
206:43 - column respectively
206:45 - Okay cool so create Matrix we get two
206:49 - integers representing how big we want
206:50 - the Matrix to be and we just have to
206:52 - return the Matrix
206:54 - okay cool
206:56 - so
206:58 - let's go ahead and start building that
207:00 - out first we need to create or
207:03 - initialize the Matrix let's say Matrix
207:08 - slice let's use make make slice slice it
207:13 - right
207:14 - and we can just initialize it to a
207:17 - length of zero it doesn't matter we're
207:18 - going to grow it
207:20 - and for I colon equals zero I is less
207:24 - than length of rows
207:28 - I plus plus
207:31 - and then we're going to need an inner
207:32 - for Loop
207:34 - manage J which is going to
207:39 - deal with the number of columns columns
207:42 - J plus plus
207:44 - okay so what do we do
207:47 - um when we get to the first row well the
207:49 - first thing we need to do is make a new
207:52 - slice to represent the row so
207:55 - we'll say row
207:57 - make
207:58 - and we can just do
208:00 - a single slice of integers
208:03 - again row length of zeros is fine
208:07 - um we could pre-allocate but it probably
208:10 - doesn't matter too much at this point
208:14 - um and then for each J we're now going
208:17 - to append into the row so we do row
208:19 - equals append
208:23 - row
208:25 - I times J I believe was the formula
208:28 - right we want every cell
208:31 - to be the result of I times J so the
208:34 - values will sort of grow out as the
208:37 - Matrix gets larger and larger
208:40 - cool so that's adding the like this
208:43 - inner loop is adding values to each
208:46 - individual row and then we just need to
208:48 - append the row to The Matrix so Matrix
208:51 - equals append Matrix
208:56 - row
208:57 - and then when we're done appending all
208:59 - of the rows to The Matrix we can return
209:00 - the Matrix itself
209:04 - go ahead and run that
209:06 - invalid argument rows variable of type
209:09 - into or length
209:11 - see what we got here
209:13 - where did I screw up
209:16 - this time right
209:19 - I don't know why I'm checking a length
209:22 - here
209:23 - Rose is just an integer
209:25 - it's not
209:26 - a slice with a size
209:28 - let's try that again
209:32 - cool creating a three by three Matrix
209:36 - does that math check out
209:38 - one times one is one one times two is
209:41 - two two times two is four yep that looks
209:43 - good
209:45 - cool let's submit it
209:47 - I want to show you a common Pitfall that
209:49 - you might fall into when dealing with
209:52 - slices and how you can just outright
209:53 - avoid it
209:54 - um this is something you should pretty
209:57 - much never do when you want to append to
210:02 - um other slice in this case you want to
210:04 - append elements to other slice you
210:07 - should always reassign into the same
210:10 - slice so this should read other slice
210:12 - equals append other slice element you
210:15 - don't want to be appending kind of into
210:17 - one thing and reassigning into a
210:20 - separate slice you'll run into some bugs
210:23 - and we're going to talk about how that
210:24 - works right now so in this first example
210:27 - we have these slices a b and c and by
210:31 - the way I would highly recommend coming
210:33 - here on boot Dev so that you can
210:34 - actually kind of look and puzzle through
210:36 - what's going on in the code rather just
210:38 - seeing it on the screen but basically we
210:41 - have these slices and when we append to
210:45 - them
210:46 - we're we're breaking the rule basically
210:48 - we're uh appending for example here
210:52 - um four onto a but then returning the
210:55 - value
210:57 - the value returned by append we're kind
210:59 - of saving it into a new slice called B
211:01 - which again you generally should not do
211:03 - you should just save it back into the
211:05 - same slice a
211:07 - um but anyways we're going along um kind
211:09 - of doing that pattern and at the end
211:12 - you'll notice that nothing too terrible
211:15 - happened basically we ended up with an a
211:18 - with three zeros B had four appended to
211:21 - it properly and C had five appended to
211:25 - it properly so you could kind of take
211:27 - away from this example well maybe
211:28 - there's nothing wrong maybe we can just
211:30 - kind of uh break the rule and append
211:34 - into new slices seems like everything's
211:36 - working like I'd expect and it's worth
211:38 - pointing out that we can even print out
211:40 - the addresses in memory of the slices B
211:44 - and C and see that the addresses are
211:47 - different in other words when we call
211:49 - this append functions where we append
211:51 - five onto
211:54 - um you know the slice a and and save it
211:57 - back into the variable C we can see that
212:00 - actually C is being kind of copied into
212:02 - a new location so again everything's
212:04 - kind of working as we'd expect now it's
212:07 - really in this example two that
212:09 - something very strange happens
212:12 - if we look down
212:14 - here we're appending on to J
212:18 - the value for
212:20 - and then we're appending on to G here
212:23 - the value 5.
212:26 - but the interesting thing is that after
212:29 - we append 5 to G if we print out J again
212:33 - we can see that J was actually changed
212:36 - kind of under the hood right up here
212:39 - J had four in its fourth index
212:44 - and then we never touched J again
212:46 - directly but by appending on to G we
212:49 - actually screwed up J we mutated J and
212:53 - the reason for that is because in this
212:55 - example because of the way we've
212:57 - sloppily used the append function G and
213:01 - J actually point to the same address in
213:04 - memory so mutating G changed J now I
213:10 - already mentioned that we were doing the
213:11 - same thing up here right we were using
213:13 - the same kind of sloppy use of the
213:15 - append function that I'm recommending to
213:17 - avoid but we only had the bug in example
213:20 - two and the reason for that is because
213:24 - the original slice in example 2 has a
213:27 - capacity of eight
213:29 - while the original slice in example one
213:32 - had a capacity of three so what that
213:35 - means is when we used the append
213:38 - function in the first example once we
213:41 - went over the capacity we allocated a
213:43 - new underlying array which is why we got
213:45 - different memory addresses and so when
213:48 - we mutate C here C is in a different
213:51 - place in memory than b so they're kind
213:53 - of operating independently which is
213:55 - again what you usually want in your code
213:59 - however because the capacity was already
214:01 - large enough in example two there was no
214:04 - need for the append function to create a
214:07 - new underlying array so G and J point to
214:10 - the same
214:11 - same array in memory
214:14 - again which means if we mutate g under
214:16 - the hood we are just mutating J so again
214:18 - the way you can avoid all of this
214:21 - headache
214:23 - is to just not do this right append onto
214:27 - the same slice pretty much every time
214:30 - unless you have like some crazy specific
214:33 - reason not to do so which like I'm
214:36 - skeptical that exists I certainly
214:38 - haven't run into it in you know many
214:40 - years of writing application code and go
214:42 - so the question for this quiz is why is
214:46 - 5 the final value in the last index of
214:49 - array J right so why why did we have a 5
214:53 - here even though we appended four
214:56 - um and the answers are J and G point to
214:59 - the same underlying array so G is append
215:00 - over row J the go team is trolling I
215:03 - think that's obviously not it uh and
215:05 - because append only works properly when
215:06 - the number of elements is less than 10
215:08 - uh that would be very silly so it's it's
215:10 - definitely this middle one
215:12 - we're overriding the same location in
215:15 - memory next question on the same topic
215:17 - is why doesn't the bug regarding slices
215:19 - J and G in example two occur in example
215:23 - one as well and the answers are because
215:27 - there are fewer elements and goes
215:28 - runtime can't handle more than eight
215:30 - elements that would be awful or the
215:33 - arrays cap is exceeded so a new
215:34 - underlying array is allocated and and
215:36 - that one is the answer so the next
215:38 - question is how can you best avoid these
215:41 - types of bugs don't use the append
215:43 - function always assign the result of the
215:45 - append function back into the same slice
215:47 - or always assign the result of the
215:49 - append function to a new slice
215:51 - well it's not using a new slice that's
215:53 - how we got into this trouble in the
215:54 - first place and we definitely want to
215:56 - use the append function it's pretty
215:57 - useful so again always assign the result
216:01 - of the append function back into the
216:02 - same slice
216:03 - you'll avoid a lot of headache that way
216:05 - finally some syntactic sugar to help us
216:09 - iterate over the elements of a slice
216:11 - you've probably been wondering for the
216:13 - majority of this chapter ugh do I have
216:15 - to do this like I equals zero I is less
216:17 - than the length every time I want to
216:19 - iterate over the elements of the slice
216:21 - other languages have syntactic sugar to
216:23 - make it easier so does go so the syntax
216:25 - is pretty simple this is it right here
216:28 - and basically by writing it this way
216:30 - index at each iteration of the loop will
216:33 - be equal to the index in the loop
216:35 - starting at zero right so zero one two
216:37 - three and then element is the value
216:39 - associated with that Index right and
216:42 - then obviously slice here is the name of
216:44 - the slice so range is really the
216:46 - interesting keyword that allows us to
216:48 - iterate over everything stored in a
216:50 - slice to give a more concrete example
216:52 - here we have a slice of strings called
216:55 - fruits and we can arrange over the
216:58 - fruits and if we print I and fruit in
217:01 - this example that we print zero apple
217:04 - one banana two grape and so on let's
217:07 - jump into the assignment it says we need
217:09 - to be able to quickly detect bad words
217:12 - in the messages that our system sends
217:14 - complete the index of first bad word
217:16 - function okay so that's this
217:18 - um it finds any bad words in the message
217:20 - if it finds any bad words in the message
217:22 - it should return the index of the first
217:25 - bad word in the message slice this will
217:27 - help us filter out naughty words uh from
217:29 - our messaging system if no bad words are
217:30 - found will return negative one instead
217:32 - use the range keyword
217:34 - Okay cool so the bad words themselves
217:37 - are defined for us and passed into our
217:39 - function and then the message itself is
217:42 - already broken up into words it looks
217:44 - like and passed in is an array of
217:46 - strings right so we can I'm kind of just
217:48 - figuring this out by looking uh looking
217:50 - down here so we have a slice of bad
217:52 - words and a slice of words in the
217:55 - message hey there John okay cool
218:00 - so
218:01 - um let's start
218:04 - by iterating over all of the words in
218:07 - the message right seems like a
218:09 - reasonable place to start so four
218:13 - I
218:14 - word colon equals range message
218:20 - and then we want to check and see if
218:26 - if one of these words is equal to one of
218:29 - the bad words so we're going to use a
218:31 - nested Loop actually
218:34 - we'll do J
218:37 - bad word in range bad words
218:41 - right
218:42 - and then here we can say if word equals
218:45 - equals bad word
218:48 - that means we found the bad word and we
218:50 - can return
218:53 - we want to return the index so we return
218:55 - I right that would be the index of the
218:58 - bad word
218:59 - otherwise if we don't find a bad word
219:01 - we'll just keep going in fact we'll just
219:04 - keep going through all the bad words and
219:05 - then we'll keep going through all the
219:06 - rest of the words
219:08 - and if we get to the end of everything
219:09 - without finding any matches then we can
219:11 - just return negative one
219:14 - makes sense right
219:16 - cool let's run that
219:19 - J declared not used
219:21 - right so we've come across this syntax
219:24 - before we can ignore variables with an
219:26 - underscore right
219:28 - let's run that
219:31 - let's take a look at our test Suite
219:32 - scanning message hey there John for bad
219:34 - words
219:36 - index negative one
219:38 - that means none were found right
219:41 - which makes sense we didn't have any
219:43 - scanning message uh oh my Frick for bad
219:45 - words
219:46 - brick is a bad word index three okay
219:49 - this is looking good to me I'm gonna go
219:50 - ahead and submit that
219:53 - if you're familiar with object literals
219:55 - in JavaScript or python dictionaries
219:58 - then maps and go are essentially the
220:00 - same thing maps are just a way to
220:02 - associate a key with a value so let's
220:05 - take a look at this example we create a
220:08 - new map
220:09 - with this syntax here we're going to use
220:11 - this built-in make function and then
220:14 - pass in the type of the map so map of
220:16 - string to integer so we're mapping
220:19 - strings two integers
220:21 - and we're going to say inside of the
220:23 - ages map we're going to set the key John
220:26 - to the integer 37. so again we're
220:30 - mapping that name John to the value 37.
220:33 - rather than creating an empty map and
220:36 - then kind of adding key value pairs one
220:38 - at a time we can also declare the entire
220:40 - map up front and use kind of this colon
220:43 - syntax to separate the keys and the
220:45 - values and then we can also check how
220:47 - many keys I guess keys and values are in
220:51 - the map by using the built-in length
220:53 - function similarly to how you would use
220:55 - it on a slice so in this case we create
220:58 - a new map we create two keys each with
221:00 - their Associated values and then by
221:02 - printing the length we'll just print the
221:03 - number two so let's jump right into the
221:06 - assignment that's usually the best way
221:07 - to get an idea for how all the syntax
221:09 - works
221:10 - assignment says we can speed up our
221:12 - contact info lookups by using a map
221:14 - looking up a value in a map by its key
221:17 - is much faster than searching through a
221:19 - slice so when we look up something in a
221:22 - map by a given key that's going to be an
221:25 - instant lookup
221:27 - if we had stored it in a slice then we'd
221:29 - have to search through the entire slice
221:31 - sort of index by index looking for the
221:33 - value that we want so Maps can be a
221:36 - great way to make our code more
221:37 - efficient
221:38 - the assignment says complete the get
221:40 - user map function it takes a slice of
221:42 - names and a slice of phone numbers and
221:44 - returns a map of name to user structs
221:47 - and potentially an error okay so let me
221:50 - expand our coding window here
221:53 - okay so we're returning a map of string
221:55 - to user structs looks like the user
221:57 - struct is defined right here
221:59 - if the length of names and phone numbers
222:01 - is not equal return error with string
222:02 - invalid sizes the first name in the name
222:04 - slice matches the first number and so on
222:07 - Okay cool so first things first we're
222:09 - gonna have to create a new map so we'll
222:12 - do
222:13 - um
222:13 - user map
222:16 - colon equals and I'm just going to
222:18 - create a literal a new map literal
222:21 - actually no I won't I'll do I'll use the
222:22 - syntax from up here this works just fine
222:25 - so we'll use the make function
222:27 - so make map of string to user
222:32 - all right so that's now an empty map
222:36 - and then what we're going to do is check
222:38 - and make sure that these are the same
222:39 - length so if the length of names does
222:43 - not equal the length
222:45 - of phone numbers
222:49 - then we'll return nil so nil is the zero
222:52 - value of a map
222:55 - we could also return an empty map of the
222:58 - same type but I'd say you should prefer
223:00 - nil for slices and maps and things and
223:03 - then the error
223:05 - should say invalid sizes so errors dot
223:08 - new
223:09 - invalid
223:10 - sizes
223:13 - support the errors package
223:16 - Okay cool so if we get down to line 13
223:18 - now we should know that both of these
223:20 - slices names and phone numbers are of
223:22 - the same size which means we can Loop
223:24 - like this so four I starting at zero
223:28 - I is less than the length of it doesn't
223:31 - matter because they'll be the same right
223:32 - length of names
223:34 - I plus plus
223:37 - then we can say name
223:39 - is names at I
223:43 - and we can say phone number
223:48 - phone numbers
223:50 - at I
223:53 - okay
223:55 - and then we're going to want to insert
223:57 - values into the user map so we'll do
223:59 - user map
224:00 - at
224:01 - the key in this case the key is the name
224:05 - right so key is the name
224:07 - and we'll set it equal to a new instance
224:09 - of a user struct so user
224:14 - and the user struct has two Fields name
224:16 - which will just again be the name and
224:19 - the phone number
224:22 - which will just be this phone number
224:24 - here
224:26 - cool
224:29 - so that should fill the entire user map
224:31 - with all of the names and phone numbers
224:33 - and then by the end we should just be
224:34 - able to return
224:36 - user map nil
224:39 - okay cool I think we got everything
224:41 - let's go ahead and run that
224:45 - and see what we get
224:47 - so creating map key John value name
224:50 - number key Bob value name number this is
224:53 - looking this is looking correct to me
224:54 - here we have creating a map with invalid
224:56 - sizes
224:58 - um if we take a look at the tests
225:01 - uh yep that makes sense the second test
225:02 - has two names but three numbers so I
225:05 - would expect it to get that invalid
225:07 - sizes error
225:08 - cool let's uh let's submit that
225:11 - so the primary way you interact with
225:13 - maps is just by setting and deleting
225:16 - values at a given key right they're very
225:18 - associative right a value maps to a key
225:21 - but there's no other ordering Maps
225:23 - aren't ordered from you know index 0 1 2
225:25 - 3 like a slices everything's unordered
225:28 - you're literally just mapping values to
225:30 - keys Okay cool so let's take a look at
225:32 - some of the different syntax that we can
225:34 - use to interact with maps so we can
225:36 - insert an element by just setting the
225:38 - key equal to the value
225:41 - we can get an element out just by
225:43 - accessing it directly at its key we can
225:46 - delete Elements by using the built-in
225:48 - delete function where we're passing in
225:50 - the map itself and the key that we want
225:52 - to delete notice that we're not passing
225:54 - in the value at all we're just passing
225:55 - in the key
225:56 - and then we can also check if a key
225:58 - exists by parsing the return value of
226:03 - kind of this access syntax into two
226:06 - separate values where the first value
226:08 - will be the element itself and the
226:10 - second value is a Boolean if the Boolean
226:14 - is true then the element will be
226:16 - whatever element was stored of that key
226:18 - however if the Boolean is false that
226:22 - tells you that that key didn't exist in
226:24 - the map and the element will just be the
226:26 - zero value for its type let's jump into
226:29 - the assignment so it says in fact Let me
226:31 - let me resize this a bit
226:34 - says it's important to keep up with
226:36 - privacy regulations and respect our
226:38 - users data we need a function that will
226:39 - delete user records okay complete the
226:42 - delete if necessary function it takes a
226:45 - map of users and a name which I'm going
226:48 - to guess is the key in the map and it
226:51 - will return a Boolean saying whether or
226:53 - not the user was deleted and then an
226:56 - error if something went wrong
226:57 - Okay cool so if the user does not exist
226:59 - in the map or turn the error not found
227:01 - oh interesting so if we're trying to
227:02 - delete something and it's not there
227:03 - that's an error
227:06 - if they exist but aren't scheduled for
227:08 - deletion then return deleted as false so
227:12 - we'll this will be false and there won't
227:14 - be any errors but if they exist and are
227:16 - scheduled for deletion then we'll return
227:18 - the deleted Boolean as true with no
227:22 - other errors okay that's making sense to
227:24 - me and then a note on how maps are
227:27 - passed into functions is that like
227:29 - slices maps are actually passed by
227:31 - reference so even though this function
227:33 - delete if necessary does not return a
227:36 - map
227:37 - if we mutate this user's map it will be
227:41 - mutated for the caller of the function
227:42 - so that's how we are able to delete
227:44 - something from the map even though we're
227:46 - not returning the map once we're done
227:47 - with it so the first thing we need to do
227:49 - is just check and see if the name that
227:51 - we're trying to delete exists so let's
227:54 - do this if
227:56 - blank okay colon equals users
228:01 - at name
228:03 - not not okay
228:05 - so this is that kind of special if
228:09 - statement syntax right where we're
228:12 - actually ignoring the value itself we're
228:15 - just interested in that Boolean value
228:17 - telling us whether or not this
228:20 - um this key exists in the map and if it
228:23 - does not then we're going to go ahead
228:24 - and return
228:25 - uh return the error not found so false
228:28 - because we always do zero values for
228:29 - everything besides the error and then
228:30 - errors dot new
228:33 - not found and we'll make sure to import
228:36 - that errors package
228:39 - okay cool and again I'm just I'm just uh
228:41 - using this syntax here
228:43 - let's check if a key exists
228:45 - cool moving on okay so if we get past uh
228:48 - that guard Clause to line 12 well then
228:50 - we know
228:51 - um that the user exists so
228:53 - um at this point ah we need to check if
228:55 - they're scheduled for deletion so I'm
228:57 - actually going to switch up my syntax
228:58 - here the user struct has the scheduled
229:01 - for deletion Boolean so I'm going to go
229:03 - ahead and do this on a separate line
229:06 - and I will save that user
229:09 - so I'll do
229:11 - um
229:11 - existing user
229:16 - and then we'll just do if not okay
229:19 - so that down here now I can use that
229:21 - existing user struct so I can say if
229:23 - existing user dot scheduled for deletion
229:29 - so if they exist and are scheduled for
229:31 - deletion return deleted as true with no
229:32 - errors and delete the record for the map
229:33 - so we need to use this built-in delete
229:35 - function so we'll delete
229:39 - users
229:41 - name
229:42 - and then we'll return true
229:45 - no
229:46 - all right so if they are scheduled for
229:48 - deletion we'll delete them and report
229:50 - back that we deleted them
229:52 - cool
229:53 - um otherwise
229:55 - if they're not scheduled for deletion
229:58 - return delete is false with no errors so
230:00 - return
230:01 - false no
230:04 - okay that looks right to me let's go
230:05 - ahead and run that
230:10 - attempting to delete John deleted John
230:12 - attempting to delete musk not found
230:14 - Santa not found attempt to delete K did
230:16 - not delete Kate Okay cool so I mean all
230:18 - that look it looks like all the cases
230:19 - were covered let's just come down here
230:21 - and take a look
230:23 - okay so we had a John and John was
230:25 - deleted
230:26 - and that attempting to delete musk
230:28 - there's not actually a musk in the map
230:30 - so not found makes sense there's also
230:33 - not a Santa and Cade was not scheduled
230:36 - for deletion so he did not get deleted
230:39 - and then the final map still has those
230:41 - keys that looks correct to me
230:44 - in this next section we're going to be
230:46 - covering some of the material from the
230:48 - go blog now I'm not going to read all of
230:51 - this out uh that would be a little dry
230:53 - but I definitely recommend reading this
230:56 - over if you have the time otherwise I'm
230:58 - going to cover kind of the key points so
231:00 - the first question is what makes a type
231:02 - qualify to be able to be used as a map
231:05 - key okay so any type can be used as a
231:08 - map value but not every type can be used
231:10 - as a map key and that's because map Keys
231:14 - maybe of any type that is comparable so
231:17 - things like strings booleans numbers all
231:21 - those can be compared for equality what
231:24 - cannot be compared for equality are
231:26 - slices maps and functions and kind of
231:30 - one of the reasons for that is slices
231:31 - and maps and functions they're kind of
231:33 - just pointers to addresses in memory so
231:36 - if you compare one slice to another
231:39 - slice you're not really comparing the
231:41 - underlying values you're actually
231:43 - comparing kind of where those two slices
231:46 - are stored in your computer's Ram
231:49 - and because they're stored in different
231:51 - places you'll actually get two slices
231:54 - with maybe the exact same values stored
231:56 - in them say slice one has the numbers
231:58 - one two three in the first three indexes
232:00 - and the second slice has the same
232:02 - they might still be compared as unequal
232:05 - because they're stored in different
232:07 - addresses in memory so I mean all that
232:10 - being said long story short you just
232:12 - can't use slices and maps and functions
232:15 - as map keys so to answer the question
232:18 - what makes type qualify to be used as a
232:20 - map key the type is comparable this next
232:24 - question is interesting and kind of
232:25 - plays on the idea that we can Nest Maps
232:29 - kind of one inside the other or we could
232:31 - do something that's arguably simpler let
232:33 - me show you what I mean so here is an
232:35 - example of a map of strings
232:39 - that maps to another map
232:42 - which maps from strings to integers so
232:46 - like the first string kind of maps to
232:47 - the second string which maps to an
232:49 - integer if you want to think about it
232:50 - that way if you're familiar with Json
232:52 - objects this would be like mapping Json
232:55 - objects kind of down multiple levels of
232:58 - keys so in the example given in the go
233:01 - blog essentially what's being said is
233:03 - we're mapping two strings to account
233:06 - and so what that looks like in code is
233:09 - if we want to get access to the count we
233:11 - actually have to go to the map
233:12 - index the nested map with a key and then
233:17 - index into that next map with another
233:19 - key before we get the value out now this
233:22 - looks simple on the surface but what
233:24 - actually happens is when you need when
233:26 - you go down those nested levels you
233:29 - actually can't be sure that the inner
233:31 - map exists and So to avoid panicking
233:34 - your code will actually Panic by the way
233:36 - if you try to access a key in a map that
233:39 - is nil So to avoid panicking you have to
233:42 - check and make sure that those nested
233:44 - Maps actually exist which just results
233:47 - in a lot of extra code so while nesting
233:50 - Maps definitely works and I've used it
233:52 - quite a bit there can in some instances
233:55 - be a simpler way which is to actually
233:57 - use a struct as a key notice that a
234:01 - struct was not named as one of the
234:04 - non-comparable types structs are
234:06 - comparable so if you want to create a
234:09 - map that kind of has multiple keys that
234:11 - kind of combine together to form a
234:14 - composite key then just create a new
234:16 - struct right with two values inside of
234:19 - it and those two values kind of unique
234:22 - together create their own key so this
234:25 - simplifies a lot of things where now we
234:27 - can have one map and we can use that
234:29 - struct key to create kind of uniqueness
234:32 - across two different values this might
234:34 - be useful for example if you're trying
234:35 - to create
234:36 - a map That's Unique for first last name
234:39 - combinations right you want Lane Wagner
234:41 - stored in two different fields first
234:43 - name and last name to be unique together
234:45 - so to answer the question which is
234:48 - simpler to use a struct directly as a
234:50 - key or to Nest maps and the authors of
234:53 - the go blog and I would agree
234:55 - argue that using a struct directly is
234:58 - going to be simpler let's jump right
235:00 - into this next assignment it says we
235:02 - have a slice of user IDs okay so those
235:04 - are strings and each instance of an ID
235:06 - in the slice indicates that a message
235:08 - was sent to that user we need to count
235:10 - up how many times each user's ID appears
235:13 - in the slice to track how many messages
235:14 - they received implement the get counts
235:17 - function okay so that's this one
235:20 - a map of string to int so that each int
235:23 - is a count of how many times each string
235:24 - was found in the slice okay cool simple
235:26 - enough
235:27 - so let's create a new map so this will
235:30 - be the counts map
235:32 - and it's going to be a map of string to
235:35 - integer
235:38 - and then let's Loop over all of the user
235:40 - IDs so for blank user ID
235:45 - and range user IDs
235:49 - and we're just we're going to ignore the
235:50 - index because we don't care about it
235:53 - and the first thing we're going to do is
235:55 - check to see if a value in the map for
235:59 - the given user ID already exists so
236:02 - count
236:03 - okay colon equals
236:06 - user IDs
236:09 - sorry counts
236:12 - at user ID
236:15 - right
236:18 - cool
236:19 - um in fact now like now that I type that
236:22 - out I'm not actually sure that I need
236:23 - this
236:24 - because if I don't use this
236:27 - this access will still work it's just if
236:29 - if the key didn't exist count will be
236:31 - zero which is fine so actually I don't
236:34 - even think I care
236:35 - um
236:36 - cool so we get the count it'll be zero
236:39 - if it didn't yet exist and then we just
236:40 - increment it by one so count plus plus
236:44 - and then we'll save it back into the map
236:46 - so counts at user ID equals count
236:49 - so we're just grabbing it out
236:51 - incrementing it by one and putting it
236:53 - back
236:54 - that seems like what we want to do right
236:56 - and then at the end we'll just return
236:59 - counts
237:01 - cool
237:03 - let's go ahead and run that and see what
237:04 - we get
237:08 - jittering counts for 10 000 user IDs
237:11 - Counts from selected IDs zero zero has
237:13 - 31 FF has 27 DD has 37 okay and if I
237:18 - look down here it looks like the IDS are
237:22 - being generated randomly
237:24 - cool so
237:27 - let's go ahead and submit it because
237:28 - this feels right
237:33 - cool we're good to go this next section
237:35 - is about a piece or an excerpt from the
237:39 - effective go book
237:41 - um that is a book that I'd highly
237:43 - recommend reading um some of the stuff's
237:45 - a bit outdated they've made the decision
237:46 - not to continuously update effective go
237:49 - but it is an Open Source book you can go
237:51 - read the whole thing for free um and the
237:53 - link is right there so go check that out
237:55 - if you're interested
237:57 - um that said you don't need to I'll be
237:58 - talking through the parts that we care
238:00 - about here so Maps can have at most
238:02 - blank values associated with the same
238:05 - key the answers are one any number of
238:07 - three and two well maps are associative
238:09 - right they map a single key to a single
238:12 - value and you can't have duplicates of
238:15 - the same key in a map that wouldn't make
238:17 - any sense right then when you put in a
238:18 - key you would maybe get back a slice
238:20 - like that doesn't quite work so the
238:22 - answer is Maps can have at most one
238:24 - value associated with the same key the
238:27 - next question says attempting to get a
238:28 - value from a map where the key does not
238:30 - exist Returns the closest Value panics
238:32 - or Returns the zero value that's covered
238:35 - here in the section on missing keys but
238:37 - basically to summarize if you attempt to
238:40 - get a I mean we actually covered this in
238:42 - the last um the last coding assignment
238:44 - but if you attempt to access a key in a
238:47 - map where the key doesn't exist you'll
238:49 - just get back to zero value so for
238:51 - example if it's a map of strings to
238:54 - integers
238:55 - and you access a string that doesn't
238:58 - exist you'll get back as the value zero
239:01 - and that's kind of nice just because
239:03 - accessing values in a map is a safe
239:06 - operation your code will not will not
239:08 - panic so to answer the question it
239:10 - Returns the zero value
239:12 - and it's also worth pointing out really
239:14 - quickly that if the map doesn't exist so
239:17 - not that the key that you're trying to
239:19 - access doesn't exist but if the map
239:21 - itself doesn't exist if it's a nil map
239:23 - then your code will Panic so that is a
239:26 - dangerous operation you want to make
239:27 - sure you're always accessing values in
239:29 - maps that have been initialized the next
239:32 - question is a function can mutate the
239:34 - values stored in a map and those changes
239:36 - blank the caller effect or do not affect
239:40 - the caller now the answer to this one is
239:43 - in this first section that Maps like
239:45 - slices are references so when we pass a
239:48 - map into a function that function can
239:51 - change what's in the map and those
239:54 - changes will be visible outside of the
239:56 - function this is different from
239:57 - Primitives right strings integers
240:00 - um booleans those are all passed into
240:01 - functions by value if you mutate them
240:03 - within a function uh the the caller of
240:05 - that function will not see those changes
240:07 - unless you return those values but the
240:10 - same does not hold true for slices and
240:12 - maps
240:13 - so to answer the question a function can
240:16 - mutate the values stored in a map and
240:18 - those changes they do affect the collar
240:21 - the next question says what does the
240:23 - second return value from a retrieve
240:25 - operation in a map indicate so let's
240:29 - take a look at this code example here so
240:31 - we've got this time zone map where we're
240:33 - accessing the map at a given a given key
240:36 - and it can return two values
240:40 - the first value is the value associated
240:43 - with the key and the second value is a
240:45 - Boolean right we use this in the last
240:46 - coding assignment so a Boolean that
240:48 - indicates whether the value at the key
240:49 - is a nil value nope that's not accurate
240:52 - a Boolean that indicates whether the key
240:53 - exists that's the one
240:56 - let's practice with some nested Maps so
241:00 - like we talked about earlier Maps can
241:02 - contain other Maps as their values not
241:05 - as not as their keys right so let's jump
241:07 - into the assignment it says because
241:08 - textio is a glorified customer database
241:11 - right I mean we're sending
241:12 - SMS and email messages to a giant list
241:15 - of customers we're basically just a big
241:16 - customer database we have a lot of
241:18 - internal Logic for sorting and dealing
241:20 - with customer names complete the get
241:22 - name counts function it takes a slice of
241:24 - strings names
241:27 - and returns a nested Maps this is going
241:29 - to be very similar to the last
241:30 - assignment we did
241:32 - um but this time it's going to be a
241:33 - nested map where the first key is all
241:35 - the unique First characters of the names
241:36 - and the second key is all the names
241:39 - themselves so this could be useful if
241:41 - for some reason we wanted to get access
241:42 - to all of the names that start with a
241:45 - very quickly so to kind of visualize
241:47 - this we've got this example if the input
241:49 - names slice is this slice here Billy
241:52 - Billy Bob Joe it would create the
241:54 - following nested map so the first key is
241:57 - just a letter
242:00 - the second key is the full name and then
242:03 - the value is the number of times that
242:07 - name showed up in the original list and
242:09 - then it's worth pointing out here that
242:12 - the return value is a map of runes to a
242:15 - map of strings and integers in go we
242:18 - often just represent individual
242:20 - characters as runes rather than strings
242:23 - of length one it just gives us a little
242:25 - more kind of a surety in our type system
242:28 - okay so let's start by creating a new
242:31 - top level map so we'll call it counts
242:34 - and we'll make that full map
242:37 - now it's important to understand because
242:40 - this map contains Maps inside of it we
242:44 - will need to continuously initialize new
242:46 - maps I'll show you what that looks like
242:48 - so now let's just Loop over all these
242:50 - names so for
242:53 - um we don't care about the index name
242:55 - and range names
242:58 - Okay so we've got a name the first thing
243:00 - we need to do is actually check and see
243:03 - if we already have a map associated with
243:07 - the first character of this name so
243:09 - let's get that first character let's do
243:11 - if
243:13 - we probably need to do some safety
243:15 - checking so like if length of name
243:19 - actually the easiest thing to do would
243:21 - just be if name is the empty string
243:25 - and we'll continue
243:27 - we don't care about blank names they
243:29 - they don't do anything for us right so
243:31 - we'll just we'll just skip them great if
243:33 - it's not the empty string
243:35 - then we can say first character
243:39 - is name zero
243:41 - okay so that gives us the roon at the
243:44 - first index in the name
243:47 - and then what we can do is look up in
243:50 - our map so counts at first oops counts
243:54 - at first character
243:58 - um we can see if the inner map
244:02 - exists
244:04 - so if it does not exist not if not okay
244:10 - let's just keep it simple if it doesn't
244:12 - exist we'll just initialize it so if it
244:14 - does not exist we'll say counts at first
244:16 - character
244:18 - equals and we'll initialize the new
244:20 - inner map so we just need a new map of
244:24 - string to integer
244:27 - at that first character key
244:30 - right
244:31 - right in fact
244:34 - to be explicit I'm going to ignore the
244:36 - inner map there
244:38 - so by the time we get down here to line
244:41 - 18 we should be 100 certain that counts
244:44 - at first character contains an
244:47 - initialized map
244:48 - so then we can just simply do counts of
244:51 - first character at
244:53 - name
244:58 - plus plus
245:00 - right
245:02 - because we've we've made sure that the
245:04 - inner map exists and if
245:08 - the name key doesn't exist it will
245:10 - return a zero which we can then
245:12 - increment and save back into the map so
245:16 - that should work just fine
245:18 - at the end we can return counts
245:22 - cool hopefully that makes sense
245:26 - and we've got some test cases down here
245:29 - Matthew George Drew Philip Bryant and
245:31 - then a big list okay cool let's run it
245:33 - and see what happens
245:36 - whoops cannot use first Char variable of
245:39 - type byte as roon value
245:42 - right so when you index into a string
245:46 - right so name is a single string in go
245:49 - then it is a byte type but we want to
245:53 - Rune type so
245:55 - I'm gonna go ahead and cast it
245:57 - and run it again
246:02 - cool uh generating counts for 50 for the
246:05 - first 50 names count for M Matthew is
246:08 - three
246:09 - G George is One D Drew is four we don't
246:12 - have any panics so these counts look
246:16 - totally plausible to me let's go ahead
246:19 - and submit it
246:20 - it's time to talk about first class and
246:23 - higher order functions which are just
246:24 - really kind of confusing complex terms
246:27 - for a much simpler idea which is
246:29 - functions as data
246:32 - a programming language is said to
246:34 - support first class functions if it
246:36 - allows you to pass around functions just
246:39 - like you pass around any other variable
246:40 - storing essentially an entire function
246:42 - as a value and then a function that uses
246:47 - that first class function so a function
246:49 - that accepts another function as a
246:51 - parameter or returns a function as a
246:54 - return value is said to be called a
246:57 - higher order function let's take a look
246:59 - at a concrete example okay so here we
247:02 - have two functions add and multiply
247:04 - these are very simple functions you
247:06 - should be able to understand uh what
247:08 - they do just by looking at them for a
247:10 - second
247:11 - um but here we have kind of an
247:13 - interesting function it's called
247:15 - Aggregate and it takes as input
247:19 - three integers a b and c and it takes as
247:23 - input an entire function right so it
247:26 - takes a function and we're calling it
247:28 - here arithmetic it's the fourth
247:30 - parameter to the aggregate function and
247:33 - this function has a specific signature
247:35 - this function arithmetic must take as
247:39 - its parameters two integers
247:41 - okay and return an integer itself and
247:45 - then the aggregate function just returns
247:47 - an integer so what does the aggregate
247:49 - function do well it calls the function
247:53 - it was given Twice first it calls it
247:55 - once with a and b
247:57 - and then it calls it again with the
248:00 - results of A and B and C
248:03 - so for example if we call aggregate with
248:05 - the numbers 2 3 4 and the function add
248:09 - then it will add all three of those
248:11 - numbers together right which would in
248:13 - this case print nine
248:15 - and then we can also use that same
248:17 - aggregate function with the same numbers
248:18 - two three and four but this time pass in
248:21 - that multiply function and here we'll
248:23 - get 24 right because we're multiplying
248:26 - um all of the variables together instead
248:27 - of adding them it's okay if this is a
248:29 - bit confusing uh if this is the first
248:32 - time you've worked with functions as
248:34 - data take a second to really kind of
248:36 - stare at this code and and figure out
248:38 - these this crazy function signature it's
248:41 - actually not that complex once you kind
248:43 - of get past the scary syntax
248:46 - um but but don't feel bad if you have to
248:47 - pause the video and take a good look
248:49 - let's get our hands dirty with this
248:51 - assignment says textile is launching a
248:53 - new email messaging product malio I
248:57 - guess uh SMS and email right fix the
249:01 - compile time bug in the get formatted
249:03 - messages function the function body is
249:05 - correct but the function signature is
249:07 - not okay so this formatter function here
249:10 - looks like it will be a problem let's go
249:12 - ahead and run the code and see what kind
249:14 - of an error we get so this is compile
249:16 - time error saying we have a syntax
249:18 - problem and that makes sense because
249:20 - here we're basically saying well the
249:22 - formatter input is a function but we're
249:25 - not saying what type of function it is
249:27 - and that doesn't work because get
249:29 - formatted messages is going to use the
249:31 - formatter function so it needs to know
249:33 - essentially what parameters it takes as
249:36 - input and what it's going to return
249:37 - right kind of like the arithmetic
249:41 - function here takes two integers and
249:43 - returns an integer we need to update
249:46 - this function signature to kind of
249:48 - inform the get formatted messages
249:49 - function what this formatter function
249:52 - actually does so if we look at the code
249:55 - because we know the function body is
249:57 - correct it looks like
250:00 - formatter accepts a message's input
250:03 - which is a string
250:05 - and it's going to return whatever should
250:07 - be appended to this formatted messages
250:09 - slice which is a string so it looks like
250:11 - it takes one string as input and returns
250:14 - one string as output that kind of makes
250:15 - sense for a formatter function
250:18 - so we say it takes a string and it
250:21 - returns a string
250:23 - let's go ahead and run that and see what
250:25 - we get
250:26 - oh at least it compiled says thanks for
250:29 - getting back to me which returned thanks
250:32 - for getting back to me kind regards
250:34 - Okay cool so the ad signature ads kind
250:37 - regards to the end and add greeting
250:41 - thanks for getting back to me hello
250:43 - thanks for getting back to me cool let's
250:45 - go ahead and run that
250:50 - awesome
250:51 - so this might seem like an exercise in
250:54 - complexity right like why do I need to
250:57 - pass around functions as data that just
250:58 - seems to add a bunch of well needless
251:01 - complexity and for the most part you're
251:03 - right you really should only use higher
251:05 - order and first class functions if you
251:07 - have a very good reason to do so so the
251:09 - question is kind of what are the good
251:11 - reasons to do so well first class and
251:14 - higher order functions are very often
251:15 - used for on the back end side of the
251:18 - stack HTTP handlers right so if you have
251:21 - some front-end code that needs to reach
251:22 - out to a backend server and get some
251:24 - data those handlers are typically first
251:27 - class or higher order functions because
251:30 - we need some code right the Handler
251:33 - function to run like in the future we
251:36 - don't want to call it now right we want
251:37 - to call it when something happens in the
251:40 - UI World kind of on the on the front end
251:42 - side of the stack they're often used in
251:44 - on click handlers right so I write a
251:46 - function and I don't necessarily call it
251:48 - when my program starts but I call it
251:51 - when something thing interesting happens
251:52 - like the user clicks a button right when
251:55 - a button click happens I want to call
251:57 - you know this function and so typically
252:00 - in code we can represent that with a
252:02 - higher order function we say on click do
252:05 - this and then we kind of give it the
252:07 - name of a function to call and then just
252:09 - to review the definitions uh very
252:11 - quickly a first class function is a
252:14 - function that is kind of being passed
252:15 - around as data and a higher order
252:18 - function is the function that's using
252:20 - that first class function right it's a
252:22 - function that accepts a function as
252:23 - input or returns it as one of its return
252:26 - values so the question is what is a
252:28 - higher order function it is a function
252:30 - that takes another function as an
252:32 - argument or returns a function but it's
252:34 - not a function that is first in this
252:36 - call stack or a function with Superior
252:38 - logic
252:41 - so the next question is what is a first
252:44 - class function it is a function that is
252:47 - treated like any other variable right
252:48 - it's a function that we're going to pass
252:50 - around as as data to probably be called
252:53 - sometime in the future
252:54 - function carrying is kind of like a
252:57 - special kind of higher order function
252:59 - it's a function that accepts another
253:02 - function as input we're kind of familiar
253:04 - with that idea but that also returns a
253:08 - new function as its output so it's kind
253:10 - of a way of like enhancing a function
253:13 - with new Behavior it's kind of a weird
253:15 - concept to think about abstractly so
253:17 - let's jump into this example
253:19 - okay so here we have a function called
253:22 - self math and self math is the curried
253:25 - function it takes a math function as
253:27 - input that accepts two integers and
253:30 - returns an integer and it returns a new
253:33 - function that only takes a single
253:36 - integer as input and returns an integer
253:38 - and then what it does again it returns a
253:41 - function right that takes a single
253:42 - integer as an input and returns an
253:44 - integer and it calls the math function
253:46 - that it was given
253:48 - with the same input twice right so we're
253:51 - kind of mapping a function that accepts
253:53 - two different integers into a function
253:56 - that kind of forces both of those
253:58 - integers to be the same integer so like
254:01 - what does that do in practice well
254:03 - basically we can use our self math
254:06 - function to convert a multiply function
254:09 - into a square function right so multiply
254:12 - takes X and Y and multiplies them
254:14 - together this new Square function that
254:16 - we created dynamically only takes a
254:19 - single value and multiplies it by itself
254:22 - right same with the add function we can
254:25 - kind of use the self-map function to
254:27 - convert it into a function that just
254:29 - doubles its input right so we Square 5
254:32 - we get 25 we double 5 and we get 10. so
254:36 - when would carrying be used in the real
254:38 - world to be honest I don't use it very
254:40 - often but in backend server land I do
254:43 - sometimes use it for middleware
254:45 - functions so a middleware function is is
254:48 - a function that basically changes the
254:50 - HTTP Handler of a back-end server and
254:53 - just as a spoiler we will be covering
254:55 - this in the project at the end of this
254:57 - course
254:58 - um but it's for kind of injecting some
255:01 - additional logic into a function so say
255:03 - we have an HTTP Handler that accepts as
255:06 - input a user ID and returns an entire
255:09 - user object with you know say their
255:11 - first name their last name that sort of
255:12 - thing
255:14 - um a middleware function might do
255:16 - something like require an authentication
255:18 - token right so we can write all of our
255:20 - HTTP handlers that serve different data
255:23 - sort of independently and then we can
255:25 - use a curried function to kind of
255:27 - require authentication Logic on all of
255:30 - our HTTP handlers in fact in go currying
255:34 - is very often used to handle the sort of
255:37 - middleware problem now if all of that
255:39 - went straight over your head again
255:41 - that's okay it's kind of hard to talk
255:43 - about something that we're not working
255:45 - on at the moment so again we're going to
255:48 - hover middleware and HTTP handlers in
255:50 - the project at the end of this course so
255:52 - stick around for that so jumping into
255:54 - the assignment it says the mainly API
255:56 - needs a very robust error logging system
255:59 - so we can see when things are going awry
256:00 - in the back end we need a function that
256:03 - can create a custom logger a function
256:05 - that prints to the console given a
256:07 - specific formatter Okay cool so this
256:10 - function get logger should return a
256:13 - logger
256:14 - which is a function right it's a
256:16 - function that takes two strings as input
256:18 - and apparently prints them because it
256:21 - doesn't return anything
256:23 - and get logger takes as input a
256:26 - formatter which accepts two strings as
256:28 - input and returns a single string
256:31 - okay so it says complete the get logger
256:33 - function it should return a new function
256:34 - the inputs should be passed into the
256:36 - formatter function the order they're
256:38 - given to the logger function Okay so
256:41 - let's start writing this so we're going
256:43 - to return a function
256:45 - that takes two strings as input right
256:49 - and I'm going to reference up here for
256:53 - the syntax we're interested in so I'm
256:54 - going to do a string
256:57 - B string
256:59 - okay
257:01 - and this function should return nothing
257:03 - so we can just go straight into the body
257:06 - and it says
257:08 - this function prints the formatted
257:10 - inputs so formatter returns a single
257:13 - string so we can just do fmt.printline
257:16 - and we're going to need to oh we already
257:18 - have fmt imported perfect
257:21 - so we need to print the result of the
257:24 - formatter functions it's going to be
257:25 - formatter
257:26 - and we'll pass into the formatter A and
257:30 - B
257:34 - right so we're returning a new function
257:36 - a logger
257:37 - that accepts two inputs
257:40 - or mats them given the formatter that we
257:43 - were given right and that just prints it
257:45 - to the console
257:46 - cool let's go ahead and run that
257:52 - error on database server out of memory
257:53 - and database server CPU is pegged this
257:57 - all looks good let's see how the test
257:58 - Suite actually works
258:00 - it looks like these are the formatters
258:02 - colon delimit and comma delimit and if
258:05 - you take a look at our messages some are
258:07 - delimited by a colon some are delimited
258:09 - by a comma
258:12 - so that's how that is working very cool
258:15 - all right I'm going to go ahead and
258:16 - submit that I think this is correct
258:19 - time to talk about the defer keyword
258:21 - this is a really kind of unique thing to
258:24 - go if you're familiar with any other
258:27 - programming languages it's unlikely that
258:30 - you're familiar with something similar
258:32 - to the defer keyword at least I've never
258:35 - used it or used a concept that is
258:38 - similar to the defer keyword in another
258:40 - language
258:41 - um barely go specific okay so the defer
258:44 - keyword allows us to execute some
258:47 - function at the end of the current
258:50 - function or when the current function
258:52 - exits the Deferred keyword is very often
258:55 - used as sort of a clean up step
258:57 - um for example in this in this function
259:00 - here copy file
259:02 - we open a source file from the file
259:05 - system and then we defer closing the
259:08 - file right so every time you open access
259:11 - to a file in the file system you need to
259:13 - remember to close that file otherwise
259:15 - you're sort of wasting Computer
259:16 - Resources
259:18 - the problem is
259:20 - closing the file at the end of the
259:22 - function is a little tedious because we
259:24 - have multiple return statements here so
259:26 - we'd kind of have to close it before
259:27 - both of them if that makes sense by
259:30 - using the defer keyword we can just tell
259:31 - the go programming language hey I want
259:34 - to call source.close
259:36 - right before the copy file function ends
259:39 - and just defers it kind of until the end
259:42 - and it will only call it once no matter
259:44 - where the function actually returns from
259:47 - on to the assignment it says there is a
259:50 - bug in the log and delete function fix
259:51 - it let me expand this a little bit so we
259:54 - can see it this function should always
259:56 - delete the user from the user's map Okay
259:58 - cool so we're given a user's map we're
260:00 - given a name and we know that maps are
260:03 - passed by reference so if we delete a
260:05 - map it will be deleted in the callers
260:08 - code as well
260:12 - um it should return a log string that
260:13 - indicates to the color some information
260:14 - about the user's deletion okay so delete
260:17 - should always happen and then the kind
260:19 - of uh the appropriate log message should
260:22 - be returned from the function that makes
260:24 - sense
260:25 - um but it looks like there's a bug okay
260:27 - so let's go ahead and run the code and
260:28 - see what we get
260:32 - so initial users Brianna Elon John Cade
260:34 - attempting to delete John deleting Santa
260:37 - deleting Cade
260:40 - okay so John's still there the problem
260:42 - is that we're trying to delete John but
260:46 - John's not actually getting deleted
260:47 - right so we need to fix that bug
260:50 - and if we take a look John is an admin
260:55 - and here we are returning
260:58 - log admin but we're not deleting admins
261:01 - so so that's that's the real problem
261:03 - right the users should always be deleted
261:06 - now
261:07 - here's the problem we can do this
261:11 - um this will work
261:12 - if I run this my guess is this should
261:15 - fix the bug yep John is no longer there
261:18 - he was deleted successfully but this is
261:20 - kind of gross right we're calling delete
261:22 - three different times
261:25 - um what if in the future we add another
261:27 - case and we forget we forget to add the
261:30 - delete again we'll have another bug
261:32 - um
261:33 - well what we could do what we could do
261:36 - is just delete at the top once
261:39 - right
261:41 - but the problem is if we do that
261:45 - we delete the user from the user's map
261:47 - too soon
261:49 - and now this OK variable that's checking
261:51 - for existence so it can change which log
261:53 - is returned like that logic won't work
261:55 - it will just always be not okay so we'll
261:58 - always just return log not fan so that's
262:00 - a problem
262:02 - what we can do is defer the deletion so
262:05 - this code says we'll call this delete
262:08 - function right before login delete
262:11 - returns so if it's almost like the
262:14 - equivalent of you know adding this at
262:17 - every step of the way so let's go ahead
262:18 - and run that make sure it works
262:23 - John's there John's gone perfect and we
262:26 - have different logs getting returned so
262:29 - that looks good I'm gonna go ahead and
262:30 - submit that this chapter is not called
262:32 - Advanced functions uh for no reason
262:35 - let's talk about closures closures are
262:39 - um I don't want to like intimidate you
262:40 - and say they're really hard but they're
262:42 - a little weird so let's let's take a
262:44 - second second to understand uh how they
262:46 - work
262:46 - okay a closure is a function that
262:48 - references variables from outside its
262:50 - own function body the function May
262:52 - access and assign to the referenced
262:53 - variables so in this example
262:56 - the concature function returns a
262:59 - function that has a reference to the
263:00 - enclosed doc value okay so concature is
263:03 - a function it returns a new function
263:06 - right and that's what's Happening Here
263:11 - and it's enclosing this doc string
263:15 - within the function so it's getting
263:17 - initialized outside of the function and
263:19 - then getting used within the function
263:21 - and what happens is basically when we
263:25 - call concatter to to make this new
263:29 - like concat function
263:31 - we're saving a reference to this doc
263:34 - variable so every kind of concurrent not
263:37 - concurrence every uh subsequent call to
263:41 - this function that is returned we'll
263:44 - keep adding on right plus equals word
263:47 - we'll keep adding on to the same doc
263:50 - variable so let's look at what that kind
263:52 - of looks like in usage so we're calling
263:55 - concatter and we're getting back this
263:57 - Harry Potter aggregator right that's
263:59 - what we're assigning this function
264:03 - we're assigning this function into this
264:05 - variable so Harry Potter aggregator is a
264:07 - function right it's it's specifically
264:09 - it's this function right here
264:11 - cool and then we're going to call it
264:12 - with mister and then we'll call it again
264:15 - with and and Mrs dursley Right we're
264:18 - calling it over and over and over and
264:19 - what's happening under the hood is we're
264:21 - appending those words Mr and Mrs onto
264:25 - that doc variable so at the end when we
264:28 - finally print
264:30 - what's being returned which is the doc
264:32 - variable itself we get the full sentence
264:35 - Mr and Mrs dursley number four privet
264:38 - drive now closures are one of those
264:40 - Advanced things that you to be honest
264:42 - again don't you usually use in
264:44 - production code maybe every once in a
264:46 - while but they're very important to
264:48 - understand because it is very common to
264:51 - have kind of bugs surrounding closures
264:54 - so if you don't understand what's going
264:55 - on under the hood it can be really hard
264:57 - to debug a kind of complex code that
264:59 - might even be using closures by accident
265:02 - so the assignment says keeping track of
265:04 - how many emails we send is Mission
265:06 - critical at malio complete the adder
265:09 - function it should return a function
265:11 - that adds its input and integer to an
265:14 - enclosed sum value and then Returns the
265:16 - new sum in other words it keeps a
265:17 - running total of the sum variable within
265:20 - a closure Okay cool so it's going to be
265:21 - very similar to this right so we'll
265:23 - start by creating a sum value so sum
265:26 - colon equals zero right we're working
265:28 - with integers not flows and then we need
265:30 - to return
265:32 - a function with the signature so return
265:34 - dunk X int
265:37 - turns an INT
265:40 - oh not not returns an X returns an INT
265:43 - and then here the we need to add X to
265:47 - sum right so sum plus equals X
265:51 - and then we need to return
265:54 - the new sum
265:55 - right and then if we go take a look at
265:58 - this test case let's see
266:04 - okay so we're adding these email bills
266:08 - with a bunch of different numbers
266:11 - the test iterates over the bills ah okay
266:14 - so we're creating two adders here so
266:16 - we're creating account adder and a cost
266:18 - adder
266:20 - and then let me expand this
266:23 - I'm going to just make that basically
266:25 - full screen
266:27 - so the test actually creates two
266:29 - different adders two different instances
266:31 - of our Adder function right and one of
266:33 - them is going to count how many bills
266:36 - there are and the other one will keep a
266:39 - running total
266:40 - of the cost of all of the bills right so
266:43 - we're actually using our function twice
266:46 - for two different things and they'll
266:47 - each have their own enclosed some count
266:51 - that they keep track of differently
266:53 - right the count will have its own the
266:55 - cost will have its own the count is
266:56 - simple it just adds one either every
266:58 - time the cost will add the actual cost
267:00 - and pennies cool let's go ahead and run
267:02 - this
267:05 - so um and these values are getting
267:08 - interpolated into this message so you've
267:10 - sent one email costs 45 cents two emails
267:13 - 77 cents three emails 120 cents it's
267:16 - like all of these are going up that
267:18 - makes sense I mean we could even go
267:19 - verify right 45 plus 32 77 that looks
267:23 - right to me let's go ahead and submit it
267:26 - all right we're on to a little quiz
267:27 - about closures can a closure mutate a
267:30 - variable outside of its body uh yes
267:33 - that's basically the entire point of a
267:35 - closure another little review question
267:37 - here says when a variable is enclosed in
267:40 - a closure the enclosing function has
267:42 - access to blank a copy of the value or a
267:46 - mutable reference to the original value
267:48 - well if it was a copy then our sum never
267:51 - would have worked right because we'd be
267:52 - working with a new copy of the sum
267:54 - variable every time so it's actually a
267:56 - mutable reference to the original value
267:58 - we've already been using Anonymous
268:00 - functions kind of all throughout this
268:01 - chapter
268:02 - um now let's kind of just talk about
268:04 - what they are so Anonymous functions are
268:06 - exactly what they sound like they're
268:07 - just functions that do not have a name
268:09 - they have no name
268:12 - um Anonymous functions are really useful
268:13 - when you're kind of just one-off maybe
268:15 - creating a closure you're returning a
268:17 - new type of function if if you're not
268:20 - defining the function for like use
268:22 - across the entire program but you're
268:24 - more using it as a value using it as a
268:26 - first class function
268:27 - um that's when you're going to see
268:28 - Anonymous functions use the most so as
268:31 - an example
268:32 - um here we have an anonymous function
268:36 - declaration right we're creating a new
268:38 - function we're defining its internal
268:40 - logic it's it's function body but we're
268:42 - not giving it a name right there's no
268:44 - name for this function that we're
268:46 - passing into do math it is an anonymous
268:49 - function the assignment says complete
268:52 - the print reports function call Print
268:54 - cost report once for each message okay
268:57 - let's take a look print cost report
268:59 - looks like it takes as input a function
269:03 - cost calculator
269:04 - great okay
269:07 - call Print cost report once for each
269:09 - message pass an anonymous function as
269:10 - the cost calculator that returns an INT
269:12 - equal to twice the length of the input
269:14 - message okay let's go ahead and do that
269:16 - so
269:19 - um it says to do it once for each
269:20 - message yeah so four
269:22 - message
269:24 - range messages
269:30 - call Print cost report prints cost
269:33 - report
269:35 - and print cost report takes a cost
269:38 - calculator which is a function that
269:41 - takes a string and returns an INT
269:44 - is said to use an anonymous function
269:46 - right so funks we need to actually
269:48 - Define our X string int
269:51 - we need to define the body
269:53 - that returns an INT equal to twice the
269:56 - length of the input message so X is a
269:58 - string in fact I'm going to name this
269:59 - message
270:02 - and we'll return the length of message
270:05 - times two
270:08 - right twice the length of the input
270:09 - message and then print cost report takes
270:12 - a second parameter which is the message
270:14 - itself
270:15 - right
270:19 - I think am I am I reading this correctly
270:21 - cost report
270:23 - fix the calculator and the message
270:24 - itself yep because it's gonna it's then
270:26 - going to call the cost calculator and
270:28 - then and then print kind of a little
270:29 - report
270:30 - okay cool
270:32 - um that's looking pretty good to me
270:36 - we don't return anything from print
270:37 - reports okay let's go ahead and run this
270:43 - so message here's Johnny costs 28 cents
270:46 - go ahead make my day 42 cents you had me
270:49 - at hello 38 cents that's looking correct
270:51 - right there's 19
270:54 - 28 not 19 what's half of 28 14
270:57 - characters there looks good to me okay
271:00 - let's go ahead and submit that
271:03 - let's talk about pointers and in order
271:06 - to understand pointers we need to talk a
271:08 - little bit about Ram or memory right
271:11 - random access memory which is basically
271:13 - the part of the hardware in our computer
271:15 - that stores data right because pointers
271:18 - and variables are all about kind of how
271:20 - we store data in the memory of our
271:23 - computer let's start with something
271:24 - simple
271:26 - let's create a new variable
271:28 - in our program
271:31 - and let's call it X
271:33 - and we'll set x equal to 5.
271:35 - under the hood what happens
271:37 - automatically when we create a new
271:39 - variable uh and set it equal to five is
271:41 - somewhere in our computer's memory that
271:44 - variable's value is going to get stored
271:47 - so let's say uh for the sake of the
271:49 - example that it's stored here in memory
271:52 - address
271:52 - 169. Now Memory in your computer you can
271:55 - think of it as fairly simply a memory
271:58 - address that stores a value so we've got
272:01 - kind of you know millions of different
272:03 - memory addresses in which we can store
272:04 - data and somewhere in memory that value
272:09 - needs to live so let's just say it gets
272:11 - assigned again automatically
272:12 - to address 169.
272:16 - great now what happens if I create a new
272:18 - variable let's call it y
272:21 - and set it equal to the current value of
272:23 - x
272:25 - y actually gets a new copy of the value
272:29 - so X lives here at address 169 y let's
272:34 - just say is going to limit address 170
272:36 - and we get a copy of that five so down
272:39 - here in this table this is where we're
272:40 - going to keep track of all of our
272:42 - variables we'll say that X
272:45 - so X is the variable name lives at
272:48 - address 169
272:50 - and it stores the value 5.
272:54 - now why
272:56 - lives at address 170
273:00 - and stores also the value 5. at its most
273:04 - basic a pointer is just a variable that
273:09 - stores a memory address so let's say for
273:13 - example that we create a new variable
273:15 - called Z
273:17 - and we set it to point which is uh which
273:21 - uses the Ampersand I can't draw an
273:23 - ampersand pretend that that's an
273:25 - ampersand uh the the the a reference to
273:28 - X right it points to X
273:30 - what that does is that we're creating a
273:33 - new variable called Z
273:35 - it's going to get a new address anytime
273:38 - we create a new variable it's going to
273:39 - live in a new address in memory let's
273:41 - say it lives at address 171.
273:44 - but its value instead of being 5 instead
273:47 - of being a copy of X because we used
273:49 - kind of the pointer syntax or the
273:51 - reference syntax
273:53 - the value is going to be the address of
273:57 - x
273:59 - so we're going to store 169 which is the
274:02 - again the address of X as the value and
274:06 - Z is going to be a pointer type so kind
274:09 - of the way the go programming language
274:11 - works is it knows that Z is effectively
274:14 - pointing to the value 5 right because
274:17 - its address is 171.
274:19 - which stores a pointer to 169 so we can
274:22 - look up the value 5 at address 169.
274:26 - so what this means is if we update the
274:29 - value that Z points to under the hood
274:32 - we're updating X so we can do things
274:35 - like pass pointers into functions change
274:38 - the underlying value and the value
274:41 - outside of that function is also changed
274:44 - which again in a language like go
274:45 - doesn't happen normally because
274:47 - typically if you pass a variable like X
274:49 - into a function and then change it those
274:52 - changes are not seen outside of the
274:54 - function you would need to return the
274:56 - updated value and then assign it into a
274:58 - new variable so pointers basically allow
275:00 - us to change the value of something from
275:02 - within a function right from within a
275:04 - different scope let me show you what
275:07 - that looks like in a quick example so
275:09 - remember that Z stores the value 169.
275:13 - which points to this address
275:16 - which stores the value 5.
275:19 - so if we want to update the value of x
275:22 - without having access to the original
275:24 - variable x what we can do is use the D
275:27 - reference operator which is an asterisk
275:30 - we can dereference Z now this D
275:33 - reference operator essentially follows
275:35 - this chain and finds the value right and
275:37 - we reassign into it let's say the value
275:41 - 6. so this becomes 6 and this location
275:45 - in memory is updated now to hold the
275:48 - value 6. so we've updated the value of x
275:52 - without even without even using right
275:55 - the name X so now that we've kind of
275:58 - covered what a pointer is let's look at
276:00 - just a little bit more of the syntax in
276:03 - code
276:03 - so the type of a pointer is not the type
276:07 - of the underlying value alone so if I
276:10 - want a pointer to an integer I actually
276:13 - have to use this syntax here I'm
276:15 - creating a new variable called p
276:17 - and it's being initialized as a pointer
276:20 - to an integer so a pointer is a specific
276:22 - type in go
276:24 - now to be fair
276:26 - um it's not super common that you're
276:28 - creating blank pointers and the zero
276:30 - value for a pointer is nil more often
276:34 - than not what you're going to do is have
276:35 - a concrete value like this my string
276:38 - hello and then you'll create a pointer
276:40 - to that value by using the Ampersand
276:44 - like we talked about so in this case the
276:47 - type of my string is string and the type
276:51 - of my string pointer is a pointer to a
276:54 - string which would be syntactically star
276:57 - string they're kind of two primary
277:00 - reasons that you would use a pointer in
277:02 - the go programming language the first is
277:04 - the more common reason which is you want
277:06 - to be able to pass a value into a
277:08 - function and change the value and have
277:11 - those changes kind of persist outside of
277:13 - the function right because normally when
277:15 - you pass a value into a function a copy
277:18 - is passed in so if you want to pass in
277:20 - sort of the original value so it can be
277:22 - changed and updated uh you might use a
277:24 - pointer the second reason is if you're
277:26 - very concerned about the performance of
277:28 - your program every time you create a
277:31 - copy of a variable in memory you have to
277:33 - copy that variable in memory right which
277:36 - takes some time so if you're dealing
277:39 - with lots and lots of data and you're
277:40 - trying to be very performant you can
277:43 - make micro optimizations and kind of use
277:45 - pointers on under the hood if you want
277:47 - to avoid all of that memory copying now
277:50 - I will say that you usually won't want
277:52 - to do this up front because pointers are
277:54 - dangerous and they can lead to bugs if
277:57 - not used properly so generally speaking
278:00 - I would recommend against making those
278:02 - performance optimizations unless you
278:04 - really need them let's jump into the
278:06 - assignment it says fix the bug in the
278:08 - send message function it's supposed to
278:10 - print a nicely formatted message to the
278:11 - console containing an sms's recipient
278:14 - and message body however it's not
278:15 - working as expected okay so let's run
278:18 - the code
278:21 - and we get these kind of weird weird
278:23 - looking values that are getting printed
278:26 - here in the two and the message Fields
278:30 - now this is hexadecimal it's not binary
278:33 - it's not decimal it's hexadecimal and
278:36 - this is the default formatting for a
278:38 - memory address so we have these
278:41 - ampersands here they're creating
278:43 - pointers too
278:45 - the underlying values that's not what we
278:48 - want it's not what we want here right
278:50 - that's why this looks disgusting we need
278:52 - to dereference or sorry we need to
278:55 - remove the reference I guess dereference
278:58 - um
279:00 - we need to remove the Ampersand so that
279:01 - we are no longer creating pointers so
279:03 - run it again
279:05 - and we get the values themselves which
279:07 - is what what we've been asked to do
279:12 - let's recap some syntax sometimes it can
279:14 - get a little confusing between the
279:16 - asterisk and the Ampersand what each of
279:18 - them mean and in what context so when
279:20 - we're talking about the type of a
279:23 - variable in go a Pointer's type is
279:27 - star and then you know the type of the
279:30 - underlying value so a pointer to an INT
279:32 - is star int
279:34 - an ampersand is used to reference a
279:37 - value so if we want to create a pointer
279:40 - to the my string variable or the my
279:44 - string value then we use an ampersand so
279:47 - the Ampersand followed by the name of a
279:50 - variable creates a pointer to that
279:53 - variable now here's where it can get
279:55 - just a little bit tricky
279:57 - the asterisk is again used to
280:00 - de-reference a pointer so the asterisk
280:03 - is used in a Pointer's type it's also
280:07 - used as an operator to dereference a
280:09 - pointer so when we say
280:12 - asterisk my string pointer this refers
280:16 - to the underlying value so we can
280:18 - actually change the underlying value Say
280:21 - by assigning it to in this case a new
280:23 - string so in short ampersands to create
280:27 - new references or new pointers to a
280:30 - value and the asterisk is used to
280:33 - de-reference a pointer and get back at
280:35 - that underlying value let's hop into the
280:38 - assignment it says complete the remove
280:40 - profanity function it should use the
280:42 - strings dot replace all functions this
280:45 - is a built-in function in the standard
280:47 - library in the strings package to
280:49 - replace all instances of the following
280:51 - words in the input message with
280:54 - asterisks it should mutate the value in
280:58 - the pointer and return nothing do not
280:59 - alter the function signature Okay cool
281:01 - so remove profanity takes as input a a a
281:05 - message variable which is a pointer to a
281:09 - string so because it's a pointer we're
281:11 - going to be able to mutate it without
281:14 - returning anything explicitly okay let's
281:17 - jump into it so first thing we're going
281:19 - to do is dereference
281:22 - the message pointer and store
281:26 - its value in a new variable called
281:27 - message value
281:29 - and then we'll just update this
281:32 - by using that strings dot replace all
281:35 - functions strings dot replace all
281:39 - we want to replace the values in message
281:41 - value we want to or I should say we want
281:44 - to replace substrings from message value
281:46 - we'll look for the word dang and we'll
281:49 - replace it with four asterisks
281:53 - and we want to do the same thing twice
281:56 - more
281:57 - with shoot which has five letters so
281:59 - let's add an asterisk and heck
282:02 - which has four so that should be good
282:05 - cool let's let's run this I need to
282:07 - import the strings package before I
282:09 - forget and see what happens
282:11 - so
282:12 - in its current state we actually did not
282:15 - update anything right shoot is still
282:17 - there dang is still there that's because
282:19 - we actually need to
282:22 - point the message
282:25 - pointer to a string back at the updated
282:28 - value so we can do dereferenced message
282:31 - equals
282:33 - message value
282:35 - let's run that
282:38 - perfect
282:39 - let's submit it
282:42 - now we've got a pointer quiz so the
282:44 - question is what is the value of
282:46 - Ampersand y after the code on the left
282:49 - executes
282:50 - so we've got X set to 50 Y is a pointer
282:55 - to an integer
282:56 - okay well in this case it's just going
282:59 - to be 100 because we're explicitly
283:00 - setting it to 100 on the last line of
283:02 - the code
283:03 - so that one was pretty easy now this
283:05 - question is a little trickier it says
283:07 - what is the value of x after the code on
283:10 - the left executes well X is set to 50.
283:14 - Y is a pointer to X
283:17 - and then we dereference y instead equal
283:19 - to 100.
283:20 - so that's actually also going to be 100
283:24 - because we're setting X through Y which
283:28 - is a pointer to X
283:30 - I mentioned earlier that pointers can be
283:32 - dangerous and that is definitely the
283:34 - case if a pointer points to nothing then
283:38 - it's zero value is nil right so this is
283:41 - the same for interfaces or errors right
283:44 - in go fairly often you'll be checking at
283:47 - runtime if a value is nil or not and the
283:51 - thing about pointers is if you ever try
283:53 - to de-reference a pointer that doesn't
283:56 - point to anything your code will Panic
283:59 - so pretty much any time you dereference
284:01 - something you should be checking before
284:03 - you dereference it to make sure that the
284:06 - pointer actually points to a valid
284:08 - location in memory so this assignment
284:10 - says let's make our profanity Checker
284:11 - safe update the remove profanity
284:13 - function If the message is nil return
284:15 - early to avoid a panic okay so let me
284:17 - run it in its current state and you'll
284:20 - see we get this nasty Panic here it says
284:22 - invalid memory address or nil
284:26 - okay so what we need to do here is if
284:29 - message
284:31 - equals equals nil
284:33 - return
284:35 - nothing right if we've been given an
284:38 - invalid input we'll just bail early
284:40 - another way to do this if the assignment
284:43 - expected something different we could
284:45 - return an error here right we might do
284:47 - something like return errors.new invalid
284:50 - input I think that would also be a good
284:52 - way to write this function but we've
284:55 - been asked to just do a naked return so
284:57 - we will do that let's submit it
285:00 - so let's talk about how pointers are
285:02 - used in conjunction with methods so
285:05 - you'll very frequently see that methods
285:09 - actually take a pointer receiver rather
285:12 - than a non-pointer receiver and
285:14 - typically that's done because the method
285:17 - will be making changes to the instance
285:20 - of the type itself in this case a struct
285:22 - right so we have this car with a color
285:24 - field and the set color method on the
285:27 - car is going to change the color right
285:29 - and so here if we create a new car we
285:32 - set the color to blue and then print it
285:34 - you can see it's been updated to Blue
285:35 - instead of white now contrast that with
285:39 - a non-pointer receiver
285:41 - this acts like a normal function right
285:43 - we don't have a pointer so we don't have
285:45 - a reference to the location in memory so
285:48 - if we update the car's color to Blue it
285:51 - actually just stays white it doesn't
285:53 - persist that change so that's why I say
285:56 - that it's uh more common that you'll see
285:58 - pointer receivers on methods than
286:01 - non-pointer receivers but but you will
286:03 - definitely see both so the question is
286:05 - which is more widely used in go and the
286:07 - answer is pointer receivers now when it
286:10 - comes to pointer receivers one thing
286:12 - that's important to understand from like
286:13 - a syntactic point of view is that even
286:15 - though the uh the input on the left hand
286:19 - side right the receiver is a pointer
286:21 - when you actually call the method you
286:24 - can call
286:26 - in this case right the grow method you
286:28 - can actually call it on just a normal
286:30 - value or a pointer it will sort of cast
286:32 - the value under the hood to a pointer if
286:35 - it isn't one already right so C in this
286:37 - case is just a circle it's not a pointer
286:40 - to a circle but when we call C dot grow
286:43 - the pointer to the circle is passed into
286:46 - the method so we didn't need to kind of
286:48 - explicitly you know cast c to a pointer
286:50 - to a circle by you know adding an
286:52 - ampersand right here
286:54 - okay so with that understood
286:56 - um let's move on to the assignment so
286:58 - the assignment says fix the bug in the
287:00 - codes that set message sets the message
287:01 - field of the given email structure and
287:03 - the new value persists outside the scope
287:05 - of the set message method Okay so we've
287:07 - got this email struct we've got the set
287:09 - message uh the set message
287:13 - method
287:14 - if I run the code in its current state
287:18 - we've got before messages my first draft
287:21 - Sandra Bullock after looks identical
287:24 - right and if we go and take a look at
287:26 - the test Suite then we can see
287:30 - that
287:32 - set message is being called this is my
287:35 - second draft so we would have expected
287:37 - this message to say this is my second
287:39 - draft instead of this my first draft the
287:41 - reason it's not happening is because
287:43 - this function essentially doesn't do
287:46 - anything this method does nothing
287:47 - because
287:49 - this is not a pointer to an email
287:52 - let's go ahead and run that again
287:56 - first draft second draft perfect
287:59 - let's submit that
288:01 - everything we've done up to this point
288:03 - in the course has been in the browser
288:05 - we've been writing code right in our
288:08 - text editor on boot Dev now we're going
288:11 - to break out of that environment and do
288:13 - some local development on our own
288:15 - machine we're going to figure out how to
288:16 - use the go tool chain to build real
288:19 - production go programs
288:21 - but before we do that let's talk a
288:24 - little bit about packages we need to
288:26 - understand packages in order to build
288:28 - our own go programs now you've probably
288:30 - noticed that up until this point in the
288:32 - course every coding assignment has had
288:34 - the words package main at the top of the
288:37 - file that just means that we've been
288:39 - writing code within the main package and
288:42 - that's actually really important the
288:44 - main package is a special type of
288:47 - package it's a package that runs as a
288:49 - standalone program so anytime you're
288:52 - writing an actual application that you
288:54 - need to run say on the command line or
288:56 - as a server you'll be writing code
288:58 - within the main package a package with
289:01 - any other name so any name besides main
289:05 - is a library package and basically what
289:09 - that means is it's imported by other
289:11 - libraries and application code so
289:14 - oftentimes it's just imported by a main
289:17 - package so that it can use it if you're
289:19 - familiar with npm from JavaScript or pip
289:22 - from python that's effectively what a
289:25 - non-main package is in go it's just some
289:27 - code that you can publish as kind of a
289:30 - standalone library that then other
289:32 - developers can use in their main
289:35 - packages in their actual applications
289:37 - so let's take a look at an example here
289:40 - so you're probably familiar with this
289:42 - style of code it's what we've been
289:43 - writing uh all throughout this course
289:45 - we've been writing within the main
289:47 - package because we've been writing
289:48 - executable scripts right code that
289:51 - actually runs and does something
289:54 - and then we have this import statement
289:56 - where we've typically just been
289:57 - importing from the standard library but
289:59 - the standard library is made up of
290:02 - Library packages right like the fmt
290:04 - package or the Math slash random package
290:08 - the interesting thing about the main
290:10 - package is that it always has a main
290:12 - function and that main function serves
290:14 - as the entry point to the program so
290:17 - packages that are not main packages
290:19 - they're Library packages we'll just
290:21 - export functions named functions to be
290:24 - used Again by other libraries and
290:27 - application code only main packages will
290:30 - have a main function that runs when the
290:33 - program starts so to jump into the
290:35 - coding assignment it just says fix the
290:36 - bug in the code so let's go ahead and
290:38 - run the code and see what happens
290:46 - nothing happens right we're stuck in
290:49 - this infinite Loop apparently apparently
290:52 - this code compiles and then does nothing
290:55 - it's kind of a weird Behavior right in
290:58 - order to fix this all we need to do is
291:01 - update this
291:03 - to be a main package so that we get as
291:05 - output for our code a runnable
291:08 - executable a script that we can actually
291:09 - execute in the browser so let's go ahead
291:11 - and run that
291:12 - and we get starting meleosterver
291:14 - stopping malio server kind of as we
291:17 - would expect uh based on uh based on
291:20 - this code here so I'm going to go ahead
291:21 - and submit that so we're familiar with
291:24 - main packages but what about Library
291:25 - packages well by convention a package's
291:29 - name is the same as the last element of
291:31 - its import path so for example the math
291:33 - Rand or Math slash Rand package from the
291:37 - go standard library has files that begin
291:40 - with package Rand so the Rand package
291:44 - lives at Math slash rant now it's
291:47 - important to point out that the standard
291:48 - Library actually has another Rand
291:50 - package at crypto slash rant so they're
291:54 - both kind of the Rand package but they
291:55 - have different import paths when a
291:58 - package isn't part of the standard
292:00 - Library when for example you make your
292:03 - own Library package the import path is
292:07 - typically the same as the remote URL
292:10 - that you'd use to go look at that
292:12 - library's source code so for example in
292:15 - our fictitious maleo products right part
292:18 - of the textio conglomerate of messaging
292:20 - products uh they might have their own
292:23 - GitHub namespace it's slash malio so
292:25 - github.com malio is their GitHub
292:27 - organization and then maybe they create
292:29 - their own package or their own excuse me
292:32 - repository on GitHub called Rand and
292:35 - that's where the repository for their
292:37 - Rand package lives that's where the
292:38 - source code lives on the internet right
292:40 - github.com Rand now that package is Name
292:44 - by convention should be Rand because
292:47 - that's the last section of the import
292:49 - path
292:51 - but that's just a convention they could
292:53 - if they wanted to change the name of the
292:56 - package to say random and then all of
292:58 - the files in their source code would say
293:00 - package random now again it is possible
293:04 - to use a different package name one
293:06 - that's not the same as the last section
293:09 - of the import path but I highly
293:11 - discourage it it is best practice to
293:13 - just use the convention and keep
293:15 - everything consistent now one last thing
293:17 - to point out here is that in go packages
293:20 - live at the directory level rather than
293:23 - the file level so if you're used to say
293:25 - python or JavaScript you might be used
293:29 - to importing code directly from other
293:31 - files in go if all of the code lives
293:35 - within the same directory then it's part
293:37 - of the same package and you don't need
293:39 - to Import and Export code between files
293:41 - in the same package or in the same
293:43 - directory so in go you would only need
293:46 - to import code if it lives in a
293:49 - different directory or a different
293:51 - package and packages and directories are
293:53 - one and the same you can't have multiple
293:55 - packages in the same directory so the
293:58 - quiz question for this section is what
294:00 - would be the conventional package name
294:02 - of a package with the path github.com
294:05 - parser
294:08 - and the answer is going to be parser
294:10 - because it should match the last section
294:12 - of the import path
294:14 - the next question on the topic of
294:16 - package naming is given the import path
294:19 - of path to Rand path slash two slash
294:22 - Rand which of these is a valid package
294:25 - name so notice it's not asking which is
294:28 - a conventional it's asking which one is
294:29 - actually valid we've got random Rand
294:32 - spam any of these path well Rand would
294:34 - be the conventional name but actually
294:36 - any of these could technically be used
294:39 - okay it's time to write some go code on
294:42 - our local machines and you're going to
294:44 - need three things in order to make it
294:46 - through the rest of this chapter the
294:48 - first thing is you're going to need an
294:50 - editor I'll be using vs code throughout
294:53 - the rest of this chapter to do all of
294:54 - our local development stuff you can use
294:56 - vs code or you can use something else
294:58 - that you're more familiar with if you do
295:01 - use vs code you'll probably want to
295:03 - install the official golang plugin the
295:06 - next thing you'll need is a unix-like or
295:08 - sh-like terminal so if you're on macro
295:11 - Linux then the built-in terminal will
295:12 - work just fine if you're on Windows you
295:15 - have a few different options personally
295:17 - I would recommend installing Ubuntu in
295:19 - wsl2 I'll link uh in the description
295:22 - down below how to do that but you will
295:24 - need to have a terminal in order to
295:26 - follow along with these instructions if
295:28 - you choose to use something like the
295:30 - default Windows command line you're
295:31 - going to have to change some of the
295:32 - instructions in the terminal to kind of
295:34 - translate them to your own machine the
295:37 - last thing you'll need is just to
295:38 - install the go tool chain on your local
295:40 - machine and I would recommend one of two
295:42 - different ways the first is to use the
295:44 - official download page and the second is
295:47 - to use the Webby download script either
295:50 - of them will work and I've linked to
295:51 - them both on this page so you can go
295:53 - check them out and get go download it
295:54 - now once you've downloaded and installed
295:57 - go the way you can test to make sure
295:59 - that everything is working correctly is
296:01 - type Go version in your terminal if you
296:04 - get back a valid Go version of at least
296:07 - version 1.20 which is what I'm using at
296:10 - the time of recording this video then
296:12 - you should be good to go now I need to
296:14 - point out at this point that some people
296:15 - get confused and think this is Go
296:17 - version 1.2 it's not it's Go version
296:20 - 1.20 which is the same as Go version
296:23 - 1.20 which is one version greater than
296:27 - go 1.19 or go 1.19 so make sure that
296:30 - you're not on Go 1.2 that would be very
296:32 - very old if you're having trouble
296:35 - getting go installed so that you can use
296:37 - it within your terminal the first thing
296:39 - I'll have you do is definitely try
296:40 - closing your shell session and
296:42 - restarting it a lot of times that can
296:44 - help just getting go into your path if
296:48 - that doesn't work then Googling around
296:50 - can be one method to kind of try to
296:53 - figure out what's going on on your
296:54 - machine it's really hard for me to kind
296:56 - of predict what issues you might have
296:58 - especially considering the fact that Mac
297:00 - OS windows and Linux can all be a little
297:02 - different but what I will recommend is
297:04 - that if you're are having trouble jump
297:06 - into the boot Dev Discord and ask a
297:09 - specific question about the trouble
297:10 - you're having and we'll be happy to help
297:12 - you out so the question for this step
297:14 - really just to confirm that we installed
297:16 - go correctly and that we can use it asks
297:19 - what does the Go version command print
297:21 - and if we check the output we can see it
297:23 - says Go version go 1.20 so that's the
297:26 - that's the version of the go tool chain
297:28 - we have uh Darwin I'm on a Mac so this
297:31 - is like the core Unix operating system
297:33 - and then amd64 which is my CPU
297:36 - architecture so it's going to be this
297:39 - bottom one so we've talked about
297:41 - packages and we've talked about how
297:43 - packages exist basically the directory
297:45 - level and go now we need to talk about
297:47 - modules a module is a bigger idea than
297:51 - just a package a module is kind of a
297:54 - releasable collection of go packages so
297:58 - sometimes it's just a single package
297:59 - right you have a single package a single
298:01 - module and you release it as one package
298:04 - but other times you might break that
298:06 - main package up into sub packages and
298:10 - you'd release all of those packages
298:12 - together as one go module now a
298:16 - repository is not a unique idea to go
298:18 - but it's sort of even greater than just
298:21 - a module repository or a git repository
298:25 - is just a collection of code that you
298:27 - kind of keep in Source control all the
298:30 - same level and it can contain one or
298:32 - more modules though it's actually really
298:34 - common for a single repository to just
298:37 - have a single go module within it so
298:40 - while one model repo can have many
298:43 - different go modules inside of it I
298:45 - would argue that's not usually the case
298:47 - typically you'll have one go module
298:50 - living in one repository that's not a
298:52 - convention that's just the way I've seen
298:54 - it more often than not so for the sake
298:56 - of example let's assume a git repository
298:59 - that contains a single module and that
299:02 - means that at the root of the git
299:04 - repository we'd have a single go dot mod
299:06 - file that looks something like this the
299:09 - first line contains the path prefix for
299:12 - the entire module so remember a module
299:14 - can contain in multiple packages and
299:17 - every package in that module its import
299:20 - path is going to be prefixed with the
299:22 - path of the entire module the next line
299:25 - just specifies the Go version and the
299:27 - last line will specify any dependencies
299:30 - that this module depends on so to answer
299:34 - the question what is a go module an
299:38 - executable main package
299:40 - um no that could be part of a go module
299:42 - but it's not a go module itself
299:45 - a collection of packages that are
299:46 - released together that is accurate a
299:49 - file of go code no a module will contain
299:52 - many many files of go code or a library
299:55 - package and again no not necessarily you
299:58 - could have a module that's just a single
300:00 - Library package but a go module can be
300:02 - many more packages than that or it could
300:04 - be a main package for example so it's
300:06 - going to be a collection of packages
300:07 - that are released together
300:09 - so we need to talk just a little bit
300:12 - more about these import paths now if
300:15 - you're familiar with npm from the
300:16 - JavaScript ecosystem cargo from the rust
300:19 - ecosystem or pip from the python
300:21 - ecosystem then you're probably familiar
300:23 - with the idea of a namespace for a
300:26 - third-party package for example I might
300:28 - make a package called Left pad publish
300:31 - it up to npm's Central repository and
300:34 - now anyone in the world just knowing my
300:36 - kind of namespace name left pad can
300:39 - download and use my code as a dependency
300:42 - the interesting thing about the go
300:44 - ecosystem is that there is no central
300:46 - location for third-party packages like
300:49 - npmjs.com in JavaScript land instead the
300:54 - goats will chain sort of works on top of
300:57 - git and actually uses the import path as
301:00 - the remote URL and it looks to that
301:03 - import path for where it can go download
301:06 - code so more often than not you'll see
301:08 - modules with support pass that start
301:10 - with github.com or gitlab.com because
301:13 - that's where the code itself is hosted
301:16 - an important exception to this rule that
301:19 - the import path is where you go to
301:20 - download the code is the standard
301:22 - Library you don't need to download
301:23 - standard Library code it comes packaged
301:26 - with the go tool chain so the question
301:28 - is do packages in the standard Library
301:30 - have a module path prefix the answer is
301:33 - no
301:35 - the next question is what is an import
301:38 - path and I know we've already talked
301:39 - about this but I want to show you a more
301:40 - concrete example so this is the
301:42 - github.com wagslane slash go Dash
301:46 - rabbitmq GitHub repository so this is a
301:49 - GitHub repository that I maintain it's
301:51 - just a little package for rabbitmq users
301:53 - a little go client for rabbitmq so this
301:56 - is a library module and a library
301:59 - package it's intended for other
302:01 - developers to actually import this code
302:03 - into their applications it's not a
302:05 - standalone you know main package so
302:08 - let's take a look at the file structure
302:12 - at the very root of the repository we
302:14 - have the go dot mod file now this is
302:16 - that kind of simple standard setup where
302:19 - one git repository happens to have one
302:22 - go module or one sort of releaseable
302:25 - unit of code and if we take a peek
302:28 - inside we can see that the go.mod file
302:33 - specifies the import path github.com
302:36 - wagslane slash go Dash rabbitmq so this
302:40 - matches the URL of the git repository
302:44 - hosted on GitHub now here's the
302:46 - interesting thing this module only has
302:50 - one package that's exported to the
302:53 - outside world and it exists here at this
302:54 - top level so you can see all of these go
302:56 - files consume.go consumeroptions.go they
302:59 - exist at the top level of the repository
303:01 - so when you import this package to use
303:05 - it you just import from this root path
303:09 - because the root package is what you're
303:12 - importing there are no sub packages to
303:15 - import here but let's pretend for a
303:17 - second that we did want to export
303:18 - another package in the same go module so
303:22 - we have our top level go module go
303:24 - rabbitmq and the top level package that
303:27 - could be accessed at the same import
303:29 - path as the module let's say we added
303:32 - another directory we could call it maybe
303:34 - Network works and inside it would be the
303:37 - networks package if someone wanted to
303:40 - import that package then they would take
303:42 - the import path for the entire module
303:45 - github.com
303:47 - which points to the root package like we
303:50 - already talked about and it would just
303:52 - append another slash networks onto the
303:54 - end right so the module path serves as a
303:58 - prefix for any nested packages
304:01 - so to answer the original question what
304:04 - is an import path well it's not an HTTP
304:06 - connection and it's not a restful server
304:08 - it's a module path plus an optional
304:12 - package subdirectory so we've talked
304:15 - about repositories modules packages
304:16 - you've got go installed now let's talk
304:18 - about how you can set up your local
304:20 - development environment and some of this
304:23 - stuff isn't going to be necessary and
304:25 - I'll point that out but I do want to
304:26 - show you how I've set up my machine and
304:28 - you can emulate the way I do it if you
304:30 - like that style now I need to mention
304:33 - the go path
304:36 - if you're Googling around trying to
304:37 - figure out how to set up your local
304:38 - development environment for go you will
304:40 - almost certainly come across old
304:42 - outdated articles that talk about the go
304:44 - path in kind of any version newer than I
304:47 - think it's 1.13 right so we're on 1.20
304:50 - now you can basically forget about the
304:54 - go path you don't need to worry about it
304:56 - you used to have to put your code in the
304:59 - go path now the recommended way is
305:01 - actually to not put your code in the go
305:03 - path it can be a little confusing but
305:05 - again generally speaking you can just
305:07 - forget about the go path and if you find
305:10 - any articles that talk about it they're
305:12 - probably outdated the entire idea of go
305:16 - modules is what replaced the old go path
305:19 - so the question is do you need to put
305:21 - your code inside of your go path the
305:24 - answers are yes it doesn't matter and no
305:26 - in fact you shouldn't and actually in
305:28 - fact you shouldn't
305:31 - so I've altered my window layout so
305:33 - that's a little bit easier for you to
305:35 - see what I'm doing I've got the boot Dev
305:37 - instructions over here on the left and
305:39 - then I've got vs code over here on the
305:41 - right with my terminal at the bottom
305:43 - cool so I'm just here in my file system
305:45 - I'm not within the go path I'm just kind
305:47 - of in my personal workspace and we'll
305:49 - just follow these instructions it says
305:50 - create a new directory and enter it so
305:52 - we'll make directory hello go
305:56 - and let me just LS show you the new
305:59 - directory was created and we'll enter
306:01 - that directory
306:02 - cool now inside of that new hello go
306:05 - directory I'm going to create new go
306:07 - module so we'll do go mod init
306:10 - and I keep all of my code on GitHub so
306:12 - I'll do github.com slash my username
306:16 - because that's my namespace on GitHub so
306:18 - wagslane slash the name of this project
306:22 - which we're just calling hello go
306:25 - cool it says go creating new module now
306:28 - if I LS I should see that new go.mod
306:32 - file next let's go ahead and take a look
306:35 - at that file
306:37 - so you can see it just created a new
306:39 - module
306:40 - github.com hello go with the Go version
306:43 - and there are no dependencies yet so
306:45 - there's no other sections to the go
306:47 - module file so now that we are done with
306:49 - this step the question is why does go
306:51 - include a remote URL in module paths
306:54 - right so this is a remote URL in theory
306:58 - right when we push this up to GitHub
306:59 - we'll push it up to this URL and the
307:02 - answers are to confuse new Gophers uh to
307:05 - ensure that developers are using Source
307:06 - control or to simplify remote
307:08 - downloading of packages and it is
307:10 - definitely that last one the next
307:12 - question on the same step asks what is
307:15 - Hello go in our case the repository
307:18 - slash directory name or the module path
307:20 - prefix and in our case it's actually the
307:24 - name of the repository so again if we
307:26 - were to push this up to GitHub github's
307:28 - the name of the website where it's
307:29 - hosted wagslane is my namespace on
307:32 - GitHub and hello go would be the name of
307:35 - the directory that we are in and the
307:37 - name of the repository up on GitHub
307:44 - then this next question is just to make
307:46 - sure that we completed the step properly
307:48 - what does the first line of go.mod
307:50 - contain and it contains module followed
307:53 - by
307:54 - the module path
307:55 - now so that vs code will work properly
307:58 - with all my syntax highlighting with the
308:00 - go plugin I'm actually going to reopen
308:03 - uh vs code
308:05 - to that same directory the hello go
308:08 - directory so we'll just be working
308:10 - within this module for a second
308:14 - and the instructions say inside of hello
308:17 - go so now I'm inside of this hello go
308:20 - directory at kind of the top level of uh
308:23 - my vs code window it says create a new
308:25 - file called main.go let's go ahead and
308:27 - do that
308:30 - conventionally the file in the main
308:31 - package uh that contains the main
308:33 - function is called main.go paste the
308:36 - following code into your file Okay cool
308:38 - so we should all be familiar with this
308:40 - code by now right we've we've probably
308:43 - written code like this uh I don't know
308:46 - almost a hundred times by now in the
308:48 - boot Dev platform next it looks like
308:51 - we're just going to run the code using
308:53 - the go tool chains interpreter so go run
308:57 - main.go
308:59 - and we get a nice hello world printed to
309:03 - the console there are sort of two main
309:05 - ways to run go code locally one is with
309:08 - the go run command like we just used the
309:10 - other is to use the go build command
309:12 - which we'll get into in just a second
309:13 - and actually in general I prefer the go
309:17 - build method go run is really only
309:20 - suitable for when you're running a tiny
309:22 - little scripts like this one and just to
309:25 - be clear about the difference go run so
309:28 - go run main.go runs the go code in the
309:32 - file that we pass in right in this case
309:34 - main.go and and that's all it does go
309:37 - build actually builds a production
309:39 - executable which is how you'll use your
309:42 - go code in the real world so I typically
309:45 - prefer building that production
309:46 - executable just because it's more
309:48 - accurately reflects how your code will
309:50 - run in production so the question on
309:53 - this step is does go run build a
309:56 - production executable and the answer is
309:58 - no it just kind of one off runs your
310:00 - code it doesn't build any production
310:02 - ready artifacts now at the end of this
310:05 - same step we're asked to execute the go
310:07 - help run command in our shell so go help
310:10 - run which just prints out a bunch of
310:14 - help information on how to use the go
310:17 - run command and the question for the
310:19 - step says which can go run except as
310:22 - arguments if we scroll to the top so
310:24 - here's where I ran go help run
310:26 - uh we can see the usage information and
310:28 - it says run compiles and runs the named
310:31 - main go package typically the package is
310:33 - specified as a list of dot go source
310:36 - files from a single directory but it can
310:37 - also be an import path file system path
310:39 - or pattern matching a single known
310:42 - package so which can go run accept as
310:45 - arguments package names file names it
310:47 - actually looks like it can handle both
310:49 - great now we get to use go build so you
310:52 - can for the most part just forget about
310:53 - go run you probably don't need to use it
310:56 - all too often so go build compiles go
310:59 - code into an executable program so all
311:01 - you need to do is make sure that you're
311:03 - in the same kind of main package that
311:06 - you want to build so I'm here in the
311:07 - hello go directory I can LS to prove it
311:11 - to you we've got the main.go file here
311:13 - package main Funk main all that good
311:16 - stuff we'll run go build
311:19 - we don't even need to pass in package or
311:21 - file names it just builds uh the package
311:24 - of the current directory so as you can
311:26 - see here we have this new executable
311:29 - binary in our current hello go directory
311:32 - now if you remember way back to I think
311:35 - chapter one of this course we talked
311:37 - about the difference between interpreted
311:38 - languages and compiled languages and one
311:41 - of the amazing things about go is that
311:43 - we build compiled executables that we
311:46 - can execute anywhere so this hello go
311:49 - binary we can now copy this put it on
311:52 - another machine and run it without even
311:54 - needing to install the go tool chain on
311:56 - that machine this is compiled machine
311:58 - code so we can now run this hello go
312:02 - program like we would any other
312:03 - executable dot slash hello go
312:06 - and it prints hello world now I do want
312:09 - to show you a little tip here because
312:10 - every time you update your code let's
312:13 - say I change this to hello world 2. if I
312:16 - just re-run hello go it still will just
312:19 - print hello world and that's because I
312:21 - didn't re-compile my code so a lot of
312:23 - new go developers kind of forget to
312:25 - recompile their code and they think they
312:27 - have bugs or their code's not doing what
312:29 - they expect you have to recompile what
312:30 - I'd recommend doing is just every time
312:33 - you update your code and want to rerun
312:35 - it uh you should build and compile and
312:37 - you can just do it in the same step by
312:38 - doing go build and then double Ampersand
312:40 - dot slash the name of your binary so
312:43 - this basically says compile my code if
312:46 - that succeeds run the compiled binary
312:49 - and the question for this step is what
312:51 - was created after running go build an
312:54 - executable file named main an executable
312:56 - file named hello go or a package named
312:59 - CMD and in this case it was an
313:01 - executable file named hello go right
313:04 - we've got it right there it just kind of
313:05 - defaults to the name of the directory
313:08 - the next question for this step is what
313:10 - happens when you run a DOT slash hello
313:12 - go and I actually change this to hello
313:14 - world 2 but if we do it again after
313:16 - changing the code back
313:18 - um the options are program panics hello
313:21 - world is printed or the code compiles
313:23 - um hello world is printed and it's
313:25 - important to understand here the reason
313:27 - we don't say the code compiles is
313:29 - because at this step dot slash hello go
313:31 - all we are doing is running the compiled
313:34 - binary we're not recompiling the code
313:37 - the next command in the go tool chain
313:40 - that we're going to talk about is go
313:41 - install now to be honest I don't use it
313:44 - a ton but I still think it's important
313:45 - to understand because you'll see it
313:47 - around okay so ensure you're in your
313:49 - hello go repo then run go install so I'm
313:51 - here in the hello go directory and we
313:53 - run go install
313:56 - and next we navigate out of our project
313:59 - directory so I'm going to go up one
314:00 - level
314:01 - and what it's telling me is go has
314:04 - installed the hello go program globally
314:07 - so the go tool chain when we ran go
314:09 - install basically compiled that code and
314:11 - then made it globally accessible to our
314:13 - entire machine so now if I run a hello
314:15 - go notice without the dot slash because
314:18 - I'm not running a program in my current
314:20 - directory I'm running now a program
314:22 - that's in my path
314:24 - it prints hello world so now I can use
314:27 - this script that I built anywhere on my
314:30 - machine which is just super useful
314:32 - um if you're building kind of scripts
314:34 - for your own local productivity so the
314:36 - question for this step is what does go
314:38 - install do saves local code to the
314:41 - remote Source control provider installs
314:43 - dependencies or compiles and installs
314:45 - the program locally and the answer is
314:47 - that it compiles and installs the
314:48 - program locally again you would really
314:50 - only use this if you're building scripts
314:52 - for your own personal use on your
314:54 - machine the next question for this same
314:57 - step is code must be compiled with go
315:00 - build before running go install it's
315:02 - true false now if you're paying
315:04 - attention you probably noticed the
315:06 - answer here but we actually ran go
315:08 - install without a binary existing in our
315:12 - current directory so if I go back into
315:13 - the hello go directory and run go
315:15 - install
315:16 - you'll see there's actually no hello go
315:19 - binary that exists here and it works
315:21 - just the same so the code does not need
315:24 - to be compiled with go build first
315:27 - all right so we've created a main
315:29 - package and a executable program now
315:32 - we're going to build a library package a
315:34 - custom Library package so uh what we're
315:37 - supposed to do is create a sibling
315:39 - directory at the same level as the hello
315:40 - go directory so I'm in the hello go
315:42 - directory currently I'm going to go up
315:43 - one level and let's see so we've got a
315:47 - hello go in here I'm going to make a new
315:48 - directory called my strings
315:52 - and then we'll go into my strings
315:55 - and here we need to initialize a new go
315:57 - module so I'll do go mod init
316:00 - github.com wagslane
316:03 - slash my strings
316:07 - and that module is created now to get my
316:09 - vs code tooling all working properly
316:12 - again I'm going to just reopen
316:15 - es code to that level so we'll go back
316:17 - and find the my strings
316:19 - directory and open directly into that
316:22 - directory
316:23 - okay
316:25 - next we create a new file called
316:27 - mystrings.go so this is the go dot mod
316:30 - that we created with the go mod init
316:33 - command and now we're creating a new
316:34 - file called mystrings.go
316:38 - and we want to paste the following code
316:44 - okay so package my strings that's the
316:47 - first thing to notice right this is not
316:48 - a main package so we won't be able to
316:50 - build this package as a standalone
316:53 - executable this package will be kind of
316:56 - the intention is for us to use it in our
316:58 - other hello go package
317:00 - the other thing to notice about this
317:03 - code aside from the package name is that
317:06 - there is no main function here again
317:09 - because it's not an executable program
317:11 - we're just going to be exporting
317:13 - functions that can be used in our main
317:16 - package let's talk a little bit about
317:18 - this reverse function so this is the
317:20 - only function in the mystrings package
317:22 - at the moment and uh you know
317:25 - theoretically it reverses a string from
317:26 - left to right although I haven't tested
317:28 - it
317:29 - um but the important thing is that we
317:30 - need to capitalize we need to capitalize
317:33 - the first letter of the function's name
317:36 - and that's because in go that's how we
317:38 - export a function
317:40 - if it were little r then this function
317:43 - would not be able to be used outside of
317:45 - this package but we want to export it
317:47 - because we want to be able to use it in
317:49 - our main package right in the hello go
317:51 - directory and kind of import this logic
317:53 - and use it now we're told to run the go
317:56 - build command here in this directory and
317:58 - you'll notice it doesn't actually seem
318:00 - to do anything there again there was no
318:02 - executable file that was built because
318:05 - this is not a main package but it is
318:07 - worth pointing out that go build is
318:09 - still a useful command because it checks
318:10 - for compile time errors so for example
318:12 - if I create an invalid token here and
318:15 - then run go build we will get compile
318:18 - time errors so it is still kind of
318:20 - useful just to make sure that this code
318:22 - compiles so the question for this step
318:25 - is what was the output of the go build
318:27 - command in the library package was it an
318:31 - executable program or was the compiled
318:32 - package silently saved to the local
318:34 - build cache well we didn't get an
318:36 - executable package right this is not a
318:39 - main package so we don't get get a nice
318:41 - runnable executable instead it is
318:43 - silently saved to the local build cache
318:45 - so it can be used later in an actual
318:47 - executable program
318:49 - and then the next question is why is the
318:52 - function capital r reverse instead of
318:54 - lowercase R reverse and its lowercase
318:57 - names aren't exported for external use
318:59 - or conventionally uppercase names are
319:01 - used in go the answer is that lowercase
319:03 - names are not exported so by convention
319:06 - functions can have either a lowercase
319:09 - name or an uppercase name and uppercase
319:11 - names are exported from the package so
319:14 - this next question is does a package in
319:16 - a folder named date parser need to also
319:19 - be called Date parser right does the
319:21 - package need to be days parser now
319:23 - you'll notice that we created a
319:25 - directory called my strings and a
319:27 - package called my strings and if you
319:30 - remember back to earlier in this chapter
319:31 - we talked about how by convention that's
319:34 - the best way to do it it's not necessary
319:36 - but it is it is the convention okay so
319:40 - now let's use our reverse function back
319:43 - in the main package in the hello go
319:45 - directory right so it says modify hello
319:48 - goes main.go so I need to reopen
319:51 - I'm going to open vs code back into the
319:56 - hello go directory
320:01 - it says modify hello goes main.go file
320:03 - okay so we'll use parentheses here so
320:06 - that we can do some multiple Imports
320:10 - and we'll be using the import path that
320:13 - matches the module name of our mystrings
320:16 - package so in my case it was github.com
320:18 - wagslane
320:21 - slash my strings
320:24 - and then here we just copy this code
320:28 - from the instructions and in fact let me
320:31 - space this out so we can see it just a
320:33 - little bit better Okay cool so we've
320:35 - imported the mystrings package and then
320:37 - down in our code we can use my strings
320:39 - which is the name of the package dot
320:42 - reverse
320:44 - to call that exported function
320:47 - okay
320:49 - now because we've added a dependency we
320:52 - need to update our go.mod file so
320:55 - edit the hello goes go.mod file to
320:58 - contain the following
320:59 - this is the important part down here
321:02 - so we need to add
321:05 - replace example.com username my strings
321:08 - with dot dot slash my strings and
321:11 - require example.com username slash my
321:15 - strings version zero now I do need to
321:18 - update this right because I didn't use
321:20 - example.com I used github.com wagslane
321:26 - now what's going on here right
321:30 - goes dependency management is very
321:33 - heavily based on git and remote URLs so
321:36 - normally what you would do is take your
321:39 - my streams my strings package and push
321:43 - it up to GitHub and then import it from
321:46 - there and sort of all of the go packages
321:48 - in the world that require the my strings
321:51 - package will point up to that remote
321:53 - location that remote server what we're
321:56 - doing here with this replace and require
322:00 - well specifically the replace is we're
322:03 - kind of doing a little hack to get
322:05 - things to work locally without having to
322:07 - publish to get so we're basically saying
322:10 - I want you to take this string this
322:13 - import path right github.com
322:16 - mystrings and don't go look for it out
322:19 - on the internet instead just resolve it
322:22 - to this path dot dot slash my strings
322:25 - right and now because does well I should
322:27 - probably get back into the hello go
322:30 - directory
322:32 - right dot dot slash my strings this is
322:36 - the directory containing the mystrings
322:38 - package right so we're basically just
322:40 - saying replace this with my local uh
322:43 - file system we're telling go how to find
322:46 - this package on our machine so now that
322:49 - we've made those changes we can build
322:52 - and run this program again so go build
322:55 - dot slash hello go
322:59 - build and run and it looks like it's
323:02 - working correctly this this function is
323:05 - supposed to reverse the string and we
323:06 - get this nasty little
323:10 - and the question is just asking us what
323:12 - was printed and that's what we got on
323:15 - the same step this next question asks
323:18 - how does the go tool chain know where to
323:20 - find the imported code
323:22 - npm hosts the files publicly it
323:24 - downloads it from Google servers we use
323:26 - the replace keyword in the gobot.mod to
323:29 - point it to the relative location of my
323:31 - strings or it was fetched from GitHub
323:33 - now again I want to point out that most
323:35 - of the time you'll be fetching code from
323:36 - GitHub or gitlab or some remote Source
323:39 - when you're using third-party
323:41 - dependencies in our case we used this
323:44 - replace keyword to point the go tool
323:48 - chain to the location of the mystrings
323:50 - package on our machine so we already
323:53 - briefly talked about this but I just
323:54 - want to reiterate that this little
323:57 - replace hack is useful for kind of
324:00 - testing and doing things on our local
324:01 - machine but it's not suitable for
324:04 - production generally what you would do
324:06 - is push up that my strings git
324:08 - repository to GitHub and then import
324:10 - from there so you will typically not see
324:13 - replace aliases in production go.mod
324:17 - files very often you'll just see
324:20 - packages sort of required vanilla from
324:24 - their remote location so now we're going
324:26 - to practice using a remote third-party
324:29 - module says create a new directory in
324:31 - the same Parent Directory as hellogo and
324:34 - my strings called Date test so let's go
324:36 - back up one level
324:38 - and create a new directory maker
324:41 - date test
324:43 - then I'm going to go ahead and again
324:45 - reopen vs code
324:48 - into that directory
324:53 - okay create a main.go with this code
324:58 - we can do that
325:04 - next initialize a module so we do
325:10 - go mod init and again I'll just use
325:13 - github.com wax Lane slash date test
325:19 - creating new go.mod to add module
325:21 - requirements and Subs do go mod tidy
325:24 - okay cool
325:26 - um I'm gonna ignore that for just a
325:27 - second and instead I'm going to follow
325:28 - the instructions it says download and
325:30 - install the remote go tiny date package
325:31 - using go get
325:34 - Okay so we've used go install in the
325:36 - past right go install installs and
325:38 - executable on our machine to be used
325:40 - anywhere go get is how we go download
325:43 - and install third-party dependencies so
325:46 - we're going and grabbing the
325:50 - github.comytime module
325:53 - and it gets added automatically
325:57 - to our go.mod you'll see that it just
326:00 - kind of grabs the latest version
326:04 - cool
326:05 - um print the contents of your go.mod I
326:07 - don't need to run that because we've got
326:08 - it open here in vs code and then compile
326:11 - and run our program again so
326:13 - let's do that go build
326:16 - and run and it's going to compile
326:20 - to
326:21 - a file called Date test right because
326:23 - that's the name of our directory
326:28 - cool and as you can see it's printing
326:31 - out this date here so what did we do
326:33 - right we used go get
326:36 - to download code from this remote
326:38 - location which also happens to be the
326:41 - import path right because that's how go
326:43 - packages work typically so let me go
326:46 - grab that and just show you this is
326:51 - this is a package that's hosted on
326:54 - GitHub so the go tool chain actually
326:55 - went to GitHub and downloaded this code
326:58 - right added it to the go dot mod as a
327:01 - dependency and then created this new
327:03 - file called go.sum that kind of contains
327:07 - any uh transient dependencies or
327:10 - dependencies used by the go tiny time
327:13 - package that we just imported so it kind
327:15 - of keeps track of everything that we're
327:17 - using and the question for this one is
327:19 - how did the go tool chain know where to
327:21 - download the Go tiny time package
327:23 - oh man this uh this question is not
327:26 - optimized for this ridiculously zoomed
327:29 - in view it says the module import path
327:31 - is used for remote lookups EG github.com
327:34 - go timing time or the go tool chain has
327:38 - every open source go modules location
327:39 - memorized uh that is not true it just it
327:42 - just does a remote lookup right it goes
327:44 - and fetches that from the remote git URL
327:48 - and then just to make sure that we did
327:50 - the step correctly uh it's asking us
327:52 - what was printed after running the new
327:54 - date test program you can see it right
327:56 - there and it looks like it's this
327:59 - 2020-04-03 right it's it's this
328:02 - hard-coded date in RFC
328:06 - 3339 format
328:09 - so hopefully that last section gave you
328:10 - a taste of local development at least
328:12 - showing you how to build and compile
328:14 - some code on your own machine we'll
328:16 - obviously be doing a lot more local
328:17 - development at the end of this video
328:19 - with the project but for now for the
328:21 - rest of this course we'll be back
328:22 - working in the boot Dev web interface
328:25 - cool so we're on to talking about clean
328:27 - packages and this is kind of just a an
328:31 - article that I'm not going to bother
328:33 - reading out loud on screen but I'll talk
328:35 - about each individual section as the
328:38 - questions are asked so
328:39 - the question is should you export code
328:42 - from the main package and that's talked
328:46 - about down here but it's basically
328:48 - simple don't export code from the main
328:50 - package and if you think about it it
328:51 - makes sense there's no reason to
328:53 - capitalize function names in the main
328:54 - package because no other packages can
328:57 - import from a main package a main
329:00 - package is built into its own Standalone
329:02 - executable it's not a library so a
329:05 - capitalizing functions in the main
329:07 - package is just kind of confusing
329:09 - because it kind of signals to developers
329:11 - that you're writing code that's meant to
329:13 - be imported and it's not
329:16 - this next question says when should you
329:19 - not export a function variable or type
329:23 - now this is an interesting question I
329:26 - think a lot of newer developers think
329:28 - well maybe I should just export more
329:30 - stuff because maybe the users of my
329:33 - package will find it useful you actually
329:36 - want to think in the reverse you want to
329:38 - export as few things as possible when
329:41 - you're building Library packages because
329:43 - anytime you export a function you now
329:46 - need to support that function right you
329:49 - can't really take it away later
329:50 - everyone's code will break right so you
329:53 - should really think about what you're
329:54 - exposing to your users as like the
329:57 - surface area of a shape and you want to
329:59 - keep that surface area as small as
330:02 - possible to keep the maintenance burden
330:04 - down and to make your package easy to
330:06 - use right the fewer things that your
330:09 - users need to know about in order to
330:11 - effectively use your package the easier
330:13 - it'll be to use so when should you not
330:15 - export a function variables or type when
330:18 - the end user doesn't need to know about
330:20 - it hide everything that they don't need
330:23 - to to know about the next question is
330:25 - should you often change a package's
330:28 - exported API so API stands for
330:30 - application programming interface and
330:32 - basically anytime you export something
330:34 - from a library package you're adding
330:37 - that thing to the packages API right
330:41 - it's the interface that other developers
330:43 - will use to access your package so
330:46 - should you often change a package's
330:48 - exported API the answer is that no you
330:51 - should try to keep changes to your
330:53 - internal functionality right imagine if
330:55 - the go programming language let's say
330:57 - the standard Library changed fmt dot
331:00 - print line to fft.print right and just
331:04 - removed fmt.printline that would break
331:07 - an immense amount of code right so you
331:10 - don't want to go about publishing
331:11 - packages that you intend to kind of
331:13 - update the API for uh very rapidly
331:16 - stable apis are good apis
331:20 - so should you often change a package as
331:22 - exported API no try to keep the changes
331:24 - to internal functionality yes move fast
331:27 - and break things or if the package is
331:29 - main then yes the answer is just no try
331:33 - to keep changes to internal
331:35 - functionality again if the package is
331:38 - main then it's irrelevant because you're
331:40 - not building a library
331:43 - I want to talk about the difference
331:45 - between concurrent or parallel
331:47 - programming and synchronous or
331:50 - sequential programming now it's worth
331:52 - pointing out at this point that
331:53 - concurrency and parallelism are
331:56 - different and we'll talk about their
331:57 - differences in a future course for for
331:59 - now we're going to kind of treat them as
332:02 - the same idea and I'll just kind of
332:03 - refer to them as concurrency similarly
332:06 - sequential programming and synchronous
332:09 - they're slightly different terms but I'm
332:11 - going to kind of bucket them for the
332:12 - purpose of this discussion we'll be
332:14 - really comparing uh concurrent code to
332:17 - synchronous or sequential code so let's
332:20 - start with the easy one let's talk about
332:21 - synchronous or sequential programming
332:24 - say we have some code
332:26 - X colon equals five
332:28 - X plus plus and then maybe fmt dot print
332:34 - dot print
332:36 - line
332:38 - X
332:39 - the nice thing about this code and what
332:41 - makes it synchronous or sequential is
332:43 - that the code executes in order from top
332:45 - to bottom right first we create a
332:47 - variable named X set equal to five then
332:49 - we increment it by one and then we print
332:51 - X right everything's happening in order
332:54 - from top to bottom one thing at a time
332:57 - now this is usually what you want it's
333:00 - simple it's easy to reason about it's
333:02 - easy to write code this way the problem
333:04 - is sometimes it's not the most efficient
333:06 - way to write performance code or code
333:09 - that can run as fast as possible on a
333:13 - given set of Hardware so in order to
333:15 - understand how we can maybe optimize
333:16 - this we need to look into how your
333:19 - computer's CPU or Central Processing
333:23 - Unit works
333:26 - so your CPU has a clock speed which
333:29 - basically like from a very high level
333:31 - means how many instructions how many
333:34 - instructions
333:35 - it can do per let's say second those
333:38 - aren't necessarily the units but it is
333:40 - basically how many computations it can
333:42 - do per amount of time you just say it's
333:46 - seconds to keep things simple
333:48 - okay so when we're analyzing this code
333:50 - over here on the right basically what
333:51 - needs to happen is first we set x equal
333:53 - to five and that takes up one
333:56 - instruction right after that we get to
333:58 - increment X by six that'll take up
334:00 - another instruction and then we get to
334:01 - print X so the speed at which we can
334:05 - execute this little program here is
334:08 - dependent on how fast the CPUs clock
334:11 - speed is so if we want our program to go
334:14 - faster we can basically do one of two
334:15 - things either we can reduce the number
334:18 - of instructions required for our program
334:21 - to execute or we can get a faster CPU
334:25 - one that can do more instructions per
334:27 - second the problem is getting a faster
334:30 - CPU sometimes is really really expensive
334:33 - and so instead of getting a faster CPU
334:36 - what we've kind of done over the years
334:38 - is instead add more CPUs and in this
334:44 - case we've kind of broken the CPU up
334:46 - actually into what we call different
334:48 - cores so you might actually have a quad
334:51 - core processor Each of which let's say
334:53 - does I don't know five thousand
334:57 - instructions per nanosecond I'm totally
335:00 - making these units up
335:02 - um but you get the idea any one of these
335:05 - CPU cores can only do 5000 but the
335:07 - interesting thing is they can all do
335:10 - five thousand per nanosecond at the same
335:13 - time so if we distribute our program
335:16 - across all of the cores in theory we
335:19 - should be able to go uh we should be
335:20 - able to go about four times as fast
335:24 - again if we use all four cores instead
335:27 - of just one the problem is that most
335:29 - code we write can't take advantage of
335:32 - all four cores for example let's look at
335:34 - this code over here we set x equal to
335:36 - five and then we increment it and then
335:38 - we print it it has to happen in one two
335:41 - three
335:43 - right in order one two three we can't do
335:46 - all of these instructions at the same
335:48 - time if we did then X plus plus would
335:51 - have nothing to increment because we
335:53 - never would have set
335:54 - um an X variable equal to five in the
335:56 - first place and print line X would have
335:58 - nothing to print because X hasn't been
336:01 - set yet so writing concurrent or
336:04 - parallel code can drastically speed up
336:07 - the performance of our programs because
336:08 - we're able to distribute
336:10 - um kind of all the instructions that we
336:12 - need to compute across multiple cores
336:14 - the problem is we do actually need to
336:16 - write our code in a different way we
336:18 - need to expect that some of the
336:21 - instructions are going to happen at the
336:23 - same time and that's what's going to
336:25 - speed up our program so let's say we had
336:27 - a little bit more code in our program
336:29 - here maybe we have X or excuse me y
336:32 - colon equals six
336:34 - y minus minus
336:37 - fmt dot print
336:40 - line
336:42 - y
336:43 - okay this code here in this block kind
336:48 - of dependent on each other right we have
336:49 - to do it in one two three order and the
336:53 - same goes for this block here
336:55 - but we don't have to necessarily do this
336:58 - block of code where we calculate and
337:00 - print X before or after we calculate and
337:03 - print y they're kind of separate in that
337:05 - way so we can actually do is take this
337:07 - block of code and execute it in one core
337:09 - and at the same time execute this other
337:11 - block of code in another core doing them
337:15 - at the same time so let's sort of
337:16 - visualize the runtime of this program
337:19 - here if we run this code synchronously
337:22 - or sequentially right not taking
337:24 - advantage of two CPU cores but instead
337:26 - of doing it all in one core then our
337:28 - running time might look something like
337:29 - this
337:30 - I don't know let's just say six
337:33 - nanoseconds
337:34 - but instead if we run it across two
337:37 - cores in parallel
337:40 - each core executes at the same time
337:46 - and they'll each take approximately
337:47 - let's say three nanoseconds
337:51 - so we're done in half the time again
337:53 - because we took advantage of the
337:55 - hardware that was available to us so to
337:57 - wrap up writing concurrent code in many
338:01 - cases can drastically reduce kind of how
338:05 - long it takes to run our programs and it
338:07 - depends just a little bit on kind of
338:09 - fundamentally what we are trying to do
338:10 - so in this case we literally could take
338:12 - a program and chop its run time in half
338:16 - by utilizing a little bit more Hardware
338:18 - so this chapter is going to be all about
338:20 - concurrency in the go programming
338:22 - language and the great thing about go is
338:25 - how easy it makes it to write concurrent
338:28 - code so the question is how do we write
338:30 - concurrent code in go what's the syntax
338:33 - well there's actually a really awesome
338:36 - built-in keyword to the go program
338:38 - language the go keyword and it spawns a
338:42 - new go routine when you use it now a go
338:45 - routine is kind of unique to the go
338:48 - programming language but at a high level
338:50 - you can just think of it as a a separate
338:52 - thread of execution we're essentially
338:54 - telling the go programming language hey
338:56 - all this stuff in this function right
338:59 - that I'm calling with the go keyword can
339:01 - happen in parallel right we can go
339:03 - execute that on another core of the CPU
339:06 - if we need to so whenever we use the go
339:09 - keyword execution kind of immediately
339:12 - jumps to the next step after the
339:15 - function call right so this do something
339:18 - function will kind of go be executed in
339:22 - parallel right and then execution
339:24 - continues in the current function I'm
339:26 - kind of just on the next line and then
339:28 - as a last note before we jump into some
339:30 - code to see how this really works when
339:32 - we use the go keyword we are not able to
339:35 - capture any return values from this
339:38 - function call which makes sense right
339:39 - because we're kind of moving on we can't
339:42 - wait for the function to finish and
339:44 - return some stuff that's the whole point
339:46 - we want the function to go kind of do
339:48 - its thing on another thread so let's try
339:51 - this out in an assignment it says Emilio
339:53 - we send a lot of network requests right
339:55 - requests over the Internet each email we
339:58 - send must go out over the internet to
340:00 - serve our millions of customers we need
340:01 - to we need a single go program to be
340:03 - capable of sending thousands of emails
340:05 - at once right so we need to be able to
340:06 - do lots of things at once this is what
340:08 - go routines allow us to do
340:10 - edit the send email function to execute
340:13 - its Anonymous function concurrently so
340:15 - that the received message prints after
340:17 - the send message so let's go ahead and
340:19 - run the code in its current state
340:26 - and we get email received hello there
340:29 - Stacy email sent hello there Stacy right
340:31 - so it looks out of order
340:33 - now here's our send email function it
340:36 - takes a message
340:37 - as a string parameter
340:40 - and the interesting thing is it calls
340:43 - this Anonymous function here right so
340:44 - it's defining this function and then
340:46 - immediately calling it where it's going
340:49 - to wait for 250 milliseconds and then
340:51 - print email received and then this
340:54 - function will exit
340:56 - and it will print email sent right and
340:58 - then print the message so again that's
341:00 - why this is out of order right we're
341:01 - we're executing this function first and
341:04 - then we're moving on to the next line
341:06 - so the way we fix this is by using the
341:09 - go keyword
341:11 - to execute this bit of code at the same
341:14 - time as this bit of code right the go
341:17 - keyword will immediately move down to
341:19 - line 13 on the main thread or the main
341:21 - go routine and spawn a new go routine to
341:24 - kind of do this in the background and
341:27 - because of this waiting time the email
341:30 - received message should happen
341:32 - afterwards so let's go ahead and run
341:35 - this again
341:40 - sent received sent received looks good
341:42 - to me
341:43 - so you may have been thinking to
341:45 - yourself well how useful is it to call a
341:48 - function in a go routine if I can't even
341:49 - get the return values the answer in go
341:52 - is that we use channels typically to
341:55 - kind of re-synchronize our code so
341:58 - typically we'll use go routines or the
342:01 - go keyword plus sum function let's go do
342:04 - a bunch of computation all at the same
342:06 - time and then we can kind of
342:07 - re-synchronize either in the main go
342:09 - routine or in some other go routine by
342:12 - passing data back and forth between go
342:14 - routines using channels a channel is
342:18 - really just a thread safe or go routine
342:20 - safe Q we can put stuff in one end and
342:25 - read it out the other end in the same
342:27 - order so we'll typically have one or
342:29 - more go routines kind of sending data
342:32 - into the channel maybe they finished a
342:34 - calculation they're returning their
342:36 - results over the channel and it'll have
342:37 - one or more go routines on the other end
342:40 - reading that data off of the channel and
342:42 - processing it some way maybe sending a
342:45 - report maybe printing it to the console
342:47 - so this is the Syntax for making a
342:49 - channel and channels are typed so we can
342:51 - say this is a channel of integers
342:54 - and then we can send data into the
342:56 - channel using this Arrow operator it's
342:59 - it's really pretty intuitive we're
343:00 - saying 69 is being sent into the channel
343:03 - and then it's actually the same operator
343:06 - to read a value out of a channel we just
343:08 - move it over to the other side again
343:10 - super intuitive we're reading a value
343:12 - out of the channel and saving it into
343:15 - the variable V in this example now it's
343:18 - important to understand that the both of
343:19 - these operations sending and receiving
343:22 - on a channel are blocking operations so
343:25 - if I'm trying to send a value into a
343:28 - channel and there's no other go routine
343:31 - on the other side that will be able to
343:32 - read it out then my code will actually
343:34 - stop and wait on this go routine until
343:38 - there is a reader ready and the same
343:40 - goes for reading when a go routine gets
343:43 - to this section of code if there's
343:45 - nothing being sent into the channel on
343:48 - another go routine then this code will
343:50 - just sit and wait until something is
343:52 - sent so let's move on to the assignment
343:54 - it says run the program you'll see that
343:57 - it Deadlocks and never exits so a
343:59 - deadlock is basically when all of the go
344:01 - routines in a program are blocking and
344:04 - there's nothing for them to do it means
344:05 - there's a bug in the code so let's run
344:07 - the code just to see what that feels
344:09 - like although
344:11 - I think it's just going to feel like
344:12 - it's running the code for a long time so
344:14 - I'm going to go ahead and cancel that
344:17 - filter old emails function is trying to
344:19 - send on a channel and there's no other
344:21 - go routing running that can accept the
344:22 - value from the channel okay so let's
344:24 - take a look filter all the emails take
344:26 - some emails as an input create an is old
344:30 - Channel and that looks like it Loops
344:31 - over the emails and if they are before a
344:34 - certain date it's going to pass the
344:36 - Boolean true into the channel otherwise
344:37 - it's going to pass in false and then
344:39 - once that Loop exits
344:42 - it's going to read out
344:44 - of the channel here and print to the
344:47 - console you know whether or not the
344:49 - emails were old okay cool
344:53 - so this makes sense this makes sense why
344:55 - this is blocking right this first send
344:57 - either here or here whichever one
344:59 - happens first is going to block because
345:02 - the reader
345:04 - like that code hasn't happened yet this
345:06 - is the same this is the same go routine
345:08 - right this is not happening at the same
345:11 - time as this is happening so we'll use
345:13 - the go routine to fix it fix the
345:14 - deadlock by spawning an anonymous go
345:16 - routine to write to the is old Channel
345:18 - instead of using the same routine that's
345:20 - reading from it okay cool so we need to
345:22 - run this Loop essentially in a new go
345:24 - routine so we'll do go bunk
345:28 - and we'll just use an anonymous function
345:30 - here because we don't really care about
345:32 - naming it
345:34 - and we'll just run that entire block of
345:36 - code
345:37 - in a new and auto suction so now this
345:39 - and this will happen at the same time
345:42 - let's go ahead and run that
345:48 - cool and this looks like what I would
345:50 - expect I'll go ahead and submit that so
345:52 - there's this concept of a token when
345:55 - we're talking about concurrent programs
345:57 - a token is basically a unary value right
346:01 - so not binary there's not two possible
346:03 - values true and false unary there's just
346:05 - one possible value and when there's just
346:07 - one possible value we really don't care
346:10 - much about that value it's not
346:12 - interesting in any way right so it's not
346:14 - that we care what is passed when we're
346:16 - working with tokens it's that we care
346:18 - when and if something is passed through
346:21 - a Channel at all so for example this
346:24 - code here is reading a value out of this
346:27 - Channel and it's just discarding
346:30 - whatever it reads out it doesn't even
346:31 - care what it is it's just waiting to see
346:34 - kind of when something comes through the
346:38 - channel so let's move on to the
346:39 - assignment and kind of put that into
346:41 - practice it says our malio server isn't
346:43 - able to boot up until it receives the
346:45 - signal that all of its databases are
346:47 - online and it learn about them being
346:49 - online by waiting for tokens which are
346:51 - just empty structs on a channel complete
346:54 - the weight for DBS function it should
346:56 - block until it receives num DBS so this
346:59 - integer here tokens on the DB Chan
347:03 - channel right so this is a channel of
347:05 - empty structs and again empty structs
347:08 - are tokens they're unary values they're
347:10 - not interesting they don't have any
347:11 - fields
347:12 - each time it reads a token the get
347:14 - databases Channel go routine will print
347:16 - a message to the console for you okay so
347:18 - I'm guessing that's down here yeah it
347:20 - looks like it's gonna watch
347:22 - um and and print here
347:24 - okay
347:25 - so let's get started and write some code
347:29 - it should block until it receives
347:30 - numdb's token so it's a variable amount
347:33 - of tokens so I guess the easiest way to
347:35 - do this would be for with a loop so 4 I
347:38 - clone equals zero
347:40 - I is less than num DBS
347:45 - I plus plus
347:47 - and then in here we're just going to
347:49 - wait for a token to come across the DB
347:52 - channel right so it'll block once and
347:54 - then we'll move on to the next iteration
347:55 - of the loop block again move on until
347:58 - we've waited for you know numdbs tokens
348:03 - um and then block until it receives the
348:04 - tokens each time reads a token
348:06 - that's it looks like we don't have to
348:08 - return anything so let's run that
348:14 - database one is online two is online
348:16 - this looks good to me so now let's talk
348:19 - about buffered channels so the channels
348:21 - we've been using up until this point
348:22 - haven't really stored anything in them
348:24 - right we needed a sender and a receiver
348:27 - at the same time as soon as the sender
348:29 - sends the receiver receives there's
348:31 - nothing kind of stored in the channel at
348:33 - any given time but that is exactly what
348:36 - a buffered channel is so we have a
348:39 - buffer of some length let's say five
348:41 - different items and senders can actually
348:43 - send into the channel even when there's
348:46 - no receivers until the buffer fills up
348:49 - so a sender could send five things into
348:52 - the channel and then the buffer is full
348:54 - the channel is full right and when a
348:56 - receiver finally goes to read and pop
348:59 - items off of the other end it will read
349:01 - and pop them off in order one by one
349:04 - until the channel is empty
349:06 - so this is the syntax we'd use if we
349:08 - want to make a Channel of integers with
349:10 - a buffer size of 100. we just use that
349:13 - optional second parameter to the
349:16 - built-in make function so let's move on
349:18 - to the assignment it says we want to be
349:19 - able to send emails in batches a writing
349:22 - go routine will take an entire batch of
349:24 - email messages to a buffer channel uh
349:26 - we'll write an entire batch of email
349:28 - messages to a buffer Channel and later
349:30 - once the channel is full a reading go
349:32 - routine will go read all of those
349:34 - messages so we can actually go find
349:35 - where that's happening here in the test
349:37 - Suite
349:40 - okay here so send emails
349:43 - um oh nope this is where they're getting
349:44 - read I'm sorry ah I'm silly the function
349:48 - that we'll be working on is what's
349:50 - writing into the channel so emails to
349:53 - send is the channel we're supposed to
349:55 - write an entire batch of emails into the
349:57 - channel and theoretically sometime in
349:59 - the future
350:01 - those emails will be read out of the
350:04 - channel and actually sent off okay
350:08 - cool so what happens if I run the code
350:10 - in its current state
350:13 - kind of imagining that it's going to
350:15 - block forever
350:18 - yeah that's never going to exit so add
350:21 - emails to queue is getting called here
350:24 - and send emails is getting called here
350:26 - and notice that they're getting called
350:29 - on the same they're both running in the
350:31 - same go routine
350:32 - Right add emails to queue is there's no
350:35 - go keyword anywhere that I see so that's
350:37 - why we are blocking here
350:39 - there's no reader on the other end
350:41 - right but because we want to do this
350:44 - batching we actually should be able to
350:47 - do it all on the same thread
350:49 - we just need a big enough batch size so
350:51 - we need a buffer
350:53 - if we buffer this emails to send Channel
350:56 - with the length
350:58 - of the emails slice
351:01 - then we should have enough room to push
351:03 - all of the emails into the buffer
351:04 - Channel let's go ahead and try that
351:09 - cool that looks like it is working
351:12 - channels and go can actually be closed
351:15 - and there's really only one reason you'd
351:17 - want to close a go Channel and it's to
351:19 - indicate that you're done with it
351:21 - a channel should always be closed from
351:24 - the sending side so the sending go
351:26 - routine the one that's pushing values
351:27 - into the channel will be the one to
351:29 - close the channel and that will indicate
351:31 - to any readers of the channel That this
351:33 - channel is closed there's nothing else
351:34 - to read from it and the actual syntax is
351:38 - really simple it's just the built-in
351:40 - close function where we pass in the
351:42 - channel itself now on the reading side
351:44 - we can actually check if a channel is
351:47 - closed using this kind of optional
351:50 - second variable that comes back when
351:52 - reading a channel this OK variable it's
351:54 - a Boolean if the Boolean is true the
351:57 - channel is open if it is false the
351:59 - channel is closed if the channel happens
352:01 - to be buffered then OK will remain true
352:05 - until the channel is emptied out so OK
352:08 - will only be false once the buffer
352:10 - channel is empty and closed the last
352:14 - thing I'll mention before we jump into
352:15 - the assignment is that you never want to
352:17 - send a value across a closed Channel if
352:20 - you do that go routine will panic and
352:23 - that's why it's really important that
352:24 - you only ever close a channel from the
352:27 - sending side because that go routine is
352:29 - going to be the one that knows when it's
352:31 - done sending values okay on to the
352:34 - assignment it says Emilio we're all
352:36 - about tracking what our systems are up
352:38 - to with great logging and Telemetry the
352:40 - send reports function sends out a batch
352:42 - of reports to our clients and reports
352:44 - back how many were sent across the
352:45 - channel it closes the channel when it's
352:48 - done okay so the send reports function
352:51 - here
352:52 - sends the reports or sends the number of
352:54 - reports across the channel and closes
352:56 - the channel great
352:58 - complete the count reports function it
353:01 - should use an infinite for Loop to read
353:03 - from the channel if the channel is
353:05 - closed break out of the loop otherwise
353:07 - keep a running total of the number of
353:08 - reports sent and return the total number
353:10 - of responses Okay cool so first things
353:14 - first
353:15 - we need to keep track of a total
353:18 - so let's start at zero
353:22 - and we know that at the end of the
353:23 - function we'll be returning
353:25 - the total
353:27 - right
353:28 - and it says use an infinite for Loop to
353:30 - read from the channel okay so four
353:34 - um and then we need to read from the
353:36 - channel so we'll do
353:39 - um
353:39 - numsense
353:42 - and read from the numset channel
353:47 - okay if the channel is closed break out
353:49 - of loop ah right so we need to use that
353:50 - syntax to check if the channel is closed
353:53 - so if not okay if the channel is closed
353:56 - then we'll return
353:58 - total
354:01 - or I suppose we're returning down here
354:02 - so we could just break let's just do
354:04 - that instead
354:05 - break
354:06 - otherwise uh we do total plus equals num
354:10 - sent and it's important to understand
354:12 - that as soon as okay is false num sent
354:15 - will just be a zero value so it's not a
354:17 - valid value that was sent across the
354:18 - channel
354:19 - so it's safe to just just break like
354:21 - that
354:22 - okay cool this is looking correct to me
354:24 - let's go ahead and run that
354:31 - let's see batch of 15 38 and 61 Cent do
354:36 - those add up to 114 uh it looks like
354:38 - they might uh like my terrible in in my
354:42 - head arithmetic says that that's perfect
354:44 - so I'm going to go ahead and submit it
354:46 - the range keyword works with channels as
354:49 - well as slices and Maps so we can
354:52 - actually range over the channel and it
354:54 - will block until a value is ready it
354:57 - will read it into in this case the
354:59 - variable item and then execute the body
355:01 - and it will do that over and over and
355:03 - over for each new value coming across
355:05 - the channel
355:07 - um and we'll only exit the loop once the
355:09 - channel is closed so onto the assignment
355:11 - it says it's that time again malio is
355:13 - hiring and we've been assigned to do the
355:16 - interviews for some reason the Fibonacci
355:18 - sequence is melio's interview problem of
355:20 - choice we've been tasked with building a
355:22 - small toy program that we can use in the
355:23 - interview
355:24 - okay so complete the concurrent
355:27 - Fibonacci function if you're not
355:29 - familiar with the Fibonacci sequence I
355:31 - don't want to go like too crazy far into
355:33 - it but it's basically this sequence of
355:35 - numbers here where
355:37 - each number
355:39 - is the sum of the two proceeding numbers
355:41 - so one and two equal three two and three
355:44 - equal five in fact you probably can't
355:46 - even see that let me Zoom this in a
355:48 - little bit
355:49 - so one and one or one and two equal
355:51 - three two and three equal five three and
355:54 - five equal eight right so this is just
355:56 - this kind of set sequence of numbers
356:00 - okay complete the concurrent FIB
356:02 - function it should create a new channel
356:03 - events so let's go ahead and do that
356:05 - so Channel ins
356:07 - make
356:08 - Channel events
356:10 - great
356:11 - call Fibonacci in a go routine passing
356:14 - to it the channel
356:16 - and the number of Fibonacci numbers to
356:18 - generate okay so we have a Fibonacci
356:20 - function here
356:21 - and it takes the numbers and the channel
356:23 - itself so let's start a go routine
356:27 - in an anonymous function go funk
356:31 - call the function
356:34 - um and in here we call Fibonacci let me
356:37 - just copy and paste that because I can't
356:39 - spell it
356:41 - uh it takes n and
356:45 - this channel of ins as input okay
356:51 - then use a Range Loop to read from the
356:54 - channel and print out the numbers one by
356:55 - one each on the line okay so the
356:57 - Fibonacci function is going to pass its
357:00 - results back over this channel so it's
357:03 - it's taking the channel and it's going
357:06 - to act as the sender on the channel so
357:09 - we down here below kind of where we're
357:12 - spawning that go routine need to act as
357:14 - the reader so for the range Channel
357:19 - events
357:24 - print out the numbers one by one
357:27 - print line V
357:29 - and then when the Fibonacci function is
357:32 - done it will close the channel so we'll
357:34 - exit from the loop
357:36 - cool let's go ahead and run that
357:41 - does this look accurate 10 numbers zero
357:44 - and one zero plus one is one one plus
357:47 - two is three two plus three is five
357:49 - looking good to me on to select
357:52 - statements so a select statement is
357:54 - similar to a switch statement if you're
357:56 - familiar with switch statements from
357:58 - other languages or from go or it's kind
358:00 - of this if else uh chain and we're
358:03 - really looking to kind of match a
358:05 - specific case but what's interesting
358:07 - about select statements is they're
358:08 - unique to channels and they basically
358:11 - let us listen on two different channels
358:14 - and kind of execute one block of code or
358:18 - or rather execute a block of code for
358:21 - the channel that sends a value the
358:24 - soonest so we can kind of simultaneously
358:26 - listen on both channels and if this
358:28 - channel sends a value first then we'll
358:30 - do you know one thing otherwise when
358:33 - this one sends something we'll do
358:34 - another thing so one go routine can kind
358:36 - of process events from multiple channels
358:39 - at the same time using a select
358:41 - statement so this this is the syntax
358:42 - here we create a select block and then
358:45 - multiple cases one for each channel that
358:49 - we are interested in kind of listening
358:51 - for values on or reading values off of
358:54 - so if this channel ins has a value ready
358:57 - then this case will be executed
359:00 - otherwise if this one if Channel strings
359:03 - has a value ready then this case will be
359:06 - executed if both have a value ready at
359:09 - the same time then one will be chosen
359:10 - randomly so you don't want to kind of be
359:13 - dependent on any weird ordering
359:14 - basically as stuff comes across it's
359:17 - going to get processed so on to the
359:19 - assignment says complete the log
359:20 - messages function use an infinite for
359:22 - Loop and a select statement to log the
359:23 - emails and SMS messages as they come
359:25 - across the two channels okay so channel
359:27 - of emails channel of SMS messages add a
359:29 - condition to return from the function
359:31 - when one of the two channels closes
359:32 - whichever is first use the log SMS and
359:35 - log email functions to log the messages
359:37 - Okay cool so uh infinite for Loop start
359:41 - there and inside we'll need to select
359:47 - can use this as our syntax guide over
359:49 - here we've got case uh email
359:53 - okay
359:56 - value from Channel emails
360:01 - if that case fires and we say if not
360:04 - okay so if the channel is closed we just
360:06 - return and this function returns nothing
360:08 - so we can just make it return
360:10 - otherwise we need to log email I think
360:14 - that's
360:15 - it log email there it is
360:18 - the email
360:19 - cool other case uh sms okay from the
360:24 - channel of SMS
360:27 - if not okay
360:30 - return
360:32 - otherwise
360:34 - log the SMS
360:38 - right
360:39 - so this for Loop will just go forever
360:41 - until one of these two channels closes
360:43 - in which case it will return
360:45 - right and it's important that we return
360:47 - before we do the logging because when a
360:50 - channel closes the OK variable is false
360:54 - and a zero value comes across the
360:57 - channel
360:58 - that wasn't sent into the channel that
361:00 - makes sense like the closure happens
361:02 - after the last value comes out
361:05 - let's go ahead and run that
361:10 - looking good to me we'll submit it
361:13 - the select statement also has a default
361:17 - case you don't always need to use the
361:19 - default case and basically the default
361:21 - case only fires if you're interested in
361:24 - non-blocking so for example this select
361:27 - block here will fire the case uh that
361:32 - kind of pulls this V value out of this
361:34 - channel if there is a value ready to be
361:37 - pulled at the time that we enter the
361:39 - select block if there's not a value
361:41 - ready to be read out of the channel then
361:44 - the default case is fired immediately so
361:47 - it kind of turns the select block into a
361:49 - non-blocking block of code and then
361:51 - there's a few things we're going to need
361:53 - to know for this assignment the first
361:55 - are these uh there's several standard
361:57 - Library functions so time dot tick
362:00 - returns a channel that sends a value on
362:03 - a given interval so we could say pass in
362:05 - a second to time.tick and we would get
362:07 - back a channel that receives a value
362:10 - once per second pretty cool for like
362:13 - rate limiting doing something on a set
362:16 - interval time dot after sends a single
362:20 - value after the specified time has
362:22 - passed so if we've created a new Channel
362:25 - with time.actor and passed in one second
362:27 - then one value would come across after a
362:30 - second had passed and then the channel
362:31 - would be closed
362:33 - um time dot sleep just blocks for the
362:36 - specified amount of time in fact I think
362:37 - we've kind of seen it around um so far
362:39 - in the course
362:41 - and we have read only and write only
362:43 - channels and these are pretty cool from
362:45 - like a type safety standpoint basically
362:47 - we can take a channel and we can pass it
362:49 - into a function but specify that within
362:52 - the function we are just going to read
362:54 - from it so then within the function the
362:57 - compiler will not allow us to write to
362:59 - it so this is a great way to kind of
363:00 - keep a go routine safe in terms of which
363:03 - functions are readers of channels and
363:05 - which functions are writers of channels
363:07 - and we do the same thing with writers by
363:10 - using this syntax here so readers read
363:12 - out of the channel writers right into
363:14 - the channel the assignment says like all
363:16 - good backend Engineers we frequently
363:18 - save backup snapshots of the maleo
363:20 - database complete the save backups
363:22 - function okay it should read values from
363:25 - the snapshot ticker and save after
363:27 - channels simultaneously okay so the
363:29 - ticker and the save after these are
363:31 - channels that are created down here
363:35 - using those standard Library functions
363:37 - that we just talked about
363:39 - okay
363:40 - so we need to use a select statement it
363:44 - looks like read values continuously so
363:46 - I'm going to use a for Loop
363:48 - and a select statement
363:52 - if a value is received from snapshot
363:54 - ticker call take snapshot Okay so
363:58 - case Val okay
364:01 - we want to read out of a snapshot ticker
364:09 - um do we actually do we care about the
364:10 - channel being closed let's see I assume
364:13 - saved after no actually we don't so we
364:15 - just need
364:16 - the value from snapshot ticker
364:19 - oh and we don't even care about what the
364:20 - value is so we can just completely
364:22 - ignore the value
364:24 - um call take snapshot
364:27 - okay
364:30 - if the value is saved after so case
364:35 - save after
364:38 - call Save snapshot
364:42 - and return from the function because
364:43 - we're done okay
364:45 - so again we don't need to return
364:46 - anything from this function it doesn't
364:48 - have any return values if neither
364:50 - channel has a value ready call wait for
364:53 - data okay so default
364:57 - wait for data
365:01 - and then sleep for 500 milliseconds so
365:04 - time.sleep
365:06 - time dot millisecond
365:10 - times 500.
365:13 - okay
365:15 - this is looking good so we've got this
365:16 - infinite for Loop we'll we're looking
365:18 - for values
365:19 - um that are coming across these channels
365:21 - anytime a snapshot should be taken we
365:24 - take it anytime this save after Channel
365:27 - passes us a value we will save the
365:30 - snapshot and exit the function otherwise
365:33 - we'll wait for data whatever that does
365:36 - and sleep for 500 milliseconds in fact
365:38 - I'm curious what does wait for data do
365:40 - okay so all these do
365:41 - um is kind of Print Different messages
365:43 - so let's go ahead and run that
365:50 - Okay cool so nothing to do waiting
365:52 - nothing to do waiting right so every 500
365:54 - milliseconds we're kind of logging out
365:56 - that we're waiting we're waiting for
365:57 - things to to do
365:59 - um taking back backups taking backups
366:01 - and
366:02 - um finally saving the backups at the end
366:04 - cool let's submit this this looks
366:06 - correct to me
366:07 - Dave Cheney is a fantastic author and
366:10 - contributor to the go programming
366:12 - language and the go ecosystem and he has
366:15 - this awesome article that I would
366:16 - definitely recommend checking out it's
366:18 - called Channel axioms I've kind of
366:20 - summarized it here and we're going to
366:22 - talk about a few key points so the first
366:25 - is that Ascend to a nil Channel blocks
366:27 - forever so the zero value for a channel
366:30 - is nil if you don't use the make
366:32 - function to initialize a channel then
366:34 - the Channel's value is just nil and if
366:37 - you try to send on a nil Channel your
366:40 - code's just going to block forever
366:42 - similarly a receive from a nil channel
366:45 - will just block forever now this one's a
366:48 - lot more dangerous trying to send on a
366:51 - closed Channel panics so you need to be
366:54 - really careful and make sure your only
366:55 - closing channels from the go routine or
366:59 - the function that's writing to the
367:00 - channel so that you can be sure you'll
367:02 - never try to write to that closed
367:04 - Channel again and then a receive from a
367:07 - closed Channel Returns the zero value
367:09 - immediately so if you're trying to pull
367:11 - data out of a channel and it's already
367:13 - closed you'll just get the zero value
367:14 - and we've already seen how you can also
367:17 - kind of optionally check for that okay
367:18 - value which will be returned as false so
367:22 - what happens when you read from a Nils
367:24 - channel uh the receiver will block
367:26 - forever and what happens when you send
367:29 - to a closed Channel you'll get a panic
367:32 - and you never really want to panic and
367:34 - go that's almost always indicative of a
367:37 - bug
367:37 - so channels are one tool that we have in
367:40 - go to sort of synchronize State across
367:43 - different go routines right we can send
367:45 - data from one go routine to another
367:47 - safely mutexes are another built-in
367:50 - primitive well rather they're not built
367:52 - into the language but they're built into
367:54 - the standard library and they allow us
367:56 - to also sort of communicate or share
367:59 - data between to go routines mutexes work
368:03 - by locking access to protected resources
368:07 - so that only one go routine can access
368:09 - that resource at a time so the
368:12 - sync.mutex type
368:14 - is exposed by the standard library and
368:16 - basically the way it works is you create
368:18 - a new mutex and then you share it across
368:20 - many different go routines
368:22 - and then you wrap whatever code that
368:26 - that is dangerous or whatever resource
368:28 - that is dangerous
368:29 - um that you never want to go routines
368:31 - the same time kind of getting access to
368:34 - you wrap them in a call to lock and
368:37 - unlock so for example in this function
368:39 - we have this protected function and it
368:42 - calls mutex.lock at the top of the
368:44 - function and then it defers an unlock
368:48 - and what this means is when one go
368:50 - routine calls this protected function if
368:54 - it's the first call to this protected
368:56 - function then this mux.lock will lock
368:58 - the mutex for this go routine and it
369:01 - will be able to move on and kind of
369:02 - complete the rest of the function and
369:04 - then call mutex.unlock every other go
369:08 - routine
369:09 - that calls this function right on this
369:11 - shared mutex will actually block at the
369:14 - mux.lock function call
369:16 - because the mutex is locked by another
369:18 - go routine so mutex stands for Mutual
369:21 - exclusion because it excludes every go
369:24 - routine except one except for the one
369:26 - that holds the lock and once that first
369:28 - one actually unlocks the mutex then one
369:31 - other go routine is able to pick up the
369:33 - lock execute its protected code and move
369:36 - on from there so it's a way to take some
369:38 - dangerous resource and sort of share it
369:41 - across many different go routines safely
369:43 - there are a couple of different reasons
369:45 - why why you would want to protect a
369:47 - resource and only allow a single go
369:49 - routine to kind of work on that resource
369:52 - at a time but one super common one is
369:55 - Maps so maps are not thread safe and go
369:58 - if two different go routines are trying
370:00 - to read from and write to the same map
370:03 - go will actually panic because that has
370:07 - a very high likelihood of causing a race
370:09 - condition and if you're wondering what a
370:11 - race condition is a race condition is
370:13 - kind of what it sounds like it's when
370:15 - two different go routines are
370:16 - effectively racing to get access to a
370:20 - specific resource so imagine a case
370:22 - where we have a count variable and it's
370:24 - set equal to maybe five and you have one
370:26 - go routine that reads that count
370:28 - variable and saves it into say another
370:30 - variable my count right and then maybe
370:32 - doubles it and then saves the doubled
370:35 - value back into account
370:36 - well what if we have another uh thread
370:39 - of execution doing the same thing if
370:41 - they both read count let's say they both
370:43 - read five double
370:46 - five so now they both store 25 and they
370:50 - both go to write 25 back into the
370:52 - variable
370:53 - all you did was double five once where
370:57 - you were probably expecting to have two
370:59 - different threads doubling the variables
371:01 - you you probably were expecting for it
371:03 - to go 5 to 25 and then double again 25
371:06 - squared
371:07 - 6 25 I think um the point is depending
371:10 - on exactly how those operations are
371:13 - threaded into the CPU you'll actually
371:14 - get different Behavior so race
371:17 - conditions are awful to debug and
371:20 - mutexes allow us to lock access to those
371:23 - protected variables so we could wrap
371:24 - that count variable in a mutex to avoid
371:28 - it being accessed at the same time by
371:30 - different go routines
371:32 - so this should make a lot more sense
371:34 - once we write some code the assignment
371:36 - says we send emails across many
371:38 - different go routines at Amelia to keep
371:40 - track of how many we've sent to a given
371:43 - email address we use an in-memory map
371:45 - Okay so we've got this counts map stored
371:48 - within a safe counter struct the map is
371:50 - of string to integer and then we've got
371:52 - a pointer to a mutex that we're sharing
371:55 - across all of these different go
371:57 - routines
371:58 - our safe counter struct is unsafe update
372:01 - the increments and the value methods so
372:04 - they utilize the safe counters mutex to
372:06 - ensure that the map is not accessed by
372:08 - multiple go routines at the same time
372:11 - Okay so we've got the safe counter and
372:14 - it looks like it's going to be kind of
372:16 - copied across different go routines so
372:19 - we create one instance of the safe
372:20 - counter it's getting passed into this
372:23 - test function and then we've got this go
372:25 - routine
372:26 - um it looks like we're spawning go
372:27 - routines in a for Loop and then uh and
372:30 - then using that safe counter right so
372:33 - increment is being called many different
372:34 - times across many different uh threads
372:37 - of execution and that is not safe
372:40 - cool
372:41 - um so let's see what happens if I run
372:43 - the code right now
372:47 - Jill has three emails John has four
372:50 - and if I look down into the tests like
372:52 - that is wildly inaccurate right so it
372:56 - kind of looks like what's happening is
372:58 - is like the example I described where
373:00 - maybe you're multiplying numbers
373:02 - together at the same time so you kind of
373:05 - end up with a smaller number because
373:06 - everyone's doing it at the same time
373:07 - then saving the variable back it kind of
373:09 - looks like that's what's happening we're
373:11 - getting these tiny results because all
373:13 - of these different go routines are
373:14 - incrementing uh the number at the same
373:16 - time
373:18 - okay
373:19 - so we need to lock this down
373:23 - foreign
373:31 - the mutex and then defer the unlock
373:36 - it's important to understand that we
373:38 - could do this and it would be the same
373:42 - um right we lock we do the dangerous
373:44 - thing and then we unlock
373:46 - um but this is the preferred
373:50 - the preferred way kind of the idiomatic
373:51 - go way to do it
373:53 - um it's just it's just a little safer
373:54 - right if we add multiple Returns the
373:57 - defer will never not execute so that's
374:00 - how we're going to do it and then we
374:01 - also need to lock on the Val function
374:05 - because reading and writing at the same
374:07 - time is also dangerous
374:09 - cool let's run that see if we get some
374:12 - bigger numbers in our counts
374:15 - notice it's taking a lot longer
374:17 - to run and and that's because we're
374:19 - locking and unlocking so every thread
374:22 - has to kind of go one after the others
374:24 - so it slows it down but it's a lot safer
374:28 - so we get these accurate counts let's go
374:31 - ahead and submit that
374:33 - so as we discussed a mutex is called a
374:36 - mutex because it's short for Mutual
374:38 - exclusion and the conventional name for
374:41 - a mutex is mutex or sometimes it's
374:45 - abbreviated to mux personally I use mux
374:47 - a lot
374:49 - so to answer the question what does it
374:51 - refer to it's going to be mutual
374:52 - exclusion the next question is how many
374:54 - threads or go routines can lock a mutex
374:57 - at once or at the same time the answer
375:00 - is one right if any more could lock it
375:04 - at the same time it wouldn't be very
375:06 - useful
375:07 - the next question is why would you use a
375:09 - mutex to safely access a data structure
375:12 - concurrently to stop other packages from
375:14 - using my code to protect data from
375:16 - network access or to encapsulate private
375:18 - data members of a struct it's going to
375:20 - be to safely Access Data concurrently
375:24 - time to talk about another type of mutex
375:27 - so we've already covered pretty much all
375:29 - of the functionality you need to know
375:31 - about the sync.mutex type but there's
375:33 - another type there's a sync.rw mutex or
375:37 - sync.read write mutex so the sync dot
375:41 - read write mutex has a little more
375:43 - functionality it has the same lock and
375:46 - unlock methods and works exactly the
375:48 - same way as a normal mutex but
375:50 - additionally it has two more methods r
375:53 - lock and R unlock so the reason you
375:55 - would use a read write mutex is because
375:58 - it allows you to have multiple readers
376:00 - at the same time for example it's
376:03 - actually safe to read from a map on
376:06 - multiple go routines at the same time as
376:08 - long as you're not reading and writing
376:10 - at the same time or writing and writing
376:12 - at the same time writing is the
376:14 - dangerous operation so the way this
376:16 - works is if the mutex is locked like
376:20 - with the Dot Lock method then no other
376:23 - go routines can lock or r lock the mutex
376:28 - however if the mutex is just are locked
376:31 - then other mutexes can still are locket
376:36 - so you can get multiple readers but you
376:38 - can't get readers and writers or writers
376:41 - and writers it just allows many threads
376:43 - to concurrently read so what this does
376:46 - is if you have a program with a shared
376:48 - resource where most of the threads are
376:51 - interested with reading the shared
376:52 - resource and you only have a few writers
376:54 - you can make your code a lot faster by
376:57 - using a read write mutex and allowing
376:59 - multiple readers at the same time your
377:01 - code will move faster and have fewer
377:03 - locks slowing down and synchronizing
377:06 - your application so onto the assignment
377:08 - it says let's update our same code from
377:10 - the last assignment but this time we can
377:12 - speed it up by allowing readers to be
377:14 - read from the map concurrently update
377:16 - the vowel method to only lock the mutex
377:18 - for reading notice that if you run the
377:20 - code with a right lock it will block
377:21 - forever Okay cool so if I try to run it
377:24 - right now it's going to have issues
377:26 - because I believe believe it is are
377:29 - locked
377:30 - by the test Suite out of the gate so
377:33 - that's a problem we can fix it
377:37 - by changing those to our lock and R
377:41 - unlock
377:47 - perfect looks good to me I'm gonna go
377:49 - ahead and submit that
377:52 - so a quick review on read write mutexes
377:54 - how many writers can access an RW mutex
377:57 - at once or at the same time uh the
378:00 - answer is one and how many readers can
378:03 - access nrwmutex at once it's going to be
378:06 - infinite there is no limit
378:07 - the next question is can readers and
378:09 - writers use RW mutexes at the same time
378:12 - the answer is still no right no one can
378:16 - use the mutex if it's being written to
378:18 - generics are an amazing new feature in
378:21 - the go programming language at least
378:23 - they are new as of the time of this
378:25 - recording we're on version 1.20 now and
378:28 - generics were just released in 1.18 and
378:31 - they were one of the most widely
378:32 - requested features by go developers so
378:36 - let's talk about what generics are and
378:37 - why they're so useful
378:39 - let's take a look at this code here we
378:42 - have a function called split int slice
378:44 - so it takes a slice of ins and it splits
378:47 - it into two smaller slices of integers
378:50 - it effectively just splits the slice in
378:52 - half and returns to new slices the
378:56 - really interesting thing about this
378:57 - function is that if you take a look at
378:59 - the function body
379:00 - it doesn't actually care that this is a
379:03 - slice of ins it could be a slice of
379:05 - strings or a slice of booleans the logic
379:07 - and the function body would be the same
379:08 - right it would calculate kind of the
379:10 - midpoint of the slice and return two new
379:12 - slices with all the values up to that
379:15 - midpoint the annoying thing is that
379:18 - prior to generics in version 1.18 if we
379:21 - wanted to split a slice of strings we
379:23 - would actually need to write an entirely
379:25 - separate function because in go we have
379:28 - static typing and we need to tell the
379:30 - compiler what type of slice it is that
379:33 - we are splitting now it is true that
379:36 - prior to generics you could write a
379:39 - function that takes a slice of the empty
379:41 - interface which is essentially a slice
379:43 - of anything and then returns to slices
379:46 - of the empty interface the problem with
379:48 - that is that you need to cast the return
379:50 - values back into whatever they were
379:52 - which is kind of a dangerous runtime
379:55 - check
379:56 - so generics or type parameters are
379:59 - really just a way for us to write that
380:01 - function with the empty interface but do
380:03 - it in a compiler safe way because if you
380:06 - think about it the compiler can know
380:07 - that this function doesn't care about
380:11 - the types going in but that any time
380:14 - it's called the types coming out will be
380:17 - the same as the types coming in so how
380:19 - does it work well we effectively have a
380:22 - new type of parameter that can be passed
380:24 - into a function so after the function's
380:26 - name we have these optional square
380:28 - brackets and here we're defining a new
380:31 - type we're calling it t and we're saying
380:34 - it is of type any or it can be anything
380:37 - now because we are using T the type
380:41 - parameter as both the input and the
380:44 - output we're telling the go compiler hey
380:46 - whatever I pass into this function
380:48 - that's what I'm expecting to get back
380:51 - out right if I pass in a slice of
380:52 - integers I expect to get out two slices
380:55 - of integer so now if we take a look at
380:58 - how the code is actually used right how
381:01 - the function is called we can use the
381:03 - split any slice function give it a slice
381:06 - of integers and we'll get back to slices
381:09 - of integers everything is type safe
381:11 - so in a nutshell the reason to use
381:14 - generics is to dry up our coat right dry
381:17 - is just an acronym for don't repeat
381:19 - yourself it's a way of writing code that
381:21 - can be reused more easily so instead of
381:24 - having to write two nearly identical
381:26 - functions just to deal with two separate
381:28 - types of slices we can now write a type
381:31 - safe function once and reuse it
381:33 - throughout our application so let's Jump
381:35 - Right In the assignment says at malio we
381:38 - often store all of the emails of a given
381:40 - email campaign in memory as a slice we
381:42 - store payments for a single user in the
381:44 - same way so those are two very different
381:45 - things right emails and payments
381:47 - complete the get last function it should
381:50 - be a generic function that Returns the
381:52 - last element from a slice no matter the
381:54 - types stored in the slice if the slice
381:55 - is empty it returns a zero value of the
381:57 - type okay cool let's get started okay so
381:59 - we can kind of use this syntax as a
382:01 - guide so we're going to need to specify
382:04 - a type it can be anything like the
382:07 - assignment said and we're going to take
382:09 - his input a slice of that type and
382:11 - return one element of that type
382:15 - okay now it says we need to return the
382:18 - last element from a slice so we need to
382:21 - slice the slice essentially check its
382:23 - length right so we can say if the length
382:26 - of s
382:28 - is zero so if there's nothing in the
382:30 - slice we're going to have to just return
382:33 - uh the empty type of tea
382:36 - which
382:37 - down here it says we can create uh we
382:40 - can create a new empty variable like
382:42 - this so we'll just do
382:44 - r
382:46 - zero Val
382:48 - and then we'll just return it
382:51 - Okay cool so if the slice is empty we'll
382:52 - return the zero value otherwise
382:56 - we'll return
382:58 - s at
383:01 - the length of s minus 1. right okay so
383:05 - there's nothing in the slice we'll
383:07 - return the zero value otherwise we'll
383:09 - return the element in the last index and
383:11 - the reason we have to do this guard
383:13 - Clause is because otherwise this would
383:14 - be an unsafe operation we'd get an index
383:16 - out of bounds error if we tried to do
383:19 - this operation on a slice of zero length
383:22 - so let's go ahead and run it
383:26 - and it looks like
383:29 - okay so the test case with a zero length
383:31 - slice returns an empty struct that looks
383:34 - correct to me getting last email from a
383:36 - slice of like three
383:37 - there's the last one looks like it
383:40 - returned it correctly and then here we
383:42 - have payments right so a completely
383:43 - different type and the last one is Jane
383:45 - example.com yep that looks correct to me
383:48 - Margo Margo cool let's submit it so why
383:52 - are there generics in the go programming
383:53 - language well there's kind of three main
383:55 - points that are important to understand
383:56 - the first as we already covered is that
383:58 - generics reduce repetitive code so
384:01 - whenever we have code that doesn't
384:02 - really care about the type or maybe it
384:04 - only cares about a small superficial
384:06 - part of the type then we can write more
384:08 - abstract and more reusable code if we
384:11 - have access to generics right because it
384:13 - keeps the code compile time safe and
384:15 - type safe before in go if we wanted to
384:17 - reuse code we had to do sort of
384:19 - dangerous runtime checking right casting
384:22 - things to empty interfaces and back from
384:24 - empty interfaces
384:26 - it's also important to understand that
384:28 - generics are going to be used much more
384:30 - frequently in libraries and packages if
384:33 - you're say a back-end developer and
384:35 - you're building applications and not
384:38 - libraries or packages that are intended
384:39 - to be used by other people
384:41 - um You probably don't need to use
384:43 - generics all that often which is why the
384:45 - go programming language was able to get
384:47 - away with not even supporting them for
384:49 - so long now if you do work on libraries
384:52 - or packages or maybe you're even a
384:54 - contributor to the go standard library
384:56 - then you probably are going to use
384:58 - generics quite a bit more they'll make
385:00 - it a lot easier to write more abstract
385:02 - code that's useful for more and more use
385:05 - cases the last Point that's important to
385:07 - understand is just Why did it take so
385:09 - long to get generics into the language
385:11 - right they're super useful why didn't we
385:14 - add them I don't know five years ago or
385:16 - a decade ago and go was kind of getting
385:19 - started the answer is that one of the
385:21 - philosophies behind the go programming
385:23 - language is just to kind of keep it
385:25 - simple go doesn't have all that many
385:28 - features because go developers and go
385:30 - maintainers don't buy into the idea that
385:33 - more features necessarily makes a better
385:35 - programming language by having fewer
385:37 - features it means there's less to learn
385:39 - to get up and running with the language
385:41 - it also means that anytime you see a
385:43 - piece of go code you'll have an easier
385:45 - time understanding it and working with
385:46 - it so even more so than other languages
385:49 - the go team is very hesitant to add new
385:51 - stuff so generics were in the works for
385:54 - a long time and it was only after many
385:57 - years of thinking about it and making
385:58 - sure that we really needed them that
386:00 - they actually got their way into the
386:02 - language so the question here is what
386:04 - code would generics be most likely to
386:06 - help with a binary tree detecting
386:09 - whether or not a string contains a given
386:11 - substring or calculating the area of a
386:13 - circle
386:14 - well
386:16 - detecting whether or not a string
386:17 - contains a substring we'll probably just
386:18 - use string types and calculating the
386:20 - area of a circle just sounds like floats
386:22 - to me but a binary tree is a data
386:25 - structure that can store any type it's
386:27 - kind of like you know a slice in that
386:28 - way so I'm going to go with binary tree
386:30 - on that one the next question is Ghost
386:33 - approach to language design is to
386:35 - support as many useful features as
386:37 - possible to resist adding new features
386:39 - until they're extremely important or
386:41 - proven extremely important or to never
386:43 - add new features the language doesn't
386:44 - change and the answer is to just resist
386:47 - adding new features unless they're
386:48 - proven to be very very important the
386:51 - next question is generics will probably
386:53 - be used more heavily in blank main
386:55 - packages which are executable
386:57 - applications or Library packages and I
387:00 - definitely argue that they'll be more
387:01 - heavily used in library packages Okay so
387:04 - we've talked about how generics are
387:05 - super useful when the type that is being
387:08 - used in your function doesn't matter
387:09 - right when it can be anything but
387:13 - constraints allow us to write generics
387:16 - that are actually just useful for a
387:18 - subset of types right so maybe this
387:21 - function doesn't care too much about the
387:24 - types that are being used but it does
387:25 - care a little bit so let's take a look
387:28 - at an example this concat function
387:31 - is similar to the other generics that
387:33 - we've worked with the big difference is
387:35 - that the type T the type parameter
387:37 - instead of being able to be anything
387:39 - we're saying it has to be a Stringer
387:42 - right we've specified the Stringer
387:43 - interface here it's just anything with a
387:45 - string method on it that returns a
387:47 - string with the built-in any constraint
387:50 - which is effectively the empty interface
387:52 - we can't really do anything with the
387:55 - values inside the functions right which
387:57 - is why it works for something where
387:58 - we're just say splitting a slice of that
388:00 - type
388:01 - but in this function the concat function
388:03 - we're actually able to use the type a
388:07 - little bit we're able to call the method
388:10 - that's implemented on it and that's just
388:13 - because the only thing that we know
388:14 - about these values coming into the
388:16 - function is that they have that string
388:18 - method so what does the concat function
388:20 - do well it takes a slice of stringers
388:24 - it Loops over all of them
388:27 - grabs the string representation right by
388:30 - calling that string method the string
388:32 - representation of each value and it kind
388:33 - of just mashes them all together right
388:35 - it concatenates them and Returns the
388:38 - result so let's take a look at the
388:40 - assignment
388:41 - we have different kinds of line items
388:43 - that we can charge our customers credit
388:44 - cards for line items can be things like
388:46 - subscriptions one Pi or one-time
388:48 - payments great complete the charge for
388:51 - line item function first it should check
388:53 - if the user has a balance with enough
388:54 - funds to be able to pay for the cost of
388:56 - a new item okay so we're given a new
388:59 - item which is of type T doing a slice of
389:02 - old items and a balance which is just a
389:04 - float
389:06 - um if they don't have enough funds then
389:08 - we'll return an insufficient funds error
389:10 - but if they do have enough funds then
389:12 - we'll add the line item to the user's
389:14 - history by appending new item to the
389:16 - sliceables old items okay this new slice
389:19 - is your first return value right so
389:20 - we're returning three values here so
389:22 - we're returning kind of the new list of
389:25 - old items after new item has been
389:27 - appended
389:29 - um and we need to calculate the user's
389:31 - New Balance by subtracting the cost of
389:33 - the new item from their balance this is
389:34 - my second return value Okay cool so we
389:36 - take in their balance we're going to
389:38 - subtract the cost of the new item and
389:40 - then return the New Balance
389:42 - um and obviously if nothing went wrong
389:44 - we'll return a nil error okay
389:46 - so we have the type
389:49 - here as a line item so line item is this
389:52 - interface and it looks like we we kind
389:54 - of have these two methods available to
389:56 - us within our function we can get the
389:58 - cost of a line item or we can get the
390:00 - name of a line item so the first thing
390:03 - our function is supposed to do is check
390:04 - if the user has a balance with enough
390:06 - funds so we need to do something like
390:09 - uh new New Balance
390:13 - is equal to
390:16 - balance
390:18 - minus
390:20 - the new item
390:22 - dot get cost
390:24 - right so we're going to check what the
390:25 - New Balance would be after subtracting
390:28 - the cost of the item from the user's
390:30 - balance then we can say if the new
390:32 - balance
390:35 - is less than zero
390:38 - then we'll return this insufficient
390:40 - funds error
390:42 - right and zero values for everything
390:43 - else so it'll be a nil slice 0.0 float
390:48 - and
390:49 - errors dot new insufficient funds
390:54 - we'll need the errors package
390:56 - okay cool otherwise that means this uh
390:59 - this balance is uh zero or greater right
391:04 - and it says
391:06 - add the line item to the user's history
391:07 - by appending it to the sliceable items
391:09 - so we could do old items equals append
391:13 - old items new item
391:18 - okay
391:19 - this new slice is your first return
391:21 - value great
391:23 - otherwise and then calculate the user's
391:26 - New Balance by subtracting the cost of
391:27 - the new item from the balance so we
391:29 - already did that um this is your second
391:31 - return value so I think we just return
391:35 - um old items New Balance
391:39 - and
391:41 - nil
391:42 - right
391:44 - let's go ahead and run that
391:48 - okay charging customer for a yearly
391:50 - subscription current balance is one
391:52 - thousand new balance is 750 total number
391:55 - of line items is now one
391:57 - sorry for monthly subscription
392:00 - new balance is less total number of line
392:02 - items is now three let's go take a look
392:04 - at those test cases just to make sure
392:07 - that this makes sense
392:11 - okay so they had zero now they have one
392:13 - subscription
392:15 - here they had two subscriptions now they
392:17 - have three subscriptions cool that looks
392:21 - or three line items that looks good to
392:22 - me I'm gonna go ahead and submit it when
392:24 - generics were released a new syntax for
392:26 - writing interfaces was also released
392:29 - um partly just because this new syntax
392:31 - is super useful if you're trying to use
392:33 - interfaces as constraints for your
392:35 - generic functions so let's take a look
392:37 - at an example a type list is pretty much
392:40 - as simple as it sounds we're basically
392:41 - just creating a new interface in this
392:43 - case we're calling it ordered and then
392:45 - we're just listing all of the types that
392:47 - we are saying Implement that interface
392:50 - so there's no methods here but the
392:53 - interesting thing about all of these
392:54 - types is that they all support these
392:57 - inequality operators like less than less
392:59 - than or equal to greater than and so if
393:01 - we use ordered as a constraint then
393:04 - we're free to use these comparison
393:07 - operators on that type and the question
393:10 - that goes along with this is why might
393:12 - you create an interface using a type
393:14 - list and and the answers are you know
393:16 - exactly which types satisfy your
393:18 - interface or it's too much trouble to
393:20 - define the methods required by your
393:21 - interface that second one is a bad
393:23 - reason uh it's it you would really only
393:25 - do this if you know exactly which types
393:27 - satisfy your interface let's take a look
393:29 - at parametric constraints which sounds
393:31 - like a kind of complex term but it's
393:34 - actually really simple it basically just
393:35 - means that we can use type parameters in
393:39 - interface definitions as well so instead
393:42 - of just creating interfaces which we
393:43 - then use in our type parameters for
393:46 - functions we're actually using type
393:49 - parameters to Define new interfaces so
393:52 - for example here we have a store
393:56 - that takes as a type parameter P which
393:59 - is a product now a product is just an
394:02 - interface right it's a product is
394:04 - anything that can return a price and a
394:07 - name so a store which is again an
394:10 - interface is just anything that can sell
394:13 - a product now the idea really is that
394:16 - simple if you want to get an idea for
394:18 - kind of how this whole snippet of code
394:20 - works the example code I'm not going to
394:23 - talk through every line that would take
394:24 - a little bit too long but feel free to
394:26 - kind of browse through this and get a
394:27 - feel for how that interface Works we're
394:30 - going to jump straight into the
394:31 - assignment so getting onto the
394:33 - assignment does the Chief Architect at
394:35 - malio has decided she wants us to
394:36 - implement billing with generics
394:38 - specifically she wants us to create a
394:39 - new biller interface a biller is an
394:41 - interface that can be used to charge a
394:43 - customer and it can also report its name
394:45 - okay so let's take a look at what a
394:46 - customer is
394:48 - so a customer is this interface it's
394:50 - just anything that has a get billing
394:52 - email method on it
394:54 - so in this case a user is a customer and
394:57 - an org is a customer okay
395:02 - um
395:03 - and it can also report its name okay
395:05 - that's simple enough
395:08 - um there are two kinds of billers user
395:09 - billers and org Builders Okay so we've
395:11 - got user Builder here
395:13 - and org Builder here
395:16 - create the new biller interface just
395:18 - have two methods okay so let's go ahead
395:19 - and do that
395:20 - type
395:22 - filler
395:24 - interface
395:25 - two methods charge
395:28 - and name
395:30 - the good news is the architect already
395:31 - wrote the user biller and orgular types
395:33 - for us to fulfill this new Builder
395:35 - interface right we took a look at that
395:39 - use the definitions of the types and
395:40 - their methods to figure out how to write
395:42 - the biller interface on line seven Okay
395:43 - cool so let's start with name it looks
395:47 - simpler so a user biller has a name
395:49 - method it takes no parameters and
395:50 - returns a string same with the org
395:52 - Builder so that one's simple
395:54 - it just returns a string
395:57 - okay the charge method for user biller
395:59 - accepts a user returns a bill
396:02 - but for the org Builder accepts an org
396:04 - and returns a bill okay so it always
396:06 - returns a bill that part's easy
396:08 - but what it accepts is a little bit
396:11 - different
396:13 - right and if we take a look at
396:16 - the customer interface where did it go
396:19 - customer interface here
396:21 - then we see that we have
396:25 - um
396:27 - we have this common interface that we
396:29 - can use to represent both a user
396:32 - and an org
396:34 - okay so that's convenient because we can
396:36 - use that interface right as a parametric
396:37 - uh constraint so
396:41 - let's create a new uh
396:44 - parametric type or you know but we'll
396:48 - create a new type parameter
396:52 - call it C because it's a customer
396:55 - should be easy enough and then charge
396:57 - will actually take as input C
397:02 - right it will take a customer rather
397:04 - than specifically a user or an org
397:08 - okay let's try that
397:12 - it compiled at least let's see what we
397:14 - got using basic user biller to create a
397:16 - bill for Joe at example.com fifty
397:18 - dollars basic user biller for Samuel
397:21 - Boggs
397:22 - fifty dollars
397:24 - Pro user Biller
397:25 - or Jade 100 okay that's looking correct
397:29 - to me it looks like the pro uh Pro and
397:32 - basic uh have a discrepancy of fifteen a
397:34 - hundred dollars and then the org biller
397:36 - is being used here you can see it's
397:38 - actually much more expensive so that
397:40 - looks correct to me so let's talk about
397:42 - naming generic types we can take a look
397:45 - at this old example or the example from
397:47 - earlier in the course where we had to
397:48 - split any slice right and it has t as a
397:51 - type parameter of Type n e and then we
397:54 - use T kind of L throughout the function
397:56 - signature T is variable name it doesn't
397:59 - we don't have to
398:02 - you can name this whatever we want right
398:03 - we could name it my type
398:06 - whatever the heck we want right slice
398:09 - value it doesn't matter however it turns
398:13 - out that capital t is actually fairly
398:15 - common convention
398:17 - um when there is just a single type
398:19 - parameter for a function
398:21 - so the question here is the name of a
398:23 - type parameter blank
398:25 - can and should be whatever you want can
398:27 - be anything but T is a common convention
398:29 - or must be t uh it turns out it can be
398:33 - anything but T is a fairly common
398:34 - conventional name
398:36 - Rob Pike one of the creators of the go
398:38 - programming language created an awesome
398:40 - set of Proverbs that outlines some more
398:43 - of the philosophies behind the language
398:45 - I'm not going to read them all to you
398:47 - but I am going to cover some of the ones
398:49 - that I think are the most important and
398:51 - if you are interested I'd highly
398:53 - recommend going and watching his talk
398:55 - about the Proverbs if you want to go
398:58 - more in depth on them so let's start at
399:00 - the top don't communicate by sharing
399:02 - memory share memory by communicating so
399:06 - this basically is telling us we should
399:08 - probably try to use channels more often
399:12 - than we use mutexes when we're trying to
399:14 - share memory between go routines
399:16 - which leads right into the third one
399:18 - which is channels orchestrate and
399:21 - mutex's serialize so when we use
399:25 - channels we get kind of this elegant
399:27 - flow of data through our program right
399:30 - one go routine did something another go
399:32 - routine can react to it mutexes are all
399:35 - about just locking access to protected
399:37 - resources if we can use channels to
399:40 - express logic in our program it will
399:42 - tend to work a little bit better another
399:45 - great one is that the empty interface
399:47 - says nothing right every type in go
399:51 - fulfills the empty interface you should
399:53 - really avoid using the empty interface
399:55 - just because it doesn't tell you
399:57 - anything interesting about your types
400:00 - the empty interface is sometimes used by
400:02 - new go developers to kind of get around
400:04 - the type system and that just leads to
400:07 - unsafe code go format style is no one's
400:10 - favorite and yet go format style is
400:12 - everyone's favorite so we'll get into
400:14 - this in just a bit when we jump into the
400:16 - project but the go tool chain comes with
400:18 - its own formatter and pretty much every
400:21 - production piece of go code out there
400:23 - uses the same formatter which is
400:25 - fantastic because it means all go code
400:27 - looks the same while not everyone
400:31 - necessarily agrees on the formatters
400:33 - choice of say tabs versus spaces it's
400:36 - still everyone's favorite because it
400:38 - means we all get something consistent
400:40 - that works reasonably well the next one
400:43 - is one of my favorites it's a little
400:45 - copying is better than a little
400:46 - dependency now if you've ever worked in
400:48 - the JavaScript ecosystem with node
400:50 - modules you'll know exactly what this
400:52 - means node modules is typically a huge
400:54 - folder and a lot of times when you're
400:56 - working on a front-end framework your
400:59 - dependencies are much greater than your
401:01 - actual application code and in go we
401:04 - typically just kind of inverse that way
401:06 - of thinking we want our application code
401:08 - to be the bulk of the code within our
401:11 - project and we tend to use far fewer
401:13 - dependencies as almost a philosophy and
401:16 - this brings us to the one mentioned here
401:19 - in the question which says which is
401:21 - better clear or clever and at least
401:23 - according to Rog pipe clear is better
401:26 - than clever so if you can write your
401:29 - code in a way that is very clear to
401:31 - anyone else reading it or even just to
401:33 - yourself that's better than trying to do
401:35 - a trick that might seem clever but is
401:37 - actually hard for humans to understand
401:39 - remember code is written for humans not
401:42 - for machines
401:44 - the next question is which is better
401:46 - copying a little code or including a
401:49 - small dependency and Rob Pike would
401:51 - argue that it's typically better to copy
401:54 - a little bit of code rather than include
401:56 - a very small dependency in your project
401:58 - the next one I want to point out is that
402:00 - errors are just values right in GO error
402:03 - is just a specific interface and we
402:05 - return it from functions just like we do
402:07 - any other value there's not some special
402:09 - way to handle errors with tries and
402:12 - catches errors are just values and we
402:14 - deal with them just like we would any
402:16 - other value
402:20 - and the last one I want to point out is
402:22 - that documentation is for users this is
402:25 - actually an interesting one I think what
402:27 - he's saying here and I I need to go
402:30 - re-watch the talk to confirm but that
402:33 - documentation is primarily for people
402:34 - who aren't maintaining the code in other
402:37 - words it's best if the code itself is
402:39 - really easy to understand so it doesn't
402:41 - need to be heavily documented so that
402:43 - other maintainers can work on it right
402:46 - documentation in the sense that you know
402:48 - we should be writing external documents
402:50 - that explain how the code work or how to
402:52 - use it should be for the users of our
402:54 - code right in the sense that if we're
402:56 - writing a library we should be writing
402:58 - documentation for the users of the
403:00 - library the developers calling our
403:03 - exported functions right not the
403:05 - maintainers of the library itself so
403:08 - documentation should primarily be
403:10 - written for the users of your code
403:12 - it's time to build a fully fledged
403:15 - backend server in go from scratch on our
403:17 - local machines the purpose of the server
403:20 - will be to aggregate data from RSS feeds
403:22 - if you're not familiar with RSS it's a
403:24 - protocol that makes Distributing things
403:26 - like podcasts and blog posts really easy
403:28 - so what our server will allow users to
403:31 - do is add different RSS feeds to its
403:34 - database and then it will go
403:35 - automatically collect all of the posts
403:38 - from those feeds and download them and
403:40 - save them in the database so that we can
403:42 - then view them later
403:44 - before we get started there are four
403:46 - things you're going to need the first is
403:49 - a basic understanding of SQL the
403:52 - language that's most often used to query
403:54 - relational databases if you're not
403:56 - familiar with SQL yet that's okay I've
403:58 - got a full course on SQL I'll link that
404:01 - down in the description below go watch
404:02 - that then come back here if you're not
404:04 - familiar with SQL number two is you're
404:07 - going to need a text editor and a
404:08 - command line I'm using vs code and zsh
404:11 - here in the video so you'll see me using
404:13 - that feel free to go download those if
404:15 - uh you want to try them out but you can
404:17 - use whatever text editor you want as
404:19 - long as it can edit your files and you
404:21 - have access to a terminal to run
404:23 - commands number three is the go
404:26 - programming language itself if you don't
404:27 - have that you can go download it I will
404:29 - link the download page down in the
404:31 - description below and I'd also recommend
404:33 - just installing the go plug-in if you're
404:36 - in vs code there is an official go
404:38 - plugin Go download that it'll make your
404:40 - life easier with syntax highlighting and
404:41 - formatting and that sort of thing number
404:44 - four the last thing you'll need is an
404:46 - http client so an HTTP client will allow
404:49 - you to make get and post and put
404:52 - requests into the web server that we're
404:54 - building we'll need that for testing I
404:56 - use the Thunder client it's a vs code
404:58 - extension but you can use anything you
405:00 - like even curl on the command line or
405:02 - Postman insomnia there's tons of choices
405:04 - Google HTTP clients or if you don't
405:07 - already have a preference again if
405:09 - you're in vs code I'd recommend the
405:11 - Thunder client extension now that you
405:13 - have all of those tools installed and
405:16 - hopefully working let's jump into the
405:17 - project the first thing we're going to
405:19 - need is just a main.go file we'll create
405:21 - our entry point it will be a part of the
405:24 - main package and it will need a main
405:27 - function so func main takes no arguments
405:30 - return those returns no parameters and
405:33 - for now let's just print hello world
405:34 - make sure we can kind of build and run
405:37 - this program we're going to need to
405:39 - initialize a new module for our project
405:42 - so I'm going to do go mod init
405:45 - and I like to name my modules after
405:47 - their remote path right where they will
405:49 - exist
405:50 - um kind of out on the internet so in my
405:52 - case I use github.com my GitHub uh
405:55 - namespace which is wagslane Slash the
405:58 - name of this repository which again is
406:01 - where I'll be keeping this code on
406:02 - GitHub so I highly recommend you keep
406:04 - track of this code in GitHub this entire
406:07 - project should be checked into git and
406:10 - uploaded to GitHub or gitlab or whatever
406:12 - you prefer so I'm going to name this
406:15 - repository
406:16 - RSS aggregator RSS AG so we'll go ahead
406:20 - and create that
406:22 - that will create this new go module
406:25 - and now that that's ready we should be
406:27 - able to just go build
406:30 - and execute the new
406:33 - um binary or the new executable that
406:35 - will be created from go Belgium I'll
406:36 - just run it once so you can see
406:38 - that created this new binary file here
406:40 - in my current directory and so from now
406:44 - on I'll be running this command go build
406:46 - and Dot slash
406:49 - RSS act so that will build and run
406:52 - and we got hello world back so we're
406:54 - good to go like I said before we're
406:56 - going to be building this project with
406:58 - Git and storing our code in Source
407:00 - control as we go so I'm gonna go ahead
407:02 - and create a new
407:03 - git repository and in vs code it
407:06 - highlights all the code that has changed
407:08 - but not yet been committed to Source
407:10 - control here in green but I don't want
407:12 - all of this in my source control the dot
407:14 - vs code file is configurations for my
407:16 - editor that's a personal thing that
407:18 - doesn't need to be in the project itself
407:19 - same with the RSS AG binary we don't
407:22 - want to commit the binary that we are
407:25 - building or the executable file that
407:26 - we're building we just want to commit
407:28 - our source code so I'm going to create a
407:30 - new DOT get ignore file
407:33 - and we're going to ignore the dot vs
407:35 - code folder and the RSS AG binary
407:41 - and next
407:44 - um we're going to add all of the secrets
407:47 - the like configuration Secrets uh for
407:49 - our project in a DOT EnV file and read
407:53 - them out of the file itself so uh for
407:56 - example one of the configuration
407:57 - variables that we're going to set is the
407:59 - port that the server will run on so I'm
408:02 - going to set that port to 8000.
408:06 - and I'm going to also ignore that dot
408:09 - EnV file in the git ignore
408:11 - again because configuration data is
408:13 - something kind of local to my machine in
408:16 - production this port might be something
408:18 - different so we don't need to commit
408:19 - this file to Source control but I do
408:22 - want it here in my repo now at this
408:25 - point I do want to pause and say if you
408:27 - have no idea what a port is or you have
408:30 - no idea what HTTP requests are or rest
408:33 - apis are
408:34 - um we're going to move fairly quickly in
408:37 - this project so if you're not familiar
408:39 - with that stuff again I will link down
408:40 - in the description below my HTTP course
408:43 - that would be a good one to go brush up
408:45 - on before working on this project
408:47 - so now we need a way to read this port
408:51 - variable into our program so that we can
408:53 - use it and the go standard library has a
408:56 - built-in function called
408:58 - os.getn so it's a an exported function
409:01 - called get end from the OS package and
409:04 - we can get the value of a variable by
409:07 - its key so in this case the key is port
409:10 - and we'll get back a
409:13 - Port string
409:15 - and then for now let's just uh let's
409:18 - just say if Port string equals the empty
409:21 - string
409:22 - then we'll say
409:24 - uh log dot fatal so log dot fatal will
409:28 - exit the program immediately with arrow
409:30 - code 1 and a message and we'll say port
409:35 - is not found in the environment
409:39 - otherwise we'll say
409:43 - port
409:45 - and we'll print the port string
409:48 - okay cool let's go ahead and run that
409:57 - word is not found in the environment
409:58 - okay so the problem here is that Port
410:01 - the environment variable doesn't exist
410:04 - in my current shell session if I wanted
410:06 - to add it I could run in my in my
410:09 - command line export Port equals 8000.
410:13 - and then run this again
410:16 - and then we get Port equals a thousand
410:18 - the problem is I don't want to manually
410:20 - set this environment variable every time
410:23 - I work on my server I want to pull it
410:25 - from this file so we're going to use a
410:28 - package that allows us to grab
410:30 - environment variables from a DOT ENB
410:32 - file and it is this package here
410:36 - github.com joho slash go.env
410:40 - um that's also the URL of the library
410:42 - you can paste that into your browser go
410:44 - check it out but we're just going to
410:46 - install it here locally
410:48 - and that will add it here to our go.mod
410:52 - and then I'm going to run go mod vendor
410:56 - to copy that code here into
411:00 - my my vendor folder we get kind of a
411:04 - local copy of that
411:06 - we'll run
411:08 - um
411:09 - here we're going to need to actually use
411:10 - it so we do go.env.load
411:14 - and by default load loads the dot EnV
411:20 - file I think we can also optionally pass
411:22 - in dot EnV
411:24 - as the file path
411:26 - and what's uh what's my error here could
411:29 - not import no required module provides
411:32 - go that's let's go mod tidy
411:36 - that should clean up my imports okay
411:37 - perfect
411:41 - and
411:43 - do I need to do anything else what are
411:45 - we getting here could not import no
411:47 - required module I should probably go mod
411:48 - vendor again
411:52 - that should pull in the code okay so you
411:54 - can see we've kind of imported and
411:56 - downloaded all of that code from the
411:58 - package
411:59 - and now I'm not getting air any errors
412:01 - in my console okay so this will take the
412:04 - environment variables from my DOT EnV
412:05 - file and pull them into my current
412:07 - environment so then I can use os.getendv
412:11 - to load the variable so to test that
412:13 - let's go ahead and change uh the port to
412:16 - 8080.
412:18 - and rerun the server
412:22 - still says 8 000 so something went wrong
412:24 - maybe I'm misremembering how to use this
412:26 - uh use this package
412:29 - let's try just go dot end without load
412:32 - still port 80.
412:34 - what am I doing wrong
412:37 - does it not overwrite you know what it
412:39 - might not overwrite my current session
412:40 - I'm going to kill my current sell
412:42 - session shell session and create a new
412:45 - one
412:45 - and then we'll do this again so now I
412:48 - won't have that exported 8 000 that I
412:51 - had in my terminal
412:53 - um run that again
412:54 - Okay cool so now it's pulling it from
412:57 - the file because I don't already have it
412:59 - defined in my shell session now I want
413:01 - to take just a second and point out
413:03 - there are text instructions for this
413:05 - entire project over on boot.dev and I'll
413:08 - link that down in the description below
413:09 - we're going to be using a lot of text uh
413:12 - you know code Snippets from those text
413:14 - instructions and they'll be easier to
413:16 - kind of copy and paste and grab from
413:18 - boot.dev directly than trying to you
413:20 - know retype what you're seeing me type
413:22 - here on the screen now we're going to
413:24 - actually spin up our server and we're
413:26 - going to be using the chi router to do
413:28 - it it's a third-party router very
413:30 - lightweight built on top of kind of the
413:32 - same way that the standard library in go
413:34 - does http routers and so let's go ahead
413:37 - and install those now we'll do go get
413:39 - github.com go Dash try chai or chi I
413:44 - always struggle to pronounce that one
413:46 - we'll install that and we'll install
413:48 - this the cores package from the same uh
413:52 - the same name space the G namespace next
413:55 - we'll create a new router so I'll do
413:58 - router colon equals Qi dot new router
414:02 - in fact I should probably go mod vendor
414:08 - have it there and I'll do another go mod
414:10 - tidy and go mod vendor to bring it in
414:15 - cool so this creates a new router object
414:18 - next we'll connect up this router to an
414:21 - http.server so that serve colon equals
414:24 - a pointer to an HTTP dot server
414:28 - and a server needs a Handler
414:31 - which will be the router itself
414:34 - and we also need a or an address which
414:39 - is just a colon plus that Port string so
414:44 - in this case it'll be colon you know
414:46 - 8080. cool and then we can call
414:49 - http.listen and serve
414:53 - or sorry not http.listen server we want
414:55 - to call it on the server object so
414:57 - serve.list.serve
414:59 - cool and before we call that in fact I
415:02 - think that returns an error so let's
415:03 - capture that error
415:05 - say if error is not equal nil
415:08 - log dot fatal
415:10 - s in the air is a message
415:14 - okay listen and serve will block so when
415:17 - we get to line 30
415:19 - our our code basically just stops right
415:21 - here and starts handling HTTP requests
415:24 - if anything goes wrong in the process of
415:27 - handling those requests then an error
415:29 - will be returned and we'll you know log
415:32 - it and exit the program but it kind of
415:34 - the happy path for our code is that you
415:37 - know nothing should ever be returned
415:38 - from listen and serve because our server
415:40 - is just going to run forever before we
415:42 - run this let's just add one more kind of
415:45 - logging statement we'll do log dot print
415:47 - line actually let's do print f
415:50 - and we'll say server starting on Port
415:56 - percent V and we'll pass in that Port
415:59 - string
416:01 - okay cool
416:02 - with that let's go ahead and build and
416:04 - run again so go build
416:09 - see what we get
416:11 - Hello World server starting on Port
416:13 - 8080. I should probably remove I should
416:15 - probably remove that hello world at this
416:17 - point now that we have a running server
416:19 - let's go ahead and test it so I'm over
416:21 - here in the Thunder client tab again
416:23 - because I'm using the thunderclient
416:25 - plugin and I'm going to click new
416:26 - request
416:27 - and we're going to make a request to
416:30 - http colon slash localhost right you
416:34 - want to make a request to our own
416:35 - machine on the port that we're running
416:37 - on which I believe is 8080.
416:39 - okay with that let's go ahead and start
416:42 - up our server
416:48 - okay server starting on port 8080 so it
416:51 - should be good now you'll see I don't
416:53 - have a new prompt because my my server
416:55 - is still running
416:56 - um if I send this get request perfect we
416:59 - get a 404 that's exactly what we'd
417:01 - expect because remember in our code we
417:03 - haven't actually set up any handlers or
417:05 - anything we just have a server running
417:07 - so we're getting a 404 because we're
417:09 - trying to hit a path in this case the
417:11 - root path and it doesn't have anything
417:13 - any logic there to handle that code if
417:16 - we killed our server
417:18 - and ran it again we just get the
417:20 - connection refused I've configured my
417:23 - thunderclient to actually store all of
417:25 - my tests or my HTTP requests as plain
417:29 - text here in the working directory but I
417:32 - don't want those going into my source
417:33 - control so I'm going to go ahead and add
417:34 - that to the git ignore Thunder Dash
417:37 - tests will ignore everything in there
417:40 - next let's add a course configuration to
417:43 - our router so this is so that people can
417:44 - make requests to our server from a
417:46 - browser and we're going to be using some
417:48 - fairly permissive configurations here
417:50 - and we'll use router dot use and then
417:54 - we'll pass in
417:55 - this cores.handler configuration this
417:58 - comes from that course package that we
418:00 - installed earlier
418:01 - and let me see what am I doing here we
418:03 - need one more parenthesis there
418:06 - and then I'm going to go ahead and
418:07 - vendor this as well so go mod tidy
418:11 - go mod vendor
418:15 - cool so we should have all of that code
418:18 - here in our vendor folder as well I'm
418:22 - not going to go too in depth on exactly
418:24 - what cores are you can definitely go
418:26 - look that up but just to give you a high
418:27 - level overview this configuration is
418:30 - essentially telling our server to send a
418:33 - bunch of extra HTTP headers in our
418:36 - responses that will tell browsers hey we
418:39 - allow you to send uh you know requests
418:42 - to http or https versions We allow you
418:46 - to use these methods we allow you to
418:47 - send any headers it's just a way to say
418:50 - hey we're going to allow you to do
418:51 - basically whatever you want there are
418:54 - ways you can tighten up this
418:55 - configuration for security purposes but
418:57 - for now we're just going to be running
418:59 - our project on our local machine so
419:01 - we're going to just open it up make it
419:03 - permissive to avoid any sort of uh kind
419:05 - of weird testing issues if we try to
419:07 - connect to our server through a browser
419:10 - This Server we're building is going to
419:12 - be a Json rest API which means all of
419:15 - the request bodies coming in and
419:16 - response bodies going back will have a
419:19 - Json format so let's create a little
419:22 - helper function that will make it easier
419:24 - to send Json responses so I'm going to
419:26 - create a new file called json.go it's
419:28 - going to be in the main package
419:30 - and the function signature is going to
419:32 - look like this so we've got a function
419:34 - we're calling it respond with Json it
419:35 - takes as input a response writer this is
419:38 - the same HTTP response writer that HTTP
419:41 - handlers in go use it's exposed by the
419:44 - standard Library
419:45 - it will take a code so this is the
419:48 - status code we're going to respond with
419:49 - and it will take an interface which is
419:51 - just something that we can Marshal to a
419:55 - Json structure the first thing the
419:57 - function will do is Marshal the payload
419:59 - into a Json object or a Json string and
420:02 - the way we do that is with the standard
420:04 - Library so we need data and error equals
420:06 - json.martial
420:09 - and we pass in the payload
420:11 - so this function will attempt to
420:13 - Marshall whatever it's given into a Json
420:16 - string and it will return it as bytes
420:19 - and the reason it returns it is bytes is
420:20 - so that we can write it in a binary
420:22 - format directly to the HTTP response
420:24 - which is pretty convenient if that fails
420:27 - for whatever reason
420:29 - then what we'll do
420:31 - is we'll write a header to the response
420:35 - and we'll use status code 500 we'll say
420:36 - something went wrong on our end right
420:38 - internal service error or internal
420:40 - server error
420:42 - and then we'll just return from the
420:43 - function and actually if something goes
420:45 - wrong we should probably log it as well
420:48 - on the server side so that we can see
420:50 - our own logs and see hey we tried to do
420:52 - something in a broke uh so we'll do log
420:54 - dot
420:55 - print line
420:57 - failed to Marshall
421:01 - Json response
421:03 - and let's print the response
421:07 - or let's print what we tried to Marshall
421:09 - that's probably more
421:11 - more interesting we'll use printfs that
421:13 - we can interpolate that value there next
421:15 - we're going to need to add a header to
421:18 - the response to say that we're
421:19 - responding with Json data so we'll do w
421:21 - dot right header
421:25 - and or not right header I'm sorry w dot
421:28 - headers
421:31 - is it header
421:33 - dot add
421:36 - and we want to add the content type key
421:38 - so content type
421:41 - and the key will be applica or the value
421:43 - of the application Json
421:46 - so this adds a response header to the
421:48 - HTTP request saying hey we're responding
421:50 - with a content type of application slash
421:52 - Json which is the standard and a value
421:54 - for Json responses
421:57 - um and then we should be able to write
421:59 - the status code so we do w dot right
422:02 - header 200 so everything went well and
422:06 - then we need to write the data itself so
422:08 - w dot write
422:10 - and pass in the Json data this will
422:13 - write the response body now that we have
422:15 - a way to respond with some Json data
422:17 - let's create an HTTP Handler that does
422:19 - that so we'll do handlers
422:22 - or Handler
422:24 - readiness
422:27 - again this will be in the main package
422:29 - and we're going to create a new function
422:33 - called Handler Readiness and this is a
422:36 - very specific function signature this is
422:38 - the function signature that you have to
422:40 - use if you want to Define an HTTP
422:42 - Handler in the way that the go standard
422:44 - Library expects so it always takes a
422:47 - response writer as the first parameter
422:49 - and a pointer to an HTTP request as the
422:52 - second parameter and then in the body of
422:54 - this Handler we can just call our
422:56 - respond with Json function
422:58 - so we'll say respondus Json
423:01 - we'll pass in that HTTP response writer
423:05 - we want to respond with a 200 status
423:07 - code
423:08 - and some
423:10 - some response payload in this case
423:14 - all we care about is the 200 okay status
423:16 - codes I'm actually just going to respond
423:18 - with an empty struct which should
423:19 - Marshal to kind of an empty Json object
423:22 - and now that I'm writing this I realize
423:24 - that we actually made a mistake or I
423:26 - made a mistake in the Json response Json
423:30 - code we should pass in we should use the
423:33 - passed in Response Code instead of hard
423:35 - coding the 200. so if everything goes
423:37 - right we'll use the code given okay now
423:40 - with that we need to hook up our Handler
423:43 - Now using the chi router what we do is
423:46 - we hook up a an HTTP Handler which is
423:48 - this function to a specific HTTP method
423:51 - and path okay so the way we're going to
423:54 - do that is I'm going to create a new
423:55 - router so V1 router and we'll use that
423:59 - same Qi dot new router to do it and I'm
424:03 - going to specify V1 router dot handle
424:08 - handle Funk excuse me
424:10 - I want to handle the slash ready path
424:14 - and I want to handle it with this
424:17 - Handler Readiness function
424:19 - okay so we're we're connecting the
424:21 - Handler Readiness function to the slash
424:24 - ready path and the reason I created this
424:26 - new V1 router is because I'm going to
424:28 - mount that so I can do router.mount
424:34 - to the slash V1 path
424:37 - okay so I'm nesting a V1 router under
424:41 - the slash V1 path and I'm hooking up the
424:43 - Readiness Handler at the slash ready
424:45 - path so the full path for this request
424:48 - will be slash B1 slash ready and that's
424:51 - just so that if we make breaking changes
424:53 - in the future we can kind of have two
424:55 - different handlers one under version one
424:57 - and one under version two for our rest
424:59 - API this is fairly standard practice and
425:02 - actually I'm going to name this path
425:04 - health
425:05 - Health Z that's just a habit uh that I'm
425:09 - bringing with me from kubernetes Land
425:10 - that's pretty standard to have a slash
425:12 - Health Z path
425:13 - um that you can hit to see if your
425:15 - server is live and running so that's the
425:17 - purpose of this Handler it should just
425:19 - respond if the server is alive and
425:21 - running and everything's good okay so
425:23 - let's go ahead and run the server and
425:25 - make sure it's doing what we'd expect so
425:26 - go build and Dot slash
425:29 - RSS AG that starts up the server
425:31 - and then we can open up thunderclient
425:34 - and now instead of making a request to
425:36 - the root which we'd expect to get a 404
425:39 - from we'll do slash V1 slash Health Z
425:42 - and make that get request and we get the
425:46 - 200.
425:47 - now here's the weird thing if I change
425:49 - this to a post request and I make that
425:52 - I actually still get a 200 but that's
425:55 - not really Our intention the health Z
425:56 - endpoint should really only be
425:58 - accessible by get request so I'm going
426:00 - to make an update here rather than using
426:02 - the v1rander.handlefunk I'm going to use
426:04 - v1router.get and this will scope the
426:07 - Handler to only fire on get requests
426:10 - okay with that let's go ahead and
426:12 - rebuild our server
426:14 - and check again
426:16 - post should fail method not allowed
426:19 - perfect but the get request should still
426:21 - work
426:22 - so we have a nice helper function for
426:24 - responding with arbitrary.json now I
426:26 - want one for responding with arbitrary
426:28 - error messages so let's do function
426:30 - respond with error it will look very
426:33 - similar but instead of taking a payload
426:34 - which is an interface it will take a
426:36 - message string and this function is
426:38 - basically just going to format that
426:40 - message into a consistent Json object
426:43 - every single time
426:46 - okay uh first thing we're going to do is
426:48 - say if the code is greater than 499
426:51 - we're going to log a message and that's
426:52 - because uh error codes in the 400 range
426:56 - are client-side errors so we don't
426:58 - really need to know about them it just
427:00 - means someone's using our API in a weird
427:02 - way but we do need to know whenever
427:03 - we're serving we're responding with a
427:05 - 500 level error code because that means
427:08 - we have a bug on our end and we should
427:09 - probably go fix it
427:11 - so we'll do log dot print line
427:14 - responding with 500 level error
427:18 - and we'll just tack the message itself
427:20 - on there
427:21 - okay cool after we do that logging we'll
427:25 - use the respond with Json function
427:28 - but we'll be responding with a specific
427:31 - structure of Json so let's go ahead and
427:34 - Define that as a struct so type
427:37 - error response
427:40 - is a struct and has one field error this
427:43 - is just a string
427:44 - and we'll add this Json tag to just say
427:47 - this the key that this should Marshal to
427:50 - is error so in go we typically take a
427:54 - struct and add these Json reflect tags
427:57 - to it to specify how we want this
428:00 - json.martial function or on the other
428:03 - side the json.unmarshall function uh to
428:07 - kind of convert this struct into a Json
428:10 - object so in this case we're saying I
428:12 - have an error field it's a string and I
428:15 - want the key for the field to be error
428:17 - so this struct will Marshal into a Json
428:20 - object that looks kind of like uh like
428:23 - this
428:26 - error
428:27 - you know something went
428:30 - wrong
428:32 - right
428:34 - it wouldn't have uh actually wouldn't
428:36 - have that but it would look like that
428:38 - okay and we'll see that in just a second
428:41 - okay so now we get to respond with Json
428:43 - we pass in the response writer a cut the
428:46 - same code that we were given and then
428:48 - we'll just respond with an error
428:50 - response
428:52 - and the error message will be the
428:54 - message that we were given
428:57 - okay let's hook this up to another
428:59 - Handler
429:01 - so here we can do V1
429:03 - router dot get
429:06 - we'll create an error endpoint and oh I
429:10 - need I need an actual Handler
429:12 - so we'll create a new one called Handler
429:21 - Handler error and we'll respond with an
429:25 - error instead of passing in an empty
429:27 - struct we'll say
429:30 - something went wrong
429:33 - and we'll respond with a 400 status code
429:36 - client error right
429:38 - okay now we can hook up this error
429:40 - Handler
429:42 - here
429:43 - it will only work on get requests that
429:46 - seems reasonable and basically it's just
429:48 - going to call that respond with error
429:50 - function so it'll be a good way to test
429:52 - that
429:54 - okay
429:55 - let's go ahead and rebuild the server
429:59 - oh what do we screw up routing pattern
430:02 - must begin with Slash ah
430:05 - let's go fix that
430:08 - so you can see here we've got slash
430:10 - Health Z slash V1 we need to start these
430:13 - with a slash
430:14 - it's just the way the chai route or the
430:16 - QI router works
430:19 - cool
430:21 - um let's go open up the Thunder client
430:22 - and send a request
430:25 - to the slash error Handler
430:28 - cool we get the 400 bad request status
430:31 - code and this is that Json body so every
430:35 - single time that we need to return an
430:37 - error from our server now we can just
430:39 - use this function and it will always use
430:41 - this consistent error format which is
430:43 - great because we can throw this in our
430:45 - documentation and just tell all of the
430:46 - users of our API hey this is what you
430:49 - should expect when something goes wrong
430:51 - now that we have a little bit of our
430:52 - boilerplate set up I'm going to take the
430:54 - opportunity to commit all of this to get
430:56 - uh so that I don't lose it
430:59 - um I will say that I generally recommend
431:02 - committing the vendor folder so you can
431:04 - think of the vendor folder kind of like
431:06 - the node modules folder if you're
431:07 - familiar with JavaScript land and in
431:09 - JavaScript you would never commit it
431:11 - it's way too big but in go we typically
431:14 - don't have all that many dependencies so
431:16 - it's actually perfectly fine to commit
431:18 - the vendor folder in most scenarios and
431:20 - I'd even recommend it so I'm going to go
431:22 - ahead and add that and commit it
431:27 - we'll say boilerplate or HTTP server
431:32 - complete
431:34 - for this project we're going to use
431:36 - postgres as our SQL database it's a
431:38 - production ready database in fact it's
431:40 - the one I used to build boot.dev
431:43 - you're going to need to install postgres
431:45 - on your local machine make sure that the
431:48 - postgres server is up and running and
431:50 - that you have a client installed that
431:52 - you can use to make kind of one-off SQL
431:55 - queries against it I have detailed
431:58 - instructions on how to do all of that in
432:00 - the text instructions for this project
432:01 - over on boot.f so again go check those
432:04 - out if you need to figure out how to
432:06 - install postgres locally and get a
432:08 - postgres client up and running on your
432:10 - machine I use PG admin so that's what
432:12 - you'll see me using in this tutorial
432:15 - so if you followed those instructions
432:17 - then you should have a postgres server
432:19 - running on your local machine and a
432:21 - postgres client installed again I use PG
432:23 - admin that's what you're seeing here on
432:26 - the screen
432:27 - okay so because postgres is running
432:29 - locally I Have This localhost Server
432:32 - here in PG admin that I've connected to
432:35 - again that's the postgres server running
432:37 - on my own machine and under databases I
432:39 - have kind of the built-in postgres
432:41 - database but I want to create a new
432:43 - database that we're going to use for
432:44 - this project so in this case I'm just
432:47 - going to name it RSS AG
432:50 - and we'll create that database
432:53 - and then here within the RSS AG database
432:56 - as long as the uh kind of icons are cold
433:00 - then you're connected and everything is
433:03 - working at least up to this point let's
433:05 - run a quick query against the database
433:07 - just to really make sure everything's
433:09 - working so I'm right clicking here on
433:10 - the RSS AG database and I'm going to
433:13 - click query tool
433:15 - and from this tool I should be able to
433:18 - just write some raw SQL so I'm going to
433:19 - go ahead and do a select
433:21 - version this should just return the
433:24 - current version of postgres that I'm
433:26 - using
433:27 - I'm on version 14.7 and as long as
433:30 - you're on something
433:31 - 14.7 or newer you should be good to go
433:34 - now it's important to keep in mind here
433:36 - that PG admin is just a client for
433:39 - interacting with an SQL database right
433:41 - we're able to write raw SQL code here
433:44 - and run it against our database server
433:46 - if you think about it kind of in an
433:49 - analogous sense PG admin is basically
433:51 - just the same thing as the Thunder
433:52 - client where the Thunder client is a
433:55 - client for running one-off HTTP requests
433:58 - against our server PG admin is a client
434:01 - for running one-off SQL requests or SQL
434:04 - queries against our database directly
434:06 - next we're going to install two command
434:09 - line tools that will allow us to work
434:10 - with SQL databases from our go code much
434:14 - easier now these aren't fully fledged
434:16 - orms if you're familiar with that term
434:18 - these are kind of lightweight libraries
434:20 - that allow us to work with SQL databases
434:22 - using the standard library and just sort
434:24 - of streamline the process for us the
434:26 - first one is called sqlc and again you
434:29 - can find all of these commands in the
434:31 - text instructions over on boot Dev so be
434:33 - sure to be following along over there
434:34 - but we're going to use the go install
434:36 - command to go grab
434:38 - sqlc and install it into our command
434:42 - line once that's done you should be able
434:44 - to just run sqlc version to make sure
434:47 - it's working
434:48 - next we'll install Goose the same way so
434:52 - go install and then the installation
434:54 - path for goose again that link is over
434:58 - in the text instructions and then you
435:00 - can make sure that goose is installed
435:02 - working correctly by typing Goose Dash
435:04 - version the great thing about sqlc and
435:07 - goose is that they work based on Raw SQL
435:10 - there's no kind of fancy query language
435:13 - that's unique to those tools we can just
435:15 - write SQL queries and we're going to
435:16 - store all of that in our repository so
435:18 - I'm going to create a new folder which
435:20 - is called SQL and in there I'll create a
435:23 - new directory called schema and this is
435:25 - where we'll store all of our table
435:27 - definitions or more specifically our
435:30 - migrations so uh we'll start with a
435:33 - users table and the way Goose works is
435:35 - it runs the migrations in order so we're
435:38 - going to start with a 0 0 1 migration
435:41 - and we'll call it users.sql
435:44 - from a very high level the way that
435:46 - database migrations work is they have an
435:49 - up and a down statement so for example
435:52 - here we're creating a users table the up
435:54 - statement will just create a new users
435:56 - table and the down statement will delete
435:58 - that same table so any down statement
436:01 - should just undo the operation of the
436:03 - upstatement and that just makes it easy
436:05 - to roll back changes to our database
436:07 - schema if we ever need to the goose
436:10 - command line tool Works based off of SQL
436:13 - comments so we'll start with a comment
436:14 - dash dash plus goose
436:17 - up
436:21 - and dash dash plus goose
436:24 - down
436:25 - and then anything we type here will be
436:28 - considered an up migration and anything
436:30 - here will be a down migration so let's
436:32 - start with the up migration it's going
436:34 - to be create
436:35 - create table users
436:39 - and the first field will just be called
436:41 - ID it'll be a uuid a universally unique
436:44 - identifier I prefer uuids to integer
436:48 - primary keys for a number of reasons
436:50 - um I'll link a blog post down in the
436:52 - description below
436:54 - um and that's just going to be a primary
436:55 - key
436:57 - next we're going to need a created at
437:00 - which is a time stamp
437:03 - not null but we must have must have it
437:06 - created at must have an updated at same
437:09 - thing
437:13 - and then a user will also have a name
437:14 - and we'll just
437:16 - make that a text field again
437:19 - let's say that's not null
437:21 - I need to remember to terminate my SQL
437:23 - statements with a semicolon and for the
437:25 - down by migration it's pretty simple
437:27 - we'll just drop the table so drop table
437:30 - users all right let's run our migration
437:33 - but first we're going to need to be able
437:35 - to connect to our local database from
437:37 - our program and from our command line so
437:40 - very first thing is we'll need a DB URL
437:45 - and we'll set it equal to the URL that
437:48 - we use to connect to our local postgres
437:50 - server so this isn't to connect to PG
437:52 - admin this
437:53 - this same connection string that PG
437:54 - admin uses to connect to the databaser
437:57 - we want to go directly to the database
437:59 - so it's going to look something like
438:00 - this postgres
438:02 - is the protocol so colon slash again
438:05 - this is just a URL and then we have the
438:08 - authentication part which in my case is
438:11 - Wags Lane because that's the user on my
438:15 - machine and then colon and then password
438:18 - if you have a password for your local
438:20 - database this is where it goes I
438:22 - actually did not set one up because it's
438:24 - just my local database
438:26 - and it's going to be at localhost
438:29 - colon
438:30 - 5432 which is the standard port for
438:34 - postgres and the last part of the URL is
438:37 - just going to be the database name that
438:39 - you created so in my case I believe it
438:41 - was RSS AG
438:43 - o okay so your url should look very
438:45 - similar to this with maybe you know the
438:47 - username the database name something
438:49 - like that could be could potentially be
438:51 - swapped out on your machine
438:53 - okay to run our migration here I'm going
438:57 - to copy I'm going to copy this database
439:00 - URL
439:01 - and then I'm going to CD into this
439:04 - directory so CD SQL schema
439:07 - and then from here I can run goose
439:10 - hostgress
439:12 - so I'm telling I'm telling Goose that
439:13 - hey I'm using a postgres database and
439:16 - then I'll paste in my connection string
439:18 - and type up so this will run the up
439:21 - migration a nasty error here turns out I
439:25 - forgot some commas we need to separate
439:27 - all of these field names with commas
439:29 - cool save that file let's try again
439:34 - so we got
439:36 - okay001 users.sql no more migrations so
439:39 - that should have run let's check PG
439:41 - admin to make sure that it works so now
439:43 - over in PG admin under my RSS AG
439:45 - database I should be able to come into
439:47 - the schemas tab
439:50 - the tables tag and I can see here that I
439:53 - now have two tables Goose DB version so
439:56 - this is an automatic table created and
439:58 - managed by goose and then I've got the
440:00 - users table that I just created let's go
440:02 - ahead and do a select star from users
440:06 - and we should just be able to see those
440:08 - column names come back now let's make
440:10 - sure that the down migration works as
440:12 - well
440:13 - go ahead and run the exact same thing
440:15 - but this time down instead and you can
440:18 - see that it down migrated the same file
440:20 - now over in PG admin if I right click on
440:24 - tables and click refresh you'll see the
440:26 - user's table is gone and this query
440:28 - should fail now
440:29 - okay so let's re-up migrate to get that
440:31 - database table created again and then
440:33 - the interesting thing about migrations
440:34 - is you can rerun the same up migration
440:37 - and you won't get any errors because
440:39 - Goose knows that you're already migrated
440:41 - up to the most recent version of your
440:44 - migrations now it's time to write a
440:46 - query so we're using sqlc to handle our
440:49 - queries and Goose to handle our
440:51 - migrations so to get sqlc set up we need
440:53 - to create a new file in the root of our
440:55 - project called
440:57 - sqlc.yaml I'm going to paste in this
441:00 - configuration here basically it's just
441:01 - telling sqlc what version we're using
441:04 - what database engine we're using and
441:06 - where we're going to store our queries
441:09 - the raw SQL for our queries are going to
441:11 - live in the SQL directory under a new
441:13 - subdirectory called queries
441:15 - we've specified that here right and here
441:19 - I'm going to create a new file I'm just
441:20 - going to call it users.sql
441:24 - and again this is where the SQL will
441:26 - live and the way sqlc works is that it
441:29 - takes the SQL statements and it
441:32 - generates go code Type safe go code that
441:35 - matches the SQL every sqlc query starts
441:39 - off with a comment that starts with its
441:42 - name so name we'll do a create user
441:45 - statement and it returns one record so
441:49 - we're saying I want a new function
441:50 - called create user oops and it's going
441:53 - to return one user that statement will
441:56 - be insert into users
442:00 - ID created Created at updated at and
442:06 - name
442:07 - values
442:10 - dollar sign one
442:13 - dollar sign to dollar sign three dollar
442:16 - sign four okay so what's this nonsense
442:19 - right in sqlc each dollar sign number is
442:25 - interpolated with the parameters for the
442:27 - function so this statement will create a
442:29 - new function called create user with
442:31 - four parameters and the first parameter
442:34 - will go in right here
442:36 - the second one the third one the fourth
442:38 - one Etc so it allows us to create
442:40 - queries that take arguments as input and
442:43 - then we'll end the query with just
442:44 - return returning
442:47 - returning star
442:50 - okay
442:51 - we want to create a new user and return
442:54 - that record right we expect one record
442:56 - back now let's use sqlc to actually
442:59 - generate the go code for this query we
443:03 - always run sqlc from the root of our
443:05 - package rather than within the queries
443:07 - directory itself and the reason that
443:10 - works is because we have this sqlc.yaml
443:12 - file at the top level okay so if
443:15 - everything was written correctly we
443:16 - should be able to do sqlc generate
443:20 - and what happens is it goes and reads
443:23 - that query and it also reads our table
443:27 - definitions
443:28 - which we've
443:30 - specified here right SQL schema so it
443:34 - knows the shape of our tables and it
443:36 - knows the query we want to create and it
443:39 - can go automatically generate all of
443:41 - this go code in the internal slash
443:43 - database package
443:45 - now we need to actually use the database
443:47 - in our go code so here in main.go I'm
443:50 - going to create a new struct called API
443:53 - config and it's going to hold a
443:55 - connection to a database
443:58 - now this database dot queries type is
444:00 - actually exposed by that code that we
444:03 - generated using sqlc so you can poke
444:05 - around through this package and kind of
444:06 - get familiar with the generated code we
444:09 - never manually update this code that's
444:11 - generated by sqlc it's completely
444:14 - managed by sqlc we're just going to
444:16 - write raw SQL to generate this code
444:18 - okay next thing we need to do is import
444:21 - our database connection
444:23 - so here in dot EnV we have our DB URL
444:29 - and we need to grab that and pull it
444:33 - into our application we're also going to
444:35 - need to disable SSL mode so SSL mode
444:38 - equals disable and this just this just
444:41 - tells our code hey we don't need to be
444:43 - connecting to our local database using
444:46 - encryption we kind of trust our local
444:49 - database
444:50 - so we'll parse that as a string so I'll
444:53 - do DB URL
444:57 - and if the database URL
444:59 - is not found then we'll
445:02 - we'll report a message
445:04 - or we'll log an error message and exit
445:07 - after that we need to actually connect
445:08 - to the database so the go standard
445:10 - library has a built-in SQL package we
445:12 - can do sql.open
445:14 - the driver name that we'll be using is
445:16 - just postgres
445:19 - and then we can pass in the connection
445:21 - string and this will return a new
445:24 - connection and an error
445:26 - and again if there's an error
445:30 - we'll just go ahead and log a message
445:31 - and exit
445:37 - can't connect to database
445:41 - now this is kind of a weird quirky thing
445:43 - about how go handles databases but we
445:45 - actually need to import
445:47 - a database driver into our program but
445:51 - we don't actually need to call anything
445:52 - from it so the sqlc docs mentioned this
445:55 - but basically we just need to include
445:56 - this line at the top of our program and
445:59 - we do need to import it so I'll do a go
446:01 - get on that lib PQ
446:05 - and we'll import it using that
446:07 - underscore just to say include this code
446:10 - in my program even though I'm not
446:12 - calling it directly
446:13 - okay with that there now we should be
446:16 - able to create a new API config
446:20 - and let's just call it API CFG
446:25 - and it takes as one of its Fields a DB
446:31 - where am I at I think I scrolled too far
446:37 - BB oh and I should probably go mod tidy
446:41 - and go mod vendor
446:45 - so that I stopped getting weird errors
446:47 - in my in my vs code
446:51 - okay uh this API CFG takes a
446:53 - database.queries but if you look here we
446:55 - don't have a database.queries we have an
446:57 - sql.db so we actually need to convert it
446:59 - into a connection to our package and we
447:03 - can do that with database
447:06 - dot new and we pass it as input the
447:09 - connection and we'll get back
447:11 - queries error
447:15 - here we can say if it's not equal nil
447:27 - and pass in the queries
447:30 - to the struct
447:33 - oh did I do that wrong maybe this
447:34 - doesn't return an error
447:36 - mismatch two variables but database.new
447:38 - returns one okay cool so this actually
447:39 - can't fail it's just a it's just a
447:41 - simple conversion
447:43 - we could actually even just do this it's
447:45 - probably easier
447:48 - great now we have an API config that we
447:51 - can pass into our handlers so that they
447:53 - have access to our database
447:56 - let's write that create user Handler
447:58 - okay so I'm just going to copy paste
447:59 - this Handler Readiness and change it to
448:01 - Handler
448:02 - user
448:05 - and we'll update this to say Handler
448:07 - this will be the create user Handler
448:10 - now here's the interesting thing about
448:12 - HTTP handlers and go the function
448:15 - signature can't change but we do want to
448:18 - pass into this function an additional
448:21 - piece of data we want to
448:24 - add this API config so the way we do it
448:28 - is by making this function a method so
448:31 - we do API CFG is a pointer to an API
448:36 - config so our function signature Remains
448:39 - the Same
448:41 - right it still just accepts these two
448:42 - parameters but now we have some
448:44 - additional data stored on the struct
448:46 - itself that we can gain access to
448:49 - and let's hook up this create user
448:51 - Handler in Main
448:53 - so we'll add it to the V1 Handler we'll
448:56 - do V1 router Dot
448:59 - post we want this to be a post request
449:02 - to slash users
449:05 - and we want to use the
449:08 - create Handler create user method which
449:12 - we defined on this struct so we can pass
449:15 - in API CFG dot Handler create user and
449:21 - now our Handler will have access to
449:23 - um to the database
449:25 - okay cool
449:27 - this Handler needs to take as input a
449:31 - Json body it should expect
449:34 - some parameters so we'll do type
449:35 - parameters
449:38 - is a struct
449:39 - and I think for now we just need a name
449:43 - and we need to parse the request body
449:46 - into this struct so we'll do Json dot
449:49 - new decoder
449:51 - and r dot body
449:54 - okay and this response or this returns a
449:56 - decoder
450:00 - then we do decoder dot decode
450:04 - and we want to decode into an instance
450:07 - of the parameters struct so we'll do
450:09 - params is an empty parameter struct and
450:13 - we'll decode into
450:16 - a pointer two parameters and this
450:20 - returns an error if anything goes wrong
450:26 - if there is an error then we should use
450:28 - that Handler function that we made
450:30 - earlier respond with error and say
450:32 - something like well we need to pass in W
450:35 - um if something goes wrong here it's
450:36 - probably a client-side error right so
450:37 - I'm just going to pass in a 400.
450:40 - and we'll say
450:42 - um
450:47 - let's see error parsing Json
450:56 - cool and then we'll return because we're
450:59 - done at that point if there is an issue
451:01 - okay otherwise we have access to a name
451:05 - so we can use our database to create a
451:08 - user so we do API
451:11 - cfg.db dot create user now this is the
451:15 - method that SQL C generated for us right
451:19 - because it read our create user SQL and
451:23 - it created
451:24 - a create user function for us right and
451:27 - it created the parameters as a struct so
451:30 - that's pretty convenient
451:31 - uh let's see how this works so create
451:33 - user accepts a context and some create
451:37 - user param so I'm going to use uh I
451:40 - think it's
451:42 - CTX no
451:44 - r dot context there we go
451:46 - so that's the context for this request
451:49 - and then we pass in database dot create
451:52 - user params this is struct and it should
451:55 - have yep all of our uh types that we
451:59 - need to pass into the create user
452:01 - function okay
452:03 - so first things first an ID
452:06 - the ID is a uuid
452:09 - um and this is the first point at which
452:11 - I think we've needed to use them so
452:12 - we're going to have to import this
452:14 - package so github.com Google slash uuid
452:17 - this is a very uh well-known uuid
452:20 - package and go
452:22 - we will go get it
452:27 - with that install we should be able to
452:28 - do
452:29 - uuid.new
452:32 - and that will just create a new random
452:34 - uuid and if you aren't familiar this is
452:37 - what a uuid looks like in string form
452:39 - it's basically just this really long
452:42 - random uh bit of I mean in this case
452:46 - represented as text that we can use as a
452:48 - primary identifier for every user so
452:50 - every user will get their own random ID
452:53 - cool
452:55 - um I should probably go mod tidy go mod
452:58 - vendor
453:00 - we practice every time you install a new
453:02 - package to make sure you vendor it and
453:04 - go mod tidy kind of cleans up any unused
453:07 - Imports um and resolves some issues
453:08 - there
453:10 - okay uh created that I'm going to set to
453:12 - just time dot now dot UTC
453:16 - it's created now and then updated that
453:18 - should represent the last time it was
453:20 - updated uh which would also be now right
453:23 - because we're creating something new
453:25 - and the user's name will just be
453:27 - params.name right it's whatever was
453:29 - passed in to this HTTP request in the
453:33 - body
453:34 - oh and I just am now realizing that I
453:36 - messed up this Json Tech should look
453:38 - like this
453:42 - okay cool
453:44 - um so create user should probably return
453:45 - an error yep returns a new user and an
453:48 - error
453:51 - again if there was an error creating the
453:53 - user we'll want to respond with an error
453:56 - and we'll say
453:59 - couldn't create user
454:04 - 400 seems fine
454:07 - and then we'll actually respond with the
454:09 - user object itself
454:11 - okay database dot user and see how that
454:14 - goes well let's actually take a look and
454:16 - see what does a database.user even look
454:18 - like
454:24 - I'm curious
454:26 - yeah so all these I mean all these
454:27 - fields are exported so they should
454:29 - Marshal to Json just fine let's go ahead
454:31 - and run this and see and see what we get
454:33 - before we run the code though it looks
454:35 - like I've got a couple little things to
454:36 - resolve here so error is already defined
454:38 - there and then here oh I'm messing
454:41 - something up we need to pass that in we
454:43 - need to interpolate that
454:44 - cool oh and here as well
454:48 - percent V because those are errors okay
454:50 - cool
454:52 - um now let's go ahead and run build and
454:53 - run the code so go build and
454:57 - run RSS hack
455:00 - wait server has started so let's go
455:04 - ahead and open up the Thunder client
455:07 - and now we'll be sending a post request
455:10 - to the user's endpoint
455:13 - and we'll be sending in a Json body
455:18 - oh me
455:20 - grow this just a little bit
455:24 - and we need to specify a name
455:26 - I'm going to create a new user called
455:28 - Lane
455:29 - and let's see what happens
455:32 - couldn't create user
455:34 - database wagslane does not exist
455:37 - it looks to me like I probably messed up
455:39 - my connection string let's go take a
455:41 - look at that
455:43 - so here in dot EnV
455:46 - y yeah okay we forgot to or I forgot to
455:48 - add the name of the database here at the
455:51 - end so we we need to do slash name of
455:55 - database all right let's try that again
455:58 - let's rebuild the server
456:00 - and resend that request
456:03 - cool we got a 200 response it looks like
456:06 - that is a new random ID great
456:10 - of that updated at and the name
456:12 - next just to make sure that the record
456:14 - actually was created in the database
456:16 - server itself I'm going to pop back over
456:18 - here to PG admin refresh my tables
456:23 - there's our users table and rerun this
456:25 - select star from users
456:27 - perfect looks like we've got one record
456:28 - in here with all of the data that I
456:30 - would expect now I want to make one more
456:32 - optimization to our code here you can
456:35 - see in this Json response that the fee
456:37 - the key names in the Json object are the
456:39 - same as the exported key names here in
456:44 - the user struct in the database package
456:46 - now we can't change this struct manually
456:49 - again this is generated by sqlc so what
456:53 - I think we should do is instead create a
456:56 - new models folder models.go
457:00 - in the main package
457:02 - and here we'll create our own user type
457:06 - so type user struct and it will be
457:10 - nearly identical so let me go grab this
457:12 - one
457:13 - be nearly identical
457:15 - the only difference at this point is
457:17 - that I'm going to add Json tags
457:20 - so that I can specify you know what
457:23 - these names should be and we've been
457:26 - using kind of this snake case convention
457:28 - so I'm just going to stick with that so
457:30 - updated
457:31 - at a name
457:34 - and I'm going to create a function uh
457:36 - we'll say database user to user and it
457:40 - will take a DB user
457:46 - and return a user and all this does is
457:49 - return a new user struct where we've
457:53 - kind of populate it with all of the
457:56 - all the stuff from the database user
457:59 - so again the purpose of this is really
458:01 - just
458:02 - I want to own the shape that's being
458:05 - returned over the wire right on our HTTP
458:08 - responses and now I have the power to
458:11 - configure that easily within within my
458:12 - application
458:14 - so we'll go ahead and just uh
458:17 - paste these in here
458:23 - okay and then in my user Handler rather
458:27 - than responding with the database user
458:29 - I'm going to respond with our user
458:33 - cool
458:34 - let's re-run and build that
458:37 - and let's run our query again now
458:40 - remember we already have a user in our
458:42 - database so I'm going to
458:46 - create a second one let's call this one
458:49 - Rob
458:52 - and this time you can see we have those
458:55 - snake case keys
458:57 - and again I'm going to go check in PG
459:01 - admin to make sure that Rob is there
459:03 - perfect now we've got Lane and Rob and
459:05 - you can see they have different randomly
459:07 - generated IDs and their timestamps are
459:09 - slightly different
459:10 - we're going to be using API keys to
459:12 - authenticate our users on This Server
459:15 - the nice thing about an API key is Not
459:17 - only is a little more secure than a
459:19 - username and a password but because it's
459:21 - so long it also serves as a unique ID
459:24 - for that user so we don't even need a
459:26 - combo of username password we can just
459:28 - use the API key in order to kind of
459:30 - uniquely identify people so we need to
459:33 - run a migration that adds a new field to
459:36 - the users table
459:38 - so that we can store their API Keys now
459:39 - we've already created this migration
459:42 - that creates the users table and we
459:44 - don't want to modify this because it's
459:45 - generally a really bad idea to go
459:47 - modifying your existing migrations
459:49 - instead we create a new one so I'm going
459:51 - to create a new one and we'll call it
459:53 - zero zero two because we want it to run
459:55 - after the first migration and again
459:58 - Goose uses these numbers to know in
460:00 - which order it should run the migrations
460:02 - and we'll call it users API key
460:07 - and the migration statements are going
460:10 - to look a little bit different okay so
460:13 - the up statement is going to be an alter
460:15 - table so alter table users We'll add a
460:19 - column
460:21 - and we'll call the column just API
460:23 - underscore key
460:24 - it's going to be a varchar so varchar
460:28 - 64. now the difference between varchar
460:30 - and text at least for our purposes here
460:32 - is that the varchar is exactly 64
460:35 - characters long so we're saying we want
460:37 - our API keys to be 64 characters long
460:40 - and we want those API keys to be unique
460:43 - no two users should have the same API
460:45 - key we also don't want them to be null
460:48 - and we're going to set a default
460:51 - a default API key and this is important
460:54 - because if we didn't set a default we'd
460:56 - run into an issue when we run this
460:58 - migration remember we already have two
461:00 - users in our database currently so if we
461:03 - just try to add a column that has these
461:06 - unique not null constraints on it then
461:10 - what's the SQL database going to do how
461:12 - is it going to generate new API keys
461:15 - that are unique and not null typically
461:17 - it would just default the new
461:20 - um you know you know the field in the
461:21 - existing records to null but because
461:23 - we've said they can't be null and they
461:25 - must be unique we need to provide a
461:29 - unique default for every new record or
461:31 - for excuse me for every existing record
461:34 - in the database
461:35 - so the default value that we need to add
461:38 - again needs to be unique for every
461:40 - person so we're actually going to have
461:42 - to use some random number Generations so
461:45 - we can generate a unique API key for
461:47 - every user and this is the snippet of
461:49 - code that does that again you can go
461:51 - grab this in the text instructions for
461:54 - this project over on boot Dev but let me
461:57 - explain basically what it's doing we're
461:58 - generating some random bytes and then
462:01 - we're casting it into a byte array
462:04 - and we're using the Sha 256 hash
462:07 - function to get kind of a a fixed size
462:11 - output so we're saying take a a big
462:14 - random slice of bytes
462:17 - hash them with straw 256 so that we get
462:19 - a fixed size output and then encode it
462:22 - in hexadecimal
462:25 - and that's so that we get 64 unique
462:27 - hexadecimal characters this one makes
462:29 - more sense when we actually run the
462:30 - query and you see what the output looks
462:32 - like
462:33 - and then as far as the down migration
462:35 - goes we just need to alter able users
462:38 - and drop
462:41 - column API key again
462:44 - down migrations should just undo
462:47 - whatever was done in the up migration
462:49 - let's go ahead and run this migration so
462:51 - I'm going to need to change directory
462:52 - into SQL
462:54 - schema
462:56 - then we'll run goose postgres
462:59 - and then let me go grab the connection
463:01 - string now we do need to peel off this
463:04 - SSL mode disable Goose doesn't need that
463:07 - um just our code needs that so I'm going
463:08 - to grab the rest of the string
463:10 - and we'll run an migration
463:13 - cool so it looks like it ran
463:14 - successfully
463:15 - let's go see if those default values
463:17 - look good
463:18 - run the select star statement and there
463:23 - you can see the new API keys
463:26 - so big old hexadecimal strings that
463:28 - uniquely identify every user and should
463:31 - be kept secret by the user because just
463:33 - the API key is enough to authenticate
463:35 - the user
463:37 - now that we've got our migration and
463:38 - we've updated our schema we actually
463:40 - need to go update our query right we
463:44 - need to be creating new API keys for new
463:47 - users so let's go update our create user
463:51 - function it should now accept an API key
463:53 - as the last parameter
463:56 - and pass it in here
464:00 - actually you know what
464:02 - if we do it this way we're basically
464:04 - telling our application code hey you
464:06 - need to go generate an API key in the
464:09 - same way that we generated it here in
464:11 - our SQL I think it would actually be
464:13 - easier what if we just take this
464:16 - and plop that
464:19 - in here
464:21 - right so now we'll use we'll use SQL to
464:24 - generate the new API Keys we don't even
464:25 - need to update the function signature of
464:27 - our create user function cool so the SQL
464:30 - will just handle the creation of new API
464:32 - Keys every time a new user is created
464:35 - all right now we should be able to run
464:38 - sqlc generate
464:41 - insert has more Expressions than Target
464:43 - columns let's
464:46 - let's oh right sorry we do still need to
464:48 - pass in the API key as the column name
464:51 - the difference is because we are not
464:53 - using dollar sign five our function
464:55 - signature won't change this got a little
464:57 - confusing I was reading it like a
464:58 - function signature even though it is it
465:00 - is SQL okay run that again
465:03 - it went off without a hitch you can see
465:05 - it updated a few files in our database
465:07 - package now we should be able to go use
465:09 - that in our code
465:11 - but before we test our server let's add
465:14 - one more thing let's give us a way to
465:16 - get a user so we'll create a new
465:18 - function
465:19 - and this one we'll call
465:21 - get user
465:24 - by API key
465:26 - it's return a single row
465:29 - and it's going to be a select statement
465:30 - so select star
465:32 - from
465:34 - users
465:36 - where
465:38 - API key equals dollar sign one
465:43 - and we'll run sqlc generate again to
465:46 - generate the code for that query you can
465:49 - see it created it here
465:51 - so in our Handler user function we
465:54 - actually don't need to make any changes
465:57 - to our create user Handler right we
465:59 - didn't change the number of parameters
466:00 - that we need to pass in for the API key
466:02 - it's handled kind of under the hood by
466:05 - the SQL query
466:06 - but we do need a new Handler for getting
466:09 - users so let's go ahead and add that
466:13 - so I'm going to copy paste that do
466:16 - Handler
466:17 - get user by API key
466:21 - maybe we can just let's just simplify
466:23 - this let's just call it Handler get user
466:26 - now this Handler is going to look very
466:28 - different
466:30 - this is an authenticated endpoint so in
466:34 - order to create a user on our API
466:36 - basically to register a new account you
466:38 - don't need to have an API key but if you
466:40 - want to get your own user information
466:42 - you have to give us an API key first
466:45 - this isn't going to be the only
466:48 - authenticated endpoint or the endpoint
466:50 - that you can only do if you're logged in
466:52 - so I think it makes sense to kind of
466:55 - abstract the logic for getting a user by
466:58 - their API key into a package so under
467:02 - the internal package here where we have
467:04 - our database code I'm going to create a
467:06 - new package and we'll just call it auth
467:09 - and in there I'll create a new file
467:10 - we'll call it auth.go this whole package
467:13 - will just be called
467:15 - auth
467:18 - now the only function that we care to
467:22 - export in this auth package is going to
467:24 - be this one called get API key
467:27 - and its purpose get API key it will say
467:29 - it extracts
467:31 - an API key
467:33 - from
467:35 - the headers of an HTTP request so it's
467:39 - going to go into the headers look for a
467:40 - specific header and see if it can find
467:42 - the API key if it can it'll return it
467:45 - otherwise it will return an error
467:48 - now as the authors of This Server we get
467:51 - to decide what we want the
467:52 - authentication header to look like so
467:54 - I'm just going to say
467:56 - example
467:59 - let's expect an authorization header so
468:01 - the key of the header will be
468:03 - authorization
468:04 - and the value will be API key
468:08 - and then sum you know like insert API
468:12 - key here
468:14 - okay so we're looking for a header of
468:18 - this format
468:20 - so first let's look and see if we can
468:22 - find a value associated with the
468:24 - authorization key
468:26 - um we're just using the HTTP standard
468:28 - Library here so we can do headers dot
468:30 - get
468:32 - authorization
468:33 - and this should return let's see a
468:35 - string okay so the value associated with
468:38 - this
468:39 - with this header key now if value is the
468:44 - empty string then we can just say
468:47 - turn empty string and an error say
468:51 - errors.new
468:54 - no authentication info
468:58 - about
468:59 - so otherwise we have a valid value so we
469:03 - could do something like this uh
469:06 - vowels
469:08 - strings dot split
469:11 - bowel
469:13 - okay so
469:15 - strings.split takes a string as input
469:18 - and a delimiter so we're going to say we
469:20 - want to split this string here right the
469:24 - the value given to us by the
469:26 - authorization header we want to split it
469:28 - on Spaces okay
469:31 - so next we can say if the length of
469:34 - vowels
469:35 - does not equal to
469:37 - then again we can return an error saying
469:40 - like you know maybe malformed
469:44 - malformed ah header
469:46 - right because we're expecting that the
469:49 - value of this key is two like two
469:53 - specific values separated by a space the
469:56 - first should be API key and the second
469:59 - should be the API key right the first
470:02 - would just be the string API key and the
470:04 - second should be the actual API key
470:07 - okay so if the length is wrong then uh
470:10 - next we should probably check and make
470:12 - sure they typed this in correctly so we
470:13 - can say if vowels it's zero does not
470:18 - equal API key
470:22 - malformed auth header
470:25 - we could say malformed first part of
470:28 - auth header
470:30 - okay otherwise
470:33 - we can just return
470:37 - thousand one and no error right
470:42 - because by that point we're sure that
470:45 - all the all this part was correct and
470:47 - we're extracting just the API key
470:50 - okay what did I screw up here errors.new
470:53 - oh right you're not supposed to
470:54 - capitalize errors in go that is a a
470:57 - linting error
471:01 - stylistic error okay cool
471:04 - so now we've got the get API key
471:07 - function we can go ahead and use this in
471:09 - our get user Handler
471:11 - so let's go ahead and grab that API key
471:13 - so API key and error
471:16 - auth dot get API key and we pass in the
471:20 - HTTP headers so r dot header perfect if
471:25 - there is an error let's handle it
471:29 - we can just respond with an error saying
471:33 - auth error
471:36 - and 400 we should probably do like a 403
471:39 - and in fact now that I'm thinking about
471:41 - HTTP codes creating a user
471:43 - probably should be a 201 instead of a
471:45 - 200. like you probably won't run into
471:49 - any issues for using a 200 but 201 is
471:52 - the created code so it's like a little
471:55 - more correct uh if you're looking at it
471:57 - from kind of a restful HTTP standpoint
471:59 - and then 403
472:01 - um is one of these kind of permissions
472:03 - errors so that should be good
472:05 - okay now that we have an API key we can
472:08 - use our
472:10 - database query that we created dot
472:13 - getuser by API key
472:15 - again we'll pass in the requests context
472:17 - and
472:19 - the API key I haven't really touched on
472:21 - this yet
472:23 - in go
472:24 - um there is a context package in the
472:26 - standard library and basically it gives
472:28 - you a way to track
472:30 - something that's happening across
472:32 - multiple go routines and the most
472:35 - important thing that you can do with a
472:36 - context is you can cancel it so by
472:40 - canceling the context it would
472:41 - effectively kill the HTTP request I
472:44 - don't want to go too much into detail on
472:46 - how all of that works here you could
472:48 - definitely go read up on it but for now
472:51 - just make sure that it's important to
472:52 - kind of use the current context so every
472:55 - http.request has a context on it and you
472:59 - should use that context in any calls you
473:02 - make within the Handler that requires a
473:05 - context just in case uh kind of
473:07 - cancellations happen
473:08 - okay cool uh that returns a user and an
473:13 - error
473:15 - again if there is an error
473:19 - Let's do let's use a better uh
473:23 - string here maybe
473:28 - couldn't get user
473:31 - and this one let's just go with a 404 or
473:34 - a 400 for now
473:36 - cool and then we can respond with Json
473:42 - this time it will just be a 200 code and
473:45 - again we should cast that database user
473:47 - to the user model that we defined here
473:52 - right with the the nicely formatted Json
473:55 - tags
473:56 - and that should be good okay let's hook
473:58 - up our get user Handler
474:02 - to our router
474:04 - so here we'll do V1 router dot get so
474:09 - same path slash users
474:12 - but we'll be hooking up
474:14 - the get user Handler to the get HTTP
474:18 - method so again same path different
474:19 - method all right let's test our new
474:23 - endpoint
474:25 - um first I'm going to go ahead and rerun
474:26 - sqlc generate because I can't remember
474:28 - if I've done that and then we'll build
474:31 - and run the server
474:36 - okay with that running let's head over
474:38 - to thunderclient
474:41 - and first let's create another new user
474:46 - so Json body
474:48 - let me minimize this a little bit
474:51 - let's keep create a new user we'll call
474:53 - them Rand
474:55 - and it'll be a post request that looks
474:58 - good
474:59 - okay response came back
475:02 - Rand was created and this is rand's ID
475:05 - ah we screwed something up we're not
475:08 - responding with the API key
475:10 - let's go update that
475:13 - so here in our model I believe it's
475:16 - because we're not casting
475:18 - so we need API
475:20 - e
475:21 - string
475:23 - Json
475:25 - API key
475:28 - and then here
475:30 - I need to do that conversion so it's
475:32 - just getting dropped because we weren't
475:33 - we weren't setting the API key anywhere
475:37 - okay uh let's rebuild
475:43 - and we'll create a new user let's call
475:45 - this one Joe
475:47 - okay cool
475:49 - so Joe was created and it actually
475:52 - returned the API key perfect now let's
475:55 - go ahead and I'm going to create a new
475:57 - request
475:59 - this one
476:01 - also to localhost
476:04 - 8080
476:06 - slash V1 users but this one will be a
476:09 - get
476:10 - and we're going to add some headers or
476:12 - specifically one header right we're
476:14 - going to add our authorization header
476:16 - and its value will be API key
476:20 - and then the actual API key just paste
476:23 - it in there
476:24 - okay let's go ahead and run that
476:27 - and it's returning Joe
476:31 - it's good to test failure cases too so
476:33 - let's just see what happens if we
476:36 - update this header and let's just like
476:38 - let's just make something
476:40 - broken let's just remove a section of
476:42 - the API key and see what happens
476:45 - cool we get a 400 bat request couldn't
476:46 - get user SQL no rows in the result set
476:49 - so essentially user is not found perfect
476:51 - so we've got our users set up and our
476:54 - authentication system now it's time to
476:56 - actually get to some business logic
476:57 - right this is an RSS feed aggregator so
477:00 - we need a way to store feeds let's
477:03 - create a new schema or rather a new
477:05 - migration in our schema folder this will
477:08 - be 003 and we'll call it feed
477:11 - s.sql
477:13 - now this is going to be a create table
477:14 - migration right we want to create a
477:18 - beads table so we'll do create table
477:20 - feeds
477:22 - now a feed and the drop will also drop
477:25 - the feed stable a feed has an ID just
477:27 - like a user it also has a created at and
477:30 - an updated ad and it also has a name
477:32 - like all of that is actually very
477:34 - similar
477:35 - um what's unique about a feed is it has
477:37 - a URL
477:38 - which is text as well that is unique
477:43 - and not null
477:45 - and it also has a user ID
477:51 - which references sorry it's a user ID is
477:55 - a uuid which references
477:58 - users ID
478:01 - and we'll also add the on delete Cascade
478:04 - [Music]
478:07 - essentially what this does is it says we
478:09 - have a user ID stored in our feeds table
478:11 - that references the ID of a user in the
478:16 - users table right so this is this is
478:17 - relational data this is a relational
478:19 - database
478:20 - essentially what this means is if we try
478:22 - to create a feed
478:24 - for a user ID that does not exist in the
478:27 - users table we'll get an error which is
478:29 - what we want because we don't want feeds
478:31 - to be able to exist without a user who
478:33 - created them and then this on delete
478:35 - Cascade bit just says when a user is
478:38 - deleted I want all of the feeds
478:41 - associated with that user to be deleted
478:43 - automatically it will Cascade and delete
478:45 - all of them and let's run this migration
478:48 - so I'm going to hop into the SQL schema
478:51 - directory
478:52 - and from here we can run goose postgres
478:55 - postgres and grab my connection screen
478:59 - again we don't need the SSL mode stuff
479:01 - for goose
479:02 - grab the rest of it
479:04 - and up
479:06 - cool now over here in PG admin I can do
479:09 - a select star from feeds and make sure
479:12 - that that table exists with those fields
479:15 - next we'll need a query to create a new
479:17 - feed so I'm going to go ahead and copy
479:19 - this queries file update it to feeds and
479:23 - then we'll delete this one because we
479:24 - don't need it and we'll create a
479:26 - create feed
479:29 - and insert into feeds ID created I
479:33 - updated that name there will not be an
479:35 - API key but let's see we need a
479:39 - name URL and user ID okay name URL
479:44 - user ID
479:46 - we won't be generating an API key here
479:49 - instead all of these values I think will
479:52 - just be passed in from our application
479:54 - code so one two three four five six we
479:57 - need six parameters for this function
480:00 - five and six and then we'll just return
480:04 - the entire feed row after it's done
480:07 - being created and then I'll just
480:08 - navigate back to the root of the project
480:11 - and run SQL sqlc generate
480:17 - to create the code for that new query
480:19 - next we're going to create a new Handler
480:21 - that will allow users of our API to
480:24 - create a new feed
480:26 - here's the thing that Handler is also
480:28 - going to need all of this same logic
480:32 - that we have in the get user Handler
480:35 - right we'll need to grab an
480:37 - authentication a token or an API key
480:40 - from the authorization header fetch the
480:42 - user and then use that user in the
480:45 - Handler and rather than copying and
480:46 - pasting uh this what 10 lines of code
480:49 - into every Handler that's authenticated
480:51 - instead we're going to build some
480:53 - middleware to kind of dry up the code
480:55 - right
480:56 - um
480:57 - let's go ahead and do that so I'll
480:58 - create a new file I'm going to call it
481:00 - middleware
481:01 - off
481:03 - dot go
481:05 - art of the main package
481:07 - and here we're going to define a new
481:09 - type and it's our own custom type I'm
481:12 - calling it auth Handler and you'll
481:15 - notice it looks almost exactly like a
481:19 - regular HTTP Handler the only difference
481:21 - is that it includes a third parameter it
481:25 - has a user associated with it so if you
481:28 - think about this it makes a lot of sense
481:30 - for any authenticated Handler to accept
481:33 - three parameters where the third one is
481:35 - the authenticated user now the problem
481:39 - with this auth Handler type that we
481:41 - created is that it doesn't match the
481:43 - function signature of an HTTP dot
481:46 - Handler func right those functions with
481:49 - just the response writer and the request
481:51 - as the only two parameters so what we're
481:53 - going to do is create a new function
481:55 - called middleware auth that works it's a
481:59 - method on our API config so it has
482:01 - access to the database
482:03 - um but it its job is to take an auth
482:05 - Handler as input and return turn a
482:08 - Handler Funk so that we can you know use
482:10 - it with the QI router
482:12 - okay
482:13 - let's Implement that the way this
482:16 - function will actually work is we're
482:18 - going to return a closure so we're
482:21 - returning here a new Anonymous function
482:23 - with that same function signature as
482:26 - your normal HTTP Handler func the
482:28 - difference is that as we Define this
482:31 - function we'll have access to everything
482:33 - within the API config so we'll be able
482:35 - to query the database so we can
482:37 - basically just go rip out the code from
482:39 - our get user Handler
482:42 - and paste it in here
482:44 - right we're going to go get the API key
482:47 - from the request well from the request
482:50 - headers at least and then we can go
482:53 - ahead and grab the user using that API
482:57 - key
482:58 - all right so we'll have access to the
483:00 - user here in the function
483:02 - finally all we need to do is run the
483:05 - Handler that we were given
483:07 - with the response writer the request and
483:11 - the user right so by the time we get to
483:14 - actually calling the auth Handler we're
483:16 - able to give it
483:18 - an actual user from the database and
483:21 - this is really great let me show you why
483:23 - so now that the middle middleware auth
483:25 - function exists we can remove all of
483:28 - this code from the get user Handler
483:31 - we can update the get user Handler to
483:34 - accept as input
483:39 - a database user
483:42 - user database.user
483:45 - look at how clean this function becomes
483:48 - right now it's just now it's literally
483:50 - just one line cool and now to hook it up
483:52 - you'll notice we have an error over here
483:54 - we just need to call our middleware auth
483:57 - function
483:59 - API CFG dot middleware off
484:05 - we call this function to convert the get
484:07 - user Handler into a standard
484:11 - http.handlerfunk I kind of move fast
484:14 - through that hopefully it all makes
484:15 - sense though basically we're just
484:16 - calling the middleware auth function
484:18 - first
484:19 - to get the authenticated user and then
484:22 - we're calling that callback the the get
484:25 - user Handler the nice thing is now we'll
484:27 - be able to reuse that middleware across
484:29 - many different HTTP Handler functions so
484:33 - now let's create the create feed Handler
484:35 - I'm going to go ahead and just copy this
484:37 - Handler user change it to Handler feed
484:42 - and for now we just need a create
484:43 - function so I'll delete this get
484:45 - and we'll call it Handler
484:48 - create feed
484:50 - and remember it's an authenticated
484:52 - endpoint so we can have it accept the
484:54 - user directly so user database dot user
484:58 - we know who's creating the feed by the
485:00 - time we get to this function which is
485:02 - awesome
485:03 - all right in order to create create a
485:06 - feed
485:07 - use our new create feed function which
485:09 - takes
485:10 - create feed params
485:12 - and create feed params have ID created
485:16 - updated at name that's all the same the
485:18 - difference is a URL and a user ID
485:21 - so URL
485:24 - and a user ID
485:27 - which is a uuid
485:28 - which actually exists already on the
485:30 - user object so we can just do user.id
485:32 - okay
485:34 - what do we want as input we need a URL
485:37 - so we also are going to want a params.u
485:40 - well
485:47 - so we want the user that's creating a
485:50 - new feed to be able to just send us a
485:52 - name and a URL and we'll go about
485:54 - creating the entire uh kind of you know
485:57 - feed object in the database or feed Row
486:00 - in the database
486:01 - so this is what our parameters should
486:03 - look like uh what error am I running
486:04 - into here cannot use API cfg.create feed
486:10 - no new variables on left side of that's
486:13 - odd create feed should return a feed
486:17 - let's take a look at that definition
486:20 - yeah it does return a feed what am I
486:23 - messing up here
486:26 - oh first of all that shouldn't be a user
486:28 - that should be a feat okay that's the
486:30 - problem I was over I was trying to
486:32 - overwrite the database.user type with a
486:35 - feed type that won't work
486:37 - okay so we're creating a feed we're
486:39 - generating a new uid that's great we're
486:42 - using the current time perfect
486:44 - um this is getting messed up uh variable
486:48 - of type uuid.uid as uuid.no uuid ah okay
486:54 - I see the problem
486:56 - the create feed params
486:59 - except a uuid.null uuid that's a problem
487:03 - we don't ever want a you the null uuid
487:06 - type from the uuid package is a nullable
487:09 - uuid
487:10 - but we don't want it to be nullable
487:12 - because we expect that every feed will
487:15 - be created by a user so let's go update
487:17 - our
487:19 - our uh I think it's our is it our
487:22 - migration let's go look schema feeds
487:25 - yeah user ID uuid
487:30 - not null
487:32 - cool it doesn't need to be unique a user
487:34 - can have multiple feeds but it should
487:35 - never be null
487:37 - all right
487:38 - um with that we're actually going to
487:40 - need to go
487:44 - uh rerun our migration so SQL
487:48 - um
487:49 - schema
487:52 - and we'll do a down to drop the table
487:57 - down
487:59 - and then back up to create the new table
488:01 - with the proper schema
488:04 - and then we should re-run
488:07 - SQL C generate
488:11 - okay
488:12 - did that work
488:14 - create feed create feed params looks
488:16 - like that error is gone it's now just a
488:18 - uuid type perfect now at this point we
488:22 - have a valid database feed I should
488:24 - probably update this error so that it
488:26 - actually says feed and we want to return
488:28 - it
488:29 - in our HTTP response trouble is remember
488:33 - we don't want to just directly return
488:35 - the struct let's go create a new model
488:37 - for a feed
488:39 - so we'll do type
488:42 - feed
488:43 - then I'm going to go just copy
488:48 - the types from here and we'll use those
488:53 - and we'll make our own Json tags or the
488:56 - type
489:01 - user ID
489:03 - URL
489:06 - name
489:07 - updated at
489:09 - and created that okay
489:12 - and then we'll want a
489:16 - what is it database database feed to
489:21 - feed
489:29 - and we'll return a feed
489:43 - all of this should be
489:45 - pretty straightforward
489:48 - again this just gives us more control
489:50 - right now we in our code that's not
489:53 - generated by SQL C
489:55 - are able to Define
489:57 - you know what the shape of the response
490:00 - will look like if for whatever reason we
490:02 - needed to store some data in the
490:03 - database but never wanted to respond
490:05 - with it in our Json API we could make
490:07 - those changes here in this struct okay
490:10 - so now we've got database feed to feed
490:12 - we'll call that
490:14 - and now we should be good to go
490:17 - all right let's test out our new Handler
490:19 - so I'm gonna rebuild our server and run
490:23 - it
490:26 - and over in the Thunder client let's see
490:29 - so we just created a new user Joe so we
490:32 - have our authentication key here or our
490:34 - API key
490:36 - I'm going to do a new request to HTTP
490:39 - slash localhost
490:42 - 8080 slash V1 slash feeds ah now that I
490:46 - type this out I realize that we never
490:48 - hooked it up
490:50 - let's go hook up that feed
490:52 - so
490:53 - speed Handler Handler create feed we
490:55 - need to go paste this in to
490:59 - the main function
491:01 - so this one will go under slash feeds
491:04 - because we're creating a resource we're
491:05 - going to use a post request
491:08 - Handler create feed
491:11 - okay that should be hooked up now let's
491:12 - restart our server
491:17 - and over here again I need to grab that
491:21 - API key all right
491:27 - what do we want here post request
491:32 - localhost 8080 V1 feeds
491:36 - we do need to authenticate again so
491:41 - query headers
491:45 - authen
491:46 - authorization
491:48 - API key
491:51 - paste in that API key
491:53 - okay uh what do we send in as the body
491:57 - let's take a look at our Handler again
492:00 - a name and a URL okay
492:03 - so name now remember this is this is
492:06 - this is not a person this is a feed
492:08 - right and a feed is a URL that kind of
492:12 - links to an RSS feed out on the internet
492:14 - so this one I'm going to put just lanes
492:17 - lanes blog
492:20 - and then
492:22 - the URL is going to be
492:25 - https colon slash wagslane.dev
492:30 - slash index dot XML so in case you're
492:36 - not familiar with what an RSS feed is
492:37 - let me just show you really quick
492:39 - um I'm here on my blog wagslane.dev and
492:42 - if you click RSS up at the top it'll
492:44 - take you to my RSS feed now every RSS
492:47 - feed will have a different URL it's kind
492:51 - of up to the author of the blog or the
492:53 - podcast what that feed URL is but you
492:55 - can usually find it by poking around on
492:57 - their website so in my case it's just
493:00 - wagslane.dev slash index.xml and it will
493:03 - look something like this if you open it
493:05 - up in a browser it's basically this
493:07 - structured XML document that describes
493:11 - what each post on the blog says at least
493:14 - from a high level it'll usually have
493:16 - something like a link to the post maybe
493:18 - a short description
493:20 - um basic stuff like that again podcasts
493:22 - also work on the same RSS structure so
493:25 - for testing you can use my blog or if
493:27 - you know of any other RSS feeds out on
493:29 - the web you can use them
493:31 - so now that I've pasted in that URL uh
493:34 - let's go ahead and create that feed
493:37 - and what do we get back
493:40 - cool the feed's got a new URL created at
493:43 - updated at the name and the URL seem to
493:46 - have persisted correctly and that is the
493:49 - user ID associated with the API key that
493:53 - we use to create the feed next we're
493:55 - going to add the ability for any user to
493:58 - get all of the feeds in the database
494:00 - this is not an authenticated endpoint
494:03 - okay
494:04 - we need new query I'm going to go ahead
494:06 - and use the same file this query will
494:08 - just be called get feeds
494:11 - and it will return many rows instead of
494:15 - just one
494:16 - all right and this one will be uh select
494:22 - star from feeds
494:25 - super super simple query here we're just
494:27 - gonna go grab all the feeds and return
494:29 - them
494:30 - okay from there we should be able to
494:33 - sqlc generate
494:36 - and let's go hook up that Handler
494:39 - I'm going to use the same Handler feed
494:42 - file
494:43 - uh but this one will be a little bit
494:45 - different
494:46 - you're going to
494:50 - call this one Handler get feeds
494:56 - it's not authenticated so we don't need
494:58 - to pass in a user and it doesn't even
495:00 - take any parameters right it's just
495:02 - going to go get all of the feeds so API
495:05 - cfg.db dot get feeds
495:09 - and it the get feeds function if you
495:11 - remember we just wrote it in SQL it
495:13 - doesn't take any parameters and it just
495:15 - returns all the feeds that are currently
495:17 - in the database
495:18 - so this error should be say something
495:20 - like couldn't
495:21 - get feeds
495:25 - cool now we need to return all of the
495:29 - feeds this is not a single feed this is
495:33 - now a slice of database dot feeds so not
495:36 - only do we need to return them but we
495:38 - need to actually convert them so let's
495:39 - go update our models a little bit let's
495:42 - create a new function
495:44 - this one will be database feeds to feeds
495:49 - and the difference is it will accept a
495:51 - slice of database fees and it will
495:53 - return a slice feeds
495:56 - let's do this slice feed we'll create a
495:59 - new empty slice of feeds and then four
496:02 - DB feed
496:07 - range DB feeds
496:12 - feeds equals append
496:16 - feeds
496:18 - database feeds
496:20 - or database feed
496:22 - and return
496:23 - Beats sorry not we don't want to append
496:26 - it directly we have to we have to call
496:28 - our conversion function
496:29 - okay
496:31 - so this function will just iterate over
496:33 - all of the database feeds one by one
496:35 - converting them into our new feed
496:37 - structure and then returning them
496:39 - cool now here we can use that function
496:43 - to do that mapping
496:45 - great let's hook up this Handler
496:48 - so in main.go we'll create a new
496:51 - entry here
496:53 - this is going to be a get request
496:57 - and it's not authenticated
497:01 - it'll be Handler
497:04 - get feeds
497:05 - cool let's regenerate I can't remember
497:09 - if I generated my SQL C so I'll do that
497:11 - couldn't hurt
497:12 - and then we'll build and run the server
497:18 - okay with that running let's go ahead
497:20 - and create a couple more RSS feeds
497:23 - so here
497:26 - update the body
497:29 - of my request sorry I'm so zoomed in so
497:31 - that you guys can see and it just makes
497:32 - it hard
497:35 - um no this was to create users this is
497:38 - users here's feeds
497:40 - okay let's let's just add the same URL
497:44 - with a couple well no we can't we can't
497:46 - add the same URL let's just use some
497:48 - garbage URLs just to test
497:57 - all right
497:59 - okay that created properly
498:02 - now let's test our new endpoint
498:06 - this one is going to be a get request to
498:09 - feeds and we don't need to add any
498:11 - authentication information okay
498:13 - run that
498:17 - awesome this looks good to me we've got
498:19 - an array at the top level and then two
498:21 - feed objects one for garbage blog and
498:24 - one's for one for lanes block so it
498:26 - looks like everything's working so we've
498:28 - given users a way to create feeds and a
498:30 - way to query all of the feeds now we're
498:32 - going to give users a way to follow
498:34 - specific feeds so that they can see kind
498:36 - of an aggregated view of all of the
498:39 - feeds that they care about on the system
498:41 - okay so uh let's go ahead and add a new
498:44 - migration
498:45 - we need a new table
498:47 - so this will be the fourth migration and
498:50 - we'll call this new table feed follows
498:52 - and this table is just going to store
498:54 - the relationship between a user and all
498:57 - of the feeds they're following so it'll
498:59 - be a many-to-many kind of table of user
499:02 - IDs to feed IDs
499:04 - all right the table is going to be
499:07 - called feed follows
499:09 - so create table feed follows every feed
499:11 - follow like every other record in our
499:14 - database will have an ID created at and
499:16 - an updated at
499:18 - but its unique Fields will be a little
499:19 - bit different
499:21 - first it's going to need a user ID
499:26 - which is
499:28 - oh my gosh why can't I type fingers
499:30 - throw the wrong place in the keyboard
499:32 - so a user ID is a uuid
499:35 - um that can be it doesn't see it doesn't
499:38 - need to be unique
499:40 - um but it does need to be not null
499:44 - then we need a feed ID
499:48 - also a uuid not null
499:51 - and then we're going to create a unique
499:53 - constraint on the combination of user ID
499:58 - to feed ID so unique
500:02 - user ID
500:07 - so again this constraint is going to
500:09 - make it so that we can never have two
500:12 - instances of a follow for the same user
500:16 - feed relationship right you as user can
500:19 - only follow a certain feed once you
500:21 - can't follow it twice that doesn't
500:23 - really make sense right so we're gonna
500:24 - ensure that that's unique also I missed
500:27 - a couple things here the user ID should
500:30 - reference so references
500:35 - uh the users table
500:38 - ID field and on delete will Cascade
500:43 - so if a user is deleted we're going to
500:46 - go delete all of the data about what
500:48 - feeds they're following
500:50 - and then this one's going to be very
500:52 - similar
500:53 - except it references the feeds table
500:57 - with its ID and again if a feed gets
500:59 - deleted then we'll go delete all of the
501:01 - following data related to that feed
501:05 - cool okay let's go ahead and run this
501:08 - migration
501:09 - so I'm gonna go back up into the SQL or
501:14 - say back down into the SQL schema
501:16 - directory
501:17 - and from here
501:19 - I'll need my connection string do goose
501:23 - postgres
501:25 - connection string ah I didn't grab the
501:28 - whole thing let's try that again
501:32 - all of that
501:33 - goose postgres
501:36 - up
501:38 - cool speed follows databases or feed
501:42 - follows table is there so now we need a
501:44 - way for users to follow feeds alright
501:48 - let's go ahead and go create that so I'm
501:49 - going to copy and paste the feed Handler
501:53 - file and we'll call it Handler
501:55 - feed follows
501:59 - and update this so Handler create feed
502:02 - follow so remember in order for a user
502:05 - to follow a feed all we need to do is
502:07 - create a new feed follow record with
502:09 - that user feed relationship
502:13 - okay this is an authenticated endpoint
502:15 - right we so we we need a user and we
502:17 - need them to be authenticated have
502:19 - passed an API key right
502:22 - and let's see what do we need them to
502:24 - give us as input I think all we need is
502:27 - a feed ID
502:29 - right they just need to tell us which
502:31 - feed they want to
502:33 - follow
502:35 - so a feed ID is a uuid
502:40 - all right and now we should be able to
502:43 - create the oh we never we never made we
502:47 - never made the SQL query what am I doing
502:48 - what am I doing I'm getting way ahead of
502:50 - myself let's go add that query quickly
502:54 - so feed
502:55 - follows
502:57 - and to start we'll need a create feed
503:01 - follow
503:03 - okay what's in a feed follow right we've
503:06 - got all these
503:07 - all of these fields and I think yeah
503:11 - we're just gonna have them all passed in
503:13 - directly that seems like the easiest way
503:15 - so
503:16 - insert into feed follows
503:19 - ID created that updated at
503:23 - user ID
503:25 - ID
503:28 - that's five parameters right one two
503:30 - three four five
503:32 - cool that looks good
503:34 - now I should be able to go back and run
503:36 - sqlc generate
503:40 - cool now I should have
503:43 - a
503:45 - create feed follow function
503:49 - with create feed follow params
503:53 - all right
503:55 - it accepts a user ID and a feed ID so
503:58 - the user ID is just the author
503:59 - authenticated user the feed ID is going
504:02 - to be passed in his params right
504:05 - cool couldn't create feed follow
504:10 - don't need a get Handler quite yet and
504:13 - then we're gonna just need to make make
504:15 - that uh mapping function as well for
504:19 - feed follows
504:24 - so in our models file I'll create a new
504:26 - feed follow struct and it's going to
504:29 - have a user ID and a feed ID
504:39 - and a new function database feed
504:43 - follow to feed follow
505:00 - all right DB feed follow dot ID
505:14 - by the way I'm not using GitHub copilot
505:16 - in this video just so that you could
505:19 - just just so you can see more of my
505:22 - thought process but I typically do use
505:25 - GitHub copilot and it makes this kind of
505:28 - function just like way faster to write
505:31 - it would guess this kind of function
505:33 - almost perfectly
505:35 - um so just so you know I I do recommend
505:38 - those kinds of tools to speed up the
505:39 - development process
505:41 - um I'm just not using it uh right now so
505:43 - you can see how I think through you know
505:45 - architecting this this application
505:46 - without all the AI prompts getting in
505:48 - the way
505:49 - okay now we should be able to database
505:52 - feed follow to feed follow and we're
505:54 - gonna be clear that this is a feed
505:56 - follow not a feed
505:58 - and that goes there
506:02 - perfect
506:04 - all right let's hook this up so we're
506:06 - going to need to go into main.go
506:09 - V V1 router dot post because we're
506:12 - creating a resource
506:14 - slash feed follows
506:18 - and this is an authenticated
506:22 - authenticated Handler
506:26 - Handler create feed follow okay let's
506:29 - test this new endpoint so we'll build
506:31 - and run the server
506:37 - and we'll need a new request
506:40 - this one will be kind of similar it'll
506:45 - be
506:46 - oops a post request to the feed follows
506:50 - endpoint
506:52 - and we're going to need to authenticate
506:55 - so let's go grab some authentication
506:57 - information
507:00 - let's see get users let's go ahead and
507:03 - send this couldn't get user SQL no
507:06 - result okay I need to figure out what
507:09 - users I have available to me
507:11 - oh that's right we we changed this API
507:14 - key we wanted it to break let's go
507:16 - create a new user
507:20 - we'll make a new one called
507:23 - uh Billy
507:26 - and there's Billy's API key
507:29 - cool we've got some feeds
507:32 - but our feed follows
507:35 - need an auth section
507:38 - sorry in the headers
507:41 - we're doing it manually
507:43 - authorization
507:45 - API key
507:47 - there's Billy's key and then in the body
507:50 - we need to pass in the ID of the feed
507:53 - that we want to follow
507:55 - so let's do a get on all of the feeds
507:58 - and we can follow either of these let's
508:01 - follow Lane's block
508:04 - there's our feed ID
508:07 - paste that in there and create
508:13 - amazing new ID for the feed follow
508:15 - there's the user ID the feed ID what
508:18 - happens if we try to recreate it cool
508:21 - couldn't create feed follow duplicate
508:23 - key value violates unique constraint
508:25 - that's what we'd expect right we
508:26 - shouldn't be able to follow the same
508:29 - feed multiple times we're already
508:30 - following it we already have a record uh
508:33 - indicating that we are following it
508:34 - everything appears to be working just
508:37 - fine next let's give users a way to see
508:40 - all of the different feeds that they are
508:42 - currently following
508:43 - so we'll do get
508:47 - feed follows
508:49 - it will return many
508:52 - and the query will be select star from
508:57 - eat follows where user ID equals dollar
509:03 - sign one
509:04 - right so get all the feed follows for a
509:07 - given ID
509:10 - so let's get that hooked up I need to
509:12 - run SQL C generate to create that query
509:15 - and then down here we'll create a new
509:17 - Handler
509:21 - this Handler will also be
509:24 - authenticated but it's going to be get
509:27 - feed follows
509:30 - have the user we don't need any
509:32 - parameters here
509:34 - and we're just going to call get
509:37 - follows
509:38 - and we'll just need to pass in the
509:40 - user's ID
509:43 - couldn't get feed follow this
509:48 - cool now we've got a list of feed
509:50 - follows or a slice of feed follows so
509:52 - we're going to need to convert an entire
509:54 - slice so again down here we'll write
509:57 - this type of a function
509:59 - it's going to be database feed
510:03 - follows
510:06 - to feed follows
510:22 - all right
510:25 - lots of copying and pasting here feed
510:28 - follows
510:36 - okay so now we have a way to convert an
510:38 - entire slice of database feed follows to
510:41 - our own struct
510:43 - that looks good to me
510:47 - there feed follows
510:50 - okay cool now we have a Handler for
510:52 - getting feed follows let's go ahead and
510:54 - update this
510:57 - so we need a new V1 router dot get
511:02 - slash feed underscore follows
511:07 - middleware off
511:11 - if feed follow us
511:14 - Perfect all right let's give that a shot
511:17 - so we'll build and run again
511:27 - and now
511:28 - let's see so this is
511:31 - um
511:31 - this is the request that we use to
511:34 - create
511:36 - so let's grab
511:38 - so hard working on such a small screen
511:42 - let's grab our API key and create a new
511:46 - request
511:52 - 80 V1 feed follows
511:56 - it's going to be a get request it does
511:57 - need to be authenticated
512:03 - okay
512:05 - see if that works
512:07 - cool we got the one feedback that we are
512:10 - currently following finally we need a
512:12 - way to unfollow feeds or to delete feed
512:16 - follows so let's create a new one new
512:18 - query
512:20 - we'll do delete
512:22 - feed follow
512:23 - now this one is going to be our first
512:25 - query that doesn't actually return
512:27 - anything
512:29 - um it's just going to be an execute
512:31 - right we're not returning one record
512:33 - we're not returning many records we're
512:34 - returning no records we're just going to
512:36 - run a a SQL query so uh it's going to be
512:40 - delete
512:42 - ROM
512:44 - feed follows
512:47 - where ID equals dollar sign one and user
512:54 - ID equals dollar sign two now it's
512:57 - important it's important to point out
512:58 - that we don't actually need the user ID
513:02 - here for this query to work right the ID
513:04 - is already a unique identifier the
513:07 - reason I'm tacking on this user ID is
513:10 - because this will prevent someone who
513:13 - doesn't own a feed follow
513:15 - from trying to unfollow a feed on behalf
513:19 - of somebody else
513:20 - that makes sense uh if for whatever
513:24 - reason another user got accessed let's
513:27 - say if if for some reason user B got
513:30 - access to the feed follow ID of user a
513:34 - if we didn't have this check here then
513:38 - that user who hijacked a feed follow ID
513:41 - would be able to like unfollow like
513:45 - force the other user to do an unfollow
513:47 - if that makes sense this ensures that
513:50 - only the user who actually owns the
513:52 - follow record can execute the unfollow
513:55 - command
513:57 - hopefully that makes sense
513:59 - okay uh from here let's just go ahead
514:01 - and generate that
514:05 - and go hook it up to a new endpoint
514:11 - so we'll do
514:12 - Handler
514:15 - delete feed follow
514:18 - now this one's going to be a little
514:19 - different
514:22 - in that it is authenticated but we need
514:24 - to get a feed follow ID and delete
514:27 - requests so like HTTP delete request the
514:30 - delete HTTP method they don't typically
514:33 - have a body in the payload it's it's
514:36 - possible but I would argue it's not
514:38 - super conventional it's a little more
514:40 - conventional to pass the ID in the HTTP
514:44 - path so it's going to look something
514:46 - like this
514:51 - you and router dot delete feed follows
514:54 - slash
514:56 - feed follow
514:58 - ID
515:00 - and then this will be Handler
515:02 - uh Delete feed follow right so we want
515:07 - the feed follow ID dynamically passed in
515:10 - the path of the request
515:12 - so the question is how do we grab this
515:14 - feed follow ID in our Handler itself
515:17 - well the chai router has or Chi oh I'm
515:21 - never going to say that the proper way
515:22 - the chi router has a I think it's Pat is
515:26 - it URL let's see URL
515:30 - parameter that's the one uh you are pro
515:33 - URL parameter function where we can pass
515:35 - in the request and a key and in this
515:37 - case it's going to have to match so feed
515:39 - follow ID matches whatever we type in
515:42 - here between the open and close brackets
515:46 - okay and that's going to return a string
515:48 - so this is the feed follow ID string
515:53 - great we're going to take that and we're
515:55 - going to parse it into a uuid so we'll
515:57 - do uuid.parse
516:02 - and that will return a feed follow ID
516:05 - and potentially an error
516:10 - if the error it's not equal nil
516:13 - say couldn't parse feed
516:17 - Hollow ID
516:20 - and that will be a 400 level error
516:22 - perfect
516:23 - okay
516:24 - from here we should be able to do API
516:27 - cfg.database dot delete feed follow and
516:31 - we need to pass in the request context
516:34 - and
516:37 - feed follow params so database dot
516:41 - delete feed follow parameters it takes
516:45 - an ID and a user ID so the ID of the
516:47 - feed follow
516:49 - we just parsed
516:51 - and then the user ID
516:53 - comes in with that user object because
516:55 - this is an authenticated request
516:58 - cool and that should return just an
517:00 - error
517:05 - right oh and it's just it's just given
517:07 - me yellow squigglies because I need to
517:08 - handle the error
517:10 - I couldn't
517:12 - delete feed
517:14 - follow
517:16 - perfect uh what do we respond with here
517:18 - I guess we have a couple different
517:19 - options
517:20 - um the simplest thing would just be to
517:22 - respond with like an empty Json object I
517:25 - guess uh what matters to the client is
517:28 - probably the 200 Response Code
517:31 - um so we could like for the sake of
517:34 - Simplicity just so we can use our
517:35 - respond with Json function we'll just
517:37 - return an empty Json object
517:39 - alternatively maybe we could return an
517:42 - object that says like message you know
517:45 - unfollow successful or something um
517:48 - but it doesn't matter too much I think
517:50 - as long as it's a 200 level code we're
517:53 - pretty much good to go
517:55 - okay and that's already been hooked up
517:58 - so let's go ahead and test it
518:01 - I can't remember if I generated let me
518:03 - do that again and then we'll restart the
518:05 - server
518:08 - and take a look
518:12 - okay so this was our endpoint it's
518:15 - returning the feeds that we are
518:17 - currently following
518:19 - let's go ahead and delete
518:21 - this feed follow so we need new request
518:27 - this is going to be a delete request
518:29 - we're going to unfollow a specific ID
518:32 - we're going to unfollow this
518:34 - we're going to delete this feed follow
518:37 - you'd follow with that with that ID
518:41 - and the headers we do need to be
518:43 - authenticated as the same person
518:49 - so authorization
518:55 - same API key
518:57 - okay let's run that delete
518:59 - we got a 200 response now let's go do a
519:03 - get and make sure that it's gone yep
519:07 - empty list or empty array we're good to
519:09 - go okay we've built out the majority of
519:12 - the crud section of our API but we
519:15 - haven't built the most interesting part
519:17 - which is the part of the server that
519:19 - actually goes out and fetches posts from
519:21 - the different RSS feeds that exist in
519:23 - our database again the whole purpose of
519:26 - this server that we're building is so
519:28 - that it can keep track of all of these
519:30 - different feeds in the database and then
519:32 - go out periodically and actually
519:34 - download all of the posts that are on
519:38 - each individual feed so for example we
519:40 - have a feed for my personal blog post
519:42 - this server will actually go out to my
519:45 - blog every I don't know 10 minutes and
519:48 - check to see if there's a new blog post
519:50 - to download and store in the database so
519:53 - the first thing we need to do is update
519:55 - the feeds table
519:57 - to have one more column we need a new
519:59 - column called last fetched at and it's
520:02 - just so we can keep track of when we
520:04 - last fetched the posts for a given fee
520:06 - so let's go ahead and add that we'll
520:08 - need new migration
520:10 - um and it will look kind of like this
520:11 - migration uh it's going to be our fifth
520:14 - migration so far it's going to be on the
520:16 - feeds table and we're going to be adding
520:18 - the last fetched at
520:21 - last fetched at
520:24 - field okay so alter table feeds add
520:28 - column last fetched at
520:33 - and this one is going to be
520:38 - timestamp
520:40 - and it will be nullable so we don't need
520:42 - a not null constraint
520:44 - um
520:45 - in fact that's it
520:47 - um it's okay like we don't need to
520:50 - specify any defaults that should be it
520:52 - um and then as far as the down migration
520:54 - goes we'll just be deleting or dropping
520:58 - the column from the feeds table okay
521:01 - cool let's run that migration
521:06 - so goose postgres
521:16 - perfect so we don't need to update the
521:19 - create feed function we want the last
521:23 - fetch that field to default to null so
521:25 - no changes are necessary there but we do
521:27 - need a new we do need a new query this
521:29 - one's going to be called
521:32 - yet next
521:34 - oh my gosh get next feed to fetch can't
521:38 - type today get another speed to fetch
521:40 - and it will return a single row
521:43 - and this one should say select star
521:46 - from feeds
521:49 - order by
521:52 - last fetched at
521:54 - descending nulls first
521:58 - limit
522:00 - one
522:01 - okay so we always this the purpose of
522:05 - this function is to go get the feed that
522:07 - next needs to be fetched like we need to
522:11 - go get posts for this feed next and the
522:14 - whole idea is
522:16 - first we want to go find any feeds that
522:18 - have never been fetched before those
522:20 - need to take priority after that if
522:23 - every feed has been fetched then we want
522:25 - to go find the one that was fetched the
522:27 - longest ago like the farthest in the
522:30 - past right so we're ordering by last
522:32 - fetched at nulls first in descending
522:36 - order
522:37 - actually scratch that we're going to
522:39 - want to do
522:41 - ascending right ascending would put the
522:44 - lowest the smallest time stamps right
522:47 - the ones further in the past at the top
522:49 - and then Ascend into the present okay so
522:53 - order by last fetch that ascending nulls
522:56 - first perfect
522:57 - okay just to make sure that my SQL code
523:00 - is valid we'll generate that looks good
523:03 - okay next we need one more query this
523:05 - one will be called
523:07 - Mark feed fetched
523:10 - Arc feed I guess as fetched
523:14 - this is one we'll call after we fetch a
523:15 - feed to say that we fetched it and we'll
523:18 - return the updated feed
523:20 - okay so it's going to be update
523:23 - feeds
523:25 - set
523:26 - last fetched at equal to now
523:30 - and update it at also equal to now so we
523:36 - haven't really gone over this but the
523:37 - updated and created that feels are
523:39 - mostly for auditing purposes it's pretty
523:41 - standard practice to set these fields on
523:44 - basically every record in an SQL
523:46 - database just so you can see when
523:48 - they've been created and updated it's
523:50 - kind of again auditing purposes
523:53 - okay where
523:56 - ID equals dollar sign one
524:00 - and
524:03 - returning star
524:06 - okay so we update the feeds we set the
524:09 - last fetch that and the updated at to
524:11 - the current time
524:12 - for the given ID that looks good to me
524:15 - let's go ahead and generate that
524:16 - perfect next we need a way to kind of
524:20 - take an RSS URL or a feed URL and parse
524:23 - it into an actual response body and in
524:27 - this case we're going to represent it as
524:28 - a struct let me show you what I mean so
524:31 - let's create a new file I'm just going
524:32 - to call it rss.go
524:36 - and it's going to be part of the main
524:38 - package
524:40 - and we need a new function and we're
524:43 - going to call it RSS to
524:46 - or actually let's call it url
524:49 - url to feed
524:52 - okay
524:54 - and it's going to take as input a URL
524:58 - which is just a string
524:59 - and it will return a new type so we need
525:02 - to specify the new type type
525:04 - RSS feed
525:09 - it will return both an RSS feed and
525:12 - potentially an error if there's
525:13 - something wrong with the request that
525:15 - it's making
525:16 - now that RSS feed struct that we just
525:19 - created is going to represent basically
525:21 - this giant this giant document here
525:25 - right so if you go to
525:26 - wagslane.dev
525:28 - index.xml which is a valid RSS feed then
525:31 - you'll see this giant document and
525:34 - really you can think of RSS as just a
525:37 - structured data in XML format and XML is
525:40 - just kind of like crappy Json so the way
525:43 - we parse XML in go is very similar to
525:46 - The Way We parse Json let me show you
525:49 - what I mean I've done the Dirty Work of
525:51 - scanning all of the valid values in that
525:54 - big RSS document and I found that
525:58 - basically these are the keys
526:01 - um for the RSS entries in my blog so RSS
526:06 - is kind of a standardized set of keys
526:09 - within XML and basically what I'm saying
526:12 - is these are the keys that we care about
526:14 - right at the top level of an RSS feed we
526:16 - expect a channel key right in the XML
526:20 - document and we expect a channel to have
526:22 - a title a link a description a language
526:24 - and then a slice of items and then items
526:28 - are kind of these nested objects that
526:30 - each have their own title link
526:31 - descriptions and publication dates right
526:34 - and each item is a new blog post and if
526:37 - you're asking how I came up with those
526:40 - names of all of the different Keys it's
526:42 - because I went and looked here in this
526:43 - document I saw okay at the top level we
526:45 - have a channel right and then we have
526:47 - this entry with a title a link a
526:51 - description right so I just kind of
526:52 - manually looked through this document
526:54 - and found all the stuff that I wanted to
526:56 - parse out so let's fill in the rest of
526:58 - this URL to feed function so first we're
527:01 - going to need an HTTP client I'm just
527:04 - creating a new client using the HTTP
527:06 - Library um we'll set it to a timeout of
527:08 - 10 seconds if it takes more than 10
527:09 - seconds to fetch an RSS feed we don't
527:12 - want that feed anyway probably broken
527:14 - okay uh then we can use that client to
527:17 - make a get request to
527:20 - the URL of the feed
527:22 - and that's going to return an HTTP
527:24 - response and potentially an error
527:28 - if there's an error we'll just return
527:30 - let's just do
527:34 - um for cons for ease of use I'm going to
527:36 - make this a pointer to an RSS feed so we
527:38 - can just return nil and the error
527:42 - cool
527:43 - um if everything's okay then we're going
527:45 - to defer a close
527:48 - on let's close on the rest sorry it's
527:52 - not it's not the close function it's
527:53 - resp.body Dot close
527:58 - okay and then after that we want to get
528:01 - all of the data from the response body
528:03 - so it's going to be io.read all we have
528:06 - to read everything from
528:08 - resp dot body and that comes back as a
528:12 - slice of bytes and an error
528:18 - okay this slice of bytes we want to read
528:22 - into
528:24 - this RSS feed so dealing with XML in go
528:28 - is very similar to dealing with Json and
528:32 - go it's actually going to be XML Dot
528:37 - unmarshall pass in the data and a
528:41 - pointer
528:42 - to where we want to unmarshul today so
528:44 - actually I need to create an empty
528:45 - struct we need RSS feed
528:48 - is an empty RSS feed struct
528:52 - then we'll unmarshall into that location
528:55 - in memory
528:57 - that will return an error
529:01 - if everything goes well then we can just
529:03 - return the new populated RSS feed
529:11 - perfect now as I type this out I'm
529:14 - already kind of dissatisfied with this
529:16 - pointer solution I don't think that
529:17 - needs to be a pointer I think we should
529:18 - just
529:19 - return empty structs
529:22 - either way would work I think this is a
529:25 - little cleaner though because it means
529:27 - the user of this function us right we'll
529:30 - get an actual RSS feedback and not a
529:32 - pointer to an RSS feed
529:34 - okay let's go ahead and test this really
529:36 - quick I'm just going to do a little kind
529:38 - of hacky thing
529:41 - just right at the top of main I'm going
529:42 - to call URL to feed and give it the URL
529:46 - of
529:48 - um my blog so wagslane.dev
529:51 - slash index dot XML
529:54 - that should return a feed
529:57 - and an error
529:59 - right and then if error not equal nil
530:04 - blog dot fatal
530:07 - error otherwise I want to just print out
530:10 - fmt Dot
530:12 - print line let's just print out the
530:14 - whole feed it'll be disgusting but at
530:17 - least we'll get to see if it kind of
530:18 - worked
530:19 - okay let's build and run that
530:30 - there we go
530:33 - cool so if you kind of scroll through
530:35 - this you'll see it looks like I mean
530:37 - there was no errors and then it looks
530:39 - like we properly
530:42 - at least you know at first glance looks
530:44 - like we properly filled out that struct
530:46 - it's kind of just dumping all of the
530:48 - data
530:49 - so now that we've done a sanity test on
530:51 - our URL to feed function let's go write
530:54 - the actual scraper
530:56 - create a new file just call this
530:58 - scraper.go
531:00 - again in the main package
531:04 - okay
531:05 - um the scraper is a long running job so
531:08 - this scraper function is going to be
531:10 - running in the background as our server
531:13 - runs so we'll let's name it something
531:15 - like start scraping
531:18 - and let me split up these parameters so
531:21 - we can really see so we can actually see
531:23 - what uh
531:24 - what we're dealing with here so it'll
531:26 - take three inputs a connection to the
531:28 - database
531:30 - um a number of concurrency units I guess
531:34 - the best way to think about this is how
531:36 - many different go routines we want to do
531:38 - the scraping on
531:40 - and then how much time we want in
531:43 - between each request to go scrape a new
531:46 - RSS feed
531:48 - cool and it shouldn't return anything
531:50 - because this is going to be a
531:51 - long-running job now because this worker
531:54 - this scraper is going to be running in
531:55 - the background of our server I think
531:57 - it's really important that we have good
531:58 - logging that kind of tells us what's
532:01 - going on as it's happening so when we
532:04 - start scraping I'm going to do a little
532:06 - log message here so log dot printf
532:10 - we'll say
532:11 - scraping
532:14 - on percent
532:16 - the go routines
532:19 - every
532:20 - percent s duration
532:24 - as in the concurrency and the time
532:27 - between requests
532:29 - cool after that we need to figure out
532:32 - like how we're going
532:34 - to make our requests on this interval
532:37 - and there's a really cool
532:39 - um mechanism in the standard library and
532:41 - go called a ticker so we can create a
532:44 - new ticker uh using the standard Library
532:46 - so time dot new ticker and we give it a
532:49 - duration in this case time between
532:51 - requests
532:54 - and it responds with a ticker
532:57 - and then we can use a for Loop
533:01 - to execute the body of the for Loop
533:04 - every time a new value comes across the
533:08 - e-ticker's channel so the ticker Has a
533:10 - Field called C which is a channel where
533:14 - every
533:15 - kind of let's say that you know time
533:17 - between requests was set to one minute
533:19 - in that case every one minute a value
533:22 - would be sent across the channel so by
533:24 - using this syntax here we could say run
533:26 - this for Loop every one minute and the
533:29 - reason I'm passing in an empty
533:32 - initialize and an empty middle section
533:35 - to the for Loop is so that it executes
533:37 - immediately the first time so the very
533:39 - first time we get to line 17 the body of
533:42 - the for Loop will request will will fire
533:44 - immediately
533:45 - and then it will wait for the for the
533:49 - interval on the ticker if that makes
533:51 - sense if we just did this
533:53 - oops if we just did what is it for range
533:58 - ticker.c uh then it would actually wait
534:00 - for the minute up front but I want to do
534:02 - it once immediately it'll make it easier
534:05 - to debug and work with now at this point
534:07 - I realize that I've made a mistake
534:09 - the purpose of this concurrency
534:11 - parameter here is to you know indicate
534:14 - to the start scraping function how many
534:16 - go routines we want to use to go fetch
534:19 - all of these different feeds and the
534:22 - whole point is that we can fetch them at
534:23 - the same time so that means that each
534:26 - time that this ticker fires we need to
534:28 - be potentially go you know going it out
534:30 - to the internet to fetch 10 20 30
534:33 - different RSS feeds and download all of
534:36 - their blog posts at the same time which
534:39 - means we'll actually need to be able to
534:40 - grab a a multiple number of feeds we'll
534:44 - need to grab more than just one at a
534:47 - time so rather than get next feed to
534:49 - fetch let's change this to get next
534:51 - feeds to fetch and we'll have it return
534:54 - many and then rather than limiting to
534:56 - one let's limit to dollar sign one so we
534:59 - can actually pass in how many feeds we
535:02 - want as a parameter to this function
535:05 - okay then we should be able to
535:07 - regenerate that
535:13 - and we should oh we're not even using
535:16 - the function yet so okay so that was
535:18 - actually the perfect time to do that
535:19 - okay let's fill out the body of this for
535:21 - Loop so every Interval Timer tweet
535:24 - request we want to go grab the next
535:26 - batch of feeds to fetch so we can just
535:28 - call that function that we just wrote
535:30 - database dot get next feeds to fetch
535:33 - it takes a context and a limit so the
535:37 - first thing we'll just use context dot
535:40 - background
535:41 - so again I haven't gone into a ton of
535:43 - detail on the context passage but
535:45 - basically context dot background is like
535:47 - the global context it's what you use if
535:50 - you don't have access to a scoped
535:51 - context like we do for our individual
535:54 - HTTP requests
535:55 - okay so that'll work for now and then we
535:58 - also need to pass in a limit so we'll
536:00 - just cast into 32 and the limit or the
536:04 - sorry the concurrency
536:09 - and that should return some feeds and an
536:12 - error
536:16 - if there's an error we should probably
536:18 - print something
536:31 - now notice I'm continuing here that's
536:33 - because this function should always be
536:36 - running as our server
536:39 - operates like there's no time in which
536:42 - we want this function to ever stop so if
536:44 - I returned here that would be a problem
536:45 - it would actually stop scraping
536:47 - completely just because maybe I don't
536:49 - know our database connection was down
536:50 - temporarily so for now we're just going
536:52 - to log and continue now that we have a
536:55 - slice of feeds let's write some logic
536:57 - that goes and fetches each feed
536:59 - individually and importantly fetches
537:02 - each individually at the same time so
537:05 - we're going to need a synchronization
537:06 - mechanism I'm going to use a weight
537:08 - group so the standard library has this
537:11 - awesome thing called a sync.weight group
537:16 - and we can iterate over all of the fees
537:18 - so four feed range feeds
537:25 - okay so the way that the weight group
537:27 - works is anytime you want to spawn a new
537:31 - go routine within the context of the
537:33 - weight group you do a weight group dot
537:35 - add
537:36 - and you add some number to it so here
537:39 - I'm iterating over all of the feeds that
537:41 - we want to fetch on individual go
537:43 - routines and I'm going to add one to the
537:45 - weight group
537:47 - then at the end of the loop I can do a
537:50 - weight group dot weight
537:53 - and within the loop I can spawn a new go
537:57 - routine so we're going to go do some
538:00 - function in fact I guess I should just
538:01 - name it kind of what we'll be doing uh
538:04 - let's call it scrape feed go scrape
538:08 - feed
538:09 - and here we're actually going to pass
538:11 - the weight group in as one of the
538:14 - parameters
538:15 - and within
538:18 - scrape feed
538:21 - takes a weight group which is a pointer
538:23 - to a sink
538:25 - weight group
538:29 - within this function we'll defer a
538:31 - weight group dot done
538:34 - okay
538:35 - so what happens here basically
538:39 - we're iterating over the the all of the
538:41 - feeds on the same go routine as the you
538:45 - know the start scraping function so on
538:48 - the main go routine
538:50 - on the main go routine we're adding one
538:52 - to the weight group for every feed right
538:55 - so say we had a concurrency of 30 we
538:58 - would be adding 30 to the weight group
539:01 - now we'll be spawning all of these
539:04 - separate go routines as we do that and
539:06 - when we get to the end of the loop we're
539:08 - going to be waiting on the weight group
539:10 - for 30 30 distinct
539:15 - calls to done so done effectively
539:19 - decrements the counter by one right done
539:22 - decrements the counter by one so we're
539:24 - adding one every time we iterate over
539:26 - the slice and then we're calling done
539:29 - when we're done actually scraping the
539:31 - feed so what this does is it allows us
539:33 - to call scrape feed at the same time 30
539:37 - times we go spawn 30 different go
539:39 - routines to scrape 30 different RSS
539:42 - feeds
539:43 - and when they're all done
539:45 - line 35 will kind of execute and will
539:49 - move past that until they're like before
539:51 - they're done we'll be blocking on line
539:53 - 35 which is what we want to do because
539:55 - we don't want to continue on to the next
539:57 - iteration of the loop until we are sure
540:00 - that we've actually scraped all of the
540:02 - feeds
540:03 - so we've sort of stubbed out the scrape
540:05 - feed function right now it doesn't do
540:06 - anything other than call weight group
540:08 - dot done let's actually go scrape some
540:10 - feeds
540:11 - so it's going to need access to a
540:13 - database connection
540:15 - and it's also going to need a specific
540:17 - feed to go fetch so feed is a data base
540:21 - dot feed
540:24 - cool and then here we can pass in
540:26 - database and speed
540:30 - great the first thing scrape feed should
540:33 - do and and keep in mind we're deferring
540:35 - the weight group dot done so this will
540:37 - always be called at the end of this
540:38 - function
540:41 - um the first thing we should do is Mark
540:42 - that we've fetched this feed or that
540:44 - we're fetching this feed so it's going
540:46 - to be database.mark feed as fetched we
540:49 - can just use the background context
540:51 - again
540:53 - and we need the ID of the feed so feed
540:56 - Dot ID
540:58 - cool that should return an error if
541:01 - there was an error I think oh it also
541:03 - Returns the updated feed I don't think
541:05 - we care about the updated Feats I think
541:06 - we can ignore that
541:09 - say if error is not equal nil now keep
541:12 - in mind we're not returning anything
541:13 - from this function remember we're
541:15 - calling it on a new go routine so
541:16 - there's nothing to return here if
541:18 - there's an error instead we'll just log
541:19 - there was an issue
541:30 - and return nothing and next we need to
541:34 - actually do the heavy lifting which is
541:35 - to go out and scrape the feet so we
541:37 - already wrote Our URL to feed function
541:39 - let's just use that
541:41 - so URL to feed and we'll pass in the
541:45 - feed dot URL and we should get back an
541:48 - RSS feed and an error
541:53 - and if error does not equal nil
542:01 - error fetching feed
542:07 - and we'll return there
542:10 - otherwise we need to do some
542:14 - logging so in the future what we'll do
542:17 - is instead of iterating over all of the
542:20 - items in the RSS struct that we get back
542:24 - and just printing them to the console
542:25 - we'll be saving them into the database
542:27 - but for now just so that we can test our
542:30 - scrape feed function we're just going to
542:33 - log log all of this to the console so
542:35 - we're going to log each individual post
542:38 - or rather that we found a post and then
542:41 - how many posts we found the last thing
542:44 - we need to do is go hook up this start
542:46 - scraping function to our main function
542:48 - so that it actually starts okay so start
542:51 - scraping takes database concurrency
542:53 - actually I'll just open this up my
542:55 - screen's too small to be working in two
542:57 - tabs at the same time
542:59 - okay
543:00 - um we're going to need to call it before
543:02 - listen and serve because remember this
543:04 - is where our server kind of blocks and
543:07 - waits forever for incoming requests so
543:09 - we should probably call it I don't know
543:11 - right
543:13 - here seems like a good spot
543:16 - so
543:18 - um
543:19 - it's just a function right yeah it's not
543:21 - a method takes database concurrency and
543:23 - time between requests okay
543:25 - so we go go start scraping remember we
543:28 - want to call it on a new go routine so
543:30 - it doesn't interrupt this main flow
543:32 - because remember start scraping is never
543:34 - going to return it's a long running
543:36 - function this is an infinite for Loop
543:39 - okay
543:40 - it needs a database connection so we'll
543:42 - actually need to save this in
543:45 - a new variable so that we can use it in
543:48 - the API config and in the start scraping
543:50 - function
543:52 - next we need the concurrency
543:54 - um
543:55 - let's just start with 10. seems good and
543:58 - then time between requests let's do time
544:00 - dot minute
544:03 - perfect
544:04 - I went ahead and added a second RSS feed
544:06 - so let's go ahead and check the database
544:08 - and see what feeds we have currently
544:11 - so I've got Lane's blog and the boot Dev
544:13 - blog so there's two now remember when
544:15 - you're setting a concurrency of 10 so we
544:18 - should definitely be able to fetch both
544:20 - of these blogs at the same time on the
544:22 - first iteration of that Loop if we say
544:25 - deployed this to production and allowed
544:26 - users to start creating feeds maybe we'd
544:28 - get up to 100 200 400 different feeds in
544:32 - here then we'd only be fetching 10 at a
544:34 - time right just so we understand how
544:35 - that mechanism works but for now this
544:37 - should be good enough to test I'm going
544:39 - to update our logs just a bit so we can
544:42 - see which blog
544:43 - each post is from so found post
544:45 - item.title
544:48 - on feed
544:50 - .name okay let's go ahead and run that
545:01 - found Post Properties of pointers and go
545:03 - on feed boot Dev blog perfect kind of
545:07 - scroll up we should be able to see some
545:09 - the boot Dev Blog has way more blog
545:12 - posts than my personal blog here it is
545:15 - here's some Lanes blog stuff okay so
545:18 - that looks like it's working we should
545:20 - be able to move on to the next step now
545:21 - where we'll actually save these blog
545:24 - posts into the database rather than just
545:26 - logging the titles to the console we're
545:29 - going to need a new table in our
545:31 - database so let's start there
545:33 - we'll call it posts
545:35 - so the purpose of this table is to store
545:38 - all of the posts that we are fetching
545:39 - from all the different uh from all the
545:42 - different RSS feeds
545:44 - okay
545:45 - um what am I doing this is this is
545:47 - queries we need to start with a
545:48 - migration
545:49 - so let's grab this we'll make it zero
545:52 - zero six
545:55 - posts dot SQL
545:58 - all right Goose up is going to be create
546:01 - table posts
546:03 - what goes in a posts table
546:06 - um we are going to need an ID to create
546:08 - that and update it that pretty much
546:09 - never changes
546:11 - um what else does a post have well it
546:13 - has a title
546:16 - right title
546:19 - um is that text Dot null that makes
546:21 - sense uh posts also typically have a
546:23 - description
546:25 - text I'm going to allow that one to be
546:27 - nullable I think it's okay if a post is
546:28 - missing its description
546:30 - posts also typically have a published at
546:33 - date published
546:36 - at it's a time stamp
546:38 - um should we allow that one to be
546:39 - nullable
546:41 - no no let's make that not null
546:44 - what else does a post have it has a URL
546:48 - a URL should be not null for sure
546:53 - um I'm also going to say that it should
546:54 - be unique
546:56 - unique
546:58 - I don't think we ever want to store the
547:01 - same Post in the database twice
547:04 - there's no point right if we have a post
547:06 - I don't see why we would need it a
547:08 - second time so let's let's go ahead and
547:10 - make that one unique
547:11 - and then lastly let's just put in a feed
547:13 - ID
547:16 - and the feed ID is going to be a uuid
547:18 - that uh
547:22 - we're going to want it to be a reference
547:24 - of references
547:27 - um feeds ID
547:29 - right
547:31 - and that's going to be
547:33 - does that need to be unique
547:35 - it doesn't need to be unique but it
547:36 - should be not null we should always have
547:38 - the feed ID of a post and let's here put
547:43 - on delete Cascade if we delete a feed
547:46 - we'll Cascade and delete all of its
547:47 - posts and I forgot to put the type here
547:49 - so URL text not null unique okay that
547:53 - looks good to me let's go ahead and run
547:54 - our migration so it's going to be we
547:57 - need a CD into
547:59 - SQL schema and run goose postgres
548:07 - we'll need this connection string
548:12 - up
548:15 - perfect
548:16 - next we'll need a couple of queries to
548:18 - interact with this table the first one
548:19 - is going to be just a way to create a
548:21 - post so posts and we'll do
548:26 - create
548:27 - oops
548:29 - free post
548:30 - return one thing
548:32 - and we'll just kind of be inserting a
548:35 - bunch of stuff I think let's take a look
548:37 - at the post table so we've got ID
548:38 - created at updated let me just grab this
548:40 - so I don't forget it
548:48 - okay
548:49 - so insert into posts
548:52 - ID created at updated at
548:55 - we also have we have a lot of stuff so
548:57 - I'm actually going to start spacing this
548:59 - out a little bit
549:01 - create it at updated at it's going to be
549:03 - a title
549:06 - and
549:08 - the description
549:15 - publish that
549:17 - URL
549:19 - and a feed ID
549:23 - okay and the values one two three four
549:27 - how many do we got
549:29 - just eight
549:31 - five
549:33 - six
549:35 - seven
549:37 - eight
549:38 - returning star
549:41 - straightforward right insert into posts
549:43 - all of these fields
549:45 - no fancy logic that should be good okay
549:48 - let's run sqlc generate
549:51 - add that function to our internal
549:54 - package and then we just need to go use
549:56 - it so down in the scraper now instead of
549:59 - just logging all of these posts to the
550:02 - console let's save them to the database
550:04 - I'm going to leave this log message it
550:06 - says feed blank collected blank posts
550:09 - found so that'll just log all of the
550:11 - different feeds we're collecting but
550:13 - each individual post I think it's
550:14 - wasteful and kind of busy to log
550:17 - everything so we're not going to do that
550:18 - instead we'll just call DB dot create
550:20 - post
550:22 - context.background
550:25 - and what does it take create postparams
550:29 - database dot create post params okay
550:30 - cool I kind of like how sqlc
550:34 - breaks down the parameters into
550:37 - um
550:37 - into a struct makes it pretty simple to
550:40 - work with
550:41 - okay
550:42 - um we've got an ID created updated that
550:45 - okay ID is just going to be a new ID
550:53 - created that updated that that'll just
550:55 - be time.now
550:57 - dot UTC
551:06 - what's next title description idle
551:15 - item.title
551:18 - I just realized oh I just realized now
551:20 - that I'm not putting the field names
551:22 - kind of embarrassing
551:27 - okay title description
551:34 - do they not have a description what does
551:36 - an item have
551:39 - let's take a look at an item
551:42 - items have title link description yeah
551:45 - it does have a description what am I
551:46 - messing up here
551:48 - can I use item.escription variable of
551:50 - type string as sql.null string ah right
551:52 - okay
551:53 - so we need to do sql.null string
551:56 - a null string has the string itself and
551:58 - whether or not it's valid so we just put
552:01 - in the string
552:02 - and then we say it is valid string dot
552:05 - valid is Boolean true
552:09 - although actually this is a problem
552:10 - right this is a problem because if
552:12 - item.description is blank if it's an
552:14 - empty string we're going to be putting
552:16 - in an empty string and saying that it's
552:18 - there even though it's not so let's not
552:22 - do this
552:23 - let's do something a little different
552:26 - let's go
552:28 - description
552:30 - it's a new sql.null string
552:36 - why is why is that giving me trouble
552:39 - oh because I'm doing it within the call
552:41 - to create post do it right here
552:43 - okay so we'll create a new sql.null
552:46 - string and then we'll say
552:49 - if item dot description does not equal
552:53 - the empty string
552:55 - then we get to set description dot
552:58 - string equal to item.description
553:01 - and description dot valid
553:05 - equals true
553:07 - and then we'll use the description here
553:09 - does that make sense so if if the item's
553:12 - description is blank then we'll set the
553:14 - value to null in the database
553:15 - effectively
553:17 - otherwise we'll create the valid
553:21 - description entity
553:24 - okay next we need a published at
553:28 - let's see we've got an item dot Pub date
553:31 - which is a string okay so we're going to
553:32 - need to parse that string to parse that
553:35 - date there is a Time dot parse function
553:38 - in the standard library and we're going
553:40 - to use this RFC one one two three Z
553:43 - layout so this is the layout that I'm
553:46 - using on the boot Dev blog and on my
553:48 - blog to be more robust and support all
553:51 - of the different publishing formats for
553:53 - all the different blogs that we want to
553:55 - scrape we'd probably need to make this
553:57 - logic a little bit more robust but for
553:59 - now
554:00 - I'm just going to say we're parsing it
554:03 - this way if it's not that way I guess we
554:05 - take a hike okay
554:08 - if there's an error so if error does not
554:10 - equal nil
554:13 - we can say log dot print line
554:18 - couldn't parse date
554:24 - sent V with error
554:27 - sent V
554:28 - and we'll pass in the actual Pub date
554:32 - and an error and that's going to be a
554:35 - printf
554:36 - oops
554:37 - cool and then if that's an issue we'll
554:39 - just continue so if we don't get a valid
554:41 - time uh then we'll just we'll just log
554:44 - it log in move on
554:46 - okay so published at pass in that I
554:50 - shouldn't use single name variables like
554:51 - this let's do
554:53 - up at
554:57 - okay
554:58 - what else do we got a URL and a feed ID
555:00 - so URL
555:02 - is just going to be the item.link
555:06 - and feed ID
555:08 - do we have access to the feed ID here
555:12 - we do we have the feed right because we
555:14 - passed in the feed here
555:18 - e dot ID
555:22 - now db.createpost does return an error
555:25 - so we need to handle that error
555:28 - what am I screwing up here
555:31 - oh it also Returns the post itself
555:33 - I don't think we care about the new post
555:35 - though I think all we care about is if
555:36 - it failed so if error
555:39 - equal nil
555:48 - ton create post with error
555:52 - okay let's give that a shot okay build
555:55 - and run
555:58 - now remember we're expecting this time
556:00 - to get logs that just say that the blogs
556:02 - were collected so 21 posts from Lane's
556:05 - blog 321 posts from the boot Dev blog
556:07 - were collected I'm going to go ahead and
556:09 - kill the server and let's check PG admin
556:13 - so now if we select star from Posts
556:16 - you should see a bunch of stuff in here
556:19 - IDs created at titles descriptions
556:23 - published at dates
556:25 - awesome this is looking fantastic
556:28 - we scroll down to see how many rows
556:30 - there are 342. that looks right to me
556:32 - now I think we have an issue here let me
556:36 - show you what I mean if we run this
556:37 - again so remember we've scraped both of
556:39 - the feeds and pulled in all of the posts
556:41 - so if I rerun my server at this point
556:45 - yeah we're getting all of these issues
556:48 - failed to create posts duplicate key
556:50 - value violates unique constraint posts
556:52 - URL key right now this makes sense we
556:55 - didn't want to store duplicate posts in
556:57 - our database so we have a unique
556:59 - constraint on the post URL which means
557:01 - when we go try to recreate the posts it
557:04 - fails because we already have the posts
557:06 - in our database
557:07 - so let's do a little string uh string
557:10 - detection so that we don't log this crap
557:13 - every time this happens because this
557:15 - isn't really an error this is expected
557:17 - Behavior so we can do something like if
557:22 - strings dot contains
557:25 - air dot error
557:28 - uh duplicate duplicate
557:32 - e
557:36 - then do we continue what are we doing
557:39 - here
557:40 - then we continue
557:43 - otherwise we'll log the air so we're
557:45 - only going to log the error if it's not
557:48 - a duplicate key error okay so let's run
557:51 - that again and make sure we don't get
557:54 - those errors
557:56 - perfect
557:57 - we have one last feature to add to our
558:00 - RSS aggregator we need a way for users
558:02 - to be able to get a list of all of the
558:04 - newest posts from the feeds that they're
558:07 - following so we'll need a new query
558:10 - we can call this one
558:15 - get posts for user and it will return
558:19 - many posts
558:21 - now let's think about this query for a
558:22 - second it's a little more complex than
558:23 - the other queries we've done in that I
558:25 - think we need to do a join so we have
558:27 - our posts table
558:30 - right posts have IDs created ad updated
558:32 - at but importantly they have a feed ID
558:34 - so we know what feed every Post in the
558:37 - database belongs to and we also have a
558:40 - feed follows table that tells us which
558:43 - feeds an individual or user is following
558:46 - so if we join those two tables together
558:49 - right if we take all of the feed follow
558:51 - information kind of join it to the posts
558:54 - table then we should be able to filter
558:56 - by all of the feeds that a user is
558:59 - actually following so what does that
559:01 - look like
559:03 - you do select
559:06 - hosts.star so everything from the post
559:09 - table
559:10 - ROM posts
559:13 - join
559:15 - feed follows
559:18 - on
559:20 - oops on post dot feed ID
559:24 - equals feed follows dot feed ID
559:29 - okay so this adds essentially all the
559:31 - feed follow information to our like the
559:34 - virtual table for this query right we're
559:37 - joining those two tables together so now
559:38 - we should be able to filter
559:40 - um the way we want Okay so we've we've
559:43 - joined them together where
559:46 - posts dot wait post no where feed
559:51 - follows dot user ID
559:54 - equals
559:56 - dollar sign one
559:58 - okay so we join the tables and then we
560:00 - filter all the posts down or rather the
560:03 - entire table down by the specific user
560:06 - ID so all of the posts that belong to
560:08 - feeds that the user is not following
560:10 - should at this step get trimmed out
560:15 - then we can order by let's do Post dot
560:19 - published at descending so give us the
560:21 - newest stuff first
560:24 - and we'll limit by a configurable amount
560:27 - so dollar sign two
560:29 - cool
560:31 - let's go ahead and try to generate that
560:34 - looks like it worked let's see if uh see
560:37 - if when we run the actual application it
560:39 - does what we expect let's hook that
560:41 - query up to a new endpoint so I'm here
560:44 - in the users file that seems like a
560:46 - reasonable place we'll do Handler
560:50 - get posts for a user
560:53 - it will be an authenticated endpoint so
560:55 - we'll need that that user data but here
560:58 - we're going to call DB dot or sorry API
561:02 - config
561:03 - dot DB dot get
561:06 - hosts for user and then we can pass in
561:09 - the
561:10 - request.context and user dot ID
561:15 - oh we also need I think a limit
561:18 - oh get no no sorry we take we take
561:21 - database dot get post for user params
561:24 - right because we have multiple
561:25 - parameters here so we'll need the user's
561:27 - ID and a limit the user dot ID and for
561:31 - now let's just say a limit of 10. and
561:33 - that will return to us some posts and
561:35 - potentially an error
561:38 - if we get an error
561:40 - we'll respond with it
561:43 - couldn't get posts
561:46 - otherwise we need to return the post
561:48 - themselves now we should go create
561:52 - a special posts model right so that we
561:56 - get our
561:57 - our own tag so type post struct
562:00 - go mostly copy this from
562:04 - our internal
562:06 - host model
562:08 - wherever it ended up here it is
562:15 - okay
562:17 - add some Json tags
562:28 - goodness typing is hard
562:47 - now here's an interesting thing
562:50 - this sql.null string is not something
562:54 - that we're going to want to use in this
562:58 - struct because this is a struct that
562:59 - Marshals to Json the null string object
563:03 - is a nested struct so if we marshaled it
563:06 - directly to Json we would actually get
563:08 - description as a Json key and then
563:10 - string as a Json key and then valid as a
563:13 - Json case would be a little nested
563:14 - object there that's pretty bad user
563:17 - experience because Json natively
563:19 - supports kind of null in the sense that
563:21 - you can just omit the key or use like
563:25 - the actual value null so what we're
563:28 - going to do is instead do a pointer to a
563:31 - string
563:32 - and the way Json marshalling and go
563:35 - works is if you have a pointer to a
563:36 - string and it is nil then it will
563:39 - Marshal to what you'd expect in Json
563:40 - land which is that null value
563:43 - okay then published at
563:49 - URL
563:53 - and feed ID
563:56 - okay did I miss anything let me look
563:58 - over this really quick
564:00 - that's looking good
564:03 - and next we need the conversion so we'll
564:07 - do
564:09 - database post to post
564:44 - now this one gets a little hairy right
564:46 - we probably need to do some logic here
564:48 - so we'll say
564:50 - bar
564:52 - description pointer to a string
564:56 - and then if DB post dot description dot
565:00 - valid
565:02 - then we'll set description equal to
565:06 - the address of dbpost.description.string
565:10 - cool then we can just directly use the
565:13 - description variable there
565:16 - all right published at
565:25 - what else we got URL and feed ID
565:34 - okay and last but not least we need a
565:36 - way to do it uh do the conversion for an
565:38 - entire slice
565:40 - bunk DB
565:42 - database posts to posts
565:58 - and the logic will look
566:00 - pretty much identical to that but I
566:02 - actually think it'll be easier to type
566:03 - it out so we'll do uh
566:05 - posts slice post
566:25 - database post post
566:28 - s in the database post
566:33 - okay
566:35 - there we go
566:38 - a lot of conversion logic there
566:40 - but now we should be good to just
566:42 - respond with some Json
566:45 - and we can pass in
566:48 - those posts as database posts
566:51 - cool what am I getting here
566:54 - struck literally uses unkeyed Fields oh
566:56 - yeah let's not do that
566:59 - we want an ID
567:02 - and I think it's a limit
567:07 - right what am I messing up user ID
567:11 - perfect
567:13 - okay let's build and run the server
567:15 - again
567:19 - oh I realize I made a mistake I need to
567:21 - actually hook this up to something so
567:23 - let's go back into main.go
567:27 - we need a new endpoint
567:29 - we'll do get
567:33 - I don't know user feed
567:37 - now feeds probably a loaded term in this
567:39 - uh in this application we should say
567:41 - let's just do posts
567:43 - and it's going to require middleware so
567:46 - middleware off
567:48 - and API CFG Dot
567:52 - Handler get posts for user okay so get
567:56 - slash posts it's an authenticated
567:58 - endpoint Perfect all right let's rebuild
567:59 - and run that
568:03 - okay
568:06 - opening up thunderclient
568:10 - first we need to check
568:12 - well actually let's just grab some auth
568:16 - information so
568:18 - um
568:20 - this clearly has some off
568:24 - let's grab that API key create a new
568:27 - request
568:28 - HTTP colon localhost
568:34 - V1 posts
568:38 - headers close that
568:41 - authorization
568:43 - API key okay
568:46 - so
568:47 - if I make that request I'm getting back
568:49 - no posts now we know we have posts in
568:51 - the database but my my user that I'm
568:53 - currently logged in as is not following
568:56 - anything
568:58 - all right I'm getting back the empty
569:00 - array when I
569:02 - when I check my feed follows
569:04 - um but I can check which feeds Exist by
569:07 - running this API request
569:10 - so let's grab this feed let's grab the
569:13 - Wags Lane feed and let's go follow that
569:16 - one
569:17 - so we'll post to feed follows here
569:20 - this feed ID
569:23 - okay so now I should be following let's
569:25 - check my feed follows
569:28 - great I'm following them so now if I go
569:31 - get my posts
569:36 - there we go
569:38 - I should just be getting posts
569:41 - from the wagslane.dead block
569:46 - perfect let's try following
569:49 - let's try following um
569:52 - the other one
569:53 - so
569:56 - where is it feed follows no feeds
570:00 - let's try following the boot Dev blog as
570:02 - well
570:03 - so post
570:05 - feed follows
570:09 - send that check my feed follows now I'm
570:12 - following both
570:13 - now if I go get my posts
570:17 - perfect we're seeing stuff from the boot
570:18 - Dev blog
570:19 - that's it
570:21 - thank you for sticking with me through
570:24 - all of this mess we've created an
570:27 - amazing blog aggregator that will
570:29 - actually work pretty darn well at scale
570:32 - you could run this thing uh you know
570:34 - over a long period of time collect
570:36 - millions of blog posts and it would do
570:39 - pretty well I hope you had a ton of fun
570:42 - with this project I do want to remind
570:44 - you that this is a server right we've
570:48 - kind of been running it stopping it
570:49 - restarting it but at the end of the day
570:51 - you can just turn it on ADD new feeds
570:55 - and follows and interact with it
570:57 - directly and it will once a minute go
570:59 - out and collect all of those blog posts
571:02 - so you could just keep this running on a
571:04 - Raspberry Pi in your house to aggregate
571:06 - you know blog posts podcasts all that
571:10 - kind of stuff
571:11 - um I will point out that we have done a
571:13 - bit of happy path programming so happy
571:15 - path programming is when you're not
571:17 - necessarily handling every Edge case out
571:20 - there you're you're handling kind of you
571:22 - know the thing that you expect to happen
571:23 - most of the time so for example um we
571:26 - only had one type of date parsing for
571:29 - the published at dates in our RSS feeds
571:32 - but maybe there are RSS feeds out there
571:34 - that use a different date format and
571:36 - will fail to parse them
571:38 - um so one way that you could extend this
571:39 - project would be to just add a ton of
571:42 - new RSS feeds and make sure that you
571:44 - deal with the issues as they come up
571:46 - make sure you improve the logging so you
571:48 - can see the issues when they come up
571:50 - anyways I hope you had a ton of fun with
571:52 - this project and that you learned
571:54 - something
571:55 - I just want to remind you that we do
571:57 - have an entire back-end learning path
571:59 - over on boot.dev in go lay so if you
572:02 - liked this project if you liked this
572:04 - course and are looking for some more
572:05 - content definitely go check out boot.dev
572:09 - we also published a lot of different
572:10 - ways that you could potentially extend
572:12 - this project to make it cooler for
572:15 - example maybe you add a front end or a
572:17 - command line application that interacts
572:19 - directly with the API so that you don't
572:20 - need to use a manual client like
572:22 - thunderclient every time that you want
572:24 - to interact with your posts and then I
572:27 - also just want to remind you before I go
572:29 - that you can find me on Twitter at
572:32 - wagslane or on YouTube at boot.dev
572:36 - definitely go subscribe to our YouTube
572:37 - channel as well thank you again to free
572:39 - codecamp for allowing us to publish this
572:42 - course and this project walkthrough I
572:44 - hope you enjoyed it and I'll see you in
572:46 - the next one